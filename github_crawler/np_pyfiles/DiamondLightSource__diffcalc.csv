file_path,api_count,code
diffcalc.py,0,"b""#!/usr/bin/env python\n\nimport sys\n\nfrom diffcmd.diffcalc_launcher import main\n\n\nif __name__ == '__main__':\n    sys.exit(main())"""
integration_checks.py,0,"b""'''\nCreated on 9 Mar 2017\n\n@author: zrb13439\n\n'''\n\n'''\nIntegration tests for startup scripts (named so that nosetests will *not* pick\nup by default.\n\nThis is because these must be run with:\n\n    $ nosetests --with-process-isolation integration_checks.py\n\nThis is not a standard nose option. Install it with:\n\n    $ pip install nosepipe\n\nnosepipe is described at https://github.com/dmccombs/nosepipe/\n'''\n\nfrom nose import SkipTest\n\n\ndef test_sixcircle_startup():\n    import startup.sixcircle\n    startup.sixcircle.ct.pause = False\n    startup.sixcircle.demo.all()\n\n\ndef test_fivecircle_startup():\n    import startup.fivecircle\n    startup.fivecircle.ct.pause = False\n    startup.fivecircle.demo.all()\n\n\ndef test_fourcircle_startup():\n    import startup.fourcircle\n    startup.fourcircle.ct.pause = False\n    startup.fourcircle.demo.all()\n\n\ndef test_i13_startup():\n    raise SkipTest('Still need to work out to use i13s very tight limits')\n    import startup.i13\n    startup.i13.ct.pause = False\n    startup.i13.demo.all()\n\n\ndef test_i16_startup():\n    import startup.i16\n    startup.i16.ct.pause = False\n    startup.i16.demo.all()\n\n\ndef test_i21_startup_standard():\n    import startup.i21\n    startup.i21.ct.pause = False\n    startup.i21.demo.all()\n\n\ndef test_i21_startup_bespoke():\n    import startup.i21\n    startup.i21.ct.pause = False\n    startup.i21.demo.i21()\n    \n    \ndef test_sixcirle_api():\n    import startup.api.sixcircle\n    startup.api.sixcircle.demo_all()\n\n"""
mock.py,0,"b'# mock.py\n# Test tools for mocking and patching.\n# Copyright (C) 2007-2012 Michael Foord & the mock team\n# E-mail: fuzzyman AT voidspace DOT org DOT uk\n\n# mock 0.8.0\n# http://www.voidspace.org.uk/python/mock/\n\n# Released subject to the BSD License\n# Please see http://www.voidspace.org.uk/python/license.shtml\n\n# Scripts maintained at http://www.voidspace.org.uk/python/index.shtml\n# Comments, suggestions and bug reports welcome.\n\n\n__all__ = (\n    \'Mock\',\n    \'MagicMock\',\n    \'mocksignature\',\n    \'patch\',\n    \'sentinel\',\n    \'DEFAULT\',\n    \'ANY\',\n    \'call\',\n    \'create_autospec\',\n    \'FILTER_DIR\',\n    \'NonCallableMock\',\n    \'NonCallableMagicMock\',\n)\n\n\n__version__ = \'0.8.0\'\n\n\nimport pprint\nimport sys\n\ntry:\n    import inspect\nexcept ImportError:\n    # for alternative platforms that\n    # may not have inspect\n    inspect = None\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    # Python 2.4 compatibility\n    def wraps(original):\n        def inner(f):\n            f.__name__ = original.__name__\n            f.__doc__ = original.__doc__\n            f.__module__ = original.__module__\n            return f\n        return inner\n\ntry:\n    unicode\nexcept NameError:\n    # Python 3\n    basestring = unicode = str\n\ntry:\n    long\nexcept NameError:\n    # Python 3\n    long = int\n\ntry:\n    BaseException\nexcept NameError:\n    # Python 2.4 compatibility\n    BaseException = Exception\n\ntry:\n    next\nexcept NameError:\n    def next(obj):\n        return obj.next()\n\n\nBaseExceptions = (BaseException,)\nif \'java\' in sys.platform:\n    # jython\n    import java\n    BaseExceptions = (BaseException, java.lang.Throwable)\n\ntry:\n    _isidentifier = str.isidentifier\nexcept AttributeError:\n    # Python 2.X\n    import keyword\n    import re\n    regex = re.compile(r\'^[a-z_][a-z0-9_]*$\', re.I)\n    def _isidentifier(string):\n        if string in keyword.kwlist:\n            return False\n        return regex.match(string)\n\n\ninPy3k = sys.version_info[0] == 3\n\n# Needed to work around Python 3 bug where use of ""super"" interferes with\n# defining __class__ as a descriptor\n_super = super\n\nself = \'im_self\'\nbuiltin = \'__builtin__\'\nif inPy3k:\n    self = \'__self__\'\n    builtin = \'builtins\'\n\nFILTER_DIR = True\n\n\ndef _is_instance_mock(obj):\n    # can\'t use isinstance on Mock objects because they override __class__\n    # The base class for all mocks is NonCallableMock\n    return issubclass(type(obj), NonCallableMock)\n\n\ndef _is_exception(obj):\n    return (\n        isinstance(obj, BaseExceptions) or\n        isinstance(obj, ClassTypes) and issubclass(obj, BaseExceptions)\n    )\n\n\nclass _slotted(object):\n    __slots__ = [\'a\']\n\n\nDescriptorTypes = (\n    type(_slotted.a),\n    property,\n)\n\n\n# getsignature and mocksignature heavily ""inspired"" by\n# the decorator module: http://pypi.python.org/pypi/decorator/\n# by Michele Simionato\n\ndef _getsignature(func, skipfirst):\n    if inspect is None:\n        raise ImportError(\'inspect module not available\')\n\n    if inspect.isclass(func):\n        func = func.__init__\n        # will have a self arg\n        skipfirst = True\n    elif not (inspect.ismethod(func) or inspect.isfunction(func)):\n        func = func.__call__\n\n    regargs, varargs, varkwargs, defaults = inspect.getargspec(func)\n\n    # instance methods need to lose the self argument\n    if getattr(func, self, None) is not None:\n        regargs = regargs[1:]\n\n    _msg = (""_mock_ is a reserved argument name, can\'t mock signatures using ""\n            ""_mock_"")\n    assert \'_mock_\' not in regargs, _msg\n    if varargs is not None:\n        assert \'_mock_\' not in varargs, _msg\n    if varkwargs is not None:\n        assert \'_mock_\' not in varkwargs, _msg\n    if skipfirst:\n        regargs = regargs[1:]\n\n    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,\n                                      formatvalue=lambda value: """")\n    return signature[1:-1], func\n\n\ndef _getsignature2(func, skipfirst, instance=False):\n    if inspect is None:\n        raise ImportError(\'inspect module not available\')\n\n    if isinstance(func, ClassTypes) and not instance:\n        try:\n            func = func.__init__\n        except AttributeError:\n            return\n        skipfirst = True\n    elif not isinstance(func, FunctionTypes):\n        # for classes where instance is True we end up here too\n        try:\n            func = func.__call__\n        except AttributeError:\n            return\n\n    try:\n        regargs, varargs, varkwargs, defaults = inspect.getargspec(func)\n    except TypeError:\n        # C function / method, possibly inherited object().__init__\n        return\n\n    # instance methods and classmethods need to lose the self argument\n    if getattr(func, self, None) is not None:\n        regargs = regargs[1:]\n    if skipfirst:\n        # this condition and the above one are never both True - why?\n        regargs = regargs[1:]\n\n    signature = inspect.formatargspec(regargs, varargs, varkwargs, defaults,\n                                      formatvalue=lambda value: """")\n    return signature[1:-1], func\n\n\ndef _check_signature(func, mock, skipfirst, instance=False):\n    if not _callable(func):\n        return\n\n    result = _getsignature2(func, skipfirst, instance)\n    if result is None:\n        return\n    signature, func = result\n\n    # can\'t use self because ""self"" is common as an argument name\n    # unfortunately even not in the first place\n    src = ""lambda _mock_self, %s: None"" % signature\n    checksig = eval(src, {})\n    _copy_func_details(func, checksig)\n    type(mock)._mock_check_sig = checksig\n\n\ndef _copy_func_details(func, funcopy):\n    funcopy.__name__ = func.__name__\n    funcopy.__doc__ = func.__doc__\n    #funcopy.__dict__.update(func.__dict__)\n    funcopy.__module__ = func.__module__\n    if not inPy3k:\n        funcopy.func_defaults = func.func_defaults\n        return\n    funcopy.__defaults__ = func.__defaults__\n    funcopy.__kwdefaults__ = func.__kwdefaults__\n\n\ndef _callable(obj):\n    if isinstance(obj, ClassTypes):\n        return True\n    if getattr(obj, \'__call__\', None) is not None:\n        return True\n    return False\n\n\ndef _is_list(obj):\n    # checks for list or tuples\n    # XXXX badly named!\n    return type(obj) in (list, tuple)\n\n\ndef _instance_callable(obj):\n    """"""Given an object, return True if the object is callable.\n    For classes, return True if instances would be callable.""""""\n    if not isinstance(obj, ClassTypes):\n        # already an instance\n        return getattr(obj, \'__call__\', None) is not None\n\n    klass = obj\n    # uses __bases__ instead of __mro__ so that we work with old style classes\n    if klass.__dict__.get(\'__call__\') is not None:\n        return True\n\n    for base in klass.__bases__:\n        if _instance_callable(base):\n            return True\n    return False\n\n\ndef _set_signature(mock, original, instance=False):\n    # creates a function with signature (*args, **kwargs) that delegates to a\n    # mock. It still does signature checking by calling a lambda with the same\n    # signature as the original. This is effectively mocksignature2.\n    if not _callable(original):\n        return\n\n    skipfirst = isinstance(original, ClassTypes)\n    result = _getsignature2(original, skipfirst, instance)\n    if result is None:\n        # was a C function (e.g. object().__init__ ) that can\'t be mocked\n        return\n\n    signature, func = result\n\n    src = ""lambda %s: None"" % signature\n    context = {\'_mock_\': mock}\n    checksig = eval(src, context)\n    _copy_func_details(func, checksig)\n\n    name = original.__name__\n    if not _isidentifier(name):\n        name = \'funcopy\'\n    context = {\'checksig\': checksig, \'mock\': mock}\n    src = """"""def %s(*args, **kwargs):\n    checksig(*args, **kwargs)\n    return mock(*args, **kwargs)"""""" % name\n    exec (src, context)\n    funcopy = context[name]\n    _setup_func(funcopy, mock)\n    return funcopy\n\n\ndef mocksignature(func, mock=None, skipfirst=False):\n    """"""\n    mocksignature(func, mock=None, skipfirst=False)\n\n    Create a new function with the same signature as `func` that delegates\n    to `mock`. If `skipfirst` is True the first argument is skipped, useful\n    for methods where `self` needs to be omitted from the new function.\n\n    If you don\'t pass in a `mock` then one will be created for you.\n\n    The mock is set as the `mock` attribute of the returned function for easy\n    access.\n\n    Functions returned by `mocksignature` have many of the same attributes\n    and assert methods as a mock object.\n\n    `mocksignature` can also be used with classes. It copies the signature of\n    the `__init__` method.\n\n    When used with callable objects (instances) it copies the signature of the\n    `__call__` method.\n    """"""\n    if mock is None:\n        mock = Mock()\n    signature, func = _getsignature(func, skipfirst)\n    src = ""lambda %(signature)s: _mock_(%(signature)s)"" % {\n        \'signature\': signature\n    }\n\n    funcopy = eval(src, dict(_mock_=mock))\n    _copy_func_details(func, funcopy)\n    _setup_func(funcopy, mock)\n    return funcopy\n\n\ndef _setup_func(funcopy, mock):\n    funcopy.mock = mock\n\n    # can\'t use isinstance with mocks\n    if not _is_instance_mock(mock):\n        return\n\n    def assert_called_with(*args, **kwargs):\n        return mock.assert_called_with(*args, **kwargs)\n    def assert_called_once_with(*args, **kwargs):\n        return mock.assert_called_once_with(*args, **kwargs)\n    def assert_has_calls(*args, **kwargs):\n        return mock.assert_has_calls(*args, **kwargs)\n    def assert_any_call(*args, **kwargs):\n        return mock.assert_any_call(*args, **kwargs)\n    def reset_mock():\n        funcopy.method_calls = _CallList()\n        funcopy.mock_calls = _CallList()\n        mock.reset_mock()\n        ret = funcopy.return_value\n        if _is_instance_mock(ret) and not ret is mock:\n            ret.reset_mock()\n\n    funcopy.called = False\n    funcopy.call_count = 0\n    funcopy.call_args = None\n    funcopy.call_args_list = _CallList()\n    funcopy.method_calls = _CallList()\n    funcopy.mock_calls = _CallList()\n\n    funcopy.return_value = mock.return_value\n    funcopy.side_effect = mock.side_effect\n    funcopy._mock_children = mock._mock_children\n\n    funcopy.assert_called_with = assert_called_with\n    funcopy.assert_called_once_with = assert_called_once_with\n    funcopy.assert_has_calls = assert_has_calls\n    funcopy.assert_any_call = assert_any_call\n    funcopy.reset_mock = reset_mock\n\n    mock._mock_signature = funcopy\n\n\ndef _is_magic(name):\n    return \'__%s__\' % name[2:-2] == name\n\n\nclass _SentinelObject(object):\n    ""A unique, named, sentinel object.""\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return \'sentinel.%s\' % self.name\n\n\nclass _Sentinel(object):\n    """"""Access attributes to return a named object, usable as a sentinel.""""""\n    def __init__(self):\n        self._sentinels = {}\n\n    def __getattr__(self, name):\n        if name == \'__bases__\':\n            # Without this help(mock) raises an exception\n            raise AttributeError\n        return self._sentinels.setdefault(name, _SentinelObject(name))\n\n\nsentinel = _Sentinel()\n\nDEFAULT = sentinel.DEFAULT\n\n\nclass OldStyleClass:\n    pass\nClassType = type(OldStyleClass)\n\n\ndef _copy(value):\n    if type(value) in (dict, list, tuple, set):\n        return type(value)(value)\n    return value\n\n\nClassTypes = (type,)\nif not inPy3k:\n    ClassTypes = (type, ClassType)\n\n_allowed_names = set(\n    [\n        \'return_value\', \'_mock_return_value\', \'side_effect\',\n        \'_mock_side_effect\', \'_mock_parent\', \'_mock_new_parent\',\n        \'_mock_name\', \'_mock_new_name\'\n    ]\n)\n\n\ndef _mock_signature_property(name):\n    _allowed_names.add(name)\n    _the_name = \'_mock_\' + name\n    def _get(self, name=name, _the_name=_the_name):\n        sig = self._mock_signature\n        if sig is None:\n            return getattr(self, _the_name)\n        return getattr(sig, name)\n    def _set(self, value, name=name, _the_name=_the_name):\n        sig = self._mock_signature\n        if sig is None:\n            self.__dict__[_the_name] = value\n        else:\n            setattr(sig, name, value)\n\n    return property(_get, _set)\n\n\n\nclass _CallList(list):\n\n    def __contains__(self, value):\n        if not isinstance(value, list):\n            return list.__contains__(self, value)\n        len_value = len(value)\n        len_self = len(self)\n        if len_value > len_self:\n            return False\n\n        for i in range(0, len_self - len_value + 1):\n            sub_list = self[i:i+len_value]\n            if sub_list == value:\n                return True\n        return False\n\n    def __repr__(self):\n        return pprint.pformat(list(self))\n\n\ndef _check_and_set_parent(parent, value, name, new_name):\n    if not _is_instance_mock(value):\n        return False\n    if ((value._mock_name or value._mock_new_name) or\n        (value._mock_parent is not None) or\n        (value._mock_new_parent is not None)):\n        return False\n\n    _parent = parent\n    while _parent is not None:\n        # setting a mock (value) as a child or return value of itself\n        # should not modify the mock\n        if _parent is value:\n            return False\n        _parent = _parent._mock_new_parent\n\n    if new_name:\n        value._mock_new_parent = parent\n        value._mock_new_name = new_name\n    if name:\n        value._mock_parent = parent\n        value._mock_name = name\n    return True\n\n\n\nclass Base(object):\n    _mock_return_value = DEFAULT\n    _mock_side_effect = None\n    def __init__(self, *args, **kwargs):\n        pass\n\n\n\nclass NonCallableMock(Base):\n    """"""A non-callable version of `Mock`""""""\n\n    def __new__(cls, *args, **kw):\n        # every instance has its own class\n        # so we can create magic methods on the\n        # class without stomping on other mocks\n        new = type(cls.__name__, (cls,), {\'__doc__\': cls.__doc__})\n        instance = object.__new__(new)\n        return instance\n\n\n    def __init__(\n            self, spec=None, wraps=None, name=None, spec_set=None,\n            parent=None, _spec_state=None, _new_name=\'\', _new_parent=None,\n            **kwargs\n        ):\n        if _new_parent is None:\n            _new_parent = parent\n\n        __dict__ = self.__dict__\n        __dict__[\'_mock_parent\'] = parent\n        __dict__[\'_mock_name\'] = name\n        __dict__[\'_mock_new_name\'] = _new_name\n        __dict__[\'_mock_new_parent\'] = _new_parent\n\n        if spec_set is not None:\n            spec = spec_set\n            spec_set = True\n\n        self._mock_add_spec(spec, spec_set)\n\n        __dict__[\'_mock_children\'] = {}\n        __dict__[\'_mock_wraps\'] = wraps\n        __dict__[\'_mock_signature\'] = None\n\n        __dict__[\'_mock_called\'] = False\n        __dict__[\'_mock_call_args\'] = None\n        __dict__[\'_mock_call_count\'] = 0\n        __dict__[\'_mock_call_args_list\'] = _CallList()\n        __dict__[\'_mock_mock_calls\'] = _CallList()\n\n        __dict__[\'method_calls\'] = _CallList()\n\n        if kwargs:\n            self.configure_mock(**kwargs)\n\n        _super(NonCallableMock, self).__init__(\n            spec, wraps, name, spec_set, parent,\n            _spec_state\n        )\n\n\n    def attach_mock(self, mock, attribute):\n        """"""\n        Attach a mock as an attribute of this one, replacing its name and\n        parent. Calls to the attached mock will be recorded in the\n        `method_calls` and `mock_calls` attributes of this one.""""""\n        mock._mock_parent = None\n        mock._mock_new_parent = None\n        mock._mock_name = \'\'\n        mock._mock_new_name = None\n\n        setattr(self, attribute, mock)\n\n\n    def mock_add_spec(self, spec, spec_set=False):\n        """"""Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.""""""\n        self._mock_add_spec(spec, spec_set)\n\n\n    def _mock_add_spec(self, spec, spec_set):\n        _spec_class = None\n\n        if spec is not None and not _is_list(spec):\n            if isinstance(spec, ClassTypes):\n                _spec_class = spec\n            else:\n                _spec_class = _get_class(spec)\n\n            spec = dir(spec)\n\n        __dict__ = self.__dict__\n        __dict__[\'_spec_class\'] = _spec_class\n        __dict__[\'_spec_set\'] = spec_set\n        __dict__[\'_mock_methods\'] = spec\n\n\n    def __get_return_value(self):\n        ret = self._mock_return_value\n        if self._mock_signature is not None:\n            ret = self._mock_signature.return_value\n\n        if ret is DEFAULT:\n            ret = self._get_child_mock(\n                _new_parent=self, _new_name=\'()\'\n            )\n            self.return_value = ret\n        return ret\n\n\n    def __set_return_value(self, value):\n        if self._mock_signature is not None:\n            self._mock_signature.return_value = value\n        else:\n            self._mock_return_value = value\n            _check_and_set_parent(self, value, None, \'()\')\n\n    __return_value_doc = ""The value to be returned when the mock is called.""\n    return_value = property(__get_return_value, __set_return_value,\n                            __return_value_doc)\n\n\n    @property\n    def __class__(self):\n        if self._spec_class is None:\n            return type(self)\n        return self._spec_class\n\n    called = _mock_signature_property(\'called\')\n    call_count = _mock_signature_property(\'call_count\')\n    call_args = _mock_signature_property(\'call_args\')\n    call_args_list = _mock_signature_property(\'call_args_list\')\n    mock_calls = _mock_signature_property(\'mock_calls\')\n\n\n    def __get_side_effect(self):\n        sig = self._mock_signature\n        if sig is None:\n            return self._mock_side_effect\n        return sig.side_effect\n\n    def __set_side_effect(self, value):\n        value = _try_iter(value)\n        sig = self._mock_signature\n        if sig is None:\n            self._mock_side_effect = value\n        else:\n            sig.side_effect = value\n\n    side_effect = property(__get_side_effect, __set_side_effect)\n\n\n    def reset_mock(self):\n        ""Restore the mock object to its initial state.""\n        self.called = False\n        self.call_args = None\n        self.call_count = 0\n        self.mock_calls = _CallList()\n        self.call_args_list = _CallList()\n        self.method_calls = _CallList()\n\n        for child in self._mock_children.values():\n            child.reset_mock()\n\n        ret = self._mock_return_value\n        if _is_instance_mock(ret) and ret is not self:\n            ret.reset_mock()\n\n\n    def configure_mock(self, **kwargs):\n        """"""Set attributes on the mock through keyword arguments.\n\n        Attributes plus return values and side effects can be set on child\n        mocks using standard dot notation and unpacking a dictionary in the\n        method call:\n\n        >>> attrs = {\'method.return_value\': 3, \'other.side_effect\': KeyError}\n        >>> mock.configure_mock(**attrs)""""""\n        for arg, val in sorted(kwargs.items(),\n                               # we sort on the number of dots so that\n                               # attributes are set before we set attributes on\n                               # attributes\n                               key=lambda entry: entry[0].count(\'.\')):\n            args = arg.split(\'.\')\n            final = args.pop()\n            obj = self\n            for entry in args:\n                obj = getattr(obj, entry)\n            setattr(obj, final, val)\n\n\n    def __getattr__(self, name):\n        if name == \'_mock_methods\':\n            raise AttributeError(name)\n        elif self._mock_methods is not None:\n            if name not in self._mock_methods or name in _all_magics:\n                raise AttributeError(""Mock object has no attribute %r"" % name)\n        elif _is_magic(name):\n            raise AttributeError(name)\n\n        result = self._mock_children.get(name)\n        if result is None:\n            wraps = None\n            if self._mock_wraps is not None:\n                # XXXX should we get the attribute without triggering code\n                # execution?\n                wraps = getattr(self._mock_wraps, name)\n\n            result = self._get_child_mock(\n                parent=self, name=name, wraps=wraps, _new_name=name,\n                _new_parent=self\n            )\n            self._mock_children[name]  = result\n\n        elif isinstance(result, _SpecState):\n            result = create_autospec(\n                result.spec, result.spec_set, result.instance,\n                result.parent, result.name\n            )\n            self._mock_children[name]  = result\n\n        return result\n\n\n    def __repr__(self):\n        _name_list = [self._mock_new_name]\n        _parent = self._mock_new_parent\n        last = self\n\n        dot = \'.\'\n        if _name_list == [\'()\']:\n            dot = \'\'\n        seen = set()\n        while _parent is not None:\n            last = _parent\n\n            _name_list.append(_parent._mock_new_name + dot)\n            dot = \'.\'\n            if _parent._mock_new_name == \'()\':\n                dot = \'\'\n\n            _parent = _parent._mock_new_parent\n\n            # use ids here so as not to call __hash__ on the mocks\n            if id(_parent) in seen:\n                break\n            seen.add(id(_parent))\n\n        _name_list = list(reversed(_name_list))\n        _first = last._mock_name or \'mock\'\n        if len(_name_list) > 1:\n            if _name_list[1] not in (\'()\', \'().\'):\n                _first += \'.\'\n        _name_list[0] = _first\n        name = \'\'.join(_name_list)\n\n        name_string = \'\'\n        if name not in (\'mock\', \'mock.\'):\n            name_string = \' name=%r\' % name\n\n        spec_string = \'\'\n        if self._spec_class is not None:\n            spec_string = \' spec=%r\'\n            if self._spec_set:\n                spec_string = \' spec_set=%r\'\n            spec_string = spec_string % self._spec_class.__name__\n        return ""<%s%s%s id=\'%s\'>"" % (\n            type(self).__name__,\n            name_string,\n            spec_string,\n            id(self)\n        )\n\n\n    def __dir__(self):\n        """"""Filter the output of `dir(mock)` to only useful members.\n        XXXX\n        """"""\n        extras = self._mock_methods or []\n        from_type = dir(type(self))\n        from_dict = list(self.__dict__)\n\n        if FILTER_DIR:\n            from_type = [e for e in from_type if not e.startswith(\'_\')]\n            from_dict = [e for e in from_dict if not e.startswith(\'_\') or\n                         _is_magic(e)]\n        return sorted(set(extras + from_type + from_dict +\n                          list(self._mock_children)))\n\n\n    def __setattr__(self, name, value):\n        if name in _allowed_names:\n            # property setters go through here\n            return object.__setattr__(self, name, value)\n        elif (self._spec_set and self._mock_methods is not None and\n            name not in self._mock_methods and\n            name not in self.__dict__):\n            raise AttributeError(""Mock object has no attribute \'%s\'"" % name)\n        elif name in _unsupported_magics:\n            msg = \'Attempting to set unsupported magic method %r.\' % name\n            raise AttributeError(msg)\n        elif name in _all_magics:\n            if self._mock_methods is not None and name not in self._mock_methods:\n                raise AttributeError(""Mock object has no attribute \'%s\'"" % name)\n\n            if not _is_instance_mock(value):\n                setattr(type(self), name, _get_method(name, value))\n                original = value\n                real = lambda *args, **kw: original(self, *args, **kw)\n                value = mocksignature(value, real, skipfirst=True)\n            else:\n                # only set _new_name and not name so that mock_calls is tracked\n                # but not method calls\n                _check_and_set_parent(self, value, None, name)\n                setattr(type(self), name, value)\n        else:\n            if _check_and_set_parent(self, value, name, name):\n                self._mock_children[name] = value\n        return object.__setattr__(self, name, value)\n\n\n    def __delattr__(self, name):\n        if name in _all_magics and name in type(self).__dict__:\n            delattr(type(self), name)\n            if name not in self.__dict__:\n                # for magic methods that are still MagicProxy objects and\n                # not set on the instance itself\n                return\n\n        return object.__delattr__(self, name)\n\n\n    def _format_mock_call_signature(self, args, kwargs):\n        name = self._mock_name or \'mock\'\n        return _format_call_signature(name, args, kwargs)\n\n\n    def _format_mock_failure_message(self, args, kwargs):\n        message = \'Expected call: %s\\nActual call: %s\'\n        expected_string = self._format_mock_call_signature(args, kwargs)\n        call_args = self.call_args\n        if len(call_args) == 3:\n            call_args = call_args[1:]\n        actual_string = self._format_mock_call_signature(*call_args)\n        return message % (expected_string, actual_string)\n\n\n    def assert_called_with(_mock_self, *args, **kwargs):\n        """"""assert that the mock was called with the specified arguments.\n\n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.""""""\n        self = _mock_self\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\'Expected call: %s\\nNot called\' % (expected,))\n\n        if self.call_args != (args, kwargs):\n            msg = self._format_mock_failure_message(args, kwargs)\n            raise AssertionError(msg)\n\n\n    def assert_called_once_with(_mock_self, *args, **kwargs):\n        """"""assert that the mock was called exactly once and with the specified\n        arguments.""""""\n        self = _mock_self\n        if not self.call_count == 1:\n            msg = (""Expected to be called once. Called %s times."" %\n                   self.call_count)\n            raise AssertionError(msg)\n        return self.assert_called_with(*args, **kwargs)\n\n\n    def assert_has_calls(self, calls, any_order=False):\n        """"""assert the mock has been called with the specified calls.\n        The `mock_calls` list is checked for the calls.\n\n        If `any_order` is False (the default) then the calls must be\n        sequential. There can be extra calls before or after the\n        specified calls.\n\n        If `any_order` is True then the calls can be in any order, but\n        they must all appear in `mock_calls`.""""""\n        if not any_order:\n            if calls not in self.mock_calls:\n                raise AssertionError(\n                    \'Calls not found.\\nExpected: %r\\n\'\n                    \'Actual: %r\' % (calls, self.mock_calls)\n                )\n            return\n\n        all_calls = list(self.mock_calls)\n\n        not_found = []\n        for kall in calls:\n            try:\n                all_calls.remove(kall)\n            except ValueError:\n                not_found.append(kall)\n        if not_found:\n            raise AssertionError(\n                \'%r not all found in call list\' % (tuple(not_found),)\n            )\n\n\n    def assert_any_call(self, *args, **kwargs):\n        """"""assert the mock has been called with the specified arguments.\n\n        The assert passes if the mock has *ever* been called, unlike\n        `assert_called_with` and `assert_called_once_with` that only pass if\n        the call is the most recent one.""""""\n        kall = call(*args, **kwargs)\n        if kall not in self.call_args_list:\n            expected_string = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\n                \'%s call not found\' % expected_string\n            )\n\n\n    def _get_child_mock(self, **kw):\n        """"""Create the child mocks for attributes and return value.\n        By default child mocks will be the same type as the parent.\n        Subclasses of Mock may want to override this to customize the way\n        child mocks are made.\n\n        For non-callable mocks the callable variant will be used (rather than\n        any custom subclass).""""""\n        _type = type(self)\n        if not issubclass(_type, CallableMixin):\n            if issubclass(_type, NonCallableMagicMock):\n                klass = MagicMock\n            elif issubclass(_type, NonCallableMock) :\n                klass = Mock\n        else:\n            klass = _type.__mro__[1]\n        return klass(**kw)\n\n\n\ndef _try_iter(obj):\n    if obj is None:\n        return obj\n    if _is_exception(obj):\n        return obj\n    if _callable(obj):\n        return obj\n    try:\n        return iter(obj)\n    except TypeError:\n        # XXXX backwards compatibility\n        # but this will blow up on first call - so maybe we should fail early?\n        return obj\n\n\n\nclass CallableMixin(Base):\n\n    def __init__(self, spec=None, side_effect=None, return_value=DEFAULT,\n                 wraps=None, name=None, spec_set=None, parent=None,\n                 _spec_state=None, _new_name=\'\', _new_parent=None, **kwargs):\n        self.__dict__[\'_mock_return_value\'] = return_value\n\n        _super(CallableMixin, self).__init__(\n            spec, wraps, name, spec_set, parent,\n            _spec_state, _new_name, _new_parent, **kwargs\n        )\n\n        self.side_effect = side_effect\n\n\n    def _mock_check_sig(self, *args, **kwargs):\n        # stub method that can be replaced with one with a specific signature\n        pass\n\n\n    def __call__(_mock_self, *args, **kwargs):\n        # can\'t use self in-case a function / method we are mocking uses self\n        # in the signature\n        _mock_self._mock_check_sig(*args, **kwargs)\n        return _mock_self._mock_call(*args, **kwargs)\n\n\n    def _mock_call(_mock_self, *args, **kwargs):\n        self = _mock_self\n        self.called = True\n        self.call_count += 1\n        self.call_args = _Call((args, kwargs), two=True)\n        self.call_args_list.append(_Call((args, kwargs), two=True))\n\n        _new_name = self._mock_new_name\n        _new_parent = self._mock_new_parent\n        self.mock_calls.append(_Call((\'\', args, kwargs)))\n\n        seen = set()\n        skip_next_dot = _new_name == \'()\'\n        do_method_calls = self._mock_parent is not None\n        name = self._mock_name\n        while _new_parent is not None:\n            this_mock_call = _Call((_new_name, args, kwargs))\n            if _new_parent._mock_new_name:\n                dot = \'.\'\n                if skip_next_dot:\n                    dot = \'\'\n\n                skip_next_dot = False\n                if _new_parent._mock_new_name == \'()\':\n                    skip_next_dot = True\n\n                _new_name = _new_parent._mock_new_name + dot + _new_name\n\n            if do_method_calls:\n                if _new_name == name:\n                    this_method_call = this_mock_call\n                else:\n                    this_method_call = _Call((name, args, kwargs))\n                _new_parent.method_calls.append(this_method_call)\n\n                do_method_calls = _new_parent._mock_parent is not None\n                if do_method_calls:\n                    name = _new_parent._mock_name + \'.\' + name\n\n            _new_parent.mock_calls.append(this_mock_call)\n            _new_parent = _new_parent._mock_new_parent\n\n            # use ids here so as not to call __hash__ on the mocks\n            _new_parent_id = id(_new_parent)\n            if _new_parent_id in seen:\n                break\n            seen.add(_new_parent_id)\n\n        ret_val = DEFAULT\n        effect = self.side_effect\n        if effect is not None:\n            if _is_exception(effect):\n                raise effect\n\n            if not _callable(effect):\n                return next(effect)\n\n            ret_val = effect(*args, **kwargs)\n            if ret_val is DEFAULT:\n                ret_val = self.return_value\n\n        if (self._mock_wraps is not None and\n             self._mock_return_value is DEFAULT):\n            return self._mock_wraps(*args, **kwargs)\n        if ret_val is DEFAULT:\n            ret_val = self.return_value\n        return ret_val\n\n\n\nclass Mock(CallableMixin, NonCallableMock):\n    """"""\n    Create a new `Mock` object. `Mock` takes several optional arguments\n    that specify the behaviour of the Mock object:\n\n    * `spec`: This can be either a list of strings or an existing object (a\n      class or instance) that acts as the specification for the mock object. If\n      you pass in an object then a list of strings is formed by calling dir on\n      the object (excluding unsupported magic attributes and methods). Accessing\n      any attribute not in this list will raise an `AttributeError`.\n\n      If `spec` is an object (rather than a list of strings) then\n      `mock.__class__` returns the class of the spec object. This allows mocks\n      to pass `isinstance` tests.\n\n    * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*\n      or get an attribute on the mock that isn\'t on the object passed as\n      `spec_set` will raise an `AttributeError`.\n\n    * `side_effect`: A function to be called whenever the Mock is called. See\n      the `side_effect` attribute. Useful for raising exceptions or\n      dynamically changing return values. The function is called with the same\n      arguments as the mock, and unless it returns `DEFAULT`, the return\n      value of this function is used as the return value.\n\n      Alternatively `side_effect` can be an exception class or instance. In\n      this case the exception will be raised when the mock is called.\n\n      If `side_effect` is an iterable then each call to the mock will return\n      the next value from the iterable.\n\n    * `return_value`: The value returned when the mock is called. By default\n      this is a new Mock (created on first access). See the\n      `return_value` attribute.\n\n    * `wraps`: Item for the mock object to wrap. If `wraps` is not None\n      then calling the Mock will pass the call through to the wrapped object\n      (returning the real result and ignoring `return_value`). Attribute\n      access on the mock will return a Mock object that wraps the corresponding\n      attribute of the wrapped object (so attempting to access an attribute that\n      doesn\'t exist will raise an `AttributeError`).\n\n      If the mock has an explicit `return_value` set then calls are not passed\n      to the wrapped object and the `return_value` is returned instead.\n\n    * `name`: If the mock has a name then it will be used in the repr of the\n      mock. This can be useful for debugging. The name is propagated to child\n      mocks.\n\n    Mocks can also be called with arbitrary keyword arguments. These will be\n    used to set attributes on the mock after it is created.\n    """"""\n\n\n\ndef _dot_lookup(thing, comp, import_path):\n    try:\n        return getattr(thing, comp)\n    except AttributeError:\n        __import__(import_path)\n        return getattr(thing, comp)\n\n\ndef _importer(target):\n    components = target.split(\'.\')\n    import_path = components.pop(0)\n    thing = __import__(import_path)\n\n    for comp in components:\n        import_path += "".%s"" % comp\n        thing = _dot_lookup(thing, comp, import_path)\n    return thing\n\n\ndef _is_started(patcher):\n    # XXXX horrible\n    return hasattr(patcher, \'is_local\')\n\n\nclass _patch(object):\n\n    attribute_name = None\n\n    def __init__(\n            self, getter, attribute, new, spec, create,\n            mocksignature, spec_set, autospec, new_callable, kwargs\n        ):\n        if new_callable is not None:\n            if new is not DEFAULT:\n                raise ValueError(\n                    ""Cannot use \'new\' and \'new_callable\' together""\n                )\n            if autospec is not False:\n                raise ValueError(\n                    ""Cannot use \'autospec\' and \'new_callable\' together""\n                )\n\n        self.getter = getter\n        self.attribute = attribute\n        self.new = new\n        self.new_callable = new_callable\n        self.spec = spec\n        self.create = create\n        self.has_local = False\n        self.mocksignature = mocksignature\n        self.spec_set = spec_set\n        self.autospec = autospec\n        self.kwargs = kwargs\n        self.additional_patchers = []\n\n\n    def copy(self):\n        patcher = _patch(\n            self.getter, self.attribute, self.new, self.spec,\n            self.create, self.mocksignature, self.spec_set,\n            self.autospec, self.new_callable, self.kwargs\n        )\n        patcher.attribute_name = self.attribute_name\n        patcher.additional_patchers = [\n            p.copy() for p in self.additional_patchers\n        ]\n        return patcher\n\n\n    def __call__(self, func):\n        if isinstance(func, ClassTypes):\n            return self.decorate_class(func)\n        return self.decorate_callable(func)\n\n\n    def decorate_class(self, klass):\n        for attr in dir(klass):\n            if not attr.startswith(patch.TEST_PREFIX):\n                continue\n\n            attr_value = getattr(klass, attr)\n            if not hasattr(attr_value, ""__call__""):\n                continue\n\n            patcher = self.copy()\n            setattr(klass, attr, patcher(attr_value))\n        return klass\n\n\n    def decorate_callable(self, func):\n        if hasattr(func, \'patchings\'):\n            func.patchings.append(self)\n            return func\n\n        @wraps(func)\n        def patched(*args, **keywargs):\n            # don\'t use a with here (backwards compatability with Python 2.4)\n            extra_args = []\n            entered_patchers = []\n\n            # can\'t use try...except...finally because of Python 2.4\n            # compatibility\n            try:\n                try:\n                    for patching in patched.patchings:\n                        arg = patching.__enter__()\n                        entered_patchers.append(patching)\n                        if patching.attribute_name is not None:\n                            keywargs.update(arg)\n                        elif patching.new is DEFAULT:\n                            extra_args.append(arg)\n\n                    args += tuple(extra_args)\n                    return func(*args, **keywargs)\n                except:\n                    if (patching not in entered_patchers and\n                        _is_started(patching)):\n                        # the patcher may have been started, but an exception\n                        # raised whilst entering one of its additional_patchers\n                        entered_patchers.append(patching)\n                    # re-raise the exception\n                    raise\n            finally:\n                for patching in reversed(entered_patchers):\n                    patching.__exit__()\n\n        patched.patchings = [self]\n        if hasattr(func, \'func_code\'):\n            # not in Python 3\n            patched.compat_co_firstlineno = getattr(\n                func, ""compat_co_firstlineno"",\n                func.func_code.co_firstlineno\n            )\n        return patched\n\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n\n        original = DEFAULT\n        local = False\n\n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n\n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n                ""%s does not have the attribute %r"" % (target, name)\n            )\n        return original, local\n\n\n    def __enter__(self):\n        """"""Perform the patch.""""""\n        new, spec, spec_set = self.new, self.spec, self.spec_set\n        autospec, kwargs = self.autospec, self.kwargs\n        new_callable = self.new_callable\n        self.target = self.getter()\n\n        original, local = self.get_original()\n\n        if new is DEFAULT and autospec is False:\n            inherit = False\n            if spec_set == True:\n                spec_set = original\n            elif spec == True:\n                # set spec to the object we are replacing\n                spec = original\n\n            if (spec or spec_set) is not None:\n                if isinstance(original, ClassTypes):\n                    # If we\'re patching out a class and there is a spec\n                    inherit = True\n\n            Klass = MagicMock\n            _kwargs = {}\n            if new_callable is not None:\n                Klass = new_callable\n            elif (spec or spec_set) is not None:\n                if not _callable(spec or spec_set):\n                    Klass = NonCallableMagicMock\n\n            if spec is not None:\n                _kwargs[\'spec\'] = spec\n            if spec_set is not None:\n                _kwargs[\'spec_set\'] = spec_set\n\n            # add a name to mocks\n            if (isinstance(Klass, type) and\n                issubclass(Klass, NonCallableMock) and self.attribute):\n                _kwargs[\'name\'] = self.attribute\n\n            _kwargs.update(kwargs)\n            new = Klass(**_kwargs)\n\n            if inherit and _is_instance_mock(new):\n                # we can only tell if the instance should be callable if the\n                # spec is not a list\n                if (not _is_list(spec or spec_set) and not\n                    _instance_callable(spec or spec_set)):\n                    Klass = NonCallableMagicMock\n\n                _kwargs.pop(\'name\')\n                new.return_value = Klass(_new_parent=new, _new_name=\'()\',\n                                         **_kwargs)\n        elif autospec is not False:\n            # spec is ignored, new *must* be default, spec_set is treated\n            # as a boolean. Should we check spec is not None and that spec_set\n            # is a bool? mocksignature should also not be used. Should we\n            # check this?\n            if new is not DEFAULT:\n                raise TypeError(\n                    ""autospec creates the mock for you. Can\'t specify ""\n                    ""autospec and new.""\n                )\n            spec_set = bool(spec_set)\n            if autospec is True:\n                autospec = original\n\n            new = create_autospec(autospec, spec_set=spec_set,\n                                  _name=self.attribute, **kwargs)\n        elif kwargs:\n            # can\'t set keyword args when we aren\'t creating the mock\n            # XXXX If new is a Mock we could call new.configure_mock(**kwargs)\n            raise TypeError(""Can\'t pass kwargs to a mock we aren\'t creating"")\n\n        new_attr = new\n        if self.mocksignature:\n            new_attr = mocksignature(original, new)\n\n        self.temp_original = original\n        self.is_local = local\n        setattr(self.target, self.attribute, new_attr)\n        if self.attribute_name is not None:\n            extra_args = {}\n            if self.new is DEFAULT:\n                extra_args[self.attribute_name] =  new\n            for patching in self.additional_patchers:\n                arg = patching.__enter__()\n                if patching.new is DEFAULT:\n                    extra_args.update(arg)\n            return extra_args\n\n        return new\n\n\n    def __exit__(self, *_):\n        """"""Undo the patch.""""""\n        if not _is_started(self):\n            raise RuntimeError(\'stop called on unstarted patcher\')\n\n        if self.is_local and self.temp_original is not DEFAULT:\n            setattr(self.target, self.attribute, self.temp_original)\n        else:\n            delattr(self.target, self.attribute)\n            if not self.create and not hasattr(self.target, self.attribute):\n                # needed for proxy objects like django settings\n                setattr(self.target, self.attribute, self.temp_original)\n\n        del self.temp_original\n        del self.is_local\n        del self.target\n        for patcher in reversed(self.additional_patchers):\n            if _is_started(patcher):\n                patcher.__exit__()\n\n    start = __enter__\n    stop = __exit__\n\n\n\ndef _get_target(target):\n    try:\n        target, attribute = target.rsplit(\'.\', 1)\n    except (TypeError, ValueError):\n        raise TypeError(""Need a valid target to patch. You supplied: %r"" %\n                        (target,))\n    getter = lambda: _importer(target)\n    return getter, attribute\n\n\ndef _patch_object(\n        target, attribute, new=DEFAULT, spec=None,\n        create=False, mocksignature=False, spec_set=None, autospec=False,\n        new_callable=None, **kwargs\n    ):\n    """"""\n    patch.object(target, attribute, new=DEFAULT, spec=None, create=False,\n                 mocksignature=False, spec_set=None, autospec=False,\n                 new_callable=None, **kwargs)\n\n    patch the named member (`attribute`) on an object (`target`) with a mock\n    object.\n\n    `patch.object` can be used as a decorator, class decorator or a context\n    manager. Arguments `new`, `spec`, `create`, `mocksignature`, `spec_set`,\n    `autospec` and `new_callable` have the same meaning as for `patch`. Like\n    `patch`, `patch.object` takes arbitrary keyword arguments for configuring\n    the mock object it creates.\n\n    When used as a class decorator `patch.object` honours `patch.TEST_PREFIX`\n    for choosing which methods to wrap.\n    """"""\n    getter = lambda: target\n    return _patch(\n        getter, attribute, new, spec, create, mocksignature,\n        spec_set, autospec, new_callable, kwargs\n    )\n\n\ndef _patch_multiple(target, spec=None, create=False,\n        mocksignature=False, spec_set=None, autospec=False,\n        new_callable=None, **kwargs\n    ):\n    """"""Perform multiple patches in a single call. It takes the object to be\n    patched (either as an object or a string to fetch the object by importing)\n    and keyword arguments for the patches::\n\n        with patch.multiple(settings, FIRST_PATCH=\'one\', SECOND_PATCH=\'two\'):\n            ...\n\n    Use `DEFAULT` as the value if you want `patch.multiple` to create\n    mocks for you. In this case the created mocks are passed into a decorated\n    function by keyword, and a dictionary is returned when `patch.multiple` is\n    used as a context manager.\n\n    `patch.multiple` can be used as a decorator, class decorator or a context\n    manager. The arguments `spec`, `spec_set`, `create`, `mocksignature`,\n    `autospec` and `new_callable` have the same meaning as for `patch`. These\n    arguments will be applied to *all* patches done by `patch.multiple`.\n\n    When used as a class decorator `patch.multiple` honours `patch.TEST_PREFIX`\n    for choosing which methods to wrap.\n    """"""\n    if type(target) in (unicode, str):\n        getter = lambda: _importer(target)\n    else:\n        getter = lambda: target\n\n    if not kwargs:\n        raise ValueError(\n            \'Must supply at least one keyword argument with patch.multiple\'\n        )\n    # need to wrap in a list for python 3, where items is a view\n    items = list(kwargs.items())\n    attribute, new = items[0]\n    patcher = _patch(\n        getter, attribute, new, spec, create, mocksignature, spec_set,\n        autospec, new_callable, {}\n    )\n    patcher.attribute_name = attribute\n    for attribute, new in items[1:]:\n        this_patcher = _patch(\n            getter, attribute, new, spec, create, mocksignature, spec_set,\n            autospec, new_callable, {}\n        )\n        this_patcher.attribute_name = attribute\n        patcher.additional_patchers.append(this_patcher)\n    return patcher\n\n\ndef patch(\n        target, new=DEFAULT, spec=None, create=False,\n        mocksignature=False, spec_set=None, autospec=False,\n        new_callable=None, **kwargs\n    ):\n    """"""\n    `patch` acts as a function decorator, class decorator or a context\n    manager. Inside the body of the function or with statement, the `target`\n    (specified in the form `\'package.module.ClassName\'`) is patched\n    with a `new` object. When the function/with statement exits the patch is\n    undone.\n\n    The `target` is imported and the specified attribute patched with the new\n    object, so it must be importable from the environment you are calling the\n    decorator from. The target is imported when the decorated function is\n    executed, not at decoration time.\n\n    If `new` is omitted, then a new `MagicMock` is created and passed in as an\n    extra argument to the decorated function.\n\n    The `spec` and `spec_set` keyword arguments are passed to the `MagicMock`\n    if patch is creating one for you.\n\n    In addition you can pass `spec=True` or `spec_set=True`, which causes\n    patch to pass in the object being mocked as the spec/spec_set object.\n\n    `new_callable` allows you to specify a different class, or callable object,\n    that will be called to create the `new` object. By default `MagicMock` is\n    used.\n\n    A more powerful form of `spec` is `autospec`. If you set `autospec=True`\n    then the mock with be created with a spec from the object being replaced.\n    All attributes of the mock will also have the spec of the corresponding\n    attribute of the object being replaced. Methods and functions being mocked\n    will have their arguments checked and will raise a `TypeError` if they are\n    called with the wrong signature (similar to `mocksignature`). For mocks\n    replacing a class, their return value (the \'instance\') will have the same\n    spec as the class.\n\n    Instead of `autospec=True` you can pass `autospec=some_object` to use an\n    arbitrary object as the spec instead of the one being replaced.\n\n    If `mocksignature` is True then the patch will be done with a function\n    created by mocking the one being replaced. If the object being replaced is\n    a class then the signature of `__init__` will be copied. If the object\n    being replaced is a callable object then the signature of `__call__` will\n    be copied.\n\n    By default `patch` will fail to replace attributes that don\'t exist. If\n    you pass in `create=True`, and the attribute doesn\'t exist, patch will\n    create the attribute for you when the patched function is called, and\n    delete it again afterwards. This is useful for writing tests against\n    attributes that your production code creates at runtime. It is off by by\n    default because it can be dangerous. With it switched on you can write\n    passing tests against APIs that don\'t actually exist!\n\n    Patch can be used as a `TestCase` class decorator. It works by\n    decorating each test method in the class. This reduces the boilerplate\n    code when your test methods share a common patchings set. `patch` finds\n    tests by looking for method names that start with `patch.TEST_PREFIX`.\n    By default this is `test`, which matches the way `unittest` finds tests.\n    You can specify an alternative prefix by setting `patch.TEST_PREFIX`.\n\n    Patch can be used as a context manager, with the with statement. Here the\n    patching applies to the indented block after the with statement. If you\n    use ""as"" then the patched object will be bound to the name after the\n    ""as""; very useful if `patch` is creating a mock object for you.\n\n    `patch` takes arbitrary keyword arguments. These will be passed to\n    the `Mock` (or `new_callable`) on construction.\n\n    `patch.dict(...)`, `patch.multiple(...)` and `patch.object(...)` are\n    available for alternate use-cases.\n    """"""\n    getter, attribute = _get_target(target)\n    return _patch(\n        getter, attribute, new, spec, create, mocksignature,\n        spec_set, autospec, new_callable, kwargs\n    )\n\n\nclass _patch_dict(object):\n    """"""\n    Patch a dictionary, or dictionary like object, and restore the dictionary\n    to its original state after the test.\n\n    `in_dict` can be a dictionary or a mapping like container. If it is a\n    mapping then it must at least support getting, setting and deleting items\n    plus iterating over keys.\n\n    `in_dict` can also be a string specifying the name of the dictionary, which\n    will then be fetched by importing it.\n\n    `values` can be a dictionary of values to set in the dictionary. `values`\n    can also be an iterable of `(key, value)` pairs.\n\n    If `clear` is True then the dictionary will be cleared before the new\n    values are set.\n\n    `patch.dict` can also be called with arbitrary keyword arguments to set\n    values in the dictionary::\n\n        with patch.dict(\'sys.modules\', mymodule=Mock(), other_module=Mock()):\n            ...\n\n    `patch.dict` can be used as a context manager, decorator or class\n    decorator. When used as a class decorator `patch.dict` honours\n    `patch.TEST_PREFIX` for choosing which methods to wrap.\n    """"""\n\n    def __init__(self, in_dict, values=(), clear=False, **kwargs):\n        if isinstance(in_dict, basestring):\n            in_dict = _importer(in_dict)\n        self.in_dict = in_dict\n        # support any argument supported by dict(...) constructor\n        self.values = dict(values)\n        self.values.update(kwargs)\n        self.clear = clear\n        self._original = None\n\n\n    def __call__(self, f):\n        if isinstance(f, ClassTypes):\n            return self.decorate_class(f)\n        @wraps(f)\n        def _inner(*args, **kw):\n            self._patch_dict()\n            try:\n                return f(*args, **kw)\n            finally:\n                self._unpatch_dict()\n\n        return _inner\n\n\n    def decorate_class(self, klass):\n        for attr in dir(klass):\n            attr_value = getattr(klass, attr)\n            if (attr.startswith(patch.TEST_PREFIX) and\n                 hasattr(attr_value, ""__call__"")):\n                decorator = _patch_dict(self.in_dict, self.values, self.clear)\n                decorated = decorator(attr_value)\n                setattr(klass, attr, decorated)\n        return klass\n\n\n    def __enter__(self):\n        """"""Patch the dict.""""""\n        self._patch_dict()\n\n\n    def _patch_dict(self):\n        values = self.values\n        in_dict = self.in_dict\n        clear = self.clear\n\n        try:\n            original = in_dict.copy()\n        except AttributeError:\n            # dict like object with no copy method\n            # must support iteration over keys\n            original = {}\n            for key in in_dict:\n                original[key] = in_dict[key]\n        self._original = original\n\n        if clear:\n            _clear_dict(in_dict)\n\n        try:\n            in_dict.update(values)\n        except AttributeError:\n            # dict like object with no update method\n            for key in values:\n                in_dict[key] = values[key]\n\n\n    def _unpatch_dict(self):\n        in_dict = self.in_dict\n        original = self._original\n\n        _clear_dict(in_dict)\n\n        try:\n            in_dict.update(original)\n        except AttributeError:\n            for key in original:\n                in_dict[key] = original[key]\n\n\n    def __exit__(self, *args):\n        """"""Unpatch the dict.""""""\n        self._unpatch_dict()\n        return False\n\n    start = __enter__\n    stop = __exit__\n\n\ndef _clear_dict(in_dict):\n    try:\n        in_dict.clear()\n    except AttributeError:\n        keys = list(in_dict)\n        for key in keys:\n            del in_dict[key]\n\n\npatch.object = _patch_object\npatch.dict = _patch_dict\npatch.multiple = _patch_multiple\npatch.TEST_PREFIX = \'test\'\n\nmagic_methods = (\n    ""lt le gt ge eq ne ""\n    ""getitem setitem delitem ""\n    ""len contains iter ""\n    ""hash str sizeof ""\n    ""enter exit ""\n    ""divmod neg pos abs invert ""\n    ""complex int float index ""\n    ""trunc floor ceil ""\n)\n\nnumerics = ""add sub mul div floordiv mod lshift rshift and xor or pow ""\ninplace = \' \'.join(\'i%s\' % n for n in numerics.split())\nright = \' \'.join(\'r%s\' % n for n in numerics.split())\nextra = \'\'\nif inPy3k:\n    extra = \'bool next \'\nelse:\n    extra = \'unicode long nonzero oct hex truediv rtruediv \'\n\n# not including __prepare__, __instancecheck__, __subclasscheck__\n# (as they are metaclass methods)\n# __del__ is not supported at all as it causes problems if it exists\n\n_non_defaults = set(\'__%s__\' % method for method in [\n    \'cmp\', \'getslice\', \'setslice\', \'coerce\', \'subclasses\',\n    \'format\', \'get\', \'set\', \'delete\', \'reversed\',\n    \'missing\', \'reduce\', \'reduce_ex\', \'getinitargs\',\n    \'getnewargs\', \'getstate\', \'setstate\', \'getformat\',\n    \'setformat\', \'repr\', \'dir\'\n])\n\n\ndef _get_method(name, func):\n    ""Turns a callable object (like a mock) into a real function""\n    def method(self, *args, **kw):\n        return func(self, *args, **kw)\n    method.__name__ = name\n    return method\n\n\n_magics = set(\n    \'__%s__\' % method for method in\n    \' \'.join([magic_methods, numerics, inplace, right, extra]).split()\n)\n\n_all_magics = _magics | _non_defaults\n\n_unsupported_magics = set([\n    \'__getattr__\', \'__setattr__\',\n    \'__init__\', \'__new__\', \'__prepare__\'\n    \'__instancecheck__\', \'__subclasscheck__\',\n    \'__del__\'\n])\n\n_calculate_return_value = {\n    \'__hash__\': lambda self: object.__hash__(self),\n    \'__str__\': lambda self: object.__str__(self),\n    \'__sizeof__\': lambda self: object.__sizeof__(self),\n    \'__unicode__\': lambda self: unicode(object.__str__(self)),\n}\n\n_return_values = {\n    \'__int__\': 1,\n    \'__contains__\': False,\n    \'__len__\': 0,\n    \'__exit__\': False,\n    \'__complex__\': 1j,\n    \'__float__\': 1.0,\n    \'__bool__\': True,\n    \'__nonzero__\': True,\n    \'__oct__\': \'1\',\n    \'__hex__\': \'0x1\',\n    \'__long__\': long(1),\n    \'__index__\': 1,\n}\n\n\ndef _get_eq(self):\n    def __eq__(other):\n        ret_val = self.__eq__._mock_return_value\n        if ret_val is not DEFAULT:\n            return ret_val\n        return self is other\n    return __eq__\n\ndef _get_ne(self):\n    def __ne__(other):\n        if self.__ne__._mock_return_value is not DEFAULT:\n            return DEFAULT\n        return self is not other\n    return __ne__\n\ndef _get_iter(self):\n    def __iter__():\n        ret_val = self.__iter__._mock_return_value\n        if ret_val is DEFAULT:\n            return iter([])\n        # if ret_val was already an iterator, then calling iter on it should\n        # return the iterator unchanged\n        return iter(ret_val)\n    return __iter__\n\n_side_effect_methods = {\n    \'__eq__\': _get_eq,\n    \'__ne__\': _get_ne,\n    \'__iter__\': _get_iter,\n}\n\n\n\ndef _set_return_value(mock, method, name):\n    fixed = _return_values.get(name, DEFAULT)\n    if fixed is not DEFAULT:\n        method.return_value = fixed\n        return\n\n    return_calulator = _calculate_return_value.get(name)\n    if return_calulator is not None:\n        try:\n            return_value = return_calulator(mock)\n        except AttributeError:\n            # XXXX why do we return AttributeError here?\n            #      set it as a side_effect instead?\n            return_value = AttributeError(name)\n        method.return_value = return_value\n        return\n\n    side_effector = _side_effect_methods.get(name)\n    if side_effector is not None:\n        method.side_effect = side_effector(mock)\n\n\n\nclass MagicMixin(object):\n    def __init__(self, *args, **kw):\n        _super(MagicMixin, self).__init__(*args, **kw)\n        self._mock_set_magics()\n\n\n    def _mock_set_magics(self):\n        these_magics = _magics\n\n        if self._mock_methods is not None:\n            these_magics = _magics.intersection(self._mock_methods)\n\n            remove_magics = set()\n            remove_magics = _magics - these_magics\n\n            for entry in remove_magics:\n                if entry in type(self).__dict__:\n                    # remove unneeded magic methods\n                    delattr(self, entry)\n\n        # don\'t overwrite existing attributes if called a second time\n        these_magics = these_magics - set(type(self).__dict__)\n\n        _type = type(self)\n        for entry in these_magics:\n            setattr(_type, entry, MagicProxy(entry, self))\n\n\n\nclass NonCallableMagicMock(MagicMixin, NonCallableMock):\n    """"""A version of `MagicMock` that isn\'t callable.""""""\n    def mock_add_spec(self, spec, spec_set=False):\n        """"""Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.""""""\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()\n\n\n\nclass MagicMock(MagicMixin, Mock):\n    """"""\n    MagicMock is a subclass of Mock with default implementations\n    of most of the magic methods. You can use MagicMock without having to\n    configure the magic methods yourself.\n\n    If you use the `spec` or `spec_set` arguments then *only* magic\n    methods that exist in the spec will be created.\n\n    Attributes and the return value of a `MagicMock` will also be `MagicMocks`.\n    """"""\n    def mock_add_spec(self, spec, spec_set=False):\n        """"""Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.""""""\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()\n\n\n\nclass MagicProxy(object):\n    def __init__(self, name, parent):\n        self.name = name\n        self.parent = parent\n\n    def __call__(self, *args, **kwargs):\n        m = self.create_mock()\n        return m(*args, **kwargs)\n\n    def create_mock(self):\n        entry = self.name\n        parent = self.parent\n        m = parent._get_child_mock(name=entry, _new_name=entry,\n                                   _new_parent=parent)\n        setattr(parent, entry, m)\n        _set_return_value(parent, m, entry)\n        return m\n\n    def __get__(self, obj, _type=None):\n        return self.create_mock()\n\n\n\nclass _ANY(object):\n    ""A helper object that compares equal to everything.""\n\n    def __eq__(self, other):\n        return True\n\n    def __ne__(self, other):\n        return False\n\n    def __repr__(self):\n        return \'<ANY>\'\n\nANY = _ANY()\n\n\n\ndef _format_call_signature(name, args, kwargs):\n    message = \'%s(%%s)\' % name\n    formatted_args = \'\'\n    args_string = \', \'.join([repr(arg) for arg in args])\n    kwargs_string = \', \'.join([\n        \'%s=%r\' % (key, value) for key, value in kwargs.items()\n    ])\n    if args_string:\n        formatted_args = args_string\n    if kwargs_string:\n        if formatted_args:\n            formatted_args += \', \'\n        formatted_args += kwargs_string\n\n    return message % formatted_args\n\n\n\nclass _Call(tuple):\n    """"""\n    A tuple for holding the results of a call to a mock, either in the form\n    `(args, kwargs)` or `(name, args, kwargs)`.\n\n    If args or kwargs are empty then a call tuple will compare equal to\n    a tuple without those values. This makes comparisons less verbose::\n\n        _Call((\'name\', (), {})) == (\'name\',)\n        _Call((\'name\', (1,), {})) == (\'name\', (1,))\n        _Call(((), {\'a\': \'b\'})) == ({\'a\': \'b\'},)\n\n    The `_Call` object provides a useful shortcut for comparing with call::\n\n        _Call(((1, 2), {\'a\': 3})) == call(1, 2, a=3)\n        _Call((\'foo\', (1, 2), {\'a\': 3})) == call.foo(1, 2, a=3)\n\n    If the _Call has no name then it will match any name.\n    """"""\n    def __new__(cls, value=(), name=None, parent=None, two=False,\n                from_kall=True):\n        name = \'\'\n        args = ()\n        kwargs = {}\n        _len = len(value)\n        if _len == 3:\n            name, args, kwargs = value\n        elif _len == 2:\n            first, second = value\n            if isinstance(first, basestring):\n                name = first\n                if isinstance(second, tuple):\n                    args = second\n                else:\n                    kwargs = second\n            else:\n                args, kwargs = first, second\n        elif _len == 1:\n            value, = value\n            if isinstance(value, basestring):\n                name = value\n            elif isinstance(value, tuple):\n                args = value\n            else:\n                kwargs = value\n\n        if two:\n            return tuple.__new__(cls, (args, kwargs))\n\n        return tuple.__new__(cls, (name, args, kwargs))\n\n\n    def __init__(self, value=(), name=None, parent=None, two=False,\n                 from_kall=True):\n        self.name = name\n        self.parent = parent\n        self.from_kall = from_kall\n\n\n    def __eq__(self, other):\n        if other is ANY:\n            return True\n        try:\n            len_other = len(other)\n        except TypeError:\n            return False\n\n        self_name = \'\'\n        if len(self) == 2:\n            self_args, self_kwargs = self\n        else:\n            self_name, self_args, self_kwargs = self\n\n        other_name = \'\'\n        if len_other == 0:\n            other_args, other_kwargs = (), {}\n        elif len_other == 3:\n            other_name, other_args, other_kwargs = other\n        elif len_other == 1:\n            value, = other\n            if isinstance(value, tuple):\n                other_args = value\n                other_kwargs = {}\n            elif isinstance(value, basestring):\n                other_name = value\n                other_args, other_kwargs = (), {}\n            else:\n                other_args = ()\n                other_kwargs = value\n        else:\n            # len 2\n            # could be (name, args) or (name, kwargs) or (args, kwargs)\n            first, second = other\n            if isinstance(first, basestring):\n                other_name = first\n                if isinstance(second, tuple):\n                    other_args, other_kwargs = second, {}\n                else:\n                    other_args, other_kwargs = (), second\n            else:\n                other_args, other_kwargs = first, second\n\n        if self_name and other_name != self_name:\n            return False\n\n        # this order is important for ANY to work!\n        return (other_args, other_kwargs) == (self_args, self_kwargs)\n\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n\n    def __call__(self, *args, **kwargs):\n        if self.name is None:\n            return _Call((\'\', args, kwargs), name=\'()\')\n\n        name = self.name + \'()\'\n        return _Call((self.name, args, kwargs), name=name, parent=self)\n\n\n    def __getattr__(self, attr):\n        if self.name is None:\n            return _Call(name=attr, from_kall=False)\n        name = \'%s.%s\' % (self.name, attr)\n        return _Call(name=name, parent=self, from_kall=False)\n\n\n    def __repr__(self):\n        if not self.from_kall:\n            name = self.name or \'call\'\n            if name.startswith(\'()\'):\n                name = \'call%s\' % name\n            return name\n\n        if len(self) == 2:\n            name = \'call\'\n            args, kwargs = self\n        else:\n            name, args, kwargs = self\n            if not name:\n                name = \'call\'\n            elif not name.startswith(\'()\'):\n                name = \'call.%s\' % name\n            else:\n                name = \'call%s\' % name\n        return _format_call_signature(name, args, kwargs)\n\n\n    def call_list(self):\n        """"""For a call object that represents multiple calls, `call_list`\n        returns a list of all the intermediate calls as well as the\n        final call.""""""\n        vals = []\n        thing = self\n        while thing is not None:\n            if thing.from_kall:\n                vals.append(thing)\n            thing = thing.parent\n        return _CallList(reversed(vals))\n\n\ncall = _Call(from_kall=False)\n\n\n\ndef create_autospec(spec, spec_set=False, instance=False, _parent=None,\n                    _name=None, **kwargs):\n    """"""Create a mock object using another object as a spec. Attributes on the\n    mock will use the corresponding attribute on the `spec` object as their\n    spec.\n\n    Functions or methods being mocked will have their arguments checked in a\n    similar way to `mocksignature` to check that they are called with the\n    correct signature.\n\n    If `spec_set` is True then attempting to set attributes that don\'t exist\n    on the spec object will raise an `AttributeError`.\n\n    If a class is used as a spec then the return value of the mock (the\n    instance of the class) will have the same spec. You can use a class as the\n    spec for an instance object by passing `instance=True`. The returned mock\n    will only be callable if instances of the mock are callable.\n\n    `create_autospec` also takes arbitrary keyword arguments that are passed to\n    the constructor of the created mock.""""""\n    if _is_list(spec):\n        # can\'t pass a list instance to the mock constructor as it will be\n        # interpreted as a list of strings\n        spec = type(spec)\n\n    is_type = isinstance(spec, ClassTypes)\n\n    _kwargs = {\'spec\': spec}\n    if spec_set:\n        _kwargs = {\'spec_set\': spec}\n    elif spec is None:\n        # None we mock with a normal mock without a spec\n        _kwargs = {}\n\n    _kwargs.update(kwargs)\n\n    Klass = MagicMock\n    if type(spec) in DescriptorTypes:\n        # descriptors don\'t have a spec\n        # because we don\'t know what type they return\n        _kwargs = {}\n    elif not _callable(spec):\n        Klass = NonCallableMagicMock\n    elif is_type and instance and not _instance_callable(spec):\n        Klass = NonCallableMagicMock\n\n    _new_name = _name\n    if _parent is None:\n        # for a top level object no _new_name should be set\n        _new_name = \'\'\n\n    mock = Klass(parent=_parent, _new_parent=_parent, _new_name=_new_name,\n                 name=_name, **_kwargs)\n\n    if isinstance(spec, FunctionTypes):\n        # should only happen at the top level because we don\'t\n        # recurse for functions\n        mock = _set_signature(mock, spec)\n    else:\n        _check_signature(spec, mock, is_type, instance)\n\n    if _parent is not None and not instance:\n        _parent._mock_children[_name] = mock\n\n    if is_type and not instance and \'return_value\' not in kwargs:\n        # XXXX could give a name to the return_value mock?\n        mock.return_value = create_autospec(spec, spec_set, instance=True,\n                                            _name=\'()\', _parent=mock)\n\n    for entry in dir(spec):\n        if _is_magic(entry):\n            # MagicMock already does the useful magic methods for us\n            continue\n\n        if isinstance(spec, FunctionTypes) and entry in FunctionAttributes:\n            # allow a mock to actually be a function from mocksignature\n            continue\n\n        # XXXX do we need a better way of getting attributes without\n        # triggering code execution (?) Probably not - we need the actual\n        # object to mock it so we would rather trigger a property than mock\n        # the property descriptor. Likewise we want to mock out dynamically\n        # provided attributes.\n        # XXXX what about attributes that raise exceptions on being fetched\n        # we could be resilient against it, or catch and propagate the\n        # exception when the attribute is fetched from the mock\n        original = getattr(spec, entry)\n\n        kwargs = {\'spec\': original}\n        if spec_set:\n            kwargs = {\'spec_set\': original}\n\n        if not isinstance(original, FunctionTypes):\n            new = _SpecState(original, spec_set, mock, entry, instance)\n            mock._mock_children[entry] = new\n        else:\n            parent = mock\n            if isinstance(spec, FunctionTypes):\n                parent = mock.mock\n\n            new = MagicMock(parent=parent, name=entry, _new_name=entry,\n                            _new_parent=parent, **kwargs)\n            mock._mock_children[entry] = new\n            skipfirst = _must_skip(spec, entry, is_type)\n            _check_signature(original, new, skipfirst=skipfirst)\n\n        # so functions created with mocksignature become instance attributes,\n        # *plus* their underlying mock exists in _mock_children of the parent\n        # mock. Adding to _mock_children may be unnecessary where we are also\n        # setting as an instance attribute?\n        if isinstance(new, FunctionTypes):\n            setattr(mock, entry, new)\n\n    return mock\n\n\ndef _must_skip(spec, entry, is_type):\n    if not isinstance(spec, ClassTypes):\n        if entry in getattr(spec, \'__dict__\', {}):\n            # instance attribute - shouldn\'t skip\n            return False\n        # can\'t use type because of old style classes\n        spec = spec.__class__\n    if not hasattr(spec, \'__mro__\'):\n        # old style class: can\'t have descriptors anyway\n        return is_type\n\n    for klass in spec.__mro__:\n        result = klass.__dict__.get(entry, DEFAULT)\n        if result is DEFAULT:\n            continue\n        if isinstance(result, (staticmethod, classmethod)):\n            return False\n        return is_type\n\n    # shouldn\'t get here unless function is a dynamically provided attribute\n    # XXXX untested behaviour\n    return is_type\n\n\ndef _get_class(obj):\n    try:\n        return obj.__class__\n    except AttributeError:\n        # in Python 2, _sre.SRE_Pattern objects have no __class__\n        return type(obj)\n\n\nclass _SpecState(object):\n\n    def __init__(self, spec, spec_set=False, parent=None,\n                 name=None, ids=None, instance=False):\n        self.spec = spec\n        self.ids = ids\n        self.spec_set = spec_set\n        self.parent = parent\n        self.instance = instance\n        self.name = name\n\n\nFunctionTypes = (\n    # python function\n    type(create_autospec),\n    # instance method\n    type(ANY.__eq__),\n    # unbound method\n    type(_ANY.__eq__),\n)\n\nFunctionAttributes = set([\n    \'func_closure\',\n    \'func_code\',\n    \'func_defaults\',\n    \'func_dict\',\n    \'func_doc\',\n    \'func_globals\',\n    \'func_name\',\n])\n'"
setup.py,0,"b""from setuptools import setup, find_packages\n\nsetup(\n    name='diffcalc',\n    version='2.1',\n    \n    description='A diffraction condition calculator for X-ray or neutron diffractometer control.',\n    long_description=open('README.rst').read(),\n    url='https://github.com/DiamondLightSource/diffcalc',\n    \n    author='Rob Walton',\n    author_email='rob.walton@diamond.ac.uk',\n    \n    license='GNU',\n    \n    packages=find_packages(exclude=['docs']),\n    \n    install_requires=[         \n        'numpy',\n        'ipython',\n        'pytest',\n        'pytest-xdist',\n        'nose'\n    ],\n\n    entry_points={\n        'console_scripts': [\n            'diffcalc=diffcmd.diffcalc_launcher:main',\n        ],\n    },\n)"""
diffcalc/__init__.py,0,b''
diffcalc/hardware.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom __future__ import absolute_import\n\nfrom diffcalc.util import DiffcalcException\nfrom diffcalc import settings\n\nSMALL = 1e-8\n\nfrom diffcalc.util import command\n\n__all__ = [\'hardware\', \'setcut\', \'setmin\', \'setmax\']\n\n\ndef getNameFromScannableOrString(o):\n        try:  # it may be a scannable\n            return o.getName()\n        except AttributeError:\n            return str(o)\n\n\n\n@command\ndef hardware():\n    """"""hardware  -- show diffcalc limits and cuts""""""\n    print settings.hardware.repr_sector_limits_and_cuts()  # @UndefinedVariable\n\n@command\ndef setcut(scannable_or_string=None, val=None):\n    """"""setcut {name {val}} -- sets cut angle\n    """"""\n    if scannable_or_string is None and val is None:\n        print settings.hardware.repr_sector_limits_and_cuts()  # @UndefinedVariable\n    else:\n        name = getNameFromScannableOrString(scannable_or_string)\n        if val is None:\n            print \'%s: %f\' % (name, settings.hardware.get_cuts()[name])  # @UndefinedVariable\n        else:\n            oldcut = settings.hardware.get_cuts()[name]  # @UndefinedVariable\n            settings.hardware.set_cut(name, float(val))  # @UndefinedVariable\n            newcut = settings.hardware.get_cuts()[name]  # @UndefinedVariable\n\n@command\ndef setmin(name=None, val=None):\n    """"""setmin {axis {val}} -- set lower limits used by auto sector code (None to clear)"""""" #@IgnorePep8\n    _setMinOrMax(name, val, settings.hardware.set_lower_limit)  # @UndefinedVariable\n\n@command\ndef setmax(name=None, val=None):\n    """"""setmax {name {val}} -- sets upper limits used by auto sector code (None to clear)"""""" #@IgnorePep8\n    _setMinOrMax(name, val, settings.hardware.set_upper_limit)  # @UndefinedVariable\n\n@command\ndef setrange(name=None, lower=None, upper=None):\n    """"""setrange {axis {min} {max}} -- set lower and upper limits used by auto sector code (None to clear)"""""" #@IgnorePep8\n    _setMinOrMax(name, lower, settings.hardware.set_lower_limit)  # @UndefinedVariable\n    _setMinOrMax(name, upper, settings.hardware.set_upper_limit)  # @UndefinedVariable\n\ndef _setMinOrMax(name, val, setMethod):\n    if name is None:\n        print settings.hardware.repr_sector_limits_and_cuts()  # @UndefinedVariable\n    else:\n        name = getNameFromScannableOrString(name)\n        if val is None:\n            print settings.hardware.repr_sector_limits_and_cuts(name)  # @UndefinedVariable\n        else:\n            setMethod(name, float(val))\n\n\ncommands_for_help = [\'Hardware\',\n                     hardware,\n                     setcut,\n                     setmin,\n                     setmax]\n\n\nclass HardwareAdapter(object):\n\n    def __init__(self, diffractometerAngleNames, defaultCuts={},\n                 energyScannableMultiplierToGetKeV=1):\n\n        self._diffractometerAngleNames = diffractometerAngleNames\n        self._cut_angles = {}\n        self._configure_cuts(defaultCuts)\n        self.energyScannableMultiplierToGetKeV = \\\n            energyScannableMultiplierToGetKeV\n        self._name = \'base\'\n\n    @property\n    def name(self):\n        return self._name\n\n    def get_axes_names(self):\n        return tuple(self._diffractometerAngleNames)\n\n    def get_position(self):\n        """"""pos = get_position() -- returns the current physical diffractometer\n        position as a diffcalc.util object in degrees\n        """"""\n        raise NotImplementedError()\n\n    def get_wavelength(self):\n        """"""wavelength = get_wavelength() -- returns wavelength in Angstroms\n        """"""\n        return 12.39842 / self.get_energy()\n\n    def get_energy(self):\n        """"""energy = get_energy() -- returns energy in kEv  """"""\n        raise NotImplementedError()\n\n    def __str__(self):\n        s = self.name + "":\\n""\n        s += ""      energy : %9.4f keV\\n"" % self.get_energy()\n        s += ""  wavelength : %9.4f A\\n"" % self.get_wavelength()\n        names = self._diffractometerAngleNames\n        width = max(len(k) for k in names)\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\\n\'\n        for name, pos in zip(names, self.get_position()):\n            s += fmt % (name, pos)\n        return s\n\n    def __repr__(self):\n        return self.__str__()\n\n    def get_position_by_name(self, angleName):\n        names = list(self._diffractometerAngleNames)\n        return self.get_position()[names.index(angleName)]\n\n### Limits ###\n\n    def get_lower_limit(self, name):\n        \'\'\'returns lower limits by axis name. Limit may be None if not set\n        \'\'\'\n        raise NotImplementedError()\n\n    def get_upper_limit(self, name):\n        \'\'\'returns upper limit by axis name. Limit may be None if not set\n        \'\'\'\n        raise NotImplementedError()\n\n    def set_lower_limit(self, name, value):\n        """"""value may be None to remove limit""""""\n        raise NotImplementedError()\n\n    def set_upper_limit(self, name, value):\n        """"""value may be None to remove limit""""""\n        raise NotImplementedError()\n\n    def is_axis_value_within_limits(self, axis_name, value):\n        raise NotImplementedError()\n\n    def is_position_within_limits(self, positionArray):\n        """"""\n        where position array is in degrees and cut to be between -180 and 180\n        """"""\n        names = self._diffractometerAngleNames\n        for axis_name, value in zip(names, positionArray):\n            if not self.is_axis_value_within_limits(axis_name, value):\n                return False\n        return True\n\n    def repr_sector_limits_and_cuts(self, name=None):\n        if name is None:\n            s = \'\'\n            for name in self.get_axes_names():\n                s += self.repr_sector_limits_and_cuts(name) + \'\\n\'\n            s += ""Note: When auto sector/transforms are used,\\n ""\n            s += ""      cuts are applied before checking limits.""\n            return s\n        # limits:\n        low = self.get_lower_limit(name)\n        high = self.get_upper_limit(name)\n        s = \'  \'\n        if low is not None:\n            s += ""% 6.1f <= "" % low\n        else:\n            s += \' \' * 10\n        s += \'%5s\' % name\n        if high is not None:\n            s += "" <= % 6.1f"" % high\n        else:\n            s += \' \' * 10\n        # cuts:\n        try:\n            if self.get_cuts()[name] is not None:\n                s += "" (cut: % 6.1f)"" % self.get_cuts()[name]\n        except KeyError:\n            pass\n\n        return s\n\n### Cutting Stuff ###\n\n    def _configure_cuts(self, defaultCutsDict):\n        # 1. Set default cut angles\n        self._cut_angles = dict.fromkeys(self._diffractometerAngleNames, -180.)\n        if \'phi\' in self._cut_angles:\n            self._cut_angles[\'phi\'] = 0.\n        # 2. Overide with user-specified cuts\n        for name, val in defaultCutsDict.iteritems():\n            self.set_cut(name, val)\n\n    def set_cut(self, name, value):\n        if name in self._cut_angles:\n            self._cut_angles[name] = value\n        else:\n            raise KeyError(""Diffractometer has no angle %s. Try: %s."" %\n                            (name, self._diffractometerAngleNames))\n\n    def get_cuts(self):\n        return self._cut_angles\n\n    def cut_angles(self, positionArray):\n        \'\'\'Assumes each angle in positionArray is between -360 and 360\n        \'\'\'\n        cutArray = []\n        names = self._diffractometerAngleNames\n        for axis_name, value in zip(names, positionArray):\n            cutArray.append(self.cut_angle(axis_name, value))\n        return tuple(cutArray)\n\n    def cut_angle(self, axis_name, value):\n        cut_angle = self._cut_angles[axis_name]\n        if cut_angle is None:\n            return value\n        return cut_angle_at(cut_angle, value)\n\n\ndef cut_angle_at(cut_angle, value):\n    if (cut_angle == 0 and (abs(value - 360) < SMALL) or\n        (abs(value + 360) < SMALL) or\n        (abs(value) < SMALL)):\n        value = 0.\n    if value < (cut_angle - SMALL):\n        return value + 360.\n    elif value >= cut_angle + 360. + SMALL:\n        return value - 360.\n    else:\n        return value\n\n\nclass DummyHardwareAdapter(HardwareAdapter):\n\n    def __init__(self, diffractometerAngleNames):\n        super(self.__class__, self).__init__(diffractometerAngleNames)\n#         HardwareAdapter.__init__(self, diffractometerAngleNames)\n\n        self._position = [0.] * len(diffractometerAngleNames)\n        self._upperLimitDict = {}\n        self._lowerLimitDict = {}\n        self._wavelength = 1.\n        self.energyScannableMultiplierToGetKeV = 1\n        self._name = ""Dummy""\n\n# Required methods\n\n    def get_position(self):\n        """"""\n        pos = getDiffractometerPosition() -- returns the current physical\n        diffractometer position as a list in degrees\n        """"""\n        return self._position\n\n    def _set_position(self, pos):\n        assert len(pos) == len(self.get_axes_names()), \\\n            ""Wrong length of input list""\n        self._position = pos\n\n    position = property(get_position, _set_position)\n\n    def get_energy(self):\n        """"""energy = get_energy() -- returns energy in kEv  """"""\n        if self._wavelength is None:\n            raise DiffcalcException(\n                ""Energy or wavelength have not been set"")\n        return (12.39842 /\n                (self._wavelength * self.energyScannableMultiplierToGetKeV))\n\n    def _set_energy(self, energy):\n        self._wavelength = 12.39842 / energy\n\n    energy = property(get_energy, _set_energy)\n\n    def get_wavelength(self):\n        """"""wavelength = get_wavelength() -- returns wavelength in Angstroms""""""\n        if self._wavelength is None:\n            raise DiffcalcException(\n                ""Energy or wavelength have not been set"")\n        return self._wavelength\n\n    def _set_wavelength(self, wavelength):\n        self._wavelength = wavelength\n\n    wavelength = property(get_wavelength, _set_wavelength)\n\n    def get_lower_limit(self, name):\n        \'\'\'returns lower limits by axis name. Limit may be None if not set\n        \'\'\'\n        if name not in self._diffractometerAngleNames:\n            raise ValueError(""No angle called %s. Try one of: %s"" %\n                             (name, self._diffractometerAngleNames))\n        return self._lowerLimitDict.get(name)\n\n    def get_upper_limit(self, name):\n        \'\'\'returns upper limit by axis name. Limit may be None if not set\n        \'\'\'\n        if name not in self._diffractometerAngleNames:\n            raise ValueError(""No angle called %s. Try one of: %s"" %\n                             name, self._diffractometerAngleNames)\n        return self._upperLimitDict.get(name)\n\n    def set_lower_limit(self, name, value):\n        """"""value may be None to remove limit""""""\n        if name not in self._diffractometerAngleNames:\n            raise ValueError(\n                ""Cannot set lower Diffcalc limit: No angle called %s. Try one ""\n                ""of: %s"" % (name, self._diffractometerAngleNames))\n        if value is None:\n            try:\n                del self._lowerLimitDict[name]\n            except KeyError:\n                print (""WARNING: There was no lower Diffcalc limit %s set to ""\n                       ""clear"" % name)\n        else:\n            self._lowerLimitDict[name] = value\n\n    def set_upper_limit(self, name, value):\n        """"""value may be None to remove limit""""""\n        if name not in self._diffractometerAngleNames:\n            raise ValueError(\n                ""Cannot set upper Diffcalc limit: No angle called %s. Try one ""\n                ""of: %s"" % (name, self._diffractometerAngleNames))\n        if value is None:\n            try:\n                del self._upperLimitDict[name]\n            except KeyError:\n                print (""WARNING: There was no upper Diffcalc limit %s set to ""\n                       ""clear"" % name)\n        else:\n            self._upperLimitDict[name] = value\n\n    def is_axis_value_within_limits(self, axis_name, value):\n        if axis_name in self._upperLimitDict:\n            if value > self._upperLimitDict[axis_name]:\n                return False\n        if axis_name in self._lowerLimitDict:\n            if value < self._lowerLimitDict[axis_name]:\n                return False\n        return True\n\n\nclass ScannableHardwareAdapter(HardwareAdapter):\n\n    def __init__(self, diffractometerScannable, energyScannable,\n                 energyScannableMultiplierToGetKeV=1):\n        input_names = diffractometerScannable.getInputNames()\n        super(self.__class__, self).__init__(input_names)\n#         HardwareAdapter.__init__(self, input_names)\n        self.diffhw = diffractometerScannable\n        self.energyhw = energyScannable\n        self.energyScannableMultiplierToGetKeV = \\\n            energyScannableMultiplierToGetKeV\n        self._name = ""ScannableHarwdareMonitor""\n\n# Required methods\n\n    def get_position(self):\n        """"""\n        pos = getDiffractometerPosition() -- returns the current physical\n        diffractometer position as a list in degrees\n        """"""\n        return self.diffhw.getPosition()\n\n    def get_energy(self):\n        """"""energy = get_energy() -- returns energy in keV (NOT eV!) """"""\n        multiplier = self.energyScannableMultiplierToGetKeV\n        energy = self.energyhw.getPosition() * multiplier\n        if energy is None:\n            raise DiffcalcException(""Energy has not been set"")\n        return energy\n\n    def get_wavelength(self):\n        """"""wavelength = get_wavelength() -- returns wavelength in Angstroms""""""\n        energy = self.get_energy()\n        return 12.39842 / energy\n\n    @property\n    def name(self):\n        return self.diffhw.getName()\n\n### Limits ###\n\n    def get_lower_limit(self, name):\n        \'\'\'returns lower limits by axis name. Limit may be None if not set\n        \'\'\'\n        try:\n            scn = self.diffhw.getGroupMember(name)\n        except AttributeError:\n            scn = self.diffhw.getFieldScannable(name)\n        try:\n            limit = scn.getLowerInnerLimit()\n            return limit\n        except AttributeError:\n            pass\n        try:\n            limits = scn.getLowerGdaLimits()\n        except AttributeError:\n            raise DiffcalcException(""Cannot read lower limit for scannable {}"".format(name))\n        try:\n            if len(limits) != 1:\n                raise DiffcalcException(""Lower limit for scannable {} has {} limit values"".format(name, len(limits)))\n            return limits[0]\n        except TypeError:\n            return limits\n\n    def get_upper_limit(self, name):\n        \'\'\'returns upper limit by axis name. Limit may be None if not set\n        \'\'\'\n        try:\n            scn = self.diffhw.getGroupMember(name)\n        except AttributeError:\n            scn = self.diffhw.getFieldScannable(name)\n        try:\n            limit = scn.getUpperInnerLimit()\n            return limit\n        except AttributeError:\n            pass\n        try:\n            limits = scn.getUpperGdaLimits()\n        except AttributeError:\n            raise DiffcalcException(""Cannot read upper limit for scannable {}"".format(name))\n        try:\n            if len(limits) != 1:\n                raise DiffcalcException(""Upper limit for scannable {} has {} limit values"".format(name, len(limits)))\n            return limits[0]\n        except TypeError:\n            return limits\n\n    def set_lower_limit(self, name, value):\n        scn = self.diffhw.getGroupMember(name)\n        try:\n            scn.setLowerDummyLimit(value)\n        except AttributeError:\n            raise DiffcalcException(\'This command is only implemented in dummy mode.\\n\'\n                                    \'Please use GDA/EPICS interface to set hardware limits.\')\n\n    def set_upper_limit(self, name, value):\n        scn = self.diffhw.getGroupMember(name)\n        try:\n            scn.setUpperDummyLimit(value)\n        except AttributeError:\n            raise DiffcalcException(\'This command is only implemented in dummy mode.\\n\'\n                                    \'Please use GDA/EPICS interface to set hardware limits.\')\n\n    def is_position_within_limits(self, positionArray):\n        """"""\n        where position array is in degrees and cut to be between -180 and 180\n        """"""\n        try:\n            res = False if self.diffhw.checkPositionValid(positionArray) else True\n        except NotImplementedError:\n            res = HardwareAdapter.is_position_within_limits(self, positionArray)\n        return res\n\n    def is_axis_value_within_limits(self, axis_name, value):\n        scn = self.diffhw.getGroupMember(axis_name)\n        res = False if scn.checkPositionValid([value,]) else True\n        return res\n'"
diffcalc/log.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom __future__ import absolute_import\n\nimport logging\n\ntry:\n    import gda\n    GDA = True  \nexcept ImportError:\n    GDA = False\n\nif not GDA:\n    import getpass\n    logging.basicConfig(format=""%(asctime)s %(levelname)s:%(name)s:%(message)s"",\n                        datefmt=\'%m/%d/%Y %I:%M:%S\',\n                        filename=\'/tmp/diffcalc_%s.log\' % getpass.getuser(),\n                        level=logging.DEBUG)\n'"
diffcalc/settings.py,0,"b""'''\nCreated on Aug 5, 2013\n\n@author: walton\n'''\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n# These should be by the user *before* importing other modules\ngeometry = None\nhardware = None\nubcalc_persister = UbCalculationNonPersister()\n\naxes_scannable_group = None\nenergy_scannable = None\nenergy_scannable_multiplier_to_get_KeV=1\n\n\n# These will be set by dcyou, dcvlieg or dcwillmot\nubcalc_strategy = None\nangles_to_hkl_function = None  # Used by checkub to avoid coupling it to an hkl module\ninclude_sigtau=False\ninclude_reference=True\n\nreference_vector = matrix('1; 0; 0')\nsurface_vector = matrix('0; 0; 1')\n\nNUNAME = 'gam'\n"""
diffcalc/util.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, acos, cos, sin, sqrt\nfrom functools import wraps\nimport textwrap\n\ntry:\n    from gda.jython.commands.InputCommands import requestInput as raw_input\n    GDA = True\nexcept ImportError:\n    GDA = False\n    pass  # raw_input unavailable in gda\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\n\n\n# from http://physics.nist.gov/\nh_in_eV_per_s = 4.135667516E-15\nc = 299792458\nTWELVEISH = c * h_in_eV_per_s  # 12.39842\n\n\nSMALL = 1e-10\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nCOLOURISE_TERMINAL_OUTPUT = not GDA\n\ndef bold(s):\n    if not COLOURISE_TERMINAL_OUTPUT:\n        return s\n    else:    \n        BOLD = \'\\033[1m\'\n        END = \'\\033[0m\'\n        return BOLD + s + END\n\n\ndef x_rotation(th):\n    return matrix(((1, 0, 0), (0, cos(th), -sin(th)), (0, sin(th), cos(th))))\n\n\ndef y_rotation(th):\n    return matrix(((cos(th), 0, sin(th)), (0, 1, 0), (-sin(th), 0, cos(th))))\n\n\ndef z_rotation(th):\n    return matrix(((cos(th), -sin(th), 0), (sin(th), cos(th), 0), (0, 0, 1)))\n\n\ndef xyz_rotation(u, angle):\n    u = [list(u), [0, 0, 0], [0, 0, 0]]\n    u = matrix(u) / norm(matrix(u))\n    e11=u[0,0]**2+(1-u[0,0]**2)*cos(angle)\n    e12=u[0,0]*u[0,1]*(1-cos(angle))-u[0,2]*sin(angle)\n    e13=u[0,0]*u[0,2]*(1-cos(angle))+u[0,1]*sin(angle)\n    e21=u[0,0]*u[0,1]*(1-cos(angle))+u[0,2]*sin(angle)\n    e22=u[0,1]**2+(1-u[0,1]**2)*cos(angle)\n    e23=u[0,1]*u[0,2]*(1-cos(angle))-u[0,0]*sin(angle)\n    e31=u[0,0]*u[0,2]*(1-cos(angle))-u[0,1]*sin(angle)\n    e32=u[0,1]*u[0,2]*(1-cos(angle))+u[0,0]*sin(angle)\n    e33=u[0,2]**2+(1-u[0,2]**2)*cos(angle)\n    return matrix([[e11,e12,e13],[e21,e22,e23],[e31,e32,e33]])\n\n\nclass CoordinateConverter(object):\n    """"""Class for converting matrix objects between coordinate frames""""""\n\n    def __init__(self, transform=None):\n        if transform is None:\n            self.R = None\n        elif type(transform) in (list, tuple, matrix):\n            self.R = matrix(transform)\n            self.nrow, self.ncol = self.R.shape\n            if self.nrow != self.ncol:\n                raise TypeError(\'Transformation matrix shape is invalid: %d x %d\' % (self.nrow, self.ncol))\n        else:\n            raise TypeError(\'Invalid object type %s\' % str(type(transform)))\n\n    def transform(self, v, inv=False):\n        if type(v) in (list, tuple, matrix):\n            m = matrix(v)\n        else:\n            raise TypeError(\'Invalid object type %s\' % str(type(m)))\n        if self.R is None:\n            return m\n        nr, nc = m.shape\n        if nc == 1:\n            if nr != self.nrow:\n                raise TypeError(\'Invalid number of rows: %d != %d\'% (nr, self.nrow))\n            if inv:\n                return self.R.I * m\n            else:\n                return self.R * m\n        elif nr == 1:\n            if nc != self.ncol:\n                raise TypeError(\'Invalid number of columns: %d != %d\' % (nc, self.ncol))\n            if inv:\n                return m * self.R.I\n            else:\n                return m * self.R\n        elif m.shape == self.R.shape:\n            if inv:\n                return self.R.I * m * self.R\n            else:\n                return self.R * m * self.R.I\n        raise TypeError(\'Invalid matrix shape: %d x %d\' % (nr, nc))\n\n\nclass DiffcalcException(Exception):\n    """"""Error caused by user misuse of diffraction calculator.\n    """"""\n    def __str__(self):\n        lines = []\n        for msg_line in self.message.split(\'\\n\'):\n            lines.append(\'* \' + msg_line)\n        width = max(len(l) for l in lines)\n        lines.insert(0, \'\\n\\n\' + \'*\' * width)\n        lines.append(\'*\' * width)\n        return \'\\n\'.join(lines)\n\n\nclass AbstractPosition(object):\n\n    def inRadians(self):\n        pos = self.clone()\n        pos.changeToRadians()\n        return pos\n\n    def inDegrees(self):\n        pos = self.clone()\n        pos.changeToDegrees()\n        return pos\n\n    def changeToRadians(self):\n        raise NotImplementedError()\n\n    def changeToDegrees(self):\n        raise NotImplementedError()\n\n    def totuple(self):\n        raise NotImplementedError()\n\n\n### Matrices\n\ndef cross3(x, y):\n    """"""z = cross3(x ,y) -- where x, y & z are 3*1 Jama matrices""""""\n    [[x1], [x2], [x3]] = x.tolist()\n    [[y1], [y2], [y3]] = y.tolist()\n    return matrix([[x2 * y3 - x3 * y2],\n                   [x3 * y1 - x1 * y3],\n                   [x1 * y2 - x2 * y1]])\n\n\ndef dot3(x, y):\n    """"""z = dot3(x ,y) -- where x, y are 3*1 Jama matrices""""""\n    return x[0, 0] * y[0, 0] + x[1, 0] * y[1, 0] + x[2, 0] * y[2, 0]\n\n\ndef norm3(x):\n    """"""z = norm3(x) -- where x is 3*1 Jama matrix""""""\n    return norm(x)\n\n\ndef angle_between_vectors(a, b):\n    costheta = dot3(a * (1 / norm(a)), b * (1 / norm(b)))\n    return acos(bound(costheta))\n\n\n## Math\n\ndef bound(x):\n    """"""\n    moves x between -1 and 1. Used to correct for rounding errors which may\n    have moved the sin or cosine of a value outside this range.\n    """"""\n    if abs(x) > (1 + SMALL):\n        raise AssertionError(\n            ""The value (%f) was unexpectedly too far outside -1 or 1 to ""\n            ""safely bound. Please report this."" % x)\n    if x > 1:\n        return 1\n    if x < -1:\n        return -1\n    return x\n\n\ndef matrixToString(m):\n    \'\'\' str = matrixToString(m) --- displays a Jama matrix m as a string\n    \'\'\'\n    toReturn = \'\'\n    for row in m.array:\n        for el in row:\n            toReturn += str(el) + \'\\t\'\n        toReturn += \'\\n\'\n    return toReturn\n\n\ndef nearlyEqual(first, second, tolerance):\n    if type(first) in (int, float):\n        return abs(first - second) <= tolerance\n\n    if type(first) != type(matrix([[1]])):\n        # lists\n        first = matrix([list(first)])\n        second = matrix([list(second)])\n    diff = first - (second)\n    return norm(diff) <= tolerance\n\n\ndef radiansEquivilant(first, second, tolerance):\n    if abs(first - second) <= tolerance:\n        return True\n    if abs((first - 2 * pi) - second) <= tolerance:\n        return True\n    if abs((first + 2 * pi) - second) <= tolerance:\n        return True\n    if abs(first - (second - 2 * pi)) <= tolerance:\n        return True\n    if abs(first - (second + 2 * pi)) <= tolerance:\n        return True\n\n    return False\n\n\ndef degreesEquivilant(first, second, tolerance):\n    return radiansEquivilant(first * TORAD, second * TORAD, tolerance)\n\n\ndef differ(first, second, tolerance):\n    """"""Returns error message if the norm of the difference between two arrays\n    or numbers is greater than the given tolerance. Else returns False.\n    """"""\n    # TODO: Fix spaghetti\n    nonArray = False\n    if type(first) in (int, float):\n        if type(second) not in (int, float):\n            raise TypeError(\n                ""If first is an int or float, so must second. ""\n                ""first=%s, second=%s"" & (repr(first), repr(second)))\n        first = [first]\n        second = [second]\n        nonArray = True\n    if not isinstance(first, matrix):\n        first = matrix([list(first)])\n    if not isinstance(second, matrix):\n        second = matrix([list(second)])\n    diff = first - second\n    if norm(diff) >= tolerance:\n        if nonArray:\n            return (\'%s!=%s\' %\n                    (repr(first.tolist()[0][0]), repr(second.tolist()[0][0])))\n        return (\'%s!=%s\' %\n                (repr(tuple(first.tolist()[0])),\n                repr(tuple(second.tolist()[0]))))\n    return False\n\n\n### user input\n\ndef getInputWithDefault(prompt, default=""""):\n    """"""\n    Prompts user for input and returns if possible a float or a list of floats,\n    or if failing this a string.    default may be a number, array of numbers,\n    or string.\n    """"""\n    if default is not """":\n        # Generate default string\n        if type(default) in (list, tuple):\n            defaultString = """"\n            for val in default:\n                defaultString += str(val) + \' \'\n            defaultString = defaultString.strip()\n        else:\n            defaultString = str(default)\n        prompt = str(prompt) + \'[\' + defaultString + \']: \'\n    else:\n        prompt = str(prompt) + \': \'\n\n    rawresult = raw_input(prompt)\n\n    # Return default if no input provided\n    if rawresult == """":\n        return default\n\n    # Try to process result into list of numbers\n    try:\n        result = []\n        for val in rawresult.split():\n            result.append(float(val))\n    except ValueError:\n        # return a string\n        return rawresult\n    if len(result) == 1:\n        result = result[0]\n    return result\n\n\nclass MockRawInput(object):\n    def __init__(self, toReturnList):\n        if type(toReturnList) != list:\n            toReturnList = [toReturnList]\n        self.toReturnList = toReturnList\n\n    def __call__(self, prompt):\n        toReturn = self.toReturnList.pop(0)\n        if type(toReturn) != str:\n            raise TypeError\n        print prompt + toReturn\n        return toReturn\n\n\ndef getMessageFromException(e):\n    try:  # Jython\n        return e.args[0]\n    except:\n        try:  # Python\n            return e.message\n        except:\n            # Java\n            return e.args[0]\n\n\ndef promptForNumber(prompt, default=""""):\n    val = getInputWithDefault(prompt, default)\n    if type(val) not in (float, int):\n        return None\n    return val\n\n\ndef promptForList(prompt, default=""""):\n    val = getInputWithDefault(prompt, default)\n    if type(val) not in (list, tuple):\n        return None\n    return val\n\n\ndef isnum(o):\n    return isinstance(o, (int, float))\n\n\ndef allnum(l):\n    return not [o for o in l if not isnum(o)]\n\n\nDEBUG = False\n\n\n\ndef command(f):\n    """"""A decorator to wrap a command method or function.\n\n    Calls to the decorated method or function are wrapped by call_command.\n    """"""\n    # TODO: remove one level of stack trace by not using wraps\n    @wraps(f)\n    def wrapper(*args, **kwds):\n        return call_command(f, args)\n\n    return wrapper\n\n\ndef call_command(f, args):\n\n    if DEBUG:\n        return f(*args)\n    try:\n        return f(*args)\n    except TypeError, e:\n        # NOTE: TypeErrors resulting from bugs in the core code will be\n        # erroneously caught here! TODO: check depth of TypeError stack\n        raise TypeError(e.message + \'\\n\\nUSAGE:\\n\' + f.__doc__)\n    except DiffcalcException, e:\n        # TODO: log and create a new one to shorten stack trace for user\n        raise DiffcalcException(e.message)\n\ndef solve_h_fixed_q(h, qval, B, coeff):\n    \'\'\'Find list of all hkl values with a given h and scattering vector amplitude\n    that match linear hkl constraint a*h + b*k + c*l = d\'\'\'\n    B00, B10, B20 = B[0,0], B[1,0], B[2,0]\n    B01, B11, B21 = B[0,1], B[1,1], B[2,1]\n    B02, B12, B22 = B[0,2], B[1,2], B[2,2]\n    a, b, c, d = coeff\n    if b != 0:\n        try:\n            l1 = -(((B01*B02 + B11*B12 + B21*B22)*b - (B01**2 + B11**2 + B21**2)*c)*d - \\\n                  ((B01*B02 + B11*B12 + B21*B22)*a*b - (B00*B02 + B10*B12 + B20*B22)*b**2 - \\\n                   ((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*c)*h + \\\n                  sqrt(-(B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                         2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*d**2 + \\\n                         2*((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                             2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a - \\\n                             (B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*b + \\\n                             (B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                              (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                              ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*c)*d*h - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*h**2 + \\\n                         ((B02**2 + B12**2 + B22**2)*b**2 - 2*(B01*B02 + B11*B12 + B21*B22)*b*c + \\\n                          (B01**2 + B11**2 + B21**2)*c**2)*qval)*b)/((B02**2 + B12**2 + B22**2)*b**2 - \\\n                                                                     2*(B01*B02 + B11*B12 + B21*B22)*b*c + (B01**2 + B11**2 + B21**2)*c**2)\n            l2 = -(((B01*B02 + B11*B12 + B21*B22)*b - (B01**2 + B11**2 + B21**2)*c)*d - \\\n                    ((B01*B02 + B11*B12 + B21*B22)*a*b - (B00*B02 + B10*B12 + B20*B22)*b**2 - \\\n                     ((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*c)*h - \\\n                    sqrt(-(B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*d**2 + \\\n                           2*((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                               2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a - \\\n                               (B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                                (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                                ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*b + \\\n                               (B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*c)*d*h - \\\n                           ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                             2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                             2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                                (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                                ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                             (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                              2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                             (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                              2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                             2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                 (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                 ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                                 (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                  (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                  ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*h**2 + \\\n                           ((B02**2 + B12**2 + B22**2)*b**2 - 2*(B01*B02 + B11*B12 + B21*B22)*b*c + \\\n                            (B01**2 + B11**2 + B21**2)*c**2)*qval)*b)/((B02**2 + B12**2 + B22**2)*b**2 - \\\n                                                                       2*(B01*B02 + B11*B12 + B21*B22)*b*c + (B01**2 + B11**2 + B21**2)*c**2)\n            k1 = (d - a * h - c * l1) / b\n            k2 = (d - a * h - c * l2) / b\n            return [(h, k1 ,l1), (h, k2, l2)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for h=%f with the given hkl constraints"" % h)\n    elif c != 0:\n        try:\n            k1 = (((B02**2 + B12**2 + B22**2)*b - (B01*B02 + B11*B12 + B21*B22)*c)*d - \\\n                  ((B02**2 + B12**2 + B22**2)*a*b + (B00*B01 + B10*B11 + B20*B21)*c**2 - \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a + (B00*B02 + B10*B12 + B20*B22)*b)*c)*h - \\\n                  sqrt(-(B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                         2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*d**2 + \\\n                         2*((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                             2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a - \\\n                             (B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*b + \\\n                             (B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                              (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                              ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*c)*d*h - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*h**2 + \\\n                         ((B02**2 + B12**2 + B22**2)*b**2 - 2*(B01*B02 + B11*B12 + B21*B22)*b*c + \\\n                          (B01**2 + B11**2 + B21**2)*c**2)*qval)*c)/((B02**2 + B12**2 + B22**2)*b**2 - \\\n                                                                     2*(B01*B02 + B11*B12 + B21*B22)*b*c + (B01**2 + B11**2 + B21**2)*c**2)\n            k2 = (((B02**2 + B12**2 + B22**2)*b - (B01*B02 + B11*B12 + B21*B22)*c)*d - \\\n                  ((B02**2 + B12**2 + B22**2)*a*b + (B00*B01 + B10*B11 + B20*B21)*c**2 - \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a + (B00*B02 + B10*B12 + B20*B22)*b)*c)*h + \\\n                  sqrt(-(B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                         2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*d**2 + \\\n                         2*((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                             2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a - \\\n                             (B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*b + \\\n                             (B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                              (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                              ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*c)*d*h - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*h**2 + \\\n                         ((B02**2 + B12**2 + B22**2)*b**2 - 2*(B01*B02 + B11*B12 + B21*B22)*b*c + \\\n                          (B01**2 + B11**2 + B21**2)*c**2)*qval)*c)/((B02**2 + B12**2 + B22**2)*b**2 - \\\n                                                                     2*(B01*B02 + B11*B12 + B21*B22)*b*c + (B01**2 + B11**2 + B21**2)*c**2)\n            l1 = (d - a * h - b * k1) / c\n            l2 = (d - a * h - b * k2) / c\n            return [(h, k1 ,l1), (h, k2, l2)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for h=%f with the given hkl constraints"" % h)\n    else:\n        raise DiffcalcException(""Value of h is fixed to a constant by the constraint on hkl"")\n\ndef solve_k_fixed_q(k, qval, B, coeff):\n    \'\'\'Find list of all hkl values with a given k and scattering vector amplitude\n    that match linear hkl constraint a*h + b*k + c*l = d\'\'\'\n    B00, B10, B20 = B[0,0], B[1,0], B[2,0]\n    B01, B11, B21 = B[0,1], B[1,1], B[2,1]\n    B02, B12, B22 = B[0,2], B[1,2], B[2,2]\n    a, b, c, d = coeff\n    if a != 0:\n        try:\n            l1 = -(((B00*B02 + B10*B12 + B20*B22)*a - (B00**2 + B10**2 + B20**2)*c)*d + \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a**2 - (B00*B02 + B10*B12 + B20*B22)*a*b - \\\n                    ((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*c)*k + \\\n                   sqrt(-(B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                          2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*d**2 - \\\n                          2*((B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a - \\\n                              (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                               2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b + \\\n                              (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                               (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                               ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*c)*d*k - \\\n                          ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                            2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                            2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                               (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                               ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                            (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                             2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                            (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                             2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                            2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                                (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                 (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                 ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*k**2 + \\\n                          ((B02**2 + B12**2 + B22**2)*a**2 - 2*(B00*B02 + B10*B12 + B20*B22)*a*c + \\\n                           (B00**2 + B10**2 + B20**2)*c**2)*qval)*a)/((B02**2 + B12**2 + B22**2)*a**2 - \\\n                                                                      2*(B00*B02 + B10*B12 + B20*B22)*a*c + (B00**2 + B10**2 + B20**2)*c**2)\n            l2 = -(((B00*B02 + B10*B12 + B20*B22)*a - (B00**2 + B10**2 + B20**2)*c)*d + \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a**2 - (B00*B02 + B10*B12 + B20*B22)*a*b - \\\n                    ((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*c)*k - \\\n                   sqrt(-(B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                          2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*d**2 - \\\n                          2*((B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a - \\\n                              (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                               2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b + \\\n                              (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                               (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                               ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*c)*d*k - \\\n                          ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                            2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                            2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                               (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                               ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                            (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                             2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                            (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                             2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                            2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                                (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                 (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                 ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*k**2 + \\\n                          ((B02**2 + B12**2 + B22**2)*a**2 - 2*(B00*B02 + B10*B12 + B20*B22)*a*c + \\\n                           (B00**2 + B10**2 + B20**2)*c**2)*qval)*a)/((B02**2 + B12**2 + B22**2)*a**2 - \\\n                                                                      2*(B00*B02 + B10*B12 + B20*B22)*a*c + (B00**2 + B10**2 + B20**2)*c**2)\n            h1 = (d - b * k - c * l1) / a\n            h2 = (d - b * k - c * l2) / a\n            return [(h1, k ,l1), (h2, k, l2)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for k=%f with the given hkl constraints"" % k)\n    elif c != 0:\n        try:\n            h1 = (((B02**2 + B12**2 + B22**2)*a - (B00*B02 + B10*B12 + B20*B22)*c)*d - \\\n                  ((B02**2 + B12**2 + B22**2)*a*b + (B00*B01 + B10*B11 + B20*B21)*c**2 - \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a + (B00*B02 + B10*B12 + B20*B22)*b)*c)*k - \\\n                  sqrt(-(B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                         2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*d**2 - \\\n                         2*((B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                             (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                             ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a - \\\n                             (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                              2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b + \\\n                             (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                              (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                              ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*c)*d*k - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*k**2 + \\\n                         ((B02**2 + B12**2 + B22**2)*a**2 - 2*(B00*B02 + B10*B12 + B20*B22)*a*c + \\\n                          (B00**2 + B10**2 + B20**2)*c**2)*qval)*c)/((B02**2 + B12**2 + B22**2)*a**2 - \\\n                                                                     2*(B00*B02 + B10*B12 + B20*B22)*a*c + (B00**2 + B10**2 + B20**2)*c**2)\n            h2 = (((B02**2 + B12**2 + B22**2)*a - (B00*B02 + B10*B12 + B20*B22)*c)*d - \\\n                  ((B02**2 + B12**2 + B22**2)*a*b + (B00*B01 + B10*B11 + B20*B21)*c**2 - \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a + (B00*B02 + B10*B12 + B20*B22)*b)*c)*k + \\\n                  sqrt(-(B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                         2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*d**2 - \\\n                         2*((B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                             (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                             ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a - \\\n                             (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                              2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b + \\\n                             (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                              (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                              ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*c)*d*k - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*k**2 + \\\n                         ((B02**2 + B12**2 + B22**2)*a**2 - 2*(B00*B02 + B10*B12 + B20*B22)*a*c + \\\n                          (B00**2 + B10**2 + B20**2)*c**2)*qval)*c)/((B02**2 + B12**2 + B22**2)*a**2 - \\\n                                                                     2*(B00*B02 + B10*B12 + B20*B22)*a*c + (B00**2 + B10**2 + B20**2)*c**2)\n            l1 = (d - a * h1 - b * k) / c\n            l2 = (d - a * h2 - b * k) / c\n            return [(h1, k ,l1), (h2, k, l2)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for k=%f with the given hkl constraints"" % k)\n    else:\n        raise DiffcalcException(""Value of k is fixed to a constant by the constraint on hkl"")\n\ndef solve_l_fixed_q(l, qval, B, coeff):\n    \'\'\'Find list of all hkl values with a given l and scattering vector amplitude\n    that match linear hkl constraint a*h + b*k + c*l = d\'\'\'\n    B00, B10, B20 = B[0,0], B[1,0], B[2,0]\n    B01, B11, B21 = B[0,1], B[1,1], B[2,1]\n    B02, B12, B22 = B[0,2], B[1,2], B[2,2]\n    a, b, c, d = coeff\n    if a != 0:\n        try:\n            k1 = -(((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*d + \\\n                    ((B01*B02 + B11*B12 + B21*B22)*a**2 - (B00*B02 + B10*B12 + B20*B22)*a*b - \\\n                     ((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*c)*l + \\\n                    sqrt(-(B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                           2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*d**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b + \\\n                               (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                                2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c)*d*l - \\\n                           ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                             2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                             2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                                (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                                ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                             (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                              2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                             (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                              2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                             2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                 (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                 ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                                 (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                  (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                  ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*l**2 + \\\n                           ((B01**2 + B11**2 + B21**2)*a**2 - 2*(B00*B01 + B10*B11 + B20*B21)*a*b + \\\n                            (B00**2 + B10**2 + B20**2)*b**2)*qval)*a)/((B01**2 + B11**2 + B21**2)*a**2 - \\\n                                                                       2*(B00*B01 + B10*B11 + B20*B21)*a*b + (B00**2 + B10**2 + B20**2)*b**2)\n            k2 = -(((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*d + \\\n                   ((B01*B02 + B11*B12 + B21*B22)*a**2 - (B00*B02 + B10*B12 + B20*B22)*a*b - \\\n                    ((B00*B01 + B10*B11 + B20*B21)*a - (B00**2 + B10**2 + B20**2)*b)*c)*l - \\\n                   sqrt(-(B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                          2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*d**2 + \\\n                          2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                              (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                              ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                              (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                               (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                               ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b + \\\n                              (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                               2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c)*d*l - \\\n                          ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                            2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                            2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                               (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                               ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                            (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                             2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                            (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                             2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                            2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                                (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                                ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                                (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                 (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                 ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*l**2 + \\\n                          ((B01**2 + B11**2 + B21**2)*a**2 - 2*(B00*B01 + B10*B11 + B20*B21)*a*b + \\\n                           (B00**2 + B10**2 + B20**2)*b**2)*qval)*a)/((B01**2 + B11**2 + B21**2)*a**2 - \\\n                                                                      2*(B00*B01 + B10*B11 + B20*B21)*a*b + (B00**2 + B10**2 + B20**2)*b**2)\n            h1 = (d - b * k1 - c * l) / a\n            h2 = (d - b * k2 - c * l) / a\n            return [(h1, k1 ,l), (h2, k2, l)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for l=%f with the given hkl constraints"" % l)\n    elif b != 0:\n        try:\n            h1 = (((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*d + \\\n                  ((B01*B02 + B11*B12 + B21*B22)*a*b - (B00*B02 + B10*B12 + B20*B22)*b**2 - \\\n                   ((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*c)*l - \\\n                  sqrt(-(B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                         2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*d**2 + \\\n                         2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                             (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                             ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                             (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                              (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                              ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b + \\\n                             (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                              2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c)*d*l - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*l**2 + \\\n                         ((B01**2 + B11**2 + B21**2)*a**2 - 2*(B00*B01 + B10*B11 + B20*B21)*a*b + \\\n                          (B00**2 + B10**2 + B20**2)*b**2)*qval)*b)/((B01**2 + B11**2 + B21**2)*a**2 - \\\n                                                                     2*(B00*B01 + B10*B11 + B20*B21)*a*b + (B00**2 + B10**2 + B20**2)*b**2)\n            h2 = (((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*d + \\\n                  ((B01*B02 + B11*B12 + B21*B22)*a*b - (B00*B02 + B10*B12 + B20*B22)*b**2 - \\\n                   ((B01**2 + B11**2 + B21**2)*a - (B00*B01 + B10*B11 + B20*B21)*b)*c)*l + \\\n                  sqrt(-(B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                         2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*d**2 + \\\n                         2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                             (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                             ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                             (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                              (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                              ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b + \\\n                             (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                              2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c)*d*l - \\\n                         ((B02**2*B11**2 - 2*B01*B02*B11*B12 + B01**2*B12**2 + (B02**2 + B12**2)*B21**2 - \\\n                           2*(B01*B02 + B11*B12)*B21*B22 + (B01**2 + B11**2)*B22**2)*a**2 - \\\n                           2*(B02**2*B10*B11 + B00*B01*B12**2 + (B02**2 + B12**2)*B20*B21 + \\\n                              (B00*B01 + B10*B11)*B22**2 - (B01*B02*B10 + B00*B02*B11)*B12 - \\\n                              ((B01*B02 + B11*B12)*B20 + (B00*B02 + B10*B12)*B21)*B22)*a*b + \\\n                           (B02**2*B10**2 - 2*B00*B02*B10*B12 + B00**2*B12**2 + (B02**2 + B12**2)*B20**2 - \\\n                            2*(B00*B02 + B10*B12)*B20*B22 + (B00**2 + B10**2)*B22**2)*b**2 + \\\n                           (B01**2*B10**2 - 2*B00*B01*B10*B11 + B00**2*B11**2 + (B01**2 + B11**2)*B20**2 - \\\n                            2*(B00*B01 + B10*B11)*B20*B21 + (B00**2 + B10**2)*B21**2)*c**2 + \\\n                           2*((B01*B02*B10*B11 - B00*B02*B11**2 + (B01*B02 + B11*B12)*B20*B21 - \\\n                               (B00*B02 + B10*B12)*B21**2 - (B01**2*B10 - B00*B01*B11)*B12 - \\\n                               ((B01**2 + B11**2)*B20 - (B00*B01 + B10*B11)*B21)*B22)*a - \\\n                               (B01*B02*B10**2 - B00*B02*B10*B11 + (B01*B02 + B11*B12)*B20**2 - \\\n                                (B00*B02 + B10*B12)*B20*B21 - (B00*B01*B10 - B00**2*B11)*B12 - \\\n                                ((B00*B01 + B10*B11)*B20 - (B00**2 + B10**2)*B21)*B22)*b)*c)*l**2 + \\\n                         ((B01**2 + B11**2 + B21**2)*a**2 - 2*(B00*B01 + B10*B11 + B20*B21)*a*b + \\\n                          (B00**2 + B10**2 + B20**2)*b**2)*qval)*b)/((B01**2 + B11**2 + B21**2)*a**2 - \\\n                                                                     2*(B00*B01 + B10*B11 + B20*B21)*a*b + (B00**2 + B10**2 + B20**2)*b**2)\n            k1 = (d - a * h1 - c * l) / b\n            k2 = (d - a * h2 - c * l) / b\n            return [(h1, k1 ,l), (h2, k2, l)]\n        except ValueError:\n            raise DiffcalcException(""Couldn\'t find solution for l=%f with the given hkl constraints"" % l)\n    else:\n        raise DiffcalcException(""Value of l is fixed to a constant by the constraint on hkl"")\n'"
diffcmd/__init__.py,0,b''
diffcmd/diffcalc_launcher.py,0,"b'#!/usr/bin/python\n\nimport argparse\nimport subprocess\nimport os\nimport getpass\n\nDIFFCALC_BIN = os.path.split(os.path.realpath(__file__))[0]\nDIFFCALC_ROOT = os.path.abspath(os.path.join(DIFFCALC_BIN, os.pardir))\n\nMODULE_FOR_MANUALS = \'_make_sixcircle_manual\'\n\ndef main():\n    parser = argparse.ArgumentParser(description=\'Diffcalc: A diffraction condition calculator of x-ray and neutron crystalography\')\n    parser.add_argument(\'--modules\', dest=\'show_modules\', action=\'store_true\',\n                        help=\'list available modules\')\n    parser.add_argument(\'--python\', dest=\'use_python\', action=\'store_true\',\n                        help=\'run within python rather than ipython\')\n    parser.add_argument(\'--debug\', dest=\'debug\', action=\'store_true\',\n                        help=\'run in debug mode\')\n    parser.add_argument(\'--make-manuals-source\', dest=\'make_manuals\', action=\'store_true\',\n                        help=\'make .rst manual files by running template through sixcircle\')\n    parser.add_argument(\'--non-interactive\', dest=\'non_interactive\', action=\'store_true\',\n                        help=\'do not enter interactive mode after startup\')\n    parser.add_argument(\'module\', type=str, nargs=\'?\',\n                        help=\'the module to startup with\')\n    args = parser.parse_args()\n    \n    # Create list of available modules\n    module_names = []\n    for module_path in os.listdir(os.path.join(DIFFCALC_ROOT, \'startup\')):\n        if not module_path.startswith(\'_\') and module_path.endswith(\'.py\'):\n            module_names.append(module_path.split(\'.\')[0])\n    module_names.sort()\n    \n    if args.show_modules:\n        print_available_modules(module_names)\n        exit(0)      \n    \n    if not args.make_manuals and not args.module:   \n        print ""A module name should be provided. Choose one of:""\n        print_available_modules(module_names)\n        exit(0)\n        \n    if args.make_manuals:\n        if args.module:\n            print ""When building the manuals no module should be given""\n            exit(1)\n        args.module = MODULE_FOR_MANUALS\n        \n    if not args.make_manuals and args.module not in module_names:\n        print ""The provided argument \'%s\' is not one of:"" % args.module\n        print_available_modules(module_names)\n        exit(1)\n    \n    env = os.environ.copy()\n    \n    if \'PYTHONPATH\' not in env:\n        env[\'PYTHONPATH\'] = \'\'\n    env[\'PYTHONPATH\'] = DIFFCALC_ROOT + \':\' + env[\'PYTHONPATH\']\n    \n    diffcmd_start_path = os.path.join(DIFFCALC_ROOT, \'diffcmd\', \'start.py\')\n    \n    if args.use_python:\n        cmd = \'python\'\n    else:  # ipython\n        cmd = \'ipython --no-banner --HistoryManager.hist_file=/tmp/ipython_hist_%s.sqlite\' % getpass.getuser()\n    \n    iflag = \'\' if args.non_interactive else \'-i\'    \n    cmd = cmd + \' \' + \' \'.join([iflag, diffcmd_start_path, args.module, str(args.debug)])\n   \n    print \'Running: \' + cmd\n    rc = subprocess.call(cmd, env=env, shell=True)\n    exit(rc)\n\n \ndef print_available_modules(module_names):           \n    lines = []\n    for m in sorted(module_names):\n        lines.append(\'   \' + m)\n    print \'\\n\'.join(lines)\n\n\nif __name__ == \'__main__\':\n    main()\n# \n'"
diffcmd/diffcmd_utils.py,0,"b'#\n# General utility functions to handle Diffcalc commands\n#\n\nfrom gda.jython.commands.GeneralCommands import alias\n\ntry:\n    import gda\n    GDA = True  \nexcept ImportError:\n    GDA = False\n\n\n\ndef alias_commands(global_namespace_dict):\n    """"""Alias commands left in global_namespace_dict by previous import from\n    diffcalc.\n\n    This is the equivalent of diffcmd/ipython/magic_commands() for use\n    when IPython is not available\n    """"""\n    gnd = global_namespace_dict\n    global GLOBAL_NAMESPACE_DICT\n    GLOBAL_NAMESPACE_DICT = gnd\n    print ""Aliasing commands""\n    \n    ### Alias commands in namespace ###\n    commands = gnd[\'hkl_commands_for_help\']\n    commands += gnd[\'ub_commands_for_help\']\n    if not GDA:  # TODO: encapsulation issue: this should be done outside this function!\n        commands.append(gnd[\'pos\'])\n        commands.append(gnd[\'scan\'])\n    aliased_names = []\n\n    for f in commands:\n        # Skip section headers like \'Motion\'\n        if not hasattr(f, \'__call__\'):\n            continue\n        \n        alias(f.__name__)\n        aliased_names.append(f.__name__)\n\n    print ""Aliased commands: "" + \' \'.join(aliased_names) \n'"
diffcmd/ipython.py,0,"b'import re\nfrom functools import wraps\nfrom IPython.core.magic import register_line_magic\nfrom IPython import get_ipython  # @UnusedImport (used by register_line_magic)\nfrom diffcalc.gdasupport.scannable.hkl import Hkl\n\n""""""\nFor wrapping functions:\n\n    In [1]: import diffcmd.ipython\n    \n    In [2]: diffcmd.ipython.GLOBAL_NAMESPACE_DICT = globals()\n    \n    In [3]: from IPython.core.magic import register_line_magic\n    \n    In [4]: from diffcmd.ipython import parse_line\n    \n    In [5]: @register_line_magic\n       ...: @parse_line\n       ...: def check_parser(*args):\n       ...:         return args\n       ...: \n    \n    In [6]: check_parser\n    Out[6]: <function __main__.check_parser>\n    \n    In [7]: del check_parser\n    \n    In [8]: check_parser\n    Out[8]: ()\n    \n    In [9]: check_parser 1\n    Out[9]: (1,)\n    \n    In [10]: check_parser 1 2\n    Out[10]: (1, 2)\n    \n    In [11]: check_parser 1 2 [3]\n    Out[11]: (1, 2, [3])\n    \n    In [12]: b=\'bbb\'\n    \n    In [13]: check_parser 1 2 [3] b\n    Out[13]: (1, 2, [3], \'bbb\')\n\n\nAnd to create something dynamically from a function:\n\n    In [28]: def f(a, b, c):\n       ....:        ....:     return a, b, c\n       ....: \n    \n    In [29]: register_line_magic(parse_line(f))\n    Out[29]: <function __main__.f>\n    \n    In [30]: del f\n    \n    In [31]: f \'a\' -2 [1 3 -4]\n    Out[31]: (\'a\', -2, [1, 3, -4])\n\nAnd from a list of functions:\n\n    In [32]: def one(a):\n       ....:     return a\n       ....: \n    \n    In [33]: def two(a, b):\n       ....:     return a, b\n       ....: \n    \n    In [34]: functions = one, two\n    \n    In [35]: del one, two\n    \n    In [36]: for f in functions:\n       ....:     register_line_magic(parse_line(f))\n       ....:     \n    \n    In [37]: one 1\n    Out[37]: 1\n\n    In [39]: two 1 2\n    Out[39]: (1, 2)\n\nAnd to check if we are running in iPython:\n\n    In [47]: \'get_ipython\' in globals()\n    Out[47]: True\n\ndef in_ipython():\n     try:\n         get_ipython()\n         return True\n     except NameError:\n         return False\n\n\n""""""\n\n\nGLOBAL_NAMESPACE_DICT = {}\n\nMATH_OPERATORS = set([\'-\', \'+\', \'/\', \'*\'])\n\n# Keep a copy of python\'s original help as we may remove it later\nif \'help\' in __builtins__:   \n    ORIGINAL_PYTHON_HELP = __builtins__[\'help\']\n\n\nCOMMA_USAGE_HELP = \\\n\'\'\'\n|   When calling a function without brackets, whitespace must be used in\n|   place of commas. For example:\n|   \n|      >>> function a b [1 2 3] \'c\'\n|      \n|   is equivalent to:\n|   \n|      >>> function(a, b, [1, 2, 3], \'c\')\n|      \n\'\'\'\n\n\nMATH_OPERATOR_USAGE_HELP = \\\n\'\'\'\n|    When calling a function without brackets, whitespace is used in place of\n|    commas. Therefore terms which require evaluation must contain no space.\n|    These will fail for example:\n|\n|      >>> function - 1\n|      >>> function a() * 2\n\n|    But this\n\n|       >>> function -1 1-1 +1 a()+1 [-1 0+1 b()] c+1\n|        \n|    is okay and equivalent to:\n|    \n|       >>> function(-1, 0, 1, a() + 1, [-1, 1, b()], c + 1)\n|       \n      \n\'\'\'\n\ncomma_finder = re.compile(r\'\'\'((?:[^,""\']|""[^""]*""|\'[^\']*\')+)\'\'\')\nspace_finder = re.compile(r\'\'\'((?:[^ ""\']|""[^""]*""|\'[^\']*\')+)\'\'\')\nhash_finder = re.compile(r\'\'\'((?:[^#""\']|""[^""]*""|\'[^\']*\')+)\'\'\')\nopen_square_finder = re.compile(r\'\'\'((?:[^[""\']|""[^""]*""|\'[^\']*\')+)\'\'\')\nclose_square_finder = re.compile(r\'\'\'((?:[^]""\']|""[^""]*""|\'[^\']*\')+)\'\'\')\n\ndef tokenify(s):\n    \n    # Don\'t accept commas outside strings.\n    # Users are frustrated by not knowing when commas _are_ required.\n    # Making it clear when they are not helps them understand the\n    # difference.\n\n    if \',\' in comma_finder.split(s):\n        print COMMA_USAGE_HELP\n        print ""(string was: %s)"" % s\n        raise SyntaxError(\'unexpected comma\')\n    \n    # ignore comment  \n    hash_split = hash_finder.split(s)\n    if \'#\' in hash_split:\n        s = \'\' if hash_split[0] == \'#\' else hash_split[1]\n    \n    # surround square brackets with spaces to simplify token extraction\n    s = \'\'.join(\' [ \' if e == \'[\' else e for e in open_square_finder.split(s))\n    s = \'\'.join(\' ] \' if e == \']\' else e for e in close_square_finder.split(s))\n    \n    \n    # tokens are now separated by spaces\n    \n    tokens = space_finder.split(s)[1::2]\n    tokens = [tok for tok in tokens if tok != \'\']\n    return tokens\n\n\ndef parse(s, d):\n    s = str(s)\n    tokens = tokenify(s)\n    for tok in tokens:\n        if tok in MATH_OPERATORS:\n            print MATH_OPERATOR_USAGE_HELP\n            raise SyntaxError(\'could not evaluate: ""%s""\' % tok)\n    \n    \n    s = \', \'.join(tokens)\n\n    s = s.replace(\'[, \', \'[\')\n    s = s.replace(\',]\', \']\')\n    s = s.replace(\', ]\', \']\')\n    \n    try:\n        args = eval(\'[\' + s + \']\', d)\n    except SyntaxError:\n        raise SyntaxError(\'could not evaluate: ""%s""\' % s)\n    return args\n\ndef parse_line(f, global_namespace_dict=None):\n    \'\'\'A decorator that parses a single string argument into a list of arguments\n    and calls the wrapped function with these.\n    \'\'\'\n    if not global_namespace_dict:\n        global_namespace_dict = GLOBAL_NAMESPACE_DICT\n    @wraps(f)\n    def wrapper(line):\n        args = parse(line, global_namespace_dict)\n        return f(*args)\n    return wrapper\n\n\n\n_DEFAULT_HELP = \\\n""""""\nFor help with diffcalc\'s orientation phase try:\n    \n    >>> help ub\n    \nFor help with moving in reciprocal lattice space try:\n\n    >>> help hkl\n    \nFor more detailed help try for example:\n\n    >>> help newub\n    \nFor help with driving axes or scanning:\n\n    >>> help pos\n    >>> help scan\n    \nFor help with regular python try for example:\n\n    >>> help list\n    \nFor more detailed help with diffcalc go to:\n\n    https://diffcalc.readthedocs.io\n    \n""""""\n\ndef magic_commands(global_namespace_dict):\n    """"""Magic commands left in global_namespace_dict by previous import from\n    diffcalc.\n    \n    Also creates a help command. NOTE that calling this will\n    remove the original commands from the global namespace as otherwise these\n    would shadow the ipython magiced versions.\n    \n    Depends on hkl_commands_for_help & ub_commands_for_help list having been\n    left in the global namespace and assumes there is pos and scan command.\n    """"""\n    gnd = global_namespace_dict\n    global GLOBAL_NAMESPACE_DICT\n    GLOBAL_NAMESPACE_DICT = gnd\n    \n    ### Magic commands in namespace ###\n    commands = list(gnd[\'hkl_commands_for_help\'])\n    commands += gnd[\'ub_commands_for_help\']\n    commands.append(gnd[\'pos\'])\n    commands.append(gnd[\'scan\'])\n    command_map = {}\n    for f in commands:\n        # Skip section headers like \'Motion\'\n        if not hasattr(f, \'__call__\'):\n            continue\n        # magic the function and remove from namespace (otherwise it would\n        # shadow the magiced command)\n        register_line_magic(parse_line(f, gnd))\n        del gnd[f.__name__]\n        command_map[f.__name__] = f\n\n    ### Create help function ###\n    #Expects python\'s original help to be named pythons_help and to be\n    #available in the top-level global namespace (where non-diffcalc\n    #objects may have help called from).        \n    def help(s):  # @ReservedAssignment   \n        """"""Diffcalc help for iPython\n        """"""\n        if s == \'\':\n            print _DEFAULT_HELP\n        elif s == \'hkl\':\n            # Use help injected into hkl object\n            print Hkl.dynamic_docstring\n        elif s == \'ub\':\n            # Use help injected into ub command\n            print command_map[\'ub\'].__doc__\n        elif s in command_map:\n            print ""%s (diffcalc command):"" %s\n            print command_map[s].__doc__\n        else:\n            exec(\'pythons_help(%s)\' %s, gnd)\n\n      \n    ### Setup help command ###\n    gnd[\'pythons_help\'] = ORIGINAL_PYTHON_HELP  \n    register_line_magic(help)\n    # Remove builtin help\n    # (otherwise it would shadow magiced command\n    if \'help\' in __builtins__:   \n        del __builtins__[\'help\']\n'"
diffcmd/ipythonmagic.py,0,"b'\nimport diffcmd.ipython\nfrom IPython.core.magic import register_line_magic\nfrom diffcmd.ipython import parse_line\n\ncommand_map = {}\n    \n_DEFAULT_HELP = """"""\nFor help with diffcalc\'s orientation phase try:\n    \n    >>> help ub\n    \nFor help with moving in reciprocal lattice space try:\n\n    >>> help hkl\n    \nFor more detailed help try for example:\n\n    >>> help newub\n    \nFor help with driving axes or scanning:\n\n    >>> help pos\n    >>> help scan\n    \nFor help with regular python try for example:\n\n    >>> help list\n    \nFor more detailed help with diffcalc go to:\n\n    https://diffcalc.readthedocs.io\n    \n""""""\n\n# This function should be called with parameter globals()\ndef define_commands(dictionary):\n    print ""Ipython detected - magicing commands""\n    magiced_names = []\n    commands = hkl_commands_for_help + ub_commands_for_help  # @UndefinedVariable\n    commands += [pos, scan]  # @UndefinedVariable\n    ipython.GLOBAL_NAMESPACE_DICT = dictionary\n    for f in commands:\n        # Skip section headers like \'Motion\'\n        if not hasattr(f, \'__call__\'):\n            continue\n        \n        # magic the function and remove from namespace (otherwise it would\n        # shadow the magiced command)\n        register_line_magic(parse_line(f))\n        del dictionary[f.__name__]\n        command_map[f.__name__] = f\n        magiced_names.append(f.__name__)\n    \n    print ""Magiced commands: "" + \' \'.join(magiced_names) \n    \n    # because the functions have gone from namespace we need to override\n    pythons_help = __builtins__.help\n    del __builtins__.help\n    \n    register_line_magic(help)\n    del help\n\ndef help(s):\n    """"""Diffcalc help for iPython\n    """"""\n    if s == \'\':\n        print _DEFAULT_HELP\n    elif s == \'hkl\':\n        # Use help injected into hkl object\n        print hkl.__doc__\n    elif s == \'ub\':\n        # Use help injected into ub command\n        print command_map[\'ub\'].__doc__\n    elif s in command_map:\n        print ""%s (diffcalc command):"" %s\n        print command_map[s].__doc__\n    else:\n        exec(\'pythons_help(%s)\' %s)\n'"
diffcmd/make_manual.py,0,"b'\n\nfrom StringIO import StringIO\nfrom IPython import get_ipython\nimport sys\nfrom diffcalc.dc.help import format_commands_for_rst_table\n\n\nTEST_INPUT=""""""\nDiffcalc\'s Scannables\n=====================\n\nPlease see :ref:`moving-in-hkl-space` and :ref:`scanning-in-hkl-space` for some relevant examples.\n\nTo list and show the current positions of your beamline\'s scannables\nuse ``pos`` with no arguments::\n     \n   >>> pos wl\n   \nshould do nought, but this should be replaced::\n\n   ==> pos wl 2  \n   \nshould do the thing\n\n   ==> abcd\n""""""\n\n\n\ndef echorun(magic_cmd):\n    print ""\\n>>> "" + str(magic_cmd)\n     \n\n    \ndef make_manual(input_file_path,\n                output_file_path,\n                ub_commands_for_help,\n                hkl_commands_for_help):\n    \n    # Read input file (should be .rst file)\n    with open(input_file_path, \'r\') as f:\n        input_string = f.read()\n    \n    # Parse input string\n    output_lines = []\n    for lineno, line in enumerate(input_string.split(\'\\n\')):\n        process = \'==>\' in line\n            \n        if process and \'STOP\' in line:\n            print ""\'==> STOP\' found on line. STOPPING"", lineno + 1\n            return\n        \n        elif process and \'UB_HELP_TABLE\' in line:\n            print \'Creating UB help table\'\n            output_lines_from_line = format_commands_for_rst_table(\n                \'\', ub_commands_for_help)\n            \n        elif process and \'HKL_HELP_TABLE\' in line:\n            print \'Creating HKL help table\'\n            output_lines_from_line = format_commands_for_rst_table(\n                \'\', hkl_commands_for_help)\n                \n        else:\n            output_lines_from_line = parse_line(\n                line, lineno + 1, input_file_path)\n\n#         print \'\\n\'.join(output_lines_from_line)\n        output_lines.extend(output_lines_from_line)\n    \n    # Write output file\n    if output_file_path:\n        with open(output_file_path, \'w\') as f:\n            f.write(\'\\n\'.join(output_lines))\n        print ""Wrote file:"", output_file_path\n#     try:\n#         if output_file_path:\n#             orig_stdout = sys.stdout\n#             f = file(output_file_path, \'w\')\n#             sys.stdout = f\n#         \n#         \n#     \n#     finally:\n#         if output_file_path:\n#             sys.stdout = orig_stdout\n#             f.close()\n\n \ndef parse_line(linein, lineno, filepath):\n    output_lines = []\n    if \'==>\' in linein:\n        pre, cmd = linein.split(\'==>\')\n        _check_spaces_only(pre, lineno, filepath)\n        cmd = cmd.strip()  # strip whitespace\n        output_lines.append(pre + "">>> "" + cmd)\n        result_lines = _capture_magic_command_output(cmd, lineno, filepath)\n\n        \n        # append to output    \n        for line in result_lines:\n            output_lines.append(pre + line)\n    else:\n        output_lines.append(linein)\n    return output_lines\n\n    \ndef _check_spaces_only(s, lineno, filepath):\n    for c in s:\n        if c != \' \':\n            raise Exception(\'Error on line %i of %s :\\n text proceeding --> must be \'\n                            \'spaces only\' % (lineno, filepath))\n            \ndef _capture_magic_command_output(magic_cmd, lineno, filepath):\n    orig_stdout = sys.stdout\n    result = StringIO()\n    sys.stdout = result\n    \n    def log_error():\n        msg = ""Error on line %i of %s evaluating \'%s\'"" % (lineno, filepath, magic_cmd)\n        sys.stderr.write(\'\\n\' + \'=\' * 79 + \'\\n\' + msg + \'\\n\' +\'v\' * 79 + \'\\n\')\n        return msg\n    \n    try:\n        line_magics = get_ipython().magics_manager.magics[\'line\']\n        magic = magic_cmd.split(\' \')[0]\n        if magic not in line_magics:\n            msg = log_error()\n            raise Exception(msg + "" (\'%s\' is not a magic command)"" % magic)           \n        get_ipython().magic(magic_cmd)\n    except:\n        log_error()\n        raise\n    finally:\n        sys.stdout = orig_stdout\n\n    result_lines = result.getvalue().split(\'\\n\')\n        \n    # trim trailing lines which are whitespace only\n    while result_lines and (result_lines[-1].isspace() or not result_lines[-1]):\n        result_lines.pop()\n        \n    return result_lines\n    \n\n    '"
diffcmd/start.py,0,"b'""""""\nstart the diffcmd environemt using a script from startup.\nThis should normally be run by the main diffcalc.py program.\n\nwith diffcalc on PYTHONPATH\n$ ipython -i -m diffcm.diffcmd module_name_string debug_bool\n""""""\nfrom __future__ import absolute_import\n\nimport diffcalc\nimport diffcalc.settings\nimport os\nimport sys\nfrom diffcalc.ub.persistence import UBCalculationJSONPersister\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder\nfrom diffcalc.util import bold\nimport diffcalc.util\nimport diffcalc.gdasupport.minigda.command\nDIFFCALC_ROOT = os.path.realpath(diffcalc.__file__).split(\'diffcalc/__init__.py\')[0]\n\ntry:\n    __IPYTHON__  # @UndefinedVariable\n    IPYTHON = True\nexcept NameError:\n    IPYTHON = False\n\n\nmodule_name = sys.argv[1] #3 if IPYTHON else 1]\ndebug = sys.argv[2] == \'True\' #4 if IPYTHON else 2])\n\nprint\nprint bold(\'-\' * 34 + \' DIFFCALC \' + \'-\' * 35)\n\n# configure persisentence\nDIFFCALC_VAR = os.path.join(os.path.expanduser(\'~\'), \'.diffcalc\', module_name)\nif not os.path.exists(DIFFCALC_VAR):\n    print ""Making diffcalc var folder:\'%s\'"" % DIFFCALC_VAR\n    os.makedirs(DIFFCALC_VAR)\ndiffcalc.settings.ubcalc_persister = UBCalculationJSONPersister(DIFFCALC_VAR, UBCalcStateEncoder)\n\n# configure debug\ndiffcalc.util.DEBUG = debug\nif debug:\n    print ""WARNING: debug mode on; help for command syntax errors disabled.""\n\n# import script\nscript = os.path.join(DIFFCALC_ROOT, \'startup\', module_name) + \'.py\'\n\nprint ""Startup script: \'%s\'"" % script    \nnamespace = {}\nexecfile(script, namespace)\nglobals().update(namespace)\ndiffcalc.gdasupport.minigda.command.ROOT_NAMESPACE_DICT = dict(namespace)\nprint bold(\'-\' * 36 + \' Help \' + \'-\' * 37)\nprint HELP_STRING  # @UndefinedVariable\nif \'LOCAL_MANUAL\' in locals():\n    print ""Local:  "" + LOCAL_MANUAL  # @UndefinedVariable\nprint bold(\'-\' * 79)\nprint\n\n\n# magic commands if IPython\nif IPYTHON:\n    from diffcmd.ipython import magic_commands\n    magic_commands(globals())\n\n    \nif \'MANUALS_TO_MAKE\' in locals():\n    summary_lines = [\'Made manuals:\']\n    from diffcmd.make_manual import make_manual\n    for source_path in MANUALS_TO_MAKE:  # @UndefinedVariable\n        import diffcalc.ub.ub\n        try:\n            diffcalc.ub.ub.rmub(\'example\')\n        except KeyError:\n            pass\n        target_path = source_path.replace(\'_template\', \'\')\n        print \'@\' * 79\n        print ""Making manual""\n        print ""    Source:"", source_path\n        print ""    Target:"", target_path\n        \n        make_manual(source_path, target_path,\n                    ub_commands_for_help,  # @UndefinedVariable\n                    hkl_commands_for_help)  # @UndefinedVariable\n        summary_lines.append(\' - \' + source_path + \' -- > \' + target_path)\n    print \'\\n\'.join(summary_lines)\n    '"
model/vrml_animator.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport sys\nimport time\nimport threading\nfrom math import pi\nimport socket\n\nfrom pivy.coin import *\nfrom pivy.sogui import *\n\n\nPORT = 4567\nTORAD = pi / 180\n\n\ndef connect_to_socket(host, port):\n    print ""Connecting to %s on port %d"" % (host, port)\n    connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    print ""Connected""\n    connection.connect((host, port))\n    socketfile = connection.makefile(\'rw\', 0)\n    return socketfile\n\n\ndef serve_socket_connection(port):\n    print (""Serving connection on all interfaces on %s port %d"" %\n           (socket.gethostname(), port))\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((socket.gethostname(), port))\n    sock.listen(1)\n    time.sleep(1)\n    (connection, addr) = sock.accept()\n    print \'Connected from \', addr, \' accepted\'\n    socket_file = connection.makefile(\'rw\', 0)  # no buffering\n    return socket_file\n\n\ndef node_name(anglename):\n    return \'dad_\' + anglename + \'_frame\'\n\n\nclass SceneUpdatingThread(threading.Thread):\n\n    def __init__(self, scene, axisnames):\n        threading.Thread.__init__(self)\n        self.scene = scene\n\n        # Infer rotation axes based on initial orientation\n        self.rotation_axes = {}\n        self.axies_nodes = {}\n        for axisname in axisnames:\n            node = self.scene.getByName(node_name(axisname))\n            self.axies_nodes[axisname] = node\n            value = node.rotation.getValue()\n            self.rotation_axes[axisname] = value.getAxisAngle()[0]\n\n    def run(self):\n        socket_file = serve_socket_connection(PORT)\n\n        while True:\n            msg = socket_file.readline()\n            if msg == \'\':\n                print \'***Socket closed\'\n                socket_file = serve_socket_connection(PORT)\n                continue\n            print msg.strip()\n            d = eval(msg.strip())  # msg should be a dictionary representation\n            for axisname in d:\n                self.set_axis_rotation(axisname, d[axisname])\n\n    def set_axis_rotation(self, anglename, degrees):\n        nodename = node_name(anglename)\n        angle = degrees * TORAD\n        while angle < 0:\n            angle = 2 * pi + angle\n        node = self.scene.getByName(nodename)\n        getattr(node, \'rotation\').setValue(\n            self.rotation_axes[anglename], angle)\n\n\nclass Animator(object):\n\n    def __init__(self, filename, axisnames):\n        print ""filename : "" + filename\n        print ""    axes : "" + \' \'.join(axisnames)\n        # Create viewer\n        self.myWindow = SoGui.init(sys.argv[0])  # @UndefinedVariable\n        if self.myWindow is None: sys.exit(1)\n        viewer = SoGuiExaminerViewer(self.myWindow)  # @UndefinedVariable\n        # load file into scene\n        so_input = SoInput()  # @UndefinedVariable\n        so_input.openFile(filename)\n        self.scene = SoDB.readAll(so_input)  # @UndefinedVariable\n        # Add scene to viewer\n        viewer.setSceneGraph(self.scene)\n        viewer.setTitle(\' \'.join(axisnames))\n        viewer.show()\n\n        self.start_update_scene_thread(axisnames)\n\n    def start_update_scene_thread(self, axisnames):\n        t = SceneUpdatingThread(self.scene, axisnames)\n        t.setDaemon(True)\n        t.start()\n\n    def show(self):\n        SoGui.show(self.myWindow)  # @UndefinedVariable\n        SoGui.mainLoop()  # @UndefinedVariable\n\ndef main():\n    animator = Animator(sys.argv[1], sys.argv[2:])\n    animator.show()\n\nif __name__ == ""__main__"":\n    main()\n\n'"
numjy/__init__.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    import Jama\n    from numjy import linalg\n    from numjy.jama_matrix_wrapper import matrix\n    JAMA = True\nexcept ImportError:\n    JAMA = False\n\n\ndef hstack(list_of_column_matrices):\n    if not Jama:\n        raise Exception('Jama not available, use numpy directly')\n    ncol = len(list_of_column_matrices)\n    nrow = list_of_column_matrices[0].shape[0]\n    m = Jama.Matrix(nrow, ncol)\n    for c, column_matrix in enumerate(list_of_column_matrices):\n        m.setMatrix(0, nrow - 1, c, c, column_matrix.m)\n    return matrix(m)\n"""
numjy/jama_matrix_wrapper.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport Jama\n\n\nclass matrix(object):\n\n    def __init__(self, a):\n        if isinstance(a, Jama.Matrix):\n            self.m = a\n        elif isinstance(a, basestring):\n            l = []\n            for row in a.strip().split(';'):\n                l.append([float(element)\n                          for element in row.replace(',', ' ').split()])\n            self.m = Jama.Matrix(l)\n        elif isinstance(a, matrix):\n            self.m = Jama.Matrix(a.tolist())\n        elif isinstance(a, (list, tuple)):\n            if isinstance(a[0], (list, tuple)):\n                # a is a list of lists (not rigorous test!)\n                self.m = Jama.Matrix(a)\n            else:\n                # a is a row vector\n                self.m = Jama.Matrix([a])\n        else:\n            # give it a go\n            self.m = Jama.Matrix(a)\n\n    def __eq__(self, other):\n        nrow, ncol = self.shape\n        b = matrix(Jama.Matrix(nrow, ncol))\n        for i in range(nrow):\n            for j in range(ncol):\n                b[i, j] = self[i, j] == other[i, j]\n        return b\n\n    @property\n    def shape(self):\n        return self.m.getRowDimension(), self.m.getColumnDimension()\n\n    def __len__(self):\n        return self.m.getRowDimension()\n\n    def all(self):  # @ReservedAssignment\n        for row in self.m.array:\n            if not all(row):\n                return False\n        return True\n\n    def tolist(self):\n        l = []\n        nrow, ncol = self.shape\n        for i in range(nrow):\n            row = []\n            for j in range(ncol):\n                row.append(self[i, j])\n            l.append(row)\n        return l\n\n    def sum(self):  # @ReservedAssignment\n        return sum(sum(row) for row in self.m.array)\n\n    @property\n    def I(self):\n        return matrix(self.m.inverse())\n\n    @property\n    def T(self):\n        return matrix(self.m.transpose())\n\n    def _scaler(self, scaler):\n        return Jama.Matrix(self.shape[0], self.shape[1], scaler)\n\n    def __add__(self, other):\n        v = other.m if isinstance(other, matrix) else self._scaler(other)\n        return matrix(self.m.plus(v))\n\n    def __sub__(self, other):\n        v = other.m if isinstance(other, matrix) else self._scaler(other)\n        return matrix(self.m.minus(v))\n\n    def __mul__(self, other):\n        return matrix(self.m.times(other.m if isinstance(other, matrix) else\n                                   other))\n\n    def __div__(self, other):\n        # dividend = other.I if isinstance(other, matrix) else 1. /float(other)\n        return self.__mul__(1. / float(other))\n\n    def __getitem__(self, key):\n        i, j = key\n        return self.m.get(i, j)\n\n    def __setitem__(self, key, value):\n        i, j = key\n        self.m.set(i, j, value)\n\n    def __str__(self):\n        insides = ['  '.join([str(el) for el in row]) for row in self.tolist()]\n        return '[[' + ']\\n ['.join(insides) + ']]'\n\n    def __repr__(self):\n        return 'matrix(' + '\\n       '.join(self.__str__().split('\\n')) + ')'\n"""
numjy/linalg.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ndef norm(mat):\n    return mat.m.normF()\n'"
simplejson/__init__.py,0,"b'r""""""JSON (JavaScript Object Notation) <http://json.org> is a subset of\nJavaScript syntax (ECMA-262 3rd edition) used as a lightweight data\ninterchange format.\n\n:mod:`simplejson` exposes an API familiar to users of the standard library\n:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained\nversion of the :mod:`json` library contained in Python 2.6, but maintains\ncompatibility with Python 2.4 and Python 2.5 and (currently) has\nsignificant performance advantages, even without using the optional C\nextension for speedups.\n\nEncoding basic Python object hierarchies::\n\n    >>> import simplejson as json\n    >>> json.dumps([\'foo\', {\'bar\': (\'baz\', None, 1.0, 2)}])\n    \'[""foo"", {""bar"": [""baz"", null, 1.0, 2]}]\'\n    >>> print json.dumps(""\\""foo\\bar"")\n    ""\\""foo\\bar""\n    >>> print json.dumps(u\'\\u1234\')\n    ""\\u1234""\n    >>> print json.dumps(\'\\\\\')\n    ""\\\\""\n    >>> print json.dumps({""c"": 0, ""b"": 0, ""a"": 0}, sort_keys=True)\n    {""a"": 0, ""b"": 0, ""c"": 0}\n    >>> from StringIO import StringIO\n    >>> io = StringIO()\n    >>> json.dump([\'streaming API\'], io)\n    >>> io.getvalue()\n    \'[""streaming API""]\'\n\nCompact encoding::\n\n    >>> import simplejson as json\n    >>> json.dumps([1,2,3,{\'4\': 5, \'6\': 7}], separators=(\',\',\':\'))\n    \'[1,2,3,{""4"":5,""6"":7}]\'\n\nPretty printing::\n\n    >>> import simplejson as json\n    >>> s = json.dumps({\'4\': 5, \'6\': 7}, sort_keys=True, indent=\'    \')\n    >>> print \'\\n\'.join([l.rstrip() for l in  s.splitlines()])\n    {\n        ""4"": 5,\n        ""6"": 7\n    }\n\nDecoding JSON::\n\n    >>> import simplejson as json\n    >>> obj = [u\'foo\', {u\'bar\': [u\'baz\', None, 1.0, 2]}]\n    >>> json.loads(\'[""foo"", {""bar"":[""baz"", null, 1.0, 2]}]\') == obj\n    True\n    >>> json.loads(\'""\\\\""foo\\\\bar""\') == u\'""foo\\x08ar\'\n    True\n    >>> from StringIO import StringIO\n    >>> io = StringIO(\'[""streaming API""]\')\n    >>> json.load(io)[0] == \'streaming API\'\n    True\n\nSpecializing JSON object decoding::\n\n    >>> import simplejson as json\n    >>> def as_complex(dct):\n    ...     if \'__complex__\' in dct:\n    ...         return complex(dct[\'real\'], dct[\'imag\'])\n    ...     return dct\n    ...\n    >>> json.loads(\'{""__complex__"": true, ""real"": 1, ""imag"": 2}\',\n    ...     object_hook=as_complex)\n    (1+2j)\n    >>> from decimal import Decimal\n    >>> json.loads(\'1.1\', parse_float=Decimal) == Decimal(\'1.1\')\n    True\n\nSpecializing JSON object encoding::\n\n    >>> import simplejson as json\n    >>> def encode_complex(obj):\n    ...     if isinstance(obj, complex):\n    ...         return [obj.real, obj.imag]\n    ...     raise TypeError(repr(o) + "" is not JSON serializable"")\n    ...\n    >>> json.dumps(2 + 1j, default=encode_complex)\n    \'[2.0, 1.0]\'\n    >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)\n    \'[2.0, 1.0]\'\n    >>> \'\'.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))\n    \'[2.0, 1.0]\'\n\n\nUsing simplejson.tool from the shell to validate and pretty-print::\n\n    $ echo \'{""json"":""obj""}\' | python -m simplejson.tool\n    {\n        ""json"": ""obj""\n    }\n    $ echo \'{ 1.2:3.4}\' | python -m simplejson.tool\n    Expecting property name: line 1 column 2 (char 2)\n""""""\n__version__ = \'2.6.2\'\n__all__ = [\n    \'dump\', \'dumps\', \'load\', \'loads\',\n    \'JSONDecoder\', \'JSONDecodeError\', \'JSONEncoder\',\n    \'OrderedDict\', \'simple_first\',\n]\n\n__author__ = \'Bob Ippolito <bob@redivi.com>\'\n\nfrom decimal import Decimal\n\nfrom decoder import JSONDecoder, JSONDecodeError\nfrom encoder import JSONEncoder, JSONEncoderForHTML\ndef _import_OrderedDict():\n    import collections\n    try:\n        return collections.OrderedDict\n    except AttributeError:\n        import ordered_dict\n        return ordered_dict.OrderedDict\nOrderedDict = _import_OrderedDict()\n\ndef _import_c_make_encoder():\n    try:\n        from simplejson._speedups import make_encoder\n        return make_encoder\n    except ImportError:\n        return None\n\n_default_encoder = JSONEncoder(\n    skipkeys=False,\n    ensure_ascii=True,\n    check_circular=True,\n    allow_nan=True,\n    indent=None,\n    separators=None,\n    encoding=\'utf-8\',\n    default=None,\n    use_decimal=True,\n    namedtuple_as_object=True,\n    tuple_as_array=True,\n    bigint_as_string=False,\n    item_sort_key=None,\n)\n\ndef dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        encoding=\'utf-8\', default=None, use_decimal=True,\n        namedtuple_as_object=True, tuple_as_array=True,\n        bigint_as_string=False, sort_keys=False, item_sort_key=None,\n        **kw):\n    """"""Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n    will be skipped instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the some chunks written to ``fp``\n    may be ``unicode`` instances, subject to normal Python ``str`` to\n    ``unicode`` coercion rules. Unless ``fp.write()`` explicitly\n    understands ``unicode`` (as in ``codecs.getwriter()``) this is likely\n    to cause an error.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If *indent* is a string, then JSON array elements and object members\n    will be pretty-printed with a newline followed by that string repeated\n    for each level of nesting. ``None`` (the default) selects the most compact\n    representation without any newlines. For backwards compatibility with\n    versions of simplejson earlier than 2.1.0, an integer is also accepted\n    and is converted to a string with that many spaces.\n\n    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n    then it will be used instead of the default ``(\', \', \': \')`` separators.\n    ``(\',\', \':\')`` is the most compact JSON representation.\n\n    ``encoding`` is the character encoding for str instances, default is UTF-8.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *use_decimal* is true (default: ``True``) then decimal.Decimal\n    will be natively serialized to JSON with full precision.\n\n    If *namedtuple_as_object* is true (default: ``True``),\n    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded\n    as JSON objects.\n\n    If *tuple_as_array* is true (default: ``True``),\n    :class:`tuple` (and subclasses) will be encoded as JSON arrays.\n\n    If *bigint_as_string* is true (default: ``False``), ints 2**53 and higher\n    or lower than -2**53 will be encoded as strings. This is to avoid the\n    rounding that happens in Javascript otherwise. Note that this is still a\n    lossy operation that will not round-trip correctly and should be used\n    sparingly.\n\n    If specified, *item_sort_key* is a callable used to sort the items in\n    each dictionary. This is useful if you want to sort items other than\n    in alphabetical order by key. This option takes precedence over\n    *sort_keys*.\n\n    If *sort_keys* is true (default: ``False``), the output of dictionaries\n    will be sorted by item.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg.\n\n    """"""\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        encoding == \'utf-8\' and default is None and use_decimal\n        and namedtuple_as_object and tuple_as_array\n        and not bigint_as_string and not item_sort_key and not kw):\n        iterable = _default_encoder.iterencode(obj)\n    else:\n        if cls is None:\n            cls = JSONEncoder\n        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n            separators=separators, encoding=encoding,\n            default=default, use_decimal=use_decimal,\n            namedtuple_as_object=namedtuple_as_object,\n            tuple_as_array=tuple_as_array,\n            bigint_as_string=bigint_as_string,\n            sort_keys=sort_keys,\n            item_sort_key=item_sort_key,\n            **kw).iterencode(obj)\n    # could accelerate with writelines in some versions of Python, at\n    # a debuggability cost\n    for chunk in iterable:\n        fp.write(chunk)\n\n\ndef dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        encoding=\'utf-8\', default=None, use_decimal=True,\n        namedtuple_as_object=True, tuple_as_array=True,\n        bigint_as_string=False, sort_keys=False, item_sort_key=None,\n        **kw):\n    """"""Serialize ``obj`` to a JSON formatted ``str``.\n\n    If ``skipkeys`` is false then ``dict`` keys that are not basic types\n    (``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n    will be skipped instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the return value will be a\n    ``unicode`` instance subject to normal Python ``str`` to ``unicode``\n    coercion rules instead of being escaped to an ASCII ``str``.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n    strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a string, then JSON array elements and object members\n    will be pretty-printed with a newline followed by that string repeated\n    for each level of nesting. ``None`` (the default) selects the most compact\n    representation without any newlines. For backwards compatibility with\n    versions of simplejson earlier than 2.1.0, an integer is also accepted\n    and is converted to a string with that many spaces.\n\n    If ``separators`` is an ``(item_separator, dict_separator)`` tuple\n    then it will be used instead of the default ``(\', \', \': \')`` separators.\n    ``(\',\', \':\')`` is the most compact JSON representation.\n\n    ``encoding`` is the character encoding for str instances, default is UTF-8.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *use_decimal* is true (default: ``True``) then decimal.Decimal\n    will be natively serialized to JSON with full precision.\n\n    If *namedtuple_as_object* is true (default: ``True``),\n    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded\n    as JSON objects.\n\n    If *tuple_as_array* is true (default: ``True``),\n    :class:`tuple` (and subclasses) will be encoded as JSON arrays.\n\n    If *bigint_as_string* is true (not the default), ints 2**53 and higher\n    or lower than -2**53 will be encoded as strings. This is to avoid the\n    rounding that happens in Javascript otherwise.\n\n    If specified, *item_sort_key* is a callable used to sort the items in\n    each dictionary. This is useful if you want to sort items other than\n    in alphabetical order by key. This option takes precendence over\n    *sort_keys*.\n\n    If *sort_keys* is true (default: ``False``), the output of dictionaries\n    will be sorted by item.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg.\n\n    """"""\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        encoding == \'utf-8\' and default is None and use_decimal\n        and namedtuple_as_object and tuple_as_array\n        and not bigint_as_string and not sort_keys\n        and not item_sort_key and not kw):\n        return _default_encoder.encode(obj)\n    if cls is None:\n        cls = JSONEncoder\n    return cls(\n        skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n        check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n        separators=separators, encoding=encoding, default=default,\n        use_decimal=use_decimal,\n        namedtuple_as_object=namedtuple_as_object,\n        tuple_as_array=tuple_as_array,\n        bigint_as_string=bigint_as_string,\n        sort_keys=sort_keys,\n        item_sort_key=item_sort_key,\n        **kw).encode(obj)\n\n\n_default_decoder = JSONDecoder(encoding=None, object_hook=None,\n                               object_pairs_hook=None)\n\n\ndef load(fp, encoding=None, cls=None, object_hook=None, parse_float=None,\n        parse_int=None, parse_constant=None, object_pairs_hook=None,\n        use_decimal=False, namedtuple_as_object=True, tuple_as_array=True,\n        **kw):\n    """"""Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\n    a JSON document) to a Python object.\n\n    *encoding* determines the encoding used to interpret any\n    :class:`str` objects decoded by this instance (``\'utf-8\'`` by\n    default).  It has no effect when decoding :class:`unicode` objects.\n\n    Note that currently only encodings that are a superset of ASCII work,\n    strings of other encodings should be passed in as :class:`unicode`.\n\n    *object_hook*, if specified, will be called with the result of every\n    JSON object decoded and its return value will be used in place of the\n    given :class:`dict`.  This can be used to provide custom\n    deserializations (e.g. to support JSON-RPC class hinting).\n\n    *object_pairs_hook* is an optional function that will be called with\n    the result of any object literal decode with an ordered list of pairs.\n    The return value of *object_pairs_hook* will be used instead of the\n    :class:`dict`.  This feature can be used to implement custom decoders\n    that rely on the order that the key and value pairs are decoded (for\n    example, :func:`collections.OrderedDict` will remember the order of\n    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n    takes priority.\n\n    *parse_float*, if specified, will be called with the string of every\n    JSON float to be decoded.  By default, this is equivalent to\n    ``float(num_str)``. This can be used to use another datatype or parser\n    for JSON floats (e.g. :class:`decimal.Decimal`).\n\n    *parse_int*, if specified, will be called with the string of every\n    JSON int to be decoded.  By default, this is equivalent to\n    ``int(num_str)``.  This can be used to use another datatype or parser\n    for JSON integers (e.g. :class:`float`).\n\n    *parse_constant*, if specified, will be called with one of the\n    following strings: ``\'-Infinity\'``, ``\'Infinity\'``, ``\'NaN\'``.  This\n    can be used to raise an exception if invalid JSON numbers are\n    encountered.\n\n    If *use_decimal* is true (default: ``False``) then it implies\n    parse_float=decimal.Decimal for parity with ``dump``.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg.\n\n    """"""\n    return loads(fp.read(),\n        encoding=encoding, cls=cls, object_hook=object_hook,\n        parse_float=parse_float, parse_int=parse_int,\n        parse_constant=parse_constant, object_pairs_hook=object_pairs_hook,\n        use_decimal=use_decimal, **kw)\n\n\ndef loads(s, encoding=None, cls=None, object_hook=None, parse_float=None,\n        parse_int=None, parse_constant=None, object_pairs_hook=None,\n        use_decimal=False, **kw):\n    """"""Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n    document) to a Python object.\n\n    *encoding* determines the encoding used to interpret any\n    :class:`str` objects decoded by this instance (``\'utf-8\'`` by\n    default).  It has no effect when decoding :class:`unicode` objects.\n\n    Note that currently only encodings that are a superset of ASCII work,\n    strings of other encodings should be passed in as :class:`unicode`.\n\n    *object_hook*, if specified, will be called with the result of every\n    JSON object decoded and its return value will be used in place of the\n    given :class:`dict`.  This can be used to provide custom\n    deserializations (e.g. to support JSON-RPC class hinting).\n\n    *object_pairs_hook* is an optional function that will be called with\n    the result of any object literal decode with an ordered list of pairs.\n    The return value of *object_pairs_hook* will be used instead of the\n    :class:`dict`.  This feature can be used to implement custom decoders\n    that rely on the order that the key and value pairs are decoded (for\n    example, :func:`collections.OrderedDict` will remember the order of\n    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n    takes priority.\n\n    *parse_float*, if specified, will be called with the string of every\n    JSON float to be decoded.  By default, this is equivalent to\n    ``float(num_str)``. This can be used to use another datatype or parser\n    for JSON floats (e.g. :class:`decimal.Decimal`).\n\n    *parse_int*, if specified, will be called with the string of every\n    JSON int to be decoded.  By default, this is equivalent to\n    ``int(num_str)``.  This can be used to use another datatype or parser\n    for JSON integers (e.g. :class:`float`).\n\n    *parse_constant*, if specified, will be called with one of the\n    following strings: ``\'-Infinity\'``, ``\'Infinity\'``, ``\'NaN\'``.  This\n    can be used to raise an exception if invalid JSON numbers are\n    encountered.\n\n    If *use_decimal* is true (default: ``False``) then it implies\n    parse_float=decimal.Decimal for parity with ``dump``.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg.\n\n    """"""\n    if (cls is None and encoding is None and object_hook is None and\n            parse_int is None and parse_float is None and\n            parse_constant is None and object_pairs_hook is None\n            and not use_decimal and not kw):\n        return _default_decoder.decode(s)\n    if cls is None:\n        cls = JSONDecoder\n    if object_hook is not None:\n        kw[\'object_hook\'] = object_hook\n    if object_pairs_hook is not None:\n        kw[\'object_pairs_hook\'] = object_pairs_hook\n    if parse_float is not None:\n        kw[\'parse_float\'] = parse_float\n    if parse_int is not None:\n        kw[\'parse_int\'] = parse_int\n    if parse_constant is not None:\n        kw[\'parse_constant\'] = parse_constant\n    if use_decimal:\n        if parse_float is not None:\n            raise TypeError(""use_decimal=True implies parse_float=Decimal"")\n        kw[\'parse_float\'] = Decimal\n    return cls(encoding=encoding, **kw).decode(s)\n\n\ndef _toggle_speedups(enabled):\n    import simplejson.decoder as dec\n    import simplejson.encoder as enc\n    import simplejson.scanner as scan\n    c_make_encoder = _import_c_make_encoder()\n    if enabled:\n        dec.scanstring = dec.c_scanstring or dec.py_scanstring\n        enc.c_make_encoder = c_make_encoder\n        enc.encode_basestring_ascii = (enc.c_encode_basestring_ascii or\n            enc.py_encode_basestring_ascii)\n        scan.make_scanner = scan.c_make_scanner or scan.py_make_scanner\n    else:\n        dec.scanstring = dec.py_scanstring\n        enc.c_make_encoder = None\n        enc.encode_basestring_ascii = enc.py_encode_basestring_ascii\n        scan.make_scanner = scan.py_make_scanner\n    dec.make_scanner = scan.make_scanner\n    global _default_decoder\n    _default_decoder = JSONDecoder(\n        encoding=None,\n        object_hook=None,\n        object_pairs_hook=None,\n    )\n    global _default_encoder\n    _default_encoder = JSONEncoder(\n       skipkeys=False,\n       ensure_ascii=True,\n       check_circular=True,\n       allow_nan=True,\n       indent=None,\n       separators=None,\n       encoding=\'utf-8\',\n       default=None,\n   )\n\ndef simple_first(kv):\n    """"""Helper function to pass to item_sort_key to sort simple\n    elements to the top, then container elements.\n    """"""\n    return (isinstance(kv[1], (list, dict, tuple)), kv[0])\n'"
simplejson/decoder.py,0,"b'""""""Implementation of JSONDecoder\n""""""\nimport re\nimport sys\nimport struct\n\nfrom simplejson.scanner import make_scanner\ndef _import_c_scanstring():\n    try:\n        from simplejson._speedups import scanstring\n        return scanstring\n    except ImportError:\n        return None\nc_scanstring = _import_c_scanstring()\n\n__all__ = [\'JSONDecoder\']\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\n\ndef _floatconstants():\n    _BYTES = \'7FF80000000000007FF0000000000000\'.decode(\'hex\')\n    # The struct module in Python 2.4 would get frexp() out of range here\n    # when an endian is specified in the format string. Fixed in Python 2.5+\n    if sys.byteorder != \'big\':\n        _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]\n    nan, inf = struct.unpack(\'dd\', _BYTES)\n    return nan, inf, -inf\n\nNaN, PosInf, NegInf = _floatconstants()\n\n\nclass JSONDecodeError(ValueError):\n    """"""Subclass of ValueError with the following additional properties:\n\n    msg: The unformatted error message\n    doc: The JSON document being parsed\n    pos: The start index of doc where parsing failed\n    end: The end index of doc where parsing failed (may be None)\n    lineno: The line corresponding to pos\n    colno: The column corresponding to pos\n    endlineno: The line corresponding to end (may be None)\n    endcolno: The column corresponding to end (may be None)\n\n    """"""\n    def __init__(self, msg, doc, pos, end=None):\n        ValueError.__init__(self, errmsg(msg, doc, pos, end=end))\n        self.msg = msg\n        self.doc = doc\n        self.pos = pos\n        self.end = end\n        self.lineno, self.colno = linecol(doc, pos)\n        if end is not None:\n            self.endlineno, self.endcolno = linecol(doc, end)\n        else:\n            self.endlineno, self.endcolno = None, None\n\n\ndef linecol(doc, pos):\n    lineno = doc.count(\'\\n\', 0, pos) + 1\n    if lineno == 1:\n        colno = pos\n    else:\n        colno = pos - doc.rindex(\'\\n\', 0, pos)\n    return lineno, colno\n\n\ndef errmsg(msg, doc, pos, end=None):\n    # Note that this function is called from _speedups\n    lineno, colno = linecol(doc, pos)\n    if end is None:\n        #fmt = \'{0}: line {1} column {2} (char {3})\'\n        #return fmt.format(msg, lineno, colno, pos)\n        fmt = \'%s: line %d column %d (char %d)\'\n        return fmt % (msg, lineno, colno, pos)\n    endlineno, endcolno = linecol(doc, end)\n    #fmt = \'{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})\'\n    #return fmt.format(msg, lineno, colno, endlineno, endcolno, pos, end)\n    fmt = \'%s: line %d column %d - line %d column %d (char %d - %d)\'\n    return fmt % (msg, lineno, colno, endlineno, endcolno, pos, end)\n\n\n_CONSTANTS = {\n    \'-Infinity\': NegInf,\n    \'Infinity\': PosInf,\n    \'NaN\': NaN,\n}\n\nSTRINGCHUNK = re.compile(r\'(.*?)([""\\\\\\x00-\\x1f])\', FLAGS)\nBACKSLASH = {\n    \'""\': u\'""\', \'\\\\\': u\'\\\\\', \'/\': u\'/\',\n    \'b\': u\'\\b\', \'f\': u\'\\f\', \'n\': u\'\\n\', \'r\': u\'\\r\', \'t\': u\'\\t\',\n}\n\nDEFAULT_ENCODING = ""utf-8""\n\ndef py_scanstring(s, end, encoding=None, strict=True,\n        _b=BACKSLASH, _m=STRINGCHUNK.match):\n    """"""Scan the string s for a JSON string. End is the index of the\n    character in s after the quote that started the JSON string.\n    Unescapes all valid JSON string escape sequences and raises ValueError\n    on attempt to decode an invalid string. If strict is False then literal\n    control characters are allowed in the string.\n\n    Returns a tuple of the decoded string and the index of the character in s\n    after the end quote.""""""\n    if encoding is None:\n        encoding = DEFAULT_ENCODING\n    chunks = []\n    _append = chunks.append\n    begin = end - 1\n    while 1:\n        chunk = _m(s, end)\n        if chunk is None:\n            raise JSONDecodeError(\n                ""Unterminated string starting at"", s, begin)\n        end = chunk.end()\n        content, terminator = chunk.groups()\n        # Content is contains zero or more unescaped string characters\n        if content:\n            if not isinstance(content, unicode):\n                content = unicode(content, encoding)\n            _append(content)\n        # Terminator is the end of string, a literal control character,\n        # or a backslash denoting that an escape sequence follows\n        if terminator == \'""\':\n            break\n        elif terminator != \'\\\\\':\n            if strict:\n                msg = ""Invalid control character %r at"" % (terminator,)\n                #msg = ""Invalid control character {0!r} at"".format(terminator)\n                raise JSONDecodeError(msg, s, end)\n            else:\n                _append(terminator)\n                continue\n        try:\n            esc = s[end]\n        except IndexError:\n            raise JSONDecodeError(\n                ""Unterminated string starting at"", s, begin)\n        # If not a unicode escape sequence, must be in the lookup table\n        if esc != \'u\':\n            try:\n                char = _b[esc]\n            except KeyError:\n                msg = ""Invalid \\\\escape: "" + repr(esc)\n                raise JSONDecodeError(msg, s, end)\n            end += 1\n        else:\n            # Unicode escape sequence\n            esc = s[end + 1:end + 5]\n            next_end = end + 5\n            if len(esc) != 4:\n                msg = ""Invalid \\\\uXXXX escape""\n                raise JSONDecodeError(msg, s, end)\n            uni = int(esc, 16)\n            # Check for surrogate pair on UCS-4 systems\n            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:\n                msg = ""Invalid \\\\uXXXX\\\\uXXXX surrogate pair""\n                if not s[end + 5:end + 7] == \'\\\\u\':\n                    raise JSONDecodeError(msg, s, end)\n                esc2 = s[end + 7:end + 11]\n                if len(esc2) != 4:\n                    raise JSONDecodeError(msg, s, end)\n                uni2 = int(esc2, 16)\n                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n                next_end += 6\n            char = unichr(uni)\n            end = next_end\n        # Append the unescaped character\n        _append(char)\n    return u\'\'.join(chunks), end\n\n\n# Use speedup if available\nscanstring = c_scanstring or py_scanstring\n\nWHITESPACE = re.compile(r\'[ \\t\\n\\r]*\', FLAGS)\nWHITESPACE_STR = \' \\t\\n\\r\'\n\ndef JSONObject((s, end), encoding, strict, scan_once, object_hook,\n        object_pairs_hook, memo=None,\n        _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n    # Backwards compatibility\n    if memo is None:\n        memo = {}\n    memo_get = memo.setdefault\n    pairs = []\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end:end + 1]\n    # Normally we expect nextchar == \'""\'\n    if nextchar != \'""\':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end:end + 1]\n        # Trivial empty object\n        if nextchar == \'}\':\n            if object_pairs_hook is not None:\n                result = object_pairs_hook(pairs)\n                return result, end + 1\n            pairs = {}\n            if object_hook is not None:\n                pairs = object_hook(pairs)\n            return pairs, end + 1\n        elif nextchar != \'""\':\n            raise JSONDecodeError(\n                ""Expecting property name enclosed in double quotes"",\n                s, end)\n    end += 1\n    while True:\n        key, end = scanstring(s, end, encoding, strict)\n        key = memo_get(key, key)\n\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is "": "" or just "":"".\n        if s[end:end + 1] != \':\':\n            end = _w(s, end).end()\n            if s[end:end + 1] != \':\':\n                raise JSONDecodeError(""Expecting \':\' delimiter"", s, end)\n\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration:\n            raise JSONDecodeError(""Expecting object"", s, end)\n        pairs.append((key, value))\n\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = \'\'\n        end += 1\n\n        if nextchar == \'}\':\n            break\n        elif nextchar != \',\':\n            raise JSONDecodeError(""Expecting \',\' delimiter"", s, end - 1)\n\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end += 1\n                nextchar = s[end]\n                if nextchar in _ws:\n                    end = _w(s, end + 1).end()\n                    nextchar = s[end]\n        except IndexError:\n            nextchar = \'\'\n\n        end += 1\n        if nextchar != \'""\':\n            raise JSONDecodeError(\n                ""Expecting property name enclosed in double quotes"",\n                s, end - 1)\n\n    if object_pairs_hook is not None:\n        result = object_pairs_hook(pairs)\n        return result, end\n    pairs = dict(pairs)\n    if object_hook is not None:\n        pairs = object_hook(pairs)\n    return pairs, end\n\ndef JSONArray((s, end), scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n    values = []\n    nextchar = s[end:end + 1]\n    if nextchar in _ws:\n        end = _w(s, end + 1).end()\n        nextchar = s[end:end + 1]\n    # Look-ahead for trivial empty array\n    if nextchar == \']\':\n        return values, end + 1\n    _append = values.append\n    while True:\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration:\n            raise JSONDecodeError(""Expecting object"", s, end)\n        _append(value)\n        nextchar = s[end:end + 1]\n        if nextchar in _ws:\n            end = _w(s, end + 1).end()\n            nextchar = s[end:end + 1]\n        end += 1\n        if nextchar == \']\':\n            break\n        elif nextchar != \',\':\n            raise JSONDecodeError(""Expecting \',\' delimiter"", s, end)\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n    return values, end\n\nclass JSONDecoder(object):\n    """"""Simple JSON <http://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | unicode           |\n    +---------------+-------------------+\n    | number (int)  | int, long         |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    """"""\n\n    def __init__(self, encoding=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, strict=True,\n            object_pairs_hook=None):\n        """"""\n        *encoding* determines the encoding used to interpret any\n        :class:`str` objects decoded by this instance (``\'utf-8\'`` by\n        default).  It has no effect when decoding :class:`unicode` objects.\n\n        Note that currently only encodings that are a superset of ASCII work,\n        strings of other encodings should be passed in as :class:`unicode`.\n\n        *object_hook*, if specified, will be called with the result of every\n        JSON object decoded and its return value will be used in place of the\n        given :class:`dict`.  This can be used to provide custom\n        deserializations (e.g. to support JSON-RPC class hinting).\n\n        *object_pairs_hook* is an optional function that will be called with\n        the result of any object literal decode with an ordered list of pairs.\n        The return value of *object_pairs_hook* will be used instead of the\n        :class:`dict`.  This feature can be used to implement custom decoders\n        that rely on the order that the key and value pairs are decoded (for\n        example, :func:`collections.OrderedDict` will remember the order of\n        insertion). If *object_hook* is also defined, the *object_pairs_hook*\n        takes priority.\n\n        *parse_float*, if specified, will be called with the string of every\n        JSON float to be decoded.  By default, this is equivalent to\n        ``float(num_str)``. This can be used to use another datatype or parser\n        for JSON floats (e.g. :class:`decimal.Decimal`).\n\n        *parse_int*, if specified, will be called with the string of every\n        JSON int to be decoded.  By default, this is equivalent to\n        ``int(num_str)``.  This can be used to use another datatype or parser\n        for JSON integers (e.g. :class:`float`).\n\n        *parse_constant*, if specified, will be called with one of the\n        following strings: ``\'-Infinity\'``, ``\'Infinity\'``, ``\'NaN\'``.  This\n        can be used to raise an exception if invalid JSON numbers are\n        encountered.\n\n        *strict* controls the parser\'s behavior when it encounters an\n        invalid control character in a string. The default setting of\n        ``True`` means that unescaped control characters are parse errors, if\n        ``False`` then control characters will be allowed in strings.\n\n        """"""\n        self.encoding = encoding\n        self.object_hook = object_hook\n        self.object_pairs_hook = object_pairs_hook\n        self.parse_float = parse_float or float\n        self.parse_int = parse_int or int\n        self.parse_constant = parse_constant or _CONSTANTS.__getitem__\n        self.strict = strict\n        self.parse_object = JSONObject\n        self.parse_array = JSONArray\n        self.parse_string = scanstring\n        self.memo = {}\n        self.scan_once = make_scanner(self)\n\n    def decode(self, s, _w=WHITESPACE.match):\n        """"""Return the Python representation of ``s`` (a ``str`` or ``unicode``\n        instance containing a JSON document)\n\n        """"""\n        obj, end = self.raw_decode(s)\n        end = _w(s, end).end()\n        if end != len(s):\n            raise JSONDecodeError(""Extra data"", s, end, len(s))\n        return obj\n\n    def raw_decode(self, s, idx=0, _w=WHITESPACE.match):\n        """"""Decode a JSON document from ``s`` (a ``str`` or ``unicode``\n        beginning with a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n        Optionally, ``idx`` can be used to specify an offset in ``s`` where\n        the JSON document begins.\n\n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n\n        """"""\n        try:\n            obj, end = self.scan_once(s, idx=_w(s, idx).end())\n        except StopIteration:\n            raise JSONDecodeError(""No JSON object could be decoded"", s, idx)\n        return obj, end\n'"
simplejson/encoder.py,0,"b'""""""Implementation of JSONEncoder\n""""""\nimport re\nfrom decimal import Decimal\n\ndef _import_speedups():\n    try:\n        from simplejson import _speedups\n        return _speedups.encode_basestring_ascii, _speedups.make_encoder\n    except ImportError:\n        return None, None\nc_encode_basestring_ascii, c_make_encoder = _import_speedups()\n\nfrom simplejson.decoder import PosInf\n\nESCAPE = re.compile(ur\'[\\x00-\\x1f\\\\""\\b\\f\\n\\r\\t\\u2028\\u2029]\')\nESCAPE_ASCII = re.compile(r\'([\\\\""]|[^\\ -~])\')\nHAS_UTF8 = re.compile(r\'[\\x80-\\xff]\')\nESCAPE_DCT = {\n    \'\\\\\': \'\\\\\\\\\',\n    \'""\': \'\\\\""\',\n    \'\\b\': \'\\\\b\',\n    \'\\f\': \'\\\\f\',\n    \'\\n\': \'\\\\n\',\n    \'\\r\': \'\\\\r\',\n    \'\\t\': \'\\\\t\',\n    u\'\\u2028\': \'\\\\u2028\',\n    u\'\\u2029\': \'\\\\u2029\',\n}\nfor i in range(0x20):\n    #ESCAPE_DCT.setdefault(chr(i), \'\\\\u{0:04x}\'.format(i))\n    ESCAPE_DCT.setdefault(chr(i), \'\\\\u%04x\' % (i,))\n\nFLOAT_REPR = repr\n\ndef encode_basestring(s):\n    """"""Return a JSON representation of a Python string\n\n    """"""\n    if isinstance(s, str) and HAS_UTF8.search(s) is not None:\n        s = s.decode(\'utf-8\')\n    def replace(match):\n        return ESCAPE_DCT[match.group(0)]\n    return u\'""\' + ESCAPE.sub(replace, s) + u\'""\'\n\n\ndef py_encode_basestring_ascii(s):\n    """"""Return an ASCII-only JSON representation of a Python string\n\n    """"""\n    if isinstance(s, str) and HAS_UTF8.search(s) is not None:\n        s = s.decode(\'utf-8\')\n    def replace(match):\n        s = match.group(0)\n        try:\n            return ESCAPE_DCT[s]\n        except KeyError:\n            n = ord(s)\n            if n < 0x10000:\n                #return \'\\\\u{0:04x}\'.format(n)\n                return \'\\\\u%04x\' % (n,)\n            else:\n                # surrogate pair\n                n -= 0x10000\n                s1 = 0xd800 | ((n >> 10) & 0x3ff)\n                s2 = 0xdc00 | (n & 0x3ff)\n                #return \'\\\\u{0:04x}\\\\u{1:04x}\'.format(s1, s2)\n                return \'\\\\u%04x\\\\u%04x\' % (s1, s2)\n    return \'""\' + str(ESCAPE_ASCII.sub(replace, s)) + \'""\'\n\n\nencode_basestring_ascii = (\n    c_encode_basestring_ascii or py_encode_basestring_ascii)\n\nclass JSONEncoder(object):\n    """"""Extensible JSON <http://json.org> encoder for Python data structures.\n\n    Supports the following objects and types by default:\n\n    +-------------------+---------------+\n    | Python            | JSON          |\n    +===================+===============+\n    | dict, namedtuple  | object        |\n    +-------------------+---------------+\n    | list, tuple       | array         |\n    +-------------------+---------------+\n    | str, unicode      | string        |\n    +-------------------+---------------+\n    | int, long, float  | number        |\n    +-------------------+---------------+\n    | True              | true          |\n    +-------------------+---------------+\n    | False             | false         |\n    +-------------------+---------------+\n    | None              | null          |\n    +-------------------+---------------+\n\n    To extend this to recognize other objects, subclass and implement a\n    ``.default()`` method with another method that returns a serializable\n    object for ``o`` if possible, otherwise it should call the superclass\n    implementation (to raise ``TypeError``).\n\n    """"""\n    item_separator = \', \'\n    key_separator = \': \'\n    def __init__(self, skipkeys=False, ensure_ascii=True,\n            check_circular=True, allow_nan=True, sort_keys=False,\n            indent=None, separators=None, encoding=\'utf-8\', default=None,\n            use_decimal=True, namedtuple_as_object=True,\n            tuple_as_array=True, bigint_as_string=False,\n            item_sort_key=None):\n        """"""Constructor for JSONEncoder, with sensible defaults.\n\n        If skipkeys is false, then it is a TypeError to attempt\n        encoding of keys that are not str, int, long, float or None.  If\n        skipkeys is True, such items are simply skipped.\n\n        If ensure_ascii is true, the output is guaranteed to be str\n        objects with all incoming unicode characters escaped.  If\n        ensure_ascii is false, the output will be unicode object.\n\n        If check_circular is true, then lists, dicts, and custom encoded\n        objects will be checked for circular references during encoding to\n        prevent an infinite recursion (which would cause an OverflowError).\n        Otherwise, no such check takes place.\n\n        If allow_nan is true, then NaN, Infinity, and -Infinity will be\n        encoded as such.  This behavior is not JSON specification compliant,\n        but is consistent with most JavaScript based encoders and decoders.\n        Otherwise, it will be a ValueError to encode such floats.\n\n        If sort_keys is true, then the output of dictionaries will be\n        sorted by key; this is useful for regression tests to ensure\n        that JSON serializations can be compared on a day-to-day basis.\n\n        If indent is a string, then JSON array elements and object members\n        will be pretty-printed with a newline followed by that string repeated\n        for each level of nesting. ``None`` (the default) selects the most compact\n        representation without any newlines. For backwards compatibility with\n        versions of simplejson earlier than 2.1.0, an integer is also accepted\n        and is converted to a string with that many spaces.\n\n        If specified, separators should be a (item_separator, key_separator)\n        tuple.  The default is (\', \', \': \').  To get the most compact JSON\n        representation you should specify (\',\', \':\') to eliminate whitespace.\n\n        If specified, default is a function that gets called for objects\n        that can\'t otherwise be serialized.  It should return a JSON encodable\n        version of the object or raise a ``TypeError``.\n\n        If encoding is not None, then all input strings will be\n        transformed into unicode using that encoding prior to JSON-encoding.\n        The default is UTF-8.\n\n        If use_decimal is true (not the default), ``decimal.Decimal`` will\n        be supported directly by the encoder. For the inverse, decode JSON\n        with ``parse_float=decimal.Decimal``.\n\n        If namedtuple_as_object is true (the default), objects with\n        ``_asdict()`` methods will be encoded as JSON objects.\n\n        If tuple_as_array is true (the default), tuple (and subclasses) will\n        be encoded as JSON arrays.\n\n        If bigint_as_string is true (not the default), ints 2**53 and higher\n        or lower than -2**53 will be encoded as strings. This is to avoid the\n        rounding that happens in Javascript otherwise.\n\n        If specified, item_sort_key is a callable used to sort the items in\n        each dictionary. This is useful if you want to sort items other than\n        in alphabetical order by key.\n        """"""\n\n        self.skipkeys = skipkeys\n        self.ensure_ascii = ensure_ascii\n        self.check_circular = check_circular\n        self.allow_nan = allow_nan\n        self.sort_keys = sort_keys\n        self.use_decimal = use_decimal\n        self.namedtuple_as_object = namedtuple_as_object\n        self.tuple_as_array = tuple_as_array\n        self.bigint_as_string = bigint_as_string\n        self.item_sort_key = item_sort_key\n        if indent is not None and not isinstance(indent, basestring):\n            indent = indent * \' \'\n        self.indent = indent\n        if separators is not None:\n            self.item_separator, self.key_separator = separators\n        elif indent is not None:\n            self.item_separator = \',\'\n        if default is not None:\n            self.default = default\n        self.encoding = encoding\n\n    def default(self, o):\n        """"""Implement this method in a subclass such that it returns\n        a serializable object for ``o``, or calls the base implementation\n        (to raise a ``TypeError``).\n\n        For example, to support arbitrary iterators, you could\n        implement default like this::\n\n            def default(self, o):\n                try:\n                    iterable = iter(o)\n                except TypeError:\n                    pass\n                else:\n                    return list(iterable)\n                return JSONEncoder.default(self, o)\n\n        """"""\n        raise TypeError(repr(o) + "" is not JSON serializable"")\n\n    def encode(self, o):\n        """"""Return a JSON string representation of a Python data structure.\n\n        >>> from simplejson import JSONEncoder\n        >>> JSONEncoder().encode({""foo"": [""bar"", ""baz""]})\n        \'{""foo"": [""bar"", ""baz""]}\'\n\n        """"""\n        # This is for extremely simple cases and benchmarks.\n        if isinstance(o, basestring):\n            if isinstance(o, str):\n                _encoding = self.encoding\n                if (_encoding is not None\n                        and not (_encoding == \'utf-8\')):\n                    o = o.decode(_encoding)\n            if self.ensure_ascii:\n                return encode_basestring_ascii(o)\n            else:\n                return encode_basestring(o)\n        # This doesn\'t pass the iterator directly to \'\'.join() because the\n        # exceptions aren\'t as detailed.  The list call should be roughly\n        # equivalent to the PySequence_Fast that \'\'.join() would do.\n        chunks = self.iterencode(o, _one_shot=True)\n        if not isinstance(chunks, (list, tuple)):\n            chunks = list(chunks)\n        if self.ensure_ascii:\n            return \'\'.join(chunks)\n        else:\n            return u\'\'.join(chunks)\n\n    def iterencode(self, o, _one_shot=False):\n        """"""Encode the given object and yield each string\n        representation as available.\n\n        For example::\n\n            for chunk in JSONEncoder().iterencode(bigobject):\n                mysocket.write(chunk)\n\n        """"""\n        if self.check_circular:\n            markers = {}\n        else:\n            markers = None\n        if self.ensure_ascii:\n            _encoder = encode_basestring_ascii\n        else:\n            _encoder = encode_basestring\n        if self.encoding != \'utf-8\':\n            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):\n                if isinstance(o, str):\n                    o = o.decode(_encoding)\n                return _orig_encoder(o)\n\n        def floatstr(o, allow_nan=self.allow_nan,\n                _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):\n            # Check for specials. Note that this type of test is processor\n            # and/or platform-specific, so do tests which don\'t depend on\n            # the internals.\n\n            if o != o:\n                text = \'NaN\'\n            elif o == _inf:\n                text = \'Infinity\'\n            elif o == _neginf:\n                text = \'-Infinity\'\n            else:\n                return _repr(o)\n\n            if not allow_nan:\n                raise ValueError(\n                    ""Out of range float values are not JSON compliant: "" +\n                    repr(o))\n\n            return text\n\n\n        key_memo = {}\n        if (_one_shot and c_make_encoder is not None\n                and self.indent is None):\n            _iterencode = c_make_encoder(\n                markers, self.default, _encoder, self.indent,\n                self.key_separator, self.item_separator, self.sort_keys,\n                self.skipkeys, self.allow_nan, key_memo, self.use_decimal,\n                self.namedtuple_as_object, self.tuple_as_array,\n                self.bigint_as_string, self.item_sort_key,\n                Decimal)\n        else:\n            _iterencode = _make_iterencode(\n                markers, self.default, _encoder, self.indent, floatstr,\n                self.key_separator, self.item_separator, self.sort_keys,\n                self.skipkeys, _one_shot, self.use_decimal,\n                self.namedtuple_as_object, self.tuple_as_array,\n                self.bigint_as_string, self.item_sort_key,\n                Decimal=Decimal)\n        try:\n            return _iterencode(o, 0)\n        finally:\n            key_memo.clear()\n\n\nclass JSONEncoderForHTML(JSONEncoder):\n    """"""An encoder that produces JSON safe to embed in HTML.\n\n    To embed JSON content in, say, a script tag on a web page, the\n    characters &, < and > should be escaped. They cannot be escaped\n    with the usual entities (e.g. &amp;) because they are not expanded\n    within <script> tags.\n    """"""\n\n    def encode(self, o):\n        # Override JSONEncoder.encode because it has hacks for\n        # performance that make things more complicated.\n        chunks = self.iterencode(o, True)\n        if self.ensure_ascii:\n            return \'\'.join(chunks)\n        else:\n            return u\'\'.join(chunks)\n\n    def iterencode(self, o, _one_shot=False):\n        chunks = super(JSONEncoderForHTML, self).iterencode(o, _one_shot)\n        for chunk in chunks:\n            chunk = chunk.replace(\'&\', \'\\\\u0026\')\n            chunk = chunk.replace(\'<\', \'\\\\u003c\')\n            chunk = chunk.replace(\'>\', \'\\\\u003e\')\n            yield chunk\n\n\ndef _make_iterencode(markers, _default, _encoder, _indent, _floatstr,\n        _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,\n        _use_decimal, _namedtuple_as_object, _tuple_as_array,\n        _bigint_as_string, _item_sort_key,\n        ## HACK: hand-optimized bytecode; turn globals into locals\n        False=False,\n        True=True,\n        ValueError=ValueError,\n        basestring=basestring,\n        Decimal=Decimal,\n        dict=dict,\n        float=float,\n        id=id,\n        int=int,\n        isinstance=isinstance,\n        list=list,\n        long=long,\n        str=str,\n        tuple=tuple,\n    ):\n    if _item_sort_key and not callable(_item_sort_key):\n        raise TypeError(""item_sort_key must be None or callable"")\n\n    def _iterencode_list(lst, _current_indent_level):\n        if not lst:\n            yield \'[]\'\n            return\n        if markers is not None:\n            markerid = id(lst)\n            if markerid in markers:\n                raise ValueError(""Circular reference detected"")\n            markers[markerid] = lst\n        buf = \'[\'\n        if _indent is not None:\n            _current_indent_level += 1\n            newline_indent = \'\\n\' + (_indent * _current_indent_level)\n            separator = _item_separator + newline_indent\n            buf += newline_indent\n        else:\n            newline_indent = None\n            separator = _item_separator\n        first = True\n        for value in lst:\n            if first:\n                first = False\n            else:\n                buf = separator\n            if isinstance(value, basestring):\n                yield buf + _encoder(value)\n            elif value is None:\n                yield buf + \'null\'\n            elif value is True:\n                yield buf + \'true\'\n            elif value is False:\n                yield buf + \'false\'\n            elif isinstance(value, (int, long)):\n                yield ((buf + str(value))\n                       if (not _bigint_as_string or\n                           (-1 << 53) < value < (1 << 53))\n                           else (buf + \'""\' + str(value) + \'""\'))\n            elif isinstance(value, float):\n                yield buf + _floatstr(value)\n            elif _use_decimal and isinstance(value, Decimal):\n                yield buf + str(value)\n            else:\n                yield buf\n                if isinstance(value, list):\n                    chunks = _iterencode_list(value, _current_indent_level)\n                else:\n                    _asdict = _namedtuple_as_object and getattr(value, \'_asdict\', None)\n                    if _asdict and callable(_asdict):\n                        chunks = _iterencode_dict(_asdict(),\n                                                  _current_indent_level)\n                    elif _tuple_as_array and isinstance(value, tuple):\n                        chunks = _iterencode_list(value, _current_indent_level)\n                    elif isinstance(value, dict):\n                        chunks = _iterencode_dict(value, _current_indent_level)\n                    else:\n                        chunks = _iterencode(value, _current_indent_level)\n                for chunk in chunks:\n                    yield chunk\n        if newline_indent is not None:\n            _current_indent_level -= 1\n            yield \'\\n\' + (_indent * _current_indent_level)\n        yield \']\'\n        if markers is not None:\n            del markers[markerid]\n\n    def _iterencode_dict(dct, _current_indent_level):\n        if not dct:\n            yield \'{}\'\n            return\n        if markers is not None:\n            markerid = id(dct)\n            if markerid in markers:\n                raise ValueError(""Circular reference detected"")\n            markers[markerid] = dct\n        yield \'{\'\n        if _indent is not None:\n            _current_indent_level += 1\n            newline_indent = \'\\n\' + (_indent * _current_indent_level)\n            item_separator = _item_separator + newline_indent\n            yield newline_indent\n        else:\n            newline_indent = None\n            item_separator = _item_separator\n        first = True\n        if _item_sort_key:\n            items = dct.items()\n            items.sort(key=_item_sort_key)\n        elif _sort_keys:\n            items = dct.items()\n            items.sort(key=lambda kv: kv[0])\n        else:\n            items = dct.iteritems()\n        for key, value in items:\n            if isinstance(key, basestring):\n                pass\n            # JavaScript is weakly typed for these, so it makes sense to\n            # also allow them.  Many encoders seem to do something like this.\n            elif isinstance(key, float):\n                key = _floatstr(key)\n            elif key is True:\n                key = \'true\'\n            elif key is False:\n                key = \'false\'\n            elif key is None:\n                key = \'null\'\n            elif isinstance(key, (int, long)):\n                key = str(key)\n            elif _skipkeys:\n                continue\n            else:\n                raise TypeError(""key "" + repr(key) + "" is not a string"")\n            if first:\n                first = False\n            else:\n                yield item_separator\n            yield _encoder(key)\n            yield _key_separator\n            if isinstance(value, basestring):\n                yield _encoder(value)\n            elif value is None:\n                yield \'null\'\n            elif value is True:\n                yield \'true\'\n            elif value is False:\n                yield \'false\'\n            elif isinstance(value, (int, long)):\n                yield (str(value)\n                       if (not _bigint_as_string or\n                           (-1 << 53) < value < (1 << 53))\n                           else (\'""\' + str(value) + \'""\'))\n            elif isinstance(value, float):\n                yield _floatstr(value)\n            elif _use_decimal and isinstance(value, Decimal):\n                yield str(value)\n            else:\n                if isinstance(value, list):\n                    chunks = _iterencode_list(value, _current_indent_level)\n                else:\n                    _asdict = _namedtuple_as_object and getattr(value, \'_asdict\', None)\n                    if _asdict and callable(_asdict):\n                        chunks = _iterencode_dict(_asdict(),\n                                                  _current_indent_level)\n                    elif _tuple_as_array and isinstance(value, tuple):\n                        chunks = _iterencode_list(value, _current_indent_level)\n                    elif isinstance(value, dict):\n                        chunks = _iterencode_dict(value, _current_indent_level)\n                    else:\n                        chunks = _iterencode(value, _current_indent_level)\n                for chunk in chunks:\n                    yield chunk\n        if newline_indent is not None:\n            _current_indent_level -= 1\n            yield \'\\n\' + (_indent * _current_indent_level)\n        yield \'}\'\n        if markers is not None:\n            del markers[markerid]\n\n    def _iterencode(o, _current_indent_level):\n        if isinstance(o, basestring):\n            yield _encoder(o)\n        elif o is None:\n            yield \'null\'\n        elif o is True:\n            yield \'true\'\n        elif o is False:\n            yield \'false\'\n        elif isinstance(o, (int, long)):\n            yield (str(o)\n                   if (not _bigint_as_string or\n                       (-1 << 53) < o < (1 << 53))\n                       else (\'""\' + str(o) + \'""\'))\n        elif isinstance(o, float):\n            yield _floatstr(o)\n        elif isinstance(o, list):\n            for chunk in _iterencode_list(o, _current_indent_level):\n                yield chunk\n        else:\n            _asdict = _namedtuple_as_object and getattr(o, \'_asdict\', None)\n            if _asdict and callable(_asdict):\n                for chunk in _iterencode_dict(_asdict(), _current_indent_level):\n                    yield chunk\n            elif (_tuple_as_array and isinstance(o, tuple)):\n                for chunk in _iterencode_list(o, _current_indent_level):\n                    yield chunk\n            elif isinstance(o, dict):\n                for chunk in _iterencode_dict(o, _current_indent_level):\n                    yield chunk\n            elif _use_decimal and isinstance(o, Decimal):\n                yield str(o)\n            else:\n                if markers is not None:\n                    markerid = id(o)\n                    if markerid in markers:\n                        raise ValueError(""Circular reference detected"")\n                    markers[markerid] = o\n                o = _default(o)\n                for chunk in _iterencode(o, _current_indent_level):\n                    yield chunk\n                if markers is not None:\n                    del markers[markerid]\n\n    return _iterencode\n'"
simplejson/ordered_dict.py,0,"b'""""""Drop-in replacement for collections.OrderedDict by Raymond Hettinger\n\nhttp://code.activestate.com/recipes/576693/\n\n""""""\nfrom UserDict import DictMixin\n\n# Modified from original to support Python 2.4, see\n# http://code.google.com/p/simplejson/issues/detail?id=53\ntry:\n    all\nexcept NameError:\n    def all(seq):\n        for elem in seq:\n            if not elem:\n                return False\n        return True\n\nclass OrderedDict(dict, DictMixin):\n\n    def __init__(self, *args, **kwds):\n        if len(args) > 1:\n            raise TypeError(\'expected at most 1 arguments, got %d\' % len(args))\n        try:\n            self.__end\n        except AttributeError:\n            self.clear()\n        self.update(*args, **kwds)\n\n    def clear(self):\n        self.__end = end = []\n        end += [None, end, end]         # sentinel node for doubly linked list\n        self.__map = {}                 # key --> [key, prev, next]\n        dict.clear(self)\n\n    def __setitem__(self, key, value):\n        if key not in self:\n            end = self.__end\n            curr = end[1]\n            curr[2] = end[1] = self.__map[key] = [key, curr, end]\n        dict.__setitem__(self, key, value)\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, key)\n        key, prev, next = self.__map.pop(key)\n        prev[2] = next\n        next[1] = prev\n\n    def __iter__(self):\n        end = self.__end\n        curr = end[2]\n        while curr is not end:\n            yield curr[0]\n            curr = curr[2]\n\n    def __reversed__(self):\n        end = self.__end\n        curr = end[1]\n        while curr is not end:\n            yield curr[0]\n            curr = curr[1]\n\n    def popitem(self, last=True):\n        if not self:\n            raise KeyError(\'dictionary is empty\')\n        # Modified from original to support Python 2.4, see\n        # http://code.google.com/p/simplejson/issues/detail?id=53\n        if last:\n            key = reversed(self).next()\n        else:\n            key = iter(self).next()\n        value = self.pop(key)\n        return key, value\n\n    def __reduce__(self):\n        items = [[k, self[k]] for k in self]\n        tmp = self.__map, self.__end\n        del self.__map, self.__end\n        inst_dict = vars(self).copy()\n        self.__map, self.__end = tmp\n        if inst_dict:\n            return (self.__class__, (items,), inst_dict)\n        return self.__class__, (items,)\n\n    def keys(self):\n        return list(self)\n\n    setdefault = DictMixin.setdefault\n    update = DictMixin.update\n    pop = DictMixin.pop\n    values = DictMixin.values\n    items = DictMixin.items\n    iterkeys = DictMixin.iterkeys\n    itervalues = DictMixin.itervalues\n    iteritems = DictMixin.iteritems\n\n    def __repr__(self):\n        if not self:\n            return \'%s()\' % (self.__class__.__name__,)\n        return \'%s(%r)\' % (self.__class__.__name__, self.items())\n\n    def copy(self):\n        return self.__class__(self)\n\n    @classmethod\n    def fromkeys(cls, iterable, value=None):\n        d = cls()\n        for key in iterable:\n            d[key] = value\n        return d\n\n    def __eq__(self, other):\n        if isinstance(other, OrderedDict):\n            return len(self)==len(other) and \\\n                   all(p==q for p, q in  zip(self.items(), other.items()))\n        return dict.__eq__(self, other)\n\n    def __ne__(self, other):\n        return not self == other\n'"
simplejson/scanner.py,0,"b'""""""JSON token scanner\n""""""\nimport re\ndef _import_c_make_scanner():\n    try:\n        from simplejson._speedups import make_scanner\n        return make_scanner\n    except ImportError:\n        return None\nc_make_scanner = _import_c_make_scanner()\n\n__all__ = [\'make_scanner\']\n\nNUMBER_RE = re.compile(\n    r\'(-?(?:0|[1-9]\\d*))(\\.\\d+)?([eE][-+]?\\d+)?\',\n    (re.VERBOSE | re.MULTILINE | re.DOTALL))\n\ndef py_make_scanner(context):\n    parse_object = context.parse_object\n    parse_array = context.parse_array\n    parse_string = context.parse_string\n    match_number = NUMBER_RE.match\n    encoding = context.encoding\n    strict = context.strict\n    parse_float = context.parse_float\n    parse_int = context.parse_int\n    parse_constant = context.parse_constant\n    object_hook = context.object_hook\n    object_pairs_hook = context.object_pairs_hook\n    memo = context.memo\n\n    def _scan_once(string, idx):\n        try:\n            nextchar = string[idx]\n        except IndexError:\n            raise StopIteration\n\n        if nextchar == \'""\':\n            return parse_string(string, idx + 1, encoding, strict)\n        elif nextchar == \'{\':\n            return parse_object((string, idx + 1), encoding, strict,\n                _scan_once, object_hook, object_pairs_hook, memo)\n        elif nextchar == \'[\':\n            return parse_array((string, idx + 1), _scan_once)\n        elif nextchar == \'n\' and string[idx:idx + 4] == \'null\':\n            return None, idx + 4\n        elif nextchar == \'t\' and string[idx:idx + 4] == \'true\':\n            return True, idx + 4\n        elif nextchar == \'f\' and string[idx:idx + 5] == \'false\':\n            return False, idx + 5\n\n        m = match_number(string, idx)\n        if m is not None:\n            integer, frac, exp = m.groups()\n            if frac or exp:\n                res = parse_float(integer + (frac or \'\') + (exp or \'\'))\n            else:\n                res = parse_int(integer)\n            return res, m.end()\n        elif nextchar == \'N\' and string[idx:idx + 3] == \'NaN\':\n            return parse_constant(\'NaN\'), idx + 3\n        elif nextchar == \'I\' and string[idx:idx + 8] == \'Infinity\':\n            return parse_constant(\'Infinity\'), idx + 8\n        elif nextchar == \'-\' and string[idx:idx + 9] == \'-Infinity\':\n            return parse_constant(\'-Infinity\'), idx + 9\n        else:\n            raise StopIteration\n\n    def scan_once(string, idx):\n        try:\n            return _scan_once(string, idx)\n        finally:\n            memo.clear()\n\n    return scan_once\n\nmake_scanner = c_make_scanner or py_make_scanner\n'"
simplejson/tool.py,0,"b'r""""""Command-line tool to validate and pretty-print JSON\n\nUsage::\n\n    $ echo \'{""json"":""obj""}\' | python -m simplejson.tool\n    {\n        ""json"": ""obj""\n    }\n    $ echo \'{ 1.2:3.4}\' | python -m simplejson.tool\n    Expecting property name: line 1 column 2 (char 2)\n\n""""""\nimport sys\nimport simplejson as json\n\ndef main():\n    if len(sys.argv) == 1:\n        infile = sys.stdin\n        outfile = sys.stdout\n    elif len(sys.argv) == 2:\n        infile = open(sys.argv[1], \'rb\')\n        outfile = sys.stdout\n    elif len(sys.argv) == 3:\n        infile = open(sys.argv[1], \'rb\')\n        outfile = open(sys.argv[2], \'wb\')\n    else:\n        raise SystemExit(sys.argv[0] + "" [infile [outfile]]"")\n    try:\n        obj = json.load(infile,\n                        object_pairs_hook=json.OrderedDict,\n                        use_decimal=True)\n    except ValueError, e:\n        raise SystemExit(e)\n    json.dump(obj, outfile, sort_keys=True, indent=\'    \', use_decimal=True)\n    outfile.write(\'\\n\')\n\n\nif __name__ == \'__main__\':\n    main()\n'"
startup/__init__.py,0,b''
startup/_common_imports.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n\nfrom __future__ import absolute_import\n\nimport os, sys\n\nfrom diffcalc.hardware import ScannableHardwareAdapter\nimport diffcalc.hkl.you.geometry\nfrom diffcalc.ub.persistence import UbCalculationNonPersister, UBCalculationJSONPersister\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder\nfrom diffcalc import settings\nimport diffcalc.util\n\ntry:\n    __IPYTHON__  # @UndefinedVariable\n    IPYTHON = True\nexcept NameError:\n    IPYTHON = False\n\ntry:\n    from gda.device.scannable.scannablegroup import ScannableGroup\n    from gdascripts.scannable.dummy import SingleInputDummy as Dummy\n    from diffcmd.diffcmd_utils import alias_commands\n    GDA = True  \nexcept ImportError:\n    # Not running in gda environment so fall back to minigda emulation\n    from diffcalc.gdasupport.minigda.scannable import ScannableGroup\n    from diffcalc.gdasupport.minigda.scannable import SingleFieldDummyScannable as Dummy\n    GDA = False\n\n\nHELP_STRING = \\\n""""""Quick:  https://github.com/DiamondLightSource/diffcalc/blob/master/README.rst\nManual: http://diffcalc.readthedocs.io/en/latest/youmanual.html\nType:   > help ub\n        > help hkl""""""\n\n\nif GDA:\n    from gda.configuration.properties import LocalProperties  # @UnresolvedImport\n    var_folder = LocalProperties.get(""gda.var"")\n    diffcalc_persistance_path = os.path.join(var_folder, \'diffcalc\')\n    if not os.path.exists(diffcalc_persistance_path):\n        print ""Making diffcalc var folder:\'%s\'"" % diffcalc_persistance_path\n        os.makedirs(diffcalc_persistance_path)\n    settings.ubcalc_persister = UBCalculationJSONPersister(diffcalc_persistance_path, UBCalcStateEncoder)\n# else: should have been set if outside GDA\n\n\n\n'"
startup/_demo.py,0,"b'\'\'\'\nCreated on 19 Feb 2017\n\n@author: zrb13439\n\'\'\'\n\nimport diffcmd.ipython\n\ntry:\n    __IPYTHON__  # @UndefinedVariable\n    IPYTHON = True\nexcept NameError:\n    IPYTHON = False\n    \n\nGEOMETRIES = [\'sixc\', \'fivec\', \'fourc\', \'i16\', \'i21\']\n\n\ndef echo(cmd):\n    print ""\\n>>> "" + str(cmd)\n\n    \ndef print_heading(s):\n    print \'\\n\' + \'=\' * len(s) + \'\\n\' + s + \'\\n\' + \'=\' * len(s)\n\n\nclass Demo(object):\n    \n    def __init__(self, namespace, geometry):\n        self.namespace = namespace\n        assert geometry in GEOMETRIES\n        self.geometry = geometry\n\n    def all(self):\n        self.orient()\n        self.constrain()\n        self.scan()\n                 \n    def orient(self):\n        print_heading(\'Orientation demo\')\n        self.remove_test_ubcalc()\n        \n        pos_cmd_001 = {\n            \'sixc\': \'pos sixc [0 60 0 30 90 0]\', # mu, delta, gam, eta, chi, phi\n            \'i16\': \'pos sixc [0 90 30 0 60 0]\', #  phi, chi, eta, mu, delta, gam\n            \'i21\': \'pos fourc [60 30 0 0]\',\n            \'fivec\': \'pos fivec [60 0 30 90 0]\',\n            \'fourc\': \'pos fourc [60 30 90 0]\'\n            }[self.geometry]\n \n        pos_cmd_011 = {\n            \'sixc\': \'pos sixc [0 90 0 45 45 90]\', # mu, delta, gam, eta, chi, phi\n            \'i16\': \'pos sixc [90 45 45 0 90 0]\', #  phi, chi, eta, mu, delta, gam\n            \'i21\': \'pos fourc [90 90 0 0]\',\n            \'fivec\': \'pos fivec [90 0 45 45 90]\',\n            \'fourc\': \'pos fourc [90 45 45 90]\'\n            }[self.geometry]\n                   \n        self.echorun_magiccmd_list([\n            \'help ub\',\n            \'pos wl 1\',\n            ""newub \'test\'"",\n            ""setlat \'cubic\' 1 1 1 90 90 90"",\n            \'ub\',\n            \'c2th [0 0 1]\',\n            pos_cmd_001,\n            \'addref [0 0 1]\',\n            \'c2th [0 1 1]\',\n            pos_cmd_011,\n            \'addref [0 1 1]\',\n            \'ub\',\n            \'checkub\'])\n        \n    def constrain(self):\n        print_heading(\'Constraint demo\')\n        con_qaz_cmd = \'\' if self.geometry in (\'fourc\', \'i21\') else \'con qaz 90\'\n        con_mu_cmd = \'con mu 0\' if self.geometry in (\'sixc\', \'i16\') else \'\'\n        setmin_chi = \'setmin chi -180\' if self.geometry == \'i21\' else \'setmin chi 0\'\n        setmin_phi = \'setmin phi -180\' if self.geometry == \'i21\' else \'\'\n        setmax_phi = \'setmax phi 180\' if self.geometry == \'i21\' else \'\'\n        self.echorun_magiccmd_list([\n            \'help hkl\',\n            con_qaz_cmd,\n            \'con a_eq_b\',\n            con_mu_cmd,\n            \'con\',\n            \'setmin delta 0\',\n            setmin_chi,\n            setmin_phi,\n            setmax_phi])\n            \n    def scan(self):\n        print_heading(\'Scanning demo\')\n        if self.geometry == \'i16\':\n            diff_name = \'sixc\'\n        elif self.geometry == \'i21\':\n            diff_name = \'fourc\'\n        else:\n            diff_name = self.geometry\n        self.echorun_magiccmd_list([\n            \'setnphi [0 0 1]\' if self.geometry == \'i21\' else \'\',\n            \'pos hkl [0 0 1]\' if self.geometry == \'i21\' else \'pos hkl [1 0 0]\',\n            \'scan delta 40 90 10 hkl ct 1\',\n            \'pos hkl [0 1 0]\',\n            \'scan h 0 1 .2 k l %s ct 1\' % diff_name,\n            \'con psi\',\n            \'scan psi 0 90 10 hkl [1 0 1] eta chi phi ct .1\'])\n \n    def echorun_magiccmd_list(self, magic_cmd_list):\n        for cmd in magic_cmd_list:\n            self.echorun_magiccmd(cmd)\n            \n    def remove_test_ubcalc(self):\n        try:\n            eval(""rmub(\'test\')"", self.namespace)\n        except (OSError, KeyError):\n            pass\n \n    def echorun_magiccmd(self, magic_cmd):\n        if IPYTHON:\n            from IPython import get_ipython\n            echo(magic_cmd)\n            get_ipython().magic(magic_cmd) \n        else:  # Python\n            # python\'s help is interactive. Handle specially \n            if magic_cmd == \'help ub\':\n                \n                echo(""help ub"")\n                exec(""print ub.__doc__"", self.namespace)\n                return\n            if magic_cmd == \'help hkl\':\n                echo(""help(hkl)"")\n                exec(""print hkl.__doc__"", self.namespace)\n                return  \n            \n            # Echo the Python version of the magic command   \n            tokens = diffcmd.ipython.tokenify(magic_cmd)\n            if not tokens:\n                return\n            python_cmd = tokens.pop(0) + \'(\' + \', \'.join(tokens) + \')\'\n            python_cmd = python_cmd.replace(\'[, \', \'[\')\n            python_cmd = python_cmd.replace(\',]\', \']\')\n            python_cmd = python_cmd.replace(\', ]\', \']\')\n            echo(python_cmd)\n            \n            # Run the Python version of the magic command\n            elements = diffcmd.ipython.parse(magic_cmd, self.namespace)\n            func = elements.pop(0)\n            result = func(*elements)\n            if result:\n                print result\n'"
startup/_make_sixcircle_manual.py,0,"b'from startup._common_imports import *\n\n\ndiffcalc.util.COLOURISE_TERMINAL_OUTPUT = False\n\n### Create dummy scannables ###\nprint ""Dummy scannables: sixc(mu, delta, gam, eta, chi, phi) and en""\nmu = Dummy(\'mu\')\ndelta = Dummy(\'delta\')\ngam = Dummy(\'gam\')\neta = Dummy(\'eta\')\nchi = Dummy(\'chi\')\nphi = Dummy(\'phi\')\n_sixc = ScannableGroup(\'sixc\', (mu, delta, gam, eta, chi, phi))\nen = Dummy(\'en\')\nen.level = 3\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_sixc, en, ESMTGKeV)\nsettings.geometry = diffcalc.hkl.you.geometry.SixCircle()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _sixc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\n\n# For manual!\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nsettings.ubcalc_persister = UbCalculationNonPersister()\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\n\nDIFFCALC_ROOT = os.sep.join(\n    os.path.realpath(diffcalc.__file__).split(os.sep)[:-2])\n\nMANUALS_TO_MAKE = [\n    os.path.join(\n        DIFFCALC_ROOT, \'doc\', \'source\', \'youmanual_template.rst\'),\n    os.path.join(\n        DIFFCALC_ROOT, \'README_template.rst\')]\n\nprint \'MANUALS_TO_MAKE: \', MANUALS_TO_MAKE\n'"
startup/fivecircle.py,0,"b'from startup._common_imports import *\nimport startup._demo\n\n### Create dummy scannables ###\nprint ""Diffcalc creating dummy Scannables as _fivec and en were not found""\ndelta = Dummy(\'delta\')\ngam = Dummy(\'gam\')\neta = Dummy(\'eta\')\nchi = Dummy(\'chi\')\nphi = Dummy(\'phi\')\n_fivec = ScannableGroup(\'_fivec\', (delta, gam, eta, chi, phi))\nen = Dummy(\'en\')\nen.level = 3\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fivec, en, ESMTGKeV)\nsettings.geometry = diffcalc.hkl.you.geometry.FiveCircle()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group = _fivec\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n    \nlastub()  # Load the last ub calculation used\n\n# Set some limits\nsetmin(\'gam\', -179)\nsetmax(\'gam\', 179)\n\ndemo = startup._demo.Demo(globals(), \'fivec\')'"
startup/fourcircle.py,0,"b'from startup._common_imports import *\nimport startup._demo\n\n### Create dummy scannables ###\ndelta = Dummy(\'delta\')\neta = Dummy(\'eta\')\nchi = Dummy(\'chi\')\nphi = Dummy(\'phi\')\n_fourc = ScannableGroup(\'_fourc\', (delta, eta, chi, phi))\nen = Dummy(\'en\')\nen.level = 3\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fourc, en, ESMTGKeV)\nsettings.geometry = diffcalc.hkl.you.geometry.FourCircle()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _fourc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n\n# Load the last ub calculation used\nlastub() \n\ndemo = startup._demo.Demo(globals(), \'fourc\')'"
startup/i06.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\nfrom diffcalc.gdasupport.minigda.scannable import ScannableMotionWithScannableFieldsBase  # @UnusedImport\n\nfrom diffcalc.hkl.you.geometry import YouGeometry, YouPosition\nfrom diffcalc.settings import NUNAME\nfrom diffcalc.hardware import setrange\nfrom diffcalc.hkl.you.calc import SMALL\nif not GDA:    \n    import startup._demo\nelse:\n#     import __main__  # @UnresolvedImport\n    from __main__ import dd2th,ddth,dummychi,energy  # @UnresolvedImport\nLOCAL_MANUAL = ""http://confluence.diamond.ac.uk/pages/viewpage.action?pageId=31853413""\n# Diffcalc i06-1\n# ======== === \n# delta    dd2th\n# eta      ddth\n# chi      dummy\n# phi      0\n\nclass ThreeCircleI06(YouGeometry):\n    """"""For a diffractometer with theta two-theta geometry:\n          delta, eta\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'threec\', {\'mu\': 0, NUNAME: 0, \'phi\': 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        delta_phys, eta_phys, chi_phys = physical_angle_tuple\n        return YouPosition(0, delta_phys, 0, eta_phys, chi_phys, 0, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        _, delta_phys, _, eta_phys, chi_phys, _ = clone_position.totuple()\n        return delta_phys, eta_phys, chi_phys\n\n\n### Create dummy scannables ###\nif GDA:  \n    print ""!!! Starting LIVE diffcalc with delta(dd2th), eta(ddth), chi(dummy) and denergy."" \n    _threec = ScannableGroup(\'_threec\', (dd2th, ddth, dummychi))\n    delta = _threec.dd2th\n    eta = _threec.ddth\n    en=energy\n#     if float(en.getPosition()) == 0: # no energy value - dummy mode\n#         en(800)\n    \nelse:   \n    delta = Dummy(\'delta\')\n    eta = Dummy(\'eta\')\n    chi = Dummy(\'chi\')\n    _threec = ScannableGroup(\'_threec\', (delta, eta, chi))\n    en = Dummy(\'en\')\n    en(800)\n    \nen.level = 3\n \n### Configure and import diffcalc objects ###\nESMTGKeV = 0.001\nsettings.hardware = ScannableHardwareAdapter(_threec, en, ESMTGKeV)\nsettings.geometry = ThreeCircleI06()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _threec\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nif not GDA:\n    setrange(\'chi\', 90 - SMALL, 90 + SMALL)\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n \nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n# Load the last ub calculation used\nlastub() \n'"
startup/i07EH1h.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\nfrom diffcalc.settings import NUNAME\n\nif GDA:    \n    from __main__ import diff1vdelta, diff1halpha, diff1vgamma, diff1homega, dcm1energy # @UnresolvedImport\n\nfrom diffcalc.hkl.you.geometry import YouRemappedGeometry\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\nclass FourCircleI07EH1h(YouRemappedGeometry):\n    """"""For a diffractometer with angles:\n          delta, gam, eta, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouRemappedGeometry.__init__(self, \'fourc\', {\'mu\': 0, \'chi\': 90}, beamline_axes_transform)\n\n        # Order should match scannable order in _fourc group for mapping to work correctly\n        omega_to_phi = lambda x: 180. - x\n        self._scn_mapping_to_int = ((\'delta\', lambda x: x),\n                                    (\'gam\',   lambda x: x),\n                                    (\'eta\',   lambda x: x),\n                                    (\'phi\',   omega_to_phi))\n        phi_to_omega = lambda x: ((180. - x) + 180.) % 360 - 180\n        self._scn_mapping_to_ext = ((\'delta\', lambda x: x),\n                                    (\'gam\',   lambda x: x),\n                                    (\'eta\',   lambda x: x),\n                                    (\'phi\',   phi_to_omega))\n\n### Create dummy scannables ###\nif GDA:  \n    ###map GDA scannable to diffcalc axis name###\n    _fourc = ScannableGroup(\'_fourc\', (diff1vdelta, diff1vgamma, diff1halpha, diff1homega))\n    delta=_fourc.diff1vdelta\n    gam=_fourc.diff1vgamma\n    eta=_fourc.diff1halpha\n    phi=_fourc.diff1homega\n    en=dcm1energy\n    if float(en.getPosition()) == 0: # no energy value - dummy mode\n        en(800)\nelse:\n    #Create dummy axes to run outside GDA in IPython#   \n    delta = Dummy(\'delta\')\n    gam = Dummy(NUNAME)\n    eta = Dummy(\'eta\')\n    phi = Dummy(\'phi\')\n    _fourc = ScannableGroup(\'_fourc\', (delta, gam, eta, phi))\n    en = Dummy(\'en\')\n    en(800)\n\nen.level = 3\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fourc, en, ESMTGKeV)\nsettings.geometry = FourCircleI07EH1h()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _fourc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\nsettings.include_reference = False\n \n# for aliasing completeness\nmu= settings.geometry.fixed_constraints[\'mu\']\nchi= settings.geometry.fixed_constraints[\'chi\']\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n# Load the last ub calculation used\nlastub()\n# Set reference vector direction returning betain and betaout angles as alpha and beta\nif ubcalc.name:\n    surfnphi(\'0; 0; 1\')\n\n### Set i07 specific limits\ndef setLimitsAndCuts():\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    setmin(delta, -11.275)\n    setmax(delta, 100.0) \n    setmin(gam, -11.0)\n    setmax(gam, 49.934) \n    setmin(eta, -5.096)\n    setmax(eta,  5.115)\n    setcut(phi, -180.0)\n    print ""Current hardware limits set to:""\n    hardware()\n\nif not GDA:\n    setLimitsAndCuts()\n\n# TODO: make demo code for (2+2) diffractometer geometry\n#if not GDA:\n#    demo = startup._demo.Demo(globals(), \'fourc\')\n'"
startup/i07EH1v.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\nfrom diffcalc.settings import NUNAME\n\nif GDA:    \n    from __main__ import diff1vdelta, diff1valpha, diff1vgamma, diff1vomega, dcm1energy # @UnresolvedImport\n\nfrom diffcalc.hkl.you.geometry import YouGeometry, YouPosition\n\n\nclass FourCircleI07EH1v(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, gam, mu, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'fourc\', {\'eta\': 0, \'chi\': 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        delta_phys, gam_phys, mu_phys, phi_phys = physical_angle_tuple\n        return YouPosition(mu_phys, delta_phys, gam_phys, 0, 0, phi_phys, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        mu_phys, delta_phys, gam_phys, _, _, phi_phys = clone_position.totuple()\n        return delta_phys, gam_phys, mu_phys, phi_phys\n\n\n### Create dummy scannables ###\nif GDA:  \n    ###map GDA scannable to diffcalc axis name###\n    _fourc = ScannableGroup(\'_fourc\', (diff1vdelta, diff1vgamma, diff1valpha, diff1vomega))\n    delta=_fourc.diff1vdelta\n    gam=_fourc.diff1vgamma\n    mu=_fourc.diff1valpha\n    phi=_fourc.diff1vomega\n    en=dcm1energy\nelse:\n    #Create dummy axes to run outside GDA in IPython#   \n    delta = Dummy(\'delta\')\n    gam = Dummy(NUNAME)\n    mu = Dummy(\'mu\')\n    phi = Dummy(\'phi\')\n    _fourc = ScannableGroup(\'_fourc\', (delta, gam, mu, phi))\n    en = Dummy(\'en\')\n\nen.level = 3\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fourc, en, ESMTGKeV)\nsettings.geometry = FourCircleI07EH1v()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _fourc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\nsettings.include_reference = False\n\n# for aliasing completeness\neta= settings.geometry.fixed_constraints[\'eta\']\nchi= settings.geometry.fixed_constraints[\'chi\']\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n# Load the last ub calculation used\nlastub()\n# Set reference vector direction returning betain and betaout angles as alpha and beta\nif ubcalc.name:\n    surfnphi(\'0; 0; 1\')\n\n### Set i07 specific limits\ndef setLimitsAndCuts():\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    setmin(delta, -11.275)\n    setmax(delta, 100.0) \n    setmin(gam, -11.0)\n    setmax(gam, 49.934) \n    setmin(mu, -6.561)\n    setmax(mu, 29.163)\n    setcut(phi, -180.0)\n    print ""Current hardware limits set to:""\n    hardware()\n\nif not GDA:\n    setLimitsAndCuts()\n\n# TODO: make demo code for (2+2) diffractometer geometry\n#if not GDA:\n#    demo = startup._demo.Demo(globals(), \'fourc\')\n'"
startup/i07EH2v.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\nfrom diffcalc.settings import NUNAME\n\nif GDA:    \n    from __main__ import diff2delta, diff2alpha, diff2gamma, diff2omega, dcm1energy # @UnresolvedImport\n\nfrom diffcalc.hkl.you.geometry import YouGeometry, YouPosition\n\n\nclass FourCircleI07EH2v(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, gam, mu, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'fourc\', {\'eta\': 0, \'chi\': 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        delta_phys, gam_phys, mu_phys, phi_phys = physical_angle_tuple\n        return YouPosition(mu_phys, delta_phys, gam_phys, 0, 0, phi_phys, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        mu_phys, delta_phys, gam_phys, _, _, phi_phys = clone_position.totuple()\n        return delta_phys, gam_phys, mu_phys, phi_phys\n\n\n### Create dummy scannables ###\nif GDA:  \n    ###map GDA scannable to diffcalc axis name###\n    _fourc = ScannableGroup(\'_fourc\', (diff2delta, diff2gamma, diff2alpha, diff2omega))\n    delta=_fourc.diff2delta\n    gam=_fourc.diff2gamma\n    mu=_fourc.diff2alpha\n    phi=_fourc.diff2omega\n    en=dcm1energy\nelse:\n    #Create dummy axes to run outside GDA in IPython#   \n    delta = Dummy(\'delta\')\n    gam = Dummy(NUNAME)\n    mu = Dummy(\'mu\')\n    phi = Dummy(\'phi\')\n    _fourc = ScannableGroup(\'_fourc\', (delta, gam, mu, phi))\n    en = Dummy(\'en\')\n\nen.level = 3\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fourc, en, ESMTGKeV)\nsettings.geometry = FourCircleI07EH2v()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _fourc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\nsettings.include_reference = False\n\n# for aliasing completeness\neta= settings.geometry.fixed_constraints[\'eta\']\nchi= settings.geometry.fixed_constraints[\'chi\']\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n# Load the last ub calculation used\nlastub()\n# Set reference vector direction returning betain and betaout angles as alpha and beta\nif ubcalc.name:\n    surfnphi(\'0; 0; 1\')\n\n### Set i07 specific limits\ndef setLimitsAndCuts():\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    setmin(delta, -0.60755)\n    setmax(delta, 120.0) \n    setmin(gam, -1.3913)\n    setmax(gam, 48.160) \n    setmin(mu, -2.5124)\n    setmax(mu, 24.107)\n    setcut(phi, -180.0)\n    print ""Current hardware limits set to:""\n    hardware()\n\nif not GDA:\n    setLimitsAndCuts()\n\n# TODO: make demo code for (2+2) diffractometer geometry\n#if not GDA:\n#    demo = startup._demo.Demo(globals(), \'fourc\')\n'"
startup/i10.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\nfrom diffcalc.hkl.you.geometry import YouRemappedGeometry\nfrom diffcalc.settings import NUNAME\n\nif not GDA:    \n    import startup._demo\nelse:\n#     import __main__  # @UnresolvedImport\n    from __main__ import tth,tthArea,th,thArea,chi,pgm_energy, simtth,simth,simchi,simalpha # @UnresolvedImport\n\nLOCAL_MANUAL = """"\n\nSIM_MODE=False\n\nclass FourCircleI10(YouRemappedGeometry):\n    """"""For a diffractometer with angles:\n          delta, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouRemappedGeometry.__init__(self, \'fourc\', {\'mu\': 0, NUNAME: 0, \'phi\': 0}, beamline_axes_transform)\n\n        # Order should match scannable order in _fourc group for mapping to work correctly\n        self._scn_mapping_to_int = ((\'delta\', lambda x: x),\n                                    (\'eta\',   lambda x: x),\n                                    (\'chi\',   lambda x: x),\n                                    (\'phi\',   lambda x: x))\n        self._scn_mapping_to_ext = ((\'delta\', lambda x: x),\n                                    (\'eta\',   lambda x: x),\n                                    (\'chi\',   lambda x: x),\n                                    (\'phi\',   lambda x: x))\n### Create dummy scannables ###\nif GDA:  \n    ###map GDA scannable to diffcalc axis name###\n    phi = Dummy(\'phi\')\n    _fourc = ScannableGroup(\'_fourc\', (tth, th, chi, phi))\n    _area_fourc = ScannableGroup(\'_fourc\', (tthArea, thArea, chi, phi))\n    _sim_fourc = ScannableGroup(\'_fourc\', (simtth, simth, simchi, simalpha))\n    en=pgm_energy\n    if float(en.getPosition()) == 0: # no energy value - dummy mode\n        en(800)\n    simenergy = Dummy(\'en\')\n    simenergy(800)\nelse:\n    #Create dummy axes to run outside GDA in IPython#   \n    delta = Dummy(\'delta\')\n    eta = Dummy(\'eta\')\n    chi = Dummy(\'chi\')\n    phi = Dummy(\'phi\')\n    _fourc = _area_fourc = _sim_fourc = ScannableGroup(\'_fourc\', (delta, eta, chi, phi))\n    en = simenergy = Dummy(\'en\')\n    en(800)\n\nen.level = 3\n_geometry = FourCircleI10()\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 0.001\n_hw = ScannableHardwareAdapter(_fourc, en, ESMTGKeV)\n_area_hw = ScannableHardwareAdapter(_area_fourc, en, ESMTGKeV)\n_hw_sim = ScannableHardwareAdapter(_sim_fourc, simenergy, ESMTGKeV)\nsettings.hardware = _hw\nsettings.geometry = _geometry\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _fourc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n \nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n### Load the last ub calculation used\nlastub()\n \n### Set i10 specific limits\ndef setLimitsAndCuts(delta,eta,chi,phi):\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    if not GDA:\n        setmin(delta, -60.0)\n        setmax(delta, 165.0) \n        setmin(eta, -94.408)\n        setmax(eta, 190.591)\n        setmin(chi, 85.5)\n        setmax(chi, 94.5)\n        setmin(phi, 0)\n        setmax(phi, 360.0)\n    print ""Current hardware limits set to:""\n    hardware()\n\nif not GDA:\n    setLimitsAndCuts(delta,eta,chi,phi)\n\nif GDA:\n    def swithMotors(delta, mu, eta, chi, phi):\n        import __main__\n        from diffcalc.dc import dcyou as _dc\n        \n        ### update Wrap i21 names to get diffcalc names\n        _fourc = ScannableGroup(\'_fourc\', (delta, mu, eta, chi, phi))\n        #update diffcalc objects\n        __main__.settings.hardware = ScannableHardwareAdapter(_fourc, __main__.en, ESMTGKeV)  # @UndefinedVariable\n        __main__.settings.geometry = diffcalc.hkl.you.geometry.FourCircle()  # @UndefinedVariable\n        __main__.settings.energy_scannable = __main__.en  # @UndefinedVariable\n        __main__.settings.axes_scannable_group= _fourc\n        __main__.settings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n        \n        __main__.fourc=DiffractometerScannableGroup(\'fourc\', _dc, _fourc)\n        __main__.hkl = Hkl(\'hkl\', _fourc, _dc)\n        __main__.h, __main__.k, __main__.l = hkl.h, hkl.k, hkl.l\n\n        from diffcalc.gdasupport.you import _virtual_angles\n        from diffcalc.gdasupport.scannable.simulation import SimulatedCrystalCounter\n        from diffcalc.gdasupport.scannable.wavelength import Wavelength\n        __main__.hklverbose = Hkl(\'hklverbose\', _fourc, _dc, _virtual_angles)\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', _fourc, __main__.settings.geometry,__main__.wl)  # @UndefinedVariable\n        \n    def stopMotors(delta, eta, chi, phi):\n        delta.stop()\n        eta.stop()\n        chi.stop()\n        phi.stop()\n        \n    def simdc():\n        \'\'\' switch to use dummy motors in diffcalc\n        \'\'\'\n        print ""Stop real motors""\n        stopMotors(tth,th,chi,phi)\n        \n        global SIM_MODE\n        SIM_MODE=True\n        import __main__\n        __main__.en=Dummy(""en"")\n        print ""Set energy to 12398.425 eV in simulation mode!""\n        __main__.en(12398.425) #1 Angstrom wavelength @UndefinedVariable\n        print ""Switch to simulation motors""\n        swithMotors(simtth,simalpha,simth,simchi,phi)\n        setLimitsAndCuts(simtth,simalpha,simth,simchi,phi)\n        \n    def realdc():\n        \'\'\' switch to use real motors in diffcalc\n        \'\'\'\n        print ""Stop simulation motors""\n        stopMotors(simtth,simalpha,simth,simchi,phi)\n        \n        global SIM_MODE\n        SIM_MODE=False\n        import __main__\n        print ""Set energy to current beamline energy in real mode!""\n        __main__.en=pgm_energy\n        print ""Switch to real motors""\n        swithMotors(tth,th,chi,phi)\n        setLimitsAndCuts(tth,th,chi,phi)\n     \n    from gda.jython.commands.GeneralCommands import alias  # @UnresolvedImport\n    print ""Created commands: \'simdc\' and \'realdc\' to switch between real and simulated motors.""\n    alias(""simdc"")\n    alias(""realdc"")\n\n\nhkl_ccd = Hkl(\'hkl_ccd\', _area_fourc, DiffractometerYouCalculator(_area_hw, _geometry))\nhkl_point = Hkl(\'hkl_point\', _fourc, DiffractometerYouCalculator(_hw, _geometry))\n\n\ndef useccd():\n    print \'- setting hkl ---> hkl_ccd\'\n    global settings\n    settings.hardware = _area_hw\n    settings.energy_scannable = pgm_energy\n    settings.axes_scannable_group= _area_fourc\n\n    # Create diffractometer scannable\n    from diffcalc.dc import dcyou as _dc\n    _diff_scn = DiffractometerScannableGroup(settings.geometry.name, _dc, _area_fourc)\n\n    setLimitsAndCuts(tthArea,thArea,chi,phi)\n    import __main__\n    __main__.hkl = hkl_ccd\n    __main__.h   = hkl_ccd.h\n    __main__.k   = hkl_ccd.k\n    __main__.l   = hkl_ccd.l\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = pgm_energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\ndef usepoint():\n    print \'- setting hkl ---> hkl_point\'\n    global settings\n    settings.hardware = _hw\n    settings.energy_scannable = pgm_energy\n    settings.axes_scannable_group= _fourc\n\n    # Create diffractometer scannable\n    from diffcalc.dc import dcyou as _dc\n    _diff_scn = DiffractometerScannableGroup(settings.geometry.name, _dc, _fourc)\n\n    setLimitsAndCuts(tth,th,chi,phi)\n    import __main__\n    __main__.hkl = hkl_point\n    __main__.h   = hkl_point.h\n    __main__.k   = hkl_point.k\n    __main__.l   = hkl_point.l\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = pgm_energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\ndef usesim():\n    # sample chamber\n    print \'- setting hkl ---> hkl_sim\'\n    print \'-          en ---> simenergy\'\n    global settings\n    settings.hardware = _hw_sim\n    settings.energy_scannable = simenergy\n    settings.axes_scannable_group = _sim_fourc\n\n    # Create diffractometer scannable\n    import __main__\n    _diff_scn_name = settings.geometry.name\n    from diffcalc.dc import dcyou as _dc\n    _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sim_fourc)\n    hkl_sim = Hkl(\'hkl_sim\', _sim_fourc, DiffractometerYouCalculator(_hw_sim, settings.geometry))\n\n    __main__.hkl = hkl_sim\n    __main__.h   = hkl_sim.h\n    __main__.k   = hkl_sim.k\n    __main__.l   = hkl_sim.l\n    setLimitsAndCuts(simtth, simth, simchi, simalpha)\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = simenergy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\n### Demo ###\nif not GDA:\n    demo = demo = startup._demo.Demo(globals(), \'fourc\')\n'"
startup/i13.py,0,"b'from diffcalc.util import x_rotation, y_rotation, z_rotation, TORAD, TODEG\nfrom startup._common_imports import *\nfrom diffcalc.hkl.you.geometry import YouGeometry, YouPosition\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nif not GDA:\n    import startup._demo\n\n\nclass FiveCircleI13(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, gamma, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'diffcalc_fivec\', {\'mu\': 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        delta_phys, gam_phys, eta_phys, chi_phys, phi_phys = physical_angle_tuple\n        return YouPosition(0, delta_phys, gam_phys, -eta_phys, -chi_phys, -phi_phys, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        _, delta_phys, gam_phys, eta_phys, chi_phys, phi_phys = clone_position.totuple()\n        return delta_phys, gam_phys, -eta_phys, -chi_phys, -phi_phys\n\n\ndef set_default_limits():\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    print(""set_default_limits...."")\n    setmax(delta, 90)\n    setmin(delta, -1)\n    setmin(gam, 0)\n    setmax(gam, 90)\n    setmin(eta, -90)\n    setmax(eta, 90)\n    setmin(chi, -10)\n    setmax(chi, 100)\n    setmin(phi, -88)\n    setmax(phi, 88)\n    #setcut(phi, -90)\n    \nif \'_fivec\' in globals() and \'en\' in globals():\n    # Assume we are running in a live GDA deployment with a _fivec ScannableGroup\n    # with axes named: delta, gam, eta, chi, phi.\n    # Ensure that these five Scannables exist.\n    # There must also be Scannable en for moving and reading the energy\n    print ""Diffcalc using predefined _fivec and en Scannables""\nelse:\n    ### Create dummy scannables ###\n    print ""Diffcalc creating dummy Scannables as _fivec and en were not found""\n    delta = Dummy(\'delta\')\n    gam = Dummy(\'gam\')\n    eta = Dummy(\'eta\')\n    chi = Dummy(\'chi\')\n    phi = Dummy(\'phi\')\n    _fivec = ScannableGroup(\'_fivec\', (delta, gam, eta, chi, phi))\n    if not (\'en\' in globals()):\n        print ""Diffcalc creating dummy Scannables as en was not found""\n        en = Dummy(\'en\')\n        en.level = 3\n    #set_default_limits()\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_fivec, en, ESMTGKeV)\nbeamline_axes_transform = matrix([[0, 0, 1],[1, 0, 0], [0, 1, 0,]])\nsettings.geometry = FiveCircleI13(beamline_axes_transform=beamline_axes_transform)\nsettings.energy_scannable = en\nsettings.axes_scannable_group = _fivec\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n  \n# Load the last ub calculation used  \n# lastub()\n\n# \n# setmax(delta, 28)\n# setmin(delta, -1)\n# setmin(gam, 0)\n# setmax(gam, 16)\n# setmin(eta, -10)\n# setmax(eta, 10)\n# setmin(chi, 90 - 12)\n# setmax(chi, 90 + 12)\n# setmin(phi, -88)\n# setmax(phi, 88)\n# setcut(phi, -90)\n# hardware()\n\nif not GDA:\n    setmax(delta, 90)\n    setmin(delta, -1)\n    setmin(gam, 0)\n    setmax(gam, 90)\n    setmin(eta, -90)\n    setmax(eta, 90)\n    setmin(chi, -10)\n    setmax(chi, 100)\n    setmin(phi, -88)\n    setmax(phi, 88)\n    setcut(phi, -90)\nhardware()\n\n\n\n#def X(th_deg):\n#    return x_rotation(th_deg * TORAD)\n#\n#\n#def Y(th_deg):\n#    return y_rotation(th_deg * TORAD)\n#                      \n#\n#def Z(th_deg):\n#    return z_rotation(th_deg * TORAD)\n#\n#\n#WEDGE = X(15)\n\n\nif not GDA:\n    demo = startup._demo.Demo(globals(), \'fivec\')\n    \n\n\n\n""""""\nFivec, no real limits, working out U matrix\n===========================================\nU = xyz_rotation([-0.70711, 0.70711, 0.00000], 54.73561 * TORAD)\nsetu U\npos en 20\ncon qaz 90\ncon a_eq_b\nUBCALC\n\n   name:     2017-03-07-i13\n\n   n_phi:     -0.00000  -0.00000   1.00000\n   n_hkl:      0.57735   0.57735   0.57735 <- set\n   miscut:\n      angle:   0.00003\n      axis:    0.70711  -0.70711   0.00000\n\nCRYSTAL\n\n   name:         Si111\n\n   a, b, c:    5.43000   5.43000   5.43000\n              90.00000  90.00000  90.00000\n\n   B matrix:   1.15712   0.00000   0.00000\n               0.00000   1.15712   0.00000\n               0.00000   0.00000   1.15712\n\nUB MATRIX\n\n   U matrix:   0.78868  -0.21133  -0.57735\n              -0.21132   0.78867  -0.57735\n               0.57735   0.57735   0.57735\n\n      angle:  54.73564\n       axis:   0.70711  -0.70711   0.00000\n\n   UB matrix:  0.91260  -0.24453  -0.66807\n              -0.24453   0.91259  -0.66807\n               0.66807   0.66807   0.66807\n\nREFLECTIONS\n\n     ENERGY     H     K     L     DELTA      GAM      ETA      CHI      PHI  TAG\n   1 20.000  1.00  1.00  1.00   11.3483   0.0000   5.6741  90.0000  45.0000  \n   2 20.000  4.00  0.00  0.00   26.3978   0.0000  13.1989  35.2644 -15.0000  \n\nIn [80]: listub\nUB calculations in: /Users/zrb13439/.diffcalc/i13\n\n 0) 2017-03-07-i13  14 Mar 2017 (14:35)\n 1) test            07 Mar 2017 (11:38)\n \n In [81]: hardware\n    -1.0 <= delta <=   90.0 (cut: -180.0)\n     0.0 <=   gam <=   90.0 (cut: -180.0)\n   -90.0 <=   eta <=   90.0 (cut: -180.0)\n   -10.0 <=   chi <=  100.0 (cut: -180.0)\n  -180.0 <=   phi <=  180.0 (cut:  -90.0)\nNote: When auto sector/transforms are used,\n       cuts are applied before checking limits.\n       \nAdd in delta and gamma constraintss:\nIn [85]: atan(28/16)*TODEG\nOut[85]: 45.0\n\nIn [86]: atan(28/16.)*TODEG\nOut[86]: 60.25511870305777\n\nIn [87]: con qaz 60\n    qaz  : 60.0000\n    a_eq_b\n    mu   : 0.0000\n\nIn [88]: sim hkl [4 0 0]\n_fivec would move to:\n  delta :   22.6459\n    gam :   13.9379\n    eta :   59.2132\n    chi :    8.8270\n    phi :  -63.0717\n\n  alpha :    7.5752\n   beta :    7.5752\n    naz :    4.5446\n    psi :   90.0000\n    qaz :   60.0000\n    tau :   54.7356\n  theta :   13.1989\n\n""""""\n'"
startup/i16.py,0,"b'from startup._common_imports import *\nfrom diffcalc.hkl.you.geometry import YouPosition\nimport diffcalc.hkl.you.geometry\nif not GDA:\n    import startup._demo\n\nLOCAL_MANUAL = \'http://confluence.diamond.ac.uk/display/I16/Diffcalc%20(i16)\'\n\nclass SixCircleI16(diffcalc.hkl.you.geometry.YouGeometry):\n    def __init__(self):\n        diffcalc.hkl.you.geometry.YouGeometry.__init__(self, \'sixc\', {})\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        #    i16:   phi, chi, eta, mu, delta, gam\n        # H. You:   mu, delta, nu, eta, chi, phi\n        phi_phys, chi_phys, eta_phys, mu_phys, delta_phys, gam_phys = physical_angle_tuple\n        return YouPosition(mu_phys, delta_phys, gam_phys, eta_phys, chi_phys, phi_phys, unit=\'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        mu_phys, delta_phys, nu_phys, eta_phys, chi_phys, phi_phys = clone_position.totuple()\n        return phi_phys, chi_phys, eta_phys, mu_phys, delta_phys, nu_phys\n\n\nif GDA:\n    from scannable.extraNameHider import ExtraNameHider\n    dummy_energy = Dummy(\'dummy_energy\')\n    simple_energy = ExtraNameHider(\'energy\', dummy_energy)  # @UndefinedVariable\n    if \'euler\' not in locals():\n        raise Exception(\'Expecting a device called euler\')\n\nelse: # Assume running in dummy mode outside GDA\n    mu = Dummy(\'mu\')\n    delta = Dummy(\'delta\')\n    gam = Dummy(\'gam\')\n    eta = Dummy(\'eta\')\n    chi = Dummy(\'chi\')\n    phi = Dummy(\'phi\')\n    euler = ScannableGroup(\'euler\', (phi, chi, eta, mu, delta, gam))\n    en = simple_energy = Dummy(\'energy\')\n    en.level = 3\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(euler, simple_energy, ESMTGKeV)\nsettings.geometry = SixCircleI16()\nsettings.energy_scannable = simple_energy\nsettings.axes_scannable_group= euler\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nfrom diffcalc.hkl.you.persistence import YouStateEncoder\nsettings.ubcalc_persister = UBCalculationJSONPersister(diffcalc.settings.ubcalc_persister.directory,\n                                                                YouStateEncoder)\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nhkl.setLevel(6)\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n    \nlastub()  # Load the last ub calculation used\n\nfrom startup.beamlinespecific.azihkl import AzihklClass\nazihkl=AzihklClass(\'aziref\')\nazihkl()\n\n# iPython removes the actual command from namespace\nif not GDA:\n    diffcalc.hardware.setrange(chi, -2, 100)\n    diffcalc.hardware.setrange(eta, -2, 92)\n    diffcalc.hardware.setrange(delta, -2, 145)\n    diffcalc.hardware.setrange(gam, -2, 145)\n    setcut(phi, -180)\n\n    demo = startup._demo.Demo(globals(), \'i16\')\n'"
startup/i21.py,0,"b'from startup._common_imports import *  # @UnusedWildImport\n\nfrom diffcalc.gdasupport.scannable.diffractometer import DiffractometerScannableGroup\nfrom startup.beamlinespecific.i21 import FourCircleI21, DiffractometerTPScannableGroup, TPScannableGroup\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nif not GDA:    \n    import startup._demo\nelse:\n#     import __main__  # @UnresolvedImport\n    from __main__ import th, chi, phi, difftth, m5tth, energy, simth,simchi,simphi,simdelta,simm5tth, ps_chi, ps_phi # @UnresolvedImport\n\nLOCAL_MANUAL = ""http://confluence.diamond.ac.uk/x/UoIQAw""\n# Diffcalc i21\n# ======== === \n# delta    difftth or m5tth\n# eta      th\n# chi      chi\n# phi      -phi\n\n### Create dummy scannables ###\nif not GDA:  \n    delta = Dummy(\'delta\')\n    m5tth = Dummy(\'m5tth\')\n    th = Dummy(\'th\')\n    chi = Dummy(\'chi\')\n    phi = Dummy(\'phi\')\n\n### Wrap i21 names to get diffcalc names - sample chamber\nif GDA:\n    en=energy\n    if float(en.getPosition()) == 0: # no energy value - dummy?\n        en(800)\n    simenergy = Dummy(\'en\')\n    simenergy(800)\nelse:\n    en = simenergy = Dummy(\'en\')\n    en(800)\n\nen.level = 3\nsimenergy.level = 3\n\n### Configure and import diffcalc objects ###\nbeamline_axes_transform = matrix(\'0 0 -1; 0 1 0; 1 0 0\')\n_lowq_geometry = FourCircleI21(beamline_axes_transform=beamline_axes_transform, delta_offset=-4.)\n_highq_geometry = FourCircleI21(beamline_axes_transform=beamline_axes_transform, delta_offset=4.)\n_tth_geometry = FourCircleI21(beamline_axes_transform=beamline_axes_transform)\n\nif GDA:\n    _sc_difftth = ScannableGroup(\'_fourc\', (difftth, th, chi, phi))\n    _sc_m5tth = ScannableGroup(\'_fourc\', (m5tth, th, chi, phi))\n\n    _sc_difftth_tp = TPScannableGroup(\'_fourc\', (difftth, th, ps_chi, ps_phi))\n    _sc_m5tth_tp = TPScannableGroup(\'_fourc\', (m5tth, th, ps_chi, ps_phi))\n\n    _sc_sim = ScannableGroup(\'_fourc\', (simdelta, simth, simchi, simphi))\nelse:\n    _sc_difftth = _sc_m5tth = _sc_sim = ScannableGroup(\'_fourc\', (delta, th, chi, phi))\n\nESMTGKeV = 0.001\n_hw_difftth = ScannableHardwareAdapter(_sc_difftth, en, ESMTGKeV)\n_hw_m5tth = ScannableHardwareAdapter(_sc_m5tth, en, ESMTGKeV)\nif GDA:\n    _hw_difftth_tp = ScannableHardwareAdapter(_sc_difftth_tp, en, ESMTGKeV)\n    _hw_m5tth_tp = ScannableHardwareAdapter(_sc_m5tth_tp, en, ESMTGKeV)\n_hw_sim = ScannableHardwareAdapter(_sc_sim, simenergy, ESMTGKeV)\n\nsettings.hardware = _hw_difftth\nsettings.geometry = _tth_geometry\nsettings.energy_scannable = en\nsettings.axes_scannable_group = _sc_difftth\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nfrom diffcalc.hkl.you.persistence import YouStateEncoder\nsettings.ubcalc_persister = UBCalculationJSONPersister(diffcalc.settings.ubcalc_persister.directory,\n                                                                YouStateEncoder)\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n \n### Load the last ub calculation used\nfrom diffcalc.ub.ub import lastub\nlastub()\n \n### Set i21 specific limits\ndef setLimitsAndCuts(delta_angle, eta_angle, chi_angle, phi_angle):\n    \'\'\' set motor limits for diffcalc, these are within the actual motor limits\n    \'\'\'\n    if not GDA:\n        print ""INFO: diffcalc limits set in $diffcalc/startup/i21.py taken from http://confluence.diamond.ac.uk/pages/viewpage.action?pageId=51413586""\n        setmin(delta_angle, 0.0)\n        setmax(delta_angle, 180.0) #default to diode delta limits\n        setmin(chi_angle, -41.0)\n        setmax(chi_angle, 36.0)\n        setmin(eta_angle, 0.0)\n        setmax(eta_angle, 150.0)\n        setmin(phi_angle, -100.0)\n        setmax(phi_angle, 100.0)\n    #http://jira.diamond.ac.uk/browse/I21-361\n    setcut(eta_angle, 0.0)\n    setcut(phi_angle, -180.0)\n    print ""Current hardware limits set to:""\n    hardware()\n\nif GDA:\n    setLimitsAndCuts(difftth, th, chi, phi)\nelse:\n    setLimitsAndCuts(delta, th, chi, phi)\n\n\n### Create i21 bespoke secondary hkl devices\n# Warning: this breaks the encapsulation provided by the diffcalc.dc.you public\n#          interface, and may be prone to breakage in future.\n\nprint \'Creating i21 bespoke scannables:\'\n\n\nhkl_m5tth = Hkl(\'hkl_m5tth\', _sc_m5tth, DiffractometerYouCalculator(_hw_m5tth, _tth_geometry))\nhkl_lowq = Hkl(\'hkl_lowq\', _sc_m5tth, DiffractometerYouCalculator(_hw_m5tth, _lowq_geometry))\nhkl_highq = Hkl(\'hkl_highq\', _sc_m5tth, DiffractometerYouCalculator(_hw_m5tth, _highq_geometry))\nhkl_difftth = Hkl(\'hkl_difftth\', _sc_difftth, DiffractometerYouCalculator(_hw_difftth, _tth_geometry))\nif GDA:\n    hkl_m5tth_tp = Hkl(\'hkl_m5tth_tp\', _sc_m5tth_tp, DiffractometerYouCalculator(_hw_m5tth_tp, _tth_geometry))\n    hkl_lowq_tp = Hkl(\'hkl_lowq_tp\', _sc_m5tth_tp, DiffractometerYouCalculator(_hw_m5tth_tp, _lowq_geometry))\n    hkl_highq_tp = Hkl(\'hkl_highq_tp\', _sc_m5tth_tp, DiffractometerYouCalculator(_hw_m5tth_tp, _highq_geometry))\n    hkl_difftth_tp = Hkl(\'hkl_difftth_tp\', _sc_difftth_tp, DiffractometerYouCalculator(_hw_difftth_tp, _tth_geometry))\n\nhkl_sim = Hkl(\'hkl_sim\', _sc_sim, DiffractometerYouCalculator(_hw_sim, _tth_geometry))\n\n# Custom scannables\nfrom startup.beamlinespecific.conic_scannables import conic_h, conic_k, conic_l, conic_th\n\ndef usem5tth_tp():\n    if GDA:\n        usem5tth(True)\n\ndef uselowq_tp():\n    if GDA:\n        uselowq(True)\n\ndef usehighq_tp():\n    if GDA:\n        usehighq(True)\n\ndef usedifftth_tp():\n    if GDA:\n        usedifftth(True)\n\ndef usem5tth(tp=None):\n    print \'- setting hkl ---> hkl_m5tth\'\n    global settings\n    if tp:\n        settings.hardware = _hw_m5tth_tp\n    else:\n        settings.hardware = _hw_m5tth\n    settings.geometry = _tth_geometry\n    if tp:\n        settings.axes_scannable_group = _sc_m5tth_tp\n    else:\n        settings.axes_scannable_group = _sc_m5tth\n\n    # Create diffractometer scannable\n    _diff_scn_name = _tth_geometry.name\n    from diffcalc.dc import dcyou as _dc\n    reload(_dc)\n    lastub()\n\n    if tp:\n        _diff_scn = DiffractometerTPScannableGroup(_diff_scn_name, _dc, _sc_m5tth_tp)\n    else:\n        _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sc_m5tth)\n\n    if tp:\n        setLimitsAndCuts(m5tth, th, ps_chi, ps_phi)\n    elif GDA:\n        setLimitsAndCuts(m5tth, th, chi, phi)\n    else:\n        setLimitsAndCuts(delta, th, chi, phi)\n\n    import __main__\n    if tp:\n        __main__.hkl = hkl_m5tth_tp\n        __main__.h   = hkl_m5tth_tp.h\n        __main__.k   = hkl_m5tth_tp.k\n        __main__.l   = hkl_m5tth_tp.l\n    else:\n        __main__.hkl = hkl_m5tth\n        __main__.h   = hkl_m5tth.h\n        __main__.k   = hkl_m5tth.k\n        __main__.l   = hkl_m5tth.l\n\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\n    # Custom scannables\n    import startup.beamlinespecific.conic_scannables as _conic\n    reload(_conic)\n    __main__.conic_h = _conic.conic_h\n    __main__.conic_k = _conic.conic_k\n    __main__.conic_l = _conic.conic_l\n\n\ndef uselowq(tp=None):\n    print \'- setting hkl ---> hkl_lowq\'\n    global settings\n    if tp:\n        settings.hardware = _hw_m5tth_tp\n    else:\n        settings.hardware = _hw_m5tth\n    settings.geometry = _lowq_geometry\n    if tp:\n        settings.axes_scannable_group = _sc_m5tth_tp\n    else:\n        settings.axes_scannable_group = _sc_m5tth\n\n    # Create diffractometer scannable\n    _diff_scn_name = _lowq_geometry.name\n    from diffcalc.dc import dcyou as _dc\n    reload(_dc)\n    lastub()\n\n    if tp:\n        _diff_scn = DiffractometerTPScannableGroup(_diff_scn_name, _dc, _sc_m5tth_tp)\n    else:\n        _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sc_m5tth)\n\n    if tp:\n        setLimitsAndCuts(m5tth, th, ps_chi, ps_phi)\n    elif GDA:\n        setLimitsAndCuts(m5tth, th, chi, phi)\n    else:\n        setLimitsAndCuts(delta, th, chi, phi)\n    \n    import __main__\n    if tp:\n        __main__.hkl = hkl_lowq_tp\n        __main__.h   = hkl_lowq_tp.h\n        __main__.k   = hkl_lowq_tp.k\n        __main__.l   = hkl_lowq_tp.l\n    else:\n        __main__.hkl = hkl_lowq\n        __main__.h   = hkl_lowq.h\n        __main__.k   = hkl_lowq.k\n        __main__.l   = hkl_lowq.l\n\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\n    # Custom scannables\n    import startup.beamlinespecific.conic_scannables as _conic\n    reload(_conic)\n    __main__.conic_h = _conic.conic_h\n    __main__.conic_k = _conic.conic_k\n    __main__.conic_l = _conic.conic_l\n\n\ndef usehighq(tp=None):\n    print \'- setting hkl ---> hkl_highq\'\n    global settings\n    if tp:\n        settings.hardware = _hw_m5tth_tp\n    else:\n        settings.hardware = _hw_m5tth\n    settings.geometry = _highq_geometry\n    if tp:\n        settings.axes_scannable_group = _sc_m5tth_tp\n    else:\n        settings.axes_scannable_group = _sc_m5tth\n\n    # Create diffractometer scannable\n    _diff_scn_name = _highq_geometry.name\n    from diffcalc.dc import dcyou as _dc\n    reload(_dc)\n    lastub()\n\n    if tp:\n        _diff_scn = DiffractometerTPScannableGroup(_diff_scn_name, _dc, _sc_m5tth_tp)\n    else:\n        _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sc_m5tth)\n\n    if tp:\n        setLimitsAndCuts(m5tth, th, ps_chi, ps_phi)\n    elif GDA:\n        setLimitsAndCuts(m5tth, th, chi, phi)\n    else:\n        setLimitsAndCuts(delta, th, chi, phi)\n\n    import __main__\n    if tp:\n        __main__.hkl = hkl_highq_tp\n        __main__.h   = hkl_highq_tp.h\n        __main__.k   = hkl_highq_tp.k\n        __main__.l   = hkl_highq_tp.l\n    else:\n        __main__.hkl = hkl_highq\n        __main__.h   = hkl_highq.h\n        __main__.k   = hkl_highq.k\n        __main__.l   = hkl_highq.l\n\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\n    # Custom scannables\n    import startup.beamlinespecific.conic_scannables as _conic\n    reload(_conic)\n    __main__.conic_h = _conic.conic_h\n    __main__.conic_k = _conic.conic_k\n    __main__.conic_l = _conic.conic_l\n\ndef usedifftth(tp=None):\n    # sample chamber\n    print \'- setting hkl ---> hkl_difftth\'\n    global settings\n    if tp:\n        settings.hardware = _hw_difftth_tp\n    else:\n        settings.hardware = _hw_difftth\n    settings.geometry = _tth_geometry\n    if tp:\n        settings.axes_scannable_group = _sc_difftth_tp\n    else:\n        settings.axes_scannable_group = _sc_difftth\n\n    # Create diffractometer scannable\n    _diff_scn_name = _tth_geometry.name\n\n    from diffcalc.dc import dcyou as _dc\n    reload(_dc)\n    lastub()\n\n    if tp:\n        _diff_scn = DiffractometerTPScannableGroup(_diff_scn_name, _dc, _sc_difftth_tp)\n    else:\n        _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sc_difftth)\n\n    if tp:\n        setLimitsAndCuts(difftth, th, ps_chi, ps_phi)\n    elif GDA:\n        setLimitsAndCuts(difftth, th, chi, phi)\n    else:\n        setLimitsAndCuts(delta, th, chi, phi)\n\n    import __main__\n    if tp:\n        __main__.hkl = hkl_difftth_tp\n        __main__.h   = hkl_difftth_tp.h\n        __main__.k   = hkl_difftth_tp.k\n        __main__.l   = hkl_difftth_tp.l\n    else:\n        __main__.hkl = hkl_difftth\n        __main__.h   = hkl_difftth.h\n        __main__.k   = hkl_difftth.k\n        __main__.l   = hkl_difftth.l\n\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = energy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n\n    # Custom scannables\n    import startup.beamlinespecific.conic_scannables as _conic\n    reload(_conic)\n    __main__.conic_h = _conic.conic_h\n    __main__.conic_k = _conic.conic_k\n    __main__.conic_l = _conic.conic_l\n\ndef usesim():\n    # sample chamber\n    print \'- setting hkl ---> hkl_sim\'\n    print \'-          en ---> simenergy\'\n    global settings\n    settings.hardware = _hw_sim\n    settings.geometry = _tth_geometry\n    settings.axes_scannable_group = _sc_sim\n\n    setLimitsAndCuts(simdelta, simth, simchi, simphi)\n\n    # Create diffractometer scannable\n    import __main__\n    _diff_scn_name = _tth_geometry.name\n    from diffcalc.dc import dcyou as _dc\n    reload(_dc)\n    lastub()\n\n    _diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _sc_sim)\n\n    __main__.hkl = hkl_sim\n    __main__.h   = hkl_sim.h\n    __main__.k   = hkl_sim.k\n    __main__.l   = hkl_sim.l\n\n    __main__.fourc = _diff_scn\n    from diffcalc.gdasupport.you import _virtual_angles\n    __main__.hklverbose = Hkl(\'hklverbose\', __main__.fourc, _dc, _virtual_angles)\n    if GDA:\n        __main__.en = simenergy\n        __main__.wl = Wavelength(\'wl\',__main__.en,ESMTGKeV)  # @UndefinedVariable\n        __main__.ct = SimulatedCrystalCounter(\'ct\', __main__.fourc, settings.geometry, __main__.wl)  # @UndefinedVariable\n    # Custom scannables\n    import startup.beamlinespecific.conic_scannables as _conic\n    reload(_conic)\n    __main__.conic_h = _conic.conic_h\n    __main__.conic_k = _conic.conic_k\n    __main__.conic_l = _conic.conic_l\n\n\nprint ""Created i21 bespoke commands:      usem5tth,    uselowq,    usehighq,    usedifftth""\nprint ""Set toolpoint mode using commands: usem5tth_tp, uselowq_tp, usehighq_tp, usedifftth_tp""\nprint ""Set simulation mode using command: usesim""\n\nif GDA:\n    from gda.jython.commands.GeneralCommands import alias  # @UnresolvedImport\n    alias(""usem5tth"")\n    alias(""uselowq"")\n    alias(""usehighq"")\n    alias(""usedifftth"")\n    alias(""usem5tth_tp"")\n    alias(""uselowq_tp"")\n    alias(""usehighq_tp"")\n    alias(""usedifftth_tp"")\n    alias(""usesim"")\nelse:\n    from IPython.core.magic import register_line_magic  # @UnresolvedImport\n    from diffcmd.ipython import parse_line\n    if IPYTHON:\n        from IPython import get_ipython  # @UnresolvedImport @UnusedImport\n        register_line_magic(parse_line(usem5tth, globals()))\n        del usem5tth\n        register_line_magic(parse_line(uselowq, globals()))\n        del uselowq\n        register_line_magic(parse_line(usehighq, globals()))\n        del usehighq\n        register_line_magic(parse_line(usedifftth, globals()))\n        del usedifftth\n        register_line_magic(parse_line(usem5tth_tp, globals()))\n        del usem5tth_tp\n        register_line_magic(parse_line(uselowq_tp, globals()))\n        del uselowq_tp\n        register_line_magic(parse_line(usehighq_tp, globals()))\n        del usehighq_tp\n        register_line_magic(parse_line(usedifftth_tp, globals()))\n        del usedifftth_tp\n        register_line_magic(parse_line(usesim, globals()))\n        del usesim\n\n### Demo ###\n\nif not GDA:\n    class I21Demo(startup._demo.Demo):\n        \n        def __init__(self, namespace):\n            startup._demo.Demo.__init__(self, namespace, \'i21\')\n        \n        def i21(self):\n            startup._demo.print_heading(\'i21 scannables demo\')\n    \n            self.echorun_magiccmd_list([\n                \'pos th 1\',\n                \'pos chi 2\',\n                \'pos phi 3\',\n                \'pos m5tth 4\',\n                \'usem5tth\',\n                \'fourc\'])\n        \n    demo = I21Demo(globals())\nelse: \n    print ""DIFFCALC demo:""\n    class I21Demo(object):\n        \n        def __init__(self, namespace):\n            self.namespace = namespace\n\n        def all(self):\n            self.orient()\n            self.constrain()\n            self.scan()\n            \n        def remove_test_ubcalc(self):\n            try:\n                eval(""rmub(\'test\')"", self.namespace)\n            except (OSError, KeyError):\n                pass\n        \n        def executeCommand(self, cmd_list):\n            for cmd in cmd_list:\n                if cmd == \'help ub\':\n                    print(""help ub"")\n                    exec(""print ub.__doc__"", self.namespace)\n                elif cmd == \'help hkl\':\n                    print(""help(hkl)"")\n                    exec(""print hkl.__doc__"", self.namespace)\n                else:    \n                    exec(cmd, self.namespace) \n    \n        def orient(self):\n            print\n            print ""-""*100\n            print \'Orientation demo\'\n            print\n            self.remove_test_ubcalc()\n            cmd_list=[\n                \'help ub\',\n                ""from gda.jython.commands.ScannableCommands import pos; pos(wl, 10)"",\n                ""newub(\'test\')"",\n                ""setlat(\'cubic\', 1,1, 1, 90, 90, 90)"",\n                \'ub\',\n                \'c2th([0, 0, .1])\',\n                \'from gda.jython.commands.ScannableCommands import pos; pos(fourc, [60, 30, 0, 0])\',\n                \'addref([0, 0, .1])\',\n                \'c2th([0, .1, .1])\',\n                \'from gda.jython.commands.ScannableCommands import pos; pos(fourc, [90, 90, 0, 0])\',\n                \'addref([0, .1, .1])\',\n                \'ub\',\n                \'checkub\']        \n            self.executeCommand(cmd_list)\n            \n        def constrain(self):\n            print\n            print ""-""*100\n            print \'Constraint demo\'\n            print\n            cmd_list=[\n                \'help hkl\',\n                \'con(a_eq_b)\',\n                \'con\']\n            self.executeCommand(cmd_list)\n    \n        def scan(self):\n            print\n            print ""-""*100\n            print \'Scanning demo\'\n            print\n            \n            cmd_list=[\n                \'setnphi([0, 0, 1])\',\n                \'pos hkl([0, 0, .1])\',\n                \'scan(difftth, 40, 90, 10, hkl, ct, 1)\',\n                \'pos(hkl, [0, .1, 0])\',\n                \'scan(h, 0, .1, .02, k, l, fourc, ct, 1)\',\n                \'con(psi)\',\n                \'scan(psi, 0, 90, 10, hkl, [.1, 0, .1], th, chi, phi, ct, .1)\']\n            self.executeCommand(cmd_list)\n'"
startup/sixcircle.py,0,"b'from startup._common_imports import *\nimport startup._demo\n\n### Create dummy scannables ###\nmu = Dummy(\'mu\')\ndelta = Dummy(\'delta\')\ngam = Dummy(\'gam\')\neta = Dummy(\'eta\')\nchi = Dummy(\'chi\')\nphi = Dummy(\'phi\')\n_sixc = ScannableGroup(\'_sixc\', (mu, delta, gam, eta, chi, phi))\nen = Dummy(\'en\')\nen.level = 3\n\n\n### Configure and import diffcalc objects ###\nESMTGKeV = 1\nsettings.hardware = ScannableHardwareAdapter(_sixc, en, ESMTGKeV)\nsettings.geometry = diffcalc.hkl.you.geometry.SixCircle()  # @UndefinedVariable\nsettings.energy_scannable = en\nsettings.axes_scannable_group= _sixc\nsettings.energy_scannable_multiplier_to_get_KeV = ESMTGKeV\n\nfrom diffcalc.gdasupport.you import *  # @UnusedWildImport\n\nif GDA:\n    print ""Running in GDA --- aliasing commands""\n    alias_commands(globals())\n\n# Load the last ub calculation used\nlastub()\n\n# Set some limits\nsetmin(\'gam\', -179)\nsetmax(\'gam\', 179)\n\ndemo = startup._demo.Demo(globals(), \'sixc\')'"
test/__init__.py,0,b''
test/test_numjy.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom nose.tools import eq_, ok_, assert_almost_equal  # @UnresolvedImport\nfrom nose.plugins.skip import SkipTest\n\ntry:\n    import numpy\n    __NUMPY_AVAILABLE__ = True\nexcept ImportError:\n    __NUMPY_AVAILABLE__ = False\ntry:\n    import numjy\n    import Jama\n    __NUMJY_AVAILABLE__ = True\nexcept ImportError:\n    __NUMJY_AVAILABLE__ = False\n\nfrom test.tools import assert_2darray_almost_equal, meq_\n\n\nclass _TestNumpyMatrix():\n\n    def m(self, args):\n        raise NotImplementedError()\n\n    def test__init__(self):\n        m = self.m([[1, 2], [3, 4]])\n        meq_(self.m('1 2;3 4'), m)\n        meq_(self.m('1 2; 3 4'), m)\n        meq_(self.m('1, 2; 3, 4'), m)\n        meq_(self.m('1, 2; 3 4'), m)\n        meq_(self.m('1 ,  2;  3  4  '), m)\n        \n    def test__init__with_row_vector(self):\n        meq_(self.m([1, 2]), self.m([[1, 2]]))\n\n    def test_shape(self):\n        shape = self.m('1 2 3; 4 5 6').shape\n        eq_(len(shape), 2)\n        eq_(shape[0], 2)\n        eq_(shape[1], 3)\n\n    def test_len(self):\n        eq_(len(self.m('1 2 3; 4 5 6')), 2)\n\n    def test_2dslice(self):\n        m = self.m('0 1; 10 11')\n        eq_(m[0, 0], 00)\n        eq_(m[0, 1], 01)\n        eq_(m[1, 0], 10)\n        eq_(m[1, 1], 11)\n\n    def test_set_2dslice(self):\n        m = self.m('1 2; 3 4')\n        m[1, 1] = 40\n        meq_(m, self.m('1 2; 3 40'))\n\n    def test_tolist(self):\n        l = [[1, 2], [3, 4]]\n        assert_2darray_almost_equal(self.m(l).tolist(), l)\n\n    def test__str__(self):\n        eq_(str(self.m('1.234 2.; 3.1 4.')),\n            '[[1.234 2.   ]\\n [3.1   4.   ]]')\n\n    def test__repr__(self):\n        eq_(repr(self.m('1. 2.; 3. 4.')),\n            'matrix([[1., 2.],\\n        [3., 4.]])')\n\n    def test_all(self):\n        ok_(self.m([[True, True], [True, True]]).all())\n        ok_(not self.m([[True, False], [True, True]]).all())\n\n    def test_eq(self):\n        meq_(self.m('1 2; 3 4'),\n             self.m('1 2; 3 4.'))\n\n    def test_eq_false(self):\n        ok_(not (self.m('1 2; 3 4') == self.m('1 2; 3 5')).all())\n\n    def test__eq__(self):\n        meq_(self.m('1 2; 3 4') == self.m('1 2; 3 4.1'),\n             self.m([[True, True], [True, False]]))\n\n    def test__mul__matrix(self):\n        meq_(self.m('1 2; 3 4') * self.m('5 6; 7 8'),\n             self.m('19 22; 43 50'))\n\n    def test__mul__vector(self):\n        meq_(self.m('1 2; 3 4') * self.m('5; 7'),\n             self.m('19; 43'))\n\n    def test__mul__scaler(self):\n        meq_(self.m('1, 2; 3, 4') * 10,\n             self.m('10 20; 30 40'))\n\n    def test__sum__(self):\n        meq_(self.m('1 2; 3 4') + self.m('5 6; 7 8'),\n             self.m(' 6 8; 10 12'))\n\n    def test__sum__scaler(self):\n        meq_(self.m('1 2; 3 4') + 10,\n             self.m('11 12; 13 14'))\n\n    def test__sub__(self):\n        meq_(self.m('1 2; 3 4') - self.m('5 6; 7 8'),\n             self.m('-4 -4; -4 -4'))\n\n    def test__sub__scaler(self):\n        meq_(self.m('11 12; 13 14') - 10,\n             self.m('1 2; 3 4'))\n\n    def test__div__(self):\n        r = self.m('1 2; 3 4') / self.m('5. 6.; 7. 8.')\n        assert_almost_equal(r[0, 0], .2)\n        assert_almost_equal(r[0, 1], .33333333)\n        assert_almost_equal(r[1, 0], 0.42857143)\n        assert_almost_equal(r[1, 1], .5)\n\n    def test__div__scaler(self):\n        meq_(self.m('10 20; 30 40') / 10.,\n             self.m('1 2; 3 4'))\n\n    def test_I(self):\n        inverse = self.m('1 2; 3 4').I\n        assert_almost_equal(inverse[0, 0], -2)\n        assert_almost_equal(inverse[0, 1], 1)\n        assert_almost_equal(inverse[1, 0], 1.5)\n        assert_almost_equal(inverse[1, 1], -.5)\n\n    def test_T(self):\n        meq_(self.m('1 2; 3 4').T,\n             self.m('1 3; 2 4'))\n\n    def test_sum(self):\n        eq_(self.m('1 2; 3 4').sum(), 10)\n\n\nclass _TestLinalg():\n\n    def matrix(self, args):\n        raise NotImplementedError()\n\n    def norm(self, args):\n        raise NotImplementedError()\n\n    def test_norm_frobenius(self):\n        m1 = self.matrix('1 1 1; 1 1 1; 1 1 1')\n        assert_almost_equal(self.norm(m1), 3, places=13)\n        m2 = self.matrix('1 2 3; 4 5 6; 7 8 9')\n        assert_almost_equal(self.norm(m2), 16.881943016134134, places=13)\n\n\nclass _TestNumpy():\n\n    def matrix(self, args):\n        raise NotImplementedError()\n\n    def hstack(self, args):\n        raise NotImplementedError()\n\n    def test_hstack(self):\n        v1 = self.matrix('1;2;3')\n        v2 = self.matrix('4;5;6')\n        v3 = self.matrix('7;8;9')\n        meq_(self.hstack([v1, v2, v3]), self.matrix('1,4,7;2,5,8;3,6,9'))\n\n\nif __NUMPY_AVAILABLE__:\n\n    class TestNumpyMatrix(_TestNumpyMatrix):\n\n        def m(self, args):\n            return numpy.matrix(args)\n\n    class TestLinalgNumpy(_TestLinalg):\n\n        def matrix(self, args):\n            return numpy.matrix(args)\n\n        def norm(self, args):\n            return numpy.linalg.norm(args)\n\n    class TestNumpy(_TestNumpy):\n\n        def matrix(self, args):\n            return numpy.matrix(args)\n\n        def hstack(self, args):\n            return numpy.hstack(args)\n\n\nif __NUMJY_AVAILABLE__:\n\n    class TestNumjyMatrix(_TestNumpyMatrix):\n\n        def m(self, args):\n            return numjy.matrix(args)\n\n        def test__str__(self):\n            eq_(str(self.m('1.234 2.0; 3.1 4.0')),\n                '[[1.234  2.0]\\n [3.1  4.0]]')\n\n        def test__repr__(self):\n            print repr(self.m('1. 2.; 3. 4.'))\n            eq_(repr(self.m('1. 2.; 3. 4.')),\n                'matrix([[1.0  2.0]\\n        [3.0  4.0]])')\n\n        def test__div__(self):\n            raise SkipTest()\n\n    class TestLinalgNumjy(_TestLinalg):\n\n        def matrix(self, args):\n            return numjy.matrix(args)\n\n        def norm(self, args):\n            return numjy.linalg.norm(args)\n\n        def hstack(self, args):\n            return numjy.hstack(args)\n\n    class TestNumjy(_TestNumpy):\n\n        def matrix(self, args):\n            return numjy.matrix(args)\n\n        def hstack(self, args):\n            return numjy.hstack(args)\n"""
test/test_tools.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom test.tools import assert_almost_equal, assert_array_almost_equal, \\\n    assert_2darray_almost_equal, assert_matrix_almost_equal, \\\n    assert_dict_almost_equal\nfrom nose.tools import eq_  # @UnresolvedImport\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\nclass test_assert_almost_equal():\n\n    def test_fails(self):\n        try:\n            assert_almost_equal(1, 1.0000001)\n            assert False\n        except AssertionError:\n#            eq_(e.args[0], \'1 != 1.0000001000000001 within 7 places\')\n            pass\n\n    def test__passes(self):\n        assert_almost_equal(1, 1.00000001)\n        assert_almost_equal(1, 1.0000001, 6)\n\n\nclass test_assert_array_almost_equal():\n\n    def test__passes(self):\n        assert_array_almost_equal((1, 2, 3), (1.00000001, 2, 3.))\n        assert_array_almost_equal((1, 2, 3), (1.0000001, 2, 3.), 6)\n        assert_array_almost_equal((1, 2, 3), [1, 2, 3])\n        assert_array_almost_equal((), ())\n        assert_array_almost_equal([], ())\n\n    def test_wrong_length(self):\n        try:\n            assert_array_almost_equal((1, 2, 3), (1, 2))\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], \'(1, 2, 3) != (1, 2) as lengths differ\')\n\n    def test_wrong_value(self):\n        try:\n            assert_array_almost_equal((3, 2, 1), (3, 2, 1.0000001))\n            assert False\n        except AssertionError:\n            pass\n\n\nclass test_assert_2darray_almost_equal():\n\n    def test__passes(self):\n        assert_2darray_almost_equal(((1, 2), (3, 4)),\n                                    ((1.00000001, 2), (3, 4)))\n        assert_2darray_almost_equal(((1, 2), (3, 4)),\n                                    ((1.0000001, 2), (3, 4)), 6)\n        assert_2darray_almost_equal(((1, 2), (3, 4)),\n                                    [(1, 2), [3, 4]])\n        assert_2darray_almost_equal(((), ()), ((), ()))\n        assert_2darray_almost_equal([(), []], ([], ()))\n\n    def test_wrong_length(self):\n        try:\n            assert_2darray_almost_equal(((1, 2), (3, 4)), ((1, 2), (3, 4, 5)))\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0],\n                \'((1, 2), (3, 4)) != ((1, 2), (3, 4, 5)) as sizes differ\')\n\n    def test_wrong_value(self):\n        try:\n            assert_2darray_almost_equal(((1, 2), (3, 4)),\n                                        ((1.0000001, 2), (3, 4)))\n            assert False\n        except AssertionError:\n            pass\n\n\nclass test_assert_matrix_almost_equal():\n\n    def test__passes(self):\n        assert_matrix_almost_equal(matrix([[1, 2], [3, 4]]),\n                                   matrix([[1.00000001, 2], [3, 4]]))\n        assert_matrix_almost_equal(matrix([[1, 2], [3, 4]]),\n                                   matrix([[1.0000001, 2], [3, 4]]), 6)\n\n    def test_wrong_length(self):\n        try:\n            assert_matrix_almost_equal(matrix([[1, 2], [3, 4]]),\n                                       matrix([[1, 2, 3], [4, 5, 6]]))\n            assert False\n        except AssertionError:\n            pass\n\n    def test_wrong_value(self):\n        try:\n            assert_matrix_almost_equal(matrix([[1, 2], [3, 4]]),\n                                        matrix([[1.0000001, 2], [3, 4]]))\n            assert False\n        except AssertionError:\n            pass\n\n\nclass test_assert_dict_almost_equal():\n\n    def test__passes(self):\n        assert_dict_almost_equal({}, {})\n        assert_dict_almost_equal({\'a\': 1}, {\'a\': 1})\n        assert_dict_almost_equal({\'a\': 1.}, {\'a\': 1.})\n        assert_dict_almost_equal({\'a\': 1.00000001}, {\'a\': 1.00000001})\n\n    def test_wrong_keys(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1}, {\'a\': 1, \'b\': 2})\n            assert False\n        except AssertionError:\n            pass\n\n    def test_wrong_object(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1}, {\'a\': \'1\'})\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], ""For key \'a\', 1 != \'1\'"")\n\n    def test_wrong_int(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1}, {\'a\': 2})\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], ""For key \'a\', 1 != 2"")\n\n    def test_wrong_float1(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1.}, {\'a\': 2.})\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], ""For key \'a\', 1.0 != 2.0 within 7 places"")\n\n    def test_wrong_float2(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1}, {\'a\': 2.})\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], ""For key \'a\', 1 != 2.0 within 7 places"")\n\n    def test_wrong_float3(self):\n        try:\n            assert_dict_almost_equal({\'a\': 1.}, {\'a\': 2})\n            assert False\n        except AssertionError, e:\n            eq_(e.args[0], ""For key \'a\', 1.0 != 2 within 7 places"")\n\n    def test_okay_differing_types1(self):\n        assert_dict_almost_equal({\'a\': 1.}, {\'a\': 1})\n\n    def test_okay_differing_types2(self):\n        assert_dict_almost_equal({\'a\': 1}, {\'a\': 1.})\n'"
test/tools.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom nose.tools import assert_almost_equal  # @UnresolvedImport\nfrom nose.tools import ok_\nfrom functools import wraps\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\ndef format_note(note):\n    return "" # %s"" % note if note else """"\n\n\ndef assert_array_almost_equal(first, second, places=7, msg=None, note=None):\n    err = ""%r != %r as lengths differ%s"" % (first, second, format_note(note))\n    assert len(first) == len(second), err\n    for f, s in zip(first, second):\n        default_msg = (\n            ""\\n%r != \\n%r within %i places%s"" % (format_array(first, places),\n            format_array(second, places), places, format_note(note)))\n        assert_almost_equal(f, s, places, msg or default_msg)\n\n\ndef format_array(a, places):\n    fmt = \'% .\' + str(places) + \'f\'\n    return \'(\' + \', \'.join((fmt % el) for el in a) + \')\'\n\n\naneq_ = arrayeq_ = assert_array_almost_equal\n\n\ndef assert_2darray_almost_equal(first, second, places=7, msg=None, note=None):\n    err = ""%r != %r as sizes differ%s"" % (first, second, format_note(note))\n    assert len(first) == len(second), err\n    for f2, s2 in zip(first, second):\n        err = ""%r != %r as sizes differ%s"" % (first, second, format_note(note))\n        assert len(f2) == len(s2), err\n        for f, s in zip(f2, s2):\n            message = ""within %i places%s"" % (places, format_note(note))\n            message += \'\\n\' + format_2darray(first, places) + ""!=\\n""\n            message += format_2darray(second, places)\n            assert_almost_equal(f, s, places, msg or message)\n\n\ndef format_2darray(array, places):\n    fmt = \'% .\' + str(places) + \'f\'\n    s = """"\n    for row in array:\n        line = [fmt % el for el in row]\n        s += \'[\' + \', \'.join(line) + \']\\n\'\n    return s\n\n\ndef _array(m):\n    if isinstance(m, matrix):  # numpy\n        return m.tolist()\n    else:                       # assume Jama\n        return m.array\n\n\ndef assert_matrix_almost_equal(first, second, places=7, msg=None, note=None):\n    assert_2darray_almost_equal(_array(first), _array(second), places, msg)\n\n\ndef assert_dict_almost_equal(first, second, places=7, msg=None, note=None):\n    def_msg = ""%r != %r as keys differ%s"" % (first, second, format_note(note))\n    assert set(first.keys()) == set(second.keys()), msg or def_msg\n    keys = first.keys()\n    keys.sort()\n    for key in keys:\n        f = first[key]\n        s = second[key]\n        if isinstance(f, float) or isinstance(s, float):\n            def_msg = (""For key %s, %r != %r within %i places%s"" %\n                       (repr(key), f, s, places, format_note(note)))\n            assert_almost_equal(f, s, places, msg or def_msg)\n        else:\n            if f != s:\n                raise AssertionError(\n                    ""For key %s, %r != %r%s"" %\n                    (repr(key), f, s, format_note(note)))\n\ndneq_ = assert_dict_almost_equal\n\ndef assert_second_dict_almost_in_first(value, expected, places=7, msg=None):\n    value = value.copy()\n    for key in value.keys():\n        if key not in expected.keys():\n            del value[key]\n    assert_dict_almost_equal(value, expected, places=7, msg=None)\n\n\ndef assert_iterable_almost_equal(first, second, places=7, msg=None, note=None):\n    def_msg = (""%r != %r as lengths differ%s"" %\n               (first, second, format_note(note)))\n    assert len(first) == len(second), msg or def_msg\n    for f, s in zip(first, second):\n        if isinstance(f, float) or isinstance(s, float):\n            assert_almost_equal(f, s, places, msg)\n        else:\n            if f != s:\n                raise AssertionError(""%r != %r%s"" % (f, s, format_note(note)))\n\n\nmneq_ = matrixeq_ = assert_matrix_almost_equal\n\n\ndef meq_(a, b):\n    ok_((a == b).all(), \'\\n%s\\n  !=\\n%s\' % (a, b))\n\n\ndef wrap_command_to_print_calls(f, user_syntax=True):\n\n    def print_with_user_syntax(f, args):\n        arg_strings = []\n        for arg in args:\n            if isinstance(arg, list):\n                element_as_strings = (str(el) for el in arg)\n                arg_strings.append(\'[%s]\' % \' \'.join(element_as_strings))\n            else:\n                try:\n                    arg_strings.append(arg.name)  # Scannable\n                except AttributeError:\n                    arg_strings.append(repr(arg))  # e.g. number or string\n\n        print \'\\n>>>\', f.__name__, \' \'.join(arg_strings)\n\n    def print_with_python_syntax(f, args):\n        print \'\\n>>> %s(%s)\' % (f.__name__, \', \'.join(args))\n\n    def print_and_call_command(f, args):\n        if user_syntax:\n            print_with_user_syntax(f, args)\n        else:\n            print_with_python_syntax(f, args)\n        result = f(*args)\n        if result is not None:\n            print result\n        return result\n\n    @wraps(f)\n    def wrapper(*args, **kwds):\n        return print_and_call_command(f, args)\n\n    return wrapper\n'"
diffcalc/dc/__init__.py,0,b''
diffcalc/dc/common.py,0,"b'from diffcalc.util import allnum, command, DiffcalcException\n\n\ndef sim(scn, hkl):\n    """"""sim hkl scn -- simulates moving scannable (not all)\n    """"""\n    if not isinstance(hkl, (tuple, list)):\n        raise TypeError()\n\n    if not allnum(hkl):\n        raise TypeError()\n\n    try:\n        print scn.simulateMoveTo(hkl)\n    except AttributeError:\n        raise TypeError(\n                ""The first argument does not support simulated moves"")\n        \ndef energy_to_wavelength(energy):\n    try:\n        return 12.39842 / energy\n    except ZeroDivisionError:\n        raise DiffcalcException(\n            ""Cannot calculate hkl position as Energy is set to 0"")'"
diffcalc/dc/dcvlieg.py,0,"b'from diffcalc.dc.common import energy_to_wavelength\n\nfrom diffcalc import settings\nfrom diffcalc.hkl.vlieg.transform import VliegTransformSelector,\\\n    TransformCommands, VliegPositionTransformer\nfrom diffcalc.dc.help import compile_extra_motion_commands_for_help\nimport diffcalc.hkl.vlieg.calc\n\n\n# reload to aid testing only\nimport diffcalc.ub.ub as _ub\nreload(_ub)\nfrom diffcalc import hardware as _hardware\n#reload(_hardware)\nimport diffcalc.hkl.vlieg.hkl as _hkl\nreload(_hkl)\n\nfrom diffcalc.ub.ub import *  # @UnusedWildImport\nfrom diffcalc.hardware import *  # @UnusedWildImport\nfrom diffcalc.hkl.vlieg.hkl import *  # @UnusedWildImport\nfrom diffcalc.gdasupport.scannable.sim import sim\n\n_transform_selector = VliegTransformSelector()\n_transform_commands = TransformCommands(_transform_selector)\n_transformer = VliegPositionTransformer(settings.geometry, settings.hardware,\n                                       _transform_selector)\n\ntransform = _transform_commands.transform\ntransforma = _transform_commands.transforma\ntransformb = _transform_commands.transformb\ntransformc = _transform_commands.transformc\n\n\non = \'on\'\noff = \'off\'\nauto = \'auto\'\nmanual = \'manual\'\n    \ndef hkl_to_angles(h, k, l, energy=None):\n    """"""Convert a given hkl vector to a set of diffractometer angles""""""\n    if energy is None:\n        energy = settings.hardware.get_energy()  # @UndefinedVariable\n\n    position, params = hklcalc.hklToAngles(h, k, l, energy_to_wavelength(energy))\n    position = _transformer.transform(position)\n    angle_tuple = settings.geometry.internal_position_to_physical_angles(position)  # @UndefinedVariable\n    angle_tuple = settings.hardware.cut_angles(angle_tuple)  # @UndefinedVariable\n \n    return angle_tuple, params\n\n\ndef angles_to_hkl(angleTuple, energy=None):\n    """"""Converts a set of diffractometer angles to an hkl position\n    ((h, k, l), paramDict)=angles_to_hkl(self, (a1, a2,aN), energy=None)""""""\n    if energy is None:\n        energy = settings.hardware.get_energy()  # @UndefinedVariable\n\n    i_pos = settings.geometry.physical_angles_to_internal_position(angleTuple)  # @UndefinedVariable\n    return hklcalc.anglesToHkl(i_pos, energy_to_wavelength(energy))\n\n\nsettings.ubcalc_strategy = diffcalc.hkl.vlieg.calc.VliegUbCalcStrategy()\nsettings.angles_to_hkl_function = diffcalc.hkl.vlieg.calc.vliegAnglesToHkl       \nsettings.include_sigtau = True\n\nub_commands_for_help = _ub.commands_for_help\n\nhkl_commands_for_help = (_hkl.commands_for_help +\n                         _hardware.commands_for_help +\n                         [\'Transform\',\n                          transform,\n                          transforma,\n                          transformb,\n                          transformc] +\n                          compile_extra_motion_commands_for_help())\n\n'"
diffcalc/dc/dcwillmot.py,0,"b'# This file differs from dcyou in only two places\n\nfrom diffcalc import settings\nfrom diffcalc.dc.common import energy_to_wavelength\nfrom diffcalc.dc.help import compile_extra_motion_commands_for_help\nimport diffcalc.hkl.willmott.calc\n\n\n# reload to aid testing only\nfrom diffcalc.ub import ub as _ub\nreload(_ub)\nfrom diffcalc import hardware as _hardware\n#reload(_hardware)\nfrom diffcalc.hkl.you import hkl as _hkl\nreload(_hkl)\n\nfrom diffcalc.ub.ub import *  # @UnusedWildImport\nfrom diffcalc.hardware import *  # @UnusedWildImport\nfrom diffcalc.hkl.willmot.hkl import *  # @UnusedWildImport\nfrom diffcalc.gdasupport.scannable.sim import sim\n\ndef hkl_to_angles(h, k, l, energy=None):\n    """"""Convert a given hkl vector to a set of diffractometer angles""""""\n    if energy is None:\n        energy = settings.hardware.get_energy()  # @UndefinedVariable\n\n    (pos, params) = hklcalc.hklToAngles(h, k, l, energy_to_wavelength(energy))\n    angle_tuple = settings.geometry.internal_position_to_physical_angles(pos)  # @UndefinedVariable\n    angle_tuple = settings.hardware.cut_angles(angle_tuple)  # @UndefinedVariable\n\n    return angle_tuple, params\n\ndef angles_to_hkl(angleTuple, energy=None):\n    """"""Converts a set of diffractometer angles to an hkl position\n    ((h, k, l), paramDict)=angles_to_hkl(self, (a1, a2,aN), energy=None)""""""\n    if energy is None:\n        energy = settings.hardware.get_energy()  # @UndefinedVariable\n    i_pos = settings.geometry.physical_angles_to_internal_position(angleTuple)  # @UndefinedVariable\n    return hklcalc.anglesToHkl(i_pos, energy_to_wavelength(energy))\n\nsettings.ubcalc_strategy = diffcalc.hkl.willmott.calc.WillmottHorizontalUbCalcStrategy()\nsettings.angles_to_hkl_function = diffcalc.hkl.willmott.calc.angles_to_hkl    \n        \n\nub_commands_for_help = _ub.commands_for_help\n\nhkl_commands_for_help = _hkl.commands_for_help + _hardware.commands_for_help + compile_extra_motion_commands_for_help()\n'"
diffcalc/dc/dcyou.py,0,"b'from diffcalc import settings\nfrom diffcalc.dc.common import energy_to_wavelength\nfrom diffcalc.dc.help import compile_extra_motion_commands_for_help\n\nimport diffcalc.hkl.you.calc\nsettings.ubcalc_strategy = diffcalc.hkl.you.calc.YouUbCalcStrategy()\nsettings.angles_to_hkl_function = diffcalc.hkl.you.calc.youAnglesToHkl\n\n# reload to aid testing only\nfrom diffcalc.ub import ub as _ub\n\nreload(_ub)\nfrom diffcalc import hardware as _hardware\n#reload(_hardware)\nfrom diffcalc.hkl.you import hkl as _hkl\nreload(_hkl)\n\nfrom diffcalc.ub.ub import *  # @UnusedWildImport\nfrom diffcalc.hardware import *  # @UnusedWildImport\nfrom diffcalc.hkl.you.hkl import *  # @UnusedWildImport\n\n\nclass DiffractometerYouCalculator(object):\n\n    def __init__(self, diffractometerObject, diffcalcObject):\n        self.diffhw = diffractometerObject\n        self.geometry = diffcalcObject\n\n\n    def hkl_to_angles(self, h, k, l, energy=None):\n        """"""Convert a given hkl vector to a set of diffractometer angles\n        \n        return angle tuple and params dictionary\n        \n        """"""\n        if energy is None:\n            energy = self.diffhw.get_energy()  # @UndefinedVariable\n    \n        (pos, params) = hklcalc.hklToAngles(h, k, l, energy_to_wavelength(energy))\n        angle_tuple = self.geometry.internal_position_to_physical_angles(pos)  # @UndefinedVariable\n        angle_tuple = self.diffhw.cut_angles(angle_tuple)  # @UndefinedVariable\n    \n        return angle_tuple, params\n    \n    \n    def hkl_list_to_angles(self, hkl_list, energy=None):\n        """"""Convert a given hkl vector to a set of diffractometer angles\n        \n        return angle tuple and params dictionary\n        \n        """"""\n        if energy is None:\n            energy = self.diffhw.get_energy()  # @UndefinedVariable\n    \n        (pos, params) = hklcalc.hklListToAngles(hkl_list, energy_to_wavelength(energy))\n        angle_tuple = self.geometry.internal_position_to_physical_angles(pos)  # @UndefinedVariable\n        angle_tuple = self.diffhw.cut_angles(angle_tuple)  # @UndefinedVariable\n    \n        return angle_tuple, params\n    \n    \n    def angles_to_hkl(self, angleTuple, energy=None):\n        """"""Converts a set of diffractometer angles to an hkl position\n        \n        Return hkl tuple and params dictionary\n        \n        """"""\n        if energy is None:\n            energy = self.diffhw.get_energy()  # @UndefinedVariable\n        i_pos = self.geometry.physical_angles_to_internal_position(angleTuple)  # @UndefinedVariable\n        return hklcalc.anglesToHkl(i_pos, energy_to_wavelength(energy))\n\n\ndef hkl_to_angles(h, k, l, energy=None):\n    _dcyou = DiffractometerYouCalculator(settings.hardware, settings.geometry)\n    return _dcyou.hkl_to_angles(h, k, l, energy)\n\ndef hkl_list_to_angles(hkl, energy=None):\n    _dcyou = DiffractometerYouCalculator(settings.hardware, settings.geometry)\n    return _dcyou.hkl_list_to_angles(hkl, energy)\n\ndef angles_to_hkl(angleTuple, energy=None):\n    _dcyou = DiffractometerYouCalculator(settings.hardware, settings.geometry)\n    return _dcyou.angles_to_hkl(angleTuple, energy)\n\n\n\nub_commands_for_help = _ub.commands_for_help\nhkl_commands_for_help = _hkl.commands_for_help + _hardware.commands_for_help + compile_extra_motion_commands_for_help()\n'"
diffcalc/dc/help.py,0,"b'\'\'\'\nCreated on 6 May 2016\n\n@author: walton\n\'\'\'\nfrom diffcalc import settings\nfrom diffcalc.gdasupport.scannable.sim import sim\nimport textwrap\nfrom diffcalc.util import bold\n\n\nclass ExternalCommand(object):\n    """"""Instances found in a command_list by format_command_help will\n    result in documentation for a command without there actually being one.\n    """"""\n    def __init__(self, docstring):\n        """"""Set the docstring that will be pulled off by format_command_help.\n        """"""\n        self.__doc__ = docstring\n        self.__name__ = \'\'\n\n\nWIDTH = 27\nINDENT = 3\n\n\ndef format_command_help(command_list):\n\n    row_list = _command_list_to_table_cells(command_list)\n    lines = []\n    for row_cells in row_list:\n        if len(row_cells) == 1:\n            heading = row_cells[0]\n            lines.append(\'\')\n            lines.append(bold(heading))\n            lines.append(\'\')\n        elif len(row_cells) == 2:\n            cell1, cell2 = row_cells\n    \n            cell1_lines = textwrap.wrap(cell1, WIDTH, subsequent_indent=\'    \')\n            cell2_lines = textwrap.wrap(cell2, 79 - INDENT - 3 - WIDTH)\n            \n            first_line = True\n            while cell1_lines or cell2_lines:\n                line = \' \' * INDENT\n                if cell1_lines:\n                    line += cell1_lines.pop(0).ljust(WIDTH)\n                else:\n                    line += \' \' * (WIDTH)\n                line += \' : \' if first_line else \'   \'\n                if cell2_lines:\n                    line += cell2_lines.pop(0)\n                lines.append(line)\n                first_line = False\n\n    return \'\\n\'.join(lines)\n\n        \ndef format_commands_for_rst_table(title, command_list):\n    W1 = WIDTH  # internal width\n    W2 = 79 - W1 - 3  # internal width\n    HORIZ_LINE = \'+-\' + \'-\' * W1 + \'-+-\' + \'-\' * W2 + \'-+\'\n    \n    row_list = _command_list_to_table_cells(command_list)\n    \n    lines = []\n  \n    lines.append(HORIZ_LINE)  # Top line\n    for row_cells in row_list:\n        if len(row_cells) == 1:\n            lines.append(\'| \' + (\'**\' + row_cells[0] + \'**\').ljust(W1 + W2 + 3) + \' |\')\n        \n        elif len(row_cells) == 2:\n            cmd_and_args = row_cells[0].split(\' \', 1)\n            cmd = cmd_and_args[0]\n            args = cmd_and_args[1] if len(cmd_and_args) == 2 else \'\'\n            cell1 = \'**-- %s** %s\' % (cmd, args)\n            cell1_lines = textwrap.wrap(cell1, W1)  #, subsequent_indent=\'    \')\n            cell2_lines = textwrap.wrap(row_cells[1], W2)\n            \n            while cell1_lines or cell2_lines:\n                line = \'| \'\n                line += (cell1_lines.pop(0) if cell1_lines else \'\').ljust(W1)\n                line += \' | \'\n                line += (cell2_lines.pop(0) if cell2_lines else \'\').ljust(W2)\n                line += \' |\'\n                lines.append(line)\n        \n        else:\n            assert False\n        \n        lines.append(HORIZ_LINE)\n    return lines\n\n    \n    \n    \n                \ndef _command_list_to_table_cells(command_list):\n    row_list = []\n    for obj in command_list:\n\n        if isinstance(obj, basestring):  # group heading\n            row_list.append([obj.upper()])\n\n        else:  # individual command\n            doc_before_empty_line = obj.__doc__.split(\'\\n\\n\')[0]\n            doc_lines = [s.strip() for s in doc_before_empty_line.split(\'\\n\')]\n            for doc_line in doc_lines:\n                if doc_line == \'\':\n                    continue\n                if obj.__name__ in (\'ub\', \'hkl\'):\n                    continue\n                name, args, desc = _split_doc_line(doc_line)\n                desc = desc.strip()\n                args = args.strip()\n                if desc and desc[-1] == \'.\':\n                    desc = desc[:-1]\n                \n                row_list.append([name + (\' \' if args else \'\') + args, desc])\n    \n    return row_list\n    \n\ndef _split_doc_line(docLine):\n    name, _, right = docLine.partition(\' \')\n    args, _, desc = right.partition(\'-- \')\n    return name, args, desc\n\n\ndef compile_extra_motion_commands_for_help():\n    \n    _hwname = settings.hardware.name  # @UndefinedVariable\n    _angles = \', \'.join(settings.hardware.get_axes_names())  # @UndefinedVariable\n    \n    commands = []\n        \n    commands.append(\'Motion\')\n    commands.append(sim)\n    commands.append(ExternalCommand(\n        \'%(_hwname)s -- show Eularian position\' % vars()))\n    commands.append(ExternalCommand(\n        \'pos %(_hwname)s [%(_angles)s]  -- move to Eularian position\'\n        \'(None holds an axis still)\' % vars()))\n    commands.append(ExternalCommand(\n        \'sim %(_hwname)s [%(_angles)s] -- simulate move to Eulerian position\'\n        \'%(_hwname)s\' % vars()))\n    \n    commands.append(ExternalCommand(\n        \'hkl -- show hkl position\'))\n    commands.append(ExternalCommand(\n        \'pos hkl [h k l] -- move to hkl position\'))\n    commands.append(ExternalCommand(\n        \'pos {h | k | l} val -- move h, k or l to val\'))\n    commands.append(ExternalCommand(\n        \'sim hkl [h k l] -- simulate move to hkl position\'))\n    \n#     if engine_name != \'vlieg\':\n#         pass\n#         # TODO: remove sigtau command and \'Surface\' string\n    return commands'"
diffcalc/gdasupport/__init__.py,0,b''
diffcalc/gdasupport/you.py,0,"b'from diffcalc.gdasupport.scannable.diffractometer import DiffractometerScannableGroup\nfrom diffcalc.gdasupport.scannable.hkl import Hkl\nfrom diffcalc.gdasupport.scannable.hkloffset import HklOffset\nfrom diffcalc.gdasupport.scannable.simulation import SimulatedCrystalCounter\nfrom diffcalc.gdasupport.scannable.wavelength import Wavelength\nfrom diffcalc.gdasupport.scannable.parameter import DiffractionCalculatorParameter\n\n\nfrom diffcalc.dc import dcyou as _dc\nfrom diffcalc.dc.help import format_command_help\nfrom diffcalc.gdasupport.scannable.sr2 import Sr2\nfrom diffcalc.gdasupport.scannable.qtrans import Qtrans\nreload(_dc)\nfrom diffcalc.dc.dcyou import *  # @UnusedWildImport\nfrom diffcalc import settings\n\ntry:\n    import gda  # @UnusedImport @UnresolvedImport\n    GDA = True\nexcept:\n    GDA = False\n    \nif not GDA:\n    from diffcalc.gdasupport.minigda import command\n    _pos = command.Pos()\n    _scan = command.Scan(command.ScanDataPrinter())\n\n    def pos(*args):\n        """"""\n        pos                   show position of all Scannables\n        pos scn               show position of scn\n        pos scn targetmove    scn to target (a number)\n        """"""\n        return _pos(*args)\n\n    def scan(*args):\n        """"""\n        scan scn start stop step {scn {target}} {det t}\n        """"""\n        return _scan(*args)\n\n\nfrom diffcalc.gdasupport.scannable.sim import sim  # @UnusedImport\n\n_scn_group = settings.axes_scannable_group\n_diff_scn_name = settings.geometry.name # @UndefinedVariable\n_energy_scannable = settings.energy_scannable\n\n\n# Create diffractometer scannable\n_diff_scn = DiffractometerScannableGroup(_diff_scn_name, _dc, _scn_group)\nglobals()[_diff_scn_name] = _diff_scn\n\n# Create hkl scannables\nhkl = Hkl(\'hkl\', _scn_group, _dc)\nh = hkl.h\nk = hkl.k\nl = hkl.l\n\nhkloffset = HklOffset(\'hkloffset\', _scn_group, _dc)\nh_offset = hkloffset.h\nk_offset = hkloffset.k\nl_offset = hkloffset.l\npol_offset = hkloffset.polar\naz_offset = hkloffset.azimuthal\n\nsr2 = Sr2(\'sr2\', _scn_group, _dc)\n\nqtrans = Qtrans(\'qtrans\', _scn_group, _dc)\n\nHkl.dynamic_docstring = format_command_help(hkl_commands_for_help)  # must be on the class\nub.__doc__ = format_command_help(ub_commands_for_help)\n\nif settings.include_reference:\n    _virtual_angles = (\'theta\', \'ttheta\', \'qaz\', \'alpha\', \'naz\', \'tau\', \'psi\', \'beta\', \'betain\', \'betaout\')\nelse:\n    _virtual_angles = (\'theta\', \'ttheta\', \'qaz\', \'betain\', \'betaout\')\nhklverbose = Hkl(\'hklverbose\', _scn_group, _dc, _virtual_angles)\n\n\n# Create wavelength scannable\nwl = Wavelength(\n    \'wl\', _energy_scannable, settings.energy_scannable_multiplier_to_get_KeV)\nif not GDA:\n    wl.asynchronousMoveTo(1)  # Angstrom\n_energy_scannable.level = 3\nwl.level = 3\n\n\n# Create simulated counter timer\nct = SimulatedCrystalCounter(\'ct\', _scn_group, settings.geometry, wl)\nct.level = 10\n\n\n# Create constraint scannables\ndef _create_constraint_scannable(con_name, scn_name=None):\n    if not scn_name:\n        scn_name = con_name\n    return DiffractionCalculatorParameter(\n        scn_name, con_name, _dc.constraint_manager)\n     \n# Detector constraints\ndef isconstrainable(name):\n    return not constraint_manager.is_constraint_fixed(name)\n\nif isconstrainable(\'delta\'): delta_con = _create_constraint_scannable(\'delta\', \'delta_con\')\nif isconstrainable(\'gam\'): gam_con = _create_constraint_scannable(\'gam\', \'gam_con\')\nif isconstrainable(\'qaz\'): qaz = _create_constraint_scannable(\'qaz\')\nif isconstrainable(\'naz\'): naz = _create_constraint_scannable(\'naz\')\n\n# Reference constraints\nif settings.include_reference:\n    alpha = _create_constraint_scannable(\'alpha\')\n    beta = _create_constraint_scannable(\'beta\')\n    psi = _create_constraint_scannable(\'psi\')\n    a_eq_b = \'a_eq_b\'\nbetain = _create_constraint_scannable(\'betain\')\nbetaout = _create_constraint_scannable(\'betaout\')\nbin_eq_bout = \'bin_eq_bout\'\n\n# Sample constraints\nif isconstrainable(\'mu\'): mu_con = _create_constraint_scannable(\'mu\', \'mu_con\')\nif isconstrainable(\'eta\'): eta_con = _create_constraint_scannable(\'eta\', \'eta_con\')\nif isconstrainable(\'chi\'): chi_con = _create_constraint_scannable(\'chi\', \'chi_con\')\nif isconstrainable(\'phi\'): phi_con = _create_constraint_scannable(\'phi\', \'phi_con\')\nif isconstrainable(\'mu\') and isconstrainable(\'gam\'): mu_is_gam = \'mu_is_gam\'\nomega = _create_constraint_scannable(\'omega\')\nbisect = \'bisect\'\n\n\n# Cleanup other cruft\ndel format_command_help\n'"
diffcalc/hkl/__init__.py,0,b''
diffcalc/hkl/calcbase.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\n\nfrom diffcalc.util import DiffcalcException, differ\nfrom diffcalc import settings\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nclass HklCalculatorBase(object):\n\n    def __init__(self, ubcalc,\n                 raiseExceptionsIfAnglesDoNotMapBackToHkl=False):\n\n        self._ubcalc = ubcalc  # to get the UBMatrix, tau and sigma\n        self.raiseExceptionsIfAnglesDoNotMapBackToHkl = \\\n            raiseExceptionsIfAnglesDoNotMapBackToHkl\n\n    def anglesToHkl(self, pos, wavelength):\n        """"""\n        Return hkl tuple and dictionary of all virtual angles in degrees from\n        Position in degrees and wavelength in Angstroms.\n        """"""\n\n        h, k, l = self._anglesToHkl(pos.inRadians(), wavelength)\n        paramDict = self.anglesToVirtualAngles(pos, wavelength)\n        return ((h, k, l), paramDict)\n\n    def anglesToVirtualAngles(self, pos, wavelength):\n        """"""\n        Return dictionary of all virtual angles in degrees from Position object\n        in degrees and wavelength in Angstroms.\n        """"""\n        anglesDict = self._anglesToVirtualAngles(pos.inRadians(), wavelength)\n        for name in anglesDict:\n            anglesDict[name] = anglesDict[name] * TODEG\n        return anglesDict\n\n    def hklToAngles(self, h, k, l, wavelength):\n        """"""\n        Return verified Position and all virtual angles in degrees from\n        h, k & l and wavelength in Angstroms.\n\n        The calculated Position is verified by checking that it maps back using\n        anglesToHkl() to the requested hkl value.\n\n        Those virtual angles fixed or generated while calculating the position\n        are verified by by checking that they map back using\n        anglesToVirtualAngles to the virtual angles for the given position.\n\n        Throws a DiffcalcException if either check fails and\n        raiseExceptionsIfAnglesDoNotMapBackToHkl is True, otherwise displays a\n        warning.\n        """"""\n\n        # Update tracked parameters. During this calculation parameter values\n        # will be read directly from self._parameters instead of via\n        # self.getParameter which would trigger another potentially time-costly\n        # position update.\n        self.parameter_manager.update_tracked()\n\n        pos, virtualAngles = self._hklToAngles(h, k, l, wavelength)  # in rad\n\n        # to degrees:\n        pos.changeToDegrees()\n        \n        for key, val in virtualAngles.items():\n            if val is not None:\n                virtualAngles[key] = val * TODEG\n\n        self._verify_pos_map_to_hkl(h, k, l, wavelength, pos)\n\n        virtualAnglesReadback = self._verify_virtual_angles(h, k, l, wavelength, pos, virtualAngles)\n\n        return pos, virtualAnglesReadback\n\n    def _verify_pos_map_to_hkl(self, h, k, l, wavelength, pos):\n        hkl, _ = self.anglesToHkl(pos, wavelength)\n        e = 0.001\n        if ((abs(hkl[0] - h) > e) or (abs(hkl[1] - k) > e) or \n            (abs(hkl[2] - l) > e)):\n            s = ""ERROR: The angles calculated for hkl=(%f,%f,%f) were %s.\\n"" % (h, k, l, str(pos))\n            s += ""Converting these angles back to hkl resulted in hkl=""\\\n            ""(%f,%f,%f)"" % (hkl[0], hkl[1], hkl[2])\n            if self.raiseExceptionsIfAnglesDoNotMapBackToHkl:\n                raise DiffcalcException(s)\n            else:\n                print s\n\n    def _verify_virtual_angles(self, h, k, l, wavelength, pos, virtualAngles):\n        # Check that the virtual angles calculated/fixed during the hklToAngles\n    # those read back from pos using anglesToVirtualAngles\n        virtualAnglesReadback = self.anglesToVirtualAngles(pos, wavelength)\n        for key, val in virtualAngles.items():\n            if val != None: # Some values calculated in some mode_selector\n                r = virtualAnglesReadback[key]\n                if ((differ(val, r, .00001) and differ(val, r + 360, .00001) and differ(val, r - 360, .00001))):\n                    s = ""ERROR: The angles calculated for hkl=(%f,%f,%f) with""\\\n                    "" mode=%s were %s.\\n"" % (h, k, l, self.repr_mode(), str(pos))\n                    s += ""During verification the virtual angle %s resulting ""\\\n                    ""from (or set for) this calculation of %f"" % (key, val)\n                    s += ""did not match that calculated by ""\\\n                    ""anglesToVirtualAngles of %f"" % virtualAnglesReadback[key]\n                    if self.raiseExceptionsIfAnglesDoNotMapBackToHkl:\n                        raise DiffcalcException(s)\n                    else:\n                        print s\n        \n        return virtualAnglesReadback\n\n    def repr_mode(self):\n        pass\n\n### Collect all math access to context here\n\n    def _getUBMatrix(self):\n        return self._ubcalc.UB\n\n    def _getMode(self):\n        return self.mode_selector.getMode()\n\n    def _getSigma(self):\n        return self._ubcalc.sigma\n\n    def _getTau(self):\n        return self._ubcalc.tau\n\n    def _getParameter(self, name):\n        # Does not use context.getParameter as this will trigger a costly\n        # parameter collection\n        pm = self.parameter_manager\n        return pm.getParameterWithoutUpdatingTrackedParemeters(name)\n\n    def _getGammaParameterName(self):\n        return self._gammaParameterName\n'"
diffcalc/hkl/common.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nfrom diffcalc.util import allnum\n\ndef getNameFromScannableOrString(o):\n        try:  # it may be a scannable\n            return o.getName()\n        except AttributeError:\n            return str(o)\n            raise TypeError()\n\n\nclass DummyParameterManager(object):\n\n    def getParameterDict(self):\n        return {}\n\n    def _setParameter(self, name, value):\n        raise KeyError(name)\n\n    def _getParameter(self, name):\n        raise KeyError(name)\n\n    def update_tracked(self):\n        pass\n\n\ndef sim(self, scn, hkl):\n    """"""sim hkl scn -- simulates moving scannable (not all)\n    """"""\n    if not isinstance(hkl, (tuple, list)):\n        raise TypeError\n\n    if not allnum(hkl):\n        raise TypeError()\n\n    try:\n        print scn.simulateMoveTo(hkl)\n    except AttributeError:\n        raise TypeError(""The first argument does not support simulated moves"")\n'"
diffcalc/ub/__init__.py,0,b''
diffcalc/ub/calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n""""""\nInterface functions for UB matrix calculation.\n\nThis module provides a number of objects and functions for setting UB matrix\nand reference/surface normal vectors based on reflections and/or orientations and\ncrystal miscut information.\n""""""\nfrom diffcalc.ub.calcstate import UBCalcState\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.ub.reflections import ReflectionList\nfrom diffcalc.ub.persistence import UBCalculationJSONPersister, UBCalculationPersister\nfrom diffcalc.util import DiffcalcException, cross3, dot3, bold, xyz_rotation,\\\n    bound, angle_between_vectors, norm3, CoordinateConverter, allnum, TODEG\nfrom math import acos, cos, sin, pi, atan2\nfrom diffcalc.ub.reference import YouReference\nfrom diffcalc.ub.orientations import OrientationList\nfrom diffcalc import settings\nfrom itertools import product\nfrom diffcalc.ub.fitting import fit_crystal, fit_u_matrix\nfrom diffcalc.hkl.you.geometry import create_you_matrices\n\ntry:\n    from numpy import matrix, hstack\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix, hstack\n    from numjy.linalg import norm\n\nSMALL = 1e-7\n\nWIDTH = 13\n\ndef z(num):\n    """"""Round to zero if small.\n    \n    This is useful to get rid of erroneous minus signs\n    resulting from float representation close to zero.\n    \n    Parameters\n    ----------\n    num : number\n        The value to be checked for rounding.\n\n    Returns\n    -------\n    number\n        The rounded input value.\n    """"""\n    if abs(num) < SMALL:\n        num = 0\n    return num\n\n#The UB matrix is used to find or set the orientation of a set of\n#planes described by an hkl vector. The U matrix can be used to find\n#or set the orientation of the crystal lattices\' y axis. If there is\n#crystal miscut the crystal lattices y axis is not parallel to the\n#crystals optical surface normal. For surface diffraction experiments,\n#where not only the crystal lattice must be oriented appropriately but\n#so must the crystal\'s optical surface, two angles tau and sigma are\n#used to describe the difference between the two. Sigma is (minus) the\n#ammount of chi axis rotation and tau (minus) the ammount of phi axis\n#rotation needed to move the surface normal into the direction of the\n\n\nclass PaperSpecificUbCalcStrategy(object):\n    """"""Base class defining interface for scattering vector calculation\n    for the given diffractometer position.\n    """"""\n\n    def calculate_q_phi(self, pos):\n        """"""Calculate scattering vector in laboratory frame.\n        \n        Calculate hkl in the phi frame in units of 2 * pi / lambda.\n        \n        Parameters\n        ----------\n        pos: object\n            Diffractometer angles in radians.\n        \n        Returns\n        -------\n        matrix:\n            Scattering vector coordinates corresponding to the input position.""""""\n        raise NotImplementedError()\n\n\nclass UBCalculation:\n    """"""A UB matrix calculation for an experiment.\n\n    Contains the parameters for the _crystal under test, a list of measured\n    reflections and, if its been calculated, a UB matrix to be used by the rest\n    of the code.\n    """"""\n\n    def __init__(self, persister, strategy, include_sigtau=True, include_reference=True):\n\n        # The diffractometer geometry is required to map the internal angles\n        # into those used by this diffractometer (for display only)\n\n        self._persister = persister\n        self._strategy = strategy\n        self.include_sigtau = include_sigtau\n        self.include_reference = include_reference\n        try:\n            self._tobj = CoordinateConverter(transform=settings.geometry.beamline_axes_transform)\n        except AttributeError:\n            self._tobj = CoordinateConverter(transform=None)\n        self._clear()\n        \n    def _get_diffractometer_axes_names(self):\n        return settings.hardware.get_axes_names()\n\n    def _clear(self, name=None):\n        # NOTE the Diffraction calculator is expecting this object to exist in\n        # the long run. We can\'t remove this entire object, and recreate it.\n        # It also contains a required link to the angle calculator.\n        reflist = ReflectionList(settings.geometry, self._get_diffractometer_axes_names(),\n                                 multiplier=settings.hardware.energyScannableMultiplierToGetKeV)\n        orientlist = OrientationList(settings.geometry, self._get_diffractometer_axes_names())\n        reference = YouReference(self._get_UB)\n        reference._set_n_hkl_configured(settings.reference_vector)\n        surface = YouReference(self._get_UB)\n        surface._set_n_phi_configured(settings.surface_vector)\n        self._state = UBCalcState(name=name,\n                                  reflist=reflist,\n                                  orientlist=orientlist,\n                                  reference=reference,\n                                  surface=surface)\n        self._U = None\n        self._UB = None\n        self._state.configure_calc_type()\n\n### State ###\n    def start_new(self, name):\n        """"""Start new UB matrix calculation.\n        \n        Creates a new blank UB matrix calculation.\n        \n        Parameters\n        ----------\n        name: str\n            Name of a new UB matrix calculation\n        """"""\n        # Create storage object if name does not exist (TODO)\n        self._clear(name)\n        self.save()\n\n    def load(self, name):\n        state = self._persister.load(name)\n        if isinstance(self._persister, UBCalculationJSONPersister):\n            self._state = self._persister.encoder.decode_ubcalcstate(state,\n                                                                     settings.geometry,\n                                                                     self._get_diffractometer_axes_names(),\n                                                                     settings.hardware.energyScannableMultiplierToGetKeV)\n            self._state.reference.get_UB = self._get_UB\n            self._state.surface.get_UB = self._get_UB\n        elif isinstance(self._persister, UBCalculationPersister):\n            self._state = state\n        else:\n            raise DiffcalcException(\'Unexpected persister type: \' + str(self._persister))\n        if self._state.manual_U is not None:\n            self._U = self._state.manual_U\n            self._UB = self._U * self._state.crystal.B\n            self.save()\n        elif self._state.manual_UB is not None:\n            self._UB = self._state.manual_UB\n            self.save()\n        elif self._state.is_okay_to_autocalculate_ub:\n            try:\n                self.calculate_UB(self._state.or0, self._state.or1)\n            except Exception, e:\n                print e\n        else:\n            print ""Warning: No UB calculation loaded.""\n\n    def save(self):\n        """"""Save current UB matrix calculation.""""""\n        if self._state.name:\n            self.saveas(self._state.name)\n        else:\n            print ""Warning: No UB calculation defined.""\n\n    def saveas(self, name):\n        """"""Save current UB matrix calculation.\n        \n        Parameters\n        ----------\n        name : str\n            Name for the saved UB matrix calculation.\n        """"""\n        self._state.name = name\n        self._persister.save(self._state, name)\n\n    def listub(self):\n        """"""List saved UB matrix calculations.\n        \n        Returns:\n        :obj:`list` of :obj:`str`\n            List of names of the saved UB matrix calculations.\n        """"""\n        return self._persister.list()\n    \n    def listub_metadata(self):\n        return self._persister.list_metadata()\n\n    def remove(self, name):\n        """"""Delete UB matrix calculation.\n        \n        Parameters\n        ----------\n        name : str\n            Name of the UB matrix calculation to be deleted.\n        """"""\n        self._persister.remove(name)\n        if self._state.name == name:\n            self._clear()\n\n    def getState(self):\n        return self._state.getState()\n\n    def __str__(self):\n\n        if self._state.name is None:\n            return ""<<< No UB calculation started >>>""\n        lines = []\n        lines.append(bold(""UBCALC""))\n        lines.append("""")\n        lines.append(\n            ""   name:"".ljust(WIDTH) + self._state.name.rjust(9))\n        \n        if self.include_sigtau:\n            lines.append("""")\n            lines.append(\n                ""   sigma:"".ljust(WIDTH) + (""% 9.5f"" % self._state.sigma).rjust(9))\n            lines.append(\n                ""   tau:"".ljust(WIDTH) + (""% 9.5f"" % self._state.tau).rjust(9))\n\n        _ub_calculated = self._UB is not None\n        if self.include_reference:\n            lines.append("""")\n            lines.append(bold(""REFERNCE""))\n            lines.append("""")\n            lines.extend(self._state.reference.repr_lines(_ub_calculated, WIDTH, self._tobj))\n        lines.append("""")\n        lines.append(bold(""SURFACE NORMAL""))\n        lines.append("""")\n        lines.extend(self._state.surface.repr_lines(_ub_calculated, WIDTH, self._tobj))\n        \n        lines.append("""")\n        lines.append(bold(""CRYSTAL""))\n        lines.append("""")\n        \n        if self._state.crystal is None:\n            lines.append(""   <<< none specified >>>"")\n        else:\n            lines.extend(self._state.crystal.str_lines(self._tobj))\n\n        lines.append("""")\n        lines.append(bold(""UB MATRIX""))\n        lines.append("""")\n        \n        if self._UB is None:\n            lines.append(""   <<< none calculated >>>"")\n        else:\n            lines.extend(self.str_lines_u(self.U))\n            lines.append("""")\n            lines.extend(self.str_lines_ub_angle_and_axis(self.UB))\n            lines.append("""")\n            lines.extend(self.str_lines_ub(self.UB))\n\n        lines.extend(self.str_lines_refl())\n        \n        lines.extend(self.str_lines_orient())\n        \n        return \'\\n\'.join(lines)\n\n    def str_lines_u(self, umatrix):\n        lines = []\n        fmt = ""% 9.5f % 9.5f % 9.5f""\n        U = self._tobj.transform(umatrix, True)\n        lines.append(""   U matrix:"".ljust(WIDTH) +\n                     fmt % (z(U[0, 0]), z(U[0, 1]), z(U[0, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(U[1, 0]), z(U[1, 1]), z(U[1, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(U[2, 0]), z(U[2, 1]), z(U[2, 2])))\n        return lines\n\n    def str_lines_ub_angle_and_axis(self, ubmatrix):\n        lines = []\n        fmt = ""% 9.5f % 9.5f % 9.5f""\n        rotation_angle, rotation_axis = self.get_miscut_angle_axis(ubmatrix)\n        if abs(norm(rotation_axis)) < SMALL:\n            lines.append(""   miscut angle:"".ljust(WIDTH) + ""  0"")\n        else:\n            lines.append(""   miscut:"")\n            lines.append(""      angle:"".ljust(WIDTH) + ""% 9.5f"" % rotation_angle)\n            lines.append(""       axis:"".ljust(WIDTH) + fmt % tuple((rotation_axis.T).tolist()[0]))\n \n        return lines\n\n    def str_lines_ub(self, ubmatrix):\n        lines = []\n        fmt = ""% 9.5f % 9.5f % 9.5f""\n        if self._tobj.R is not None:\n            UB = self._tobj.R.I * ubmatrix\n        else:\n            UB = self.UB\n        lines.append(""   UB matrix:"".ljust(WIDTH) +\n                     fmt % (z(UB[0, 0]), z(UB[0, 1]), z(UB[0, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(UB[1, 0]), z(UB[1, 1]), z(UB[1, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(UB[2, 0]), z(UB[2, 1]), z(UB[2, 2])))\n        return lines\n\n    def str_lines_refl(self):\n        lines = ["""", bold(""REFLECTIONS""), """"]\n        \n        lines.extend(self._state.reflist.str_lines())\n        return lines\n\n    def str_lines_orient(self):\n        lines = ["""", bold(""CRYSTAL ORIENTATIONS""), """"]\n        \n        lines.extend(self._state.orientlist.str_lines(self._tobj))\n        return lines\n\n    @property\n    def name(self):\n        """"""str: Name of the current UB matrix calculation.""""""\n        return self._state.name\n### Lattice ###\n\n    def set_lattice(self, name, *shortform):\n        """"""\n        Converts a list shortform crystal parameter specification to a six-long\n        tuple. See setlat() for a description of the shortforms supported.\n        """"""\n        if not shortform:\n            raise TypeError(""Please specify unit cell parameters."")\n        elif allnum(shortform):\n            sf = shortform\n            if len(sf) == 1:\n                system = ""Cubic""\n            elif len(sf) == 2:\n                system = ""Tetragonal""\n            elif len(sf) == 3:\n                system = ""Orthorhombic""\n            elif len(sf) == 4:\n                if abs(sf[0] - sf[1]) < SMALL and sf[3] == 120:\n                    system = ""Hexagonal""\n                else:\n                    system = ""Monoclinic""\n            elif len(sf) == 6:\n                system = ""Triclinic""\n            else:\n                raise TypeError(""Invalid number of input parameters to set unit lattice."")\n            fullform = (system,) + shortform\n        else:\n            if not isinstance(shortform[0], basestring):\n                raise TypeError(""Invalid unit cell parameters specified."")\n            fullform = shortform\n        if self._state.name is None:\n            raise DiffcalcException(\n                ""Cannot set lattice until a UBCalcaluation has been started ""\n                ""with newubcalc"")\n        self._state.crystal = CrystalUnderTest(name, *fullform)\n        # Clear U and UB if these exist\n        if self._U is not None:  # (UB will also exist)\n            print (""Warning: Setting new unit cell parameters.\\n""\n                   ""         The old UB calculation has been cleared."")\n        self.save()\n\n### Surface normal stuff ###\n\n    def _gettau(self):\n        """"""\n        Returns tau (in degrees): the (minus) ammount of phi axis rotation ,\n        that together with some chi axis rotation (minus sigma) brings the\n        optical surface normal parallel to the omega axis.\n        """"""\n        return self._state.tau\n\n    def _settau(self, tau):\n        self._state.tau = tau\n        self.save()\n\n    tau = property(_gettau, _settau)\n\n    def _getsigma(self):\n        """"""\n        Returns sigma (in degrees): the (minus) ammount of phi axis rotation ,\n        that together with some phi axis rotation (minus tau) brings the\n        optical surface normal parallel to the omega axis.\n        """"""\n        return self._state.sigma\n\n    def _setsigma(self, sigma):\n        self.state._sigma = sigma\n        self.save()\n\n    sigma = property(_getsigma, _setsigma)\n\n\n### Reference vector ###\n\n    def _get_n_hkl(self):\n        return self._state.reference.n_hkl\n    \n    def _get_n_phi(self):\n        return self._state.reference.n_phi\n    \n    n_hkl = property(_get_n_hkl)\n    n_phi = property(_get_n_phi)\n    \n    def set_n_phi_configured(self, n_phi):\n        self._state.reference.n_phi_configured = self._tobj.transform(n_phi)\n        self.save()\n        \n    def set_n_hkl_configured(self, n_hkl):\n        self._state.reference.n_hkl_configured = n_hkl\n        self.save()\n        \n    def print_reference(self):\n        print \'\\n\'.join(self._state.reference.repr_lines(self.is_ub_calculated(), WIDTH=9, conv=self._tobj))\n\n\n### Surface vector ###\n\n    def _get_surf_nhkl(self):\n        return self._state.surface.n_hkl\n    \n    def _get_surf_nphi(self):\n        return self._state.surface.n_phi\n    \n    surf_nhkl = property(_get_surf_nhkl)\n    surf_nphi = property(_get_surf_nphi)\n    \n    def set_surf_nphi_configured(self, n_phi):\n        self._state.surface.n_phi_configured = self._tobj.transform(n_phi)\n        self.save()\n        \n    def set_surf_nhkl_configured(self, n_hkl):\n        self._state.surface.n_hkl_configured = n_hkl\n        self.save()\n        \n    def print_surface(self):\n        print \'\\n\'.join(self._state.surface.repr_lines(self.is_ub_calculated(), WIDTH=9, conv=self._tobj))\n\n### Reflections ###\n\n    def add_reflection(self, h, k, l, position, energy, tag, time):\n        """"""Add a reference reflection.\n        \n        Adds a reflection position in degrees and in the\n        systems internal representation.\n        \n        Parameters\n        ----------\n        h : number\n            h index of the reflection\n        k : number\n            k index of the reflection\n        l : number\n            l index of the reflection\n        position: :obj:`list` or :obj:`tuple` of numbers\n            list of diffractometer angles in internal representation in degrees\n        energy : float\n            energy of the x-ray beam\n        tag : str\n            identifying tag for the reflection\n        time : :obj:`datetime`\n            datetime object\n        """"""\n        if self._state.reflist is None:\n            raise DiffcalcException(""No UBCalculation loaded"")\n        self._state.reflist.add_reflection(h, k, l, position, energy, tag, time)\n        self.save()  # incase autocalculateUbAndReport fails\n\n        # If second reflection has just been added then calculateUB\n        if self.get_reference_count() == 2:\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def edit_reflection(self, idx, h, k, l, position, energy, tag, time):\n        """"""Changes a reference reflection.\n        \n        Changes a reflection position in degrees and in the\n        systems internal representation.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the reflection to be changed\n        h : number\n            h index of the reflection\n        k : number\n            k index of the reflection\n        l : number\n            l index of the reflection\n        position: :obj:`list` or :obj:`tuple` of numbers\n            list of diffractometer angles in internal representation in degrees\n        energy : float\n            energy of the x-ray beam\n        tag : str\n            identifying tag for the reflection\n        time : :obj:`datetime`\n            datetime object\n        """"""\n        if self._state.reflist is None:\n            raise DiffcalcException(""No UBCalculation loaded"")\n        num = self.get_tag_refl_num(idx)\n        self._state.reflist.edit_reflection(num, h, k, l, position, energy, tag, time)\n\n        # If first or second reflection has been changed and there are at least\n        # two reflections then recalculate  UB\n        or12 = self.get_ub_references()\n        if idx in or12 or num in or12:\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def get_reflection(self, idx):\n        """"""Get a reference reflection.\n        \n        Get a reflection position in degrees and in the\n        systems internal representation.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the reflection\n        """"""\n        return self._state.reflist.getReflection(idx)\n\n    def get_reflection_in_external_angles(self, idx):\n        """"""Get a reference reflection.\n        \n        Get a reflection position in degrees and in the\n        external diffractometer representation.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the reflection\n        """"""\n        return self._state.reflist.get_reflection_in_external_angles(idx)\n    \n    def get_number_reflections(self):\n        """"""Get a number of stored reference reflections.\n        \n        Returns\n        -------\n        int:\n            Number of reference reflections.\n        """"""\n        try:\n            return len(self._state.reflist)\n        except TypeError:\n            return 0\n\n    def get_tag_refl_num(self, tag):\n        """"""Get a reference reflection index.\n        \n        Get a reference reflection index for the \n        provided reflection tag.\n        \n        Parameters\n        ----------\n        tag : str\n            identifying tag for the reflection\n        Returns\n        -------\n        int:\n            Reference reflection index\n        """"""\n        if tag is None:\n            raise IndexError(""Reflection tag is None"")\n        return self._state.reflist.get_tag_index(tag) + 1\n\n    def del_reflection(self, idx):\n        """"""Delete a reference reflection.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the deleted reflection\n        """"""\n        num = self.get_tag_refl_num(idx)\n        self._state.reflist.removeReflection(num)\n        or12 = self.get_ub_references()\n        if ((idx in or12 or num in or12) and\n            (self._U is not None)):\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def swap_reflections(self, idx1, idx2):\n        """"""Swap indices of two reference reflections.\n        \n        Parameters\n        ----------\n        idx1 : str or int\n            index or tag of the first reflection to be swapped\n        idx2 : str or int\n            index or tag of the second reflection to be swapped\n        """"""\n        num1 = self.get_tag_refl_num(idx1)\n        num2 = self.get_tag_refl_num(idx2)\n        self._state.reflist.swap_reflections(num1, num2)\n        or12 = self.get_ub_references()\n        if ((idx1 in or12 or idx2 in or12 or \n             num1 in or12 or num2 in or12) and\n            (self._U is not None)):\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def _autocalculateUbAndReport(self):\n        if self.get_reference_count() < 2:\n            pass\n        elif self._state.crystal is None:\n            print (""Not calculating UB matrix as no lattice parameters have ""\n                   ""been specified."")\n        elif not self._state.is_okay_to_autocalculate_ub:\n            print (""Not calculating UB matrix as it has been manually set. ""\n                   ""Use \'calcub\' to explicitly recalculate it."")\n        else:  # okay to autocalculate\n            if self._UB is None:\n                print ""Calculating UB matrix.""\n            else:\n                print ""Recalculating UB matrix.""\n            or12 = self.get_ub_references()\n            self.calculate_UB(*or12)\n\n### Orientations ###\n\n    def add_orientation(self, h, k, l, x, y, z, position, tag, time):\n        """"""Add a reference orientation.\n        \n        Adds a reference orientation in the external diffractometer\n        coordinate system.\n        \n        Parameters\n        ----------\n        h : number\n            h index of the reference orientation\n        k : number\n            k index of the reference orientation\n        l : number\n            l index of the reference orientation\n        x : number\n            x coordinate of the reference orientation\n        y : number\n            x coordinate of the reference orientation\n        z : number\n            x coordinate of the reference orientation\n        position: :obj:`list` or :obj:`tuple` of numbers\n            list of diffractometer angles in internal representation in degrees\n        tag : str\n            identifying tag for the reflection\n        time : :obj:`datetime`\n            datetime object\n        """"""\n        if self._state.orientlist is None:\n            raise DiffcalcException(""No UBCalculation loaded"")\n        xyz_tr = self._tobj.transform(matrix([[x],[y],[z]]))\n        xr, yr, zr = xyz_tr.T.tolist()[0]\n        self._state.orientlist.add_orientation(h, k, l, xr, yr, zr, position, tag, time)\n        self.save()  # in case autocalculateUbAndReport fails\n\n        # If second reflection has just been added then calculateUB\n        if self.get_reference_count() == 2:\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def edit_orientation(self, idx, h, k, l, x, y, z, position, tag, time):\n        """"""Change a reference orientation.\n        \n        Changes a reference orientation in the external diffractometer\n        coordinate system.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the orientation to be changed\n        h : number\n            h index of the reference orientation\n        k : number\n            k index of the reference orientation\n        l : number\n            l index of the reference orientation\n        x : number\n            x coordinate of the reference orientation\n        y : number\n            x coordinate of the reference orientation\n        z : number\n            x coordinate of the reference orientation\n        position: :obj:`list` or :obj:`tuple` of numbers\n            list of diffractometer angles in internal representation in degrees\n        tag : str\n            identifying tag for the reflection\n        time : :obj:`datetime`\n            datetime object\n        """"""\n        if self._state.orientlist is None:\n            raise DiffcalcException(""No UBCalculation loaded"")\n        num = self.get_tag_orient_num(idx)\n        xyz_tr = self._tobj.transform(matrix([[x],[y],[z]]))\n        xr, yr, zr = xyz_tr.T.tolist()[0]\n        self._state.orientlist.edit_orientation(num, h, k, l, xr, yr, zr, position, tag, time)\n\n        # If first or second orientation has been changed and there are\n        # two orientations then recalculate  UB\n        or12 = self.get_ub_references()\n        if idx in or12 or num in or12:\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def get_orientation(self, idx, conv=False):\n        """"""Get a reference orientation.\n        \n        Get a reference orientation in the external diffractometer\n        coordinate system.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the reference orientation\n        """"""\n        hkl, xyz, pos, tg, tm = self._state.orientlist.getOrientation(idx)\n        if conv:\n            xyz_rot = self._tobj.transform(matrix([[xyz[0]],[xyz[1]],[xyz[2]]]), True)\n            xyz = xyz_rot.T.tolist()[0]\n        return hkl, xyz, pos, tg, tm\n\n    def get_orientation_in_external_angles(self, idx, conv=False):\n        """"""Get a reference orientation.\n        \n        Get a reference orientation in the external diffractometer\n        coordinate system with diffractometer position in external angles.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the reference orientation\n        """"""\n        hkl, xyz, pos, tg, tm = self._state.orientlist.get_orientation_in_external_angles(idx)\n        if conv:\n            xyz_rot = self._tobj.transform(matrix([[xyz[0]],[xyz[1]],[xyz[2]]]), True)\n            xyz = xyz_rot.T.tolist()[0]\n        return hkl, xyz, pos, tg, tm\n\n    def get_number_orientations(self):\n        """"""Get a number of stored reference orientations.\n        \n        Returns\n        -------\n        int:\n            Number of reference orientations.\n        """"""\n        try:\n            return len(self._state.orientlist)\n        except TypeError:\n            return 0\n\n    def get_tag_orient_num(self, tag):\n        """"""Get a reference orientation index.\n        \n        Get a reference orientation index for the \n        provided orientation tag.\n        \n        Parameters\n        ----------\n        tag : str\n            identifying tag for the orientation\n        Returns\n        -------\n        int:\n            Reference orientation index\n        """"""\n        if tag is None:\n            raise IndexError(""Orientations tag is None"")\n        return self._state.orientlist.get_tag_index(tag) + 1\n\n    def del_orientation(self, idx):\n        """"""Delete a reference orientation.\n        \n        Parameters\n        ----------\n        idx : str or int\n            index or tag of the deleted orientation\n        """"""\n        orientationNumber = self.get_tag_orient_num(idx)\n        self._state.orientlist.removeOrientation(orientationNumber)\n        if ((orientationNumber == 2) and (self._U is not None)):\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def swap_orientations(self, idx1, idx2):\n        """"""Swap indices of two reference orientations.\n        \n        Parameters\n        ----------\n        idx1 : str or int\n            index or tag of the first orientation to be swapped\n        idx2 : str or int\n            index or tag of the second orientation to be swapped\n        """"""\n        num1 = self.get_tag_orient_num(idx1)\n        num2 = self.get_tag_orient_num(idx2)\n        self._state.orientlist.swap_orientations(num1, num2)\n        if ((num1 == 1 or num1 == 2 or num2 == 1 or num2 == 2) and\n            (self._U is not None)):\n            self._autocalculateUbAndReport()\n        self.save()\n\n    def get_ub_references(self):\n        return (self._state.or0, self._state.or1)\n\n    def get_reference_count(self):\n        n_ref = self.get_number_reflections()\n        n_orient = self.get_number_orientations()\n        return n_ref + n_orient\n#    @property\n#    def reflist(self):\n#        return self._state.reflist\n### Calculations ###\n\n    def set_U_manually(self, m, conv=True):\n        """"""Manually sets U. matrix must be 3*3 Jama or python matrix.\n        Turns off aution UB calcualtion.""""""\n\n        # Check matrix is a 3*3 Jama matrix\n        if m.__class__ != matrix:\n            m = matrix(m)  # assume its a python matrix\n        if m.shape[0] != 3 or m.shape[1] != 3:\n            raise  ValueError(""Expects 3*3 matrix"")\n\n        if self._UB is None:\n            print ""Calculating UB matrix.""\n        else:\n            print ""Recalculating UB matrix.""\n        \n        if conv:\n            self._U = self._tobj.transform(m)\n        else:\n            self._U = m\n        self._state.configure_calc_type(manual_U=self._U)\n        if self._state.crystal is None:\n            raise DiffcalcException(\n                ""A crystal must be specified before manually setting U"")\n        self._UB = self._U * self._state.crystal.B\n        self.save()\n\n    def set_UB_manually(self, m):\n        """"""Manually sets UB. matrix must be 3*3 Jama or python matrix.\n        Turns off aution UB calcualtion.""""""\n\n        # Check matrix is a 3*3 Jama matrix\n        if m.__class__ != matrix:\n            m = matrix(m)  # assume its a python matrix\n        if m.shape[0] != 3 or m.shape[1] != 3:\n            raise  ValueError(""Expects 3*3 matrix"")\n\n        if self._tobj.R is not None:\n            self._UB = self._tobj.R * m\n        else:\n            self._UB = m\n        self._state.configure_calc_type(manual_UB=self._UB)\n        self.save()\n\n    @property\n    def U(self):\n        """"""matrix: Returns U matrix.""""""\n        if self._U is None:\n            raise DiffcalcException(\n                ""No U matrix has been calculated during this ub calculation"")\n        return self._U\n\n    @property\n    def UB(self):\n        """"""matrix: Returns UB matrix.""""""\n        return self._get_UB()\n    \n    def is_ub_calculated(self):\n        return self._UB is not None\n\n    def _get_UB(self):\n        if not self.is_ub_calculated():\n            raise DiffcalcException(\n                ""No UB matrix has been calculated during this ub calculation"")\n        else:\n            return self._UB\n\n    def _calc_UB(self, h1, h2, u1p, u2p):\n        B = self._state.crystal.B\n        h1c = B * h1\n        h2c = B * h2\n\n        # Create modified unit vectors t1, t2 and t3 in crystal and phi systems\n        t1c = h1c\n        t3c = cross3(h1c, h2c)\n        t2c = cross3(t3c, t1c)\n\n        t1p = u1p  # FIXED from h1c 9July08\n        t3p = cross3(u1p, u2p)\n        t2p = cross3(t3p, t1p)\n\n        # ...and nornmalise and check that the reflections used are appropriate\n        SMALL = 1e-4  # Taken from Vlieg\'s code\n\n        def normalise(m):\n            d = norm(m)\n            if d < SMALL:\n                raise DiffcalcException(""Invalid UB reference data. Please check that the specified ""\n                                        ""reference reflections/orientations are not parallel."")\n            return m / d\n\n        t1c = normalise(t1c)\n        t2c = normalise(t2c)\n        t3c = normalise(t3c)\n\n        t1p = normalise(t1p)\n        t2p = normalise(t2p)\n        t3p = normalise(t3p)\n\n        Tc = hstack([t1c, t2c, t3c])\n        Tp = hstack([t1p, t2p, t3p])\n        self._U = Tp * Tc.I\n        self._UB = self._U * B\n\n    def calculate_UB(self, idx1=None, idx2=None):\n        """"""Calculate UB matrix.\n        \n        Calculate UB matrix using two reference reflections and/or\n        reference orientations.\n        \n        By default use the first two reference reflections when provided.\n        If one or both reflections are not available use one or two reference\n        orientations to complement mission reflection data.\n        \n        Parameters\n        ----------\n        idx1: int or str, optional\n            The index or the tag of the first reflection or orientation.\n        idx2: int or str, optional\n            The index or the tag of the second reflection or orientation.\n        """"""\n\n        # Major variables:\n        # h1, h2: user input reciprocal lattice vectors of the two reflections\n        # h1c, h2c: user input vectors in cartesian crystal plane\n        # pos1, pos2: measured diffractometer positions of the two reflections\n        # u1a, u2a: measured reflection vectors in alpha frame\n        # u1p, u2p: measured reflection vectors in phi frame\n\n        # Get hkl and angle values for the first two reflections\n        if self._state.reflist is None and self._state.orientlist is None:\n            raise DiffcalcException(""Cannot calculate a U matrix until a ""\n                                    ""UBCalculation has been started with ""\n                                    ""\'newub\'"")\n        if idx1 is not None and idx2 is None:\n            self.calculate_UB_from_primary_only(idx1)\n            return\n        elif idx1 is None and idx2 is None:\n            ref_data = []\n            for func, idx in product((self.get_reflection, self.get_orientation), (1, 2)):\n                try:\n                    ref_data.append(func(idx))\n                except Exception:\n                    pass\n            try:\n                ref1, ref2 = ref_data[:2]\n            except ValueError:\n                raise DiffcalcException(""Cannot find calculate a U matrix. Please add ""\n                                        ""reference reflection and/or orientation data."")\n        else:\n            try:\n                ref1 = self.get_reflection(idx1)\n            except Exception:\n                try:\n                    ref1 = self.get_orientation(idx1)\n                except Exception:\n                    raise DiffcalcException(\n                        ""Cannot find first reflection or orientation with index %s"" % str(idx1))\n            try:\n                ref2 = self.get_reflection(idx2)\n            except Exception:\n                try:\n                    ref2 = self.get_orientation(idx2)\n                except Exception:\n                    raise DiffcalcException(\n                        ""Cannot find second reflection or orientation with index %s"" % str(idx2))\n        h1 = matrix([ref1[0]]).T  # row->column\n        h2 = matrix([ref2[0]]).T\n\n        # Compute the two reflections\' reciprocal lattice vectors in the\n        # cartesian crystal frame\n        try:\n            _, pos1, _ = ref1[:3]\n            pos1.changeToRadians()\n            u1p = self._strategy.calculate_q_phi(pos1)\n        except AttributeError:\n            _, r1, pos1 = ref1[:3]\n            pos1.changeToRadians()\n            [MU, _, _, ETA, CHI, PHI] = create_you_matrices(*pos1.totuple())\n            Z = PHI.I * CHI.I * ETA.I * MU.I\n            u1p = Z * matrix([r1]).T\n        try:\n            _, pos2, _ = ref2[:3]\n            pos2.changeToRadians()\n            u2p = self._strategy.calculate_q_phi(pos2)\n        except AttributeError:\n            _, r2, pos2 = ref2[:3]\n            pos2.changeToRadians()\n            [MU, _, _, ETA, CHI, PHI] = create_you_matrices(*pos2.totuple())\n            Z = PHI.I * CHI.I * ETA.I * MU.I\n            u2p = Z * matrix([r2]).T\n\n        self._calc_UB(h1, h2, u1p, u2p)\n\n        self._state.configure_calc_type(or0=idx1, or1=idx2)\n        self.save()\n\n    def calculate_UB_from_primary_only(self, idx=1):\n        """"""\n        Calculate orientation matrix with the shortest absolute angle change.\n        Default: use first reflection.\n        """"""\n\n        # Algorithm from http://www.j3d.org/matrix_faq/matrfaq_latest.html\n\n        # Get hkl and angle values for the first two reflections\n        if self._state.reflist is None:\n            raise DiffcalcException(\n                ""Cannot calculate a u matrix until a UBCalcaluation has been ""\n                ""started with newub"")\n        try:\n            (h, pos, _, _, _) = self.get_reflection(idx)\n        except IndexError:\n            raise DiffcalcException(\n                ""One reflection is required to calculate a u matrix"")\n\n        h = matrix([h]).T  # row->column\n        pos.changeToRadians()\n        B = self._state.crystal.B\n        h_crystal = B * h\n        h_crystal = h_crystal * (1 / norm(h_crystal))\n\n        q_measured_phi = self._strategy.calculate_q_phi(pos)\n        q_measured_phi = q_measured_phi * (1 / norm(q_measured_phi))\n\n        rotation_axis = cross3(h_crystal, q_measured_phi)\n        rotation_axis = rotation_axis * (1 / norm(rotation_axis))\n\n        cos_rotation_angle = dot3(h_crystal, q_measured_phi)\n        rotation_angle = acos(cos_rotation_angle)\n\n        uvw = rotation_axis.T.tolist()[0]  # TODO: cleanup\n        print ""resulting U angle: %.5f deg"" % (rotation_angle * TODEG)\n        u_repr = (\', \'.join([\'% .5f\' % el for el in uvw]))\n        print ""resulting U axis direction: [%s]"" % u_repr\n\n        u, v, w = uvw\n        rcos = cos(rotation_angle)\n        rsin = sin(rotation_angle)\n        m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]  # TODO: tidy\n        m[0][0] = rcos + u * u * (1 - rcos)\n        m[1][0] = w * rsin + v * u * (1 - rcos)\n        m[2][0] = -v * rsin + w * u * (1 - rcos)\n        m[0][1] = -w * rsin + u * v * (1 - rcos)\n        m[1][1] = rcos + v * v * (1 - rcos)\n        m[2][1] = u * rsin + w * v * (1 - rcos)\n        m[0][2] = v * rsin + u * w * (1 - rcos)\n        m[1][2] = -u * rsin + v * w * (1 - rcos)\n        m[2][2] = rcos + w * w * (1 - rcos)\n\n        if self._UB is None:\n            print ""Calculating UB matrix from the first reflection only.""\n        else:\n            print ""Recalculating UB matrix from the first reflection only.""\n        print (""NOTE: A new UB matrix will not be automatically calculated ""\n               ""when the orientation reflections are modified."")\n\n        self._U = matrix(m)\n        self._UB = self._U * B\n\n        self._state.configure_calc_type(manual_U=self._U, or0=idx)\n        self.save()\n\n    def fit_ub_matrix(self, *args):\n        if args is None:\n            raise DiffcalcException(""Please specify list of reference reflection indices."")\n        if len(args) < 3:\n            raise DiffcalcException(""Need at least 3 reference reflections to fit UB matrix."")\n\n        if len(self._state.crystal.get_lattice_params()[1]) == 6:\n            new_u, uc_params = self._fit_ub_matrix_uncon(*args)\n        else:\n            refl_list = []\n            for idx in args:\n                try:\n                    hkl_vals, pos, en, _ ,_ = self.get_reflection(idx)\n                    pos.changeToRadians()\n                    refl_list.append((hkl_vals, pos, en,))\n                except IndexError:\n                    raise DiffcalcException(""Cannot read reflection data for index %s"" % str(idx))\n            print ""Fitting crystal lattice parameters...""\n            new_lattice = fit_crystal(self._state.crystal, refl_list)\n            print ""Fitting orientation matrix...""\n            new_u = fit_u_matrix(self._U, new_lattice, refl_list)\n            uc_params = (self._state.crystal.getLattice()[0],) + new_lattice.getLattice()[1:]\n        return new_u, uc_params\n\n    def _fit_ub_matrix_uncon(self, *args):\n        if args is None:\n            raise DiffcalcException(""Please specify list of reference reflection indices."")\n        if len(args) < 3:\n            raise DiffcalcException(""Need at least 3 reference reflections to fit UB matrix."")\n\n        x = []\n        y = []\n        for idx in args:\n            try:\n                hkl_vals, pos, en, _, _ = self.get_reflection(idx)\n            except IndexError:\n                raise DiffcalcException(""Cannot read reflection data for index %s"" % str(idx))\n            pos.changeToRadians()\n            x.append(hkl_vals)\n            wl = 12.3984 / en\n            y_tmp = self._strategy.calculate_q_phi(pos) * 2.* pi / wl\n            y.append(y_tmp.T.tolist()[0])\n\n        xm = matrix(x)\n        ym = matrix(y)\n        b = (xm.T * xm).I * xm.T * ym\n\n        b1, b2, b3 = matrix(b.tolist()[0]), matrix(b.tolist()[1]), matrix(b.tolist()[2])\n        e1 = b1 / norm(b1)\n        e2 = b2 - e1 * dot3(b2.T, e1.T)\n        e2 = e2 / norm(e2)\n        e3 = b3 - e1 * dot3(b3.T, e1.T) - e2 * dot3(b3.T, e2.T)\n        e3 = e3 / norm(e3)\n\n        new_umatrix = matrix(e1.tolist() +\n                             e2.tolist() +\n                             e3.tolist()).T\n\n        V = dot3(cross3(b1.T, b2.T), b3.T)\n        a1 = cross3(b2.T, b3.T) * 2 * pi / V\n        a2 = cross3(b3.T, b1.T) * 2 * pi / V\n        a3 = cross3(b1.T, b2.T) * 2 * pi / V\n        ax, bx, cx = norm(a1), norm(a2), norm(a3)\n        alpha = acos(dot3(a2, a3)/(bx * cx)) *TODEG\n        beta = acos(dot3(a1, a3)/(ax * cx)) *TODEG\n        gamma = acos(dot3(a1, a2)/(ax * bx)) *TODEG\n\n        lattice_name = self._state.crystal.getLattice()[0]\n        return new_umatrix, (lattice_name, ax, bx, cx, alpha, beta, gamma)\n\n    def set_miscut(self, xyz, angle, add_miscut=False):\n        """"""Calculate U matrix using a miscut axis and an angle""""""\n        if xyz is None:\n            rot_matrix = xyz_rotation([0, 1, 0], angle)\n        else:\n            rot_matrix = self._tobj.transform(xyz_rotation(xyz, angle))\n        if self.is_ub_calculated() and add_miscut:\n            new_U = rot_matrix * self._U\n        else:\n            new_U = rot_matrix\n        self.set_U_manually(new_U, False)\n        self.print_surface()\n        self.save()\n\n    def get_hkl_plane_distance(self, hkl):\n        """"""Calculates and returns the distance between planes""""""\n        return self._state.crystal.get_hkl_plane_distance(hkl)\n\n    def get_hkl_plane_angle(self, hkl1, hkl2):\n        """"""Calculates and returns the angle between planes""""""\n        return self._state.crystal.get_hkl_plane_angle(hkl1, hkl2)\n\n    def rescale_unit_cell(self, h, k, l, pos):\n        """"""\n        Calculate unit cell scaling parameter that matches\n        given hkl position and diffractometer angles\n        """"""\n        q_vec = self._strategy.calculate_q_phi(pos)\n        q_hkl = norm(q_vec) / settings.hardware.get_wavelength()\n        d_hkl = self._state.crystal.get_hkl_plane_distance([h, k, l])\n        sc = 1/ (q_hkl * d_hkl)\n        name, a1, a2, a3, alpha1, alpha2, alpha3 = self._state.crystal.getLattice()\n        if abs(sc - 1.) < SMALL:\n            return None, None\n        ref_a1 = sc * a1 if abs(h) > SMALL else a1\n        ref_a2 = sc * a2 if abs(k) > SMALL else a2\n        ref_a3 = sc * a3 if abs(l) > SMALL else a3\n        return sc, (name, ref_a1, ref_a2, ref_a3, alpha1, alpha2, alpha3)\n\n    def calc_miscut(self, h, k, l, pos):\n        """"""\n        Calculate miscut angle and axis that matches\n        given hkl position and diffractometer angles\n        """"""\n        q_vec = self._strategy.calculate_q_phi(pos)\n        hkl_nphi = self._UB * matrix([[h], [k], [l]])\n        axis = self._tobj.transform(cross3(q_vec, hkl_nphi), True)\n        norm_axis = norm(axis)\n        if norm_axis < SMALL:\n            return None, None\n        axis = axis / norm(axis)\n        try:\n            miscut = acos(bound(dot3(q_vec, hkl_nphi) / (norm(q_vec) * norm(hkl_nphi)))) * TODEG\n        except AssertionError:\n            return None, None\n        return miscut, axis.T.tolist()[0]\n\n    def get_miscut_angle_axis(self, ubmatrix):\n        y = self._get_surf_nphi()\n        l = ubmatrix * y\n        rotation_axis = self._tobj.transform(cross3(y, l), True)\n        if abs(norm(rotation_axis)) < SMALL:\n            rotation_axis = matrix(\'0; 0; 0\')\n            rotation_angle = 0\n        else:\n            rotation_axis = rotation_axis * (1 / norm(rotation_axis))\n            cos_rotation_angle = bound(dot3(y, l) / norm(l))\n            rotation_angle = acos(cos_rotation_angle) * TODEG\n        return rotation_angle, rotation_axis\n\n    def calc_hkl_offset(self, h, k, l, pol, az):\n        """"""\n        Calculate hkl orientation values that are related to\n        the input hkl values by rotation with a given polar\n        and azimuthal angles\n        """"""\n        hkl_nphi = self._UB * matrix([[h], [k], [l]])\n        y_axis = cross3(hkl_nphi, matrix(\'0; 1; 0\'))\n        if norm3(y_axis) < SMALL:\n            y_axis = cross3(hkl_nphi, matrix(\'0; 0; 1\'))\n        rot_polar = xyz_rotation(y_axis.T.tolist()[0], pol)\n        rot_azimuthal = xyz_rotation(hkl_nphi.T.tolist()[0], az)\n        hklrot_nphi = rot_azimuthal * rot_polar * hkl_nphi\n        hklrot = self._UB.I * hklrot_nphi\n        hkl_list = hklrot.T.tolist()[0]\n        return hkl_list\n\n    def calc_offset_for_hkl(self, hkl_offset, hkl_ref):\n        """"""\n        Calculate polar and azimuthal angles and scaling factor\n        relating offset and reference hkl values\n        """"""\n        d_ref = self._state.crystal.get_hkl_plane_distance(hkl_ref)\n        hklref_nphi = self._UB * matrix([[hkl_ref[0]], [hkl_ref[1]], [hkl_ref[2]]])\n        d_offset = self._state.crystal.get_hkl_plane_distance(hkl_offset)\n        hkloff_nphi = self._UB * matrix([[hkl_offset[0]], [hkl_offset[1]], [hkl_offset[2]]])\n        sc = d_ref / d_offset\n        par_ref_off = cross3(hklref_nphi, hkloff_nphi)\n        if norm3(par_ref_off) < SMALL:\n            return 0, float(\'nan\'), sc\n        y_axis = cross3(hklref_nphi, matrix(\'0; 1; 0\'))\n        if norm3(y_axis) < SMALL:\n            y_axis = cross3(hklref_nphi, matrix(\'0; 0; 1\'))\n        x_axis = cross3(y_axis, hklref_nphi)\n        x_coord = cos(angle_between_vectors(hkloff_nphi, x_axis))\n        y_coord = cos(angle_between_vectors(hkloff_nphi, y_axis))\n        pol = angle_between_vectors(hklref_nphi, hkloff_nphi)\n        if abs(y_coord) < SMALL and abs(x_coord) < SMALL:\n            # Set azimuthal rotation matrix to identity\n            az = 0\n        else:\n            az = atan2(y_coord, x_coord)\n        return pol, az, sc\n'"
diffcalc/ub/calcstate.py,0,"b'from diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.ub.reflections import ReflectionList, _Reflection\nfrom math import pi\nimport datetime  # @UnusedImport For crazy time eval code!\nfrom diffcalc.ub.reference import YouReference\nfrom diffcalc.ub.orientations import _Orientation, OrientationList\nfrom diffcalc.log import logging\nfrom diffcalc import settings\nfrom diffcalc.hkl.you.geometry import YouPosition\ntry:\n    from collection import OrderedDict\nexcept ImportError:\n    from simplejson import OrderedDict\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nlogger = logging.getLogger(""diffcalc.ub.calcstate"")\n\nTODEG = 180 / pi\n\n\nclass UBCalcState():\n    \n    def __init__(self, name=None, crystal=None, reflist=None, orientlist=None, tau=0, sigma=0,\n                 manual_U=None, manual_UB=None, or0=None, or1=None, reference=None, surface=None):\n\n        assert reflist is not None\n        self.name = name\n        self.crystal = crystal\n        self.reflist = reflist\n        self.orientlist = orientlist\n        self.tau = tau  # degrees\n        self.sigma = sigma  # degrees\n        self.manual_U = manual_U\n        self.manual_UB = manual_UB\n        self.or0 = or0\n        self.or1 = or1\n        self.reference = reference\n        self.surface = surface\n        \n    @property\n    def is_okay_to_autocalculate_ub(self):\n        nothing_set = ((self.manual_U is None) and \n                       (self.manual_UB is None) and \n                       (self.or0 is None) and \n                       (self.or1 is None))\n        or0_and_or1_used =  (self.or0 is not None) and (self.or1 is not None)\n        return nothing_set or or0_and_or1_used\n    \n\n    def configure_calc_type(self,\n                            manual_U=None,\n                            manual_UB=None,\n                            or0=None,\n                            or1=None):\n        self.manual_U = manual_U\n        self.manual_UB = manual_UB\n        self.or0 = or0\n        self.or1 = or1\n\n\nclass UBCalcStateEncoder(json.JSONEncoder):\n    \n    def default(self, obj):\n        \n        if isinstance(obj, UBCalcState):\n            d = OrderedDict()\n            d[\'name\'] = obj.name\n            d[\'crystal\'] = obj.crystal\n            d[\'reflist\'] = obj.reflist\n            d[\'orientlist\'] = obj.orientlist\n            d[\'tau\'] = obj.tau\n            d[\'sigma\'] = obj.sigma\n            d[\'reference\'] = obj.reference\n            d[\'surface\'] = obj.surface\n            d[\'u\'] = obj.manual_U\n            d[\'ub\'] = obj.manual_UB\n            d[\'or0\'] = obj.or0\n            d[\'or1\'] = obj.or1\n            \n            return d\n        \n        if isinstance(obj, CrystalUnderTest):\n            return repr([obj._name, obj._system, obj._a1, obj._a2, obj._a3, obj._alpha1 * TODEG,\n                         obj._alpha2 * TODEG, obj._alpha3 * TODEG])\n            \n        if isinstance(obj, matrix):\n            l = [\', \'.join((repr(e) for e in row)) for row in obj.tolist()]\n            return l\n        \n        if isinstance(obj, ReflectionList):\n            d = OrderedDict()\n            for n, ref in enumerate(obj._reflist):\n                d[str(n+1)] = ref\n            return d\n\n        if isinstance(obj, _Reflection):\n            d = OrderedDict()\n            d[\'tag\'] = obj.tag\n            d[\'hkl\'] = repr([obj.h, obj.k, obj.l])\n            d[\'pos\'] = repr(list(obj.pos.totuple()))\n            d[\'energy\'] = obj.energy\n            dt = eval(obj.time)  # e.g. --> datetime.datetime(2013, 8, 5, 15, 47, 7, 962432)\n            d[\'time\'] = None if dt is None else dt.isoformat()\n            return d\n        \n        if isinstance(obj, OrientationList):\n            d = OrderedDict()\n            for n, orient in enumerate(obj._orientlist):\n                d[str(n+1)] = orient\n            return d\n\n        if isinstance(obj, _Orientation):\n            d = OrderedDict()\n            d[\'tag\'] = obj.tag\n            d[\'hkl\'] = repr([obj.h, obj.k, obj.l])\n            d[\'xyz\'] = repr([obj.x, obj.y, obj.z])\n            d[\'pos\'] = repr(list(obj.pos.totuple()))\n            dt = eval(obj.time)  # e.g. --> datetime.datetime(2013, 8, 5, 15, 47, 7, 962432)\n            d[\'time\'] = None if dt is None else dt.isoformat()\n            return d\n        \n        if isinstance(obj, YouReference):\n            d = OrderedDict()\n            if obj.n_hkl_configured is not None:\n                d[\'n_hkl_configured\'] = repr(obj.n_hkl_configured.T.tolist()[0])\n            else:\n                d[\'n_hkl_configured\'] = None\n            if obj.n_phi_configured is not None:\n                d[\'n_phi_configured\'] = repr(obj.n_phi_configured.T.tolist()[0])\n            else:\n                d[\'n_phi_configured\'] = None\n            return d\n        \n        \n        return json.JSONEncoder.default(self, obj)\n\n    @staticmethod\n    def decode_ubcalcstate(state, geometry, diffractometer_axes_names, multiplier):\n\n        # Backwards compatibility code\n        orientlist_=OrientationList(geometry, diffractometer_axes_names, [])\n        try:\n            orientlist_=decode_orientlist(state[\'orientlist\'], geometry, diffractometer_axes_names)\n        except KeyError:\n            pass\n        try:\n            surface_=decode_reference(state[\'surface\'], settings.surface_vector, False)\n        except KeyError:\n            surface_ = YouReference(None)\n            surface_._set_n_phi_configured(settings.surface_vector)\n        return UBCalcState(\n            name=state[\'name\'],\n            crystal=state[\'crystal\'] and CrystalUnderTest(*eval(state[\'crystal\'])),\n            reflist=decode_reflist(state[\'reflist\'], geometry, diffractometer_axes_names, multiplier),\n            orientlist=orientlist_,\n            tau=state[\'tau\'],\n            sigma=state[\'sigma\'],\n            manual_U=state[\'u\'] and decode_matrix(state[\'u\']),\n            manual_UB=state[\'ub\'] and decode_matrix(state[\'ub\']),\n            or0=state[\'or0\'],\n            or1=state[\'or1\'],\n            reference=decode_reference(state.get(\'reference\', None), settings.reference_vector, True),\n            surface=surface_\n        )\n\n\ndef decode_matrix(rows):\n    return matrix([[eval(e) for e in row.split(\', \')] for row in rows])\n\n\ndef decode_reflist(reflist_dict, geometry, diffractometer_axes_names, multiplier):\n    reflections = []\n    try:\n        sorted_ref_keys = sorted(reflist_dict.keys(), key=int)\n    except ValueError:\n        logger.warning(""Warning: Invalid index found in the stored list of reflections. ""\n                       ""Please check the reflection list order."")\n        sorted_ref_keys = sorted(reflist_dict.keys())\n    for key in sorted_ref_keys:\n        reflections.append(decode_reflection(reflist_dict[key], geometry))\n        \n    return ReflectionList(geometry, diffractometer_axes_names, reflections, multiplier)\n\n\ndef decode_orientlist(orientlist_dict, geometry, diffractometer_axes_names):\n    orientations = []\n    try:\n        sorted_orient_keys = sorted(orientlist_dict.keys(), key=int)\n    except ValueError:\n        logger.exception(""Warning: Invalid index found in the stored list of orientations. ""\n                         ""Please check the orientation list order."")\n        sorted_orient_keys = sorted(orientlist_dict.keys())\n    for key in sorted_orient_keys:\n        orientations.append(decode_orientation(orientlist_dict[key], geometry, diffractometer_axes_names))\n        \n    return OrientationList(geometry, diffractometer_axes_names, orientations)\n\n\ndef decode_reflection(ref_dict, geometry):\n    h, k, l = eval(ref_dict[\'hkl\'])\n    time = ref_dict[\'time\'] and gt(ref_dict[\'time\'])\n    pos_tuple = eval(ref_dict[\'pos\'])\n    try:\n        position = geometry.create_position(*pos_tuple)\n    except AttributeError:\n        position = YouPosition(*pos_tuple)\n    return _Reflection(h, k, l, position, ref_dict[\'energy\'], str(ref_dict[\'tag\']), repr(time))\n\n\ndef decode_reference(ref_dict, ref_vector, flg):\n    reference = YouReference(None)  # TODO: We can\'t set get_ub method yet (tangles!)\n    if ref_dict:   \n        nhkl = ref_dict.get(\'n_hkl_configured\', None)\n        nphi = ref_dict.get(\'n_phi_configured\', None)\n        if nhkl:\n            reference._set_n_hkl_configured(matrix([eval(nhkl)]).T)\n        elif nphi:\n            reference._set_n_phi_configured(matrix([eval(nphi)]).T)\n        elif flg:\n            reference._set_n_hkl_configured(ref_vector)\n        else:\n            reference._set_n_phi_configured(ref_vector)\n    return reference\n\n\ndef decode_orientation(orient_dict, geometry, diffractometer_axes_names):\n    h, k, l = eval(orient_dict[\'hkl\'])\n    x, y, z = eval(orient_dict[\'xyz\'])\n    time = orient_dict[\'time\'] and gt(orient_dict[\'time\'])\n    try:\n        pos_tuple = eval(orient_dict[\'pos\'])\n        position = geometry.create_position(*pos_tuple)\n    except KeyError:\n        pos_tuple = (0.,) * len(diffractometer_axes_names)\n        position = geometry.physical_angles_to_internal_position(pos_tuple)\n    return _Orientation(h, k, l, x, y, z, position, str(orient_dict[\'tag\']), repr(time))\n\n\n# From: http://stackoverflow.com/questions/127803/how-to-parse-iso-formatted-date-in-python\ndef gt(dt_str):\n    dt, _, us= dt_str.partition(""."")\n    dt= datetime.datetime.strptime(dt, ""%Y-%m-%dT%H:%M:%S"")\n    us= int(us.rstrip(""Z""), 10)\n    return dt + datetime.timedelta(microseconds=us)'"
diffcalc/ub/crystal.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, cos, sin, acos, sqrt\nfrom diffcalc.util import angle_between_vectors, allnum\n\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nTORAD = pi / 180\nTODEG = 180 / pi\nSMALL = 1e-7\n\ndef z(num):\n    """"""Round to zero if small. This is useful to get rid of erroneous\n    minus signs resulting from float representation close to zero.\n    """"""\n    if abs(num) < SMALL:\n        num = 0\n    return num\n\n\nclass CrystalUnderTest(object):\n    """"""\n    Contains the lattice parameters and calculated B matrix for the crystal\n    under test. Also Calculates the distance between planes at a given hkl\n    value.\n\n    The lattice parameters can be specified and then if desired saved to a\n    __library to be loaded later. The parameters are persisted across restarts.\n    Lattices stored in config/var/crystals.xml .\n    """"""\n\n    def __init__(self, name, *args):\n        \'\'\'Creates a new lattice and calculates related values.\n\n        Keyword arguments:\n            name -- a string\n            a,b,c,alpha,beta,gamma -- lengths and angles (in degrees)\n        \'\'\'\n\n        self._name = name\n        self._a1 = None\n        self._a2 = None\n        self._a3 = None\n        self._alpha1 = None\n        self._alpha2 = None\n        self._alpha3 = None\n        self._system = ""Triclinic""\n        if allnum(args):\n            # Set the direct lattice parameters\n            a, b, c, alpha, beta, gamma = args\n            self._a1 = a\n            self._a2 = b\n            self._a3 = c\n            self._alpha1 = alpha * TORAD\n            self._alpha2 = beta * TORAD\n            self._alpha3 = gamma * TORAD\n            self._set_reciprocal_cell(self._a1, self._a2, self._a3,\n                                      self._alpha1, self._alpha2, self._alpha3)\n        else:\n            self._system = args[0]\n            self._set_cell_for_system(self._system, *args[1:])\n\n\n    def _set_reciprocal_cell(self, a1, a2, a3, alpha1, alpha2, alpha3):\n        # Calculate the reciprocal lattice parameters\n        self._beta1 = acos((cos(alpha2) * cos(alpha3) - cos(alpha1)) /\n                           (sin(alpha2) * sin(alpha3)))\n\n        self._beta2 = beta2 = acos((cos(alpha1) * cos(alpha3) - cos(alpha2)) /\n                                   (sin(alpha1) * sin(alpha3)))\n\n        self._beta3 = beta3 = acos((cos(alpha1) * cos(alpha2) - cos(alpha3)) /\n                                   (sin(alpha1) * sin(alpha2)))\n\n        volume = (a1 * a2 * a3 *\n                  sqrt(1 + 2 * cos(alpha1) * cos(alpha2) * cos(alpha3) -\n                       cos(alpha1) ** 2 - cos(alpha2) ** 2 - cos(alpha3) ** 2))\n\n        self._b1 = b1 = 2 * pi * a2 * a3 * sin(alpha1) / volume\n        self._b2 = b2 = 2 * pi * a1 * a3 * sin(alpha2) / volume\n        self._b3 = b3 = 2 * pi * a1 * a2 * sin(alpha3) / volume\n\n        # Calculate the BMatrix from the direct and reciprical parameters.\n        # Reference: Busang and Levy (1967)\n        self._bMatrix = matrix([\n            [b1, b2 * cos(beta3), b3 * cos(beta2)],\n            [0.0, b2 * sin(beta3), -b3 * sin(beta2) * cos(alpha1)],\n            [0.0, 0.0, 2 * pi / a3]])\n\n    @property\n    def B(self):\n        \'\'\'\n        Returns the B matrix, may be null if crystal is not set, or if there\n        was a problem calculating this\'\'\'\n        return self._bMatrix\n\n    def get_hkl_plane_distance(self, hkl):\n        \'\'\'Calculates and returns the distance between planes\'\'\'\n        hkl = matrix([hkl])\n        bReduced = self._bMatrix / (2 * pi)\n        bMT = bReduced.I * bReduced.T.I\n        return 1.0 / sqrt((hkl * bMT.I * hkl.T)[0,0])\n\n    def get_hkl_plane_angle(self, hkl1, hkl2):\n        \'\'\'Calculates and returns the angle between [hkl1] and [hkl2] planes\'\'\'\n        hkl1 = matrix([hkl1]).T\n        hkl2 = matrix([hkl2]).T\n        nphi1 = self._bMatrix * hkl1\n        nphi2 = self._bMatrix * hkl2\n        angle = angle_between_vectors(nphi1, nphi2)\n        return angle\n\n    def __str__(self):\n        \'\'\'    Returns lattice name and all set and calculated parameters\'\'\'\n        return \'\\n\'.join(self.str_lines())\n\n    def str_lines(self, conv=None):\n        WIDTH = 13\n        if self._name is None:\n            return [""   none specified""]\n        try:\n            b = conv.R.I * self._bMatrix\n        except AttributeError:\n            b = self._bMatrix\n        lines = []\n        lines.append(""   name:"".ljust(WIDTH) + self._name.rjust(9))\n        lines.append("""")\n        lines.append(""   a, b, c:"".ljust(WIDTH) +\n                     ""% 9.5f % 9.5f % 9.5f"" % (self.getLattice()[1:4]))\n        lines.append("" "" * WIDTH +\n                     ""% 9.5f % 9.5f % 9.5f  %s"" % (self.getLattice()[4:] + (self._system,)))\n        lines.append("""")\n\n        fmt = ""% 9.5f % 9.5f % 9.5f""\n        lines.append(""   B matrix:"".ljust(WIDTH) +\n                     fmt % (z(b[0, 0]), z(b[0, 1]), z(b[0, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(b[1, 0]), z(b[1, 1]), z(b[1, 2])))\n        lines.append(\' \' * WIDTH + fmt % (z(b[2, 0]), z(b[2, 1]), z(b[2, 2])))\n        return lines\n\n    def getLattice(self):\n        return(self._name, self._a1, self._a2, self._a3, self._alpha1 * TODEG,\n               self._alpha2 * TODEG, self._alpha3 * TODEG)\n\n    def get_lattice_params(self):\n        try:\n            if self._system == \'Triclinic\':\n                return self._system, (self._a1, self._a2, self._a3,\n                    self._alpha1 * TODEG, self._alpha2 * TODEG, self._alpha3 * TODEG)\n            elif self._system == \'Monoclinic\':\n                return self._system, (self._a1, self._a2, self._a3,\n                    self._alpha2 * TODEG)\n            elif self._system == \'Orthorhombic\':\n                return self._system, (self._a1, self._a2, self._a3)\n            elif self._system == \'Tetragonal\' or self._system == \'Hexagonal\':\n                return self._system, (self._a1, self._a3)\n            elif self._system == \'Rhombohedral\': \n                return self._system, (self._a1,\n                    self._alpha1 * TODEG)\n            elif self._system == \'Cubic\':\n                return self._system, (self._a1,)\n            else:\n                raise TypeError(""Invalid crystal system parameter: %s"" % str(self._system))\n        except ValueError, e:\n            raise TypeError(e.message)\n\n    def _get_cell_for_system(self, system=None):\n        if system == \'Triclinic\':\n            return (self._a1, self._a2, self._a3,\n                        self._alpha1 * TORAD,\n                        self._alpha2 * TORAD,\n                        self._alpha3 * TORAD)\n        elif system == \'Monoclinic\':\n            return (self._a1, self._a2, self._a3,\n                        pi/2, self._alpha2 * TORAD, pi/2)\n        elif system == \'Orthorhombic\':\n            return (self._a1, self._a2, self._a3,\n                        pi/2, pi/2, pi/2)\n        elif system == \'Tetragonal\':\n            return (self._a1, self._a1, self._a3,\n                        pi/2, pi/2, pi/2)\n        elif system == \'Rhombohedral\':\n            return (self._a1, self._a1, self._a1,\n                        self._alpha1 * TORAD,\n                        self._alpha1 * TORAD,\n                        self._alpha1 * TORAD)\n        elif system == \'Hexagonal\':\n            return (self._a1, self._a1, self._a3,\n                        pi/2, pi/2, 2*pi/3)\n        elif system == \'Cubic\':\n            return (self._a1, self._a1, self._a1,\n                        pi/2, pi/2, pi/2)\n        else:\n            raise TypeError(""Invalid crystal system parameter: %s"" % str(system))\n\n    def _set_cell_for_system(self, system=None, *args):\n        try:\n            if len(args) == 6 or system == \'Triclinic\':\n                (self._a1, self._a2, self._a3,\n                    self._alpha1, self._alpha2, self._alpha3) = args\n            elif system == \'Monoclinic\':\n                (self._a1, self._a2, self._a3,\n                    self._alpha2) = args\n            elif system == \'Orthorhombic\':\n                (self._a1, self._a2, self._a3) = args\n            elif system == \'Tetragonal\' or system == \'Hexagonal\':\n                (self._a1, self._a3) = args\n            elif system == \'Rhombohedral\': \n                (self._a1,\n                    self._alpha1) = args\n            elif system == \'Cubic\':\n                (self._a1,) = args\n            else:\n                raise TypeError(""Invalid crystal system parameter: %s"" % str(system))\n        except ValueError, e:\n            raise TypeError(e.message)\n        (self._a1, self._a2, self._a3,\n         self._alpha1, self._alpha2, self._alpha3) = self._get_cell_for_system(system)\n        self._set_reciprocal_cell(self._a1, self._a2, self._a3,\n                                  self._alpha1, self._alpha2, self._alpha3)\n\n'"
diffcalc/ub/fitting.py,0,"b'###one,\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nfrom diffcalc.util import DiffcalcException, SMALL, angle_between_vectors, TODEG\nfrom math import pi, sqrt, sin, cos, atan2\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.hkl.you.geometry import create_you_matrices\n\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\n\n\ndef is_small(x):\n    return abs(x) < SMALL\n\n\ndef sign(x):\n    if is_small(x):\n        return 0\n    if x > 0:\n        return 1\n    # x < 0\n    return -1\n\n\ndef _get_refl_hkl(refl_list):\n    refl_data = []\n    for ref in refl_list:\n        hkl_vals, pos, en = ref\n        refl_data.append((matrix([hkl_vals]).T, pos, en))\n    return refl_data\n\n\ndef _func_crystal(vals, uc_system, ref_data):\n    trial_cr = CrystalUnderTest(\'trial\', uc_system, 1, 1, 1, 90, 90, 90)\n    try:\n        trial_cr._set_cell_for_system(uc_system, *vals)\n    except Exception:\n        return 1e6\n\n    res = 0\n    I = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n    for (hkl_vals, pos_vals, en) in ref_data:\n        wl = 12.3984 / en\n        [_, DELTA, NU, _, _, _] = create_you_matrices(*pos_vals.totuple())\n        q_pos = (NU * DELTA - I) * matrix([[0], [2 * pi / wl], [0]])\n        q_hkl = trial_cr.B * hkl_vals\n        res += (norm(q_pos) - norm(q_hkl))**2\n    return res\n\n\nclass UbTargetCrystal(object):\n\n    def __init__(self, refl_list, uc_system):\n        self.uc_system = uc_system\n        self.ref_data = _get_refl_hkl(refl_list)\n\n    def value(self, vals):\n        return _func_crystal(vals, self.uc_system, self.ref_data)\n\n\ndef _func_orient(vals, crystal, ref_data):\n    quat = _get_quat_from_u123(*vals)\n    trial_u = _get_rot_matrix(*quat)\n    tmp_ub = trial_u * crystal.B\n\n    res = 0\n    I = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n    for (hkl_vals, pos_vals, en) in ref_data:\n        wl = 12.3984 / en\n        [MU, DELTA, NU, ETA, CHI, PHI] = create_you_matrices(*pos_vals.totuple())\n        q_del = (NU * DELTA - I) * matrix([[0], [2 * pi / wl], [0]])\n        q_vals = PHI.I * CHI.I * ETA.I * MU.I * q_del\n\n        q_hkl = tmp_ub * hkl_vals\n        res += angle_between_vectors(q_hkl, q_vals)\n    return res\n\n\nclass UbTargetOrient(object):\n\n    def __init__(self, refl_list, crystal):\n        self.crystal = crystal\n        self.ref_data = _get_refl_hkl(refl_list)\n\n    def value(self, vals):\n        return _func_orient(vals, self.crystal, self.ref_data)\n\n\ndef get_crystal_target(refl_list, system):\n\n    try:\n        from org.apache.commons.math3.analysis import MultivariateFunction\n        from org.apache.commons.math3.optim.nonlinear.scalar import ObjectiveFunction\n\n        class MultivariateFunctionUbTarget(MultivariateFunction):\n\n            def value(self, vals):\n                target_obj = UbTargetCrystal(refl_list, system)\n                return target_obj.value(vals)\n\n        return ObjectiveFunction(MultivariateFunctionUbTarget())\n    except ImportError:\n        target_obj = UbTargetCrystal(refl_list, system)\n        return target_obj.value\n\n\ndef get_u_target(refl_list, crystal):\n\n    try:\n        from org.apache.commons.math3.analysis import MultivariateFunction\n        from org.apache.commons.math3.optim.nonlinear.scalar import ObjectiveFunction\n\n        class MultivariateFunctionUbTarget(MultivariateFunction):\n\n            def value(self, vals):\n                target_obj = UbTargetOrient(refl_list, crystal)\n                return target_obj.value(vals)\n\n        return ObjectiveFunction(MultivariateFunctionUbTarget())\n    except ImportError:\n        target_obj = UbTargetOrient(refl_list, crystal)\n        return target_obj.value\n\n\ndef _get_rot_matrix(q0, q1, q2, q3):\n    rot = matrix([[q0**2 + q1**2 - q2**2 - q3**2,            2.*(q1*q2 - q0*q3),            2.*(q1*q3 + q0*q2),],\n                  [           2.*(q1*q2 + q0*q3), q0**2 - q1**2 + q2**2 - q3**2,            2.*(q2*q3 - q0*q1),],\n                  [           2.*(q1*q3 - q0*q2),            2.*(q2*q3 + q0*q1), q0**2 - q1**2 - q2**2 + q3**2,]])\n    return rot\n\n\ndef _get_init_u123(um):\n\n    tr = um[0,0] + um[1,1] + um[2,2]\n    sgn_q1 = sign(um[2,1] - um[1,2])\n    sgn_q2 = sign(um[0,2] - um[2,0])\n    sgn_q3 = sign(um[1,0] - um[0,1])\n    q0 = sqrt(1. + tr) / 2.\n    q1 = sgn_q1 * sqrt(1. + um[0,0] - um[1,1] - um[2,2]) / 2.0\n    q2 = sgn_q2 * sqrt(1. - um[0,0] + um[1,1] - um[2,2]) / 2.0\n    q3 = sgn_q3 * sqrt(1. - um[0,0] - um[1,1] + um[2,2]) / 2.0\n    u1 = (1. - um[0,0]) / 2.\n    u2 = atan2(q0, q1) / (2. * pi)\n    u3 = atan2(q2, q3) / (2. * pi)\n    if u2 < 0: u2 += 1.\n    if u3 < 0: u3 += 1.\n    return u1, u2, u3\n\n\ndef _get_quat_from_u123(u1, u2, u3):\n    q0, q1 = sqrt(1.-u1)*sin(2.*pi*u2), sqrt(1.-u1)*cos(2.*pi*u2)\n    q2, q3 =    sqrt(u1)*sin(2.*pi*u3),    sqrt(u1)*cos(2.*pi*u3)\n    return q0, q1, q2, q3\n\n\ndef _get_uc_upper_limits(system):\n    max_unit = 100.\n    sgm_unit = 1e-2\n    sgm_angle = 1e-1\n    if system == \'Triclinic\':\n        return ([max_unit, max_unit, max_unit,\n                    180., 180., 180.],\n                [sgm_unit, sgm_unit, sgm_unit,\n                    sgm_angle, sgm_angle, sgm_angle])\n    elif system == \'Monoclinic\':\n        return ([max_unit, max_unit, max_unit, 180.],\n                [sgm_unit, sgm_unit, sgm_unit, sgm_angle])\n    elif system == \'Orthorhombic\':\n        return ([max_unit, max_unit, max_unit,],\n                [sgm_unit, sgm_unit, sgm_unit,])\n    elif system == \'Tetragonal\' or system == \'Hexagonal\':\n        return ([max_unit, max_unit,],\n                [sgm_unit, sgm_unit,])\n    elif system == \'Rhombohedral\': \n        return ([max_unit, 180.,],\n                [sgm_unit, sgm_angle,])\n    elif system == \'Cubic\':\n        return ([max_unit,],\n                [sgm_unit,])\n    else:\n        raise TypeError(""Invalid crystal system parameter: %s"" % str(system))\n\n\ndef fit_crystal(uc, refl_list):\n    try:\n        uc_system, uc_params = uc.get_lattice_params()\n        start = uc_params\n        lower = [0,] * len(uc_params)\n        upper, sigma = _get_uc_upper_limits(uc_system)\n    except AttributeError:\n        raise DiffcalcException(""UB matrix not initialised. Cannot run UB matrix fitting procedure."")\n    try:\n        from org.apache.commons.math3.optim.nonlinear.scalar.noderiv import CMAESOptimizer\n        from org.apache.commons.math3.optim.nonlinear.scalar import GoalType\n        from org.apache.commons.math3.optim import MaxEval, InitialGuess, SimpleBounds\n        from org.apache.commons.math3.random import MersenneTwister\n        \n        optimizer = CMAESOptimizer(30000,\n                                   0,\n                                   True,\n                                   10,\n                                   0,\n                                   MersenneTwister(),\n                                   True,\n                                   None)\n        opt = optimizer.optimize((MaxEval(5000),\n                                   get_crystal_target(refl_list, uc_system),\n                                   GoalType.MINIMIZE,\n                                   CMAESOptimizer.PopulationSize(15),\n                                   CMAESOptimizer.Sigma(sigma),\n                                   InitialGuess(start),\n                                   SimpleBounds(lower, upper)))\n        vals = opt.getPoint()\n        #res = opt.getValue()\n    except ImportError:\n        from scipy.optimize import minimize\n\n        ref_data = _get_refl_hkl(refl_list)\n        bounds = zip(lower, upper)\n        res = minimize(_func_crystal,\n                       start,\n                       args=(uc_system, ref_data),\n                       method=\'SLSQP\',\n                       tol=1e-10,\n                       options={\'disp\' : False,\n                                \'maxiter\': 10000,\n                                \'eps\': 1e-6,\n                                \'ftol\': 1e-10},\n                       bounds=bounds)\n        vals = res.x\n    res_cr = CrystalUnderTest(\'trial\', uc_system, 1, 1, 1, 90, 90, 90)\n    res_cr._set_cell_for_system(uc_system, *vals)\n    return res_cr\n\ndef fit_u_matrix(init_u, uc, refl_list):\n    try:\n        start = list(_get_init_u123(init_u))\n        lower = [ 0, 0, 0]\n        upper = [ 1, 1, 1]\n        sigma = [ 1e-2, 1e-2, 1e-2]\n    except AttributeError:\n        raise DiffcalcException(""UB matrix not initialised. Cannot run UB matrix fitting procedure."")\n    try:\n        from org.apache.commons.math3.optim.nonlinear.scalar.noderiv import CMAESOptimizer\n        from org.apache.commons.math3.optim.nonlinear.scalar import GoalType\n        from org.apache.commons.math3.optim import MaxEval, InitialGuess, SimpleBounds\n        from org.apache.commons.math3.random import MersenneTwister\n        \n        optimizer = CMAESOptimizer(30000,\n                                   0,\n                                   True,\n                                   10,\n                                   0,\n                                   MersenneTwister(),\n                                   True,\n                                   None)\n        opt = optimizer.optimize((MaxEval(3000),\n                                   get_u_target(refl_list, uc),\n                                   GoalType.MINIMIZE,\n                                   CMAESOptimizer.PopulationSize(15),\n                                   CMAESOptimizer.Sigma(sigma),\n                                   InitialGuess(start),\n                                   SimpleBounds(lower, upper)))\n        vals = opt.getPoint()\n        res = opt.getValue()\n    except ImportError:\n        from scipy.optimize import minimize\n\n        ref_data = _get_refl_hkl(refl_list)\n        bounds = zip(lower, upper)\n        res = minimize(_func_orient,\n                       start,\n                       args=(uc, ref_data),\n                       method=\'SLSQP\',\n                       tol=1e-10,\n                       options={\'disp\' : False,\n                                \'maxiter\': 10000,\n                                \'eps\': 1e-6,\n                                \'ftol\': 1e-10},\n                       bounds=bounds)\n        vals = res.x\n    q0, q1, q2, q3 = _get_quat_from_u123(*vals)\n    res_u = _get_rot_matrix(q0, q1, q2, q3)\n    #angle = 2. * acos(q0)\n    #xr = q1 / sqrt(1. - q0 * q0)\n    #yr = q2 / sqrt(1. - q0 * q0)\n    #zr = q3 / sqrt(1. - q0 * q0)\n    #print angle * TODEG, (xr, yr, zr), res\n    return res_u\n'"
diffcalc/ub/orientations.py,0,"b'###\n# Copyright 2008-2017 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom copy import deepcopy\nimport datetime  # @UnusedImport for the eval below\nfrom diffcalc.hkl.you.geometry import YouPosition\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.util import DiffcalcException, bold\n\n\nclass _Orientation:\n    """"""A orientation""""""\n    def __init__(self, h, k, l, x, y, z, position, tag, time):\n\n        self.h = float(h)\n        self.k = float(k)\n        self.l = float(l)\n        self.x = float(x)\n        self.y = float(y)\n        self.z = float(z)\n        self.pos = position\n        self.tag = tag\n        self.time = time  # Saved as e.g. repr(datetime.now())\n\n    def __str__(self):\n        return (""h=%-4.2f k=%-4.2f l=%-4.2f  x=%-4.2f ""\n                ""y=%-4.2f z=%-4.2  mu=%-8.4f ""\n                ""delta=%-8.4f nu=%-8.4f eta=%-8.4f chi=%-8.4f ""\n                ""phi=%-8.4f  %-s %s"" % (self.h, self.k, self.l,\n                self.x, self.y, self.z,\n                self.pos.mu, self.pos.delta, self.pos.nu, self.pos.eta,\n                self.pos.chi, self.pos.phi, self.tag, self.time))\n\n\nclass OrientationList:\n\n    def __init__(self, geometry, externalAngleNames, orientations=None):\n        self._geometry = geometry\n        self._externalAngleNames = externalAngleNames\n        self._orientlist = orientations if orientations else []\n\n    def get_tag_index(self, idx):\n        _tag_list = [ornt.tag for ornt in self._orientlist]\n        try:\n            num  = _tag_list.index(idx)\n        except ValueError:\n            if isinstance(idx, int):\n                if idx < 1 or idx > len(self._orientlist):\n                    raise IndexError(""Orientation index is out of range"")\n                else:\n                    num = idx - 1\n            else:\n                raise IndexError(""Orientation index not found"")\n        return num\n\n    def add_orientation(self, h, k, l, x, y, z, position, tag, time):\n        """"""adds a crystal orientation\n        """"""\n        if type(position) in (list, tuple):\n            try:\n                position = self._geometry.create_position(*position)\n            except AttributeError:\n                position = YouPosition(*position)\n        self._orientlist += [_Orientation(h, k, l, x, y, z, position, tag,\n                                     time.__repr__())]\n\n    def edit_orientation(self, idx, h, k, l, x, y, z, position, tag, time):\n        """"""num starts at 1""""""\n        try:\n            num = self.get_tag_index(idx)\n        except IndexError:\n            raise DiffcalcException(""There is no orientation "" + repr(idx)\n                                     + "" to edit."")\n        if type(position) in (list, tuple):\n            position = YouPosition(*position)\n        self._orientlist[num] = _Orientation(h, k, l, x, y, z, position, tag, time.__repr__())\n\n    def getOrientation(self, idx):\n        """"""\n        getOrientation(idx) --> ( [h, k, l], [x, y, z], pos, tag, time ) --\n        idx refers to an orientation index (starts at 1) or a tag\n        """"""\n        num = self.get_tag_index(idx)\n        r = deepcopy(self._orientlist[num])  # for convenience\n        return [r.h, r.k, r.l], [r.x, r.y, r.z], deepcopy(r.pos), r.tag, eval(r.time)\n\n    def get_orientation_in_external_angles(self, idx):\n        """"""\n        get_orientation_in_external_angles(idx) --> ( [h, k, l], [x, y, z], pos, tag, time ) --\n        idx refers to an orientation index (starts at 1) or a tag\n        """"""\n        num = self.get_tag_index(idx)\n        r = deepcopy(self._orientlist[num])  # for convenience\n        externalAngles = self._geometry.internal_position_to_physical_angles(r.pos)\n        result = [r.h, r.k, r.l], [r.x, r.y, r.z], externalAngles, r.tag, eval(r.time)\n        return result\n\n    def removeOrientation(self, idx):\n        num = self.get_tag_index(idx)\n        del self._orientlist[num]\n\n    def swap_orientations(self, idx1, idx2):\n        num1 = self.get_tag_index(idx1)\n        num2 = self.get_tag_index(idx2)\n        orig1 = self._orientlist[num1]\n        self._orientlist[num1] = self._orientlist[num2]\n        self._orientlist[num2] = orig1\n\n    def __len__(self):\n        return len(self._orientlist)\n\n    def __str__(self):\n        return \'\\n\'.join(self.str_lines())\n\n    def str_lines(self, conv=None):\n        axes = tuple(s.upper() for s in self._externalAngleNames)\n        if not self._orientlist:\n            return [""   <<< none specified >>>""]\n\n        lines = []\n\n        str_format = (""     %5s %5s %5s   %5s %5s %5s  "" + ""%8s "" * len(axes) + "" TAG"")\n        values = (\'H\', \'K\', \'L\', \'X\', \'Y\', \'Z\') + axes\n        lines.append(bold(str_format % values))\n\n        for n in range(1, len(self._orientlist) + 1):\n            orient_tuple = self.get_orientation_in_external_angles(n)\n            [h, k, l], [x, y, z], externalAngles, tag, _ = orient_tuple\n            try:\n                xyz_rot = conv.transform(matrix([[x],[y],[z]]), True)\n                xr, yr, zr = xyz_rot.T.tolist()[0]\n            except AttributeError:\n                xr, yr, zr = x ,y ,z\n            if tag is None:\n                tag = """"\n            str_format = (""  %2d % 4.2f % 4.2f % 4.2f  "" +\n                      ""% 4.2f % 4.2f % 4.2f  "" + ""% 8.4f "" * len(axes) + "" %s"")\n            values = (n, h, k, l, xr, yr, zr) + externalAngles + (tag,)\n            lines.append(str_format % values)\n        return lines\n'"
diffcalc/ub/persistence.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom __future__ import with_statement\n\nimport os, glob\nimport datetime\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\n\ndef is_writable(directory):\n    """"""Return true if the file is writable from the current user\n    """"""\n    probe = os.path.join(directory, ""probe"")\n    try:\n        open(probe, \'w\')\n    except IOError:\n        return False\n    else:\n        os.remove(probe)\n        return True\n\ndef check_directory_appropriate(directory):\n\n    if not os.path.exists(directory):\n        raise IOError(""\'%s\' does not exist"")\n    \n    if not os.path.isdir(directory):\n        raise IOError(""\'%s\' is not a directory"")\n    \n    if not is_writable(directory):\n        raise IOError(""\'%s\' is not writable"")\n\n\nclass UBCalculationJSONPersister(object):\n\n    def __init__(self, directory, encoder):\n        check_directory_appropriate(directory)\n        self.directory = directory\n        self.description = directory\n        self.encoder = encoder\n        \n    def filepath(self, name):\n        return os.path.join(self.directory, name + \'.json\')\n        \n    def save(self, state, name):\n        # FORMAT = \'%Y-%m-%d %H:%M:%S\'\n        # time_string = datetime.datetime.strftime(datetime.datetime.now(), FORMAT)\n        with open(self.filepath(name), \'w\') as f:\n            json.dump(state, f, indent=4, cls=self.encoder)\n\n    def load(self, name):\n        with open(self.filepath(name), \'r\') as f:\n            return json.load(f)\n\n    def list(self):  # @ReservedAssignment\n        files = self._get_save_files()\n        return [os.path.basename(f + \'.json\').split(\'.json\')[0] for f in files]\n\n    def list_metadata(self):       \n        metadata = []\n        for f in self._get_save_files():            \n            dt = datetime.datetime.fromtimestamp(os.path.getmtime(f))\n            metadata.append(dt.strftime(\'%d %b %Y (%H:%M)\'))\n        return metadata\n    \n    def _get_save_files(self):\n        files = filter(os.path.isfile, glob.glob(os.path.join(self.directory, \'*.json\')))\n        files.sort(key=lambda x: os.path.getmtime(x))\n        files.reverse()\n        return files\n\n    def remove(self, name):\n        os.remove(self.filepath(name))\n\n\n\nclass UBCalculationPersister(object):\n    """"""Attempts to the use the gda\'s database to store ub calculation state\n    """"""\n    def __init__(self):\n        try:\n            from uk.ac.diamond.daq.persistence.jythonshelf import LocalJythonShelfManager\n            from uk.ac.diamond.daq.persistence.jythonshelf.LocalDatabase import \\\n                LocalDatabaseException\n            self.shelf = LocalJythonShelfManager.getLocalObjectShelf(\n                \'diffcalc.ub\')\n        except ImportError, e:\n            print (""!!! UBCalculationPersister could not import the gda database ""\n                   ""code: "" + repr(e))\n            self.shelf = None\n        except LocalDatabaseException, e:\n            print (""UBCalculationPersister could not connect to the gda ""\n                   ""database: "" + repr(e))\n            self.shelf = None\n        self.description = \'GDA sql database\'\n\n    def save(self, state, key):\n        if self.shelf is not None:\n            self.shelf[key] = state\n        else:\n            print ""<<<no database available to save UB calculation>>>""\n\n    def load(self, name):\n        if self.shelf is not None:\n            return self.shelf[name]\n        else:\n            raise IOError(""Could not load UB calculation: no database available"")\n\n    def list(self):  # @ReservedAssignment\n        if self.shelf is not None:\n            names = list(self.shelf.keys())\n            names.sort()\n            return names\n        else:\n            return []\n\n    def remove(self, name):\n        if self.shelf is not None:\n            del self.shelf[name]\n        else:\n            raise IOError(""Could not remove UB calculation: no database available"")\n\n\nclass UbCalculationNonPersister(UBCalculationPersister):\n    """"""\n    A version of UBCalculationPersister that simply stores to a local dict\n    rather than a database. Useful for testing.\n    """"""\n    def __init__(self):\n        self.shelf = dict()\n        self.description = \'memory only\'\n'"
diffcalc/ub/reference.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy.linalg import norm\n\n\nclass YouReference(object):\n    \n    def __init__(self, get_UB):\n        self.get_UB = get_UB  # callable\n        self._n_phi_configured = None\n        self._n_hkl_configured = None\n    \n    def _set_n_phi_configured(self, n_phi):\n        self._n_phi_configured = n_phi\n        self._n_hkl_configured = None\n    \n    def _get_n_phi_configured(self):\n        return self._n_phi_configured\n    \n    n_phi_configured = property(_get_n_phi_configured, _set_n_phi_configured)\n                    \n    def _set_n_hkl_configured(self, n_hkl):\n        self._n_phi_configured = None\n        self._n_hkl_configured = n_hkl\n        \n    def _get_n_hkl_configured(self):\n        return self._n_hkl_configured\n    \n    n_hkl_configured = property(_get_n_hkl_configured, _set_n_hkl_configured)\n    \n    @property\n    def n_phi(self):\n        if self._n_phi_configured is None:\n            n_phi = self.get_UB() * self._n_hkl_configured\n            n_phi = n_phi / norm(n_phi)\n        else:\n            n_phi = self._n_phi_configured\n        return n_phi\n        \n    @property\n    def n_hkl(self):\n        if self._n_hkl_configured is None:\n            n_hkl = self.get_UB().I * self._n_phi_configured\n            n_hkl = n_hkl / norm(n_hkl)\n        else:\n            n_hkl = self._n_hkl_configured\n        return n_hkl\n    \n    def _pretty_vector(self, m):\n        return \' \'.join([(\'% 9.5f\' % e).rjust(9) for e in m.T.tolist()[0]])\n    \n    def repr_lines(self, ub_calculated, WIDTH, conv):\n        SET_LABEL = \' <- set\'\n        lines = []\n        if self._n_phi_configured is not None:\n            nphi_label = SET_LABEL\n            nhkl_label = \'\'\n        elif self._n_hkl_configured is not None:\n            nphi_label = \'\'\n            nhkl_label = SET_LABEL\n        else:\n            raise AssertionError(""Neither a manual n_phi nor n_hkl is configured"")\n        \n        if ub_calculated:\n            lines.append(""   n_phi:"".ljust(WIDTH) + self._pretty_vector(conv.transform(self.n_phi, True)) + nphi_label)\n            lines.append(""   n_hkl:"".ljust(WIDTH) + self._pretty_vector(self.n_hkl) + nhkl_label)\n        else:  # no ub calculated\n            if self._n_phi_configured is not None:\n                lines.append(""   n_phi:"".ljust(WIDTH) + self._pretty_vector(conv.transform(self._n_phi_configured, True)) + SET_LABEL)\n            elif self._n_hkl_configured is not None:\n                lines.append(""   n_hkl:"".ljust(WIDTH) + self._pretty_vector(self._n_hkl_configured) + SET_LABEL)\n\n        return lines\n'"
diffcalc/ub/reflections.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom copy import deepcopy\nimport datetime  # @UnusedImport for the eval below\nfrom diffcalc.util import DiffcalcException, bold\nfrom diffcalc.hkl.you.geometry import YouPosition\n\n\nclass _Reflection:\n    """"""A reflection""""""\n    def __init__(self, h, k, l, position, energy, tag, time):\n\n        self.h = float(h)\n        self.k = float(k)\n        self.l = float(l)\n        self.pos = position\n        self.tag = tag\n        self.energy = float(energy)      # energy=12.39842/lambda\n        self.wavelength = 12.3984 / self.energy\n        self.time = time  # Saved as e.g. repr(datetime.now())\n\n    def __str__(self):\n        return (""energy=%-6.3f h=%-4.2f k=%-4.2f l=%-4.2f  mu=%-8.4f ""\n                ""delta=%-8.4f nu=%-8.4f eta=%-8.4f chi=%-8.4f ""\n                ""phi=%-8.4f  %-s %s"" % (self.energy, self.h, self.k, self.l,\n                self.pos.mu, self.pos.delta, self.pos.nu, self.pos.eta,\n                self.pos.chi, self.pos.phi, self.tag, self.time))\n\n\nclass ReflectionList:\n\n    def __init__(self, geometry, externalAngleNames, reflections=None, multiplier=1):\n        self._geometry = geometry\n        self._externalAngleNames = externalAngleNames\n        self._reflist = reflections if reflections else []\n        self._multiplier = multiplier\n\n    def get_tag_index(self, idx):\n        _tag_list = [ref.tag for ref in self._reflist]\n        try:\n            num  = _tag_list.index(idx)\n        except ValueError:\n            if isinstance(idx, int):\n                if idx < 1 or idx > len(self._reflist):\n                    raise IndexError(""Reflection index is out of range"")\n                else:\n                    num = idx - 1\n            else:\n                raise IndexError(""Reflection index not found"")\n        return num\n\n    def add_reflection(self, h, k, l, position, energy, tag, time):\n        """"""adds a reflection, position in degrees\n        """"""\n        if type(position) in (list, tuple):\n            try:\n                position = self._geometry.create_position(*position)\n            except AttributeError:\n                position = YouPosition(*position)\n        self._reflist += [_Reflection(h, k, l, position, energy, tag, time.__repr__())]\n\n    def edit_reflection(self, idx, h, k, l, position, energy, tag, time):\n        """"""num starts at 1""""""\n        try:\n            num = self.get_tag_index(idx)\n        except IndexError:\n            raise DiffcalcException(""There is no reflection "" + repr(idx)\n                                     + "" to edit."")\n        if type(position) in (list, tuple):\n            position = YouPosition(*position)\n        self._reflist[num] = _Reflection(h, k, l, position, energy, tag, time.__repr__())\n\n    def getReflection(self, idx):\n        """"""\n        getReflection(idx) --> ( [h, k, l], position, energy, tag, time ) --\n        position in degrees\n        """"""\n        num = self.get_tag_index(idx)\n        r = deepcopy(self._reflist[num])  # for convenience\n        return [r.h, r.k, r.l], deepcopy(r.pos), r.energy, r.tag, eval(r.time)\n\n    def get_reflection_in_external_angles(self, idx):\n        """"""getReflection(num) --> ( [h, k, l], (angle1...angleN), energy, tag )\n        -- position in degrees""""""\n        num = self.get_tag_index(idx)\n        r = deepcopy(self._reflist[num])  # for convenience\n        externalAngles = self._geometry.internal_position_to_physical_angles(r.pos)\n        result = [r.h, r.k, r.l], externalAngles, r.energy, r.tag, eval(r.time)\n        return result\n\n    def removeReflection(self, idx):\n        num = self.get_tag_index(idx)\n        del self._reflist[num]\n\n    def swap_reflections(self, idx1, idx2):\n        num1 = self.get_tag_index(idx1)\n        num2 = self.get_tag_index(idx2)\n        orig1 = self._reflist[num1]\n        self._reflist[num1] = self._reflist[num2]\n        self._reflist[num2] = orig1\n\n    def __len__(self):\n        return len(self._reflist)\n\n    def __str__(self):\n        return \'\\n\'.join(self.str_lines())\n\n    def str_lines(self):\n        axes = tuple(s.upper() for s in self._externalAngleNames)\n        if not self._reflist:\n            return [""   <<< none specified >>>""]\n\n        lines = []\n\n        format = (""     %6s %5s %5s %5s  "" + ""%8s "" * len(axes) + "" TAG"")\n        values = (\'ENERGY\', \'H\', \'K\', \'L\') + axes\n        lines.append(bold(format % values))\n\n        for n in range(1, len(self._reflist) + 1):\n            ref_tuple = self.get_reflection_in_external_angles(n)\n            [h, k, l], externalAngles, energy, tag, _ = ref_tuple\n            if tag is None:\n                tag = """"\n            format = (""  %2d %6.3f % 4.2f % 4.2f % 4.2f  "" +\n                      ""% 8.4f "" * len(axes) + "" %s"")\n            values = (n, energy / self._multiplier, h, k, l) + externalAngles + (tag,)\n            lines.append(format % values)\n        return lines\n'"
diffcalc/ub/ub.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc import settings\nfrom diffcalc.ub.calc import UBCalculation\n\nfrom math import asin, pi\nfrom datetime import datetime\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\nfrom diffcalc.util import getInputWithDefault as promptForInput, \\\n    promptForNumber, promptForList, isnum, bold, SMALL, DiffcalcException\nfrom diffcalc.util import command\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\n# When using ipython magic, these functions must not be imported to the top\n# level namespace. Doing so will stop them from being called with magic.\n\n__all__ = [\'addorient\', \'addref\', \'c2th\', \'hklangle\', \'calcub\', \'delorient\', \'delref\', \'editorient\',\n           \'editref\', \'listub\', \'loadub\', \'newub\', \'orientub\', \'saveubas\', \'setlat\',\n           \'addmiscut\', \'setmiscut\', \'setu\', \'setub\', \'showorient\', \'showref\', \'swaporient\',\n           \'swapref\', \'trialub\', \'fitub\', \'checkub\', \'ub\', \'ubcalc\', \'rmub\', \'clearorient\',\n           \'clearref\', \'lastub\', \'refineub\', \'surfnphi\', \'surfnhkl\']\n\nif settings.include_sigtau:\n    __all__.append(\'sigtau\')\n\nif settings.include_reference:\n    __all__.append(\'setnphi\')\n    __all__.append(\'setnhkl\')\n\n\nubcalc = UBCalculation(settings.ubcalc_persister,\n                       settings.ubcalc_strategy,\n                       settings.include_sigtau,\n                       settings.include_reference)\n\n\n\n### UB state ###\n\n@command\ndef newub(name=None):\n    """"""newub {\'name\'} -- start a new ub calculation name\n    """"""\n    if name is None:\n        # interactive\n        name = promptForInput(\'calculation name\')\n        while not name:\n            print \'Please provide non-empty UB calculation name\'\n            name = promptForInput(\'calculation name\')\n        try:\n            ubcalc.start_new(name)\n        except IOError:\n            raise DiffcalcException(\'Cannot create UB calculation persistence file with name ""%s""\' % name)\n        setlat()\n    elif isinstance(name, basestring):\n        if name in ubcalc._persister.list():\n            print (""No UB calculation started: There is already a calculation ""\n                    ""called: "" + name)\n            reply = promptForInput(""Load the existing UB calculation \'%s\'? "" % name, \'y\')\n            if reply in (\'y\', \'Y\', \'yes\'):\n                loadub(name)\n                return\n            else:\n                reply = promptForInput(""Overwrite the existing UB calculation \'%s\'? "" % name, \'y\')\n                if reply in (\'y\', \'Y\', \'yes\'):\n                    ubcalc.start_new(name)\n                    setlat()\n                else:\n                    print (""Aborting"")\n        else:\n            # just trying might cause confusion here\n            ubcalc.start_new(name)\n    else:\n        raise TypeError()\n\n@command\ndef loadub(name_or_num):\n    """"""loadub \'name\' | num -- load an existing ub calculation\n    """"""\n    if isinstance(name_or_num, basestring):\n        ubcalc.load(name_or_num)\n    else:\n        ubcalc.load(ubcalc.listub()[int(name_or_num)])\n\n@command\ndef lastub():\n    """"""lastub -- load the last used ub calculation\n    """"""\n    try:\n        lastub_name = ubcalc.listub()[0]\n        print ""Loading ub calculation: \'%s\'"" % lastub_name\n        loadub(0)\n    except IndexError:\n        print ""WARNING: There is no record of the last ub calculation used""\n\n@command\ndef rmub(name_or_num):\n    """"""rmub \'name\'|num -- remove existing ub calculation\n    """"""\n    if isinstance(name_or_num, basestring):\n        ubcalc.remove(name_or_num)\n    else:\n        ubcalc.remove(ubcalc.listub()[int(name_or_num)])\n\n@command\ndef listub():\n    """"""listub -- list the ub calculations available to load.\n    """"""\n    if hasattr(ubcalc._persister, \'description\'):\n        print ""UB calculations in: "" + ubcalc._persister.description\n    else:\n        print ""UB calculations:""\n    print\n    ubnames = ubcalc.listub()\n    # TODO: whole mechanism of making two calls is messy\n    try:\n        ub_metadata = ubcalc.listub_metadata()\n    except AttributeError:\n        ub_metadata = [\'\'] * len(ubnames)\n    try:\n        wdt_names = max([len(nm) for nm in ubnames])\n    except Exception:\n        wdt_names = 30\n    fmt_names = \' \'.join([""%3i) "",\n                          ""%%-%is "" % wdt_names,\n                          ""%s""])\n    for n, name, data in zip(range(len(ubnames)), ubnames, ub_metadata):\n        print fmt_names % (n, name, data)\n\n@command\ndef saveubas(name):\n    """"""saveubas \'name\' -- save the ub calculation with a new name\n    """"""\n    if isinstance(name, basestring):\n        # just trying might cause confusion here\n        ubcalc.saveas(name)\n    else:\n        raise TypeError()\n\n@command\ndef ub():\n    """"""ub -- show the complete state of the ub calculation\n    """"""\n    #wavelength = float(hardware.get_wavelength())\n    #energy = float(hardware.get_energy())\n    print ubcalc.__str__()\n\n### UB lattice ###\n\n@command\ndef setlat(name=None, *args):\n    """"""\n    setlat  -- interactively enter lattice parameters (Angstroms and Deg)\n\n    setlat name \'Cubic\' a -- sets Cubic system\n    setlat name \'Tetragonal\' a c -- sets Tetragonal system\n    setlat name \'Hexagonal\' a c -- sets Hexagonal system\n    setlat name \'Orthorhombic\' a b c -- sets Orthorombic system\n    setlat name \'Rhombohedral\' a alpha -- sets Rhombohedral system\n    setlat name \'Monoclinic\' a b c beta -- sets Monoclinic system\n    setlat name \'Triclinic\' a b c alpha beta gamma -- sets Triclinic system\n\n    setlat name a -- assumes Cubic system\n    setlat name a b -- assumes Tetragonal system\n    setlat name a b c -- assumes Orthorombic system\n    setlat name a b c angle -- assumes Monoclinic system with beta not equal to 90 or\n                                       Hexagonal system if a = b and gamma = 120\n    setlat name a b c alpha beta gamma -- sets Triclinic system\n    """"""\n\n    if name is None:  # Interactive\n        name = promptForInput(""crystal name"")\n        system = None\n        systen_dict = {1: ""Triclinic"",\n                       2: ""Monoclinic"",\n                       3: ""Orthorhombic"",\n                       4: ""Tetragonal"",\n                       5: ""Rhombohedral"",\n                       6: ""Hexagonal"",\n                       7: ""Cubic""}\n        while system is None:\n            system_fmt = ""\\n"".join([""crystal system"",] + \n                                   [""%d) %s"" % (k, v) \n                                    for (k, v) in systen_dict.items()] +\n                                   [\'\',])\n            system = promptForNumber(system_fmt, 1)\n            if system not in systen_dict.keys():\n                print ""Invalid crystal system index selection.\\n""\n                print ""Please select vale between 1 and 7.""\n                system = None\n        a = promptForNumber(\'    a\', 1)\n        args = (a,)\n        if system in (1, 2, 3):\n            b = promptForNumber(\'    b\', a)\n            args += (b,)\n        if system in (1, 2, 3, 4, 6):\n            c = promptForNumber(\'    c\', a)\n            args += (c,)\n        if system in (1, 5):\n            alpha = promptForNumber(\'alpha\', 90)\n            args += (alpha,)\n        if system in (1, 2):\n            beta = promptForNumber(\'beta\', 90)\n            args += (beta,)\n        if system in (1,):\n            gamma = promptForNumber(\'gamma\', 90)\n            args += (gamma,)\n        args = (systen_dict[system],) + args\n    elif not isinstance(name, basestring):\n        raise TypeError(""Invalid crystal name."")\n    ubcalc.set_lattice(name, *args)\n\n\n@command\ndef c2th(hkl, en=None):\n    """"""\n    c2th [h k l]  -- calculate two-theta angle for reflection\n    """"""\n    if en is None:\n        wl = settings.hardware.get_wavelength()  # @UndefinedVariable\n    else:\n        wl = 12.39842 / en\n    d = ubcalc.get_hkl_plane_distance(hkl)\n    if wl > (2 * d):\n        raise ValueError(\n            \'Reflection un-reachable as wavelength (%f) is more than twice\\n\'\n            \'the plane distance (%f)\' % (wl, d))\n    try:\n        return 2.0 * asin(wl / (d * 2)) * TODEG\n    except ValueError as e:\n        raise ValueError(\'asin(wl / (d * 2) with wl=%f and d=%f: \' %(wl, d) + e.args[0])\n    \n\n@command\ndef hklangle(hkl1, hkl2):\n    """"""\n    hklangle [h1 k1 l1] [h2 k2 l2]  -- calculate angle between [h1 k1 l1] and [h2 k2 l2] planes\n    """"""\n    return ubcalc.get_hkl_plane_angle(hkl1, hkl2) * TODEG\n\n### Surface and reference vector stuff ###\n\n@command\ndef sigtau(sigma=None, tau=None):\n    """"""sigtau {sigma tau} -- sets or displays sigma and tau""""""\n    if sigma is None and tau is None:\n        chi = settings.hardware.get_position_by_name(\'chi\')  # @UndefinedVariable\n        phi = settings.hardware.get_position_by_name(\'phi\')  # @UndefinedVariable\n        _sigma, _tau = ubcalc.sigma, ubcalc.tau\n        print ""sigma, tau = %f, %f"" % (_sigma, _tau)\n        print ""  chi, phi = %f, %f"" % (chi, phi)\n        sigma = promptForInput(""sigma"", -chi)\n        tau = promptForInput(""  tau"", -phi)\n        ubcalc.sigma = sigma\n        ubcalc.tau = tau\n    else:\n        ubcalc.sigma = float(sigma)\n        ubcalc.tau = float(tau)\n\n\n@command\ndef setnphi(xyz=None):\n    """"""setnphi {[x y z]} -- sets or displays n_phi reference vector""""""\n    if xyz is None:\n        ubcalc.print_reference()\n    else:\n        ubcalc.set_n_phi_configured(_to_column_vector_triple(xyz))\n        ubcalc.print_reference()\n\n@command\ndef setnhkl(hkl=None):\n    """"""setnhkl {[h k l]} -- sets or displays n_hkl reference vector""""""\n    if hkl is None:\n        ubcalc.print_reference()\n    else:\n        ubcalc.set_n_hkl_configured(_to_column_vector_triple(hkl))\n        ubcalc.print_reference()\n \n \n@command\ndef surfnphi(xyz=None):\n    """"""surfnphi {[x y z]} -- sets or displays surface normal vector in lab space""""""\n    if xyz is None:\n        ubcalc.print_surface()\n    else:\n        ubcalc.set_surf_nphi_configured(_to_column_vector_triple(xyz))\n        ubcalc.print_surface()\n\n@command\ndef surfnhkl(hkl=None):\n    """"""surfnhkl {[h k l]} -- sets or displays surface normal vector in reciprocal space""""""\n    if hkl is None:\n        ubcalc.print_surface()\n    else:\n        ubcalc.set_surf_nhkl_configured(_to_column_vector_triple(hkl))\n        ubcalc.print_surface()\n \n \ndef _to_column_vector_triple(o):\n    m = matrix(o)\n    if m.shape == (1, 3):\n        return m.T\n    elif m.shape == (3, 1):\n        return m\n    else:\n        raise ValueError(""Unexpected shape matrix: "" + m)\n    \n### UB refelections ###\n\n@command\ndef showref():\n    """"""showref -- shows full reflection list""""""\n    if ubcalc._state.reflist:\n        print \'\\n\'.join(ubcalc.str_lines_refl())\n    else:\n        print ""<<< No reflections stored >>>""\n\n@command\ndef addref(*args):\n    """"""\n    addref -- add reflection interactively\n    addref [h k l] {\'tag\'} -- add reflection with current position and energy\n    addref [h k l] (p1, .., pN) energy {\'tag\'} -- add arbitrary reflection\n    """"""\n\n    multiplier = settings.hardware.energyScannableMultiplierToGetKeV\n    if len(args) == 0:\n        h = promptForNumber(\'h\', 0.)\n        k = promptForNumber(\'k\', 0.)\n        l = promptForNumber(\'l\', 0.)\n        if None in (h, k, l):\n            _handleInputError(""h,k and l must all be numbers"")\n        reply = promptForInput(\'current pos\', \'y\')\n        if reply in (\'y\', \'Y\', \'yes\'):\n            positionList = settings.hardware.get_position()  # @UndefinedVariable\n            energy = settings.hardware.get_energy()  # @UndefinedVariable\n        else:\n            currentPos = settings.hardware.get_position()  # @UndefinedVariable\n            positionList = []\n            names = settings.hardware.get_axes_names()  # @UndefinedVariable\n            for i, angleName in enumerate(names):\n                val = promptForNumber(angleName.rjust(7), currentPos[i])\n                if val is None:\n                    _handleInputError(""Please enter a number, or press""\n                                          "" Return to accept default!"")\n                    return\n                positionList.append(val)\n            energy = promptForNumber(\'energy\', settings.hardware.get_energy() / multiplier)  # @UndefinedVariable\n            if energy is None:\n                _handleInputError(""Please enter a number, or press ""\n                                      ""Return to accept default!"")\n                return\n            energy *= multiplier\n        tag = promptForInput(""tag"")\n        if tag == \'\':\n            tag = None\n        pos = settings.geometry.physical_angles_to_internal_position(positionList)  # @UndefinedVariable\n        ubcalc.add_reflection(h, k, l, pos, energy, tag,\n                                   datetime.now())\n    elif len(args) in (1, 2, 3, 4):\n        args = list(args)\n        h, k, l = args.pop(0)\n        if not (isnum(h) and isnum(k) and isnum(l)):\n            raise TypeError(""h,k and l must all be numbers"")\n        if len(args) >= 2:\n            pos = settings.geometry.physical_angles_to_internal_position(  # @UndefinedVariable\n                args.pop(0))\n            energy = args.pop(0) * multiplier\n            if not isnum(energy):\n                raise TypeError(""Energy value must be a number"")\n        else:\n            pos = settings.geometry.physical_angles_to_internal_position(  # @UndefinedVariable\n                settings.hardware.get_position())  # @UndefinedVariable\n            energy = settings.hardware.get_energy()  # @UndefinedVariable\n        if len(args) == 1:\n            tag = args.pop(0)\n            if not isinstance(tag, basestring):\n                raise TypeError(""Tag value must be a string"")\n            if tag == \'\':\n                tag = None\n        else:\n            tag = None\n        ubcalc.add_reflection(h, k, l, pos, energy, tag,\n                                   datetime.now())\n    else:\n        raise TypeError(""Too many parameters specified for addref command."")\n\n@command\ndef editref(idx):\n    """"""editref {num | \'tag\'} -- interactively edit a reflection.\n    """"""\n\n    # Get old reflection values\n    [oldh, oldk, oldl], oldExternalAngles, oldEnergy, oldTag, oldT = \\\n        ubcalc.get_reflection_in_external_angles(idx)\n    del oldT  # current time will be used.\n\n    h = promptForNumber(\'h\', oldh)\n    k = promptForNumber(\'k\', oldk)\n    l = promptForNumber(\'l\', oldl)\n    if None in (h, k, l):\n        _handleInputError(""h,k and l must all be numbers"")\n    reply = promptForInput(\'update position with current hardware setting\',\n                           \'n\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        positionList = settings.hardware.get_position()  # @UndefinedVariable\n        energy = settings.hardware.get_energy()  # @UndefinedVariable\n    else:\n        positionList = []\n        names = settings.hardware.get_axes_names()  # @UndefinedVariable\n        for i, angleName in enumerate(names):\n            val = promptForNumber(angleName.rjust(7), oldExternalAngles[i])\n            if val is None:\n                _handleInputError(""Please enter a number, or press ""\n                                      ""Return to accept default!"")\n                return\n            positionList.append(val)\n        muliplier = settings.hardware.energyScannableMultiplierToGetKeV  # @UndefinedVariable\n        energy = promptForNumber(\'energy\', oldEnergy / muliplier)\n        if energy is None:\n            _handleInputError(""Please enter a number, or press Return ""\n                                  ""to accept default!"")\n            return\n        energy = energy * muliplier\n    tag = promptForInput(""tag"", oldTag)\n    if tag == \'\':\n        tag = None\n    pos = settings.geometry.physical_angles_to_internal_position(positionList)  # @UndefinedVariable\n    ubcalc.edit_reflection(idx, h, k, l, pos, energy, tag,\n                                datetime.now())\n\n@command\ndef delref(idx):\n    """"""delref {num | \'tag\'} -- deletes a reflection\n    """"""\n    ubcalc.del_reflection(idx)\n    \n@command\ndef clearref():\n    """"""clearref -- deletes all the reflections\n    """"""\n    while ubcalc.get_number_reflections():\n        ubcalc.del_reflection(1)   \n\n@command\ndef swapref(idx1=None, idx2=None):\n    """"""\n    swapref -- swaps first two reflections used for calculating U matrix\n    swapref {num1 | \'tag1\'} {num2 | \'tag2\'} -- swaps two reflections\n    """"""\n    if idx1 is None and idx2 is None:\n        ubcalc.swap_reflections(1, 2)\n    elif idx1 is None or idx2 is None:\n        raise TypeError(""Please specify two reflection references to swap"")\n    else:\n        ubcalc.swap_reflections(idx1, idx2)\n\n### U calculation from crystal orientation\n@command\ndef showorient():\n    """"""showorient -- shows full list of crystal orientations""""""\n    if ubcalc._state.orientlist:\n        print \'\\n\'.join(ubcalc.str_lines_orient())\n    else:\n        print ""<<< No crystal orientations stored >>>""\n\n@command\ndef addorient(*args):\n    """"""\n    addorient -- add crystal orientation interactively\n    addorient [h k l] [x y z] {\'tag\'} -- add crystal orientation with current position in laboratory frame\n    addorient [h k l] [x y z] (p1, .., pN) {\'tag\'} -- add crystal orientation in laboratory frame\n    """"""\n\n    if len(args) == 0:\n        h = promptForNumber(\'h\', 0.)\n        k = promptForNumber(\'k\', 0.)\n        l = promptForNumber(\'l\', 0.)\n        if None in (h, k, l):\n            _handleInputError(""h,k and l must all be numbers"")\n\n        x = promptForNumber(\'x\', 0.)\n        y = promptForNumber(\'y\', 0.)\n        z = promptForNumber(\'z\', 0.)\n        if None in (x, y, z):\n            _handleInputError(""x,y and z must all be numbers"")\n\n        reply = promptForInput(\'current pos\', \'y\')\n        if reply in (\'y\', \'Y\', \'yes\'):\n            positionList = settings.hardware.get_position()  # @UndefinedVariable\n        else:\n            currentPos = settings.hardware.get_position()  # @UndefinedVariable\n            positionList = []\n            names = settings.hardware.get_axes_names()  # @UndefinedVariable\n            for i, angleName in enumerate(names):\n                val = promptForNumber(angleName.rjust(7), currentPos[i])\n                if val is None:\n                    _handleInputError(""Please enter a number, or press""\n                                          "" Return to accept default!"")\n                    return\n                positionList.append(val)\n        tag = promptForInput(""tag"")\n        if tag == \'\':\n            tag = None\n        pos = settings.geometry.physical_angles_to_internal_position(positionList)  # @UndefinedVariable\n        ubcalc.add_orientation(h, k, l, x , y, z, pos, tag,\n                                   datetime.now())\n    elif len(args) in (2, 3, 4):\n        args = list(args)\n        h, k, l = args.pop(0)\n        if not (isnum(h) and isnum(k) and isnum(l)):\n            raise TypeError(""h,k and l must all be numbers"")\n        x, y, z = args.pop(0)\n        if not (isnum(x) and isnum(y) and isnum(z)):\n            raise TypeError(""x,y and z must all be numbers"")\n        if len(args) > 1:\n            pos = settings.geometry.physical_angles_to_internal_position(  # @UndefinedVariable\n                args.pop(0))\n        else:\n            pos = settings.geometry.physical_angles_to_internal_position(  # @UndefinedVariable\n                settings.hardware.get_position())  # @UndefinedVariable\n        if len(args) == 1:\n            tag = args.pop(0)\n            if not isinstance(tag, basestring):\n                raise TypeError(""Tag value must be a string."")\n            if tag == \'\':\n                tag = None\n        else:\n            tag = None\n        ubcalc.add_orientation(h, k, l, x, y ,z, pos, tag,\n                                   datetime.now())\n    else:\n        raise TypeError(""Invalid number of parameters specified for addorient command."")\n\n@command\ndef editorient(idx):\n    """"""editorient num | \'tag\' -- interactively edit a crystal orientation.\n    """"""\n\n    # Get old reflection values\n    [oldh, oldk, oldl], [oldx, oldy, oldz], oldExternalAngles, oldTag, oldT = \\\n        ubcalc.get_orientation_in_external_angles(idx, True)\n    del oldT  # current time will be used.\n\n    h = promptForNumber(\'h\', oldh)\n    k = promptForNumber(\'k\', oldk)\n    l = promptForNumber(\'l\', oldl)\n    if None in (h, k, l):\n        _handleInputError(""h,k and l must all be numbers"")\n    x = promptForNumber(\'x\', oldx)\n    y = promptForNumber(\'y\', oldy)\n    z = promptForNumber(\'z\', oldz)\n    if None in (x, y, z):\n        _handleInputError(""x,y and z must all be numbers"")\n    reply = promptForInput(\'update position with current hardware setting\',\n                           \'n\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        positionList = settings.hardware.get_position()  # @UndefinedVariable\n    else:\n        positionList = []\n        names = settings.hardware.get_axes_names()  # @UndefinedVariable\n        for i, angleName in enumerate(names):\n            val = promptForNumber(angleName.rjust(7), oldExternalAngles[i])\n            if val is None:\n                _handleInputError(""Please enter a number, or press ""\n                                      ""Return to accept default!"")\n                return\n            positionList.append(val)\n    tag = promptForInput(""tag"", oldTag)\n    if tag == \'\':\n        tag = None\n    pos = settings.geometry.physical_angles_to_internal_position(positionList)  # @UndefinedVariable\n    ubcalc.edit_orientation(idx, h, k, l, x, y, z, pos, tag,\n                                datetime.now())\n\n@command\ndef delorient(idx):\n    """"""delorient num | \'tag\' -- deletes a crystal orientation\n    """"""\n    ubcalc.del_orientation(idx)\n    \n@command\ndef clearorient():\n    """"""clearorient -- deletes all the crystal orientations\n    """"""\n    while ubcalc.get_number_orientations():\n        ubcalc.del_orientation(1)\n\n@command\ndef swaporient(idx1=None, idx2=None):\n    """"""\n    swaporient -- swaps first two crystal orientations used for calculating U matrix\n    swaporient {num1 | \'tag1\'} {num2 | \'tag2\'} -- swaps two crystal orientations\n    """"""\n    if idx1 is None and idx2 is None:\n        ubcalc.swap_orientations(1, 2)\n    elif idx1 is None or idx2 is None:\n        raise TypeError(""Please specify two orientation references to swap"")\n    else:\n        ubcalc.swap_orientations(idx1, idx2)\n\n\n### UB calculations ###\n\n@command\ndef setu(U=None):\n    """"""setu {[[..][..][..]]} -- manually set U matrix\n    """"""\n    if U is None:\n        U = _promptFor3x3MatrixDefaultingToIdentity()\n        if U is None:\n            return  # an error will have been printed or thrown\n    if _is3x3TupleOrList(U) or _is3x3Matrix(U):\n        ubcalc.set_U_manually(U)\n    else:\n        raise TypeError(""U must be given as 3x3 list or tuple"")\n\n@command\ndef setub(UB=None):\n    """"""setub {[[..][..][..]]} -- manually set UB matrix""""""\n    if UB is None:\n        UB = _promptFor3x3MatrixDefaultingToIdentity()\n        if UB is None:\n            return  # an error will have been printed or thrown\n    if _is3x3TupleOrList(UB):\n        ubcalc.set_UB_manually(UB)\n    else:\n        raise TypeError(""UB must be given as 3x3 list or tuple"")\n\ndef _promptFor3x3MatrixDefaultingToIdentity():\n    estring = ""Please enter a number, or press Return to accept default!""\n    row1 = promptForList(""row1"", (1, 0, 0))\n    if row1 is None:\n        _handleInputError(estring)\n        return None\n    row2 = promptForList(""row2"", (0, 1, 0))\n    if row2 is None:\n        _handleInputError(estring)\n        return None\n    row3 = promptForList(""row3"", (0, 0, 1))\n    if row3 is None:\n        _handleInputError(estring)\n        return None\n    return [row1, row2, row3]\n\n@command\ndef calcub(idx1=None, idx2=None):\n    """"""\n    calcub -- (re)calculate U matrix from the first two reflections and/or orientations.\n    calcub idx1 idx2 -- (re)calculate U matrix from reflections and/or orientations referred by indices and/or tags idx1 and idx2.\n    """"""\n    ubcalc.calculate_UB(idx1, idx2)\n\n@command\ndef trialub(idx=1):\n    """"""trialub -- (re)calculate U matrix from reflection with index or tag idx only (check carefully). Default: use first reflection.\n    """"""\n    ubcalc.calculate_UB(idx)\n\n@command\ndef orientub(idx1=None, idx2=None):\n    """"""\n    DEPRECATED. Please use \'calcub\' command.\n    orientub -- (re)calculate U matrix from the first two reflections and/or orientations.\n    orientub idx1 idx2 -- (re)calculate U matrix from reflections and/or orientations referred by indices and/or tags idx1 and idx2.\n    """"""\n    ubcalc.calculate_UB(idx1, idx2)\n\n    # This command requires the ubcalc\n\ndef checkub():\n    """"""checkub -- show calculated and entered hkl values for reflections.\n    """"""\n\n    s = ""\\n    %7s  %4s  %4s  %4s    %6s   %6s   %6s     TAG\\n"" % \\\n    (\'ENERGY\', \'H\', \'K\', \'L\', \'H_COMP\', \'K_COMP\', \'L_COMP\')\n    s = bold(s)\n    nref = ubcalc.get_number_reflections()\n    if not nref:\n        s += ""<<empty>>""\n    for n in range(nref):\n        hklguess, pos, energy, tag, _ = ubcalc.get_reflection(n + 1)\n        wavelength = 12.39842 / energy\n        hkl = settings.angles_to_hkl_function(pos.inRadians(), wavelength, ubcalc.UB)\n        h, k, l = hkl\n        if tag is None:\n            tag = """"\n        s += (""% 2d % 6.4f % 4.2f % 4.2f % 4.2f   % 6.4f  % 6.4f  ""\n              ""% 6.4f  %6s\\n"" % (n + 1, energy, hklguess[0],\n              hklguess[1], hklguess[2], h, k, l, tag))\n    print s\n\n@command\ndef refineub(*args):\n    """"""\n    refineub {[h k l]} {pos} -- refine unit cell dimensions and U matrix to match diffractometer angles for a given hkl value\n    """"""\n    if len(args) > 0:\n        args = list(args)\n        h, k, l = args.pop(0)\n        if not (isnum(h) and isnum(k) and isnum(l)):\n            raise TypeError()\n    else:\n        h = promptForNumber(\'h\', 0.)\n        k = promptForNumber(\'k\', 0.)\n        l = promptForNumber(\'l\', 0.)\n        if None in (h, k, l):\n            _handleInputError(""h,k and l must all be numbers"")\n    if len(args) == 1:\n        pos = settings.geometry.physical_angles_to_internal_position(  # @UndefinedVariable\n                args.pop(0))\n    elif len(args) == 0:\n        reply = promptForInput(\'current pos\', \'y\')\n        if reply in (\'y\', \'Y\', \'yes\'):\n            positionList = settings.hardware.get_position()  # @UndefinedVariable\n        else:\n            currentPos = settings.hardware.get_position()  # @UndefinedVariable\n            positionList = []\n            names = settings.hardware.get_axes_names()  # @UndefinedVariable\n            for i, angleName in enumerate(names):\n                val = promptForNumber(angleName.rjust(7), currentPos[i])\n                if val is None:\n                    _handleInputError(""Please enter a number, or press""\n                                          "" Return to accept default!"")\n                    return\n                positionList.append(val)\n        pos = settings.geometry.physical_angles_to_internal_position(positionList)  # @UndefinedVariable\n    else:\n        raise TypeError()\n    \n    pos.changeToRadians()\n    scale, lat = ubcalc.rescale_unit_cell(h, k, l, pos)\n    if scale:\n        lines = [""Unit cell scaling factor:"".ljust(9) +\n                         ""% 9.5f"" % scale]\n        lines.append(""Refined crystal lattice:"")\n        lines.append(""   a, b, c:"".ljust(9) +\n                         ""% 9.5f % 9.5f % 9.5f"" % (lat[1:4]))\n        lines.append("" "" * 12 +\n                         ""% 9.5f % 9.5f % 9.5f"" % (lat[4:]))\n        lines.append("""")\n        print \'\\n\'.join(lines)\n        reply = promptForInput(\'Update crystal settings?\', \'y\')\n        if reply in (\'y\', \'Y\', \'yes\'):\n            ubcalc.set_lattice(*lat)\n    else:\n        print ""No unit cell mismatch detected""\n    mc_angle, mc_axis = ubcalc.calc_miscut(h, k, l, pos)\n    if mc_angle:\n        lines = [""Miscut parameters:"",]\n        lines.append(""      angle:"".ljust(9) + ""% 9.5f"" % mc_angle)\n        lines.append(""       axis:"".ljust(9) + ""% 9.5f % 9.5f % 9.5f"" % tuple(mc_axis))\n        print \'\\n\'.join(lines)\n        reply = promptForInput(\'Apply miscut parameters?\', \'y\')\n        if reply in (\'y\', \'Y\', \'yes\'):\n            ubcalc.set_miscut(mc_axis, -mc_angle * TORAD, True)\n    else:\n        print ""No miscut detected for the given settings""\n        ubcalc.set_miscut(None, 0, True)\n\n@command\ndef fitub(*args):\n    """"""fitub ref1, ref2, ref3... -- fit UB matrix to match list of provided reference reflections.""""""\n    new_umatrix, new_lattice = ubcalc.fit_ub_matrix(*args)\n    _system = ubcalc._state.crystal._system\n\n    lines = [""Refined crystal lattice:"",]\n    lines.append(""   a, b, c:"".ljust(9) +\n                     ""% 9.5f % 9.5f % 9.5f  %s"" % (new_lattice[1:4] + (_system,)))\n    lines.append("" "" * 12 +\n                     ""% 9.5f % 9.5f % 9.5f"" % (new_lattice[4:]))\n    lines.append("""")\n    print \'\\n\'.join(lines)\n    reply = promptForInput(\'Update crystal settings?\', \'y\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        ubcalc.set_lattice(new_lattice[0], _system, *new_lattice[1:])\n\n    new_ubmatrix = new_umatrix * ubcalc._state.crystal.B\n    lines = ubcalc.str_lines_u(new_umatrix) + ubcalc.str_lines_ub_angle_and_axis(new_ubmatrix)\n    print \'\\n\' + \'\\n\'.join(lines)\n    reply = promptForInput(\'Update U matrix?\', \'y\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        ubcalc.set_U_manually(new_umatrix, False)\n\n@command\ndef addmiscut(*args):\n    """"""addmiscut angle {[x y z]} -- apply miscut to U matrix using a specified miscut angle in degrees and a rotation axis""""""\n    \n    if len(args) == 0:\n        _handleInputError(""Please specify a miscut angle in degrees ""\n                          ""and, optionally, a rotation axis (default: [0 1 0])"")\n    else:\n        args=list(args)\n        angle = args.pop(0)\n        rad_angle = float(angle) * TORAD\n        if len(args) == 0:\n            xyz = None\n        else:\n            xyz = args.pop(0)\n        ubcalc.set_miscut(xyz, rad_angle, True)\n\n@command\ndef setmiscut(*args):\n    """"""setmiscut angle {[x y z]} -- manually set U matrix using a specified miscut angle in degrees and a rotation axis (default: [0 1 0])""""""\n    \n    if len(args) == 0:\n        _handleInputError(""Please specify a miscut angle in degrees ""\n                          ""and, optionally, a rotation axis (default: [0 1 0])"")\n    else:\n        args=list(args)\n        angle = args.pop(0)\n        rad_angle = float(angle) * TORAD\n        if len(args) == 0:\n            xyz = None\n        else:\n            xyz = args.pop(0)\n        ubcalc.set_miscut(xyz, rad_angle, False)\n\ncommands_for_help = [\'State\',\n                     newub,\n                     loadub,\n                     lastub,\n                     listub,\n                     rmub,\n                     saveubas,\n                     ub,\n                     \'Lattice\',\n                     setlat,\n                     c2th,\n                     hklangle]\n\nif ubcalc.include_reference:\n    commands_for_help.extend([\n                     \'Reference\',\n                     setnphi,\n                     setnhkl])\ncommands_for_help.extend([\n                     \'Surface normal\',\n                     surfnphi,\n                     surfnhkl])\n\nif ubcalc.include_sigtau:\n    commands_for_help.extend([\n                     \'Surface\',\n                     sigtau])\n\ncommands_for_help.extend([\n                     \'Reflections\',\n                     showref,\n                     addref,\n                     editref,\n                     delref,\n                     clearref,\n                     swapref,\n                     \'Orientations\',\n                     showorient,\n                     addorient,\n                     editorient,\n                     delorient,\n                     clearorient,\n                     swaporient,\n                     \'UB matrix\',\n                     fitub,\n                     checkub,\n                     setu,\n                     setub,\n                     calcub,\n                     orientub,\n                     trialub,\n                     refineub,\n                     addmiscut,\n                     setmiscut])\n\n\n\ndef _is3x3TupleOrList(m):\n    if type(m) not in (list, tuple):\n        return False\n    if len(m) != 3:\n        return False\n    for mrow in m:\n        if type(mrow) not in (list, tuple):\n            return False\n        if len(mrow) != 3:\n            return False\n    return True\n\n\ndef _is3x3Matrix(m):\n    return isinstance(m, matrix) and tuple(m.shape) == (3, 3)\n        \n\ndef _handleInputError(msg):\n    raise TypeError(msg)'"
doc/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n\n#\n# documentation build configuration file, created by\n# sphinx-quickstart on Fri Apr 15 10:03:07 2011.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os, time\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\', \'sphinx.ext.extlinks\', \'sphinx.ext.intersphinx\', \'sphinx.ext.todo\', \'sphinx.ext.imgmath\', \'sphinx.ext.ifconfig\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Diffcalc\'\ncopyright = u\'2017-%s, Diamond Light Source\' % time.strftime(\'%Y\')\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'2.1\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'2.1\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#html_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# html_theme_options = {\n# \'sidebarbgcolor\'  : \'#f2f2f2\',\n# \'sidebartextcolor\': \'#444a95\',\n# \'sidebarlinkcolor\': \'#0b0f40\',\n# }\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n\nimport sphinx_rtd_theme\n\nhtml_theme = ""sphinx_rtd_theme""\n\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = \'diffcalc_web.png\'\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\n#html_static_path = [\'_static\']\nhtml_static_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\nhtml_show_sourcelink = False\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\nhtml_show_sphinx = False\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size (\'letter\' or \'a4\').\n#latex_paper_size = \'letter\'\nlatex_paper_size = \'a4\'\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#latex_font_size = \'10pt\'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\'youmanual\', \'diffcalc_user_guide.tex\', u\'Diffcalc User Guide\',\n    u\'Diamond Light Source\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page\nlatex_logo = \'diffcalc_pdf.png\'\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = \'\'\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\n#man_pages = []\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {}\n\n""""""\n Additional options for Diffcalc\n""""""\n\ntodo_include_todos = True\n\nextlinks = {\n    \'opengda_url\' :(\'http://www.opengda.org/%s\', None),\n    }\n\nrst_prolog = """"""\n.. |DLS| replace:: :abbr:`DLS (Diamond Light Source)`\n""""""\n'"
startup/api/__init__.py,0,b''
startup/api/sixcircle.py,0,"b""\nfrom __future__ import absolute_import\n\n\nfrom diffcalc import settings\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.hardware import DummyHardwareAdapter\nimport diffcalc.util  # @UnusedImport\n\n\n# Disable error handling designed for interactive use\ndiffcalc.util.DEBUG = True\n\n\n# Configure and import diffcalc objects\nsettings.hardware = DummyHardwareAdapter(('mu', 'delta', 'gam', 'eta', 'chi', 'phi'))\nsettings.geometry = SixCircle()  # @UndefinedVariable\n\n\n# These must be imported AFTER the settings have been configured\nfrom diffcalc.dc import dcyou as dc\nfrom diffcalc.ub import ub\nfrom diffcalc import hardware\nfrom diffcalc.hkl.you import hkl\n\n# Set some limits\nhardware.setmin('gam', -179)\nhardware.setmax('gam', 179)\n\n# These demos reproduce the outline in the developer guide\ndef demo_all():\n    demo_orient()\n    demo_motion()\n\n\ndef demo_orient():\n\n    ub.listub()\n    \n    # Create a new ub calculation and set lattice parameters\n    ub.newub('test')\n    ub.setlat('cubic', 1, 1, 1, 90, 90, 90)\n    \n    # Add 1st reflection (demonstrating the hardware adapter)\n    settings.hardware.wavelength = 1\n    ub.c2th([1, 0, 0])                 # energy from hardware\n    settings.hardware.position = 0, 60, 0, 30, 0, 0\n    ub.addref([1, 0, 0])# energy and position from hardware\n    \n    # Add 2nd reflection (this time without the harware adapter)\n    ub.c2th([0, 1, 0], 12.39842)\n    ub.addref([0, 1, 0], [0, 60, 0, 30, 0, 90], 12.39842)\n    \n    # check the state\n    ub.ub()\n    ub.checkub()\n\n\ndef demo_motion():\n    dc.angles_to_hkl((0., 60., 0., 30., 0., 0.))\n    hkl.con('qaz', 90)\n    hkl.con('a_eq_b')\n    hkl.con('mu', 0)\n    \n    hardware.setmin('delta', 0)\n    dc.hkl_to_angles(1, 0, 0)\n\n\ndemo_all()\n    \n    \n    \n    """
startup/beamlinespecific/__init__.py,0,b''
startup/beamlinespecific/azihkl.py,0,"b""###\n# Copyright 2008-2018 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport platform\nfrom diffcalc.util import DiffcalcException\n\nDEBUG = False\n\ntry:\n    from gda.device.scannable import ScannableBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import ScannableBase\n\nfrom diffcalc.ub.ub import ubcalc, _to_column_vector_triple\n\n\nclass _DynamicDocstringMetaclass(type):\n\n    def _get_doc(self):\n        return AzihklClass.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\nclass AzihklClass(ScannableBase):\n    'Azimuthal reference reciprocal lattice vector'\n\n    if platform.system() != 'Java':\n        __metaclass__ = _DynamicDocstringMetaclass  # TODO: Removed to fix Jython\n\n    dynamic_docstring = 'Azimuthal reference reciprocal lattice vector'\n\n    def _get_doc(self):\n        return AzihklClass.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n    def __init__(self,name):\n        self.setName(name)\n        self.setLevel(3)\n        self.setInputNames(['azih','azik','azil'])\n        self.setOutputFormat(['%4.4f', '%4.4f','%4.4f'])\n\n    def asynchronousMoveTo(self,new_position):\n        ref_matrix = _to_column_vector_triple(new_position)\n        ubcalc.set_n_hkl_configured(ref_matrix)\n\n    def isBusy(self):\n        return 0\n\n    def getPosition(self):\n        try:\n            ref_matrix = ubcalc.n_hkl\n            return ref_matrix.T.tolist()[0]\n        except DiffcalcException, e:\n            print e\n"""
startup/beamlinespecific/conic_scannables.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nimport types\nfrom math import sin, cos, acos, atan2, sqrt, pi\n\nfrom diffcalc.gdasupport.scannable.parametrised_hkl import ParametrisedHKLScannable\nfrom diffcalc.util import DiffcalcException, TORAD, TODEG, SMALL\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\ncirc_hkl = ParametrisedHKLScannable(\'circ\', (\'q\', \'pol\', \'az\'))\ncirc_hkl.parameter_to_hkl = lambda (q, pol, az): (q * sin(pol) * cos(az), q * sin(pol) * sin(az), q * cos(pol))\ncirc_hkl.hkl_to_parameter = lambda (h, k, l): (sqrt(h*h+k*k+l*l), acos(l/sqrt(h*h+k*k+l*l)), atan2(k, h))\n\ndef __polar_to_hkl(params):\n    from diffcalc.dc import dcyou as _dc\n    from diffcalc.util import norm3, cross3\n    import __main__\n\n    sc, az = params\n    h, k, l = __main__.hkl.getPosition()[:3]\n    hkl_nphi = _dc._ub.ubcalc._UB * matrix([[h], [k], [l]])\n    try:\n        h_ref, k_ref, l_ref = _dc._ub.ubcalc.get_reflection(1)[0]\n        ref_nphi = _dc._ub.ubcalc._UB * matrix([[h_ref], [k_ref], [l_ref]])\n        ref_nphi *= norm3(hkl_nphi) / norm3(ref_nphi)\n    except IndexError:\n        raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n    nphi = _dc._ub.ubcalc.n_phi\n    inplane_vec = cross3(ref_nphi, nphi)\n    inplane_vec *= sqrt(1 - sc ** 2) * norm3(hkl_nphi) / norm3(inplane_vec)\n    ref_nhkl = _dc._ub.ubcalc._UB.I * ref_nphi\n    h_ref, k_ref, l_ref = ref_nhkl.T.tolist()[0]  \n    h_res, k_res, l_res = _dc._ub.ubcalc.calc_hkl_offset(h_ref, k_ref, l_ref, acos(sc), az)\n    return h_res, k_res, l_res\n\ndef __hkl_to_polar(hkl):\n    from diffcalc.dc import dcyou as _dc\n\n    try:\n        hkl_ref = _dc._ub.ubcalc.get_reflection(1)[0]\n    except IndexError:\n        raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n    pol, az, _ = _dc._ub.ubcalc.calc_offset_for_hkl(hkl, hkl_ref)\n    return cos(pol), az\n\nconic_hkl = ParametrisedHKLScannable(\'conic\', (\'rlu\', \'az\'))\nconic_hkl.parameter_to_hkl = __polar_to_hkl\nconic_hkl.hkl_to_parameter = __hkl_to_polar\n\ndef __conic_h_to_hkl(self, params):\n    from diffcalc.dc import dcyou as _dc\n    from diffcalc.util import norm3, solve_h_fixed_q\n    import __main__\n\n    try:\n        h_param, a, b, c, d = params\n    except TypeError:\n        raise DiffcalcException(""Invalid number of input parameters."")\n    h, k, l = __main__.hkl.getPosition()[:3]\n    hkl_nphi = _dc._ub.ubcalc._UB * matrix([[h], [k], [l]])\n    qval = norm3(hkl_nphi)**2\n    hkl = solve_h_fixed_q(h_param, qval, _dc._ub.ubcalc._UB, (a, b, c, d))\n    return hkl\n\ndef __hkl_to_conic_h(self, hkl):\n    h, _, _ = hkl\n    try:\n        a, b, c, d = self.cached_params\n    except TypeError:\n        raise DiffcalcException(""hkl constraint values not set."")\n    return (h, a, b, c, d)\n\nconic_h = ParametrisedHKLScannable(\'conic_h\', (\'h\', \'a\', \'b\', \'c\', \'d\'), 4)\nconic_h.parameter_to_hkl = types.MethodType(__conic_h_to_hkl, conic_h)\nconic_h.hkl_to_parameter = types.MethodType(__hkl_to_conic_h, conic_h)\n\ndef __conic_k_to_hkl(self, params):\n    from diffcalc.dc import dcyou as _dc\n    from diffcalc.util import norm3, solve_k_fixed_q\n    import __main__\n\n    try:\n        k_param, a, b, c, d = params\n    except TypeError:\n        raise DiffcalcException(""Invalid number of input parameters."")\n    h, k, l = __main__.hkl.getPosition()[:3]\n    hkl_nphi = _dc._ub.ubcalc._UB * matrix([[h], [k], [l]])\n    qval = norm3(hkl_nphi)**2\n    hkl = solve_k_fixed_q(k_param, qval, _dc._ub.ubcalc._UB, (a, b, c, d))\n    return hkl\n\ndef __hkl_to_conic_k(self, hkl):\n    _, k, _ = hkl\n    try:\n        a, b, c, d = self.cached_params\n    except TypeError:\n        raise DiffcalcException(""hkl constraint values not set."")\n    return (k, a, b, c, d)\n\nconic_k = ParametrisedHKLScannable(\'conic_k\', (\'k\', \'a\', \'b\', \'c\', \'d\'), 4)\nconic_k.parameter_to_hkl = types.MethodType(__conic_k_to_hkl, conic_k)\nconic_k.hkl_to_parameter = types.MethodType(__hkl_to_conic_k, conic_k)\n\ndef __conic_l_to_hkl(self, params):\n    from diffcalc.dc import dcyou as _dc\n    from diffcalc.util import norm3, solve_l_fixed_q\n    import __main__\n\n    try:\n        l_param, a, b, c, d = params\n    except TypeError:\n        raise DiffcalcException(""Invalid number of input parameters."")\n    h, k, l = __main__.hkl.getPosition()[:3]\n    hkl_nphi = _dc._ub.ubcalc._UB * matrix([[h], [k], [l]])\n    qval = norm3(hkl_nphi)**2\n    hkl = solve_l_fixed_q(l_param, qval, _dc._ub.ubcalc._UB, (a, b, c, d))\n    return hkl\n\ndef __hkl_to_conic_l(self, hkl):\n    _, _, l = hkl\n    try:\n        a, b, c, d = self.cached_params\n    except TypeError:\n        raise DiffcalcException(""hkl constraint values not set."")\n    return (l, a, b, c, d)\n\nconic_l = ParametrisedHKLScannable(\'conic_l\', (\'l\', \'a\', \'b\', \'c\', \'d\'), 4)\nconic_l.parameter_to_hkl = types.MethodType(__conic_l_to_hkl, conic_l)\nconic_l.hkl_to_parameter = types.MethodType(__hkl_to_conic_l, conic_l)\n\ndef __conic_th_to_hkl(self, params):\n    from diffcalc.dc import dcyou as _dc\n    from diffcalc.util import norm3, solve_h_fixed_q, solve_k_fixed_q\n    import __main__\n\n    try:\n        r, th, h0, k0 = params\n    except TypeError:\n        raise DiffcalcException(""Invalid number of input parameters."")\n    if not (th >= 0 and th < 180):\n        raise DiffcalcException(""Value of th should be n [0, 180) range"")\n    sin_th = sin(th * TORAD)\n    cos_th = cos(th * TORAD)\n    a  = sin_th\n    b = -cos_th\n    c = 0\n    d = h0 * sin_th - k0 * cos_th\n    h, k, l = __main__.hkl.getPosition()[:3]\n    hkl_nphi = _dc._ub.ubcalc._UB * matrix([[h], [k], [l]])\n    qval = norm3(hkl_nphi)**2\n    if th > 45.:\n        k = k0 + r * sin_th\n        hkl = solve_k_fixed_q(k, qval, _dc._ub.ubcalc._UB, (a, b, c, d))\n    else:\n        h = h0 + r * cos_th\n        hkl = solve_h_fixed_q(h, qval, _dc._ub.ubcalc._UB, (a, b, c, d))\n    return hkl\n\ndef __hkl_to_conic_th(self, hkl):\n    h, k, _ = hkl\n    try:\n        r0, th0, h0, k0 = self.cached_params\n    except TypeError:\n        raise DiffcalcException(""hkl constraint values not set."")\n    r = sqrt((h - h0)**2 + (k - k0)**2)\n    if abs(r) < SMALL:\n        return r, th0, h0, k0\n    th = atan2(k - k0, h - h0)\n    if r0 < 0:\n        r = -r\n        if th < 0:\n            th += pi\n        elif abs(th - pi) < SMALL:\n            th = 0\n    return (r, th * TODEG, h0, k0)\n\nconic_th = ParametrisedHKLScannable(\'conic_th\', (\'r\', \'th\', \'h0\', \'k0\'), 4)\nconic_th.parameter_to_hkl = types.MethodType(__conic_th_to_hkl, conic_th)\nconic_th.hkl_to_parameter = types.MethodType(__hkl_to_conic_th, conic_th)\n'"
startup/beamlinespecific/i21.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from gda.device.scannable.scannablegroup import ScannableGroup\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import ScannableGroup\n\nfrom diffcalc.gdasupport.scannable.diffractometer import DiffractometerScannableGroup\nfrom diffcalc.settings import NUNAME\nfrom diffcalc.hkl.you.geometry import YouRemappedGeometry\n\n\nclass FourCircleI21(YouRemappedGeometry):\n    """"""For a diffractometer with angles:\n          delta, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None, delta_offset=0):\n        self._delta_offset = delta_offset\n        YouRemappedGeometry.__init__(self, \'fourc\', {\'eta\': 0, \'delta\': 0}, beamline_axes_transform)\n\n        # Order should match scannable order in _fourc group for mapping to work correctly\n        self._scn_mapping_to_int = ((NUNAME, lambda x: x + self._delta_offset),\n                                    (\'mu\',   lambda x: x),\n                                    (\'chi\',  lambda x: x),\n                                    (\'phi\',  lambda x: -x))\n        self._scn_mapping_to_ext = ((NUNAME, lambda x: x - self._delta_offset),\n                                    (\'mu\',   lambda x: x),\n                                    (\'chi\',  lambda x: x),\n                                    (\'phi\',  lambda x: -x))\n\nclass TPScannableGroup(ScannableGroup):\n\n    def asynchronousMoveTo(self, position):\n        # if input has any Nones, then replace these with the current positions\n        if None in position:\n            position = list(position)\n            current = self.getPosition()\n            for idx, val in enumerate(position):\n                if val is None:\n                    position[idx] = current[idx]\n\n        for scn, pos in zip(self.getGroupMembers(), position):\n            scn.asynchronousMoveTo(pos)\n            scn.waitWhileBusy()\n\nclass DiffractometerTPScannableGroup(DiffractometerScannableGroup):\n\n    def asynchronousMoveTo(self, position):\n        # if input has any Nones, then replace these with the current positions\n        if None in position:\n            position = list(position)\n            current = self.getPosition()\n            for idx, val in enumerate(position):\n                if val is None:\n                    position[idx] = current[idx]\n\n        for scn, pos in zip(self.__motors, position):\n            scn.asynchronousMoveTo(pos)\n            scn.waitWhileBusy()\n\n        '"
test/diffcalc/__init__.py,0,b''
test/diffcalc/scenarios.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom datetime import datetime\nfrom math import asin, sin, cos, atan2\n\nfrom diffcalc.ub.reflections import _Reflection\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition\nfrom diffcalc.hkl.you.geometry import YouPosition\nfrom diffcalc.hkl.you.calc import sign\nfrom diffcalc.util import TORAD, TODEG\n\n\nclass YouPositionScenario(YouPosition):\n    """"""Convert six-circle Vlieg diffractometer angles into 4S+2D You geometry""""""\n    def __init__(self, alpha=None, delta=None, gamma=None, omega=None,\n                 chi=None, phi=None):\n        self.mu = alpha\n        self.eta = omega\n        self.chi = chi\n        self.phi = phi\n        self.unit = \'DEG\'\n        asin_delta = asin(sin(delta*TORAD) * cos(gamma*TORAD))*TODEG  # Eq.(83)\n        vals_delta = [asin_delta, 180. - asin_delta]\n        idx, _ = min([(i, abs(delta - d)) for i, d in enumerate(vals_delta)], key=lambda x: x[1])\n        self.delta = vals_delta[idx]\n        sgn = sign(cos(self.delta * TORAD))\n        self.nu = atan2(sgn*(cos(delta*TORAD)*cos(gamma*TORAD)*sin(alpha*TORAD) + cos(alpha*TORAD)*sin(gamma*TORAD)),\n                        sgn*(cos(delta*TORAD)*cos(gamma*TORAD)*cos(alpha*TORAD) - sin(alpha*TORAD)*sin(gamma*TORAD)))*TODEG   # Eq.(84)\n\n\nclass SessionScenario:\n    """"""\n    A test scenario. The test case must have __name, lattice and bmatrix set\n    and if umatrix is set then so must ref 1 and ref 2. Matrices should be 3*3\n    python arrays of lists and ref1 and ref2 in the format (h, k, l, position,\n    energy, tag).""""""\n\n    def __init__(self):\n        self.name = None\n        self.lattice = None\n        self.bmatrix = None\n        self.ref1 = None\n        self.ref2 = None\n        self.umatrix = None\n        self.calculations = []  # CalculationScenarios\n\n    def __str__(self):\n        toReturn = ""\\nTestScenario:""\n        toReturn += ""\\n     name: "" + self.name\n        toReturn += ""\\n  lattice:"" + str(self.lattice)\n        toReturn += ""\\n  bmatrix:"" + str(self.bmatrix)\n        toReturn += ""\\n     ref1:"" + str(self.ref1)\n        toReturn += ""\\n     ref2:"" + str(self.ref2)\n        toReturn += ""\\n  umatrix:"" + str(self.umatrix)\n        return toReturn\n\n\nclass CalculationScenario:\n    """"""\n    Used as part of a test scenario. A UB matrix appropriate for this\n    calcaultion will have been calculated or loaded\n    """"""\n    def __init__(self, tag, package, mode, energy, modeToTest, modeNumber):\n        self.tag = tag\n        self.package = package\n        self.mode = mode\n        self.energy = energy\n        self.wavelength = 12.39842 / energy\n        self.modeToTest = modeToTest\n        self.modeNumber = modeNumber\n        self.hklList = None  # hkl triples\n        self.posList = []\n        self.paramList = []\n\n\ndef sessions(P=VliegPosition):\n    ############################ SESSION0 ############################\n    # From the dif_init.mat next to dif_dos.exe on Vlieg\'session2 cd\n    #session2 = SessionScenario()\n    #session2.name = \'latt1\'\n    #session2.lattice = ([4.0004, 4.0004, 2.270000, 90, 90, 90])\n    #session2.bmatrix = (((1.570639, 0, 0) ,(0.0, 1.570639, 0) ,\n    #                      (0.0, 0.0, 2.767923)))\n    #self.scenarios.append(session2)\n    \n    \n    ############################ SESSION1 ############################\n    # From b16 on 27June2008 (From Chris Nicklin)\n    \n    session1 = SessionScenario()\n    session1.name = ""b16_270608""\n    session1.time = datetime.now()\n    session1.lattice = ((3.8401, 3.8401, 5.43072, 90, 90, 90))\n    session1.bmatrix = (((1.636204, 0, 0), (0, 1.636204, 0), (0, 0, 1.156971)))\n    session1.ref1 = _Reflection(1, 0, 1.0628,\n                               P(5.000, 22.790, 0.000, 1.552, 22.400, 14.255),\n                               10, \'ref1\', session1.time)\n    session1.ref2 = _Reflection(0, 1, 1.0628,\n                               P(5.000, 22.790, 0.000, 4.575, 24.275, 101.320),\n                               10, \'ref2\', session1.time)\n    session1.umatrix = ((0.997161, -0.062217, 0.042420),\n                   (0.062542, 0.998022, -0.006371),\n                   (-0.041940, 0.009006, 0.999080))\n    session1.ref1calchkl = (1, 0, 1.0628)  # Must match the guessed value!\n    session1.ref2calchkl = (-0.0329, 1.0114, 1.04)\n    \n    \n    ############################ SESSION2 ############################\n    # cubic crystal from bliss tutorial\n    session2 = SessionScenario()\n    session2.name = ""cubic_from_bliss_tutorial""\n    session2.time = datetime.now()\n    session2.lattice = ((1.54, 1.54, 1.54, 90, 90, 90))\n    session2.ref1 = _Reflection(1, 0, 0, P(0, 60, 0, 30, 0, 0),\n                               12.39842 / 1.54, \'ref1\', session2.time)\n    session2.ref2 = _Reflection(0, 1, 0, P(0, 60, 0, 30, 0, -90),\n                               12.39842 / 1.54, \'ref2\', session2.time)\n    session2.bmatrix = (((4.07999, 0, 0), (0, 4.07999, 0), (0, 0, 4.07999)))\n    session2.umatrix = (((1, 0, 0), (0, -1, 0), (0, 0, -1)))\n    session2.ref1calchkl = (1, 0, 0)  # Must match the guessed value!\n    session2.ref2calchkl = (0, 1, 0)\n    # sixc-0a : fixed omega = 0\n    c = CalculationScenario(\'sixc-0a\', \'sixc\', \'0\', 12.39842 / 1.54, \'4cBeq\', 1)\n    c.alpha = 0\n    c.gamma = 0\n    c.w = 0\n    #c.hklList=((0.7, 0.9, 1.3), (1,0,0), (0,1,0), (1, 1, 0))\n    c.hklList = ((0.7, 0.9, 1.3),)\n    c.posList.append(\n        P(0.000000, 119.669750, 0.000000, 59.834875, -48.747500, 307.874983651098))\n    #c.posList.append(P(0.000000, 60.000000, 0.000000, 30.000, 0.000000, 0.000000))\n    #c.posList.append(P(0.000000, 60.000000, 0.000000, 30.000, 0.000000, -90.0000))\n    #c.posList.append(P(0.000000, 90.000000, 0.000000, 45.000, 0.000000, -45.0000))\n    session2.calculations.append(c)\n    \n    \n    ############################ SESSION3 ############################\n    # AngleCalc scenarios from SPEC sixc. using crystal and alignment\n    session3 = SessionScenario()\n    session3.name = ""spec_sixc_b16_270608""\n    session3.time = datetime.now()\n    session3.lattice = ((3.8401, 3.8401, 5.43072, 90, 90, 90))\n    session3.bmatrix = (((1.636204, 0, 0), (0, 1.636204, 0), (0, 0, 1.156971)))\n    session3.umatrix = ((0.997161, -0.062217, 0.042420),\n                   (0.062542, 0.998022, -0.006371),\n                   (-0.041940, 0.009006, 0.999080))\n    session3.ref1 = _Reflection(1, 0, 1.0628,\n                               P(5.000, 22.790, 0.000, 1.552, 22.400, 14.255),\n                               12.39842 / 1.24, \'ref1\', session3.time)\n    session3.ref2 = _Reflection(0, 1, 1.0628,\n                               P(5.000, 22.790, 0.000, 4.575, 24.275, 101.320),\n                               12.39842 / 1.24, \'ref2\', session3.time)\n    session3.ref1calchkl = (1, 0, 1.0628)\n    session3.ref2calchkl = (-0.0329, 1.0114, 1.04)\n    # sixc-0a : fixed omega = 0\n    ac = CalculationScenario(\'sixc-0a\', \'sixc\', \'0\', 12.39842 / 1.24, \'4cBeq\', 1)\n    ac.alpha = 0\n    ac.gamma = 0\n    ac.w = 0\n    ### with \'omega_low\':-90, \'omega_high\':270, \'phi_low\':-180, \'phi_high\':180\n    ac.hklList = []\n    ac.hklList.append((0.7, 0.9, 1.3))\n    ac.posList.append(P(0.0, 27.352179, 0.000000, 13.676090, 37.774500, 53.965500))\n    ac.paramList.append({\'Bin\': 8.3284, \'Bout\': 8.3284, \'rho\': 36.5258,\n                         \'eta\': 0.1117, \'twotheta\': 27.3557})\n    \n    ac.hklList.append((1, 0, 0))\n    ac.posList.append(P(0., 18.580230, 0.000000, 9.290115, -2.403500, 3.589000))\n    ac.paramList.append({\'Bin\': -0.3880, \'Bout\': -0.3880, \'rho\': -2.3721,\n                         \'eta\': -0.0089, \'twotheta\': 18.5826})\n    \n    ac.hklList.append((0, 1, 0))\n    ac.posList.append(P(0., 18.580230, 0.000000, 9.290115, 0.516000, 93.567000))\n    ac.paramList.append({\'Bin\':  0.0833, \'Bout\':  0.0833, \'rho\':  0.5092,\n                         \'eta\': -0.0414, \'twotheta\': 18.5826})\n    \n    ac.hklList.append((1, 1, 0))\n    ac.posList.append(P(0., 26.394192, 0.000000, 13.197096, -1.334500, 48.602000))\n    ac.paramList.append({\'Bin\': -0.3047, \'Bout\': -0.3047, \'rho\': -1.2992,\n                         \'eta\': -0.0351, \'twotheta\': 26.3976})\n    \n    session3.calculations.append(ac)\n    \n    ############################ SESSION4 ############################\n    # test crystal\n    \n    session4 = SessionScenario()\n    session4.name = ""test_orth""\n    session4.time = datetime.now()\n    session4.lattice = ((1.41421, 1.41421, 1.00000, 90, 90, 90))\n    session4.system = \'Orthorhombic\'\n    session4.bmatrix = (((4.44288, 0, 0), (0, 4.44288, 0), (0, 0, 6.28319)))\n    session4.ref1 = _Reflection(0, 1, 2,\n                               P(0.0000, 122.4938, 0.0000, 80.7181, 90.0000, -45.0000),\n                               15., \'ref1\', session4.time)\n    session4.ref2 = _Reflection(1, 0, 2,\n                               P(0.0000, 122.4938, 0.000, 61.2469, 70.5288, -45.0000),\n                               15, \'ref2\', session4.time)\n    session4.ref3 = _Reflection(1, 0, 1,\n                               P(0.0000, 60.8172, 0.000, 30.4086, 54.7356, -45.0000),\n                               15, \'ref3\', session4.time)\n    session4.ref4 = _Reflection(1, 1, 2,\n                               P(0.0000, 135.0736, 0.000, 67.5368, 63.4349, 0.0000),\n                               15, \'ref4\', session4.time)\n    session4.reflist = (session4.ref1,\n                        session4.ref2,\n                        session4.ref3,\n                        session4.ref4)\n    session4.umatrix = ((0.70711, 0.70711, 0.00),\n                   (-0.70711, 0.70711, 0.00),\n                   (0.00, 0.00, 1.00))\n    session4.ref1calchkl = (0, 1, 2)  # Must match the guessed value!\n    session4.ref2calchkl = (1, 0, 2)\n    \n    \n    ############################ SESSION5 ############################\n    # test crystal\n    \n    session5 = SessionScenario()\n    session5.name = ""Dalyite""\n    session5.time = datetime.now()\n    session5.lattice = ((7.51, 7.73, 7.00, 106.0, 113.5, 99.5))\n    session5.system = \'Triclinic\'\n    session5.bmatrix = (((0.96021, 0.27759, 0.49527), (0, 0.84559, 0.25738), (0, 0, 0.89760)))\n    session5.ref1 = _Reflection(0, 1, 2,\n                               P(0.0000, 23.7405, 0.0000, 11.8703, 46.3100, 43.1304),\n                               12.3984, \'ref1\', session5.time)\n    session5.ref2 = _Reflection(1, 0, 3,\n                               P(0.0000, 34.4282, 0.000, 17.2141, 46.4799, 12.7852),\n                               12.3984, \'ref2\', session5.time)\n    session5.ref3 = _Reflection(2, 2, 6,\n                               P(0.0000, 82.8618, 0.000, 41.4309, 41.5154, 26.9317),\n                               12.3984, \'ref3\', session5.time)\n    session5.ref4 = _Reflection(4, 1, 4,\n                               P(0.0000, 71.2763, 0.000, 35.6382, 29.5042, 14.5490),\n                               12.3984, \'ref4\', session5.time)\n    session5.ref5 = _Reflection(8, 3, 1,\n                               P(0.0000, 97.8850, 0.000, 48.9425, 5.6693, 16.7929),\n                               12.3984, \'ref5\', session5.time)\n    session5.ref6 = _Reflection(6, 4, 5,\n                               P(0.0000, 129.6412, 0.000, 64.8206, 24.1442, 24.6058),\n                               12.3984, \'ref6\', session5.time)\n    session5.ref7 = _Reflection(3, 5, 7,\n                               P(0.0000, 135.9159, 0.000, 67.9579, 34.3696, 35.1816),\n                               12.3984, \'ref7\', session5.time)\n    session5.reflist = (session5.ref1,\n                        session5.ref2,\n                        session5.ref3,\n                        session5.ref4,\n                        session5.ref5,\n                        session5.ref6,\n                        session5.ref7\n                        )\n    session5.umatrix = (( 0.99982,  0.00073,  0.01903),\n                        ( 0.00073,  0.99710, -0.07612),\n                        (-0.01903,  0.07612,  0.99692))\n    session5.ref1calchkl = (0, 1, 2)  # Must match the guessed value!\n    session5.ref2calchkl = (1, 0, 3)\n    \n    \n    ############################ SESSION6 ############################\n    # test crystal\n    \n    session6 = SessionScenario()\n    session6.name = ""Acanthite""\n    session6.time = datetime.now()\n    session6.lattice = ((4.229, 6.931, 7.862, 90, 99.61, 90))\n    session6.system = \'Monoclinic\'\n    session6.bmatrix = ((1.50688, 0.00000, 0.13532),\n                         (0.00000, 0.90653, 0.00000),\n                         (0.00000, 0.00000, 0.79918))\n    session6.ref1 = _Reflection(0, 1, 2,\n                               P(0.0000, 21.1188, 0.0000, 10.5594, 59.6447, 61.8432),\n                               10., \'ref1\', session6.time)\n    session6.ref2 = _Reflection(1, 0, 3,\n                               P(0.0000, 35.2291, 0.000, 62.4207, 87.1516, -90.0452),\n                               10., \'ref2\', session6.time)\n    session6.ref3 = _Reflection(1, 1, 6,\n                               P(0.0000, 64.4264, 0.000, 63.9009, 97.7940, -88.8808),\n                               10., \'ref3\', session6.time)\n    session6.ref4 = _Reflection(1, 2, 2,\n                               P(0.0000, 34.4369, 0.000, 72.4159, 60.1129, -29.0329),\n                               10., \'ref4\', session6.time)\n    session6.ref5 = _Reflection(2, 2, 1,\n                               P(0.0000, 43.0718, 0.000, 21.5359, 8.3873, 29.0230),\n                               10., \'ref5\', session6.time)\n    session6.reflist = (session6.ref1,\n                        session6.ref2,\n                        session6.ref3,\n                        session6.ref4,\n                        session6.ref5,\n                        )\n    session6.umatrix = (( 0.99411, 0.00079,  0.10835),\n                        ( 0.00460, 0.99876, -0.04949),\n                        (-0.10825, 0.04969,  0.99288))\n    session6.ref1calchkl = (0, 1, 2)  # Must match the guessed value!\n    session6.ref2calchkl = (1, 0, 3)\n    ########################################################################\n    return (session1, session2, session3, session4, session5, session6)\n'"
test/diffcalc/test_hardware.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\nfrom diffcalc import settings\nimport pytest\n\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\nfrom diffcalc.gdasupport.minigda.scannable import ScannableGroup\nfrom diffcalc.gdasupport.scannable.diffractometer import \\\n    DiffractometerScannableGroup\nfrom diffcalc.util import DiffcalcException\nfrom diffcalc.gdasupport.scannable.mock import MockMotor\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hardware import HardwareAdapter\nfrom diffcalc.hardware import ScannableHardwareAdapter\nfrom nose.tools import eq_, assert_raises  # @UnresolvedImport\nfrom test.diffcalc.gdasupport.scannable.mockdiffcalc import MockDiffcalc\n\n\nclass SimpleHardwareAdapter(HardwareAdapter):\n\n    def get_position(self):\n        return [1, 2, 3]\n\n    def get_energy(self):\n        return 1.\n\n\nclass TestHardwareAdapterBase(object):\n\n    def setup_method(self):\n        self.hardware = SimpleHardwareAdapter([\'a\', \'b\', \'c\'])\n\n    def test__init__Andget_axes_names(self):\n        assert self.hardware.get_axes_names() == (\'a\', \'b\', \'c\')\n\n    def test__repr__(self):\n        print self.hardware.__repr__()\n\n    def testSetGetPosition(self):\n        pass\n\n    def testSetGetEnergyWavelength(self):\n        pass\n\n    def testget_position_by_name(self):\n        assert self.hardware.get_position_by_name(\'c\') == 3\n        with pytest.raises(ValueError):\n            self.hardware.get_position_by_name(\'not an angle name\')\n\n    def setCutAndGetCuts(self):\n        self.hardware.setCut(\'a\', 2)\n        self.hardware.setCut(\'b\', 2)\n        self.hardware.setCut(\'c\', 2)\n        assert self.hardware.get_cuts() == {\'a\': 1, \'b\': 2, \'c\': 3}\n        self.assertRaises(KeyError, self.hardware.setCut, \'not_a_key\', 1)\n\n    def test__configureCuts(self):\n        hardware = SimpleHardwareAdapter([\'a\', \'b\', \'c\'])\n        assert hardware.get_cuts() == {\'a\': -180, \'b\': -180, \'c\': -180}\n        hardware = SimpleHardwareAdapter([\'a\', \'phi\', \'c\'])\n        assert hardware.get_cuts() == {\'a\': -180, \'phi\': 0, \'c\': -180}\n\n    def test__configureCutsWithDefaults(self):\n        hardware = SimpleHardwareAdapter([\'a\', \'b\', \'c\'], {\'a\': 1, \'b\': 2})\n        assert hardware.get_cuts() == {\'a\': 1, \'b\': 2, \'c\': -180}\n        hardware = SimpleHardwareAdapter([\'a\', \'phi\', \'c\'],\n                                               {\'a\': 1, \'phi\': 2})\n        assert hardware.get_cuts() == {\'a\': 1, \'phi\': 2, \'c\': -180}\n        with pytest.raises(KeyError):\n            SimpleHardwareAdapter([\'a\', \'b\', \'c\'], {\'a\': 1, \'not_a_key\': 2})\n\n    def testCut(self):\n        assert self.hardware.cut_angles((1, 2, 3)) == (1, 2, 3)\n        assert self.hardware.cut_angles((-181, 0, 181)) == (179, 0, -179)\n        assert self.hardware.cut_angles((-180, 0, 180,)) == (-180, 0, 180)\n        assert self.hardware.cut_angles((-360, 0, 360)) == (0, 0, 0)\n\n\nclass TestHardwareCommands():\n\n    def setup_method(self):\n        self.hardware = DummyHardwareAdapter([\'a\', \'b\', \'c\'])\n        settings.hardware = self.hardware\n        from diffcalc import hardware\n        reload(hardware)\n        self.commands = hardware\n\n    def testSetcut(self):\n        print ""*******""\n        self.commands.setcut()\n        print ""*******""\n        self.commands.setcut(\'a\')\n        print ""*******""\n        self.commands.setcut(\'a\', -181)\n        print ""*******""\n        eq_(self.hardware.get_cuts()[\'a\'], -181)\n        assert_raises(\n            ValueError, self.commands.setcut, \'a\', \'not a number\')\n        assert_raises(\n            KeyError, self.commands.setcut, \'not an axis\', 1)\n\n    def test_set_lim(self):\n        self.commands.setmin(\'a\', -1)\n        print ""*******""\n        self.commands.setmin()\n        print ""*******""\n        self.commands.setmax()\n        print ""*******""\n\n\nclass TestDummyHardwareAdapter(object):\n\n    def setup_method(self):\n        self.hardware = DummyHardwareAdapter(\n            [\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'])\n\n    def test__init__(self):\n        assert self.hardware.get_position() == [0.] * 6\n        assert self.hardware.get_energy() == 12.39842\n        assert self.hardware.get_wavelength() == 1.\n        assert (self.hardware.get_axes_names()\n                == (\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'))\n\n    def test__repr__(self):\n        print self.hardware.__repr__()\n\n    def testSetGetPosition(self):\n        pass\n\n    def testSetGetEnergyWavelength(self):\n        pass\n\n    def testget_position_by_name(self):\n        self.hardware.position = [1., 2., 3., 4., 5., 6.]\n        assert self.hardware.get_position_by_name(\'gamma\') == 3\n        with pytest.raises(ValueError):\n            self.hardware.get_position_by_name(\'not an angle name\')\n\n    def testLowerLimitSetAndGet(self):\n        self.hardware.set_lower_limit(\'alpha\', -1)\n        self.hardware.set_lower_limit(\'delta\', -2)\n        self.hardware.set_lower_limit(\'gamma\', -3)\n        with pytest.raises(ValueError):\n            self.hardware.set_lower_limit(\'not an angle\', 1)\n        self.hardware.set_lower_limit(\'delta\', None)\n        print ""Should print WARNING:""\n        self.hardware.set_lower_limit(\'delta\', None)\n        assert self.hardware.get_lower_limit(\'alpha\') == -1\n        assert self.hardware.get_lower_limit(\'gamma\') == -3\n\n    def testUpperLimitSetAndGet(self):\n        self.hardware.set_upper_limit(\'alpha\', 1)\n        self.hardware.set_upper_limit(\'delta\', 2)\n        self.hardware.set_upper_limit(\'gamma\', 3)\n        with pytest.raises(ValueError):\n            self.hardware.set_upper_limit(\'not an angle\', 1)\n        self.hardware.set_upper_limit(\'delta\', None)\n        print ""Should print WARNING:""\n        self.hardware.set_upper_limit(\'delta\', None)\n        assert self.hardware.get_upper_limit(\'alpha\') == 1\n        assert self.hardware.get_upper_limit(\'gamma\') == 3\n\n    def testis_position_within_limits(self):\n        self.hardware.set_upper_limit(\'alpha\', 1)\n        self.hardware.set_upper_limit(\'delta\', 2)\n        self.hardware.set_lower_limit(\'alpha\', -1)\n        assert self.hardware.is_position_within_limits([0, 0, 999])\n        assert self.hardware.is_position_within_limits([1, 2, 999])\n        assert self.hardware.is_position_within_limits([-1, -999, 999])\n        assert not self.hardware.is_position_within_limits([1.01, 0, 999])\n        assert not self.hardware.is_position_within_limits([0, 2.01, 999])\n        assert not self.hardware.is_position_within_limits([-1.01, 0, 999])\n\n    def testIsAxisWithinLimits(self):\n        self.hardware.set_upper_limit(\'alpha\', 1)\n        self.hardware.set_upper_limit(\'delta\', 2)\n        self.hardware.set_lower_limit(\'gamma\', -1)\n\n        assert self.hardware.is_axis_value_within_limits(\'alpha\', 0)\n        assert self.hardware.is_axis_value_within_limits(\'delta\', 0)\n        assert self.hardware.is_axis_value_within_limits(\'gamma\', 999)\n\n        assert self.hardware.is_axis_value_within_limits(\'alpha\', 1)\n        assert self.hardware.is_axis_value_within_limits(\'delta\', 2)\n        assert self.hardware.is_axis_value_within_limits(\'gamma\', 999)\n\n        assert self.hardware.is_axis_value_within_limits(\'alpha\', -1)\n        assert self.hardware.is_axis_value_within_limits(\'delta\', -999)\n\n        assert not self.hardware.is_axis_value_within_limits(\'alpha\', 1.01)\n        assert not self.hardware.is_axis_value_within_limits(\'delta\', 2.01)\n        assert not self.hardware.is_axis_value_within_limits(\'alpha\', 1.01)\n\n\ndef createDummyAxes(names):\n    result = []\n    for name in names:\n        result.append(DummyPD(name))\n    return result\n\n\nclass TestGdaHardwareMonitor(object):\n\n    def setup_method(self):\n        dummy = createDummyAxes([\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'])\n        self.grp = ScannableGroup(\'grp\', dummy)\n        self.diffhw = DiffractometerScannableGroup(\'sixc\', MockDiffcalc(6),\n                                                   self.grp)\n        self.energyhw = MockMotor()\n        self.hardware = ScannableHardwareAdapter(self.diffhw, self.energyhw)\n\n    def test__init__Andget_axes_names(self):\n        assert self.hardware.get_axes_names() == (\'a\', \'b\', \'c\', \'d\', \'e\', \'f\')\n\n    def testGetPosition(self):\n        self.diffhw.asynchronousMoveTo((1, 2, 3, 4, 5, 6))\n        assert self.hardware.get_position() == [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n\n    def testGetEnergy(self):\n        self.energyhw.asynchronousMoveTo(1.0)\n        assert self.hardware.get_energy() == 1.0\n\n    def testGetWavelength(self):\n        self.energyhw.asynchronousMoveTo(1.0)\n        assert self.hardware.get_wavelength() == 12.39842 / 1.0\n\n    def testLowerLimitSetAndGet(self):\n        self.hardware.set_lower_limit(\'a\', -1)\n        self.hardware.set_lower_limit(\'b\', -2)\n        self.hardware.set_lower_limit(\'c\', -3)\n        with pytest.raises(DiffcalcException):\n            self.hardware.set_lower_limit(\'not an angle\', 1)\n        self.hardware.set_lower_limit(\'d\', None)\n        print ""Should print WARNING:""\n        self.hardware.set_lower_limit(\'d\', None)\n        assert self.hardware.get_lower_limit(\'a\') == -1\n        assert self.hardware.get_lower_limit(\'c\') == -3\n\n    def testUpperLimitSetAndGet(self):\n        self.hardware.set_upper_limit(\'a\', 1)\n        self.hardware.set_upper_limit(\'b\', 2)\n        self.hardware.set_upper_limit(\'c\', 3)\n        with pytest.raises(DiffcalcException):\n            self.hardware.set_upper_limit(\'not an angle\', 1)\n        self.hardware.set_upper_limit(\'d\', None)\n        print ""Should print WARNING:""\n        self.hardware.set_upper_limit(\'d\', None)\n        assert self.hardware.get_upper_limit(\'a\') == 1\n        assert self.hardware.get_upper_limit(\'c\') == 3\n'"
test/diffcalc/test_utils.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\nfrom nose.tools import eq_  # @UnresolvedImport\n\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition\nfrom diffcalc.util import MockRawInput, \\\n    getInputWithDefault, differ, nearlyEqual, degreesEquivilant,\\\n    CoordinateConverter\nimport diffcalc.util  # @UnusedImport\nimport pytest\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\nclass TestUtils(object):\n\n    def testMockRawInput(self):\n        raw_input = MockRawInput(\'a\')  # @ReservedAssignment\n        assert raw_input(\'?\') == \'a\'\n\n        raw_input = MockRawInput([\'a\', \'1234\', \'1 2 3\'])  # @ReservedAssignment\n        assert raw_input(\'?\') == \'a\'\n        assert raw_input(\'?\') == \'1234\'\n        assert raw_input(\'?\') == \'1 2 3\'\n        with pytest.raises(IndexError):\n            raw_input(\'?\')\n\n        raw_input = MockRawInput(1)  # @ReservedAssignment\n        with pytest.raises(TypeError):\n            raw_input(\'?\')\n\n    def testGetInputWithDefaultWithStrings(self):\n        diffcalc.util.raw_input = MockRawInput(\'reply\')\n        print"">>>""\n        assert getInputWithDefault(\'enter a thing\', \'default\') == \'reply\'\n        print"">>>""\n        diffcalc.util.raw_input = MockRawInput(\'\')\n        assert getInputWithDefault(\'enter a thing\', \'default\') == \'default\'\n        print"">>>""\n        diffcalc.util.raw_input = MockRawInput(\'1.23 1 a\')\n        assert getInputWithDefault(\'enter a thing\', \'default\') == \'1.23 1 a\'\n\n    def testGetInputWithDefaultWithNumbers(self):\n        diffcalc.util.raw_input = MockRawInput(\'\')\n        assert getInputWithDefault(\'enter a thing\', 1) == 1.0\n\n        diffcalc.util.raw_input = MockRawInput(\'\')\n        assert getInputWithDefault(\'enter a thing\', 1.23) == 1.23\n\n        diffcalc.util.raw_input = MockRawInput(\'1\')\n        assert getInputWithDefault(\'enter a thing\', \'default\') == 1.0\n\n        diffcalc.util.raw_input = MockRawInput(\'1.23\')\n        assert getInputWithDefault(\'enter a thing\', \'default\') == 1.23\n\n    def testGetInputWithDefaultWithLists(self):\n        diffcalc.util.raw_input = MockRawInput(\'\')\n        assert (getInputWithDefault(\'enter a thing\', (1, 2.0, 3.1))\n                == (1.0, 2.0, 3.1))\n\n        diffcalc.util.raw_input = MockRawInput(\'1 2.0 3.1\')\n        assert getInputWithDefault(\'enter a thing\', \'default\') == [1.0, 2.0, 3.1]\n\n    def testDiffer(self):\n        assert not differ([1., 2., 3.], [1., 2., 3.], .0000000000000001)\n        assert not differ(1, 1.0, .000000000000000001)\n        assert (differ([2., 4., 6.], [1., 2., 3.], .1)\n                == \'(2.0, 4.0, 6.0)!=(1.0, 2.0, 3.0)\')\n\n        assert not differ(1., 1.2, .2)\n        assert differ(1., 1.2, .1999999999999) == \'1.0!=1.2\'\n        assert not differ(1., 1.2, 1.20000000000001)\n\n    def testNearlyEqual(self):\n        assert nearlyEqual([1, 2, 3], [1, 2, 3], .000000000000000001)\n        assert nearlyEqual(1, 1.0, .000000000000000001)\n        assert not nearlyEqual([2, 4, 6], [1, 2, 3], .1)\n\n        assert nearlyEqual(1, 1.2, .2)\n        assert not nearlyEqual(1, 1.2, .1999999999999)\n        assert nearlyEqual(1, 1.2, 1.20000000000001)\n\n    def testDegreesEqual(self):\n        tol = .001\n        assert degreesEquivilant(1, 1, tol)\n        assert degreesEquivilant(1, -359, tol)\n        assert degreesEquivilant(359, -1, tol)\n        assert not degreesEquivilant(1.1, 1, tol)\n        assert not degreesEquivilant(1.1, -359, tol)\n        assert not degreesEquivilant(359.1, -1, tol)\n\n\nclass TestPosition(object):\n\n    def testCompare(self):\n        # Test the compare method\n        pos1 = VliegPosition(1, 2, 3, 4, 5, 6)\n        pos2 = VliegPosition(1.1, 2.1, 3.1, 4.1, 5.1, 6.1)\n\n        assert pos1 == pos1\n        assert pos1 != pos2\n\n    def testNearlyEquals(self):\n        pos1 = VliegPosition(1, 2, 3, 4, 5, 6)\n        pos2 = VliegPosition(1.1, 2.1, 3.1, 4.1, 5.1, 6.1)\n        assert pos1.nearlyEquals(pos2, 0.11)\n        assert not pos1.nearlyEquals(pos2, 0.1)\n\n    def testClone(self):\n        pos = VliegPosition(1, 2, 3, 4., 5., 6.)\n        copy = pos.clone()\n        assert pos == copy\n        pos.alpha = 10\n        pos.omega = 4.1\n\n\nclass TestCoordinateConverter(object):\n\n    def setup_method(self):\n        self.conv = CoordinateConverter(transform=matrix(\'0 0 1; 1 0 0; 0 1 0\'))\n\n    def testVector(self):\n        vec100 = matrix(\'1;0;0\')\n        vec010 = matrix(\'0;1;0\')\n        vec001 = matrix(\'0;0;1\')\n\n        conv100 = self.conv.transform(vec100)\n        conv010 = self.conv.transform(vec010)\n        conv001 = self.conv.transform(vec001)\n\n        inv100 = self.conv.transform(conv100, True)\n        inv010 = self.conv.transform(conv010, True)\n        inv001 = self.conv.transform(conv001, True)\n\n        eq_(conv100.tolist(), vec010.tolist())\n        eq_(conv010.tolist(), vec001.tolist())\n        eq_(conv001.tolist(), vec100.tolist())\n        eq_(vec100.tolist(), inv100.tolist())\n        eq_(vec010.tolist(), inv010.tolist())\n        eq_(vec001.tolist(), inv001.tolist())\n\n    def testVector1m10(self):\n        vec110 = matrix(\' 1; -1;  0\')\n        vec011 = matrix(\' 0;  1; -1\')\n        vec101 = matrix(\'-1;  0;  1\')\n\n        conv110 = self.conv.transform(vec110)\n        conv011 = self.conv.transform(vec011)\n        conv101 = self.conv.transform(vec101)\n\n        inv110 = self.conv.transform(conv110, True)\n        inv011 = self.conv.transform(conv011, True)\n        inv101 = self.conv.transform(conv101, True)\n\n        eq_(conv110.tolist(), vec011.tolist())\n        eq_(conv011.tolist(), vec101.tolist())\n        eq_(conv101.tolist(), vec110.tolist())\n        eq_(vec110.tolist(), inv110.tolist())\n        eq_(vec011.tolist(), inv011.tolist())\n        eq_(vec101.tolist(), inv101.tolist())\n\n    def testMatrix(self):\n        m = matrix(\'0 -1 0; 1 0 0; 0 0 -1\')\n        tm = self.conv.transform(m)\n        im = self.conv.transform(tm, True)\n\n        eq_(m.tolist(), im.tolist())\n\n        vec110 = matrix(\' 1; -1;  0\')\n        vec011 = matrix(\' 0;  1; -1\')\n        vec101 = matrix(\'-1;  0;  1\')\n        conv110 = self.conv.transform(vec110)\n        conv011 = self.conv.transform(vec011)\n        conv101 = self.conv.transform(vec101)\n\n        m110 = m * vec110\n        m011 = m * vec011\n        m101 = m * vec101\n        cm110 = tm * conv110\n        cm011 = tm * conv011\n        cm101 = tm * conv101\n        inv110 = self.conv.transform(cm110, True)\n        inv011 = self.conv.transform(cm011, True)\n        inv101 = self.conv.transform(cm101, True)\n\n        eq_(cm110.tolist(), self.conv.transform(m110).tolist())\n        eq_(cm011.tolist(), self.conv.transform(m011).tolist())\n        eq_(cm101.tolist(), self.conv.transform(m101).tolist())\n        eq_(m110.tolist(), inv110.tolist())\n        eq_(m011.tolist(), inv011.tolist())\n        eq_(m101.tolist(), inv101.tolist())\n\n    def testVectorFail(self):\n        failvec = matrix(\'0;0;1;0\')\n        failmarix = matrix(\'0 0 1; 0 0 1; 1 0 0; 0 0 1\')\n        with pytest.raises(TypeError):\n            CoordinateConverter(transform=failmarix)\n        with pytest.raises(TypeError):\n            self.conv.transform(failvec)\n        with pytest.raises(TypeError):\n            self.conv.transform(failmarix)\n'"
test/diffcmd/__init__.py,0,b''
test/diffcmd/test_ipython.py,0,"b'from nose.tools import assert_sequence_equal  # @UnresolvedImport\nfrom nose.tools import eq_\nfrom nose import SkipTest\n\ntry:\n    import IPython.core.magic  # @UnusedImport\n    from diffcmd.ipython import parse\n    IPYTHON = True\nexcept ImportError:\n    IPYTHON = False\n\nclass CallableNamedObject(object):\n    \n    def __init__(self, name, val):\n        self._name = name\n        self._val = val\n        \n    def method(self):\n        return self._val\n        \n    def __repr__(self):\n        return self._name\n    \n    def __call__(self):\n        return self._val\n    \n\no1 = CallableNamedObject(\'o1\', 1)\no2 = CallableNamedObject(\'o2\', 2)\no3 = CallableNamedObject(\'o3\', 3)\nc = 4\nd = {\n     \'o1\' : o1,\n     \'o2\' : o2,\n     \'o3\' : o3,\n     \'c\' : 4\n     }\n       \n         \ndef check(s, *expected):\n    assert_sequence_equal(parse(s, d), expected)    \n\n\ndef assert_raises_syntax_error_with_message(msg, func, *args, **kwargs):\n    try:\n        func(*args, **kwargs)\n        raise AssertionError()\n    except SyntaxError as e:\n        eq_(e.message, msg)\n\n\n\ndef setup_module():\n    if not IPYTHON:\n        raise SkipTest(\'ipython not available\')\n    \n    \ndef test_parse_spaces():\n    check(\'\')\n    check(\' \')\n    check(\'  \')\n\ndef test_parse_commas():\n    assert_raises_syntax_error_with_message(\n        \'unexpected comma\', parse, \'1 2, 3\', d)\n    \ndef test_parse_numbers():\n    check(\'1\', 1)\n    check(\'10\', 10)\n    check(\'10 2 3\', 10, 2, 3)\n    \ndef test_parse_negative_numbers():\n    check(\'-1\', -1)\n    check(\'-10\', -10)\n    check(\'-10 2 -3\', -10, 2, -3)\n\ndef test_parse_negative_number_with_space_between_sign_and_digit():\n    msg = \'could not evaluate: ""-""\'\n    assert_raises_syntax_error_with_message(msg, parse, \'- 1\', d)\n    assert_raises_syntax_error_with_message(msg, parse, \'1 - 1\', d)\n\ndef test_parse_strings():\n    check(""\'s1\'"", \'s1\')\n    check(""\'s1\' \'s2\'"", \'s1\', \'s2\')\n    check(\'""s1""\', \'s1\')\n    check(\'""s1"" ""s2""\', \'s1\', \'s2\')\n\ndef test_parse_strings_containing_spaces():\n    check(""\'ab cd\'"", \'ab cd\')\n    check(""\' ab cd \'"", \' ab cd \')\n    \ndef test_parse_strings_containing_commas():\n    check(""\'ab,cd\'"", \'ab,cd\')\n    check(""\', ab, cd, \'"", \', ab, cd, \')\n\ndef test_parse_strings_containing_hashes():\n    check(""\'ab #cd\'"", \'ab #cd\')\n    check(""\' ab cd# \'"", \' ab cd# \')\n\ndef test_parse_strings_containing_strings():\n    check(\'\'\' 1 \'ab cd\' 2\'\'\', 1, \'ab cd\', 2)\n    check(\'\'\' 1 \'""ab"" cd\' 2\'\'\', 1, \'""ab"" cd\', 2)\n\ndef test_parse_strings_containing_square_brackets():\n    check(""\'ab[cd\'"", \'ab[cd\')\n    check(""\'[ ab cd ]\'"", \'[ ab cd ]\')\n    \ndef test_parse_objects_and_numbers():\n    check(\'o1\', o1)\n    check(\'c\', 4)\n    check(\'o1 o2\', o1, o2)\n    check(\'1 o1 o2 2 c\', 1, o1, o2, 2, 4)\n\ndef test_parse_numbers_with_math():\n    check(\'1+1\', 2)\n    check(\'-1 1-1 1 1+1\', -1, 0, 1, 2)\n\ndef test_parse_callables_and_methods():\n    check(\'o1()\', 1)\n    check(\'o1.method()\', 1)\n    \ndef test_parse_objects_numbers_and_strings():\n    check("" o1 \'s2\'"", o1, \'s2\')\n    check(""1 \'s1\' \'s2\' -2 o2"", 1, \'s1\', \'s2\', -2, o2)\n    \ndef test_parse_objects_and_numbers_and_extra_spaces():\n    check(\'  o1   \', o1)\n    check(\' o1  o2 \', o1, o2)\n    check(\'1 o1  o2   -2   \', 1, o1, o2, -2)\n\ndef test_parse_lists():\n    check(\'[]\', [])\n    check(\'[1]\', [1])\n    check(\'[-1 2 3]\', [-1, 2, 3])\n    check(\'[1 2 -3][4]\', [1, 2, -3], [4])\n    check(\'[1 2 3][4 -5]\', [1, 2, 3], [4, -5])\n    \ndef test_parse_nested_lists():\n    check(\'[[]]\', [[]])\n    check(\'[[1]]\', [[1]])\n    check(\'[[1 2 3]]\', [[1, 2, 3]])\n    check(\'[[1 2 3] [4 5 6]]\', [[1, 2, 3], [4, 5, 6]])\n    check(\'[[1 2 3][4 5 6]]\', [[1, 2, 3], [4, 5, 6]])\n    check(\'[[1 2 3][4 5 [6 7]]]\', [[1, 2, 3], [4, 5, [6, 7]]])\n\ndef test_parse_lists_and_others():\n    check(\'[[]]\', [[]])\n    check(\'[[o1]]\', [[o1]])\n    check(\'[[o1 o2() -3]]\', [[o1, 2, -3]])\n    \ndef test_parse_unexpected_list_closure():\n    msg = \'could not evaluate: ""1, 2], 3""\'\n    assert_raises_syntax_error_with_message(msg, parse, \'1 2] 3\', d)\n    assert_raises_syntax_error_with_message(msg, parse, \'1 2 ] 3\', d)\n    assert_raises_syntax_error_with_message(msg, parse, \'1 2 ]3\', d)\n    \ndef test_parse_with_trailing_comments():\n    check(\'1# comment\', 1)\n    check(\'1 # comment\', 1)\n    check(\'1# comment # comment2\', 1)\n    check(\'o1# comment\', o1)\n    check(\'o1()# comment\', 1)\n    check(\'-1# comment\', -1)\n    check(\'1-1# comment\', 0)\n\ndef test_parse_with_only_comments():\n    check(\'# comment\')\n    check(\' # comment\')\n    check(\'  # comment\')\n    \n    \n    \n'"
diffcalc/gdasupport/minigda/__init__.py,0,b''
diffcalc/gdasupport/minigda/command.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n#try:\n#    from gda.device import Scannable\n#except ImportError:\n#    from diffcalc.gdasupport.minigda.scannable import Scannable\nfrom diffcalc.gdasupport.minigda.scannable import Scannable\nfrom diffcalc.util import getMessageFromException, allnum, bold\nimport math\n\n\nROOT_NAMESPACE_DICT = {}\n\nclass Pos(object):\n\n    def __init__(self):\n        self.__name__ = \'pos\'\n\n    def __call__(self, *posargs):\n        if len(posargs) == 0:\n\n            keys = dict(ROOT_NAMESPACE_DICT).keys()\n            keys.sort()\n            for key in keys:\n                val = ROOT_NAMESPACE_DICT[key]\n                if isinstance(val, Scannable):\n                    print self.posReturningReport(val)\n        else:\n            print self.posReturningReport(*posargs)\n\n    def posReturningReport(self, *posargs):\n        # report position of this scannable\n        if len(posargs) == 1:\n            scannable = posargs[0]\n            self._assert_scannable(scannable)\n            return self._generatePositionReport(scannable)\n\n        # Move the scannable and report\n        elif len(posargs) == 2:\n            scannable = posargs[0]\n            self._assert_scannable(scannable)\n            # Move it\n            scannable.asynchronousMoveTo(posargs[1])\n            # TODO: minigda assumes all moves complete instantly, so no need\n            # yet to check the move is complete\n            return self._generatePositionReport(scannable)\n\n        else:\n            raise ValueError(\n                ""Invlaid arguements: \'pos [ scannable [ value ] ]\'"")\n\n    def _assert_scannable(self, obj):\n        if not isinstance(obj, Scannable):\n                raise TypeError(\n                    ""The first argument to the pos command must be scannable. ""\n                    ""Not: "" + str(type(obj)))\n\n    def _generatePositionReport(self, scannable):\n        fieldNames = (tuple(scannable.getInputNames()) +\n                      tuple(scannable.getExtraNames()))\n        # All scannables\n        result = ""%s:"" % scannable.getName()\n        result = result.ljust(10)\n        try:\n            pos = scannable.getPosition()\n        except Exception, e:\n            return result + ""Error: %s"" % getMessageFromException(e)\n        if pos is None:\n            return result + ""---""\n        # Single field scannable:\n        if len(fieldNames) == 1:\n            try:\n                result += ""%s"" % scannable.formatPositionFields(pos)[0]\n            except AttributeError:\n                result += str(scannable())\n        # Multi field scannable:\n        else:\n            try:\n                formatted = scannable.formatPositionFields(pos)\n                for name, formattedValue in zip(fieldNames, formatted):\n                    result += ""%s: %s "" % (name, formattedValue)\n            except AttributeError:\n                result += str(scannable())\n\n        return result\n\n\nclass ScanDataHandler:\n    def __init__(self):\n        self.scannables = None\n\n    def callAtScanStart(self, scannables):\n        pass\n\n    def callWithScanPoint(self, PositionDictIndexedByScannable):\n        pass\n\n    def callAtScanEnd(self):\n        pass\n\n\nclass ScanDataPrinter(ScanDataHandler):\n\n    def __init__(self):\n        self.first_point_printed = False\n        self.widths = []\n        self.scannables = []\n\n    def callAtScanStart(self, scannables):\n        self.first_point_printed = False\n        self.scannables = scannables\n\n    def print_first_point(self, position_dict):\n        # also sets self.widths\n        header_strings = []\n        for scn in self.scannables:\n            field_names = list(scn.getInputNames()) + list(scn.getExtraNames())\n            if len(field_names) == 1:\n                header_strings.append(scn.getName())\n            else:\n                for field_name in field_names:\n                    header_strings.append(field_name)\n\n        first_row_strings = []\n        for scn in self.scannables:\n            pos = position_dict[scn]\n            first_row_strings.extend(scn.formatPositionFields(pos))\n\n        self.widths = []\n        for header, pos_string in zip(header_strings, first_row_strings):\n            self.widths.append(max(len(header), len(pos_string)))\n\n        header_cells = []\n        for heading, width in zip(header_strings, self.widths):\n            header_cells.append(heading.rjust(width))\n\n        underline_cells = [\'-\' * w for w in self.widths]\n\n        first_row_cells = []\n        for pos, width in zip(first_row_strings, self.widths):\n            first_row_cells.append(pos.rjust(width))\n\n        #table_width = sum(self.widths) + len(self.widths * 2) - 2\n        lines = []\n        #lines.append(\'=\' * table_width)\n        lines.append(bold(\'  \'.join(header_cells)))\n        lines.append(\'  \'.join(underline_cells))\n        lines.append(\'  \'.join(first_row_cells))\n        print \'\\n\'.join(lines)\n\n    def callWithScanPoint(self, position_dict):\n        if not self.first_point_printed:\n            self.print_first_point(position_dict)\n            self.first_point_printed = True\n        else:\n            row_strings = []\n            for scn in self.scannables:\n                pos = position_dict[scn]\n                row_strings.extend(scn.formatPositionFields(pos))\n\n            row_cells = []\n            for pos, width in zip(row_strings, self.widths):\n                row_cells.append(pos.rjust(width))\n\n            print \'  \'.join(row_cells)\n\n    def callAtScanEnd(self):\n        #table_width = sum(self.widths) + len(self.widths * 2) - 2\n        #print \'=\' * table_width\n        pass\n\n\nclass Scan(object):\n    class Group:\n        def __init__(self, scannable):\n            self.scannable = scannable\n            self.args = []\n\n        def __cmp__(self, other):\n            return(self.scannable.getLevel() - other.scannable.getLevel())\n\n        def __repr__(self):\n            return ""Group(%s, %s)"" % (self.scannable.getName(), str(self.args))\n\n        def shouldTriggerLoop(self):\n            return len(self.args) == 3\n\n    def __init__(self, scanDataHandlers):\n        # scanDataHandlers should be list\n        if type(scanDataHandlers) not in (tuple, list):\n            scanDataHandlers = (scanDataHandlers,)\n        self.dataHandlers = scanDataHandlers\n\n    def __call__(self, *scanargs):\n        groups = self._parseScanArgsIntoScannableArgGroups(scanargs)\n        groups = self._reorderInnerGroupsAccordingToLevel(groups)\n        # Configure data handlers for a new scan\n        for handler in self.dataHandlers: handler.callAtScanStart(\n            [grp.scannable for grp in groups])\n        # Perform the scan\n        self._performScan(groups, currentRecursionLevel=0)\n        # Inform data handlers of scan completion\n        for handler in self.dataHandlers: handler.callAtScanEnd()\n\n    def _parseScanArgsIntoScannableArgGroups(self, scanargs):\n        """"""\n        -> [ Group(scnA, (a1, a2, a2)), Group((scnB), (b1)), ...\n        ... Group((scnC),()), Group((scnD),(d1))]\n        """"""\n        result = []\n        if not isinstance(scanargs[0], Scannable):\n            raise TypeError(""First scan argument must be a scannable"")\n\n        # Parse out scannables followed by non-scannable args\n        for arg in scanargs:\n            if isinstance(arg, Scannable):\n                result.append(Scan.Group(arg))\n            else:\n                result[-1].args.append(arg)\n        return result\n\n    def _reorderInnerGroupsAccordingToLevel(self, groups):\n        # Find the first group not to trigger a loop\n        for idx, group in enumerate(groups):\n            if not group.shouldTriggerLoop():\n                break\n        latter = groups[idx:]; latter.sort() # Horrible hack not needed in python 3!\n        return groups[:idx] + latter\n\n    def _performScan(self, groups, currentRecursionLevel):\n        # groups[currentRecursionLevel:] will start with either:\n        #  a) A loop triggering group\n        #  b) A number (possibly 0) of non-loop triggering groups\n        unprocessedGroups = groups[currentRecursionLevel:]\n\n        # 1) If first remaining group should trigger a loop, perform this loop,\n        #    recursively calling this method on the remaining groups\n        if len(unprocessedGroups) > 0:\n            first = unprocessedGroups[0]\n            # If groups starts with a request to loop:\n            if first.shouldTriggerLoop():\n                posList = self._frange(first.args[0], first.args[1], first.args[2])\n                for pos in posList:\n                    first.scannable.asynchronousMoveTo(pos)\n                    # TODO: Should wait. minigda assumes all moves complete immediately\n                    self._performScan(groups, currentRecursionLevel + 1)\n                return\n\n        # 2) Move all non-loop triggering groups (may be zero)\n        self._moveNonLoopTriggeringGroups(unprocessedGroups)\n\n        # 3) Sample position of all scannables\n        posDict = self._samplePositionsOfAllScannables(groups)\n\n        # 4) Inform the data handlers that this point has been recorded\n        for handler in self.dataHandlers: handler.callWithScanPoint(posDict)\n\n    def _moveNonLoopTriggeringGroups(self, groups):\n        # TODO: Should wait. minigda assumes all moves complete immediately. groups could be zero lengthed.\n        for grp in groups:\n            if len(grp.args) == 0:\n                pass\n            elif len(grp.args) == 1:\n                grp.scannable.asynchronousMoveTo(grp.args[0])\n            elif len(grp.args) == 2:\n                raise Exception(""Scannables followed by two args not supported by minigda\'s scan command "")\n            else:\n                raise Exception(""Scannable: %s args%s"" % (grp.scannable, str(grp.args)))\n\n    def _samplePositionsOfAllScannables(self, groups):\n        posDict = {}\n        for grp in groups:\n            posDict[grp.scannable] = grp.scannable.getPosition()\n        return posDict\n\n    def _frange(self, limit1, limit2, increment):\n        """"""Range function that accepts scalers or lists of floats (and integers).\n        """"""\n        try:\n            ranges = zip(limit1, limit2, increment)\n        except TypeError:\n            ranges = zip([limit1], [limit2], [increment])\n        counts = []\n        for l1, l2, incr in ranges:\n            step = abs(incr) if l2 >= l1 else -abs(incr) \n            if l2 == l1 or incr == 0:\n                counts.append(1)\n            else:\n                counts.append(int(math.ceil(((l2 - l1) + step / 100.) / step)))\n        max_count = max(counts)\n        result = []\n        for (l1, l2, incr), count in zip(ranges, counts):\n            step = abs(incr) if l2 >= l1 else -abs(incr) \n            result.append([l1 + min(n, count) * step  for n in range(max_count)])\n        if len(result) == 1:\n            result = result[0]\n        else:\n            result= zip(*result)\n        return result\n\n\ndef sim(scn, hkl):\n    """"""sim hkl scn -- simulates moving scannable (not all)\n    """"""\n    if not isinstance(hkl, (tuple, list)):\n        raise TypeError()\n\n    if not allnum(hkl):\n        raise TypeError()\n\n    try:\n        print scn.simulateMoveTo(hkl)\n    except AttributeError:\n        raise TypeError(\n                ""The first argument does not support simulated moves"")'"
diffcalc/gdasupport/minigda/scannable.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport time\nfrom diffcalc.util import DiffcalcException\n\ntry:\n    from gda.device.scannable import ScannableBase, ScannaleMotionBase\nexcept ImportError:\n    class Scannable(object):\n        pass\n\n    class ScannableBase(Scannable):\n        """"""Implementation of a subset of OpenGDA\'s Scannable interface\n        """"""\n    \n        level = 5\n        inputNames = []\n        extraNames = []\n        outputFormat = []\n    \n        def isBusy(self):\n            raise NotImplementedError()\n    \n        def rawGetPosition(self):\n            raise NotImplementedError()\n    \n        def rawAsynchronousMoveTo(self, newpos):\n            raise NotImplementedError()\n    \n        def waitWhileBusy(self):\n            while self.isBusy():\n                time.sleep(.1)\n    \n        def getPosition(self):\n            return self.rawGetPosition()\n    \n        def checkPositionValid(self, externalPosition):\n            raise NotImplementedError()\n    \n        def asynchronousMoveTo(self, newpos):\n            self.rawAsynchronousMoveTo(newpos)\n    \n        def atScanStart(self):\n            pass\n    \n        def atScanEnd(self):\n            pass\n    \n        def atCommandFailure(self):\n            pass\n    \n    ###\n    \n        def __repr__(self):\n            pos = self.getPosition()\n            formattedValues = self.formatPositionFields(pos)\n            if len(tuple(self.getInputNames()) + tuple(self.getExtraNames())) > 1:\n                result = self.getName() + \': \'\n            else:\n                result = \'\'\n    \n            names = tuple(self.getInputNames()) + tuple(self.getExtraNames())\n            for name, val in zip(names, formattedValues):\n                result += \' \' + name + \': \' + val\n            return result\n    ###\n    \n        def formatPositionFields(self, pos):\n            """"""Returns position as array of formatted strings""""""\n            # Make sure pos is a tuple or list\n            if type(pos) not in (tuple, list):\n                pos = tuple([pos])\n    \n            # Sanity check\n            if len(pos) != len(self.getOutputFormat()):\n                raise Exception(\n                    ""In scannable \'%s\':number of position fields differs from ""\n                    ""number format strings specified"" % self.getName())\n    \n            result = []\n            for field, frmt in zip(pos, self.getOutputFormat()):\n                if field is None:\n                    result.append(\'???\')\n                else:\n                    s = (frmt % field)\n    ##                if width!=None:\n    ##                s = s.ljust(width)\n                    result.append(s)\n    \n            return result\n    \n        def getName(self):\n            return self.name\n    \n        def setName(self, value):\n            self.name = value\n    \n        def getLevel(self):\n            return self.level\n    \n        def setLevel(self, value):\n            self.level = value\n    \n        def getInputNames(self):\n            return self.inputNames\n    \n        def setInputNames(self, value):\n            self.inputNames = value\n    \n        def getExtraNames(self):\n            return self.extraNames\n    \n        def setExtraNames(self, value):\n            self.extraNames = value\n    \n        def getOutputFormat(self):\n            return self.outputFormat\n    \n        def setOutputFormat(self, value):\n            if type(value) not in (tuple, list):\n                raise TypeError(\n                    ""%s.setOutputFormat() expects tuple or list; not %s"" %\n                    (self.getName(), str(type(value))))\n            self.outputFormat = value\n    \n        def __call__(self, newpos=None):\n            if newpos is None:\n                return self.getPosition()\n            self.asynchronousMoveTo(newpos)\n\n\n    class ScannableLimitsComponent(object):\n\n        def __init__(self):\n            # Array of lower limits (one for each input name). Null if no limits set. Any value within array may be null if\n            # that input has no corresponding limit.\n            self.internalLowerLim = None\n\n            # Array of upper limits (one for each input name). Null if no limits set. Any value within array may be null if\n            # that input has no corresponding limit.\n            self.internalUpperLim = None\n\n            self.hostScannable = None\n            self.limitType = ""Scannable""\n\n        def getInternalLower(self):\n            return self.internalLowerLim\n\n        def getInternalUpper(self):\n            return self.internalUpperLim\n\n        def checkInternalPosition(self, internalPosition):\n\n            # If neither limits are set, return null indicating okay.\n            if self.internalLowerLim is None and self.internalUpperLim is None:\n                return None\n\n            # Check lower limits if set\n            if self.internalLowerLim:\n                for i, (lim, pos) in enumerate(zip(self.internalLowerLim, internalPosition)):\n                    if pos < lim:\n                        fieldName = ""{}.{}"".format(self.getHostScannable().getName(), self.getHostScannable().getInputNames()[i])\n                        return ""{} limit violation on {}: {} < {} (internal/hardware/dial values)."".format(\n                                                                self.limitType, fieldName, pos, lim)\n\n            # Check upper limits if set\n            if self.internalUpperLim:\n                for i, (lim, pos) in enumerate(zip(self.internalUpperLim, internalPosition)):\n                    if pos > lim:\n                        fieldName = ""{}.{}"".format(self.getHostScannable().getName(), self.getHostScannable().getInputNames()[i])\n                        return ""{} limit violation on {}: {} > {} (internal/hardware/dial values)."".format(\n                                                                self.limitType, fieldName, pos, lim)\n            return None\n\n        def checkPositionLength(self, positionArray):\n            if len(positionArray) != len(self.getHostScannable().getInputNames()):\n                raise DiffcalcException(\n                    ""Expected position of length {} but got position of length {}"".format(len(self.getHostScannable().getInputNames().length),\n                                                                                          len(positionArray)))\n\n        def setInternalUpper(self, internalUpperLim, index=None, length=None):\n            if index is not None:\n                if not self.internalUpperLim:\n                    self.internalUpperLim = [None] * length\n                self.internalUpperLim[index] = internalUpperLim\n            else:\n                if internalUpperLim:\n                    self.checkPositionLength(internalUpperLim)\n                self.internalUpperLim = internalUpperLim\n\n        def setInternalLower(self, internalLowerLim, index=None, length=None):\n            if index is not None:\n                if not self.internalLowerLim:\n                    self.internalLowerLim = [None] * length\n                self.internalLowerLim[index] = internalLowerLim\n            else:\n                if internalLowerLim:\n                    self.checkPositionLength(internalLowerLim)\n                self.internalLowerLim = internalLowerLim\n\n        def setHostScannable(self, hostScannable):\n            self.hostScannable = hostScannable\n\n        def getHostScannable(self):\n            return self.hostScannable\n\n\n    class ScannableMotionBase(ScannableBase):\n        """"""Implementation of a subset of OpenGDA\'s ScannableMotion interface\n        """"""\n\n        def __init__(self):\n            self.limitsComponent = ScannableLimitsComponent()\n            self.limitsComponent.setHostScannable(self)\n\n        def asynchronousMoveTo(self, newpos):\n            report = self.checkPositionValid([newpos,])\n            if report:\n                raise DiffcalcException(report)\n            ScannableBase.asynchronousMoveTo(self, newpos)\n\n        def checkPositionValid(self, externalPosition):\n            limitsComponentMsg = self.limitsComponent.checkInternalPosition(externalPosition)\n            if limitsComponentMsg:\n                return limitsComponentMsg\n            return None\n\n        def getLowerInnerLimit(self):\n            limits = self.limitsComponent.getInternalLower()\n            try:\n                return limits[0]\n            except TypeError:\n                return None\n\n        def getUpperInnerLimit(self):\n            limits = self.limitsComponent.getInternalUpper()\n            try:\n                return limits[0]\n            except TypeError:\n                return None\n\n\n    class ScannableAdapter(Scannable):\n        \'\'\'Wrap up a Scannable and give it a new name and optionally an offset\n        (added to the delegate when reading up and subtracting when setting down\n        \'\'\'\n        \n        def __init__(self, delegate_scn, name, offset=0):\n            assert len(delegate_scn.getInputNames()) == 1\n            assert len(delegate_scn.getExtraNames()) == 0\n            self.delegate_scn = delegate_scn\n            self.name = name\n            self.offset = offset\n                   \n        def __getattr__(self, name):\n            return getattr(self.delegate_scn, name)\n        \n        def getName(self):\n            return self.name\n        \n        def getInputNames(self):\n            return [self.name]\n        \n        def getPosition(self):\n            return self.delegate_scn.getPosition() + self.offset\n        \n        def asynchronousMoveTo(self, newpos):\n            self.delegate_scn.asynchronousMoveTo(newpos - self.offset)\n            \n        def __repr__(self):\n            pos = self.getPosition()\n            formatted_values = self.delegate_scn.formatPositionFields(pos)  \n            return self.name + \': \' + formatted_values[0] + \' \' + self.get_hint()\n        \n        def get_hint(self):\n            if self.offset:\n                offset_hint = \' + \' if self.offset >= 0 else \' - \'\n                offset_hint += str(self.offset)\n            else:\n                offset_hint = \'\'\n            return \'(%s%s)\' % (self.delegate_scn.name, offset_hint)\n        \n        def __call__(self, newpos=None):\n            if newpos is None:\n                return self.getPosition()\n            self.asynchronousMoveTo(newpos)\n\n\nclass SingleFieldDummyScannable(ScannableMotionBase):\n\n    def __init__(self, name, initial_position=0.):\n        ScannableMotionBase.__init__(self)\n        self.name = name\n        self.inputNames = [name,]\n        self.outputFormat = [\'% 6.4f\',]\n        self.level = 3\n        self._current_position = float(initial_position)\n\n    def isBusy(self):\n        return False\n\n    def waitWhileBusy(self):\n        return\n\n    def asynchronousMoveTo(self, new_position):\n        report = self.checkPositionValid([new_position,])\n        if report:\n            raise DiffcalcException(report)\n        self._current_position = float(new_position)\n\n    def getPosition(self):\n        return self._current_position\n\n    def setLowerDummyLimit(self, lowLimit):\n        self.limitsComponent.setInternalLower(lowLimit, 0, len(self.getInputNames()))\n        \n    def setUpperDummyLimit(self, upperLimit):\n        self.limitsComponent.setInternalUpper(upperLimit, 0, len(self.getInputNames()))\n\n\nclass DummyPD(SingleFieldDummyScannable):\n    """"""For compatability with the gda\'s dummy_pd module""""""\n    pass\n\n\nclass MultiInputExtraFieldsDummyScannable(ScannableMotionBase):\n    \'\'\'Multi input Dummy PD Class supporting input and extra fields\'\'\'\n    def __init__(self, name, inputNames, extraNames):\n        ScannableMotionBase.__init__(self)\n        self.setName(name)\n        self.setInputNames(inputNames)\n        self.setExtraNames(extraNames)\n        self.setOutputFormat([\'%6.4f\'] * (len(inputNames) + len(extraNames)))\n        self.setLevel(3)\n        self.currentposition = [0.0] * len(inputNames)\n\n    def isBusy(self):\n        return 0\n\n    def asynchronousMoveTo(self, new_position):\n        if type(new_position) == type(1) or type(new_position) == type(1.0):\n            new_position = [new_position]\n            msg = ""Wrong new_position size""\n        assert len(new_position) == len(self.currentposition), msg\n        for i in range(len(new_position)):\n            if new_position[i] != None:\n                self.currentposition[i] = float(new_position[i])\n\n    def getPosition(self):\n        extraValues = range(100, 100 + (len(self.getExtraNames())))\n        return self.currentposition + map(float, extraValues)\n\n\nclass ZeroInputExtraFieldsDummyScannable(ScannableMotionBase):\n    \'\'\'Zero input/extra field dummy pd\n    \'\'\'\n    def __init__(self, name):\n        ScannableMotionBase.__init__(self)\n        self.setName(name)\n        self.setInputNames([])\n        self.setOutputFormat([])\n\n    def isBusy(self):\n        return 0\n\n    def asynchronousMoveTo(self, new_position):\n        pass\n\n    def getPosition(self):\n        pass\n\n\nclass ScannableGroup(ScannableBase):\n    """"""wraps up motors. Simulates motors if non given.""""""\n\n    def __init__(self, name, motorList):\n\n        self.setName(name)\n        # Set input format\n        motorNames = []\n        for scn in motorList:\n            motorNames.append(scn.getName())\n        self.setInputNames(motorNames)\n        # Set output format\n        frmt = []\n        for motor in motorList:\n            frmt.append(motor.getOutputFormat()[0])\n        self.setOutputFormat(frmt)\n        self.__motors = motorList\n\n    def asynchronousMoveTo(self, position):\n        # if input has any Nones, then replace these with the current positions\n        if None in position:\n            position = list(position)\n            current = self.getPosition()\n            for idx, val in enumerate(position):\n                if val is None:\n                    position[idx] = current[idx]\n\n        for scn, pos in zip(self.__motors, position):\n            scn.asynchronousMoveTo(pos)\n\n    def getPosition(self):\n        return [scn.getPosition() for scn in self.__motors]\n\n    def getGroupMembers(self):\n        return self.__motors\n\n    def getGroupMember(self, name):\n        for scn in self.__motors:\n            if scn.getName() == name:\n                return scn\n        return None\n\n    def isBusy(self):\n        for scn in self.__motors:\n            if scn.isBusy():\n                return True\n        return False\n\n    def configure(self):\n        pass\n\n    def checkPositionValid(self, positionArray):\n\n        msg = ""Wrong position array size for scannable group""\n        assert len(self.__motors) == len(positionArray), msg\n        \n        for motor, pos in zip(self.__motors, positionArray):\n            reason = motor.checkPositionValid([pos,])\n            if reason:\n                return reason\n        return None\n\n\nclass ScannableMotionWithScannableFieldsBase(ScannableMotionBase):\n    \'\'\'\n    This extended version of ScannableMotionBase contains a\n    completeInstantiation() method which adds a dictionary of\n    MotionScannableParts to an instance. Each part allows one of the\n    instances fields to be interacted with like it itself is a scannable.\n    Fields are dynamically added to the instance linking to these parts\n    allowing dotted access from Jython.  They may also be accessed using\n    Jython container access methods (via the __getitem__() method). To acess\n    them from Jave use the getComponent(name) method.\n\n    When moving a part (via either a pos or scan command), the part calls\n    the parent to perform the actual task.  The parts asynchronousMoveto\n    command will call the parent with a list of None values except for the\n    field it represents which will be passed the desired position value.\n\n    The asynchronousMoveTo method in class that inherats from this base\n    class then must handle these Nones.  In some cases the method may\n    actually be able to move the underlying system assoiciated with one\n    field individually from others. If this is not possible the best\n    behaviour may be to simply not support this beahviour and exception or\n    alternatively to substitute the None values with actual current position\n    of parent\'s scannables associated fields.\n\n    ScannableMotionBaseWithMemory() inherats from this calss and provides a\n    solution useful for some scenarious: it keeps track of the last position\n    moved to, and replaces the Nones in an asynchronousMoveTo request with\n    these values. There are a number of dangers associated with this which\n    are addressed in that class\'s documentation, but it provides a way to\n    move one axis within a group of non-orthogonal axis while keeping the\n    others still.\n    \'\'\'\n    childrenDict = {}\n    numInputFields = None\n    numExtraFields = None\n\n    def completeInstantiation(self):\n        \'\'\'This method should be called at the end of all user defined\n        consructors\'\'\'\n        # self.validate()\n        self.numInputFields = len(self.getInputNames())\n        self.numExtraFields = len(self.getExtraNames())\n        self.addScannableParts()\n        self.autoCompletePartialMoveToTargets = False\n        self.positionAtScanStart = None\n\n    def setAutoCompletePartialMoveToTargets(self, b):\n        self.autoCompletePartialMoveToTargets = b\n\n    def atScanStart(self):\n        self.positionAtScanStart = self.getPosition()\n\n    def atCommandFailure(self):\n        self.positionAtScanStart = None\n\n    def atScanEnd(self):\n        self.positionAtScanStart = None\n\n###\n\n    def __repr__(self):\n        pos = self.getPosition()\n        formattedValues = self.formatPositionFields(pos)\n        if len(tuple(self.getInputNames()) + tuple(self.getExtraNames())) > 1:\n            result = self.getName() + \': \'\n        else:\n            result = \'\'\n\n        names = tuple(self.getInputNames()) + tuple(self.getExtraNames())\n        for name, val in zip(names, formattedValues):\n            result += \' \' + name + \': \' + val\n        return result\n###\n\n    def formatPositionFields(self, pos):\n        """"""Returns position as array of formatted strings""""""\n        # Make sure pos is a tuple or list\n        if type(pos) not in (tuple, list):\n            pos = tuple([pos])\n\n        # Sanity check\n        if len(pos) != len(self.getOutputFormat()):\n            raise Exception(\n                ""In scannable \'%s\':number of position fields differs from ""\n                ""number format strings specified"" % self.getName())\n\n        result = []\n        for field, frmt in zip(pos, self.getOutputFormat()):\n            if field is None:\n                result.append(\'???\')\n            else:\n                s = (frmt % field)\n##                if width!=None:\n##                s = s.ljust(width)\n                result.append(s)\n\n        return result\n\n###\n    \n    def addScannableParts(self):\n        \'\'\'\n        Creates an array of MotionScannableParts each of which allows access to\n        the scannable\'s fields. See this class\'s documentation for more info.\n        \'\'\'\n        self.childrenDict = {}\n        # Add parts to access the input fields\n        for index in range(len(self.getInputNames())):\n            scannableName = self.getInputNames()[index]\n            self.childrenDict[scannableName] = self.MotionScannablePart(\n                scannableName, index, self, isInputField=1)\n\n        # Add parts to access the extra fields\n        for index in range(len(self.getExtraNames())):\n            scannableName = self.getExtraNames()[index]\n            self.childrenDict[scannableName] = self.MotionScannablePart(\n                scannableName, index + len(self.getInputNames()),\n                self, isInputField=0)\n\n    def asynchronousMoveTo(self, newpos):\n        if self.autoCompletePartialMoveToTargets:\n            newpos = self.completePosition(newpos)\n        ScannableBase.asynchronousMoveTo(self, newpos)\n\n    def completePosition(self, position):\n        \'\'\'\n        If position contains any null or None values, these are replaced with\n        the corresponding fields from the scannables current position and then\n        returned.\'\'\'\n        # Just return position if it does not need padding\n        if None not in position:\n            return position\n        if self.positionAtScanStart is not None:\n            basePosition = self.positionAtScanStart\n        else:\n            basePosition = self.getPosition()[:self.numInputFields]\n        for i in range(self.numInputFields):\n            if position[i] is None:\n                position[i] = basePosition[i]\n        return position\n\n    def __getattr__(self, name):\n        try:\n            return self.childrenDict[name]\n        except:\n            raise AttributeError(""No child named:"" + name)\n\n    def __getitem__(self, key):\n        \'\'\'Provides container like access from Jython\'\'\'\n        return self.childrenDict[key]\n\n    def getPart(self, name):\n        \'\'\'Returns the a compnent scannable\'\'\'\n        return self.childrenDict[name]\n\n    class MotionScannablePart(ScannableMotionBase):\n        \'\'\'\n        A scannable to be placed in the parent\'s childrenDict that allows\n        access to the parent\'s individual fields.\'\'\'\n\n        def __init__(self, scannableName, index, parentScannable,\n                     isInputField):\n            ScannableMotionBase.__init__(self)\n            self.setName(scannableName)\n            if isInputField:\n                self.setInputNames([scannableName])\n            else:\n                self.setExtraNames([scannableName])\n            self.index = index\n            self.parentScannable = parentScannable\n            self.setOutputFormat(\n                [self.parentScannable.getOutputFormat()[index]])\n\n        def getParent(self):\n            return self.parentScannable\n\n        def isBusy(self):\n            return self.parentScannable.isBusy()\n\n        def asynchronousMoveTo(self, new_position):\n            if self.parentScannable.isBusy():\n                raise Exception(\n                    self.parentScannable.getName() + ""."" + self.getName() +\n                    "" cannot be moved because "" +\n                    self.parentScannable.getName() + "" is already moving"")\n\n            toMoveTo = [None] * len(self.parentScannable.getInputNames())\n            toMoveTo[self.index] = new_position\n            self.parentScannable.asynchronousMoveTo(toMoveTo)\n            \n        def moveTo(self, new_position):\n            self.asynchronousMoveTo(new_position)\n            self.waitWhileBusy()\n\n        def getPosition(self):\n            return self.parentScannable.getPosition()[self.index]\n\n        def getLowerGdaLimits(self):\n            limit = self.parentScannable.getLowerGdaLimits()\n            return None if limit is None else [limit[self.index]]\n\n        def getUpperGdaLimits(self):\n            limit = self.parentScannable.getUpperGdaLimits()\n            return None if limit is None else [limit[self.index]]\n\n        def setLowerGdaLimits(self, lowerLim):\n            try:\n                if len(lowerLim) != 1:\n                    raise DiffcalcException(""Could not setLowerGdaLmits() on scannable {} to {}. This scannable has only one field."".format(\n                        self.getName(), str(lowerLim)))\n                lowerLimValue = lowerLim[0]\n            except TypeError:\n                lowerLimValue = lowerLim\n            limit = self.parentScannable.getLowerGdaLimits()\n            if not limit:\n                limit = [None] * len(self.parentScannable.getInputNames())\n            limit[self.index] = lowerLimValue\n            self.parentScannable.setLowerGdaLimits(limit)\n\n        def setUpperGdaLimits(self, upperLim):\n            try:\n                if len(upperLim) != 1:\n                    raise DiffcalcException(""Could not setUpperGdaLmits() on scannable {} to {}. This scannable has only one field."".format(\n                        self.getName(), str(upperLim)))\n                upperLimValue = upperLim[0]\n            except TypeError:\n                upperLimValue = upperLim\n            limit = self.parentScannable.getUpperGdaLimits()\n            if not limit:\n                limit = [None] * len(self.parentScannable.getInputNames())\n            limit[self.index] = upperLimValue\n            self.parentScannable.setUpperGdaLimits(limit)\n\n        def __str__(self):\n            return self.__repr__()\n\n        def __repr__(self):\n            # Get the name of this field\n            # (assume its an input field first and correct if wrong)\n            name = self.getInputNames()[0]\n\n            if name == \'value\':\n                name = self.getExtraNames()[0]\n            parentName = self.parentScannable.getName()\n            return parentName + ""."" + name + "" : "" + str(self.getPosition())\n'"
diffcalc/gdasupport/scannable/__init__.py,0,b''
diffcalc/gdasupport/scannable/base.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from gda.device.scannable import ScannableMotionBase \\\n        as PseudoDevice\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableBase as PseudoDevice\n\n\nclass ScannableGroup(PseudoDevice):\n\n    def __init__(self, name, motorList):\n\n        self.setName(name)\n        # Set input format\n        motorNames = []\n        for scn in motorList:\n            motorNames.append(scn.getName())\n        self.setInputNames(motorNames)\n        # Set output format\n        format = []\n        for motor in motorList:\n            format.append(motor.getOutputFormat()[0])\n        self.setOutputFormat(format)\n        self.__motors = motorList\n\n    def asynchronousMoveTo(self, position):\n        # if input has any Nones, then replace these with the current positions\n        if None in position:\n            position = list(position)\n            current = self.getPosition()\n            for idx, val in enumerate(position):\n                if val is None:\n                    position[idx] = current[idx]\n\n        for scn, pos in zip(self.__motors, position):\n            scn.asynchronousMoveTo(pos)\n\n    def getPosition(self):\n        return [scn.getPosition() for scn in self.__motors]\n\n    def isBusy(self):\n        for scn in self.__motors:\n            if scn.isBusy():\n                return True\n        return False\n'"
diffcalc/gdasupport/scannable/diffractometer.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from gda.device.scannable import ScannableMotionBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableBase as ScannableMotionBase\n\nfrom diffcalc.util import getMessageFromException\n\n# TODO: Split into a base class when making other scannables\n\n\nclass DiffractometerScannableGroup(ScannableMotionBase):\n    """"""""\n    Wraps up a scannableGroup of axis to tweak the way the resulting\n    object is displayed and to add a simulate move to method.\n\n    The scannable group should have the same geometry as that expected\n    by the diffractometer hardware geometry used in the diffraction\n    calculator.\n\n    The optional parameter slaveDriver can be used to provide a\n    slave_driver. This is useful for triggering a move of an incidental\n    axis whose position depends on that of the diffractometer, but whose\n    position need not be included in the DiffractometerScannableGroup\n    itself. This parameter is exposed as a field and can be set or\n    cleared to null at will without effecting the core calculation code.\n    """"""\n\n    def __init__(self, name, diffcalc_module, scannableGroup,\n                 slave_driver=None, hint_generator=None):\n        # if motorList is None, will create a dummy __group\n        self.diffcalc_module = diffcalc_module\n        self.__group = scannableGroup\n        self.slave_driver = slave_driver\n        self.setName(name)\n        self.hint_generator = hint_generator\n\n    def getInputNames(self):\n        return self.__group.getInputNames()\n\n    def getExtraNames(self):\n        if self.slave_driver is None:\n            return []\n        else:\n            return self.slave_driver.getScannableNames()\n\n    def getOutputFormat(self):\n        if self.slave_driver is None:\n            slave_formats = []\n        else:\n            slave_formats = self.slave_driver.getScannableNames()\n        return list(self.__group.getOutputFormat()) + slave_formats\n\n    def asynchronousMoveTo(self, position):\n        self.__group.asynchronousMoveTo(position)\n        if self.slave_driver is not None:\n            self.slave_driver.triggerAsynchronousMove(position)\n\n    def getPosition(self):\n        if self.slave_driver is None:\n            slave_positions = []\n        else:\n            slave_positions = self.slave_driver.getPositions()\n        return list(self.__group.getPosition()) + list(slave_positions)\n\n    def getGroupMembers(self):\n        group_members = []\n        group_members.extend(self.__group.getGroupMembers())\n        if self.slave_driver is not None:\n            group_members.extend(self.slave_driver.scannbles)\n        return group_members\n\n    def getGroupMember(self, name):\n        if name in self.__group.getInputNames():\n            return self.__group.getGroupMember(name)\n        elif self.slave_driver is not None:\n            if name in self.slave_driver.getScannableNames():\n                return self.slave_driver.getScannable()\n        return None\n\n    def isBusy(self):\n        if self.slave_driver is None:\n            return self.__group.isBusy()\n        else:\n            return self.__group.isBusy() or self.slave_driver.isBusy()\n\n    def waitWhileBusy(self):\n        self.__group.waitWhileBusy()\n        if self.slave_driver is not None:\n            self.slave_driver.waitWhileBusy()\n\n    def simulateMoveTo(self, pos):\n        if len(pos) != len(self.getInputNames()):\n            raise ValueError(\'Wrong number of inputs\')\n        try:\n            (hkl, params) = self.diffcalc_module.angles_to_hkl(pos)\n        except Exception, e:\n            return ""Error: %s"" % getMessageFromException(e)\n        width = max(len(k) for k in params)\n\n        lines = ([\'  \' + \'hkl\'.rjust(width) + \' : % 9.4f  %.4f  %.4f\' %\n                  (hkl[0], hkl[1], hkl[2])])\n        lines[-1] = lines[-1] + \'\\n\'\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n\n    def __repr__(self):\n        position = self.getPosition()\n        names = list(self.getInputNames()) + list(self.getExtraNames())\n        if self.hint_generator is None:\n            hint_list = [\'\'] * len(self.getInputNames())\n        else:\n            hint_list = self.hint_generator()\n        \n        lines = [self.name + \':\']\n        width = max(len(k) for k in names)\n        fmt = \'  %\' + str(width) + \'s : % 9.4f   %s\'\n        for name, pos, hint in zip(names, position, hint_list):\n            lines.append(fmt % (name, pos, hint))\n        lines[len(self.getInputNames())] += \'\\n\'\n        return \'\\n\'.join(lines)\n'"
diffcalc/gdasupport/scannable/hkl.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nimport platform\n\nDEBUG = False\n\ntry:\n    from gda.device.scannable.scannablegroup import \\\n        ScannableMotionWithScannableFieldsBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableMotionWithScannableFieldsBase\n\nfrom diffcalc.util import getMessageFromException, DiffcalcException\n\n\nclass _DynamicDocstringMetaclass(type):\n\n    def _get_doc(self):\n        return Hkl.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\nclass Hkl(ScannableMotionWithScannableFieldsBase):\n    \n    if platform.system() != \'Java\':\n        __metaclass__ = _DynamicDocstringMetaclass  # TODO: Removed to fix Jython\n\n    dynamic_docstring = \'Hkl Scannable\'\n\n    def _get_doc(self):\n        return Hkl.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n    def __init__(self, name, diffractometerObject, diffcalcObject,\n                 virtualAnglesToReport=None):\n        self.diffhw = diffractometerObject\n        self._diffcalc = diffcalcObject\n        if type(virtualAnglesToReport) is str:\n            virtualAnglesToReport = (virtualAnglesToReport,)\n        self.vAngleNames = virtualAnglesToReport\n\n        self.setName(name)\n        self.setInputNames([\'h\', \'k\', \'l\'])\n        self.setOutputFormat([\'%7.5f\'] * 3)\n        if self.vAngleNames:\n            self.setExtraNames(self.vAngleNames)\n            self.setOutputFormat([\'%7.5f\'] * (3 + len(self.vAngleNames)))\n\n        self.completeInstantiation()\n        self.setAutoCompletePartialMoveToTargets(True)\n        self.dynamic_class_doc = \'Hkl Scannable xyz\'\n\n    def rawAsynchronousMoveTo(self, hkl):\n        if len(hkl) != 3: raise ValueError(\'Hkl device expects three inputs\')\n        try:\n            (pos, _) = self._diffcalc.hkl_to_angles(hkl[0], hkl[1], hkl[2])\n        except DiffcalcException, e:\n            if DEBUG:\n                raise\n            else:\n                raise DiffcalcException(e.message)\n        self.diffhw.asynchronousMoveTo(pos)\n\n    def rawGetPosition(self):\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl , params) = self._diffcalc.angles_to_hkl(pos)\n        result = list(hkl)\n        if self.vAngleNames:\n            for vAngleName in self.vAngleNames:\n                result.append(params[vAngleName])\n        return result\n\n    def getFieldPosition(self, i):\n        return self.getPosition()[i]\n\n    def isBusy(self):\n        return self.diffhw.isBusy()\n\n    def waitWhileBusy(self):\n        return self.diffhw.waitWhileBusy()\n\n    def simulateMoveTo(self, hkl):\n        if type(hkl) not in (list, tuple):\n            raise ValueError(\'Hkl device expects three inputs\')\n        if len(hkl) != 3:\n            raise ValueError(\'Hkl device expects three inputs\')\n        (pos, params) = self._diffcalc.hkl_to_angles(hkl[0], hkl[1], hkl[2])\n\n        width = max(len(k) for k in (params.keys() + list(self.diffhw.getInputNames())))\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n\n        lines = [self.diffhw.getName() + \' would move to:\']\n        for idx, name in enumerate(self.diffhw.getInputNames()):\n            lines.append(fmt % (name, pos[idx]))\n        lines[-1] = lines[-1] + \'\\n\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        lines = [\'hkl:\']\n        pos = self.diffhw.getPosition()\n        try:\n            (hkl, params) = self._diffcalc.angles_to_hkl(pos)\n        except Exception, e:\n            return ""<hkl: %s>"" % getMessageFromException(e)\n\n        width = max(len(k) for k in params)\n        lines.append(\'  \' + self.name.rjust(width) + \' : %9.4f  %.4f  %.4f\' % (hkl[0], hkl[1], hkl[2]))\n        lines[-1] = lines[-1] + \'\\n\'\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        lines.extend(["""", self.diffhw.getName() + "":""])\n        for idx, name in enumerate(self.diffhw.getInputNames()):\n            lines.append(fmt % (name, pos[idx]))\n        return \'\\n\'.join(lines)\n'"
diffcalc/gdasupport/scannable/hkloffset.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nimport platform\n\nDEBUG = False\n\ntry:\n    from gda.device.scannable.scannablegroup import \\\n        ScannableMotionWithScannableFieldsBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableMotionWithScannableFieldsBase\n\nfrom diffcalc.util import getMessageFromException, DiffcalcException, TODEG,\\\n    TORAD\n\n\nclass _DynamicDocstringMetaclass(type):\n\n    def _get_doc(self):\n        return HklOffset.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\nclass HklOffset(ScannableMotionWithScannableFieldsBase):\n    \n    if platform.system() != \'Java\':\n        __metaclass__ = _DynamicDocstringMetaclass  # TODO: Removed to fix Jython\n\n    dynamic_docstring = \'Hkl Offset Scannable\'\n\n    def _get_doc(self):\n        return HklOffset.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n    def __init__(self, name, diffractometerObject, diffcalcObject,\n                 virtualAnglesToReport=None):\n        self.diffhw = diffractometerObject\n        self._diffcalc = diffcalcObject\n        if type(virtualAnglesToReport) is str:\n            virtualAnglesToReport = (virtualAnglesToReport,)\n        self.vAngleNames = virtualAnglesToReport\n        self._hkl_reference = [0, 0, 0]\n\n        self.setName(name)\n        self.setInputNames([\'h\', \'k\', \'l\', \'polar\', \'azimuthal\'])\n        self.setOutputFormat([\'%7.5f\'] * 5)\n        if self.vAngleNames:\n            self.setExtraNames(self.vAngleNames)\n            self.setOutputFormat([\'%7.5f\'] * (5 + len(self.vAngleNames)))\n\n        self.completeInstantiation()\n        self.setAutoCompletePartialMoveToTargets(True)\n        self.dynamic_class_doc = \'Hkl Offset Scannable xyz\'\n\n    def rawAsynchronousMoveTo(self, hkl):\n        if len(hkl) != 5: raise ValueError(\'Hkl Offset device expects five inputs\')\n        try:\n            self._hkl_reference = hkl[:3]\n            pol, az = hkl[-2] * TORAD, hkl[-1] * TORAD\n            hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*self._hkl_reference, pol=pol, az=az)\n            (pos, _) = self._diffcalc.hkl_to_angles(*hkl_offset)\n        except DiffcalcException, e:\n            if DEBUG:\n                raise\n            else:\n                raise DiffcalcException(e.message)\n        self.diffhw.asynchronousMoveTo(pos)\n\n    def rawGetPosition(self):\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl_pos , params) = self._diffcalc.angles_to_hkl(pos)\n        result = list(self._hkl_reference)\n        pol, az, _ = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, self._hkl_reference)\n        result.extend([pol * TODEG, az * TODEG])\n        if self.vAngleNames:\n            for vAngleName in self.vAngleNames:\n                result.append(params[vAngleName])\n        return result\n\n    def getFieldPosition(self, i):\n        return self.getPosition()[i]\n\n    def isBusy(self):\n        return self.diffhw.isBusy()\n\n    def waitWhileBusy(self):\n        return self.diffhw.waitWhileBusy()\n\n    def simulateMoveTo(self, hkl):\n        if type(hkl) not in (list, tuple):\n            raise ValueError(\'Hkl Offset device expects five inputs\')\n        if len(hkl) != 5:\n            raise ValueError(\'Hkl Offset device expects five inputs\')\n        pol, az = hkl[-2] * TORAD, hkl[-1] * TORAD\n        hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*hkl[:3], pol=pol, az=az)\n        (pos, params) = self._diffcalc.hkl_to_angles(*hkl_offset)\n\n        width = max(len(k) for k in (params.keys() + list(self.diffhw.getInputNames())))\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n\n        lines = [\'simulated hkl: %9.4f  %.4f  %.4f\' % (hkl_offset[0],hkl_offset[1],hkl_offset[2]),\n                 self.diffhw.getName() + \' would move to:\']\n        for idx, name in enumerate(self.diffhw.getInputNames()):\n            lines.append(fmt % (name, pos[idx]))\n        lines[-1] = lines[-1] + \'\\n\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        lines = [\'hkloffset:\']\n        pos = self.diffhw.getPosition()\n        try:\n            (hkl_pos, params) = self._diffcalc.angles_to_hkl(pos)\n            pol, az, _ = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, self._hkl_reference)\n        except Exception, e:\n            return ""<hkloffser: %s>"" % getMessageFromException(e)\n\n        width = max(len(k) for k in params)\n        lines.append(\'  \' + self.name.rjust(width) + \' : %9.4f  %.4f  %.4f  %.4f  %.4f\' % (self._hkl_reference[0],\n                                                                                       self._hkl_reference[1],\n                                                                                       self._hkl_reference[2],\n                                                                                       pol * TODEG, az * TODEG))\n        lines[-1] = lines[-1] + \'\\n\'\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n'"
diffcalc/gdasupport/scannable/mock.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from gda.device.scannable import ScannableMotionBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableBase as ScannableMotionBase\n\n\nclass MockMotor(ScannableMotionBase):\n\n    def __init__(self, name='mock'):\n        self.pos = 0.0\n        self._busy = False\n        self.name = name\n\n    def asynchronousMoveTo(self, pos):\n        self._busy = True\n        self.pos = float(pos)\n\n    def getPosition(self):\n        return self.pos\n\n    def isBusy(self):\n        return self._busy\n\n    def makeNotBusy(self):\n        self._busy = False\n\n    def getOutputFormat(self):\n        return ['%f']\n"""
diffcalc/gdasupport/scannable/parameter.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nfrom diffcalc import settings\n\ntry:\n    from gda.device.scannable import ScannableMotionBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableBase as ScannableMotionBase\n\n\nclass DiffractionCalculatorParameter(ScannableMotionBase):\n\n    def __init__(self, name, parameterName, parameter_manager):\n\n        self.parameter_manager = parameter_manager\n        self.parameterName = parameterName\n        self._ext_name = settings.geometry.map_to_external_name(parameterName)\n\n        self.setName(name)\n        self.setInputNames([parameterName,])\n        self.setOutputFormat(['%5.5f',])\n        self.setLevel(3)\n\n    def asynchronousMoveTo(self, value):\n        _, cons_value = settings.geometry.map_to_internal_position(self._ext_name, value)\n        self.parameter_manager.set_constraint(self.parameterName, cons_value)\n\n    def getPosition(self):\n        value = self.parameter_manager.get_constraint(self.parameterName)\n        _, cons_value = settings.geometry.map_to_internal_position(self.parameterName, value)\n        return [cons_value,]\n\n    def isBusy(self):\n        return False\n"""
diffcalc/gdasupport/scannable/parametrised_hkl.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nfrom diffcalc.gdasupport.scannable.hkl import Hkl\nfrom diffcalc import settings\nfrom diffcalc.util import getMessageFromException\n\n\nclass ParametrisedHKLScannable(Hkl):\n\n    def __init__(self, name, inputNames, num_cached_params=0):\n\n        from diffcalc.dc import dcyou as _dc\n        Hkl.__init__(self, name, settings.axes_scannable_group, _dc, None)\n\n        self.setName(name)\n        self.setInputNames(inputNames)\n        self.setOutputFormat([\'%7.5f\'] * len(inputNames))\n\n        self.parameter_to_hkl = self._diffcalc.angles_to_hkl\n        self.hkl_to_parameter = self._diffcalc.hkl_to_angles\n        self.num_cached_params = num_cached_params\n        self.cached_params = None\n\n        self.completeInstantiation()\n        self.setAutoCompletePartialMoveToTargets(True)\n        self.dynamic_class_doc = \'Generic Hkl Scannable\'\n\n\n    def rawAsynchronousMoveTo(self, pos):\n        self.cached_params = pos[-self.num_cached_params:]\n        hkl = self.parameter_to_hkl(pos)\n        if isinstance(hkl[0], (int, float)):\n            Hkl.rawAsynchronousMoveTo(self, hkl)\n        elif isinstance(hkl[0], (tuple, list)):\n            (pos, _) = self._diffcalc.hkl_list_to_angles(hkl)\n            self.diffhw.asynchronousMoveTo(pos)\n\n\n    def rawGetPosition(self):\n        pos = self.diffhw.getPosition()  # a tuple\n        hkl, _ = self._diffcalc.angles_to_hkl(pos)\n        pos = self.hkl_to_parameter(list(hkl))\n        return pos\n\n\n    def simulateMoveTo(self, pos):\n        lines = [\'%s:\' % self.name]\n        hkl = self.parameter_to_hkl(pos)\n        if isinstance(hkl[0], (tuple, list)):\n            (angles, _) = self._diffcalc.hkl_list_to_angles(hkl)\n            hkl, _ = self._diffcalc.angles_to_hkl(angles)\n        #fmt_scn_params = \'  \'.join([\' : %9.4f\'] + [\'%.4f\'] * (len(pos) - 1))\n        #lines.append(\'  \' + self.name + fmt_scn_params % tuple(pos))\n        width = max(len(k) for k in self.inputNames)\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for idx, k in enumerate(self.inputNames):\n            lines.append(fmt % (k, pos[idx]))\n        lines.append(\'\\n  \' + \'hkl\'.rjust(width) + \' : %9.4f  %.4f  %.4f\' % (hkl[0], hkl[1], hkl[2]))\n        res = Hkl.simulateMoveTo(self, hkl)\n        lines.append(res)\n        return \'\\n\'.join(lines)\n\n\n    def __repr__(self):\n        lines = [\'%s:\' % self.name]\n        pos = self.diffhw.getPosition()\n        try:\n            (hkl, params) = self._diffcalc.angles_to_hkl(pos)\n            scn_params = self.hkl_to_parameter(list(hkl))\n        except Exception, e:\n            return ""<%s: %s>"" % (self.name, getMessageFromException(e))\n\n        width = max(len(k) for k in params)\n        fmt_scn_params = \'  \'.join([\' : %9.4f\'] + [\'%.4f\'] * (len(scn_params) - 1))\n        lines.append(\'  \' + self.name.rjust(width) + fmt_scn_params % scn_params)\n        lines.append(\'  \' + \'hkl\'.rjust(width) + \' : %9.4f  %.4f  %.4f\' % (hkl[0], hkl[1], hkl[2]))\n        lines[-1] = lines[-1] + \'\\n\'\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n'"
diffcalc/gdasupport/scannable/qtrans.py,0,"b'###\n# Copyright 2008-2018 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nimport platform\nfrom math import pi, sqrt, acos, cos\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nDEBUG = False\n\ntry:\n    from gda.device.scannable.scannablegroup import \\\n        ScannableMotionBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableMotionBase\n\nfrom diffcalc.util import DiffcalcException, bound, SMALL, dot3\n\n\nclass _DynamicDocstringMetaclass(type):\n\n    def _get_doc(self):\n        return Qtrans.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\nclass Qtrans(ScannableMotionBase):\n\n    if platform.system() != \'Java\':\n        __metaclass__ = _DynamicDocstringMetaclass  # TODO: Removed to fix Jython\n\n    dynamic_docstring = \'qtrans scannable\'\n\n\n    def _get_doc(self):\n        return Qtrans.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\n    def __init__(self, name, diffractometerObject, diffcalcObject):\n        self.diffhw = diffractometerObject\n        self._diffcalc = diffcalcObject\n\n        self.setName(name)\n        self.setInputNames([name])\n        self.setOutputFormat([\'%7.5f\'])\n\n        self.dynamic_class_doc = \'qtrans scannable\'\n\n\n    def asynchronousMoveTo(self, newpos):\n\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl_pos , _) = self._diffcalc.angles_to_hkl(pos)\n\n        nref_hkl = [i[0] for i in self._diffcalc._ub.ubcalc.n_hkl.tolist()]\n        pol, az_nref, sc = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, nref_hkl)\n        if pol < SMALL:\n            az_nref = 0\n        sc_nref_hkl = [sc * v for v in nref_hkl]\n\n        _ubm = self._diffcalc._ub.ubcalc._get_UB()\n        qvec = _ubm * matrix(hkl_pos).T\n        qvec_rlu = sqrt(dot3(qvec, qvec)) * self._diffcalc._ub.ubcalc.get_hkl_plane_distance(nref_hkl) / (2.*pi)\n\n        try:\n            newpol = acos(bound(newpos / qvec_rlu))\n        except AssertionError:\n            raise DiffcalcException(""Scattering vector projection value of %.5f r.l.u. unreachable."" % newpos)\n\n        try:\n            hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*sc_nref_hkl, pol=newpol, az=az_nref)\n            (pos, _) = self._diffcalc.hkl_to_angles(*hkl_offset)\n        except DiffcalcException, e:\n            if DEBUG:\n                raise\n            else:\n                raise DiffcalcException(e.message)\n\n        self.diffhw.asynchronousMoveTo(pos)\n\n\n    def getPosition(self):\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl_pos , _) = self._diffcalc.angles_to_hkl(pos)\n        nref_hkl = [i[0] for i in self._diffcalc._ub.ubcalc.n_hkl.tolist()]\n        pol = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, nref_hkl)[0]\n        _ubm = self._diffcalc._ub.ubcalc._get_UB()\n        qvec = _ubm * matrix(hkl_pos).T\n        sc = sqrt(dot3(qvec, qvec)) * self._diffcalc._ub.ubcalc.get_hkl_plane_distance(nref_hkl) / (2.*pi)\n        res = sc * cos(pol)\n        return res\n\n    def isBusy(self):\n        return self.diffhw.isBusy()\n\n    def waitWhileBusy(self):\n        return self.diffhw.waitWhileBusy()\n\n    def simulateMoveTo(self, newpos):\n\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl_pos , _) = self._diffcalc.angles_to_hkl(pos)\n\n        nref_hkl = [i[0] for i in self._diffcalc._ub.ubcalc.n_hkl.tolist()]\n        pol, az_nref, sc = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, nref_hkl)\n        if pol < SMALL:\n            az_nref = 0\n        sc_nref_hkl = [sc * v for v in nref_hkl]\n\n        _ubm = self._diffcalc._ub.ubcalc._get_UB()\n        qvec = _ubm * matrix(hkl_pos).T\n        qvec_rlu = sqrt(dot3(qvec, qvec)) * self._diffcalc._ub.ubcalc.get_hkl_plane_distance(nref_hkl) / (2.*pi)\n\n        try:\n            newpol = acos(bound(newpos / qvec_rlu))\n        except AssertionError:\n            raise DiffcalcException(""Scattering vector projection value  of %.5f r.l.u. unreachable."" % newpos)\n\n        try:\n            hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*sc_nref_hkl, pol=newpol, az=az_nref)\n            (pos, params) = self._diffcalc.hkl_to_angles(*hkl_offset)\n        except DiffcalcException, e:\n            if DEBUG:\n                raise\n            else:\n                raise DiffcalcException(e.message)\n\n        width = max(len(k) for k in (params.keys() + list(self.diffhw.getInputNames())))\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n\n        lines = [\'simulated hkl: %9.4f  %.4f  %.4f\' % (hkl_offset[0],hkl_offset[1],hkl_offset[2]),\n                 self.diffhw.getName() + \' would move to:\']\n        for idx, name in enumerate(self.diffhw.getInputNames()):\n            lines.append(fmt % (name, pos[idx]))\n        lines[-1] = lines[-1] + \'\\n\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n\n'"
diffcalc/gdasupport/scannable/setref2.py,0,"b'\'\'\'\nCreated on 1 Nov 2018\n\n@author: voo82357\n\'\'\'\nfrom diffcalc.util import allnum, DiffcalcException, TODEG\nfrom diffcalc.gdasupport.scannable.sim import sim\nfrom diffcalc.util import getInputWithDefault\n\ndef setref2(scn, hkl):\n    """"""setref2 scn [h k l] -- setup hkloffset scannable to scan for second reflection [hkl]""""""\n    \n    if not isinstance(hkl, (tuple, list)):\n        raise DiffcalcException(""Please specify hkl values for a second reference reflection to search."")\n\n    if not allnum(hkl):\n        raise DiffcalcException(""Please specify numeric values for hkl."")\n\n    try:\n        hkl_ref = scn._diffcalc._ub.ubcalc.get_reflection(0)[0]\n    except IndexError:\n        raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n    pol, az, sc = scn._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl, hkl_ref)\n    hkl_rot = [sc * val for val in hkl_ref]\n    hkl_sc = hkl_rot[:]\n    hkl_rot.extend([pol * TODEG, az * TODEG])\n    hkl_sc.extend([0, 0])\n\n    print (\'\\nRescaled hkl reference for second reflection : %9.4f  %.4f  %.4f\' % (hkl_sc[0], hkl_sc[1], hkl_sc[2]))\n    print (\'         polar and azimuthal rotation angles : %9.4f  %.4f\\n\' % (pol * TODEG, az * TODEG))\n\n    sim(scn, hkl_sc)\n    print (\'IMPORTANT: Applying subsequent polar and azimuthal rotations might fail. In this case, please manually\\n\'\n           \'           find accessible azimuthal rotation range to scan for second reference reflection.\')\n    reply = getInputWithDefault(\'Move to rescaled hkl position\', \'y\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        scn.asynchronousMoveTo(hkl_sc)\n    else:\n        print \'Aborting\'\n        return\n\n    sim(scn, hkl_rot)\n    reply = getInputWithDefault(\'Apply polar and azimuthal rotations\', \'y\')\n    if reply in (\'y\', \'Y\', \'yes\'):\n        scn.asynchronousMoveTo(hkl_rot)\n    else:\n        print \'Aborting\'\n        return'"
diffcalc/gdasupport/scannable/sim.py,0,"b'\'\'\'\nCreated on 7 May 2016\n\n@author: walton\n\'\'\'\n\ndef sim(scn, hkl):\n    """"""sim hkl scn -- simulates moving scannable (not all)\n    """"""\n    try:\n        print scn.simulateMoveTo(hkl)\n    except AttributeError:\n        raise TypeError(\n            ""The first argument does not support simulated moves"")'"
diffcalc/gdasupport/scannable/simulation.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport time\nfrom math import sqrt, pi, exp\n\ntry:\n    from gda.device.scannable import ScannableMotionBase \\\n        as PseudoDevice\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableBase as PseudoDevice\n\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.hkl.you.calc import youAnglesToHkl\nfrom diffcalc.hkl.vlieg.calc import vliegAnglesToHkl\nfrom diffcalc.hkl.you.geometry import calcCHI, calcPHI\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nclass Equation(object):\n\n    def __call__(self, dh, dk, dl):\n        raise Exception(\'Abstract\')\n\n    def __str__(self):\n        ""Abstract equation""\n\n\nclass Gaussian(Equation):\n\n    def __init__(self, variance):\n        self.variance = float(variance)\n\n    def __call__(self, dh, dk, dl):\n        dr_squared = dh * dh + dk * dk + dl * dl\n        return (1 / sqrt(2 * pi * self.variance) *\n                exp(-dr_squared / (2 * self.variance)))\n\n\nclass SimulatedCrystalCounter(PseudoDevice):\n\n    def __init__(self, name, diffractometerScannable, geometryPlugin,\n                 wavelengthScannable, equation=Gaussian(.01), engine=\'you\'):\n        self.setName(name)\n        self.setInputNames([name + \'_count\'])\n        self.setOutputFormat([\'%7.5f\'])\n        self.exposureTime = 1\n        self.pause = True\n        self.diffractometerScannable = diffractometerScannable\n        self.geometry = geometryPlugin\n        self.wavelengthScannable = wavelengthScannable\n        self.equation = equation\n        self.engine = engine\n\n        self.cut = None\n        self.UB = None\n        self.chiMissmount = 0.\n        self.phiMissmount = 0.\n        self.setCrystal(\'cubic\', 1, 1, 1, 90, 90, 90)\n\n    def setCrystal(self, name, a, b, c, alpha, beta, gamma):\n        self.cut = CrystalUnderTest(name, a, b, c, alpha, beta, gamma)\n        self.calcUB()\n\n    def setChiMissmount(self, chi):\n        self.chiMissmount = chi\n        self.calcUB()\n\n    def setPhiMissmount(self, phi):\n        self.phiMissmount = phi\n        self.calcUB()\n\n    def calcUB(self):\n        CHI = calcCHI(self.chiMissmount * TORAD)\n        PHI = calcPHI(self.phiMissmount * TORAD)\n        self.UB = CHI * PHI * self.cut.B\n\n    def asynchronousMoveTo(self, exposureTime):\n        self.exposureTime = exposureTime\n        if self.pause:\n            time.sleep(exposureTime)  # Should not technically block!\n\n    def getPosition(self):\n        h, k, l = self.getHkl()\n        dh, dk, dl = h - round(h), k - round(k), l - round(l)\n        count = self.equation(dh, dk, dl)\n        #return self.exposureTime, count*self.exposureTime\n        return count * self.exposureTime\n\n    def getHkl(self):\n        pos = self.geometry.physical_angles_to_internal_position(\n            self.diffractometerScannable.getPosition())\n        pos.changeToRadians()\n        wavelength = self.wavelengthScannable.getPosition()\n        if self.engine.lower() == \'vlieg\':\n            return vliegAnglesToHkl(pos, wavelength, self.UB)\n        elif self.engine.lower() == \'you\':\n            return youAnglesToHkl(pos, wavelength, self.UB)\n        else:\n            raise ValueError(self.engine)\n\n    def isBusy(self):\n        return False\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        s = \'simulated crystal detector: %s\\n\' % self.getName()\n        h, k, l = self.getHkl()\n        s += \'   h : %f\\n\' % h\n        s += \'   k : %f\\n\' % k\n        s += \'   l : %f\\n\' % l\n        s += self.cut.__str__() + \'\\n\'\n        s += ""chi orientation: %s\\n"" % self.chiMissmount\n        s += ""phi orientation: %s\\n"" % self.phiMissmount\n        ub = self.UB.tolist()\n        s += ""UB:\\n""\n        s += ""     % 18.13f% 18.13f% 18.12f\\n"" % (ub[0][0], ub[0][1], ub[0][2])\n        s += ""     % 18.13f% 18.13f% 18.12f\\n"" % (ub[1][0], ub[1][1], ub[1][2])\n        s += ""     % 18.13f% 18.13f% 18.12f\\n"" % (ub[2][0], ub[2][1], ub[2][2])\n        return s\n'"
diffcalc/gdasupport/scannable/slave_driver.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import  pi, tan, sin, atan, cos, atan2\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nclass SlaveScannableDriver(object):\n\n    def __init__(self, scannables):\n        self.scannables = scannables\n\n    def isBusy(self):\n        for scn in self.scannables:\n            if scn.isBusy():\n                return True\n        return False\n\n    def waitWhileBusy(self):\n        for scn in self.scannables:\n            scn.waitWhileBusy()\n\n    def triggerAsynchronousMove(self, triggerPos):\n        nu = self.slaveFromTriggerPos(triggerPos)\n        for scn in self.scannables:\n            scn.asynchronousMoveTo(nu)\n\n    def getPosition(self):\n        return self.scannables[0].getPosition()\n\n    def slaveFromTriggerPos(self, triggerPos):\n        raise Exception(""Abstract"")\n\n    def getScannableNames(self):\n        return [scn.name for scn in self.scannables]\n\n    def getScannable(self, name):\n        for scn in self.scannables:\n            if scn.getName() == name:\n                return scn\n        return None\n\n    def getOutputFormat(self):\n        return [list(scn.outputFormat)[0] for scn in self.scannables]\n\n    def getPositions(self):\n        return [float(scn.getPosition()) for scn in self.scannables]\n\n\n""""""\nBased on: Elias Vlieg, ""A (2+3)-Type Surface Diffractometer: Mergence of the\nz-axis and (2+2)-Type Geometries"", J. Appl. Cryst. (1998). 31. 198-203\n""""""\n\n\nclass NuDriverForSixCirclePlugin(SlaveScannableDriver):\n\n    def slaveFromTriggerPos(self, triggerPos):\n\n        alpha, delta, gamma, _, _, _ = triggerPos\n        alpha = alpha * TORAD\n        delta = delta * TORAD\n        gamma = gamma * TORAD\n\n        ### Equation16 RHS ###\n        rhs = -1 * tan(gamma - alpha) * sin(delta)\n        nu = atan(rhs)  # -pi/2 <= nu <= pi/2\n        return nu * TODEG\n\n\nclass NuDriverForWillmottHorizontalGeometry(SlaveScannableDriver):\n\n    """"""\n    Based on: Phillip Willmott, ""Angle calculations for a (2+3)-type\n    diffractometer: focus on area detectors"", J. Appl. Cryst. (2011). 44.\n    73-83\n    """"""\n\n    def __init__(self, scannables, area_detector=False):\n        SlaveScannableDriver.__init__(self, scannables)\n        self.area_detector = area_detector\n\n    def slaveFromTriggerPos(self, triggerPos):\n\n        delta, gamma, omegah, _ = triggerPos\n        delta *= TORAD\n        gamma *= TORAD\n        omegah *= TORAD\n        if self.area_detector:\n            nu = atan2(sin(delta - omegah), tan(gamma))                  # (66)\n        else:\n            top = -sin(gamma) * sin(omegah)\n            bot = (sin(omegah) * cos(gamma) * sin(delta) +\n                   cos(omegah) * cos(delta))\n            nu = atan2(top, bot)                                         # (61)\n\n        print \'nu:\', nu * TODEG\n        return nu * TODEG\n'"
diffcalc/gdasupport/scannable/sr2.py,0,"b'###\n# Copyright 2008-2018 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nimport platform\n\nDEBUG = False\n\ntry:\n    from gda.device.scannable.scannablegroup import \\\n        ScannableMotionWithScannableFieldsBase\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import \\\n        ScannableMotionWithScannableFieldsBase\n\nfrom diffcalc.util import getMessageFromException, DiffcalcException, TODEG,\\\n    TORAD\n\n\nclass _DynamicDocstringMetaclass(type):\n\n    def _get_doc(self):\n        return Sr2.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n\nclass Sr2(ScannableMotionWithScannableFieldsBase):\n    \n    if platform.system() != \'Java\':\n        __metaclass__ = _DynamicDocstringMetaclass  # TODO: Removed to fix Jython\n\n    dynamic_docstring = \'sr2 scannable\'\n\n    def _get_doc(self):\n        return Sr2.dynamic_docstring\n\n    __doc__ = property(_get_doc)  # @ReservedAssignment\n\n    def __init__(self, name, diffractometerObject, diffcalcObject,\n                 virtualAnglesToReport=None):\n        self.diffhw = diffractometerObject\n        self._diffcalc = diffcalcObject\n        if type(virtualAnglesToReport) is str:\n            virtualAnglesToReport = (virtualAnglesToReport,)\n        self.vAngleNames = virtualAnglesToReport\n\n        self.setName(name)\n        self.setInputNames([\'h\', \'k\', \'l\', \'azimuthal\'])\n        self.setOutputFormat([\'%7.5f\'] * 4)\n        if self.vAngleNames:\n            self.setExtraNames(self.vAngleNames)\n            self.setOutputFormat([\'%7.5f\'] * (4 + len(self.vAngleNames)))\n\n        self.completeInstantiation()\n        self.setAutoCompletePartialMoveToTargets(True)\n        self.dynamic_class_doc = \'sr2 scannable\'\n\n    def rawAsynchronousMoveTo(self, hkl):\n        if len(hkl) != 4: raise ValueError(\'sr2 device expects four inputs\')\n        try:\n            _hkl_ref = self._diffcalc._ub.ubcalc.get_reflection(1)[0]\n        except IndexError:\n            raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n        az = hkl[-1] * TORAD\n        try:\n            pol, _, sc = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(list(hkl[:3]), _hkl_ref)\n            hkl_sc= [sc * val for val in _hkl_ref]\n            hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*hkl_sc, pol=pol, az=az)\n            (pos, _) = self._diffcalc.hkl_to_angles(*hkl_offset)\n        except DiffcalcException, e:\n            if DEBUG:\n                raise\n            else:\n                raise DiffcalcException(e.message)\n        self.diffhw.asynchronousMoveTo(pos)\n\n    def rawGetPosition(self):\n        pos = self.diffhw.getPosition()  # a tuple\n        (hkl_pos , params) = self._diffcalc.angles_to_hkl(pos)\n        result = list(hkl_pos)\n        try:\n            _hkl_ref = self._diffcalc._ub.ubcalc.get_reflection(1)[0]\n        except IndexError:\n            raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n        _, az, _ = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, _hkl_ref)\n        result.append(az * TODEG)\n        if self.vAngleNames:\n            for vAngleName in self.vAngleNames:\n                result.append(params[vAngleName])\n        return result\n\n    def getFieldPosition(self, i):\n        return self.getPosition()[i]\n\n    def isBusy(self):\n        return self.diffhw.isBusy()\n\n    def waitWhileBusy(self):\n        return self.diffhw.waitWhileBusy()\n\n    def simulateMoveTo(self, hkl):\n        if type(hkl) not in (list, tuple):\n            raise ValueError(\'sr2 device expects four inputs\')\n        if len(hkl) != 4:\n            raise ValueError(\'sr2 device expects four inputs\')\n        az = hkl[-1] * TORAD\n        try:\n            _hkl_ref = self._diffcalc._ub.ubcalc.get_reflection(1)[0]\n        except IndexError:\n            raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n        pol, _, sc = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl[:3], _hkl_ref)\n        hkl_sc= [sc * val for val in _hkl_ref]\n        hkl_offset = self._diffcalc._ub.ubcalc.calc_hkl_offset(*hkl_sc, pol=pol, az=az)\n        (pos, params) = self._diffcalc.hkl_to_angles(*hkl_offset)\n\n        width = max(len(k) for k in (params.keys() + list(self.diffhw.getInputNames())))\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n\n        lines = [\'simulated hkl: %9.4f  %.4f  %.4f\' % (hkl_offset[0],hkl_offset[1],hkl_offset[2]),\n                 self.diffhw.getName() + \' would move to:\']\n        for idx, name in enumerate(self.diffhw.getInputNames()):\n            lines.append(fmt % (name, pos[idx]))\n        lines[-1] = lines[-1] + \'\\n\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        lines = [\'hkl:\']\n        pos = self.diffhw.getPosition()\n        try:\n            _hkl_ref = self._diffcalc._ub.ubcalc.get_reflection(1)[0]\n        except IndexError:\n            raise DiffcalcException(""Please add one reference reflection into the reflection list."")\n        try:\n            (hkl_pos, params) = self._diffcalc.angles_to_hkl(pos)\n            _, az, _ = self._diffcalc._ub.ubcalc.calc_offset_for_hkl(hkl_pos, _hkl_ref)\n        except Exception, e:\n            return ""<sr2: %s>"" % getMessageFromException(e)\n\n        width = max(len(k) for k in params)\n        lines.append(\'  \' + \'sr2\'.rjust(width) + \' : %9.4f  %.4f  %.4f  %.4f\' % (hkl_pos[0],\n                                                                                       hkl_pos[1],\n                                                                                       hkl_pos[2],\n                                                                                       az * TODEG))\n        lines[-1] = lines[-1] + \'\\n\'\n        fmt = \'  %\' + str(width) + \'s : % 9.4f\'\n        for k in sorted(params):\n            lines.append(fmt % (k, params[k]))\n        return \'\\n\'.join(lines)\n'"
diffcalc/gdasupport/scannable/vrmlanimator.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport time\nimport threading\nimport socket\nPORT = 4567\n\nfrom gda.device.scannable import ScannableMotionWithScannableFieldsBaseTest\n\n#import scannable.vrmlModelDriver\n#reload(scannable.vrmlModelDriver);from scannable.vrmlModelDriver import \\\n#     VrmlModelDriver, LinearProfile, MoveThread\n#fc=VrmlModelDriver(\n#    \'fc\',[\'alpha\',\'delta\',\'omega\', \'chi\',\'phi\'], speed=30, host=\'diamrl5104\')\n#alpha = fc.alpha\n#delta = fc.delta\n#omega = fc.omega\n#chi = fc.chi\n#phi = fc.phi\n\n\ndef connect_to_socket(host, port):\n    print ""Connecting to %s on port %d"" % (host, port)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.connect((host, port))\n    print ""Connected""\n    socketfile = sock.makefile(\'rw\', 0)\n    return socketfile\n\n\nclass LinearProfile(object):\n\n    def __init__(self, v, t_accel, startList, endList):\n        assert len(startList) == len(endList)\n        self.v = float(v)\n        self.start = startList\n        self.end = endList\n        self.t_accel = t_accel\n\n        distances = [e - s for e, s in zip(self.end, self.start)]\n        max_distance = max([abs(d) for d in distances])\n        if max_distance == 0:\n            self.delta_time = 0\n        else:\n            self.delta_time = abs(max_distance / self.v)\n            self.speeds = [d / self.delta_time for d in distances]\n        self.start_time = time.time()\n\n    def getPosition(self):\n        if self.start_time is None:\n            return self.start\n        if not self.isMoving():\n            return self.end\n        t = abs(float(time.time() - self.start_time))\n        if t > self.delta_time:\n            # we are in the deceleration phase (i.e paused for now)\n            return self.end\n        return [s + v * t for s, v in zip(self.start, self.speeds)]\n\n    def isMoving(self):\n        return time.time() < self.start_time + self.delta_time + self.t_accel\n\n\nclass MoveThread(threading.Thread):\n\n    def __init__(self, profile, socketfile, axisNames):\n        threading.Thread.__init__(self)\n        self.profile = profile\n        self.socketfile = socketfile\n        self.axisNames = axisNames\n\n    def run(self):\n        while self.profile.isMoving():\n            self.update()\n            time.sleep(.1)\n        self.update()\n\n    def update(self):\n        pos = self.profile.getPosition()\n        d = dict(zip(map(str, self.axisNames), pos))\n        if self.socketfile:\n            self.socketfile.write(repr(d) + \'\\n\')\n\n\nclass VrmlModelDriver(ScannableMotionWithScannableFieldsBaseTest):\n\n    def __init__(self, name, axes_names, host=None, speed=60, t_accel=.1,\n                 format=\'%.3f\'):\n        self.name = name\n        self.inputNames = list(axes_names)\n        self.extraNames = []\n        self.outputFormat = [format] * len(self.inputNames)\n        self.completeInstantiation()\n        self.__last_target = [0.] * len(self.inputNames)\n        self.verbose = False\n        self.move_thread = None\n        self.speed = speed\n        self.host = host\n        self.t_accel = t_accel\n        self.socketfile = None\n        if self.host:\n            try:\n                self.connect()\n            except socket.error:\n                print ""Failed to connect to %s:%r"" % (self.host, PORT)\n                print ""Connect with: %s.connect()"" % self.name\n\n    def connect(self):\n        self.socketfile = connect_to_socket(self.host, PORT)\n        self.rawAsynchronousMoveTo(self.__last_target)\n\n    def isBusy(self):\n        if self.move_thread is None:\n            return False\n        return self.move_thread.profile.isMoving()\n\n    def rawGetPosition(self):\n        if self.move_thread is None:\n            return self.__last_target\n        else:\n            return self.move_thread.profile.getPosition()\n\n    def rawAsynchronousMoveTo(self, targetList):\n        if self.isBusy():\n            raise Exception(self.name + \' is already moving\')\n        if self.verbose:\n            print self.name + "".rawAsynchronousMoveTo(%r)"" % targetList\n\n        for i, target in enumerate(targetList):\n            if target is None:\n                targetList[i] = self.__last_target[i]\n        profile = LinearProfile(\n            self.speed, self.t_accel, self.__last_target, targetList)\n        self.move_thread = MoveThread(\n            profile, self.socketfile, self.inputNames)\n        self.move_thread.start()\n        self.__last_target = targetList\n\n    def getFieldPosition(self, index):\n        return self.getPosition()[index]\n\n    def __del__(self):\n        self.socketfile.close()\n\n#class TrapezoidProfile(object):\n#\n#    def __init__(self, t_accel, v_max, delta_x):\n#        self.t_a = t_accel\n#        self.v_m = v_max\n#        self.delta_x = delta_x\n#\n#        self.t_c = (self.X - self.v_m*self.t_a) / self.v_m\n#\n#    def x(self, t):\n#        if self.t_c <=0:\n#            return self.__xshort(t)\n#        else:\n#            return self.__xlong(t)\n#\n#    def __xshort(self, t):\n#        delta_t = 2 * sqrt(self.delta_x*self.t_a/self.v_m)\n#        if t <= .5*delta_t:\n#            return (.5*self.v_m/self.t_a) * t**2\n#        else:\n#            v_peak = (self.v_m/self.t_a) * .5*delta_t\n#            return (t-.5*delta_t)*v_peak - (t-.5*delta_t)**2 ####HERE, bugged\n#            self.delta_x/2\n'"
diffcalc/gdasupport/scannable/wavelength.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\nclass Wavelength(DummyPD):\n\n    def __init__(self, name, energyScannable,\n                 energyScannableMultiplierToGetKeV=1):\n        self.energyScannable = energyScannable\n        self.energyScannableMultiplierToGetKeV = \\\n            energyScannableMultiplierToGetKeV\n\n        DummyPD.__init__(self, name)\n\n    def asynchronousMoveTo(self, pos):\n        self.energyScannable.asynchronousMoveTo(\n            (12.39842 / pos) / self.energyScannableMultiplierToGetKeV)\n\n    def getPosition(self):\n        energy = self.energyScannable.getPosition()\n        if energy == 0:\n            raise Exception(\n                      ""The energy is 0, so no wavelength could be calculated.run_All()"")\n        return 12.39842 / (energy * self.energyScannableMultiplierToGetKeV)\n\n    def isBusy(self):\n        return self.energyScannable.isBusy()\n\n    def waitWhileBusy(self):\n        return self.energyScannable.waitWhileBusy()\n'"
diffcalc/hkl/vlieg/__init__.py,0,b''
diffcalc/hkl/vlieg/calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, asin, acos, sin, cos, sqrt, atan2, fabs, atan\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\n\nfrom diffcalc.hkl.calcbase import HklCalculatorBase\nfrom diffcalc.hkl.vlieg.transform import TransformCInRadians\nfrom diffcalc.util import dot3, cross3, bound, differ\nfrom diffcalc.hkl.vlieg.geometry import createVliegMatrices, \\\n    createVliegsPsiTransformationMatrix, \\\n    createVliegsSurfaceTransformationMatrices, calcPHI\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition\nfrom diffcalc.hkl.vlieg.constraints import VliegParameterManager\nfrom diffcalc.hkl.vlieg.constraints import ModeSelector\nfrom diffcalc.ub.calc import PaperSpecificUbCalcStrategy\n\n\nTORAD = pi / 180\nTODEG = 180 / pi\ntransformC = TransformCInRadians()\n\n\nPREFER_POSITIVE_CHI_SOLUTIONS = True\n\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\ny = matrix(\'0; 1; 0\')\n\n\ndef check(condition, ErrorOrStringOrCallable, *args):\n    """"""\n    fail = check(condition, ErrorOrString) -- if condition is false raises the\n    Exception passed in, or creates one from a string. If a callable function\n    is passed in this is called with any args specified and the thing returns\n    false.\n    """"""\n    # TODO: Remove (really nasty) check function\n    if condition == False:\n        if callable(ErrorOrStringOrCallable):\n            ErrorOrStringOrCallable(*args)\n            return False\n        elif isinstance(ErrorOrStringOrCallable, str):\n            raise Exception(ErrorOrStringOrCallable)\n        else:  # assume input is an exception\n            raise ErrorOrStringOrCallable\n    return True\n\n\ndef sign(x):\n    if x < 0:\n        return -1\n    else:\n        return 1\n\n\ndef vliegAnglesToHkl(pos, wavelength, UBMatrix):\n    """"""\n    Returns hkl indices from pos object in radians.\n    """"""\n    wavevector = 2 * pi / wavelength\n\n    # Create transformation matrices\n    [ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI] = createVliegMatrices(\n        pos.alpha, pos.delta, pos.gamma, pos.omega, pos.chi, pos.phi)\n\n    # Create the plane normal vector in the alpha axis coordinate frame\n    qa = ((DELTA * GAMMA) - ALPHA.I) * matrix([[0], [wavevector], [0]])\n\n    # Transform the plane normal vector from the alpha frame to reciprical\n    # lattice frame.\n    hkl = UBMatrix.I * PHI.I * CHI.I * OMEGA.I * qa\n\n    return hkl[0, 0], hkl[1, 0], hkl[2, 0]\n\n\nclass VliegUbCalcStrategy(PaperSpecificUbCalcStrategy):\n\n    def calculate_q_phi(self, pos):\n\n        [ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI] = createVliegMatrices(\n           pos.alpha, pos.delta, pos.gamma, pos.omega, pos.chi, pos.phi)\n\n        u1a = (DELTA * GAMMA - ALPHA.I) * y\n        u1p = PHI.I * CHI.I * OMEGA.I * u1a\n        return u1p\n\n\nclass VliegHklCalculator(HklCalculatorBase):\n\n    def __init__(self, ubcalc,\n                 raiseExceptionsIfAnglesDoNotMapBackToHkl=True):\n        r = raiseExceptionsIfAnglesDoNotMapBackToHkl\n        HklCalculatorBase.__init__(self, ubcalc,\n                                   raiseExceptionsIfAnglesDoNotMapBackToHkl=r)\n        self._gammaParameterName = ({\'arm\': \'gamma\', \'base\': \'oopgamma\'}\n                                    [settings.geometry.gamma_location])\n        self.mode_selector = ModeSelector(settings.geometry, None,\n                                          self._gammaParameterName)\n        self.parameter_manager = VliegParameterManager(\n            settings.geometry, settings.hardware, self.mode_selector,\n            self._gammaParameterName)\n        self.mode_selector.setParameterManager(self.parameter_manager)\n\n    def __str__(self):\n        # should list paramemeters and indicate which are used in selected mode\n        result = ""Available mode_selector:\\n""\n        result += self.mode_selector.reportAvailableModes()\n        result += \'\\nCurrent mode:\\n\'\n        result += self.mode_selector.reportCurrentMode()\n        result += \'\\n\\nParameters:\\n\'\n        result += self.parameter_manager.reportAllParameters()\n        return result\n\n    def _anglesToHkl(self, pos, wavelength):\n        """"""\n        Return hkl tuple from VliegPosition in radians and wavelength in\n        Angstroms.\n        """"""\n        return vliegAnglesToHkl(pos, wavelength, self._getUBMatrix())\n\n    def _anglesToVirtualAngles(self, pos, wavelength):\n        """"""\n        Return dictionary of all virtual angles in radians from VliegPosition\n        object win radians and wavelength in Angstroms. The virtual angles are:\n        Bin, Bout, azimuth and 2theta.\n        """"""\n\n        # Create transformation matrices\n        [ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI] = createVliegMatrices(\n            pos.alpha, pos.delta, pos.gamma, pos.omega, pos.chi, pos.phi)\n        [SIGMA, TAU] = createVliegsSurfaceTransformationMatrices(\n            self._getSigma() * TORAD, self._getTau() * TORAD)\n\n        S = TAU * SIGMA\n        y_vector = matrix([[0], [1], [0]])\n\n        # Calculate Bin from equation 15:\n        surfacenormal_alpha = OMEGA * CHI * PHI * S * matrix([[0], [0], [1]])\n        incoming_alpha = ALPHA.I * y_vector\n        minusSinBetaIn = dot3(surfacenormal_alpha, incoming_alpha)\n        Bin = asin(bound(-minusSinBetaIn))\n\n        # Calculate Bout from equation 16:\n        #  surfacenormal_alpha has just ben calculated\n        outgoing_alpha = DELTA * GAMMA * y_vector\n        sinBetaOut = dot3(surfacenormal_alpha, outgoing_alpha)\n        Bout = asin(bound(sinBetaOut))\n\n        # Calculate 2theta from equation 25:\n\n        cosTwoTheta = dot3(ALPHA * DELTA * GAMMA * y_vector, y_vector)\n        twotheta = acos(bound(cosTwoTheta))\n        psi = self._anglesToPsi(pos, wavelength)\n\n        return {\'Bin\': Bin, \'Bout\': Bout, \'azimuth\': psi, \'2theta\': twotheta}\n\n    def _hklToAngles(self, h, k, l, wavelength):\n        """"""\n        Return VliegPosition and virtual angles in radians from h, k & l and\n        wavelength in Angstroms. The virtual angles are those fixed or\n        generated while calculating the position: Bin, Bout and 2theta; and\n        azimuth in four and five circle modes.\n        """"""\n\n        if self._getMode().group in (""fourc"", ""fivecFixedGamma"",\n                                     ""fivecFixedAlpha""):\n            return self._hklToAnglesFourAndFiveCirclesModes(h, k, l,\n                                                            wavelength)\n        elif self._getMode().group == ""zaxis"":\n            return self._hklToAnglesZaxisModes(h, k, l, wavelength)\n        else:\n            raise RuntimeError(\n                \'The current mode (%s) has an unrecognised group: %s.\'\n                 % (self._getMode().name, self._getMode().group))\n\n    def _hklToAnglesFourAndFiveCirclesModes(self, h, k, l, wavelength):\n        """"""\n        Return VliegPosition and virtual angles in radians from h, k & l and\n        wavelength in Angstrom for four and five circle modes. The virtual\n        angles are those fixed or generated while calculating the position:\n        Bin, Bout, 2theta and azimuth.\n        """"""\n\n        # Results in radians during calculations, returned in degreess\n        pos = VliegPosition(None, None, None, None, None, None)\n\n        # Normalise hkl\n        wavevector = 2 * pi / wavelength\n        hklNorm = matrix([[h], [k], [l]]) / wavevector\n\n        # Compute hkl in phi axis coordinate frame\n        hklPhiNorm = self._getUBMatrix() * hklNorm\n\n        # Determine Bin and Bout\n        if self._getMode().name == \'4cPhi\':\n            Bin = Bout = None\n        else:\n            Bin, Bout = self._determineBinAndBoutInFourAndFiveCirclesModes(\n                                                                    hklNorm)\n\n        # Determine alpha and gamma\n        if self._getMode().group == \'fourc\':\n            pos.alpha, pos.gamma = \\\n                self._determineAlphaAndGammaForFourCircleModes(hklPhiNorm)\n        else:\n            pos.alpha, pos.gamma = \\\n                self._determineAlphaAndGammaForFiveCircleModes(Bin, hklPhiNorm)\n        if pos.alpha < -pi:\n            pos.alpha += 2 * pi\n        if pos.alpha > pi:\n            pos.alpha -= 2 * pi\n\n        # Determine delta\n        (pos.delta, twotheta) = self._determineDelta(hklPhiNorm, pos.alpha,\n                                                     pos.gamma)\n\n        # Determine omega, chi & phi\n        pos.omega, pos.chi, pos.phi, psi = \\\n            self._determineSampleAnglesInFourAndFiveCircleModes(\n                hklPhiNorm, pos.alpha, pos.delta, pos.gamma, Bin)\n        # (psi will be None in fixed phi mode)\n\n        # Ensure that by default omega is between -90 and 90, by possibly\n        # transforming the sample angles\n        if self._getMode().name != \'4cPhi\':  # not in fixed-phi mode\n            if pos.omega < -pi / 2 or pos.omega > pi / 2:\n                pos = transformC.transform(pos)\n\n        # Gather up the virtual angles calculated along the way...\n        #   -pi<psi<=pi\n        if psi is not None:\n            if psi > pi:\n                psi -= 2 * pi\n            if psi < (-1 * pi):\n                psi += 2 * pi\n\n        v = {\'2theta\': twotheta, \'Bin\': Bin, \'Bout\': Bout, \'azimuth\': psi}\n        return pos, v\n\n    def _hklToAnglesZaxisModes(self, h, k, l, wavelength):\n        """"""\n        Return VliegPosition and virtual angles in radians from h, k & l and\n        wavelength in Angstroms for z-axis modes. The virtual angles are those\n        fixed or generated while calculating the position: Bin, Bout, and\n        2theta.\n        """"""\n        # Section 6:\n\n        # Results in radians during calculations, returned in degreess\n        pos = VliegPosition(None, None, None, None, None, None)\n\n        # Normalise hkl\n        wavevector = 2 * pi / wavelength\n        hkl = matrix([[h], [k], [l]])\n        hklNorm = hkl * (1.0 / wavevector)\n\n        # Compute hkl in phi axis coordinate frame\n        hklPhi = self._getUBMatrix() * hkl\n        hklPhiNorm = self._getUBMatrix() * hklNorm\n\n        # Determine Chi and Phi (Equation 29):\n        pos.phi = -self._getTau() * TORAD\n        pos.chi = -self._getSigma() * TORAD\n\n        # Equation 30:\n        [ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI] = createVliegMatrices(\n                None, None, None, None, pos.chi, pos.phi)\n        del ALPHA, DELTA, GAMMA, OMEGA\n        Hw = CHI * PHI * hklPhi\n\n        # Determine Bin and Bout:\n        (Bin, Bout) = self._determineBinAndBoutInZaxisModes(\n            Hw[2, 0] / wavevector)\n\n        # Determine Alpha and Gamma (Equation 32):\n        pos.alpha = Bin\n        pos.gamma = Bout\n\n        # Determine Delta:\n        (pos.delta, twotheta) = self._determineDelta(hklPhiNorm, pos.alpha,\n                                                     pos.gamma)\n\n        # Determine Omega:\n        delta = pos.delta\n        gamma = pos.gamma\n        d1 = (Hw[1, 0] * sin(delta) * cos(gamma) - Hw[0, 0] *\n              (cos(delta) * cos(gamma) - cos(pos.alpha)))\n        d2 = (Hw[0, 0] * sin(delta) * cos(gamma) + Hw[1, 0] *\n              (cos(delta) * cos(gamma) - cos(pos.alpha)))\n\n        if fabs(d2) < 1e-30:\n            pos.omega = sign(d1) * sign(d2) * pi / 2.0\n        else:\n            pos.omega = atan2(d1, d2)\n\n        # Gather up the virtual angles calculated along the way\n        return pos, {\'2theta\': twotheta, \'Bin\': Bin, \'Bout\': Bout}\n\n###\n\n    def _determineBinAndBoutInFourAndFiveCirclesModes(self, hklNorm):\n        """"""(Bin, Bout) = _determineBinAndBoutInFourAndFiveCirclesModes()""""""\n        BinModes = (\'4cBin\', \'5cgBin\', \'5caBin\')\n        BoutModes = (\'4cBout\', \'5cgBout\', \'5caBout\')\n        BeqModes = (\'4cBeq\', \'5cgBeq\', \'5caBeq\')\n        azimuthModes = (\'4cAzimuth\')\n        fixedBusingAndLeviWmodes = (\'4cFixedw\')\n\n        # Calculate RHS of equation 20\n        # RHS (1/K)(S^-1*U*B*H)_3 where H/K = hklNorm\n        UB = self._getUBMatrix()\n        [SIGMA, TAU] = createVliegsSurfaceTransformationMatrices(\n            self._getSigma() * TORAD, self._getTau() * TORAD)\n        #S = SIGMA * TAU\n        S = TAU * SIGMA\n        RHS = (S.I * UB * hklNorm)[2, 0]\n\n        if self._getMode().name in BinModes:\n            Bin = self._getParameter(\'betain\')\n            check(Bin != None, ""The parameter betain must be set for mode %s"" %\n                  self._getMode().name)\n            Bin = Bin * TORAD\n            sinBout = RHS - sin(Bin)\n            check(fabs(sinBout) <= 1, ""Could not compute Bout"")\n            Bout = asin(sinBout)\n\n        elif self._getMode().name in BoutModes:\n            Bout = self._getParameter(\'betaout\')\n            check(Bout != None, ""The parameter Bout must be set for mode %s"" %\n                  self._getMode().name)\n            Bout = Bout * TORAD\n            sinBin = RHS - sin(Bout)\n            check(fabs(sinBin) <= 1, ""Could not compute Bin"")\n            Bin = asin(sinBin)\n\n        elif self._getMode().name in BeqModes:\n            sinBeq = RHS / 2\n            check(fabs(sinBeq) <= 1, ""Could not compute Bin=Bout"")\n            Bin = Bout = asin(sinBeq)\n\n        elif self._getMode().name in azimuthModes:\n            azimuth = self._getParameter(\'azimuth\')\n            check(azimuth != None, ""The parameter azimuth must be set for ""\n                  ""mode %s"" % self._getMode().name)\n            del azimuth\n            # TODO: codeit\n            raise NotImplementedError()\n\n        elif self._getMode().name in fixedBusingAndLeviWmodes:\n            bandlomega = self._getParameter(\'blw\')\n            check(bandlomega != None, ""The parameter abandlomega must be set ""\n                  ""for mode %s"" % self._getMode().name)\n            del bandlomega\n            # TODO: codeit\n            raise NotImplementedError()\n        else:\n            raise RuntimeError(""AngleCalculator does not know how to handle ""\n                               ""mode %s"" % self._getMode().name)\n\n        return (Bin, Bout)\n\n    def _determineBinAndBoutInZaxisModes(self, Hw3OverK):\n        """"""(Bin, Bout) = _determineBinAndBoutInZaxisModes(HwOverK)""""""\n        BinModes = (\'6czBin\')\n        BoutModes = (\'6czBout\')\n        BeqModes = (\'6czBeq\')\n\n        if self._getMode().name in BinModes:\n            Bin = self._getParameter(\'betain\')\n            check(Bin != None, ""The parameter betain must be set for mode %s"" %\n                  self._getMode().name)\n            Bin = Bin * TORAD\n            # Equation 32a:\n            Bout = asin(Hw3OverK - sin(Bin))\n\n        elif self._getMode().name in BoutModes:\n            Bout = self._getParameter(\'betaout\')\n            check(Bout != None, ""The parameter Bout must be set for mode %s"" %\n                  self._getMode().name)\n            Bout = Bout * TORAD\n            # Equation 32b:\n            Bin = asin(Hw3OverK - sin(Bout))\n\n        elif self._getMode().name in BeqModes:\n            # Equation 32c:\n            Bin = Bout = asin(Hw3OverK / 2)\n\n        return (Bin, Bout)\n\n###\n\n    def _determineAlphaAndGammaForFourCircleModes(self, hklPhiNorm):\n\n        if self._getMode().group == \'fourc\':\n            alpha = self._getParameter(\'alpha\') * TORAD\n            gamma = self._getParameter(self._getGammaParameterName()) * TORAD\n            check(alpha != None, ""alpha parameter must be set in fourc modes"")\n            check(gamma != None, ""gamma parameter must be set in fourc modes"")\n            return alpha, gamma\n        else:\n            raise RuntimeError(\n                ""determineAlphaAndGammaForFourCirclesModes() ""\n                ""is not appropriate for %s modes"" % self._getMode().group)\n\n    def _determineAlphaAndGammaForFiveCircleModes(self, Bin, hklPhiNorm):\n\n        ## Solve equation 34 for one possible Y, Yo\n        # Calculate surface normal in phi frame\n        [SIGMA, TAU] = createVliegsSurfaceTransformationMatrices(\n            self._getSigma() * TORAD, self._getTau() * TORAD)\n        S = TAU * SIGMA\n        surfaceNormalPhi = S * matrix([[0], [0], [1]])\n        # Compute beta in vector\n        BetaVector = matrix([[0], [-sin(Bin)], [cos(Bin)]])\n        # Find Yo\n        Yo = self._findMatrixToTransformAIntoB(surfaceNormalPhi, BetaVector)\n\n        ## Calculate Hv from equation 39\n        Z = matrix([[1, 0, 0],\n                    [0, cos(Bin), sin(Bin)],\n                    [0, -sin(Bin), cos(Bin)]])\n        Hv = Z * Yo * hklPhiNorm\n        # Fixed gamma:\n        if self._getMode().group == \'fivecFixedGamma\':\n            gamma = self._getParameter(self._getGammaParameterName())\n            check(gamma != None,\n                  ""gamma parameter must be set in fivecFixedGamma modes"")\n            gamma = gamma * TORAD\n            H2 = (hklPhiNorm[0, 0] ** 2 + hklPhiNorm[1, 0] ** 2 +\n                  hklPhiNorm[2, 0] ** 2)\n            a = -(0.5 * H2 * sin(Bin) - Hv[2, 0])\n            b = -(1.0 - 0.5 * H2) * cos(Bin)\n            c = cos(Bin) * sin(gamma)\n            check((b * b + a * a - c * c) >= 0, \'Could not solve for alpha\')\n            alpha = 2 * atan2(-(b + sqrt(b * b + a * a - c * c)), -(a + c))\n\n        # Fixed Alpha:\n        elif self._getMode().group == \'fivecFixedAlpha\':\n            alpha = self._getParameter(\'alpha\')\n            check(alpha != None,\n                  ""alpha parameter must be set in fivecFixedAlpha modes"")\n            alpha = alpha * TORAD\n            H2 = (hklPhiNorm[0, 0] ** 2 + hklPhiNorm[1, 0] ** 2 +\n                  hklPhiNorm[2, 0] ** 2)\n            t0 = ((2 * cos(alpha) * Hv[2, 0] - sin(Bin) * cos(alpha) * H2 +\n                  cos(Bin) * sin(alpha) * H2 - 2 * cos(Bin) * sin(alpha)) /\n                  (cos(Bin) * 2.0))\n            check(abs(t0) <= 1, ""Cannot compute gamma: sin(gamma)>1"")\n            gamma = asin(t0)\n        else:\n            raise RuntimeError(\n                ""determineAlphaAndGammaInFiveCirclesModes() is not ""\n                ""appropriate for %s modes"" % self._getMode().group)\n\n        return (alpha, gamma)\n\n###\n\n    def _determineDelta(self, hklPhiNorm, alpha, gamma):\n        """"""\n        (delta, twotheta) = _determineDelta(hklPhiNorm, alpha, gamma) --\n        computes delta for all modes. Also returns twotheta for sanity\n        checking. hklPhiNorm is a 3X1 matrix.\n\n        alpha, gamma & delta - in radians.\n        h k & l normalised to wavevector and in phi axis coordinates\n        """"""\n        h = hklPhiNorm[0, 0]\n        k = hklPhiNorm[1, 0]\n        l = hklPhiNorm[2, 0]\n        # See Vlieg section 5 (with K=1)\n        cosdelta = ((1 + sin(gamma) * sin(alpha) - (h * h + k * k + l * l) / 2)\n                    / (cos(gamma) * cos(alpha)))\n        costwotheta = (cos(alpha) * cos(gamma) * bound(cosdelta) -\n                       sin(alpha) * sin(gamma))\n        return (acos(bound(cosdelta)), acos(bound(costwotheta)))\n\n    def _determineSampleAnglesInFourAndFiveCircleModes(self, hklPhiNorm, alpha,\n                                                       delta, gamma, Bin):\n        """"""\n        (omega, chi, phi, psi)=determineNonZAxisSampleAngles(hklPhiNorm, alpha,\n        delta, gamma, sigma, tau) where hkl has been normalised by the\n        wavevector and is in the phi Axis coordinate frame. All angles in\n        radians. hklPhiNorm is a 3X1 matrix\n        """"""\n\n        def equation49through59(psi):\n            # equation 49 R = (D^-1)*PI*D*Ro\n            PSI = createVliegsPsiTransformationMatrix(psi)\n            R = D.I * PSI * D * Ro\n\n            #  eq 57: extract omega from R\n            if abs(R[0, 2]) < 1e-20:\n                omega = -sign(R[1, 2]) * sign(R[0, 2]) * pi / 2\n            else:\n                omega = -atan2(R[1, 2], R[0, 2])\n\n            # eq 58: extract chi from R\n            sinchi = sqrt(pow(R[0, 2], 2) + pow(R[1, 2], 2))\n            sinchi = bound(sinchi)\n            check(abs(sinchi) <= 1, \'could not compute chi\')\n            # (there are two roots to this equation, but only the first is also\n            # a solution to R33=cos(chi))\n            chi = asin(sinchi)\n\n            # eq 59: extract phi from R\n            if abs(R[2, 0]) < 1e-20:\n                phi = sign(R[2, 1]) * sign(R[2, 1]) * pi / 2\n            else:\n                phi = atan2(-R[2, 1], -R[2, 0])\n            return omega, chi, phi\n\n        def checkSolution(omega, chi, phi):\n            _, _, _, OMEGA, CHI, PHI = createVliegMatrices(\n                None, None, None, omega, chi, phi)\n            R = OMEGA * CHI * PHI\n            RtimesH_phi = R * H_phi\n            print (""R*H_phi=%s, Q_alpha=%s"" %\n                   (R * H_phi.tolist(), Q_alpha.tolist()))\n            return not differ(RtimesH_phi, Q_alpha, .0001)\n\n        # Using Vlieg section 7.2\n\n        # Needed througout:\n        [ALPHA, DELTA, GAMMA, _, _, _] = createVliegMatrices(\n            alpha, delta, gamma, None, None, None)\n\n        ## Find Ro, one possible solution to equation 46: R*H_phi=Q_alpha\n\n        # Normalise hklPhiNorm (As it is currently normalised only to the\n        # wavevector)\n        normh = norm(hklPhiNorm)\n        check(normh >= 1e-10, ""reciprical lattice vector too close to zero"")\n        H_phi = hklPhiNorm * (1 / normh)\n\n        # Create Q_alpha from equation 47, (it comes normalised)\n        Q_alpha = ((DELTA * GAMMA) - ALPHA.I) * matrix([[0], [1], [0]])\n        Q_alpha = Q_alpha * (1 / norm(Q_alpha))\n\n        if self._getMode().name == \'4cPhi\':\n            ### Use the fixed value of phi as the final constraint ###\n            phi = self._getParameter(\'phi\') * TORAD\n            PHI = calcPHI(phi)\n            H_chi = PHI * H_phi\n            omega, chi = _findOmegaAndChiToRotateHchiIntoQalpha(H_chi, Q_alpha)\n            return (omega, chi, phi, None)  # psi = None as not calculated\n        else:\n            ### Use Bin as the final constraint ###\n\n            # Find a solution Ro to Ro*H_phi=Q_alpha\n            Ro = self._findMatrixToTransformAIntoB(H_phi, Q_alpha)\n\n            ## equation 50: Find a solution D to D*Q=norm(Q)*[[1],[0],[0]])\n            D = self._findMatrixToTransformAIntoB(\n                Q_alpha, matrix([[1], [0], [0]]))\n\n            ## Find psi and create PSI\n\n            # eq 54: compute u=D*Ro*S*[[0],[0],[1]], the surface normal in\n            # psi frame\n            [SIGMA, TAU] = createVliegsSurfaceTransformationMatrices(\n                self._getSigma() * TORAD, self._getTau() * TORAD)\n            S = TAU * SIGMA\n            [u1], [u2], [u3] = (D * Ro * S * matrix([[0], [0], [1]])).tolist()\n            # TODO: If u points along 100, then any psi is a solution. Choose 0\n            if not differ([u1, u2, u3], [1, 0, 0], 1e-9):\n                psi = 0\n                omega, chi, phi = equation49through59(psi)\n            else:\n                # equation 53: V=A*(D^-1)\n                V = ALPHA * D.I\n                v21 = V[1, 0]\n                v22 = V[1, 1]\n                v23 = V[1, 2]\n                # equation 55\n                a = v22 * u2 + v23 * u3\n                b = v22 * u3 - v23 * u2\n                c = -sin(Bin) - v21 * u1  # TODO: changed sign from paper\n\n                # equation 44\n                # Try first root:\n                def myatan2(y, x):\n                    if abs(x) < 1e-20 and abs(y) < 1e-20:\n                        return pi / 2\n                    else:\n                        return atan2(y, x)\n                psi = 2 * myatan2(-(b - sqrt(b * b + a * a - c * c)), -(a + c))\n                #psi = -acos(c/sqrt(a*a+b*b))+atan2(b,a)# -2*pi\n                omega, chi, phi = equation49through59(psi)\n\n            # if u points along z axis, the psi could have been either 0 or 180\n            if (not differ([u1, u2, u3], [0, 0, 1], 1e-9) and\n                abs(psi - pi) < 1e-10):\n                # Choose 0 to match that read up by  angles-to-virtual-angles\n                psi = 0.\n            # if u points a long\n            return (omega, chi, phi, psi)\n\n    def _anglesToPsi(self, pos, wavelength):\n        """"""\n        pos assumed in radians. -180<= psi <= 180\n        """"""\n        # Using Vlieg section 7.2\n\n        # Needed througout:\n        [ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI] = createVliegMatrices(\n                pos.alpha, pos.delta, pos.gamma, pos.omega, pos.chi, pos.phi)\n\n        # Solve equation 49 for psi, the rotation of the a reference solution\n        # about Qalpha or H_phi##\n\n        # Find Ro, the reference solution to equation 46: R*H_phi=Q_alpha\n\n        # Create Q_alpha from equation 47, (it comes normalised)\n        Q_alpha = ((DELTA * GAMMA) - ALPHA.I) * matrix([[0], [1], [0]])\n        Q_alpha = Q_alpha * (1 / norm(Q_alpha))\n\n        # Finh H_phi\n        h, k, l = self._anglesToHkl(pos, wavelength)\n        H_phi = self._getUBMatrix() * matrix([[h], [k], [l]])\n        normh = norm(H_phi)\n        check(normh >= 1e-10, ""reciprical lattice vector too close to zero"")\n        H_phi = H_phi * (1 / normh)\n\n        # Find a solution Ro to Ro*H_phi=Q_alpha\n        # This the reference solution with zero azimuth (psi)\n        Ro = self._findMatrixToTransformAIntoB(H_phi, Q_alpha)\n\n        # equation 48:\n        R = OMEGA * CHI * PHI\n\n        ## equation 50: Find a solution D to D*Q=norm(Q)*[[1],[0],[0]])\n        D = self._findMatrixToTransformAIntoB(Q_alpha, matrix([[1], [0], [0]]))\n\n        # solve equation 49 for psi\n        # D*R = PSI*D*Ro\n        # D*R*(D*Ro)^-1 = PSI\n        PSI = D * R * ((D * Ro).I)\n\n        # Find psi within PSI as defined in equation 51\n        PSI_23 = PSI[1, 2]\n        PSI_33 = PSI[2, 2]\n        psi = atan2(PSI_23, PSI_33)\n\n        #print ""PSI: "", PSI.tolist()\n        return psi\n\n    def _findMatrixToTransformAIntoB(self, a, b):\n        """"""\n        Finds a particular matrix Mo that transforms the unit vector a into the\n        unit vector b. Thats is it finds Mo Mo*a=b. a and b 3x1 matrixes and Mo\n        is a 3x3 matrix.\n\n        Throws an exception if this is not possible.\n            """"""\n        # Maths from the appendix of ""Angle caluculations\n        # for a 5-circle diffractometer used for surface X-ray diffraction"",\n        # E. Vlieg, J.F. van der Veen, J.E. Macdonald and M. Miller, J. of\n        # Applied Cryst. 20 (1987) 330.\n        #                                       - courtesy of Elias Vlieg again\n\n        # equation A2: compute angle xi between vectors a and b\n        cosxi = dot3(a, b)\n        try:\n            cosxi = bound(cosxi)\n        except ValueError:\n            raise Exception(""Could not compute cos(xi), vectors a=%f and b=%f ""\n                            ""must be of unit length"" % (norm(a), norm(b)))\n        xi = acos(cosxi)\n\n        # Mo is identity matrix if xi zero (math below would blow up)\n        if abs(xi) < 1e-10:\n            return I\n\n        # equation A3: c=cross(a,b)/sin(xi)\n        c = cross3(a, b) * (1 / sin(xi))\n\n        # equation A4: find D matrix that transforms a into the frame\n        # x = a; y = c x a; z = c. */\n        a1 = a[0, 0]\n        a2 = a[1, 0]\n        a3 = a[2, 0]\n        c1 = c[0, 0]\n        c2 = c[1, 0]\n        c3 = c[2, 0]\n        D = matrix([[a1, a2, a3],\n                    [c2 * a3 - c3 * a2, c3 * a1 - c1 * a3, c1 * a2 - c2 * a1],\n                    [c1, c2, c3]])\n\n        # equation A5: create Xi to rotate by xi about z-axis\n        XI = matrix([[cos(xi), -sin(xi), 0],\n                     [sin(xi), cos(xi), 0],\n                     [0, 0, 1]])\n\n        # eq A6: compute Mo\n        return D.I * XI * D\n\n\ndef _findOmegaAndChiToRotateHchiIntoQalpha(h_chi, q_alpha):\n    """"""\n    (omega, chi) = _findOmegaAndChiToRotateHchiIntoQalpha(H_chi, Q_alpha)\n\n    Solves for omega and chi in OMEGA*CHI*h_chi = q_alpha where h_chi and\n    q_alpha are 3x1 matrices with unit length. Omega and chi are returned in\n    radians.\n\n    Throws an exception if this is not possible.\n    """"""\n\n    def solve(a, b, c):\n        """"""\n        x1,x2 =  solve(a , b, c)\n        solves for the two solutions to x in equations of the form\n            a*sin(x) + b*cos(x) = c\n        by using the trigonometric identity\n            a*sin(x) + b*cos(x) = a*sin(x)+b*cos(x)=sqrt(a**2+b**2)-sin(x+p)\n        where\n            p = atan(b/a) + {0 if a>=0\n                            {pi if a<0\n        """"""\n        if a == 0:\n            p = pi / 2 if b >= 0 else - pi / 2\n        else:\n            p = atan(b / a)\n        if a < 0:\n            p = p + pi\n        guts = c / sqrt(a ** 2 + b ** 2)\n        if guts < -1:\n            guts = -1\n        elif guts > 1:\n            guts = 1\n        left1 = asin(guts)\n        left2 = pi - left1\n        return (left1 - p, left2 - p)\n\n    def ne(a, b):\n        """"""\n        shifts a and b in between -pi and pi and tests for near equality\n        """"""\n        def shift(a):\n            if a > pi:\n                return a - 2 * pi\n            elif a <= -pi:\n                return a + 2 * pi\n            else:\n                return a\n        return abs(shift(a) - shift(b)) < .0000001\n\n    # 1. Compute some solutions\n    h_chi1 = h_chi[0, 0]\n    h_chi2 = h_chi[1, 0]\n    h_chi3 = h_chi[2, 0]\n    q_alpha1 = q_alpha[0, 0]\n    q_alpha2 = q_alpha[1, 0]\n    q_alpha3 = q_alpha[2, 0]\n\n    try:\n        # a) Solve for chi using Equation 3\n        chi1, chi2 = solve(-h_chi1, h_chi3, q_alpha3)\n\n        # b) Solve for omega Equation 1 and each chi\n        B = h_chi1 * cos(chi1) + h_chi3 * sin(chi1)\n        eq1omega11, eq1omega12 = solve(h_chi2, B, q_alpha1)\n        B = h_chi1 * cos(chi2) + h_chi3 * sin(chi2)\n        eq1omega21, eq1omega22 = solve(h_chi2, B, q_alpha1)\n\n        # c) Solve for omega Equation 2 and each chi\n        A = -h_chi1 * cos(chi1) - h_chi3 * sin(chi1)\n        eq2omega11, eq2omega12 = solve(A, h_chi2, q_alpha2)\n        A = -h_chi1 * cos(chi2) - h_chi3 * sin(chi2)\n        eq2omega21, eq2omega22 = solve(A, h_chi2, q_alpha2)\n\n    except ValueError, e:\n        raise ValueError(\n            str(e) + "":\\nProblem in fixed-phi calculation for:\\nh_chi: "" +\n            str(h_chi.tolist()) + "" q_alpha: "" + str(q_alpha.tolist()))\n\n    # 2. Choose values of chi and omega that are solutions to equations 1 and 2\n    solutions = []\n    # a) Check the chi1 solutions\n    print ""_findOmegaAndChiToRotateHchiIntoQalpha:""\n    if ne(eq1omega11, eq2omega11) or ne(eq1omega11, eq2omega12):\n#        print ""1: eq1omega11, chi1 = "", eq1omega11, chi1\n        solutions.append((eq1omega11, chi1))\n    if ne(eq1omega12, eq2omega11) or ne(eq1omega12, eq2omega12):\n#        print ""2: eq1omega12, chi1 = "", eq1omega12, chi1\n        solutions.append((eq1omega12, chi1))\n    # b) Check the chi2 solutions\n    if ne(eq1omega21, eq2omega21) or ne(eq1omega21, eq2omega22):\n#        print ""3: eq1omega21, chi2 = "", eq1omega21, chi2\n        solutions.append((eq1omega21, chi2))\n    if ne(eq1omega22, eq2omega21) or ne(eq1omega22, eq2omega22):\n#        print ""4: eq1omega22, chi2 = "", eq1omega22, chi2\n        solutions.append((eq1omega22, chi2))\n#    print solutions\n#    print ""*""\n\n    if len(solutions) == 0:\n        e = ""h_chi: "" + str(h_chi.tolist())\n        e += "" q_alpha: "" + str(q_alpha.tolist())\n        e += (""\\nchi1:%4f eq1omega11:%4f eq1omega12:%4f eq2omega11:%4f ""\n              ""eq2omega12:%4f"" % (chi1 * TODEG, eq1omega11 * TODEG,\n              eq1omega12 * TODEG, eq2omega11 * TODEG, eq2omega12 * TODEG))\n        e += (""\\nchi2:%4f eq1omega21:%4f eq1omega22:%4f eq2omega21:%4f ""\n              ""eq2omega22:%4f"" % (chi2 * TODEG, eq1omega21 * TODEG,\n              eq1omega22 * TODEG, eq2omega21 * TODEG, eq2omega22 * TODEG))\n        raise Exception(""Could not find simultaneous solution for this fixed ""\n                        ""phi mode problem\\n"" + e)\n\n    if not PREFER_POSITIVE_CHI_SOLUTIONS:\n        return solutions[0]\n\n    positive_chi_solutions = [sol for sol in solutions if sol[1] > 0]\n\n    if len(positive_chi_solutions) == 0:\n        print ""WARNING: A +ve chi solution was requested, but none were found.""\n        print ""         Returning a -ve one. Try the mapper""\n        return solutions[0]\n\n    if len(positive_chi_solutions) > 1:\n        print (""INFO: Multiple +ve chi solutions were found [(omega, chi) ...]""\n             "" = "" + str(positive_chi_solutions))\n        print ""      Returning the first""\n\n    return positive_chi_solutions[0]\n'"
diffcalc/hkl/vlieg/constraints.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom copy import copy\n\nfrom diffcalc.util import DiffcalcException\n\n\nclass Mode(object):\n\n    def __init__(self, index, name, group, description, parameterNames,\n                 implemented=True):\n        self.index = index\n        self.group = group\n        self.name = name\n        self.description = description\n        self.parameterNames = parameterNames\n        self.implemented = implemented\n\n    def __repr__(self):\n        return ""%i) %s"" % (self.index, self.description)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def usesParameter(self, name):\n        return name in self.parameterNames\n\n\nclass ModeSelector(object):\n\n    def __init__(self, geometry, parameterManager=None,\n                 gammaParameterName=\'gamma\'):\n        self.parameter_manager = parameterManager\n        self._geometry = geometry\n        self._gammaParameterName = gammaParameterName\n        self._modelist = {}  # indexed by non-contiguous mode number\n        self._configureAvailableModes()\n        self._selectedIndex = 1\n\n    def setParameterManager(self, manager):\n        """"""\n        Required as a ParameterManager and ModelSelector are mutually tied\n        together in practice\n        """"""\n        self.parameter_manager = manager\n\n    def _configureAvailableModes(self):\n\n        gammaName = self._gammaParameterName\n\n        ml = self._modelist\n\n        ml[0] = Mode(0, \'4cFixedw\', \'fourc\', \'fourc fixed-bandlw\',\n                     [\'alpha\', gammaName, \'blw\'], False)\n\n        ml[1] = Mode(1, \'4cBeq\', \'fourc\', \'fourc bisecting\',\n                     [\'alpha\', gammaName])\n\n        ml[2] = Mode(2, \'4cBin\', \'fourc\', \'fourc incoming\',\n                     [\'alpha\', gammaName, \'betain\'])\n\n        ml[3] = Mode(3, \'4cBout\', \'fourc\', \'fourc outgoing\',\n                     [\'alpha\', gammaName, \'betaout\'])\n\n        ml[4] = Mode(4, \'4cAzimuth\', \'fourc\', \'fourc azimuth\',\n                     [\'alpha\', gammaName, \'azimuth\'], False)\n\n        ml[5] = Mode(5, \'4cPhi\', \'fourc\', \'fourc fixed-phi\',\n                     [\'alpha\', gammaName, \'phi\'])\n\n        ml[10] = Mode(10, \'5cgBeq\', \'fivecFixedGamma\', \'fivec bisecting\',\n                      [gammaName])\n\n        ml[11] = Mode(11, \'5cgBin\', \'fivecFixedGamma\', \'fivec incoming\',\n                      [gammaName, \'betain\'])\n\n        ml[12] = Mode(12, \'5cgBout\', \'fivecFixedGamma\', \'fivec outgoing\',\n                      [gammaName, \'betaout\'])\n\n        ml[13] = Mode(13, \'5caBeq\', \'fivecFixedAlpha\', \'fivec bisecting\',\n                      [\'alpha\'])\n\n        ml[14] = Mode(14, \'5caBin\', \'fivecFixedAlpha\', \'fivec incoming\',\n                      [\'alpha\', \'betain\'])\n\n        ml[15] = Mode(15, \'5caBout\', \'fivecFixedAlpha\', \'fivec outgoing\',\n                      [\'alpha\', \'betaout\'])\n\n        ml[20] = Mode(20, \'6czBeq\', \'zaxis\', \'zaxis bisecting\',\n                      [])\n\n        ml[21] = Mode(21, \'6czBin\', \'zaxis\', \'zaxis incoming\',\n                                  [\'betain\'])\n\n        ml[22] = Mode(22, \'6czBout\', \'zaxis\', \'zaxiz outgoing\',\n                                  [\'betaout\'])\n\n    def setModeByIndex(self, index):\n        if index in self._modelist:\n            self._selectedIndex = index\n        else:\n            raise DiffcalcException(""mode %r is not defined"" % index)\n\n    def setModeByName(self, name):\n        def findModeWithName(name):\n            for index, mode in self._modelist.items():\n                if mode.name == name:\n                    return index, mode\n            raise ValueError\n\n        try:\n            index, mode = findModeWithName(name)\n        except ValueError:\n            raise DiffcalcException(\n                \'Unknown mode. The diffraction calculator supports these \'\n                \'modeSelector: %s\' % self._supportedModes.keys())\n        if  self._geometry.supports_mode_group(mode.group):\n            self._selectedIndex = index\n        else:\n            raise DiffcalcException(\n                ""Mode %s not supported for this diffractometer (%s)."" %\n                (name, self._geometry.name))\n\n    def getMode(self):\n        return self._modelist[self._selectedIndex]\n\n    def reportCurrentMode(self):\n        return self.getMode().__str__()\n\n    def reportAvailableModes(self):\n        result = \'\'\n        indecis = self._modelist.keys()\n        indecis.sort()\n        for index in indecis:\n            mode = self._modelist[index]\n            if self._geometry.supports_mode_group(mode.group):\n                paramString = \'\'\n                flags = \'\'\n                pm = self.parameter_manager\n                for paramName in pm.getUserChangableParametersForMode(mode):\n                    paramString += paramName + "", ""\n                if paramString:\n                    paramString = paramString[:-2]  # remove trailing commas\n                if not mode.implemented:\n                    flags += ""(Not impl.)""\n                result += (\'%2i) %-15s (%s) %s\\n\' % (mode.index,\n                           mode.description, paramString, flags))\n        return result\n\n\nclass VliegParameterManager(object):\n\n    def __init__(self, geometry, hardware, modeSelector,\n                 gammaParameterName=\'gamma\'):\n        self._geometry = geometry\n        self._hardware = hardware\n        self._modeSelector = modeSelector\n        self._gammaParameterName = gammaParameterName\n        self._parameters = {}\n        self._defineParameters()\n\n    def _defineParameters(self):\n        # Set default fixed values (In degrees if angles)\n        self._parameters = {}\n        self._parameters[\'alpha\'] = 0\n        self._parameters[self._gammaParameterName] = 0\n        self._parameters[\'blw\'] = None  # Busing and Levi omega!\n        self._parameters[\'betain\'] = None\n        self._parameters[\'betaout\'] = None\n        self._parameters[\'azimuth\'] = None\n        self._parameters[\'phi\'] = None\n\n        self._parameterDisplayOrder = (\n            \'alpha\', self._gammaParameterName, \'betain\', \'betaout\', \'azimuth\',\n            \'phi\', \'blw\')\n        self._trackableParameters = (\'alpha\', self._gammaParameterName, \'phi\')\n        self._trackedParameters = []\n\n        # Overide parameters that are unchangable for this diffractometer\n        for (name, value) in self._geometry.fixed_parameters.items():\n            if name not in self._parameters:\n                raise RuntimeError(\n                    ""The %s diffractometer geometry specifies a fixed ""\n                    ""parameter %s that is not used by the diffractometer ""\n                    ""calculator"" % (self._geometry.getName, name))\n            self._parameters[name] = value\n\n    def reportAllParameters(self):\n        self.update_tracked()\n        result = \'\'\n        for name in self._parameterDisplayOrder:\n            flags = """"\n            if not self._modeSelector.getMode().usesParameter(name):\n                flags += \'(not relevant in this mode)\'\n            if self._geometry.parameter_fixed(name):\n                flags += \' (fixed by this diffractometer)\'\n            if self.isParameterTracked(name):\n                flags += \' (tracking hardware)\'\n            value = self._parameters[name]\n            if value is None:\n                value = \'---\'\n            else:\n                value = float(value)\n            result += \'%s: %s %s\\n\' % (name.rjust(8), value, flags)\n        return result\n\n    def reportParametersUsedInCurrentMode(self):\n        self.update_tracked()\n        result = \'\'\n        for name in self.getUserChangableParametersForMode(\n            self._modeSelector.getMode()):\n            flags = """"\n            value = self._parameters[name]\n            if value is None:\n                value = \'---\'\n            else:\n                value = float(value)\n            if self.isParameterTracked(name):\n                flags += \' (tracking hardware)\'\n            result += \'%s: %s %s\\n\' % (name.rjust(8), value, flags)\n        return result\n\n    def getUserChangableParametersForMode(self, mode=None):\n        """"""\n        (p1,p2...p3) = getUserChangableParametersForMode(mode) returns a list\n        of parameters names used in this mode for this diffractometer geometry.\n        Checks current mode if no mode specified.\n        """"""\n        if mode is None:\n            mode = self._mode\n        result = []\n        for name in self._parameterDisplayOrder:\n            if self._isParameterChangeable(name, mode):\n                result += [name]\n        return result\n\n### Fixed parameters stuff ###\n\n    def set_constraint(self, name, value):\n        if not name in self._parameters:\n            raise DiffcalcException(""No fixed parameter %s is used by the ""\n                                    ""diffraction calculator"" % name)\n        if self._geometry.parameter_fixed(name):\n            raise DiffcalcException(\n                ""The parameter %s cannot be changed: It has been fixed by the ""\n                ""%s diffractometer geometry""\n                % (name, self._geometry.name))\n        if self.isParameterTracked(name):\n            # for safety and to avoid confusion:\n            raise DiffcalcException(\n                ""Cannot change parameter %s as it is set to track an axis.\\n""\n                ""To turn this off use a command like \'trackalpha 0\'."" % name)\n\n        if not self.isParameterUsedInSelectedMode(name):\n            print (""WARNING: The parameter %s is not used in mode %i"" %\n                   (name, self._modeSelector.getMode().index))\n        self._parameters[name] = value\n\n    def isParameterUsedInSelectedMode(self, name):\n        return self._modeSelector.getMode().usesParameter(name)\n\n    def getParameterWithoutUpdatingTrackedParemeters(self, name):\n        try:\n            return self._parameters[name]\n        except KeyError:\n            raise DiffcalcException(""No fixed parameter %s is used by the ""\n                                    ""diffraction calculator"" % name)\n\n    def get_constraint(self, name):\n        self.update_tracked()\n        return self.getParameterWithoutUpdatingTrackedParemeters(name)\n\n    def getParameterDict(self):\n        self.update_tracked()\n        return copy(self._parameters)\n\n    @property\n    def settable_constraint_names(self):\n        """"""list of all available constraints that have settable values""""""\n        return sorted(self.getParameterDict().keys())\n\n    def setTrackParameter(self, name, switch):\n        if not name in self._parameters.keys():\n            raise DiffcalcException(""No fixed parameter %s is used by the ""\n                                    ""diffraction calculator"" % name)\n        if not name in self._trackableParameters:\n            raise DiffcalcException(""Parameter %s is not trackable"" % name)\n        if not self._isParameterChangeable(name):\n            print (""WARNING: Parameter %s is not used in mode %i"" %\n                   (name, self._mode.index))\n        if switch:\n            if name not in self._trackedParameters:\n                self._trackedParameters.append(name)\n        else:\n            if name in self._trackedParameters:\n                self._trackedParameters.remove(name)\n\n    def isParameterTracked(self, name):\n        return (name in self._trackedParameters)\n\n    def update_tracked(self):\n        """"""Note that the name of a tracked parameter MUST map into the name of\n        an external diffractometer angle\n        """"""\n        if self._trackedParameters:\n            externalAnglePositionArray = self._hardware.get_position()\n            externalAngleNames = list(self._hardware.get_axes_names())\n            for name in self._trackedParameters:\n                self._parameters[name] = \\\n                    externalAnglePositionArray[externalAngleNames.index(name)]\n\n    def _isParameterChangeable(self, name, mode=None):\n        """"""\n        Returns true if parameter is used in a mode (current mode if none\n        specified), AND if it is not locked by the diffractometer geometry\n        """"""\n        if mode is None:\n            mode = self._modeSelector.getMode()\n        return (mode.usesParameter(name) and\n                not self._geometry.parameter_fixed(name))\n'"
diffcalc/hkl/vlieg/geometry.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import tan, cos, sin, asin, atan, pi, fabs\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.util import x_rotation, z_rotation, y_rotation\nfrom diffcalc.util import AbstractPosition\nfrom diffcalc.util import bound, nearlyEqual\n\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\ndef calcALPHA(alpha):\n    return x_rotation(alpha)\n\n\ndef calcDELTA(delta):\n    return z_rotation(-delta)\n\n\ndef calcGAMMA(gamma):\n    return x_rotation(gamma)\n\n\ndef calcOMEGA(omega):\n    return z_rotation(-omega)\n\n\ndef calcCHI(chi):\n    return y_rotation(chi)\n\n\ndef calcPHI(phi):\n    return z_rotation(-phi)\n\n\ndef createVliegMatrices(alpha=None, delta=None, gamma=None, omega=None,\n                        chi=None, phi=None):\n\n    ALPHA = None if alpha is None else calcALPHA(alpha)\n    DELTA = None if delta is None else calcDELTA(delta)\n    GAMMA = None if gamma is None else calcGAMMA(gamma)\n    OMEGA = None if omega is None else calcOMEGA(omega)\n    CHI = None if chi is None else calcCHI(chi)\n    PHI = None if phi is None else calcPHI(phi)\n    return ALPHA, DELTA, GAMMA, OMEGA, CHI, PHI\n\n\ndef createVliegsSurfaceTransformationMatrices(sigma, tau):\n    """"""[SIGMA, TAU] = createVliegsSurfaceTransformationMatrices(sigma, tau)\n    angles in radians\n    """"""\n    SIGMA = matrix([[cos(sigma), 0, sin(sigma)],\n                    [0, 1, 0], \\\n                    [-sin(sigma), 0, cos(sigma)]])\n\n    TAU = matrix([[cos(tau), sin(tau), 0],\n                  [-sin(tau), cos(tau), 0],\n                  [0, 0, 1]])\n    return(SIGMA, TAU)\n\n\ndef createVliegsPsiTransformationMatrix(psi):\n    """"""PSI = createPsiTransformationMatrices(psi)\n    angles in radians\n    """"""\n    return matrix([[1, 0, 0],\n                   [0, cos(psi), sin(psi)],\n                   [0, -sin(psi), cos(psi)]])\n\n\nclass VliegPosition(AbstractPosition):\n    """"""The position of all six diffractometer axis""""""\n    def __init__(self, alpha=None, delta=None, gamma=None, omega=None,\n                 chi=None, phi=None):\n        self.alpha = alpha\n        self.delta = delta\n        self.gamma = gamma\n        self.omega = omega\n        self.chi = chi\n        self.phi = phi\n\n    def clone(self):\n        return VliegPosition(self.alpha, self.delta, self.gamma, self.omega,\n                             self.chi, self.phi)\n\n    def changeToRadians(self):\n        self.alpha *= TORAD\n        self.delta *= TORAD\n        self.gamma *= TORAD\n        self.omega *= TORAD\n        self.chi *= TORAD\n        self.phi *= TORAD\n\n    def changeToDegrees(self):\n        self.alpha *= TODEG\n        self.delta *= TODEG\n        self.gamma *= TODEG\n        self.omega *= TODEG\n        self.chi *= TODEG\n        self.phi *= TODEG\n\n    def inRadians(self):\n        pos = self.clone()\n        pos.changeToRadians()\n        return pos\n\n    def inDegrees(self):\n        pos = self.clone()\n        pos.changeToDegrees()\n        return pos\n\n    def nearlyEquals(self, pos2, maxnorm):\n        for a, b in zip(self.totuple(), pos2.totuple()):\n            if abs(a - b) > maxnorm:\n                return False\n        return True\n\n    def totuple(self):\n        return (self.alpha, self.delta, self.gamma, self.omega,\n                self.chi, self.phi)\n\n    def __str__(self):\n        return (""VliegPosition(alpha %r delta: %r gamma: %r omega: %r chi: %r""\n                ""  phi: %r)"" % self.totuple())\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __eq__(self, b):\n        return self.nearlyEquals(b, .001)\n\n\nclass VliegGeometry(object):\n\n# Required methods\n\n    def __init__(self, name, supported_mode_groups, fixed_parameters,\n                 gamma_location):\n        """"""\n        Set geometry name (String), list of supported mode groups (list of\n        strings), list of axis names (list of strings). Define the parameters\n        e.g. alpha and gamma for a four circle (dictionary). Define wether the\n        gamma angle is on the \'arm\' or the \'base\'; used only by AngleCalculator\n        to interpret the gamma parameter in fixed gamma mode: for instruments\n        with gamma on the base, rather than on the arm as the code assume\n        internally, the two methods physical_angles_to_internal_position and\n        internal_position_to_physical_angles must still be used.\n        """"""\n        if gamma_location not in (\'arm\', \'base\', None):\n            raise RuntimeError(\n                ""Gamma must be on either \'arm\' or \'base\' or None"")\n\n        self.name = name\n        self.supported_mode_groups = supported_mode_groups\n        self.fixed_parameters = fixed_parameters\n        self.gamma_location = gamma_location\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        raise NotImplementedError()\n\n    def internal_position_to_physical_angles(self, physicalAngles):\n        raise NotImplementedError()\n\n### Do not overide these these ###\n\n    def supports_mode_group(self, name):\n        return name in self.supported_mode_groups\n\n    def parameter_fixed(self, name):  # parameter_fixed\n        return name in self.fixed_parameters.keys()\n\n\nclass SixCircleGammaOnArmGeometry(VliegGeometry):\n    """"""\n    This six-circle diffractometer geometry simply passes through the\n    angles from a six circle diffractometer with the same geometry and\n    angle names as those defined in Vliegs\'s paper defined internally.\n    """"""\n\n    def __init__(self):\n        VliegGeometry.__init__(\n            self,\n            name=\'sixc_gamma_on_arm\',\n            supported_mode_groups=(\'fourc\', \'fivecFixedGamma\',\n                                    \'fivecFixedAlpha\', \'zaxis\'),\n            fixed_parameters={},\n            gamma_location=\'arm\')\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        assert (len(physicalAngles) == 6), ""Wrong length of input list""\n        return VliegPosition(*physicalAngles)\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        return internalPosition.totuple()\n\n\nclass SixCircleGeometry(VliegGeometry):\n    """"""\n    This six-circle diffractometer geometry simply passes through the\n    angles from a six circle diffractometer with the same geometry and\n    angle names as those defined in Vliegs\'s paper defined internally.\n    """"""\n\n    def __init__(self):\n        VliegGeometry.__init__(\n            self,\n            name=\'sixc\',\n            supported_mode_groups=(\'fourc\', \'fivecFixedGamma\',\n                                    \'fivecFixedAlpha\', \'zaxis\'),\n            fixed_parameters={},\n            gamma_location=\'base\')\n        self.hardwareMonitor = None\n#(deltaA, gammaA) = gammaOnBaseToArm(deltaB, gammaB, alpha) (all in radians)\n#(deltaB, gammaB) = gammaOnArmToBase(deltaA, gammaA, alpha) (all in radians)\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        assert (len(physicalAngles) == 6), ""Wrong length of input list""\n        alpha, deltaB, gammaB, omega, chi, phi = physicalAngles\n        (deltaA, gammaA) = gammaOnBaseToArm(\n            deltaB * TORAD, gammaB * TORAD, alpha * TORAD)\n        return VliegPosition(\n            alpha, deltaA * TODEG, gammaA * TODEG, omega, chi, phi)\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        alpha, deltaA, gammaA, omega, chi, phi = internalPosition.totuple()\n        deltaB, gammaB = gammaOnArmToBase(\n            deltaA * TORAD, gammaA * TORAD, alpha * TORAD)\n        deltaB, gammaB = deltaB * TODEG, gammaB * TODEG\n\n        if self.hardwareMonitor is not None:\n            gammaName = self.hardwareMonitor.get_axes_names()[2]\n            minGamma = self.hardwareMonitor.get_lower_limit(gammaName)\n            maxGamma = self.hardwareMonitor.get_upper_limit(gammaName)\n\n            if maxGamma is not None:\n                if gammaB > maxGamma:\n                    gammaB = gammaB - 180\n                    deltaB = 180 - deltaB\n            if minGamma is not None:\n                if gammaB < minGamma:\n                    gammaB = gammaB + 180\n                    deltaB = 180 - deltaB\n\n        return alpha, deltaB, gammaB, omega, chi, phi\n\n\nclass FivecWithGammaOnBase(SixCircleGeometry):\n\n    def __init__(self):\n        VliegGeometry.__init__(\n            self,\n            name=\'fivec_with_gamma\',\n            supported_mode_groups=(\'fourc\', \'fivecFixedGamma\'),\n            fixed_parameters={\'alpha\': 0.0},\n            gamma_location=\'base\')\n        self.hardwareMonitor = None\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(d,g,o,c,p)\n        """"""\n        assert (len(physicalAngles) == 5), ""Wrong length of input list""\n        return SixCircleGeometry.physical_angles_to_internal_position(\n            self, (0,) + tuple(physicalAngles))\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        """""" (d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        return SixCircleGeometry.internal_position_to_physical_angles(\n            self, internalPosition)[1:]\n\n\nclass Fivec(VliegGeometry):\n    """"""\n    This five-circle diffractometer geometry is for diffractometers with the\n    same geometry and angle names as those defined in Vliegs\'s paper defined\n    internally, but with no out plane detector arm  gamma.""""""\n\n    def __init__(self):\n        VliegGeometry.__init__(self,\n                    name=\'fivec\',\n                    supported_mode_groups=(\'fourc\', \'fivecFixedGamma\'),\n                    fixed_parameters={\'gamma\': 0.0},\n                    gamma_location=\'arm\'\n        )\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        assert (len(physicalAngles) == 5), ""Wrong length of input list""\n        physicalAngles = tuple(physicalAngles)\n        angles = physicalAngles[0:2] + (0.0,) + physicalAngles[2:]\n        return VliegPosition(*angles)\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        sixAngles = internalPosition.totuple()\n        return sixAngles[0:2] + sixAngles[3:]\n\n\nclass Fourc(VliegGeometry):\n    """"""\n    This five-circle diffractometer geometry is for diffractometers with the\n    same geometry and angle names as those defined in Vliegs\'s paper defined\n    internally, but with no out plane detector arm  gamma.""""""\n\n    def __init__(self):\n        VliegGeometry.__init__(self,\n                    name=\'fourc\',\n                    supported_mode_groups=(\'fourc\'),\n                    fixed_parameters={\'gamma\': 0.0, \'alpha\': 0.0},\n                    gamma_location=\'arm\'\n        )\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        assert (len(physicalAngles) == 4), ""Wrong length of input list""\n        physicalAngles = tuple(physicalAngles)\n        angles = (0.0, physicalAngles[0], 0.0) + physicalAngles[1:]\n        return VliegPosition(*angles)\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        """""" (a,d,g,o,c,p) = physicalAnglesToInternal(a,d,g,o,c,p)\n        """"""\n        sixAngles = internalPosition.totuple()\n        return sixAngles[1:2] + sixAngles[3:]\n\n\ndef sign(x):\n    if x < 0:\n        return -1\n    else:\n        return 1\n\n""""""\nBased on: Elias Vlieg, ""A (2+3)-Type Surface Diffractometer: Mergence of\nthe z-axis and (2+2)-Type Geometries"", J. Appl. Cryst. (1998). 31.\n198-203\n""""""\n\n\ndef solvesEq8(alpha, deltaA, gammaA, deltaB, gammaB):\n    tol = 1e-6\n    return (nearlyEqual(sin(deltaA) * cos(gammaA), sin(deltaB), tol) and\n        nearlyEqual(cos(deltaA) * cos(gammaA),\n                    cos(gammaB - alpha) * cos(deltaB), tol) and\n        nearlyEqual(sin(gammaA), sin(gammaB - alpha) * cos(deltaB), tol))\n\n\nGAMMAONBASETOARM_WARNING = \'\'\'\nWARNING: This diffractometer has the gamma circle attached to the\n         base rather than the end of\n         the delta arm as Vlieg\'s paper defines. A conversion has\n         been made from the physical angles to their internal\n         representation (gamma-on-base-to-arm). This conversion has\n         forced gamma to be positive by applying the mapping:\n\n         delta --> 180+delta\n         gamma --> 180+gamma.\n\n         This should have no adverse effect.\n\'\'\'\n\n\ndef gammaOnBaseToArm(deltaB, gammaB, alpha):\n    """"""\n    (deltaA, gammaA) = gammaOnBaseToArm(deltaB, gammaB, alpha) (all in\n    radians)\n\n    Maps delta and gamma for an instrument where the gamma circle rests on\n    the base to the case where it is on the delta arm.\n\n    There are always two possible solutions. To get the second apply the\n    transform:\n\n        delta --> 180+delta (flip to opposite side of circle)\n        gamma --> 180+gamma (flip to opposite side of circle)\n\n    This code will return the solution where gamma is between 0 and 180.\n    """"""\n\n    ### Equation11 ###\n    if fabs(cos(gammaB - alpha)) < 1e-20:\n        deltaA1 = sign(tan(deltaB)) * sign(cos(gammaB - alpha)) * pi / 2\n    else:\n        deltaA1 = atan(tan(deltaB) / cos(gammaB - alpha))\n    # ...second root\n    if deltaA1 <= 0:\n        deltaA2 = deltaA1 + pi\n    else:\n        deltaA2 = deltaA1 - pi\n\n    ### Equation 12 ###\n    gammaA1 = asin(bound(cos(deltaB) * sin(gammaB - alpha)))\n    # ...second root\n    if gammaA1 >= 0:\n        gammaA2 = pi - gammaA1\n    else:\n        gammaA2 = -pi - gammaA1\n\n    # Choose the delta solution that fits equations 8\n    if solvesEq8(alpha, deltaA1, gammaA1, deltaB, gammaB):\n        deltaA, gammaA = deltaA1, gammaA1\n    elif solvesEq8(alpha, deltaA2, gammaA1, deltaB, gammaB):\n        deltaA, gammaA = deltaA2, gammaA1\n        print ""gammaOnBaseToArm choosing 2nd delta root (to internal)""\n    elif solvesEq8(alpha, deltaA1, gammaA2, deltaB, gammaB):\n        print ""gammaOnBaseToArm choosing 2nd gamma root (to internal)""\n        deltaA, gammaA = deltaA1, gammaA2\n    elif solvesEq8(alpha, deltaA2, gammaA2, deltaB, gammaB):\n        print ""gammaOnBaseToArm choosing 2nd delta root and 2nd gamma root""\n        deltaA, gammaA = deltaA2, gammaA2\n    else:\n        raise RuntimeError(\n         ""No valid solutions found mapping from gamma-on-base to gamma-on-arm"")\n\n    return deltaA, gammaA\n\nGAMMAONARMTOBASE_WARNING = \'\'\'\n        WARNING: This diffractometer has the gamma circle attached to the base\n                 rather than the end of the delta arm as Vlieg\'s paper defines.\n                 A conversion has been made from the internal representation of\n                 angles to physical angles (gamma-on-arm-to-base). This\n                 conversion has forced gamma to be positive by applying the\n                 mapping:\n\n                    delta --> 180-delta\n                    gamma --> 180+gamma.\n\n                 This should have no adverse effect.\n\'\'\'\n\n\ndef gammaOnArmToBase(deltaA, gammaA, alpha):\n    """"""\n    (deltaB, gammaB) = gammaOnArmToBase(deltaA, gammaA, alpha) (all in\n    radians)\n\n    Maps delta and gamma for an instrument where the gamma circle is on\n    the delta arm to the case where it rests on the base.\n\n    There are always two possible solutions. To get the second apply the\n    transform:\n\n        delta --> 180-delta (reflect and flip to opposite side)\n        gamma --> 180+gamma (flip to opposite side)\n\n    This code will return the solution where gamma is positive, but will\n    warn if a sign change was made.\n    """"""\n\n    ### Equation 9 ###\n    deltaB1 = asin(bound(sin(deltaA) * cos(gammaA)))\n    # ...second root:\n    if deltaB1 >= 0:\n        deltaB2 = pi - deltaB1\n    else:\n        deltaB2 = -pi - deltaB1\n\n    ### Equation 10 ###:\n    if fabs(cos(deltaA)) < 1e-20:\n        gammaB1 = sign(tan(gammaA)) * sign(cos(deltaA)) * pi / 2 + alpha\n    else:\n        gammaB1 = atan(tan(gammaA) / cos(deltaA)) + alpha\n    #... second root:\n    if gammaB1 <= 0:\n        gammaB2 = gammaB1 + pi\n    else:\n        gammaB2 = gammaB1 - pi\n\n    ### Choose the solution that fits equation 8 ###\n    if (solvesEq8(alpha, deltaA, gammaA, deltaB1, gammaB1) and\n        0 <= gammaB1 <= pi):\n        deltaB, gammaB = deltaB1, gammaB1\n    elif (solvesEq8(alpha, deltaA, gammaA, deltaB2, gammaB1) and\n          0 <= gammaB1 <= pi):\n        deltaB, gammaB = deltaB2, gammaB1\n        print ""gammaOnArmToBase choosing 2nd delta root (to physical)""\n    elif (solvesEq8(alpha, deltaA, gammaA, deltaB1, gammaB2) and\n          0 <= gammaB2 <= pi):\n        print ""gammaOnArmToBase choosing 2nd gamma root (to physical)""\n        deltaB, gammaB = deltaB1, gammaB2\n    elif (solvesEq8(alpha, deltaA, gammaA, deltaB2, gammaB2)\n          and 0 <= gammaB2 <= pi):\n        print ""gammaOnArmToBase choosing 2nd delta root and 2nd gamma root""\n        deltaB, gammaB = deltaB2, gammaB2\n    else:\n        raise RuntimeError(\n            ""No valid solutions found mapping gamma-on-arm to gamma-on-base"")\n\n    return deltaB, gammaB\n'"
diffcalc/hkl/vlieg/hkl.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc.hkl.common import getNameFromScannableOrString\nfrom diffcalc.util import command\nfrom diffcalc import settings\n\n\nfrom diffcalc.ub import ub\nfrom diffcalc.hkl.vlieg.calc import VliegHklCalculator\n\n\n__all__ = [\'hklmode\', \'setpar\', \'trackalpha\', \'trackgamma\', \'trackphi\',\n           \'parameter_manager\', \'hklcalc\']\n\n\nhklcalc = VliegHklCalculator(ub.ubcalc)\n\nparameter_manager = hklcalc.parameter_manager\n\ndef __str__(self):\n    return hklcalc.__str__()\n\n@command\ndef hklmode(num=None):\n    """"""hklmode {num} -- changes mode or shows current and available modes and all settings"""""" #@IgnorePep8\n\n    if num is None:\n        print hklcalc.__str__()\n    else:\n        hklcalc.mode_selector.setModeByIndex(int(num))\n        pm = hklcalc.parameter_manager\n        print (hklcalc.mode_selector.reportCurrentMode() + ""\\n"" +\n               pm.reportParametersUsedInCurrentMode())\n\ndef _setParameter(name, value):\n    hklcalc.parameter_manager.set_constraint(name, value)\n\ndef _getParameter(name):\n    return hklcalc.parameter_manager.get_constraint(name)\n\n@command\ndef setpar(scannable_or_string=None, val=None):\n    """"""setpar {parameter_scannable {{val}} -- sets or shows a parameter\'\n    setpar {parameter_name {val}} -- sets or shows a parameter\'\n    """"""\n\n    if scannable_or_string is None:\n        #show all\n        parameterDict = hklcalc.parameter_manager.getParameterDict()\n        names = parameterDict.keys()\n        names.sort()\n        for name in names:\n            print _representParameter(name)\n    else:\n        name = getNameFromScannableOrString(scannable_or_string)\n        if val is None:\n            _representParameter(name)\n        else:\n            oldval = _getParameter(name)\n            _setParameter(name, float(val))\n            print _representParameter(name, oldval, float(val))\n\ndef _representParameter(name, oldval=None, newval=None):\n    flags = \'\'\n    if hklcalc.parameter_manager.isParameterTracked(name):\n        flags += \'(tracking hardware) \'\n    if settings.geometry.parameter_fixed(name):  # @UndefinedVariable\n        flags += \'(fixed by geometry) \'\n    pm = hklcalc.parameter_manager\n    if not pm.isParameterUsedInSelectedMode(name):\n        flags += \'(not relevant in this mode) \'\n    if oldval is None:\n        val = _getParameter(name)\n        if val is None:\n            val = ""---""\n        else:\n            val = str(val)\n        return ""%s: %s %s"" % (name, val, flags)\n    else:\n        return ""%s: %s --> %f %s"" % (name, oldval, newval, flags)\n\ndef _checkInputAndSetOrShowParameterTracking(name, b=None):\n    """"""\n    for track-parameter commands: If no args displays parameter settings,\n    otherwise sets the tracking switch for the given parameter and displays\n    settings.\n    """"""\n    # set if arg given\n    if b is not None:\n        hklcalc.parameter_manager.setTrackParameter(name, b)\n    # Display:\n    lastValue = _getParameter(name)\n    if lastValue is None:\n        lastValue = ""---""\n    else:\n        lastValue = str(lastValue)\n    flags = \'\'\n    if hklcalc.parameter_manager.isParameterTracked(name):\n        flags += \'(tracking hardware)\'\n    print ""%s: %s %s"" % (name, lastValue, flags)\n\n@command\ndef trackalpha(b=None):\n    """"""trackalpha {boolean} -- determines wether alpha parameter will track alpha axis"""""" #@IgnorePep8\n    _checkInputAndSetOrShowParameterTracking(\'alpha\', b)\n\n@command\ndef trackgamma(b=None):\n    """"""trackgamma {boolean} -- determines wether gamma parameter will track alpha axis"""""" #@IgnorePep8\n    _checkInputAndSetOrShowParameterTracking(\'gamma\', b)\n\n@command\ndef trackphi(b=None):\n    """"""trackphi {boolean} -- determines wether phi parameter will track phi axis"""""" #@IgnorePep8\n    _checkInputAndSetOrShowParameterTracking(\'phi\', b)\n  \n  \ncommands_for_help = [\'Mode\',\n                     hklmode,\n                     setpar,\n                     trackalpha,\n                     trackgamma,\n                     trackphi]\n'"
diffcalc/hkl/vlieg/transform.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc.util import command\n\nfrom copy import copy\nfrom math import pi\n\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition as P\n\nSMALL = 1e-10\n\n\nclass Transform(object):\n\n    def transform(self, pos):\n        raise RuntimeError(\'Not implemented\')\n\n\n### Transforms, currently for definition and testing the theory only\n\nclass TransformC(Transform):\n    \'\'\'Flip omega, invert chi and flip phi\n    \'\'\'\n    def transform(self, pos):\n        pos = pos.clone()\n        pos.omega -= 180\n        pos.chi *= -1\n        pos.phi -= 180\n        return pos\n\n\nclass TransformB(Transform):\n    \'\'\'Flip chi, and invert and flip omega\n    \'\'\'\n    def transform(self, pos):\n        pos = pos.clone()\n        pos.chi -= 180\n        pos.omega = 180 - pos.omega\n        return pos\n\n\nclass TransformA(Transform):\n    \'\'\'Invert scattering plane: invert delta and omega and flip chi\'\'\'\n    def transform(self, pos):\n        pos = pos.clone()\n        pos.delta *= -1\n        pos.omega *= -1\n        pos.chi -= 180\n        return pos\n\n\nclass TransformCInRadians(Transform):\n    \'\'\'\n    Flip omega, invert chi and flip phi. Using radians and keeping\n    -pi<omega<=pi and 0<=phi<=360\n    \'\'\'\n    def transform(self, pos):\n        pos = pos.clone()\n        if pos.omega > 0:\n            pos.omega -= pi\n        else:\n            pos.omega += pi\n        pos.chi *= -1\n        pos.phi += pi\n        return pos\n\n\n###\n\ntransformsFromSector = {\n    0: (),\n    1: (\'c\',),\n    2: (\'a\',),\n    3: (\'a\', \'c\'),\n    4: (\'b\', \'c\'),\n    5: (\'b\',),\n    6: (\'a\', \'b\', \'c\'),\n    7: (\'a\', \'b\')\n}\n\nsectorFromTransforms = {}\nfor k, v in transformsFromSector.iteritems():\n    sectorFromTransforms[v] = k\n\n\nclass VliegPositionTransformer(object):\n\n    def __init__(self, geometry, hardware, solution_transformer):\n        self._geometry = geometry\n        self._hardware = hardware\n        self._solution_transformer = solution_transformer\n        solution_transformer.limitCheckerFunction = self.is_position_within_limits\n\n    def transform(self, pos):\n        # 1. Choose the correct sector/transforms\n        return self._solution_transformer.transformPosition(pos)\n\n    def is_position_within_limits(self, position):\n        \'\'\'where position is Position object in degrees\'\'\'\n        angleTuple = self._geometry.internal_position_to_physical_angles(position)\n        angleTuple = self._hardware.cut_angles(angleTuple)\n        return self._hardware.is_position_within_limits(angleTuple)\n\n\nclass VliegTransformSelector(object):\n    \'\'\'All returned angles are between -180. and 180. -180.<=angle<180.\n    \'\'\'\n### basic sector selection\n\n    def __init__(self):\n        self.transforms = []\n        self.autotransforms = []\n        self.autosectors = []\n        self.limitCheckerFunction = None  # inject\n        self.sector = None\n        self.setSector(0)\n\n    def setSector(self, sector):\n        if not 0 <= sector <= 7:\n            raise ValueError(\'%i must between 0 and 7.\' % sector)\n        self.sector = sector\n        self.transforms = list(transformsFromSector[sector])\n\n    def setTransforms(self, transformList):\n        transformList = list(transformList)\n        transformList.sort()\n        self.sector = sectorFromTransforms[tuple(transformList)]\n        self.transforms = transformList\n\n    def addTransorm(self, transformName):\n        if transformName not in (\'a\', \'b\', \'c\'):\n            raise ValueError(\'%s is not a recognised transform. Try a, b or c\'\n                             % transformName)\n        if transformName in self.transforms:\n            print ""WARNING, transform %s is already selected""\n        else:\n            self.setTransforms(self.transforms + [transformName])\n\n    def removeTransorm(self, transformName):\n        if transformName not in (\'a\', \'b\', \'c\'):\n            raise ValueError(\'%s is not a recognised transform. Try a, b or c\'\n                             % transformName)\n        if transformName in self.transforms:\n            new = copy(self.transforms)\n            new.remove(transformName)\n            self.setTransforms(new)\n        else:\n            print ""WARNING, transform %s was not selected"" % transformName\n\n    def addAutoTransorm(self, transformOrSector):\n        \'\'\'\n        If input is a string (letter), tags one of the transofrms as being a\n        candidate for auto application. If a number, tags a sector as being a\n        candidate for auto application, and removes similar tags for any\n        transforms (as the two are incompatable).\n        \'\'\'\n        if type(transformOrSector) == str:\n            transform = transformOrSector\n            if transform not in (\'a\', \'b\', \'c\'):\n                raise ValueError(\n                    \'%s is not a recognised transform. Try a, b or c\' %\n                    transform)\n            if transform not in self.autotransforms:\n                self.autosectors = []\n                self.autotransforms.append(transform)\n            else:\n                print ""WARNING: %s is already set to auto apply"" % transform\n        elif type(transformOrSector) == int:\n            sector = transformOrSector\n            if not 0 <= sector <= 7:\n                raise ValueError(\'%i must between 0 and 7.\' % sector)\n            if sector not in self.autosectors:\n                self.autotransforms = []\n                self.autosectors.append(sector)\n            else:\n                print ""WARNING: %i is already set to auto apply"" % sector\n        else:\n            raise ValueError(""Input must be \'a\', \'b\' or \'c\', ""\n                             ""or 1,2,3,4,5,6 or 7."")\n\n    def removeAutoTransform(self, transformOrSector):\n        if type(transformOrSector) == str:\n            transform = transformOrSector\n            if transform not in (\'a\', \'b\', \'c\'):\n                raise ValueError(""%s is not a recognised transform. ""\n                                 ""Try a, b or c"" % transform)\n            if transform in self.autotransforms:\n                self.autotransforms.remove(transform)\n            else:\n                print ""WARNING: %s is not set to auto apply"" % transform\n        elif type(transformOrSector) == int:\n            sector = transformOrSector\n            if not 0 <= sector <= 7:\n                raise ValueError(\'%i must between 0 and 7.\' % sector)\n            if sector in self.autosectors:\n                self.autosectors.remove(sector)\n            else:\n                print ""WARNING: %s is not set to auto apply"" % sector\n        else:\n            raise ValueError(""Input must be \'a\', \'b\' or \'c\', ""\n                             ""or 1,2,3,4,5,6 or 7."")\n\n    def setAutoSectors(self, sectorList):\n        for sector in sectorList:\n            if not 0 <= sector <= 7:\n                raise ValueError(\'%i must between 0 and 7.\' % sector)\n        self.autosectors = list(sectorList)\n\n    def transformPosition(self, pos):\n        pos = self.transformNWithoutCut(self.sector, pos)\n        cutpos = self.cutPosition(pos)\n        # -180 <= cutpos < 180, NOT the externally applied cuts\n        if len(self.autosectors) > 0:\n            if self.is_position_within_limits(cutpos):\n                return cutpos\n            else:\n                return self.autoTransformPositionBySector(cutpos)\n        if len(self.autotransforms) > 0:\n            if self.is_position_within_limits(cutpos):\n                return cutpos\n            else:\n                return self.autoTransformPositionByTransforms(pos)\n        #else\n        return cutpos\n\n    def transformNWithoutCut(self, n, pos):\n\n        if n == 0:\n            return P(pos.alpha, pos.delta, pos.gamma,\n                     pos.omega, pos.chi, pos.phi)\n        if n == 1:\n            return P(pos.alpha, pos.delta, pos.gamma,\n                     pos.omega - 180., -pos.chi, pos.phi - 180.)\n        if n == 2:\n            return P(pos.alpha, -pos.delta, pos.gamma,\n                     -pos.omega, pos.chi - 180., pos.phi)\n        if n == 3:\n            return P(pos.alpha, -pos.delta, pos.gamma,\n                     180. - pos.omega, 180. - pos.chi, pos.phi - 180.)\n        if n == 4:\n            return P(pos.alpha, pos.delta, pos.gamma,\n                     -pos.omega, 180. - pos.chi, pos.phi - 180.)\n        if n == 5:\n            return P(pos.alpha, pos.delta, pos.gamma,\n                     180. - pos.omega, pos.chi - 180., pos.phi)\n        if n == 6:\n            return P(pos.alpha, -pos.delta, pos.gamma,\n                     pos.omega, -pos.chi, pos.phi - 180.)\n        if n == 7:\n            return P(pos.alpha, -pos.delta, pos.gamma,\n                     pos.omega - 180., pos.chi, pos.phi)\n        else:\n            raise Exception(""sector must be between 0 and 7"")\n\n### autosector\n\n    def hasAutoSectorsOrTransformsToApply(self):\n        return len(self.autosectors) > 0 or len(self.autotransforms) > 0\n\n    def autoTransformPositionBySector(self, pos):\n        okaysectors = []\n        okaypositions = []\n        for sector in self.autosectors:\n            newpos = self.transformNWithoutCut(sector, pos)\n            if self.is_position_within_limits(newpos):\n                okaysectors.append(sector)\n                okaypositions.append(newpos)\n        if len(okaysectors) == 0:\n            raise Exception(\n                ""Autosector could not find a sector (from %s) to move %s into ""\n                ""limits."" % (self.autosectors, str(pos)))\n        if len(okaysectors) > 1:\n            print (""WARNING: Autosector found multiple sectors that would ""\n                   ""move %s to move into limits: %s"" % (str(pos), okaysectors))\n\n        print (""INFO: Autosector changed sector from %i to %i"" %\n               (self.sector, okaysectors[0]))\n        self.sector = okaysectors[0]\n        return okaypositions[0]\n\n    def autoTransformPositionByTransforms(self, pos):\n        possibleTransforms = self.createListOfPossibleTransforms()\n        okaytransforms = []\n        okaypositions = []\n        for transforms in possibleTransforms:\n            sector = sectorFromTransforms[tuple(transforms)]\n            newpos = self.cutPosition(self.transformNWithoutCut(sector, pos))\n            if self.is_position_within_limits(newpos):\n                okaytransforms.append(transforms)\n                okaypositions.append(newpos)\n        if len(okaytransforms) == 0:\n            raise Exception(\n                ""Autosector could not find a sector (from %r) to move %r into ""\n                ""limits."" % (self.autosectors, pos))\n        if len(okaytransforms) > 1:\n            print (""WARNING: Autosector found multiple sectors that would ""\n                   ""move %s to move into limits: %s"" %\n                   (repr(pos), repr(okaytransforms)))\n\n        print (""INFO: Autosector changed selected transforms from %r to %r"" %\n               (self.transforms, okaytransforms[0]))\n        self.setTransforms(okaytransforms[0])\n        return okaypositions[0]\n\n    def createListOfPossibleTransforms(self):\n        def vary(possibleTransforms, name):\n            result = []\n            for transforms in possibleTransforms:\n                # add the original.\n                result.append(transforms)\n                # add a modified one\n                toadd = list(copy(transforms))\n                if name in transforms:\n                    toadd.remove(name)\n                else:\n                    toadd.append(name)\n                toadd.sort()\n                result.append(toadd)\n            return result\n        # start with the currently selected list of transforms\n        if len(self.transforms) == 0:\n            possibleTransforms = [()]\n        else:\n            possibleTransforms = copy(self.transforms)\n\n        for name in self.autotransforms:\n            possibleTransforms = vary(possibleTransforms, name)\n\n        return possibleTransforms\n\n    def is_position_within_limits(self, pos):\n        \'\'\'where pos os a poistion object in degrees\'\'\'\n        return self.limitCheckerFunction(pos)\n\n    def __repr__(self):\n        def createPrefix(transform):\n            if transform in self.transforms:\n                s = \'*on* \'\n            else:\n                s = \'off  \'\n            if len(self.autotransforms) > 0:\n                if transform in self.autotransforms:\n                    s += \'*auto*\'\n                else:\n                    s += \'      \'\n            return s\n        s = \'Transforms/sector:\\n\'\n        s += (\'  %s (a transform) Invert scattering plane: invert delta and \'\n              \'omega and flip chi\\n\' % createPrefix(\'a\'))\n        s += (\'  %s (b transform) Flip chi, and invert and flip omega\\n\' %\n              createPrefix(\'b\'))\n        s += (\'  %s (c transform) Flip omega, invert chi and flip phi\\n\' %\n              createPrefix(\'c\'))\n        s += \'  Current sector: %i (Spec fourc equivalent)\\n\' % self.sector\n        if len(self.autosectors) > 0:\n            s += \'  Auto sectors: %s\\n\' % self.autosectors\n        return s\n\n    def cutPosition(self, position):\n        \'\'\'Cuts angles at -180.; moves each argument between -180. and 180.\n        \'\'\'\n        def cut(a):\n            if a is None:\n                return None\n            else:\n                if a < (-180. - SMALL):\n                    return a + 360.\n                if a > (180. + SMALL):\n                    return a - 360.\n            return a\n        return P(cut(position.alpha), cut(position.delta), cut(position.gamma),\n                 cut(position.omega), cut(position.chi), cut(position.phi))\n\n\ndef getNameFromScannableOrString(o):\n        try:  # it may be a scannable\n            return o.getName()\n        except AttributeError:\n            return str(o)\n\n\nclass TransformCommands(object):\n\n    def __init__(self, sector_selector):\n        self._sectorSelector = sector_selector\n\n    @command\n    def transform(self):\n        """"""transform  -- show transform configuration""""""\n        print self._sectorSelector.__repr__()\n\n    @command\n    def transforma(self, *args):\n        """"""transforma {on|off|auto|manual} -- configure transform A application\n        """"""\n        self._transform(\'transforma\', \'a\', args)\n\n    @command\n    def transformb(self, *args):\n        """"""transformb {on|off|auto|manual} -- configure transform B application\n        """"""\n        self._transform(\'transformb\', \'b\', args)\n\n    @command\n    def transformc(self, *args):\n        """"""transformc {on|off|auto|manual} -- configure transform C application\n        """"""\n\n        self._transform(\'transformc\', \'c\', args)\n\n    def _transform(self, commandName, transformName, args):\n        if len(args) == 0:\n            print self._sectorSelector.__repr__()\n            return\n        # get name\n        if len(args) != 1:\n            raise TypeError()\n        if type(args[0]) is not str:\n            raise TypeError()\n\n        ss = self._sectorSelector\n        if args[0] == \'on\':\n            ss.addTransorm(transformName)\n        elif args[0] == \'off\':\n            ss.removeTransorm(transformName)\n        elif args[0] == \'auto\':\n            ss.addAutoTransorm(transformName)\n        elif args[0] == \'manual\':\n            ss.removeAutoTransform(transformName)\n        else:\n            raise TypeError()\n        print self._sectorSelector.__repr__()\n\n    @command\n    def sector(self, sector=None):\n        """"""sector {0-7} -- Select or display sector (a la Spec)\n        """"""\n        if sector is None:\n            print self._sectorSelector.__repr__()\n        else:\n            if type(sector) is not int and not (0 <= sector <= 7):\n                raise TypeError()\n            self._sectorSelector.setSector(sector)\n            print self._sectorSelector.__repr__()\n\n    @command\n    def autosector(self, *args):\n        """"""autosector [None] [0-7] [0-7]... -- Set sectors that might be automatically applied"""""" #@IgnorePep8\n        if len(args) == 0:\n            print self._sectorSelector.__repr__()\n        elif len(args) == 1 and args[0] is None:\n            self._sectorSelector.setAutoSectors([])\n            print self._sectorSelector.__repr__()\n        else:\n            sectorList = []\n            for arg in args:\n                if type(arg) is not int:\n                    raise TypeError()\n                sectorList.append(arg)\n            self._sectorSelector.setAutoSectors(sectorList)\n            print self._sectorSelector.__repr__()\n\n\n\n'"
diffcalc/hkl/willmott/__init__.py,0,b''
diffcalc/hkl/willmott/calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, asin, acos, atan2, sin, cos, sqrt\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.log import logging\nfrom diffcalc.util import bound, AbstractPosition, DiffcalcException,\\\n    x_rotation, z_rotation\nfrom diffcalc.hkl.vlieg.geometry import VliegGeometry\nfrom diffcalc.ub.calc import PaperSpecificUbCalcStrategy\nfrom diffcalc.hkl.calcbase import HklCalculatorBase\nfrom diffcalc.hkl.common import DummyParameterManager\n\nlogger = logging.getLogger(""diffcalc.hkl.willmot.calcwill"")\n\nCHOOSE_POSITIVE_GAMMA = True\n\nTORAD = pi / 180\nTODEG = 180 / pi\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\nSMALL = 1e-10\n\nTEMPORARY_CONSTRAINTS_DICT_RAD = {\'betain\': 2 * TORAD}\n\n\ndef create_matrices(delta, gamma, omegah, phi):\n    return (calc_DELTA(delta), calc_GAMMA(gamma), calc_OMEGAH(omegah),\n            calc_PHI(phi))\n\n\ndef calc_DELTA(delta):\n    return x_rotation(delta)                                             # (39)\n\n\ndef calc_GAMMA(gamma):\n    return z_rotation(gamma)                                             # (40)\n\n\ndef calc_OMEGAH(omegah):\n    return x_rotation(omegah)                                            # (41)\n\n\ndef calc_PHI(phi):\n    return z_rotation(phi)                                               # (42)\n\n\ndef angles_to_hkl_phi(delta, gamma, omegah, phi):\n    """"""Calculate hkl matrix in phi frame in units of 2*pi/lambda\n    """"""\n    DELTA, GAMMA, OMEGAH, PHI = create_matrices(delta, gamma, omegah, phi)\n    H_lab = (GAMMA * DELTA - I) * matrix([[0], [1], [0]])                # (43)\n    H_phi = PHI.I * OMEGAH.I * H_lab                                     # (44)\n    return H_phi\n\n\ndef angles_to_hkl(delta, gamma, omegah, phi, wavelength, UB):\n    """"""Calculate hkl matrix in reprical lattice space in units of 1/Angstrom\n    """"""\n    H_phi = angles_to_hkl_phi(delta, gamma, omegah, phi) * 2 * pi / wavelength\n    hkl = UB.I * H_phi                                                    # (5)\n    return hkl\n\n\nclass WillmottHorizontalPosition(AbstractPosition):\n\n    def __init__(self, delta=None, gamma=None, omegah=None, phi=None):\n        self.delta = delta\n        self.gamma = gamma\n        self.omegah = omegah\n        self.phi = phi\n\n    def clone(self):\n        return WillmottHorizontalPosition(self.delta, self.gamma, self.omegah,\n                                          self.phi)\n\n    def changeToRadians(self):\n        self.delta *= TORAD\n        self.gamma *= TORAD\n        self.omegah *= TORAD\n        self.phi *= TORAD\n\n    def changeToDegrees(self):\n        self.delta *= TODEG\n        self.gamma *= TODEG\n        self.omegah *= TODEG\n        self.phi *= TODEG\n\n    def totuple(self):\n        return (self.delta, self.gamma, self.omegah, self.phi)\n\n    def __str__(self):\n        return (\'WillmottHorizontalPosition(\'\n                \'delta: %.4f gamma: %.4f omegah: %.4f phi: %.4f)\' %\n                (self.delta, self.gamma, self.omegah, self.phi))\n\n\nclass WillmottHorizontalGeometry(object):\n\n    def __init__(self):\n        self.name = \'willmott_horizontal\'\n\n    def physical_angles_to_internal_position(self, physicalAngles):\n        return WillmottHorizontalPosition(*physicalAngles)\n\n    def internal_position_to_physical_angles(self, internalPosition):\n        return internalPosition.totuple()\n\n    def create_position(self, delta, gamma, omegah, phi):\n        return WillmottHorizontalPosition(delta, gamma, omegah, phi)\n\n\nclass WillmottHorizontalUbCalcStrategy(PaperSpecificUbCalcStrategy):\n\n    def calculate_q_phi(self, pos):\n        H_phi = angles_to_hkl_phi(*pos.totuple())\n        return matrix(H_phi.tolist())\n\n\nclass DummyConstraints(object):\n\n    @property\n    def reference(self):\n        """"""dictionary of constrained reference circles""""""\n        return TEMPORARY_CONSTRAINTS_DICT_RAD\n\n\nclass ConstraintAdapter(object):\n\n    def __init__(self, constraints):\n        self._constraints = constraints\n\n    def getParameterDict(self):\n        names = self._constraints.available\n        return dict(zip(names, [None] * len(names)))\n\n    def setParameter(self, name, value):\n        self._constraints.set_constraint(name, value)\n\n    def get(self, name):\n        if name in self._constraints.all:\n            val = self._constraints.get_value(name)\n            return 999 if val is None else val\n        else:\n            return 999\n\n    def update_tracked(self):\n        pass\n\n\nclass WillmottHorizontalCalculator(HklCalculatorBase):\n\n    def __init__(self, ubcalc, constraints,\n                 raiseExceptionsIfAnglesDoNotMapBackToHkl=True):\n        """"""""\n        Where constraints.reference is a one element dict with the key either\n        (\'betain\', \'betaout\' or \'equal\') and the value a number or None for\n        \'betain_eq_betaout\'\n        """"""\n\n        HklCalculatorBase.__init__(self, ubcalc,\n                                   raiseExceptionsIfAnglesDoNotMapBackToHkl)\n\n        if constraints is not None:\n            self.constraints = constraints\n            self.parameter_manager = ConstraintAdapter(constraints)\n        else:\n            self.constraints = DummyConstraints()\n            self.parameter_manager = DummyParameterManager()\n\n    @property\n    def _UB(self):\n        return self._ubcalc.UB\n\n    def _anglesToHkl(self, pos, wavelength):\n        """"""\n        Calculate miller indices from position in radians.\n        """"""\n        hkl_matrix = angles_to_hkl(pos.delta, pos.gamma, pos.omegah, pos.phi,\n                             wavelength, self._UB)\n        return hkl_matrix[0, 0], hkl_matrix[1, 0], hkl_matrix[2, 0],\n\n    def _anglesToVirtualAngles(self, pos, wavelength):\n        """"""\n        Calculate virtual-angles in radians from position in radians.\n\n        Return theta, alpha, and beta in a dictionary.\n        """"""\n\n        betain = pos.omegah                                              # (52)\n\n        hkl = angles_to_hkl(pos.delta, pos.gamma, pos.omegah, pos.phi,\n                              wavelength, self._UB)\n        H_phi = self._UB * hkl\n        H_phi = H_phi / (2 * pi / wavelength)\n        l_phi = H_phi[2, 0]\n        sin_betaout = l_phi - sin(betain)\n        betaout = asin(bound(sin_betaout))                               # (54)\n\n        cos_2theta = cos(pos.delta) * cos(pos.gamma)\n        theta = acos(bound(cos_2theta)) / 2.\n\n        return {\'theta\': theta, \'betain\': betain, \'betaout\': betaout}\n\n    def _hklToAngles(self, h, k, l, wavelength):\n        """"""\n        Calculate position and virtual angles in radians for a given hkl.\n        """"""\n\n        H_phi = self._UB * matrix([[h], [k], [l]])  # units: 1/Angstrom\n        H_phi = H_phi / (2 * pi / wavelength)       # units: 2*pi/wavelength\n        h_phi = H_phi[0, 0]\n        k_phi = H_phi[1, 0]\n        l_phi = H_phi[2, 0]                                               # (5)\n\n        ### determine betain (omegah) and betaout ###\n\n        if not self.constraints.reference:\n            raise ValueError(""No reference constraint has been constrained."")\n\n        ref_name, ref_value = self.constraints.reference.items()[0]\n        if ref_value is not None:\n            ref_value *= TORAD\n        if ref_name == \'betain\':\n            betain = ref_value\n            betaout = asin(bound(l_phi - sin(betain)))                   # (53)\n        elif ref_name == \'betaout\':\n            betaout = ref_value\n            betain = asin(bound(l_phi - sin(betaout)))                   # (54)\n        elif ref_name == \'bin_eq_bout\':\n            betain = betaout = asin(bound(l_phi / 2))                    # (55)\n        else:\n            raise ValueError(""Unexpected constraint name\'%s\'."" % ref_name)\n\n        if abs(betain) < SMALL:\n            raise DiffcalcException(\'required betain was 0 degrees (requested \'\n                                    \'q is perpendicular to surface normal)\')\n        if betain < -SMALL:\n            raise DiffcalcException(""betain was -ve (%.4f)"" % betain)\n#        logger.info(\'betain = %.4f, betaout = %.4f\',\n#                    betain * TODEG, betaout * TODEG)\n        omegah = betain                                                  # (52)\n\n        ### determine H_lab (X, Y and Z) ###\n\n        Y = -(h_phi ** 2 + k_phi ** 2 + l_phi ** 2) / 2                  # (45)\n\n        Z = (sin(betaout) + sin(betain) * (Y + 1)) / cos(omegah)         # (47)\n\n        X_squared = (h_phi ** 2 + k_phi ** 2 -\n                    ((cos(betain) * Y + sin(betain) * Z) ** 2))          # (48)\n        if (X_squared < 0) and (abs(X_squared) < SMALL):\n            X_squared = 0\n        Xpositive = sqrt(X_squared)\n        if CHOOSE_POSITIVE_GAMMA:\n            X = -Xpositive\n        else:\n            X = Xpositive\n#        logger.info(\'H_lab (X,Y,Z) = [%.4f, %.4f, %.4f]\', X, Y, Z)\n        ### determine diffractometer angles ###\n\n        gamma = atan2(-X, Y + 1)                                         # (49)\n        if (abs(gamma) < SMALL):\n            # degenerate case, only occurs when q || z\n            delta = 2 * omegah\n        else:\n            delta = atan2(Z * sin(gamma), -X)                            # (50)\n        M = cos(betain) * Y + sin(betain) * Z\n        phi = atan2(h_phi * M - k_phi * X, h_phi * X + k_phi * M)        # (51)\n\n        pos = WillmottHorizontalPosition(delta, gamma, omegah, phi)\n        virtual_angles = {\'betain\': betain, \'betaout\': betaout}\n        return pos, virtual_angles\n'"
diffcalc/hkl/willmott/commands.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc.hkl.common import getNameFromScannableOrString\nfrom diffcalc.util import command\n\n\nclass WillmottHklCommands(object):\n\n    def __init__(self, hklcalc):\n        self._hklcalc = hklcalc\n        self.commands = [self.con,\n                         self.uncon,\n                         self.cons]\n\n    def __str__(self):\n        return self._hklcalc.__str__()\n\n    @command\n    def con(self, scn_or_string):\n        """"""con <constraint> -- constrains constraint\n        """"""\n        name = getNameFromScannableOrString(scn_or_string)\n        self._hklcalc.constraints.constrain(name)\n        print self._report_constraints()\n\n    @command\n    def uncon(self, scn_or_string):\n        """"""uncon <constraint> -- unconstrains constraint\n        """"""\n        name = getNameFromScannableOrString(scn_or_string)\n        self._hklcalc.constraints.unconstrain(name)\n        print self._report_constraints()\n\n    @command\n    def cons(self):\n        """"""cons -- list available constraints and values\n        """"""\n        print self._report_constraints()\n\n    def _report_constraints(self):\n        return (self._hklcalc.constraints.build_display_table_lines() + \'\\n\\n\' +\n               self._hklcalc.constraints._report_constraints())\n'"
diffcalc/hkl/willmott/constraints.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc.util import DiffcalcException\n\n\ndef filter_dict(d, keys):\n    """"""Return a copy of d containing only keys that are in keys""""""\n    ##return {k: d[k] for k in keys} # requires Python 2.6\n    return dict((k, d[k]) for k in keys if k in d.keys())\n\n\nref_constraints = (\'betain\', \'betaout\', \'bin_eq_bout\')\nvalueless_constraints = (\'bin_eq_bout\')\nall_constraints = ref_constraints\n\n\nclass WillmottConstraintManager(object):\n    """"""Constraints in degrees.\n    """"""\n\n    def __init__(self):\n        self._constrained = {\'bin_eq_bout\': None}\n\n    @property\n    def available_constraint_names(self):\n        """"""list of all available constraints""""""\n        return all_constraints\n\n    @property\n    def all(self):  # @ReservedAssignment\n        """"""dictionary of all constrained values""""""\n        return self._constrained.copy()\n\n    @property\n    def reference(self):\n        """"""dictionary of constrained reference circles""""""\n        return filter_dict(self.all, ref_constraints)\n\n    @property\n    def constrained_names(self):\n        """"""ordered tuple of constained circles""""""\n        names = self.all.keys()\n        names.sort(key=lambda name: list(all_constraints).index(name))\n        return tuple(names)\n\n    def is_constrained(self, name):\n        return name in self._constrained\n\n    def get_value(self, name):\n        return self._constrained[name]\n\n    def _build_display_table(self):\n        constraint_types = (ref_constraints,)\n        num_rows = max([len(col) for col in constraint_types])\n        max_name_width = max(\n            [len(name) for name in sum(constraint_types[:2], ())])\n        # headings\n        lines = [\'    \' + \'REF\'.ljust(max_name_width)]\n        lines.append(\'    \' + \'=\' * max_name_width + \' \')\n\n        # constraint rows\n        for n_row in range(num_rows):\n            cells = []\n            for col in constraint_types:\n                name = col[n_row] if n_row < len(col) else \'\'\n                cells.append(self._label_constraint(name))\n                cells.append((\'%-\' + str(max_name_width) + \'s \') % name)\n            lines.append(\'\'.join(cells))\n        lines.append\n        return \'\\n\'.join(lines)\n\n    def _report_constraints(self):\n        if not self.reference:\n            return ""!!! No reference constraint set""\n        name, val = self.reference.items()[0]\n        if name in valueless_constraints:\n            return ""    %s"" % name\n        else:\n            if val is None:\n                return ""!!! %s: ---"" % name\n            else:\n                return ""    %s: %.4f"" % (name, val)\n\n    def _label_constraint(self, name):\n        if name == \'\':\n            label = \'    \'\n        elif (self.is_constrained(name) and (self.get_value(name) is None) and\n            name not in valueless_constraints):\n            label = \'o-> \'\n        elif self.is_constrained(name):\n            label = \'--> \'\n        else:\n            label = \'    \'\n        return label\n\n    def constrain(self, name):\n        if name in self.all:\n            return ""%s is already constrained."" % name.capitalize()\n        elif name in ref_constraints:\n            return self._constrain_reference(name)\n        else:\n            raise DiffcalcException(\'%s is not a valid constraint name\')\n\n    def _constrain_reference(self, name):\n        if self.reference:\n            constrained_name = self.reference.keys()[0]\n            del self._constrained[constrained_name]\n            self._constrained[name] = None\n            return \'%s constraint replaced.\' % constrained_name.capitalize()\n        else:\n            self._constrained[name] = None\n\n    def unconstrain(self, name):\n        if name in self._constrained:\n            del self._constrained[name]\n        else:\n            return ""%s was not already constrained."" % name.capitalize()\n\n###\n    def _check_constraint_settable(self, name, verb):\n        if name not in all_constraints:\n            raise DiffcalcException(\n                \'Could not %(verb)s %(name)s as this is not an available \'\n                \'constraint.\' % locals())\n        elif name not in self.all.keys():\n            raise DiffcalcException(\n                \'Could not %(verb)s %(name)s as this is not currently \'\n                \'constrained.\' % locals())\n        elif name in valueless_constraints:\n            raise DiffcalcException(\n                \'Could not %(verb)s %(name)s as this constraint takes no \'\n                \'value.\' % locals())\n\n    def set_constraint(self, name, value):  # @ReservedAssignment\n        self._check_constraint_settable(name, \'set\')\n        old_value = self.all[name]\n        old = str(old_value) if old_value is not None else \'---\'\n        self._constrained[name] = float(value)\n        new = str(value)\n        return ""%(name)s : %(old)s --> %(new)s"" % locals()\n'"
diffcalc/hkl/you/__init__.py,0,b''
diffcalc/hkl/you/calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, sin, cos, tan, acos, asin, atan, atan2, sqrt\nfrom itertools import product\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\n\nfrom diffcalc.log import logging\nfrom diffcalc.hkl.calcbase import HklCalculatorBase\nfrom diffcalc.hkl.you.geometry import create_you_matrices, calcMU, calcPHI, \\\n    calcCHI, calcETA\nfrom diffcalc.hkl.you.geometry import YouPosition\nfrom diffcalc.util import DiffcalcException, bound, angle_between_vectors,\\\n    y_rotation\nfrom diffcalc.util import cross3, z_rotation, x_rotation\nfrom diffcalc.ub.calc import PaperSpecificUbCalcStrategy\n\nfrom diffcalc.settings import NUNAME\nlogger = logging.getLogger(""diffcalc.hkl.you.calc"")\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n\nSMALL = 1e-6\nTORAD = pi / 180\nTODEG = 180 / pi\n\nPRINT_DEGENERATE = False\n\n\ndef is_small(x):\n    return abs(x) < SMALL\n\n\ndef sign(x):\n    if is_small(x):\n        return 0\n    if x > 0:\n        return 1\n    # x < 0\n    return -1\n\n\ndef normalised(vector):\n    return vector * (1 / norm(vector))\n\n\ndef cut_at_minus_pi(value):\n    if value < (-pi - SMALL):\n        return value + 2 * pi\n    if value >= pi + SMALL:\n        return value - 2 * pi\n    return value\n\n\ndef _calc_N(Q, n):\n    """"""Return N as described by Equation 31""""""\n    Q = normalised(Q)\n    n = normalised(n)\n    if is_small(angle_between_vectors(Q, n)):\n        # Replace the reference vector with an alternative vector from Eq.(78) \n        idx_min, _ = min(enumerate([abs(Q[0, 0]), abs(Q[1, 0]), abs(Q[2, 0])]), key=lambda v: v[1])\n        idx_1, idx_2 = [idx for idx in range(3) if idx != idx_min]\n        qval = sqrt(Q[idx_1, 0] * Q[idx_1, 0] + Q[idx_2, 0] * Q[idx_2, 0])\n        n[idx_min, 0] = qval\n        n[idx_1, 0] = -Q[idx_min, 0] * Q[idx_1, 0] / qval\n        n[idx_2, 0] = -Q[idx_min, 0] * Q[idx_2, 0] / qval\n        if is_small(norm(n)):\n            n[idx_min, 0] = 0\n            n[idx_1, 0] =  Q[idx_2, 0] / qval\n            n[idx_2, 0] = -Q[idx_1, 0] / qval\n    Qxn = cross3(Q, n)\n    QxnxQ = cross3(Qxn, Q)\n    QxnxQ = normalised(QxnxQ)\n    Qxn = normalised(Qxn)\n    return matrix([[Q[0, 0], QxnxQ[0, 0], Qxn[0, 0]],\n                   [Q[1, 0], QxnxQ[1, 0], Qxn[1, 0]],\n                   [Q[2, 0], QxnxQ[2, 0], Qxn[2, 0]]])\n\n\ndef _calc_angle_between_naz_and_qaz(theta, alpha, tau):\n    # Equation 30:\n    top = cos(tau) - sin(alpha) * sin(theta)\n    bottom = cos(alpha) * cos(theta)\n    if is_small(bottom):\n        if is_small(cos(alpha)):\n            raise ValueError(\'cos(alpha) is too small\')\n        if is_small(cos(theta)):\n            raise ValueError(\'cos(theta) is too small\')\n    if is_small(sin(tau)):\n        return 0.\n    return acos(bound(top / bottom))\n\n\ndef youAnglesToHkl(pos, wavelength, UBmatrix):\n    """"""Calculate miller indices from position in radians.\n    """"""\n\n    [MU, DELTA, NU, ETA, CHI, PHI] = create_you_matrices(*pos.totuple())\n\n    q_lab = (NU * DELTA - I) * matrix([[0], [2 * pi / wavelength], [0]])   # 12\n\n    hkl = UBmatrix.I * PHI.I * CHI.I * ETA.I * MU.I * q_lab\n\n    return hkl[0, 0], hkl[1, 0], hkl[2, 0]\n\n\ndef _tidy_degenerate_solutions(pos, constraints):\n\n    original = pos.inDegrees()\n    detector_like_constraint = constraints.detector or constraints.naz\n    nu_constrained_to_0 = is_small(pos.nu) and detector_like_constraint\n    mu_constrained_to_0 = is_small(pos.mu) and \'mu\' in constraints.sample\n    delta_constrained_to_0 = is_small(pos.delta) and detector_like_constraint\n    eta_constrained_to_0 = is_small(pos.eta) and \'eta\' in constraints.sample\n    phi_not_constrained = not \'phi\' in constraints.sample\n\n    if nu_constrained_to_0 and mu_constrained_to_0 and phi_not_constrained:\n        # constrained to vertical 4-circle like mode\n        if is_small(pos.chi):  # phi || eta\n            desired_eta = pos.delta / 2.\n            eta_diff = desired_eta - pos.eta\n            pos.eta = desired_eta\n            pos.phi -= eta_diff\n            if PRINT_DEGENERATE:\n                print (\'DEGENERATE: with chi=0, phi and eta are colinear:\'\n                       \'choosing eta = delta/2 by adding % 7.3f to eta and \'\n                       \'removing it from phi. (mu=%s=0 only)\' % (eta_diff * TODEG, NUNAME))\n                print \'            original:\', original\n\n    elif delta_constrained_to_0 and eta_constrained_to_0 and phi_not_constrained:\n        # constrained to horizontal 4-circle like mode\n        if is_small(pos.chi - pi / 2):  # phi || mu\n            desired_mu = pos.nu / 2.\n            mu_diff = desired_mu - pos.mu\n            pos.mu = desired_mu\n            pos.phi += mu_diff\n            if PRINT_DEGENERATE:\n                print (\'DEGENERATE: with chi=90, phi and mu are colinear: choosing\'\n                       \' mu = %s/2 by adding % 7.3f to mu and to phi. \'\n                       \'(delta=eta=0 only)\' % (NUNAME, mu_diff * TODEG))\n                print \'            original:\', original\n\n    return pos\n\n\ndef _theta_and_qaz_from_detector_angles(delta, nu):\n    # Equation 19:\n    cos_2theta = cos(delta) * cos(nu)\n    theta = acos(cos_2theta) / 2.\n    sgn = sign(sin(2. * theta))\n    qaz = atan2(sgn * sin(delta), sgn * cos(delta) * sin(nu))\n    return theta, qaz\n\n\nclass YouUbCalcStrategy(PaperSpecificUbCalcStrategy):\n\n    def calculate_q_phi(self, pos):\n\n        [MU, DELTA, NU, ETA, CHI, PHI] = create_you_matrices(*pos.totuple())\n        # Equation 12: Compute the momentum transfer vector in the lab  frame\n        y = matrix(\'0; 1; 0\')\n        q_lab = (NU * DELTA - I) * y\n        # Transform this into the phi frame.\n        return PHI.I * CHI.I * ETA.I * MU.I * q_lab\n\n\nUNREACHABLE_MSG = (\n    \'The current combination of constraints with %s = %.4f\\n\'\n    \'prohibits a solution for the specified reflection.\')\n\n\nclass YouHklCalculator(HklCalculatorBase):\n\n    def __init__(self, ubcalc, constraints,\n                  raiseExceptionsIfAnglesDoNotMapBackToHkl=True):\n        HklCalculatorBase.__init__(self, ubcalc,\n                                   raiseExceptionsIfAnglesDoNotMapBackToHkl)\n        self.constraints = constraints\n        self.parameter_manager = constraints  # TODO: remove need for this attr\n\n    def __str__(self):\n        return self.constraints.__str__()\n\n    def _get_n_phi(self):\n        return self._ubcalc.n_phi\n    \n    def _get_surf_nphi(self):\n        return self._ubcalc.surf_nphi\n    \n    def _get_ubmatrix(self):\n        return self._getUBMatrix()  # for consistency\n\n    def repr_mode(self):\n        return repr(self.constraints.all)\n\n    def _anglesToHkl(self, pos, wavelength):\n        """"""Calculate miller indices from position in radians.\n        """"""\n        return youAnglesToHkl(pos, wavelength, self._get_ubmatrix())\n\n    def _anglesToVirtualAngles(self, pos, _wavelength):\n        """"""Calculate pseudo-angles in radians from position in radians.\n\n        Return theta, qaz, alpha, naz, tau, psi and beta in a dictionary.\n\n        """"""\n\n        # depends on surface normal n_lab.\n        mu, delta, nu, eta, chi, phi = pos.totuple()\n\n        theta, qaz = _theta_and_qaz_from_detector_angles(delta, nu)      # (19)\n\n        [MU, DELTA, NU, ETA, CHI, PHI] = create_you_matrices(mu,\n                                           delta, nu, eta, chi, phi)\n        Z = MU * ETA * CHI * PHI\n        D = NU * DELTA\n\n        # Compute incidence and outgoing angles bin and betaout\n        surf_nphi = Z * self._get_surf_nphi()\n        kin = matrix([[0],[1],[0]])\n        kout = D * matrix([[0],[1],[0]])\n        betain = angle_between_vectors(kin, surf_nphi) - pi / 2.\n        betaout = pi / 2. - angle_between_vectors(kout, surf_nphi)\n\n        if settings.include_reference:\n            n_lab = Z * self._get_n_phi()\n            alpha = asin(bound((-n_lab[1, 0])))\n            naz = atan2(n_lab[0, 0], n_lab[2, 0])                            # (20)\n\n            cos_tau = cos(alpha) * cos(theta) * cos(naz - qaz) + \\\n                      sin(alpha) * sin(theta)\n            tau = acos(bound(cos_tau))                                       # (23)\n\n            # Compute Tau using the dot product directly (THIS ALSO WORKS)\n            # q_lab = ( (NU * DELTA - I ) * matrix([[0],[1],[0]])\n            # norm = norm(q_lab)\n            # q_lab = matrix([[1],[0],[0]]) if norm == 0 else q_lab * (1/norm)\n            # tau_from_dot_product = acos(bound(dot3(q_lab, n_lab)))\n\n            sin_beta = 2 * sin(theta) * cos(tau) - sin(alpha)\n            beta = asin(bound(sin_beta))                                     # (24)\n\n            psi = next(self._calc_psi(alpha, theta, tau, qaz, naz))\n\n            return {\'theta\': theta, \'ttheta\': 2 * theta, \'qaz\': qaz, \'alpha\': alpha,\n                    \'naz\': naz, \'tau\': tau, \'psi\': psi, \'beta\': beta,\n                    \'betain\': betain, \'betaout\': betaout}\n        return {\'theta\': theta, \'ttheta\': 2 * theta, \'qaz\': qaz,\n                \'betain\': betain, \'betaout\': betaout}\n\n\n    def _choose_single_solution(self, pos_virtual_angles_pairs_in_degrees):\n\n        if len(pos_virtual_angles_pairs_in_degrees) == 1:\n            return pos_virtual_angles_pairs_in_degrees[0]\n\n        absolute_distances = []\n        _hw_pos = settings.hardware.get_position()\n        _you_pos = settings.geometry.physical_angles_to_internal_position(_hw_pos).totuple()\n\n        metric = lambda (a, b): 2.* asin(abs(sin((a - b) * TORAD / 2.))) * TODEG\n\n        for _pos, _ in pos_virtual_angles_pairs_in_degrees:\n            pos_pairs = zip(_pos.totuple(), _you_pos)\n            absolute_distances.append([metric(p)for p in pos_pairs])\n\n        min_distances = [min(d) for d in zip(*absolute_distances)]\n        relative_distances = [sorted([round(vl - mn, 2) for (vl, mn) in zip(ab, min_distances)], reverse=True)\n                               for ab in absolute_distances]\n\n        shortest_solution_index, _ = min(enumerate(relative_distances), key=lambda x: x[1])\n        pos, virtual_angles = pos_virtual_angles_pairs_in_degrees[shortest_solution_index]\n\n        if logger.isEnabledFor(logging.DEBUG):\n            msg = (\'Multiple sample solutions found (choosing solution with \'\n                   \'shortest distance to all-zeros position):\\n\')\n            i = 0\n            for (pos_, _), distance in zip(pos_virtual_angles_pairs_in_degrees,\n                                          relative_distances):\n                msg += \'*\' if i == shortest_solution_index else \'.\'\n\n                msg += (\'mu=% 7.3f, delta=% 7.3f, nu=% 7.3f, eta=% 7.3f, chi=% 7.3f, phi=% 7.3f\' %\n                        pos_.totuple())\n                msg += \' (distance=%s)\\n\' % str(distance)\n                i += 1\n            msg += \':\\n\'\n            logger.debug(msg)\n\n        return pos, virtual_angles\n\n    def hklToAngles(self, h, k, l, wavelength, return_all_solutions=False):\n        """"""\n        Return verified Position and all virtual angles in degrees from\n        h, k & l and wavelength in Angstroms.\n\n        The calculated Position is verified by checking that it maps back using\n        anglesToHkl() to the requested hkl value.\n\n        Those virtual angles fixed or generated while calculating the position\n        are verified by by checking that they map back using\n        anglesToVirtualAngles to the virtual angles for the given position.\n\n        Throws a DiffcalcException if either check fails and\n        raiseExceptionsIfAnglesDoNotMapBackToHkl is True, otherwise displays a\n        warning.\n        """"""\n\n        pos_virtual_angles_pairs = self._hklToAngles(h, k, l, wavelength, return_all_solutions)  # in rad\n        assert pos_virtual_angles_pairs\n        pos_virtual_angles_pairs_in_degrees = []\n        for pos, virtual_angles in pos_virtual_angles_pairs:\n            \n            # to degrees:\n            pos.changeToDegrees()\n            for key, val in virtual_angles.items():\n                if val is not None:\n                    virtual_angles[key] = val * TODEG\n\n            self._verify_pos_map_to_hkl(h, k, l, wavelength, pos)\n\n            pos_virtual_angles_pairs_in_degrees.append((pos, virtual_angles))\n\n        if return_all_solutions:\n            return pos_virtual_angles_pairs_in_degrees\n        else:\n            pos, virtual_angles = self._choose_single_solution(pos_virtual_angles_pairs_in_degrees)\n            return pos, virtual_angles\n\n    def hklListToAngles(self, hkl_list, wavelength, return_all_solutions=False):\n        """"""\n        Return verified Position and all virtual angles in degrees from\n        h, k & l and wavelength in Angstroms.\n\n        The calculated Position is verified by checking that it maps back using\n        anglesToHkl() to the requested hkl value.\n\n        Those virtual angles fixed or generated while calculating the position\n        are verified by by checking that they map back using\n        anglesToVirtualAngles to the virtual angles for the given position.\n\n        Throws a DiffcalcException if either check fails and\n        raiseExceptionsIfAnglesDoNotMapBackToHkl is True, otherwise displays a\n        warning.\n        """"""\n\n        pos_virtual_angles_pairs_in_degrees = []\n        for (h, k, l) in hkl_list:\n            try:\n                pos_virtual_angles_pairs = self._hklToAngles(h, k, l, wavelength, return_all_solutions)  # in rad\n                for pos, virtual_angles in pos_virtual_angles_pairs:\n                    \n                    # to degrees:\n                    pos.changeToDegrees()\n                    for key, val in virtual_angles.items():\n                        if val is not None:\n                            virtual_angles[key] = val * TODEG\n        \n                    self._verify_pos_map_to_hkl(h, k, l, wavelength, pos)\n        \n                    pos_virtual_angles_pairs_in_degrees.append((pos, virtual_angles))\n            except DiffcalcException:\n                continue\n        if not pos_virtual_angles_pairs_in_degrees:\n            raise DiffcalcException(\'No solutions were found matching existing hardware limits. \'\n                \'Please consider using an alternative set of constraints.\')\n\n        if return_all_solutions:\n            return pos_virtual_angles_pairs_in_degrees\n        else:\n            pos, virtual_angles = self._choose_single_solution(pos_virtual_angles_pairs_in_degrees)\n            return pos, virtual_angles\n\n\n    def hkl_to_all_angles(self, h, k, l, wavelength):\n        return self.hklToAngles(h, k, l, wavelength, True)\n\n\n    def _hklToAngles(self, h, k, l, wavelength, return_all_solutions=False):\n        """"""(pos, virtualAngles) = hklToAngles(h, k, l, wavelength) --- with\n        Position object pos and the virtual angles returned in degrees. Some\n        modes may not calculate all virtual angles.\n        """"""\n\n        if not self.constraints.is_fully_constrained():\n            raise DiffcalcException(\n                ""Diffcalc is not fully constrained.\\n""\n                ""Type \'help con\' for instructions"")\n\n        if not self.constraints.is_current_mode_implemented():\n            raise DiffcalcException(\n                ""Sorry, the selected constraint combination is valid but ""\n                ""is not implemented. Type \'help con\' for implemented combinations"")\n              \n        # constraints are dictionaries  \n        ref_constraint = self.constraints.reference\n        if ref_constraint:\n            ref_constraint_name, ref_constraint_value = ref_constraint.items()[0]\n        det_constraint = self.constraints.detector\n        naz_constraint = self.constraints.naz\n        samp_constraints = self.constraints.sample\n            \n        assert not (det_constraint and naz_constraint), (\n               ""Two \'detector\' constraints given"")\n\n\n        h_phi = self._get_ubmatrix() * matrix([[h], [k], [l]])\n        theta = self._calc_theta(h_phi, wavelength)\n        tau = angle_between_vectors(h_phi, self._get_n_phi())\n        surf_tau = angle_between_vectors(h_phi, self._get_surf_nphi())\n        \n        if is_small(sin(tau)) and ref_constraint:\n            if ref_constraint_name == \'psi\':\n                raise DiffcalcException(""Azimuthal angle \'psi\' is undefined as reference and scattering vectors parallel.\\n""\n                                        ""Please constrain one of the sample angles or choose different reference vector orientation."")\n            elif ref_constraint_name == \'a_eq_b\':\n                raise DiffcalcException(""Reference constraint \'a_eq_b\' is redundant as reference and scattering vectors are parallel.\\n""\n                                        ""Please constrain one of the sample angles or choose different reference vector orientation."")\n        if is_small(sin(surf_tau)) and ref_constraint and ref_constraint_name == \'bin_eq_bout\':\n            raise DiffcalcException(""Reference constraint \'bin_eq_bout\' is redundant as scattering vectors is parallel to the surface normal.\\n""\n                                    ""Please select another constrain to define sample azimuthal orientation."")\n\n\n        ### Reference constraint column ###\n\n        n_phi = self._get_n_phi()\n        if ref_constraint:\n            if set([\'psi\', \'a_eq_b\', \'alpha\', \'beta\']).issuperset(ref_constraint.keys()):\n                # An angle for the reference vector (n) is given      (Section 5.2)         \n                alpha, _ = self._calc_remaining_reference_angles(\n                    ref_constraint_name, ref_constraint_value, theta, tau)\n            elif set([\'bin_eq_bout\', \'betain\', \'betaout\']).issuperset(ref_constraint.keys()):\n                alpha, _ = self._calc_remaining_reference_angles(\n                    ref_constraint_name, ref_constraint_value, theta, surf_tau)\n                tau = surf_tau\n                n_phi = self._get_surf_nphi()\n\n        solution_tuples = []\n        if det_constraint or naz_constraint:\n\n            if len(samp_constraints) == 1:\n                for qaz, naz, delta, nu in self._calc_det_angles_given_det_or_naz_constraint(\n                                                det_constraint, naz_constraint, theta, tau, alpha):\n                    for mu, eta, chi, phi in self._calc_sample_angles_from_one_sample_constraint(\n                                                samp_constraints, h_phi, theta, alpha, qaz, naz, n_phi):\n                        solution_tuples.append((mu, delta, nu, eta, chi, phi))\n\n            elif len(samp_constraints) == 2:\n                if det_constraint:\n                    det_constraint_name, det_constraint_val = det_constraint.items()[0]\n                    for delta, nu, qaz in self._calc_remaining_detector_angles(det_constraint_name, det_constraint_val, theta):\n                        for mu, eta, chi, phi in self._calc_sample_angles_given_two_sample_and_detector(\n                            samp_constraints, qaz, theta, h_phi, n_phi):\n                            solution_tuples.append((mu, delta, nu, eta, chi, phi))\n                \n                else:\n                    raise DiffcalcException(\n                        \'No code yet to handle this combination of detector and sample constraints!\')\n\n        elif len(samp_constraints) == 2:\n            if ref_constraint_name == \'psi\':\n                psi_vals = [ref_constraint_value,]\n            else:\n                psi_vals = self._calc_psi(alpha, theta, tau)\n            for psi in psi_vals:\n                angles = list(self._calc_sample_given_two_sample_and_reference(\n                    samp_constraints, h_phi, theta, psi, n_phi))\n                solution_tuples.extend(angles)\n\n        elif len(samp_constraints) == 3:\n            for angles in self._calc_angles_given_three_sample_constraints(\n                h, k, l, wavelength, return_all_solutions, samp_constraints,\n                 h_phi, theta):\n                solution_tuples.append(angles)\n        \n        if not solution_tuples:\n            raise DiffcalcException(\'No solutions were found. \'\n                \'Please consider using an alternative set of constraints.\')\n\n        tidy_solutions = [_tidy_degenerate_solutions(YouPosition(*pos, unit=\'RAD\'),\n                                                     self.constraints).totuple() for pos in solution_tuples]\n        merged_solution_tuples = set(self._filter_angle_limits(tidy_solutions,\n                                                               not return_all_solutions))\n        if not merged_solution_tuples:\n            raise DiffcalcException(\'No solutions were found matching existing hardware limits. \'\n                \'Please consider using an alternative set of constraints.\')\n\n        #def _find_duplicate_angles(el):\n        #    idx, tpl = el\n        #    for tmp_tpl in filtered_solutions[idx:]:\n        #        if False not in [abs(x-y) < SMALL for x,y in zip(tmp_tpl, tpl)]:\n        #            return False\n        #    return True\n        #merged_solution_tuples = filter(_find_duplicate_angles, enumerate(filtered_solutions, 1))\n        position_pseudo_angles_pairs = self._create_position_pseudo_angles_pairs(wavelength, merged_solution_tuples)\n        if not position_pseudo_angles_pairs:\n            raise DiffcalcException(\'No solutions were found. Please check hardware limits and \'\n                \'consider using an alternative pseudo-angle constraints.\')\n\n        return position_pseudo_angles_pairs\n\n\n    def _create_position_pseudo_angles_pairs(self, wavelength, merged_solution_tuples):\n\n        position_pseudo_angles_pairs = []\n        for pos in merged_solution_tuples:\n            # Create position\n            position = YouPosition(*pos, unit=\'RAD\')\n            #position = _tidy_degenerate_solutions(position, self.constraints)\n            #if position.phi <= -pi + SMALL:\n            #    position.phi += 2 * pi\n            # pseudo angles calculated along the way were for the initial solution\n            # and may be invalid for the chosen solution TODO: anglesToHkl need no\n            # longer check the pseudo_angles as they will be generated with the\n            # same function and it will prove nothing\n            pseudo_angles = self._anglesToVirtualAngles(position, wavelength)\n            is_sol = True\n            for constraint in [self.constraints.reference,\n                               self.constraints.detector,\n                               self.constraints.naz]:\n                try:\n                    constraint_name, constraint_value = constraint.items()[0]\n                    if constraint_name == \'a_eq_b\':\n                        diff = pseudo_angles[\'alpha\'] - pseudo_angles[\'beta\']\n                    elif constraint_name == \'bin_eq_bout\':\n                        diff = pseudo_angles[\'betain\'] - pseudo_angles[\'betaout\']\n                    else:\n                        diff = constraint_value - pseudo_angles[constraint_name]\n                except Exception:\n                    continue\n                diff = abs(sin(diff/2.))\n                if not is_small(diff):\n                    is_sol = False\n                    break\n            if is_sol:\n                position_pseudo_angles_pairs.append((position, pseudo_angles))\n        return position_pseudo_angles_pairs\n\n\n    def _calc_theta(self, h_phi, wavelength):\n        """"""Calculate theta using Equation1\n        """"""\n        q_length = norm(h_phi)\n        if is_small(q_length):\n            raise DiffcalcException(\'Reflection is unreachable as |Q| is too small\')\n        wavevector = 2 * pi / wavelength\n        try:\n            theta = asin(bound(q_length / (2 * wavevector)))\n        except AssertionError:\n            raise DiffcalcException(\n                \'Reflection is unreachable as |Q| is too long\')\n        if is_small(cos(theta)):\n            raise DiffcalcException(\n                \'Reflection is unreachable as theta angle is too close to 90 deg\')\n        return theta\n\n    def _calc_psi(self, alpha, theta, tau, qaz=None, naz=None):\n        """"""Calculate psi from Eq. (18), (25) and (28)\n        """"""\n        sin_tau = sin(tau)\n        cos_theta = cos(theta)\n        if is_small(sin_tau):\n            # The reference vector is parallel to the scattering vector\n            yield float(\'nan\')\n        elif is_small(cos_theta):\n            # Reflection is unreachable as theta angle is too close to 90 deg\n            yield float(\'nan\')\n        elif is_small(sin(theta)):\n            # Reflection is unreachable as |Q| is too small\n            yield float(\'nan\')\n        else:\n            cos_psi = ((cos(tau) * sin(theta) - sin(alpha)) / cos_theta) # (28)\n            if qaz is None or naz is None :\n                try:\n                    acos_psi = acos(bound(cos_psi / sin_tau))\n                    if is_small(acos_psi):\n                        yield 0.\n                    else:\n                        for psi in [acos_psi, -acos_psi]:\n                            yield psi\n                except AssertionError:\n                    print (\'WARNING: Diffcalc could not calculate an azimuth (psi)\')\n                    yield float(\'nan\')\n            else:\n                sin_psi = cos(alpha) * sin(qaz - naz)\n                sgn = sign(sin_tau)\n                eps = sin_psi**2 + cos_psi**2\n                sigma_ = eps/sin_tau**2 - 1\n                if not is_small(sigma_):\n                    print (\'WARNING: Diffcalc could not calculate a unique azimuth \'\n                           \'(psi) because of loss of accuracy in numerical calculation\')\n                    yield float(\'nan\')\n                else:\n                    psi = atan2(sgn * sin_psi, sgn * cos_psi)\n                    yield psi\n\n\n    def _calc_remaining_reference_angles(self, name, value, theta, tau):\n        """"""Return alpha and beta given one of a_eq_b, alpha, beta or psi\n        """"""\n        if name == \'psi\':\n            psi = value\n            # Equation 26 for alpha\n            sin_alpha = (cos(tau) * sin(theta) -\n                         cos(theta) * sin(tau) * cos(psi))\n            if abs(sin_alpha) > 1 + SMALL:\n                raise DiffcalcException(UNREACHABLE_MSG % (name, value * TODEG))\n            alpha = asin(bound(sin_alpha))\n            # Equation 27 for beta\n            sin_beta = cos(tau) * sin(theta) + cos(theta) * sin(tau) * cos(psi)\n            if abs(sin_beta) > 1 + SMALL:\n                raise DiffcalcException(UNREACHABLE_MSG % (name, value * TODEG))\n\n            beta = asin(bound(sin_beta))\n\n        elif name == \'a_eq_b\' or name == \'bin_eq_bout\':\n            alpha = beta = asin(cos(tau) * sin(theta))            # (24)\n\n        elif name == \'alpha\' or name == \'betain\':\n            alpha = value                                                # (24)\n            sin_beta = 2 * sin(theta) * cos(tau) - sin(alpha)\n            if abs(sin_beta) > 1 + SMALL:\n                raise DiffcalcException(UNREACHABLE_MSG % (name, value * TODEG))\n            beta = asin(sin_beta)\n\n        elif name == \'beta\' or name == \'betaout\':\n            beta = value\n            sin_alpha = 2 * sin(theta) * cos(tau) - sin(beta)            # (24)\n            if abs(sin_alpha) > 1 + SMALL:\n                raise DiffcalcException(UNREACHABLE_MSG % (name, value * TODEG))\n\n            alpha = asin(sin_alpha)\n\n        return alpha, beta\n\n    def _calc_det_angles_given_det_or_naz_constraint(\n            self, det_constraint, naz_constraint, theta, tau, alpha):\n        \n        assert det_constraint or naz_constraint\n        try:\n            naz_qaz_angle = _calc_angle_between_naz_and_qaz(theta, alpha, tau)\n        except AssertionError:\n            return\n        if det_constraint:\n            # One of the detector angles is given                 (Section 5.1)\n            det_constraint_name, det_constraint = det_constraint.items()[0]\n            for delta, nu, qaz in self._calc_remaining_detector_angles(\n                                        det_constraint_name, det_constraint, theta):\n                if is_small(naz_qaz_angle):\n                    naz_angles = [qaz,]\n                else:\n                    naz_angles = [qaz - naz_qaz_angle, qaz + naz_qaz_angle]\n                for naz in naz_angles:\n                    yield qaz, naz, delta, nu\n        elif naz_constraint: # The \'detector\' angle naz is given:\n            det_constraint_name, det_constraint = naz_constraint.items()[0]\n            naz_name, naz = det_constraint_name, det_constraint\n            assert naz_name == \'naz\'\n            if is_small(naz_qaz_angle):\n                qaz_angles = [naz,]\n            else:\n                qaz_angles = [naz - naz_qaz_angle, naz + naz_qaz_angle]\n            for qaz in qaz_angles:\n                for delta, nu, _ in self._calc_remaining_detector_angles(\n                                        \'qaz\', qaz, theta):\n                    yield qaz, naz, delta, nu\n\n    def _calc_remaining_detector_angles(self, constraint_name,\n                                        constraint_value, theta):\n        """"""Return delta, nu and qaz given one detector angle\n        """"""\n        #                                                         (section 5.1)\n        # Find qaz using various derivations of 17 and 18\n        sin_2theta = sin(2 * theta)\n        cos_2theta = cos(2 * theta)\n        if is_small(sin_2theta):\n            raise DiffcalcException(\n                \'No meaningful scattering vector (Q) can be found when \'\n                \'theta is so small (%.4f).\' % theta * TODEG)\n\n        if constraint_name == \'delta\':\n            delta = constraint_value\n            try:\n                asin_qaz = asin(bound(sin(delta) / sin_2theta))              # (17 & 18)\n            except AssertionError:\n                return\n            cos_delta = cos(delta)\n            if is_small(cos_delta):\n                #raise DiffcalcException(\n                #    \'The %s and %s circles are redundant when delta is constrained to %.0f degrees.\'\n                #    \'Please change delta constraint or use 4-circle mode.\' % (NUNAME, \'mu\', delta * TODEG))\n                print ((\'DEGENERATE: with delta=90, %s is degenerate: choosing \'\n                       \'%s = 0 (allowed because %s is unconstrained)\') %\n                       (NUNAME, NUNAME, NUNAME))\n                acos_nu = 1.\n            else:\n                try:\n                    acos_nu = acos(bound(cos_2theta / cos_delta))\n                except AssertionError:\n                    return\n            if is_small(cos(asin_qaz)):\n                qaz_angles = [sign(asin_qaz) * pi / 2.,]\n            else:\n                qaz_angles = [asin_qaz, pi - asin_qaz]\n            if is_small(acos_nu):\n                nu_angles = [0.,]\n            else:\n                nu_angles = [acos_nu, -acos_nu]\n            for qaz, nu in product(qaz_angles, nu_angles):\n                sgn_ref = sign(sin_2theta) * sign(cos(qaz))\n                sgn_ratio = sign(sin(nu)) * sign(cos_delta)\n                if sgn_ref == sgn_ratio:\n                    yield delta, nu, qaz\n\n        elif constraint_name == NUNAME:\n            nu = constraint_value\n            cos_nu = cos(nu)\n            if is_small(cos_nu):\n                raise DiffcalcException(\n                    \'The %s circle constraint to %.0f degrees is redundant.\'\n                    \'Please change this constraint or use 4-circle mode.\' % (NUNAME, nu * TODEG))\n            cos_delta = cos_2theta / cos(nu)\n            cos_qaz = cos_delta * sin(nu) / sin_2theta\n            try:\n                acos_delta = acos(bound(cos_delta))\n                acos_qaz = acos(bound(cos_qaz))\n            except AssertionError:\n                return\n            if is_small(acos_qaz):\n                qaz_angles = [0.,]\n            else:\n                qaz_angles = [acos_qaz, -acos_qaz]\n            if is_small(acos_delta):\n                delta_angles = [0.,]\n            else:\n                delta_angles = [acos_delta, -acos_delta]\n            for qaz, delta in product(qaz_angles, delta_angles):\n                sgn_ref = sign(sin(delta))\n                sgn_ratio = sign(sin(qaz)) * sign(sin_2theta)\n                if sgn_ref == sgn_ratio:\n                    yield delta, nu, qaz\n\n        elif constraint_name == \'qaz\':\n            qaz = constraint_value\n            asin_delta = asin(sin(qaz) * sin_2theta)\n            if is_small(cos(asin_delta)):\n                delta_angles = [sign(asin_delta) * pi / 2.,]\n            else:\n                delta_angles = [asin_delta, pi - asin_delta]\n            for delta in delta_angles:\n                cos_delta = cos(delta)\n                if is_small(cos_delta):\n                    print ((\'DEGENERATE: with delta=90, %s is degenerate: choosing \'\n                           \'%s = 0 (allowed because %s is unconstrained)\') %\n                           (NUNAME, NUNAME, NUNAME))\n                    #raise DiffcalcException(\n                    #    \'The %s circle is redundant when delta is at %.0f degrees.\'\n                    #    \'Please change detector constraint or use 4-circle mode.\' % (NUNAME, delta * TODEG))\n                    nu = 0.\n                else:\n                    sgn_delta = sign(cos_delta)\n                    nu = atan2(sgn_delta * sin_2theta * cos(qaz), sgn_delta * cos_2theta)\n                yield delta, nu, qaz\n        else:\n            raise DiffcalcException(\n                constraint_name + \' is not an explicit detector angle \'\n                \'(naz cannot be handled here)\')\n\n\n    def _calc_sample_angles_from_one_sample_constraint(\n            self, samp_constraints, h_phi, theta, alpha, qaz, naz, n_phi):\n        \n        sample_constraint_name, sample_value = samp_constraints.items()[0]\n        q_lab = matrix([[cos(theta) * sin(qaz)], \n                [-sin(theta)], \n                [cos(theta) * cos(qaz)]]) # (18)\n        n_lab = matrix([[cos(alpha) * sin(naz)], \n                [-sin(alpha)], \n                [cos(alpha) * cos(naz)]]) # (20)\n        mu_eta_chi_phi_tuples = list(self._calc_remaining_sample_angles(\n            sample_constraint_name, sample_value, q_lab, n_lab, h_phi, \n            n_phi))\n        return mu_eta_chi_phi_tuples\n\n    def _calc_sample_given_two_sample_and_reference(\n            self, samp_constraints, h_phi, theta, psi, n_phi):\n        \n        for angles in self._calc_sample_angles_given_two_sample_and_reference(\n                 samp_constraints, psi, theta, h_phi, n_phi):\n            qaz, psi, mu, eta, chi, phi = angles \n            values_in_deg = tuple(v * TODEG for v in angles)\n            logger.debug(\'Initial angles: xi=%.3f, psi=%.3f, mu=%.3f, \'\n                \'eta=%.3f, chi=%.3f, phi=%.3f\' % \n                values_in_deg) # Try to find a solution for each possible transformed xi\n\n            logger.debug("""")\n            msg = ""---Trying psi=%.3f, qaz=%.3f"" % (psi * TODEG, qaz * TODEG)\n            logger.debug(msg)\n            \n            for delta, nu, _ in self._calc_remaining_detector_angles(\'qaz\', qaz, theta):\n                logger.debug(""delta=%.3f, %s=%.3f"", delta * TODEG, NUNAME, nu * TODEG)\n                #for mu, eta, chi, phi in self._generate_sample_solutions(\n                #    mu, eta, chi, phi, samp_constraints.keys(), delta, \n                #    nu, wavelength, (h, k, l), ref_constraint_name, \n                #    ref_constraint_value):\n                yield mu, delta, nu, eta, chi, phi\n\n    def _calc_remaining_sample_angles(self, constraint_name, constraint_value,\n                                      q_lab, n_lab, q_phi, n_phi):\n        """"""Return phi, chi, eta and mu, given one of these""""""\n        #                                                         (section 5.3)\n\n        N_lab = _calc_N(q_lab, n_lab)\n        N_phi = _calc_N(q_phi, n_phi)\n        Z = N_lab * N_phi.T\n\n        if constraint_name == \'mu\':                                      # (35)\n            mu = constraint_value\n            V = calcMU(mu).I * N_lab * N_phi.T\n            try:\n                acos_chi = acos(bound(V[2, 2]))\n            except AssertionError:\n                return\n            if is_small(sin(acos_chi)):\n                # chi ~= 0 or 180 and therefor phi || eta The solutions for phi\n                # and eta here will be valid but will be chosen unpredictably.\n                # Choose eta=0:\n                #\n                # tan(phi+eta)=v12/v11 from docs/extensions_to_yous_paper.wxm\n                chi = acos_chi\n                eta = 0.\n                phi = atan2(-V[1, 0], V[1, 1])\n                logger.debug(\n                    \'Eta and phi cannot be chosen uniquely with chi so close \'\n                    \'to 0 or 180. Returning phi=%.3f and eta=%.3f\', \n                    phi * TODEG, eta * TODEG)\n                yield mu, eta, chi, phi\n            else:\n                for chi in [acos_chi, -acos_chi]:\n                    sgn = sign(sin(chi))\n                    phi = atan2(-sgn * V[2, 1], -sgn * V[2, 0])\n                    eta = atan2(-sgn * V[1, 2],  sgn * V[0, 2])\n                    yield mu, eta, chi, phi\n\n        elif constraint_name == \'phi\':                                     # (37)\n            phi = constraint_value\n            V = N_lab * N_phi.I * calcPHI(phi).T\n            try:\n                asin_eta = asin(bound(V[0, 1]))\n            except AssertionError:\n                return\n            if is_small(cos(asin_eta)):\n                raise DiffcalcException(\'Chi and mu cannot be chosen uniquely \'\n                                        \'with eta so close to +/-90.\')\n            for eta in [asin_eta, pi - asin_eta]:\n                sgn = sign(cos(eta))\n                mu = atan2(sgn * V[2, 1], sgn * V[1, 1])\n                chi = atan2(sgn * V[0, 2], sgn * V[0, 0])\n                yield mu, eta, chi, phi\n\n        elif constraint_name in (\'eta\', \'chi\'):\n            if constraint_name == \'eta\':                                 # (39)\n                eta = constraint_value\n                cos_eta = cos(eta)\n                if is_small(cos_eta):\n                    #TODO: Not likely to happen in real world!?\n                    raise DiffcalcException(\n                        \'Chi and mu cannot be chosen uniquely with eta \'\n                        \'constrained so close to +-90.\')\n                try:\n                    asin_chi = asin(bound(Z[0, 2] / cos_eta))\n                except AssertionError:\n                    return\n                all_eta = [eta,]\n                all_chi = [asin_chi, pi - asin_chi]\n\n            else:  # constraint_name == \'chi\'                            # (40)\n                chi = constraint_value\n                sin_chi = sin(chi)\n                if is_small(sin_chi):\n                    raise DiffcalcException(\n                        \'Eta and phi cannot be chosen uniquely with chi \'\n                        \'constrained so close to 0. (Please contact developer \'\n                        \'if this case is useful for you)\')\n                try:\n                    acos_eta = acos(bound(Z[0, 2] / sin_chi))\n                except AssertionError:\n                    return\n                all_eta = [acos_eta, -acos_eta]\n                all_chi = [chi,]\n\n            for chi, eta in product(all_chi, all_eta):\n                top_for_mu = Z[2, 2] * sin(eta) * sin(chi) + Z[1, 2] * cos(chi)\n                bot_for_mu = -Z[2, 2] * cos(chi) + Z[1, 2] * sin(eta) * sin(chi)\n                if is_small(top_for_mu) and is_small(bot_for_mu):\n                    # chi == +-90, eta == 0/180 and therefore phi || mu cos(chi) ==\n                    # 0 and sin(eta) == 0 Experience shows that even though e.g.\n                    # the z[2, 2] and z[1, 2] values used to calculate mu may be\n                    # basically 0 (1e-34) their ratio in every case tested so far\n                    # still remains valid and using them will result in a phi\n                    # solution that is continuous with neighbouring positions.\n                    #\n                    # We cannot test phi minus mu here unfortunately as the final\n                    # phi and mu solutions have not yet been chosen (they may be\n                    # +-x or 180+-x). Otherwise we could choose a sensible solution\n                    # here if the one found was incorrect.\n\n                    # tan(phi+eta)=v12/v11 from extensions_to_yous_paper.wxm\n                    #phi_minus_mu = -atan2(Z[2, 0], Z[1, 1])\n                    raise DiffcalcException(\n                        \'Mu cannot be chosen uniquely as mu || phi with chi so close \'\n                        \'to +/-90 and eta so close 0 or 180.\\nPlease choose \'\n                        \'a different set of constraints.\')\n                mu = atan2(-top_for_mu, -bot_for_mu)                         # (41)\n\n                top_for_phi = Z[0, 1] * cos(eta) * cos(chi) - Z[0, 0] * sin(eta)\n                bot_for_phi = Z[0, 1] * sin(eta) + Z[0, 0] * cos(eta) * cos(chi)\n                if is_small(bot_for_phi) and is_small(top_for_phi):\n                    DiffcalcException(\n                        \'Phi cannot be chosen uniquely as mu || phi with chi so close \'\n                        \'to +/-90 and eta so close 0 or 180.\\nPlease choose a \'\n                        \'different set of constraints.\')\n                phi = atan2(top_for_phi, bot_for_phi)                        # (42)\n                yield mu, eta, chi, phi\n\n        else:\n            raise DiffcalcException(\'Given angle must be one of phi, chi, eta or mu\')\n\n    def _calc_angles_given_three_sample_constraints(\n            self, h, k, l, wavelength, return_all_solutions, samp_constraints,\n            h_phi, theta):\n\n        def __get_last_sample_angle(A, B, C):\n            if is_small(A) and is_small(B):\n                raise DiffcalcException(\n                        \'Sample orientation cannot be chosen uniquely. Please choose a different set of constraints.\')\n            ks = atan2(A, B)\n            acos_alp = acos(bound(C / sqrt(A**2 + B**2))) \n            if is_small(acos_alp):\n                alp_list = [ks,]\n            else:\n                alp_list = [acos_alp + ks, -acos_alp + ks]\n            return alp_list\n                \n        def __get_qaz_value(mu, eta, chi, phi):\n            V0 = h2*cos(eta)*sin(chi) + (h0*cos(chi)*cos(eta) + h1*sin(eta))*cos(phi) + (h1*cos(chi)*cos(eta) - h0*sin(eta))*sin(phi)\n            V2 = -h2*sin(chi)*sin(eta)*sin(mu) + h2*cos(chi)*cos(mu) - (h0*cos(mu)*sin(chi) + (h0*cos(chi)*sin(eta) - h1*cos(eta))*sin(mu))*cos(phi) - \\\n                    (h1*cos(mu)*sin(chi) + (h1*cos(chi)*sin(eta) + h0*cos(eta))*sin(mu))*sin(phi)\n            sgn_theta = sign(cos(theta))\n            qaz = atan2(sgn_theta * V0, sgn_theta * V2)\n            return qaz\n            \n        h_phi_norm = normalised(h_phi)                                    # (68,69) \n        h0, h1, h2 = h_phi_norm[0, 0], h_phi_norm[1, 0], h_phi_norm[2, 0]\n\n        if not \'mu\' in samp_constraints:\n            eta = self.constraints.sample[\'eta\']\n            chi = self.constraints.sample[\'chi\']\n            phi = self.constraints.sample[\'phi\']\n\n            A = h0*cos(phi)*sin(chi) + h1*sin(chi)*sin(phi) - h2*cos(chi)\n            B = -h2*sin(chi)*sin(eta) - (h0*cos(chi)*sin(eta) - h1*cos(eta))*cos(phi) - (h1*cos(chi)*sin(eta) + h0*cos(eta))*sin(phi)\n            C = -sin(theta)\n            try:\n                mu_vals = __get_last_sample_angle(A, B, C)\n            except AssertionError:\n                return\n            for mu in mu_vals:\n                qaz = __get_qaz_value(mu, eta, chi, phi)\n                logger.debug(""--- Trying mu:%.f qaz_%.f"", mu * TODEG, qaz * TODEG)\n                for delta, nu, _ in self._calc_remaining_detector_angles(\'qaz\', qaz, theta):\n                    logger.debug(""delta=%.3f, %s=%.3f"", delta * TODEG, NUNAME, nu * TODEG)\n                    yield mu, delta, nu, eta, chi, phi\n\n        elif not \'eta\' in samp_constraints:\n            mu = self.constraints.sample[\'mu\']\n            chi = self.constraints.sample[\'chi\']\n            phi = self.constraints.sample[\'phi\']\n\n            A = -h0*cos(chi)*cos(mu)*cos(phi) - h1*cos(chi)*cos(mu)*sin(phi) - h2*cos(mu)*sin(chi)\n            B = h1*cos(mu)*cos(phi) - h0*cos(mu)*sin(phi)\n            C = -h0*cos(phi)*sin(chi)*sin(mu) - h1*sin(chi)*sin(mu)*sin(phi) + h2*cos(chi)*sin(mu) - sin(theta)\n            try:\n                eta_vals = __get_last_sample_angle(A, B, C)\n            except AssertionError:\n                return\n            for eta in eta_vals:\n                qaz = __get_qaz_value(mu, eta, chi, phi)\n                logger.debug(""--- Trying eta:%.f qaz_%.f"", eta * TODEG, qaz * TODEG)\n                for delta, nu, _ in self._calc_remaining_detector_angles(\'qaz\', qaz, theta):\n                    logger.debug(""delta=%.3f, %s=%.3f"", delta * TODEG, NUNAME, nu * TODEG)\n                    yield mu, delta, nu, eta, chi, phi\n\n        elif not \'chi\' in samp_constraints:\n            mu = self.constraints.sample[\'mu\']\n            eta = self.constraints.sample[\'eta\']\n            phi = self.constraints.sample[\'phi\']\n\n            A = -h2*cos(mu)*sin(eta) + h0*cos(phi)*sin(mu) + h1*sin(mu)*sin(phi)\n            B = -h0*cos(mu)*cos(phi)*sin(eta) - h1*cos(mu)*sin(eta)*sin(phi) - h2*sin(mu)\n            C = -h1*cos(eta)*cos(mu)*cos(phi) + h0*cos(eta)*cos(mu)*sin(phi) - sin(theta)\n            try:\n                chi_vals = __get_last_sample_angle(A, B, C)\n            except AssertionError:\n                return\n            for chi in chi_vals:\n                qaz = __get_qaz_value(mu, eta, chi, phi)\n                logger.debug(""--- Trying chi:%.f qaz_%.f"", chi * TODEG, qaz * TODEG)\n                for delta, nu, _ in self._calc_remaining_detector_angles(\'qaz\', qaz, theta):\n                    logger.debug(""delta=%.3f, %s=%.3f"", delta * TODEG, NUNAME, nu * TODEG)\n                    yield mu, delta, nu, eta, chi, phi\n\n        elif not \'phi\' in samp_constraints:\n            mu = self.constraints.sample[\'mu\']\n            eta = self.constraints.sample[\'eta\']\n            chi = self.constraints.sample[\'chi\']\n\n            A = h1*sin(chi)*sin(mu) - (h1*cos(chi)*sin(eta) + h0*cos(eta))*cos(mu)\n            B = h0*sin(chi)*sin(mu) - (h0*cos(chi)*sin(eta) - h1*cos(eta))*cos(mu)\n            C = h2*cos(mu)*sin(chi)*sin(eta) + h2*cos(chi)*sin(mu) - sin(theta)\n            try:\n                phi_vals = __get_last_sample_angle(A, B, C)\n            except AssertionError:\n                return\n            for phi in phi_vals:\n                qaz = __get_qaz_value(mu, eta, chi, phi)\n                logger.debug(""--- Trying phi:%.f qaz_%.f"", phi * TODEG, qaz * TODEG)\n                for delta, nu, _ in self._calc_remaining_detector_angles(\'qaz\', qaz, theta):\n                    logger.debug(""delta=%.3f, %s=%.3f"", delta * TODEG, NUNAME, nu * TODEG)\n                    yield mu, delta, nu, eta, chi, phi\n        else:\n            raise DiffcalcException(\n                \'Internal error: Invalid set of sample constraints.\')\n\n    def _calc_sample_angles_given_two_sample_and_reference(\n            self, samp_constraints, psi, theta, q_phi, n_phi):\n        """"""Available combinations:\n        chi, phi, reference\n        mu, eta, reference,\n        chi, eta, reference\n        chi, mu, reference\n        mu, phi, reference\n        eta, phi, reference\n        """"""\n\n        def __get_phi_and_qaz(chi, eta, mu):\n            a = sin(chi) * cos(eta)\n            b = sin(chi) * sin(eta) * sin(mu) - cos(chi) * cos(mu)\n            #atan2_xi = atan2(V[2, 2] * a + V[2, 0] * b,\n            #           V[2, 0] * a - V[2, 2] * b)                        # (54)\n            qaz = atan2(V[2, 0] * a - V[2, 2] * b,\n                       -V[2, 2] * a - V[2, 0] * b)                        # (54)\n    \n            a = sin(chi) * sin(mu) - cos(mu) * cos(chi) * sin(eta)\n            b = cos(mu) * cos(eta)\n            phi = atan2(V[1, 1] * a - V[0, 1] * b,\n                        V[0, 1] * a + V[1, 1] * b)                       # (55)\n    #        if is_small(mu+pi/2) and is_small(eta) and False:\n    #            phi_general = phi\n    #            # solved in extensions_to_yous_paper.wxm\n    #            phi = atan2(V[1, 1], V[0, 1])\n    #            logger.debug(""phi = %.3f or %.3f (std)"",\n    #                        phi*TODEG, phi_general*TODEG )\n    \n            return qaz, phi\n\n        def __get_chi_and_qaz(mu, eta):\n            A = sin(mu)\n            B = -cos(mu)*sin(eta)\n            sin_chi = A * V[1,0] + B * V[1,2]\n            cos_chi = B * V[1,0] - A * V[1,2]\n            if is_small(sin_chi) and is_small(cos_chi):\n                raise DiffcalcException(\n                        \'Chi cannot be chosen uniquely. Please choose a different set of constraints.\')\n            chi = atan2(sin_chi, cos_chi)\n\n            A = sin(eta)\n            B = cos(eta)*sin(mu)\n            sin_qaz = A * V[0,1] + B * V[2,1]\n            cos_qaz = B * V[0,1] - A * V[2,1]\n            qaz = atan2(sin_qaz, cos_qaz)\n            return qaz, chi\n\n        N_phi = _calc_N(q_phi, n_phi)\n        THETA = z_rotation(-theta)\n        PSI = x_rotation(psi)\n\n        if \'chi\' in samp_constraints and \'phi\' in samp_constraints:\n\n            chi = samp_constraints[\'chi\']\n            phi = samp_constraints[\'phi\']\n\n            CHI = calcCHI(chi)\n            PHI = calcPHI(phi)\n            V = CHI * PHI * N_phi * PSI.T * THETA.T                     # (46)\n\n            #atan2_xi = atan2(-V[2, 0], V[2, 2])\n            #atan2_eta = atan2(-V[0, 1], V[1, 1])\n            #atan2_mu = atan2(-V[2, 1], sqrt(V[2, 2] ** 2 + V[2, 0] ** 2))\n            try:\n                asin_mu = asin(bound(-V[2, 1]))\n            except AssertionError:\n                return\n            for mu in [asin_mu, pi - asin_mu]:\n                sgn_cosmu = sign(cos(mu))\n                #xi = atan2(-sgn_cosmu * V[2, 0], sgn_cosmu * V[2, 2])\n                qaz = atan2(sgn_cosmu * V[2, 2], sgn_cosmu * V[2, 0], )\n                eta = atan2(-sgn_cosmu * V[0, 1], sgn_cosmu * V[1, 1])\n                yield qaz, psi, mu, eta, chi, phi\n\n        elif \'mu\' in samp_constraints and \'eta\' in samp_constraints:\n\n            mu = samp_constraints[\'mu\']\n            eta = samp_constraints[\'eta\']\n\n            V = N_phi * PSI.T * THETA.T                                  # (49)\n            try:\n                bot = bound(-V[2, 1] / sqrt(sin(eta) ** 2 * cos(mu) ** 2 + sin(mu) ** 2))\n            except AssertionError:\n                return\n            if is_small(cos(mu) * sin(eta)):\n                eps = atan2(sin(eta) * cos(mu), sin(mu))\n                chi_vals = [eps + acos(bot), eps - acos(bot)]\n            else:\n                eps = atan2(sin(mu), sin(eta) * cos(mu))\n                chi_vals = [asin(bot) - eps, pi - asin(bot) - eps]       # (52)\n\n            ## Choose final chi solution here to obtain compatable xi and mu\n            ## TODO: This temporary solution works only for one case used on i07\n            ##       Return a list of possible solutions?\n            #if is_small(eta) and is_small(mu + pi / 2):\n            #    for chi in _generate_transformed_values(chi_orig):\n            #        if  pi / 2 <= chi < pi:\n            #            break\n            #else:\n            #    chi = chi_orig\n\n            for chi in chi_vals:\n                qaz, phi = __get_phi_and_qaz(chi, eta, mu)\n                yield qaz, psi, mu, eta, chi, phi\n\n        elif \'chi\' in samp_constraints and \'eta\' in samp_constraints:\n\n            chi = samp_constraints[\'chi\']\n            eta = samp_constraints[\'eta\']\n\n            V = N_phi * PSI.T * THETA.T                                  # (49)\n            try:\n                bot = bound(-V[2, 1] / sqrt(sin(eta) ** 2 * sin(chi) ** 2 + cos(chi) ** 2))\n            except AssertionError:\n                return\n            if is_small(cos(chi)):\n                eps = atan2(cos(chi), sin(chi) * sin(eta))\n                mu_vals = [eps + acos(bot), eps - acos(bot)]\n            else:\n                eps = atan2(sin(chi) * sin(eta), cos(chi))\n                mu_vals = [asin(bot) - eps, pi - asin(bot) - eps]       # (52)\n\n            for mu in mu_vals:\n                qaz, phi = __get_phi_and_qaz(chi, eta, mu)\n                yield qaz, psi, mu, eta, chi, phi\n\n        elif \'chi\' in samp_constraints and \'mu\' in samp_constraints:\n\n            chi = samp_constraints[\'chi\']\n            mu = samp_constraints[\'mu\']\n\n            V = N_phi * PSI.T * THETA.T                                  # (49)\n\n            try:\n                asin_eta = asin(bound((-V[2, 1] - cos(chi) * sin(mu)) / (sin(chi) * cos(mu))))\n            except AssertionError:\n                return\n\n            for eta in [asin_eta, pi - asin_eta]:\n                qaz, phi = __get_phi_and_qaz(chi, eta, mu)\n                yield qaz, psi, mu, eta, chi, phi\n\n        elif \'mu\' in samp_constraints and \'phi\' in samp_constraints:\n\n            mu = samp_constraints[\'mu\']\n            phi = samp_constraints[\'phi\']\n\n            PHI = calcPHI(phi)\n            V = THETA * PSI * N_phi.I * PHI.T\n\n            if is_small(cos(mu)):\n                raise DiffcalcException(\n                            \'Eta cannot be chosen uniquely. Please choose a different set of constraints.\')\n            try:\n                acos_eta = acos(bound(V[1,1] / cos(mu)))\n            except AssertionError:\n                return\n            for eta in [acos_eta, -acos_eta]:\n                qaz, chi = __get_chi_and_qaz(mu, eta)\n                yield qaz, psi, mu, eta, chi, phi\n\n        elif \'eta\' in samp_constraints and \'phi\' in samp_constraints:\n\n            eta = samp_constraints[\'eta\']\n            phi = samp_constraints[\'phi\']\n\n            PHI = calcPHI(phi)\n            V = THETA * PSI * N_phi.I * PHI.T\n\n            if is_small(cos(eta)):\n                raise DiffcalcException(\n                            \'Mu cannot be chosen uniquely. Please choose a different set of constraints.\')\n            try:\n                acos_mu = acos(bound(V[1,1] / cos(eta)))\n            except AssertionError:\n                return\n            for mu in [acos_mu, -acos_mu]:\n                qaz, chi = __get_chi_and_qaz(mu, eta)\n                yield qaz, psi, mu, eta, chi, phi\n\n        else:\n            raise DiffcalcException(\n                \'No code yet to handle this combination of 2 sample \'\n                \'constraints and one reference!:\' + str(samp_constraints))\n\n    def _calc_sample_angles_given_two_sample_and_detector(\n            self, samp_constraints, qaz, theta, q_phi, n_phi):\n        """"""Available combinations:\n        chi, phi, detector\n        mu, eta, detector\n        mu, phi, detector\n        mu, chi, detector\n        eta, phi, detector\n        eta, chi, detector\n        """"""\n\n        N_phi = _calc_N(q_phi, n_phi)\n\n        if ((\'mu\' in samp_constraints and \'eta\' in samp_constraints) or \n            (\'omega\' in samp_constraints and \'bisect\' in samp_constraints) or\n            (\'mu\' in samp_constraints and \'bisect\' in samp_constraints) or\n            (\'eta\' in samp_constraints and \'bisect\' in samp_constraints)):\n\n            if \'mu\' in samp_constraints and \'eta\' in samp_constraints:\n                mu_vals = [samp_constraints[\'mu\'],]\n                eta_vals = [samp_constraints[\'eta\'],]\n            elif \'omega\' in samp_constraints and \'bisect\' in samp_constraints:\n                omega = samp_constraints[\'omega\']\n                atan_mu = atan(tan(theta + omega) * cos(qaz))\n                asin_eta = asin(sin(theta + omega) * sin(qaz))\n                mu_vals = [atan_mu, atan_mu + pi]\n                if is_small(abs(asin_eta) - pi/2):\n                    eta_vals = [sign(asin_eta) * pi / 2, ]\n                else:\n                    eta_vals = [asin_eta, pi - asin_eta]\n\n            elif \'mu\' in samp_constraints and \'bisect\' in samp_constraints:\n                mu_vals = [samp_constraints[\'mu\'],]\n                cos_qaz = cos(qaz)\n                tan_mu = tan(samp_constraints[\'mu\'])\n                # Vertical scattering geometry with omega = 0\n                if is_small(cos_qaz):\n                    if is_small(tan_mu):\n                        thomega_vals = [theta,]\n                    else:\n                        return\n                else:\n                    atan_thomega = atan(tan_mu / cos_qaz)\n                    thomega_vals = [atan_thomega, pi + atan_thomega]\n                eta_vals = []\n                for thomega in thomega_vals:\n                    asin_eta = asin(sin(thomega) * sin(qaz))\n                    if is_small(abs(asin_eta) - pi/2):\n                        eta_vals.extend([sign(asin_eta) * pi/2,])\n                    else:\n                        eta_vals.extend([asin_eta, pi - asin_eta])\n\n            elif \'eta\' in samp_constraints and \'bisect\' in samp_constraints:\n                eta_vals = [samp_constraints[\'eta\'],]\n                sin_qaz = sin(qaz)\n                sin_eta = sin(samp_constraints[\'eta\'])\n                # Horizontal scattering geometry with omega = 0\n                if is_small(sin_qaz):\n                    if is_small(sin_eta):\n                        thomega_vals = [theta,]\n                    else:\n                        return\n                else:\n                    asin_thomega = asin(sin_eta / sin_qaz)\n                    if is_small(abs(asin_thomega) - pi/2):\n                        thomega_vals = [sign(asin_thomega) * pi/2,]\n                    else:\n                        thomega_vals = [asin_thomega, pi - asin_thomega]\n                mu_vals = []\n                for thomega in thomega_vals:\n                    atan_mu = atan(tan(thomega) * cos(qaz))\n                    mu_vals.extend([atan_mu, pi + atan_mu])\n\n            for mu, eta in product(mu_vals, eta_vals):\n                F = y_rotation(qaz - pi/2.)\n                THETA = z_rotation(-theta)\n                V = calcETA(eta).T * calcMU(mu).T * F * THETA                       # (56)\n\n                phi_vals = []\n                try:\n                    # For the case of (00l) reflection, where N_phi[0,0] = N_phi[1,0] = 0\n                    if is_small(N_phi[0, 0]) and is_small(N_phi[1, 0]):\n                        raise DiffcalcException(\n                                \'Phi cannot be chosen uniquely as q || phi and no reference \'\n                                \'vector or phi constraints have been set.\\nPlease choose a different \'\n                                \'set of constraints.\')\n                    bot = bound(-V[1, 0] / sqrt(N_phi[0, 0]**2 + N_phi[1, 0]**2))\n                    eps = atan2(N_phi[1, 0], N_phi[0, 0])\n                    phi_vals = [asin(bot) + eps, pi - asin(bot) + eps]              # (59)\n                except AssertionError:\n                    continue\n                for phi in phi_vals:\n                    a = N_phi[0, 0] * cos(phi) + N_phi[1, 0] * sin(phi)\n                    chi = atan2(N_phi[2, 0] * V[0, 0] - a * V[2, 0],\n                                N_phi[2, 0] * V[2, 0] + a * V[0, 0])                # (60)\n                    yield mu, eta, chi, phi\n\n        elif \'chi\' in samp_constraints and \'phi\' in samp_constraints:\n\n            chi = samp_constraints[\'chi\']\n            phi = samp_constraints[\'phi\']\n\n            CHI = calcCHI(chi)\n            PHI = calcPHI(phi)\n            V = CHI * PHI * N_phi                     # (62)\n\n            try:\n                bot = bound(V[2, 0] / sqrt(cos(qaz) ** 2 * cos(theta) ** 2 + sin(theta) ** 2))\n            except AssertionError:\n                return\n            eps = atan2(-cos(qaz) * cos(theta), sin(theta))\n            for mu in [asin(bot) + eps, pi - asin(bot) + eps]:\n                a = cos(theta) * sin(qaz)\n                b = -cos(theta) * sin(mu) * cos(qaz) + cos(mu) * sin(theta)\n                X = V[1, 0] * a + V[0, 0] * b\n                Y = V[0, 0] * a - V[1, 0]* b\n                if is_small(X) and is_small(Y):\n                    raise DiffcalcException(\n                            \'Eta cannot be chosen uniquely as q || eta and no reference \'\n                            \'vector or eta constraints have been set.\\nPlease choose a different \'\n                            \'set of constraints.\')\n                eta = atan2(X, Y)\n                \n                #a = -cos(mu) * cos(qaz) * sin(theta) + sin(mu) * cos(theta)\n                #b = cos(mu) * sin(qaz)\n                #psi = atan2(-V[2, 2] * a - V[2, 1] * b, V[2, 1] * a - V[2, 2] * b)\n                yield mu, eta, chi, phi\n\n        elif \'mu\' in samp_constraints and \'phi\' in samp_constraints:\n\n            mu = samp_constraints[\'mu\']\n            phi = samp_constraints[\'phi\']\n\n            F = y_rotation(qaz - pi/2.)\n            THETA = z_rotation(-theta)\n            V = calcMU(mu).T * F * THETA\n            E = calcPHI(phi) * N_phi\n            \n            try:\n                bot = bound(-V[2, 0] / sqrt(E[0, 0]**2 + E[2, 0]**2))\n            except AssertionError:\n                return\n            eps = atan2(E[2, 0], E[0, 0])\n            for chi in [asin(bot) + eps, pi - asin(bot) + eps]:\n                a = E[0, 0] * cos(chi) + E[2, 0] * sin(chi)\n                eta = atan2(V[0, 0] * E[1, 0] - V[1, 0] * a, V[0, 0] * a + V[1, 0] * E[1, 0])\n                yield mu, eta, chi, phi\n\n        elif \'mu\' in samp_constraints and \'chi\' in samp_constraints:\n\n            mu = samp_constraints[\'mu\']\n            chi = samp_constraints[\'chi\']\n            \n            V20 = cos(mu)*cos(qaz)*cos(theta) + sin(mu)*sin(theta)\n            A = N_phi[1,0]\n            B = N_phi[0,0]\n            if is_small(sin(chi)):\n                raise DiffcalcException(\n                        \'Degenerate configuration with phi || eta axes cannot be set uniquely. Please choose a different set of constraints.\')\n            if is_small(A) and is_small(B):\n                raise DiffcalcException(\n                        \'Phi cannot be chosen uniquely. Please choose a different set of constraints.\')\n            else:\n                ks = atan2(A, B)\n            try:\n                acos_phi = acos(bound((N_phi[2,0]*cos(chi) - V20)/(sin(chi) * sqrt(A**2 + B**2))))\n            except AssertionError:\n                return\n            if is_small(acos_phi):\n                phi_list = [ks,]\n            else:\n                phi_list = [acos_phi + ks, -acos_phi + ks]\n            for phi in phi_list:\n                A00 = -cos(qaz)*cos(theta)*sin(mu) + cos(mu)*sin(theta)\n                B00 =  sin(qaz)*cos(theta)\n                V00 = N_phi[0,0]*cos(chi)*cos(phi) + N_phi[1,0]*cos(chi)*sin(phi) + N_phi[2,0]*sin(chi)\n                V10 = N_phi[1,0]*cos(phi) - N_phi[0,0]*sin(phi)\n                sin_eta = (V00*A00 + V10*B00) \n                cos_eta = (V00*B00 - V10*A00)\n                if is_small(A00) and is_small(B00):\n                    raise DiffcalcException(\n                            \'Eta cannot be chosen uniquely. Please choose a different set of constraints.\')\n                eta = atan2(sin_eta, cos_eta)\n                yield mu, eta, chi, phi\n\n        elif \'eta\' in samp_constraints and \'phi\' in samp_constraints:\n\n            eta = samp_constraints[\'eta\']\n            phi = samp_constraints[\'phi\']\n\n            X = N_phi[2,0]\n            Y = (N_phi[0,0]*cos(phi)+N_phi[1,0]*sin(phi))\n            if is_small(X) and is_small(Y):\n                raise DiffcalcException(\n                        \'Chi cannot be chosen uniquely as q || chi and no reference \'\n                        \'vector or chi constraints have been set.\\nPlease choose a different \'\n                        \'set of constraints.\')\n\n            V = (N_phi[1,0]*cos(phi)-N_phi[0,0]*sin(phi)) * tan(eta)\n            sgn = sign(cos(eta))\n            eps = atan2(X*sgn, Y*sgn)\n            try:\n                acos_rhs = acos(bound((sin(qaz)*cos(theta)/cos(eta) - V) / sqrt(X**2 + Y**2)))\n            except AssertionError:\n                return\n            if is_small(acos_rhs):\n                acos_list = [eps,]\n            else:\n                acos_list = [eps + acos_rhs, eps - acos_rhs]\n            for chi in acos_list:\n                A = (N_phi[0,0]*cos(phi) + N_phi[1,0]*sin(phi))*sin(chi) - N_phi[2,0]*cos(chi)\n                B = -N_phi[2,0]*sin(chi)*sin(eta) - cos(chi)*sin(eta)*(N_phi[0,0]*cos(phi)+N_phi[1,0]*sin(phi)) \\\n                                                           - cos(eta)*(N_phi[0,0]*sin(phi)-N_phi[1,0]*cos(phi))\n                ks = atan2(A, B)\n                mu = atan2(cos(theta)*cos(qaz), -sin(theta)) + ks\n                yield mu, eta, chi, phi\n\n        elif \'eta\' in samp_constraints and \'chi\' in samp_constraints:\n\n            eta = samp_constraints[\'eta\']\n            chi = samp_constraints[\'chi\']\n\n            A = N_phi[1,0]*cos(chi)*cos(eta) - N_phi[0,0]*sin(eta)\n            B = N_phi[0,0]*cos(chi)*cos(eta) + N_phi[1,0]*sin(eta)\n            if is_small(A) and is_small(B):\n                raise DiffcalcException(\n                        \'Phi cannot be chosen uniquely. Please choose a different set of constraints.\')\n            else:\n                ks = atan2(A, B)\n            try:\n                acos_V00 = acos(bound((cos(theta)*sin(qaz) - N_phi[2,0]*cos(eta)*sin(chi))/sqrt(A**2 + B**2)))\n            except AssertionError:\n                return\n            if is_small(acos_V00):\n                phi_list = [ks,]\n            else:\n                phi_list = [acos_V00 + ks, -acos_V00 + ks]\n            for phi in phi_list:\n                A10 = N_phi[0,0]*cos(phi)*sin(chi) + N_phi[1,0]*sin(chi)*sin(phi) - N_phi[2,0]*cos(chi)\n                B10 = -N_phi[2,0]*sin(chi)*sin(eta) - (cos(chi)*cos(phi)*sin(eta) + cos(eta)*sin(phi))*N_phi[0,0] - \\\n                                                      (cos(chi)*sin(eta)*sin(phi) - cos(eta)*cos(phi))*N_phi[1,0]\n                V10 = -sin(theta)\n                A20 = -N_phi[2,0]*sin(chi)*sin(eta) - (cos(chi)*cos(phi)*sin(eta) + cos(eta)*sin(phi))*N_phi[0,0] - \\\n                                                      (cos(chi)*sin(eta)*sin(phi) - cos(eta)*cos(phi))*N_phi[1,0]\n                B20 = -N_phi[0,0]*cos(phi)*sin(chi) - N_phi[1,0]*sin(chi)*sin(phi) + N_phi[2,0]*cos(chi)\n                V20 = cos(qaz)*cos(theta)\n                sin_mu = (V10*B20 - V20*B10) * sign(A10*B20 - A20*B10)\n                cos_mu = (V10*A20 - V20*A10) * sign(B10*A20 - B20*A10)\n                if is_small(sin_mu) and is_small(cos_mu):\n                    raise DiffcalcException(\n                            \'Mu cannot be chosen uniquely. Please choose a different set of constraints.\')\n                mu = atan2(sin_mu, cos_mu)\n                yield mu, eta, chi, phi\n\n        else:\n            raise DiffcalcException(\n                \'No code yet to handle this combination of 2 sample \'\n                \'constraints and one detector!:\' + str(samp_constraints))\n\n    def _filter_angle_limits(self, possible_solutions, filter_out_of_limits=True):\n        res = []\n        angle_names = settings.hardware.get_axes_names()\n        for possible_solution in possible_solutions:\n            hw_sol = []\n            hw_possible_solution = settings.geometry.internal_position_to_physical_angles(YouPosition(*possible_solution, unit=\'RAD\'))\n            for name, value in zip(angle_names, hw_possible_solution):\n                hw_sol.append(settings.hardware.cut_angle(name, value))\n            if filter_out_of_limits:\n                is_in_limits = settings.hardware.is_position_within_limits(hw_sol)\n            else:\n                is_in_limits = True\n            if is_in_limits:\n                sol = settings.geometry.physical_angles_to_internal_position(tuple(hw_sol))\n                sol.changeToRadians()\n                res.append(sol.totuple())\n        return res\n'"
diffcalc/hkl/you/constraints.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.util import DiffcalcException, bold\nfrom diffcalc.settings import NUNAME\n\nTODEG = 180 / pi\nTORAD = pi / 180\n\ndef filter_dict(d, keys):\n    """"""Return a copy of d containing only keys that are in keys""""""\n    ##return {k: d[k] for k in keys} # requires Python 2.6\n    return dict((k, d[k]) for k in keys if k in d.keys())\n\n\ndet_constraints = (\'delta\', NUNAME, \'qaz\', \'naz\')\nif settings.include_reference:\n    ref_constraints = (\'a_eq_b\', \'alpha\', \'beta\', \'psi\', \'bin_eq_bout\', \'betain\', \'betaout\')\n    valueless_constraints = (\'a_eq_b\', \'bin_eq_bout\', \'mu_is_\' + NUNAME, \'bisect\')\nelse:\n    ref_constraints = (\'bin_eq_bout\', \'betain\', \'betaout\')\n    valueless_constraints = (\'bin_eq_bout\', \'mu_is_\' + NUNAME, \'bisect\')\nsamp_constraints = (\'mu\', \'eta\', \'chi\', \'phi\', \'mu_is_\' + NUNAME, \'bisect\', \'omega\')\n\nall_constraints = det_constraints + ref_constraints + samp_constraints\n\n\nnumber_single_sample = (len(det_constraints) * len(ref_constraints) *\n                        len(samp_constraints))\n\n\nclass YouConstraintManager(object):\n\n    def __init__(self, fixed_constraints = {}):\n        self._constrained = {}\n#        self._tracking = []\n        self.n_phi = matrix([[0], [0], [1]])\n        self._hide_detector_constraint = False # default\n        self._fixed_samp_constraints = ()\n        self._fix_constraints(fixed_constraints)\n\n    def __str__(self):\n        lines = []\n#        TODO: Put somewhere with access to UB matrix!\n#        WIDTH = 13\n#        n_phi = self.n_phi\n#        fmt = ""% 9.5f % 9.5f % 9.5f""\n#        lines.append(""   n_phi:"".ljust(WIDTH) +\n#                     fmt % (n_phi[0, 0], n_phi[1, 0], n_phi[2, 0]))\n#        if self._getUBMatrix():\n#            n_cryst = self._getUMatrix().I * self.n_phi\n#            lines.append(""   n_cryst:"".ljust(WIDTH) +\n#                         fmt % (n_cryst[0, 0], n_cryst[1, 0], n_cryst[2, 0]))\n#            n_recip = self._getUBMatrix().I * self.n_phi\n#            lines.append(""   n_recip:"".ljust(WIDTH) +\n#                         fmt % (n_recip[0, 0], n_recip[1, 0], n_recip[2, 0]))\n#        else:\n#            lines.append(\n#                ""   n_cryst:"".ljust(WIDTH) + \' ""<<< No  U matrix >>>""\')\n#            lines.append(\n#                ""   n_recip:"".ljust(WIDTH) + \' ""<<< No UB matrix >>>""\')\n\n        lines.extend(self.build_display_table_lines())\n        lines.append("""")\n        lines.extend(self.report_constraints_lines())\n        lines.append("""")\n        if (self.is_fully_constrained() and\n            not self.is_current_mode_implemented()):\n            lines.append(\n                ""    Sorry, this constraint combination is not implemented"")\n            lines.append(""    Type \'help con\' for available combinations"")\n        else:\n            lines.append(""    Type \'help con\' for instructions"")  # okay\n        return \'\\n\'.join(lines)\n\n    @property\n    def available_constraint_names(self):\n        """"""list of all available constraints""""""\n        return all_constraints\n\n    @property\n    def settable_constraint_names(self):\n        """"""list of all available constraints that have settable values""""""\n        all_copy = list(all_constraints)\n        for valueless in valueless_constraints:\n            all_copy.remove(valueless)\n        return all_copy\n\n    @property\n    def all(self):  # @ReservedAssignment\n        """"""dictionary of all constrained values""""""\n        return self._constrained.copy()\n\n    @property\n    def detector(self):\n        """"""dictionary of constrained detector circles""""""\n        return filter_dict(self.all, det_constraints[:-1])\n\n    @property\n    def reference(self):\n        """"""dictionary of constrained reference circles""""""\n        return filter_dict(self.all, ref_constraints)\n\n    @property\n    def sample(self):\n        """"""dictionary of constrained sample circles""""""\n        return filter_dict(self.all, samp_constraints)\n\n    @property\n    def naz(self):\n        """"""dictionary with naz and value if constrained""""""\n        return filter_dict(self.all, (\'naz\',))\n\n    @property\n    def constrained_names(self):\n        """"""ordered tuple of constained circles""""""\n        names = self.all.keys()\n        names.sort(key=lambda name: list(all_constraints).index(name))\n        return tuple(names)\n\n    @property\n    def available_names(self):\n        """"""ordered tuple of fixed circles""""""\n        names = [name for name in self.all.keys() if not self.is_constraint_fixed(name)]\n        names.sort(key=lambda name: list(all_constraints).index(name))\n        return tuple(names)\n\n    def _fix_constraints(self, fixed_constraints):\n        for name in fixed_constraints:\n            self.constrain(name)\n            self.set_constraint(name, fixed_constraints[name])\n        \n        if self.detector or self.naz:    \n            self._hide_detector_constraint = True\n        \n        fixed_samp_constraints = list(self.sample.keys())\n        if \'mu\' in self.sample or NUNAME in self.detector:\n            fixed_samp_constraints.append(\'mu_is_\' + NUNAME)\n        self._fixed_samp_constraints = tuple(fixed_samp_constraints)\n        \n\n    def is_constrained(self, name):\n        return name in self._constrained\n\n    def get_value(self, name):\n        return self._constrained[name]\n\n    def build_display_table_lines(self):\n        unfixed_samp_constraints = list(samp_constraints)\n        for name in self._fixed_samp_constraints:\n            unfixed_samp_constraints.remove(name)\n        if self._hide_detector_constraint:\n            constraint_types = (ref_constraints, unfixed_samp_constraints)\n        else:\n            constraint_types = (det_constraints, ref_constraints,\n                                unfixed_samp_constraints)\n        num_rows = max([len(col) for col in constraint_types])\n        max_name_width = max(\n            [len(name) for name in sum(constraint_types[:-1], ())])\n        \n        cells = []\n        \n        header_cells = []\n        if not self._hide_detector_constraint:\n            header_cells.append(bold(\'    \' + \'DET\'.ljust(max_name_width)))\n        header_cells.append(bold(\'    \' + \'REF\'.ljust(max_name_width)))\n        header_cells.append(bold(\'    \' + \'SAMP\'))\n        cells.append(header_cells)\n        \n        underline_cells = [\'    \' + \'-\' * max_name_width] * len(constraint_types)\n        cells.append(underline_cells)\n        \n        for n_row in range(num_rows):\n            row_cells = []\n            for col in constraint_types:\n                name = col[n_row] if n_row < len(col) else \'\'\n                row_cells.append(self._label_constraint(name))\n                ext_name = settings.geometry.map_to_external_name(name)\n                row_cells.append((\'%-\' + str(max_name_width) + \'s\') % ext_name)\n            cells.append(row_cells)\n        \n        lines = [\' \'.join(row_cells).rstrip() for row_cells in cells]\n        return lines\n\n    def _report_constraint(self, name):\n        val = self.get_constraint(name)\n        ext_name = settings.geometry.map_to_external_name(name)\n        if name in valueless_constraints:\n            return ""    %s"" % ext_name\n        else:\n            if val is None:\n                return ""!   %-5s: ---"" % ext_name\n            else:\n                ext_name, ext_val = settings.geometry.map_to_external_position(name, val)\n                return ""    %-5s: %.4f"" % (ext_name, ext_val)\n\n    def report_constraints_lines(self):\n        lines = []\n        required = 3 - len(self.all)\n        if required == 0:\n            pass\n        elif required == 1:\n            lines.append(\'!   1 more constraint required\')\n        else:\n            lines.append(\'!   %d more constraints required\' % required)\n        lines.extend([self._report_constraint(name) for name in self.available_names])\n        return lines\n\n    def is_fully_constrained(self):\n        return len(self.all) == 3\n\n    def is_current_mode_implemented(self):\n        if not self.is_fully_constrained():\n            raise ValueError(""Three constraints required"")\n        \n        if len(self.sample) == 3:\n            if (set(self.sample.keys()) == set([\'chi\', \'phi\', \'eta\']) or\n               set(self.sample.keys()) == set([\'chi\', \'phi\', \'mu\']) or\n               set(self.sample.keys()) == set([\'chi\', \'eta\', \'mu\']) or\n               set(self.sample.keys()) == set([\'phi\', \'eta\', \'mu\'])):\n                return True\n            return False\n\n        if len(self.sample) == 1:\n            return (\'omega\' not in set(self.sample.keys()) and\n                    \'bisect\' not in set(self.sample.keys()))\n\n        if len(self.reference) == 1:\n            return (set(self.sample.keys()) == set([\'chi\', \'phi\']) or\n                    set(self.sample.keys()) == set([\'chi\', \'eta\']) or\n                    set(self.sample.keys()) == set([\'chi\', \'mu\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'eta\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'phi\']) or\n                    set(self.sample.keys()) == set([\'eta\', \'phi\']))\n\n        if len(self.detector) == 1:\n            return (set(self.sample.keys()) == set([\'chi\', \'phi\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'eta\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'phi\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'chi\']) or\n                    set(self.sample.keys()) == set([\'eta\', \'phi\']) or\n                    set(self.sample.keys()) == set([\'eta\', \'chi\']) or\n                    set(self.sample.keys()) == set([\'mu\', \'bisect\']) or\n                    set(self.sample.keys()) == set([\'eta\', \'bisect\']) or\n                    set(self.sample.keys()) == set([\'omega\', \'bisect\']))\n        \n        return False\n        \n\n    def _label_constraint(self, name):\n        if name == \'\':\n            label = \'   \'\n#        elif self.is_tracking(name):  # implies constrained\n#            label = \'~~> \'\n        elif (self.is_constrained(name) and (self.get_value(name) is None) and\n            name not in valueless_constraints):\n            label = \'o->\'\n        elif self.is_constrained(name):\n            label = \'-->\'\n        else:\n            label = \'   \'\n        return label\n\n    def constrain(self, name):\n        ext_name = settings.geometry.map_to_external_name(name)\n        if self.is_constraint_fixed(name):\n            raise DiffcalcException(\'%s constraint cannot be changed\' % ext_name)\n        if name in self.all:\n            return ""%s is already constrained."" % ext_name.capitalize()\n        elif name in det_constraints:\n            return self._constrain_detector(name)\n        elif name in ref_constraints:\n            return self._constrain_reference(name)\n        elif name in samp_constraints:\n            return self._constrain_sample(name)\n        else:\n            raise DiffcalcException(""%s is not a valid constraint name. Type \'con\' for a table of constraint name"" % ext_name)\n\n    def is_constraint_fixed(self, name):\n        return ((name in det_constraints and self._hide_detector_constraint) or\n                (name in samp_constraints and name in self._fixed_samp_constraints))\n\n    def _constrain_detector(self, name):\n        if self.naz:\n            del self._constrained[\'naz\']\n            self._constrained[name] = None\n            return \'Naz constraint replaced.\'\n        elif self.detector:\n            constrained_name = self.detector.keys()[0]\n            del self._constrained[constrained_name]\n            self._constrained[name] = None\n            return\'%s constraint replaced.\' % constrained_name.capitalize()\n        elif len(self.all) == 3:  # and no detector\n            raise self._could_not_constrain_exception(name)\n        else:\n            self._constrained[name] = None\n\n    def _could_not_constrain_exception(self, name):\n        ext_name = settings.geometry.map_to_external_name(name)\n        names = [settings.geometry.map_to_external_name(nm) for nm in self.available_names]\n        if len(names) > 1:\n            names_fmt = \'one of the\\nangles \' + \', \'.join(names[:-1]) + \' or \' + names[-1]\n        else:\n            names_fmt = \'angle \' + names[0]\n        return DiffcalcException(\n            ""%s could not be constrained. First un-constrain %s ""\n            ""(with \'uncon\')"" %\n            (ext_name.capitalize(), names_fmt))\n\n    def _constrain_reference(self, name):\n        if self.reference:\n            constrained_name = self.reference.keys()[0]\n        elif len(self._constrained) < 3:\n            constrained_name = None\n        elif len(self.available_names) == 1:\n            constrained_name = self.available_names[0]\n        else:\n            raise self._could_not_constrain_exception(name)\n        try:\n            del self._constrained[constrained_name]\n            self._constrained[name] = None\n            ext_constrained_name = settings.geometry.map_to_external_name(constrained_name)\n            return \'%s constraint replaced.\' % ext_constrained_name.capitalize()\n        except KeyError:\n            self._constrained[name] = None\n\n    def _constrain_sample(self, name):\n        if len(self._constrained) < 3:\n            constrained_name = None\n        elif len(self.available_names) == 1:\n            # Only one settable constraint\n            constrained_name = self.available_names[0]\n        elif len(self.sample) == 1:\n            # (detector and reference constraints set)\n            # it is clear which sample constraint to remove\n            constrained_name = self.sample.keys()[0]\n            if self.is_constraint_fixed(constrained_name):\n                raise self._could_not_constrain_exception(name)\n        else:\n            # else: three constraints are set\n            raise self._could_not_constrain_exception(name)\n        try:\n            del self._constrained[constrained_name]\n            self._constrained[name] = None\n            ext_constrained_name = settings.geometry.map_to_external_name(constrained_name)\n            return \'%s constraint replaced.\' % ext_constrained_name.capitalize()\n        except KeyError:\n            self._constrained[name] = None\n\n    def unconstrain(self, name):\n        ext_name = settings.geometry.map_to_external_name(name)\n        if self.is_constraint_fixed(name):\n            raise DiffcalcException(\'%s constraint cannot be removed\' % ext_name)\n        if name in self._constrained:\n            del self._constrained[name]\n        else:\n            return ""%s was not already constrained."" % ext_name.capitalize()\n\n    def _check_constraint_settable(self, name):\n        ext_name = settings.geometry.map_to_external_name(name)\n        if name not in all_constraints:\n            raise DiffcalcException(\n                \'Could not set %(ext_name)s. This is not an available \'\n                \'constraint.\' % locals())\n        elif name not in self.all.keys():\n            raise DiffcalcException(\n                \'Could not set %(ext_name)s. This is not currently \'\n                \'constrained.\' % locals())\n        elif name in valueless_constraints:\n            raise DiffcalcException(\n                \'Could not set %(ext_name)s. This constraint takes no \'\n                \'value.\' % locals())\n\n    def clear_constraints(self):\n        self._constrained = {}\n\n    def set_constraint(self, name, value):  # @ReservedAssignment\n        ext_name = settings.geometry.map_to_external_name(name)\n        if self.is_constraint_fixed(name):\n            raise DiffcalcException(\'%s constraint cannot be changed\' % ext_name)\n        self._check_constraint_settable(name)\n#        if name in self._tracking:\n#            raise DiffcalcException(\n#                ""Could not set %s as this constraint is configured to track ""\n#                ""its associated\\nphysical angle. First remove this tracking ""\n#                ""(use \'untrack %s\')."""""" % (name, name))\n        old_value = self.get_constraint(name)\n        try:\n            old_str = \'---\' if old_value is None else str(old_value)\n        except Exception:\n            old_str = \'---\'\n        try:\n            self._constrained[name] = float(value) * TORAD\n        except Exception:\n            raise DiffcalcException(\'Cannot set %s constraint. Invalid input value.\' % ext_name)\n        try:\n            new_str = \'---\' if value is None else str(value)\n        except Exception:\n            new_str = \'---\'\n        return ""%s : %s --> %s"" % (name, old_str, new_str)\n\n    def get_constraint(self, name):\n        value = self.all[name]\n        return None if value is None else value * TODEG\n    '"
diffcalc/hkl/you/geometry.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\n\nfrom diffcalc.util import AbstractPosition, DiffcalcException\nfrom diffcalc import settings\n\nTORAD = pi / 180\nTODEG = 180 / pi\nfrom diffcalc.util import x_rotation, z_rotation, y_rotation\n\nfrom diffcalc.settings import NUNAME\n\nclass YouGeometry(object):\n\n    def __init__(self, name, fixed_constraints, beamline_axes_transform=None):\n        self.name = name\n        self.fixed_constraints = fixed_constraints\n        # beamline_axes_transform matrix is composed of columns of the\n        # beamline basis vector coordinates in the diffcalc coordinate system,\n        # i.e. it transforms the beamline coordinate system into the diffcalc one.\n        self.beamline_axes_transform = beamline_axes_transform\n\n    def map_to_internal_position(self, name, value):\n        return name, value\n\n    def map_to_external_position(self, name, value):\n        return name, value\n\n    def map_to_internal_name(self, name):\n        return name\n\n    def map_to_external_name(self, name):\n        return name\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        raise NotImplementedError()\n\n    def internal_position_to_physical_angles(self, internal_position):\n        raise NotImplementedError()\n\n    def create_position(self, *args):\n        return YouPosition(*args, unit=\'DEG\')\n\n\nclass YouRemappedGeometry(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, eta, chi, phi\n    """"""\n    def __init__(self, name, fixed_constraints, beamline_axes_transform=None):\n        YouGeometry.__init__(self, name, fixed_constraints, beamline_axes_transform)\n\n        # Order should match scannable order in _fourc group for mapping to work correctly\n        self._scn_mapping_to_int = ()\n        self._scn_mapping_to_ext = ()\n\n    def map_to_internal_name(self, name):\n        scn_names = settings.hardware.diffhw.getInputNames()\n        try:\n            idx_name = scn_names.index(name)\n            you_name, _ = self._scn_mapping_to_int[idx_name]\n            return you_name\n        except ValueError:\n            return name\n\n    def map_to_external_name(self, name):\n        scn_names = settings.hardware.diffhw.getInputNames()\n        for idx, (you_name, _) in enumerate(self._scn_mapping_to_ext):\n            if you_name == name:\n                return scn_names[idx]\n        return name\n\n    def map_to_internal_position(self, name, value):\n        scn_names = settings.hardware.diffhw.getInputNames()\n        try:\n            idx_name = scn_names.index(name)\n        except ValueError:\n            return name, value\n        new_name, op = self._scn_mapping_to_int[idx_name]\n        try:\n            return new_name, op(value)\n        except TypeError:\n            return new_name, None\n\n    def map_to_external_position(self, name, value):\n        try:\n            (idx, _, op), = tuple((i, nm, o) for i, (nm, o) in enumerate(self._scn_mapping_to_ext) if nm == name)\n        except ValueError:\n            return name, value\n        scn_names = settings.hardware.diffhw.getInputNames()\n        try:\n            ext_name = scn_names[idx]\n        except ValueError:\n            return name, value\n        try:\n            return ext_name, op(value)\n        except TypeError:\n            return ext_name, None\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        you_angles = {}\n        scn_names = settings.hardware.diffhw.getInputNames()\n        for scn_name, phys_angle in zip(scn_names, physical_angle_tuple):\n            name, val = self.map_to_internal_position(scn_name, phys_angle)\n            you_angles[name] = val\n        you_angles.update(self.fixed_constraints)\n\n        angle_values = tuple(you_angles[name] for name in YouPosition.get_names())\n        return YouPosition(*angle_values, unit=\'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        you_angles = clone_position.todict()\n        res = []\n        for name, _ in self._scn_mapping_to_ext:\n            _, val = self.map_to_external_position(name, you_angles[name])\n            res.append(val)\n        return tuple(res)\n\n#==============================================================================\n#==============================================================================\n# Geometry plugins for use with \'You\' hkl calculation engine\n#==============================================================================\n#==============================================================================\n\n\nclass SixCircle(YouGeometry):\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'sixc\', {}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        return YouPosition(*physical_angle_tuple, unit=\'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        return clone_position.totuple()\n\n\nclass FourCircle(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'fourc\', {\'mu\': 0, NUNAME: 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        delta, eta, chi, phi = physical_angle_tuple\n        return YouPosition(0, delta, 0, eta, chi, phi, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        _, delta, _, eta, chi, phi = clone_position.totuple()\n        return delta, eta, chi, phi\n\n\nclass FiveCircle(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, nu, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'fivec\', {\'mu\': 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        delta, nu, eta, chi, phi = physical_angle_tuple\n        return YouPosition(0, delta, nu, eta, chi, phi, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        _, delta, nu, eta, chi, phi = clone_position.totuple()\n        return delta, nu, eta, chi, phi\n\n\n#==============================================================================\n\n\ndef create_you_matrices(mu=None, delta=None, nu=None, eta=None, chi=None,\n                        phi=None):\n    """"""\n    Create transformation matrices from H. You\'s paper.\n    """"""\n    MU = None if mu is None else calcMU(mu)\n    DELTA = None if delta is None else calcDELTA(delta)\n    NU = None if nu is None else calcNU(nu)\n    ETA = None if eta is None else calcETA(eta)\n    CHI = None if chi is None else calcCHI(chi)\n    PHI = None if phi is None else calcPHI(phi)\n    return MU, DELTA, NU, ETA, CHI, PHI\n\n\ndef calcNU(nu):\n    return x_rotation(nu)\n\n\ndef calcDELTA(delta):\n    return z_rotation(-delta)\n\n\ndef calcMU(mu_or_alpha):\n    return x_rotation(mu_or_alpha)\n\n\ndef calcETA(eta):\n    return z_rotation(-eta)\n\n\ndef calcCHI(chi):\n    return y_rotation(chi)\n\n\ndef calcPHI(phi):\n    return z_rotation(-phi)\n\n\nclass YouPosition(AbstractPosition):\n\n    def __init__(self, mu, delta, nu, eta, chi, phi, unit):\n        self.mu = mu\n        self.delta = delta\n        self.nu = nu\n        self.eta = eta\n        self.chi = chi\n        self.phi = phi\n        if unit not in [\'DEG\', \'RAD\']:\n            raise DiffcalcException(""Invalid angle unit value %s."" % str(unit))\n        else:\n            self.unit = unit\n\n    def clone(self):\n        return YouPosition(self.mu, self.delta, self.nu, self.eta, self.chi,\n                           self.phi, self.unit)\n\n    def changeToRadians(self):\n        if self.unit == \'DEG\':\n            self.mu *= TORAD\n            self.delta *= TORAD\n            self.nu *= TORAD\n            self.eta *= TORAD\n            self.chi *= TORAD\n            self.phi *= TORAD\n            self.unit = \'RAD\'\n        elif self.unit == \'RAD\':\n            return\n        else:\n            raise DiffcalcException(""Invalid angle unit value %s."" % str(self.unit))\n\n    def changeToDegrees(self):\n        if self.unit == \'RAD\':\n            self.mu *= TODEG\n            self.delta *= TODEG\n            self.nu *= TODEG\n            self.eta *= TODEG\n            self.chi *= TODEG\n            self.phi *= TODEG\n            self.unit = \'DEG\'\n        elif self.unit == \'DEG\':\n            return\n        else:\n            raise DiffcalcException(""Invalid angle unit value %s."" % str(self.unit))\n\n    @staticmethod\n    def get_names():\n        return (\'mu\', \'delta\', NUNAME, \'eta\', \'chi\', \'phi\')\n\n    def totuple(self):\n        return (self.mu, self.delta, self.nu, self.eta, self.chi, self.phi)\n\n    def todict(self):\n        return dict(zip(self.get_names(), self.totuple()))\n\n    def __str__(self):\n        fmt_tuple = sum(zip(self.get_names(), self.totuple()), ()) + (self.unit,)\n        return (""YouPosition(%s: %r %s: %r %s: %r %s: %r %s: %r  %s: %r) in %s""\n                % fmt_tuple)\n    \n    def __eq__(self, other):\n        return self.totuple() == other.totuple()\n\n\nclass WillmottHorizontalPosition(YouPosition):\n\n    def __init__(self, delta=None, gamma=None, omegah=None, phi=None):\n        self.mu = 0\n        self.delta = delta\n        self.nu = gamma\n        self.eta = omegah\n        self.chi = -90\n        self.phi = phi\n        self.unit= \'DEG\'\n'"
diffcalc/hkl/you/hkl.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom __future__ import absolute_import\n\nfrom diffcalc.hkl.common import getNameFromScannableOrString\nfrom diffcalc.util import command\nfrom diffcalc.hkl.you.calc import YouHklCalculator\nfrom diffcalc import settings\n\n\n\nimport diffcalc.ub.ub\nfrom diffcalc.hkl.you.constraints import YouConstraintManager\n\n__all__ = [\'allhkl\', \'con\', \'uncon\', \'hklcalc\', \'constraint_manager\']\n\n\n_fixed_constraints = settings.geometry.fixed_constraints  # @UndefinedVariable\n\nconstraint_manager = YouConstraintManager(_fixed_constraints)\n\nhklcalc = YouHklCalculator(diffcalc.ub.ub.ubcalc, constraint_manager)\n\n\ndef __str__(self):\n    return hklcalc.__str__()\n\n@command\ndef con(*args):\n    """"""\n    con -- list available constraints and values\n    con <name> {val} -- constrains and optionally sets one constraint\n    con <name> {val} <name> {val} <name> {val} -- clears and then fully constrains\n\n    Select three constraints using \'con\' and \'uncon\'. Choose up to one\n    from each of the sample and detector columns and up to three from\n    the sample column.\n\n    Not all constraint combinations are currently available:\n\n        1 x samp:              all\n\n        2 x samp and 1 x ref:  chi & phi\n                               chi & eta\n                               chi & mu\n                               mu & eta\n                               mu & phi\n                               eta & phi\n\n        2 x samp and 1 x det:  chi & phi\n                               mu & eta\n                               mu & phi\n                               mu & chi\n                               eta & phi\n                               eta & chi\n                               bisect & mu\n                               bisect & eta\n                               bisect & omega\n\n        3 x samp:              eta, chi & phi\n                               mu, chi & phi  \n                               mu, eta & phi  \n                               mu, eta & chi  \n\n    See also \'uncon\'\n    """"""\n    args = list(args)\n    msg = _handle_con(args)\n    if (hklcalc.constraints.is_fully_constrained() and \n        not hklcalc.constraints.is_current_mode_implemented()):\n        msg += (""\\n\\nWARNING: The selected constraint combination ""\n            ""is not implemented.\\n\\nType \'help con\' to see implemented combinations"")\n    if msg:\n        print msg\n\n    diffcalc.ub.ub.ubcalc.save()\n\n\ndef _handle_con(args):\n    if not args:\n        return hklcalc.constraints.__str__()\n    \n    if len(args) > 6:\n        raise TypeError(""Unexpected args: "" + str(args))\n    \n    cons_value_pairs = []\n    while args:\n        scn_or_str = args.pop(0)\n        ext_name = getNameFromScannableOrString(scn_or_str)\n        if args and isinstance(args[0], (int, long, float)):\n            ext_value = args.pop(0)\n        else:\n            try:\n                ext_value = settings.hardware.get_position_by_name(ext_name)\n            except ValueError:\n                ext_value = None\n        cons_name, cons_value = settings.geometry.map_to_internal_position(ext_name, ext_value)\n        cons_value_pairs.append((cons_name, cons_value))\n    \n    if len(cons_value_pairs) == 1:\n        pass\n    elif len(cons_value_pairs) == 3:\n        hklcalc.constraints.clear_constraints()\n    else:\n        raise TypeError(""Either one or three constraints must be specified"")\n    for name, value in cons_value_pairs:\n        hklcalc.constraints.constrain(name)\n        if value is not None:\n            hklcalc.constraints.set_constraint(name, value)\n    return \'\\n\'.join(hklcalc.constraints.report_constraints_lines())\n\n\n@command\ndef uncon(scn_or_string):\n    """"""uncon <name> -- remove constraint\n\n    See also \'con\'\n    """"""\n    ext_name = getNameFromScannableOrString(scn_or_string)\n    cons_name = settings.geometry.map_to_internal_name(ext_name)\n    hklcalc.constraints.unconstrain(cons_name)\n    print \'\\n\'.join(hklcalc.constraints.report_constraints_lines())\n\n    diffcalc.ub.ub.ubcalc.save()\n\n\n@command \ndef allhkl(hkl, wavelength=None):\n    """"""allhkl [h k l] -- print all hkl solutions ignoring limits\n\n    """"""\n    _hardware = settings.hardware\n    _geometry = settings.geometry\n    if wavelength is None:\n        wavelength = _hardware.get_wavelength()\n    h, k, l = hkl\n    pos_virtual_angles_pairs = hklcalc.hkl_to_all_angles(\n                                    h, k, l, wavelength)\n    cells = []\n    msg_lines = [\'_\' * 300]\n    idx_err = 0\n    # virtual_angle_names = list(pos_virtual_angles_pairs[0][1].keys())\n    # virtual_angle_names.sort()\n    if settings.include_reference:\n        virtual_angle_names = [\'qaz\', \'psi\', \'naz\', \'tau\', \'theta\', \'ttheta\', \'alpha\', \'beta\', \'betain\', \'betaout\']\n    else:\n        virtual_angle_names = [\'qaz\', \'theta\', \'ttheta\', \'betain\', \'betaout\']\n    header_cell_names = [\'\'] + list(_hardware.get_axes_names()) + [\' \'] + virtual_angle_names\n    cells.append([\'%9s\' % s for s in header_cell_names])\n\n    for pos, virtual_angles in pos_virtual_angles_pairs:\n        row_cells = []\n\n        angle_tuple = _geometry.internal_position_to_physical_angles(pos)\n        angle_tuple = _hardware.cut_angles(angle_tuple)\n        try:\n            err_msg = _hardware.diffhw.checkPositionValid(angle_tuple)\n        except Exception:\n            err_msg = ""Cannot read limit violation message.""\n        if err_msg:\n            idx_err += 1\n            idx_str =  str(idx_err) + \'.\'\n            row_cells.append(idx_str)\n            msg_lines.append(idx_str + \'  \' + err_msg)\n        else:\n            row_cells.append(\'*\')\n        for val in angle_tuple:\n            row_cells.append(\'%9.4f\' % val)\n        row_cells.append(\'|\')\n        for name in virtual_angle_names:\n            row_cells.append(\'%9.4f\' %  virtual_angles[name])\n        cells.append(row_cells)\n\n    column_widths = []\n    for col in range(len(cells[0])):\n        widths = []\n        for row in range(len(cells)):\n            cell = cells[row][col]\n            width = len(cell.strip())\n            widths.append(width)\n        column_widths.append(max(widths))\n    total_width = sum(column_widths) + 2 * (len(column_widths) - 1)\n\n    lines = []\n    for row_cells in cells:\n        trimmed_row_cells = []\n        for cell, width in zip(row_cells, column_widths):\n            trimmed_cell = cell.strip().rjust(width)\n            trimmed_row_cells.append(trimmed_cell)\n        lines.append(\'  \'.join(trimmed_row_cells))\n    lines.append(\'\')\n    for msg in msg_lines:\n        lines.append(msg[:total_width])\n    print \'\\n\'.join(lines)\n\n\ncommands_for_help = [\'Constraints\',\n                     con,\n                     uncon,\n                     \'Hkl\',\n                     allhkl\n                     ]\n'"
diffcalc/hkl/you/persistence.py,0,"b""###\n# Copyright 2008-2018 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder, UBCalcState\nfrom diffcalc.util import DiffcalcException, TODEG\n\n\nclass YouStateEncoder(UBCalcStateEncoder):\n\n    def default(self, obj):\n\n        if isinstance(obj, UBCalcState):\n            d = UBCalcStateEncoder.default(self, obj)\n\n            from diffcalc.hkl.you.hkl import constraint_manager\n            d['constraints'] = constraint_manager.all\n            return d\n\n        return UBCalcStateEncoder.default(self, obj)\n\n    @staticmethod\n    def decode_ubcalcstate(state, geometry, diffractometer_axes_names, multiplier):\n\n        # Backwards compatibility code\n        try:\n            cons_dict = state['constraints']\n            from diffcalc.hkl.you.hkl import constraint_manager\n            for cons_name, val in cons_dict.iteritems():\n                try:\n                    constraint_manager.constrain(cons_name)\n                    if val is not None:\n                        constraint_manager.set_constraint(cons_name, val * TODEG)\n                except DiffcalcException:\n                    print 'WARNING: Ignoring constraint %s' % cons_name\n        except KeyError:\n            pass\n\n        return UBCalcStateEncoder.decode_ubcalcstate(state, geometry, diffractometer_axes_names, multiplier)\n"""
test/diffcalc/dc/__init__.py,0,b''
test/diffcalc/dc/test_dcvlieg.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\nfrom diffcalc import settings\nimport pytest\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\nfrom diffcalc.gdasupport.scannable.base import ScannableGroup\nfrom diffcalc.gdasupport.scannable.diffractometer import \\\n    DiffractometerScannableGroup\nfrom diffcalc.gdasupport.scannable.hkl import Hkl\nfrom diffcalc.gdasupport.scannable.parameter import \\\n    DiffractionCalculatorParameter\nfrom diffcalc.gdasupport.scannable.slave_driver import \\\n    NuDriverForSixCirclePlugin\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry, \\\n    SixCircleGeometry, Fivec, Fourc\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hardware import ScannableHardwareAdapter\nfrom test.tools import aneq_, mneq_\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom diffcalc.util import DiffcalcException, MockRawInput\nfrom test.diffcalc import scenarios\nimport diffcalc.util  # @UnusedImport to overide raw_input\nfrom diffcalc.gdasupport.minigda.command import sim\n\ndiffcalc.util.DEBUG = True\n\ndef prepareRawInput(listOfStrings):\n    diffcalc.util.raw_input = MockRawInput(listOfStrings)\n\n\nprepareRawInput([])\n\n\ndef createDummyAxes(names):\n    result = []\n    for name in names:\n        result.append(DummyPD(name))\n    return result\n\n\nclass BaseTestDiffractionCalculatorWithData(object):\n\n    def setSessionAndCalculation(self):\n        raise Exception(""Abstract"")\n\n    def setup_method(self):\n        self.geometry = SixCircleGammaOnArmGeometry()\n        self.hardware = DummyHardwareAdapter(\n            (\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'))\n        settings.hardware = self.hardware\n        settings.geometry = self.geometry\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        from diffcalc.dc import dcvlieg as dc\n        reload(dc)\n        self.dc = dc\n        self.setSessionAndCalculation()\n        prepareRawInput([])\n\n    def setDataAndReturnObject(self, sessionScenario, calculationScenario):\n        self.sess = sessionScenario\n        self.calc = calculationScenario\n        return self\n\n    def test_angles_to_hkl(self):\n        with pytest.raises(DiffcalcException):\n            self.dc.angles_to_hkl((1, 2, 3, 4, 5, 6))  # no energy set\n        settings.hardware.energy = 10\n        with pytest.raises(DiffcalcException):\n            self.dc.angles_to_hkl((1, 2, 3, 4, 5, 6))  # no ub calculated \n        s = self.sess\n        c = self.calc\n\n        # setup session info\n        self.dc.newub(s.name)\n        self.dc.setlat(s.name, *s.lattice)\n        r = s.ref1\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        r = s.ref2\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        self.dc.calcub()\n\n        # check the ubcalculation is okay before continuing\n        # (useful to check for typos!)\n        mneq_(self.dc.ubcalc.UB,\n              matrix(s.umatrix) * matrix(s.bmatrix), 4,\n              note=""wrong UB matrix after calculating U"")\n        # Test each hkl/position pair\n        for idx in range(len(c.hklList)):\n            hkl = c.hklList[idx]\n            pos = c.posList[idx]\n            # 1) specifying energy explicitely\n            ((h, k, l), params) = self.dc.angles_to_hkl(pos.totuple(), c.energy)\n            msg = (""wrong hkl calc for TestScenario=%s, AngleTestScenario""\n                   ""=%s, pos=%s):\\n  expected hkl=%f %f %f\\n  returned hkl=""\n                   ""%f %f %f ""\n                   % (s.name, c.tag, str(pos), hkl[0], hkl[1], hkl[2], h, k, l)\n                   )\n            assert [h, k, l] == pytest.approx(hkl, abs=.001)\n#             self.assert_((abs(h - hkl[0]) < .001) & (abs(k - hkl[1]) < .001)\n#                          & (abs(l - hkl[2]) < .001), msg)\n            # 2) specifying energy via hardware\n            settings.hardware.energy = c.energy\n            msg = (""wrong hkl calcualted for TestScenario=%s, ""\n                   ""AngleTestScenario=%s, pos=%s):\\n  expected hkl=%f %f %f\\n""\n                   ""  returned hkl=%f %f %f "" %\n                   (s.name, c.tag, str(pos), hkl[0], hkl[1], hkl[2], h, k, l))\n            ((h, k, l), params) = self.dc.angles_to_hkl(pos.totuple())\n            assert [h, k, l] == pytest.approx(hkl, abs=.001)\n            del params\n\n    def test_hkl_to_angles(self):\n        s = self.sess\n        c = self.calc\n\n        ## setup session info\n        self.dc.newub(s.name)\n        self.dc.setlat(s.name, *s.lattice)\n        r = s.ref1\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        r = s.ref2\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        self.dc.calcub()\n        # check the ubcalculation is okay before continuing\n        # (useful to check for typos !)\n        mneq_(self.dc.ubcalc.UB,\n              matrix(s.umatrix) * matrix(s.bmatrix), 4,\n              note=""wrong UB matrix after calculating U"")\n\n        ## setup calculation info\n        self.dc.hklmode(c.modeNumber)\n        # Set fixed parameters\n        if c.alpha != None:\n            self.dc.setpar(\'alpha\', c.alpha)\n        if c.gamma != None:\n            self.dc.setpar(\'gamma\', c.alpha)\n\n        # Test each hkl/position pair\n        for idx in range(len(c.hklList)):\n            (h, k, l) = c.hklList[idx]\n\n            expectedangles = \\\n                self.geometry.internal_position_to_physical_angles(c.posList[idx])\n            (angles, params) = self.dc.hkl_to_angles(h, k, l, c.energy)\n            expectedAnglesStr = (""%f "" * len(expectedangles)) % expectedangles\n            anglesString = (""%f "" * len(angles)) % angles\n            namesString = ((""%s "" * len(self.hardware.get_axes_names()))\n                           % self.hardware.get_axes_names())\n            note = (""wrong position calcualted for TestScenario=%s, ""\n                    ""AngleTestScenario=%s, hkl=%f %f %f:\\n""\n                    ""                       { %s }\\n""\n                    ""  expected pos=%s\\n  returned pos=%s ""\n                    % (s.name, c.tag, h, k, l, namesString, expectedAnglesStr,\n                       anglesString))\n            mneq_(matrix([list(expectedangles)]), matrix([list(angles)]), 2,\n                  note=note)\n            del params\n\n    def testSimWithHklAndSixc(self):\n        dummyAxes = createDummyAxes(\n            [\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'])\n        dummySixcScannableGroup = ScannableGroup(\'sixcgrp\', dummyAxes)\n        sixcdevice = DiffractometerScannableGroup(\n            \'SixCircleGammaOnArmGeometry\', self.dc, dummySixcScannableGroup)\n        hkldevice = Hkl(\'hkl\', sixcdevice, self.dc)\n        with pytest.raises(TypeError):\n            sim()\n        with pytest.raises(TypeError):\n            sim(hkldevice)\n        with pytest.raises(TypeError):\n            sim(hkldevice, 1, 2, 3)\n        with pytest.raises(TypeError):\n            sim(\'not a proper scannable\', 1)\n        with pytest.raises(TypeError):\n            sim(hkldevice, (1, 2, \'not a number\'))\n        with pytest.raises(TypeError):\n            sim(hkldevice, 1)\n        with pytest.raises(ValueError):\n            sim(hkldevice, (1, 2, 3, 4))\n\n        s = self.sess\n        c = self.calc\n        # setup session info\n        self.dc.newub(s.name)\n        self.dc.setlat(s.name, *s.lattice)\n        r = s.ref1\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        r = s.ref2\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        self.dc.calcub()\n\n        # check the ubcalculation is okay before continuing\n        # (useful to check for typos!)\n        mneq_(self.dc.ubcalc.UB,\n              (matrix(s.umatrix) * (matrix(s.bmatrix))),\n              4, note=""wrong UB matrix after calculating U"")\n        self.hardware.energy = c.energy\n        # Test each hkl/position pair\n        for idx in range(len(c.hklList)):\n            hkl = c.hklList[idx]\n            pos = c.posList[idx].totuple()\n            sim(sixcdevice, pos)\n            sim(hkldevice, hkl)\n\n    def testCheckub(self):\n        ## setup session info\n        s = self.sess\n        self.dc.newub(s.name)\n        self.dc.setlat(s.name, *s.lattice)\n        r = s.ref1\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        r = s.ref2\n        self.dc.addref(\n            [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n        self.dc.calcub()\n        print ""*** checkub ***""\n        print self.dc.checkub()\n        print ""***************""\n\n\nclass TestDiffractionCalculatorHklWithDataSess2Calc0(\n    BaseTestDiffractionCalculatorWithData):\n    def setSessionAndCalculation(self):\n        self.sess = scenarios.sessions()[1]\n        self.calc = self.sess.calculations[0]\n\n\nclass TestDiffractionCalculatorHklWithDataSess3Calc0(\n    BaseTestDiffractionCalculatorWithData):\n    def setSessionAndCalculation(self):\n        self.sess = scenarios.sessions()[2]\n        self.calc = self.sess.calculations[0]\n\n\nclass TestSixcBase(object):\n\n    def createDiffcalcAndScannables(self, geometryClass):\n        self.en = DummyPD(\'en\')\n        dummy = createDummyAxes(\n            [\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'])\n        group = ScannableGroup(\'sixcgrp\', dummy)\n        self.sixc = DiffractometerScannableGroup(\'sixc\', None, group)\n        \n        self.hardware = DummyHardwareAdapter(\n            (\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'))\n        settings.hardware = ScannableHardwareAdapter(self.sixc, self.en)\n        settings.geometry = geometryClass()\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        from diffcalc.dc import dcvlieg as dc\n        reload(dc)\n        self.dc = dc\n        \n\n        self.sixc.diffcalc = self.dc\n        self.hkl = Hkl(\'hkl\', self.sixc, self.dc)\n\n\nclass TestFourcBase(object):\n\n    def createDiffcalcAndScannables(self):\n        self.en = DummyPD(\'en\')\n        dummy = createDummyAxes([\'delta\', \'omega\', \'chi\', \'phi\'])\n        scannableGroup = ScannableGroup(\'fourcgrp\', dummy)\n        self.fourc = DiffractometerScannableGroup(\n            \'fourc\', None, scannableGroup)\n        \n        settings.hardware = ScannableHardwareAdapter(self.fourc, self.en)\n        settings.geometry = Fourc()\n        settings.ubcalc_persister = UbCalculationNonPersister()\n\n        from diffcalc.dc import dcvlieg as dc\n        reload(dc)\n        self.dc = dc\n        \n        self.fourc.diffcalc = self.dc\n        self.hkl = Hkl(\'hkl\', self.fourc, self.dc)\n\n\nclass SixCircleGammaOnArmTest(TestSixcBase):\n\n    def setup_method(self):\n        TestSixcBase.createDiffcalcAndScannables(self,\n                                                 SixCircleGammaOnArmGeometry)\n        self.hklverbose = Hkl(\'hkl\', self.sixc, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        settings.hardware.set_cut(\'phi\', -180)  # cut phi at -180 to match dif\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'b16_270608\')\n        self.dc.setlat(\'xtal\', 3.8401, 3.8401, 5.43072)\n        self.en(12.39842 / 1.24)\n        self.sixc([5.000, 22.790, 0.000, 1.552, 22.400, 14.255])\n        self.dc.addref([1, 0, 1.0628])\n        self.sixc([5.000, 22.790, 0.000, 4.575, 24.275, 101.320])\n        self.dc.addref([0, 1, 1.0628])\n        self.dc.checkub()\n\n    def testDiffractionCalculatorScannableIntegration(self):\n        betain = DiffractionCalculatorParameter(\'betain\', \'betain\',\n                                                self.dc.parameter_manager)\n        betain.asynchronousMoveTo(12.34)\n        self.assertEqual(betain.getPosition(), 12.34)\n\n    def mode(self, mode, alpha=0, gamma=0, betain=0, betaout=0, phi=0, sig=0,\n             tau=0):\n        self.dc.hklmode(mode)\n        self.dc.setpar(\'alpha\', alpha)\n        self.dc.setpar(\'gamma\', gamma)\n        self.dc.setpar(\'betain\', betain)\n        self.dc.setpar(\'betaout\', betaout)\n        self.dc.setpar(\'phi\', phi)\n        self.dc.sigtau(sig, tau)\n\n    def test1(self):\n        self.mode(1)\n        self.hkl([.7, .9, 1.3])\n        aneq_((0., 27.3557, 0., 13.6779, 37.7746, 53.9654), self.sixc(), 4)\n        print self.hkl\n        print self.hklverbose\n\n    def test2(self):\n        self.mode(1, alpha=5, gamma=0)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 26.9296, 0., 8.4916, 27.2563, 59.5855), self.sixc(), 4)\n\n    def test3(self):\n        self.mode(1, alpha=5, gamma=10)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 22.9649, 10., 42.2204, 4.9721, 23.0655), self.sixc(), 4)\n\n    def test4(self):\n        self.mode(2, alpha=5, gamma=10, betain=4)\n\n        self.hkl([.7, .9, 1.3])\n        aneq_((5, 22.9649, 10., -11.8850, 4.7799, 80.4416),\n              self.sixc(), 4, note=""[alpha, delta, gamma, omega, chi, phi"")\n\n    def test5(self):\n        self.mode(1, alpha=5, gamma=10, sig=-1.3500, tau=-106)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 22.9649, 10., 30.6586, 4.5295, 35.4036), self.sixc(), 4)\n\n    def test6(self):\n        self.mode(2, alpha=5, gamma=10, sig=-1.3500, tau=-106, betain=6)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 22.9649, 10., 2.2388, 4.3898, 65.4395), self.sixc(), 4)\n\n    def test7(self):\n        self.mode(3, alpha=5, gamma=10, sig=-1.3500, tau=-106, betaout=7)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 22.9649, 10., 43.4628, 5.0387, 21.7292), self.sixc(), 4)\n\n    def test7a(self):\n        self.mode(5, phi=10)  # Fix phi\n        self.hkl([.7, .9, 1.3])\n\n    def test8(self):\n        #8\n        self.mode(10, gamma=10, sig=-1.35, tau=-106)  # 5cgBeq\n        self.hkl([.7, .9, 1.3])\n        aneq_((6.1937, 22.1343, 10., 46.9523, 1.5102, 18.8112), self.sixc(), 3)\n\n    def test9(self):\n        self.mode(13, alpha=5, gamma=10, sig=-1.35, tau=-106)  # 5cgBeq\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 22.2183, 11.1054, 65.8276, 2.5180, -0.0749), self.sixc(), 4)\n\n    def test10(self):\n        self.mode(20, sig=-1.35, tau=-106)  # 6czBeq\n        self.hkl([.7, .9, 1.3])\n        aneq_((8.1693, 22.0156, 8.1693, -40.2188, 1.35, 106.), self.sixc(), 4)\n\n    def test11(self):\n        self.mode(21, betain=8, sig=-1.35, tau=-106)  # 6czBin\n        self.hkl([.7, .9, 1.3])\n        aneq_((8., 22.0156, 8.3386, -40.0939, 1.3500, 106.), self.sixc(), 4)\n\n    def test12(self):\n        self.mode(22, betaout=1, sig=-1.35, tau=-106)  # 6czBin\n        self.hkl([.7, .9, 1.3])\n        aneq_((15.4706, 22.0994, 1., -45.5521, 1.3500, 106.), self.sixc(), 4)\n\n\nclass ZAxisGammaOnBaseTest(TestSixcBase):\n\n    def setup_method(self):\n        TestSixcBase.createDiffcalcAndScannables(self, SixCircleGeometry)\n        self.hklverbose = Hkl(\'hkl\', self.sixc, self.dc, (\'Bout\'))\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'From DDIF\')\n        self.dc.setlat(\'cubic\', 1, 1, 1)\n        self.en(12.39842 / 1)\n        self.dc.setu([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.dc.hklmode(20)  # zaxis, bisecting\n        self.dc.sigtau(0, 0)\n\n    def checkHKL(self, hkl, adgocp=None, betaout=None, nu=None):\n        self.hklverbose.asynchronousMoveTo(hkl)\n        aneq_(self.sixc(), list(adgocp), 3)\n        aneq_(self.hklverbose(), (hkl[0], hkl[1], hkl[2], betaout), 3)\n\n    def testHKL_001(self):\n        self.checkHKL([0, 0.0000001, 1], [30, 0, 60, 90, 0, 0], betaout=30, nu=0)\n\n    def testHKL_010(self):\n        self.checkHKL([0, 1, 0], [0, 60, 0, 120, 0, 0], betaout=0, nu=0)\n\n    def testHKL_011(self):\n        self.checkHKL([0, 1, 1], [30, 54.7356, 90, 125.2644, 0, 0],\n                      betaout=30, nu=-54.7356)\n\n    def testHKL_100(self):\n        self.checkHKL([1, 0, 0], [0, 60, 0, 30, 0, 0], betaout=0, nu=0)\n\n    def testHKL_101(self):\n        self.checkHKL([1, 0, 1], [30, 54.7356, 90, 35.2644, 0, 0],\n                      betaout=30, nu=-54.7356)\n\n    def testHKL_110(self):\n        #TODO: Modify test to ask that in this case gamma is left unmoved\n        self.checkHKL([1, 1, 0], [0, 90, 0, 90, 0, 0], betaout=0, nu=0)\n\n    def testHKL_1_1_0001(self):\n        self.checkHKL([1, 1, .0001], [0.0029, 89.9971, 90.0058, 90., 0, 0],\n                      betaout=0.0029, nu=89.9971)\n\n    def testHKL_111(self):\n        self.checkHKL([1, 1, 1], [30, 54.7356, 150, 99.7356, 0, 0],\n                      betaout=30, nu=54.7356)\n\n    def testHKL_11_0_0(self):\n        self.checkHKL([1.1, 0, 0], [0, 66.7340, 0., 33.3670, 0, 0],\n                      betaout=0, nu=0)\n\n    def testHKL_09_0_0(self):\n        self.checkHKL([.9, 0, 0], [0, 53.4874, 0, 26.7437, 0, 0],\n                      betaout=0, nu=0)\n\n    def testHKL_07_08_08(self):\n        self.checkHKL([.7, .8, .8], [23.5782, 59.9980, 76.7037, 84.2591, 0, 0],\n                      betaout=23.5782, nu=-49.1014)\n\n    def testHKL_07_08_09(self):\n        self.checkHKL([.7, .8, .9], [26.7437, 58.6754, 86.6919, 85.3391, 0, 0],\n                      betaout=26.7437, nu=-55.8910)\n\n    def testHKL_07_08_1(self):\n        self.checkHKL([.7, .8, 1], [30, 57.0626, 96.8659, 86.6739, 0, 0],\n                      betaout=30, nu=-63.0210)\n\n\nclass ZAxisGammaOnBaseIncludingNuRotationTest(ZAxisGammaOnBaseTest):\n\n    def setup_method(self):\n        ZAxisGammaOnBaseTest.setup_method(self)\n        self.nu = DummyPD(\'nu\')\n        self.sixc.slaveScannableDriver = NuDriverForSixCirclePlugin(self.nu)\n\n\nclass SixcGammaOnBaseTest(TestSixcBase):\n\n    def setup_method(self):\n        TestSixcBase.createDiffcalcAndScannables(self, SixCircleGeometry)\n        self.hklverbose = Hkl(\'hkl\', self.sixc, self.dc, (\'Bout\'))\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'From DDIF\')\n        self.dc.setlat(\'cubic\', 1, 1, 1)\n        self.en(12.39842 / 1)\n        self.dc.setu([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.dc.sigtau(0, 0)\n\n    def testToFigureOut101and011(self):\n        self.hkl([1, 0, 1])\n        print ""101: "", self.sixc()\n        self.hkl([0, 1, 1])\n        print ""011: "", self.sixc()\n        print ""**""\n\n    def testOrientation(self):\n        self.dc.newub(\'cubic\')\n        self.dc.setlat(\'cubic\', 1, 1, 1)\n        self.en(39842 / 1)\n        self.dc.sigtau(0, 0)\n        self.sixc([0, 90, 0, 45, 45, 0])\n        self.dc.addref([1, 0, 1])\n        self.sixc([0, 90, 0, 45, 45, 90])\n        self.dc.addref([0, 1, 1])\n        self.dc.checkub()\n        res = self.dc.ubcalc.U\n        des = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        mneq_(res, des, 4)\n#         print ""***""\n#         self.dc.dc()\n        print ""***""\n        self.dc.showref()\n        print ""***""\n        self.dc.hklmode()\n        print ""***""\n\n\nclass FiveCircleTest(object):\n\n    def setup_method(self):\n        self.en = DummyPD(\'en\')\n        dummy = createDummyAxes([\'alpha\', \'delta\', \'omega\', \'chi\', \'phi\'])\n        group = ScannableGroup(\'fivecgrp\', dummy)\n        self.fivec = DiffractometerScannableGroup(\'fivec\', None, group)\n        \n        settings.hardware = ScannableHardwareAdapter(self.fivec, self.en)\n        settings.geometry = Fivec()\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        from diffcalc.dc import dcvlieg as dc\n        reload(dc)\n        self.dc = dc\n        \n        self.fivec.diffcalc = self.dc\n        self.hkl = Hkl(\'hkl\', self.fivec, self.dc)\n        self.hklverbose = Hkl(\'hkl\', self.fivec, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'b16_270608\')\n        self.dc.setlat(\'xtal\', 3.8401, 3.8401, 5.43072)\n        self.en(12.39842 / 1.24)\n        self.fivec([5.000, 22.790, 1.552, 22.400, 14.255])\n        self.dc.addref([1, 0, 1.0628])\n        self.fivec([5.000, 22.790, 4.575, 24.275, 101.320])\n        self.dc.addref([0, 1, 1.0628])\n        self.dc.checkub()\n\n    def testSetGammaFails(self):\n        self.assertRaises(\n            DiffcalcException, self.dc.setpar, \'gamma\', 9999)\n\n    def test1(self):\n        self.dc.hklmode(1)\n        self.dc.setpar(\'alpha\', 0)\n        self.hkl([.7, .9, 1.3])\n        aneq_((0., 27.3557, 13.6779, 37.7746, 53.9654), self.fivec(), 4)\n\n    def test2(self):\n        self.dc.hklmode(1)\n        self.dc.setpar(\'alpha\', 5)\n        self.hkl([.7, .9, 1.3])\n        aneq_((5., 26.9296, 8.4916, 27.2563, 59.5855), self.fivec(), 4)\n\n\nclass FourCircleTest(TestFourcBase):\n\n    def setup_method(self):\n        TestFourcBase.createDiffcalcAndScannables(self)\n        self.hklverbose = Hkl(\'hkl\', self.fourc, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'fromDiffcalcItself\')\n        # This dataset generated by diffcalc code itself\n        # (not a proper test of code guts)\n        self.dc.setlat(\'xtal\', 3.8401, 3.8401, 5.43072)\n        self.en(12.39842 / 1.24)\n        self.fourc([22.790, 1.552, 22.400, 14.255])\n        self.dc.addref([1, 0, 1.0628])\n        self.fourc([22.790, 4.575, 24.275, 101.320])\n        self.dc.addref([0, 1, 1.0628])\n        self.dc.checkub()\n\n    def testSetGammaFails(self):\n        self.assertRaises(\n            DiffcalcException, self.dc.setpar, \'gamma\', 9999)\n\n    def test1(self):\n        self.dc.hklmode(1)\n        self.hkl([.7, .9, 1.3])\n        aneq_((27.3557325339904, 13.67786626699521, 23.481729970652825,\n               47.81491152277463), self.fourc(), 4)\n\n\nclass FourCircleWithcubic(TestFourcBase):\n\n    def setup_method(self):\n        TestFourcBase.createDiffcalcAndScannables(self)\n        self.hklverbose = Hkl(\'hkl\', self.fourc, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        self.orient()\n\n    def setUp3(self):\n        TestFourcBase.createDiffcalcAndScannables(self)\n        self.hklverbose = Hkl(\'hkl\', self.fourc, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        self.orient()\n\n    def orient(self):\n        self.dc.newub(\'cubic\')\n        # This dataset generated by diffcalc code itself\n        # (not a proper test of code guts)\n        self.dc.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        self.en(12.39842)\n        self.fourc([60, 30, 0, 0])\n        self.dc.addref([1, 0, 0])\n        self.fourc([60, 30, 90, 0])\n        self.dc.addref([0, 0, 1])\n        self.dc.checkub()\n\n    def testHkl100(self):\n        self.dc.hklmode(1)\n        self.dc.sigtau(0, 0)\n        self.hkl([1, 0, 0])\n        aneq_(self.fourc(), (60, -60, 0, 90), 4)\n        #dif gives\n        #h       k       l       alpha    delta    gamma    omega      chi  phi\n        #1.000   0.000   0.000   0.  60.   0.0000 -60.0000   0.0000  90.0000\n        #beta_in beta_out      rho      eta twotheta\n        #-0.0000   0.0000   0.0000   0.0000  60.0000\n\n    def testHkl001(self):\n        self.dc.hklmode(1)\n        self.dc.sigtau(0, 0)\n        self.hkl([0, 0, 1])\n        aneq_(self.fourc()[0:3], (60, 30, 90), 4)  # (phi is undetermined here)\n        #h       k       l        alpha    delta    gamma    omega      ch  phi\n        #0.000   0.000   1.000   0.0000  60.   0.  30.0000  90.0000  45.0000\n        #                          beta_in beta_out      rho      eta twotheta\n        #                          30.0000  30.0000  60.0000   0.5236  60.0000\n\n    def testHkl110(self):\n        self.dc.hklmode(1)\n        self.dc.sigtau(0, 0)\n        self.hkl([1, 1, 0])\n        # TODO: No check here!\n        #    h       k       l    alpha    delta    gamma    omega   chi    phi\n        #1.000   1.000   0.000   0.  90.   0.0000 135.0000   0.0000 -45.0000\n        #                          beta_in beta_out      rho      eta twotheta\n        #                           0.0000  -0.0000  -0.0000   0.0000  90.0000\n\n\nclass FourCircleForI06Experiment(TestFourcBase):\n\n    def setup_method(self):\n        TestFourcBase.createDiffcalcAndScannables(self)\n        self.hklverbose = Hkl(\'hkl\', self.fourc, self.dc,\n                              (\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'))\n        self.orient()\n\n    def orient(self):\n        self.en(1.650)\n        self.dc.newub(\'cubic\')\n        self.dc.setlat(\'xtal\', 5.34, 5.34, 13.2, 90, 90, 90)\n        self.dc.setu([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.dc.hklmode(5)\n        self.dc.setpar(\'phi\', -90)\n        self.dc.setcut(\'phi\', -180)  # @UndefinedVariable\n\n    def testHkl001(self):\n        self.hkl([0, 0, 1])\n        aneq_(self.fourc(), [33.07329403295449, 16.536647016477247, 90., -90.],\n              note=""[delta, omega, chi, phi]"")\n\n#    def testHkl100(self):\n#        self.pos_hkl(1, 0, 0)\n#        aneq_(self.pos_fourc(),\n#              [89.42926563609406, 134.71463281804702, 90.0, -90.0],\n#              note=""[delta, omega, chi, phi]"")\n\n    def testHkl101(self):\n        self.hkl([1, 0, 1])\n        aneq_(self.fourc(), [98.74666191021282, 117.347760720783, 90., -90.],\n              note=""[delta, omega, chi, phi]"")\n'"
test/diffcalc/gdasupport/__init__.py,0,b''
test/diffcalc/gdasupport/test_you.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\nfrom nose.tools import eq_, raises  # @UnresolvedImport\nfrom nose.plugins.skip import Skip, SkipTest  # @UnresolvedImport\nfrom diffcalc.hardware import ScannableHardwareAdapter\nfrom diffcalc.gdasupport.minigda.scannable import SingleFieldDummyScannable,\\\n    ScannableGroup\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\n\nimport diffcalc.util  # @UnusedImport\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nimport diffcalc.gdasupport.minigda.command\nfrom test.tools import mneq_\n\nfrom diffcalc import settings\nimport diffcalc.hkl.you.calc\ndiffcalc.gdasupport.minigda.command.ROOT_NAMESPACE_DICT = globals()\npos = diffcalc.gdasupport.minigda.command.Pos()\n\nen = SingleFieldDummyScannable(\'en\')  # keV\nmu = SingleFieldDummyScannable(\'mu\')\ndelta = SingleFieldDummyScannable(\'delta\')\ngam = SingleFieldDummyScannable(\'gam\')\neta = SingleFieldDummyScannable(\'eta\')\nchi = SingleFieldDummyScannable(\'chi\')\nphi = SingleFieldDummyScannable(\'phi\')\nsixc_group = ScannableGroup(\'sixc\', (mu, delta, gam, eta, chi, phi))\n\nubcalc_no = 1\n\nyou = None\ndef setup_module():\n    global you\n    settings.hardware = ScannableHardwareAdapter(sixc_group, en)\n    settings.geometry = SixCircle()\n    settings.ubcalc_persister = UbCalculationNonPersister()\n    settings.axes_scannable_group = sixc_group\n    settings.energy_scannable = en\n    settings.ubcalc_strategy = diffcalc.hkl.you.calc.YouUbCalcStrategy()\n    settings.angles_to_hkl_function = diffcalc.hkl.you.calc.youAnglesToHkl\n\n    from diffcalc.gdasupport import you\n    reload(you)\n\n\n""""""\nAll the components used here are well tested. This integration test is\nmainly to get output for the manual, to help when tweaking the user\ninterface, and to make sure it all works together.\n""""""\n# \n# PRINT_WITH_USER_SYNTAX = True\n# for name, obj in self.objects.iteritems():\n#     if inspect.ismethod(obj):\n#         globals()[name] = wrap_command_to_print_calls(\n#                               obj, PRINT_WITH_USER_SYNTAX)\n#     else:\n#         globals()[name] = obj\n# pos = wrap_command_to_print_calls(Pos(globals()), PRINT_WITH_USER_SYNTAX)\n\n\ndef call_scannable(scn):\n    print \'\\n>>> %s\' % scn.name\n    print scn.__str__()\n\n\n\n\n\n\ndef test_help_visually():\n    print ""\\n>>> help ub""\n    help(you.ub)\n    print ""\\n>>> help hkl""\n    help(you.hkl)\n    print ""\\n>>> help newub""\n    help(you.newub)\n\ndef test_axes():\n    call_scannable(you.sixc)  # @UndefinedVariable\n    call_scannable(phi)\n\ndef test_with_no_ubcalc():\n    you.ub()\n    you.showref()\n    call_scannable(you.hkl)\n\ndef _orient():\n    global ubcalc_no\n    pos(you.wl, 1)\n    call_scannable(en)  # like typing en (or en())\n    you.newub(\'test\' + str(ubcalc_no))\n    ubcalc_no += 1\n    you.setlat(\'cubic\', 1, 1, 1, 90, 90, 90)\n\n    you.c2th([1, 0, 0])\n    pos(you.sixc, [0, 60, 0, 30, 0, 0])  # @UndefinedVariable\n    you.addref([1, 0, 0], \'ref1\')\n\n    you.c2th([0, 1, 0])\n    pos(phi, 90)\n    you.addref([0, 1, 0], \'ref2\')\n\ndef test__orientation_phase():\n    _orient()\n    you.ub()\n    you.checkub()\n    you.showref()\n\n    U = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n    UB = U * 2 * pi\n    mneq_(you.ubcalc.U, U)\n    mneq_(you.ubcalc.UB, UB)\n\ndef test_hkl_read():\n    _orient()\n    call_scannable(you.hkl)\n\ndef test_help_con():\n    help(you.con)\n\ndef test_constraint_mgmt():\n    diffcalc.util.DEBUG = True\n    you.con()  # TODO: show constrained values underneath\n\ndef test_hkl_move_no_constraints():\n    raise SkipTest()\n    _orient()\n    pos(you.hkl, [1, 0, 0])\n\ndef test_hkl_move_no_values():\n    raise SkipTest()\n    _orient()\n    you.con(mu)\n    you.con(gam)\n    you.con(\'a_eq_b\')\n    you.con(\'a_eq_b\')\n    pos(you.hkl, [1, 0, 0])\n\ndef test_hkl_move_okay():\n    _orient()\n    you.ub()\n    you.con(mu)\n    you.con(gam)\n    you.con(\'a_eq_b\')\n    pos(you.mu_con, 0)\n    pos(you.gam_con, 0)  # TODO: Fails with qaz=90\n    pos(you.hkl, [1, 1, 0])  # TODO: prints DEGENERATE. necessary?\n    call_scannable(you.sixc)  # @UndefinedVariable\n\n@raises(TypeError)\ndef test_usage_error_signature():\n    you.c2th(\'wrong arg\', \'wrong arg\')\n\n@raises(TypeError)\ndef test_usage_error_inside():\n    you.setlat(\'wrong arg\', \'wrong arg\')'"
test/diffcalc/hkl/__init__.py,0,b''
test/diffcalc/ub/__init__.py,0,b''
test/diffcalc/ub/test_calculation.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom diffcalc.hkl.you.calc import YouUbCalcStrategy\nfrom diffcalc.hkl.you.geometry import SixCircle, YouPosition\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.persistence import UBCalculationJSONPersister\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder\nfrom math import pi, sqrt, atan2\nfrom mock import Mock\nfrom nose.tools import eq_\nfrom test.tools import matrixeq_\nimport tempfile\nimport datetime\nfrom diffcalc.util import TORAD, x_rotation\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\n\n\ndef posFromI16sEuler(phi, chi, eta, mu, delta, gamma):\n    return YouPosition(mu, delta, gamma, eta, chi, phi, unit=\'DEG\')\n\nUB1 = matrix(\n    ((0.9996954135095477, -0.01745240643728364, -0.017449748351250637),\n     (0.01744974835125045, 0.9998476951563913, -0.0003045864904520898),\n     (0.017452406437283505, -1.1135499981271473e-16, 0.9998476951563912))\n    ) * (2 * pi)\n\nEN1 = 12.39842\nREF1a = posFromI16sEuler(1, 1, 30, 0, 60, 0)\nREF1b = posFromI16sEuler(1, 91, 30, 0, 60, 0)\n\n\nclass TestUBCalculationWithYouStrategy():\n    """"""Testing the math only here.\n    """"""\n\n    def setup_method(self):\n        \n        self.tempdir = tempfile.mkdtemp()\n\n        geometry = SixCircle()  # pass through\n        hardware = Mock()\n        names = \'m\', \'d\', \'n\', \'e\', \'c\', \'p\'\n        hardware.get_axes_names.return_value = names\n        self.tmpdir = tempfile.mkdtemp()\n        print self.tmpdir\n        settings.hardware = hardware\n        settings.geometry = geometry\n        self.ubcalc = UBCalculation(UBCalculationJSONPersister(self.tmpdir, UBCalcStateEncoder),\n                                    YouUbCalcStrategy())\n\n    def testAgainstI16Results(self):\n        self.ubcalc.start_new(\'cubcalc\')\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.add_reflection(1, 0, 0, REF1a, EN1, \'100\', None)\n        self.ubcalc.add_reflection(0, 0, 1, REF1b, EN1, \'001\', None)\n        matrixeq_(self.ubcalc.UB, UB1)\n        \n    def test_save_and_restore_empty_ubcalc_with_one_already_started(self):\n        NAME = \'test_save_and_restore_empty_ubcalc_with_one_already_started\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.start_new(NAME)\n    \n    \n    def test_save_and_restore_empty_ubcalc(self):\n        NAME = \'test_save_and_restore_empty_ubcalc\'\n        self.ubcalc.start_new(NAME)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        eq_(self.ubcalc.name, NAME)\n        \n    def test_save_and_restore_ubcalc_with_lattice(self):\n        NAME = \'test_save_and_restore_ubcalc_with_lattice\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        eq_(self.ubcalc._state.crystal.getLattice(), (\'latt\', 1, 1, 1, 90, 90, 90))\n        \n    def test_save_and_restore_ubcalc_with_reflections(self):\n        NAME = \'test_save_and_restore_ubcalc_with_reflections\'\n        self.ubcalc.start_new(NAME)\n        now = datetime.datetime.now()\n        self.ubcalc.add_reflection(1, 0, 0, REF1a, EN1, \'100\', now)\n        self.ubcalc.add_reflection(0, 0, 1, REF1b, EN1, \'001\', now)\n        self.ubcalc.add_reflection(0, 0, 1.5, REF1b, EN1, \'001_5\', now)\n        ref1 = self.ubcalc.get_reflection(1)\n        ref2 = self.ubcalc.get_reflection(2)\n        ref3 = self.ubcalc.get_reflection(3)\n        eq_(self.ubcalc.get_reflection(1), ref1)\n        eq_(self.ubcalc.get_reflection(2), ref2)\n        eq_(self.ubcalc.get_reflection(3), ref3)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        eq_(self.ubcalc.get_reflection(1), ref1)\n        eq_(self.ubcalc.get_reflection(2), ref2)\n        eq_(self.ubcalc.get_reflection(3), ref3)\n        \n    def test_save_and_restore_ubcalc_with_UB_from_two_ref(self):\n        NAME = \'test_save_and_restore_ubcalc_with_UB_from_two_ref\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.add_reflection(1, 0, 0, REF1a, EN1, \'100\', None)\n        self.ubcalc.add_reflection(0, 0, 1, REF1b, EN1, \'001\', None)\n        matrixeq_(self.ubcalc.UB, UB1)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        matrixeq_(self.ubcalc.UB, UB1)\n        \n    def test_save_and_restore_ubcalc_with_UB_from_one_ref(self):\n        NAME = \'test_save_and_restore_ubcalc_with_UB_from_one_ref\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.add_reflection(1, 0, 0, REF1a, EN1, \'100\', None)\n        self.ubcalc.calculate_UB_from_primary_only()\n        matrixeq_(self.ubcalc.UB, UB1,  places=2)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        matrixeq_(self.ubcalc.UB, UB1,  places=2)\n\n    def test_save_and_restore_ubcalc_with_manual_ub(self):\n        NAME = \'test_save_and_restore_ubcalc_with_manual_ub\'\n        UB = matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_UB_manually(UB)\n        matrixeq_(self.ubcalc.UB, UB)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        matrixeq_(self.ubcalc.UB, UB)\n\n    def test_save_and_restore_ubcalc_with_manual_u(self):\n        NAME = \'test_save_and_restore_ubcalc_with_manual_u\'\n        U = matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.set_U_manually(U)\n        matrixeq_(self.ubcalc.UB, U * 2 * pi)\n        \n        self.ubcalc.start_new(NAME + \'2\')\n        self.ubcalc.load(NAME)\n        \n        matrixeq_(self.ubcalc.UB, U * 2 * pi)\n\n    def test_calc_hkl_offset(self):\n        NAME = \'test_calc_hkl_offset\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.set_U_manually(x_rotation(0))\n        hkloff_110 = self.ubcalc.calc_hkl_offset(0, 0, sqrt(2), 90. * TORAD, -45 * TORAD)\n        hkloff_m101 = self.ubcalc.calc_hkl_offset(0, 0, sqrt(2), 45. * TORAD, 90 * TORAD)\n        alpha = atan2(2,1)\n        hkloff_102 = self.ubcalc.calc_hkl_offset(sqrt(5), 0, 0, alpha, 90 * TORAD)\n        matrixeq_(matrix(\'1 1 0\'), matrix(hkloff_110))\n        matrixeq_(matrix(\'-1 0 1\'), matrix(hkloff_m101))\n        matrixeq_(matrix(\'1 0 2\'), matrix(hkloff_102))\n\n    def test_calc_offset_for_hkl(self):\n        NAME = \'test_calc_offset_for_hkl\'\n        self.ubcalc.start_new(NAME)\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.set_U_manually(x_rotation(0))\n        for hklref, hkloff, pol_ref, az_ref, sc_ref in [([0, 0, 1], [1, 1, 0], 90 * TORAD, -45 * TORAD, sqrt(2)),\n                                                        ([0, 0, 1], [-1, 0, 1], 45 * TORAD, 90 * TORAD, sqrt(2)),\n                                                        ([1, 0, 0], [1, 0, 2], atan2(2,1), 90 * TORAD, sqrt(5)),]:\n            pol, az , sc = self.ubcalc.calc_offset_for_hkl(hkloff, hklref)\n            matrixeq_(matrix([[pol_ref, az_ref, sc_ref]]),\n                      matrix([[pol, az, sc]]))\n\n'"
test/diffcalc/ub/test_calculation_vlieg.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\nfrom datetime import datetime\nfrom math import cos, sin, pi\n\nfrom mock import Mock\nfrom nose.tools import raises\nfrom diffcalc import settings\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition as Pos\nfrom test.tools import matrixeq_, mneq_\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom diffcalc.util import DiffcalcException\nfrom diffcalc.hkl.vlieg.calc import VliegUbCalcStrategy\nfrom test.diffcalc import scenarios\n\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\nTORAD = pi / 180\n\n\n\nclass TestUBCalculationWithSixCircleGammaOnArm(object):\n\n    def setup_method(self):\n        self.geometry = SixCircleGammaOnArmGeometry()\n        mock_hardware = Mock()\n        mock_hardware.energyScannableMultiplierToGetKeV = 1\n        mock_hardware.get_axes_names.return_value = (\'a\', \'d\', \'g\', \'o\', \'c\', \'p\')\n        settings.hardware = mock_hardware\n        settings.geometry = self.geometry\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    VliegUbCalcStrategy())\n        self.time = datetime.now()\n\n### State ###\n\n    def testNewCalculation(self):\n        self.ubcalc.start_new(\'testcalc\')\n        assert self.ubcalc.name, \'testcalc\' == ""Name not set by newCalcualtion""\n\n    @raises(DiffcalcException)\n    def testNewCalculationHasNoU(self):\n        self.ubcalc.start_new(\'testcalc\')\n        print self.ubcalc.U\n\n    @raises(DiffcalcException)\n    def testNewCalculationHasNoUB(self):\n        self.ubcalc.start_new(\'testcalc\')\n        print self.ubcalc.UB\n\n### Lattice ###\n\n    def testSetLattice(self):\n        # Not much to test, just make sure no exceptions\n        self.ubcalc.start_new(\'testcalc\')\n        self.ubcalc.set_lattice(\'testlattice\', 4.0004, 4.0004, 2.27, 90, 90, 90)\n\n### Calculations ###\n\n    def testset_U_manually(self):\n\n        # Test the calculations with U=I\n        U = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        for sess in scenarios.sessions():\n            self.setup_method()\n            self.ubcalc.start_new(\'testcalc\')\n            self.ubcalc.set_lattice(sess.name, *sess.lattice)\n            self.ubcalc.set_U_manually(U)\n            # Check the U matrix\n            mneq_(self.ubcalc.U, matrix(U), 4,\n                  note=""wrong U after manually setting U"")\n\n            # Check the UB matrix\n            if sess.bmatrix is None:\n                continue\n            print ""U: "", U\n            print ""actual ub: "", self.ubcalc.UB.tolist()\n            print "" desired b: "", sess.bmatrix\n            mneq_(self.ubcalc.UB, matrix(sess.bmatrix), 4,\n                  note=""wrong UB after manually setting U"")\n\n    @raises(DiffcalcException)\n    def testGetUMatrix(self):\n        self.ubcalc.start_new(\'testcalc\')\n        print self.ubcalc.U\n\n    @raises(DiffcalcException)\n    def testGetUBMatrix(self):\n        self.ubcalc.start_new(\'testcalc\')\n        print self.ubcalc.UB\n\n    def testCalculateU(self):\n\n        for sess in scenarios.sessions():\n            self.setup_method()\n            self.ubcalc.start_new(\'testcalc\')\n            # Skip this test case unless it contains a umatrix\n            if sess.umatrix is None:\n                continue\n\n            self.ubcalc.set_lattice(sess.name, *sess.lattice)\n            ref1 = sess.ref1\n            ref2 = sess.ref2\n            t = sess.time\n            self.ubcalc.add_reflection(\n                ref1.h, ref1.k, ref1.l, ref1.pos, ref1.energy, ref1.tag, t)\n            self.ubcalc.add_reflection(\n                ref2.h, ref2.k, ref2.l, ref2.pos, ref2.energy, ref2.tag, t)\n            self.ubcalc.calculate_UB()\n            returned = self.ubcalc.U.tolist()\n            print ""*Required:""\n            print sess.umatrix\n            print ""*Returned:""\n            print returned\n            mneq_(self.ubcalc.U, matrix(sess.umatrix), 4,\n                  note=""wrong U calulated for sess.name="" + sess.name)\n\n    def test__str__(self):\n        sess = scenarios.sessions()[0]\n        print ""***""\n        print self.ubcalc.__str__()\n\n        print ""***""\n        self.ubcalc.start_new(\'test\')\n        print self.ubcalc.__str__()\n\n        print ""***""\n        self.ubcalc.set_lattice(sess.name, *sess.lattice)\n        print self.ubcalc.__str__()\n\n        print ""***""\n        ref1 = sess.ref1\n        ref2 = sess.ref2\n        t = sess.time\n        self.ubcalc.add_reflection(\n            ref1.h, ref1.k, ref1.l, ref1.pos, ref1.energy, ref1.tag, t)\n        self.ubcalc.add_reflection(\n            ref2.h, ref2.k, ref2.l, ref2.pos, ref2.energy, ref2.tag, t)\n        print self.ubcalc.__str__()\n\n        print ""***""\n        self.ubcalc.calculate_UB()\n        print self.ubcalc.__str__()\n\n\ndef x_rotation(mu_or_alpha):\n    mu_or_alpha *= TORAD\n    return matrix(((1, 0, 0),\n                   (0, cos(mu_or_alpha), -sin(mu_or_alpha)),\n                   (0, sin(mu_or_alpha), cos(mu_or_alpha))))\n\n\ndef y_rotation(chi):\n    chi *= TORAD\n    return matrix(((cos(chi), 0, sin(chi)),\n                   (0, 1, 0),\n                   (-sin(chi), 0, cos(chi))))\n\n\ndef z_rotation(th):\n    eta = -th * TORAD\n    return matrix(((cos(eta), sin(eta), 0),\n                   (-sin(eta), cos(eta), 0),\n                   (0, 0, 1)))\n\nCUBIC_EN = 12.39842\nCUBIC = (1, 1, 1, 90, 90, 90)\nROT = 29\n\n\nclass TestUBCalcWithCubic(object):\n\n    def setup_method(self):\n        print ""TestUBCalcWithCubic.setup_method""\n        mock_hardware = Mock()\n        mock_hardware.energyScannableMultiplierToGetKeV = 1\n        mock_hardware.get_axes_names.return_value = \\\n            (\'a\', \'d\', \'g\', \'o\', \'c\', \'p\')\n        settings.hardware = mock_hardware\n        settings.geometry = SixCircleGammaOnArmGeometry()\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    VliegUbCalcStrategy())\n        self.ubcalc.start_new(\'xtalubcalc\')\n        self.ubcalc.set_lattice(""xtal"", *CUBIC)\n        self.energy = CUBIC_EN\n\n    def addref(self, hklref):\n        hkl, position = hklref\n        now = datetime.now()\n        self.ubcalc.add_reflection(\n            hkl[0], hkl[1], hkl[2], position, self.energy, ""ref"", now)\n\n\nclass TestUBCalcWithCubicTwoRef(TestUBCalcWithCubic):\n\n    def check(self, testname, hklref1, hklref2, expectedUMatrix):\n        self.addref(hklref1)\n        self.addref(hklref2)\n        matrixeq_(expectedUMatrix, self.ubcalc.U)\n\n    def test_with_squarely_mounted(self):\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0))\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90, phi=0))\n        pairs = ((""hl"", href, lref, I),\n                 (""lh"", lref, href, I))\n        for testname, ref1, ref2, u in pairs:\n            yield self.check, testname, ref1, ref2, u\n\n    def test_with_x_mismount(self):\n        U = x_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0))\n        kref = ((0, 1, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 - ROT + 90, chi=90,\n                    phi=0))\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 - ROT, chi=90, phi=0))\n        pairs = ((""hk"", href, kref, U),\n                 (""hl"", href, lref, U),\n                 (""kh"", kref, href, U),\n                 (""kl"", kref, lref, U),\n                 (""lk"", lref, kref, U),\n                 (""lh"", lref, href, U))\n        for testname, ref1, ref2, u in pairs:\n            yield self.check, testname, ref1, ref2, u\n\n    def test_with_y_mismount(self):\n        U = y_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0 - ROT, phi=0))\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90 - ROT, phi=0))\n        pairs = ((""hl"", href, lref, U),\n                 (""lh"", lref, href, U))\n        for testname, ref1, ref2, u in pairs:\n            yield self.check, testname, ref1, ref2, u\n\n    def test_with_z_mismount(self):\n        U = z_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0 + ROT))\n        lref = ((0, 0, 1),  # phi degenerate\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90, phi=67))\n        pairs = ((""hl"", href, lref, U),\n                 (""lh"", lref, href, U))\n        for testname, ref1, ref2, u in pairs:\n            yield self.check, testname, ref1, ref2, u\n\n    def test_with_zy_mismount(self):\n        U = z_rotation(ROT) * y_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0 - ROT,\n                    phi=0 + ROT))\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90 - ROT,\n                    phi=ROT))  # chi degenerate\n        pairs = ((""hl"", href, lref, U),\n                 (""lh"", lref, href, U))\n        for testname, ref1, ref2, u in pairs:\n            yield self.check, testname, ref1, ref2, u\n\n\nclass TestUBCalcWithcubicOneRef(TestUBCalcWithCubic):\n\n    def check(self, testname, hklref, expectedUMatrix):\n        print testname\n        self.addref(hklref)\n        self.ubcalc.calculate_UB_from_primary_only()\n        matrixeq_(expectedUMatrix, self.ubcalc.U)\n\n    def test_with_squarely_mounted(self):\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0))\n        href_b = ((1, 0, 0),\n                  Pos(alpha=0, delta=60, gamma=0, omega=30 + 90, chi=90,\n                      phi=-90))\n        lref = ((0, 0, 1),  # degenerate in phi\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90, phi=67))\n        pairs = ((""h"", href, I),\n                 (""hb"", href_b, I),\n                 (""l"", lref, I))\n        for testname, ref, u in pairs:\n            yield self.check, testname, ref, u\n\n    def test_with_x_mismount_h(self):\n        U = x_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0))\n        self.check(""h"", href, I)\n        \n    def test_with_x_mismount_k(self):\n        U = x_rotation(ROT)\n        kref = ((0, 1, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 - ROT + 90, chi=90,\n                    phi=0))\n        self.check(""k"", kref, U)\n        \n    def test_with_x_mismount_l(self):\n        U = x_rotation(ROT)\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 - ROT, chi=90, phi=0))\n        self.check(""l"", lref, U)\n\n    def test_with_y_mismount_h(self):\n        U = y_rotation(ROT)\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0 - ROT, phi=0))\n        self.check(""h"", href, U)\n\n    def test_with_y_mismount_k(self):\n        U = y_rotation(ROT)\n        kref = ((0, 1, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 + 90, chi=90, phi=0))\n        self.check(""k"", kref, I)  # TODO: can\'t pass - word instructions\n\n    def test_with_y_mismount_l(self):\n        U = y_rotation(ROT)\n        lref = ((0, 0, 1),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90 - ROT, phi=0))\n        self.check(""l"", lref, U)\n\n    def test_with_z_mismount_h(self):\n        U = z_rotation(ROT)\n\n        href = ((1, 0, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0, phi=0 + ROT))\n        self.check(""h"", href, U)\n\n    def test_with_z_mismount_k(self):\n        U = z_rotation(ROT)\n        kref = ((0, 1, 0),\n                Pos(alpha=0, delta=60, gamma=0, omega=30 + 90, chi=0,\n                    phi=0 + ROT))\n        self.check(""k"", kref, U),\n\n    def test_with_z_mismount_l(self):\n        U = z_rotation(ROT)\n        lref = ((0, 0, 1),  # phi degenerate\n                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90, phi=67))\n        self.check(""l"", lref, I)  # TODO: can\'t pass - word instructions\n\n    #Probably lost cause, conclusion is be careful and return the angle and\n    #direction of resulting u matrix\n#    def skip_test_with_zy_mismount(self):\n#        U = z_rotation(ROT) * y_rotation(ROT)\n#        href = ((1, 0, 0),\n#                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=0 - ROT,\n#                    phi=0 + ROT))\n#        kref = ((0, 1, 0),\n#                Pos(alpha=0, delta=60, gamma=0, omega=30 + 90, chi=90 - ROT,\n#                    phi=0 + ROT))\n#        lref = ((0, 0, 1),\n#                Pos(alpha=0, delta=60, gamma=0, omega=30, chi=90 - ROT,\n#                    phi=ROT))  # chi degenerate\n#        pairs = ((""h"", href, U),\n#                 (""k"", kref, U),\n#                 (""l"", lref, U))\n#        for testname, ref, u in pairs:\n#            yield self.check, testname, ref, u\n'"
test/diffcalc/ub/test_calculation_you.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\nfrom mock import Mock\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.hkl.you.geometry import YouPosition\nfrom diffcalc.hkl.you.calc import YouUbCalcStrategy\nfrom test.tools import matrixeq_\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\n\n#newub \'cubic\'                   <-->  reffile(\'cubic)\n#setlat \'cubic\' 1 1 1 90 90 90   <-->  latt([1,1,1,90,90,90])\n#pos wl 1                        <-->  BLi.setWavelength(1)\n#                                <-->  c2th([0,0,1]) --> 60\n#pos sixc [0 60 0 30 1 1]        <-->  pos euler [1 1 30 0 60 0]\n#addref 1 0 0                    <-->  saveref(\'100\',[1, 0, 0])\n#pos chi 91                      <-->\n#addref 0 0 1                    <-->  saveref(\'100\',[1, 0, 0]) ; showref()\n#                                      ubm(\'100\',\'001\')\n#                                      ubm() ->\n#array(\'d\', [0.9996954135095477, -0.01745240643728364, -0.017449748351250637,\n#0.01744974835125045, 0.9998476951563913, -0.0003045864904520898,\n#0.017452406437283505, -1.1135499981271473e-16, 0.9998476951563912])\n\n\ndef posFromI16sEuler(phi, chi, eta, mu, delta, gamma):\n    return YouPosition(mu, delta, gamma, eta, chi, phi, unit=\'DEG\')\n\nUB1 = matrix(\n    ((0.9996954135095477, -0.01745240643728364, -0.017449748351250637),\n     (0.01744974835125045, 0.9998476951563913, -0.0003045864904520898),\n     (0.017452406437283505, -1.1135499981271473e-16, 0.9998476951563912))\n    ) * (2 * pi)\n\nEN1 = 12.39842\nREF1a = posFromI16sEuler(1, 1, 30, 0, 60, 0)\nREF1b = posFromI16sEuler(1, 91, 30, 0, 60, 0)\n\n\nclass TestUBCalculationWithYouStrategy():\n    """"""Testing the math only here.\n    """"""\n\n    def setup_method(self):\n        geometry = SixCircle()  # pass through\n        hardware = Mock()\n        names = \'m\', \'d\', \'n\', \'e\', \'c\', \'p\'\n        hardware.get_axes_names.return_value = names\n        settings.hardware = hardware\n        settings.geometry = geometry\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    YouUbCalcStrategy())\n\n    def testAgainstI16Results(self):\n        self.ubcalc.start_new(\'cubcalc\')\n        self.ubcalc.set_lattice(\'latt\', 1, 1, 1, 90, 90, 90)\n        self.ubcalc.add_reflection(1, 0, 0, REF1a, EN1, \'100\', None)\n        self.ubcalc.add_reflection(0, 0, 1, REF1b, EN1, \'001\', None)\n        self.ubcalc.calculate_UB()\n        matrixeq_(self.ubcalc.UB, UB1)\n'"
test/diffcalc/ub/test_crystal.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom test.tools import assert_dict_almost_equal, mneq_\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom test.diffcalc import scenarios\n\n\nclass TestCrystalUnderTest(object):\n\n    def setup_method(self):\n        self.tclatt = []\n        self.tcbmat = []\n\n        # From the dif_init.mat next to dif_dos.exe on Vlieg\'s cd\n        #self.tclatt.append([4.0004, 4.0004, 2.270000, 90, 90, 90])\n        #self.tcbmat.append([[1.570639, 0, 0] ,[0.0, 1.570639, 0] ,\n        #                    [0.0, 0.0, 2.767923]])\n\n        # From b16 on 27June2008 (From Chris Nicklin)\n        # self.tclatt.append([3.8401, 3.8401, 5.43072, 90, 90, 90])\n        # self.tcbmat.append([[1.636204, 0, 0],[0, 1.636204, 0],\n        #                     [0, 0, 1.156971]])\n\n    def testGetBMatrix(self):\n        # Check the calculated B Matrix\n        for sess in scenarios.sessions():\n            if sess.bmatrix is None:\n                continue\n            cut = CrystalUnderTest(\'tc\', *sess.lattice)\n            desired = matrix(sess.bmatrix)\n            print desired.tolist()\n            answer = cut.B\n            print answer.tolist()\n            note = ""Incorrect B matrix calculation for scenario "" + sess.name\n            mneq_(answer, desired, 4, note=note)\n\n    def test__str__(self):\n        cut = CrystalUnderTest(""HCl"", 1, 2, 3, 4, 5, 6)\n        print cut.__str__()'"
test/diffcalc/ub/test_orientations.py,0,"b'###\n# Copyright 2008-2019 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom datetime import datetime\nfrom diffcalc.ub.orientations import OrientationList\nfrom diffcalc.hkl.you.geometry  import YouPosition as Pos, SixCircle\nfrom diffcalc.util import DiffcalcException\nimport pytest\n\n\nclass TestOrientationList(object):\n\n    def setup_method(self):\n        self._geometry = SixCircle()\n        self.orientlist = OrientationList(self._geometry,\n                                      [\'a\', \'d\', \'g\', \'o\', \'c\', \'p\'])\n        self.time = datetime.now()\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        self.orientlist.add_orientation(1, 2, 3, 0.1, 0.2, 0.3, pos, ""orient1"", self.time)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        self.orientlist.add_orientation(1.1, 2.2, 3.3, 0.11, 0.12, 0.13, pos, ""orient2"", self.time)\n\n    def test_add_orientation(self):\n        assert len(self.orientlist) == 2\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        self.orientlist.add_orientation(10, 20, 30, 0.1, 0.2, 0.3, pos, ""orient1"", self.time)\n\n    def testGetOrientation(self):\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        answered = self.orientlist.getOrientation(1)\n        desired = ([1, 2, 3], [0.1, 0.2, 0.3], pos, ""orient1"", self.time)\n        assert answered == desired\n        answered = self.orientlist.getOrientation(""orient1"")\n        assert answered == desired\n\n    def testRemoveOrientation(self):\n        self.orientlist.removeOrientation(1)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        answered = self.orientlist.getOrientation(1)\n        desired = ([1.1, 2.2, 3.3], [0.11, 0.12, 0.13], pos, ""orient2"", self.time)\n        assert answered == desired\n        self.orientlist.removeOrientation(""orient2"")\n        assert self.orientlist._orientlist == []\n\n    def testedit_orientation(self):\n        ps = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        self.orientlist.edit_orientation(1, 10, 20, 30, 1, 2, 3, ps, ""new1"", self.time)\n        assert (self.orientlist.getOrientation(1)\n                == ([10, 20, 30], [1, 2, 3], ps, ""new1"", self.time))\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.orientlist.getOrientation(2)\n                == ([1.1, 2.2, 3.3], [0.11, 0.12, 0.13], pos, ""orient2"", self.time))\n        self.orientlist.edit_orientation(""orient2"", 1.1, 2.2, 3.3, 1.11, 1.12, 1.13, pos, ""new2"", self.time)\n        assert (self.orientlist.getOrientation(""new2"")\n                == ([1.1, 2.2, 3.3], [1.11, 1.12, 1.13], pos, ""new2"", self.time))\n        self.orientlist.edit_orientation(""new2"", 1.1, 2.2, 3.3, 1.11, 1.12, 1.13, pos, ""new1"", self.time)\n        assert (self.orientlist.getOrientation(""new1"")\n                == ([10, 20, 30], [1, 2, 3], ps, ""new1"", self.time))\n\n    def testSwapOrientation(self):\n        self.orientlist.swap_orientations(1, 2)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.orientlist.getOrientation(1)\n                == ([1.1, 2.2, 3.3], [0.11, 0.12, 0.13], pos, ""orient2"", self.time))\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        assert (self.orientlist.getOrientation(2)\n                 == ([1, 2, 3], [0.1, 0.2, 0.3], pos, ""orient1"", self.time))\n        self.orientlist.swap_orientations(""orient1"", ""orient2"")\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.orientlist.getOrientation(2)\n                == ([1.1, 2.2, 3.3], [0.11, 0.12, 0.13], pos, ""orient2"", self.time))\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        assert (self.orientlist.getOrientation(1)\n                 == ([1, 2, 3], [0.1, 0.2, 0.3], pos, ""orient1"", self.time))\n'"
test/diffcalc/ub/test_persistence.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport os\nimport shutil\nimport unittest\nimport tempfile\nimport time\nfrom nose.tools import eq_  # @UnresolvedImport\n\ntry:\n    from gda.configuration.properties import LocalProperties\nexcept ImportError:\n    print ""Could not import LocalProperties to configure database locations.""\n\nfrom diffcalc.ub.persistence import UbCalculationNonPersister, UBCalculationJSONPersister\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder\n\n\ndef prepareEmptyGdaVarFolder():\n    vartest_dir = os.path.join(os.getcwd(), \'var_test\')\n    LocalProperties.set(\'gda.var\', vartest_dir)\n    if os.path.exists(vartest_dir):\n        print ""Removing existing gda.var: "", vartest_dir\n        shutil.rmtree(vartest_dir)\n    print ""Creating gda.var: "", vartest_dir\n    os.mkdir(vartest_dir)\n\n\nclass TestUBCalculationNonPersister(object):\n\n    def setup_method(self):\n        self.persister = UbCalculationNonPersister()\n\n    def testSaveAndLoad(self):\n        self.persister.save(\'string1\', \'ub1\')\n\n\nclass TestUBCalculationJSONPersister(object):\n\n    def setup_method(self):\n        self.tmpdir = tempfile.mkdtemp()\n        print self.tmpdir\n        self.persister = UBCalculationJSONPersister(self.tmpdir, UBCalcStateEncoder)\n        f = open(os.path.join(self.tmpdir, \'unexpected_file\'), \'w\')\n        f.close()\n        \n    def test_list_with_empty_dir(self):\n        eq_(self.persister.list(), [])\n        \n    def test_save_load(self):\n        d = {\'a\' : 1, \'b\': 2}\n        self.persister.save(d, \'first\')\n        eq_(self.persister.load(\'first\'), d)\n\n    def test_save_overwites(self):\n        d1 = {\'a\' : 1, \'b\': 2}\n        self.persister.save(d1, \'first\')\n        eq_(self.persister.load(\'first\'), d1)\n\n        d2 = {\'a\' : 3, \'b\': 4, \'c\' : 5}\n        self.persister.save(d2, \'first\')\n        eq_(self.persister.load(\'first\'), d2)\n\n    def test_list(self):\n        d = {\'a\' : 1, \'b\': 2}\n        self.persister.save(d, \'first\')\n        eq_(self.persister.list(), [\'first\'])\n        \n    def test_multiple_list(self):\n        d = {\'a\' : 1, \'b\': 2}\n        self.persister.save(d, \'first_written\')\n        time.sleep(1.)\n        eq_(self.persister.list(), [\'first_written\'])\n        self.persister.save(d, \'second_written\')\n        time.sleep(1.)\n        eq_(self.persister.list(), [\'second_written\', \'first_written\'])\n        self.persister.save(d, \'third_written\')\n        time.sleep(1.)\n        eq_(self.persister.list(), [\'third_written\', \'second_written\', \'first_written\'])\n        \n    def test_remove_list(self):\n        d = {\'a\' : 1, \'b\': 2}\n        self.persister.save(d, \'first\')\n        self.persister.remove(\'first\')\n        eq_(self.persister.list(), [])\n        \n    \n\n'"
test/diffcalc/ub/test_reference.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom mock import Mock\nfrom diffcalc.ub.reference import YouReference\nfrom test.tools import assert_array_almost_equal, assert_2darray_almost_equal\n\ntry:\n    from numpy import matrix, hstack\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix, hstack\n    from numjy.linalg import norm\n\n\nclass TestYouReference():\n\n    def setup_method(self):\n        self.get_UB = Mock()\n        self.reference = YouReference(self.get_UB)\n        self.reference._set_n_phi_configured(matrix('0; 0; 1'))\n        self.get_UB.return_value = matrix('1 0 0; 0 1 0; 0 0 1')\n\n    def test_default_n_phi(self):\n        assert_2darray_almost_equal(self.reference.n_phi.tolist(), matrix('0; 0; 1').tolist())\n        \n    def test__str__with_phi_configured(self):\n        print self.reference\n        \n    def test__str__with_hkl_configured(self):\n        self.reference.n_hkl_configured = matrix('0; 1; 1')\n        print self.reference\n        \n    def test_n_phi_from_hkl_with_unity_matrix_001(self):\n        self.get_UB.return_value = matrix('1 0 0; 0 1 0; 0 0 1')\n        self.reference.n_hkl_configured = matrix('0; 0; 1')\n        assert_2darray_almost_equal(self.reference.n_phi.tolist(), matrix('0; 0; 1').tolist())\n\n    def test_n_phi_from_hkl_with_unity_matrix_010(self):\n        self.get_UB.return_value = matrix('1 0 0; 0 1 0; 0 0 1')\n        self.reference.n_hkl_configured = matrix('0; 1; 0')\n        assert_2darray_almost_equal(self.reference.n_phi.tolist(), matrix('0; 1; 0').tolist())\n        \n        \n        \n\n """
test/diffcalc/ub/test_reflections.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom datetime import datetime\nfrom diffcalc.ub.reflections import ReflectionList\nfrom diffcalc.hkl.you.geometry  import YouPosition as Pos, SixCircle\nfrom diffcalc.util import DiffcalcException\nimport pytest\n\n\nclass TestReflectionList(object):\n\n    def setup_method(self):\n        self._geometry = SixCircle()\n        self.reflist = ReflectionList(self._geometry,\n                                      [\'a\', \'d\', \'g\', \'o\', \'c\', \'p\'])\n        self.time = datetime.now()\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        self.reflist.add_reflection(1, 2, 3, pos, 1000, ""ref1"", self.time)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        self.reflist.add_reflection(1.1, 2.2, 3.3, pos, 1100, ""ref2"", self.time)\n\n    def test_add_reflection(self):\n        assert len(self.reflist) == 2\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        self.reflist.add_reflection(11.1, 12.2, 13.3, pos, 1100, ""ref2"", self.time)\n\n    def testGetReflection(self):\n        answered = self.reflist.getReflection(1)\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        desired = ([1, 2, 3], pos, 1000, ""ref1"", self.time)\n        assert answered == desired\n        answered = self.reflist.getReflection(\'ref1\')\n        assert answered == desired\n\n    def testRemoveReflection(self):\n        self.reflist.removeReflection(1)\n        answered = self.reflist.getReflection(1)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        desired = ([1.1, 2.2, 3.3], pos, 1100, ""ref2"", self.time)\n        assert answered == desired\n        self.reflist.removeReflection(""ref2"")\n        assert self.reflist._reflist == []\n\n    def testedit_reflection(self):\n        ps = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        self.reflist.edit_reflection(1, 10, 20, 30, ps, 1000, ""new1"", self.time)\n        assert (self.reflist.getReflection(1)\n                == ([10, 20, 30], ps, 1000, ""new1"", self.time))\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.reflist.getReflection(2)\n                == ([1.1, 2.2, 3.3], pos, 1100, ""ref2"", self.time))\n        self.reflist.edit_reflection(""ref2"", 1.1, 2.2, 3.3, pos, 1100, ""new2"", self.time)\n        assert (self.reflist.getReflection(""new2"")\n                == ([1.1, 2.2, 3.3], pos, 1100, ""new2"", self.time))\n        self.reflist.edit_reflection(""new2"", 10, 20, 30, pos, 1100, ""new1"", self.time)\n        assert (self.reflist.getReflection(""new1"")\n                == ([10, 20, 30], ps, 1000, ""new1"", self.time))\n\n    def testSwapReflection(self):\n        self.reflist.swap_reflections(1, 2)\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.reflist.getReflection(1)\n                == ([1.1, 2.2, 3.3], pos, 1100, ""ref2"", self.time))\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        assert (self.reflist.getReflection(2)\n                 == ([1, 2, 3], pos, 1000, ""ref1"", self.time))\n        self.reflist.swap_reflections(""ref1"", ""ref2"")\n        pos = Pos(0.11, 0.22, 0.33, 0.44, 0.55, 0.66, \'DEG\')\n        assert (self.reflist.getReflection(2)\n                == ([1.1, 2.2, 3.3], pos, 1100, ""ref2"", self.time))\n        pos = Pos(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, \'DEG\')\n        assert (self.reflist.getReflection(1)\n                 == ([1, 2, 3], pos, 1000, ""ref1"", self.time))\n\n    def createRefStateDicts(self):\n        ref_0 = {\n            \'h\': 1,\n            \'k\': 2,\n            \'l\': 3,\n            \'position\': (0.1, 0.2, 0.3, 0.4, 0.5, 0.6),\n            \'energy\': 1000,\n            \'tag\': ""ref1"",\n            \'time\': repr(self.time)\n        }\n        ref_1 = {\n            \'h\': 1.1,\n            \'k\': 2.2,\n            \'l\': 3.3,\n            \'position\': (0.11, 0.22, 0.33, 0.44, 0.55, 0.66),\n            \'energy\': 1100,\n            \'tag\': ""ref2"",\n            \'time\': repr(self.time)\n        }\n        return ref_0, ref_1'"
test/diffcalc/ub/test_ub.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom nose.tools import eq_  # @UnresolvedImport\nimport tempfile\nimport os.path\nimport pytest\nfrom math import atan, sqrt\nfrom nose import SkipTest\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nimport diffcalc.util  # @UnusedImport\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry,\\\n    VliegPosition\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom test.tools import assert_iterable_almost_equal, mneq_, arrayeq_\nfrom diffcalc.ub.persistence import UbCalculationNonPersister,\\\n    UBCalculationJSONPersister\nfrom diffcalc.ub.calcstate import UBCalcStateEncoder\nfrom diffcalc.util import DiffcalcException, MockRawInput, xyz_rotation,\\\n    TODEG, TORAD, CoordinateConverter\nfrom diffcalc.hkl.vlieg.calc import VliegUbCalcStrategy, vliegAnglesToHkl\nfrom diffcalc.hkl.you.calc import youAnglesToHkl, YouUbCalcStrategy\nfrom test.diffcalc import scenarios\nfrom test.diffcalc.scenarios import YouPositionScenario\n\n\ndiffcalc.util.DEBUG = True\n\n\ndef prepareRawInput(listOfStrings):\n    diffcalc.util.raw_input = MockRawInput(listOfStrings)\n\nprepareRawInput([])\n\nfrom diffcalc import settings\n\n\n\nclass _UBCommandsBase():\n\n    def setup_method(self):\n        names = \'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\', \'phi\'\n        self.hardware = DummyHardwareAdapter(names)\n        settings.hardware = self.hardware\n        self.conv = CoordinateConverter(transform=self.t_matrix)\n        self._refineub_matrix = matrix(\'0.70711   0.70711   0.00000; -0.70711   0.70711   0.00000; 0.00000   0.00000   1.00000\')\n\n        from diffcalc.ub import ub\n        reload(ub)\n        self.ub = ub\n        #self.ub.ubcalc = ub.ubcalc\n        prepareRawInput([])\n        diffcalc.util.RAISE_EXCEPTIONS_FOR_ALL_ERRORS = True\n\n    def testNewUb(self):\n        self.ub.newub(\'test1\')\n        eq_(self.ub.ubcalc._state.name, \'test1\')\n        with pytest.raises(TypeError):\n            self.ub.newub(1)\n\n    def testNewUbInteractively(self):\n        prepareRawInput([\'ubcalcname\', \'xtal\', \'1\', \'1\', \'2\', \'3\', \'91\', \'92\',\n                         \'93\'])\n        self.ub.newub()\n\n    def testLoadub(self):\n        with pytest.raises(TypeError):\n            self.ub.loadub((1, 2))\n\n    def testSaveubcalcas(self):\n        with pytest.raises(TypeError):\n            self.ub.saveubas(1)\n        with pytest.raises(TypeError):\n            self.ub.saveubas((1, 2))\n        self.ub.saveubas(\'blarghh\')\n\n    def testUb(self):\n        with pytest.raises(TypeError):\n            self.ub.showref((1))\n        self.ub.ub()\n        self.ub.newub(\'testubcalc\')\n        self.ub.ub()\n\n    def testSetlat(self):\n        # ""Exception should result if no UBCalculation started"")\n        with pytest.raises(DiffcalcException):\n            self.ub.setlat(\'HCl\', 2)\n\n        self.ub.newub(\'testing_setlat\')\n        with pytest.raises(TypeError):\n            self.ub.setlat(1)\n        with pytest.raises(TypeError):\n            self.ub.setlat(1, 2)\n        with pytest.raises(TypeError):\n            self.ub.setlat(\'HCl\')\n        self.ub.setlat(\'NaCl\', 1.1)\n        ubcalc = self.ub.ubcalc\n        eq_((\'NaCl\', 1.1, 1.1, 1.1, 90, 90, 90), ubcalc._state.crystal.getLattice())\n        self.ub.setlat(\'NaCl\', 1.1, 2.2)\n        eq_((\'NaCl\', 1.1, 1.1, 2.2, 90, 90, 90), ubcalc._state.crystal.getLattice())\n        self.ub.setlat(\'NaCl\', 1.1, 2.2, 3.3)\n        eq_((\'NaCl\', 1.1, 2.2, 3.3, 90, 90, 90), ubcalc._state.crystal.getLattice())\n        self.ub.setlat(\'NaCl\', 1.1, 2.2, 3.3, 91)\n        eq_((\'NaCl\', 1.1, 2.2, 3.3, 90, 91, 90), ubcalc._state.crystal.getLattice())\n        with pytest.raises(TypeError):\n            self.ub.setlat((\'NaCl\', 1.1, 2.2, 3.3, 91, 92))\n        self.ub.setlat(\'NaCl\', 1.1, 2.2, 3.3, 91, 92, 93)\n        assert_iterable_almost_equal(\n            (\'NaCl\', 1.1, 2.2, 3.3, 91, 92, 92.99999999999999),\n             ubcalc._state.crystal.getLattice())\n\n    def testSetlatInteractive(self):\n        self.ub.newub(\'testing_setlatinteractive\')\n        prepareRawInput([\'xtal\', \'1\', \'1\', \'2\', \'3\', \'91\', \'92\', \'93\'])\n        self.ub.setlat()\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        assert_iterable_almost_equal(getLattice(),\n                         (\'xtal\', 1., 2., 3., 91, 92, 92.999999999999986))\n\n        #Defaults:\n        prepareRawInput([\'xtal\', \'\', \'\', \'\', \'\', \'\', \'\', \'\'])\n        self.ub.setlat()\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        eq_(getLattice(), (\'xtal\', 1., 1., 1., 90, 90, 90))\n\n    def testShowref(self):\n        with pytest.raises(TypeError):\n            self.ub.showref((1))\n        eq_(self.ub.showref(), None)  # No UBCalculation loaded\n        # will be tested, for exceptions at least, implicitly below\n        self.ub.newub(\'testing_showref\')\n        eq_(self.ub.showref(), None)  # No UBCalculation loaded""\n\n    def testAddref(self):\n        with pytest.raises(TypeError):\n            self.ub.addref(1)\n        with pytest.raises(TypeError):\n            self.ub.addref(1, 2)\n        with pytest.raises(TypeError):\n            self.ub.addref(1, 2, \'blarghh\')\n        # start new ubcalc\n        self.ub.newub(\'testing_addref\')\n        reflist = self.ub.ubcalc._state.reflist  # for convenience\n\n        pos1 = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        pos2 = (2.1, 2.2, 2.3, 2.4, 2.5, 2.6)\n        pos3 = (3.1, 3.2, 3.3, 3.4, 3.5, 3.6)\n        pos4 = (4.1, 4.2, 4.3, 4.4, 4.5, 4.6)\n        #\n        self.hardware.energy = 1.10\n        self.hardware.position = pos1\n        self.ub.addref([1.1, 1.2, 1.3])\n        result = reflist.get_reflection_in_external_angles(1)\n        eq_(result[:-1], ([1.1, 1.2, 1.3], pos1, 1.10, None))\n\n        self.hardware.energy = 2.10\n        self.hardware.position = pos2\n        self.ub.addref([2.1, 2.2, 2.3], \'atag\')\n        result = reflist.get_reflection_in_external_angles(2)\n        eq_(result[:-1], ([2.1, 2.2, 2.3], pos2, 2.10, \'atag\'))\n\n        self.ub.addref([3.1, 3.2, 3.3], pos3, 3.10)\n        result = reflist.get_reflection_in_external_angles(3)\n        eq_(result[:-1], ([3.1, 3.2, 3.3], pos3, 3.10, None))\n\n        self.ub.addref([4.1, 4.2, 4.3], pos4, 4.10, \'tag2\')\n        result = reflist.get_reflection_in_external_angles(4)\n        eq_(result[:-1], ([4.1, 4.2, 4.3], pos4, 4.10, \'tag2\'))\n\n    def testAddrefInteractively(self):\n        prepareRawInput([])\n        # start new ubcalc\n        self.ub.newub(\'testing_addref\')\n        reflist = self.ub.ubcalc._state.reflist  # for convenience\n\n        pos1 = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        pos2 = (2.1, 2.2, 2.3, 2.4, 2.5, 2.6)\n        pos3 = (3.1, 3.2, 3.3, 3.4, 3.5, 3.6)\n        pos3s = [\'3.1\', \'3.2\', \'3.3\', \'3.4\', \'3.5\', \'3.6\']\n        pos4 = (4.1, 4.2, 4.3, 4.4, 4.5, 4.6)\n        pos4s = [\'4.1\', \'4.2\', \'4.3\', \'4.4\', \'4.5\', \'4.6\']\n        #\n        self.hardware.energy = 1.10\n        self.hardware.position = pos1\n        prepareRawInput([\'1.1\', \'1.2\', \'1.3\', \'\', \'\'])\n        self.ub.addref()\n        result = reflist.get_reflection_in_external_angles(1)\n        eq_(result[:-1], ([1.1, 1.2, 1.3], pos1, 1.10, None))\n\n        self.hardware.energy = 2.10\n        self.hardware.position = pos2\n        prepareRawInput([\'2.1\', \'2.2\', \'2.3\', \'\', \'atag\'])\n        self.ub.addref()\n        result = reflist.get_reflection_in_external_angles(2)\n        eq_(result[:-1], ([2.1, 2.2, 2.3], pos2, 2.10, \'atag\'))\n\n        prepareRawInput([\'3.1\', \'3.2\', \'3.3\', \'n\'] + pos3s + [\'3.10\', \'\'])\n        self.ub.addref()\n        result = reflist.get_reflection_in_external_angles(3)\n        eq_(result[:-1], ([3.1, 3.2, 3.3], pos3, 3.10, None))\n\n        prepareRawInput([\'4.1\', \'4.2\', \'4.3\', \'n\'] + pos4s + [\'4.10\', \'tag2\'])\n        self.ub.addref()\n        result = reflist.get_reflection_in_external_angles(4)\n        eq_(result[:-1], ([4.1, 4.2, 4.3], pos4, 4.10, \'tag2\'))\n\n    def testEditRefInteractivelyWithCurrentPosition(self):\n        pos1 = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        pos2 = (2.1, 2.2, 2.3, 2.4, 2.5, 2.6)\n        self.ub.newub(\'testing_editref\')\n        self.ub.addref([1, 2, 3], pos1, 10, \'tag1\')\n        self.hardware.energy = 11\n        self.hardware.position = pos2\n        prepareRawInput([\'1.1\', \'\', \'3.1\', \'y\', \'\'])\n        self.ub.editref(1)\n\n        reflist = self.ub.ubcalc._state.reflist  # for convenience\n        result = reflist.get_reflection_in_external_angles(1)\n        eq_(result[:-1], ([1.1, 2, 3.1], pos2, 11, \'tag1\'))\n\n    def testEditRefInteractivelyWithEditedPosition(self):\n        pos1 = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        pos2 = (2.1, 2.2, 2.3, 2.4, 2.5, 2.6)\n        pos2s = [\'2.1\', \'2.2\', \'2.3\', \'2.4\', \'2.5\', \'2.6\']\n        self.ub.newub(\'testing_editref\')\n        self.ub.addref([1, 2, 3], pos1, 10, \'tag1\')\n        prepareRawInput([\'1.1\', \'\', \'3.1\', \'n\'] + pos2s + [\'12\', \'newtag\'])\n        self.ub.editref(1)\n\n        reflist = self.ub.ubcalc._state.reflist\n        result = reflist.get_reflection_in_external_angles(1)\n        eq_(result[:-1], ([1.1, 2, 3.1], pos2, 12, \'newtag\'))\n\n    def testSwapref(self):\n        with pytest.raises(TypeError):\n            self.ub.swapref(1)\n        with pytest.raises(TypeError):\n            self.ub.swapref(1, 2, 3)\n        with pytest.raises(IndexError):\n            self.ub.swapref(1, 1.1)\n        self.ub.newub(\'testing_swapref\')\n        pos = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        self.ub.addref([1, 2, 3], pos, 10, \'tag1\')\n        self.ub.addref([1, 2, 3], pos, 10, \'tag2\')\n        self.ub.addref([1, 2, 3], pos, 10, \'tag3\')\n        self.ub.swapref(1, 3)\n        self.ub.swapref(1, 3)\n        self.ub.swapref(3, 1)  # end flipped\n        reflist = self.ub.ubcalc._state.reflist\n        tag1 = reflist.get_reflection_in_external_angles(1)[3]\n        tag2 = reflist.get_reflection_in_external_angles(2)[3]\n        tag3 = reflist.get_reflection_in_external_angles(3)[3]\n        eq_(tag1, \'tag3\')\n        eq_(tag2, \'tag2\')\n        eq_(tag3, \'tag1\')\n        self.ub.swapref()\n        tag1 = reflist.get_reflection_in_external_angles(1)[3]\n        tag2 = reflist.get_reflection_in_external_angles(2)[3]\n        eq_(tag1, \'tag2\')\n        eq_(tag2, \'tag3\')\n\n    def testDelref(self):\n        self.ub.newub(\'testing_swapref\')\n        pos = (1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n        self.ub.addref([1, 2, 3], pos, 10, \'tag1\')\n        reflist = self.ub.ubcalc._state.reflist\n        reflist.get_reflection_in_external_angles(1)\n        self.ub.delref(1)\n        with pytest.raises(IndexError):\n            reflist.get_reflection_in_external_angles(1)\n\n    def testShoworient(self):\n        with pytest.raises(TypeError):\n            self.ub.showorient((1))\n        eq_(self.ub.showorient(), None)  # No UBCalculation loaded\n        # will be tested, for exceptions at least, implicitly below\n        self.ub.newub(\'testing_showorient\')\n        eq_(self.ub.showorient(), None)  # No UBCalculation loaded""\n\n    def testAddorient(self):\n        with pytest.raises(TypeError):\n            self.ub.addorient(1)\n        with pytest.raises(TypeError):\n            self.ub.addorient(1, 2)\n        with pytest.raises(TypeError):\n            self.ub.addorient(1, 2, \'blarghh\')\n        # start new ubcalc\n        self.ub.newub(\'testing_addorient\')\n        orientlist = self.ub.ubcalc._state.orientlist  # for convenience\n\n        hkl1 = [1.1, 1.2, 1.3]\n        hkl2 = [2.1, 2.2, 2.3]\n        orient1 = [1.4, 1.5, 1.6]\n        orient2 = [2.4, 2.5, 2.6]\n        #\n        self.ub.addorient(hkl1, orient1)\n        result = orientlist.getOrientation(1)\n        trans_orient1 = self.conv.transform(matrix([orient1]).T)\n        eq_(result[0], hkl1)\n        mneq_(matrix([result[1]]), trans_orient1.T)\n        eq_(result[-2], None)\n\n        self.ub.addorient(hkl2, orient2, \'atag\')\n        result = orientlist.getOrientation(2)\n        trans_orient2 = self.conv.transform(matrix([orient2]).T)\n        eq_(result[0], hkl2)\n        mneq_(matrix([result[1]]), trans_orient2.T)\n        eq_(result[-2], \'atag\')\n\n    def testAddorientInteractively(self):\n        prepareRawInput([])\n        # start new ubcalc\n        self.ub.newub(\'testing_addorient\')\n        orientlist = self.ub.ubcalc._state.orientlist  # for convenience\n\n        hkl1 = [1.1, 1.2, 1.3]\n        hkl2 = [2.1, 2.2, 2.3]\n        orient1 = [1.4, 1.5, 1.6]\n        orient2 = [2.4, 2.5, 2.6]\n        #\n        prepareRawInput([\'1.1\', \'1.2\', \'1.3\', \'1.4\', \'1.5\', \'1.6\', \'y\', \'\'])\n        self.ub.addorient()\n        result = orientlist.getOrientation(1)\n        trans_orient1 = self.conv.transform(matrix([orient1]).T)\n        eq_(result[0], hkl1)\n        mneq_(matrix([result[1]]), trans_orient1.T)\n        eq_(result[-2], None)\n\n        prepareRawInput([\'2.1\', \'2.2\', \'2.3\', \'2.4\', \'2.5\', \'2.6\', \'y\', \'atag\'])\n        self.ub.addorient()\n        result = orientlist.getOrientation(2)\n        trans_orient2 = self.conv.transform(matrix([orient2]).T)\n        eq_(result[0], hkl2)\n        mneq_(matrix([result[1]]), trans_orient2.T)\n        eq_(result[-2], \'atag\')\n\n    def testEditOrientInteractively(self):\n        hkl1 = [1.1, 1.2, 1.3]\n        hkl2 = [1.1, 1.2, 3.1]\n        orient1 = [1.4, 1.5, 1.6]\n        orient2 = [2.4, 1.5, 2.6]\n        orient2s = [\'2.4\', \'\', \'2.6\']\n        self.ub.newub(\'testing_editorient\')\n        self.ub.addorient(hkl1, orient1, \'tag1\')\n        prepareRawInput([\'1.1\', \'\', \'3.1\'] + orient2s + [\'y\', \'newtag\',])\n        self.ub.editorient(1)\n\n        orientlist = self.ub.ubcalc._state.orientlist\n        result = orientlist.getOrientation(1)\n        trans_orient2 = self.conv.transform(matrix([orient2]).T)\n        eq_(result[0], hkl2)\n        mneq_(matrix([result[1]]), trans_orient2.T)\n        eq_(result[-2], \'newtag\')\n\n    def testSwaporient(self):\n        with pytest.raises(TypeError):\n            self.ub.swaporient(1)\n        with pytest.raises(TypeError):\n            self.ub.swaporient(1, 2, 3)\n        with pytest.raises(IndexError):\n            self.ub.swaporient(1, 1.1)\n        self.ub.newub(\'testing_swaporient\')\n        hkl = [1.1, 1.2, 1.3]\n        orient = [1.4, 1.5, 1.6]\n        self.ub.addorient(hkl, orient, \'tag1\')\n        self.ub.addorient(hkl, orient, \'tag2\')\n        self.ub.addorient(hkl, orient, \'tag3\')\n        self.ub.swaporient(1, 3)\n        self.ub.swaporient(1, 3)\n        self.ub.swaporient(3, 1)  # end flipped\n        orientlist = self.ub.ubcalc._state.orientlist\n        tag1 = orientlist.getOrientation(1)[-2]\n        tag2 = orientlist.getOrientation(2)[-2]\n        tag3 = orientlist.getOrientation(3)[-2]\n        eq_(tag1, \'tag3\')\n        eq_(tag2, \'tag2\')\n        eq_(tag3, \'tag1\')\n        self.ub.swaporient()\n        tag1 = orientlist.getOrientation(1)[-2]\n        tag2 = orientlist.getOrientation(2)[-2]\n        eq_(tag1, \'tag2\')\n        eq_(tag2, \'tag3\')\n\n    def testDelorient(self):\n        self.ub.newub(\'testing_delorient\')\n        hkl = [1.1, 1.2, 1.3]\n        pos = [1.4, 1.5, 1.6]\n        self.ub.addorient(hkl, pos, \'tag1\')\n        orientlist = self.ub.ubcalc._state.orientlist\n        orientlist.getOrientation(1)\n        self.ub.delorient(1)\n        with pytest.raises(IndexError):\n            orientlist.getOrientation(1)\n\n    def testSetu(self):\n        # just test calling this method\n        #self.ub.setu([[1,2,3],[1,2,3],[1,2,3]])\n        self.ub.newub(\'testsetu\')\n        setu = self.ub.setu\n        with pytest.raises(TypeError):\n            setu(1, 2)\n        with pytest.raises(TypeError):\n            setu(1)\n        with pytest.raises(TypeError):\n            setu(\'a\')\n        with pytest.raises(TypeError):\n            setu([1, 2, 3])\n        with pytest.raises(TypeError):\n            setu([[1, 2, 3], [1, 2, 3], [1, 2]])\n        # diffCalcException expected if no lattice set yet\n        with pytest.raises(DiffcalcException):\n            setu([[1, 2, 3], [1, 2, 3], [1, 2, 3]])\n        self.ub.setlat(\'NaCl\', 1.1)\n        setu([[1, 2, 3], [1, 2, 3], [1, 2, 3]])  # check no exceptions only\n        setu(((1, 2, 3), (1, 2, 3), (1, 2, 3)))  # check no exceptions only\n\n    def testSetuInteractive(self):\n        self.ub.newub(\'testsetu\')\n        self.ub.setlat(\'NaCl\', 1.1)\n\n        prepareRawInput([\'1 2 3\', \'4 5 6\', \'7 8 9\'])\n        self.ub.setu()\n        a = self.ub.ubcalc.U.tolist()\n        eq_([list(a[0]), list(a[1]), list(a[2])],\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        prepareRawInput([\'\', \' 9 9.9 99\', \'\'])\n        self.ub.setu()\n\n        a = self.ub.ubcalc.U.tolist()\n        eq_([list(a[0]), list(a[1]), list(a[2])],\n            [[1, 0, 0], [9, 9.9, 99], [0, 0, 1]])\n\n    def testSetub(self):\n        # just test calling this method\n        self.ub.newub(\'testsetub\')\n        setub = self.ub.setub\n        with pytest.raises(TypeError):\n            setub(1, 2)\n        with pytest.raises(TypeError):\n            setub(1)\n        with pytest.raises(TypeError):\n            setub(\'a\')\n        with pytest.raises(TypeError):\n            setub([1, 2, 3])\n        with pytest.raises(TypeError):\n            setub([[1, 2, 3], [1, 2, 3], [1, 2]])\n        setub([[1, 2, 3], [1, 2, 3], [1, 2, 3]])  # check no exceptions only\n        setub(((1, 2, 3), (1, 2, 3), (1, 2, 3)))  # check no exceptions only\n\n    def testSetUbInteractive(self):\n        self.ub.newub(\'testsetu\')\n        self.ub.setlat(\'NaCl\', 1.1)\n\n        prepareRawInput([\'1 2 3\', \'4 5 6\', \'7 8 9\'])\n        self.ub.setub()\n        a = self.ub.ubcalc.UB.tolist()\n        eq_([list(a[0]), list(a[1]), list(a[2])],\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        prepareRawInput([\'\', \' 9 9.9 99\', \'\'])\n        self.ub.setub()\n        a = self.ub.ubcalc.UB.tolist()\n        eq_([list(a[0]), list(a[1]), list(a[2])],\n            [[1, 0, 0], [9, 9.9, 99], [0, 0, 1]])\n\n    def testCalcub(self):\n        with pytest.raises(DiffcalcException):\n            self.ub.calcub(1)  # wrong input\n        # no ubcalc started:\n        with pytest.raises(DiffcalcException):\n            self.ub.calcub()\n        self.ub.newub(\'testcalcub\')\n        # not enough reflections:\n        with pytest.raises(DiffcalcException):\n            self.ub.calcub()\n\n        for s in scenarios.sessions(settings.Pos):\n            self.ub.setlat(s.name, *s.lattice)\n            self.ub.clearref()\n            r = s.ref1\n            self.ub.addref(\n                [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n            r = s.ref2\n            self.ub.addref(\n                [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n            self.ub.calcub(s.ref1.tag, s.ref2.tag)\n            mneq_(self.ub.ubcalc.UB, matrix(s.umatrix) * matrix(s.bmatrix),\n                  4, note=""wrong UB matrix after calculating U"")\n\n    def testOrientub(self):\n        with pytest.raises(DiffcalcException):\n            self.ub.orientub(1)  # wrong input\n        # no ubcalc started:\n        with pytest.raises(DiffcalcException):\n            self.ub.orientub()\n        self.ub.newub(\'testorientub\')\n        # not enough orientations:\n        with pytest.raises(DiffcalcException):\n            self.ub.orientub()\n\n        s = scenarios.sessions(settings.Pos)[1]\n        self.ub.setlat(s.name, *s.lattice)\n        r1 = s.ref1\n        orient1 = self.conv.transform(matrix(\'1; 0; 0\'), True)\n        tag1 = \'or\'+r1.tag\n        self.ub.addorient(\n            (r1.h, r1.k, r1.l), orient1.T.tolist()[0], tag1)\n        r2 = s.ref2\n        orient2 = self.conv.transform(matrix(\'0; -1; 0\'), True)\n        tag2 = \'or\'+r2.tag\n        self.ub.addorient(\n            (r2.h, r2.k, r2.l), orient2.T.tolist()[0], tag2)\n        self.ub.orientub()\n        mneq_(self.ub.ubcalc.UB, matrix(s.umatrix) * matrix(s.bmatrix),\n              4, note=""wrong UB matrix after calculating U"")\n        self.ub.orientub(tag1, tag2)\n        mneq_(self.ub.ubcalc.UB, matrix(s.umatrix) * matrix(s.bmatrix),\n              4, note=""wrong UB matrix after calculating U"")\n        self.ub.addref(\n            [r1.h, r1.k, r1.l], r1.pos.totuple(), r1.energy, r1.tag)\n        self.ub.orientub(r1.tag, tag2)\n        mneq_(self.ub.ubcalc.UB, matrix(s.umatrix) * matrix(s.bmatrix),\n              4, note=""wrong UB matrix after calculating U"")\n        self.ub.addref(\n            [r2.h, r2.k, r2.l], r2.pos.totuple(), r2.energy, r2.tag)\n        self.ub.orientub(tag1, r2.tag)\n        mneq_(self.ub.ubcalc.UB, matrix(s.umatrix) * matrix(s.bmatrix),\n              4, note=""wrong UB matrix after calculating U"")\n\n    def testRefineubInteractively(self):\n        self.ub.newub(\'testing_refineubinteractive\')\n        self.ub.setlat(\'xtal\', 1, 1, 1, 90, 90, 90)\n        self.ub.setmiscut(0)\n        prepareRawInput([\'1\', \'1\', \'\', \'n\', \'0\', \'60\', \'0\', \'30\', \'0\', \'0\', \'y\', \'y\'])\n        self.ub.refineub()\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        eq_((\'xtal\', sqrt(2.), sqrt(2.), 1, 90, 90, 90), getLattice())\n        mneq_(self.ub.ubcalc.U, self._refineub_matrix,\n              4, note=""wrong U matrix after refinement"")\n\n    def testRefineubInteractivelyWithPosition(self):\n        self.ub.newub(\'testing_refineubinteractivepos\')\n        self.ub.setlat(\'xtal\', 1, 1, 1, 90, 90, 90)\n        self.ub.setmiscut(0)\n        self.hardware.position = [0, 60, 0, 30, 0, 0]\n        prepareRawInput([\'1\', \'1\', \'\', \'y\', \'y\', \'y\'])\n        self.ub.refineub()\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        eq_((\'xtal\', sqrt(2.), sqrt(2.), 1, 90, 90, 90), getLattice())\n        mneq_(self.ub.ubcalc.U, self._refineub_matrix,\n              4, note=""wrong U matrix after refinement"")\n\n    def testRefineubInteractivelyWithHKL(self):\n        self.ub.newub(\'testing_refineubinteractivehkl\')\n        self.ub.setlat(\'xtal\', 1, 1, 1, 90, 90, 90)\n        self.ub.setmiscut(0)\n        self.hardware.position = [0, 60, 0, 30, 0, 0]\n        prepareRawInput([\'y\', \'y\', \'y\'])\n        self.ub.refineub([1, 1, 0])\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        eq_((\'xtal\', sqrt(2.), sqrt(2.), 1, 90, 90, 90), getLattice())\n        mneq_(self.ub.ubcalc.U, self._refineub_matrix,\n              4, note=""wrong U matrix after refinement"")\n\n    def testRefineub(self):\n        self.ub.newub(\'testing_refineub\')\n        self.ub.setlat(\'xtal\', 1, 1, 1, 90, 90, 90)\n        self.ub.setmiscut(0)\n        prepareRawInput([\'y\', \'y\'])\n        self.ub.refineub([1, 1, 0], [0, 60, 0, 30, 0, 0])\n        getLattice = self.ub.ubcalc._state.crystal.getLattice\n        eq_((\'xtal\', sqrt(2.), sqrt(2.), 1, 90, 90, 90), getLattice())\n        mneq_(self.ub.ubcalc.U, self._refineub_matrix,\n              4, note=""wrong U matrix after refinement"")\n\n    def testFitub(self):\n        self.ub.newub(\'testfitub\')\n        for s in scenarios.sessions(settings.Pos)[-3:]:\n            a, b, c, alpha, beta, gamma = s.lattice\n            self.ub.clearref()\n            for r in s.reflist:\n                self.ub.addref(\n                    [r.h, r.k, r.l], r.pos.totuple(), r.energy, r.tag)\n            self.ub.setlat(s.name, s.system, *s.lattice)\n            self.ub.calcub(s.ref1.tag, s.ref2.tag)\n\n            init_latt = (1.06 * a, 1.07 * b, 0.94 * c,\n                         1.05 * alpha, 1.06 * beta, 0.95 * gamma)\n            self.ub.setlat(s.name, s.system, *init_latt)\n            self.ub.addmiscut(3., [0.2, 0.8, 0.1])\n\n            prepareRawInput([\'y\', \'y\'])\n            self.ub.fitub(*tuple(r.tag for r in s.reflist))\n            assert self.ub.ubcalc._state.crystal._system == s.system\n            mneq_(matrix((self.ub.ubcalc._state.crystal.getLattice()[1:])), matrix(s.lattice),\n                  2, note=""wrong lattice after fitting UB"")\n            mneq_(self.ub.ubcalc.U, matrix(s.umatrix),\n                  3, note=""wrong U matrix after fitting UB"")\n\n    def testC2th(self):\n        self.ub.newub(\'testc2th\')\n        self.ub.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        assert self.ub.c2th((0, 0, 1)) == pytest.approx(60)\n\n    def testHKLangle(self):\n        self.ub.newub(\'testhklangle\')\n        self.ub.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        assert self.ub.hklangle((0, 0, 1), (0, 0, 2)) == pytest.approx(0)\n        assert self.ub.hklangle((0, 1, 0), (0, 0, 2)) == pytest.approx(90)\n        assert self.ub.hklangle((1, 0, 0), (0, 0, 2)) == pytest.approx(90)\n        assert self.ub.hklangle((1, 1, 0), (0, 0, 2)) == pytest.approx(90)\n        assert self.ub.hklangle((0, 1, 1), (0, 0, 2)) == pytest.approx(45)\n        assert self.ub.hklangle((1, 0, 1), (0, 0, 2)) == pytest.approx(45)\n        assert self.ub.hklangle((1, 1, 1), (0, 0, 2)) == pytest.approx(atan(sqrt(2))*TODEG)\n\n    def testSigtau(self):\n        # sigtau [sig tau]\n        with pytest.raises(TypeError):\n            self.ub.sigtau(1)\n        with pytest.raises(ValueError):\n            self.ub.sigtau(1, \'a\')\n        self.ub.sigtau(1, 2)\n        self.ub.sigtau(1, 2.0)\n        eq_(self.ub.ubcalc.sigma, 1)\n        eq_(self.ub.ubcalc.tau, 2.0)\n\n    def testSigtauInteractive(self):\n        prepareRawInput([\'1\', \'2.\'])\n        self.ub.sigtau()\n        eq_(self.ub.ubcalc.sigma, 1)\n        eq_(self.ub.ubcalc.tau, 2.0)\n        #Defaults:\n        prepareRawInput([\'\', \'\'])\n        self.hardware.position = [None, None, None, None, 3, 4.]\n        self.ub.sigtau()\n        eq_(self.ub.ubcalc.sigma, -3.)\n        eq_(self.ub.ubcalc.tau, -4.)\n\n    def testSetWithString(self):\n        with pytest.raises(TypeError):\n            self.ub.setlat(\'alpha\')\n        with pytest.raises(TypeError):\n            self.ub.setlat(\'alpha\', 1, \'a\')\n\n    def test_setnphihkl_at_various_phases(self):\n        self.ub.setnphi([1, 0, 1])\n        self.ub.setnhkl([1, 0, 1])\n        self.ub.newub(\'test\')\n        self.ub.setnphi([1, 0, 1])\n        self.ub.setnhkl([1, 0, 1]) \n        self.ub.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        self.ub.setnphi([1, 0, 1])\n        self.ub.setnhkl([1, 0, 1])\n        self.ub.setu([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.ub.setnphi([1, 0, 1])\n        self.ub.setnhkl([1, 0, 1])\n\n    def test_surfnphihkl_at_various_phases(self):\n        self.ub.surfnphi([1, 0, 1])\n        self.ub.surfnhkl([1, 0, 1])\n        self.ub.newub(\'test\')\n        self.ub.surfnphi([1, 0, 1])\n        self.ub.surfnhkl([1, 0, 1]) \n        self.ub.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        self.ub.surfnphi([1, 0, 1])\n        self.ub.surfnhkl([1, 0, 1])\n        self.ub.setu([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.ub.surfnphi([1, 0, 1])\n        self.ub.surfnhkl([1, 0, 1])\n\n    def testMiscut(self):\n        self.ub.newub(\'testsetmiscut\')\n        self.ub.ubcalc._state.reference._set_n_phi_configured(matrix(\'0; 0; 1\'))\n        self.ub.setlat(\'cube\', 1, 1, 1, 90, 90, 90)\n        beam_axis = self.conv.transform(matrix(\'0; 1; 0\'), True).T.tolist()[0]\n        beam_maxis = self.conv.transform(matrix(\'0; -1; 0\'), True).T.tolist()[0]\n        self.ub.setmiscut(self.t_hand * 30, beam_axis)\n        mneq_(self.ub.ubcalc._state.reference.n_hkl, matrix(\'-0.5000000; 0.00000; 0.8660254\'))\n        self.ub.addmiscut(self.t_hand * 15, beam_axis)\n        mneq_(self.ub.ubcalc._state.reference.n_hkl, matrix(\'-0.7071068; 0.00000; 0.7071068\'))\n        self.ub.addmiscut(self.t_hand * 45, beam_maxis)\n        mneq_(self.ub.ubcalc._state.reference.n_hkl, matrix(\'0.0; 0.0; 1.0\'))\n\n\nclass TestUbCommandsVlieg(_UBCommandsBase):\n    \n    def setup_method(self):\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        settings.geometry = SixCircleGammaOnArmGeometry()\n        settings.ubcalc_strategy = VliegUbCalcStrategy()\n        settings.angles_to_hkl_function = vliegAnglesToHkl\n        settings.Pos = VliegPosition\n        self.t_matrix = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.t_hand = 1\n        _UBCommandsBase.setup_method(self)\n\n\nclass TestUBCommandsYou(_UBCommandsBase):\n\n    def setup_method(self):\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        settings.geometry = SixCircle()\n        settings.ubcalc_strategy = YouUbCalcStrategy()\n        settings.angles_to_hkl_function = youAnglesToHkl\n        settings.Pos = YouPositionScenario\n        self.t_matrix = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.t_hand = 1\n        _UBCommandsBase.setup_method(self)\n\n\nclass TestUBCommandsCustomGeom(TestUBCommandsYou):\n\n    def setup_method(self):\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        inv = matrix([[0, 0, -1], [0, 1, 0], [1, 0, 0]])\n        self.zrot = xyz_rotation([0, 0 ,1], 30. * TORAD)\n        self.t_matrix = inv * self.zrot\n        self.t_hand = 1\n        settings.geometry = SixCircle(beamline_axes_transform=self.t_matrix)\n        settings.ubcalc_strategy = YouUbCalcStrategy()\n        settings.angles_to_hkl_function = youAnglesToHkl\n        settings.Pos = YouPositionScenario\n        _UBCommandsBase.setup_method(self)\n\n    def testSetu(self):\n        self.ub.newub(\'testsetu_custom\')\n        self.ub.setlat(\'NaCl\', 1.1)\n        zrot = xyz_rotation([0, 0 , 1], 30. * TORAD)\n        self.ub.setu(zrot.tolist())\n        mneq_(self.ub.ubcalc.U, self.conv.transform(self.zrot))\n\n    def testSetuInteractive(self):\n        # Interactive functionality already tested\n        raise SkipTest()\n\n    def testSetub(self):\n        self.ub.newub(\'testsetub_custom\')\n        self.ub.setlat(\'NaCl\', 1.1)\n        zrot = xyz_rotation([0, 0 , 1], 30. * TORAD)\n        self.ub.setu(zrot.tolist())\n\n        mneq_(self.ub.ubcalc.UB, self.conv.transform(self.zrot) * self.ub.ubcalc._state.crystal.B)\n\n    def testSetUbInteractive(self):\n        # Interactive functionality already tested\n        raise SkipTest()\n\nclass TestUbCommandsJsonPersistence(TestUBCommandsYou):\n\n    def setup_method(self):\n        settings.ubcalc_persister = self._createPersister()\n        settings.geometry = SixCircle()\n        settings.ubcalc_strategy = YouUbCalcStrategy()\n        settings.angles_to_hkl_function = youAnglesToHkl\n        settings.Pos = YouPositionScenario\n        self.t_matrix = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        self.t_hand = 1\n        _UBCommandsBase.setup_method(self)\n\n    def _createPersister(self):\n        self.tmpdir = tempfile.mkdtemp()\n        print self.tmpdir\n        self.persister = UBCalculationJSONPersister(self.tmpdir, UBCalcStateEncoder)\n        f = open(os.path.join(self.tmpdir, \'unexpected_file\'), \'w\')\n        f.close()\n        return self.persister\n\n    def testNewUb(self):\n        self.ub.newub(\'test1\')\n        self.ub.loadub(\'test1\')\n        self.ub.ub()\n        \n    def test_n_phi_persistance(self):\n        self.ub.newub(\'test1\')\n        self.ub.setnphi([0, 1, 0])\n        arrayeq_(self.ub.ubcalc.n_phi.T.tolist()[0], [0, 1, 0])\n        self.ub.loadub(\'test1\')\n        arrayeq_(self.ub.ubcalc.n_phi.T.tolist()[0], [0, 1, 0])\n\n'"
test/diffcalc/dc/you/__init__.py,0,b''
test/diffcalc/dc/you/test_fourcircle.py,0,"b""from math import pi\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\nfrom test.tools import mneq_, aneq_, assert_dict_almost_equal\n\nimport diffcalc.util  # @UnusedImport\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hkl.you.geometry import FourCircle\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom diffcalc import settings\n\n\ndiffcalc.util.DEBUG = True\nwl = 1\nen = 12.39842 / wl\n\nangles = [60, 30, 0, 0]\nparam = {'tau': 90, 'psi': 90, 'beta': 0, 'alpha': 0, 'naz': 0, 'qaz': 90, 'theta': 30, 'ttheta': 60, 'betain': 0, 'betaout': 0}\n\n\ndc = None\ndef setup_module():\n    global dc\n    axes = 'delta', 'eta', 'chi', 'phi'\n    settings.hardware = DummyHardwareAdapter(axes)\n    settings.geometry = FourCircle()\n    settings.ubcalc_persister = UbCalculationNonPersister()\n    settings.reference_vector = matrix('0; 0; 1')\n    \n    from diffcalc.dc import dcyou as dc\n    reload(dc)\n    dc.newub('test')\n    dc.setlat('cubic', 1, 1, 1, 90, 90, 90)\n    dc.addref([1, 0, 0], [60, 30, 0, 0], en, 'ref1')\n    dc.addref([0, 1, 0], [60, 30, 0, 90], en, 'ref2')\n\ndef test_orientation_phase():\n    # assumes reflections added were ideal (with no mis-mount)\n    dc.ub()\n    dc.checkub()\n    dc.showref()\n\n    U = matrix('1 0 0; 0 1 0; 0 0 1')\n    UB = U * 2 * pi\n    mneq_(dc._ub.ubcalc.U, U)\n    mneq_(dc._ub.ubcalc.UB, UB)\n   \ndef test_angles_to_hkl_bypassing_hardware_plugin():\n    hkl_calc, param_calc = dc.angles_to_hkl(angles, en)\n    aneq_(hkl_calc, [1, 0, 0])\n    assert_dict_almost_equal(param_calc, param)\n    \ndef test_hkl_to_angles_bypassing_hardware_plugin():\n    dc.con('a_eq_b')\n    h, k, l = [1, 0, 0]\n    angles_calc, param_calc = dc.hkl_to_angles(h, k, l, en)\n    aneq_(angles_calc, angles)\n    assert_dict_almost_equal(param_calc, param)\n    \ndef test_angles_to_hkl():\n    hkl_calc, param_calc = dc.angles_to_hkl(angles, en)\n    aneq_(hkl_calc, [1, 0, 0])\n    assert_dict_almost_equal(param_calc, param)\n    \ndef test_hkl_to_angles():\n    dc.con('a_eq_b')\n    h, k, l = [1, 0, 0]\n    angles_calc, param_calc = dc.hkl_to_angles(h, k, l, en)\n    aneq_(angles_calc, angles)\n    assert_dict_almost_equal(param_calc, param)"""
test/diffcalc/dc/you/test_sixcircle.py,0,"b'\nfrom math import pi\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\nfrom test.tools import mneq_, aneq_, dneq_\n\nimport diffcalc.util  # @UnusedImport\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom diffcalc.settings import NUNAME\nfrom diffcalc import settings\n\n\ndiffcalc.util.DEBUG = True\nwl = 1\nen = 12.39842 / wl\n\nangles = [0, 60, 0, 30, 0, 0]\nparam = {\'tau\': 90, \'psi\': 90, \'beta\': 0, \'alpha\': 0, \'naz\': 0, \'qaz\': 90, \'theta\': 30, \'ttheta\': 60, \'betain\': 0, \'betaout\': 0}\n\n\ndc=None\ndef setup_module():\n    global dc\n    axes = \'mu\', \'delta\', NUNAME, \'eta\', \'chi\', \'phi\'\n    settings.hardware = DummyHardwareAdapter(axes)\n    settings.geometry = SixCircle()\n    settings.ubcalc_persister = UbCalculationNonPersister()\n    \n    from diffcalc.dc import dcyou as dc\n    reload(dc)\n\n    dc.newub(\'test\')\n    dc.setlat(\'cubic\', 1, 1, 1, 90, 90, 90)\n    dc.addref([1, 0, 0], [0, 60, 0, 30, 0, 0], en, \'ref1\')\n    dc.addref([0, 1, 0], [0, 60, 0, 30, 0, 90], en, \'ref2\')\n\ndef test_orientation_phase():\n    # assumes reflections added were ideal (with no mis-mount)\n    dc.ub()\n    dc.checkub()\n    dc.showref()\n\n    U = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n    UB = U * 2 * pi\n    mneq_(dc._ub.ubcalc.U, U)\n    mneq_(dc._ub.ubcalc.UB, UB)\n       \ndef test_angles_to_hkl_bypassing_hardware_plugin():\n    hkl_calc, param_calc = dc.angles_to_hkl(angles, en)\n    aneq_(hkl_calc, [1, 0, 0])\n    dneq_(param_calc, param)\n\ndef test_hkl_to_angles_bypassing_hardware_plugin():\n    dc.con(\'a_eq_b\')\n    dc.con(\'mu\', 0)\n    dc.con(NUNAME, 0)\n\n    h, k, l = [1, 0, 0]\n    angles_calc, param_calc = dc.hkl_to_angles(h, k, l, en)\n    aneq_(angles_calc, angles)\n    dneq_(param_calc, param)\n\ndef test_angles_to_hkl():\n    hkl_calc, param_calc = dc.angles_to_hkl(angles)\n    aneq_(hkl_calc, [1, 0, 0])\n    dneq_(param_calc, param)\n    \ndef test_hkl_to_angles():\n    dc.con(\'a_eq_b\')\n    dc.con(\'mu\', 0)\n    dc.con(NUNAME, 0)\n\n    h, k, l = [1, 0, 0]\n    angles_calc, param_calc = dc.hkl_to_angles(h, k, l)\n    aneq_(angles_calc, angles)\n    dneq_(param_calc, param)\n    \ndef test_allhkl():\n    diffcalc.util.DEBUG = True\n    dc.con(\'eta\', 0, \'chi\', 0, \'phi\', 0)\n    dc.allhkl([.1, 0, .01], 1)\n    \n\n# def test_ub_help_visually(self):\n#     print ""-"" * 80 + ""\\nub:""\n#     print format_command_help(self.dc.ub.commands)\n# \n# def test_hkl_help_visually(self):\n#     print ""-"" * 80 + ""\\nhkl:""\n#     print format_command_help(self.dc.hkl.commands)'"
test/diffcalc/gdasupport/minigda/__init__.py,0,b''
test/diffcalc/gdasupport/minigda/test_command.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\nimport diffcalc.gdasupport.minigda.command\nfrom diffcalc.gdasupport.minigda.command import Pos, Scan, ScanDataPrinter\nfrom diffcalc.gdasupport.minigda.scannable import \\\n    MultiInputExtraFieldsDummyScannable, SingleFieldDummyScannable\n\n\nclass BadSingleFieldDummyScannable(SingleFieldDummyScannable):\n        def getPosition(self):\n            raise Exception(""Problem"")\n\n\nclass NoneReturningSingleFieldDummyScannable(SingleFieldDummyScannable):\n        def getPosition(self):\n            return None\n\n\nclass TestPos(object):\n\n    def setup_method(self):\n        self.dummyMainNamespace = namespace = {}\n        namespace[\'notAScannable\'] = 3.124\n        namespace[\'scnA\'] = SingleFieldDummyScannable(\'scnA\')\n        namespace[\'scnB\'] = SingleFieldDummyScannable(\'scnB\')\n        namespace[\'scnC\'] = SingleFieldDummyScannable(\'scnC\')\n        namespace[\'scnD\'] = SingleFieldDummyScannable(\'scnD\')\n        namespace[\'scnNone\'] = \\\n            NoneReturningSingleFieldDummyScannable(\'scnNone\')\n        namespace[\'scnBad\'] = BadSingleFieldDummyScannable(\'scnBad\')\n        \n        diffcalc.gdasupport.minigda.command.ROOT_NAMESPACE_DICT = \\\n            self.dummyMainNamespace\n        self.pos = Pos()\n\n    def testPosReturningReportWithRead(self):\n        scnA = self.dummyMainNamespace[\'scnA\']\n        assert self.pos.posReturningReport(scnA) == \'scnA:      0.0000\'\n\n    def testPosReturningReportWithMove(self):\n        scnA = self.dummyMainNamespace[\'scnA\']\n        assert self.pos.posReturningReport(scnA, 1.123) == \'scnA:      1.1230\'\n\n    def test__call__(self):\n        scnA = self.dummyMainNamespace[\'scnA\']\n        self.pos.__call__(scnA)\n        self.pos.__call__(scnA, 4.321)\n        print ""*""\n        self.pos.__call__()\n        print ""*""\n\n    def testPosReturningReportWithMultiFieldScannables(self):\n        scn = MultiInputExtraFieldsDummyScannable(\'mie\', [\'i1\', \'i2\'], [\'e1\'])\n        assert (self.pos.posReturningReport(scn) \n                == \'mie:      i1: 0.0000 i2: 0.0000 e1: 100.0000 \')\n\n    def testPosReturningReportWithBadScannable(self):\n        scnBad = self.dummyMainNamespace[\'scnBad\']\n        assert self.pos.posReturningReport(scnBad) == ""scnBad:   Error: Problem""\n        assert (self.pos.posReturningReport(scnBad, 4.321)\n                 == ""scnBad:   Error: Problem"")\n\n    def testPosReturningReportWithNoneReturningScannable(self):\n        scnNone = self.dummyMainNamespace[\'scnNone\']\n        assert self.pos.posReturningReport(scnNone) == ""scnNone:  ---""\n        assert self.pos.posReturningReport(scnNone, 4.321) == ""scnNone:  ---""\n\n\nclass TestScan(object):\n\n    def setup_method(self):\n        self.scan = Scan([ScanDataPrinter()])\n\n    def test__parseScanArgsIntoScannableArgGroups(self):\n        scnA = SingleFieldDummyScannable(\'scnA\')\n        scnB = SingleFieldDummyScannable(\'scnB\')\n        scnC = SingleFieldDummyScannable(\'scnC\')\n        scnD = SingleFieldDummyScannable(\'scnD\')\n\n        scanargs = (scnA, 1, 2, 3, scnB, [4, 5, 6], scnC, scnD, 1.123456)\n        r = self.scan._parseScanArgsIntoScannableArgGroups(scanargs)\n        result = [r[0].scannable, r[0].args, r[1].scannable, r[1].args,\n                  r[2].scannable, r[2].args, r[3].scannable, r[3].args]\n        desired = [scnA, [1, 2, 3], scnB, [[4, 5, 6], ], scnC, list(), scnD,\n                   [1.123456]]\n        assert result == desired\n\n    def test__reorderGroupsAccordingToLevel(self):\n        scn4 = SingleFieldDummyScannable(\'scn4\')\n        scn4.setLevel(4)\n        scn5a = SingleFieldDummyScannable(\'scn5a\')\n        scn5a.setLevel(5)\n        scn5b = SingleFieldDummyScannable(\'scn5b\')\n        scn5b.setLevel(5)\n        scn6 = SingleFieldDummyScannable(\'scn6\')\n        scn6.setLevel(6)\n\n        def t(scanargs):\n            groups = self.scan._parseScanArgsIntoScannableArgGroups(scanargs)\n            r = self.scan._reorderInnerGroupsAccordingToLevel(groups)\n            return [r[0].scannable, r[1].scannable, r[2].scannable,\n                    r[3].scannable]\n\n        assert (t((scn5a, 1, 2, 3, scn6, 1, scn5b, scn4))\n                == [scn5a, scn4, scn5b, scn6])\n        assert (t((scn5a, 1, 3, scn6, 1, scn5b, scn4))\n                == [scn4, scn5a, scn5b, scn6])\n\n    def test__Frange(self):\n        assert self.scan._frange(1, 1.3, .1) == [1.0, 1.1, 1.2, 1.3]\n\n    def test__Call__(self):\n        scn4 = SingleFieldDummyScannable(\'scn4\')\n        scn4.setLevel(4)\n        scn5a = SingleFieldDummyScannable(\'scn5a\')\n        scn5a.setLevel(5)\n        scn5b = SingleFieldDummyScannable(\'scn5b\')\n        scn5b.setLevel(5)\n        scn6 = SingleFieldDummyScannable(\'scn6\')\n        scn6.setLevel(6)\n        self.scan.__call__(scn5a, 1, 3, 1, scn6, 1, scn5b, scn4)\n'"
test/diffcalc/gdasupport/minigda/test_scannable.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\nfrom diffcalc.gdasupport.scannable.mock import MockMotor\nfrom diffcalc.gdasupport.minigda.scannable import \\\n    SingleFieldDummyScannable\nfrom diffcalc.gdasupport.minigda.scannable import Scannable\nfrom diffcalc.gdasupport.minigda.scannable import ScannableGroup\n\n\nclass TestScannable(object):\n\n    def setup_method(self):\n        self.scannable = Scannable()\n\n    def testSomethingUnrelated(self):\n        a = SingleFieldDummyScannable('a')\n        print isinstance(a, Scannable)\n\n\ndef createDummyAxes(names):\n    result = []\n    for name in names:\n        result.append(DummyPD(name))\n    return result\n\n\nclass TestScannableGroup(object):\n\n    def setup_method(self):\n        self.a = MockMotor('a')\n        self.b = MockMotor('bbb')\n        self.c = MockMotor('c')\n        self.sg = ScannableGroup('abc', (self.a, self.b, self.c))\n\n    def testInit(self):\n        assert list(self.sg.getInputNames()) == ['a', 'bbb', 'c']\n        assert self.sg.getPosition() == [0.0, 0.0, 0.0]\n\n    def testAsynchronousMoveTo(self):\n        self.sg.asynchronousMoveTo([1, 2.0, 3])\n        assert self.sg.getPosition() == [1.0, 2.0, 3.0]\n\n    def testAsynchronousMoveToWithNones(self):\n        self.sg.asynchronousMoveTo([1.0, 2.0, 3.0])\n        self.sg.asynchronousMoveTo([None, None, 3.2])\n        assert self.sg.getPosition() == [1.0, 2.0, 3.2]\n\n    def testGetPosition(self):\n        # implicitely tested above\n        pass\n\n    def testIsBusy(self):\n        assert not self.sg.isBusy()\n        self.sg.asynchronousMoveTo([1.0, 2.0, 3.0])\n        assert self.sg.isBusy()\n        self.b.makeNotBusy()\n        assert self.sg.isBusy()\n        self.a.makeNotBusy()\n        self.c.makeNotBusy()\n        assert not self.sg.isBusy()\n"""
test/diffcalc/gdasupport/scannable/__init__.py,0,b''
test/diffcalc/gdasupport/scannable/mockdiffcalc.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nclass MockParameterManager:\n\n    def __init__(self):\n        self.params = {}\n\n    def set_constraint(self, name, value):\n        self.params[name] = value\n\n    def get_constraint(self, name):\n        return self.params[name]\n\n\nclass MockDiffcalc:\n\n    def __init__(self, numberAngles):\n        self.numberAngles = numberAngles\n        self.parameter_manager = MockParameterManager()\n\n    def hkl_to_angles(self, h, k, l):\n        params = {}\n        params['theta'] = 1.\n        params['2theta'] = 12.\n        params['Bin'] = 123.\n        params['Bout'] = 1234.\n        params['azimuth'] = 12345.\n        return ([h] * self.numberAngles, params)\n\n    def angles_to_hkl(self, pos):\n        if len(pos) != self.numberAngles: raise ValueError\n        params = {}\n        params['theta'] = 1.\n        params['2theta'] = 12.\n        params['Bin'] = 123.\n        params['Bout'] = 1234.\n        params['azimuth'] = 12345.\n        return ([pos[0]] * 3, params)\n\n"""
test/diffcalc/gdasupport/scannable/test_diffractometer.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\nfrom mock import Mock\n\nfrom diffcalc.gdasupport.scannable.slave_driver import SlaveScannableDriver\nfrom diffcalc.gdasupport.scannable.diffractometer import \\\n    DiffractometerScannableGroup\nfrom diffcalc.gdasupport.scannable.mock import MockMotor\nfrom test.diffcalc.gdasupport.scannable.mockdiffcalc import MockDiffcalc\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\ntry:\n    from gda.device.scannable.scannablegroup import ScannableGroup\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import ScannableGroup\n\n\ndef createDummyAxes(names):\n    result = []\n    for name in names:\n        result.append(DummyPD(name))\n    return result\n\n\nclass MockSlaveScannableDriver(object):\n\n    def __init__(self):\n        self.busy = False\n        self.lastPosition = None\n\n    def isBusy(self):\n        return self.busy\n\n    def triggerAsynchronousMove(self, position):\n        self.lastPosition = position\n\n    def getPositions(self):\n        return 90, 91\n\n\nclass TestDiffractometerScannableGroup(object):\n\n    def setup_method(self):\n        self.a = MockMotor()\n        self.b = MockMotor()\n        self.c = MockMotor()\n        self.d = MockMotor()\n        self.e = MockMotor()\n        self.f = MockMotor()\n        self.grp = ScannableGroup(\n            \'grp\', [self.a, self.b, self.c, self.d, self.e, self.f])\n        self.grp.configure()\n        self.sg = DiffractometerScannableGroup(\n            \'sixc\', MockDiffcalc(6), self.grp)\n\n    def testInit(self):\n        assert list(self.sg.getPosition()) == [0., 0., 0., 0., 0., 0.]\n\n    def testAsynchronousMoveTo(self):\n        self.sg.asynchronousMoveTo([1, 2.0, 3, 4, 5, 6])\n        assert list(self.sg.getPosition()) == [1., 2., 3., 4., 5., 6.]\n\n    def testAsynchronousMoveToWithNones(self):\n        self.sg.asynchronousMoveTo([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n        self.sg.asynchronousMoveTo([None, None, 3.2, None, 5.2, None])\n        assert list(self.sg.getPosition()) == [1., 2., 3.2, 4., 5.2, 6.]\n\n    def testGetPosition(self):\n        #implicitely tested above\n        pass\n\n    def testWhereMoveTo(self):\n        # just check for exceptions\n        print self.sg.simulateMoveTo((1.23, 2, 3, 4, 5, 6))\n\n    def testIsBusy(self):\n        assert not self.sg.isBusy()\n        self.sg.asynchronousMoveTo([1.0, 2.0, 3.0, 4, 5, 6])\n        assert self.sg.isBusy()\n        self.b.makeNotBusy()\n        assert self.sg.isBusy()\n        self.a.makeNotBusy()\n        self.c.makeNotBusy()\n        self.d.makeNotBusy()\n        self.e.makeNotBusy()\n        self.f.makeNotBusy()\n        assert not self.sg.isBusy()\n\n    def testRepr(self):\n        print self.sg.__repr__()\n\n\nclass TestDiffractometerScannableGroupWithSlave(\n    TestDiffractometerScannableGroup):\n\n    def setup_method(self):\n        TestDiffractometerScannableGroup.setup_method(self)\n        self.mock_driver = Mock(spec=SlaveScannableDriver)\n        self.mock_driver.getPositions.return_value = 90, 91\n        self.mock_driver.isBusy.return_value = False\n        self.mock_driver.getScannableNames.return_value = \'a\', \'b\'\n\n        self.sg.slave_driver = self.mock_driver\n\n    def test__init__(self):\n        sg = DiffractometerScannableGroup(\n            \'sixc\', MockDiffcalc(6), self.grp, self.mock_driver)\n        assert sg.slave_driver == self.mock_driver\n\n    def testAsynchronousMoveToWithNones(self):\n        self.sg.asynchronousMoveTo([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n        self.sg.asynchronousMoveTo([None, None, 3.2, None, 5.2, None])\n        assert list(self.sg.getPosition()) == [1., 2., 3.2, 4., 5.2, 6., 90, 91]\n        self.mock_driver.triggerAsynchronousMove.assert_called_with(\n            [None, None, 3.2, None, 5.2, None])\n\n    def testIsBusyWithSlave(self):\n        self.mock_driver.isBusy.return_value = True\n        assert self.sg.isBusy()\n\n    ### overridden\n\n    def testInit(self):\n        assert list(self.sg.getPosition()) == [0., 0., 0., 0., 0., 0., 90, 91]\n\n    def testAsynchronousMoveTo(self):\n        self.sg.asynchronousMoveTo([1, 2.0, 3, 4, 5, 6])\n        assert list(self.sg.getPosition()) == [1., 2., 3., 4., 5., 6., 90, 91]\n\n\nclass TestDiffractometerScannableGroupWithFailingAngleCalculator(object):\n\n    def setup_method(self):\n        class BadMockAngleCalculator:\n            def angles_to_hkl(self, pos):\n                raise Exception(""Problem"")\n        dummy = createDummyAxes([\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\',\n                                 \'phi\'])\n        self.group = ScannableGroup(\'grp\', dummy)\n        self.group.configure()\n        self.sg = DiffractometerScannableGroup(\n            \'sixc\', BadMockAngleCalculator(), self.group)\n\n    def testGetPosition(self):\n        self.sg.getPosition()\n\n    def testSimulateMoveTo(self):\n        assert (self.sg.simulateMoveTo([1., 2., 3., 4., 5., 6.])\n                == ""Error: Problem"")\n'"
test/diffcalc/gdasupport/scannable/test_hkl.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport mock\nimport nose\nimport unittest\n\nfrom diffcalc.gdasupport.scannable.diffractometer import \\\n    DiffractometerScannableGroup\nfrom diffcalc.gdasupport.scannable.hkl import Hkl\nfrom test.diffcalc.gdasupport.scannable.mockdiffcalc import MockDiffcalc\nimport pytest\ntry:\n    from gda.device.scannable.scannablegroup import ScannableGroup\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import ScannableGroup\n\n\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\ndef createDummyAxes(names):\n    result = []\n    for name in names:\n        result.append(DummyPD(name))\n    return result\n\n\nPARAM_DICT = {\'theta\': 1, \'2theta\': 12., \'Bin\': 123., \'Bout\': 1234.,\n              \'azimuth\': 12345}\n\n\nclass Popper:\n\n    def __init__(self, *items):\n        self.items = list(items)\n\n    def __call__(self, *args):\n        return self.items.pop(0)\n\n\nclass TestHkl(object):\n\n    def setup_method(self):\n        self.mock_dc_module = mock.Mock()\n        self.mockSixc = mock.Mock(spec=DiffractometerScannableGroup)\n        self.hkl = Hkl(\'hkl\', self.mockSixc, self.mock_dc_module)\n\n    def testInit(self):\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 2, 3], PARAM_DICT)\n        assert self.hkl.getPosition() == [1, 2, 3]\n\n    def testAsynchronousMoveTo(self):\n        self.mock_dc_module.hkl_to_angles.return_value = ([6, 5, 4, 3, 2, 1],\n                                                       None)\n        self.hkl.asynchronousMoveTo([1, 0, 1])\n        self.mock_dc_module.hkl_to_angles.assert_called_with(1, 0, 1)\n        self.mockSixc.asynchronousMoveTo.assert_called_with([6, 5, 4, 3, 2, 1])\n\n    def testGetPosition(self):\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        assert self.hkl.getPosition() == [1, 0, 1]\n        self.mock_dc_module.angles_to_hkl.assert_called_with([6, 5, 4, 3, 2, 1])\n\n    def testAsynchronousMoveToWithNonesOutsideScan(self):\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1],\n                                                       PARAM_DICT)\n        self.mock_dc_module.hkl_to_angles.return_value = ([12, 5, 4, 3, 2, 1],\n                                                       PARAM_DICT)  # <- 2,0,1\n\n        self.hkl.asynchronousMoveTo([2, 0, None])\n\n        self.mock_dc_module.angles_to_hkl.assert_called_with([6, 5, 4, 3, 2, 1])\n        self.mock_dc_module.hkl_to_angles.assert_called_with(2, 0, 1)\n        self.mockSixc.asynchronousMoveTo.assert_called_with(\n            [12, 5, 4, 3, 2, 1])\n\n    def testAsynchronousMoveToWithNonesInScan(self):\n\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        self.hkl.atScanStart()\n        # should not be used:\n        self.mockSixc.getPosition.return_value = [6.1, 5.1, 4.1, 3.1, 2.1, 1.1]\n        self.mock_dc_module.hkl_to_angles.return_value = ([12, 5, 4, 3, 2, 1],\n                                                       PARAM_DICT)\n        self.hkl.asynchronousMoveTo([2, 0, None])\n        # atScanStart:\n        self.mock_dc_module.angles_to_hkl.assert_called_with([6, 5, 4, 3, 2, 1])\n        self.mock_dc_module.hkl_to_angles.assert_called_with(2, 0, 1)\n        self.mockSixc.asynchronousMoveTo.assert_called_with(\n            [12, 5, 4, 3, 2, 1])\n\n    def testAsynchronousMoveToWithNonesInScanAfterCommandFailure(self):\n        # should be forgotten:\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        self.hkl.atScanStart()\n        self.hkl.atCommandFailure()\n\n        self.mockSixc.getPosition.return_value = [6.1, 5.1, 4.1, 3.1, 2.1, 1.1]\n        self.mock_dc_module.hkl_to_angles.return_value = (\n                [12.1, 5.1, 4.1, 3.1, 2.1, 1.1], PARAM_DICT)\n        self.hkl.asynchronousMoveTo([2, 0, None])\n\n        self.mock_dc_module.angles_to_hkl.assert_called_with(\n            [6.1, 5.1, 4.1, 3.1, 2.1, 1.1])\n        self.mock_dc_module.hkl_to_angles.assert_called_with(2, 0, 1)\n        self.mockSixc.asynchronousMoveTo.assert_called_with(\n            [12.1, 5.1, 4.1, 3.1, 2.1, 1.1])\n\n    def testAsynchronousMoveToWithNonesInScanAfterAtScanEnd(self):\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        self.hkl.atScanStart()\n        self.hkl.atScanEnd()\n\n        self.mockSixc.getPosition.return_value = [6.1, 5.1, 4.1, 3.1, 2.1, 1.1]\n        self.mock_dc_module.hkl_to_angles.return_value = (\n            [12.1, 5.1, 4.1, 3.1, 2.1, 1.1], PARAM_DICT)\n        self.hkl.asynchronousMoveTo([2, 0, None])\n\n        self.mock_dc_module.angles_to_hkl.assert_called_with(\n            [6.1, 5.1, 4.1, 3.1, 2.1, 1.1])\n        self.mock_dc_module.hkl_to_angles.assert_called_with(2, 0, 1)\n        self.mockSixc.asynchronousMoveTo.assert_called_with(\n            [12.1, 5.1, 4.1, 3.1, 2.1, 1.1])\n\n    def testIsBusy(self):\n        self.mockSixc.isBusy.return_value = False\n        assert not self.hkl.isBusy()\n        self.mockSixc.isBusy.assert_called()\n\n    def testWaitWhileBusy(self):\n        self.hkl.waitWhileBusy()\n        self.mockSixc.waitWhileBusy.assert_called()\n\n    def testWhereMoveTo(self):\n        # just check for exceptions\n        self.mock_dc_module.hkl_to_angles.return_value = ([6, 5, 4, 3, 2, 1],\n                                                       PARAM_DICT)\n        self.mockSixc.getName.return_value = \'sixc\'\n        self.mockSixc.getInputNames.return_value = [\'alpha\', \'delta\', \'gamma\',\n                                                    \'omega\', \'chi\', \'phi\']\n        print self.hkl.simulateMoveTo((1.23, 0, 0))\n\n    def testDisp(self):\n        print self.hkl.__repr__()\n\n\nclass TestHklReturningVirtualangles(TestHkl):\n    def setup_method(self):\n        TestHkl.setup_method(self)\n        self.hkl = Hkl(\'hkl\', self.mockSixc, self.mock_dc_module,\n                       [\'theta\', \'2theta\', \'Bin\', \'Bout\', \'azimuth\'])\n\n    def testInit(self):\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        assert self.hkl.getPosition() == [1, 0, 1, 1, 12, 123, 1234, 12345]\n\n    def testGetPosition(self):\n        self.mockSixc.getPosition.return_value = [6, 5, 4, 3, 2, 1]\n        self.mock_dc_module.angles_to_hkl.return_value = ([1, 0, 1], PARAM_DICT)\n        assert self.hkl.getPosition() == [1, 0, 1, 1, 12, 123, 1234, 12345]\n        self.mock_dc_module.angles_to_hkl.assert_called_with([6, 5, 4, 3, 2, 1])\n\n\nclass TestHklWithFailingAngleCalculator(object):\n    def setup_method(self):\n        class BadMockAngleCalculator:\n            def angles_to_hkl(self, pos):\n                raise Exception(""Problem in angles_to_hkl"")\n\n        dummy = createDummyAxes([\'alpha\', \'delta\', \'gamma\', \'omega\', \'chi\',\n                                 \'phi\'])\n        self.group = ScannableGroup(\'grp\', dummy)\n        self.SixCircleGammaOnArmGeometry = DiffractometerScannableGroup(\n            \'SixCircleGammaOnArmGeometry\', MockDiffcalc(6), self.group)\n        self.hkl = Hkl(\'hkl\', self.SixCircleGammaOnArmGeometry,\n                       BadMockAngleCalculator())\n\n    def testGetPosition(self):\n        with pytest.raises(Exception):\n            self.hkl.getPosition(None)\n\n    def test__repr__(self):\n        assert self.hkl.__repr__() == ""<hkl: Problem in angles_to_hkl>""\n\n    def test__str__(self):\n        assert self.hkl.__str__() == ""<hkl: Problem in angles_to_hkl>""\n\n    def testComponentGetPosition(self):\n        with pytest.raises(Exception):\n            self.hkl.h.getPosition(None)\n\n    def testComponent__repr__(self):\n        raise nose.SkipTest()\n        assert self.hkl.h.__repr__() == ""<h: Problem in angles_to_hkl>""\n\n    def testComponent__str__(self):\n        raise nose.SkipTest()\n        assert self.hkl.h.__str__() == ""<h: Problem in angles_to_hkl>""\n'"
test/diffcalc/gdasupport/scannable/test_parameter.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\nfrom diffcalc.gdasupport.scannable.parameter import \\\n    DiffractionCalculatorParameter\nfrom test.diffcalc.gdasupport.scannable.mockdiffcalc import \\\n    MockParameterManager\n\n\nclass TestDiffractionCalculatorParameter(object):\n\n    def setup_method(self):\n        self.dcp = DiffractionCalculatorParameter('dcp', 'betain',\n                                                  MockParameterManager())\n\n    def testAsynchronousMoveToAndGetPosition(self):\n        self.dcp.asynchronousMoveTo(12.3)\n        assert self.dcp.getPosition() == [12.3,]\n\n    def testIsBusy(self):\n        assert not self.dcp.isBusy()\n"""
test/diffcalc/gdasupport/scannable/test_simulation.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi\nimport unittest\nfrom pytest import approx\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.gdasupport.scannable.simulation import SimulatedCrystalCounter, \\\n    Gaussian\nfrom diffcalc.hkl.vlieg.geometry import Fourc\nfrom diffcalc.util import nearlyEqual\nfrom test.tools import mneq_\n\n\nclass MockScannable(object):\n    def __init__(self):\n        self.pos = None\n\n    def getPosition(self):\n        return self.pos\n\n\nclass MockEquation(object):\n\n    def __call__(self, dh, dk, dl):\n        self.dHkl = dh, dk, dl\n        return 1\n\n\nclass TestSimulatedCrystalCounter(object):\n\n    def setup_method(self):\n        self.diff = MockScannable()\n        self.wl = MockScannable()\n        self.wl.pos = 1.\n        self.eq = MockEquation()\n        self.scc = SimulatedCrystalCounter('det', self.diff, Fourc(), self.wl,\n                                           self.eq)\n\n    def testInit(self):\n        assert list(self.scc.getInputNames()) == ['det_count']\n        assert list(self.scc.getExtraNames()) == []\n        assert self.scc.chiMissmount == 0.\n        assert self.scc.phiMissmount == 0.\n\n    def testCalcUB(self):\n        UB = matrix([[2 * pi, 0, 0], [0, 2 * pi, 0], [0, 0, 2 * pi]])\n        mneq_(self.scc.UB, UB)\n\n    def testGetHkl(self):\n        self.diff.pos = [60, 30, 0, 0]\n        hkl = self.scc.getHkl()\n        assert hkl == approx((1, 0, 0))\n\n        self.diff.pos = [60, 31, 0, 0]\n        hkl = self.scc.getHkl()\n        assert hkl == approx((0.999847695156391, 0.017452406437283574, 0))\n\n    def testGetPosition(self):\n        self.diff.pos = [60, 30, 0, 0]\n        self.scc.asynchronousMoveTo(2)\n        count = self.scc.getPosition()\n        assert self.eq.dHkl == approx((0, 0, 0))\n        assert count == 2\n\n        self.diff.pos = [60, 31, 0, 0]\n        count = self.scc.getPosition()\n        dHkl = (0.999847695156391 - 1, .017452406437283574, 0)\n        assert self.eq.dHkl == approx(dHkl)\n        assert count == 2\n\n    def test__repr__(self):\n        self.diff.pos = [60, 30, 0, 0]\n        print self.scc.__repr__()\n\n\nclass TestGaussianEquation(object):\n    def setup_method(self):\n        self.eq = Gaussian(1.)\n\n    def test__call__(self):\n        assert self.eq(0, 0, 0) == 0.3989422804014327\n"""
test/diffcalc/gdasupport/scannable/test_wavelength.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\nfrom diffcalc.gdasupport.scannable.wavelength import Wavelength\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\nclass TestWavelength(object):\n\n    def setup_method(self):\n        self.en = DummyPD('en')\n        self.wl = Wavelength('wl', self.en)\n\n    def testIt(self):\n        self.en.asynchronousMoveTo(12.39842)\n        assert self.wl.getPosition() == 1\n\n        self.wl.asynchronousMoveTo(1.)\n        assert self.wl.getPosition() == 1.\n        assert self.en.getPosition() == 12.39842\n"""
test/diffcalc/hkl/vlieg/__init__.py,0,b''
test/diffcalc/hkl/vlieg/test_calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport random\nimport unittest\nfrom math import pi\nfrom mock import Mock\nfrom test.tools import mneq_\nimport pytest\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\n\nfrom diffcalc.hkl.vlieg.calc import VliegHklCalculator, \\\n    _findOmegaAndChiToRotateHchiIntoQalpha, check\nfrom diffcalc.hkl.vlieg.geometry import createVliegMatrices\nfrom diffcalc.util import DiffcalcException\nfrom test.diffcalc import scenarios\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\ndef createMockUbcalc(UB):\n    ubcalc = Mock()\n    ubcalc.tau = 0\n    ubcalc.sigma = 0\n    ubcalc.UB = UB\n    ubcalc.n_phi = matrix([[0], [0], [1]])\n    return ubcalc\n\n\ndef createMockHardwareMonitor():\n    hardware = Mock()\n    hardware.get_position.return_value = (0.0, 0.0, 0.0)\n    hardware.get_axes_names.return_value = \'madeup\', \'alpha\', \'gamma\'\n    return hardware\n\n\ndef createMockDiffractometerGeometry():\n    geometry = Mock()\n    geometry.parameter_fixed.return_value = False\n    geometry.supports_mode_group.return_value = True\n    geometry.fixed_parameters = {}\n    geometry.name = \'mock\'\n    geometry.gamma_location = \'arm\'\n    return geometry\n\n\nclass TestVliegCoreMathBits(object):\n\n    def setup_method(self):\n        self.many = [-91, -90, -89, -46, -45, -44, -1,\n                     0, 1, 44, 45, 46, 89, 90, 91]\n        self.many = (self.many +\n                     map(lambda x: x + 180, self.many) +\n                     map(lambda x: x - 180, self.many))\n\n    def test_check(self):\n        check(True, \'Should not throw\')\n        with pytest.raises(Exception):\n            check(False, \'string\')\n        with pytest.raises(DiffcalcException):\n            check(False, DiffcalcException(\'dce\'))\n\n        def acallable(toPrint=None):\n            if toPrint is None:\n                print ""Not throwing exception""\n            else:\n                print toPrint\n\n        check(False, acallable)\n        check(False, acallable, \'this should be printed\')\n\n    # TODO: Removed 2017-03-06, deprecated started code failing -- RobW.\n    def SKIP__findOmegaAndChiToRotateHchiIntoQalpha_WithIntegerValues(self):\n        for omega in self.many:\n            for chi in self.many:\n                print str(omega), "","", str(chi)\n                self.try__findOmegaAndChiToRotateHchiIntoQalpha(omega, chi)\n\n    def SKIP_findOmegaAndChiToRotateHchiIntoQalpha_WithRandomValues(self):\n        for _ in range(10):\n            for omega in self.many:\n                for chi in self.many:\n                    omega = omega + random.uniform(-.001, .001)\n                    chi = chi + random.uniform(-.001, .001)\n                    self.try__findOmegaAndChiToRotateHchiIntoQalpha(omega, chi)\n                    #print str(omega), "","", str(chi)\n\n    def test__findOmegaAndChiToRotateHchiIntoQalpha_WithTrickyOnes(self):\n        tricky_ones = [(-45., -180.), (45., -180.), (135., -180.), (2000, 0.),\n                       (225., 0.), (225., -180.), (-225., 0.), (-225., 0.),\n                       (-225., -180.), (-135., -180.), (89.998894, -44.999218)]\n        for omega, chi in tricky_ones:\n            self.try__findOmegaAndChiToRotateHchiIntoQalpha(omega, chi)\n\n    def try__findOmegaAndChiToRotateHchiIntoQalpha(self, omega, chi):\n        h_chi = matrix([[1], [1], [1]])\n        h_chi = h_chi * (1 / norm(h_chi))\n        [_, _, _, OMEGA, CHI, _] = createVliegMatrices(\n            None, None, None, omega * TORAD, chi * TORAD, None)\n        q_alpha = OMEGA * CHI * h_chi\n        try:\n            omega_calc, chi_calc = _findOmegaAndChiToRotateHchiIntoQalpha(\n                h_chi, q_alpha)\n        except ValueError, e:\n            raise ValueError(str(e) + ""\\n, resulting from test where omega:%f""\n                             "" chi%f"" % (self.omega, self.chi))\n        [_, _, _, OMEGA, CHI, _] = createVliegMatrices(\n            None, None, None, omega_calc, chi_calc, None)\n        self.assertArraysNearlyEqual(OMEGA * CHI * h_chi, q_alpha, .000001,\n                                     ""omega: %f chi:%f"" % (omega, chi))\n\n    def assertArraysNearlyEqual(self, first, second, tolerance,\n                                contextString=\'\'):\n        """"""\n        Fail if the norm of the difference between two arrays is greater than\n        the given tolerance.\n        """"""\n        diff = first - second\n        if norm(diff) >= tolerance:\n            raise self.failureException(\n                \'\\n%r !=\\n %r\\ncontext: %s\' %\n                (first.tolist(), second.tolist(), contextString))\n\n\nclass BaseTestHklCalculator():\n\n    def setSessionAndCalculation(self):\n        raise Exception(""Abstract"")\n\n    def setup_method(self):\n        settings.geometry = createMockDiffractometerGeometry()\n        settings.hardware = createMockHardwareMonitor()\n        self.ac = VliegHklCalculator(None)\n        self.ac.raiseExceptionsIfAnglesDoNotMapBackToHkl = True\n        self.setSessionAndCalculation()\n\n    def testAnglesToHkl(self):\n        mockUbcalc = createMockUbcalc(\n            matrix(self.sess.umatrix) * matrix(self.sess.bmatrix))\n\n        settings.geometry = createMockDiffractometerGeometry()\n        settings.hardware = createMockHardwareMonitor()\n        self.ac = VliegHklCalculator(mockUbcalc)\n        self.ac.raiseExceptionsIfAnglesDoNotMapBackToHkl = True\n\n        # Check the two given reflections\n        (hklactual1, params) = self.ac.anglesToHkl(self.sess.ref1.pos,\n                                                   self.sess.ref1.wavelength)\n        del params\n        (hklactual2, params) = self.ac.anglesToHkl(self.sess.ref2.pos,\n                                                   self.sess.ref2.wavelength)\n        mneq_(matrix([hklactual1]), matrix([self.sess.ref1calchkl]), 3)\n        mneq_(matrix([hklactual2]), matrix([self.sess.ref2calchkl]), 3)\n\n        # ... znd in each calculation through the hkl/posiiont pairs\n        if self.calc:\n            for hkl, pos, param in zip(self.calc.hklList,\n                                       self.calc.posList,\n                                       self.calc.paramList):\n                (hkl_actual, params) = self.ac.anglesToHkl(pos,\n                                                        self.calc.wavelength)\n                note = (""wrong hkl calcualted for scenario.name=%s, ""\n                        ""calculation.tag=%s\\n  expected hkl=(%f,%f,%f)\\n""\n                        ""calculated hkl=(%f,%f,%f)"" %\n                        (self.sess.name, self.calc.tag, hkl[0], hkl[1], hkl[2],\n                         hkl_actual[0], hkl_actual[1], hkl_actual[2]))\n                mneq_(matrix([hkl_actual]), matrix([hkl]), 3, note=note)\n                print ""***anglesToHkl***""\n                print ""*** "", str(hkl), "" ***""\n                print params\n                print param\n\n    def testHklToAngles(self):\n        if self.calc:\n            # Configure the angle calculator for this session scenario\n            UB = matrix(self.sess.umatrix) * matrix(self.sess.bmatrix)\n            mockUbcalc = createMockUbcalc(UB)\n            hw = createMockHardwareMonitor()\n            settings.geometry = createMockDiffractometerGeometry()\n            settings.hardware = hw\n            ac = VliegHklCalculator(mockUbcalc)\n            ac.raiseExceptionsIfAnglesDoNotMapBackToHkl = True\n\n            ## configure the angle calculator for this calculation\n            ac.mode_selector.setModeByName(self.calc.modeToTest)\n\n            # Set fixed parameters\n            if self.calc.modeToTest in (\'4cBeq\', \'4cFixedw\'):\n\n                #ac.setParameter(\'alpha\', self.calc.alpha )\n                ac.parameter_manager.setTrackParameter(\'alpha\', True)\n                hw.get_position.return_value = 888, self.calc.alpha, 999\n                ac.parameter_manager.set_constraint(\'gamma\', self.calc.gamma)\n\n            # Test each hkl/position pair\n            for idx in range(len(self.calc.hklList)):\n                hkl = self.calc.hklList[idx]\n                expectedpos = self.calc.posList[idx]\n                (pos, params) = ac.hklToAngles(hkl[0], hkl[1], hkl[2],\n                                               self.calc.wavelength)\n                note = (""wrong positions calculated for TestScenario=%s, ""\n                        ""AngleTestScenario=%s, hkl=(%f,%f,%f):\\n""\n                        ""  expected pos=%s;\\n""\n                        ""  returned pos=%s "" %\n                        (self.sess.name, self.calc.tag, hkl[0], hkl[1], hkl[2],\n                         str(expectedpos), str(pos)))\n                assert pos.nearlyEquals(expectedpos, 0.01), note\n                print ""*** hklToAngles ***""\n                print ""*** "", str(hkl), "" ***""\n                print params\n                try:\n                    print self.calc.paramList[idx]\n                except IndexError:  # Not always specified\n                    pass\n\n\nclass TestVliegHklCalculatorSess1NoCalc(BaseTestHklCalculator):\n    def setSessionAndCalculation(self):\n        self.sess = scenarios.sessions()[0]\n        self.calc = None\n\n\nclass TestVliegHklCalculatorSess2Calc0(BaseTestHklCalculator):\n    def setSessionAndCalculation(self):\n        self.sess = scenarios.sessions()[1]\n        self.calc = self.sess.calculations[0]\n\n\nclass TestVliegHklCalculatorSess3Calc0(\n    BaseTestHklCalculator):\n    def setSessionAndCalculation(self):\n        self.sess = scenarios.sessions()[2]\n        self.calc = self.sess.calculations[0]\n'"
test/diffcalc/hkl/vlieg/test_constraints.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\nfrom diffcalc.hkl.vlieg.constraints import ModeSelector, VliegParameterManager\nfrom diffcalc.util import DiffcalcException\nfrom test.diffcalc.hkl.vlieg.test_calc import \\\n    createMockHardwareMonitor, createMockDiffractometerGeometry\nimport pytest\n\n\nclass TestModeSelector(object):\n\n    def setup_method(self):\n\n        self.ms = ModeSelector(createMockDiffractometerGeometry(),\n                               parameterManager=None)\n        self.pm = VliegParameterManager(createMockDiffractometerGeometry(),\n                                        None, self.ms)\n        self.ms.setParameterManager(self.pm)\n\n    def testSetModeByIndex(self):\n        self.ms.setModeByIndex(0)\n        assert self.ms.getMode().name == \'4cFixedw\'\n        self.ms.setModeByIndex(1)\n        assert self.ms.getMode().name == \'4cBeq\'\n\n    def testGetMode(self):\n        # tested implicetely by testSetmode\n        pass\n\n    def testShowAvailableModes(self):\n        print self.ms.reportAvailableModes()\n\n\nclass TestParameterManager(object):\n\n    def setup_method(self):\n        self.hw = createMockHardwareMonitor()\n        self.ms = ModeSelector(createMockDiffractometerGeometry())\n        self.pm = VliegParameterManager(createMockDiffractometerGeometry(),\n                                        self.hw, self.ms)\n\n    def testDefaultParameterValues(self):\n        assert self.pm.get_constraint(\'alpha\') == 0\n        assert self.pm.get_constraint(\'gamma\') == 0\n        with pytest.raises(DiffcalcException):\n            self.pm.get_constraint(\'not-a-parameter-name\')\n\n    def testSetParameter(self):\n        self.pm.set_constraint(\'alpha\', 10.1)\n        assert self.pm.get_constraint(\'alpha\') == 10.1\n\n    def testSetTrackParameter_isParameterChecked(self):\n        assert not self.pm.isParameterTracked(\'alpha\')\n        self.pm.set_constraint(\'alpha\', 9)\n\n        self.pm.setTrackParameter(\'alpha\', True)\n        assert self.pm.isParameterTracked(\'alpha\') == True\n        with pytest.raises(DiffcalcException):\n            self.pm.set_constraint(\'alpha\', 10)\n        self.hw.get_position.return_value = 888, 11, 999\n        assert self.pm.get_constraint(\'alpha\') == 11\n\n        print self.pm.reportAllParameters()\n        print ""**""\n        print self.ms.reportCurrentMode()\n        print self.pm.reportParametersUsedInCurrentMode()\n\n        self.pm.setTrackParameter(\'alpha\', False)\n        assert not self.pm.isParameterTracked(\'alpha\')\n        assert self.pm.get_constraint(\'alpha\') == 11\n        self.hw.get_position.return_value = 888, 12, 999\n        assert self.pm.get_constraint(\'alpha\') == 11\n        self.pm.set_constraint(\'alpha\', 13)\n        assert self.pm.get_constraint(\'alpha\') == 13\n'"
test/diffcalc/hkl/vlieg/test_geometry.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport random\nimport unittest\nfrom math import pi\n\ntry:\n    from numpy import matrix\n    from numpy.linalg import norm\nexcept ImportError:\n    from numjy import matrix\n    from numjy.linalg import norm\nfrom test.tools import mneq_\n\n\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry, \\\n    gammaOnArmToBase, gammaOnBaseToArm, SixCircleGeometry, Fivec, Fourc\nfrom diffcalc.hkl.vlieg.geometry import createVliegMatrices\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition\nfrom diffcalc.util import nearlyEqual, radiansEquivilant as radeq\n\n\nrandom.seed()  # uses time\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nclass TestSixCirclePlugin(object):\n\n    def setup_method(self):\n        self.geometry = SixCircleGeometry()\n\n    def testGetName(self):\n        assert self.geometry.name == ""sixc""\n\n    def testPhysicalAnglesToInternalPosition(self):\n        pos = [0, 0, 0, 0, 0, 0]\n        expected = self.geometry.physical_angles_to_internal_position(pos)\n        assert VliegPosition(*pos) == expected\n\n    def testInternalPositionToPhysicalAngles(self):\n        pos = VliegPosition(0, 0, 0, 0, 0, 0)\n        result = self.geometry.internal_position_to_physical_angles(pos)\n        assert norm(matrix([pos.totuple()]) - matrix([result])) < 0.001\n\n    def testGammaOn(self):\n        assert self.geometry.gamma_location == \'base\'\n\n    def testSupportsModeGroup(self):\n        assert self.geometry.supports_mode_group(\'fourc\')\n        assert not self.geometry.supports_mode_group(\'made up mode\')\n\n    def testGetFixedParameters(self):\n        self.geometry.fixed_parameters  # check for exceptions\n\n    def isParamaterUnchangable(self):\n        assert not self.geometry.isParamaterUnchangable(\'made up parameter\')\n\n\nclass TestSixCircleGammaOnArmGeometry(object):\n\n    def setup_method(self):\n        self.geometry = SixCircleGammaOnArmGeometry()\n\n    def testGetName(self):\n        assert self.geometry.name == ""sixc_gamma_on_arm""\n\n    def testPhysicalAnglesToInternalPosition(self):\n        pos = [1, 2, 3, 4, 5, 6]\n        expected = self.geometry.physical_angles_to_internal_position(pos)\n        assert VliegPosition(*pos) == expected\n\n    def testInternalPositionToPhysicalAngles(self):\n        pos = VliegPosition(1, 2, 3, 4, 5, 6)\n        result = self.geometry.internal_position_to_physical_angles(pos)\n        mneq_(matrix([pos.totuple()]), matrix([result]), 4)\n\n    def testSupportsModeGroup(self):\n        assert self.geometry.supports_mode_group(\'fourc\')\n        assert not self.geometry.supports_mode_group(\'made up mode\')\n\n    def testGetFixedParameters(self):\n        self.geometry.fixed_parameters  # check for exceptions\n\n    def isParamaterUnchangable(self):\n        assert not self.geometry.isParamaterUnchangable(\'made up parameter\')\n\n\ny_vector = matrix([[0], [1], [0]])\n\nTOLERANCE = 1e-5\n\n\ndef armAnglesToLabVector(alpha, delta, gamma):\n    [ALPHA, DELTA, GAMMA, _, _, _] = createVliegMatrices(\n        alpha, delta, gamma, None, None, None)\n    return ALPHA * DELTA * GAMMA * y_vector\n\n\ndef baseAnglesToLabVector(delta, gamma):\n    [_, DELTA, GAMMA, _, _, _] = createVliegMatrices(\n        None, delta, gamma, None, None, None)\n    return GAMMA * DELTA * y_vector\n\n\ndef checkGammaOnArmToBase(alpha, deltaA, gammaA):\n        deltaB, gammaB = gammaOnArmToBase(deltaA, gammaA, alpha)\n\n        labA = armAnglesToLabVector(alpha, deltaA, gammaA)\n        labB = baseAnglesToLabVector(deltaB, gammaB)\n        if not nearlyEqual(labA, labB, TOLERANCE):\n            strLabA = (""[%f, %f, %f]"" %\n                       (labA.get(0, 0), labA.get(1, 0), labA.get(2, 0)))\n            strLabB = (""[%f, %f, %f]"" %\n                       (labB.get(0, 0), labB.get(1, 0), labB.get(2, 0)))\n            rep = (""alpha=%f, delta=%f, gamma=%f"" %\n                   (alpha * TODEG, deltaB * TODEG, gammaB * TODEG))\n            raise AssertionError(\'\\nArm-->Base \' + rep + \'\\n\' +\n                ""arm (delta, gamma) = (%f,%f) <==>\\t labA = %s\\n"" %\n                (deltaA * TODEG, gammaA * TODEG, strLabA) +\n                ""base(delta, gamma) = (%f,%f) <==>\\t labB = %s\\n"" %\n                (deltaB * TODEG, gammaB * TODEG, strLabB))\n\n\ndef checkBaseArmBaseReciprocity(alpha, delta_orig, gamma_orig):\n        (deltaB, gammaB) = (delta_orig, gamma_orig)\n        (deltaA, gammaA) = gammaOnBaseToArm(deltaB, gammaB, alpha)\n        (deltaB, gammaB) = gammaOnArmToBase(deltaA, gammaA, alpha)\n        if ((not radeq(deltaB, delta_orig, TOLERANCE)) or\n            (not radeq(gammaB, gamma_orig, TOLERANCE))):\n            s = ""\\nBase-Arm-Base reciprocity\\n""\n            s += \'alpha=%f\\n\' % (alpha * TODEG,)\n            s += (\'   (deltaB, gammaB) = (%f, %f)\\n\' %\n                  (delta_orig * TODEG, gamma_orig * TODEG))\n            s += (\' ->(deltaA, gammaA) = (%f, %f)\\n\' %\n                  (deltaA * TODEG, gammaA * TODEG))\n            s += (\' ->(deltaB, gammaB) = (%f, %f)\\n\' %\n                  (deltaB * TODEG, gammaB * TODEG))\n            raise AssertionError(s)\n\n\ndef checkArmBaseArmReciprocity(alpha, delta_orig, gamma_orig):\n    (deltaA, gammaA) = (delta_orig, gamma_orig)\n    (deltaB, gammaB) = gammaOnArmToBase(deltaA, gammaA, alpha)\n    (deltaA, gammaA) = gammaOnBaseToArm(deltaB, gammaB, alpha)\n    if ((not radeq(deltaA, delta_orig, TOLERANCE)) or\n        (not radeq(gammaA, gamma_orig, TOLERANCE))):\n        s = ""\\nArm-Base-Arm reciprocity\\n""\n        s += ""alpha=%f\\n"" % (alpha * TODEG,)\n        s += (""   (deltaA, gammaA) = (%f, %f)\\n"" %\n              (delta_orig * TODEG, gamma_orig * TODEG))\n        s += ("" ->(deltaB, gammaB) = (%f, %f)\\n"" %\n              (deltaB * TODEG, gammaB * TODEG))\n        s += ("" ->(deltaA, gammaA) = (%f, %f)\\n"" %\n              (deltaA * TODEG, gammaA * TODEG))\n        raise AssertionError(s)\n\n\ndef test_generator_for_cases():\n    for alpha in [-89.9, -45, -1, 0, 1, 45, 89.9]:\n        for gamma in [-89.9, -46, -45, -44, -1, 0, 1, 44, 45, 46, 89.9]:\n            for delta in [-179.9, -135, -91, -89.9, -89, -46, -45, -44, -1, 0,\n                          1, 44, 45, 46, 89, 89.9, 91, 135, 179.9]:\n                yield (checkGammaOnArmToBase, alpha * TORAD, delta * TORAD,\n                       gamma * TORAD)\n                yield (checkArmBaseArmReciprocity, alpha * TORAD,\n                       delta * TORAD, gamma * TORAD)\n\n\nclass TestFiveCirclePlugin(object):\n\n    def setup_method(self):\n        self.geometry = Fivec()\n\n    def testGetName(self):\n        assert self.geometry.name == ""fivec""\n\n    def testPhysicalAnglesToInternalPosition(self):\n        expected = self.geometry.physical_angles_to_internal_position(\n            (1, 2, 4, 5, 6))\n        assert VliegPosition(1, 2, 0, 4, 5, 6) == expected\n\n    def testInternalPositionToPhysicalAngles(self):\n        result = self.geometry.internal_position_to_physical_angles(\n            VliegPosition(1, 2, 0, 4, 5, 6))\n        assert (norm(matrix([[1, 2, 4, 5, 6]]) - (matrix([list(result)])))\n                < 0.001)\n\n    def testSupportsModeGroup(self):\n        assert self.geometry.supports_mode_group(\'fourc\')\n        assert not self.geometry.supports_mode_group(\'fivecFixedAlpha\')\n        assert self.geometry.supports_mode_group(\'fivecFixedGamma\')\n\n    def testGetFixedParameters(self):\n        self.geometry.fixed_parameters  # check for exceptions\n\n    def testisParamaterFixed(self):\n        assert not self.geometry.parameter_fixed(\'made up parameter\')\n        assert self.geometry.parameter_fixed(\'gamma\')\n\n\nclass TestFourCirclePlugin(object):\n\n    def setup_method(self):\n        self.geometry = Fourc()\n\n    def testGetName(self):\n        assert self.geometry.name == ""fourc""\n\n    def testPhysicalAnglesToInternalPosition(self):\n        expected = self.geometry.physical_angles_to_internal_position((2, 4, 5, 6))\n        assert VliegPosition(0, 2, 0, 4, 5, 6) == expected\n\n    def testInternalPositionToPhysicalAngles(self):\n        result = self.geometry.internal_position_to_physical_angles(\n            VliegPosition(0, 2, 0, 4, 5, 6))\n        assert (norm(matrix([[2, 4, 5, 6]]) - matrix([list(result)]))\n                     < 0.001)\n\n    def testSupportsModeGroup(self):\n        assert self.geometry.supports_mode_group(\'fourc\')\n        assert not self.geometry.supports_mode_group(\'fivecFixedAlpha\')\n        assert not self.geometry.supports_mode_group(\'fivecFixedGamma\')\n\n    def testGetFixedParameters(self):\n        self.geometry.fixed_parameters  # check for exceptions\n\n    def testisParamaterFixed(self):\n        assert not self.geometry.parameter_fixed(\'made up parameter\')\n        assert self.geometry.parameter_fixed(\'gamma\')\n        assert self.geometry.parameter_fixed(\'alpha\')\n'"
test/diffcalc/hkl/vlieg/test_hkl.py,0,"b""###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport unittest\n\nfrom mock import Mock\n\nimport diffcalc.util  # @UnusedImport to overide raw_input\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.util import MockRawInput\nfrom diffcalc.hkl.vlieg.calc import VliegHklCalculator\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nimport pytest\n\ntry:\n    from gdascripts.pd.dummy_pds import DummyPD  # @UnusedImport\nexcept ImportError:\n    from diffcalc.gdasupport.minigda.scannable import DummyPD\n\n\ndef prepareRawInput(listOfStrings):\n    diffcalc.util.raw_input = MockRawInput(listOfStrings)\n\nprepareRawInput([])\n\n\nclass TestHklCommands(object):\n\n    def setup_method(self):\n        from diffcalc import settings\n        settings.geometry = SixCircleGammaOnArmGeometry()\n        dummy = 'alpha', 'delta', 'gamma', 'omega', 'chi', 'phi'\n        settings.hardware = DummyHardwareAdapter(dummy)\n        self.mock_ubcalc = Mock(spec=UBCalculation)\n        self.hklcalc = VliegHklCalculator(self.mock_ubcalc, True)\n        settings.ubcalc_persister = UbCalculationNonPersister()\n        \n        from diffcalc.hkl.vlieg import hkl\n        reload(hkl)\n        hkl.hklcalc = self.hklcalc\n        self.hkl = hkl\n        prepareRawInput([])\n\n    def testHklmode(self):\n        with pytest.raises(TypeError):\n            self.hkl.hklmode(1, 2)\n        with pytest.raises(ValueError):\n            self.hkl.hklmode('unwanted_string')\n        print self.hkl.hklmode()\n        print self.hkl.hklmode(1)\n\n    def testSetWithString(self):\n        self.hkl.setpar()\n        self.hkl.setpar('alpha')\n        self.hkl.setpar('alpha', 1)\n        self.hkl.setpar('alpha', 1.1)\n        pm = self.hkl.hklcalc.parameter_manager\n        assert pm.get_constraint('alpha') == 1.1\n\n    def testSetWithScannable(self):\n        alpha = DummyPD('alpha')\n        self.hkl.setpar(alpha, 1.1)\n        pm = self.hkl.hklcalc.parameter_manager\n        assert pm.get_constraint('alpha') == 1.1\n"""
test/diffcalc/hkl/vlieg/test_transform.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom nose.tools import eq_\nimport unittest\n\nfrom mock import Mock\n\nfrom diffcalc.hkl.vlieg.geometry import SixCircleGammaOnArmGeometry\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hkl.vlieg.geometry import VliegPosition as P, \\\n   VliegPosition as Pos\nfrom diffcalc.hkl.vlieg.transform import TransformA, TransformB, TransformC, \\\n    transformsFromSector, TransformCommands, \\\n    VliegTransformSelector, VliegPositionTransformer\nimport diffcalc.util  # @UnusedImport\nimport pytest\n\n\nclass TestVliegPositionTransformer(object):\n\n    def setup_method(self):\n        names = \'a\', \'d\', \'g\', \'o\', \'c\', \'phi\'\n        self.hardware = DummyHardwareAdapter(names)\n        self.geometry = SixCircleGammaOnArmGeometry()\n\n        self.transform_selector = VliegTransformSelector()\n        self.transformer = VliegPositionTransformer(\n            self.geometry, self.hardware, self.transform_selector)\n        self.transform_commands = TransformCommands(self.transform_selector)\n\n        diffcalc.util.RAISE_EXCEPTIONS_FOR_ALL_ERRORS = True\n\n    def map(self, pos):  # @ReservedAssignment\n        pos = self.transformer.transform(pos)\n        angle_tuple = self.geometry.internal_position_to_physical_angles(pos)\n        angle_tuple = self.hardware.cut_angles(angle_tuple)\n        return angle_tuple\n\n    def testMapDefaultSector(self):\n\n        eq_(self.map(Pos(1, 2, 3, 4, 5, 6)),\n            (1, 2, 3, 4, 5, 6))\n\n        eq_(self.map(Pos(-180, -179, 0, 179, 180, 359)),\n            (-180, -179, 0, 179, 180, 359))\n\n        eq_(self.map(Pos(0, 0, 0, 0, 0, 0)),\n            (0, 0, 0, 0, 0, 0))\n\n        eq_(self.map(Pos(-270, 270, 0, 0, 0, -90)),\n            (90, -90, 0, 0, 0, 270))\n\n    def testMapSector1(self):\n        self.transform_commands._sectorSelector.setSector(1)\n\n        eq_(self.map(Pos(1, 2, 3, 4, 5, 6)),\n            (1, 2, 3, 4 - 180, -5, (6 - 180) + 360))\n\n        eq_(self.map(Pos(-180, -179, 0, 179, 180, 359)),\n            (-180, -179, 0, 179 - 180, -180, 359 - 180))\n\n        eq_(self.map(Pos(0, 0, 0, 0, 0, 0)),\n            (0, 0, 0, 0 - 180, 0, (0 - 180) + 360))\n\n        eq_(self.map(Pos(-270, 270, 0, 0, 0, -90)),\n            (90, -90, 0, 0 - 180, 0, 270 - 180))\n\n    def testMapAutoSector(self):\n        self.transform_commands._sectorSelector.addAutoTransorm(1)\n        self.hardware.set_lower_limit(\'c\', 0)\n\n        eq_(self.map(Pos(1, 2, 3, 4, -5, 6)),\n            (1, 2, 3, 4 - 180, 5, (6 - 180) + 360))\n\n        eq_(self.map(Pos(-180, -179, 0, 179, -180, 359)),\n            (-180, -179, 0, 179 - 180, 180, 359 - 180))\n\n        eq_(self.map(Pos(0, 0, 0, 0, -5, 0)),\n            (0, 0, 0, 0 - 180, 5, (0 - 180) + 360))\n\n        eq_(self.map(Pos(-270, 270, 0, 0, -5, -90)),\n            (90, -90, 0, 0 - 180, 5, 270 - 180))\n\n    def testTransform(self):\n        # mapper\n        self.transform_commands.transform()  # should print its state\n        with pytest.raises(TypeError):\n            self.transform_commands.transform(1)\n        with pytest.raises(TypeError):\n            self.transform_commands.transform(\'a\', 1)\n\n    def testTransformsOnOff(self):\n        # transforma [on/off/auto/manual]\n        ss = self.transform_commands._sectorSelector\n        self.transform_commands.transforma()  # should print mapper state\n        eq_(ss.transforms, [], ""test assumes transforms are off to start"")\n        self.transform_commands.transforma(\'on\')\n        eq_(ss.transforms, [\'a\'])\n        self.transform_commands.transformb(\'on\')\n        eq_(ss.transforms, [\'a\', \'b\'])\n        self.transform_commands.transformc(\'off\')\n        eq_(ss.transforms, [\'a\', \'b\'])\n        self.transform_commands.transformb(\'off\')\n        eq_(ss.transforms, [\'a\'])\n\n    def testTransformsAuto(self):\n        ss = self.transform_commands._sectorSelector\n        eq_(ss.autotransforms, [], ""test assumes transforms are off to start"")\n        self.transform_commands.transforma(\'auto\')\n        eq_(ss.autotransforms, [\'a\'])\n        self.transform_commands.transformb(\'auto\')\n        eq_(ss.autotransforms, [\'a\', \'b\'])\n        self.transform_commands.transformc(\'manual\')\n        eq_(ss.autotransforms, [\'a\', \'b\'])\n        self.transform_commands.transformb(\'manual\')\n        eq_(ss.autotransforms, [\'a\'])\n\n    def testTransformsBadInput(self):\n        transforma = self.transform_commands.transforma\n        with pytest.raises(TypeError):\n            transforma(1)\n        with pytest.raises(TypeError):\n            transforma(\'not_valid\')\n        with pytest.raises(TypeError):\n            transforma(\'auto\', 1)\n\n    def testSector(self):\n        #sector [0-7]\n        ss = self.transform_commands._sectorSelector\n        self.transform_commands.sector()  # should print mapper state\n        eq_(ss.sector, 0, ""test assumes sector is 0 to start"")\n        self.transform_commands.sector(1)\n        eq_(ss.sector, 1)\n        with pytest.raises(TypeError):\n            self.transform_commands.sector(1, 2)\n        with pytest.raises(TypeError):\n            self.transform_commands.sector(\'a\')\n\n    def testAutosectors(self):\n        #autosector [0-7]\n        ss = self.transform_selector\n        self.transform_commands.autosector()  # should print mapper state\n        eq_(ss.autosectors, [], ""test assumes no auto sectors to start"")\n        self.transform_commands.autosector(1)\n        eq_(ss.autosectors, [1])\n        self.transform_commands.autosector(1, 2)\n        eq_(ss.autosectors, [1, 2])\n        self.transform_commands.autosector(1)\n        eq_(ss.autosectors, [1])\n        self.transform_commands.autosector(3)\n        eq_(ss.autosectors, [3])\n        with pytest.raises(TypeError):\n            self.transform_commands.autosector(1, \'a\')\n        with pytest.raises(TypeError):\n            self.transform_commands.autosector(\'a\')\n\n\nclass MockLimitChecker(object):\n\n    def __init__(self):\n        self.okay = True\n\n    def isPoswithiLimits(self, pos):\n        return self.okay\n\n    def isDeltaNegative(self, pos):\n        return pos.delta <= 0\n\n\nclass TestVliegTransformSelector(object):\n\n    def setup_method(self):\n        self.limitChecker = MockLimitChecker()\n        self.ss = VliegTransformSelector()\n        self.ss.limitCheckerFunction = self.limitChecker.isPoswithiLimits\n\n    def test__init__(self):\n        assert (self.ss.sector, 0)\n\n    def testCutPosition(self):\n        d = .1\n        tocut = P(-180., 180., 180. - d, 180. + d, -180. + d, -180. - d)\n        expected = P(-180., 180., 180. - d, -180. + d, -180. + d, 180. - d)\n        assert (self.ss.cutPosition(tocut) == expected)\n\n    def testTransformNWithoutCut(self):\n        pos = P(1, 2, 3, 4, 5, 6)\n        assert (self.ss.transformNWithoutCut(0, pos) == pos)\n\n    def testTransformPosition(self):\n        pos = P(0 - 360, .1 + 360, .2 - 360, .3 + 360, .4, 5)\n        res = self.ss.transformPosition(pos)\n        des = P(0, .1, .2, .3, .4, 5)\n        assert (res == des, \'%s!=\\n%s\' % (res, des))\n\n    def testSetSector(self):\n        self.ss.setSector(4)\n        assert (self.ss.sector, 4)\n        assert (self.ss.transforms, [\'b\', \'c\'])\n\n    def testSetTransforms(self):\n        self.ss.setTransforms((\'c\', \'b\'))\n        assert (self.ss.sector, 4)\n        assert (self.ss.transforms, [\'b\', \'c\'])\n\n    def testAddAutoTransormWithBadInput(self):\n        assert (self.ss.autosectors, [])\n        assert (self.ss.autotransforms, [])\n        with pytest.raises(ValueError):\n            self.ss.addAutoTransorm(\'not transform\')\n        with pytest.raises(ValueError):\n            self.ss.addAutoTransorm(9999)\n        with pytest.raises(ValueError):\n            self.ss.addAutoTransorm([])\n\n    def testAddAutoTransormWithTransforms(self):\n        self.ss.autosectors = [1, 2, 3, 4, 5]\n        self.ss.addAutoTransorm(\'a\')\n        print ""Should now print a warning...""\n        self.ss.addAutoTransorm(\'a\')  # twice\n        self.ss.addAutoTransorm(\'b\')\n        assert (self.ss.autosectors, [])\n        assert (self.ss.autotransforms, [\'a\', \'b\'])\n\n    def testAddAutoTransormWithSectors(self):\n        self.ss.autotransforms = [\'a\', \'c\']\n        self.ss.addAutoTransorm(2)\n        print ""Should now print a warning...""\n        self.ss.addAutoTransorm(2)  # twice\n        self.ss.addAutoTransorm(3)\n        assert (self.ss.autosectors, [2, 3])\n        assert (self.ss.autotransforms, [])\n\n    def testis_position_within_limits(self):\n        assert (self.ss.is_position_within_limits(None), True)\n        self.limitChecker.okay = False\n        assert (self.ss.is_position_within_limits(None), False)\n\n    def test__repr__(self):\n        self.ss.setSector(0)\n        print ""************************""\n        print self.ss\n        print ""************************""\n        self.ss.setTransforms(\'a\')\n        print self.ss\n        print ""************************""\n        self.ss.setTransforms((\'a\', \'b\', \'c\'))\n        print self.ss\n        print ""************************""\n\n\nclass TestSectorSelectorAutoCode(object):\n\n    def setup_method(self):\n        self.limitChecker = MockLimitChecker()\n        self.ss = VliegTransformSelector()\n        self.ss.limitCheckerFunction = self.limitChecker.isDeltaNegative\n        self.pos = P(0, .1, .2, .3, .4, 5)\n        self.pos_in2 = self.ss.cutPosition(\n            self.ss.transformNWithoutCut(2, self.pos))\n        self.pos_in3 = self.ss.cutPosition(\n            self.ss.transformNWithoutCut(3, self.pos))\n\n    def testAddautoTransformWithSectors(self):\n        self.ss.addAutoTransorm(2)\n        self.ss.addAutoTransorm(3)\n        assert (self.ss.autosectors, [2, 3])\n        assert (self.ss.autotransforms, [])\n        self.ss.removeAutoTransform(3)\n        assert (self.ss.autosectors, [2])\n\n    def testAddautoTransformTransforms(self):\n        self.ss.addAutoTransorm(\'a\')\n        self.ss.addAutoTransorm(\'b\')\n        assert (self.ss.autosectors, [])\n        assert (self.ss.autotransforms, [\'a\', \'b\'])\n\n    def testRemoveAutoTransformWithSectors(self):\n        self.ss.addAutoTransorm(2)\n        self.ss.addAutoTransorm(3)\n        self.ss.removeAutoTransform(3)\n        assert (self.ss.autosectors, [2])\n        self.ss.removeAutoTransform(2)\n        assert (self.ss.autosectors, [])\n\n    def testRemoveAutoTransformTransforms(self):\n        self.ss.addAutoTransorm(\'a\')\n        self.ss.addAutoTransorm(\'b\')\n        self.ss.removeAutoTransform(\'b\')\n        assert (self.ss.autotransforms, [\'a\'])\n        self.ss.removeAutoTransform(\'a\')\n        assert (self.ss.autotransforms, [])\n\n    def testTransformPosition(self):\n        # Check that with no transforms set to autoapply, the limit\n        # checker function is ignored\n        ss = VliegTransformSelector()\n        ss.limitCheckerFunction = self.limitChecker.isPoswithiLimits\n        self.limitChecker.okay = False\n        ss.transformPosition(P(0, .1, .2, .3, .4, 5))\n\n    def testMockLimitChecker(self):\n        assert not self.limitChecker.isDeltaNegative(P(0, .1, .2, .3, .4, 5))\n        assert self.limitChecker.isDeltaNegative(P(0, -.1, .2, .3, .4, 5))\n\n    def testAutoTransformPositionWithSectors(self):\n        self.ss.addAutoTransorm(2)\n        print ""Should print \'INFO: Autosector changed sector from 0 to 2\':""\n        result = self.ss.autoTransformPositionBySector(self.pos)\n        assert (result == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def testAutoTransformPositionWithSectorChoice(self):\n        self.ss.addAutoTransorm(2)\n        self.ss.addAutoTransorm(3)\n        print ""Should print \'WARNING: Autosector found multiple sectors...\':""\n        print ""Should print \'INFO: Autosector changed sector from 0 to 2\':""\n        result = self.ss.autoTransformPositionBySector(self.pos)\n        assert (result == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def testAutoTransformPositionWithSectorsFails(self):\n        self.ss.addAutoTransorm(0)\n        self.ss.addAutoTransorm(1)\n        self.ss.addAutoTransorm(4)\n        self.ss.addAutoTransorm(5)\n        print ""Should print \'INFO: Autosector changed sector from 0 to 2\':""\n        with pytest.raises(Exception):\n            self.ss.autoTransformPositionBySector(self.pos)\n        #self.ss.autoTransformPositionBySector(self.pos)\n        assert (self.ss.sector, 0)  # unchanged\n\n    def testCreateListOfPossibleTransforms(self):\n        self.ss.addAutoTransorm(\'a\')\n        assert (self.ss.createListOfPossibleTransforms(),\n                          [(), [\'a\', ]])\n        self.ss.addAutoTransorm(\'b\')\n        assert (self.ss.createListOfPossibleTransforms(),\n                          [(), [\'b\', ], [\'a\', ], [\'a\', \'b\']])\n        self.ss.transforms = [\'a\', \'c\']\n\n    def testAutoTransformPositionWithTransforms(self):\n        self.ss.addAutoTransorm(\'a\')\n        print ""Should print \'INFO: \':""\n        result = self.ss.autoTransformPositionByTransforms(self.pos)\n        assert (result == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def testAutoTransformPositionWithTansformsChoice(self):\n        self.ss.addAutoTransorm(\'a\')\n        self.ss.addAutoTransorm(\'c\')\n        print ""Should print \'WARNING:\':""\n        print ""Should print \'INFO: \':""\n        result = self.ss.autoTransformPositionByTransforms(self.pos)\n        assert (result == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def testTransformPositionWithAutoTransforms(self):\n        self.ss.addAutoTransorm(\'a\')\n        assert (self.ss.transformPosition(self.pos) == self.pos_in2)\n        assert (self.ss.sector, 2)\n        print ""Should not print \'INFO...\'""\n        assert (self.ss.transformPosition(self.pos) == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def testTransformPositionWithAutoTransforms2(self):\n        self.ss.addAutoTransorm(2)\n        assert (self.ss.transformPosition(self.pos) == self.pos_in2)\n        assert (self.ss.sector, 2)\n        print ""Should not print \'INFO...\'""\n        assert (self.ss.transformPosition(self.pos) == self.pos_in2)\n        assert (self.ss.sector, 2)\n\n    def test__repr__(self):\n        self.ss.setSector(0)\n        print ""************************""\n        print self.ss\n        print ""************************""\n        self.ss.setTransforms(\'a\')\n        print self.ss\n        print ""************************""\n        self.ss.setTransforms((\'a\', \'b\', \'c\'))\n        print self.ss\n        print ""************************""\n\n        self.ss.addAutoTransorm(1)\n        self.ss.addAutoTransorm(2)\n        self.ss.addAutoTransorm(3)\n        print self.ss\n        print ""************************""\n        self.ss.addAutoTransorm(\'a\')\n        self.ss.addAutoTransorm(\'c\')\n        print self.ss\n        print ""************************""\n\n\nclass TestTransforms(object):\n\n    def setup_method(self):\n        self.limitCheckerFunction = Mock()\n        self.ss = VliegTransformSelector()\n        self.ss.limitCheckerFunction = self.limitCheckerFunction\n\n    def applyTransforms(self, transforms, pos):\n        result = pos.clone()\n        for transform in transforms:\n            if transform == \'a\':\n                result = TransformA().transform(result)\n            if transform == \'b\':\n                result = TransformB().transform(result)\n            if transform == \'c\':\n                result = TransformC().transform(result)\n        return self.ss.cutPosition(result)\n\n    def _testTransformN(self, n):\n        transforms = transformsFromSector[n]\n        pos = P(1, 2, 3, 4, 5, 6)\n        self.ss.setSector(n)\n        fromss = self.ss.transformPosition(pos)\n        fromhere = self.applyTransforms(transforms, pos)\n        assert (fromss == fromhere,\n                     (""sector: %i\\ntransforms:%s\\n%s !=\\n%s"" %\n                      (n, transforms, fromss, fromhere)))\n\n    def testTransform0(self):\n        self._testTransformN(0)\n\n    def testTransform1(self):\n        self._testTransformN(1)\n\n    def testTransform2(self):\n        self._testTransformN(2)\n\n    def testTransform3(self):\n        self._testTransformN(3)\n\n    def testTransform4(self):\n        self._testTransformN(5)\n\n    def testTransform5(self):\n        self._testTransformN(5)\n\n    def testTransform6(self):\n        self._testTransformN(6)\n\n    def testTransform7(self):\n        self._testTransformN(7)\n'"
test/diffcalc/hkl/willmot/__init__.py,0,b''
test/diffcalc/hkl/willmot/test_calcwill.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n# TODO: class largely copied from test_calc\n\nfrom math import pi\nfrom mock import Mock\nfrom nose.tools import raises\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hkl.willmott.calc import \\\n    WillmottHorizontalUbCalcStrategy, WillmottHorizontalCalculator, \\\n    WillmottHorizontalPosition as Pos, WillmottHorizontalGeometry\nfrom test.tools import assert_array_almost_equal, \\\n    assert_second_dict_almost_in_first, matrixeq_\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom diffcalc.util import DiffcalcException\nfrom test.diffcalc.test_hardware import SimpleHardwareAdapter\nfrom test.diffcalc.hkl.vlieg.test_calc import createMockUbcalc, \\\n    createMockDiffractometerGeometry\nimport diffcalc.hkl.willmott.calc  # @UnusedImport\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\n\nclass _BaseTest():\n\n    def setup_method(self):\n        self.mock_ubcalc = createMockUbcalc(None)\n        self.mock_geometry = createMockDiffractometerGeometry()\n        self.mock_hardware = SimpleHardwareAdapter(\n                             [\'delta\', \'gamma\', \'omegah\', \'phi\'])\n        self.constraints = Mock()\n        \n        settings.geometry = self.mock_geometry\n        settings.hardware = self.mock_hardware\n        self.calc = WillmottHorizontalCalculator(self.mock_ubcalc, self.constraints)\n\n        self.places = 12\n\n    def _check_hkl_to_angles(self, testname, zrot, yrot, hkl, pos_expected,\n                             wavelength, virtual_expected={}):\n        print (\'_check_hkl_to_angles(%s, %.1f, %.1f, %s, %s, %.2f, %s)\'\n               % (testname, zrot, yrot, hkl, pos_expected, wavelength,\n                  virtual_expected))\n        self.zrot, self.yrot = zrot, yrot\n        self._configure_ub()\n        pos, virtual = self.calc.hklToAngles(hkl[0], hkl[1], hkl[2],\n                                             wavelength)\n        assert_array_almost_equal(pos.totuple(), pos_expected.totuple(),\n                                  self.places)\n        assert_second_dict_almost_in_first(virtual, virtual_expected)\n\n    def _check_angles_to_hkl(self, testname, zrot, yrot, hkl_expected, pos,\n                             wavelength, virtual_expected={}):\n        print (\'_check_angles_to_hkl(%s, %.1f, %.1f, %s, %s, %.2f, %s)\' %\n               (testname, zrot, yrot, hkl_expected, pos, wavelength,\n                virtual_expected))\n        self.zrot, self.yrot = zrot, yrot\n        self._configure_ub()\n        hkl, virtual = self.calc.anglesToHkl(pos, wavelength)\n        assert_array_almost_equal(hkl, hkl_expected, self.places)\n        assert_second_dict_almost_in_first(virtual, virtual_expected)\n\n    @raises(DiffcalcException)\n    def _check_hkl_to_angles_fails(self, *args):\n        self._check_hkl_to_angles(*args)\n\n\n# Primary and secondary reflections found with the help of DDIF on Diamond\'s\n# i07 on Jan 27 2010\n\nSi_5_5_12_WAVELENGTH = 0.6358\nSi_5_5_12_HKL0 = 2, 19, 32\nSi_5_5_12_REF0 = Pos(delta=21.975, gamma=4.419, omegah=2, phi=326.2)\nSi_5_5_12_HKL1 = 0, 7, 22\nSi_5_5_12_REF1 = Pos(delta=11.292, gamma=2.844, omegah=2, phi=124.1)\n\n# This is U matrix displayed by DDIF\nU_FROM_DDIF = matrix([[0.233140, 0.510833, 0.827463],\n                      [-0.65596, -0.545557, 0.521617],\n                      [0.717888, -0.664392, 0.207894]])\n\n# This is the version that Diffcalc comes up with ( see following test)\nSi_5_5_12_U_DIFFCALC = matrix([[-0.7178876, 0.6643924, -0.2078944],\n                     [-0.6559596, -0.5455572, 0.5216170],\n                     [0.2331402, 0.5108327, 0.8274634]])\n\n\nclass TestUBCalculationWithWillmotStrategy_Si_5_5_12():\n\n    def setup_method(self):\n        hardware = Mock()\n        hardware.get_axes_names.return_value = (\'d\', \'g\', \'oh\', \'p\')\n        settings.geometry = WillmottHorizontalGeometry()\n        settings.hardware = hardware\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    WillmottHorizontalUbCalcStrategy())\n\n    def testAgainstResultsFromJan_27_2010(self):\n        self.ubcalc.start_new(\'test\')\n        self.ubcalc.set_lattice(\'Si_5_5_12\', 7.68, 53.48, 75.63, 90, 90, 90)\n        self.ubcalc.add_reflection(\n            Si_5_5_12_HKL0[0], Si_5_5_12_HKL0[1], Si_5_5_12_HKL0[2],\n            Si_5_5_12_REF0, 12.39842 / Si_5_5_12_WAVELENGTH, \'ref0\', None)\n        self.ubcalc.add_reflection(\n            Si_5_5_12_HKL1[0], Si_5_5_12_HKL1[1], Si_5_5_12_HKL1[2],\n            Si_5_5_12_REF1, 12.39842 / Si_5_5_12_WAVELENGTH, \'ref1\', None)\n        self.ubcalc.calculate_UB()\n        print ""U: "", self.ubcalc.U\n        print ""UB: "", self.ubcalc.UB\n        matrixeq_(self.ubcalc.U, Si_5_5_12_U_DIFFCALC)\n\n\nclass TestSurfaceNormalVertical_Si_5_5_12_PosGamma(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints.reference = {\'betain\': 2}\n        self.wavelength = 0.6358\n        B = CrystalUnderTest(\'xtal\', 7.68, 53.48,\n                             75.63, 90, 90, 90).B\n        self.UB = Si_5_5_12_U_DIFFCALC * B\n        diffcalc.hkl.willmott.calc.CHOOSE_POSITIVE_GAMMA = True\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\'\', 999, 999, hkl, pos, self.wavelength,\n                                  virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\'\', 999, 999, hkl, pos,\n                                            self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n\n    def testHkl_2_19_32_found_orientation_setting(self):\n        \'\'\'Check that the or0 reflection maps back to the assumed hkl\'\'\'\n        self.places = 2\n        self._check_angles_to_hkl(\'\', 999, 999, Si_5_5_12_HKL0,\n                        Si_5_5_12_REF0,\n                        self.wavelength, {\'betain\': 2})\n\n    def testHkl_0_7_22_found_orientation_setting(self):\n        \'\'\'Check that the or1 reflection maps back to the assumed hkl\'\'\'\n        self.places = 0\n        self._check_angles_to_hkl(\'\', 999, 999, Si_5_5_12_HKL1,\n                        Si_5_5_12_REF1,\n                        self.wavelength, {\'betain\': 2})\n\n    def testHkl_2_19_32_calculated_from_DDIF(self):\n        self.places = 3\n        self._check((2, 19, 32),\n                    Pos(delta=21.974, gamma=4.419, omegah=2, phi=-33.803),\n                    {\'betain\': 2})\n\n    def testHkl_0_7_22_calculated_from_DDIF(self):\n        self.places = 3\n        self._check((0, 7, 22),\n                    Pos(delta=11.242, gamma=3.038, omegah=2, phi=123.064),\n                    {\'betain\': 2})\n\n    def testHkl_2_m5_12_calculated_from_DDIF(self):\n        self.places = 3\n        self._check((2, -5, 12),\n                    Pos(delta=5.224, gamma=10.415, omegah=2, phi=-1.972),\n                    {\'betain\': 2})\n\n# conlcusion:\n# given or1 from testHkl_2_19_32_found_orientation_setting and,\n# or1 from testHkl_0_7_22_found_orientation_setting\n# we can calculate a U matrix which agrees with that from diff except for\n# signs and row order\n# We can also calculate values for 2_19_32 and 0_7_22 that match those\n# calculated by DDIF to the number of recorded decimal places (3)\n\n\nclass SkipTestSurfaceNormalVertical_Si_5_5_12_NegGamma(\n    TestSurfaceNormalVertical_Si_5_5_12_PosGamma):\n    """"""When choosing -ve gamma delta ends up being -ve too""""""\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints.reference = {\'betain\': 2 * TORAD}\n        self.wavelength = 0.6358\n        B = CrystalUnderTest(\'xtal\', 7.68, 53.48,\n                             75.63, 90, 90, 90).B\n        self.UB = Si_5_5_12_U_DIFFCALC * B\n        diffcalc.hkl.willmott.calc.CHOOSE_POSITIVE_GAMMA = False\n\n\n##################################################################\n\n# Primary and secondary reflections found with the help of DDIF on Diamond\'s\n# i07 on Jan 28/29 2010\n\n\nPt531_HKL0 = -1.000, 1.000, 6.0000\nPt531_REF0 = Pos(delta=9.465, gamma=16.301, omegah=2,\n                                  phi=307.94 - 360)\nPt531_REF0_DIFFCALC = Pos(\n    9.397102509657, 16.181230279320, 2.000000000000, -52.139290474913)\n\nPt531_HKL1 = -2.000, -1.000, 7.0000\nPt531_REF1 = Pos(delta=11.094, gamma=11.945, omegah=2, phi=238.991 - 360)\nPt531_REF1_DIFFCALC = Pos(\n    11.012695836306, 11.863612760237, 2.000000000000, -121.215597507237)\n\nPt531_HKL2 = 1, 1, 9\nPt531_REF2 = Pos(delta=14.272, gamma=7.806, omegah=2,\n                                  phi=22.9)\nPt531_REF2_DIFFCALC = Pos(\n    14.188161709766, 7.758593908726, 2.000000000000, 23.020313153847)\nPt531_WAVELENGTH = 0.6358\n\n# This is U matrix displayed by DDIF\nU_FROM_DDIF = matrix([[-0.00312594, -0.00063417, 0.99999491],\n                      [0.99999229, -0.00237817, 0.00312443],\n                      [0.00237618, 0.99999697, 0.00064159]])\n\n# This is the version that Diffcalc comes up with ( see following test)\nPt531_U_DIFFCALC = matrix([[-0.0023763, -0.9999970, -0.0006416],\n                           [0.9999923, -0.0023783, 0.0031244],\n                           [-0.0031259, -0.0006342, 0.9999949]])\n\n\nclass TestUBCalculationWithWillmotStrategy_Pt531():\n\n    def setup_method(self):\n        hardware = Mock()\n        hardware.get_axes_names.return_value = (\'d\', \'g\', \'oh\', \'p\')\n        settings.geometry = WillmottHorizontalGeometry()\n        settings.hardware = hardware\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    WillmottHorizontalUbCalcStrategy())\n\n    def testAgainstResultsFromJan_27_2010(self):\n        self.ubcalc.start_new(\'test\')\n        self.ubcalc.set_lattice(\'Pt531\', 6.204, 4.806, 23.215, 90, 90, 49.8)\n        self.ubcalc.add_reflection(\n            Pt531_HKL0[0], Pt531_HKL0[1], Pt531_HKL0[2], Pt531_REF0,\n            12.39842 / Pt531_WAVELENGTH, \'ref0\', None)\n        self.ubcalc.add_reflection(\n            Pt531_HKL1[0], Pt531_HKL1[1], Pt531_HKL1[2], Pt531_REF1,\n            12.39842 / Pt531_WAVELENGTH, \'ref1\', None)\n        self.ubcalc.calculate_UB()\n        print ""U: "", self.ubcalc.U\n        print ""UB: "", self.ubcalc.UB\n        matrixeq_(self.ubcalc.U, Pt531_U_DIFFCALC)\n\n\nclass TestSurfaceNormalVertical_Pt531_PosGamma(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints.reference = {\'betain\': 2}\n        self.wavelength = Pt531_WAVELENGTH\n\n        cut = CrystalUnderTest(\'Pt531\', 6.204, 4.806, 23.215, 90, 90, 49.8)\n        B = cut.B\n        self.UB = Pt531_U_DIFFCALC * B\n        diffcalc.hkl.willmott.calc.CHOOSE_POSITIVE_GAMMA = True\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n#        self._check_angles_to_hkl(\'\', 999, 999, hkl, pos, self.wavelength,\n#                                  virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\'\', 999, 999, hkl, pos,\n                                            self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n\n    def testHkl_0_found_orientation_setting(self):\n        \'\'\'Check that the or0 reflection maps back to the assumed hkl\'\'\'\n        self.places = 1\n        self._check_angles_to_hkl(\'\', 999, 999, Pt531_HKL0,\n                        Pt531_REF0,\n                        self.wavelength, {\'betain\': 2})\n\n    def testHkl_1_found_orientation_setting(self):\n        \'\'\'Check that the or1 reflection maps back to the assumed hkl\'\'\'\n        self.places = 0\n        self._check_angles_to_hkl(\'\', 999, 999, Pt531_HKL1,\n                        Pt531_REF1,\n                        self.wavelength, {\'betain\': 2})\n\n    def testHkl_0_predicted_versus_found_during_oriantation_phase(self):\n        self._check(Pt531_HKL0,\n                    Pt531_REF0_DIFFCALC,  # inspected as close to Pt531_REF0\n                    {\'betain\': 2})\n\n    def testHkl_1_predicted_versus_found_during_oriantation_phase(self):\n        self._check(Pt531_HKL1,\n                    Pt531_REF1_DIFFCALC,  # inspected as close to Pt531_REF1,\n                    {\'betain\': 2})\n\n    def testHkl_2_predicted_versus_found_during_oriantation_phase(self):\n        self._check(Pt531_HKL2,\n                    Pt531_REF2_DIFFCALC,  # inspected as close to Pt531_REF2\n                    {\'betain\': 2})\n'"
test/diffcalc/hkl/you/__init__.py,0,b''
test/diffcalc/hkl/you/test_calc.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nfrom math import pi, cos, sin\nfrom nose.tools import raises\nfrom mock import Mock\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hardware import DummyHardwareAdapter\nfrom diffcalc.hkl.you.calc import YouHklCalculator\nfrom diffcalc.hkl.you.constraints import YouConstraintManager\nfrom test.tools import assert_array_almost_equal, \\\n    assert_second_dict_almost_in_first, arrayeq_\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.util import y_rotation, z_rotation, DiffcalcException\nfrom diffcalc.hkl.you.geometry import YouPosition as Pos, SixCircle, YouGeometry\nfrom diffcalc.hkl.you.calc import youAnglesToHkl\n\nTORAD = pi / 180\nTODEG = 180 / pi\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n\nfrom diffcalc.settings import NUNAME\n\nclass Pair:\n\n    def __init__(self, name, hkl, position, fails=False):\n        self.name = name\n        self.hkl = hkl\n        self.position = position\n        self.fails = fails\n\n\ndef createMockUbcalc(UB):\n    ubcalc = Mock()\n    ubcalc.tau = 0\n    ubcalc.sigma = 0\n    ubcalc.UB = UB\n    ubcalc.n_phi = matrix([[0], [0], [1]])\n    ubcalc.surf_nphi = matrix([[0], [0], [1]])\n    return ubcalc\n\n\ndef createMockHardwareMonitor():\n    names = [\'mu\', \'delta\', NUNAME, \'eta\', \'chi\', \'phi\']\n    hardware = DummyHardwareAdapter(names)\n\n    hardware.set_lower_limit(\'delta\', 0)\n    hardware.set_upper_limit(\'delta\', 179.999)\n    hardware.set_lower_limit(NUNAME, 0)\n    hardware.set_upper_limit(NUNAME, 179.999)\n    hardware.set_lower_limit(\'mu\', 0)\n    hardware.set_lower_limit(\'eta\', 0)\n    hardware.set_upper_limit(\'chi\', 179.999)\n    hardware.set_lower_limit(\'chi\', -10)\n    hardware.set_cut(\'phi\', -179.999)\n    return hardware\n\n\nclass _BaseTest(object):\n\n    def setup_method(self):\n        self.mock_ubcalc = createMockUbcalc(None)\n        settings.geometry = SixCircle()\n        self.constraints = YouConstraintManager()\n        self.calc = YouHklCalculator(self.mock_ubcalc, self.constraints)\n\n        self.mock_hardware = createMockHardwareMonitor()\n        self.mock_hardware.set_lower_limit(\'delta\', 0)\n        self.mock_hardware.set_upper_limit(\'delta\', 179.999)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.mock_hardware.set_upper_limit(NUNAME, 179.999)\n        self.mock_hardware.set_lower_limit(\'mu\', 0)\n        self.mock_hardware.set_lower_limit(\'eta\', 0)\n        self.mock_hardware.set_upper_limit(\'chi\', 179.999)\n        self.mock_hardware.set_lower_limit(\'chi\', -10)\n        self.mock_hardware.set_cut(\'phi\', -179.999)\n        settings.hardware = self.mock_hardware\n\n        self.places = 5\n\n    def _configure_ub(self):\n        ZROT = z_rotation(self.zrot * TORAD)  # -PHI\n        YROT = y_rotation(self.yrot * TORAD)  # +CHI\n        U = ZROT * YROT\n        UB = U * self.B\n        self.mock_ubcalc.UB = UB\n\n    def _check_hkl_to_angles(self, testname, zrot, yrot, hkl, pos_expected,\n                             wavelength, virtual_expected={}):\n        print (\'_check_hkl_to_angles(%s, %.1f, %.1f, %s, %s, %.2f, %s)\' %\n               (testname, zrot, yrot, hkl, pos_expected, wavelength,\n                virtual_expected))\n        self.zrot, self.yrot = zrot, yrot\n        self._configure_ub()\n\n        pos, virtual = self.calc.hklToAngles(hkl[0], hkl[1], hkl[2],\n                                             wavelength)\n        assert_array_almost_equal(pos.totuple(), pos_expected.totuple(),\n                                  self.places)\n        assert_second_dict_almost_in_first(virtual, virtual_expected)\n\n    def _check_angles_to_hkl(self, testname, zrot, yrot, hkl_expected, pos,\n                             wavelength, virtual_expected={}):\n        print (\'_check_angles_to_hkl(%s, %.1f, %.1f, %s, %s, %.2f, %s)\' %\n               (testname, zrot, yrot, hkl_expected, pos, wavelength,\n                virtual_expected))\n        self.zrot, self.yrot = zrot, yrot\n        self._configure_ub()\n        hkl, virtual = self.calc.anglesToHkl(pos, wavelength)\n        assert_array_almost_equal(hkl, hkl_expected, self.places, note=""***Test (not diffcalc!) incorrect*** : the desired settings do not map to the target hkl"")\n        assert_second_dict_almost_in_first(virtual, virtual_expected)\n\n    @raises(DiffcalcException)\n    def _check_hkl_to_angles_fails(self, *args):\n        self._check_hkl_to_angles(*args)\n\n    def case_generator(self):\n        for case in self.case_dict.values():\n            yield (self._check_angles_to_hkl, case.name, self.zrot, self.yrot,\n                   case.hkl, case.position, self.wavelength, {})\n            test_method = (self._check_hkl_to_angles_fails if case.fails else\n                           self._check_hkl_to_angles)\n            yield (test_method, case.name, self.zrot, self.yrot, case.hkl,\n                                case.position, self.wavelength, {})\n\n\nclass _TestCubic(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.B = I * 2 * pi\n\n\nclass _TestCubicVertical(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=0 - self.yrot,\n                     phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=4 - self.yrot,\n                     phi=0 + self.zrot, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=90 + self.zrot, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=90 - self.yrot,\n                     phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=97.46959231642/2, chi=86.18592516571 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=86 - self.yrot,\n                     phi=0 + self.zrot, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_various_zrot_and_yrot0(self):\n        for zrot in [0, 2, -2, 45, -45, 90, -90]:  # -180, 180 work if recut\n            self.makes_cases(zrot, 0)\n            self.case_dict[\'001\'].fails = True  # q||n\n            for case_tuple in self.case_generator():\n                yield case_tuple\n\n    def test_hkl_to_angles_zrot1_yrot2(self):\n        self.makes_cases(1, 2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_hkl_to_angles_zrot1_yrotm2(self):\n        self.makes_cases(1, -2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_hkl_to_angles_zrotm1_yrot2(self):\n        self.makes_cases(-1, 2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_hkl_to_angles_zrotm1_yrotm2(self):\n        self.makes_cases(-1, -2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def testHklDeltaGreaterThan90(self):\n        wavelength = 1            \n        hkl = (0.1, 0, 1.5)\n        pos = Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=97.46959231642/2, chi=86.18592516571,\n                      phi=0, unit=\'DEG\')\n        self._check_hkl_to_angles(\'\', 0, 0, hkl, pos, wavelength)\n\n\nclass TestCubicVertical_aeqb(_TestCubicVertical):\n\n    def setup_method(self):\n        _TestCubicVertical.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'mu\': 0, NUNAME: 0}\n\n\nclass TestCubicVertical_psi_90(_TestCubicVertical):\n    \'\'\'mode psi=90 should be the same as mode a_eq_b\'\'\'\n\n    def setup_method(self):\n        _TestCubicVertical.setup_method(self)\n        self.constraints._constrained = {\'psi\': 90 * TORAD, \'mu\': 0, NUNAME: 0}\n\n    def test_pairs_various_zrot_and_yrot0(self):\n        for zrot in [0, 2, -2, 45, -45, 90, -90]:  # -180, 180 work if recut\n            self.makes_cases(zrot, 0)\n            self.case_dict[\'001\'].fails = True  # q||n psi is undefined\n            for case_tuple in self.case_generator():\n                yield case_tuple\n\n    def test_hkl_to_angles_zrot1_yrotm2(self):\n        self.constraints._constrained = {\'psi\': -90 * TORAD, \'mu\': 0, NUNAME: 0}\n        super(TestCubicVertical_psi_90, self).test_hkl_to_angles_zrot1_yrotm2()\n\n    def test_hkl_to_angles_zrotm1_yrotm2(self):\n        self.constraints._constrained = {\'psi\': -90 * TORAD, \'mu\': 0, NUNAME: 0}\n        super(TestCubicVertical_psi_90, self).test_hkl_to_angles_zrotm1_yrotm2()\n\nclass TestCubicVertical_qaz_90(_TestCubicVertical):\n    \'\'\'mode psi=90 should be the same as mode a_eq_b\'\'\'\n\n    def setup_method(self):\n        _TestCubicVertical.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'mu\': 0,\n                                         \'qaz\': 90 * TORAD}\n\n\nclass TestCubicVertical_ChiPhiMode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {NUNAME: 0, \'chi\': 90. * TORAD, \'phi\': 0.}\n        self.mock_hardware.set_lower_limit(\'mu\', -180.)\n        self.mock_hardware.set_lower_limit(\'eta\', -180.)\n        self.places = 5\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'110\', (1, 1, 0),\n                 Pos(mu=-90, delta=90, nu=0, eta=90, chi=90,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'100-->001\', (sin(4 * TORAD), 0, cos(4 * TORAD)),\n                 Pos(mu=-8.01966360660, delta=60, nu=0, eta=29.75677306273, chi=90,\n                     phi=0, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=120, chi=90, phi=0, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30 - self.yrot, chi=90,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=-5.077064540005, delta=97.46959231642, nu=0,\n                      eta=48.62310452627, chi=90 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'010-->001\', (0, cos(86 * TORAD), sin(86 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=34, chi=90,\n                     phi=0, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\nclass TestCubic_FixedPhiMode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'mu\': 0, NUNAME: 0, \'phi\': 0}\n        self.mock_hardware.set_upper_limit(\'chi\', 180.)\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=0 - self.yrot,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=4 - self.yrot,\n                     phi=0, unit=\'DEG\'),),\n            #Pair(\'010\', (0, 1, 0),\n            #     Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=0, phi=90, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=90 - self.yrot,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=97.46959231642/2 + self.zrot, chi=86.18592516571 - self.yrot,\n                      phi=0, unit=\'DEG\')),\n            Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=86 - self.yrot,\n                     phi=0, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_various_zrot0_and_yrot(self):\n        for yrot in [0, 2, -2, 45, -45, 90, -90]:  # -180, 180 work if recut\n            self.makes_cases(0, yrot)\n            for case_tuple in self.case_generator():\n                yield case_tuple\n\nclass TestCubic_FixedPhi30Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'mu\': 0, NUNAME: 0, \'phi\': 30 * TORAD}\n        self.mock_hardware.set_upper_limit(\'chi\', 180.)\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=0 + self.zrot, chi=0 - self.yrot,\n                     phi=30, unit=\'DEG\')),\n            #Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n            #     Pos(mu=0, delta=60, nu=0, eta=0 + self.zrot, chi=4 - self.yrot,\n            #         phi=30, unit=\'DEG\'),),\n            #Pair(\'010\', (0, 1, 0),\n            #     Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=0, phi=90, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=90 - self.yrot,\n                     phi=30, unit=\'DEG\')),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=46.828815370173 + self.zrot, chi=86.69569481984 - self.yrot,\n                      phi=30, unit=\'DEG\')),\n            #Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n            #     Pos(mu=0, delta=60, nu=0, eta=0 + self.zrot, chi=86 - self.yrot,\n            #         phi=30, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_and_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\nclass TestCubic_FixedPhiMode010(TestCubic_FixedPhiMode):\n\n    def setup_method(self):\n        TestCubic_FixedPhiMode.setup_method(self)\n        self.constraints._constrained = {\'mu\': 0, NUNAME: 0, \'phi\': 90 * TORAD}\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30 + self.zrot, chi=0, phi=90, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_various_zrot0_and_yrot(self):\n        for yrot in [0, 2, -2, 45, -45, 90, -90]:  # -180, 180 work if recut\n            self.makes_cases(0, yrot)\n            \n            for case_tuple in self.case_generator():\n                yield case_tuple\n\nclass TestCubicVertical_MuEtaMode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {NUNAME: 0, \'mu\': 90. * TORAD, \'eta\': 0.}\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'011\', (0, 1, 1),\n                 Pos(mu=90, delta=90, nu=0, eta=0, chi=0,\n                     phi=90, unit=\'DEG\')),\n            Pair(\'100-->001\', (sin(4 * TORAD), 0, cos(4 * TORAD)),\n                 Pos(mu=90, delta=60, nu=0, eta=0, chi=56,\n                     phi=0, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=90, delta=60, nu=0, eta=0, chi=-30, phi=90, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=90, delta=60, nu=0, eta=0, chi=60,\n                     phi=0, unit=\'DEG\'), fails=True),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=90, delta=97.46959231642, nu=0,\n                      eta=0, chi=37.45112900750 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'010-->001\', (0, cos(86 * TORAD), sin(86 * TORAD)),\n                 Pos(mu=90, delta=60, nu=0, eta=0, chi=56,\n                     phi=90, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubic_FixedRefMuPhiMode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'psi\': 90 * TORAD, \'mu\': 0, \'phi\': 0}\n        self.mock_hardware.set_upper_limit(\'chi\', 180.)\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=0,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'010-->100\', (sin(4 * TORAD), cos(4 * TORAD), 0),\n                 Pos(mu=0, delta=60, nu=0, eta=120 - 4, chi=0,\n                     phi=0, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=120, chi=0, phi=0, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=90,\n                     phi=0, unit=\'DEG\'), fails=True),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=97.46959231642/2, chi=86.18592516571,\n                      phi=0, unit=\'DEG\')),\n            Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=86,\n                     phi=0, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_various_zrot0_and_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubic_FixedRefEtaPhiMode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'psi\': 0, \'eta\': 0, \'phi\': 0}\n        self.mock_hardware.set_upper_limit(\'chi\', 180.)\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n        self.mock_hardware.set_upper_limit(\'mu\', 180.)\n        self.mock_hardware.set_lower_limit(\'mu\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=-90, delta=60, nu=0, eta=0, chi=30,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                 Pos(mu=-90, delta=60, nu=0, eta=0, chi=30 + 4,\n                     phi=0, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=120, delta=0, nu=60, eta=0, chi=180, phi=0, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=90,\n                     phi=0, unit=\'DEG\'), fails=True),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 0.15),  # cover case where delta > 90 !\n                  Pos(mu=-90, delta=10.34318, nu=0,\n                      eta=0, chi=61.48152,\n                      phi=0, unit=\'DEG\')),\n            Pair(\'010-->001\', (0, cos(4 * TORAD), sin(4 * TORAD)),\n                 Pos(mu=120 + 4, delta=0, nu=60, eta=0, chi=180,\n                     phi=0, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_various_zrot0_and_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubicVertical_Bisect(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {NUNAME: 0, \'bisect\': None, \'omega\': 0}\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'101\', (1, 0, 1),\n                 Pos(mu=0, delta=90, nu=0, eta=45, chi=45,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'10m1\', (1, 0, -1),\n                 Pos(mu=0, delta=90, nu=0, eta=45, chi=-45,\n                     phi=0, unit=\'DEG\')),\n            Pair(\'011\', (0, 1, 1),\n                 Pos(mu=0, delta=90, nu=0, eta=45, chi=45,\n                     phi=90, unit=\'DEG\')),\n            Pair(\'100-->001\', (sin(4 * TORAD), 0, cos(4 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=86,\n                     phi=0, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=90, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=90,\n                     phi=0, unit=\'DEG\'), fails=True),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=0, delta=97.46959231642, nu=0,\n                      eta=48.73480, chi=86.18593 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n            Pair(\'010-->001\', (0, cos(86 * TORAD), sin(86 * TORAD)),\n                 Pos(mu=0, delta=60, nu=0, eta=30, chi=86,\n                     phi=90, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubicVertical_Bisect_NuMu(TestCubicVertical_Bisect):\n\n    def setup_method(self):\n        TestCubicVertical_Bisect.setup_method(self)\n        self.constraints._constrained = {NUNAME: 0, \'bisect\': None, \'mu\': 0}\n\n\nclass TestCubicVertical_Bisect_qaz(TestCubicVertical_Bisect):\n\n    def setup_method(self):\n        TestCubicVertical_Bisect.setup_method(self)\n        self.constraints._constrained = {\'qaz\': 90. * TORAD, \'bisect\': None, \'mu\': 0}\n\n\nclass TestCubicHorizontal_Bisect(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'delta\': 0, \'bisect\': None, \'omega\': 0}\n        self.mock_hardware.set_lower_limit(\'chi\', 0.)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n            Pair(\'101\', (1, 0, 1),\n                 Pos(mu=45, delta=0, nu=90, eta=0, chi=45,\n                     phi=180, unit=\'DEG\')),\n            Pair(\'10m1\', (1, 0, -1),\n                 Pos(mu=45, delta=0, nu=90, eta=0, chi=135,\n                     phi=180, unit=\'DEG\')),\n            Pair(\'011\', (0, 1, 1),\n                 Pos(mu=45, delta=0, nu=90, eta=0, chi=45,\n                     phi=-90, unit=\'DEG\')),\n            Pair(\'100-->001\', (sin(4 * TORAD), 0, cos(4 * TORAD)),\n                 Pos(mu=30, delta=0, nu=60, eta=0, chi=4,\n                     phi=180, unit=\'DEG\'),),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=30, delta=0, nu=60, eta=0, chi=90, phi=-90, unit=\'DEG\')),\n            Pair(\'001\', (0, 0, 1),\n                 Pos(mu=30, delta=0, nu=60, eta=0, chi=0,\n                     phi=0, unit=\'DEG\'), fails=True),\n            Pair(\'0.1 0 1.5\', (0.1, 0, 1.5),  # cover case where delta > 90 !\n                  Pos(mu=48.73480, delta=0, nu=97.46959231642,\n                      eta=0, chi=3.81407 - self.yrot,\n                      phi=180 + self.zrot, unit=\'DEG\')),\n            Pair(\'010-->001\', (0, cos(86 * TORAD), sin(86 * TORAD)),\n                 Pos(mu=30, delta=0, nu=60, eta=0, chi=4,\n                     phi=-90, unit=\'DEG\')),\n        )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubicHorizontal_Bisect_NuMu(TestCubicHorizontal_Bisect):\n\n    def setup_method(self):\n        TestCubicHorizontal_Bisect.setup_method(self)\n        self.constraints._constrained = {\'delta\': 0, \'bisect\': None, \'eta\': 0}\n\n\nclass TestCubicHorizontal_Bisect_qaz(TestCubicHorizontal_Bisect):\n\n    def setup_method(self):\n        TestCubicHorizontal_Bisect.setup_method(self)\n        self.constraints._constrained = {\'qaz\': 0, \'bisect\': None, \'eta\': 0}\n\n\nclass SkipTestYouHklCalculatorWithCubicMode_aeqb_delta_60(_TestCubicVertical):\n    \'\'\'\n    Works to 4-5 decimal places but chooses different solutions when phi||eta .\n    Skip all tests.\n    \'\'\'\n\n    def setup_method(self):\n        _TestCubicVertical.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'mu\': 0,\n                                         \'delta\': 60 * TORAD}\n        self.places = 5\n\n\nclass _TestCubicHorizontal(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n\n    def makes_cases(self, zrot, yrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=90 + self.yrot,\n                      phi=-180 + self.zrot, unit=\'DEG\')),\n             Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=90 - 4 + self.yrot,\n                      phi=-180 + self.zrot, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=90,\n                      phi=-90 + self.zrot, unit=\'DEG\'), fails=True),  # degenrate case mu||phi\n             Pair(\'001\', (0, 0, 1),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n             Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0 - 4 - self.yrot,\n                      phi=0 + self.zrot, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        self.case_dict[\'001\'].fails = True  # q||n\n        self.case_dict[\'100\'].fails = True  # mu||phi\n        self.case_dict[\'100-->001\'].position.phi = 180  # not -180\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n#    def test_pairs_various_zrot_and_yrot0(self):\n#        for zrot in [0, 2, -2, 45, -45, 90, -90]:\n# -180, 180 work but with cut problem\n#            self.makes_cases(zrot, 0)\n#            self.case_dict[\'001\'].fails = True # q||n\n#            for case_tuple in self.case_generator():\n#                yield case_tuple\n\n    def test_hkl_to_angles_zrot1_yrot2(self):\n        self.makes_cases(1, 2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_hkl_to_angles_zrot1_yrotm2(self):\n        self.makes_cases(1, -2)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestCubicHorizontal_qaz0_aeqb(_TestCubicHorizontal):\n\n    def setup_method(self):\n        _TestCubicHorizontal.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'qaz\': 0, \'eta\': 0}\n\n\nclass TestCubicHorizontal_delta0_aeqb(_TestCubicHorizontal):\n\n    def setup_method(self):\n        _TestCubicHorizontal.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'delta\': 0, \'eta\': 0}\n\n\nclass TestCubic_FixedDeltaEtaPhi0Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'eta\': 0, \'delta\': 0, \'phi\': 0}\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=-90 - self.yrot,\n                      phi=0, unit=\'DEG\')),\n             Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi= -90 + 4 - self.yrot,\n                      phi=0, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=120, delta=0, nu=60, eta=0, chi=0,\n                      phi=0, unit=\'DEG\'), fails=True),  # degenerate case chi||q\n             Pair(\'001\', (0, 0, 1),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0 - self.yrot,\n                      phi=0, unit=\'DEG\')),\n             Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0 - 4 - self.yrot,\n                      phi=0, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_pairs_various_zrot0_and_yrot(self):\n        for yrot in [0, 2, -2, 45, -45, 90, -90]:\n            self.makes_cases(yrot, 0)\n            for case_tuple in self.case_generator():\n                yield case_tuple\n    \nclass TestCubic_FixedDeltaEtaPhi30Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'eta\': 0, \'delta\': 0, \'phi\': 30 * TORAD}\n        self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=0, delta=0, nu=60, eta=0, chi=-90 - self.yrot,\n                      phi=30, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=90, delta=0, nu=60, eta=0, chi=-90 - self.yrot,\n                      phi=30, unit=\'DEG\')),\n             Pair(\'001\', (0, 0, 1),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0 - self.yrot,\n                      phi=30, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\nclass TestCubic_FixedDeltaEtaChi0Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'eta\': 0, \'delta\': 0, \'chi\': 0}\n        #self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=120, delta=0, nu=60, eta=0, chi=0,\n                      phi=-90 + self.zrot, unit=\'DEG\')),\n             Pair(\'100-->001\', (cos(4 * TORAD), 0, sin(4 * TORAD)),\n                  Pos(mu=120 - 4, delta=0, nu=60, eta=0, chi= 0,\n                      phi=-90 + self.zrot, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=120, delta=0, nu=60, eta=0, chi=0,\n                      phi=self.zrot, unit=\'DEG\')),\n             Pair(\'001\', (0, 0, 1),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=0,\n                      phi=0, unit=\'DEG\'), fails=True),  # degenerate case phi||q\n             Pair(\'001-->100\', (cos(86 * TORAD), 0, sin(86 * TORAD)),\n                  Pos(mu=30 - 4 , delta=0, nu=60, eta=0, chi=0,\n                      phi=90 + self.zrot, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_pairs_various_zrot_and_yrot0(self):\n        for zrot in [0, 2, -2,]:\n            self.makes_cases(0, zrot)\n            for case_tuple in self.case_generator():\n                yield case_tuple\n    \nclass TestCubic_FixedDeltaEtaChi30Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'eta\': 0, \'delta\': 0, \'chi\': 30 * TORAD}\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=120, delta=0, nu=60, eta=0, chi=30,\n                      phi=-90, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=120, delta=0, nu=60, eta=0, chi=30,\n                      phi=0, unit=\'DEG\')),\n             Pair(\'100-->001\', (-sin(30 * TORAD), 0, cos(30 * TORAD)),\n                  Pos(mu=30, delta=0, nu=60, eta=0, chi=30,\n                      phi=0, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\nclass TestCubic_FixedGamMuChi90Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'mu\': 0, NUNAME: 0, \'chi\': 90 * TORAD}\n        #self.mock_hardware.set_lower_limit(\'chi\', -180.)\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi=90,\n                      phi=-90 + self.zrot, unit=\'DEG\')),\n             Pair(\'010-->100\', (sin(4 * TORAD), cos(4 * TORAD), 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi= 90,\n                      phi=-4 + self.zrot, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi=90,\n                      phi=self.zrot, unit=\'DEG\')),\n             Pair(\'001\', (0, 0, 1),\n                  Pos(mu=0, delta=60, nu=0, eta=30, chi=90,\n                      phi=0, unit=\'DEG\'), fails=True),  # degenerate case phi||q\n             Pair(\'100-->010\', (sin(86 * TORAD), cos(86 * TORAD), 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi=90,\n                      phi=-90 + 4 + self.zrot, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n    def test_pairs_various_zrot_and_yrot0(self):\n        for zrot in [0, 2, -2,]:\n            self.makes_cases(0, zrot)\n            for case_tuple in self.case_generator():\n                yield case_tuple\n    \nclass TestCubic_FixedGamMuChi30Mode(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.constraints._constrained = {\'mu\': 0, NUNAME: 0, \'chi\': 30 * TORAD}\n\n    def makes_cases(self, yrot, zrot):\n        self.zrot = zrot\n        self.yrot = yrot\n        self.wavelength = 1\n        self.cases = (\n             Pair(\'100\', (1, 0, 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi=30,\n                      phi=-90, unit=\'DEG\')),\n             Pair(\'010\', (0, 1, 0),\n                  Pos(mu=0, delta=60, nu=0, eta=120, chi=30,\n                      phi=0, unit=\'DEG\')),\n             Pair(\'100-->010\', (sin(30 * TORAD), cos(30 * TORAD), 0),\n                  Pos(mu=00, delta=60, nu=0, eta=120, chi=30,\n                      phi=-30, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def test_pairs_zrot0_yrot0(self):\n        self.makes_cases(0, 0)\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\nclass TestAgainstSpecSixcB16_270608(_BaseTest):\n    \'\'\'NOTE: copied from test.diffcalc.scenarios.session3\'\'\'\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n\n        U = matrix(((0.997161, -0.062217, 0.042420),\n                    (0.062542, 0.998022, -0.006371),\n                    (-0.041940, 0.009006, 0.999080)))\n\n        B = matrix(((1.636204, 0, 0),\n                    (0, 1.636204, 0),\n                    (0, 0, 1.156971)))\n\n        self.UB = U * B\n        self.constraints._constrained = {\'a_eq_b\': None, \'mu\': 0, NUNAME: 0}\n        self.places = 2  # TODO: the Vlieg code got this to 3 decimal places\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def makes_cases(self, zrot, yrot):\n        del zrot, yrot  # not used\n        self.wavelength = 1.24\n        self.cases = (\n            Pair(\'7_9_13\', (0.7, 0.9, 1.3),\n                 Pos(mu=0, delta=27.352179, nu=0, eta=13.676090,\n                     chi=37.774500, phi=53.965500, unit=\'DEG\')),\n            Pair(\'100\', (1, 0, 0),\n                 Pos(mu=0, delta=18.580230, nu=0, eta=9.290115,\n                     chi=-2.403500, phi=3.589000, unit=\'DEG\')),\n            Pair(\'010\', (0, 1, 0),\n                 Pos(mu=0, delta=18.580230, nu=0, eta=9.290115,\n                     chi=0.516000, phi=93.567000, unit=\'DEG\')),\n            Pair(\'110\', (1, 1, 0),\n                 Pos(mu=0, delta=26.394192, nu=0, eta=13.197096,\n                     chi=-1.334500, phi=48.602000, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def case_generator(self):\n        zrot, yrot = 999, 999\n        for case in self.cases:\n            yield (self._check_angles_to_hkl, case.name, zrot, yrot, case.hkl,\n                   case.position, self.wavelength, {})\n            test_method = (self._check_hkl_to_angles_fails if case.fails else\n                           self._check_hkl_to_angles)\n            yield (test_method, case.name, zrot, yrot, case.hkl, case.position,\n                   self.wavelength, {})\n\n    def test_hkl_to_angles_given_UB(self):\n        self.makes_cases(None, None)  # xrot, yrot unused\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\n\nclass TestThreeTwoCircleForDiamondI06andI10(_BaseTest):\n    """"""\n    This is a three circle diffractometer with only delta and omega axes\n    and a chi axis with limited range around 90. It is operated with phi\n    fixed and can only reach reflections with l (or z) component.\n\n    The data here is taken from an experiment performed on Diamonds I06\n    beamline.\n    """"""\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints._constrained = {\'phi\': -pi / 2, NUNAME: 0, \'mu\': 0}\n        self.wavelength = 12.39842 / 1.650\n\n    def _configure_ub(self):\n        U = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        B = CrystalUnderTest(\'xtal\', 5.34, 5.34, 13.2, 90, 90, 90).B\n        self.mock_ubcalc.UB = U * B\n\n    def testHkl001(self):\n        hkl = (0, 0, 1)\n        pos = Pos(mu=0, delta=33.07329403295449, nu=0, eta=16.536647016477247,\n                  chi=90, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n\n    def testHkl100(self):\n        hkl = (1, 0, 0)\n        pos = Pos(mu=0, delta=89.42926563609406, nu=0, eta=134.71463281804702,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n\n    def testHkl101(self):\n        hkl = (1, 0, 1)\n        pos = Pos(mu=0, delta=98.74666191021282, nu=0, eta=117.347760720783,\n                  chi=90, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'101\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'101\', 999, 999, hkl, pos, self.wavelength, {})\n\n\nclass TestThreeTwoCircleForDiamondI06andI10Horizontal(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints._constrained = {\'phi\': -pi / 2, \'delta\': 0, \'eta\': 0}\n        self.wavelength = 12.39842 / 1.650\n\n    def _configure_ub(self):\n        U = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n        B = CrystalUnderTest(\'xtal\', 5.34, 5.34, 13.2, 90, 90, 90).B\n        self.mock_ubcalc.UB = U * B\n\n    def testHkl001(self):\n        hkl = (0, 0, 1)\n        pos = Pos(mu=16.536647016477247, delta=0, nu=33.07329403295449, eta=0,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n\n    @raises(DiffcalcException)  # q || chi\n    def testHkl100(self):\n        hkl = (1, 0, 0)\n        pos = Pos(mu=134.71463281804702, delta=0, nu=89.42926563609406, eta=0,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n\n    def testHkl101(self):\n        hkl = (1, 0, 1)\n        pos = Pos(mu=117.347760720783, delta=0, nu=98.74666191021282, eta=0,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'101\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'101\', 999, 999, hkl, pos, self.wavelength, {})\n\n\nclass TestThreeTwoCircleForDiamondI06andI10ChiDeltaEta(TestThreeTwoCircleForDiamondI06andI10Horizontal):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.constraints._constrained = {\'phi\': -pi / 2, \'chi\': 0, \'delta\': 0}\n        self.wavelength = 12.39842 / 1.650\n\n    @raises(DiffcalcException)  # q || eta\n    def testHkl001(self):\n        hkl = (0, 0, 1)\n        pos = Pos(mu=16.536647016477247, delta=0, nu=33.07329403295449, eta=0,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'001\', 999, 999, hkl, pos, self.wavelength, {})\n\n    def testHkl100(self):\n        hkl = (1, 0, 0)\n        pos = Pos(mu=134.71463281804702, delta=0, nu=89.42926563609406, eta=0,\n                  chi=0, phi=-90, unit=\'DEG\')\n        self._check_angles_to_hkl(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n        self._check_hkl_to_angles(\n            \'100\', 999, 999, hkl, pos, self.wavelength, {})\n\nclass TestFixedChiPhiPsiMode_DiamondI07SurfaceNormalHorizontal(_TestCubic):\n    """"""\n    The data here is taken from an experiment performed on Diamonds I07\n    beamline, obtained using Vlieg\'s DIF software""""""\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.mock_hardware.set_upper_limit(\'delta\', 90)\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        # Set some random reference vector orientation\n        # that won\'t coincide with the scattering vector direction.\n        #self.mock_ubcalc.n_phi = matrix([[0.087867277], [0.906307787], [0.413383038]])\n        #self.mock_ubcalc.n_phi = matrix([[0.], [1.], [0.]])\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl001(self):\n        self._check((0, 0, 1),  # betaout=30\n                    Pos(mu=30, delta=0, nu=60, eta=90, chi=0, phi=0, unit=\'DEG\'), fails=True)\n\n    def testHkl010(self):\n        self._check((0, 1, 0),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=120, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl011(self):\n        self._check((0, 1, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=90, eta=125.2644, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl100(self):\n        self._check((1, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl101(self):\n        self._check((1, 0, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=90, eta=35.2644, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl110(self):\n        self._check((1, 1, 0),  # betaout=0\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl11nearly0(self):\n        self.places = 3\n        self._check((1, 1, .0001),  # betaout=0\n                    Pos(mu=0.0029, delta=89.9971, nu=90.0058, eta=90, chi=0,\n                      phi=0, unit=\'DEG\'))\n\n    def testHkl111(self):\n        self._check((1, 1, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=150, eta=99.7356, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHklover100(self):\n        self._check((1.1, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=66.7340, nu=0, eta=33.3670, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHklunder100(self):\n        self._check((.9, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=53.4874, nu=0, eta=26.7437, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl788(self):\n        self._check((.7, .8, .8),  # betaout=23.5782\n                    Pos(mu=23.5782, delta=59.9980, nu=76.7037, eta=84.2591,\n                      chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl789(self):\n        self._check((.7, .8, .9),  # betaout=26.7437\n                    Pos(mu=26.74368, delta=58.6754, nu=86.6919, eta=85.3391,\n                      chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl7810(self):\n        self._check((.7, .8, 1),  # betaout=30\n                    Pos(mu=30, delta=57.0626, nu=96.86590, eta=86.6739, chi=0,\n                      phi=0, unit=\'DEG\'))\n\n\nclass SkipTestFixedChiPhiPsiModeSurfaceNormalVertical(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl001(self):\n        self._check((0, 0, 1),  # betaout=30\n                    Pos(mu=30, delta=0, nu=60, eta=90, chi=0, phi=0, unit=\'DEG\'), fails=True)\n\n    def testHkl010(self):\n        self._check((0, 1, 0),  # betaout=0\n                    Pos(mu=120, delta=0, nu=60, eta=0, chi=90, phi=0, unit=\'DEG\'))\n\n    def testHkl011(self):\n        self._check((0, 1, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=90, eta=125.2644, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl100(self):\n        self._check((1, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl101(self):\n        self._check((1, 0, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=90, eta=35.2644, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl110(self):\n        self._check((1, 1, 0),  # betaout=0\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl11nearly0(self):\n        self.places = 3\n        self._check((1, 1, .0001),  # betaout=0\n                    Pos(mu=0.0029, delta=89.9971, nu=90.0058, eta=90, chi=0,\n                      phi=0, unit=\'DEG\'))\n\n    def testHkl111(self):\n        self._check((1, 1, 1),  # betaout=30\n                    Pos(mu=30, delta=54.7356, nu=150, eta=99.7356, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHklover100(self):\n        self._check((1.1, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=66.7340, nu=0, eta=33.3670, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHklunder100(self):\n        self._check((.9, 0, 0),  # betaout=0\n                    Pos(mu=0, delta=53.4874, nu=0, eta=26.7437, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl788(self):\n        self._check((.7, .8, .8),  # betaout=23.5782\n                    Pos(mu=23.5782, delta=59.9980, nu=76.7037, eta=84.2591,\n                      chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl789(self):\n        self._check((.7, .8, .9),  # betaout=26.7437\n                    Pos(mu=26.74368, delta=58.6754, nu=86.6919, eta=85.3391,\n                      chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl7810(self):\n        self._check((.7, .8, 1),  # betaout=30\n                    Pos(mu=30, delta=57.0626, nu=96.86590, eta=86.6739, chi=0,\n                      phi=0, unit=\'DEG\'))\n\nclass SkipTestFixedChiPhiPsiModeSurfaceNormalVerticalI16(_TestCubic):\n    # testing with Chris N. for pre christmas 2012 i16 experiment\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(\'nu\', 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n#        self._check_angles_to_hkl(\n#            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl_1_1_0(self):\n        self._check((1, 1, 0.001),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n        #(-89.9714,  89.9570,  90.0382,  90.0143,  90.0000,  0.0000)\n\n    def testHkl_1_1_05(self):\n        self._check((1, 1, 0.5),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_1_1_1(self):\n        self._check((1, 1, 1),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n        #    (-58.6003,  42.7342,  132.9004,  106.3249,  90.0000,  0.0000\n\n    def testHkl_1_1_15(self):\n        self._check((1, 1, 1.5),  # betaout=0\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n\n\nclass TestConstrain3Sample_ChiPhiEta(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        # Set some random reference vector orientation\n        # that won\'t coincide with the scattering vector direction.\n        #self.mock_ubcalc.n_phi = matrix([[0.087867277], [0.906307787], [0.413383038]])\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl_all0_001(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0}\n        self._check((0, 0, 1),\n                    Pos(mu=30, delta=0, nu=60, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_010(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0}\n        self._check((0, 1, 0),\n                    Pos(mu=120, delta=0, nu=60, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_011(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0}\n        self._check((0, 1, 1),\n                    Pos(mu=90, delta=0, nu=90, eta=0, chi=0, phi=0, unit=\'DEG\'))\n        \n    def testHkl_phi30_100(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 30 * TORAD, \'eta\': 0}\n        self._check((1, 0, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=0, chi=0, phi=30, unit=\'DEG\'))\n        \n    def testHkl_eta30_100(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 30 * TORAD}\n        self._check((1, 0, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=0, phi=0, unit=\'DEG\'))\n        \n    def testHkl_phi90_110(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 90 * TORAD, \'eta\': 0}\n        self._check((1, 1, 0),\n                    Pos(mu=0, delta=90, nu=0, eta=0, chi=0, phi=90, unit=\'DEG\'))\n        \n    def testHkl_eta90_110(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 90 * TORAD}\n        self._check((1, 1, 0),\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_1(self):\n        self.mock_hardware.set_upper_limit(\'delta\', 91)\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0 * TORAD}\n        self._check((.01, .01, .1),\n                    Pos(mu=8.6194, delta=0.5730, nu=5.7607, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_2(self):\n        self.mock_hardware.set_upper_limit(\'delta\', 91)\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0 * TORAD}\n        self._check((0, 0, .1),\n                    Pos(mu=2.8660, delta=0, nu=5.7320, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_3(self):\n        self.mock_hardware.set_upper_limit(\'delta\', 91)\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0 * TORAD}\n        self._check((.1, 0, .01),\n                    Pos(mu=30.3314, delta=5.7392, nu= 0.4970, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_show_all_solutionsall0_3(self):\n        self.mock_hardware.set_upper_limit(\'delta\', 91)\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0 * TORAD}\n        self._check((.1, 0, .01),\n                    Pos(mu=30.3314, delta=5.7392, nu= 0.4970, eta=0, chi=0, phi=0, unit=\'DEG\'))\n        #print self.calc.hkl_to_all_angles(.1, 0, .01, 1)\n\n    def testHkl_all0_010to001(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'eta\': 0}\n        self._check((0, cos(4 * TORAD), sin(4 * TORAD)),\n                    Pos(mu=120-4, delta=0, nu=60, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_1(self):\n        self.wavelength = .1\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0 * TORAD, \'eta\': 0}\n        self._check((0, 0, 1),\n                    Pos(mu=2.8660, delta=0, nu=5.7320, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_2(self):\n        self.wavelength = .1\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0 * TORAD, \'eta\': 0}\n        self._check((0, 0, 1),\n                    Pos(mu=2.8660, delta=0, nu=5.7320, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_3(self):\n        self.mock_hardware.set_upper_limit(\'delta\', 91)\n        self.wavelength = .1\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0 * TORAD, \'eta\': 0}\n        self._check((1, 0, .1),\n                    Pos(mu= 30.3314, delta=5.7392, nu= 0.4970, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n\nclass TestConstrain3Sample_MuChiPhi(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        # Set some random reference vector orientation\n        # that won\'t coincide with the scattering vector direction.\n        #self.mock_ubcalc.n_phi = matrix([[0.087867277], [0.906307787], [0.413383038]])\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl_all0_001(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((0, 0, 1),\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=90, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_010(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((0, 1, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=120, chi=90, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_011(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((0, 1, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'))\n        \n    def testHkl_etam60_100(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 90 * TORAD, \'mu\': 0}\n        self._check((1, 0, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=-60, chi=90, phi=90, unit=\'DEG\'))\n        \n    def testHkl_eta90_m110(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0, \'mu\': 90 * TORAD}\n        self._check((-1, 1, 0),\n                    Pos(mu=90, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'), fails=True)\n        \n    def testHkl_eta0_101(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 90 * TORAD, \'mu\': 0}\n        self._check((1, 0, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=0, chi=90, phi=90, unit=\'DEG\'))\n        \n    def testHkl_all0_010to100(self):\n        self.constraints._constrained = {\'chi\': 0, \'phi\': 0, \'mu\': 0}\n        self._check((sin(4 * TORAD), cos(4 * TORAD), 0),\n                    Pos(mu=0, delta=60, nu=0, eta=120 - 4, chi=0, phi=0, unit=\'DEG\'))\n\n\nclass TestConstrain3Sample_MuEtaChi(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        # Set some random reference vector orientation\n        # that won\'t coincide with the scattering vector direction.\n        #self.mock_ubcalc.n_phi = matrix([[0.087867277], [0.906307787], [0.413383038]])\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl_all0_001(self):\n        self.constraints._constrained = {\'eta\': 30 * TORAD, \'chi\': 90 * TORAD, \'mu\': 0}\n        self._check((0, 0, 1),\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=90, phi=0, unit=\'DEG\'), fails=True)\n\n    def testHkl_all0_010(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': 120 * TORAD, \'mu\': 0}\n        self._check((0, 1, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=120, chi=90, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_011(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': 90 * TORAD, \'mu\': 0}\n        self._check((0, 1, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'), fails=True)\n        \n    def testHkl_phi90_100(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': -60 * TORAD, \'mu\': 0}\n        self._check((1, 0, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=-60, chi=90, phi=90, unit=\'DEG\'))\n        \n    def testHkl_phi0_m110(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': 90 * TORAD, \'mu\': 90 * TORAD}\n        self._check((-1, 1, 0),\n                    Pos(mu=90, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'))\n        \n    def testHkl_phi90_101(self):\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'eta\': 0, \'mu\': 0}\n        self._check((1, 0, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=0, chi=90, phi=90, unit=\'DEG\'))\n        \n    def testHkl_all0_010to100(self):\n        self.constraints._constrained = {\'chi\': 0, \'eta\': 0, \'mu\': 0}\n        self._check((sin(4 * TORAD), cos(4 * TORAD), 0),\n                    Pos(mu=0, delta=60, nu=0, eta=0, chi=0, phi=120 - 4, unit=\'DEG\'))\n\n\nclass TestConstrain3Sample_MuEtaPhi(_TestCubic):\n\n    def setup_method(self):\n        _TestCubic.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        self.constraints._constrained = {\'chi\': 90 * TORAD, \'phi\': 0,\n                                         \'a_eq_b\': None}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n        self.places = 4\n\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\n            \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def testHkl_all0_001(self):\n        self.constraints._constrained = {\'eta\': 0, \'phi\': 0, \'mu\': 30 * TORAD}\n        self._check((0, 0, 1),\n                    Pos(mu=30, delta=0, nu=60, eta=0, chi=0, phi=0, unit=\'DEG\'))\n\n    def testHkl_all0_010(self):\n        self.constraints._constrained = {\'eta\': 120 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((0, 1, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=120, chi=90, phi=0, unit=\'DEG\'), fails=True)\n\n    def testHkl_all0_011(self):\n        self.constraints._constrained = {\'eta\': 90 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((0, 1, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'))\n        \n    def testHkl_chi90_100(self):\n        self.constraints._constrained = {\'eta\': -60 * TORAD, \'phi\': 90 * TORAD, \'mu\': 0}\n        self._check((1, 0, 0),\n                    Pos(mu=0, delta=60, nu=0, eta=-60, chi=90, phi=90, unit=\'DEG\'), fails=True)\n        \n    def testHkl_chi90_m110(self):\n        self.constraints._constrained = {\'eta\': 90 * TORAD, \'phi\': 0, \'mu\': 90 * TORAD}\n        self._check((-1, 1, 0),\n                    Pos(mu=90, delta=90, nu=0, eta=90, chi=90, phi=0, unit=\'DEG\'))\n        \n    def testHkl_chi90_101(self):\n        self.constraints._constrained = {\'eta\': 0, \'phi\': 90 * TORAD, \'mu\': 0}\n        self._check((1, 0, 1),\n                    Pos(mu=0, delta=90, nu=0, eta=0, chi=90, phi=90, unit=\'DEG\'), fails=True)\n        \n    def testHkl_all0_010to100(self):\n        self.constraints._constrained = {\'eta\': 30 * TORAD, \'phi\': 0, \'mu\': 0}\n        self._check((sin(4 * TORAD), 0, cos(4 * TORAD)),\n                    Pos(mu=0, delta=60, nu=0, eta=30, chi=90 - 4, phi=0, unit=\'DEG\'))\n\n\nclass TestHorizontalDeltaNadeta0_JiraI16_32_failure(_BaseTest):\n    """"""\n    The data here is taken from a trial experiment which failed. Diamond\'s internal Jira: \n    http://jira.diamond.ac.uk/browse/I16-32""""""\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self.mock_hardware.set_lower_limit(NUNAME, 0)\n        \n        self.wavelength = 12.39842 / 8\n        self.UB = matrix([[ -1.46410390e+00,  -1.07335571e+00,   2.44799214e-03],\n                          [  3.94098508e-01,  -1.07091934e+00,  -6.41132943e-04],\n                          [  7.93297438e-03,   4.01315826e-03,   4.83650166e-01]])\n        self.places = 3\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False, skip_test_pair_verification=False):\n        if not skip_test_pair_verification:\n            self._check_angles_to_hkl(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def test_hkl_bisecting_works_okay_on_i16(self):\n        self.constraints._constrained = {\'delta\': 0, \'a_eq_b\': None, \'eta\': 0}\n        self._check([-1.1812112493619709, -0.71251524866987204, 5.1997083010199221],\n                    Pos(mu=26, delta=0, nu=52, eta=0, chi=45.2453, phi=186.6933-360, unit=\'DEG\'), fails=False)\n\n    def test_hkl_psi90_works_okay_on_i16(self):\n        # This is failing here but on the live one. Suggesting some extreme sensitivity?\n        self.constraints._constrained = {\'delta\': 0, \'psi\': -90 * TORAD, \'eta\': 0}\n        self._check([-1.1812112493619709, -0.71251524866987204, 5.1997083010199221],\n                    Pos(mu=26, delta=0, nu=52, eta=0, chi=45.2453, phi=186.6933-360, unit=\'DEG\'), fails=False)\n        \n    def test_hkl_alpha_17_9776_used_to_fail(self):\n        # This is failing here but on the live one. Suggesting some extreme sensitivity?\n        self.constraints._constrained = {\'delta\': 0, \'alpha\': 17.9776 * TORAD, \'eta\': 0}\n        self._check([-1.1812112493619709, -0.71251524866987204, 5.1997083010199221],\n                    Pos(mu=26, delta=0, nu=52, eta=0, chi=45.2453, phi=186.6933-360, unit=\'DEG\'), fails=False)\n\n    def test_hkl_alpha_17_9776_failing_after_bigger_small(self):\n        # This is failing here but on the live one. Suggesting some extreme sensitivity?\n        self.constraints._constrained = {\'delta\': 0, \'alpha\': 17.8776 * TORAD, \'eta\': 0}\n        self._check([-1.1812112493619709, -0.71251524866987204, 5.1997083010199221],\n                    Pos(mu=25.85, delta=0, nu=52, eta=0, chi=45.2453, phi=-173.518, unit=\'DEG\'), fails=False)\n  \n#skip_test_pair_verification\n\ndef posFromI16sEuler(phi, chi, eta, mu, delta, gamma):\n    return Pos(mu, delta, gamma, eta, chi, phi, unit=\'DEG\')\n\n\nclass TestAnglesToHkl_I16Examples():\n\n    def __init__(self):\n        self.UB1 = matrix((\n           (0.9996954135095477, -0.01745240643728364, -0.017449748351250637),\n           (0.01744974835125045, 0.9998476951563913, -0.0003045864904520898),\n           (0.017452406437283505, -1.1135499981271473e-16, 0.9998476951563912))\n            ) * (2 * pi)\n        self.WL1 = 1  # Angstrom\n\n    def test_anglesToHkl_mu_0_gam_0(self):\n        pos = posFromI16sEuler(1, 1, 30, 0, 60, 0).inRadians()\n        arrayeq_(youAnglesToHkl(pos, self.WL1, self.UB1), [1, 0, 0])\n\n    def test_anglesToHkl_mu_0_gam_10(self):\n        pos = posFromI16sEuler(1, 1, 30, 0, 60, 10).inRadians()\n        arrayeq_(youAnglesToHkl(pos, self.WL1, self.UB1),\n                 [1.00379806, -0.006578435, 0.08682408])\n\n    def test_anglesToHkl_mu_10_gam_0(self):\n        pos = posFromI16sEuler(1, 1, 30, 10, 60, 0).inRadians()\n        arrayeq_(youAnglesToHkl(pos, self.WL1, self.UB1),\n                 [0.99620193, 0.0065784359, 0.08682408])\n\n    def test_anglesToHkl_arbitrary(self):\n        pos = posFromI16sEuler(1.9, 2.9, 30.9, 0.9, 60.9, 2.9).inRadians()\n        arrayeq_(youAnglesToHkl(pos, self.WL1, self.UB1),\n                 [1.01174189, 0.02368622, 0.06627361])\n\n\nclass TestAnglesToHkl_I16Numerical(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n\n        self.UB = matrix((\n           (1.11143,       0,       0),\n           (      0, 1.11143,       0),\n           (      0,       0, 1.11143))\n            )\n\n        self.constraints._constrained = {\'mu\':0, NUNAME: 0, \'phi\': 0}\n        self.wavelength = 1.\n        self.places = 6\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        self.mock_ubcalc.n_phi = matrix([[0], [0], [1]])\n\n\n    def _check(self, testname, hkl, pos, virtual_expected={}, fails=False, skip_test_pair_verification=False):\n        if not skip_test_pair_verification:\n            self._check_angles_to_hkl(\n                testname, 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                testname, 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                testname, 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def test_hkl_to_angles_given_UB(self):\n        self._check(\'I16_numeric\', [2, 0, 0.000001],\n                     posFromI16sEuler(0, 0.000029, 10.188639, 0, 20.377277, 0), fails=False)\n        self._check(\'I16_numeric\', [2, 0.000001, 0],\n                     posFromI16sEuler(0, 0, 10.188667, 0, 20.377277, 0), fails=False)\n\n\nclass TestAnglesToHkl_I16GaAsExample(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n\n        self.UB = matrix((\n           (-0.78935,   0.78234,   0.01191),\n           (-0.44391,  -0.46172,   0.90831),\n           ( 0.64431,   0.64034,   0.64039))\n            )\n\n        self.constraints._constrained = {\'qaz\': 90. * TORAD, \'alpha\': 11. * TORAD, \'mu\': 0.}\n        self.wavelength = 1.239842\n        self.places = 4\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False, skip_test_pair_verification=False):\n        if not skip_test_pair_verification:\n            self._check_angles_to_hkl(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\n                \'\', 999, 999, hkl, pos, self.wavelength, virtual_expected)\n\n    def test_hkl_to_angles_given_UB(self):\n        self._check([1., 1., 1.],\n                     posFromI16sEuler(10.7263, 89.8419, 11.0000, 0., 21.8976, 0.), fails=False)\n        self._check([0., 0., 2.],\n                     posFromI16sEuler(81.2389, 35.4478, 19.2083, 0., 25.3375, 0.), fails=False)\n\n\nclass FourCircleI21(YouGeometry):\n    """"""For a diffractometer with angles:\n          delta, eta, chi, phi\n    """"""\n    def __init__(self, beamline_axes_transform=None):\n        YouGeometry.__init__(self, \'fourc\', {\'mu\': 0, NUNAME: 0}, beamline_axes_transform)\n\n    def physical_angles_to_internal_position(self, physical_angle_tuple):\n        # mu, delta, nu, eta, chi, phi\n        delta_phys, eta_phys, chi_phys, phi_phys = physical_angle_tuple\n        return Pos(0, delta_phys, 0, eta_phys, 90 - chi_phys, phi_phys, \'DEG\')\n\n    def internal_position_to_physical_angles(self, internal_position):\n        clone_position = internal_position.clone()\n        clone_position.changeToDegrees()\n        _, delta_phys, _, eta_phys, chi_phys, phi_phys = clone_position.totuple()\n        return delta_phys, eta_phys, 90 - chi_phys, phi_phys\n\n\nclass Test_I21ExamplesUB(_BaseTest):\n    \'\'\'NOTE: copied from test.diffcalc.scenarios.session3\'\'\'\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n\n        self.i21_geometry = FourCircleI21(beamline_axes_transform = matrix(\'0 0 1; 0 1 0; 1 0 0\'))\n        settings.geometry = self.i21_geometry\n        names = [\'delta\', \'eta\', \'chi\', \'phi\']\n        self.mock_hardware = DummyHardwareAdapter(names)\n        settings.hardware = self.mock_hardware\n        self.constraints = YouConstraintManager()\n        self.calc = YouHklCalculator(self.mock_ubcalc, self.constraints)\n\n        U = matrix(((1.0,  0., 0.),\n                    (0.0, 0.18482, -0.98277),\n                    (0.0, 0.98277,  0.18482)))\n\n        B = matrix(((1.66222,     0.0,     0.0),\n                    (    0.0, 1.66222,     0.0),\n                    (    0.0,     0.0, 0.31260)))\n\n        self.UB = U * B\n\n        self.mock_hardware.set_lower_limit(\'delta\', 0)\n        self.mock_hardware.set_upper_limit(\'delta\', 180.0)\n        self.mock_hardware.set_lower_limit(\'eta\', 0)\n        self.mock_hardware.set_upper_limit(\'eta\', 150)\n        self.mock_hardware.set_lower_limit(\'chi\', -41)\n        self.mock_hardware.set_upper_limit(\'chi\', 36)\n        self.mock_hardware.set_lower_limit(\'phi\', -100)\n        self.mock_hardware.set_upper_limit(\'phi\', 100)\n        self.mock_hardware.set_cut(\'eta\', 0)\n        self.mock_hardware.set_cut(\'phi\', -180)\n        self.constraints._constrained = {\'psi\': 10 * TORAD, \'mu\': 0, NUNAME: 0}\n        self.wavelength = 12.39842 / .650\n        self.places = 5\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        self.mock_ubcalc.n_phi = matrix([[0], [0.], [1.]])\n\n    def makes_cases(self, zrot, yrot):\n        del zrot, yrot  # not used\n        self.cases = (\n            Pair(\'0_0.2_0.25\', (0.0, 0.2, 0.25),\n                 Pos(mu=0, delta=62.44607, nu=0, eta=28.68407,\n                     chi=90.0 - 0.44753, phi=-9.99008, unit=\'DEG\')),\n            Pair(\'0.25_0.2_0.1\', (0.25, 0.2, 0.1),\n                 Pos(mu=0, delta=108.03033, nu=0, eta=3.03132,\n                     chi=90 - 7.80099, phi=87.95201, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def case_generator(self):\n        zrot, yrot = 999, 999\n        for case in self.cases:\n            yield (self._check_angles_to_hkl, case.name, zrot, yrot, case.hkl,\n                   case.position, self.wavelength, {})\n            test_method = (self._check_hkl_to_angles_fails if case.fails else\n                           self._check_hkl_to_angles)\n            yield (test_method, case.name, zrot, yrot, case.hkl, case.position,\n                   self.wavelength, {})\n\n    def test_hkl_to_angles_given_UB(self):\n        self.makes_cases(None, None)  # xrot, yrot unused\n        for case_tuple in self.case_generator():\n            yield case_tuple\n\nclass SkipTest_FixedAlphaMuChiSurfaceNormalHorizontal(_BaseTest):\n    \'\'\'NOTE: copied from test.diffcalc.scenarios.session3\'\'\'\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n\n        U = matrix(((-0.71022,  0.70390, 0.01071),\n                    (-0.39941, -0.41543, 0.81725),\n                    (0.57971, 0.57615,  0.57618)))\n\n        B = matrix(((1.11143,     0.0,     0.0),\n                    (    0.0, 1.11143,     0.0),\n                    (    0.0,     0.0, 1.11143)))\n\n        self.UB = U * B\n\n        self.constraints._constrained = {\'alpha\': 12., \'mu\': 0, \'chi\': 0}\n        self.wavelength = 1.\n        self.places = 5\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n        self.mock_ubcalc.n_phi = matrix([[0.], [0.], [1.]])\n\n    def makes_cases(self, zrot, yrot):\n        del zrot, yrot  # not used\n        self.cases = (\n            Pair(\'0_0_0.25\', (2.0, 2.0,  0.),\n                 Pos(mu=0, delta=79.85393, nu=0, eta=39.92540,\n                     chi=90.0, phi=0.0, unit=\'DEG\')),\n            #Pair(\'0.25_0.25_0\', (0.25, 0.25, 0.0),\n            #     Pos(mu=0, delta=27.352179, nu=0, eta=13.676090,\n            #         chi=37.774500, phi=53.965500, unit=\'DEG\')),\n            )\n        self.case_dict = {}\n        for case in self.cases:\n            self.case_dict[case.name] = case\n\n    def case_generator(self):\n        zrot, yrot = 999, 999\n        for case in self.cases:\n            yield (self._check_angles_to_hkl, case.name, zrot, yrot, case.hkl,\n                   case.position, self.wavelength, {})\n            test_method = (self._check_hkl_to_angles_fails if case.fails else\n                           self._check_hkl_to_angles)\n            yield (test_method, case.name, zrot, yrot, case.hkl, case.position,\n                   self.wavelength, {})\n\n    def test_hkl_to_angles_given_UB(self):\n        self.makes_cases(None, None)  # xrot, yrot unused\n        for case_tuple in self.case_generator():\n            yield case_tuple\n'"
test/diffcalc/hkl/you/test_calc_methods.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\nimport math\nfrom math import pi, sin, cos\nfrom nose.plugins.skip import SkipTest\nfrom nose.tools import assert_almost_equal, raises, eq_  # @UnresolvedImport\nfrom mock import Mock\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hkl.you.calc import YouHklCalculator, I, \\\n    _calc_angle_between_naz_and_qaz\nfrom test.tools import  assert_array_almost_equal, \\\n    assert_matrix_almost_equal\nfrom diffcalc.hkl.you.geometry  import YouPosition, SixCircle\n\nfrom test.diffcalc.hkl.you.test_calc import createMockHardwareMonitor, createMockUbcalc\nfrom diffcalc.util import DiffcalcException\n\nfrom diffcalc.settings import NUNAME\n\nTORAD = pi / 180\nTODEG = 180 / pi\n\nx = matrix(\'1; 0; 0\')\ny = matrix(\'0; 1; 0\')\nz = matrix(\'0; 0; 1\')\n\n\ndef isnan(n):\n    # math.isnan was introduced only in python 2.6 and is not in Jython (2.5.2)\n    try:\n        return math.isnan(n)\n    except AttributeError:\n        return n != n  # for Jython\n\n\nclass Test_anglesToVirtualAngles():\n\n    def setup_method(self):\n        constraints = Mock()\n        constraints.is_fully_constrained.return_value = True\n        settings.hardware = createMockHardwareMonitor()\n        settings.geometry = SixCircle()\n        self.calc = YouHklCalculator(createMockUbcalc(None), constraints)\n\n    def check_angle(self, name, expected, mu=-99, delta=99, nu=99,\n                     eta=99, chi=99, phi=99):\n        """"""All in degrees""""""\n        pos = YouPosition(mu, delta, nu, eta, chi, phi, unit=\'DEG\')\n        pos.changeToRadians()\n        calculated = self.calc._anglesToVirtualAngles(pos, None)[name] * TODEG\n        assert_almost_equal(calculated, expected)\n\n    # theta\n\n    def test_theta0(self):\n        self.check_angle(\'theta\', 0, delta=0, nu=0)\n\n    def test_theta1(self):\n        self.check_angle(\'theta\', 1, delta=2, nu=0)\n\n    def test_theta2(self):\n        self.check_angle(\'theta\', 1, delta=0, nu=2)\n\n    def test_theta3(self):\n        self.check_angle(\'theta\', 1, delta=-2, nu=0)\n\n    def test_theta4(self):\n        self.check_angle(\'theta\', 1, delta=0, nu=-2)\n\n    # qaz\n\n    def test_qaz0_degenerate_case(self):\n        self.check_angle(\'qaz\', 0, delta=0, nu=0)\n\n    def test_qaz1(self):\n        self.check_angle(\'qaz\', 90, delta=2, nu=0)\n\n    def test_qaz2(self):\n        self.check_angle(\'qaz\', 90, delta=90, nu=0)\n\n    def test_qaz3(self):\n        self.check_angle(\'qaz\', 0, delta=0, nu=1,)\n\n    # Can\'t see one by eye\n    # def test_qaz4(self):\n    #    pos = YouPosition(delta=20*TORAD, nu=20*TORAD)#.inRadians()\n    #    assert_almost_equal(\n    #        self.calc._anglesToVirtualAngles(pos, None)[\'qaz\']*TODEG, 45)\n\n    #alpha\n    def test_defaultReferenceValue(self):\n        # The following tests depemd on this\n        assert_matrix_almost_equal(self.calc._ubcalc.n_phi, matrix([[0], [0], [1]]))\n\n    def test_alpha0(self):\n        self.check_angle(\'alpha\', 0, mu=0, eta=0, chi=0, phi=0)\n\n    def test_alpha1(self):\n        self.check_angle(\'alpha\', 0, mu=0, eta=0, chi=0, phi=10)\n\n    def test_alpha2(self):\n        self.check_angle(\'alpha\', 0, mu=0, eta=0, chi=0, phi=-10)\n\n    def test_alpha3(self):\n        self.check_angle(\'alpha\', 2, mu=2, eta=0, chi=0, phi=0)\n\n    def test_alpha4(self):\n        self.check_angle(\'alpha\', -2, mu=-2, eta=0, chi=0, phi=0)\n\n    def test_alpha5(self):\n        self.check_angle(\'alpha\', 2, mu=0, eta=90, chi=2, phi=0)\n\n    #beta\n\n    def test_beta0(self):\n        self.check_angle(\'beta\', 0, delta=0, nu=0, mu=0, eta=0, chi=0, phi=0)\n\n    def test_beta1(self):\n        self.check_angle(\'beta\', 0, delta=10, nu=0, mu=0, eta=6, chi=0, phi=5)\n\n    def test_beta2(self):\n        self.check_angle(\'beta\', 10, delta=0, nu=10, mu=0, eta=0, chi=0, phi=0)\n\n    def test_beta3(self):\n        self.check_angle(\'beta\', -10, delta=0, nu=-10, mu=0, eta=0, chi=0,\n                         phi=0)\n\n    def test_beta4(self):\n        self.check_angle(\'beta\', 5, delta=0, nu=10, mu=5, eta=0, chi=0, phi=0)\n\n    # azimuth\n    def test_naz0(self):\n        self.check_angle(\'naz\', 0, mu=0, eta=0, chi=0, phi=0)\n\n    def test_naz1(self):\n        self.check_angle(\'naz\', 0, mu=0, eta=0, chi=0, phi=10)\n\n    def test_naz3(self):\n        self.check_angle(\'naz\', 0, mu=10, eta=0, chi=0, phi=10)\n\n    def test_naz4(self):\n        self.check_angle(\'naz\', 2, mu=0, eta=0, chi=2, phi=0)\n\n    def test_naz5(self):\n        self.check_angle(\'naz\', -2, mu=0, eta=0, chi=-2, phi=0)\n\n    #tau\n    def test_tau0(self):\n        self.check_angle(\'tau\', 0, mu=0, delta=0, nu=0, eta=0, chi=0, phi=0)\n        #self.check_angle(\'tau_from_dot_product\', 90, mu=0, delta=0,\n        #nu=0, eta=0, chi=0, phi=0)\n\n    def test_tau1(self):\n        self.check_angle(\'tau\', 90, mu=0, delta=20, nu=0, eta=10, chi=0, phi=0)\n        #self.check_angle(\'tau_from_dot_product\', 90, mu=0, delta=20,\n        #nu=0, eta=10, chi=0, phi=0)\n\n    def test_tau2(self):\n        self.check_angle(\'tau\', 90, mu=0, delta=20, nu=0, eta=10, chi=0, phi=3)\n        #self.check_angle(\'tau_from_dot_product\', 90, mu=0, delta=20,\n        #nu=0, eta=10, chi=0, phi=3)\n\n    def test_tau3(self):\n        self.check_angle(\'tau\', 88, mu=0, delta=20, nu=0, eta=10, chi=2, phi=0)\n        #self.check_angle(\'tau_from_dot_product\', 88, mu=0, delta=20,\n        #nu=0, eta=10, chi=2, phi=0)\n\n    def test_tau4(self):\n        self.check_angle(\'tau\', 92, mu=0, delta=20, nu=0, eta=10, chi=-2,\n                         phi=0)\n        #self.check_angle(\'tau_from_dot_product\', 92, mu=0, delta=20,\n        #nu=0, eta=10, chi=-2, phi=0)\n\n    def test_tau5(self):\n        self.check_angle(\'tau\', 10, mu=0, delta=0, nu=20, eta=0, chi=0, phi=0)\n        #self.check_angle(\'tau_from_dot_product\', 10, mu=0, delta=0,\n        #nu=20, eta=0, chi=0, phi=0)\n\n    #psi\n\n    def test_psi0(self):\n        pos = YouPosition(0, 0, 0, 0, 0, 0, \'DEG\')\n        assert isnan(self.calc._anglesToVirtualAngles(pos, None)[\'psi\'])\n\n    def test_psi1(self):\n        self.check_angle(\'psi\', 90, mu=0, delta=11, nu=0, eta=0, chi=0, phi=0)\n\n    def test_psi2(self):\n        self.check_angle(\n            \'psi\', 100, mu=10, delta=.001, nu=0, eta=0, chi=0, phi=0)\n\n    def test_psi3(self):\n        self.check_angle(\n            \'psi\', 80, mu=-10, delta=.001, nu=0, eta=0, chi=0, phi=0)\n\n    def test_psi4(self):\n        self.check_angle(\n            \'psi\', 90, mu=0, delta=11, nu=0, eta=0, chi=0, phi=12.3)\n\n    def test_psi5(self):\n        #self.check_angle(\'psi\', 0, mu=10, delta=.00000001,\n        #nu=0, eta=0, chi=90, phi=0)\n        pos = YouPosition(0, 0, 0, 0, 90, 0, \'DEG\')\n        pos.changeToRadians()\n        assert isnan(self.calc._anglesToVirtualAngles(pos, None)[\'psi\'])\n\n    def test_psi6(self):\n        self.check_angle(\n            \'psi\', 90, mu=0, delta=0.001, nu=0, eta=90, chi=0, phi=0)\n\n    def test_psi7(self):\n        self.check_angle(\n            \'psi\', 92, mu=0, delta=0.001, nu=0, eta=90, chi=2, phi=0)\n\n    def test_psi8(self):\n        self.check_angle(\n            \'psi\', 88, mu=0, delta=0.001, nu=0, eta=90, chi=-2, phi=0)\n\n\nclass Test_calc_theta():\n\n    def setup_method(self):\n        settings.hardware = createMockHardwareMonitor()\n        settings.geometry = SixCircle()\n        self.calc = YouHklCalculator(createMockUbcalc(I * 2 * pi),\n                                     Mock())\n        self.e = 12.398420  # 1 Angstrom\n\n    def test_100(self):\n        h_phi = matrix([[1], [0], [0]])\n        assert_almost_equal(self.calc._calc_theta(h_phi * 2 * pi, 1) * TODEG,\n                            30)\n\n    @raises(DiffcalcException)\n    def test_too_short(self):\n        h_phi = matrix([[1], [0], [0]])\n        self.calc._calc_theta(h_phi * 0, 1)\n\n    @raises(DiffcalcException)\n    def test_too_long(self):\n        h_phi = matrix([[1], [0], [0]])\n        self.calc._calc_theta(h_phi * 2 * pi, 10)\n\n\nclass Test_calc_remaining_reference_angles_given_one():\n\n    # TODO: These are very incomplete due to either totally failing inutuition\n    #       or code!\n    def setup_method(self):\n        settings.hardware = createMockHardwareMonitor()\n        settings.geometry = SixCircle()\n        self.calc = YouHklCalculator(createMockUbcalc(None),\n                                     Mock())\n\n    def check(self, name, value, theta, tau, psi_e, alpha_e, beta_e, places=7):\n        # all in deg\n        alpha, beta = self.calc._calc_remaining_reference_angles(\n            name, value * TORAD, theta * TORAD, tau * TORAD)\n        if alpha_e is not None:\n            assert_almost_equal(alpha * TODEG, alpha_e, places)\n        if beta_e is not None:\n            assert_almost_equal(beta * TODEG, beta_e, places)\n        psi_vals = list(self.calc._calc_psi(alpha, theta * TORAD, tau * TORAD))\n        if psi_e is not None:\n            assert_array_almost_equal(sorted([v * TODEG for v in psi_vals]), sorted(psi_e))\n        for psi in psi_vals:\n            print \'psi\', psi * TODEG, \' alpha:\', alpha * TODEG,\\\n                  \' beta:\', beta * TODEG\n\n    def test_psi_given0(self):\n        self.check(\'psi\', 90, theta=10, tau=90, psi_e=[-90, 90],\n                    alpha_e=0, beta_e=0)\n\n    def test_psi_given1(self):\n        self.check(\'psi\', 92, theta=0.001, tau=90, psi_e=[-92, 92],\n                    alpha_e=2, beta_e=-2)\n\n    def test_psi_given3(self):\n        self.check(\'psi\', 88, theta=0.001, tau=90, psi_e=[-88, 88],\n                    alpha_e=-2, beta_e=2)\n\n    def test_psi_given4(self):\n        self.check(\'psi\', 0, theta=0.001, tau=90, psi_e=[0,],\n                    alpha_e=-90, beta_e=90, places=2)\n\n    def test_psi_given4a(self):\n        self.check(\'psi\', 180, theta=0.001, tau=90, psi_e=[-180, 180],\n                    alpha_e=90, beta_e=-90, places=2)\n\n    def test_psi_given5(self):\n        self.check(\'psi\', 180, theta=0.001, tau=80,\n                   psi_e=[-180, 180], alpha_e=80, beta_e=-80, places=2)\n\n    def test_a_eq_b0(self):\n        self.check(\'a_eq_b\', 9999, theta=0.001, tau=90,\n                   psi_e=[-90, 90], alpha_e=0, beta_e=0)\n\n    def test_alpha_given(self):\n        self.check(\'alpha\', 2, theta=0.001, tau=90,\n                   psi_e=[-92, 92], alpha_e=2, beta_e=-2)\n\n    def test_beta_given(self):\n        self.check(\'beta\', 2, theta=0.001, tau=90,\n                   psi_e=[-88, 88], alpha_e=-2, beta_e=2)\n#    def test_a_eq_b1(self):\n#        self.check(\'a_eq_b\', 9999, theta=20, tau=90,\n#                   psi_e=90, alpha_e=10, beta_e=10)\n\n#    def test_psi_given0(self):\n#        self.check(\'psi\', 90, theta=10, tau=45, psi_e=90,\n#                    alpha_e=7.0530221302831952, beta_e=7.0530221302831952)\n    \nclass Test_calc_detector_angles_given_one():\n\n    def setup_method(self):\n        settings.hardware = createMockHardwareMonitor()\n        settings.geometry = SixCircle()\n        self.calc = YouHklCalculator(createMockUbcalc(None),\n                                     Mock())\n\n    def check(self, name, value, theta, delta_e, nu_e, qaz_e):\n        # all in deg\n        delta, nu, qaz = zip(*self.calc._calc_remaining_detector_angles(\n            name, value * TORAD, theta * TORAD))\n        for delta_, nu_, qaz_ in zip(delta, nu, qaz):\n            print \'delta:\', delta_ * TODEG, \' nu:\', nu_ * TODEG, \' qaz:\', qaz_ * TODEG\n        assert_array_almost_equal([v * TODEG for v in delta], delta_e)\n        assert_array_almost_equal([v * TODEG for v in nu], nu_e)\n        if qaz_e is not None:\n            assert_array_almost_equal([v * TODEG for v in qaz], qaz_e)\n\n    def test_nu_given0(self):\n        self.check(NUNAME, 0, theta=3, delta_e=[6, -6], nu_e=[0, 0], qaz_e=[90, -90])\n\n    def test_nu_given1(self):\n        self.check(NUNAME, 10, theta=7.0530221302831952,\n                   delta_e=[10, -10], nu_e=[10, 10], qaz_e=None)\n\n    def test_nu_given2(self):\n        self.check(NUNAME, 6, theta=3, delta_e=[0,], nu_e=[6,], qaz_e=[0,])\n\n    def test_delta_given0(self):\n        self.check(\'delta\', 0, theta=3, delta_e=[0, 0], nu_e=[6, -6], qaz_e=[0, 180])\n\n    def test_delta_given1(self):\n        self.check(\'delta\', 10, theta=7.0530221302831952,\n                   delta_e=[10, 10], nu_e=[10, -10], qaz_e=None)\n\n    def test_delta_given2(self):\n        self.check(\'delta\', 6, theta=3, delta_e=[6,], nu_e=[0,], qaz_e=[90,])\n\n    def test_qaz_given0(self):\n        self.check(\'qaz\', 90, theta=3, delta_e=[6, 174], nu_e=[0, -180], qaz_e=[90, 90])\n\n    def test_qaz_given2(self):\n        self.check(\'qaz\', 0, theta=3, delta_e=[0, 180], nu_e=[6, -174], qaz_e=[0, 0])\n\n\nclass Test_calc_angle_between_naz_and_qaz():\n\n    def test1(self):\n        diff = _calc_angle_between_naz_and_qaz(\n            theta=0, alpha=0, tau=90 * TORAD)\n        assert_almost_equal(diff * TODEG, 90)\n\n    def test2(self):\n        diff = _calc_angle_between_naz_and_qaz(\n            theta=0 * TORAD, alpha=0, tau=80 * TORAD)\n        assert_almost_equal(diff * TODEG, 80)\n\n\nclass Test_calc_remaining_sample_angles_given_one():\n    #_calc_remaining_detector_angles_given_one\n    def setup_method(self):\n        settings.hardware = createMockHardwareMonitor()\n        settings.geometry = SixCircle()\n        self.calc = YouHklCalculator(createMockUbcalc(None),\n                                     Mock())\n\n    def check(self, name, value, Q_lab, n_lab, Q_phi, n_phi,\n              phi_e, chi_e, eta_e, mu_e):\n        mu, eta, chi, phi = zip(*self.calc._calc_remaining_sample_angles(\n                            name, value * TORAD, Q_lab, n_lab, Q_phi, n_phi))\n        for  mu_, eta_, chi_, phi_ in zip(mu, eta, chi, phi):\n            print \'phi\', phi_ * TODEG, \' chi:\', chi_ * TODEG, \' eta:\', eta_ * TODEG,\\\n                  \' mu:\', mu_ * TODEG\n        if phi_e is not None:\n            assert_array_almost_equal([v * TODEG for v in phi], phi_e)\n        if chi_e is not None:\n            assert_array_almost_equal([v * TODEG for v in chi], chi_e)\n        if eta_e is not None:\n            assert_array_almost_equal([v * TODEG for v in eta], eta_e)\n        if mu_e is not None:\n            assert_array_almost_equal([v * TODEG for v in mu], mu_e)\n\n    def test_constrain_xx_degenerate(self):\n        self.check(\'mu\', 0, Q_lab=x, n_lab=x, Q_phi=x, n_phi=x,\n                    phi_e=[0,], chi_e=[0,], eta_e=[0,], mu_e=[0,])\n\n    def test_constrain_mu_0(self):\n        self.check(\'mu\', 0, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[0,], chi_e=[0,], eta_e=[0,], mu_e=[0,])\n\n    def test_constrain_mu_10(self):\n        self.check(\'mu\', 10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[90, -90], chi_e=[10, -10], eta_e=[-90, 90], mu_e=[10, 10])\n\n    def test_constrain_mu_n10(self):\n        self.check(\'mu\', -10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[-90, 90], chi_e=[10, -10], eta_e=[90, -90], mu_e=[-10, -10])\n\n    def test_constrain_eta_10_wasfailing(self):\n        # Required the choice of a different equation\n        self.check(\'eta\', 10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[-10, -170], chi_e=[0, 180], eta_e=[10, 10], mu_e=[0, -180])\n\n    def test_constrain_eta_n10(self):\n        self.check(\'eta\', -10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[10, 170], chi_e=[0, 180], eta_e=[-10, -10], mu_e=[0, 180])\n\n    def test_constrain_eta_20_with_theta_20(self):\n        theta = 20 * TORAD\n        Q_lab = matrix([[cos(theta)], [-sin(theta)], [0]])\n        self.check(\'eta\', 20, Q_lab=Q_lab, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[0, -140], chi_e=[0, 180], eta_e=[20, 20], mu_e=[0, -180])\n\n    @raises(DiffcalcException)\n    def test_constrain_chi_0_degenerate(self):\n        self.check(\'chi\', 0, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=0, chi_e=0, eta_e=0, mu_e=0)\n\n    def test_constrain_chi_10(self):\n        self.check(\'chi\', 10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[-90, 90], chi_e=[10, 10], eta_e=[90, -90], mu_e=[-10, 10])\n\n    @raises(DiffcalcException)\n    def test_constrain_chi_90(self):\n        self.check(\'chi\', 90, Q_lab=z * (-1), n_lab=x, Q_phi=x, n_phi=z,\n                    phi_e=[0, 0], chi_e=[90, 90], eta_e=[0, 0], mu_e=[-180, 0])\n\n    def test_constrain_phi_0(self):\n        self.check(\'phi\', 0, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[0, 0], chi_e=[0, -180], eta_e=[0, 180], mu_e=[0, -180])\n\n    def test_constrain_phi_10(self):\n        self.check(\'phi\', 10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[10, 10], chi_e=[0, -180], eta_e=[-10, 190], mu_e=[0, -180])\n\n    def test_constrain_phi_n10(self):\n        self.check(\'phi\', -10, Q_lab=x, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[-10, -10], chi_e=[0, -180], eta_e=[10, 170], mu_e=[0, -180])\n\n    def test_constrain_phi_20_with_theta_20(self):\n        theta = 20 * TORAD\n        Q_lab = matrix([[cos(theta)], [-sin(theta)], [0]])\n        self.check(\'phi\', 20, Q_lab=Q_lab, n_lab=z, Q_phi=x, n_phi=z,\n                    phi_e=[20, 20], chi_e=[0, -180], eta_e=[0, 180], mu_e=[0, -180])\n\n'"
test/diffcalc/hkl/you/test_calc_surface.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n# TODO: class largely copied from test_calc\n\nfrom math import pi\nfrom mock import Mock\nfrom nose.plugins.skip import SkipTest\nfrom diffcalc import settings\n\ntry:\n    from numpy import matrix\nexcept ImportError:\n    from numjy import matrix\n\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc.hkl.willmott.calc import \\\n    WillmottHorizontalPosition as WillPos\nfrom diffcalc.hkl.you.geometry import YouPosition as YouPos\nfrom diffcalc.hkl.you.calc import YouUbCalcStrategy\nfrom test.tools import matrixeq_\nfrom diffcalc.ub.calc import UBCalculation\nfrom diffcalc.ub.crystal import CrystalUnderTest\nfrom diffcalc.ub.persistence import UbCalculationNonPersister\nfrom test.diffcalc.hkl.you.test_calc import _BaseTest\nfrom diffcalc.settings import NUNAME\n\nTORAD = pi / 180\nTODEG = 180 / pi\nI = matrix(\'1 0 0; 0 1 0; 0 0 1\')\n\n\nclass SkipTestSurfaceNormalVerticalCubic(_BaseTest):\n\n    def setup_method(self):\n\n        _BaseTest.setup_method(self)\n        self.constraints._constrained = {\'a_eq_b\': None, \'mu\': -pi / 2,\n                                         \'eta\': 0}\n        self.wavelength = 1\n        self.UB = I * 2 * pi\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        if pos is not None:\n            self._check_angles_to_hkl(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\'\', 999, 999, hkl, pos,\n                                            self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n\n    def testHkl001(self):\n        pos = YouPos(mu=-90, delta=60, nu=0, eta=0, chi=90 + 30, phi=-90, unit=\'DEG\')\n        self._check((0, 0, 1), pos, {\'alpha\': 30, \'beta\': 30})\n\n    def testHkl011(self):\n        # raise SkipTest()\n        # skipped because we can\'t calculate values to check against by hand\n        pos = YouPos(mu=-90, delta=90, nu=0, eta=0, chi=90 + 90, phi=-90, unit=\'DEG\')\n        self._check((0, 1, 1), pos, {\'alpha\': 45, \'beta\': 45})\n\n    def testHkl010fails(self):\n        self._check((0, 1, 0),\n                    None,\n                    {\'alpha\': 30, \'beta\': 30}, fails=True)\n\n    def testHkl100fails(self):\n        self._check((1, 0, 0),\n                    None,\n                    {\'alpha\': 30, \'beta\': 30}, fails=True)\n\n    def testHkl111(self):\n        raise SkipTest()\n        # skipped because we can\'t calculate values to check against by hand\n        pos = YouPos(mu=-90, delta=90, nu=0, eta=0, chi=90 + 90, phi=-90, unit=\'DEG\')\n        self._check((1, 1, 1), pos, {\'alpha\': 45, \'beta\': 45})\n\n\n# Primary and secondary reflections found with the help of DDIF on Diamond\'s\n# i07 on Jan 27 2010\n\n\nHKL0 = 2, 19, 32\nREF0 = WillPos(delta=21.975, gamma=4.419, omegah=2, phi=326.2)\n\nHKL1 = 0, 7, 22\nREF1 = WillPos(delta=11.292, gamma=2.844, omegah=2, phi=124.1)\n\nWAVELENGTH = 0.6358\nENERGY = 12.39842 / WAVELENGTH\n\n\n# This is the version that Diffcalc comes up with ( see following test)\nU_DIFFCALC = matrix([[-0.7178876, 0.6643924, -0.2078944],\n                     [-0.6559596, -0.5455572, 0.5216170],\n                     [0.2331402, 0.5108327, 0.8274634]])\n\n\n#class WillmottHorizontalGeometry(VliegGeometry):\n#\n#    def __init__(self):\n#        VliegGeometry.__init__(self,\n#                    name=\'willmott_horizontal\',\n#                    supported_mode_groups=[],\n#                    fixed_parameters={},\n#                    gamma_location=\'base\'\n#                    )\n#\n#    def physical_angles_to_internal_position(self, physicalAngles):\n#        assert (len(physicalAngles) == 4), ""Wrong length of input list""\n#        return WillPos(*physicalAngles)\n#\n#    def internal_position_to_physical_angles(self, internalPosition):\n#        return internalPosition.totuple()\n\ndef willmott_to_you_fixed_mu_eta(pos):\n    pos = YouPos(mu=-90,\n                       delta=pos.delta,\n                       nu=pos.gamma,\n                       eta=0,\n                       chi=90 + pos.omegah,\n                       phi=-90 - pos.phi,\n                       unit=\'DEG\')\n\n    if pos.phi > 180:\n        pos.phi -= 360\n    elif pos.phi < -180:\n        pos.phi += 360\n    return pos\n\n\nclass TestUBCalculationWithWillmotStrategy_Si_5_5_12_FixedMuEta():\n\n    def setup_method(self):\n\n        hardware = Mock()\n        hardware.get_axes_names.return_value = (\'m\', \'d\', \'n\', \'e\', \'c\',\n                                                       \'p\')\n        settings.hardware = hardware\n        settings.geometry = SixCircle()\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    YouUbCalcStrategy())\n\n    def testAgainstResultsFromJan_27_2010(self):\n        self.ubcalc.start_new(\'test\')\n        self.ubcalc.set_lattice(\'Si_5_5_12\', 7.68, 53.48, 75.63, 90, 90, 90)\n        self.ubcalc.add_reflection(\n            HKL0[0], HKL0[1], HKL0[2], willmott_to_you_fixed_mu_eta(REF0),\n            ENERGY, \'ref0\', None)\n        self.ubcalc.add_reflection(\n            HKL1[0], HKL1[1], HKL1[2], willmott_to_you_fixed_mu_eta(REF1),\n            ENERGY, \'ref1\', None)\n        self.ubcalc.calculate_UB()\n        print ""U: "", self.ubcalc.U\n        print ""UB: "", self.ubcalc.UB\n        matrixeq_(self.ubcalc.U, U_DIFFCALC)\n\n\nclass TestFixedMuEta(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self._configure_constraints()\n        self.wavelength = 0.6358\n        B = CrystalUnderTest(\'xtal\', 7.68, 53.48,\n                             75.63, 90, 90, 90).B\n        self.UB = U_DIFFCALC * B\n        self._configure_limits()\n\n    def _configure_constraints(self):\n        self.constraints._constrained = {\'alpha\': 2 * TORAD, \'mu\': -pi / 2,\n                                         \'eta\': 0}\n\n    def _configure_limits(self):\n        self.mock_hardware.set_lower_limit(NUNAME, None)\n        self.mock_hardware.set_upper_limit(\'delta\', 90)\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _convert_willmott_pos(self, willmott_pos):\n        return  willmott_to_you_fixed_mu_eta(willmott_pos)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\'\', 999, 999, hkl, pos, self.wavelength,\n                                  virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\'\', 999, 999, hkl, pos,\n                                            self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n\n    def testHkl_2_19_32_found_orientation_setting(self):\n        \'\'\'Check that the or0 reflection maps back to the assumed hkl\'\'\'\n        self.places = 2\n        self._check_angles_to_hkl(\'\', 999, 999, HKL0,\n                        self._convert_willmott_pos(REF0),\n                        self.wavelength, {\'alpha\': 2})\n\n    def testHkl_0_7_22_found_orientation_setting(self):\n        \'\'\'Check that the or1 reflection maps back to the assumed hkl\'\'\'\n        self.places = 0\n        self._check_angles_to_hkl(\'\', 999, 999, HKL1,\n                        self._convert_willmott_pos(REF1),\n                        self.wavelength, {\'alpha\': 2})\n\n    def testHkl_2_19_32_calculated_from_DDIF(self):\n        self.places = 3\n        willpos = WillPos(delta=21.974, gamma=4.419, omegah=2, phi=-33.803)\n        self._check((2, 19, 32),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_0_7_22_calculated_from_DDIF(self):\n        self.places = 3\n        willpos = WillPos(delta=11.241801854649, gamma=-3.038407637123,\n                          omegah=2, phi=-86.56344250267)\n        self._check((0, 7, 22),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_2_m5_12_calculated_from_DDIF(self):\n        self.places = 3\n        willpos = WillPos(delta=5.224, gamma=10.415, omegah=2, phi=-1.972)\n        self._check((2, -5, 12),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_2_19_32_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=21.974032376045, gamma=4.418955754003,\n                          omegah=2, phi=-33.80254)\n        self._check((2, 19, 32),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_0_7_22_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=11.241801854649, gamma=-3.038407637123,\n                          omegah=2, phi=-86.563442502670)\n        self._check((0, 7, 22),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_2_m5_12_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=5.223972025344, gamma=10.415435905622,\n                          omegah=2, phi=-90 + 88.02751)\n        self._check((2, -5, 12),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n\n###############################################################################\n\ndef willmott_to_you_fixed_mu_chi(pos):\n    pos = YouPos(mu=-0,\n                       delta=pos.delta,\n                       nu=pos.gamma,\n                       eta=pos.omegah,\n                       chi=90,\n                       phi=-pos.phi,\n                       unit=\'DEG\')\n    if pos.phi > 180:\n        pos.phi -= 360\n    elif pos.phi < -180:\n        pos.phi += 360\n    return pos\n\n\nclass TestUBCalculationWithWillmotStrategy_Si_5_5_12_FixedMuChi():\n\n    def setup_method(self):\n\n        hardware = Mock()\n        names = \'m\', \'d\', \'n\', \'e\', \'c\', \'p\'\n        hardware.get_axes_names.return_value = names\n        settings.hardware = hardware\n        settings.geometry = SixCircle()\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    YouUbCalcStrategy())\n\n    def testAgainstResultsFromJan_27_2010(self):\n        self.ubcalc.start_new(\'test\')\n        self.ubcalc.set_lattice(\'Si_5_5_12\', 7.68, 53.48, 75.63, 90, 90, 90)\n        self.ubcalc.add_reflection(\n            HKL0[0], HKL0[1], HKL0[2], willmott_to_you_fixed_mu_chi(REF0),\n            ENERGY, \'ref0\', None)\n        self.ubcalc.add_reflection(\n            HKL1[0], HKL1[1], HKL1[2], willmott_to_you_fixed_mu_chi(REF1),\n            ENERGY, \'ref1\', None)\n        self.ubcalc.calculate_UB()\n        print ""U: "", self.ubcalc.U\n        print ""UB: "", self.ubcalc.UB\n        matrixeq_(self.ubcalc.U, U_DIFFCALC)\n\n\nclass Test_Fixed_Mu_Chi(TestFixedMuEta):\n\n    def _configure_constraints(self):\n        self.constraints._constrained = {\'alpha\': 2 * TORAD, \'mu\': 0,\n                                         \'chi\': pi / 2}\n\n    def _convert_willmott_pos(self, willmott_pos):\n        return  willmott_to_you_fixed_mu_chi(willmott_pos)\n\n\ndef willmott_to_you_fixed_eta_chi(pos):\n    pos = YouPos(mu=pos.omegah,\n                       delta=-pos.gamma,\n                       nu=pos.delta,\n                       eta=0,\n                       chi=0,\n                       phi=-pos.phi,\n                       unit=\'DEG\')\n    if pos.phi > 180:\n        pos.phi -= 360\n    elif pos.phi < -180:\n        pos.phi += 360\n    return pos\n\n\nclass Test_Fixed_Eta_Chi(TestFixedMuEta):\n\n    def _configure_constraints(self):\n        self.constraints._constrained = {\'alpha\': 2 * TORAD, \'eta\': 0,\n                                         \'chi\': 0}\n\n    def _convert_willmott_pos(self, willmott_pos):\n        return  willmott_to_you_fixed_eta_chi(willmott_pos)\n\n    def testHkl_2_19_32_found_orientation_setting(self):\n        SkipTest()\n\n    def testHkl_0_7_22_found_orientation_setting(self):\n        SkipTest()\n\n    def testHkl_2_19_32_calculated_from_DDIF(self):\n        SkipTest()\n\n    def testHkl_0_7_22_calculated_from_DDIF(self):\n        SkipTest()\n\n    def testHkl_2_m5_12_calculated_from_DDIF(self):\n        SkipTest()\n\n    def testHkl_2_19_32_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=22.0332862, gamma=-4.0973643,\n                          omegah=2, phi=--64.0273584)\n        self._check((2, 19, 32),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_0_7_22_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=11.2572236, gamma=-2.9800571,\n                          omegah=2, phi=-86.5634425)\n        self._check((0, 7, 22),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n    def testHkl_2_m5_12_calculated_predicted_with_diffcalc_and_found(self):\n        willpos = WillPos(delta=5.3109941, gamma=-10.3716944,\n                          omegah=2, phi=167.0041454)\n        self._check((2, -5, 12),\n                    self._convert_willmott_pos(willpos),\n                    {\'alpha\': 2})\n\n# Primary and secondary reflections found with the help of DDIF on Diamond\'s\n# i07 on Jan 28/29 2010\n\n\nPt531_HKL0 = -1.000, 1.000, 6.0000\nPt531_REF0 = WillPos(delta=9.3971025, gamma=16.1812303, omegah=2,\n                                  phi=-52.1392905)\n\nPt531_HKL1 = -2.000, -1.000, 7.0000\nPt531_REF1 = WillPos(delta=11.0126958, gamma=-11.8636128, omegah=2,\n                                  phi=40.3803393)\nPt531_REF12 = WillPos(delta=11.0126958, gamma=11.8636128, omegah=2,\n                                  phi=-121.2155975)\nPt531_HKL2 = 1, 1, 9\nPt531_REF2 = WillPos(delta=14.1881617, gamma=7.7585939, omegah=2,\n                                  phi=23.0203132)\nPt531_REF22 = WillPos(delta=14.1881617, gamma=-7.7585939, omegah=2,\n                                  phi=-183.465146)\nPt531_WAVELENGTH = 0.6358\n\n# This is U matrix displayed by DDIF\nU_FROM_DDIF = matrix([[-0.00312594, -0.00063417, 0.99999491],\n                      [0.99999229, -0.00237817, 0.00312443],\n                      [0.00237618, 0.99999697, 0.00064159]])\n\n# This is the version that Diffcalc comes up with ( see following test)\nPt531_U_DIFFCALC = matrix([[-0.0023763, -0.9999970, -0.0006416],\n                           [0.9999923, -0.0023783, 0.0031244],\n                           [-0.0031259, -0.0006342, 0.9999949]])\n\n\nclass TestUBCalculationWithYouStrategy_Pt531_FixedMuChi():\n\n    def setup_method(self):\n\n        hardware = Mock()\n        names = \'m\', \'d\', \'n\', \'e\', \'c\', \'p\'\n        hardware.get_axes_names.return_value = names\n        settings.hardware = hardware\n        settings.geometry = SixCircle()\n        self.ubcalc = UBCalculation(UbCalculationNonPersister(),\n                                    YouUbCalcStrategy())\n\n    def testAgainstResultsFromJan_28_2010(self):\n        self.ubcalc.start_new(\'test\')\n        self.ubcalc.set_lattice(\'Pt531\', 6.204, 4.806, 23.215, 90, 90, 49.8)\n\n        self.ubcalc.add_reflection(Pt531_HKL0[0], Pt531_HKL0[1], Pt531_HKL0[2],\n                                  willmott_to_you_fixed_mu_chi(Pt531_REF0),\n                                  12.39842 / Pt531_WAVELENGTH,\n                                  \'ref0\', None)\n        self.ubcalc.add_reflection(Pt531_HKL1[0], Pt531_HKL1[1], Pt531_HKL1[2],\n                                  willmott_to_you_fixed_mu_chi(Pt531_REF1),\n                                  12.39842 / Pt531_WAVELENGTH,\n                                  \'ref1\', None)\n        self.ubcalc.calculate_UB()\n        print ""U: "", self.ubcalc.U\n        print ""UB: "", self.ubcalc.UB\n        matrixeq_(self.ubcalc.U, Pt531_U_DIFFCALC)\n\n\nclass Test_Pt531_FixedMuChi(_BaseTest):\n\n    def setup_method(self):\n        _BaseTest.setup_method(self)\n        self._configure_constraints()\n        self.wavelength = Pt531_WAVELENGTH\n        CUT = CrystalUnderTest(\'Pt531\', 6.204, 4.806, 23.215, 90, 90, 49.8)\n        B = CUT.B\n        self.UB = Pt531_U_DIFFCALC * B\n        self._configure_limits()\n\n    def _configure_constraints(self):\n        self.constraints._constrained = {\'alpha\': 2 * TORAD, \'mu\': 0,\n                                         \'chi\': pi / 2}\n\n    def _configure_limits(self):\n        self.mock_hardware.set_lower_limit(NUNAME, None)\n        #self.mock_hardware.set_lower_limit(\'delta\', None)\n        self.mock_hardware.set_upper_limit(\'delta\', 90)\n        self.mock_hardware.set_lower_limit(\'mu\', None)\n        self.mock_hardware.set_lower_limit(\'eta\', None)\n        self.mock_hardware.set_lower_limit(\'chi\', None)\n\n    def _convert_willmott_pos(self, willmott_pos):\n        return  willmott_to_you_fixed_mu_chi(willmott_pos)\n\n    def _configure_ub(self):\n        self.mock_ubcalc.UB = self.UB\n\n    def _check(self, hkl, pos, virtual_expected={}, fails=False):\n        self._check_angles_to_hkl(\'\', 999, 999, hkl, pos, self.wavelength,\n                                  virtual_expected)\n        if fails:\n            self._check_hkl_to_angles_fails(\'\', 999, 999, hkl, pos,\n                                            self.wavelength, virtual_expected)\n        else:\n            self._check_hkl_to_angles(\'\', 999, 999, hkl, pos, self.wavelength,\n                                      virtual_expected)\n\n    def testHkl_0_found_orientation_setting(self):\n        \'\'\'Check that the or0 reflection maps back to the assumed hkl\'\'\'\n        self.places = 1\n        self._check_angles_to_hkl(\'\', 999, 999, Pt531_HKL0,\n                        self._convert_willmott_pos(Pt531_REF0),\n                        self.wavelength, {\'alpha\': 2})\n\n    def testHkl_1_found_orientation_setting(self):\n        \'\'\'Check that the or1 reflection maps back to the assumed hkl\'\'\'\n        self.places = 0\n        self._check_angles_to_hkl(\'\', 999, 999, Pt531_HKL1,\n                        self._convert_willmott_pos(Pt531_REF1),\n                        self.wavelength, {\'alpha\': 2})\n\n    def testHkl_0_calculated_from_DDIF(self):\n        self.places = 7\n        pos_expected = self._convert_willmott_pos(Pt531_REF0)\n        self._check(Pt531_HKL0,\n                    pos_expected,\n                    {\'alpha\': 2})\n\n    def testHkl_1_calculated_from_DDIF(self):\n        self.places = 7\n        self._check(Pt531_HKL1,\n                    self._convert_willmott_pos(Pt531_REF1),\n                    {\'alpha\': 2})\n\n    def testHkl_2_calculated_from_DDIF(self):\n        self.places = 7\n        self._check(Pt531_HKL2,\n                    self._convert_willmott_pos(Pt531_REF2),\n                    {\'alpha\': 2})\n\n    def testHkl_2_m1_0_16(self):\n        self.places = 7\n        pos = WillPos(delta=25.7990976, gamma=-6.2413545, omegah=2,\n                                  phi=47.4624380)\n#        pos.phi -= 360\n        self._check((-1, 0, 16),\n                    self._convert_willmott_pos(pos),\n                    {\'alpha\': 2})\n\n\nclass Test_Pt531_Fixed_Mu_eta_(Test_Pt531_FixedMuChi):\n\n    def _configure_constraints(self):\n        self.constraints._constrained = {\'alpha\': 2 * TORAD, \'mu\': -pi / 2,\n                                         \'eta\': 0}\n\n    def _convert_willmott_pos(self, willmott_pos):\n        return  willmott_to_you_fixed_mu_eta(willmott_pos)\n\n    def testHkl_1_calculated_from_DDIF(self):\n        self.places = 7\n        self._check(Pt531_HKL1,\n                    self._convert_willmott_pos(Pt531_REF12),\n                    {\'alpha\': 2})\n\n    def testHkl_2_calculated_from_DDIF(self):\n        self.places = 7\n        self._check(Pt531_HKL2,\n                    self._convert_willmott_pos(Pt531_REF22),\n                    {\'alpha\': 2})\n\n    def testHkl_2_m1_0_16(self):\n        self.places = 7\n        pos = WillPos(delta=25.7990976, gamma=6.2413545, omegah=2,\n                                  phi=-47.4949600)\n#        pos.phi -= 360\n        self._check((-1, 0, 16),\n                    self._convert_willmott_pos(pos),\n                    {\'alpha\': 2})\n\n'"
test/diffcalc/hkl/you/test_constraints.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n\nfrom nose.tools import eq_  # @UnresolvedImport\n\nfrom diffcalc.hkl.you.constraints import YouConstraintManager\nfrom diffcalc.util import DiffcalcException\nfrom nose.tools import raises\nfrom nose.tools import assert_raises  # @UnresolvedImport\n\nfrom diffcalc.settings import NUNAME\nimport diffcalc.util\nfrom diffcalc.hkl.you.geometry import SixCircle\nfrom diffcalc import settings\n\ndef joined(d1, d2):\n    d1.update(d2)\n    return d1\n\n\nclass TestConstraintManager:\n\n    def setup_method(self):\n        diffcalc.util.COLOURISE_TERMINAL_OUTPUT = False\n        self.cm = YouConstraintManager()\n        settings.geometry = SixCircle()\n\n    def test_init(self):\n        eq_(self.cm.all, {})\n        eq_(self.cm.detector, {})\n        eq_(self.cm.reference, {})\n        eq_(self.cm.sample, {})\n        eq_(self.cm.naz, {})\n\n    def test_build_display_table(self):\n        self.cm.constrain(\'qaz\')\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'eta\')\n        self.cm.set_constraint(\'qaz\', 1.234)\n        self.cm.set_constraint(\'eta\', 99.)\n        print \'\\n\'.join(self.cm.build_display_table_lines())\n        eq_(self.cm.build_display_table_lines(),\n            [\'    DET             REF             SAMP\',\n             \'    -----------     -----------     -----------\',\n             \'    delta           a_eq_b          mu\',\n             \'    %s      o-> alpha       --> eta\' % NUNAME.ljust(6),\n             \'--> qaz             beta            chi\',\n             \'    naz             psi             phi\',\n             \'                    bin_eq_bout     mu_is_%s\' % NUNAME,\n             \'                    betain          bisect\',\n             \'                    betaout         omega\'])\n\n\n#""""""\n#    DET        REF        SAMP                  Available:\n#    ======     ======     ======\n#    delta      a_eq_b     mu                    3x samp:         80 of 80\n#    nu     o-> alpha  --> eta                   2x samp and ref: chi & phi\n#--> qaz        beta       chi                                    mu & eta\n#    naz        psi        phi                                    chi=90 & mu=0\n#                          mu_is_nu              2x samp and det: 0 of 6\n#                                                3x samp:         0 of 4\n#""""""[1:-1]\n\n    def test_unconstrain_okay(self):\n        eq_(self.cm.all, {})\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'mu\')\n        eq_(self.cm.all, {\'delta\': None, \'mu\': None})\n        eq_(self.cm.unconstrain(\'delta\'), None)\n        eq_(self.cm.all, {\'mu\': None})\n        \n    def test_clear_constraints(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'mu\')\n        self.cm.clear_constraints()\n        eq_(self.cm.all, {})\n\n    def test_unconstrain_bad(self):\n        eq_(self.cm.all, {})\n        eq_(self.cm.unconstrain(\'delta\'), ""Delta was not already constrained."")\n\n    def test_constrain_det(self, pre={}):\n        eq_(self.cm.all, pre)\n        eq_(self.cm.constrain(\'delta\'), None)\n        eq_(self.cm.all, joined({\'delta\': None}, pre))\n        eq_(self.cm.constrain(\'delta\'), \'Delta is already constrained.\')\n        eq_(self.cm.all, joined({\'delta\': None}, pre))\n        eq_(self.cm.constrain(\'naz\'), \'Delta constraint replaced.\')\n        eq_(self.cm.all, joined({\'naz\': None}, pre))\n        eq_(self.cm.constrain(\'delta\'), \'Naz constraint replaced.\')\n        eq_(self.cm.all, joined({\'delta\': None}, pre))\n\n    def test_constrain_det_one_preexisting_ref(self):\n        self.cm.constrain(\'alpha\')\n        self.test_constrain_det({\'alpha\': None})\n\n    def test_constrain_det_one_preexisting_samp(self):\n        self.cm.constrain(\'phi\')\n        self.test_constrain_det({\'phi\': None})\n\n    def test_constrain_det_one_preexisting_samp_and_ref(self):\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'phi\')\n        self.test_constrain_det({\'alpha\': None, \'phi\': None})\n\n    def test_constrain_det_two_preexisting_samp(self):\n        self.cm.constrain(\'chi\')\n        self.cm.constrain(\'phi\')\n        self.test_constrain_det({\'chi\': None, \'phi\': None})\n\n    def test_constrain_det_three_preexisting_other(self):\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'phi\')\n        self.cm.constrain(\'chi\')\n        try:\n            self.cm.constrain(\'delta\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0], (\n                ""Delta could not be constrained. First un-constrain one of the""\n                ""\\nangles alpha, chi or phi (with \'uncon\')""))\n\n    def test_constrain_det_three_preexisting_samp(self):\n        self.cm.constrain(\'phi\')\n        self.cm.constrain(\'chi\')\n        self.cm.constrain(\'eta\')\n        try:\n            self.cm.constrain(\'delta\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Delta could not be constrained. First un-constrain one of the""\n                ""\\nangles eta, chi or phi (with \'uncon\')"")\n\n    def test_constrain_ref(self, pre={}):\n        eq_(self.cm.all, pre)\n        eq_(self.cm.constrain(\'alpha\'), None)\n        eq_(self.cm.all, joined({\'alpha\': None}, pre))\n        eq_(self.cm.constrain(\'alpha\'), \'Alpha is already constrained.\')\n        eq_(self.cm.all, joined({\'alpha\': None}, pre))\n        eq_(self.cm.constrain(\'beta\'), \'Alpha constraint replaced.\')\n        eq_(self.cm.all, joined({\'beta\': None}, pre))\n\n    def test_constrain_ref_one_preexisting_det(self):\n        self.cm.constrain(\'delta\')\n        self.test_constrain_ref({\'delta\': None})\n\n    def test_constrain_ref_one_preexisting_samp(self):\n        self.cm.constrain(\'phi\')\n        self.test_constrain_ref({\'phi\': None})\n\n    def test_constrain_ref_one_preexisting_samp_and_det(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'phi\')\n        self.test_constrain_ref({\'delta\': None, \'phi\': None})\n\n    def test_constrain_ref_two_preexisting_samp(self):\n        self.cm.constrain(\'chi\')\n        self.cm.constrain(\'phi\')\n        self.test_constrain_ref({\'chi\': None, \'phi\': None})\n\n    def test_constrain_ref_three_preexisting_other(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'phi\')\n        self.cm.constrain(\'chi\')\n        try:\n            self.cm.constrain(\'alpha\'),\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Alpha could not be constrained. First un-constrain one of the""\n                ""\\nangles delta, chi or phi (with \'uncon\')"")\n\n    def test_constrain_ref_three_preexisting_samp(self):\n        self.cm.constrain(\'phi\')\n        self.cm.constrain(\'chi\')\n        self.cm.constrain(\'eta\')\n        try:\n            self.cm.constrain(\'delta\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Delta could not be constrained. First un-constrain one of the""\n                ""\\nangles eta, chi or phi (with \'uncon\')"")\n\n    def test_constrain_samp_when_one_free(self, pre={}):\n        eq_(self.cm.all, pre)\n        eq_(self.cm.constrain(\'phi\'), None)\n        eq_(self.cm.all, joined({\'phi\': None}, pre))\n        eq_(self.cm.constrain(\'phi\'), \'Phi is already constrained.\')\n        eq_(self.cm.all, joined({\'phi\': None}, pre))\n\n    def test_constrain_samp_one_preexisting_samp(self):\n        self.cm.constrain(\'chi\')\n        self.test_constrain_samp_when_one_free({\'chi\': None})\n\n    def test_constrain_samp_two_preexisting_samp(self):\n        self.cm.constrain(\'chi\')\n        self.cm.constrain(\'eta\')\n        self.test_constrain_samp_when_one_free({\'chi\': None, \'eta\': None})\n\n    def test_constrain_samp_two_preexisting_other(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'alpha\')\n        self.test_constrain_samp_when_one_free({\'delta\': None, \'alpha\': None})\n\n    def test_constrain_samp_two_preexisting_one_det(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'eta\')\n        self.test_constrain_samp_when_one_free({\'delta\': None, \'eta\': None})\n\n    def test_constrain_samp_two_preexisting_one_ref(self):\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'eta\')\n        self.test_constrain_samp_when_one_free({\'alpha\': None, \'eta\': None})\n\n    def test_constrain_samp_three_preexisting_only_one_samp(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'eta\')\n        eq_(self.cm.constrain(\'phi\'), \'Eta constraint replaced.\')\n        eq_(self.cm.all, {\'delta\': None, \'alpha\': None, \'phi\': None})\n        eq_(self.cm.constrain(\'phi\'), \'Phi is already constrained.\')\n        eq_(self.cm.all, {\'delta\': None, \'alpha\': None, \'phi\': None})\n\n    def test_constrain_samp_three_preexisting_two_samp_one_det(self):\n        self.cm.constrain(\'delta\')\n        self.cm.constrain(\'eta\')\n        self.cm.constrain(\'chi\')\n        try:\n            self.cm.constrain(\'phi\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Phi could not be constrained. First un-constrain one of the""\n                ""\\nangles delta, eta or chi (with \'uncon\')"")\n\n    def test_constrain_samp_three_preexisting_two_samp_one_ref(self):\n        self.cm.constrain(\'alpha\')\n        self.cm.constrain(\'eta\')\n        self.cm.constrain(\'chi\')\n        try:\n            self.cm.constrain(\'phi\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Phi could not be constrained. First un-constrain one of the""\n                ""\\nangles alpha, eta or chi (with \'uncon\')"")\n\n    def test_constrain_samp_three_preexisting_samp(self):\n        self.cm.constrain(\'mu\')\n        self.cm.constrain(\'eta\')\n        self.cm.constrain(\'chi\')\n        try:\n            self.cm.constrain(\'phi\')\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Phi could not be constrained. First un-constrain one of the""\n                ""\\nangles mu, eta or chi (with \'uncon\')"")\n\n    def test_report_constraints_none(self):\n        eq_(self.cm.report_constraints_lines(),\n            [\'!   3 more constraints required\'])\n\n    def test_report_constraints_one_with_value(self):\n        self.cm.constrain(NUNAME)\n        self.cm.set_constraint(NUNAME, 9.12343)\n        eq_(self.cm.report_constraints_lines(),\n            [\'!   2 more constraints required\',\n             \'    %s  : 9.1234\' % NUNAME])\n\n    def test_report_constraints_one_with_novalue(self):\n        self.cm.constrain(NUNAME)\n        print \'!   2 more constraints required\\n!   %s: ---\' % NUNAME\n        eq_(self.cm.report_constraints_lines(),\n            [\'!   2 more constraints required\',\n             \'!   %s  : ---\' % NUNAME])\n\n    def test_report_constraints_one_with_valueless(self):\n        self.cm.constrain(\'a_eq_b\')\n        eq_(self.cm.report_constraints_lines(),\n            [\'!   2 more constraints required\',\n             \'    a_eq_b\'])\n\n    def test_report_constraints_one_with_two(self):\n        self.cm.constrain(\'naz\')\n        self.cm.set_constraint(\'naz\', 9.12343)\n        self.cm.constrain(\'a_eq_b\')\n        eq_(self.cm.report_constraints_lines(),\n            [\'!   1 more constraint required\',\n             \'    naz  : 9.1234\',\n             \'    a_eq_b\'])\n\n    def test_report_constraints_one_with_three(self):\n        self.cm.constrain(\'naz\')\n        self.cm.set_constraint(\'naz\', 9.12343)\n        self.cm.constrain(\'a_eq_b\')\n        self.cm.constrain(\'mu\')\n        self.cm.set_constraint(\'mu\', 9.12343)\n\n        eq_(self.cm.report_constraints_lines(),\n            [\'    naz  : 9.1234\',\n             \'    a_eq_b\',\n             \'    mu   : 9.1234\'])\n\n    def _constrain(self, *args):\n        for con in args:\n            self.cm.constrain(con)\n\n    @raises(ValueError)\n    def test_is_implemented_invalid(self):\n        self._constrain(\'naz\')\n        self.cm.is_current_mode_implemented()\n\n    # 1 samp\n\n    def test_is_implemented_1_samp_naz(self):\n        self._constrain(\'naz\', \'alpha\', \'mu\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_1_samp_det(self):\n        self._constrain(\'qaz\', \'alpha\', \'mu\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    # 2 samp + ref\n\n    def test_is_implemented_2_samp_ref_mu_chi(self):\n        self._constrain(\'beta\', \'mu\', \'chi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_mu90_chi0(self):\n        self._constrain(\'beta\', \'mu\', \'chi\')\n        self.cm.set_constraint(\'mu\', 0)\n        self.cm.set_constraint(\'chi\', 90)\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_mu_eta(self):\n        self._constrain(\'beta\', \'mu\', \'eta\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_mu_phi(self):\n        self._constrain(\'beta\', \'mu\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_eta_chi(self):\n        self._constrain(\'beta\', \'eta\', \'chi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_eta_phi(self):\n        self._constrain(\'beta\', \'eta\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_ref_chi_phi(self):\n        self._constrain(\'beta\', \'chi\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    # 2 samp + det\n\n    def test_is_implemented_2_samp_det_mu_chi(self):\n        self._constrain(\'qaz\', \'mu\', \'chi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_mu_eta(self):\n        self._constrain(\'qaz\', \'mu\', \'eta\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_mu_phi(self):\n        self._constrain(\'qaz\', \'mu\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_eta_chi(self):\n        self._constrain(\'qaz\', \'eta\', \'chi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_eta_phi(self):\n        self._constrain(\'qaz\', \'eta\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_chi_phi(self):\n        self._constrain(\'qaz\', \'chi\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_bisect_mu(self):\n        self._constrain(\'qaz\', \'bisect\', \'mu\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_bisect_eta(self):\n        self._constrain(\'qaz\', \'bisect\', \'eta\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_2_samp_det_bisect_omega(self):\n        self._constrain(\'qaz\', \'bisect\', \'omega\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    # 3 samp\n\n    def test_is_implemented_3_samp_no_mu(self):\n        self._constrain(\'eta\', \'chi\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_3_samp_no_eta(self):\n        self._constrain(\'mu\', \'chi\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_3_samp_no_chi(self):\n        self._constrain(\'mu\', \'eta\', \'phi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_is_implemented_3_samp_no_phi(self):\n        self._constrain(\'mu\', \'eta\', \'chi\')\n        eq_(self.cm.is_current_mode_implemented(), True)\n\n    def test_set_fails(self):\n        try:\n            self.cm.set_constraint(\'not_a_constraint\', object())\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0], ""Could not set not_a_constraint. This is not an ""\n                ""available constraint."")\n\n        try:\n            self.cm.set_constraint(\'delta\', object())\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Could not set delta. This is not currently constrained."")\n\n        self.cm.constrain(\'a_eq_b\')\n        try:\n            self.cm.set_constraint(\'a_eq_b\', object())\n            assert False\n        except DiffcalcException, e:\n            eq_(e.args[0],\n                ""Could not set a_eq_b. This constraint takes no value."")\n\n#        self.cm.constrain(\'delta\')\n#        self.cm.track(\'delta\')\n#        try:\n#            self.cm.set(\'delta\', object())\n#            assert False\n#        except DiffcalcException, e:\n#            eq_(e.args[0], (""Could not set delta as this constraint is ""\n#                            ""configured to track its associated\\n""\n#                            ""physical angle. First remove this tracking ""\n#                            ""(use \'untrack delta\').""))\n\n    def test_set(self):\n        #""%s: %s --> %f %s""\n        self.cm.constrain(\'alpha\')\n        eq_(self.cm.set_constraint(\'alpha\', 1.), \'alpha : --- --> 1.0\')\n        eq_(self.cm.set_constraint(\'alpha\', 2.), \'alpha : 1.0 --> 2.0\')\n\n\n\n#    def test_track_fails(self):\n#        try:\n#            self.cm.track(\'not_a_constraint\')\n#            assert False\n#        except DiffcalcException, e:\n#            eq_(e.args[0], ""Could not track not_a_constraint as this is not ""\n#                ""an available constraint."")\n#\n#        try:\n#            self.cm.track(\'delta\')\n#            assert False\n#        except DiffcalcException, e:\n#            eq_(e.args[0],\n#                ""Could not track delta as this is not currently constrained."")\n#\n#        self.cm.constrain(\'a_eq_b\')\n#        try:\n#            self.cm.track(\'a_eq_b\')\n#            assert False\n#        except DiffcalcException, e:\n#            eq_(e.args[0],\n#                ""Could not track a_eq_b as this constraint takes no value."")\n#\n#        self.cm.constrain(\'alpha\')\n#        try:\n#            self.cm.track(\'alpha\')\n#            assert False\n#        except DiffcalcException, e:\n#            eq_(e.args[0], (""Could not configure alpha to track as this ""\n#                            ""constraint is not associated with a\\n""\n#                            ""physical angle.""))\n#\n#    def test_track(self):\n#        #""%s: %s --> %f %s""\n#        self.cm.constrain(\'delta\')\n#        eq_(self.cm.track(\'delta\'), \'delta : --- ~~> 1.0 (tracking)\')\n#        eq_(self.cm.track(\'delta\'), \'Delta was already configured to track.\')\n#        self.cm.untrack(\'delta\')\n#        self.cm.set_constraint(\'delta\', 2.)\n#        eq_(self.cm.track(\'delta\'), \'delta : 2.0 ~~> 1.0 (tracking)\')\n\nclass TestConstraintManagerWithFourCircles:\n\n    def setup_method(self):\n        self.cm = YouConstraintManager({NUNAME: 0, \'mu\': 0})    \n\n    def test_init(self):\n        eq_(self.cm.all, {NUNAME: 0, \'mu\': 0})\n        eq_(self.cm.detector, {NUNAME: 0})\n        eq_(self.cm.reference, {})\n        eq_(self.cm.sample, {\'mu\': 0})\n        eq_(self.cm.naz, {})\n\n    def test_build_initial_display_table_with_fixed_detector(self):\n        self.cm = YouConstraintManager({NUNAME: 0})\n        print self.cm.build_display_table_lines()\n        eq_(self.cm.build_display_table_lines(),\n            [\'    REF             SAMP\',\n             \'    -----------     -----------\',\n             \'    a_eq_b          mu\',\n             \'    alpha           eta\',\n             \'    beta            chi\',\n             \'    psi             phi\',\n             \'    bin_eq_bout     bisect\',\n             \'    betain          omega\',\n             \'    betaout\'])\n        \n    def test_build_initial_display_table_with_fixed_sample(self):\n        self.cm = YouConstraintManager({\'mu\': 0})\n        print self.cm.build_display_table_lines()\n        eq_(self.cm.build_display_table_lines(),\n            [\'    DET             REF             SAMP\',\n             \'    -----------     -----------     -----------\',\n             \'    delta           a_eq_b          eta\',\n             \'    %s          alpha           chi\' % NUNAME.ljust(6),\n             \'    qaz             beta            phi\',\n             \'    naz             psi             bisect\',\n             \'                    bin_eq_bout     omega\',\n             \'                    betain\',\n             \'                    betaout\'])\n        \n    def test_build_initial_display_table_for_four_circle(self):\n        self.cm = YouConstraintManager({\'mu\': 0, NUNAME: 0})\n        print self.cm.build_display_table_lines()\n        eq_(self.cm.build_display_table_lines(),\n            [\'    REF             SAMP\',\n             \'    -----------     -----------\',\n             \'    a_eq_b          eta\',\n             \'    alpha           chi\',\n             \'    beta            phi\',\n             \'    psi             bisect\',\n             \'    bin_eq_bout     omega\',\n             \'    betain\',\n             \'    betaout\'])\n        \n    def test_constrain_fixed_detector_angle(self):\n        assert_raises(DiffcalcException, self.cm.constrain, \'delta\')\n        assert_raises(DiffcalcException, self.cm.constrain, NUNAME)\n        assert_raises(DiffcalcException, self.cm.constrain, \'naz\')\n        assert_raises(DiffcalcException, self.cm.constrain, \'qaz\')\n\n    def test_unconstrain_fixed_detector_angle(self):\n        assert_raises(DiffcalcException, self.cm.unconstrain, \'delta\')\n        assert_raises(DiffcalcException, self.cm.unconstrain, NUNAME)\n        assert_raises(DiffcalcException, self.cm.unconstrain, \'naz\')\n        assert_raises(DiffcalcException, self.cm.unconstrain, \'qaz\')\n        \n    def test_set_constrain_fixed_detector_angle(self):\n        assert_raises(DiffcalcException, self.cm.set_constraint, \'delta\', 0)\n        assert_raises(DiffcalcException, self.cm.set_constraint, NUNAME, 0)\n        assert_raises(DiffcalcException, self.cm.set_constraint, \'naz\', 0)\n        assert_raises(DiffcalcException, self.cm.set_constraint, \'qaz\', 0)\n    \n    @raises(DiffcalcException)\n    def test_constrain_fixed_sample_angle(self):\n        self.cm.constrain(\'mu\')\n\n    @raises(DiffcalcException)\n    def test_unconstrain_fixed_sample_angle(self):\n        self.cm.unconstrain(\'mu\')\n\n    @raises(DiffcalcException)\n    def test_set_constrain_fixed_sample_angle(self):\n        self.cm.set_constraint(\'mu\', 0)'"
test/diffcalc/hkl/you/test_hkl.py,0,"b'###\n# Copyright 2008-2011 Diamond Light Source Ltd.\n# This file is part of Diffcalc.\n#\n# Diffcalc is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Diffcalc is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Diffcalc.  If not, see <http://www.gnu.org/licenses/>.\n###\n\n\nfrom mock import Mock, call\nfrom diffcalc import settings\n\nimport diffcalc\nfrom test.diffcalc.test_hardware import SimpleHardwareAdapter\nfrom diffcalc.hkl.you.geometry import SixCircle\ndiffcalc.util.DEBUG = True\n\n\nhkl = None\ndef setup_module():\n    global hkl\n    settings.hardware=SimpleHardwareAdapter([])\n    settings.geometry=SixCircle()\n    settings.angles_to_hkl_function=Mock()\n    settings.ubcalc_strategy=Mock()\n    settings.geometry.fixed_constraints = {}\n    \n    from diffcalc.hkl.you import hkl\n    reload(hkl)\n    \n    hkl.hklcalc = Mock()\n    hkl.hklcalc.constraints.report_constraints_lines.return_value = [\'report1\', \'report2\']\n\n\ndef test_con_with_1_constraint():\n    hkl.con(\'cona\')\n    hkl.hklcalc.constraints.constrain.assert_called_with(\'cona\')\n\ndef test_con_with_1_constraint_with_value():\n    hkl.con(\'cona\', 123)\n    hkl.hklcalc.constraints.constrain.assert_called_with(\'cona\')\n    hkl.hklcalc.constraints.set_constraint.assert_called_with(\'cona\', 123)\n\ndef test_con_with_3_constraints():\n    hkl.con(\'cona\', \'conb\', \'conc\')\n    hkl.hklcalc.constraints.clear_constraints.assert_called()\n    calls = [call(\'cona\'), call(\'conb\'), call(\'conc\')]\n    hkl.hklcalc.constraints.constrain.assert_has_calls(calls)\n\ndef test_con_with_3_constraints_first_val():\n    hkl.con(\'cona\', 1, \'conb\', \'conc\')\n    hkl.hklcalc.constraints.clear_constraints.assert_called()\n    calls = [call(\'cona\'), call(\'conb\'), call(\'conc\')]\n    hkl.hklcalc.constraints.constrain.assert_has_calls(calls)\n    hkl.hklcalc.constraints.set_constraint.assert_called_with(\'cona\', 1)\n\ndef test_con_with_3_constraints_second_val():\n    hkl.con(\'cona\', \'conb\', 2, \'conc\')\n    hkl.hklcalc.constraints.clear_constraints.assert_called()\n    calls = [call(\'cona\'), call(\'conb\'), call(\'conc\')]\n    hkl.hklcalc.constraints.constrain.assert_has_calls(calls)\n    hkl.hklcalc.constraints.set_constraint.assert_called_with(\'conb\', 2)\n    \ndef test_con_with_3_constraints_third_val():\n    hkl.con(\'cona\', \'conb\', \'conc\', 3)\n    hkl.hklcalc.constraints.clear_constraints.assert_called()\n    calls = [call(\'cona\'), call(\'conb\'), call(\'conc\')]\n    hkl.hklcalc.constraints.constrain.assert_has_calls(calls)\n    hkl.hklcalc.constraints.set_constraint.assert_called_with(\'conc\', 3)\n    \ndef test_con_with_3_constraints_all_vals():\n    hkl.con(\'cona\', 1, \'conb\', 2, \'conc\', 3)\n    hkl.hklcalc.constraints.clear_constraints.assert_called()\n    calls = [call(\'cona\'), call(\'conb\'), call(\'conc\')]\n    hkl.hklcalc.constraints.constrain.assert_has_calls(calls)\n    calls = [call(\'cona\', 1), call(\'conb\', 2), call(\'conc\', 3)]\n    hkl.hklcalc.constraints.set_constraint.assert_has_calls(calls)\n    \ndef test_con_messages_and_help_visually():\n    hkl.con()\n    print ""**""\n    print hkl.con.__doc__\n    \ndef test_con_message_display_whenn_selecting_an_unimplmented_mode():\n    hkl.hklcalc.constraints.is_fully_constrained.return_value = True\n    hkl.hklcalc.constraints.is_current_mode_implemented.return_value = False\n    hkl.con(\'phi\', \'chi\', \'eta\')\n'"
