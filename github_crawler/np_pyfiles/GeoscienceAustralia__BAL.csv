file_path,api_count,code
bal.py,0,"b'""""""\n:mod:`bal` - Calculate the bushfire attack level (BAL)\n===============================================================\n\nThis module is used to produce the bushfire attack level (BAL) for an area of\ninterest within Australia based on input vegetation and elevation datasets\nas per Method 1 in the Australian Standard AS 3959 (2009) -- Construction of\nbuildings in bushfire-prone areas.\n\n:moduleauthor: Tina Yang <tina.yang@ga.gov.au>\n\n""""""\n\nimport sys\nimport os\nimport inspect\nimport math\nfrom os.path import join as pjoin\nimport arcpy\nfrom calculate_bal import bal_cal\nfrom utilities.sa_tools import extract_by_mask, reclassify, cal_slope_aspect\n\n__version__ = \'2.1\'\n\n\ndef reclass_veg(veg, dem, output_folder, remap, mask):\n    """"""\n    Reclassify the original vegetation into the categories classified as Table\n    2.3 in AS 3959 (2009).\n\n    :param veg: `file` the input vegetation\n    :param dem: `file` the input dem used as reference projection\n    :param output_folder: `str` the output folder\n    :param remap: `srt` the vegetation reclassification\n    :param mask: `file` the mask for the effective AOI\n\n    :return: `file` the reclassified vegetation\n    """"""\n\n    arcpy.env.overwriteOutput = True\n\n    input_folder = os.path.dirname(veg)\n    arcpy.env.workspace = input_folder\n\n    veg_r_init = \'veg_r_init\'\n    veg_r_proj = pjoin(input_folder, \'veg_r_pj\')\n    veg_class_r = pjoin(output_folder, \'veg_r\')\n\n    arcpy.AddMessage(\'Remap the vegetation into classes of 1 ~ 7 ...\')\n\n    # Derive reclassifed veg...\n    reclassify(veg, remap, veg_r_init)\n\n    # project as dem and change cell size same as that of dem\n    dem_c = arcpy.GetRasterProperties_management(dem, ""CELLSIZEX"").getOutput(0)\n\n    arcpy.ProjectRaster_management(veg_r_init, veg_r_proj, dem, ""#"", dem_c)\n\n    if arcpy.Exists(veg_r_init):\n        arcpy.Delete_management(veg_r_init)\n\n    # get the AOI\n    extract_by_mask(veg_r_proj, mask, veg_class_r)\n\n    g_list = arcpy.ListRasters(\'g_g*\')\n    if len(g_list) != 0:\n        for g_file in g_list:\n            arcpy.Delete_management(g_file)\n\n    if arcpy.Exists(veg_r_proj):\n        arcpy.Delete_management(veg_r_proj)\n\n    return veg_class_r\n\n\ndef get_slope_aspect(input_dem, output_folder, mask):\n    """"""\n    Calculate the slope and aspect from the input DEM\n\n    :param input_dem: `file` the input DEM\n    :param output_folder: `str` the output folder\n    :param mask: `file` the mask for the effective AOI\n\n    :return: `file` the reclassified slope\n    :return: `file` the reclassified aspect\n    """"""\n    arcpy.env.overwriteOutput = True\n\n    input_folder = os.path.dirname(input_dem)\n    arcpy.env.workspace = input_folder\n\n    dem_slope = pjoin(input_folder, \'slope\')\n    dem_aspect = pjoin(input_folder, \'aspect\')\n\n    # Derive slope and aspect ...\n    cal_slope_aspect(input_dem, dem_slope, dem_aspect)\n\n    aspect_rec_init = pjoin(input_folder, \'aspect_r_i\')\n    slope_rec_init = pjoin(input_folder, \'slope_r_i\')\n    aspect_rec = pjoin(output_folder, \'aspect_r\')\n    slope_rec = pjoin(output_folder, \'slope_r\')\n\n    # Derive reclassifed aspect...\n    arcpy.AddMessage(\'Remap the aspect into classes of 1 ~ 9 ...\')\n\n    reclassify(dem_aspect, ""-1 0 9;0 22.5 1;22.5 67.5 2;67.5 112.5 3;\\\n               112.5 157.5 4;157.5 202.5 5;202.5 247.5 6;247.5 292.5 7;\\\n               292.5 337.5 8;337.5 360 1"", aspect_rec_init)\n\n    value_max = arcpy.GetRasterProperties_management(\n                dem_slope, ""MAXIMUM"").getOutput(0)\n\n    if float(value_max) < 20:\n        value_max = 20.0001\n\n    # remap is minimum inclusive but maxmum exclusive. using .0001 to comform\n    # to the standard minimum is exclusive and maximum is inclusive\n    remap = ""0 0 1;0.0001 5 2;5.0001 10 3;10.0001 15 4;\\\n            15.0001 20 5;20.0001 "" + \\\n            str(math.ceil(float(value_max))) + "" 6""\n\n    arcpy.AddMessage(\'Remap the slope into classes of 1 ~ 6 ...\')\n\n    # Derive reclassifed slope...\n    reclassify(dem_slope, remap, slope_rec_init)\n\n    extract_by_mask(aspect_rec_init, mask, aspect_rec)\n    extract_by_mask(slope_rec_init, mask, slope_rec)\n\n    g_list = arcpy.ListRasters(\'g_g*\')\n    if len(g_list) != 0:\n        for g_file in g_list:\n            arcpy.Delete_management(g_file)\n    if arcpy.Exists(dem_slope):\n        arcpy.Delete_management(dem_slope)\n    if arcpy.Exists(dem_aspect):\n        arcpy.Delete_management(dem_aspect)\n    if arcpy.Exists(slope_rec_init):\n        arcpy.Delete_management(slope_rec_init)\n    if arcpy.Exists(aspect_rec_init):\n        arcpy.Delete_management(aspect_rec_init)\n\n    return slope_rec, aspect_rec\n\n\ndef find_common_area(veg_class, slope, aspect):\n    """"""\n    Find the common area of vegetation, slope and aspect to calculate BAL.\n\n    :param veg_class: `file` the reclassified vegetation\n    :param slope: `file` the slope derived from DEM\n    :param aspect: `file` the aspect derived from DEM\n\n    :return: `file` the vegetation in common area\n    :return: `file` the slope in common area\n    :return: `file` the aspect in common area\n    """"""\n\n    output_folder = os.path.dirname(veg_class)\n    arcpy.env.overwriteOutput = True\n\n    # set directory\n    work_folder = output_folder\n    os.chdir(work_folder)\n    arcpy.env.workspace = work_folder\n\n    # get the common area of veg and dem\n    # get the extent of inputs\n    slope_poly = ""slope_poly.shp""\n    veg_class_poly = ""veg_class_poly.shp""\n    get_footprint(slope, slope_poly)\n    get_footprint(veg_class, veg_class_poly)\n\n    mask_com = \'mask_com.shp\'\n\n    arcpy.Intersect_analysis([slope_poly, veg_class_poly], mask_com)\n\n    veg_class_com = pjoin(output_folder, \'veg_c\')\n    slope_com = pjoin(output_folder, \'slope_c\')\n    aspect_com = pjoin(output_folder, \'aspect_c\')\n\n    extract_by_mask(veg_class, mask_com, veg_class_com)\n    extract_by_mask(slope, mask_com, slope_com)\n    extract_by_mask(aspect, mask_com, aspect_com)\n\n    if arcpy.Exists(slope_poly):\n        arcpy.Delete_management(slope_poly)\n    if arcpy.Exists(veg_class_poly):\n        arcpy.Delete_management(veg_class_poly)\n    if arcpy.Exists(mask_com):\n        arcpy.Delete_management(mask_com)\n    if arcpy.Exists(veg_class):\n        arcpy.Delete_management(veg_class)\n    if arcpy.Exists(slope):\n        arcpy.Delete_management(slope)\n    if arcpy.Exists(aspect):\n        arcpy.Delete_management(aspect)\n\n    return veg_class_com, slope_com, aspect_com\n\n\ndef bal_calc(vegetation, dem, fdi, output_folder, remap, mask):\n    """"""\n    Calcuate BAL based on vegetation map and DEM.\n\n    :param vegetation: `file` the original vegetation\n    :param dem: `file` the input DEM\n    :param fdi: `int` the input FDI value\n    :param output_folder: `str` the output folder\n    :param remap: `srt` the vegetation reclassification\n    :param mask: `file` the mask for the effective area of interest (AOI)\n    """"""\n    arcpy.env.overwriteOutput = True\n\n    arcpy.AddMessage(\'Reclassify the vegetation map ...   \')\n    veg_class = reclass_veg(vegetation, dem, output_folder, remap, mask)\n\n    arcpy.AddMessage(\'Reclassify slope and aspect ...   \')\n    slope, aspect = get_slope_aspect(dem, output_folder, mask)\n\n    if arcpy.Exists(mask):\n        arcpy.Delete_management(mask)\n\n    # extract the common area between vegtation, slope and aspect\n    arcpy.AddMessage(\'Get common area of input data ...   \')\n    veg_class_com, slope_com, aspect_com = find_common_area(veg_class,\n                                                            slope, aspect)\n\n    arcpy.AddMessage(\'Calculate the BAL ...   \')\n    bal_cal(veg_class_com, slope_com, aspect_com, fdi)\n\n\ndef get_extent_mask(extent, mask):\n    """"""\n    Derive the mask for the customised input extent.\n\n    :param extent: `str` the input extent\n    :param mask: `file` the output mask\n    """"""\n\n    extent_list = str(extent).split()\n\n    # Array to hold points\n    array = arcpy.Array()\n\n    # Create the bounding box\n    array.add(arcpy.Point(float(extent_list[0]), float(extent_list[1])))\n    array.add(arcpy.Point(float(extent_list[2]), float(extent_list[1])))\n    array.add(arcpy.Point(float(extent_list[2]), float(extent_list[3])))\n    array.add(arcpy.Point(float(extent_list[0]), float(extent_list[3])))\n    array.add(arcpy.Point(float(extent_list[0]), float(extent_list[1])))\n\n    # Create the polygon object\n    polygon = arcpy.Polygon(array)\n    array.removeAll()\n    arcpy.CopyFeatures_management(polygon, mask)\n\n\ndef get_footprint(raster, footprint):\n    """"""\n    Find the footprint of a raster\n\n    :param raster: `file` the input raster\n    :param footprint: `file` the output footprint\n    """"""\n\n    # set the environment variable and workspace\n    arcpy.env.overwriteOutput = True\n    input_folder = os.path.dirname(raster)\n    arcpy.env.workspace = input_folder\n\n    raster_extent = arcpy.Describe(raster).extent\n\n    get_extent_mask(raster_extent, footprint)\n\n    # add the original spatial reference to the footprint\n    desc = arcpy.Describe(raster)\n    arcpy.DefineProjection_management(footprint, desc.spatialReference)\n\n\ndef find_aoi(extent, dem, veg):\n    """"""\n    Find the effective area of interest based on input vegetation map, DEM and\n    extent.\n\n    :param extent: `str` the input extent\n    :param dem: `file` the input DEM\n    :param veg: `file` the input vegetation\n\n    :return: `file` the mask for effective AOI\n    """"""\n\n    # set the environment variable and workspace\n    arcpy.env.overwriteOutput = True\n    input_dem_folder = os.path.dirname(dem)\n    input_veg_folder = os.path.dirname(veg)\n    arcpy.env.workspace = input_dem_folder\n\n    # derive the effective mask based on the input data\n    arcpy.AddMessage(\'Get the area of interest from the input extent ...\')\n    mask = pjoin(input_dem_folder, \'mask.shp\')\n\n    if str(extent) in [\'DEFAULT\', \'MAXOF\', \'MINOF\']:\n        # get the extent of inputs\n        dem_poly = pjoin(input_dem_folder, ""dem_poly.shp"")\n        veg_poly = pjoin(input_veg_folder, ""veg_poly.shp"")\n        get_footprint(dem, dem_poly)\n        get_footprint(veg, veg_poly)\n        arcpy.Intersect_analysis([dem_poly, veg_poly], mask)\n\n        # delete intermediate files\n        if arcpy.Exists(dem_poly):\n            arcpy.Delete_management(dem_poly)\n        if arcpy.Exists(veg_poly):\n            arcpy.Delete_management(veg_poly)\n    else:\n        get_extent_mask(extent, mask)\n\n        # add dem\'s spatial reference to the mask\n        desc = arcpy.Describe(dem)\n        arcpy.DefineProjection_management(mask, desc.spatialReference)\n\n    return mask\n\n\ndef run():\n    """"""\n    Run the BAL calculations.\n\n    """"""\n    # add subfolders into path\n    cmd_folder = os.path.realpath(\n        os.path.abspath(\n            os.path.split(\n                inspect.getfile(\n                    inspect.currentframe()))[0]))\n    if cmd_folder not in sys.path:\n        sys.path.insert(0, cmd_folder)\n\n    cmd_subfolder = pjoin(cmd_folder, ""utilities"")\n    if cmd_subfolder not in sys.path:\n        sys.path.insert(0, cmd_subfolder)\n\n    # get input parameters from toolbox interface\n    dem = arcpy.GetParameterAsText(0)\n    veg = arcpy.GetParameterAsText(1)\n    remap = arcpy.GetParameterAsText(2)\n    output_folder = arcpy.GetParameterAsText(3)\n    fdi = arcpy.GetParameter(4)\n    extent = arcpy.GetParameter(5)\n\n    dem_sr = arcpy.Describe(dem).spatialReference\n    arcpy.AddMessage(""DEM\'s spatial reference type is {0}"".format(dem_sr.type))\n\n    if dem_sr.type == ""Projected"":\n        # find effective AOI based on the input parameters\n        mask = find_aoi(extent, dem, veg)\n\n        try:\n            # calculate the BAL for the effective AOI\n            bal_calc(veg, dem, fdi, output_folder, remap, mask)\n            arcpy.AddMessage(""Successfully completed BAL calculation!"")\n        except Exception as err:\n            # Report any exceptions back\n            arcpy.AddError(err)\n\n    else:\n        arcpy.AddError(""To go ahead, the DEM needs to be projected first"")\n\nif __name__ == \'__main__\':\n    run()\n'"
calculate_bal.py,10,"b'""""""\n:mod:`calculate_bal` - essential part of calculating the\nbushfire attack level (BAL)\n\n===============================================================\n\nThis module includes algorithms that are used to calculate BAL as per\nMethod 1 in the Australian Standard AS 3959 (2009) -- Construction of\nbuildings in bushfire-prone areas.\n\n:moduleauthor: Tina Yang <tina.yang@ga.gov.au>\n\n""""""\n\nimport arcpy\nimport os\nimport numpy as np\nfrom utilities import value_lookup, bal_database\n\n\ndef bal_cal(veg_class, slope, aspect, fdi):\n    """"""\n    Calculate the BAL based on the classified vegetation and the combined\n    slope and vegetation according to an appropriate table in AS 3959 (2009)\n    to determine the bushfire attack level (BAL).\n\n    :param veg_class: `file` the input classified vegetation\n    :param slope: `file` the input slope\n    :param aspect: `file` the input aspect\n    :param fdi: `int` the input FDI value\n    """"""\n\n    output_folder = os.path.dirname(veg_class)\n    arcpy.env.overwriteOutput = True\n\n    # set directory\n    work_folder = output_folder\n    os.chdir(work_folder)\n    arcpy.env.workspace = work_folder\n\n    # get veg raster size, format, projection, etc\n    desc = arcpy.Describe(veg_class)\n    extent = desc.extent\n    lowleft_corner = arcpy.Point(extent.XMin, extent.YMin)\n    pixel_w = desc.meanCellWidth\n    pixel_h = desc.meanCellHeight\n    sref = desc.spatialReference\n\n    # load the raster into numpy array\n    veg_data = arcpy.RasterToNumPyArray(veg_class, nodata_to_value=-99)\n    slope_data = arcpy.RasterToNumPyArray(slope, nodata_to_value=-99)\n    aspect_data = arcpy.RasterToNumPyArray(aspect, nodata_to_value=-99)\n\n    # calculate the BAL for each direction in numpy array and get maximum of\n    # 2 direction each time, until get the maximum of all directions\n    dire = [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\']\n\n    for one_dir in dire:\n        bal_list = []\n        outdata = convo(one_dir, veg_data, slope_data, aspect_data,\n                        pixel_w, fdi)\n\n        output_dir = \'bal_\' + one_dir + \'.img\'\n\n        if arcpy.Exists(output_dir):\n            arcpy.Delete_management(output_dir)\n\n        arcpy.NumPyArrayToRaster(outdata, lowleft_corner, pixel_w,\n                                 pixel_h, value_to_nodata=-99).save(output_dir)\n\n        arcpy.DefineProjection_management(output_dir, sref)\n\n        if one_dir == \'w\':\n            bigger = outdata\n            del outdata\n            continue\n\n        bal_list.append(bigger)\n        bal_list.append(outdata)\n        bigger = get_max_bal(bal_list)\n        del outdata\n\n    # get maximum BAL from the list\n    arcpy.NumPyArrayToRaster(bigger, lowleft_corner, pixel_w,\n                             pixel_h, value_to_nodata=-99).save(\'bal_max.img\')\n\n    arcpy.DefineProjection_management(\'bal_max.img\', sref)\n\n    arcpy.BuildPyramidsandStatistics_management(output_folder, ""#"",\n                                                ""BUILD_PYRAMIDS"",\n                                                ""CALCULATE_STATISTICS"")\n\n    # delete intermediate results\n    if arcpy.Exists(veg_class):\n        arcpy.Delete_management(veg_class)\n    if arcpy.Exists(slope):\n        arcpy.Delete_management(slope)\n    if arcpy.Exists(aspect):\n        arcpy.Delete_management(aspect)\n    del veg_data, slope_data, aspect_data\n    del bal_list, bigger\n\n\ndef get_max_bal(bal_list):\n    """"""\n    get the maximum bal value of all 8 directions.\n\n    :param bal_list: `list of arrays` the bal value for each of 8 directions\n\n    :return: :class:`numpy.ndarray` the maximum bal value of 8 directions\n    """"""\n\n    stacked_arrays = np.dstack(tuple(bal_list))\n    max_of_stack = stacked_arrays.max(2)\n\n    return max_of_stack\n\n\ndef get_slope_in_aspect(slope_data, aspect_data, rows, cols, aspect_value):\n    """"""\n    Get the slope data in a specific aspect.\n\n    :param slope_data: :class:`numpy.ndarray` the slope values\n    :param aspect_data: :class:`numpy.ndarray` the aspect values\n    :param rows: `int` the row number of the slope_data\n    :param cols: `int` the column number of the slope_data\n    :param aspect_value: `int` the aspect value\n\n    :return: :class:`numpy.ndarray` the slope data in an aspect\n    """"""\n\n    slope_in_aspect = np.zeros((rows, cols), np.float32)\n    # -1 means upslope\n    slope_in_aspect.fill(-1)\n    # if the original slope is nodata, the slope_in_aspect should be nodata\n    nodata_location = np.where(slope_data == -99)\n    slope_in_aspect[nodata_location] = slope_data[nodata_location]\n\n    same_aspect_location = np.where(aspect_data == aspect_value)\n    slope_in_aspect[same_aspect_location] = slope_data[same_aspect_location]\n\n    return slope_in_aspect\n\n\ndef convo(a_dir, veg_data, slope_data, aspect_data, pixel_width, fdi):\n    """"""\n    Find the maximum BAL for the point of interest in one direction by\n    assessing all neighbours\' BAL values in that direction (up to 100 metres).\n\n    :param a_dir: `string` the specific direction\n    :param veg_data: :class:`numpy.ndarray` the classified vegetation values\n    :param slope_data: :class:`numpy.ndarray` the slope values\n    :param aspect_data: :class:`numpy.ndarray` the aspect values\n    :param pixel_width: `float` the pixel width of the classified vegetation\n    :param fdi: `int` the input FDI value\n\n    :return: :class:`numpy.ndarray` the output BAL values\n    """"""\n\n    dire_aspect = value_lookup.DIRE_ASPECT\n    aspect_value = dire_aspect[a_dir]\n\n    # dire_width is the cell span length at the specific direction\n    if a_dir in [\'w\', \'e\', \'n\', \'s\']:\n        dire_width = pixel_width\n    else:\n        dire_width = pixel_width * 1.414\n\n    filter_width = int(np.ceil(100.0 / dire_width))\n\n    rows = veg_data.shape[0]\n    cols = veg_data.shape[1]\n\n    slope_in_aspect = get_slope_in_aspect(slope_data, aspect_data, rows, cols,\n                                          aspect_value)\n\n    outdata = np.zeros((rows, cols), np.float32)\n\n    for i in range(rows):\n        for jj in range(cols):\n\n            # for pixels whose neighbour amount is less than defined value.\n            # e.g here for 25m resolution, it is 4 for hori and vert and 3\n            # for diagnoal direction\n            all_neighb_dir = value_lookup.ALL_NEIGHB[a_dir](i, jj, rows, cols)\n\n            if all_neighb_dir < filter_width:\n                max_neighb_dir = all_neighb_dir\n            else:\n                max_neighb_dir = filter_width\n\n            slope = np.zeros(max_neighb_dir)\n            veg = np.zeros(max_neighb_dir)\n            bal = np.zeros(max_neighb_dir)\n            dist = np.zeros(max_neighb_dir)\n\n            # if max_neighb_dir is 0, it means no neighbours at this direction\n            # so no loop is acted as follows. then the output is nodata\n            for m in range(1, max_neighb_dir + 1):\n                # get neighbour point location\n                point_row = value_lookup.POINT_R[a_dir](i, m)\n                point_col = value_lookup.POINT_C[a_dir](jj, m)\n\n                # get neighbour point distance, slope, veg data\n                dist[m - 1] = (m - 1) * dire_width + 0.5 * dire_width\n                slope[m - 1] = slope_in_aspect[point_row, point_col]\n                veg[m - 1] = veg_data[point_row, point_col]\n\n                # calcualte bal for the neighbour point\n                bal[m - 1] = bal_esti(veg[m - 1],\n                                      dist[m - 1], slope[m - 1], fdi)\n\n            # get the calculated pixel value\n            if len(bal) > 0:\n                outdata[i, jj] = max(bal)\n            else:\n                # the boundary data\n                outdata[i, jj] = -99\n\n    return outdata\n\n\ndef find_dist_class(dist, dist_limit):\n    """"""\n    Decide the BAL class based on the input distance and the distance\n    upper-limit for each BAL class.\n\n    :param dist: `float` the horizontal distance from POI\n    :param dist_limit: `list` the upper-limit for each BAL class\n\n    :return: `int` the distance class defined in bal_database.py\n    """"""\n\n    if dist < dist_limit[0]:\n        dist_class = 1\n    elif dist < dist_limit[1]:\n        dist_class = 2\n    elif dist < dist_limit[2]:\n        dist_class = 3\n    elif dist < dist_limit[3]:\n        dist_class = 4\n    else:\n        dist_class = 5\n\n    return dist_class\n\n\ndef bal_esti(veg, dist, slope, fdi):\n    """"""\n    Calculate the BAL based on the vegetation class, slope degree and\n    horizontal distance from the point of interest (POI).\n\n    :param veg: `float` the vegetation type\n    :param dist: `float` the horizontal distance from POI\n    :param slope: `float` the slope value\n    :param fdi: `int` the input FDI value\n\n    :return: `float` the output BAL value for this neighbour point regards to\n             the POI\n    """"""\n\n    # nodata area\n    if slope == -99:\n        bal = -99\n\n    # downslope > 20 degree\n    elif slope == bal_database.SLOPE[5]:\n        if veg == -99:\n            bal = -99\n        else:\n            bal = 200\n\n    # flat land (0 degree) or upslopes\n    elif slope in [-1, bal_database.SLOPE[0]]:\n        if veg == -99:\n            bal = -99\n        else:\n            d_limit = bal_database.DIST_LIMIT_UPSLOPE[fdi][veg]\n            dist_class = find_dist_class(dist, d_limit)\n            bal = bal_database.BAL_CLASS[dist_class]\n\n    # 0 < downslope <= 20 degree\n    else:\n        if veg == -99:\n            bal = -99\n        else:\n            d_limit = bal_database.DIST_LIMIT_DOWNSLOPE[fdi][(slope, veg)]\n            dist_class = find_dist_class(dist, d_limit)\n            bal = bal_database.BAL_CLASS[dist_class]\n\n    # if fdi is not 50, if it is grassland, distance is consdiered up to 50m,\n    # update bal to nodata\n    if fdi != 50 and veg == bal_database.VEG_CLASS[6]:\n        if dist >= 50:\n            bal = -99\n\n    return bal\n'"
conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Bushfire Attack Level Toolbox documentation build configuration file, created by\n# sphinx-quickstart on Wed Apr 12 11:02:21 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(\'.\'))\nsys.path.insert(0, os.path.abspath(\'./utilities\'))\nimport sphinx_rtd_theme\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\nneeds_sphinx = \'1.4.3\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.imgmath\',\n    \'sphinx.ext.viewcode\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#\n# source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Bushfire Attack Level Toolbox\'\ncopyright = u\'2017, Geoscience Australia\'\nauthor = u\'Geoscience Australia\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = u\'2.1\'\n# The full version, including alpha/beta/rc tags.\nrelease = u\'2.1\'\n\nnumfig = True\nnumfig_secnum_depth = 3\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#\n# today = \'\'\n#\n# Else, today_fmt is used as the format for a strftime call.\n#\n# today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#\n# default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A string of reStructuredText that will be included at the end of\n# every source file that is read. \nrst_epilog = """"""\n.. |project_name| replace:: Bushfire Attack Level Toolbox\n.. |project_abbrev| replace:: BAL\n.. |GA| replace:: `Geoscience Australia`_\n.. _Geoscience Australia: http://www.ga.gov.au/\n.. |DFES| replace:: `Department of Fire and Emergency Services (WA)`_\n.. _Department of Fire and Emergency Services (WA): http://www.dfes.wa.gov.au/\n.. |github| replace:: github_\n.. _github: https://github.com/GeoscienceAustralia/BAL\n.. |folder_icon| image:: /docs/images/001_arcgis_folder_icon.png\n\n""""""\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nRTD_NEW_THEME = True\nhtml_theme = ""sphinx_rtd_theme""\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nhtml_theme_options = {\n    \'navigation_depth\': 4,\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.\n# ""<project> v<release> documentation"" by default.\n#\nhtml_title = u\'Bushfire Attack Level Toolbox\'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#\nhtml_logo = ""docs/images/geoscience_inline.jpg""\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#\n# html_extra_path = []\n\n# If not None, a \'Last updated on:\' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to \'%b %d, %Y\'.\n#\n# html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#\n# html_domain_indices = True\n\n# If false, no index is generated.\n#\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#\n# html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#\n# html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#\n# html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\', \'zh\'\n#\n# html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# \'ja\' uses this config value.\n# \'zh\' user can custom change `jieba` dictionary path.\n#\n# html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#\n# html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'BushfireAttackLevelToolboxdoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n     # The paper size (\'letterpaper\' or \'a4paper\').\n     #\n     # \'papersize\': \'letterpaper\',\n\n     # The font size (\'10pt\', \'11pt\' or \'12pt\').\n     #\n     # \'pointsize\': \'10pt\',\n\n     # Additional stuff for the LaTeX preamble.\n     #\n     # \'preamble\': \'\',\n\n     # Latex figure (float) alignment\n     #\n     # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \n     \'BushfireAttackLevelToolbox.tex\', \n     u\'Bushfire Attack Level Toolbox Documentation\',\n     u\'Geoscience Australia\', \n     \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#\n# latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n#\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#\n# latex_appendices = []\n\n# It false, will not define \\strong, \\code, \titleref, \\crossref ... but only\n# \\sphinxstrong, ..., \\sphinxtitleref, ... To help avoid clash with user added\n# packages.\n#\n# latex_keep_old_macro_names = True\n\n# If false, no module index is generated.\n#\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \n     \'bushfireattackleveltoolbox\', \n     u\'Bushfire Attack Level Toolbox Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \n     \'BushfireAttackLevelToolbox\', \n     u\'Bushfire Attack Level Toolbox Documentation\',\n     author, \n     \'BushfireAttackLevelToolbox\', \n     \'Spatial implementation of AS3959\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n#\n# texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#\n# texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#\n# texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'https://docs.python.org/\': None}\n'"
confold.py,0,"b'# -*- coding: utf-8 -*-\n#\n# BAL documentation build configuration file, created by\n# sphinx-quickstart on Tue Jul 14 11:29:00 2015.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n#cmd_folder = os.path.realpath(os.path.abspath(os.path.split(getfile(currentframe()))[0]))\n\nsys.path.insert(0, os.path.abspath(\'.\'))\n#sys.path.append(\'/usr/local/python-2.7.2/lib/python2.7\')\n\nsys.path.insert(0, os.path.abspath(\'./tests\'))\nsys.path.insert(0, os.path.abspath(\'./utilities\'))\n\n#sys.path.append(os.path.join(., \'tests\'))\n#sys.path.append(os.path.join(., \'utilities\'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\', \'sphinx.ext.doctest\', \'sphinx.ext.coverage\', \'sphinx.ext.viewcode\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'BAL\'\ncopyright = u\'2015, Geoscience Australia\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'1.0\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'1.0\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'BALdoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\'index\', \'BAL.tex\', u\'BAL Documentation\',\n   u\'Geoscience Australia\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'bal\', u\'BAL Documentation\',\n     [u\'Geoscience Australia\'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'BAL\', u\'BAL Documentation\',\n   u\'Geoscience Australia\', \'BAL\', \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n\n# -- Options for Epub output ---------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = u\'BAL\'\nepub_author = u\'Geoscience Australia\'\nepub_publisher = u\'Geoscience Australia\'\nepub_copyright = u\'2015, Geoscience Australia\'\n\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n#epub_language = \'\'\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n#epub_scheme = \'\'\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#epub_identifier = \'\'\n\n# A unique identification for the text.\n#epub_uid = \'\'\n\n# A tuple containing the cover image and cover page html template filenames.\n#epub_cover = ()\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_pre_files = []\n\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\n#epub_exclude_files = []\n\n# The depth of the table of contents in toc.ncx.\n#epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n#epub_tocdup = True\n'"
tests/run.py,0,"b'import unittest\nimport logging\n\nif \'discover\' not in dir(unittest.TestLoader):\n    import py26compat\n    unittest.TestLoader = py26compat.TestLoader\n\nlogging.disable(logging.CRITICAL)\n\nif __name__ == \'__main__\':\n    suite = unittest.TestLoader().discover(\'tests\', pattern = ""test_*.py"")\n    unittest.TextTestRunner(verbosity=2).run(suite)\n'"
tests/test_all_neighb.py,0,"b'""""""\n    Title: test_all_neighb.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing for ALL_NEIGHB dictionary in value_lookup.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestAllNEIGHB(unittest.TestCase):\n\n    def test_all_neighb(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.value_lookup import ALL_NEIGHB\n\n        rows = 10\n        cols = 10\n\n        i_list = [1, 3, 5, 7, 9]\n        jj_list = [2, 4, 5, 6, 8]\n        dire = [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\']\n\n        result_expect = [2, 7, 1, 8, 1, 1, 7, 2, 4, 5, 1, 8, 1, 1, 5, 4, 5, 4,\n                         1, 8, 1, 1, 4, 5, 6, 3, 1, 8, 1, 1, 3, 6, 8, 1, 1, 8,\n                         1, 1, 1, 8, 2, 7, 3, 6, 2, 3, 6, 2, 4, 5, 3, 6, 3, 3,\n                         5, 4, 5, 4, 3, 6, 3, 3, 4, 5, 6, 3, 3, 6, 3, 3, 3, 6,\n                         8, 1, 3, 6, 3, 1, 1, 6, 2, 7, 5, 4, 2, 5, 4, 2, 4, 5,\n                         5, 4, 4, 5, 4, 4, 5, 4, 5, 4, 5, 4, 4, 4, 6, 3, 5, 4,\n                         5, 3, 3, 4, 8, 1, 5, 4, 5, 1, 1, 4, 2, 7, 7, 2, 2, 7,\n                         2, 2, 4, 5, 7, 2, 4, 5, 2, 2, 5, 4, 7, 2, 5, 4, 2, 2,\n                         6, 3, 7, 2, 6, 3, 2, 2, 8, 1, 7, 2, 7, 1, 1, 2, 2, 7,\n                         9, 0, 2, 7, 0, 0, 4, 5, 9, 0, 4, 5, 0, 0, 5, 4, 9, 0,\n                         5, 4, 0, 0, 6, 3, 9, 0, 6, 3, 0, 0, 8, 1, 9, 0, 8, 1,\n                         0, 0]\n\n        result = []\n\n        for i in i_list:\n            for a_j in jj_list:\n                for one_dir in dire:\n                    neig = ALL_NEIGHB[one_dir](i, a_j, rows, cols)\n                    result.append(neig)\n\n        self.assertEqual(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_bal_cal.py,0,"b'""""""\n     Title: test_bal_cal.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-07-09\n     Description: Unit testing module for bal_cal function in calculate_bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\nfrom numpy.testing import assert_array_equal\n\n\nclass TestBalCal(unittest.TestCase):\n\n    def test_bal_cal(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(\n                                      getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n\n        input_folder = os.path.join(testdata_folder, \'input\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        veg_class = os.path.join(output_folder, ""veg_c"")\n        slope = os.path.join(output_folder, ""slope_c"")\n        aspect = os.path.join(output_folder, ""aspect_c"")\n        fdi = 80\n\n        if not arcpy.Exists(slope):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""slope_c""),\n                              slope)\n\n        if not arcpy.Exists(aspect):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""aspect_c""),\n                              aspect)\n\n        if not arcpy.Exists(veg_class):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""veg_c""),\n                              veg_class)\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        bal_max_expect = os.path.join(reference_folder, ""expect_bal_max.img"")\n\n        from calculate_bal import bal_cal\n\n        bal_cal(veg_class, slope, aspect, fdi)\n\n        compare_result = os.path.join(output_folder, ""compare_bal.txt"")\n\n        arcpy.RasterCompare_management(\'bal_max.img\', bal_max_expect, \'\',\n                                       \'Pixel Value\', \'\', compare_result)\n        if \'""true""\' not in open(compare_result).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        ds1 = os.path.join(output_folder, ""bal_max.img"")\n        if ds1 is None:\n            print \'Could not open bal_max.img\'\n            sys.exit(1)\n        bal_data = arcpy.RasterToNumPyArray(ds1, nodata_to_value=-99)\n\n        ds2 = bal_max_expect\n        if ds2 is None:\n            print \'Could not open expect_bal_max.img\'\n            sys.exit(1)\n        bal_expect = arcpy.RasterToNumPyArray(ds2, nodata_to_value=-99)\n\n        assert_array_equal(bal_data, bal_expect)\n\n        os.remove(compare_result)\n        os.remove(os.path.join(output_folder, ""compare_bal.xml""))\n\n        for a_dir in [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\', \'max\']:\n            output_bal = os.path.join(output_folder, \'bal_\' + a_dir + \'.img\')\n            if arcpy.Exists(output_bal):\n                arcpy.Delete_management(output_bal)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_bal_class.py,0,"b'""""""\n    Title: test_bal_class.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing module for BAL_CLASS dictionary in\n    bal_database.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestBALCLASS(unittest.TestCase):\n\n    def test_bal_class(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.bal_database import BAL_CLASS\n\n        result_expect = {1: 100, 2: 40, 3: 29, 4: 19, 5: 12.5}\n\n        self.assertEqual(BAL_CLASS, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_bal_esti.py,0,"b'""""""\n    Title: test_bal_esti.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing module for bal_esti function in calculate_bal.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestBalEsti(unittest.TestCase):\n\n    def test_bal_esti(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from calculate_bal import bal_esti\n\n        veg_list = [-99, 1, 2, 3, 4, 5, 6, 7]\n        dist_list = [12.5, 37.5, 62.5, 87.5]\n        slope_list = [-99, -1, 1, 2, 3, 4, 5, 6]\n        fdi_list = [80, 50]\n\n        result_expect = [-99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, 100, 19, 12.5, 12.5, 40, 12.5, 12.5,\n                         12.5, 29, 12.5, 12.5, 12.5, 40, 12.5, 12.5, 12.5, 19,\n                         12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 19, 12.5, -99,\n                         -99, -99, -99, -99, -99, 100, 19, 12.5, 12.5, 40,\n                         12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 40, 12.5,\n                         12.5, 12.5, 19, 12.5, 12.5, 12.5, 29, 12.5, 12.5,\n                         12.5, 19, 12.5, -99, -99, -99, -99, -99, -99, 100, 19,\n                         12.5, 12.5, 100, 12.5, 12.5, 12.5, 29, 12.5, 12.5,\n                         12.5, 40, 12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 29,\n                         12.5, 12.5, 12.5, 29, 12.5, -99, -99, -99, -99, -99,\n                         -99, 100, 29, 12.5, 12.5, 100, 19, 12.5, 12.5, 29,\n                         12.5, 12.5, 12.5, 40, 12.5, 12.5, 12.5, 29, 12.5,\n                         12.5, 12.5, 40, 12.5, 12.5, 12.5, 29, 12.5, -99, -99,\n                         -99, -99, -99, -99, 100, 40, 19, 12.5, 100, 29, 12.5,\n                         12.5, 40, 12.5, 12.5, 12.5, 100, 19, 12.5, 12.5, 29,\n                         12.5, 12.5, 12.5, 100, 19, 12.5, 12.5, 29, 12.5, -99,\n                         -99, -99, -99, -99, -99, 100, 100, 29, 12.5, 100, 29,\n                         19, 12.5, 40, 12.5, 12.5, 12.5, 100, 19, 12.5, 12.5,\n                         40, 12.5, 12.5, 12.5, 100, 19, 12.5, 12.5, 40, 12.5,\n                         -99, -99, -99, -99, -99, -99, 200, 200, 200, 200, 200,\n                         200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n                         200, 200, 200, 200, 200, 200, 200, 200, 200, 200, -99,\n                         -99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, -99, -99, -99, -99, -99, -99, -99, -99,\n                         -99, -99, -99, -99, 40, 12.5, 12.5, 12.5, 29, 12.5,\n                         12.5, 12.5, 29, 12.5, 12.5, 12.5, 40, 12.5, 12.5,\n                         12.5, 19, 12.5, 12.5, 12.5, 19, 12.5, 12.5, 12.5, 29,\n                         12.5, 12.5, 12.5, -99, -99, -99, -99, 40, 12.5, 12.5,\n                         12.5, 29, 12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 40,\n                         12.5, 12.5, 12.5, 19, 12.5, 12.5, 12.5, 19, 12.5,\n                         12.5, 12.5, 29, 12.5, 12.5, 12.5, -99, -99, -99, -99,\n                         100, 19, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 29, 12.5,\n                         12.5, 12.5, 40, 12.5, 12.5, 12.5, 29, 12.5, 12.5,\n                         12.5, 19, 12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, -99,\n                         -99, -99, -99, 100, 19, 12.5, 12.5, 40, 12.5, 12.5,\n                         12.5, 29, 12.5, 12.5, 12.5, 40, 12.5, 12.5, 12.5, 29,\n                         12.5, 12.5, 12.5, 29, 12.5, 12.5, 12.5, 29, 12.5,\n                         12.5, 12.5, -99, -99, -99, -99, 100, 29, 12.5, 12.5,\n                         100, 19, 12.5, 12.5, 40, 12.5, 12.5, 12.5, 100, 19,\n                         12.5, 12.5, 29, 12.5, 12.5, 12.5, 40, 12.5, 12.5,\n                         12.5, 40, 12.5, 12.5, 12.5, -99, -99, -99, -99, 100,\n                         29, 19, 12.5, 100, 19, 12.5, 12.5, 40, 12.5, 12.5,\n                         12.5, 100, 19, 12.5, 12.5, 40, 12.5, 12.5, 12.5, 40,\n                         12.5, 12.5, 12.5, 40, 12.5, 12.5, 12.5, -99, -99, -99,\n                         -99, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n                         200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200,\n                         200, 200, 200, 200, 200, 200, 200]\n\n        result = []\n\n        for fdi in fdi_list:\n            for slope in slope_list:\n                for veg in veg_list:\n                    for dist in dist_list:\n                        bal = bal_esti(veg, dist, slope, fdi)\n                        result.append(bal)\n\n        self.assertEqual(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_cal_slope_aspect.py,0,"b'""""""\n     Title: test_cal_slope_aspect.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for cal_slope_aspect in sa_tools.py.\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nimport numpy\nfrom inspect import getfile, currentframe\n\n\nclass TestCalSlopeAspect(unittest.TestCase):\n\n    def test_cal_slope_aspect(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(getfile(\n                                      currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        dem = os.path.join(input_folder, ""dem.img"")\n        slope_result = os.path.join(output_folder, ""result_s"")\n        aspect_result = os.path.join(output_folder, ""result_a"")\n        slope_expect = os.path.join(reference_folder, ""expect_s"")\n        aspect_expect = os.path.join(reference_folder, ""expect_a"")\n\n        from utilities.sa_tools import cal_slope_aspect\n\n        cal_slope_aspect(dem, slope_result, aspect_result)\n\n        compare_result_slope = os.path.join(output_folder,\n                                            ""compare_slope.txt"")\n        compare_result_aspect = os.path.join(output_folder,\n                                             ""compare_aspect.txt"")\n\n        arcpy.RasterCompare_management(slope_result, slope_expect, \'\',\n                             \'Pyramids Exist; Pixel Value; Statistics; Compression Type\', \'\',\n                             compare_result_slope)\n        if \'""true""\' not in open(compare_result_slope).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        arcpy.RasterCompare_management(aspect_result, aspect_expect, \'\',\n                            \'Pyramids Exist; Pixel Value; Statistics; Compression Type\', \'\',\n                            compare_result_aspect)\n        if \'""true""\' not in open(compare_result_aspect).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        # compare pixel value\n        nodata_value = -99\n        slope_arr = arcpy.RasterToNumPyArray(slope_result,\n                                             nodata_to_value=nodata_value)\n        slope_arr_exp = arcpy.RasterToNumPyArray(slope_expect,\n                                                 nodata_to_value=nodata_value)\n\n        numpy.testing.assert_array_almost_equal(slope_arr, slope_arr_exp,\n                                                decimal=4)\n\n        aspec_arr = arcpy.RasterToNumPyArray(aspect_result,\n                                              nodata_to_value=nodata_value)\n        aspec_arr_exp = arcpy.RasterToNumPyArray(aspect_expect,\n                                                  nodata_to_value=nodata_value)\n\n        numpy.testing.assert_array_almost_equal(aspec_arr, aspec_arr_exp,\n                                                decimal=4)\n\n        if arcpy.Exists(slope_result):\n            arcpy.Delete_management(slope_result)\n\n        if arcpy.Exists(aspect_result):\n            arcpy.Delete_management(aspect_result)\n\n        try:\n            os.remove(compare_result_slope)\n            os.remove(os.path.join(output_folder, ""compare_slope_r.xml""))\n            os.remove(compare_result_aspect)\n            os.remove(os.path.join(output_folder, ""compare_aspect_r.xml""))\n        except OSError:\n            pass\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_clip_array.py,3,"b'""""""\n    Title: test_clip_array.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2016-06-23\n    Description: Unit testing module for clip_arry function in sa_tools.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nimport numpy as np\nfrom inspect import getfile, currentframe\n\n\nclass TestCLIPARRAY(unittest.TestCase):\n\n    def test_clip_array(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.sa_tools import clip_array\n\n        pixelwidth = 30\n        pixelheight = 30\n\n        x_left = 395\n        y_upper = 849\n\n        extent_list = [[494.89, 748.21, 584.20, 838.35],\n                       [484.25, 768.78, 565.88, 851.64],\n                       [485.00, 759.00, 575.00, 849.00]]\n\n        expected = np.array([[3,  4, 5],\n                             [10, 11, 12],\n                             [17, 18, 19]])\n\n        data = np.arange(49).reshape(7, 7)\n\n        for extent in extent_list:\n\n            data_clip = clip_array(data, x_left, y_upper, pixelwidth,\n                                   pixelheight, extent)\n\n            np.testing.assert_array_equal(expected, data_clip)\n\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_convo.py,18,"b'""""""\n    Title: test_convo.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-01\n    Description: Unit testing module for convo function in calculate_bal.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nimport numpy as np\nfrom inspect import getfile, currentframe\nfrom numpy.testing import assert_array_equal\n\n\nclass TestConvo(unittest.TestCase):\n\n    def test_convo(self):\n\n        bal_exp_w = np.array([[-99., 29., 100., 19., 100., 40., 200., 200.],\n                              [-99., 19., 100., 100., 40., 40., 200., 200.],\n                              [-99., 40., 29., 100., 100., 29., 100., 29.],\n                              [-99., 100., 40., 29., 40., 12.5, 29., 40.],\n                              [-99., -99., 29., 40., 19., 29., 29., 29.],\n                              [-99., 40., 100., 100., 29., 40., 29., 40.],\n                              [-99., 100., 40., 29., 100., 100., 40., 100.],\n                              [-99., 100., 29., 19., 29., 100., 100., 200.]])\n\n        bal_exp_e = np.array([[100., 200., 200., 200., 200., 40., -99., -99.],\n                              [100., 200., 200., 200., 200., 19., 29., -99.],\n                              [100., 100., 100., 29., 100., 29., 29., -99.],\n                              [40., 29., 40., 12.5, 29., 40., 19., -99.],\n                              [29., 40., 19., 29, 29., 29, 40., -99.],\n                              [100., 100., 29., 40., 29., 40., 29., -99.],\n                              [40., 40., 100., 100., 40., 100., 40., -99.],\n                              [29, 19., 200., 200., 200., 200., -99., -99.]])\n\n        bal_exp_n = np.array([[-99., -99., -99., -99., -99., -99., -99., -99.],\n                              [29., 100., -99., 100., 40., 200., 40., -99.],\n                              [19, 100., 100, 40., 40., 200., 19., 29.],\n                              [40., 29., 100., 100., 29., 200., 29., 29.],\n                              [100., 40., 100., 40., 12.5, 200., 40., 19.],\n                              [29., 29., 40., 19., 29, 200, 29, 40.],\n                              [40., 100., 100., 29., 40., 29., 40., 29],\n                              [100., 40., 29., 100., 100., 40., 100., 40.]])\n\n        bal_exp_s = np.array([[19., 100., 100., 40., 40., 200., 19., 29.],\n                              [40., 29, 100., 100., 29., 100., 29., 29.],\n                              [100., 40., 29., 40., 12.5, 29., 40., 19.],\n                              [12.5, 29., 40., 19., 29, 29., 200., 40.],\n                              [40., 100., 100., 40., 40., 29, 200., 29],\n                              [100., 40., 29., 100., 100., 100., 200., 40.],\n                              [100., 29., 19., 29., 100., 100., 200., -99.],\n                              [-99., -99., -99., -99., -99., -99., -99.,\n                               -99.]])\n\n        bal_exp_nw = np.array([[-99., -99., -99., -99., -99., -99., -99.,\n                                -99.],\n                               [-99., 19., 100., -99., 40., 29., 200., 29.],\n                               [-99., 12.5, 100, 100., 29., 29., 200., 200.],\n                               [-99., 29., 19., 100., 40., 29., 40., 200.],\n                               [-99., 100., 29., 19., 29., 12.5, 19., 29.],\n                               [-99., -99., 19., 29., 12.5, 19, 19., 19],\n                               [-99., 29., 100., 40., 19., 29., 19., 29.],\n                               [-99., 40., 29., 19., 100., 100., 29., 40.]])\n\n        bal_exp_ne = np.array([[-99., -99., -99., -99., -99., -99., -99.,\n                                -99.],\n                               [100., -99., 40., 29., 200., 29., -99., -99.],\n                               [100., 100., 29, 200., 200., 12.5, 19., -99.],\n                               [19., 100., 200., 200., 40., 29., 29., -99.],\n                               [29., 19., 200., 12.5, 19., 29., 12.5, -99.],\n                               [19., 29., 12.5, 19., 19., 19., 29., -99.],\n                               [100., 40., 19., 29., 19., 29., 19., -99.],\n                               [29., 19., 100., 100., 29., 40., 29., -99.]])\n\n        bal_exp_se = np.array([[100., 100., 29., 29., 200., 12.5, 19., -99.],\n                               [19, 100., 40., 29., 40., 29., 29., -99.],\n                               [29., 19., 29, 12.5, 19., 29., 12.5, -99.],\n                               [19., 29., 12.5, 19, 19., 19., 29., -99.],\n                               [100., 40., 19., 200., 19., 29, 19., -99.],\n                               [29., 19., 100., 100., 200., 40., 29., -99.],\n                               [29., 12.5, 19., 40., 100., 200., -99., -99.],\n                               [-99., -99., -99., -99., -99., -99., -99.,\n                                -99.]])\n\n        bal_exp_sw = np.array([[-99., 12.5, 100., 100., 29., 29., 200., 12.5],\n                               [-99., 29., 19., 100., 40., 29., 40., 29.],\n                               [-99., 100., 29, 19., 29., 12.5, 19., 29.],\n                               [-99., -99., 19., 29., 12.5, 19, 19., 19],\n                               [-99., 29., 100., 40., 19., 29., 19., 29.],\n                               [-99., 40., 29., 19., 100., 100., 29., 40.],\n                               [-99., 40., 29., 12.5, 19., 40., 100., 200.],\n                               [-99., -99., -99., -99., -99., -99., -99.,\n                                -99.]])\n\n        result_list = [bal_exp_w, bal_exp_e, bal_exp_n, bal_exp_s, bal_exp_nw,\n                       bal_exp_ne, bal_exp_se, bal_exp_sw]\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from calculate_bal import convo\n\n        veg_data = np.array([[  3.,  1.,  2.,  4.,  5.,  3.,  3.,  -99.],\n                             [  7.,  1.,  1.,  3.,  3.,  4.,  5.,  6.],\n                             [  6.,  7.,  1.,  4.,  5.,  4.,  5.,  5.],\n                             [  2.,  5.,  6.,  4.,  5.,  3.,  4.,  5.],\n                             [-99.,  3.,  4.,  5.,  7.,  5.,  7.,  6.],\n                             [  4.,  1.,  2.,  3.,  4.,  5.,  6.,  7.],\n                             [  4.,  4.,  5.,  1.,  2.,  3.,  4.,  5.],\n                             [  6.,  7.,  5.,  5.,  6.,  1.,  2.,  3.]])\n\n\n        slope_data = np.array([[ 1., 2.,  -99., 4., 5., 6., 5., 5.],\n                               [ 1., 2.,  3.,  4., 5., 6., 1., 2.],\n                               [ 3., 3., 5., 4., 4., 5., 4., 4.],\n                               [ 5., 5., 6., 2., -99., 2., 3., 1.],\n                               [-99., 2.,  3., 5., 2., 3., 2., 3.],\n                               [  2., 3.,  3., 3., 3., 3., 3., 3.],\n                               [ 4., 3., 3., 4., 4., 4., 4., 5.],\n                               [ 4., 4., 1., 3., 4., 5., 6., -99.]])\n\n        aspect_data = dict([(\'w\', np.array([\n                                           [7., 7., 7., 7., 7., 7., 7., 9.],\n                                           [7., 7., 7., 7., 7., 7., 7., 7.],\n                                           [7., 7., 7., 7., 7., 7., 7., 7.],\n                                           [7., 7., 1., 7., 2., 7., 7., 7.],\n                                           [3., 7., 7., 4., 7., 7., 7., 7.],\n                                           [7., 7., 7., 7., 7., 7., 7., 7.],\n                                           [7., 7., 7., 7., 7., 7., 7., 7.],\n                                           [7., 7., 7., 7., 7., 7., 7., 7.]])),\n                             (\'e\', np.array([\n                                           [3., 3., 3., 3., 3., 3., 3., 9.],\n                                           [3., 3., 3., 3., 3., 3., 3., 3.],\n                                           [3., 3., 3., 3., 3., 3., 3., 3.],\n                                           [3., 3., 9., 3., 9., 3., 3., 3.],\n                                           [9., 3., 3., 9., 3., 3., 3., 3.],\n                                           [3., 3., 3., 3., 3., 3., 3., 3.],\n                                           [3., 3., 3., 3., 3., 3., 3., 3.],\n                                           [3., 3., 3., 3., 3., 3., 3., 3.]])),\n                             (\'n\', np.array([\n                                           [1., 1., 1., 1., 1., 1., 1., 9.],\n                                           [1., 1., 1., 1., 1., 1., 1., 1.],\n                                           [1., 1., 1., 1., 1., 1., 1., 1.],\n                                           [1., 1., 9., 1., 9., 1., 1., 1.],\n                                           [9., 1., 1., 9., 1., 1., 1., 1.],\n                                           [1., 1., 1., 1., 1., 1., 1., 1.],\n                                           [1., 1., 1., 1., 1., 1., 1., 1.],\n                                           [1., 1., 1., 1., 1., 1., 1., 1.]])),\n                             (\'s\', np.array([\n                                           [5., 5., 5., 5., 5., 5., 5., 9.],\n                                           [5., 5., 5., 5., 5., 5., 5., 5.],\n                                           [5., 5., 5., 5., 5., 5., 5., 5.],\n                                           [5., 5., 9., 5., 9., 5., 5., 5.],\n                                           [9., 5., 5., 9., 5., 5., 5., 5.],\n                                           [5., 5., 5., 5., 5., 5., 5., 5.],\n                                           [5., 5., 5., 5., 5., 5., 5., 5.],\n                                           [5., 5., 5., 5., 5., 5., 5., 5.]])),\n                             (\'nw\', np.array([\n                                           [8., 8., 8., 8., 8., 8., 8., 9.],\n                                           [8., 8., 8., 8., 8., 8., 8., 8.],\n                                           [8., 8., 8., 8., 8., 8., 8., 8.],\n                                           [8., 8., 9., 8., 9., 8., 8., 8.],\n                                           [9., 8., 8., 9., 8., 8., 8., 8.],\n                                           [8., 8., 8., 8., 8., 8., 8., 8.],\n                                           [8., 8., 8., 8., 8., 8., 8., 8.],\n                                           [8., 8., 8., 8., 8., 8., 8., 8.]])),\n                             (\'ne\', np.array([\n                                           [2., 2., 2., 2., 2., 2., 2., 9.],\n                                           [2., 2., 2., 2., 2., 2., 2., 2.],\n                                           [2., 2., 2., 2., 2., 2., 2., 2.],\n                                           [2., 2., 9., 2., 9., 2., 2., 2.],\n                                           [9., 2., 2., 9., 2., 2., 2., 2.],\n                                           [2., 2., 2., 2., 2., 2., 2., 2.],\n                                           [2., 2., 2., 2., 2., 2., 2., 2.],\n                                           [2., 2., 2., 2., 2., 2., 2., 2.]])),\n                             (\'se\', np.array([\n                                           [4., 4., 4., 4., 4., 4., 4., 9.],\n                                           [4., 4., 4., 4., 4., 4., 4., 4.],\n                                           [4., 4., 4., 4., 4., 4., 4., 4.],\n                                           [4., 4., 9., 4., 9., 4., 4., 4.],\n                                           [9., 4., 4., 9., 4., 4., 4., 4.],\n                                           [4., 4., 4., 4., 4., 4., 4., 4.],\n                                           [4., 4., 4., 4., 4., 4., 4., 4.],\n                                           [4., 4., 4., 4., 4., 4., 4., 4.]])),\n                             (\'sw\', np.array([\n                                           [6., 6., 6., 6., 6., 6., 6., 9.],\n                                           [6., 6., 6., 6., 6., 6., 6., 6.],\n                                           [6., 6., 6., 6., 6., 6., 6., 6.],\n                                           [6., 6., 9., 6., 9., 6., 6., 6.],\n                                           [9., 6., 6., 9., 6., 6., 6., 6.],\n                                           [6., 6., 6., 6., 6., 6., 6., 6.],\n                                           [6., 6., 6., 6., 6., 6., 6., 6.],\n                                           [6., 6., 6., 6., 6., 6., 6., 6.]]))\n                            ])\n\n        pixel_width = 25\n\n        dire = [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\']\n\n        fdi = 80\n\n        index = 0\n\n        for one_dir in dire:\n\n            outdata = convo(one_dir, veg_data, slope_data,\n                            aspect_data[one_dir], pixel_width, fdi)\n\n            bal_exp = result_list[index]\n\n            assert_array_equal(outdata,  bal_exp)\n\n            index += 1\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n\n'"
tests/test_dist_limit.py,0,"b'""""""\n    Title: test_dist_limit.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing module for DIST_LIMIT_UPSLOPE and\n    DIST_LIMIT_DOWNSLOPE dictionary in bal_database.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestDISTLIMIT(unittest.TestCase):\n\n    def test_dist_limit(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.bal_database import DIST_LIMIT_UPSLOPE\n        from utilities.bal_database import DIST_LIMIT_DOWNSLOPE\n\n        others_80 = DIST_LIMIT_UPSLOPE[80]\n        downslope_80 = DIST_LIMIT_DOWNSLOPE[80]\n\n        expect_others = {1: [16, 21, 31, 42], 2: [10, 14, 20, 29],\n                         3: [7, 9, 13, 19], 4: [10, 13, 19, 27],\n                         5: [6, 8, 12, 17], 6: [6, 9, 13, 19],\n                         7: [6, 8, 12, 17]}\n\n        expect_downslope = {(2, 1): [20, 27, 37, 50], (2, 2): [13, 17, 25, 35],\n                            (2, 3): [7, 10, 15, 22], (2, 4): [11, 15, 22, 31],\n                            (2, 5): [7, 9, 13, 20], (2, 6): [8, 11, 17, 24],\n                            (2, 7): [7, 9, 14, 20],\n                            (3, 1): [26, 33, 46, 61], (3, 2): [16, 22, 31, 43],\n                            (3, 3): [8, 11, 17, 25], (3, 4): [12, 17, 24, 35],\n                            (3, 5): [7, 10, 15, 23], (3, 6): [11, 15, 22, 31],\n                            (3, 7): [8, 10, 16, 23],\n                            (4, 1): [33, 42, 56, 73], (4, 2): [21, 28, 39, 53],\n                            (4, 3): [9, 13, 19, 28], (4, 4): [14, 19, 28, 39],\n                            (4, 5): [8, 11, 18, 26], (4, 6): [14, 19, 28, 39],\n                            (4, 7): [9, 12, 18, 26],\n                            (5, 1): [42, 52, 68, 87], (5, 2): [27, 35, 48, 64],\n                            (5, 3): [10, 15, 22, 31], (5, 4): [15, 21, 31, 43],\n                            (5, 5): [9, 13, 20, 29], (5, 6): [18, 25, 36, 48],\n                            (5, 7): [10, 14, 21, 30]}\n\n        self.assertEqual(others_80, expect_others)\n        self.assertEqual(downslope_80, expect_downslope)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_extract_by_mask.py,0,"b'""""""\n    Title: test_extract_by_mask.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2016-06-24\n    Description: Unit testing module for extract_by_mask function in\n    sa_tools.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nimport arcpy\nfrom inspect import getfile, currentframe\n\n\nclass TestEXTRACTBYMASK(unittest.TestCase):\n\n    def test_extract_by_mask(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n        refer_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.sa_tools import extract_by_mask\n\n        arcpy.env.overwriteOutput = True\n\n        raster = os.path.join(input_folder, ""vege_mga.img"")\n        result = os.path.join(output_folder, ""extracted_raster.img"")\n\n        extent_list = [os.path.join(input_folder, ""mask_extent_small.shp""),\n                       os.path.join(input_folder, ""mask_extent_large.shp"")]\n\n        expec_list = [os.path.join(refer_folder, ""expect_extracted_small.img""),\n                      os.path.join(refer_folder, ""expect_extracted_large.img"")]\n\n        index = 0\n        for extent in extent_list:\n\n            extract_by_mask(raster, extent, result)\n\n            compare_result = os.path.join(output_folder, ""compare_result.txt"")\n\n            arcpy.RasterCompare_management(result, expec_list[index], \'\',\n                                           \'Pixel Type\', \'\', compare_result,\n                                           \'\', \'\', \'\')\n\n            if \'""true""\' not in open(compare_result).read():\n                self.assertEqual(1, 1, \'No errors\')\n            else:\n                self.assertEqual(1, 0, \'Has errors\')\n\n            if arcpy.Exists(result):\n                arcpy.Delete_management(result)\n\n            os.remove(compare_result)\n            os.remove(os.path.join(output_folder, ""compare_result.xml""))\n\n            index += 1\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_find_aoi.py,0,"b'""""""\n     Title: test_findAOI.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for find_aoi function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestFindAOI(unittest.TestCase):\n\n    def test_find_aoi(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(getfile(\n                                      currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        dem = os.path.join(input_folder, ""dem.img"")\n        veg = os.path.join(input_folder, ""vege.img"")\n\n        from bal import find_aoi\n\n        extent_list = [\'DEFAULT\', \'MAXOF\', \'MINOF\',\n                       \'343000 5850000 347000 5852000 343000 5850000 \\\n                       347000 5852000\']\n\n        mask_expect_list = [os.path.join(reference_folder,\n                                         ""expect_mask_others.shp""),\n                            os.path.join(reference_folder,\n                                         ""expect_mask_others.shp""),\n                            os.path.join(reference_folder,\n                                         ""expect_mask_others.shp""),\n                            os.path.join(reference_folder, ""expect_mask.shp"")]\n\n        index = 0\n        for extent in extent_list:\n            mask = find_aoi(extent, dem, veg)\n\n            compare_result_mask = os.path.join(input_folder,\n                                               ""compare_mask_"" +\n                                               extent + "".txt"")\n\n            arcpy.FeatureCompare_management(mask, mask_expect_list[index],\n                                            \'Id\', \'\', \'\', \'\', \'\', \'\', \'\', \'\',\n                                            \'\', compare_result_mask)\n            if \'""true""\' not in open(compare_result_mask).read():\n                self.assertEqual(1, 1, \'No errors\')\n            else:\n                self.assertEqual(1, 0, \'Has errors\')\n\n            os.remove(compare_result_mask)\n            os.remove(os.path.join(input_folder, ""compare_mask_"" +\n                                               extent + "".xml""))\n\n            if arcpy.Exists(mask):\n                arcpy.Delete_management(mask)\n\n            index += 1\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_find_common_area.py,0,"b'""""""\n     Title: test_find_common_area.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for find_common_area function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestFindCommonArea(unittest.TestCase):\n\n    def test_find_common_area(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(\n                                      getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n\n        input_folder = os.path.join(testdata_folder, \'input\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        veg_r = os.path.join(output_folder, ""veg_r"")\n        slope_r = os.path.join(output_folder, ""slope_r"")\n        aspect_r = os.path.join(output_folder, ""aspect_r"")\n\n        if not arcpy.Exists(slope_r):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""slope_r""),\n                              slope_r)\n\n        if not arcpy.Exists(aspect_r):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""aspect_r""),\n                              aspect_r)\n\n        if not arcpy.Exists(veg_r):\n            arcpy.CopyRaster_management(os.path.join(input_folder, ""veg_r""),\n                              veg_r)\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        veg_expect = os.path.join(reference_folder, ""expect_v_c"")\n        slope_expect = os.path.join(reference_folder, ""expect_s_c"")\n        aspect_expect = os.path.join(reference_folder, ""expect_a_c"")\n\n        from bal import find_common_area\n\n        veg_c, slope_c, aspect_c = find_common_area(veg_r, slope_r, aspect_r)\n\n        compare_result_veg = os.path.join(output_folder, ""compare_veg_c.txt"")\n        compare_result_slope = os.path.join(output_folder,\n                                            ""compare_slope_c.txt"")\n        compare_result_aspect = os.path.join(output_folder,\n                                             ""compare_aspect_c.txt"")\n\n        arcpy.RasterCompare_management(veg_c, veg_expect, \'\', \'Pyramids Exist\', \'\',\n                                       compare_result_veg)\n        if \'""true""\' not in open(compare_result_veg).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        arcpy.RasterCompare_management(slope_c, slope_expect, \'\', \'\', \'\',\n                                       compare_result_slope)\n        if \'""true""\' not in open(compare_result_slope).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        arcpy.RasterCompare_management(aspect_c, aspect_expect, \'\', \'\', \'\',\n                                       compare_result_aspect)\n        if \'""true""\' not in open(compare_result_aspect).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        if arcpy.Exists(veg_c):\n            arcpy.Delete_management(veg_c)\n        if arcpy.Exists(slope_c):\n            arcpy.Delete_management(slope_c)\n        if arcpy.Exists(aspect_c):\n            arcpy.Delete_management(aspect_c)\n\n        os.remove(compare_result_veg)\n        os.remove(compare_result_slope)\n        os.remove(compare_result_aspect)\n        os.remove(os.path.join(output_folder, ""compare_veg_c.xml""))\n        os.remove(os.path.join(output_folder, ""compare_slope_c.xml""))\n        os.remove(os.path.join(output_folder, ""compare_aspect_c.xml""))\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_find_dist_class.py,0,"b'""""""\n    Title: test_find_dist_class.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing for find_dist_class function in calculate_bal.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestFindDistClass(unittest.TestCase):\n\n    def test_find_dist_class(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from calculate_bal import find_dist_class\n\n        dist_list = [12.5, 37.5, 62.5, 87.5]\n        dist_limit_list = [[16, 21, 31, 42],\n                           [11, 15, 22, 31],\n                           [42, 52, 68, 87]]\n\n        result_expect = [1, 4, 5, 5, 2, 5, 5, 5, 1, 1, 3, 5]\n\n        result = []\n\n        for dist_limit in dist_limit_list:\n            for dist in dist_list:\n                dist_class = find_dist_class(dist, dist_limit)\n                result.append(dist_class)\n\n        self.assertEqual(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_get_extent_mask.py,0,"b'""""""\n     Title: test_get_extent_mask.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for get_extent_mask function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestGetExtentMask(unittest.TestCase):\n\n    def test_get_extent_mask(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(getfile(\n                                      currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        mask_expect = os.path.join(reference_folder, ""expect_extent_mask.shp"")\n\n        from bal import get_extent_mask\n\n        extent = \'343000 5850000 347000 5852000 343000 5850000 347000 5852000\'\n\n        mask = os.path.join(output_folder, ""mask.shp"")\n        get_extent_mask(extent, mask)\n\n        compare_result_mask = os.path.join(output_folder,\n                                            ""compare_mask.txt"")\n\n        arcpy.FeatureCompare_management(mask, mask_expect, \'Id\', \'\', \'\', \'\', \'\',\n                                       \'\', \'\', \'\', \'\', compare_result_mask)\n        if \'""true""\' not in open(compare_result_mask).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        if arcpy.Exists(mask):\n            arcpy.Delete_management(mask)\n\n        os.remove(compare_result_mask)\n        os.remove(os.path.join(output_folder, ""compare_mask.xml""))\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_get_footprint.py,0,"b'""""""\n     Title: test_findAOI.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for find_aoi function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestGetFootPrint(unittest.TestCase):\n\n    def test_get_footprint(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(getfile(\n                                      currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        veg = os.path.join(input_folder, ""vege.img"")\n\n        from bal import get_footprint\n\n        footprint_expect = os.path.join(reference_folder,\n                                        ""expect_footprint.shp"")\n\n\n        footprint = \'footprint.shp\'\n        get_footprint(veg, footprint)\n\n        compare_result_footprint = os.path.join(input_folder,\n                                           ""compare_footprint.txt"")\n\n        arcpy.FeatureCompare_management(footprint, footprint_expect,\n                                        \'Id\', \'\', \'\', \'\', \'\', \'\', \'\', \'\',\n                                        \'\', compare_result_footprint)\n\n        if \'""true""\' not in open(compare_result_footprint).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        os.remove(compare_result_footprint)\n        os.remove(os.path.join(input_folder, ""compare_footprint.xml""))\n\n        if arcpy.Exists(footprint):\n            arcpy.Delete_management(footprint)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_get_max_bal.py,5,"b'""""""\n    Title: test_get_max_bal.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2016-05-27\n    Description: Unit testing for get_max_bal function in calculate_bal.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\nimport numpy as np\n\n\nclass TestGetMaxBal(unittest.TestCase):\n\n    def test_get_max_bal(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from calculate_bal import get_max_bal\n\n        a = np.array([[-99., 29., 100., 19.],\n                      [-99., 19., 100., -99],\n                      [-99., 40., 29., 100.],\n                      [-99., 100., 40., -99]])\n\n        b = np.array([[100., 200., 200., 200.],\n                      [100., -99, 200., 200.],\n                      [100., 100., 100., 29.],\n                      [40., 29., 40., -99]])\n\n        c = np.array([[-99., -99., -99., -99.],\n                      [-99, 100., -99., 100.],\n                      [19, 100., 100, -99],\n                      [40., 29., 100., -99]])\n\n        result_expect = np.array([[100., 200., 200., 200.],\n                                  [100., 100., 200., 200.],\n                                  [100, 100., 100, 100.],\n                                  [40., 100., 100., -99]])\n\n        array_list = [a, b, c]\n\n        result = get_max_bal(array_list)\n\n        np.testing.assert_array_equal(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_get_slope_aspect.py,0,"b'""""""\n     Title: test_get_slope_aspect.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-06-24\n     Description: Unit testing module for get_slope_aspect function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestGetSlopeAspect(unittest.TestCase):\n\n    def test_get_slope_aspect(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                      os.path.split(getfile(\n                                      currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        dem = os.path.join(input_folder, ""dem.img"")\n        mask = os.path.join(input_folder, ""test_mask.shp"")\n        slope_expect = os.path.join(reference_folder, ""expect_s_r"")\n        aspect_expect = os.path.join(reference_folder, ""expect_a_r"")\n\n        from bal import get_slope_aspect\n\n        output_folder = os.path.join(testdata_folder, \'output\')\n\n        slope, aspect = get_slope_aspect(dem, output_folder, mask)\n\n        compare_result_slope = os.path.join(output_folder,\n                                            ""compare_slope_r.txt"")\n        compare_result_aspect = os.path.join(output_folder,\n                                             ""compare_aspect_r.txt"")\n\n        arcpy.RasterCompare_management(slope, slope_expect, \'\', \'Pyramids Exist; Pixel Value\',\n                                       \'\', compare_result_slope)\n        if \'""true""\' not in open(compare_result_slope).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        arcpy.RasterCompare_management(aspect, aspect_expect, \'\', \'Pyramids Exist\', \'\',\n                                       compare_result_aspect)\n        if \'""true""\' not in open(compare_result_aspect).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        if arcpy.Exists(slope):\n            arcpy.Delete_management(slope)\n\n        if arcpy.Exists(aspect):\n            arcpy.Delete_management(aspect)\n\n        os.remove(compare_result_slope)\n        os.remove(os.path.join(output_folder, ""compare_slope_r.xml""))\n        os.remove(compare_result_aspect)\n        os.remove(os.path.join(output_folder, ""compare_aspect_r.xml""))\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_get_slope_in_aspect.py,3,"b'""""""\n    Title: test_get_slope_in_aspect.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-01\n    Description: Unit testing module for get_slope_in_aspect function\n    in calculate_bal.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nimport numpy as np\nfrom inspect import getfile, currentframe\nfrom numpy.testing import assert_array_equal\n\n\nclass TestGetSlopeInAspect(unittest.TestCase):\n\n    def test_get_slope_in_aspect(self):\n\n        slope_exp_w =  np.array([[1., 2., -99., 4., 5., 6., 5., -1.],\n                                 [1., 2., 3., 4., 5., 6., 1., 2.],\n                                 [3., 3., 5., 4., 4., 5., 4., 4.],\n                                 [5., 5., -1., 2., -99., 2., 3., 1.],\n                                 [-99., 2., 3., -1., 2., 3., 2., 3.],\n                                 [2., 3., 3., 3., 3., 3., 3., 3.],\n                                 [4., 3., 3., 4., 4., 4., 4., 5.],\n                                 [4., 4., 1., 3., 4., 5., 6., -99.]])\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from calculate_bal import get_slope_in_aspect\n\n        slope_data =  np.array([[ 1., 2.,  -99., 4., 5., 6., 5., 5.],\n                                [ 1., 2.,  3.,  4., 5., 6., 1., 2.],\n                                [ 3., 3., 5., 4., 4., 5., 4., 4.],\n                                [ 5., 5., 6., 2., -99., 2., 3., 1.],\n                                [-99., 2.,  3., 5., 2., 3., 2., 3.],\n                                [  2., 3.,  3., 3., 3., 3., 3., 3.],\n                                [ 4., 3., 3., 4., 4., 4., 4., 5.],\n                                [ 4., 4., 1., 3., 4., 5., 6., -99.]])\n\n        aspect_data = np.array([[7., 7., 7., 7., 7., 7., 7., 9.],\n                                [7., 7., 7., 7., 7., 7., 7., 7.],\n                                [7., 7., 7., 7., 7., 7., 7., 7.],\n                                [7., 7., 1., 7., 2., 7., 7., 7.],\n                                [3., 7., 7., 4., 7., 7., 7., 7.],\n                                [7., 7., 7., 7., 7., 7., 7., 7.],\n                                [7., 7., 7., 7., 7., 7., 7., 7.],\n                                [7., 7., 7., 7., 7., 7., 7., 7.]])\n\n        aspect_value = 7\n        rows = 8\n        cols = 8\n\n        slope_in_w = get_slope_in_aspect(slope_data, aspect_data, rows, cols,\n                                         aspect_value)\n\n        assert_array_equal(slope_in_w, slope_exp_w)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n\n'"
tests/test_point_c.py,0,"b'""""""\n    Title: test_point_c.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing module for POINT_C dictionary in value_lookup.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestPointC(unittest.TestCase):\n\n    def test_point_c(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.value_lookup import ALL_NEIGHB, POINT_C\n\n        rows = 10\n        cols = 10\n\n        i_list = [1, 3, 5, 7, 9]\n        jj_list = [2, 4, 6, 8]\n\n        dire = [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\']\n\n        result_expect = [1, 0, 3, 4, 5, 6, 2, 2, 2, 2, 2, 1, 3, 3, 4, 5, 6, 1,\n                         0, 3, 2, 1, 0, 5, 6, 7, 8, 4, 4, 4, 4, 4, 3, 5, 5, 6,\n                         7, 8, 3, 2, 1, 0, 5, 4, 3, 2, 7, 8, 9, 6, 6, 6, 6, 6,\n                         5, 7, 7, 8, 9, 5, 4, 3, 2, 7, 6, 5, 4, 9, 8, 8, 8, 8,\n                         8, 7, 9, 9, 7, 6, 5, 4, 1, 0, 3, 4, 5, 6, 2, 2, 2, 2,\n                         2, 2, 2, 1, 0, 3, 4, 5, 3, 4, 5, 6, 1, 0, 3, 2, 1, 0,\n                         5, 6, 7, 8, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 5, 6, 7, 5,\n                         6, 7, 8, 3, 2, 1, 0, 5, 4, 3, 2, 7, 8, 9, 6, 6, 6, 6,\n                         6, 6, 6, 5, 4, 3, 7, 8, 9, 7, 8, 9, 5, 4, 3, 2, 7, 6,\n                         5, 4, 9, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 9, 9, 7, 6, 5,\n                         4, 1, 0, 3, 4, 5, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 3,\n                         4, 5, 6, 3, 4, 5, 6, 1, 0, 3, 2, 1, 0, 5, 6, 7, 8, 4,\n                         4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0, 5, 6, 7, 8, 5, 6, 7,\n                         8, 3, 2, 1, 0, 5, 4, 3, 2, 7, 8, 9, 6, 6, 6, 6, 6, 6,\n                         6, 6, 5, 4, 3, 2, 7, 8, 9, 7, 8, 9, 5, 4, 3, 2, 7, 6,\n                         5, 4, 9, 8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 9, 9, 7,\n                         6, 5, 4, 1, 0, 3, 4, 5, 6, 2, 2, 2, 2, 2, 2, 1, 0, 3,\n                         4, 5, 6, 3, 4, 1, 0, 3, 2, 1, 0, 5, 6, 7, 8, 4, 4, 4,\n                         4, 4, 4, 3, 2, 1, 0, 5, 6, 7, 8, 5, 6, 3, 2, 5, 4, 3,\n                         2, 7, 8, 9, 6, 6, 6, 6, 6, 6, 5, 4, 3, 2, 7, 8, 9, 7,\n                         8, 5, 4, 7, 6, 5, 4, 9, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4,\n                         9, 9, 7, 6, 1, 0, 3, 4, 5, 6, 2, 2, 2, 2, 1, 0, 3, 4,\n                         5, 6, 3, 2, 1, 0, 5, 6, 7, 8, 4, 4, 4, 4, 3, 2, 1, 0,\n                         5, 6, 7, 8, 5, 4, 3, 2, 7, 8, 9, 6, 6, 6, 6, 5, 4, 3,\n                         2, 7, 8, 9, 7, 6, 5, 4, 9, 8, 8, 8, 8, 7, 6, 5, 4, 9]\n\n        result = []\n\n        for i in i_list:\n            for a_j in jj_list:\n                for a_dire in dire:\n                    all_neighb_dir = ALL_NEIGHB[a_dire](i, a_j, rows, cols)\n\n                    if all_neighb_dir < 4:\n                        max_neighb_dir = all_neighb_dir\n                    else:\n                        max_neighb_dir = 4\n\n                    for a_m in range(1, max_neighb_dir+1):\n                        point_col = POINT_C[a_dire](a_j, a_m)\n                        result.append(point_col)\n\n        self.assertEqual(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_point_r.py,0,"b'""""""\n    Title: test_point_r.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-07-02\n    Description: Unit testing module for POINT_R dictionary in value_lookup.py\n""""""\n\nimport sys\nimport os.path\nimport unittest\nfrom inspect import getfile, currentframe\n\n\nclass TestPointR(unittest.TestCase):\n\n    def test_point_r(self):\n\n        cmd_folder = os.path.realpath(\n                     os.path.abspath(os.path.split(\n                     getfile(currentframe()))[0]))\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        from utilities.value_lookup import ALL_NEIGHB, POINT_R\n\n        rows = 10\n        cols = 10\n\n        i_list = [1, 3, 5, 7, 9]\n        jj_list = [2, 4, 6, 8]\n\n        dire = [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\']\n\n        result_expect = [1, 1, 1, 1, 1, 1, 0, 2, 3, 4, 5, 0, 0, 2, 3, 4, 5, 2,\n                         3, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 3, 4, 5, 0, 0, 2, 3,\n                         4, 5, 2, 3, 4, 5, 1, 1, 1, 1, 1, 1, 1, 0, 2, 3, 4, 5,\n                         0, 0, 2, 3, 4, 2, 3, 4, 5, 1, 1, 1, 1, 1, 0, 2, 3, 4,\n                         5, 0, 0, 2, 2, 3, 4, 5, 3, 3, 3, 3, 3, 3, 2, 1, 0, 4,\n                         5, 6, 7, 2, 1, 2, 1, 0, 4, 5, 6, 7, 4, 5, 3, 3, 3, 3,\n                         3, 3, 3, 3, 2, 1, 0, 4, 5, 6, 7, 2, 1, 0, 2, 1, 0, 4,\n                         5, 6, 7, 4, 5, 6, 7, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 4,\n                         5, 6, 7, 2, 1, 0, 2, 1, 0, 4, 5, 6, 4, 5, 6, 7, 3, 3,\n                         3, 3, 3, 2, 1, 0, 4, 5, 6, 7, 2, 1, 0, 2, 4, 4, 5, 6,\n                         7, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 6, 7, 8, 9, 4, 3, 4,\n                         3, 2, 1, 6, 7, 8, 9, 6, 7, 5, 5, 5, 5, 5, 5, 5, 5, 4,\n                         3, 2, 1, 6, 7, 8, 9, 4, 3, 2, 1, 4, 3, 2, 1, 6, 7, 8,\n                         9, 6, 7, 8, 9, 5, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 6, 7,\n                         8, 9, 4, 3, 2, 1, 4, 3, 2, 6, 7, 8, 6, 7, 8, 9, 5, 5,\n                         5, 5, 5, 4, 3, 2, 1, 6, 7, 8, 9, 4, 3, 2, 1, 4, 6, 6,\n                         7, 8, 9, 7, 7, 7, 7, 7, 7, 6, 5, 4, 3, 8, 9, 6, 5, 6,\n                         5, 4, 3, 8, 9, 8, 9, 7, 7, 7, 7, 7, 7, 7, 7, 6, 5, 4,\n                         3, 8, 9, 6, 5, 4, 3, 6, 5, 4, 3, 8, 9, 8, 9, 7, 7, 7,\n                         7, 7, 7, 7, 6, 5, 4, 3, 8, 9, 6, 5, 4, 3, 6, 5, 4, 8,\n                         9, 8, 9, 7, 7, 7, 7, 7, 6, 5, 4, 3, 8, 9, 6, 5, 4, 3,\n                         6, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8, 7, 6, 5, 8, 7, 8, 7,\n                         6, 5, 9, 9, 9, 9, 9, 9, 9, 9, 8, 7, 6, 5, 8, 7, 6, 5,\n                         8, 7, 6, 5, 9, 9, 9, 9, 9, 9, 9, 8, 7, 6, 5, 8, 7, 6,\n                         5, 8, 7, 6, 9, 9, 9, 9, 9, 8, 7, 6, 5, 8, 7, 6, 5, 8]\n\n        result = []\n\n        for i in i_list:\n            for a_j in jj_list:\n                for a_dire in dire:\n                    all_neighb_dir = ALL_NEIGHB[a_dire](i, a_j, rows, cols)\n\n                    if all_neighb_dir < 4:\n                        max_neighb_dir = all_neighb_dir\n                    else:\n                        max_neighb_dir = 4\n\n                    for a_m in range(1, max_neighb_dir+1):\n                        point_row = POINT_R[a_dire](i, a_m)\n                        result.append(point_row)\n\n        self.assertEqual(result, result_expect)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_reclass_veg.py,0,"b'""""""\n    Title: test_reclas_veg.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2015-06-24\n    Description: Unit testing module for reclass_veg function in bal.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestReclassVeg(unittest.TestCase):\n\n    def test_reclass_veg(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                     os.path.split(getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n\n        input_folder = os.path.join(testdata_folder, \'input\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        dem = os.path.join(input_folder, ""dem.img"")\n        veg = os.path.join(input_folder, ""vege.img"")\n        mask = os.path.join(input_folder, ""test_mask.shp"")\n        veg_class_expect = os.path.join(reference_folder, ""expect_v_r"")\n\n        input_folder = os.path.dirname(veg)\n        arcpy.env.workspace = input_folder\n\n        from bal import reclass_veg\n\n        output_folder = os.path.join(testdata_folder, \'output\')\n\n        remap = ""1 3;2 2;3 3;4 5 7;6 8 1;9 2;10 3;11 12 1;13 1;14 3;\\\n                 15 6;16 7;17 3;18 19 2;20 7;21 3;22 2; 23 24 7;25 27 5;\\\n                 28 2;29 30 7;31 3;32 33 1;34 7;35 3;36 37 7;38 4;39 7;40 1;\\\n                 41 2;42 7;43 2;44 7;45 4;46 7;47 NODATA;97 2;98 99 1""\n\n\n        veg_class = reclass_veg(veg, dem, output_folder, remap, mask)\n\n        compare_result = os.path.join(output_folder, ""compare_veg_r.txt"")\n\n        arcpy.RasterCompare_management(veg_class, veg_class_expect, \'\', \'\', \'\',\n                                       compare_result)\n\n        if \'""true""\' not in open(compare_result).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        # delete output files\n        if arcpy.Exists(veg_class):\n            arcpy.Delete_management(veg_class)\n\n        os.remove(compare_result)\n        os.remove(os.path.join(output_folder, ""compare_veg_r.xml""))\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_reclassify.py,0,"b'""""""\n    Title: test_reclassify.py\n    Author: Tina Yang, tina.yang@ga.gov.au\n    CreationDate: 2016-06-28\n    Description: Unit testing module for reclassify function in sa_tools.py\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\n\n\nclass TestReclassify(unittest.TestCase):\n\n    def test_reclassify(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                     os.path.split(getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n\n        input_folder = os.path.join(testdata_folder, \'input\')\n        reference_folder = os.path.join(testdata_folder, \'reference\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n        arcpy.env.workspace = input_folder\n\n        output_folder = os.path.join(testdata_folder, \'output\')\n        reclassify_result = os.path.join(output_folder, \'reclassi\')\n\n        from utilities.sa_tools import reclassify\n\n        # test 1st case with vegetation\n        veg = os.path.join(input_folder, ""vege.img"")\n        reclassify_expect = os.path.join(reference_folder, ""expect_r_1"")\n\n        remap = ""1 3;2 2;3 3;4 5 7;6 8 1;9 2;10 3;11 12 1;13 1;14 3;\\\n                 15 6;16 7;17 3;18 19 2;20 7;21 3;22 2; 23 24 7;25 27 5;\\\n                 28 2;29 30 7;31 3;32 33 1;34 7;35 3;36 37 7;38 4;39 7;40 1;\\\n                 41 2;42 7;43 2;44 7;45 4;46 7;47 NODATA;97 2;98 99 1""\n\n        reclassify(veg, remap, reclassify_result)\n\n        compare_result = os.path.join(output_folder, ""compare_reclassify.txt"")\n\n        arcpy.RasterCompare_management(reclassify_result, reclassify_expect,\n                                       \'\', \'\', \'\', compare_result)\n\n        if \'""true""\' not in open(compare_result).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        # delete output files\n        if arcpy.Exists(reclassify_result):\n            arcpy.Delete_management(reclassify_result)\n\n        os.remove(compare_result)\n        os.remove(os.path.join(output_folder, ""compare_reclassify.xml""))\n\n        # test 2nd case with slope\n        slope = os.path.join(input_folder, ""slope_in"")\n        reclassify_expect = os.path.join(reference_folder, ""expect_r_2"")\n\n        remap = ""0 0 1;0.0001 5 2;5.0001 10 3;10.0001 15 4;\\\n                15.0001 20 5;20.0001 20 6""\n\n        reclassify(slope, remap, reclassify_result)\n\n        compare_result = os.path.join(output_folder, ""compare_reclassify.txt"")\n\n        arcpy.RasterCompare_management(reclassify_result, reclassify_expect,\n                                       \'\', \'\', \'\', compare_result)\n\n        if \'""true""\' not in open(compare_result).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        # delete output files\n        if arcpy.Exists(reclassify_result):\n            arcpy.Delete_management(reclassify_result)\n\n        os.remove(compare_result)\n        os.remove(os.path.join(output_folder, ""compare_reclassify.xml""))\n\n\n        # test 3rd case with aspect\n        aspect = os.path.join(input_folder, ""aspect_in"")\n        reclassify_expect = os.path.join(reference_folder, ""expect_r_3"")\n\n        remap = ""-1 0 9;0 22.5 1;22.5 67.5 2;67.5 112.5 3;\\\n               112.5 157.5 4;157.5 202.5 5;202.5 247.5 6;247.5 292.5 7;\\\n               292.5 337.5 8;337.5 360 1""\n\n        reclassify(aspect, remap, reclassify_result)\n\n        compare_result = os.path.join(output_folder, ""compare_reclassify.txt"")\n\n        arcpy.RasterCompare_management(reclassify_result, reclassify_expect,\n                                       \'\', \'\', \'\', compare_result)\n\n        if \'""true""\' not in open(compare_result).read():\n            self.assertEqual(1, 1, \'No errors\')\n        else:\n            self.assertEqual(1, 0, \'Has errors\')\n\n        # delete output files\n        if arcpy.Exists(reclassify_result):\n            arcpy.Delete_management(reclassify_result)\n\n        os.remove(compare_result)\n        os.remove(os.path.join(output_folder, ""compare_reclassify.xml""))\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests/test_scenario.py,1,"b'""""""\n     Title: test_scenario.py\n     Author: Tina Yang, tina.yang@ga.gov.au\n     CreationDate: 2015-07-24\n     Description: scenario test based on sample input data: classified veg,\n     classified slope and classified aspect.\n""""""\n\nimport unittest\nimport arcpy\nimport sys\nimport os.path\nfrom inspect import getfile, currentframe\nimport numpy as np\nfrom numpy.testing import assert_array_equal\n\n\nclass TestScenario(unittest.TestCase):\n\n    def test_scenario(self):\n\n        cmd_folder = os.path.realpath(os.path.abspath(\n                                    os.path.split(getfile(currentframe()))[0]))\n\n        testdata_folder = os.path.join(cmd_folder, \'test_data\')\n        input_folder = os.path.join(testdata_folder, \'input\')\n        output_folder = os.path.join(testdata_folder, \'output\')\n\n        parent = os.path.abspath(os.path.join(cmd_folder, os.pardir))\n\n        if parent not in sys.path:\n            sys.path.insert(0, parent)\n\n        arcpy.env.overwriteOutput = True\n\n        veg_class = os.path.join(output_folder, ""veg_samp"")\n        slope = os.path.join(output_folder, ""slope_samp"")\n        aspect = os.path.join(output_folder, ""aspect_samp"")\n\n        bal_expect = np.ones([3, 140])\n        bal_expect[:, 0] = -99\n        bal_expect[:, 1:29] = 100\n        bal_expect[:, 29:41] = 29\n        bal_expect[:, 41:53] = 40\n        bal_expect[:, 53:65] = 19\n        bal_expect[:, 65:81] = 40\n        bal_expect[:, 81:89] = 19\n        bal_expect[:, 89:105] = 100\n        bal_expect[:, 105:121] = 29\n        bal_expect[:, 121:140] = 200\n\n        if not arcpy.Exists(veg_class):\n            arcpy.Copy_management(os.path.join(input_folder, ""veg_samp""),\n                              veg_class)\n\n        if not arcpy.Exists(slope):\n            arcpy.Copy_management(os.path.join(input_folder, ""slope_samp""),\n                              slope)\n\n        if not arcpy.Exists(aspect):\n            arcpy.Copy_management(os.path.join(input_folder, ""aspect_samp""),\n                              aspect)\n\n        fdi = 80\n\n        from calculate_bal import bal_cal\n        bal_cal(veg_class, slope, aspect, fdi)\n\n        ds1 = os.path.join(output_folder, ""bal_w.img"")\n\n        if ds1 is None:\n            print \'Could not open bal_w.img\'\n            sys.exit(1)\n\n        bal_data = arcpy.RasterToNumPyArray(ds1, nodata_to_value=-99)\n\n        assert_array_equal(bal_data, bal_expect)\n\n        for a_dir in [\'w\', \'e\', \'n\', \'s\', \'nw\', \'ne\', \'se\', \'sw\', \'max\']:\n            output_bal = os.path.join(output_folder, \'bal_\' + a_dir + \'.img\')\n            if arcpy.Exists(output_bal):\n                arcpy.Delete_management(output_bal)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
utilities/__init__.py,0,b''
utilities/bal_database.py,0,"b'""""""\n:mod:`bal_database` - relevant dictionaries for calculating the\nbushfire attack level (BAL)\n\n===============================================================\n\nThese dictionaries are translated from tables from 2.4.2 to 2.4.5 in \nAS 3959 (2009) to determine the BAL for an area of interest within Australia.\n\n:moduleauthor: Tina Yang <tina.yang@ga.gov.au>\n\n""""""\n\nFDI = [100, 80, 50, 40]\n\n# 1: Forest, 2: Woodland, 3: Shrubland, 4: Scrub, 5: Mallee/Mulga\n# 6: Rainforest, 7: Grassland/Tussock moorland\nVEG_CLASS =  [1, 2, 3, 4, 5, 6, 7]\n\n# 1: 0, 2: 0 ~ 5, 3: 5 ~ 10, 4: 10 ~ 15, 5: 15 ~ 20, 6: > 20\nSLOPE = [1, 2, 3, 4, 5, 6]\n\n# distance uplimits for each vegetation class at upslope/flat areas\nDIST_LIMIT_UPSLOPE = dict([(FDI[0], dict([(VEG_CLASS[0], [19, 25, 35, 48]),\n                                          (VEG_CLASS[1], [12, 16, 24, 33]),\n                                          (VEG_CLASS[2], [7, 9, 13, 19]),\n                                          (VEG_CLASS[3], [10, 13, 19, 27]),\n                                          (VEG_CLASS[4], [6, 8, 12, 17]),\n                                          (VEG_CLASS[5], [8, 11, 16, 23]),\n                                          (VEG_CLASS[6], [6, 9, 13, 19])])),\n                            (FDI[1], dict([(VEG_CLASS[0], [16, 21, 31, 42]),\n                                          (VEG_CLASS[1], [10, 14, 20, 29]),\n                                          (VEG_CLASS[2], [7, 9, 13, 19]),\n                                          (VEG_CLASS[3], [10, 13, 19, 27]),\n                                          (VEG_CLASS[4], [6, 8, 12, 17]),\n                                          (VEG_CLASS[5], [6, 9, 13, 19]),\n                                          (VEG_CLASS[6], [6, 8, 12, 17])])),\n                            (FDI[2], dict([(VEG_CLASS[0], [12, 16, 23, 32]),\n                                          (VEG_CLASS[1], [7, 10, 15, 22]),\n                                          (VEG_CLASS[2], [7, 9, 13, 19]),\n                                          (VEG_CLASS[3], [10, 13, 19, 27]),\n                                          (VEG_CLASS[4], [6, 8, 12, 17]),\n                                          (VEG_CLASS[5], [5, 6, 9, 14]),\n                                          (VEG_CLASS[6], [7, 9, 14, 20])])),\n                            (FDI[3], dict([(VEG_CLASS[0], [10, 13, 20, 28]),\n                                          (VEG_CLASS[1], [6, 9, 13, 19]),\n                                          (VEG_CLASS[2], [7, 9, 13, 19]),\n                                          (VEG_CLASS[3], [10, 13, 19, 27]),\n                                          (VEG_CLASS[4], [6, 8, 12, 17]),\n                                          (VEG_CLASS[5], [4, 5, 8, 12]),\n                                          (VEG_CLASS[6], [4, 5, 8, 12])]))])\n\n# distance uplimits for each slope and vegetation class at downslope areas\nDIST_LIMIT_DOWNSLOPE = dict([(FDI[0],\n                            dict([((SLOPE[1], VEG_CLASS[0]), [24, 32, 43, 57]),\n                                  ((SLOPE[1], VEG_CLASS[1]), [15, 21, 29, 41]),\n                                  ((SLOPE[1], VEG_CLASS[2]), [7, 10, 15, 22]),\n                                  ((SLOPE[1], VEG_CLASS[3]), [11, 15, 22, 31]),\n                                  ((SLOPE[1], VEG_CLASS[4]), [7, 9, 13, 20]),\n                                  ((SLOPE[1], VEG_CLASS[5]), [10, 14, 20, 29]),\n                                  ((SLOPE[1], VEG_CLASS[6]), [7, 10, 15, 22]),\n                                  ((SLOPE[2], VEG_CLASS[0]), [31, 39, 53, 69]),\n                                  ((SLOPE[2], VEG_CLASS[1]), [20, 26, 37, 50]),\n                                  ((SLOPE[2], VEG_CLASS[2]), [8, 11, 17, 25]),\n                                  ((SLOPE[2], VEG_CLASS[3]), [12, 17, 24, 35]),\n                                  ((SLOPE[2], VEG_CLASS[4]), [7, 10, 15, 23]),\n                                  ((SLOPE[2], VEG_CLASS[5]), [13, 18, 26, 36]),\n                                  ((SLOPE[2], VEG_CLASS[6]), [8, 11, 17, 25]),\n                                  ((SLOPE[3], VEG_CLASS[0]), [39, 49, 64, 82]),\n                                  ((SLOPE[3], VEG_CLASS[1]), [25, 33, 45, 60]),\n                                  ((SLOPE[3], VEG_CLASS[2]), [9, 13, 19, 28]),\n                                  ((SLOPE[3], VEG_CLASS[3]), [14, 19, 28, 39]),\n                                  ((SLOPE[3], VEG_CLASS[4]), [8, 11, 18, 26]),\n                                  ((SLOPE[3], VEG_CLASS[5]), [17, 23, 33, 45]),\n                                  ((SLOPE[3], VEG_CLASS[6]), [9, 13, 20, 28]),\n                                  ((SLOPE[4], VEG_CLASS[0]), [50, 61, 78, 98]),\n                                  ((SLOPE[4], VEG_CLASS[1]), [32, 41, 56, 73]),\n                                  ((SLOPE[4], VEG_CLASS[2]), [10, 15, 22, 31]),\n                                  ((SLOPE[4], VEG_CLASS[3]), [15, 21, 31, 43]),\n                                  ((SLOPE[4], VEG_CLASS[4]), [9, 13, 20, 29]),\n                                  ((SLOPE[4], VEG_CLASS[5]), [22, 29, 42, 56]),\n                                  ((SLOPE[4], VEG_CLASS[6]), [11, 15, 23, 32])\n                                  ])),\n                             (FDI[1],\n                            dict([((SLOPE[1], VEG_CLASS[0]), [20, 27, 37, 50]),\n                                  ((SLOPE[1], VEG_CLASS[1]), [13, 17, 25, 35]),\n                                  ((SLOPE[1], VEG_CLASS[2]), [7, 10, 15, 22]),\n                                  ((SLOPE[1], VEG_CLASS[3]), [11, 15, 22, 31]),\n                                  ((SLOPE[1], VEG_CLASS[4]), [7, 9, 13, 20]),\n                                  ((SLOPE[1], VEG_CLASS[5]), [8, 11, 17, 24]),\n                                  ((SLOPE[1], VEG_CLASS[6]), [7, 9, 14, 20]),\n                                  ((SLOPE[2], VEG_CLASS[0]), [26, 33, 46, 61]),\n                                  ((SLOPE[2], VEG_CLASS[1]), [16, 22, 31, 43]),\n                                  ((SLOPE[2], VEG_CLASS[2]), [8, 11, 17, 25]),\n                                  ((SLOPE[2], VEG_CLASS[3]), [12, 17, 24, 35]),\n                                  ((SLOPE[2], VEG_CLASS[4]), [7, 10, 15, 23]),\n                                  ((SLOPE[2], VEG_CLASS[5]), [11, 15, 22, 31]),\n                                  ((SLOPE[2], VEG_CLASS[6]), [8, 10, 16, 23]),\n                                  ((SLOPE[3], VEG_CLASS[0]), [33, 42, 56, 73]),\n                                  ((SLOPE[3], VEG_CLASS[1]), [21, 28, 39, 53]),\n                                  ((SLOPE[3], VEG_CLASS[2]), [9, 13, 19, 28]),\n                                  ((SLOPE[3], VEG_CLASS[3]), [14, 19, 28, 39]),\n                                  ((SLOPE[3], VEG_CLASS[4]), [8, 11, 18, 26]),\n                                  ((SLOPE[3], VEG_CLASS[5]), [14, 19, 28, 39]),\n                                  ((SLOPE[3], VEG_CLASS[6]), [9, 12, 18, 26]),\n                                  ((SLOPE[4], VEG_CLASS[0]), [42, 52, 68, 87]),\n                                  ((SLOPE[4], VEG_CLASS[1]), [27, 35, 48, 64]),\n                                  ((SLOPE[4], VEG_CLASS[2]), [10, 15, 22, 31]),\n                                  ((SLOPE[4], VEG_CLASS[3]), [15, 21, 31, 43]),\n                                  ((SLOPE[4], VEG_CLASS[4]), [9, 13, 20, 29]),\n                                  ((SLOPE[4], VEG_CLASS[5]), [18, 25, 36, 48]),\n                                  ((SLOPE[4], VEG_CLASS[6]), [10, 14, 21, 30])\n                                  ])),\n                             (FDI[2],\n                            dict([((SLOPE[1], VEG_CLASS[0]), [14, 19, 27, 38]),\n                                  ((SLOPE[1], VEG_CLASS[1]), [9, 12, 18, 26]),\n                                  ((SLOPE[1], VEG_CLASS[2]), [7, 10, 15, 22]),\n                                  ((SLOPE[1], VEG_CLASS[3]), [11, 15, 22, 31]),\n                                  ((SLOPE[1], VEG_CLASS[4]), [7, 9, 13, 20]),\n                                  ((SLOPE[1], VEG_CLASS[5]), [6, 8, 12, 17]),\n                                  ((SLOPE[1], VEG_CLASS[6]), [8, 10, 16, 23]),\n                                  ((SLOPE[2], VEG_CLASS[0]), [18, 24, 34, 46]),\n                                  ((SLOPE[2], VEG_CLASS[1]), [11, 15, 23, 32]),\n                                  ((SLOPE[2], VEG_CLASS[2]), [8, 11, 17, 25]),\n                                  ((SLOPE[2], VEG_CLASS[3]), [12, 17, 24, 35]),\n                                  ((SLOPE[2], VEG_CLASS[4]), [7, 10, 15, 23]),\n                                  ((SLOPE[2], VEG_CLASS[5]), [7, 10, 15, 22]),\n                                  ((SLOPE[2], VEG_CLASS[6]), [9, 12, 18, 26]),\n                                  ((SLOPE[3], VEG_CLASS[0]), [22, 30, 41, 56]),\n                                  ((SLOPE[3], VEG_CLASS[1]), [14, 19, 28, 40]),\n                                  ((SLOPE[3], VEG_CLASS[2]), [9, 13, 19, 28]),\n                                  ((SLOPE[3], VEG_CLASS[3]), [14, 19, 28, 39]),\n                                  ((SLOPE[3], VEG_CLASS[4]), [8, 11, 18, 26]),\n                                  ((SLOPE[3], VEG_CLASS[5]), [9, 13, 19, 28]),\n                                  ((SLOPE[3], VEG_CLASS[6]), [10, 13, 20, 29]),\n                                  ((SLOPE[4], VEG_CLASS[0]), [28, 37, 51, 67]),\n                                  ((SLOPE[4], VEG_CLASS[1]), [18, 25, 36, 48]),\n                                  ((SLOPE[4], VEG_CLASS[2]), [10, 15, 22, 31]),\n                                  ((SLOPE[4], VEG_CLASS[3]), [15, 21, 31, 43]),\n                                  ((SLOPE[4], VEG_CLASS[4]), [9, 13, 20, 29]),\n                                  ((SLOPE[4], VEG_CLASS[5]), [12, 17, 25, 35]),\n                                  ((SLOPE[4], VEG_CLASS[6]), [11, 15, 23, 33])\n                                  ])),\n                             (FDI[3],\n                            dict([((SLOPE[1], VEG_CLASS[0]), [12, 16, 24, 34]),\n                                  ((SLOPE[1], VEG_CLASS[1]), [8, 11, 16, 23]),\n                                  ((SLOPE[1], VEG_CLASS[2]), [7, 10, 15, 22]),\n                                  ((SLOPE[1], VEG_CLASS[3]), [11, 15, 22, 31]),\n                                  ((SLOPE[1], VEG_CLASS[4]), [7, 9, 13, 20]),\n                                  ((SLOPE[1], VEG_CLASS[5]), [5, 7, 10, 15]),\n                                  ((SLOPE[1], VEG_CLASS[6]), [4, 6, 9, 14]),\n                                  ((SLOPE[2], VEG_CLASS[0]), [15, 20, 29, 41]),\n                                  ((SLOPE[2], VEG_CLASS[1]), [9, 13, 19, 28]),\n                                  ((SLOPE[2], VEG_CLASS[2]), [8, 11, 17, 25]),\n                                  ((SLOPE[2], VEG_CLASS[3]), [12, 17, 24, 35]),\n                                  ((SLOPE[2], VEG_CLASS[4]), [7, 10, 15, 23]),\n                                  ((SLOPE[2], VEG_CLASS[5]), [6, 8, 13, 19]),\n                                  ((SLOPE[2], VEG_CLASS[6]), [5, 7, 11, 16]),\n                                  ((SLOPE[3], VEG_CLASS[0]), [19, 25, 36, 49]),\n                                  ((SLOPE[3], VEG_CLASS[1]), [12, 16, 24, 35]),\n                                  ((SLOPE[3], VEG_CLASS[2]), [9, 13, 19, 28]),\n                                  ((SLOPE[3], VEG_CLASS[3]), [14, 19, 28, 39]),\n                                  ((SLOPE[3], VEG_CLASS[4]), [8, 11, 18, 26]),\n                                  ((SLOPE[3], VEG_CLASS[5]), [8, 11, 16, 24]),\n                                  ((SLOPE[3], VEG_CLASS[6]), [6, 8, 13, 19]),\n                                  ((SLOPE[4], VEG_CLASS[0]), [24, 31, 44, 59]),\n                                  ((SLOPE[4], VEG_CLASS[1]), [15, 21, 31, 42]),\n                                  ((SLOPE[4], VEG_CLASS[2]), [10, 15, 22, 31]),\n                                  ((SLOPE[4], VEG_CLASS[3]), [15, 21, 31, 43]),\n                                  ((SLOPE[4], VEG_CLASS[4]), [9, 13, 20, 29]),\n                                  ((SLOPE[4], VEG_CLASS[5]), [10, 14, 21, 30]),\n                                  ((SLOPE[4], VEG_CLASS[6]), [7, 9, 15, 22])\n                                  ]))])\n\n# distance classes\nDIST_CLASS = [1, 2, 3, 4, 5]\n\n# BAL\nBAL_CLASS = dict([(DIST_CLASS[0], 100),\n                  (DIST_CLASS[1], 40),\n                  (DIST_CLASS[2], 29),\n                  (DIST_CLASS[3], 19),\n                  (DIST_CLASS[4], 12.5)\n                  ])\n'"
utilities/sa_tools.py,11,"b'""""""\n:mod:`sa_tools` - some support functions replacing spatial analyst\n\n===============================================================\n\nThis module includes algorithms that are used to replace spatial analyst\nfunctions such as ExtractByMask, Reclassify, Slope and Aspect used within this\npackage.\n\n:moduleauthor: Tina Yang <tina.yang@ga.gov.au>\n\n""""""\n\nfrom __future__ import absolute_import\n\nimport numpy as np\nimport arcpy\nimport os\n\nRADIANS_PER_DEGREE = 0.01745329251994329576923690768489\n\n\ndef clip_array(data, x_left, y_upper, pixelwidth, pixelheight, extent):\n    """"""\n    Return the clipped area of the input array according to an sub-extent\n\n    :param data: :class:`numpy.ndarray` the input array\n    :param x_left: `float` the left-most x projected coordinate\n    :param y_upper: `float` the upper-most y projected coordinate\n    :param pixelwidth: `float` the pixel width\n    :param pixelheight: `float` the pixel height\n    :param extent: `tuple` the clipping extent\n\n    :return: :class:`numpy.ndarray` the clipped array\n    """"""\n\n    x_start = int(np.around((extent[0] - x_left)/pixelwidth))\n    y_start = int(np.around((y_upper - extent[3])/pixelheight))\n\n    cols = int(np.around((extent[2] - extent[0])/pixelwidth))\n    rows = int(np.around((extent[3] - extent[1])/pixelheight))\n\n    x_end = x_start + cols\n    y_end = y_start + rows\n\n    data_clip = data[y_start:y_end, x_start:x_end]\n\n    return data_clip\n\n\ndef extract_by_mask(image_fname, extent_file, out_fname):\n    """"""\n    Extract a raster using a feature (shape) file\n\n    :param image_fname: `file` the input raster\n    :param extent_file: `file` the input extent feature file\n\n    :return: `file` the output raster\n    """"""\n\n    output_folder = os.path.dirname(image_fname)\n    arcpy.env.overwriteOutput = True\n\n    # set directory\n    work_folder = output_folder\n    os.chdir(work_folder)\n    arcpy.env.workspace = work_folder\n\n    # set nodata value\n    nodata_value = -99\n\n    # get the information of the original image\n    desc = arcpy.Describe(image_fname)\n    x_min = desc.extent.XMin\n    y_min = desc.extent.YMin\n    x_max = desc.extent.XMax\n    y_max = desc.extent.YMax\n    pixel_w = desc.meanCellWidth\n    pixel_h = desc.meanCellHeight\n    sref = desc.spatialReference\n    data = arcpy.RasterToNumPyArray(image_fname, nodata_to_value=nodata_value)\n\n    # rasterise the shapefile and then extract into numpy array\n    ext_raster = ""ext_raster""\n    arcpy.FeatureToRaster_conversion(extent_file, ""FID"", ext_raster, pixel_w)\n    extent_data = arcpy.RasterToNumPyArray(ext_raster,\n                                           nodata_to_value=nodata_value)\n\n    # decide the effective extent to extract the raster\n    extent = arcpy.Describe(extent_file).extent\n    if extent.XMin < x_min:\n        effect_xmin = x_min\n    else:\n        effect_xmin = extent.XMin\n\n    if extent.YMin < y_min:\n        effect_ymin = y_min\n    else:\n        effect_ymin = extent.YMin\n\n    if extent.XMax > x_max:\n        effect_xmax = x_max\n    else:\n        effect_xmax = extent.XMax\n\n    if extent.YMax > y_max:\n        effect_ymax = y_max\n    else:\n        effect_ymax = extent.YMax\n\n    effect_extent = (effect_xmin, effect_ymin, effect_xmax, effect_ymax)\n\n    # get the lowleft corner for positioning the output raster\n    lowleft_corner = arcpy.Point(effect_xmin, effect_ymin)\n\n    # extract the effective extent of interest from original image data\n    data_in_extent = clip_array(data, x_min, y_max, pixel_w, pixel_h,\n                                effect_extent)\n\n    # extract the effective extent of interest from original extent data\n    extent_data_effect = clip_array(extent_data, extent.XMin, extent.YMax,\n                                    pixel_w, pixel_h, effect_extent)\n\n    # operate extent_data_effect and data_in_extent, if nodata in either,\n    # output is nodata\n    nodata_area = np.where(extent_data_effect == nodata_value)\n    data_in_extent[nodata_area] = nodata_value\n\n    # save the output array into a raster\n    arcpy.NumPyArrayToRaster(data_in_extent, lowleft_corner, pixel_w, pixel_h,\n                             value_to_nodata=nodata_value).save(out_fname)\n    arcpy.DefineProjection_management(out_fname, sref)\n\n    del data_in_extent\n    del extent_data_effect\n    del data\n\n    if arcpy.Exists(ext_raster):\n        arcpy.Delete_management(ext_raster)\n\n\ndef reclassify(image_fname, remap, out_fname):\n    """"""\n    Reclassify the raster as per the input remap\n\n    :param image_fname: `file` the input raster\n    :param remap: `str` the info of remap\n\n    :return: `file` the output raster\n    """"""\n\n    output_folder = os.path.dirname(image_fname)\n    arcpy.env.overwriteOutput = True\n\n    # set directory\n    work_folder = output_folder\n    os.chdir(work_folder)\n    arcpy.env.workspace = work_folder\n\n    # set nodata value\n    nodata_value = -99\n\n    # get the information of the original image\n    desc = arcpy.Describe(image_fname)\n    x_min = desc.extent.XMin\n    y_min = desc.extent.YMin\n    pixel_w = desc.meanCellWidth\n    pixel_h = desc.meanCellHeight\n    sref = desc.spatialReference\n    # get the lowleft corner for positioning the output raster\n    lowleft_corner = arcpy.Point(x_min, y_min)\n\n    data = arcpy.RasterToNumPyArray(image_fname, nodata_to_value=nodata_value)\n\n    remap_list = remap.split("";"")\n\n    for a_map in remap_list:\n        values = a_map.lstrip().split("" "")\n        if len(values) == 2:\n            start_value = float(values[0])\n            end_value = float(values[0])\n            new_value = values[1]\n        else:\n            start_value = float(values[0])\n            end_value = float(values[1])\n            new_value = values[2]\n\n        # to include the orignal end value , expand the end value a bit\n        end_value += 0.0001\n\n        if new_value == \'NODATA\':\n            new_value = nodata_value\n        else:\n            new_value = int(new_value)\n\n        range_loc = np.where((data >= start_value) & (data < end_value))\n        data[range_loc] = new_value\n\n    data = data.astype(int)\n    # save the output array into a raster\n    arcpy.NumPyArrayToRaster(data, lowleft_corner, pixel_w, pixel_h,\n                             value_to_nodata=nodata_value).save(out_fname)\n    arcpy.DefineProjection_management(out_fname, sref)\n\n    del data\n\n\ndef cal_slope_aspect(dem, slope_fname, aspect_fname):\n    """"""\n    Calculate the slope from the input dem\n\n    :param dem: `file` the input dem\n    :param slope_fname: `file` the output slope\n    :param aspect_fname: `file` the output aspect\n    """"""\n\n    output_folder = os.path.dirname(dem)\n    arcpy.env.overwriteOutput = True\n\n    # set directory\n    work_folder = output_folder\n    os.chdir(work_folder)\n    arcpy.env.workspace = work_folder\n\n    # set nodata value\n    nodata_value = -99\n\n    # get the information of the original image\n    desc = arcpy.Describe(dem)\n    x_min = desc.extent.XMin\n    y_min = desc.extent.YMin\n    pixel_w = desc.meanCellWidth\n    pixel_h = desc.meanCellHeight\n    sref = desc.spatialReference\n    # get the lowleft corner for positioning the output raster\n    lowleft_corner = arcpy.Point(x_min, y_min)\n\n    elevation_array = arcpy.RasterToNumPyArray(dem,\n                                               nodata_to_value=nodata_value)\n    mask = np.where(elevation_array == nodata_value)\n\n    # Set nodata cells adjacent to valid cells to a matching value.\n    # This is to ensure the slope values (calculated using a centred\n    # difference scheme) near nodata areas remain sensible.\n    nx, ny = elevation_array.shape\n    for i in range(ny):\n        for j in range(nx -1):\n            if (elevation_array[j+1, i] == nodata_value and\n                elevation_array[j, i] != nodata_value):\n                elevation_array[j+1, i] = elevation_array[j, i]\n\n    for i in range(nx):\n        for j in range(ny -1):\n            if (elevation_array[i, j+1] == nodata_value and\n                elevation_array[i, j] != nodata_value):\n                elevation_array[i, j+1] = elevation_array[i, j]\n\n    for i in range(ny):\n        for j in range(nx -1, -1, -1):\n            if (elevation_array[j, i] == nodata_value and\n                elevation_array[j+1, i] != nodata_value):\n                elevation_array[j, i] = elevation_array[j+1, i]\n\n    for i in range(nx):\n        for j in range(ny-1, -1, -1):\n            if (elevation_array[i, j] == nodata_value and\n                elevation_array[i, j+1] != nodata_value):\n                elevation_array[i, j] = elevation_array[i, j+1]\n\n    # Calculate gradient:\n    # See https://docs.scipy.org/doc/numpy-1.6.0/reference/generated/numpy.gradient.html\n    # This is the 1.6 version of numpy.gradient:\n    dzdx, dzdy = np.gradient(elevation_array, pixel_w, pixel_h)\n\n    # Calculate slope:\n    hypotenuse_array = np.hypot(dzdx, dzdy)\n    slope_array = np.arctan(hypotenuse_array) / RADIANS_PER_DEGREE \n    slope_array[mask] = nodata_value\n    del hypotenuse_array\n\n    # Aspect\n    # Convert angles from conventional radians to compass heading 0-360\n    aspect_array = np.mod((450. - np.arctan2(dzdy, -dzdx)/ RADIANS_PER_DEGREE), 360.)\n    aspect_array[mask] = nodata_value\n    del dzdx, dzdy\n\n    # save the output array into a raster\n    arcpy.NumPyArrayToRaster(slope_array, lowleft_corner, pixel_w, pixel_h,\n                             value_to_nodata=nodata_value).save(slope_fname)\n    arcpy.DefineProjection_management(slope_fname, sref)\n\n    arcpy.NumPyArrayToRaster(aspect_array, lowleft_corner, pixel_w, pixel_h,\n                             value_to_nodata=nodata_value).save(aspect_fname)\n    arcpy.DefineProjection_management(aspect_fname, sref)\n\n    del elevation_array, slope_array, aspect_array\n\n'"
utilities/value_lookup.py,0,"b'""""""\n:mod:`value_lookup` - helpful dictionaries for calculating the\nbushfire attack level (BAL)\n\n===============================================================\n\nThese dictionaries are helpful to adapt the algorithm spatially to Method 1 \nin AS 3959 (2009).\n\n:moduleauthor: Tina Yang <tina.yang@ga.gov.au>\n\n""""""\n\n# give each aspect a value\nDIRE_ASPECT = dict([(\'none\', 9),\n                    (\'n\', 1),\n                    (\'ne\', 2),\n                    (\'e\', 3),\n                    (\'se\', 4),\n                    (\'s\', 5),\n                    (\'sw\', 6),\n                    (\'w\', 7),\n                    (\'nw\', 8)])\n\n# find the number of all neighbours in a direction\nALL_NEIGHB = dict([(\'w\', lambda i, jj, rows, cols: jj),\n                   (\'e\', lambda i, jj, rows, cols: cols-jj-1),\n                   (\'n\', lambda i, jj, rows, cols: i),\n                   (\'s\', lambda i, jj, rows, cols: rows-i-1),\n                   (\'nw\', lambda i,jj, rows, cols: min(i, jj)),\n                   (\'ne\', lambda i,jj, rows, cols: min(i, cols-jj-1)),\n                   (\'sw\', lambda i,jj, rows, cols: min(rows-i-1, jj)),\n                   (\'se\', lambda i,jj, rows, cols: min(rows-i-1, cols-jj-1))])\n\n# find the row index of the neighbour\nPOINT_R = dict([(\'w\', lambda i, m: i),\n                (\'e\', lambda i, m: i),\n                (\'n\', lambda i, m: i-m),\n                (\'s\', lambda i, m: i+m),\n                (\'nw\', lambda i, m: i-m),\n                (\'ne\', lambda i, m: i-m),\n                (\'sw\', lambda i, m: i+m),\n                (\'se\', lambda i, m: i+m)])\n\n# find the column index of the neighbour\nPOINT_C = dict([(\'w\', lambda jj, m: jj-m),\n                (\'e\', lambda jj, m: jj+m),\n                (\'n\', lambda jj, m: jj),\n                (\'s\', lambda jj, m: jj),\n                (\'nw\', lambda jj, m: jj-m),\n                (\'ne\', lambda jj, m: jj+m),\n                (\'sw\', lambda jj, m: jj-m),\n                (\'se\', lambda jj, m: jj+m)])'"
