file_path,api_count,code
file_path_manager.py,0,"b'import glob\nimport os\n\n\nclass FilePathManager:\n    root_path = os.path.dirname(os.path.abspath(__file__)) + ""/""\n\n    @staticmethod\n    def resolve(path: str):\n        return FilePathManager.root_path + path\n\n    @staticmethod\n    def clear_dir(path: str):\n        path = FilePathManager.resolve(path + ""/*"")\n        files = glob.glob(path)\n        for f in files:\n            os.remove(f)\n'"
ui.py,1,"b'import os\nimport sys\n\nimport cv2\nimport numpy as np\nimport qdarkstyle\nfrom PyQt5 import QtCore, QtGui, uic, QtWidgets\nfrom PyQt5.QtCore import Qt\nfrom PyQt5.QtWidgets import QFileSystemModel\n\nfrom algorithms.fcm import FCM\nfrom algorithms.gk import GK\nfrom file_path_manager import FilePathManager\n\nFormClass = uic.loadUiType(""ui.ui"")[0]\n\n\nclass FilesTreeView(QtWidgets.QTreeView):\n    def __init__(self, func, parent=None):\n        super().__init__(parent)\n        self.func = func\n        self.setMinimumHeight(parent.height())\n        self.setMinimumWidth(parent.width())\n\n    def keyPressEvent(self, event):\n        self.func(event)\n\n\nclass ImageWidget(QtWidgets.QWidget):\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.raw_image = None\n        self.image = None\n\n    def setImage(self, image, raw_image):\n        self.image = image\n        self.raw_image = raw_image\n        sz = image.size()\n        self.setMinimumSize(sz)\n        self.update()\n\n    def paintEvent(self, event):\n        qp = QtGui.QPainter()\n        qp.begin(self)\n        if self.image:\n            qp.drawImage(QtCore.QPoint(0, 0), self.image)\n        qp.end()\n\n\nclass Ui(QtWidgets.QMainWindow, FormClass):\n    CMEANS = 0\n    GK = 1\n\n    def __init__(self, parent=None):\n        QtWidgets.QMainWindow.__init__(self, parent)\n        self.setupUi(self)\n        self.algorithm = ""cmeans""\n        self.root_path = FilePathManager.resolve(""images"")\n        self.filesTreeView = FilesTreeView(self.keyPressEvent, self.filesTreeView)\n        self.setup_events()\n\n    def setup_events(self):\n        model = QFileSystemModel()\n        root = model.setRootPath(self.root_path)\n        self.filesTreeView.setModel(model)\n        self.filesTreeView.setRootIndex(root)\n        self.filesTreeView.selectionModel().selectionChanged.connect(self.item_selection_changed_slot)\n        self.segment_button.clicked.connect(self.segment)\n        self.gk_radio.toggled.connect(self.select_gk)\n        self.cmeans_radio.toggled.connect(self.select_cmeans)\n\n    def select_gk(self, active):\n        if not active:\n            return\n        self.algorithm = self.GK\n\n    def select_cmeans(self, active):\n        if not active:\n            return\n        self.algorithm = self.CMEANS\n\n    def item_selection_changed_slot(self):\n        index = self.filesTreeView.selectedIndexes()[0]\n        item = self.filesTreeView.model().itemData(index)[0]\n        image_path = ""{}/{}"".format(self.root_path, item)\n        self.set_image(image_path)\n\n    def set_image(self, image_path):\n        pixmap = QtGui.QPixmap(image_path)\n        scaled_pixmap = pixmap.scaled(self.imageLabel.size(), Qt.KeepAspectRatio)\n        self.imageLabel.setPixmap(scaled_pixmap)\n\n    def show_segmented_image(self):\n        pixmap = QtGui.QPixmap(""./temp.png"")\n        scaled_pixmap = pixmap.scaled(self.imageLabel.size(), Qt.KeepAspectRatio)\n        self.output_image.setPixmap(scaled_pixmap)\n\n    def keyPressEvent(self, event):\n        if event.key() == QtCore.Qt.Key_Space:\n            self.segment()\n\n    def segment(self):\n        index = self.filesTreeView.selectedIndexes()[0]\n        item = self.filesTreeView.model().itemData(index)[0]\n        image_path = ""{}/{}"".format(self.root_path, item)\n        img = cv2.imread(image_path)\n        x, y, z = img.shape\n        img = img.reshape(x * y, z)\n\n        m = int(self.m_text.text())\n        n_clusters = int(self.n_clusters_text.text())\n        iterations = int(self.iterations_text.text())\n\n        if self.algorithm == self.CMEANS:\n            algorithm = FCM(n_clusters=n_clusters, max_iter=iterations, m=m)\n        else:\n            algorithm = GK(n_clusters=n_clusters, max_iter=iterations, m=m)\n\n        cluster_centers = algorithm.fit(img)\n        output = algorithm.predict(img)\n        img = cluster_centers[output].astype(np.int32).reshape(x, y, 3)\n        image_path = f""./temp.png""\n        cv2.imwrite(image_path, img)\n        self.show_segmented_image()\n\n\nif __name__ == \'__main__\':\n    os.environ[\'PYQTGRAPH_QT_LIB\'] = \'PyQt5\'\n    app = QtWidgets.QApplication(sys.argv)\n    app.setStyleSheet(qdarkstyle.load_stylesheet_from_environment(is_pyqtgraph=True))\n    ui = Ui()\n    ui.setWindowTitle(""Image Segmentation"")\n    ui.show()\n    app.exec_()\n'"
algorithms/__init__.py,0,b''
algorithms/fcm.py,5,"b'import numpy as np\nfrom scipy.linalg import norm\nfrom scipy.spatial.distance import cdist\n\n\nclass FCM:\n    def __init__(self, n_clusters=4, max_iter=100, m=2, error=1e-6):\n        super().__init__()\n        self.u, self.centers = None, None\n        self.n_clusters = n_clusters\n        self.max_iter = max_iter\n        self.m = m\n        self.error = error\n\n    def fit(self, X):\n        N = X.shape[0]\n        C = self.n_clusters\n        centers = []\n\n        u = np.random.dirichlet(np.ones(C), size=N)\n\n        iteration = 0\n        while iteration < self.max_iter:\n            u2 = u.copy()\n\n            centers = self.next_centers(X, u)\n            u = self.next_u(X, centers)\n            iteration += 1\n\n            # Stopping rule\n            if norm(u - u2) < self.error:\n                break\n\n        self.u = u\n        self.centers = centers\n        return centers\n\n    def next_centers(self, X, u):\n        um = u ** self.m\n        return (X.T @ um / np.sum(um, axis=0)).transpose()\n\n    def next_u(self, X, centers):\n        return self._predict(X, centers)\n\n    def _predict(self, X, centers):\n        power = float(2 / (self.m - 1))\n        temp = cdist(X, centers) ** power\n        denominator_ = temp.reshape((X.shape[0], 1, -1)).repeat(temp.shape[-1], axis=1)\n        denominator_ = temp[:, :, np.newaxis] / denominator_\n\n        return 1 / denominator_.sum(2)\n\n    def predict(self, X):\n        if len(X.shape) == 1:\n            X = np.expand_dims(X, axis=0)\n\n        u = self._predict(X, self.centers)\n        return np.argmax(u, axis=-1)\n'"
algorithms/gk.py,13,"b'import numpy as np\nfrom scipy.linalg import norm\n\n\nclass GK:\n    def __init__(self, n_clusters=4, max_iter=100, m=2, error=1e-6):\n        super().__init__()\n        self.u, self.centers, self.f = None, None, None\n        self.clusters_count = n_clusters\n        self.max_iter = max_iter\n        self.m = m\n        self.error = error\n\n    def fit(self, z):\n        N = z.shape[0]\n        C = self.clusters_count\n        centers = []\n\n        u = np.random.dirichlet(np.ones(N), size=C)\n\n        iteration = 0\n        while iteration < self.max_iter:\n            u2 = u.copy()\n\n            centers = self.next_centers(z, u)\n            f = self._covariance(z, centers, u)\n            dist = self._distance(z, centers, f)\n            u = self.next_u(dist)\n            iteration += 1\n\n            # Stopping rule\n            if norm(u - u2) < self.error:\n                break\n\n        self.f = f\n        self.u = u\n        self.centers = centers\n        return centers\n\n    def next_centers(self, z, u):\n        um = u ** self.m\n        return ((um @ z).T / um.sum(axis=1)).T\n\n    def _covariance(self, z, v, u):\n        um = u ** self.m\n\n        denominator = um.sum(axis=1).reshape(-1, 1, 1)\n        temp = np.expand_dims(z.reshape(z.shape[0], 1, -1) - v.reshape(1, v.shape[0], -1), axis=3)\n        temp = np.matmul(temp, temp.transpose((0, 1, 3, 2)))\n        numerator = um.transpose().reshape(um.shape[1], um.shape[0], 1, 1) * temp\n        numerator = numerator.sum(0)\n\n        return numerator / denominator\n\n    def _distance(self, z, v, f):\n        dif = np.expand_dims(z.reshape(z.shape[0], 1, -1) - v.reshape(1, v.shape[0], -1), axis=3)\n        determ = np.power(np.linalg.det(f), 1 / self.m)\n        det_time_inv = determ.reshape(-1, 1, 1) * np.linalg.pinv(f)\n        temp = np.matmul(dif.transpose((0, 1, 3, 2)), det_time_inv)\n        output = np.matmul(temp, dif).squeeze().T\n        return np.fmax(output, 1e-8)\n\n    def next_u(self, d):\n        power = float(1 / (self.m - 1))\n        d = d.transpose()\n        denominator_ = d.reshape((d.shape[0], 1, -1)).repeat(d.shape[-1], axis=1)\n        denominator_ = np.power(d[:, None, :] / denominator_.transpose((0, 2, 1)), power)\n        denominator_ = 1 / denominator_.sum(1)\n        denominator_ = denominator_.transpose()\n\n        return denominator_\n\n    def predict(self, z):\n        if len(z.shape) == 1:\n            z = np.expand_dims(z, axis=0)\n\n        dist = self._distance(z, self.centers, self.f)\n        if len(dist.shape) == 1:\n            dist = np.expand_dims(dist, axis=0)\n\n        u = self.next_u(dist)\n        return np.argmax(u, axis=0)\n'"
tests/aircraft.py,1,"b'import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\n\nfrom file_path_manager import FilePathManager\n\n\ndef get_type(s):\n    try:\n        ind = s.index("" "")\n        return s[:ind]\n    except:\n        return s\n\n\nnp.random.seed(5)\n\nX = pd.read_csv(FilePathManager.resolve(""data/aircraft.csv""), "","")\n# types = X[""Aircraft""]\n# types = types.apply(get_type)\nX = X.as_matrix()[:, 1:]\npca = PCA(2)\nX = pca.fit_transform(X)\nkmeans = KMeans(4)\nkmeans.fit(X)\ncentroids = kmeans.cluster_centers_\nprint(kmeans.labels_)\nplt.scatter(X[:, 0], X[:, 1], edgecolor=\'k\')\nplt.scatter(centroids[:, 0], centroids[:, 1], c=""red"", edgecolor=\'k\')\nplt.show()\n'"
tests/crime.py,0,"b'import matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\nfrom skfuzzy import cmeans\nfrom sklearn.cluster import KMeans\n\nfrom algorithms.fcm import FCM\nfrom algorithms.gk import GK\n\nsns.set()\n\nfrom file_path_manager import FilePathManager\n\ndataset_path = FilePathManager.resolve(""data/crime_data.csv"")\ndata = pd.read_csv(dataset_path)\nX = data.iloc[:, 2:4].values\n\nnumber_of_clusters = 4\nMAX_ITER = 50\nm = 2.00\n\ncntr, _, _, _, _, _, _ = cmeans(X.transpose(), number_of_clusters, m, 1e-8, maxiter=MAX_ITER)\nfcm = FCM(number_of_clusters, MAX_ITER, m)\ngk = GK(n_clusters=number_of_clusters, m=m, max_iter=MAX_ITER)\nkmeans = KMeans(n_clusters=number_of_clusters, max_iter=MAX_ITER)\ncmean_centers = fcm.fit(X)\ngk_centers = gk.fit(X)\nkmeans.fit(X)\n\npoints_s = plt.scatter(X[:, 0], X[:, 1], s=100, cmap=\'viridis\')\nfcm_s = plt.scatter(cmean_centers[:, 0], cmean_centers[:, 1], c=\'black\', s=250, alpha=0.7)\ngk_s = plt.scatter(gk_centers[:, 0], gk_centers[:, 1], c=\'yellow\', s=200, alpha=0.7)\n\nkmeans_centers = kmeans.cluster_centers_\nkm_s = plt.scatter(kmeans_centers[:, 0], kmeans_centers[:, 1], c=\'red\', s=200, alpha=0.7)\n\ncm_s = plt.scatter(cntr[:, 0], cntr[:, 1], c=\'green\', s=200, alpha=0.7)\nplt.legend((gk_s, fcm_s, cm_s, km_s, points_s),\n           (""GK Centers"", ""Our FCM Centers"", ""skfuzzy FCM Centers"", ""K-Means Centers"", ""Points""))\nplt.show()\n'"
tests/image_clustering.py,3,"b'import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom scipy import ndimage\nfrom sklearn import cluster\n\nfrom algorithms.fcm import FCM\nfrom algorithms.gk import GK\nfrom file_path_manager import FilePathManager\n\nsns.set()\n\nimage = ndimage.imread(FilePathManager.resolve(""images/car.jpg""))\nplt.figure(figsize=(15, 8))\nplt.imshow(image)\n\nx, y, z = image.shape\nimage_2d = image.reshape(x * y, z)\n\nkmeans_cluster = cluster.KMeans(n_clusters=7)\nkmeans_cluster.fit(image_2d)\ncluster_centers = kmeans_cluster.cluster_centers_\ncluster_labels = kmeans_cluster.labels_\n\nplt.figure(figsize=(15, 8))\nplt.title(""KMeans"")\nplt.imshow(cluster_centers[cluster_labels].astype(np.int32).reshape(x, y, z))\n\ncmeans_cluster = GK(n_clusters=7)\ncmeans_cluster.fit(image_2d)\ncluster_centers = cmeans_cluster.centers\ncluster_labels = np.arange(0, 7)\n\noutput = cmeans_cluster.predict(image_2d)\n\nplt.figure(figsize=(15, 8))\nplt.title(""CMeans"")\nplt.imshow(cluster_centers[output].astype(np.int32).reshape(x, y, 3))\nplt.show()\n'"
tests/iris.py,3,"b'import numpy as np\nimport seaborn as sns\nfrom skfuzzy import cmeans, cmeans_predict\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import load_iris\n\nfrom algorithms.fcm import FCM\nfrom algorithms.gk import GK\n\nsns.set()\n\ndata = load_iris()\nX, Y, target_names = data.data, data.target, data.target_names\n\nnumber_of_clusters = 3\nMAX_ITER = 500\nm = 2.00\nerror = 1e-8\nfor _ in range(50):\n    cntr = cmeans(X.transpose(), number_of_clusters, m, error, maxiter=MAX_ITER)[0]\n    fcm = FCM(number_of_clusters, MAX_ITER, m)\n    gk = GK(number_of_clusters, MAX_ITER, m)\n\n    kmeans = KMeans(n_clusters=number_of_clusters, max_iter=MAX_ITER)\n    cmean_centers = fcm.fit(X)\n    kmeans.fit(X)\n    gk_centers = gk.fit(X)\n\n    kmeans_accuracy = 0\n    fcm_accuracy = 0\n    gk_accuracy = 0\n    cmeans_accuracy = 0\n    cmeans_accuracy2 = 0\n\n    for i, y in enumerate(Y):\n        x = X[i]\n        y_predicted1 = fcm.predict(x)\n        fcm_accuracy += y_predicted1 == y\n\n        y_predicted4 = gk.predict(x)\n        gk_accuracy += y_predicted4 == y\n\n        y_predicted2 = kmeans.predict([x])[0]\n        kmeans_accuracy += y_predicted2 == y\n\n        y_predicted3 = cmeans_predict(np.expand_dims(x, 0).transpose(), cntr, m, error, maxiter=2)[0]\n        y_predicted3 = np.argmax(y_predicted3, axis=0)[0]\n        cmeans_accuracy += y_predicted3 == y\n        # print(f""y: {y}, fcm: {y_predicted1} , kmeans: {y_predicted2}, cmeans:{y_predicted3}"")\n\n        # if np.argmax(y_predicted, axis=0) == y:\n        #     print(f""equal {i}"")\n        # accuracy = accuracy + 1\n        # else:\n        #     print(y_predicted)\n\n    print(\n        f""FCM Accuracy: {fcm_accuracy/len(X)}, ""\n        f""K-Means Score: {kmeans_accuracy/len(X)}, ""\n        f""CMeans: {cmeans_accuracy/len(X)}, ""\n        f""GK: {gk_accuracy/len(X)}"")\n'"
tests/main.py,0,"b'import random\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom sklearn.datasets.samples_generator import make_blobs\n\nfrom algorithms.fuzzy_cmeans import FuzzyCMeans\nfrom algorithms.gk import GK\n\nsns.set()\nnumber_of_clusters = 5\nm = 2\niterations = 2000\nsamples = 200\nstd = 1\nX, _ = make_blobs(n_samples=samples, centers=number_of_clusters,\n                  cluster_std=std, random_state=random.randint(0, 200))\nfuzzy_cmeans = FuzzyCMeans()\ngk = GK(number_of_clusters)\ngk.fit(X)\ncenters = gk.centers\n\nprint(""centers:"")\nprint(centers)\nplt.scatter(X[:, 0], X[:, 1], s=50, cmap=\'viridis\')\nplt.scatter(centers[:, 0], centers[:, 1], c=\'black\', s=200, alpha=0.7)\nplt.show()\n'"
tests/test.py,3,"b'import numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom skfuzzy import cmeans, cmeans_predict\nfrom sklearn.cluster import KMeans\n\nfrom algorithms.fcm import FCM\nfrom file_path_manager import FilePathManager\n\nsns.set()\n\ndataset_path = FilePathManager.resolve(""data/crime_data.csv"")\ndata = pd.read_csv(dataset_path)\nX = data.iloc[:, 2:].values\n\nnumber_of_clusters = 4\nMAX_ITER = 500\nm = 2.00\nerror = 1e-8\n\ncntr = cmeans(X.transpose(), number_of_clusters, m, error, maxiter=MAX_ITER)[0]\nfcm = FCM(number_of_clusters, MAX_ITER, m)\nkmeans = KMeans(n_clusters=number_of_clusters, max_iter=MAX_ITER)\ncmean_centers = fcm.fit(X)\nkmeans.fit(X)\nY = data.iloc[:, 1].values\n\nkmeans_accuracy = 0\nfcm_accuracy = 0\ncmeans_accuracy = 0\ncmeans_accuracy2 = 0\n\nfor i, y in enumerate(Y):\n    x = X[i]\n    y_predicted1 = fcm.predict(x) + 1\n    fcm_accuracy += y_predicted1 == y\n\n    y_predicted2 = kmeans.predict([x])[0] + 1\n    kmeans_accuracy += y_predicted2 == y\n\n    y_predicted3 = cmeans_predict(np.expand_dims(x, 0).transpose(), cntr, m, error, maxiter=2)[0]\n    y_predicted3 = np.argmax(y_predicted3, axis=0)[0] + 1\n    cmeans_accuracy += y_predicted3 == y\n    print(f""y: {y}, fcm: {y_predicted1} , kmeans: {y_predicted2}, cmeans:{y_predicted3}"")\n\n    # if np.argmax(y_predicted, axis=0) == y:\n    #     print(f""equal {i}"")\n    # accuracy = accuracy + 1\n    # else:\n    #     print(y_predicted)\n\nprint(f""FCM Accuracy: {fcm_accuracy/len(X)}, K-Means Score: {kmeans_accuracy/len(X)}, CMeans: {cmeans_accuracy/len(X)}"")\n'"
