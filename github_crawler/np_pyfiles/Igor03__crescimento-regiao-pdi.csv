file_path,api_count,code
Atributos.py,1,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sun Aug  5 18:26:19 2018\n\n@author: IgorPC\n""""""\n\nfrom Limiar import get_vizinhos\n#from Limiar import get_coor_ps\nimport math\nimport numpy as np\nfrom collections import deque\n\ndef get_area(img):\n    w, h = img.shape\n    area = 0\n    for i in range (w):\n        for j in range (h):\n            if img[i, j] == 255:\n                area = area + 1\n    return area\n\ndef ver_vizinho_branco(img, x, y):\n    h, w = img.shape\n    vizinhos = get_vizinhos(x, y, w, h)\n    for i in range(len(vizinhos)):\n        if img[vizinhos[i]]==0 and img[x, y]==255:\n            return True\n        return False\n\ndef get_coor_ps (img):\n    # Ap\xc3\xb3s a imagem passar pelo processo de convolucao sao perdirdos\n    # 4 pixeis\n    w, h = img.shape\n    coor = deque()\n    for i in range (w-2):\n        for j in range (h-2):\n            if img[i, j] == 255:\n                coor.append((i, j))\n    return coor\n\n\ndef get_perimetro(img):\n    h, w = img.shape\n    perimetro = 0\n    for i in range (h):\n        for j in range (w):\n            if ver_vizinho_branco(img, i, j):\n                perimetro = perimetro + 1\n    return perimetro+1 # Quando ocorrem erros na segmentacao\n\ndef get_circularidade (img):\n    \n    return ((4*math.pi*get_area(img)/(get_perimetro(img)**2)))\n\ndef get_desvioP (img, img_seg):\n    #w, h = img_seg.shape\n    coor_ps = get_coor_ps(img_seg)\n    intensi_pix = np.zeros(len(coor_ps))\n    for i in range (intensi_pix.size):\n        intensi_pix[i] = img[coor_ps[i]]\n    \n    return intensi_pix.std()\n\ndef get_razao_ap (img):\n    return (get_area(img))/(get_perimetro(img))\n\n#def get_desvioP (img):\n#    return img.std()\n\ndef mostrar_atrib (img, img_seg):\n    print (\'\xc3\x81rea: \', get_area(img_seg))\n    print (\'Razao entre \xc3\xa1rea e per\xc3\xadmetro: \', (get_area(img_seg))/(get_perimetro(img_seg)))\n    print (\'Circularidade: \', get_circularidade(img_seg))\n    print (\'Desvio padr\xc3\xa3o: \', get_desvioP(img, img_seg))\n\n\ndef remover_ruido (img):\n    w, h = img.shape\n    count_v_brancos = 0\n    count_v_pretos = 0\n    p_brancos = get_coor_ps(img)\n    for p in p_brancos:\n        p_vizinhos = get_vizinhos(p[0], p[1], h, w)\n        while p_vizinhos:\n            if img[p_vizinhos.popleft()] == 0:\n                count_v_pretos = count_v_pretos + 1\n            else:\n                count_v_brancos = count_v_brancos + 1\n        if (count_v_pretos > count_v_brancos):\n            img[p] = 0\n    return img        '"
Limiar.py,4,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Thu Aug  2 21:11:42 2018\n\n@author: IgorPC\n""""""\n\n\nimport numpy as np\nfrom collections import deque\nimport warnings\nwarnings.filterwarnings(""ignore"")\n\n#Sabemos que todas a imegens tem dimensao 200x200\ndef get_slices(img):\n    \n    w, h = img.shape\n    slices = np.zeros(shape=(w, h), dtype = np.uint8)\n    \n#    semente[:, :3] = 255\n#    semente[:, 100:103] = 255\n#    semente[:, 50:53] = 255\n#    semente[:, 150:153] = 255\n#    semente[:, 197:] = 255\n    \n    slices[:3, :] = 255\n    slices[50:53, :] = 255 \n    slices[150:153, :] = 255\n    slices[100:103, :] = 255\n    slices[197:, :] = 255\n    \n    return slices\n\n# Retorna uma lista com as coordeanadas dos pixels vizinhos do\n# pixel img(x, y)\ndef get_vizinhos(x, y, w, h):\n    lista = deque()\n    pontos = [(x-1,y), (x+1, y), (x,y-1), (x,y+1),\n              (x-1,y+1), (x+1, y+1), (x-1,y-1), (x+1,y-1),\n             ]\n    for p in pontos:\n        if (p[0]>=0 and p[1]>=0 and p[0]<w and p[1]<h):\n            lista.append((p[0], p[1]))        \n    return lista\n\ndef get_coor_slices (img, slices):\n    \n    count = 0\n    w, h = img.shape\n    fila = deque()\n    \n    for x in range(w):\n        for y in range(h):\n            if slices[x,y]==255:\n                count = count+1\n                fila.append((x,y))\n    #print (count)\n    return fila\n\n#def get_maior_dif(pixel, semente):\n#    maior = 0\n#    x, y = pixel\n#    h, w = semente.shape # ou img.shape\n#    vizinhos = get_vizinhos(x, y, w, h)\n#    for i in range(len(vizinhos)):\n#        if ((abs(img[pixel] - img[vizinhos[i]]) >= maior)):\n#            maior = abs(img[pixel] - img[vizinhos[i]])\n#            \n#    return maior\n\n#def get_intesidad_media (img, semente):\n#    \n#    #soma = np.zeros(h*3+w*3)\n#    soma = 0\n#    count = 0\n#    h, w = img.shape\n#    for x in range(h):\n#        for y in range(w):\n#            if semente[x, y]==255:\n#                count = count+1\n#                soma = soma + img[x, y]\n#    print(count)\n#    return soma/count\n\ndef get_maior_dif(img, pixel, slices):\n    #maior = 0\n    x, y = pixel\n    h, w = slices.shape # ou img.shape\n    vizinhos = get_vizinhos(x, y, w, h)\n    difs = np.zeros(len(vizinhos))\n    for i in range(len(vizinhos)):\n        difs[i] = abs(img[pixel] - img[vizinhos[i]])        \n    return difs.mean()\n\ndef get_epsilon (img):\n    semente = get_slices(img)\n    coor_p_semente = get_coor_slices(img, semente)\n    difs = np.zeros(len(coor_p_semente))\n    for i in range(len(coor_p_semente)):\n        pixel = coor_p_semente.pop()\n        difs[i] = get_maior_dif(img, pixel, semente)\n    \n    return difs.mean().round(5)\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    '"
crescimentoDeRegiÃ£o.py,3,"b'import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import deque\nfrom scipy import signal as sg\nimport cv2\nfrom Limiar import get_epsilon\nimport Atributos as atb\n\ndef obterSemente(image):\n    w, h = image.shape\n    semente = np.zeros((w, h))\n    semente[:, :3] = 255 # Lateral esquerda\n    semente[:, (h-3):] = 255 # Lateral direita\n    \n    return semente\n\ndef vizinhos(x, y, w, h):\n    lista = deque()\n    \n    pontos = [(x-1,y), (x+1, y), (x,y-1), (x,y+1),\n              (x-1,y+1), (x+1, y+1), (x-1,y-1), (x+1,y-1),\n             ]\n    for p in pontos:\n        if (p[0]>=0 and p[1]>=0 and p[0]<w and p[1]<h):\n            lista.append((p[0], p[1]))\n            \n    return lista\n    \ndef crescerRegiao(image, reg, epsilon=5):\n    w, h = image.shape\n    \n    fila = deque()\n    for x in range(w):\n        for y in range(h):\n            if reg[x,y]==255:\n                fila.append((x,y))\n                \n    while fila: \n        ponto = fila.popleft()\n        x = ponto[0]\n        y = ponto[1]\n\n        v_list = vizinhos(x, y, w, h)\n        for v in v_list:\n            v_x = v[0]\n            v_y = v[1]\n            if( (reg[v_x][v_y]!=255) and (abs(image[x][y]-image[v_x][v_y])<epsilon)):\n                reg[v_x][v_y] = 255\n                fila.append((v_x,v_y))\n    return reg\n                \ndef plots(p1, p2, pil):\n    fig = plt.figure(figsize=(9,3), dpi=80)\n    a = fig.add_subplot(1,3,1)\n    a.axis(\'off\')\n    plt.imshow(p1, cmap=plt.cm.gray)\n    a.set_title(\'Original em tons de cinza\')\n\n    a = fig.add_subplot(1,3,2)\n    a.axis(\'off\')\n    plt.imshow(p2, cmap=plt.cm.gray)\n    a.set_title(\'Imagem segmentada\')\n\n    a = fig.add_subplot(1,3,3)\n    a.axis(\'off\')\n    plt.imshow(p1, cmap=plt.cm.gray)\n    plt.imshow(p2, alpha=0.5)\n    a.set_title(\'Regi\xc3\xa3o Segmentada\')\n\n    plt.savefig(\'resultados/\'+pil+\'/(\'+x+\').jpg\')\n\n    plt.show()\n    \ndef inv_img (img):\n    h, w = img.shape\n    #print (\'A:\', h, \'L:\', w)\n    for i in  range(h):\n        for j in  range(w):\n            if img[i, j] == 0:\n                img[i, j] = 255\n            else:\n                img[i, j] = 0\n    return img\n#######################################################################\n    \nk = 0\npil = \'WB\' \nqtd_imgs = 18\narea_media = 0\ncirc_media = 0\nrazao_ap_media = 0\ndesv_padrao_medio = 0\nfor i in range (qtd_imgs):\n    k=k+1\n    x = str(k)\n    img1 = cv2.imread(\'images/\'+pil+\'/\'+pil+\' (\'+x+\').jpg\', 0)\n    img1 = (img1 * 255).round().astype(np.uint8)\n    semente = obterSemente(img1)\n    media3 = [[1./9., 1./9., 1./9.], \n          [1./9., 1./9., 1./9.],\n          [1./9., 1./9., 1./9.]]\n    c_media = sg.convolve(img1, media3, ""valid"")\n    #c_media = cv2.medianBlur(img1,9)\n    v = get_epsilon(c_media)\n    regiao = crescerRegiao(c_media, semente, epsilon=v)\n    regiao = inv_img(regiao)\n    regiao = regiao.astype(np.uint8)\n    regiao = cv2.medianBlur(regiao,9)\n    #regiao = atb.remover_ruido(regiao)\n    #cv2.imwrite(pil+\'/(\'+x+\').jpg\', regiao)\n    print (\'----------------------------\')\n    print (\'Pilula \'+pil+\' (\'+x+\')\')\n    print (\'----------------------------\')\n    #Calculando atributos\n    atb.mostrar_atrib(c_media, regiao)\n    area_media = area_media + atb.get_area(regiao)\n    razao_ap_media = razao_ap_media + atb.get_razao_ap(regiao)\n    circ_media = circ_media + atb.get_circularidade(regiao)\n    desv_padrao_medio = desv_padrao_medio + atb.get_desvioP(c_media, regiao) \n    plots(c_media, regiao, pil)\n    \nprint (\'Atributos \'+ pil + \'\\n------------------\')\nprint (\'\xc3\x81rea m\xc3\xa9dia: \', area_media/qtd_imgs)\nprint (\'Raz\xc3\xa3o entre \xc3\xa1rea e per\xc3\xadmetro: \', razao_ap_media/qtd_imgs)\nprint (\'Circularidade m\xc3\xa9dia: \', circ_media/qtd_imgs)\nprint (\'Desvio padr\xc3\xa3o: \', desv_padrao_medio/qtd_imgs)\n\n'"
