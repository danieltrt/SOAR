file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2020, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nimport io\nimport re\n\nwith io.open(\'mkl_fft/_version.py\', \'rt\', encoding=\'utf8\') as f:\n    version = re.search(r\'__version__ = \\\'(.*?)\\\'\', f.read()).group(1)\n\nVERSION = version\n\nCLASSIFIERS = """"""\\\nDevelopment Status :: 5 - Production/Stable\nIntended Audience :: Science/Research\nIntended Audience :: Developers\nLicense :: OSI Approved\nProgramming Language :: C\nProgramming Language :: Python\nProgramming Language :: Python :: 2\nProgramming Language :: Python :: 2.7\nProgramming Language :: Python :: 3\nProgramming Language :: Python :: 3.5\nProgramming Language :: Python :: 3.6\nProgramming Language :: Python :: Implementation :: CPython\nTopic :: Software Development\nTopic :: Scientific/Engineering\nOperating System :: Microsoft :: Windows\nOperating System :: POSIX\nOperating System :: Unix\nOperating System :: MacOS\n""""""\n\ndef configuration(parent_package=\'\',top_path=None):\n    from numpy.distutils.misc_util import Configuration\n\n    config = Configuration(None, parent_package, top_path)\n    config.set_options(ignore_setup_xxx_py=True,\n                       assume_default_configuration=True,\n                       delegate_options_to_subpackages=True,\n                       quiet=True)\n\n    config.add_subpackage(\'mkl_fft\')\n\n    config.version = VERSION\n\n    return config\n\n\ndef setup_package():\n    from setuptools import setup\n    from numpy.distutils.core import setup\n    metadata = dict(\n        name = \'mkl_fft\',\n        maintainer = ""Intel Corp."",\n        maintainer_email = ""scripting@intel.com"",\n        description = ""MKL-based FFT transforms for NumPy arrays"",\n        long_description = """"""NumPy-based implementation of Fast Fourier Transform using Intel (R) Math Kernel Library. 1D and ND, complex and real transforms, in-place and not-in-place on single and double precision arrays"""""",\n        url = ""http://github.com/IntelPython/mkl_fft"",\n        author = ""Intel Corporation"",\n        download_url = ""http://github.com/IntelPython/mkl_fft"",\n        license = \'BSD\',\n        classifiers = [_f for _f in CLASSIFIERS.split(\'\\n\') if _f],\n        platforms = [""Windows"", ""Linux"", ""Mac OS-X""],\n        test_suite = \'nose.collector\',\n        python_requires = \'>=3.5\',\n        install_requires = [\'numpy\'],\n        configuration = configuration\n    )\n    setup(**metadata)\n\n    return None\n\nif __name__ == \'__main__\':\n    setup_package()\n'"
conda-recipe/run_test.py,0,b''
mkl_fft/__init__.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom ._pydfti import (fft, ifft, fft2, ifft2, fftn, ifftn, rfft, irfft,\n                      rfft_numpy, irfft_numpy, rfftn_numpy, irfftn_numpy)\n\nfrom ._version import __version__\n\n__all__ = [\'fft\', \'ifft\', \'fft2\', \'ifft2\', \'fftn\', \'ifftn\', \'rfft\', \'irfft\',\n           \'rfft_numpy\', \'irfft_numpy\', \'rfftn_numpy\', \'irfftn_numpy\']\n'"
mkl_fft/_float_utils.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom numpy import (half, float32, asarray, ndarray,\n                   longdouble, float64, longcomplex, complex_)\n\n__all__ = [\'__upcast_float16_array\', \'__downcast_float128_array\']\n\ndef __upcast_float16_array(x):\n    """"""\n    Used in _scipy_fft to upcast float16 to float32, \n    instead of float64, as mkl_fft would do""""""\n    if hasattr(x, ""dtype""):\n        xdt = x.dtype\n        if xdt == half:\n            # no half-precision routines, so convert to single precision\n            return asarray(x, dtype=float32)\n        if xdt == longdouble and not xdt == float64:\n            raise ValueError(""type %s is not supported"" % xdt)\n    if not isinstance(x, ndarray):\n        __x = asarray(x)\n        xdt = __x.dtype\n        if xdt == half:\n            # no half-precision routines, so convert to single precision\n            return asarray(__x, dtype=float32)\n        if xdt == longdouble and not xdt == float64:\n            raise ValueError(""type %s is not supported"" % xdt)\n        return __x\n    return x\n\n\ndef __downcast_float128_array(x):\n    """"""\n    Used in _numpy_fft to unsafely downcast float128/complex256 to \n    complex128, instead of raising an error""""""\n    if hasattr(x, ""dtype""):\n        xdt = x.dtype\n        if xdt == longdouble and not xdt == float64:\n            return asarray(x, dtype=float64)\n        elif xdt == longcomplex and not xdt == complex_:\n            return asarray(x, dtype=complex_)\n    if not isinstance(x, ndarray):\n        __x = asarray(x)\n        xdt = __x.dtype\n        if xdt == longdouble and not xdt == float64:\n            return asarray(x, dtype=float64)\n        elif xdt == longcomplex and not xdt == complex_:\n            return asarray(x, dtype=complex_)\n        return __x\n    return x\n'"
mkl_fft/_numpy_fft.py,45,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""\nDiscrete Fourier Transforms\n\nRoutines in this module:\n\nfft(a, n=None, axis=-1)\nifft(a, n=None, axis=-1)\nrfft(a, n=None, axis=-1)\nirfft(a, n=None, axis=-1)\nhfft(a, n=None, axis=-1)\nihfft(a, n=None, axis=-1)\nfftn(a, s=None, axes=None)\nifftn(a, s=None, axes=None)\nrfftn(a, s=None, axes=None)\nirfftn(a, s=None, axes=None)\nfft2(a, s=None, axes=(-2,-1))\nifft2(a, s=None, axes=(-2, -1))\nrfft2(a, s=None, axes=(-2,-1))\nirfft2(a, s=None, axes=(-2, -1))\n\ni = inverse transform\nr = transform of purely real data\nh = Hermite transform\nn = n-dimensional transform\n2 = 2-dimensional transform\n(Note: 2D routines are just nD routines with different default\nbehavior.)\n\n""""""\nfrom __future__ import division, absolute_import, print_function\n\n__all__ = [\'fft\', \'ifft\', \'rfft\', \'irfft\', \'hfft\', \'ihfft\', \'rfftn\',\n           \'irfftn\', \'rfft2\', \'irfft2\', \'fft2\', \'ifft2\', \'fftn\', \'ifftn\']\n\nfrom numpy.core import (array, asarray, shape, conjugate, take, sqrt, prod)\n\nimport numpy\nfrom . import _pydfti as mkl_fft\nfrom . import _float_utils\n\n\ndef _unitary(norm):\n    if norm not in (None, ""ortho""):\n        raise ValueError(""Invalid norm value %s, should be None or \\""ortho\\"".""\n                         % norm)\n    return norm is not None\n\n\ndef fft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the one-dimensional discrete Fourier Transform.\n\n    This function computes the one-dimensional *n*-point discrete Fourier\n    Transform (DFT) with the efficient Fast Fourier Transform (FFT)\n    algorithm [CT].\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex.\n    n : int, optional\n        Length of the transformed axis of the output.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros.  If `n` is not given,\n        the length of the input along the axis specified by `axis` is used.\n    axis : int, optional\n        Axis over which to compute the FFT.  If not given, the last axis is\n        used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n\n    Raises\n    ------\n    IndexError\n        if `axes` is larger than the last axis of `a`.\n\n    See Also\n    --------\n    numpy.fft : for definition of the DFT and conventions used.\n    ifft : The inverse of `fft`.\n    fft2 : The two-dimensional FFT.\n    fftn : The *n*-dimensional FFT.\n    rfftn : The *n*-dimensional FFT of real input.\n    fftfreq : Frequency bins for given FFT parameters.\n\n    Notes\n    -----\n    FFT (Fast Fourier Transform) refers to a way the discrete Fourier\n    Transform (DFT) can be calculated efficiently, by using symmetries in the\n    calculated terms.  The symmetry is highest when `n` is a power of 2, and\n    the transform is therefore most efficient for these sizes.\n\n    The DFT is defined, with the conventions used in this implementation, in\n    the documentation for the `numpy.fft` module.\n\n    References\n    ----------\n    .. [CT] Cooley, James W., and John W. Tukey, 1965, ""An algorithm for the\n            machine calculation of complex Fourier series,"" *Math. Comput.*\n            19: 297-301.\n\n    Examples\n    --------\n    >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\n    array([ -3.44505240e-16 +1.14383329e-17j,\n             8.00000000e+00 -5.71092652e-15j,\n             2.33482938e-16 +1.22460635e-16j,\n             1.64863782e-15 +1.77635684e-15j,\n             9.95839695e-17 +2.33482938e-16j,\n             0.00000000e+00 +1.66837030e-15j,\n             1.14383329e-17 +1.22460635e-16j,\n             -1.64863782e-15 +1.77635684e-15j])\n\n    >>> import matplotlib.pyplot as plt\n    >>> t = np.arange(256)\n    >>> sp = np.fft.fft(np.sin(t))\n    >>> freq = np.fft.fftfreq(t.shape[-1])\n    >>> plt.plot(freq, sp.real, freq, sp.imag)\n    [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]\n    >>> plt.show()\n\n    In this example, real input has an FFT which is Hermitian, i.e., symmetric\n    in the real part and anti-symmetric in the imaginary part, as described in\n    the `numpy.fft` documentation.\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.fft(x, n, axis)\n    if _unitary(norm):\n        output *= 1 / sqrt(output.shape[axis])\n    return output\n\n\ndef ifft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the one-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the one-dimensional *n*-point\n    discrete Fourier transform computed by `fft`.  In other words,\n    ``ifft(fft(a)) == a`` to within numerical accuracy.\n    For a general description of the algorithm and definitions,\n    see `numpy.fft`.\n\n    The input should be ordered in the same way as is returned by `fft`,\n    i.e.,\n\n    * ``a[0]`` should contain the zero frequency term,\n    * ``a[1:n//2]`` should contain the positive-frequency terms,\n    * ``a[n//2 + 1:]`` should contain the negative-frequency terms, in\n      increasing order starting from the most negative frequency.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex.\n    n : int, optional\n        Length of the transformed axis of the output.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros.  If `n` is not given,\n        the length of the input along the axis specified by `axis` is used.\n        See notes about padding issues.\n    axis : int, optional\n        Axis over which to compute the inverse DFT.  If not given, the last\n        axis is used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n\n    Raises\n    ------\n    IndexError\n        If `axes` is larger than the last axis of `a`.\n\n    See Also\n    --------\n    numpy.fft : An introduction, with definitions and general explanations.\n    fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse\n    ifft2 : The two-dimensional inverse FFT.\n    ifftn : The n-dimensional inverse FFT.\n\n    Notes\n    -----\n    If the input parameter `n` is larger than the size of the input, the input\n    is padded by appending zeros at the end.  Even though this is the common\n    approach, it might lead to surprising results.  If a different padding is\n    desired, it must be performed before calling `ifft`.\n\n    Examples\n    --------\n    >>> np.fft.ifft([0, 4, 0, 0])\n    array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])\n\n    Create and plot a band-limited signal with random phases:\n\n    >>> import matplotlib.pyplot as plt\n    >>> t = np.arange(400)\n    >>> n = np.zeros((400,), dtype=complex)\n    >>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))\n    >>> s = np.fft.ifft(n)\n    >>> plt.plot(t, s.real, \'b-\', t, s.imag, \'r--\')\n    ...\n    >>> plt.legend((\'real\', \'imaginary\'))\n    ...\n    >>> plt.show()\n\n    """"""\n    unitary = _unitary(norm)\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.ifft(x, n, axis)\n    if unitary:\n        output *= sqrt(output.shape[axis])\n    return output\n\n\ndef rfft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the one-dimensional discrete Fourier Transform for real input.\n\n    This function computes the one-dimensional *n*-point discrete Fourier\n    Transform (DFT) of a real-valued array by means of an efficient algorithm\n    called the Fast Fourier Transform (FFT).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array\n    n : int, optional\n        Number of points along transformation axis in the input to use.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros. If `n` is not given,\n        the length of the input along the axis specified by `axis` is used.\n    axis : int, optional\n        Axis over which to compute the FFT. If not given, the last axis is\n        used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n        If `n` is even, the length of the transformed axis is ``(n/2)+1``.\n        If `n` is odd, the length is ``(n+1)/2``.\n\n    Raises\n    ------\n    IndexError\n        If `axis` is larger than the last axis of `a`.\n\n    See Also\n    --------\n    numpy.fft : For definition of the DFT and conventions used.\n    irfft : The inverse of `rfft`.\n    fft : The one-dimensional FFT of general (complex) input.\n    fftn : The *n*-dimensional FFT.\n    rfftn : The *n*-dimensional FFT of real input.\n\n    Notes\n    -----\n    When the DFT is computed for purely real input, the output is\n    Hermitian-symmetric, i.e. the negative frequency terms are just the complex\n    conjugates of the corresponding positive-frequency terms, and the\n    negative-frequency terms are therefore redundant.  This function does not\n    compute the negative frequency terms, and the length of the transformed\n    axis of the output is therefore ``n//2 + 1``.\n\n    When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains\n    the zero-frequency term 0*fs, which is real due to Hermitian symmetry.\n\n    If `n` is even, ``A[-1]`` contains the term representing both positive\n    and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely\n    real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains\n    the largest positive frequency (fs/2*(n-1)/n), and is complex in the\n    general case.\n\n    If the input `a` contains an imaginary part, it is silently discarded.\n\n    Examples\n    --------\n    >>> np.fft.fft([0, 1, 0, 0])\n    array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j])\n    >>> np.fft.rfft([0, 1, 0, 0])\n    array([ 1.+0.j,  0.-1.j, -1.+0.j])\n\n    Notice how the final element of the `fft` output is the complex conjugate\n    of the second element, for real input. For `rfft`, this symmetry is\n    exploited to compute only the non-negative frequency terms.\n\n    """"""\n    unitary = _unitary(norm)\n    x = _float_utils.__downcast_float128_array(a)\n    if unitary and n is None:\n        x = asarray(x)\n        n = x.shape[axis]\n    output = mkl_fft.rfft_numpy(x, n=n, axis=axis)\n    if unitary:\n        output *= 1 / sqrt(n)\n    return output\n\n\ndef irfft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the inverse of the n-point DFT for real input.\n\n    This function computes the inverse of the one-dimensional *n*-point\n    discrete Fourier Transform of real input computed by `rfft`.\n    In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical\n    accuracy. (See Notes below for why ``len(a)`` is necessary here.)\n\n    The input is expected to be in the form returned by `rfft`, i.e. the\n    real zero-frequency term followed by the complex positive frequency terms\n    in order of increasing frequency.  Since the discrete Fourier Transform of\n    real input is Hermitian-symmetric, the negative frequency terms are taken\n    to be the complex conjugates of the corresponding positive frequency terms.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    n : int, optional\n        Length of the transformed axis of the output.\n        For `n` output points, ``n//2+1`` input points are necessary.  If the\n        input is longer than this, it is cropped.  If it is shorter than this,\n        it is padded with zeros.  If `n` is not given, it is determined from\n        the length of the input along the axis specified by `axis`.\n    axis : int, optional\n        Axis over which to compute the inverse FFT. If not given, the last\n        axis is used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n        The length of the transformed axis is `n`, or, if `n` is not given,\n        ``2*(m-1)`` where ``m`` is the length of the transformed axis of the\n        input. To get an odd number of output points, `n` must be specified.\n\n    Raises\n    ------\n    IndexError\n        If `axis` is larger than the last axis of `a`.\n\n    See Also\n    --------\n    numpy.fft : For definition of the DFT and conventions used.\n    rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.\n    fft : The one-dimensional FFT.\n    irfft2 : The inverse of the two-dimensional FFT of real input.\n    irfftn : The inverse of the *n*-dimensional FFT of real input.\n\n    Notes\n    -----\n    Returns the real valued `n`-point inverse discrete Fourier transform\n    of `a`, where `a` contains the non-negative frequency terms of a\n    Hermitian-symmetric sequence. `n` is the length of the result, not the\n    input.\n\n    If you specify an `n` such that `a` must be zero-padded or truncated, the\n    extra/removed values will be added/removed at high frequencies. One can\n    thus resample a series to `m` points via Fourier interpolation by:\n    ``a_resamp = irfft(rfft(a), m)``.\n\n    Examples\n    --------\n    >>> np.fft.ifft([1, -1j, -1, 1j])\n    array([ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j])\n    >>> np.fft.irfft([1, -1j, -1])\n    array([ 0.,  1.,  0.,  0.])\n\n    Notice how the last term in the input to the ordinary `ifft` is the\n    complex conjugate of the second term, and the output has zero imaginary\n    part everywhere.  When calling `irfft`, the negative frequencies are not\n    specified, and the output array is purely real.\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.irfft_numpy(x, n=n, axis=axis)\n    if _unitary(norm):\n        output *= sqrt(output.shape[axis])\n    return output\n\n\ndef hfft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the FFT of a signal which has Hermitian symmetry (real spectrum).\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    n : int, optional\n        Length of the transformed axis of the output.\n        For `n` output points, ``n//2+1`` input points are necessary.  If the\n        input is longer than this, it is cropped.  If it is shorter than this,\n        it is padded with zeros.  If `n` is not given, it is determined from\n        the length of the input along the axis specified by `axis`.\n    axis : int, optional\n        Axis over which to compute the FFT. If not given, the last\n        axis is used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n        The length of the transformed axis is `n`, or, if `n` is not given,\n        ``2*(m-1)`` where ``m`` is the length of the transformed axis of the\n        input. To get an odd number of output points, `n` must be specified.\n\n    Raises\n    ------\n    IndexError\n        If `axis` is larger than the last axis of `a`.\n\n    See also\n    --------\n    rfft : Compute the one-dimensional FFT for real input.\n    ihfft : The inverse of `hfft`.\n\n    Notes\n    -----\n    `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the\n    opposite case: here the signal has Hermitian symmetry in the time domain\n    and is real in the frequency domain. So here it\'s `hfft` for which\n    you must supply the length of the result if it is to be odd:\n    ``ihfft(hfft(a), len(a)) == a``, within numerical accuracy.\n\n    Examples\n    --------\n    >>> signal = np.array([1, 2, 3, 4, 3, 2])\n    >>> np.fft.fft(signal)\n    array([ 15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j])\n    >>> np.fft.hfft(signal[:4]) # Input first half of signal\n    array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])\n    >>> np.fft.hfft(signal, 6)  # Input entire signal and truncate\n    array([ 15.,  -4.,   0.,  -1.,   0.,  -4.])\n\n\n    >>> signal = np.array([[1, 1.j], [-1.j, 2]])\n    >>> np.conj(signal.T) - signal   # check Hermitian symmetry\n    array([[ 0.-0.j,  0.+0.j],\n           [ 0.+0.j,  0.-0.j]])\n    >>> freq_spectrum = np.fft.hfft(signal)\n    >>> freq_spectrum\n    array([[ 1.,  1.],\n           [ 2., -2.]])\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    x = array(x, copy=True, dtype=complex)\n    if n is None:\n        n = (x.shape[axis] - 1) * 2\n    unitary = _unitary(norm)\n    return irfft(conjugate(x), n, axis) * (sqrt(n) if unitary else n)\n\n\ndef ihfft(a, n=None, axis=-1, norm=None):\n    """"""\n    Compute the inverse FFT of a signal which has Hermitian symmetry.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    n : int, optional\n        Length of the inverse FFT.\n        Number of points along transformation axis in the input to use.\n        If `n` is smaller than the length of the input, the input is cropped.\n        If it is larger, the input is padded with zeros. If `n` is not given,\n        the length of the input along the axis specified by `axis` is used.\n    axis : int, optional\n        Axis over which to compute the inverse FFT. If not given, the last\n        axis is used.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axis\n        indicated by `axis`, or the last one if `axis` is not specified.\n        If `n` is even, the length of the transformed axis is ``(n/2)+1``.\n        If `n` is odd, the length is ``(n+1)/2``.\n\n    See also\n    --------\n    hfft, irfft\n\n    Notes\n    -----\n    `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the\n    opposite case: here the signal has Hermitian symmetry in the time domain\n    and is real in the frequency domain. So here it\'s `hfft` for which\n    you must supply the length of the result if it is to be odd:\n    ``ihfft(hfft(a), len(a)) == a``, within numerical accuracy.\n\n    Examples\n    --------\n    >>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n    >>> np.fft.ifft(spectrum)\n    array([ 1.+0.j,  2.-0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.-0.j])\n    >>> np.fft.ihfft(spectrum)\n    array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j])\n\n    """"""\n    # The copy may be required for multithreading.\n    x = _float_utils.__downcast_float128_array(a)\n    x = array(x, copy=True, dtype=float)\n    if n is None:\n        n = x.shape[axis]\n    unitary = _unitary(norm)\n    output = conjugate(rfft(x, n, axis))\n    return output * (1 / (sqrt(n) if unitary else n))\n\n\ndef _cook_nd_args(a, s=None, axes=None, invreal=0):\n    if s is None:\n        shapeless = 1\n        if axes is None:\n            s = list(a.shape)\n        else:\n            s = take(a.shape, axes)\n    else:\n        shapeless = 0\n    s = list(s)\n    if axes is None:\n        axes = list(range(-len(s), 0))\n    if len(s) != len(axes):\n        raise ValueError(""Shape and axes have different lengths."")\n    if invreal and shapeless:\n        s[-1] = (a.shape[axes[-1]] - 1) * 2\n    return s, axes\n\n\ndef _tot_size(x, axes):\n    s = x.shape\n    if axes is None:\n        return x.size\n    return prod([s[ai] for ai in axes])\n\n\ndef fftn(a, s=None, axes=None, norm=None):\n    """"""\n    Compute the N-dimensional discrete Fourier Transform.\n\n    This function computes the *N*-dimensional discrete Fourier Transform over\n    any number of axes in an *M*-dimensional array by means of the Fast Fourier\n    Transform (FFT).\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex.\n    s : sequence of ints, optional\n        Shape (length of each transformed axis) of the output\n        (`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).\n        This corresponds to `n` for `fft(x, n)`.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.\n    axes : sequence of ints, optional\n        Axes over which to compute the FFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the transform over that axis is\n        performed multiple times.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or by a combination of `s` and `a`,\n        as explained in the parameters section above.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    numpy.fft : Overall view of discrete Fourier transforms, with definitions\n        and conventions used.\n    ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.\n    fft : The one-dimensional FFT, with definitions and conventions used.\n    rfftn : The *n*-dimensional FFT of real input.\n    fft2 : The two-dimensional FFT.\n    fftshift : Shifts zero-frequency terms to centre of array\n\n    Notes\n    -----\n    The output, analogously to `fft`, contains the term for zero frequency in\n    the low-order corner of all axes, the positive frequency terms in the\n    first half of all axes, the term for the Nyquist frequency in the middle\n    of all axes and the negative frequency terms in the second half of all\n    axes, in order of decreasingly negative frequency.\n\n    See `numpy.fft` for details, definitions and conventions used.\n\n    Examples\n    --------\n    >>> a = np.mgrid[:3, :3, :3][0]\n    >>> np.fft.fftn(a, axes=(1, 2))\n    array([[[  0.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j]],\n           [[  9.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j]],\n           [[ 18.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j],\n            [  0.+0.j,   0.+0.j,   0.+0.j]]])\n    >>> np.fft.fftn(a, (2, 2), axes=(0, 1))\n    array([[[ 2.+0.j,  2.+0.j,  2.+0.j],\n            [ 0.+0.j,  0.+0.j,  0.+0.j]],\n           [[-2.+0.j, -2.+0.j, -2.+0.j],\n            [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n\n    >>> import matplotlib.pyplot as plt\n    >>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,\n    ...                      2 * np.pi * np.arange(200) / 34)\n    >>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)\n    >>> FS = np.fft.fftn(S)\n    >>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))\n    <matplotlib.image.AxesImage object at 0x...>\n    >>> plt.show()\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.fftn(x, s, axes)\n    if _unitary(norm):\n        output *= 1 / sqrt(_tot_size(output, axes))\n    return output\n\n\ndef ifftn(a, s=None, axes=None, norm=None):\n    """"""\n    Compute the N-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the N-dimensional discrete\n    Fourier Transform over any number of axes in an M-dimensional array by\n    means of the Fast Fourier Transform (FFT).  In other words,\n    ``ifftn(fftn(a)) == a`` to within numerical accuracy.\n    For a description of the definitions and conventions used, see `numpy.fft`.\n\n    The input, analogously to `ifft`, should be ordered in the same way as is\n    returned by `fftn`, i.e. it should have the term for zero frequency\n    in all axes in the low-order corner, the positive frequency terms in the\n    first half of all axes, the term for the Nyquist frequency in the middle\n    of all axes and the negative frequency terms in the second half of all\n    axes, in order of decreasingly negative frequency.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex.\n    s : sequence of ints, optional\n        Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        This corresponds to ``n`` for ``ifft(x, n)``.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.  See notes for issue on `ifft` zero padding.\n    axes : sequence of ints, optional\n        Axes over which to compute the IFFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the inverse transform over that\n        axis is performed multiple times.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or by a combination of `s` or `a`,\n        as explained in the parameters section above.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    numpy.fft : Overall view of discrete Fourier transforms, with definitions\n         and conventions used.\n    fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.\n    ifft : The one-dimensional inverse FFT.\n    ifft2 : The two-dimensional inverse FFT.\n    ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning\n        of array.\n\n    Notes\n    -----\n    See `numpy.fft` for definitions and conventions used.\n\n    Zero-padding, analogously with `ifft`, is performed by appending zeros to\n    the input along the specified dimension.  Although this is the common\n    approach, it might lead to surprising results.  If another form of zero\n    padding is desired, it must be performed before `ifftn` is called.\n\n    Examples\n    --------\n    >>> a = np.eye(4)\n    >>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\n    array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n\n\n    Create and plot an image with band-limited frequency content:\n\n    >>> import matplotlib.pyplot as plt\n    >>> n = np.zeros((200,200), dtype=complex)\n    >>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))\n    >>> im = np.fft.ifftn(n).real\n    >>> plt.imshow(im)\n    <matplotlib.image.AxesImage object at 0x...>\n    >>> plt.show()\n\n    """"""\n    unitary = _unitary(norm)\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.ifftn(x, s, axes)\n    if unitary:\n        output *= sqrt(_tot_size(output, axes))\n    return output\n\n\ndef fft2(a, s=None, axes=(-2, -1), norm=None):\n    """"""\n    Compute the 2-dimensional discrete Fourier Transform\n\n    This function computes the *n*-dimensional discrete Fourier Transform\n    over any axes in an *M*-dimensional array by means of the\n    Fast Fourier Transform (FFT).  By default, the transform is computed over\n    the last two axes of the input array, i.e., a 2-dimensional FFT.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex\n    s : sequence of ints, optional\n        Shape (length of each transformed axis) of the output\n        (`s[0]` refers to axis 0, `s[1]` to axis 1, etc.).\n        This corresponds to `n` for `fft(x, n)`.\n        Along each axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.\n    axes : sequence of ints, optional\n        Axes over which to compute the FFT.  If not given, the last two\n        axes are used.  A repeated index in `axes` means the transform over\n        that axis is performed multiple times.  A one-element sequence means\n        that a one-dimensional FFT is performed.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or the last two axes if `axes` is not given.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length, or `axes` not given and\n        ``len(s) != 2``.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    numpy.fft : Overall view of discrete Fourier transforms, with definitions\n         and conventions used.\n    ifft2 : The inverse two-dimensional FFT.\n    fft : The one-dimensional FFT.\n    fftn : The *n*-dimensional FFT.\n    fftshift : Shifts zero-frequency terms to the center of the array.\n        For two-dimensional input, swaps first and third quadrants, and second\n        and fourth quadrants.\n\n    Notes\n    -----\n    `fft2` is just `fftn` with a different default for `axes`.\n\n    The output, analogously to `fft`, contains the term for zero frequency in\n    the low-order corner of the transformed axes, the positive frequency terms\n    in the first half of these axes, the term for the Nyquist frequency in the\n    middle of the axes and the negative frequency terms in the second half of\n    the axes, in order of decreasingly negative frequency.\n\n    See `fftn` for details and a plotting example, and `numpy.fft` for\n    definitions and conventions used.\n\n\n    Examples\n    --------\n    >>> a = np.mgrid[:5, :5][0]\n    >>> np.fft.fft2(a)\n    array([[ 50.0 +0.j        ,   0.0 +0.j        ,   0.0 +0.j        ,\n              0.0 +0.j        ,   0.0 +0.j        ],\n           [-12.5+17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n              0.0 +0.j        ,   0.0 +0.j        ],\n           [-12.5 +4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n              0.0 +0.j        ,   0.0 +0.j        ],\n           [-12.5 -4.0614962j ,   0.0 +0.j        ,   0.0 +0.j        ,\n                0.0 +0.j        ,   0.0 +0.j        ],\n           [-12.5-17.20477401j,   0.0 +0.j        ,   0.0 +0.j        ,\n              0.0 +0.j        ,   0.0 +0.j        ]])\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    return fftn(x, s=s, axes=axes, norm=norm)\n\n\ndef ifft2(a, s=None, axes=(-2, -1), norm=None):\n    """"""\n    Compute the 2-dimensional inverse discrete Fourier Transform.\n\n    This function computes the inverse of the 2-dimensional discrete Fourier\n    Transform over any number of axes in an M-dimensional array by means of\n    the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``\n    to within numerical accuracy.  By default, the inverse transform is\n    computed over the last two axes of the input array.\n\n    The input, analogously to `ifft`, should be ordered in the same way as is\n    returned by `fft2`, i.e. it should have the term for zero frequency\n    in the low-order corner of the two axes, the positive frequency terms in\n    the first half of these axes, the term for the Nyquist frequency in the\n    middle of the axes and the negative frequency terms in the second half of\n    both axes, in order of decreasingly negative frequency.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, can be complex.\n    s : sequence of ints, optional\n        Shape (length of each axis) of the output (``s[0]`` refers to axis 0,\n        ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.\n        Along each axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.  See notes for issue on `ifft` zero padding.\n    axes : sequence of ints, optional\n        Axes over which to compute the FFT.  If not given, the last two\n        axes are used.  A repeated index in `axes` means the transform over\n        that axis is performed multiple times.  A one-element sequence means\n        that a one-dimensional FFT is performed.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or the last two axes if `axes` is not given.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length, or `axes` not given and\n        ``len(s) != 2``.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    numpy.fft : Overall view of discrete Fourier transforms, with definitions\n         and conventions used.\n    fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.\n    ifftn : The inverse of the *n*-dimensional FFT.\n    fft : The one-dimensional FFT.\n    ifft : The one-dimensional inverse FFT.\n\n    Notes\n    -----\n    `ifft2` is just `ifftn` with a different default for `axes`.\n\n    See `ifftn` for details and a plotting example, and `numpy.fft` for\n    definition and conventions used.\n\n    Zero-padding, analogously with `ifft`, is performed by appending zeros to\n    the input along the specified dimension.  Although this is the common\n    approach, it might lead to surprising results.  If another form of zero\n    padding is desired, it must be performed before `ifft2` is called.\n\n    Examples\n    --------\n    >>> a = 4 * np.eye(4)\n    >>> np.fft.ifft2(a)\n    array([[ 1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n           [ 0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n           [ 0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n           [ 0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    return ifftn(x, s=s, axes=axes, norm=norm)\n\n\ndef rfftn(a, s=None, axes=None, norm=None):\n    """"""\n    Compute the N-dimensional discrete Fourier Transform for real input.\n\n    This function computes the N-dimensional discrete Fourier Transform over\n    any number of axes in an M-dimensional real array by means of the Fast\n    Fourier Transform (FFT).  By default, all axes are transformed, with the\n    real transform performed over the last axis, while the remaining\n    transforms are complex.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array, taken to be real.\n    s : sequence of ints, optional\n        Shape (length along each transformed axis) to use from the input.\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).\n        The final element of `s` corresponds to `n` for ``rfft(x, n)``, while\n        for the remaining axes, it corresponds to `n` for ``fft(x, n)``.\n        Along any axis, if the given shape is smaller than that of the input,\n        the input is cropped.  If it is larger, the input is padded with zeros.\n        if `s` is not given, the shape of the input along the axes specified\n        by `axes` is used.\n    axes : sequence of ints, optional\n        Axes over which to compute the FFT.  If not given, the last ``len(s)``\n        axes are used, or all axes if `s` is also not specified.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : complex ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or by a combination of `s` and `a`,\n        as explained in the parameters section above.\n        The length of the last axis transformed will be ``s[-1]//2+1``,\n        while the remaining transformed axes will have lengths according to\n        `s`, or unchanged from the input.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT\n         of real input.\n    fft : The one-dimensional FFT, with definitions and conventions used.\n    rfft : The one-dimensional FFT of real input.\n    fftn : The n-dimensional FFT.\n    rfft2 : The two-dimensional FFT of real input.\n\n    Notes\n    -----\n    The transform for real input is performed over the last transformation\n    axis, as by `rfft`, then the transform over the remaining axes is\n    performed as by `fftn`.  The order of the output is as for `rfft` for the\n    final transformation axis, and as for `fftn` for the remaining\n    transformation axes.\n\n    See `fft` for details, definitions and conventions used.\n\n    Examples\n    --------\n    >>> a = np.ones((2, 2, 2))\n    >>> np.fft.rfftn(a)\n    array([[[ 8.+0.j,  0.+0.j],\n            [ 0.+0.j,  0.+0.j]],\n           [[ 0.+0.j,  0.+0.j],\n            [ 0.+0.j,  0.+0.j]]])\n\n    >>> np.fft.rfftn(a, axes=(2, 0))\n    array([[[ 4.+0.j,  0.+0.j],\n            [ 4.+0.j,  0.+0.j]],\n           [[ 0.+0.j,  0.+0.j],\n            [ 0.+0.j,  0.+0.j]]])\n\n    """"""\n    unitary = _unitary(norm)\n    x = _float_utils.__downcast_float128_array(a)\n    if unitary:\n        x = asarray(x)\n        s, axes = _cook_nd_args(x, s, axes)\n\n    output = mkl_fft.rfftn_numpy(x, s, axes)\n    if unitary:\n        n_tot = prod(asarray(s, dtype=output.dtype))\n        output *= 1 / sqrt(n_tot)\n    return output\n\n\ndef rfft2(a, s=None, axes=(-2, -1), norm=None):\n    """"""\n    Compute the 2-dimensional FFT of a real array.\n\n    Parameters\n    ----------\n    a : array\n        Input array, taken to be real.\n    s : sequence of ints, optional\n        Shape of the FFT.\n    axes : sequence of ints, optional\n        Axes over which to compute the FFT.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : ndarray\n        The result of the real 2-D FFT.\n\n    See Also\n    --------\n    rfftn : Compute the N-dimensional discrete Fourier Transform for real\n            input.\n\n    Notes\n    -----\n    This is really just `rfftn` with different default behavior.\n    For more details see `rfftn`.\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    return rfftn(x, s, axes, norm)\n\n\ndef irfftn(a, s=None, axes=None, norm=None):\n    """"""\n    Compute the inverse of the N-dimensional FFT of real input.\n\n    This function computes the inverse of the N-dimensional discrete\n    Fourier Transform for real input over any number of axes in an\n    M-dimensional array by means of the Fast Fourier Transform (FFT).  In\n    other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical\n    accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,\n    and for the same reason.)\n\n    The input should be ordered in the same way as is returned by `rfftn`,\n    i.e. as for `irfft` for the final transformation axis, and as for `ifftn`\n    along all the other axes.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    s : sequence of ints, optional\n        Shape (length of each transformed axis) of the output\n        (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the\n        number of input points used along this axis, except for the last axis,\n        where ``s[-1]//2+1`` points of the input are used.\n        Along any axis, if the shape indicated by `s` is smaller than that of\n        the input, the input is cropped.  If it is larger, the input is padded\n        with zeros. If `s` is not given, the shape of the input along the\n        axes specified by `axes` is used.\n    axes : sequence of ints, optional\n        Axes over which to compute the inverse FFT. If not given, the last\n        `len(s)` axes are used, or all axes if `s` is also not specified.\n        Repeated indices in `axes` means that the inverse transform over that\n        axis is performed multiple times.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : ndarray\n        The truncated or zero-padded input, transformed along the axes\n        indicated by `axes`, or by a combination of `s` or `a`,\n        as explained in the parameters section above.\n        The length of each transformed axis is as given by the corresponding\n        element of `s`, or the length of the input in every axis except for the\n        last one if `s` is not given.  In the final transformed axis the length\n        of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the\n        length of the final transformed axis of the input.  To get an odd\n        number of output points in the final axis, `s` must be specified.\n\n    Raises\n    ------\n    ValueError\n        If `s` and `axes` have different length.\n    IndexError\n        If an element of `axes` is larger than than the number of axes of `a`.\n\n    See Also\n    --------\n    rfftn : The forward n-dimensional FFT of real input,\n            of which `ifftn` is the inverse.\n    fft : The one-dimensional FFT, with definitions and conventions used.\n    irfft : The inverse of the one-dimensional FFT of real input.\n    irfft2 : The inverse of the two-dimensional FFT of real input.\n\n    Notes\n    -----\n    See `fft` for definitions and conventions used.\n\n    See `rfft` for definitions and conventions used for real input.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 2, 2))\n    >>> a[0, 0, 0] = 3 * 2 * 2\n    >>> np.fft.irfftn(a)\n    array([[[ 1.,  1.],\n            [ 1.,  1.]],\n           [[ 1.,  1.],\n            [ 1.,  1.]],\n           [[ 1.,  1.],\n            [ 1.,  1.]]])\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    output = mkl_fft.irfftn_numpy(x, s, axes)\n    if _unitary(norm):\n        output *= sqrt(_tot_size(output, axes))\n    return output\n\n\ndef irfft2(a, s=None, axes=(-2, -1), norm=None):\n    """"""\n    Compute the 2-dimensional inverse FFT of a real array.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array\n    s : sequence of ints, optional\n        Shape of the inverse FFT.\n    axes : sequence of ints, optional\n        The axes over which to compute the inverse fft.\n        Default is the last two axes.\n    norm : {None, ""ortho""}, optional\n        .. versionadded:: 1.10.0\n        Normalization mode (see `numpy.fft`). Default is None.\n\n    Returns\n    -------\n    out : ndarray\n        The result of the inverse real 2-D FFT.\n\n    See Also\n    --------\n    irfftn : Compute the inverse of the N-dimensional FFT of real input.\n\n    Notes\n    -----\n    This is really `irfftn` with different defaults.\n    For more details see `irfftn`.\n\n    """"""\n    x = _float_utils.__downcast_float128_array(a)\n    return irfftn(x, s, axes, norm)\n\n'"
mkl_fft/_scipy_fft.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom . import _pydfti\nfrom . import _float_utils\n\n__all__ = [\'fft\', \'ifft\', \'fftn\', \'ifftn\', \'fft2\', \'ifft2\', \'rfft\', \'irfft\']\n\n\ndef fft(a, n=None, axis=-1, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.fft(x, n=n, axis=axis, overwrite_x=overwrite_x)\n\n\ndef ifft(a, n=None, axis=-1, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.ifft(x, n=n, axis=axis, overwrite_x=overwrite_x)\n\n\ndef fftn(a, shape=None, axes=None, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.fftn(x, shape=shape, axes=axes, overwrite_x=overwrite_x)\n\n\ndef ifftn(a, shape=None, axes=None, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.ifftn(x, shape=shape, axes=axes, overwrite_x=overwrite_x)\n\n\ndef fft2(a, shape=None, axes=(-2,-1), overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.fftn(x, shape=shape, axes=axes, overwrite_x=overwrite_x)\n\n\ndef ifft2(a, shape=None, axes=(-2,-1), overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.ifftn(x, shape=shape, axes=axes, overwrite_x=overwrite_x)\n\n\ndef rfft(a, n=None, axis=-1, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.rfft(a, n=n, axis=axis, overwrite_x=overwrite_x)\n\n\ndef irfft(a, n=None, axis=-1, overwrite_x=False):\n    x = _float_utils.__upcast_float16_array(a)\n    return _pydfti.irfft(a, n=n, axis=axis, overwrite_x=overwrite_x)\n'"
mkl_fft/_scipy_fft_backend.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2019-2020, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom . import _pydfti\nfrom . import _float_utils\nimport mkl\n\nimport scipy.fft as _fft\n\n# Complete the namespace (these are not actually used in this module)\nfrom scipy.fft import (\n    dct, idct, dst, idst, dctn, idctn, dstn, idstn,\n    hfft2, ihfft2, hfftn, ihfftn,\n    fftshift, ifftshift, fftfreq, rfftfreq,\n    get_workers, set_workers\n)\n\nfrom numpy.core import (array, asarray, shape, conjugate, take, sqrt, prod)\nfrom os import cpu_count as os_cpu_count\nimport warnings\n\nclass _cpu_max_threads_count:\n    def __init__(self):\n        self.cpu_count = None\n        self.max_threads_count = None\n\n    def get_cpu_count(self):\n        max_threads = self.get_max_threads_count()\n        if self.cpu_count is None:\n            self.cpu_count = os_cpu_count()\n            if self.cpu_count > max_threads:\n                warnings.warn(\n                    (""os.cpu_count() returned value of {} greater than mkl.get_max_threads()\'s value of {}. ""\n                               ""Using negative values of worker option may amount to requesting more threads than ""\n                               ""Intel(R) MKL can acommodate.""\n                    ).format(self.cpu_count, max_threads))\n        return self.cpu_count\n\n    def get_max_threads_count(self):\n        if self.max_threads_count is None:\n            self.max_threads_count = mkl.get_max_threads()\n\n        return self.max_threads_count\n\n\n_hardware_counts = _cpu_max_threads_count()\n    \n\n__all__ = [\'fft\', \'ifft\', \'fft2\', \'ifft2\', \'fftn\', \'ifftn\',\n           \'rfft\', \'irfft\', \'rfft2\', \'irfft2\', \'rfftn\', \'irfftn\',\n           \'hfft\', \'ihfft\', \'hfft2\', \'ihfft2\', \'hfftn\', \'ihfftn\',\n           \'dct\', \'idct\', \'dst\', \'idst\', \'dctn\', \'idctn\', \'dstn\', \'idstn\',\n           \'fftshift\', \'ifftshift\', \'fftfreq\', \'rfftfreq\', \'get_workers\',\n           \'set_workers\', \'next_fast_len\']\n\n__ua_domain__ = \'numpy.scipy.fft\'\n__implemented = dict()\n\ndef __ua_function__(method, args, kwargs):\n    """"""Fetch registered UA function.""""""\n    fn = __implemented.get(method, None)\n    if fn is None:\n        return NotImplemented\n    return fn(*args, **kwargs)\n\n\ndef _implements(scipy_func):\n    """"""Decorator adds function to the dictionary of implemented UA functions""""""\n    def inner(func):\n        __implemented[scipy_func] = func\n        return func\n\n    return inner\n\n\ndef _unitary(norm):\n    if norm not in (None, ""ortho""):\n        raise ValueError(""Invalid norm value %s, should be None or \\""ortho\\"".""\n                         % norm)\n    return norm is not None\n\n\ndef _cook_nd_args(a, s=None, axes=None, invreal=0):\n    if s is None:\n        shapeless = 1\n        if axes is None:\n            s = list(a.shape)\n        else:\n            s = take(a.shape, axes)\n    else:\n        shapeless = 0\n    s = list(s)\n    if axes is None:\n        axes = list(range(-len(s), 0))\n    if len(s) != len(axes):\n        raise ValueError(""Shape and axes have different lengths."")\n    if invreal and shapeless:\n        s[-1] = (a.shape[axes[-1]] - 1) * 2\n    return s, axes\n\n\ndef _tot_size(x, axes):\n    s = x.shape\n    if axes is None:\n        return x.size\n    return prod([s[ai] for ai in axes])\n\n\ndef _workers_to_num_threads(w):\n    """"""Handle conversion of workers to a positive number of threads in the\n    same way as scipy.fft.helpers._workers.\n    """"""\n    if w is None:\n        return get_workers()\n    _w = int(w)\n    if (_w == 0):\n        raise ValueError(""Number of workers must be nonzero"")\n    if (_w < 0):\n        _w += _hardware_counts.get_cpu_count() + 1\n        if _w <= 0:\n            raise ValueError(""workers value out of range; got {}, must not be""\n                             "" less than {}"".format(w, -_hardware_counts.get_cpu_count()))\n    return _w\n\n\nclass Workers:\n    def __init__(self, workers):\n        self.workers = workers\n        self.n_threads = _workers_to_num_threads(workers)\n\n    def __enter__(self):\n        try:\n            mkl.domain_set_num_threads(self.n_threads, domain=\'fft\')\n        except:\n            raise ValueError(""Class argument {} result in invalid number of threads {}"".format(self.workers, self.n_threads))\n\n    def __exit__(self, *args):\n        # restore default\n        n_threads = _hardware_counts.get_max_threads_count()\n        mkl.domain_set_num_threads(n_threads, domain=\'fft\')\n\n\n@_implements(_fft.fft)\ndef fft(a, n=None, axis=-1, norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.fft(x, n=n, axis=axis, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        output *= 1 / sqrt(output.shape[axis])\n    return output\n\n\n@_implements(_fft.ifft)\ndef ifft(a, n=None, axis=-1, norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.ifft(x, n=n, axis=axis, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        output *= sqrt(output.shape[axis])\n    return output\n\n\n@_implements(_fft.fft2)\ndef fft2(a, s=None, axes=(-2,-1), norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.fftn(x, shape=s, axes=axes, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        factor = 1\n        for axis in axes:\n            factor *= 1 / sqrt(output.shape[axis])\n        output *= factor\n    return output\n\n\n@_implements(_fft.ifft2)\ndef ifft2(a, s=None, axes=(-2,-1), norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.ifftn(x, shape=s, axes=axes, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        factor = 1\n        _axes = range(output.ndim) if axes is None else axes\n        for axis in _axes:\n            factor *= sqrt(output.shape[axis])\n        output *= factor\n    return output\n\n\n@_implements(_fft.fftn)\ndef fftn(a, s=None, axes=None, norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.fftn(x, shape=s, axes=axes, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        factor = 1\n        _axes = range(output.ndim) if axes is None else axes\n        for axis in _axes:\n            factor *= 1 / sqrt(output.shape[axis])\n        output *= factor\n    return output\n\n\n@_implements(_fft.ifftn)\ndef ifftn(a, s=None, axes=None, norm=None, overwrite_x=False, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    with Workers(workers):\n        output = _pydfti.ifftn(x, shape=s, axes=axes, overwrite_x=overwrite_x)\n    if _unitary(norm):\n        factor = 1\n        _axes = range(output.ndim) if axes is None else axes\n        for axis in _axes:\n            factor *= sqrt(output.shape[axis])\n        output *= factor\n    return output\n\n\n@_implements(_fft.rfft)\ndef rfft(a, n=None, axis=-1, norm=None, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    unitary = _unitary(norm)\n    x = _float_utils.__downcast_float128_array(x)\n    if unitary and n is None:\n        x = asarray(x)\n        n = x.shape[axis]\n    with Workers(workers):\n        output = _pydfti.rfft_numpy(x, n=n, axis=axis)\n    if unitary:\n        output *= 1 / sqrt(n)\n    return output\n\n\n@_implements(_fft.irfft)\ndef irfft(a, n=None, axis=-1, norm=None, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    x = _float_utils.__downcast_float128_array(x)\n    with Workers(workers):\n        output = _pydfti.irfft_numpy(x, n=n, axis=axis)\n    if _unitary(norm):\n        output *= sqrt(output.shape[axis])\n    return output\n\n\n@_implements(_fft.rfft2)\ndef rfft2(a, s=None, axes=(-2, -1), norm=None, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    x = _float_utils.__downcast_float128_array(a)\n    return rfftn(x, s, axes, norm, workers)\n\n\n@_implements(_fft.irfft2)\ndef irfft2(a, s=None, axes=(-2, -1), norm=None, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    x = _float_utils.__downcast_float128_array(x)\n    return irfftn(x, s, axes, norm, workers)\n\n\n@_implements(_fft.rfftn)\ndef rfftn(a, s=None, axes=None, norm=None, workers=None):\n    unitary = _unitary(norm)\n    x = _float_utils.__upcast_float16_array(a)\n    x = _float_utils.__downcast_float128_array(x)\n    if unitary:\n        x = asarray(x)\n        s, axes = _cook_nd_args(x, s, axes)\n    with Workers(workers):\n        output = _pydfti.rfftn_numpy(x, s, axes)\n    if unitary:\n        n_tot = prod(asarray(s, dtype=output.dtype))\n        output *= 1 / sqrt(n_tot)\n    return output\n\n\n@_implements(_fft.irfftn)\ndef irfftn(a, s=None, axes=None, norm=None, workers=None):\n    x = _float_utils.__upcast_float16_array(a)\n    x = _float_utils.__downcast_float128_array(x)\n    with Workers(workers):\n        output = _pydfti.irfftn_numpy(x, s, axes)\n    if _unitary(norm):\n        output *= sqrt(_tot_size(output, axes))\n    return output\n'"
mkl_fft/_version.py,0,"b""__version__ = '1.1.0'\n"""
mkl_fft/setup.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nfrom __future__ import division, print_function, absolute_import\nimport sys\nfrom os.path import join, exists, abspath, dirname\nfrom os import getcwd\nfrom os import environ\n\ndef configuration(parent_package=\'\',top_path=None):\n    from numpy.distutils.misc_util import Configuration\n    from numpy.distutils.system_info import get_info\n    config = Configuration(\'mkl_fft\', parent_package, top_path)\n\n    mkl_root = environ.get(\'MKLROOT\', None)\n    if mkl_root:\n        mkl_info = {\n            \'include_dirs\': [join(mkl_root, \'include\')],\n            \'library_dirs\': [join(mkl_root, \'lib\'), join(mkl_root, \'lib\', \'intel64\')],\n            \'libraries\': [\'mkl_rt\']\n        }\n    else:\n        mkl_info = get_info(\'mkl\')\n\n    mkl_include_dirs = mkl_info.get(\'include_dirs\', [])\n    mkl_library_dirs = mkl_info.get(\'library_dirs\', [])\n    mkl_libraries = mkl_info.get(\'libraries\', [\'mkl_rt\'])\n\n    pdir = dirname(__file__)\n    wdir = join(pdir, \'src\')\n    mkl_info = get_info(\'mkl\')\n\n    try:\n        from Cython.Build import cythonize\n        sources = [join(pdir, \'_pydfti.pyx\')]\n        have_cython = True\n    except ImportError as e:\n        have_cython = False\n        sources = [join(pdir, \'_pydfti.c\')]\n        if not exists(sources[0]):\n            raise ValueError(str(e) + \'. \' + \n                             \'Cython is required to build the initial .c file.\')\n\n    config.add_extension(\n        name = \'_pydfti\',\n        sources = [\n            join(wdir, \'mklfft.c.src\'),\n        ] + sources,\n        depends = [\n            join(wdir, \'mklfft.h\'),\n            join(wdir, \'multi_iter.h\')\n        ],\n        include_dirs = [wdir] + mkl_include_dirs,\n        libraries = mkl_libraries,\n        library_dirs = mkl_library_dirs,\n        extra_compile_args = [\n            \'-DNDEBUG\',\n            # \'-ggdb\', \'-O0\', \'-Wall\', \'-Wextra\', \'-DDEBUG\',\n        ]\n    )\n\n    config.add_data_dir(\'tests\')\n\n    if have_cython:\n        config.ext_modules = cythonize(config.ext_modules, include_path=[pdir, wdir])\n\n    return config\n\nif __name__ == \'__main__\':\n    from numpy.distutils.core import setup\n    setup(configuration=configuration)\n'"
mkl_fft/tests/test_fft1d.py,49,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import division, absolute_import, print_function\n\nimport numpy as np\nfrom numpy.testing import (\n        TestCase, run_module_suite, assert_, assert_raises, assert_equal,\n        assert_warns, assert_allclose)\nfrom numpy import random as rnd\nimport sys\nimport warnings\n\nimport mkl_fft\n\ndef naive_fft1d(vec):\n    L = len(vec)\n    phase = -2j*np.pi*(np.arange(L)/float(L))\n    phase = np.arange(L).reshape(-1, 1) * phase\n    return np.sum(vec*np.exp(phase), axis=1)\n\n\ndef _datacopied(arr, original):\n    """"""\n    Strict check for `arr` not sharing any data with `original`,\n    under the assumption that arr = asarray(original)\n    """"""\n    if arr is original:\n        return False\n    if not isinstance(original, np.ndarray) and hasattr(original, \'__array__\'):\n        return False\n    return arr.base is None\n\n\nclass Test_mklfft_vector(TestCase):\n    def setUp(self):\n        rnd.seed(1234567)\n        self.xd1 = rnd.standard_normal(128)\n        self.xf1 = self.xd1.astype(np.float32)\n        self.xz1 = rnd.standard_normal((128,2)).view(dtype=np.complex128).squeeze()\n        self.xc1 = self.xz1.astype(np.complex64)\n\n    def test_vector1(self):\n        """"""check that mkl_fft gives the same result of numpy.fft""""""\n        f1 = mkl_fft.fft(self.xz1)\n        f2 = naive_fft1d(self.xz1)\n        assert_allclose(f1,f2, rtol=1e-7, atol=2e-12)\n\n        f1 = mkl_fft.fft(self.xc1)\n        f2 = naive_fft1d(self.xc1)\n        assert_allclose(f1,f2, rtol=2e-6, atol=2e-6)\n\n    def test_vector2(self):\n        ""ifft(fft(x)) is identity""\n        f1 = mkl_fft.fft(self.xz1)\n        f2 = mkl_fft.ifft(f1)\n        assert_(np.allclose(self.xz1,f2))\n\n        f1 = mkl_fft.fft(self.xc1)\n        f2 = mkl_fft.ifft(f1)\n        assert_( np.allclose(self.xc1,f2))\n\n        f1 = mkl_fft.fft(self.xd1)\n        f2 = mkl_fft.ifft(f1)\n        assert_( np.allclose(self.xd1,f2))\n\n        f1 = mkl_fft.fft(self.xf1)\n        f2 = mkl_fft.ifft(f1)\n        assert_( np.allclose(self.xf1,f2, atol = 2.0e-7))\n\n    def test_vector3(self):\n        ""fft(ifft(x)) is identity""\n        f1 = mkl_fft.ifft(self.xz1)\n        f2 = mkl_fft.fft(f1)\n        assert_(np.allclose(self.xz1,f2))\n\n        f1 = mkl_fft.ifft(self.xc1)\n        f2 = mkl_fft.fft(f1)\n        assert_( np.allclose(self.xc1,f2))\n\n        f1 = mkl_fft.ifft(self.xd1)\n        f2 = mkl_fft.fft(f1)\n        assert_( np.allclose(self.xd1,f2))\n\n        f1 = mkl_fft.ifft(self.xf1)\n        f2 = mkl_fft.fft(f1)\n        assert_( np.allclose(self.xf1, f2, atol = 2.0e-7))\n\n    def test_vector4(self):\n        ""fft of strided is same as fft of contiguous copy""\n        x = self.xz1[::2]\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.fft(x.copy())\n        assert_(np.allclose(f1,f2))\n\n        x = self.xz1[::-1]\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.fft(x.copy())\n        assert_(np.allclose(f1,f2))\n\n    def test_vector5(self):\n        ""fft in-place is the same as fft out-of-place""\n        x = self.xz1.copy()[::-2]\n        f1 = mkl_fft.fft(x, overwrite_x=True)\n        f2 = mkl_fft.fft(self.xz1[::-2])\n        assert_(np.allclose(f1,f2))\n    \n    def test_vector6(self):\n        ""fft in place""\n        x = self.xz1.copy()\n        f1 = mkl_fft.fft(x, overwrite_x=True)\n        assert_(not _datacopied(f1, x))  # this is in-place\n\n        x = self.xz1.copy()\n        f1 = mkl_fft.fft(x[::-2], overwrite_x=True)\n        assert_( not np.allclose(x, self.xz1) ) # this is also in-place\n        assert_( np.allclose(x[-2::-2], self.xz1[-2::-2]) ) \n        assert_( np.allclose(x[-1::-2], f1) ) \n\n    def test_vector7(self):\n        ""fft of real array is the same as fft of its complex cast""\n        x = self.xd1[3:17:2]\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.fft(x.astype(np.complex128))\n        assert_(np.allclose(f1,f2))\n\n    def test_vector8(self):\n        ""ifft of real array is the same as fft of its complex cast""\n        x = self.xd1[3:17:2]\n        f1 = mkl_fft.ifft(x)\n        f2 = mkl_fft.ifft(x.astype(np.complex128))\n        assert_(np.allclose(f1,f2))\n\n    def test_vector9(self):\n        ""works on subtypes of ndarray""\n        mask = np.zeros(self.xd1.shape, dtype=\'int\')\n        mask[1] = 1\n        mask[-2] = 1\n        x = np.ma.masked_array(self.xd1, mask=mask)\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.fft(self.xd1)\n        assert_allclose(f1, f2)\n\n    def test_vector10(self):\n        ""check n for real arrays""\n        x = self.xd1[:8].copy()\n        f1 = mkl_fft.fft(x, n = 7)\n        f2 = mkl_fft.fft(self.xd1[:7])\n        assert_allclose(f1, f2)\n\n        f1 = mkl_fft.fft(x, n = 9)\n        y = self.xd1[:9].copy()\n        y[-1] = 0.0\n        f2 = mkl_fft.fft(y)\n        assert_allclose(f1, f2)\n\n    def test_vector11(self):\n        ""check n for complex arrays""\n        x = self.xz1[:8].copy()\n        f1 = mkl_fft.fft(x, n = 7)\n        f2 = mkl_fft.fft(self.xz1[:7])\n        assert_allclose(f1, f2)\n\n        f1 = mkl_fft.fft(x, n = 9)\n        y = self.xz1[:9].copy()\n        y[-1] = 0.0 + 0.0j\n        f2 = mkl_fft.fft(y)\n        assert_allclose(f1, f2)\n\n    def test_vector12(self):\n        ""check fft of float-valued array""\n        x = np.arange(20)\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.fft(x.astype(np.float64))\n        assert_allclose(f1, f2)\n\n\nclass Test_mklfft_matrix(TestCase):\n    def setUp(self):\n        rnd.seed(1234567)\n        self.ad2 = rnd.standard_normal((4, 3))\n        self.af2 = self.ad2.astype(np.float32)\n        self.az2 = np.dot(\n              rnd.standard_normal((17, 15, 2)),\n              np.array([1.0 + 0.0j, 0.0 + 1.0j], dtype=np.complex128)\n        )\n        self.ac2 = self.az2.astype(np.complex64)\n        self.mat = np.matrix(self.az2)\n        self.xd1 = rnd.standard_normal(128)\n\n    def test_matrix1(self):\n        x = self.az2.copy()\n        f1 = mkl_fft.fft(x)\n        f2 = np.array([ mkl_fft.fft(x[i]) for i in range(x.shape[0])])\n        assert_allclose(f1, f2)\n\n        f1 = mkl_fft.fft(x, axis=0)\n        f2 = np.array([ mkl_fft.fft(x[:, i]) for i in range(x.shape[1])]).T\n        assert_allclose(f1, f2)\n\n    def test_matrix2(self):\n        f1 = mkl_fft.fft(self.az2)\n        f2 = mkl_fft.fft(self.mat)\n        assert_allclose(f1, f2)\n\n    def test_matrix3(self):\n        x = self.az2.copy()\n        f1 = mkl_fft.fft(x[::3,::-1])\n        f2 = mkl_fft.fft(x[::3,::-1].copy())\n        assert_allclose(f1, f2)\n\n    def test_matrix4(self):\n        x = self.az2.copy()\n        f1 = mkl_fft.fft(x[::3,::-1])\n        f2 = mkl_fft.fft(x[::3,::-1], overwrite_x=True)\n        assert_allclose(f1, f2)\n\n    def test_matrix5(self):\n        x = self.ad2;\n        f1 = mkl_fft.fft(x)\n        f2 = mkl_fft.ifft(f1)\n        assert_allclose(x, f2, atol=1e-10)\n\n    def test_matrix6(self):\n        x = self.ad2;\n        f1 = mkl_fft.ifft(x)\n        f2 = mkl_fft.fft(f1)\n        assert_allclose(x, f2, atol=1e-10)\n\n    def test_matrix7(self):\n        x = self.ad2.copy()\n        f1 = mkl_fft.fft(x)\n        f2 = np.array([ mkl_fft.fft(x[i]) for i in range(x.shape[0])])\n        assert_allclose(f1, f2)\n\n        f1 = mkl_fft.fft(x, axis=0)\n        f2 = np.array([ mkl_fft.fft(x[:, i]) for i in range(x.shape[1])]).T\n        assert_allclose(f1, f2)\n\n    def test_matrix8(self):\n        from numpy.lib.stride_tricks import as_strided\n        x = self.xd1[:10].copy()\n        y = as_strided(x, shape=(4,4,), strides=(2*x.itemsize, x.itemsize))\n        f1 = mkl_fft.fft(y)\n        f2 = mkl_fft.fft(y.copy())\n        assert_allclose(f1, f2, atol=1e-15, rtol=1e-7)\n\n\nclass Test_mklfft_rank3(TestCase):\n    def setUp(self):\n        rnd.seed(1234567)\n        self.ad3 = rnd.standard_normal((7, 11, 19))\n        self.af3 = self.ad3.astype(np.float32)\n        self.az3 = np.dot(\n              rnd.standard_normal((17, 13, 15, 2)),\n              np.array([1.0 + 0.0j, 0.0 + 1.0j], dtype=np.complex128)\n        )\n        self.ac3 = self.az3.astype(np.complex64)\n\n    def test_array1(self):\n        x = self.az3\n        for ax in range(x.ndim):\n            f1 = mkl_fft.fft(x, axis = ax)\n            f2 = mkl_fft.ifft(f1, axis = ax)\n            assert_allclose(f2, x, atol=2e-15)\n\n    def test_array2(self):\n        x = self.ad3\n        for ax in range(x.ndim):\n            f1 = mkl_fft.fft(x, axis = ax)\n            f2 = mkl_fft.ifft(f1, axis = ax)\n            assert_allclose(f2, x, atol=2e-15)\n\n    def test_array3(self):\n        x = self.az3\n        for ax in range(x.ndim):\n            f1 = mkl_fft.ifft(x, axis = ax)\n            f2 = mkl_fft.fft(f1, axis = ax)\n            assert_allclose(f2, x, atol=2e-15)\n\n    def test_array4(self):\n        x = self.ad3\n        for ax in range(x.ndim):\n            f1 = mkl_fft.ifft(x, axis = ax)\n            f2 = mkl_fft.fft(f1, axis = ax)\n            assert_allclose(f2, x, atol=2e-15)\n\n\n    def test_array5(self):\n        """"""Inputs with zero strides are handled correctly""""""\n        z = self.az3\n        z1 = z[np.newaxis]\n        f1 = mkl_fft.fft(z1, axis=-1)\n        f2 = mkl_fft.fft(z1.reshape(z1.shape), axis=-1)\n        assert_allclose(f1, f2, atol=2e-15)\n        z1 = z[:, np.newaxis]\n        f1 = mkl_fft.fft(z1, axis=-1)\n        f2 = mkl_fft.fft(z1.reshape(z1.shape), axis=-1)\n        assert_allclose(f1, f2, atol=2e-15)\n        z1 = z[:, :, np.newaxis]\n        f1 = mkl_fft.fft(z1, axis=-1)\n        f2 = mkl_fft.fft(z1.reshape(z1.shape), axis=-1)\n        assert_allclose(f1, f2, atol=2e-15)\n        z1 = z[:, :, :, np.newaxis]\n        f1 = mkl_fft.fft(z1, axis=-1)\n        f2 = mkl_fft.fft(z1.reshape(z1.shape), axis=-1)\n        assert_allclose(f1, f2, atol=2e-15)\n\n    def test_array6(self):\n        """"""Inputs with Fortran layout are handled correctly, issue 29""""""\n        z = self.az3\n        z = z.astype(z.dtype, order=\'F\')\n        y1 = mkl_fft.fft(z, axis=0)\n        y2 = mkl_fft.fft(self.az3, axis=0)\n        assert_allclose(y1, y2, atol=2e-15)\n        y1 = mkl_fft.fft(z, axis=-1)\n        y2 = mkl_fft.fft(self.az3, axis=-1)\n        assert_allclose(y1, y2, atol=2e-15)\n\n\nclass Test_mklfft_rfft(TestCase):\n    def setUp(self):\n        rnd.seed(1234567)\n        self.v1 = rnd.randn(16)\n        self.m2 = rnd.randn(5,7)\n        self.t3 = rnd.randn(5,7,11)\n\n    def test1(self):\n        x = self.v1.copy()\n        f1 = mkl_fft.rfft(x)\n        f2 = mkl_fft.irfft(f1)\n        assert_allclose(f2,x)\n\n    def test2(self):\n        x = self.v1.copy()\n        f1 = mkl_fft.irfft(x)\n        f2 = mkl_fft.rfft(f1)\n        assert_allclose(f2,x)\n\n    def test3(self):\n        for a in range(0,2):\n            for ovwr_x in [True, False]:\n                for dt, atol in zip([np.float32, np.float64], [2e-7, 2e-15]):\n                    x = self.m2.copy().astype(dt)\n                    f1 = mkl_fft.rfft(x, axis=a, overwrite_x=ovwr_x)\n                    f2 = mkl_fft.irfft(f1, axis=a, overwrite_x=ovwr_x)\n                    assert_allclose(f2, self.m2.astype(dt), atol=atol)\n\n    def test4(self):\n        for a in range(0,2):\n            for ovwr_x in [True, False]:\n                for dt, atol in zip([np.float32, np.float64], [2e-7, 2e-15]):\n                    x = self.m2.copy().astype(dt)\n                    f1 = mkl_fft.irfft(x, axis=a, overwrite_x=ovwr_x)\n                    f2 = mkl_fft.rfft(f1, axis=a, overwrite_x=ovwr_x)\n                    assert_allclose(f2, self.m2.astype(dt), atol=atol)\n\n    def test5(self):\n        for a in range(0,3):\n            for ovwr_x in [True, False]:\n                for dt, atol in zip([np.float32, np.float64], [4e-7, 4e-15]):\n                    x = self.t3.copy().astype(dt)\n                    f1 = mkl_fft.irfft(x, axis=a, overwrite_x=ovwr_x)\n                    f2 = mkl_fft.rfft(f1, axis=a, overwrite_x=ovwr_x)\n                    assert_allclose(f2, self.t3.astype(dt), atol=atol)\n\nif __name__ == ""__main__"":\n    run_module_suite(argv = sys.argv)\n'"
mkl_fft/tests/test_fftnd.py,20,"b'#!/usr/bin/env python\n# Copyright (c) 2017-2019, Intel Corporation\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#     * Redistributions of source code must retain the above copyright notice,\n#       this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of Intel Corporation nor the names of its contributors\n#       may be used to endorse or promote products derived from this software\n#       without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import division, absolute_import, print_function\n\nimport numpy as np\nfrom numpy.testing import (\n        TestCase, run_module_suite, assert_, assert_raises, assert_equal,\n        assert_warns, assert_allclose)\nfrom numpy import random as rnd\nimport sys\nimport warnings\n\nimport mkl_fft\n\nreps_64 = (2**11)*np.finfo(np.float64).eps\nreps_32 = (2**11)*np.finfo(np.float32).eps\natol_64 = (2**8)*np.finfo(np.float64).eps\natol_32 = (2**8)*np.finfo(np.float32).eps\n\ndef _get_rtol_atol(x):\n    dt = x.dtype\n    if dt == np.double or dt == np.complex128:\n        return reps_64, atol_64\n    elif dt == np.single or dt == np.complex64:\n        return reps_32, atol_32\n    else:\n        assert (dt == np.double or dt == np.complex128 or dt == np.single or dt == np.complex64), ""Unexpected dtype {}"".format(dt)\n        return reps_64, atol_64\n\n\nclass Test_mklfft_matrix(TestCase):\n    def setUp(self):\n        rnd.seed(123456)\n        self.md = rnd.randn(256, 256)\n        self.mf = self.md.astype(np.float32)\n        self.mz = rnd.randn(256, 256*2).view(np.complex128)\n        self.mc = self.mz.astype(np.complex64)\n\n    def test_matrix1(self):\n        """"""fftn equals repeated fft""""""\n        for ar in [self.md, self.mz, self.mf, self.mc]:\n            r_tol, a_tol = _get_rtol_atol(ar)\n            d = ar.copy()\n            t1 = mkl_fft.fftn(d)\n            t2 = mkl_fft.fft(mkl_fft.fft(d, axis=0), axis=1)\n            t3 = mkl_fft.fft(mkl_fft.fft(d, axis=1), axis=0)\n            assert_allclose(t1, t2, rtol=r_tol, atol=a_tol, err_msg = ""failed test for dtype {}, max abs diff: {}"".format(d.dtype, np.max(np.abs(t1-t2))))\n            assert_allclose(t1, t3, rtol=r_tol, atol=a_tol, err_msg = ""failed test for dtype {}, max abs diff: {}"".format(d.dtype, np.max(np.abs(t1-t3))))\n\n    def test_matrix2(self):\n        """"""ifftn(fftn(x)) is x""""""\n        for ar in [self.md, self.mz, self.mf, self.mc]:\n            d = ar.copy()\n            r_tol, a_tol = _get_rtol_atol(d)\n            t = mkl_fft.ifftn(mkl_fft.fftn(d))\n            assert_allclose(d, t, rtol=r_tol, atol=a_tol, err_msg = ""failed test for dtype {}, max abs diff: {}"".format(d.dtype, np.max(np.abs(d-t))))\n\n    def test_matrix3(self):\n        """"""fftn(ifftn(x)) is x""""""\n        for ar in [self.md, self.mz, self.mf, self.mc]:\n            d = ar.copy()\n            r_tol, a_tol = _get_rtol_atol(d)\n            t = mkl_fft.fftn(mkl_fft.ifftn(d))\n            assert_allclose(d, t, rtol=r_tol, atol=a_tol, err_msg = ""failed test for dtype {}, max abs diff: {}"".format(d.dtype, np.max(np.abs(d-t))))\n\n\n    def test_matrix4(self):\n        """"""fftn of strided array is same as fftn of a contiguous copy""""""\n        for ar in [self.md, self.mz, self.mf, self.mc]:\n            r_tol, a_tol = _get_rtol_atol(ar)\n            d_strided = ar[::2,::2]\n            d_contig = d_strided.copy()\n            t_strided = mkl_fft.fftn(d_strided)\n            t_contig = mkl_fft.fftn(d_contig)\n            assert_allclose(t_strided, t_contig, rtol=r_tol, atol=a_tol)\n\n\nclass Test_Regressions(TestCase):\n\n    def setUp(self):\n        rnd.seed(123456)\n        self.ad = rnd.randn(32, 17, 23)\n        self.af = self.ad.astype(np.float32)\n        self.az = rnd.randn(32, 17, 23*2).view(np.complex128)\n        self.ac = self.az.astype(np.complex64)\n\n    def test_cf_contig(self):\n        """"""fft of F-contiguous array is the same as of C-contiguous with same data""""""\n        for ar in [self.ad, self.af, self.az, self.ac]:\n            r_tol, a_tol = _get_rtol_atol(ar)\n            d_ccont = ar.copy()\n            d_fcont = np.asfortranarray(d_ccont)\n            for a in range(ar.ndim):\n                f1 = mkl_fft.fft(d_ccont, axis=a)\n                f2 = mkl_fft.fft(d_fcont, axis=a)\n                assert_allclose(f1, f2, rtol=r_tol, atol=a_tol)\n\n    def test_rfftn_numpy(self):\n        """"""Test that rfftn_numpy works as expected""""""\n        axes = [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]\n        for x in [self.ad, self.af]:\n            for a in axes:\n                r_tol, a_tol = _get_rtol_atol(x)\n                rfft_tr = mkl_fft.rfftn_numpy(np.transpose(x, a))\n                tr_rfft = np.transpose(mkl_fft.rfftn_numpy(x, axes=a), a)\n                assert_allclose(rfft_tr, tr_rfft, rtol=r_tol, atol=a_tol)\n'"
