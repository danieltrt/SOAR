file_path,api_count,code
ASO/ASO.py,9,"b'# Anarchic Society Optimization Algorithm\n# As seen in the paper by Amir Ahmadi-Javid\n# Implemented by Juanjo Sierra\n\nfrom CreateInitialSociety import *\nfrom CurrentMovementPolicy import CalculateFicklenessIndexes, GenerateCurrentMovementPolicy\nfrom SocietyMovementPolicy import CalculateExternalIrregularityIndexes, GenerateSocietyMovementPolicy\nfrom PreviousMovementPolicy import CalculateInternalIrregularityIndexes, GeneratePreviousMovementPolicy\nfrom MovementPoliciesCombination import NewPositionsPolicyBased\nfrom UpdateHistory import *\n\ndef ASO(CostFunction, dim=10, nindividuals=20, max_eval=10000,\n    fickleness_rate=0.5, external_rate=4, external_threshold=0.5,\n\tinternal_rate=4, internal_threshold=0.5, evolution_rate=0.5,\n\tlower_bound=0, upper_bound=10, initial_population_lower_bound=None,\n\tinitial_population_upper_bound=None):\n\n    # Domain of the function, tuple including lower and upper bounds\n\tdomain = (lower_bound, upper_bound)\n\tinitial_domain = (initial_population_lower_bound, initial_population_upper_bound)\n\n    # Create the initial society\n\tsociety, society_fitness, history, history_fitness = CreateInitialSociety(CostFunction,\n            nindividuals, dim, domain, initial_domain)\n\n\t# Initial function evaluations are the same as society members\n\tevaluations = nindividuals\n\n\tevaluations_marker = 0\n\tevaluation_marks = np.array([])\n\n\t# Start the main loop\n\twhile evaluations < max_eval:\n\t\tglobal_best = np.min(history_fitness)\n\t\titeration_best = society[np.argsort(society_fitness)[0]]\n\n\t\tfickleness_indexes = CalculateFicklenessIndexes(society_fitness, history_fitness, fickleness_rate)\n\t\texternal_indexes = CalculateExternalIrregularityIndexes(society_fitness, global_best, external_rate)\n\t\tinternal_indexes = CalculateInternalIrregularityIndexes(society_fitness, history_fitness, internal_rate)\n\n\t\tcurrent_movement_positions = np.array([GenerateCurrentMovementPolicy(\n\t\t\tindividual, fickleness_index, iteration_best, fickleness_rate, evolution_rate, domain)\n\t\t\tfor (individual, fickleness_index) in zip(society, fickleness_indexes)])\n\t\t\n\t\tsociety_movement_positions = np.array([GenerateSocietyMovementPolicy(\n\t\t\tindividual, external_index, global_best, external_threshold, evolution_rate, domain)\n\t\t\tfor (individual, external_index) in zip(society, external_indexes)])\n\n\t\tprevious_movement_positions = np.array([GeneratePreviousMovementPolicy(\n\t\t\tindividual, internal_index, previous_best, internal_threshold, evolution_rate, domain)\n\t\t\tfor (individual, internal_index, previous_best) in zip(society, internal_indexes, history)])\n\n\t\tsociety, society_fitness, new_evaluations = NewPositionsPolicyBased(CostFunction, current_movement_positions, society_movement_positions, previous_movement_positions)\n\t\t\n\t\thistory, history_fitness = UpdateHistory(society, society_fitness, history, history_fitness)\n\n\t\tevaluations += new_evaluations\n\n\t\tif evaluations >= evaluations_marker:\n\t\t\tevaluation_marks = np.insert(evaluation_marks, len(evaluation_marks), np.min(history_fitness))\n\t\t\tevaluations_marker += max_eval / 10\n\t\t\n\t\t#print(""Iteration {:3}, best solution: {:e}"".format(iteration, np.min(history_fitness)))\n\n\treturn np.append(evaluation_marks, np.min(history_fitness))'"
ASO/ASObenchmark10-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f1, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f6, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f14, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f15, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f16, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark10-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f2, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-10-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f7, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-999999, upper_bound=999999,\n        fickleness_rate=fickleness_rate, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f13, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-3, upper_bound=1,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f17, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f18, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark10-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f3, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-10-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f8, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-32, upper_bound=32,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f11, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-0.5, upper_bound=0.5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f19, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f20, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark10-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f4, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-10-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f9, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f12, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-np.pi, upper_bound=np.pi,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f21, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f22, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark10-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f5, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-10-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f10, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f23, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-np.pi, upper_bound=np.pi,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f24, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f25, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-10, upper_bound=10,\n        fickleness_rate=fickleness_rate, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-10-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-10-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark30-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f1, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f6, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f14, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f15, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f16, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark30-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f2, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-30-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f7, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-999999, upper_bound=999999,\n        fickleness_rate=fickleness_rate, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f13, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-3, upper_bound=1,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f17, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f18, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark30-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f3, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergenced-30-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f8, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-32, upper_bound=32,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f11, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-0.5, upper_bound=0.5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f19, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f20, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark30-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f4, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergence-30-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f9, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f12, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-np.pi, upper_bound=np.pi,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f21, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f22, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-results-30-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergence-30-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASObenchmark30-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rate = 3\n    internal_rate = 1\n    fickleness_rate = 0.5\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f5, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-100, upper_bound=100,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ASO-convergenced-30-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f10, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f23, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-np.pi, upper_bound=np.pi,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f24, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-5, upper_bound=5,\n        fickleness_rate=fickleness_rate) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([ASO(f25, dim=dim, max_eval=evaluations, external_rate=external_rate,\n        internal_rate=internal_rate, lower_bound=-10, upper_bound=10,\n        fickleness_rate=fickleness_rate, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ASO-resultsd-30-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ASO-convergenced-30-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ASO/ASOparameters.py,12,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ASO import *\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    population = 30\n    external_rates = [1,2,3,4]\n    internal_rates = [1,2,3,4]\n    fickleness_rates = [0.3, 0.5, 0.7]\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n    print(""F1: Shifted Sphere Function\\n"")\n\n    for external_rate in external_rates:\n        for internal_rate in internal_rates:\n            for fickleness_rate in fickleness_rates:\n                time1 = time.time()\n                results = np.array([ASO(f1, dim=dim, max_eval=evaluations, external_rate=external_rate,\n                    internal_rate=internal_rate, lower_bound=-100, upper_bound=100, fickleness_rate=fickleness_rate) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""External rate: {}\\tInternal rate: {}\\tFickleness rate: {}"".format(external_rate, internal_rate, fickleness_rate))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n    \n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f6 = optproblems.cec2005.F6(dim)\n    print(""F6: Shifted Rosenbrock\xe2\x80\x99s Function\\n"")\n\n    for external_rate in external_rates:\n        for internal_rate in internal_rates:\n            for fickleness_rate in fickleness_rates:\n                time1 = time.time()\n                results = np.array([ASO(f6, dim=dim, max_eval=evaluations, external_rate=external_rate,\n                    internal_rate=internal_rate, lower_bound=-100, upper_bound=100, fickleness_rate=fickleness_rate) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""External rate: {}\\tInternal rate: {}\\tFickleness rate: {}"".format(external_rate, internal_rate, fickleness_rate))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n    print(""F14: Shifted Rotated Expanded Scaffer\xe2\x80\x99s F6\\n"")\n\n    for external_rate in external_rates:\n        for internal_rate in internal_rates:\n            for fickleness_rate in fickleness_rates:\n                time1 = time.time()\n                results = np.array([ASO(f14, dim=dim, max_eval=evaluations, external_rate=external_rate,\n                    internal_rate=internal_rate, lower_bound=-100, upper_bound=100, fickleness_rate=fickleness_rate) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""External rate: {}\\tInternal rate: {}\\tFickleness rate: {}"".format(external_rate, internal_rate, fickleness_rate))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n    print(""F15: Hybrid Composition Function\\n"")\n\n    for external_rate in external_rates:\n        for internal_rate in internal_rates:\n            for fickleness_rate in fickleness_rates:\n                time1 = time.time()\n                results = np.array([ASO(f15, dim=dim, max_eval=evaluations, external_rate=external_rate,\n                    internal_rate=internal_rate, lower_bound=-5, upper_bound=5, fickleness_rate=fickleness_rate) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""External rate: {}\\tInternal rate: {}\\tFickleness rate: {}"".format(external_rate, internal_rate, fickleness_rate))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")'"
ASO/CreateInitialSociety.py,2,"b'import numpy as np\n\ndef CreateInitialSociety(CostFunction, nindividuals, dim, domain, initial_domain):\n    lower_bound, upper_bound = domain\n    initial_lower_bound, initial_upper_bound = initial_domain\n\n    if initial_lower_bound != None and initial_upper_bound != None:\n        lower_bound = initial_lower_bound\n        upper_bound = initial_upper_bound\n\n    # Create first nindividuals\n    society = np.random.uniform(lower_bound, upper_bound, nindividuals*dim).reshape(nindividuals, dim)\n    society_fitness = np.apply_along_axis(CostFunction, 1, society)\n\n    # Society structures are duplicated for storing best past position per member\n    return society, society_fitness, society, society_fitness'"
ASO/CurrentMovementPolicy.py,5,"b'import numpy as np\n\ndef Fickleness(current_fitness, iteration_best_fitness, best_past_fitness, fickleness_rate):\n    return 1 - fickleness_rate*(iteration_best_fitness/current_fitness) - (1-fickleness_rate)*(best_past_fitness/current_fitness)\n\ndef CalculateFicklenessIndexes(society_fitness, history_fitness, fickleness_rate):\n    best = np.min(society_fitness)\n    \n    return np.array([Fickleness(current, best, past, fickleness_rate)\n        for (current, past) in zip(society_fitness, history_fitness)])\n\ndef GenerateCurrentMovementPolicy(individual, fickleness_index, iteration_best, fickleness_rate, evolution_rate, domain):\n    lower_bound, upper_bound = domain\n    dim = len(individual)\n\n    if fickleness_index < fickleness_rate: \n        mutation_multiplier = np.random.uniform(-1,1,dim)\n        mutation = evolution_rate * mutation_multiplier * (iteration_best - individual)\n        return np.clip(individual + mutation, lower_bound, upper_bound)\n    else:\n        return np.random.uniform(lower_bound, upper_bound, dim)'"
ASO/MovementPoliciesCombination.py,6,"b'import numpy as np\n\ndef SelectBestPolicy(CostFunction, current_policy, society_policy, previous_policy):\n    dim = len(current_policy)\n    policies = np.concatenate((current_policy, society_policy, previous_policy)).reshape(3,dim)\n    policies_fitness = np.apply_along_axis(CostFunction, 1, policies)\n    \n    best = np.argsort(policies_fitness)[0]\n    return np.append(policies_fitness[best], policies[best])\n\ndef NewPositionsPolicyBased(CostFunction, current_policies, society_policies, previous_policies):\n    results = np.array([SelectBestPolicy(CostFunction, current, society, previous)\n\t\t\tfor (current, society, previous) in zip(current_policies, society_policies, previous_policies)])\n\n    new_evaluations = 3 * len(current_policies) # All three policies has the same amount of members\n    new_fitness = results[:, 0]\n    new_positions = np.delete(results, 0, 1)\n\n    return new_positions, new_fitness, new_evaluations'"
ASO/PreviousMovementPolicy.py,5,"b'import numpy as np\n\ndef InternalIrregularity(current_fitness, history_best_fitness, internal_rate):\n    return 1 - (np.e ** -internal_rate*(current_fitness - history_best_fitness))\n\ndef CalculateInternalIrregularityIndexes(society_fitness, history_fitness, internal_rate):\n    return np.array([InternalIrregularity(current, past, internal_rate)\n        for (current,past) in zip(society_fitness,history_fitness)])\n\ndef GeneratePreviousMovementPolicy(individual, internal_index, previous_best, internal_threshold, evolution_rate, domain):\n    lower_bound, upper_bound = domain\n    dim = len(individual)\n\n    if internal_index < internal_threshold: \n        mutation_multiplier = np.random.uniform(-1,1,dim)\n        mutation = evolution_rate * mutation_multiplier * (previous_best - individual)\n        return np.clip(individual + mutation, lower_bound, upper_bound)\n    else:\n        return np.random.uniform(lower_bound, upper_bound, dim)'"
ASO/SocietyMovementPolicy.py,5,"b'import numpy as np\n\ndef ExternalIrregularity(current_fitness, global_best_fitness, external_rate):\n    return 1 - (np.e ** -external_rate*(current_fitness - global_best_fitness))\n\ndef CalculateExternalIrregularityIndexes(society_fitness, global_best_fitness, external_rate):\n    return np.array([ExternalIrregularity(current, global_best_fitness, external_rate)\n        for current in society_fitness])\n\ndef GenerateSocietyMovementPolicy(individual, external_index, global_best, external_threshold, evolution_rate, domain):\n    lower_bound, upper_bound = domain\n    dim = len(individual)\n\n    if external_index < external_threshold: \n        mutation_multiplier = np.random.uniform(-1,1,dim)\n        mutation = evolution_rate * mutation_multiplier * (global_best - individual)\n        return np.clip(individual + mutation, lower_bound, upper_bound)\n    else:\n        return np.random.uniform(lower_bound, upper_bound, dim)'"
ASO/UpdateHistory.py,1,"b'import numpy as np\n\ndef UpdateHistory(society, society_fitness, history, history_fitness):\n    history_changes = np.where(society_fitness < history_fitness)\n    history[history_changes] = society[history_changes]\n    history_fitness[history_changes] = society_fitness[history_changes]\n\n    return history, history_fitness'"
ICA/AssimilateColonies.py,4,"b""import numpy as np\nimport numpy.matlib\n\ndef AssimilateColonies(imperialist, colonies, domain, assimilation_coef, CostFunction):\n    lower_bound, upper_bound = domain\n\n    # The imperialist position will have an impact in any colony movement\n    vector = np.matlib.repmat(imperialist, len(colonies), 1) - colonies\n\n    # The multiplier helps searching different points around the imperialist\n    multiplier = np.random.rand(len(vector)).reshape(len(vector), 1)\n\n    # And finally we calculate each colony's new position, and clip the values according to the domain\n    colonies = colonies + 2 * assimilation_coef * multiplier * vector\n    colonies = np.clip(colonies, lower_bound, upper_bound)\n\n    colonies_fitness = np.apply_along_axis(CostFunction, 1, colonies);\n    new_evaluations = len(colonies)\n\n    return colonies, colonies_fitness, new_evaluations\n"""
ICA/CreateInitialEmpires.py,9,"b'import numpy as np\n\ndef CreateInitialEmpires(countries, fitness, nimperialists, zeta):\n\n    num_colonies = np.shape(countries)[0] - nimperialists\n\n    # Countries are divided into imperialists and colonies\n    imperialists = countries[0:nimperialists]\n    imperialists_fitness = fitness[0:nimperialists]\n    colonies = countries[nimperialists:]\n    colonies_fitness = fitness[nimperialists:]\n\n    # Imperialist power is calculated\n    if max(imperialists_fitness) > 0:\n        imperialist_power = 1.3 * max(imperialists_fitness) - imperialists_fitness\n    else:\n        imperialist_power = 0.7 * max(imperialists_fitness) - imperialists_fitness\n\n    # Number of colonies per imperialist are defined according to their power\n    colonies_per_imperialist = np.round(imperialist_power/np.sum(imperialist_power) * num_colonies)\n\n    # Given a random permutation of the colonies, they are splitted\n    randperm = np.random.permutation(num_colonies)\n    colonies = colonies[randperm]\n    colonies_fitness = colonies_fitness[randperm]\n\n    cumulative_colonies_per_imperialist = np.cumsum(colonies_per_imperialist).astype(int)\n    new_colonies = np.split(colonies, cumulative_colonies_per_imperialist)[0:nimperialists]\n    new_colonies_fitness = np.split(colonies_fitness, cumulative_colonies_per_imperialist)\n    empires_total_cost = np.array([])\n\n    if len(new_colonies[-1]) == 0:\n        new_colonies[-1] = np.append(new_colonies[-1], colonies[-1])\n\n    for i in range(0,nimperialists):\n        empires_total_cost = np.append(empires_total_cost, imperialists_fitness[i] + zeta * np.mean(colonies_fitness[i]))\n\n    return imperialists, imperialists_fitness, new_colonies, new_colonies_fitness, empires_total_cost\n'"
ICA/GenerateNewCountries.py,1,"b'import numpy as np\n\ndef GenerateNewCountries(ncountries, dim, domain, initial_domain):\n    lower_bound, upper_bound = domain\n    initial_lower_bound, initial_upper_bound = initial_domain\n\n    if initial_lower_bound != None and initial_upper_bound != None:\n        lower_bound = initial_lower_bound\n        upper_bound = initial_upper_bound\n\n    # New countries are generated\n    new_countries = np.random.uniform(lower_bound, upper_bound, ncountries*dim).reshape(ncountries,dim)\n\n    return new_countries\n'"
ICA/ICA.py,7,"b'# Imperialist Competitive Algorithm: A Socio Politically Inspired Optimization Strategy\n# Developed By: Esmaeil Atashpaz Gargari\n# Translated to Python By: Juanjo Sierra\n\nimport numpy as np\nfrom GenerateNewCountries import *\nfrom CreateInitialEmpires import *\nfrom AssimilateColonies import *\nfrom RevolveColonies import *\nfrom PosessEmpire import *\nfrom UniteSimilarEmpires import *\nfrom ImperialisticCompetition import *\n\ndef ICA(CostFunction, dim=10, ncountries=200, nimperialists=8, decades=2000,\n        evaluation_criteria=False, max_eval=10000, revolution_rate=0.3, assimilation_coef=2,\n        assimilation_angle_coef=np.pi/4, zeta=0.1, damp_ratio=0.99, stop_if_just_one_empire=False,\n        uniting_threshold=0.02, lower_bound=0, upper_bound=10, initial_population_lower_bound=None,\n        initial_population_upper_bound=None):\n\n    # Zarib is used to prevent the weakest empire to have a probability of zero\n    zarib = 1.05\n    # Alpha is the importance of the mean minimun compared to the global minimum. Must be << 1\n    alpha = 0.1\n    # Domain of the problem, tuple including lower and upper bounds\n    domain = (lower_bound, upper_bound)\n    initial_domain = (initial_population_lower_bound, initial_population_upper_bound)\n\n    # Generation of the initial countries\n    initial_countries = GenerateNewCountries(ncountries, dim, domain, initial_domain)\n    \n    # New countries\' cost/fitness is calculated\n    fitness = np.apply_along_axis(CostFunction, 1, initial_countries)\n    \n    # Get initial evaluations if evaluations criteria is active\n    if evaluation_criteria:\n        evaluations = len(fitness)\n\n    # And now the countries get sorted by their fitness\n    order = np.argsort(fitness)\n    fitness = fitness[order]\n    initial_countries = initial_countries[order]\n\n    # Initial empires are defined\n    imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost = CreateInitialEmpires(initial_countries,\n                                fitness, nimperialists, zeta)\n\n    current_decade = 0\n\n    # Main loop\n    evaluations_marker = 0\n    evaluation_marks = np.array([])\n    while (evaluation_criteria and (evaluations < max_eval)) or (not evaluation_criteria and (current_decade < decades)):\n        revolution_rate = damp_ratio*revolution_rate\n\n        for i in range(0,len(imperialists)):\n            # Assimilation: movement of colonies towards imperialists (Assimilation Policy)\n            colonies[i], colonies_fitness[i], assimilation_evaluations = AssimilateColonies(imperialists[i],\n                                colonies[i], domain, assimilation_coef, CostFunction)\n\n            # Empire posession: if a colony has a lower cost than its imperialist, they switch positions\n            imperialists[i], imperialists_fitness[i], colonies[i], colonies_fitness[i] = PosessEmpire(imperialists[i],\n                                imperialists_fitness[i], colonies[i], colonies_fitness[i])\n\n            # Revolution: a sudden change in the socio-political characteristics\n            colonies[i], colonies_fitness[i], revolution_evaluations = RevolveColonies(colonies[i],\n                                colonies_fitness[i], domain, initial_domain, revolution_rate, CostFunction)\n\n            # Empire posession again\n            imperialists[i], imperialists_fitness[i], colonies[i], colonies_fitness[i] = PosessEmpire(imperialists[i],\n                                imperialists_fitness[i], colonies[i], colonies_fitness[i])\n\n            # Compute the current cost for each empire\n            empires_total_cost[i] = imperialists_fitness[i] + zeta * np.mean(colonies_fitness[i])\n\n        # Similar empires are merged into a bigger empire\n        imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost = UniteSimilarEmpires(imperialists,\n                                imperialists_fitness, colonies, colonies_fitness, empires_total_cost, domain, uniting_threshold, zeta)\n\n        # The imperialistic competition takes place\n        imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost = ImperialisticCompetition(imperialists,\n                                imperialists_fitness, colonies, colonies_fitness, empires_total_cost)\n\n        if len(imperialists) == 1 and stop_if_just_one_empire:\n            break\n\n        if evaluation_criteria:\n            new_evaluations = assimilation_evaluations + revolution_evaluations\n            evaluations += new_evaluations\n        else:\n            current_decade += 1\n\n        if evaluations >= evaluations_marker:\n            evaluation_marks = np.insert(evaluation_marks, len(evaluation_marks), min(imperialists_fitness))\n            evaluations_marker += max_eval / 10 \n\n        #print(""Decade {:4}, best solution: {:e}"".format(decade, min(imperialists_fitness)))\n\n    return np.append(evaluation_marks, min(imperialists_fitness))'"
ICA/ICAbenchmark10-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f1, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f6, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f14, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f15, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f16, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark10-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f2, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-10-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f7, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-999999, upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f13, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f17, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f18, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark10-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f3, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-10-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f8, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f11, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f19, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f20, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark10-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f4, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-10-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f9, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f12, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f21, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f22, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark10-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f5, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-10-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f10, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f23, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f24, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f25, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-10, upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-10-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-10-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark30-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f1, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f6, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f14, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f15, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f16, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark30-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f2, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-30-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f7, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-999999, upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f13, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f17, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f18, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark30-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f3, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-30-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f8, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f11, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f19, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f20, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark30-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f4, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-30-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f9, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f12, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f21, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f22, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAbenchmark30-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists = 6\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f5, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/ICA-convergence-30-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f10, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f23, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f24, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([ICA(f25, dim=dim, evaluation_criteria=True,\n        max_eval=evaluations, ncountries=countries, nimperialists=imperialists,\n        lower_bound=-10, upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/ICA-results-30-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/ICA-convergence-30-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
ICA/ICAparameters.py,12,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom ICA import *\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    countries = 30\n    imperialists_list = [3,4,5,6]\n    revolution_rates = [0.2,0.3,0.4]\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n    print(""F1: Shifted Sphere Function\\n"")\n\n    for imperialists in imperialists_list:\n        for revolution_rate in revolution_rates:\n            time1 = time.time()\n            results = np.array([ICA(f1, dim=dim, evaluation_criteria=True, max_eval=evaluations,\n                ncountries=countries, nimperialists=imperialists, revolution_rate=revolution_rate,\n                lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Imperialists: {}\\tRevolution rate: {}"".format(imperialists, revolution_rate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n    print(""F6: Shifted Rosenbrock\xe2\x80\x99s Function\\n"")\n\n    for imperialists in imperialists_list:\n        for revolution_rate in revolution_rates:\n            time1 = time.time()\n            results = np.array([ICA(f6, dim=dim, evaluation_criteria=True, max_eval=evaluations,\n                ncountries=countries, nimperialists=imperialists, revolution_rate=revolution_rate,\n                lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Imperialists: {}\\tRevolution rate: {}"".format(imperialists, revolution_rate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n    print(""F14: Shifted Rotated Expanded Scaffer\xe2\x80\x99s F6\\n"")\n\n    for imperialists in imperialists_list:\n        for revolution_rate in revolution_rates:\n            time1 = time.time()\n            results = np.array([ICA(f14, dim=dim, evaluation_criteria=True, max_eval=evaluations,\n                ncountries=countries, nimperialists=imperialists, revolution_rate=revolution_rate,\n                lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Imperialists: {}\\tRevolution rate: {}"".format(imperialists, revolution_rate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n    print(""F15: Hybrid Composition Function\\n"")\n\n    for imperialists in imperialists_list:\n        for revolution_rate in revolution_rates:\n            time1 = time.time()\n            results = np.array([ICA(f1, dim=dim, evaluation_criteria=True, max_eval=evaluations,\n                ncountries=countries, nimperialists=imperialists, revolution_rate=revolution_rate,\n                lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Imperialists: {}\\tRevolution rate: {}"".format(imperialists, revolution_rate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n'"
ICA/ImperialisticCompetition.py,14,"b'import numpy as np\n\ndef ImperialisticCompetition(imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost):\n    dim = len(colonies[0][0])\n    \n    if len(imperialists) <= 1:\n        return imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost\n\n    # Search for the weakest empire (the one with the higher cost)\n    weakest_empire = (-empires_total_cost).argsort()[0]\n    max_total_cost = empires_total_cost[weakest_empire]\n    total_powers = max_total_cost - empires_total_cost\n    posession_probability = total_powers / np.sum(total_powers)\n\n    # The empire that will conquer the colony is chosen\n    selected_empire = SelectAnEmpire(posession_probability)\n    selected_colony = np.random.randint(0, len(colonies[weakest_empire]))\n\n    # Conquest\n    colonies[selected_empire] = np.append(colonies[selected_empire], colonies[weakest_empire][selected_colony].reshape(1,dim), axis=0)\n    colonies_fitness[selected_empire] = np.append(colonies_fitness[selected_empire], colonies_fitness[weakest_empire][selected_colony])\n\n    # The colony is removed from its former empire\n    colonies[weakest_empire] = np.delete(colonies[weakest_empire], selected_colony, 0)\n    colonies_fitness[weakest_empire] = np.delete(colonies_fitness[weakest_empire], selected_colony)\n\n    # If the weakest empire remains with one or less colonies (apart from the imperialist), it is also absorbed\n    if len(colonies[weakest_empire]) <= 1:\n        colonies_addition = np.append(colonies[weakest_empire], imperialists[weakest_empire].reshape(1,dim), axis=0)\n        fitness_addition = np.append(colonies_fitness[weakest_empire], imperialists_fitness[weakest_empire])\n        colonies[selected_empire] = np.append(colonies[selected_empire], colonies_addition, axis=0)\n        colonies_fitness[selected_empire] = np.append(colonies_fitness[selected_empire], fitness_addition)\n\n        del colonies[weakest_empire]\n        del colonies_fitness[weakest_empire]\n        imperialists = np.delete(imperialists, weakest_empire, 0)\n        imperialists_fitness = np.delete(imperialists_fitness, weakest_empire)\n        empires_total_cost = np.delete(empires_total_cost, weakest_empire)\n\n    return imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost\n\n# A function for selecting a random empire with given probabilities\ndef SelectAnEmpire(probability):\n    r = np.random.rand(len(probability))\n    d = probability - r\n\n    # The empire with higher value will be selected\n    selected = (-d).argsort()[0]\n    return selected\n'"
ICA/PosessEmpire.py,1,"b'import numpy as np\n\ndef PosessEmpire(imperialist, imperialist_fitness, colonies, colonies_fitness):\n    best_colony = np.argmin(colonies_fitness)\n\n    if (colonies_fitness[best_colony] < imperialist_fitness):\n        old_imperialist = imperialist\n        old_imperialist_fitness = imperialist_fitness\n        imperialist = colonies[best_colony]\n        imperialist_fitness = colonies_fitness[best_colony]\n        colonies[best_colony] = old_imperialist\n        colonies_fitness[best_colony] = old_imperialist_fitness\n\n    return imperialist, imperialist_fitness, colonies, colonies_fitness\n'"
ICA/RevolveColonies.py,3,"b""import numpy as np\nfrom GenerateNewCountries import *\n\ndef RevolveColonies(colonies, colonies_fitness, domain, initial_domain, revolution_rate, CostFunction):\n    # How many countries revolve depends on the revolution rate\n    num_revolving_colonies = np.round(revolution_rate * len(colonies)).astype(int)\n    dim = len(colonies[0])\n    new_evaluations = 0\n\n    # We only have to make new positions and recalculate if there is at least one colony to revolve\n    if (num_revolving_colonies > 0):\n        # Revolved colonies' positions are generated as new countries\n        revolved_positions = GenerateNewCountries(num_revolving_colonies, dim, domain, initial_domain)\n\n        randperm = np.random.permutation(len(colonies))\n        colonies = colonies[randperm]\n        colonies_fitness = colonies_fitness[randperm]\n\n        # First 'num_revolving_colonies' are exchanged for their new positions\n        colonies[0:num_revolving_colonies] = revolved_positions\n        colonies_fitness[0:num_revolving_colonies] = np.apply_along_axis(CostFunction, 1, colonies[0:num_revolving_colonies])\n        new_evaluations = num_revolving_colonies\n\n    return colonies, colonies_fitness, new_evaluations\n"""
ICA/UniteSimilarEmpires.py,9,"b'import numpy as np\n\ndef UniteSimilarEmpires(imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost, domain, uniting_threshold, zeta):\n    lower_bound, upper_bound = domain\n    dim = len(colonies[0][0])\n\n    # The threshold distance is the lower distance two imperialists can be separated by without merging\n    threshold_distance = uniting_threshold * abs(upper_bound - lower_bound)\n\n    # Check if there is a pair of empires that much closer\n    for i in range(0, len(imperialists)):\n        for j in range(i+1, len(imperialists)):\n            distance_vector = imperialists[i] - imperialists[j]\n            distance = np.linalg.norm(distance_vector)\n\n            # If there is such a pair, the empire with the\n            # best (lower-cost) imperialist absorbs the other empire\n            if distance <= threshold_distance:\n                if imperialists_fitness[i] < imperialists_fitness[j]:\n                    best_imperialist = i\n                    worst_imperialist = j\n                else:\n                    best_imperialist = j\n                    worst_imperialist = i\n\n                colonies_addition = np.append(colonies[worst_imperialist], imperialists[worst_imperialist].reshape(1,dim), axis=0)\n                fitness_addition = np.append(colonies_fitness[worst_imperialist], imperialists_fitness[worst_imperialist])\n                colonies[best_imperialist] = np.append(colonies[best_imperialist], colonies_addition, axis=0)\n                colonies_fitness[best_imperialist] = np.append(colonies_fitness[best_imperialist], fitness_addition)\n                empires_total_cost[best_imperialist] = imperialists_fitness[best_imperialist] + zeta * np.mean(colonies_fitness[best_imperialist])\n\n                # And we get rid of the absorbed empire position\n                del colonies[worst_imperialist]\n                del colonies_fitness[worst_imperialist]\n                imperialists = np.delete(imperialists, worst_imperialist, 0)\n                imperialists_fitness = np.delete(imperialists_fitness, worst_imperialist)\n                empires_total_cost = np.delete(empires_total_cost, worst_imperialist)\n                return imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost\n\n    return imperialists, imperialists_fitness, colonies, colonies_fitness, empires_total_cost\n'"
POA/ChooseCandidates.py,5,"b'import numpy as np\n\ndef ChooseCandidates(candidates, candidates_fitness, members, members_fitness):\n    while (np.max(candidates_fitness) > np.min(members_fitness)):\n        former_candidate_index = np.argmax(candidates_fitness)\n        former_member_index = np.argmin(members_fitness)\n        aux_position = np.copy(candidates[former_candidate_index])\n        aux_fitness = np.copy(candidates_fitness[former_candidate_index])\n        candidates[former_candidate_index] = members[former_member_index]\n        candidates_fitness[former_candidate_index] = members_fitness[former_member_index]\n        members[former_member_index] = aux_position\n        members_fitness[former_member_index] = aux_fitness\n\n    return candidates, candidates_fitness, members, members_fitness\n'"
POA/DefineInitialParties.py,6,"b""import numpy as np\nfrom ChooseCandidates import *\n\ndef DefineInitialParties(CostFunction, nparties, nmembers, ncandidates, dim, domain, initial_domain):\n    lower_bound, upper_bound = domain\n    initial_lower_bound, initial_upper_bound = initial_domain\n\n    if initial_lower_bound != None and initial_upper_bound != None:\n        lower_bound = initial_lower_bound\n        upper_bound = initial_upper_bound\n\n    nregularmembers = nmembers - ncandidates;\n\n    # First we create the regular members of each party; it has to be saved in a list\n    # because the size of the parties may vary in following steps of the algorithm\n    members = np.random.uniform(lower_bound, upper_bound, nparties*nregularmembers*dim).reshape(nparties*nregularmembers, dim)\n    members_fitness = np.apply_along_axis(CostFunction, 1, members)\n    members = np.split(members, nparties)\n    members_fitness = np.split(members_fitness, nparties)\n\n    # And now we generate N candidate spots for each party, and assign each party's best members to them\n    candidates = np.random.uniform(lower_bound, upper_bound, nparties*ncandidates*dim).reshape(nparties, ncandidates, dim)\n    candidates_fitness = np.apply_along_axis(CostFunction, 2, candidates)\n\n    for i in range(0,nparties):\n        candidates[i], candidates_fitness[i], members[i], members_fitness[i] = ChooseCandidates(candidates[i],\n                    candidates_fitness[i], members[i], members_fitness[i])\n\n    return candidates, candidates_fitness, members, members_fitness\n"""
POA/InterGroupCooperation.py,15,"b'import numpy as np\nfrom ChooseCandidates import *\n\ndef InterGroupCooperation(candidates, candidates_fitness, members, members_fitness,\n        group_power, groups_to_merge, merge_probability, groups_to_delete, deletion_probability):\n\n    # First a random number is generated to check if the most powerful groups merge\n    if len(candidates) >= groups_to_merge:\n        random_number = np.random.rand()\n\n        if random_number < merge_probability:\n            for _ in range(1,groups_to_merge):\n                best, second = np.argsort(group_power)[0:2]\n\n                # Make the members that will be merged join the best party\n                members_addition = np.append(members[second], candidates[second], axis=0)\n                fitness_addition = np.append(members_fitness[second], candidates_fitness[second])\n                members[best] = np.append(members[best], members_addition, axis=0)\n                members_fitness[best] = np.append(members_fitness[best], fitness_addition)\n\n                # Delete the appended group\n                del members[second]\n                del members_fitness[second]\n                candidates = np.delete(candidates, second, 0)\n                candidates_fitness = np.delete(candidates_fitness, second, 0)\n                group_power = np.delete(group_power, second)\n\n            # After the merging, candidates are reassigned\n            best = np.argsort(group_power)[0]\n            candidates[best], candidates_fitness[best], members[best], members_fitness[best] = ChooseCandidates(candidates[best],\n                    candidates_fitness[best], members[best], members_fitness[best])\n\n\n    # Next step is checking if is it possible to delete the weakest groups\n    if len(candidates) > groups_to_delete:\n        random_number = np.random.rand()\n\n        if random_number < deletion_probability:\n            for _ in range(0,groups_to_delete):\n                worst = np.argsort(group_power)[-1]\n\n                # Delete the worst group\n                del members[worst]\n                del members_fitness[worst]\n                candidates = np.delete(candidates, worst, 0)\n                candidates_fitness = np.delete(candidates_fitness, worst, 0)\n                group_power = np.delete(group_power, worst)\n\n\n    return candidates, candidates_fitness, members, members_fitness, group_power\n'"
POA/IntraGroupCompetition.py,9,"b'import numpy as np\nimport numpy.matlib\nfrom ChooseCandidates import *\n\ndef IntraGroupCompetition(CostFunction, candidates, candidates_fitness, members, members_fitness, domain, bias, candidate_weighting, member_weighting):\n    lower_bound, upper_bound = domain\n    dim = len(candidates[0])\n\n    # Regular members of a party are biased toward candidates\n    candidates_rep = np.matlib.repmat(candidates, len(members), 1).reshape(len(members),len(candidates),dim)\n    members_rep = np.repeat(members, len(candidates), axis=0).reshape(len(members),len(candidates),dim)\n    fitness_rep = np.matlib.repmat(candidates_fitness, len(members), 1).reshape(len(members),len(candidates),1)\n    dif = candidates_rep - members_rep\n\n    # Operations as in the formula seen in the paper\n    sum_up = np.apply_along_axis(sum, 1, dif*fitness_rep)\n    sum_down = np.sum(candidates_fitness)\n    possible_changes = np.clip(members + bias*(sum_up/sum_down), lower_bound, upper_bound)\n\n    # Now we have to check which members are going to change, only if they have upgraded their fitness\n    new_fitness = np.apply_along_axis(CostFunction, 1, possible_changes)\n    change_index = np.where(new_fitness < members_fitness)\n    members[change_index] = possible_changes[change_index]\n    members_fitness[change_index] = new_fitness[change_index]\n    new_evaluations = len(possible_changes)\n\n    # And then check if any new regular member deserves to be a candidate\n    candidates, candidates_fitness, members, members_fitness = ChooseCandidates(candidates, candidates_fitness, members, members_fitness)\n\n    # Finally, we compute the power of the group according to the formula in the paper\n    power = (candidate_weighting*np.mean(candidates_fitness) + member_weighting*np.mean(members_fitness)) / candidate_weighting+member_weighting\n\n    return candidates, candidates_fitness, members, members_fitness, power, new_evaluations\n'"
POA/POA.py,5,"b'# Parliamentary Political Competitions: A New Approach To Global Optimization\n# As seen in the paper by Ali Borji & Mandana Hamidi\n# Implemented by Juanjo Sierra\n\nfrom DefineInitialParties import *\nfrom IntraGroupCompetition import *\nfrom InterGroupCooperation import *\n\ndef POA(CostFunction, dim=10, nparties=4, nmembers=5, ncandidates=2,\n\t\tlower_bound=0, upper_bound=10, max_eval=10000, merge_probability=0.01,\n\t\tdeletion_probability=0.001, bias=0.3, member_weighting=0.01,\n\t\tcandidate_weighting=1, groups_to_merge=2, groups_to_delete=1,\n\t\tinitial_population_lower_bound=None, initial_population_upper_bound=None):\n\n\t# Domain of the function, tuple including lower and upper bounds\n\tdomain = (lower_bound, upper_bound)\n\tinitial_domain = (initial_population_lower_bound, initial_population_upper_bound)\n\n\t# Define the initial parties and candidates\n\tcandidates, candidates_fitness, members, members_fitness = DefineInitialParties(CostFunction,\n\t\t\tnparties, nmembers, ncandidates, dim, domain, initial_domain)\n\n\tevaluations = nparties * nmembers\n\tgroup_power = np.zeros(nparties)\n\n\tevaluations_marker = 0\n\tevaluation_marks = np.array([])\n\n\twhile evaluations < max_eval:\n\t\tfor i in range(0,len(candidates)):\n\t\t\t# Intragroup Competition: regular members try to become candidates of their group\n\t\t\tcandidates[i], candidates_fitness[i], members[i], members_fitness[i], group_power[i], new_evaluations = IntraGroupCompetition(CostFunction,\n\t\t\t\t\tcandidates[i], candidates_fitness[i], members[i], members_fitness[i], domain,\n\t\t\t\t\tbias, candidate_weighting, member_weighting)\n\n\t\t# Intergroup Cooperation: best groups try to merge into a greater one, and weakest groups may disappear\n\t\tcandidates, candidates_fitness, members, members_fitness, group_power = InterGroupCooperation(candidates, candidates_fitness,\n\t\t\t\tmembers, members_fitness, group_power, groups_to_merge, merge_probability, groups_to_delete, deletion_probability)\n\n\t\t# print(""Iteration {:4}, best solution: {:e}"".format(iterations, np.min(candidates_fitness)))\n\n\t\tevaluations += new_evaluations\n\n\t\tif evaluations >= evaluations_marker:\n\t\t\tevaluation_marks = np.insert(evaluation_marks, len(evaluation_marks), np.min(candidates_fitness))\n\t\t\tevaluations_marker += max_eval / 10\n\n\treturn np.append(evaluation_marks, np.min(candidates_fitness))'"
POA/POAbenchmark10-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f6, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f14, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f15, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f16, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark10-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f2, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-10-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f7, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-999999,\n        upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f13, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-3,\n        upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f17, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f18, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark10-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f3, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-10-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f8, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-32,\n        upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f11, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-0.5,\n        upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f19, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f20, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark10-4.py,22,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f4, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-10-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f9, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f12, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-np.pi,\n        upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f21, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f22, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark10-5.py,22,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f5, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-10-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f10, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f23, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-np.pi,\n        upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f24, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f25, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-10,\n        upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-10-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-10-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n'"
POA/POAbenchmark30-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark30-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f2, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-30-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f7, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-999999,\n        upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f13, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-3,\n        upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f17, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f18, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark30-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f3, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-30-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f8, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-32,\n        upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f11, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-0.5,\n        upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f19, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f20, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark30-4.py,22,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f4, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-30-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f9, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f12, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-np.pi,\n        upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f21, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f22, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAbenchmark30-5.py,22,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 6\n    members = 5\n    candidates = 2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f5, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-100,\n        upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/POA-convergence-30-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f10, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f23, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-np.pi,\n        upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f24, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-5,\n        upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([POA(f25, dim=dim, max_eval=evaluations, nparties=parties,\n        nmembers=members, ncandidates=candidates, lower_bound=-10,\n        upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/POA-results-30-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/POA-convergence-30-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
POA/POAparameters.py,12,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom POA import *\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    parties = 5\n    members = 6\n    candidates_list = [1,2,3]\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n    print(""F1: Shifted Sphere Function\\n"")\n\n    for candidates in candidates_list:\n        time1 = time.time()\n        results = np.array([POA(f1, dim=dim, max_eval=evaluations, nparties=parties,\n            nmembers=members, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n        total_time = time.time() - time1\n        print(""Candidates: {}"".format(candidates))\n        print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n        print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f6 = optproblems.cec2005.F6(dim)\n    print(""F6: Shifted Rosenbrock\xe2\x80\x99s Function\\n"")\n\n    for candidates in candidates_list:\n        time1 = time.time()\n        results = np.array([POA(f6, dim=dim, max_eval=evaluations, nparties=parties,\n            nmembers=members, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n        total_time = time.time() - time1\n        print(""Candidates: {}"".format(candidates))\n        print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n        print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n    print(""F14: Shifted Rotated Expanded Scaffer\xe2\x80\x99s F6\\n"")\n\n    for candidates in candidates_list:\n        time1 = time.time()\n        results = np.array([POA(f14, dim=dim, max_eval=evaluations, nparties=parties,\n            nmembers=members, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n        total_time = time.time() - time1\n        print(""Candidates: {}"".format(candidates))\n        print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n        print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n    print(""F15: Hybrid Composition Function\\n"")\n\n    for candidates in candidates_list:\n        time1 = time.time()\n        results = np.array([POA(f15, dim=dim, max_eval=evaluations, nparties=parties,\n            nmembers=members, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n        total_time = time.time() - time1\n        print(""Candidates: {}"".format(candidates))\n        print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n        print(""_______________________________________________"")\n'"
SEA/BehaviourChanges.py,7,"b""import numpy as np\nfrom Manners import Manner2, Manner3, Manner4\n\ndef BehaviourChanges(population, population_fitness, history, status_best, emotion, lower_threshold, upper_threshold, k1, k2, k3, domain):\n    lower_bound, upper_bound = domain\n\n    # Select as 'bad population' individuals with emotion index lesser than lower threshold\n    bad_population = np.where(emotion < lower_threshold)[0]\n\n    # Select as 'average population' individuals with emotion index between lower and upper thresholds\n    average_population = np.where(np.logical_and(emotion >= lower_threshold, emotion < upper_threshold))[0]\n\n    # Select as 'good population' individuals with emotion index greater than or equal to upper threshold\n    good_population = np.where(emotion >= upper_threshold)[0]\n\n    # Perform appropriate change to bad population\n    if len(bad_population):\n        population[bad_population] += np.array([Manner2(individual, status_best, k2) \n                for individual in population[bad_population]])\n\n    # Perform appropriate change to average population\n    if len(average_population):\n        population[average_population] += np.array([Manner3(individual, individual_best, status_best, population, k1, k2, k3) \n                for (individual, individual_best) in zip(population[average_population], history[average_population])])\n    \n    # Perform appropriate change to good population\n    if len(good_population):\n        population[good_population] += np.array([Manner4(individual, individual_best, population, k1, k3) \n                for (individual, individual_best) in zip(population[good_population], history[good_population])])\n\n    return np.clip(population, lower_bound, upper_bound)"""
SEA/CreateInitialPopulation.py,3,"b'import numpy as np\n\ndef CreateInitialPopulation(CostFunction, nindividuals, dim, domain, initial_domain):\n    lower_bound, upper_bound = domain\n    initial_lower_bound, initial_upper_bound = initial_domain\n\n    if initial_lower_bound != None and initial_upper_bound != None:\n        lower_bound = initial_lower_bound\n        upper_bound = initial_upper_bound\n\n    # Create the N individuals with random positions in the search space\n    population = np.random.uniform(lower_bound, upper_bound, nindividuals*dim).reshape(nindividuals, dim)\n    population_fitness = np.apply_along_axis(CostFunction, 1, population)\n\n    # Reorder the population, best individuals first\n    # order = np.argsort(population_fitness)\n    # population_fitness = population_fitness[order]\n    # population = population[order]\n\n    # We return a second population and fitness as the current history of best position for each individual\n    return population, population_fitness, population, population_fitness'"
SEA/Manners.py,3,"b'import numpy as np\n\ndef Manner1(individual, population, k1):\n    return -k1 * np.random.uniform(0,1) * np.sum(population - individual, 0)\n\ndef Manner2(individual, status_best, k2):\n    return k2 * np.random.uniform(0,1) * (status_best - individual)\n\ndef Manner3Aux(individual, individual_best, k3):\n    return k3 * np.random.uniform(0,1) * (individual_best - individual)\n\ndef Manner3(individual, individual_best, status_best, population, k1, k2, k3):\n    manner3 = Manner3Aux(individual, individual_best, k3)\n    manner2 = Manner2(individual, status_best, k2)\n    manner1 = Manner1(individual, population, k1)\n\n    return manner3 + manner2 + manner1\n\ndef Manner4(individual, individual_best, population, k1, k3):\n    manner3 = Manner3Aux(individual, individual_best, k3)\n    manner1 = Manner1(individual, population, k1)\n\n    return manner3 + manner1\n'"
SEA/SEA.py,9,"b'# Social Emotional Optimization Algorithm for Nonlinear Constrained Optimization Problems\n# As seen in the paper by Yuechun Xu, Zhihua Cui & Jianchao Zeng\n# Implemented by Juanjo Sierra\n\nfrom CreateInitialPopulation import *\nfrom Manners import Manner1\nfrom UpdateFitnessAndHistory import *\nfrom BehaviourChanges import *\n\ndef SEA(CostFunction, dim=10, nindividuals=20, max_eval=10000,\n\tk1=0.01, k2=0.02, k3=0.03, emotion_decrease=0.05, lower_threshold=0.3,\n\tupper_threshold=0.6, lower_bound=0, upper_bound=10,\n\tinitial_population_lower_bound=None, initial_population_upper_bound=None):\n\n\t# Domain of the function, tuple including lower and upper bounds\n\tdomain = (lower_bound, upper_bound)\n\tinitial_domain = (initial_population_lower_bound, initial_population_upper_bound)\n\n\t# Create the first individuals\n\tpopulation, population_fitness, history, history_fitness = CreateInitialPopulation(CostFunction,\n\t\t\tnindividuals, dim, domain, initial_domain)\n\n\t# Initial evaluations (history evaluations don\'t count)\n\tevaluations = nindividuals\n\n\t# Create emotion indexes\n\temotion = np.ones(nindividuals)\n\n\t# First behaviour change\n\tmanner = np.array([Manner1(individual, population, k1) for individual in population])\n\tpopulation = np.clip(population + manner, lower_bound, upper_bound)\n\n\t# Update new positions, fitness and history\n\tpopulation_fitness, history, history_fitness, emotion, new_evaluations = UpdateFitnessAndHistory(CostFunction,\n\t\t\tpopulation, population_fitness, history, history_fitness, emotion, emotion_decrease)\n\n\tevaluations += new_evaluations\n\n\t# Update best global solution\n\tstatus_best = history[np.argsort(history_fitness)[0]]\n\n\tevaluations_marker = 0\n\tevaluation_marks = np.array([])\n\n\t# Start iterations\n\twhile evaluations < max_eval:\n\t\t# Change behaviours according to emotion indexes\n\t\tpopulation = BehaviourChanges(population, population_fitness, history, status_best, emotion,\n\t\t\t\tlower_threshold, upper_threshold, k1, k2, k3, domain)\n\n\t\t# Update new positions, fitness and history\n\t\tpopulation_fitness, history, history_fitness, emotion, new_evaluations = UpdateFitnessAndHistory(CostFunction,\n\t\t\tpopulation, population_fitness, history, history_fitness, emotion, emotion_decrease)\n\n\t\tevaluations += new_evaluations\n\n\t\t# Update best global solution\n\t\tstatus_best = history[np.argsort(history_fitness)[0]]\n\n\t\tif evaluations >= evaluations_marker:\n\t\t\tevaluation_marks = np.insert(evaluation_marks, len(evaluation_marks), np.min(history_fitness))\n\t\t\tevaluations_marker += max_eval / 10\n\n\t\t# print(""Iteration {:3}, best solution: {:e}"".format(iteration, np.min(history_fitness)))\n\n\treturn np.append(evaluation_marks, np.min(history_fitness))\n\n'"
SEA/SEAbenchmark10-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f1, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f6, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f14, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f15, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f16, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark10-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f2, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-10-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f7, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-999999, upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f13, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f17, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f18, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark10-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f3, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-10-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f8, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f11, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f19, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f20, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark10-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f4, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-10-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f9, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f12, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f21, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f22, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark10-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f5, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-10-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f10, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f23, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f24, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n    \n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f25, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-10, upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-10-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-10-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark30-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f1, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f6, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f14, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f15, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f16, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark30-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f2, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-30-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f7, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-999999, upper_bound=999999, initial_population_lower_bound=0,\n        initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f13, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f17, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f18, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark30-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f3, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-30-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f8, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f11, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f19, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f20, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark30-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f4, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-30-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f9, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f12, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f21, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f22, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAbenchmark30-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1 = 0.1\n    k2 = 0.4\n    k3 = 0.4\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f5, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SEA-convergence-30-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f10, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f23, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f24, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([SEA(f25, dim=dim, max_eval=evaluations,\n        nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n        lower_bound=-10, upper_bound=10, initial_population_lower_bound=2,\n        initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SEA-results-30-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SEA-convergence-30-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SEA/SEAparameters.py,12,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SEA import *\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    individuals = 30\n    k1_list = [0.1,0.2,0.3,0.4]\n    k2_list = [0.1,0.2,0.3,0.4]\n    k3_list = [0.1,0.2,0.3,0.4]\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n    print(""F1: Shifted Sphere Function\\n"")\n\n    for k1 in k1_list:\n        for k2 in k2_list:\n            for k3 in k3_list:\n                time1 = time.time()\n                results = np.array([SEA(f1, dim=dim, max_eval=evaluations,\n                    nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n                    lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""k1: {}\\tk2: {}\\tk3: {}"".format(k1, k2, k3))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f6 = optproblems.cec2005.F6(dim)\n    print(""F6: Shifted Rosenbrock\xe2\x80\x99s Function\\n"")\n\n    for k1 in k1_list:\n        for k2 in k2_list:\n            for k3 in k3_list:\n                time1 = time.time()\n                results = np.array([SEA(f6, dim=dim, max_eval=evaluations,\n                    nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n                    lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""k1: {}\\tk2: {}\\tk3: {}"".format(k1, k2, k3))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n    print(""F14: Shifted Rotated Expanded Scaffer\xe2\x80\x99s F6\\n"")\n\n    for k1 in k1_list:\n        for k2 in k2_list:\n            for k3 in k3_list:\n                time1 = time.time()\n                results = np.array([SEA(f14, dim=dim, max_eval=evaluations,\n                    nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n                    lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""k1: {}\\tk2: {}\\tk3: {}"".format(k1, k2, k3))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n    print(""F15: Hybrid Composition Function\\n"")\n\n    for k1 in k1_list:\n        for k2 in k2_list:\n            for k3 in k3_list:\n                time1 = time.time()\n                results = np.array([SEA(f15, dim=dim, max_eval=evaluations,\n                    nindividuals=individuals, k1=k1, k2=k2, k3=k3,\n                    lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n                total_time = time.time() - time1\n                print(""k1: {}\\tk2: {}\\tk3: {}"".format(k1, k2, k3))\n                print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n                print(""_______________________________________________"")\n\n'"
SEA/UpdateFitnessAndHistory.py,7,"b'import numpy as np\n\ndef UpdateFitnessAndHistory(CostFunction, population, population_fitness, history, history_fitness, emotion, emotion_decrease):\n    former_best = np.min(history_fitness)\n\n    # Compute new fitness for the new population\n    population_fitness = np.apply_along_axis(CostFunction, 1, population)\n    new_evaluations = len(population)\n\n    # Reorder population, history and emotions\n    # order = np.argsort(population_fitness)\n    # population_fitness = population_fitness[order]\n    # population = population[order]\n    # history = history[order]\n    # history_fitness = history_fitness[order]\n    # emotion = emotion[order]\n\n    # Adapt emotion index depending on global performance\n    emotion[np.where(population_fitness >= history_fitness)] -= emotion_decrease\n    emotion[np.where(population_fitness < history_fitness)] = 1.0\n    emotion = np.clip(emotion, 0, 1)\n\n    # Replace every individual history whose current fitness is the best\n    history_changes = np.where(population_fitness < history_fitness)\n    history[history_changes] = population[history_changes]\n    history_fitness[history_changes] = population_fitness[history_changes]\n\n    return population_fitness, history, history_fitness, emotion, new_evaluations'"
SLC/Competition.py,0,"b'import numpy as np\nfrom ProbabilityHost import *\nfrom Imitation import *\nfrom Provocation import *\nfrom LoserFunction import *\n\ndef Competition(CostFunction,league_main,league_subs,fitness_main,fitness_subs,domain,mutation_rate,mutation_probability):\n\n    nteams = league_main.shape[0]\n    evals_competition = 0\n\n    for i in range(0,nteams-2):\n        for j in range(i+1,nteams):\n            winner,loser = ProbabilityHost(i,j,league_main,fitness_main)\n            league_main,fitness_main,evals_competition = Imitation(CostFunction,\n                        winner,league_main,fitness_main,domain,evals_competition)\n            league_subs,fitness_subs,evals_competition = Provocation(CostFunction,\n                        winner,league_main,league_subs,fitness_subs,domain,evals_competition)\n            league_main,fitness_main,league_subs,fitness_subs,evals_competition = LoserFunction(CostFunction,\n                        loser,league_main,fitness_main,league_subs,fitness_subs,mutation_rate,mutation_probability,\n                        domain,evals_competition)\n\n    return league_main,league_subs,fitness_main,fitness_subs,evals_competition\n'"
SLC/CreateInitialLeague.py,4,"b""import numpy as np\nfrom Takhsis import *\n\ndef CreateInitialLeague(CostFunction, nteams, nmain, nsubs, dim, domain, initial_domain):\n    lower_bound, upper_bound = domain\n    initial_lower_bound, initial_upper_bound = initial_domain\n\n    if initial_lower_bound != None and initial_upper_bound != None:\n        lower_bound = initial_lower_bound\n        upper_bound = initial_upper_bound\n\n    # League is splitted into two matrices, representing main and subs players of each team\n    league_main = np.random.uniform(lower_bound,upper_bound,nteams*nmain*dim).reshape(nteams,nmain,dim)\n    league_subs = np.random.uniform(lower_bound,upper_bound,nteams*nsubs*dim).reshape(nteams,nsubs,dim)\n\n    # Fitness arrays\n    fitness_main = np.apply_along_axis(CostFunction, 2, league_main)\n    fitness_subs = np.apply_along_axis(CostFunction, 2, league_subs)\n    initial_evals = nteams*nmain + nteams*nsubs\n\n    # Now the 'Takhsis' is called for having the players sorted according to their fitness\n    league_main,league_subs,fitness_main,fitness_subs = Takhsis(league_main, league_subs, fitness_main, fitness_subs)\n\n    return league_main,league_subs,fitness_main,fitness_subs,initial_evals\n"""
SLC/Imitation.py,3,"b'import numpy as np\nimport random\n\ndef Imitation(CostFunction, winner, league_main, fitness_main, domain, evals_competition):\n\n    nmain = league_main.shape[1]\n    lower_bound, upper_bound = domain\n\n    for i in range(0,nmain):\n        tau = random.uniform(0.2, 0.8)\n        player1 = random.randint(0, nmain-1)\n        player2 = random.randint(0, nmain-1)\n\n        new_player = np.clip(league_main[winner][i] + tau*(league_main[0][0] - league_main[winner][player1]), lower_bound, upper_bound)\n        new_fitness = CostFunction(new_player)\n        evals_competition += 1\n\n        if new_fitness < fitness_main[winner][i]:\n            league_main[winner][i] = new_player\n            fitness_main[winner][i] = new_fitness\n        else:\n            new_player = np.clip(league_main[winner][i] +  tau*(league_main[winner][0] - league_main[winner][player1]), lower_bound, upper_bound)\n            new_fitness = CostFunction(new_player)\n            evals_competition += 1\n\n            if new_fitness < fitness_main[winner][i]:\n                league_main[winner][i] = new_player\n                fitness_main[winner][i] = new_fitness\n            else:\n                new_player = np.clip(league_main[winner][i] +  tau*(league_main[winner][player2] - league_main[winner][player1]), lower_bound, upper_bound)\n                new_fitness = CostFunction(new_player)\n                evals_competition += 1\n\n                if new_fitness < fitness_main[winner][i]:\n                    league_main[winner][i] = new_player\n                    fitness_main[winner][i] = new_fitness\n\n    return league_main, fitness_main, evals_competition\n'"
SLC/LoserFunction.py,12,"b""import numpy as np\nimport math\n\ndef LoserFunction(CostFunction, loser, league_main, fitness_main, league_subs, fitness_subs, mutation_rate, mutation_probability, domain, evals_competition):\n\n    nmain,dim = league_main.shape[1:]\n    nsubs = league_subs.shape[1]\n    lower_bound, upper_bound = domain\n\n    # Player that are being mutated are selected from a permutation of the loser team\n    main_selected = np.random.permutation(np.arange(nmain))[0:3]\n\n    # Number of mutations that will affect the selected players (at least 1, due to the ceil function)\n    num_mutations = math.ceil(mutation_probability*dim)\n\n    for i in range(3):\n        # Components mutated are different for each player\n        components_mutated = np.random.permutation(np.arange(dim))[0:num_mutations]\n\n        # Array with the mutations that will be applied to each component\n        mutations = np.random.uniform(-1,1,num_mutations)\n\n        # If the array is not copied intentionally, it will not be possible to check\n        # the 'former' player after being mutated\n        mutated_player = np.copy(league_main[loser][main_selected[i]])\n        mutated_player[components_mutated] += mutation_rate * mutations\n\n        # Mutated players must be clipped into lower and upper bounds\n        mutated_player = np.clip(mutated_player, lower_bound, upper_bound)\n\n        # Fitness evaluation of the mutated players\n        mutated_fitness = CostFunction(mutated_player)\n        evals_competition += 1\n\n        # If any mutated player is better than its former self, it is now replaced\n        if mutated_fitness < fitness_main[loser][main_selected[i]]:\n            league_main[loser][main_selected[i]] = mutated_player\n            fitness_main[loser][main_selected[i]] = mutated_fitness\n\n\n    # Crossover between subs players of the loser team\n    new_mutations = [None for _ in range(2*nsubs)]\n    new_fitness = [None for _ in range(2*nsubs)]\n\n    for i in range(nsubs):\n        # 2 random subs players are main_selected\n        subs_selected = np.random.permutation(np.arange(nsubs))[0:2]\n\n        # Alpha array that will affect the combination of the solutions\n        alpha = np.random.uniform(0,1,dim)\n\n        # 2 new players are generated combining both selected players with alpha weights\n        new_mutations[i*2] = np.clip(alpha*league_subs[loser][subs_selected[0]] + (1-alpha)*league_subs[loser][subs_selected[1]], lower_bound, upper_bound)\n        new_mutations[(i*2)+1] = np.clip(alpha*league_subs[loser][subs_selected[1]] + (1-alpha)*league_subs[loser][subs_selected[0]], lower_bound, upper_bound)\n\n        new_fitness[i*2] = CostFunction(new_mutations[i*2])\n        new_fitness[(i*2)+1] = CostFunction(new_mutations[(i*2)+1])\n        evals_competition += 2\n\n    # All players are gathered, and then they will be reordered and worst players are left out\n    all_players = np.concatenate((league_main[loser], league_subs[loser], new_mutations))\n    all_fitness = np.concatenate((fitness_main[loser], fitness_subs[loser], new_fitness))\n\n    # Players are reordered and reassigned the same as in Takhsis function\n    order = np.argsort(all_fitness)\n    all_players = all_players[order]\n    all_fitness = all_fitness[order]\n\n    league_main[loser] = all_players[0:nmain]\n    fitness_main[loser] = all_fitness[0:nmain]\n    league_subs[loser] = all_players[nmain:(nmain+nsubs)]\n    fitness_subs[loser] = all_fitness[nmain:(nmain+nsubs)]\n\n    return league_main, fitness_main, league_subs, fitness_subs, evals_competition\n"""
SLC/ProbabilityHost.py,2,"b'import numpy as np\nimport random\n\ndef ProbabilityHost(i, j, league_main, fitness_main):\n\n    icost = np.mean(fitness_main[i])\n    jcost = np.mean(fitness_main[j])\n\n    phost = icost/(icost+jcost)\n    rand = random.uniform(0,1)\n\n    if rand>phost:\n        winner = i\n        loser = j\n    else:\n        winner = j\n        loser = i\n\n    return winner, loser\n'"
SLC/Provocation.py,4,"b'import numpy as np\nimport random\n\ndef Provocation(CostFunction, winner, league_main, league_subs, fitness_subs, domain, evals_competition):\n\n    nsubs = league_subs.shape[1]\n    dim = league_subs.shape[2]\n    lower_bound, upper_bound = domain\n\n    gravity = np.mean(league_main[winner], axis=0)\n    chi_1 = random.uniform(0.9, 1)\n    chi_2 = random.uniform(0.4, 0.6)\n\n    new_player = np.clip(gravity + chi_1*(gravity - league_subs[winner][nsubs-1]), lower_bound, upper_bound)\n    new_fitness = CostFunction(new_player)\n    evals_competition += 1\n\n    if new_fitness < fitness_subs[winner][nsubs-1]:\n        league_subs[winner][nsubs-1] = new_player\n        fitness_subs[winner][nsubs-1] = new_fitness\n    else:\n        new_player = np.clip(gravity + chi_2*(league_subs[winner][nsubs-1] - gravity), lower_bound, upper_bound)\n        new_fitness = CostFunction(new_player)\n        evals_competition += 1\n\n        if new_fitness < fitness_subs[winner][nsubs-1]:\n            league_subs[winner][nsubs-1] = new_player\n            fitness_subs[winner][nsubs-1] = new_fitness\n        else:\n            league_subs[winner][nsubs-1] = np.random.uniform(lower_bound, upper_bound, dim)\n            fitness_subs[winner][nsubs-1] = CostFunction(league_subs[winner][nsubs-1])\n            evals_competition += 1\n\n    return league_subs, fitness_subs, evals_competition\n'"
SLC/SLC.py,3,"b'# Soccer League Competition Algorithm (For Continuous Decision Variables)\n# Developed By: Naser Moosavian\n# Translated to Python By: Juanjo Sierra\n\nimport numpy as np\nfrom CreateInitialLeague import *\nfrom Competition import *\nfrom Takhsis import *\n\ndef SLC(CostFunction, max_eval=50000, dim=30, nteams=5, nmain=10, nsubs=10, lower_bound=0,\n\t\tupper_bound=10, max_it=10**8, mutation_probability=0.1, mutation_rate=0.2,\n\t\tinitial_population_lower_bound=None, initial_population_upper_bound=None):\n\n\t# Domain of the problem, tuple including lower and upper bounds\n\tdomain = (lower_bound, upper_bound)\n\tinitial_domain = (initial_population_lower_bound, initial_population_upper_bound)\n\n\t# Creation of the initial league\n\tleague_main,league_subs,fitness_main,fitness_subs,initial_evals = CreateInitialLeague(CostFunction,\n\t\t\t\tnteams, nmain, nsubs, dim, domain, initial_domain)\n\n\t# Starting number of evaluations\n\tneval = initial_evals\n\n\tevaluations_marker = 0\n\tevaluation_marks = np.array([])\n\n\t# Seasons keep on launching until \'max_it\' seasons have been played, or until \'neval\' reaches number of Cost\n\t# Function evaluations that was indicated as a ceiling parameter\n\tfor it in range(0,max_it):\n\t\tleague_main,league_subs,fitness_main,fitness_subs,evals_competition = Competition(CostFunction,\n\t\t\t\t\tleague_main,league_subs,fitness_main,fitness_subs,domain,mutation_rate,mutation_probability)\n\t\tneval += evals_competition\n\t\tleague_main,league_subs,fitness_main,fitness_subs = Takhsis(league_main,league_subs,fitness_main,fitness_subs)\n\n\t\t# print(""Season {:4}, best solution: {:e}"".format(it, fitness_main[0][0]))\n\t\t# print(""\\tNumber of evaluations: {}"".format(neval))\n\n\t\tif neval >= evaluations_marker:\n\t\t\tevaluation_marks = np.insert(evaluation_marks, len(evaluation_marks), fitness_main[0][0])\n\t\t\tevaluations_marker += max_eval / 10\n\n\t\tif neval > max_eval:\n\t\t\tbreak\n\n\treturn np.append(evaluation_marks, fitness_main[0][0])\n'"
SLC/SLCbenchmark10-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f1, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f6, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f14, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f15, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f16, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark10-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f2, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-10-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f7, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-999999, upper_bound=999999,\n        initial_population_lower_bound=0, initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f13, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f17, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f18, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark10-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f3, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-10-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f8, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f11, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f19, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f20, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark10-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f4, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-10-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f9, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f12, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f21, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f22, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark10-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f5, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-10-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f10, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f23, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f24, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f25, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-10, upper_bound=10,\n        initial_population_lower_bound=2, initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-10-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-10-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark30-1.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f1, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-1.txt"", ""w"") as file:\n        print(""F1: Shifted Sphere Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-1.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n\n    np.random.seed(10)   \n    \n    f6 = optproblems.cec2005.F6(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f6, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-6.txt"", ""w"") as file:\n        print(""F6: Shifted Rosenbrock\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-6.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f14, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-14.txt"", ""w"") as file:\n        print(""F14: Shifted Rotated Expanded Scaffer\'s F6"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-14.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f15, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-15.txt"", ""w"") as file:\n        print(""F15: Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-15.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f16 = optproblems.cec2005.F16(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f16, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-16.txt"", ""w"") as file:\n        print(""F16: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-16.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark30-2.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f2 = optproblems.cec2005.F2(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f2, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-2.txt"", ""w"") as file:\n        print(""F2: Shifted Schwefel\'s Problem 1.2"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-30-2.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f7 = optproblems.cec2005.F7(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f7, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-999999, upper_bound=999999,\n        initial_population_lower_bound=0, initial_population_upper_bound=600) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-7.txt"", ""w"") as file:\n        print(""F7: Shifted Rotated Griewank\'s Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-7.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f13 = optproblems.cec2005.F13(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f13, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-3, upper_bound=1) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-13.txt"", ""w"") as file:\n        print(""F13: Expanded Extended Griewank\'s plus Rosenbrock\'s Function (F8F2)"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-13.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f17 = optproblems.cec2005.F17(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f17, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-17.txt"", ""w"") as file:\n        print(""F17: Rotated Hybrid Composition Function with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-17.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f18 = optproblems.cec2005.F18(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f18, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-18.txt"", ""w"") as file:\n        print(""F18: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-18.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark30-3.py,20,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f3 = optproblems.cec2005.F3(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f3, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-3.txt"", ""w"") as file:\n        print(""F3: Shifted Rotated High Conditioned Elliptic Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-30-3.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f8 = optproblems.cec2005.F8(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f8, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-32, upper_bound=32) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-8.txt"", ""w"") as file:\n        print(""F8: Shifted Rotated Ackley\'s Function with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-8.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f11 = optproblems.cec2005.F11(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f11, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-0.5, upper_bound=0.5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-11.txt"", ""w"") as file:\n        print(""F11: Shifted Rotated Weierstrass Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-11.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f19 = optproblems.cec2005.F19(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f19, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-19.txt"", ""w"") as file:\n        print(""F19: Rotated Hybrid Composition Function with a Narrow Basin for the Global Optimum"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-19.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f20 = optproblems.cec2005.F20(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f20, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-20.txt"", ""w"") as file:\n        print(""F20: Rotated Hybrid Composition Function with the Global Optimum on the Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-20.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark30-4.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f4 = optproblems.cec2005.F4(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f4, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-4.txt"", ""w"") as file:\n        print(""F4: Shifted Schwefel\'s Problem 1.2 with Noise in Fitness"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergence-30-4.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f9 = optproblems.cec2005.F9(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f9, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-9.txt"", ""w"") as file:\n        print(""F9: Shifted Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-9.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f12 = optproblems.cec2005.F12(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f12, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-12.txt"", ""w"") as file:\n        print(""F12: Schwefel\'s Problem 2.13"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-12.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f21 = optproblems.cec2005.F21(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f21, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-21.txt"", ""w"") as file:\n        print(""F21: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-21.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f22 = optproblems.cec2005.F22(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f22, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-results-30-22.txt"", ""w"") as file:\n        print(""F22: Rotated Hybrid Composition Function with High Condition Number Matrix"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergence-30-22.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCbenchmark30-5.py,21,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\nimport os\n\nif __name__ == ""__main__"":\n    dim = 30\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probability = 0.1\n    mutation_rate = 0.2\n\n    if not os.path.exists(\'results\'):\n        os.makedirs(\'results\')\n\n    if not os.path.exists(\'convergence\'):\n        os.makedirs(\'convergence\')\n\n    np.random.seed(10)\n\n    f5 = optproblems.cec2005.F5(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f5, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-resultsd-30-5.txt"", ""w"") as file:\n        print(""F5: Schwefel\'s Problem 2.6 with Global Optimum on Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n    with open(""convergence/SLC-convergenced-30-5.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)   \n    \n    f10 = optproblems.cec2005.F10(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f10, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-resultsd-30-10.txt"", ""w"") as file:\n        print(""F10: Shifted Rotated Rastrigin\'s Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergenced-30-10.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f23 = optproblems.cec2005.F23(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f23, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-np.pi, upper_bound=np.pi) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-resultsd-30-23.txt"", ""w"") as file:\n        print(""F23: Non-Continuous Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergenced-30-23.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f24 = optproblems.cec2005.F24(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f24, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-resultsd-30-24.txt"", ""w"") as file:\n        print(""F24: Rotated Hybrid Composition Function"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergenced-30-24.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n\n    np.random.seed(10)\n\n    f25 = optproblems.cec2005.F25(dim)\n\n    time1 = time.time()\n    results = np.array([SLC(f25, dim=dim, max_eval=evaluations, nteams=teams,\n        nmain=main_players, nsubs=sub_players, mutation_probability=mutation_probability,\n        mutation_rate=mutation_rate, lower_bound=-10, upper_bound=10,\n        initial_population_lower_bound=2, initial_population_upper_bound=5) for _ in range(repeats)])\n    total_time = time.time() - time1\n\n    means = results.mean(axis=0)\n    solutions = results[:,-1]\n    mean_best = means[-1]\n    min_sol = np.min(solutions)\n    max_sol = np.max(solutions)\n    marks = means[0:-1]\n\n    with open(""results/SLC-resultsd-30-25.txt"", ""w"") as file:\n        print(""F25: Rotated Hybrid Composition Function without Bounds"", file=file)\n        print(""Min\\t Max\\t Mean\\t Mean time"", file=file)\n        print(""_______________________________________________"", file=file)\n        print(""{} {} {} {}"".format(min_sol, max_sol, mean_best, total_time / repeats), file=file)\n\n\n    with open(""convergence/SLC-convergenced-30-25.csv"", ""w"") as file:\n        for i in range(len(marks)):\n            print(""{},{}"".format(10000*i, marks[i]), file=file)\n'"
SLC/SLCparameters.py,12,"b'import optproblems.cec2005\nimport numpy as np\nimport time\nfrom SLC import *\n\nif __name__ == ""__main__"":\n    dim = 10\n    repeats = 10\n    evaluations = 10000*dim\n    teams = 5\n    main_players = 3\n    sub_players = 3\n    mutation_probabilities = [0.05,0.1,0.2]\n    mutation_rates = [0.1,0.2,0.3]\n\n    np.random.seed(10)\n\n    f1 = optproblems.cec2005.F1(dim)\n    print(""F1: Shifted Sphere Function\\n"")\n\n    for mprobability in mutation_probabilities:\n        for mrate in mutation_rates:\n            time1 = time.time()\n            results = np.array([SLC(f1, dim=dim, max_eval=evaluations, nteams=teams,\n                nmain=main_players, nsubs=sub_players, mutation_probability=mprobability,\n                mutation_rate=mrate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Mutation probability: {}\\tMutation rate: {}"".format(mprobability, mrate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f6 = optproblems.cec2005.F6(dim)\n    print(""F6: Shifted Rosenbrock\xe2\x80\x99s Function\\n"")\n\n    for mprobability in mutation_probabilities:\n        for mrate in mutation_rates:\n            time1 = time.time()\n            results = np.array([SLC(f6, dim=dim, max_eval=evaluations, nteams=teams,\n                nmain=main_players, nsubs=sub_players, mutation_probability=mprobability,\n                mutation_rate=mrate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Mutation probability: {}\\tMutation rate: {}"".format(mprobability, mrate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f14 = optproblems.cec2005.F14(dim)\n    print(""F14: Shifted Rotated Expanded Scaffer\xe2\x80\x99s F6\\n"")\n\n    for mprobability in mutation_probabilities:\n        for mrate in mutation_rates:\n            time1 = time.time()\n            results = np.array([SLC(f14, dim=dim, max_eval=evaluations, nteams=teams,\n                nmain=main_players, nsubs=sub_players, mutation_probability=mprobability,\n                mutation_rate=mrate, lower_bound=-100, upper_bound=100) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Mutation probability: {}\\tMutation rate: {}"".format(mprobability, mrate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")\n\n    print(""###############################################"")\n\n    np.random.seed(10)\n\n    f15 = optproblems.cec2005.F15(dim)\n    print(""F15: Hybrid Composition Function\\n"")\n\n    for mprobability in mutation_probabilities:\n        for mrate in mutation_rates:\n            time1 = time.time()\n            results = np.array([SLC(f15, dim=dim, max_eval=evaluations, nteams=teams,\n                nmain=main_players, nsubs=sub_players, mutation_probability=mprobability,\n                mutation_rate=mrate, lower_bound=-5, upper_bound=5) for _ in range(repeats)])\n            total_time = time.time() - time1\n            print(""Mutation probability: {}\\tMutation rate: {}"".format(mprobability, mrate))\n            print(""Min: {:e}\\nMax: {:e}\\nMean: {:e}\\nMean time: {:5f} sec"".format(np.min(results), np.max(results), np.mean(results), total_time / repeats))\n            print(""_______________________________________________"")'"
SLC/Takhsis.py,5,"b'import numpy as np\n\n# Reorders the league and assigns best players to first team (main and subs) and so on.\ndef Takhsis(league_main, league_subs, fitness_main, fitness_subs):\n\n    nteams, nmain, dim = league_main.shape\n    nsubs = league_subs.shape[1]\n\n    # Both league arrays are merged into a common one, as well as both fitness arrays\n    league = np.append(league_main, league_subs).reshape(nteams*(nmain+nsubs),dim)\n    fitness = np.append(fitness_main, fitness_subs)\n\n    # With the descending order of fitness given by argsort, both league and fitness arrays are reordered\n    order = np.argsort(fitness)\n    league = league[order]\n    fitness = fitness[order]\n\n    # An array of trues and falses is created for selecting which players are main and which subs players,\n    # and to assign them to their matching team\n    trues = [True for _ in range(nmain)]\n    falses = [False for _ in range(nsubs)]\n    per_team = np.append(trues, falses)\n    per_league = np.array([per_team for _ in range(nteams)]).flatten()\n\n    league_main = league[per_league].reshape(nteams,nmain,dim)\n    league_subs = league[~per_league].reshape(nteams,nsubs,dim)\n\n    # This works as well for selecting which fitness values correspond to main and subs teams\n    fitness_main = fitness[per_league].reshape(nteams,nmain)\n    fitness_subs = fitness[~per_league].reshape(nteams,nmain)\n\n    return league_main, league_subs, fitness_main, fitness_subs\n'"
