file_path,api_count,code
Jimut_Cluster.py,0,"b'from tkinter import Tk, Label, Button, Entry, StringVar, DISABLED, NORMAL, END, W, E, N, S\n# tranforming json file into a pandas dataframe library\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom math import sin, cos, sqrt, atan2, radians\nfrom pandas.io.json import json_normalize\nfrom folium.plugins import MarkerCluster\nfrom tempfile import NamedTemporaryFile\nfrom geopy.geocoders import Nominatim # module to convert an address into latitude and longitude values\nfrom IPython.core.display import HTML \nfrom IPython.display import Image\nfrom datetime import datetime\nfrom tkinter import *\nimport tkinter as tk\nimport pandas as pd # library for data analsysis\nimport numpy as np # library to handle data in a vectorized manner\nimport subprocess\nimport webbrowser\nimport requests # library to handle requests\nimport argparse\nimport random # library for random number generation\nimport folium # plotting library\nimport json\nimport os\n\n\ndef Jimut_cluster(map_data):\n    import folium # plotting library\n    """"""\n    Takes in :=>\n    map_data = [(""Meat"",""Khasi"",22.569098,88.366418),\n            (""Meat"",""Chasi"",22.562298,88.376218),\n            (""Tea"",""My Tea"",22.582298,88.367218),\n            (""Museum"",""museum1"",22.570298,88.352218),\n            (""Museum"",""museum2"",22.492298,88.362218),\n            (""Museum"",""museum3"",22.592298,88.307218),\n            (""Chinese Res"",""Indo China"",22.542298,88.397218),\n            (""Thai Res"",""My Thai"",22.535298,88.397218),\n            (""Thai Res"",""Thaism"",22.535298,88.387218),\n            (""Thai Res"",""Nilu Thai"",22.538298,88.396218),\n            (""Airport"",""NSCB"",22.338298,88.333218),\n            (""Fishery"",""DODO Fishery"",22.738298,88.696218),\n            (""Motel"",""Baloo\'s Dhaba"",22.608298,88.437218)\n           ]\n    Outputs=> Map\n    """"""\n\n    \n    # approximate radius of earth in km\n    R = 6373.0\n\n    def ret_dist(lat1,lon1,lat2,lon2):\n        lat1 = radians(lat1)\n        lon1 = radians(lon1)\n        lat2 = radians(lat2)\n        lon2 = radians(lon2)\n        dlon = lon2 - lon1\n        dlat = lat2 - lat1\n        a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n        c = 2 * atan2(sqrt(a), sqrt(1 - a))\n        distance = R * c\n        #print(""Result:"", distance)\n        #print(""Should be:"", 278.546, ""km"")\n        return distance\n    string_gen = ""0123456789abcdef""\n    def get_random_col():\n        # unnecessary stuffs to make the visualization cool\n        ret_str = ""#""\n        for i in range(6):\n            ret_str += random.choice(string_gen)\n        return ret_str\n\n    latitude =  22.569098\n    longitude = 88.366418\n\n    MAP = folium.Map(location=[latitude, longitude],tiles=""Stamen Toner"", zoom_start=11)\n\n    name=map_data[0][0]\n\n    full_tree = []\n    data_cate = []\n    OVER_COL = str(get_random_col())\n    FILL_COL = str(get_random_col())\n    for item in map_data:\n        lat = item[2]\n        lng = item[3]\n        #print(item,"" => "")\n        if(item[0]!=name):\n            OVER_COL = str(get_random_col())\n            FILL_COL = str(get_random_col())\n            full_tree.append([name,data_cate])\n            name=item[0]\n            data_cate=[]\n            #print(""got into first check"")\n        if(item[0]==name):\n            data_cate.append([item[1],lat,lng])\n            #print(""got into 2nd check"")\n        label = ""cat : {}, Name : {}"".format(item[0],item[1])\n        folium.CircleMarker(\n                            [lat, lng],\n                            radius=5,\n                            popup=label,\n                            color=OVER_COL,\n                            fill=True,\n                            fill_color=FILL_COL,\n                            fill_opacity=0.7).add_to(MAP)\n    full_tree.append((name,data_cate))\n    #MAP\n    import pandas as pd \n\n    distance_api = []\n    # for i in map_data:\n    #     print(i[0],end="" "")\n    # print()\n    index_mat = []\n    for i in map_data:\n        lis = []\n        index_mat.append(str(i[0]+""_""+i[1]))\n        for j in map_data:\n\n            #print(i[2],i[3],"" "",j[2],j[3],end="""")\n            #distance_api.append([[i[2],i[3]],[j[2],j[3]],[ret_dist(i[2],i[3],j[2],j[3])]])\n            lis.append(ret_dist(i[2],i[3],j[2],j[3]))\n            #distance_api[([i[2],i[3])][([j[2],j[3]])] = ret_dist(i[2],i[3],j[2],j[3])\n            #distance_api[i[1]][j[1]] = ret_dist(i[2],i[3],j[2],j[3])\n            p1=[i[2],i[3]]\n            p2=[j[2],j[3]]\n            #print(DataFrame(ret_dist(i[2],i[3],j[2],j[3]),end=""  ""))\n            folium.PolyLine(locations=[p1, p2], color=\'blue\',weight=0.5,opacity=1).add_to(MAP)\n        distance_api.append(lis)\n        #print()\n    #print(distance_api)\n    #MAP\n    list_dist_final = []\n\n    for item in full_tree:\n        add_dist = 0\n        #print(item[0])\n        for k in item[1:]:\n            for var in k:\n                name_ =  var[0]\n                lat_ = var[1]\n                lon_ = var[2]\n                #print(""POI => "",name_,"" "",lat_,"" "",lon_)\n                # sub\n\n                for item_ in full_tree:\n                    if(item_[0]!=item[0]):\n                        for k_ in item_[1:]:\n                            for var_ in k_:\n                                name__ =  var_[0]\n                                lat__ = var_[1]\n                                lon__ = var_[2]\n                                #print(name__,"" "",lat__,"" "",lon__,end="""")\n                                dis = ret_dist(lat_,lon_,lat__,lon__)\n                                #print("" dist => "",dis)\n                                add_dist += dis\n                #print(""ADD DIST =====> "",add_dist)\n                list_dist_final.append([item[0],name_,add_dist,[lat_,lon_]])\n        \n    #print(list_dist_final)\n    # getting unique categories\n    name_it = list_dist_final[0][0]\n    min_ = list_dist_final[0][2]\n\n\n    fin_opt_list = []\n    for item in list_dist_final:\n        if(name_it==item[0]):\n            if(min_>=item[2]):\n                cat_op = item[0]\n                min_ = item[2]\n                op_name = item[1]\n                lat_lon = item[3:]\n        if(name_it!=item[0]):\n            fin_opt_list.append([cat_op,min_,op_name,lat_lon])\n            min_ = item[2]\n            name_it = item[0]\n            cat_op = item[0]\n            op_name = item[1]\n            lat_lon = item[3:]\n    fin_opt_list.append([cat_op,min_,op_name,lat_lon])\n    #print(fin_opt_list)\n    import pandas as pd \n\n    latitude =  22.569098\n    longitude = 88.366418\n\n    F_MAP = folium.Map(location=[latitude, longitude],tiles=""Stamen Toner"", zoom_start=11)\n    for i in fin_opt_list:\n        for j in fin_opt_list:\n            p1 = i[3]\n            p2 = j[3]\n            #print(p1[0])\n            #print(p2[0])\n            folium.PolyLine(locations=[p1[0], p2[0]], color=\'red\',weight=1.5,opacity=1).add_to(F_MAP)\n    #F_MAP\n    name=map_data[0][0]\n    for item in map_data:\n        lat = item[2]\n        lng = item[3]\n        #print(item,"" => "")\n        if(item[0]!=name):\n            OVER_COL = str(get_random_col())\n            FILL_COL = str(get_random_col())\n            name = item[0]\n        label = ""cat : {}, Name : {}"".format(item[0],item[1])\n        folium.CircleMarker(\n                            [lat, lng],\n                            radius=5,\n                            popup=label,\n                            color=OVER_COL,\n                            fill=True,\n                            fill_color=FILL_COL,\n                            fill_opacity=0.7).add_to(F_MAP)\n    print(""DONE!"")\n    return F_MAP'"
setup.py,0,"b'from setuptools import setup\nimport os\ndef read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\nif __name__ == \'__main__\':\n    setup(\n        name = \'wisp\',\n        version=""0.0.8-beta"",\n        description = \'A preference based location finder app\',\n        author = \'Jimut Bahan Pal\',\n        author_email = \'paljimutbahan@gmail.com\',\n        maintainer = \'Jimut Bahan Pal\',\n        maintainer_email = \'paljimutbahan@gmail.com\',\n        url = \'\',\n        license = \'GPLv2+\',\n        platforms = \'Linux\',\n        py_modules = [\'wisp\'],\n        entry_points = {\n            \'console_scripts\': [\'wisp = wisp:main\'],\n        },\n        include_package_data = True,\n        install_requires = [\n            \'requests\',\n            \'datetime\',\n            \'IPython\',\n            \'pandas\',\n            \'folium\',\n            \'geopy\',     \n            \'numpy\',\n            \'wget\',\n            \'pip\'\n        ],\n        keywords = \'Preference, location, wisp, requests, html, json, numpy, pandas, software, tkinter, folium, geopy, lat lon, wget, Ipython, location cluster, KNN, Machine learning, clustering\',\n        classifiers = [\n                \'Development Status :: 0.0.8 - Beta\',\n                \'Environment :: Console\',\n                \'Intended Audience :: End Users/Desktop\',\n                \'Intended Audience :: System Administrators\',\n                \'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)\',\n                \'Operating System :: Manjaro\',\n                \'Programming Language :: Python :: 3.7.2\',\n                \'Topic :: Internet :: WWW/HTTP\',\n                \'Topic :: Internet :: WWW/HTTP :: Indexing/Search\'\n                ],\n)\n'"
wisp.py,0,"b'""""""\n#   Copyright (c) 2019, Jimut Bahan Pal. All Rights Reserved.\n#\n#   Please refer to the GNU GENERAL PUBLIC LICENSE for more.\n#\n#   This is the application (probably basic) to find the location (almost any) in any Country \n#   according to the choices of your preference. Uses Foursquare API to get the data (geojson),\n#   also uses tkinter GUI for accepting data. Please provide the Access key for the API\n#   if bychance not given! This then creates a custom-made http server to visualise the locations\n#   in a web browser, because Folium (leaflet.js) doesn\'t work in GUI or Terminal.\n#   \n#   Caution: Please don\'t blame me if this doesn\'t works, cause the data may not be present for \n#            some location, since everyone will use free services of foursquare API.\n#\n#   e-mail : jimutbahanpal@yahoo.com\n#   website : https://jimut123.github.io\n#   Created for the purpose of final year project! :=> Almost data visualization project!\n#   \n#   Dated : 10-02-2019\n""""""\n\n__version__ = ""0.0.8-beta""\n__author__ = ""Jimut Bahan Pal <jimutbahanpal@yahoo.com>""\n\nfrom tkinter import Tk, Label, Button, Entry, StringVar, DISABLED, NORMAL, END, W, E, N, S\n# tranforming json file into a pandas dataframe library\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom pandas.io.json import json_normalize\nfrom folium.plugins import MarkerCluster\nfrom tempfile import NamedTemporaryFile\nfrom geopy.geocoders import Nominatim # module to convert an address into latitude and longitude values\nfrom IPython.core.display import HTML \nfrom IPython.display import Image\nfrom datetime import datetime\nfrom tkinter import *\nimport tkinter as tk\nimport pandas as pd # library for data analsysis\nimport numpy as np # library to handle data in a vectorized manner\nimport subprocess\nimport webbrowser\nimport requests # library to handle requests\nimport argparse\nimport random # library for random number generation\nimport folium # plotting library\nimport json\nimport os\n\n""""""\nThe arguments that are provided to the application\n""""""\n\nparser = argparse.ArgumentParser()\nparser.add_argument(""-q"",""--quiet"", help=""will not display anything in the terminal"",\n                    action=""store_true"")\nparser.add_argument(""-t"",""--theme"", help=""to select theme [1] classic [2] light [3] dark"",choices=[1, 2, 3],\n                    type=int)\nparser.add_argument(""-v"",""-V"",""--version"", help=""displays version"",\n                    action=""store_true"")\nargs = parser.parse_args()\n\nif args.version:\n    print(""version 0.0.8-beta Jimut (TM)"")\n    exit(2)\nelse:\n    if not args.quiet:\n        # the starting of the application dialogue\n        print(\'Starting application ... Necessary libraries imported. \\n\\n JIMUT (TM)\')\n    \n    """"""\n        The 3 themes for WISP application.\n    """"""\n    if args.theme == None or args.theme == 1:\n        # print(""USING DEFAULT THEME"")\n        # defining JIMUT\'s classic theme for wisp : \n        color_bg_app = ""#ffd700""\n        color_msg = ""#ffd700""\n        color_msg_fg = ""#000000""\n        color_dropdown_fg = ""#000000""\n        color_dropdown = ""#cfc611""\n        color_savemap_label = ""#ffd700""\n        color_savemap_label_fg = ""#000000""\n        color_label_select_map_fg = ""#000000""\n        color_label_select_map = ""#ffd700""\n        color_save_map_entry = ""#ffffff""\n        color_save_map_entry_fg = ""#000000""\n        color_entry_default = ""#ffffff""\n        color_entry_default_fg = ""#000000""\n        color_use_def_sec_button = ""#ffff00""\n        color_use_def_sec_button_fg = ""#000000""\n        color_submit_button = ""#ffff00""\n        color_submit_button_fg = ""#000000""\n        color_preference_label = ""#ffd700""\n        color_preference_label_fg = ""#000000""\n        color_preference_canvas = ""#ffd700""\n        color_preference_entry = ""#ffffff""\n        color_preference_entry_fg = ""#000000""\n        color_show_map_button = ""#ffff00""\n        color_show_map_button_fg = ""#000000""\n        color_pref_scrollbar = ""#8b4513""\n\n    elif args.theme == 2:\n        #print(""THEME : "",args.theme)\n        # defining JIMUT\'s light theme for wisp: \n        color_bg_app = ""#7fffd4""\n        color_msg = ""#7fffd4""\n        color_msg_fg = ""#000000""\n        color_dropdown_fg = ""#000000""\n        color_dropdown = ""#7dcea0""\n        color_savemap_label = ""#7fffd4""\n        color_savemap_label_fg = ""#000000""\n        color_label_select_map_fg = ""#000000""\n        color_label_select_map = ""#7fffd4""\n        color_save_map_entry = ""#a1caf1""\n        color_save_map_entry_fg = ""#000000""\n        color_entry_default = ""#a1caf1""\n        color_entry_default_fg = ""#000000""\n        color_use_def_sec_button = ""#88d8c0""\n        color_use_def_sec_button_fg = ""#000000""\n        color_submit_button = ""#00cc99""\n        color_submit_button_fg = ""#000000""\n        color_preference_label = ""#afe4de""\n        color_preference_label_fg = ""#000000""\n        color_preference_canvas = ""#afe4de""\n        color_preference_entry = ""#bcd4e6""\n        color_preference_entry_fg = ""#000000""\n        color_show_map_button = ""#00fa9a""\n        color_show_map_button_fg = ""#000000""\n        color_pref_scrollbar = ""#50c878""\n\n    elif args.theme == 3:\n        # defining JIMUT\'s dark theme for wisp: \n        color_bg_app = ""#253529""\n        color_msg = ""#253529""\n        color_msg_fg = ""#fefdfa""\n        color_dropdown_fg = ""#fefdfa""\n        color_dropdown = ""#07853b""\n        color_savemap_label = ""#253529""\n        color_savemap_label_fg = ""#fefdfa""\n        color_label_select_map_fg = ""#fefdfa""\n        color_label_select_map = ""#253529""\n        color_save_map_entry = ""#000000""\n        color_save_map_entry_fg = ""#fefdfa""\n        color_entry_default = ""#000000""\n        color_entry_default_fg = ""#fefdfa""\n        color_use_def_sec_button = ""#0a1195""\n        color_use_def_sec_button_fg = ""#fefdfa""\n        color_submit_button = ""#0a1195""\n        color_submit_button_fg = ""#fefdfa""\n        color_preference_label = ""#1e4d2b""\n        color_preference_label_fg = ""#fefdfa""\n        color_preference_canvas = ""#1e4d2b""\n        color_preference_entry = ""#000000""\n        color_preference_entry_fg = ""#fefdfa""\n        color_show_map_button = ""#0a1195""\n        color_show_map_button_fg = ""#fefdfa""\n        color_pref_scrollbar = ""#50c878""\n\n\n    def_sec_dummy = 0\n\n    # utils function for CLI\n\n    def get_json_secrets():\n        # this reads the secrets from the secret.txt file and returns them in tuple format!\n        try:\n            with open(\'secrets.txt\', \'r\') as f:\n                array = json.load(f)\n            if not args.quiet:\n                print(array)\n            # returns a tuple containing client id and client secret\n            return str(array[\'client_id\']),str(array[\'client_secret\'])\n        except:\n            if not args.quiet:\n                print(""NO SECRETS PRESENT, please enter it in text file secrets.txt ...\\n Else use the GUI to input secrets!"")\n            \n\n    # returns the current time\n    def time_now():\n        format = ""1;32;40""\n        s1 = \'\'\n        time_stmp = datetime.now().isoformat(timespec=\'seconds\')\n        s1 += \'\\x1b[%sm %s \\x1b[0m\' % (format, time_stmp)\n        if not args.quiet:\n            print(""running app : {} "".format(s1),end="""")\n\n\n    """"""\n    The banner theme for WISP application\n    """"""\n    def banner_wisp():\n        format = ""1;33;40""\n        s1 = \'\'\n        \n        banner = """"""\n    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x97    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x97\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97       \n    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x91    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x9d\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x95\x90\xe2\x95\x90\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97       \n    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x91 \xe2\x96\x88\xe2\x95\x97 \xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x95\x9d        \n    \xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x97\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x95\x9a\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x9d       \n    \xe2\x95\x9a\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x94\xe2\x95\x9d\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91\xe2\x96\x88\xe2\x96\x88\xe2\x95\x91                 \n    \xe2\x95\x9a\xe2\x95\x90\xe2\x95\x90\xe2\x95\x9d\xe2\x95\x9a\xe2\x95\x90\xe2\x95\x90\xe2\x95\x9d \xe2\x95\x9a\xe2\x95\x90\xe2\x95\x9d\xe2\x95\x9a\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x90\xe2\x95\x9d\xe2\x95\x9a\xe2\x95\x90\xe2\x95\x9d  \t0.0.8-beta \n                                JIMUT(TM)  \n            """"""\n        s1 += \'\\x1b[%sm %s \\x1b[0m\' % (format, banner)\n        if not args.quiet:\n            print(s1)\n\n    """"""\n    The main class for the WISP application.\n    Contains the GUI and the Custom made HTTP map generator as different modules.\n    """"""\n    class guiProj:\n        """"""\n        The actual app class\n        """"""\n        def __init__(self, master):\n            """"""\n            The constructor for creating the GUI of the app using tkinter!\n            """"""\n            banner_wisp()\n            # this is creating the padding for the input/label text etc.\n            for i in range(100):\n                master.columnconfigure(i, pad=3)    \n                master.rowconfigure(i, pad=3)\n            self.master = master\n            master.title(""WISP"")\n            # probably the do-able geometry\n            master.geometry(""430x460"")\n\n            # Shortened version of the code!\n            """"""\n            This part creates the GUI for the upper labels and text box of the GUI\n            """"""\n            msg_s = [""    CLIENT ID    "",""    FOURSQUARE SECRET    "",""    LOC/CITY    "",""    RADIUS (in meters) >= 1000    "",""    NO. OF PREFERENCE    ""]\n            i_var = 0\n\n            # just initializing!\n            self.msg_list = [None]*int(5)\n            self.text_list = [None]*int(5)\n            self.label_list = [None]*int(5)\n            self.entry_list = [None]*int(5)\n\n            # creating the basic template of the application!\n            for msg in msg_s:\n                self.msg_list[i_var] = msg\n                self.text_list[i_var] = StringVar()\n                self.text_list[i_var].set(""{}"".format(self.msg_list[i_var]))\n                self.label_list[i_var] = Label(master, textvariable=self.text_list[i_var],background=color_msg,foreground=color_msg_fg)\n                self.label_list[i_var].grid(row=i_var, column=0, columnspan=1, sticky=W+E)\n\n                self.entry_list[i_var] = Entry(master,background=color_entry_default,foreground=color_entry_default_fg)\n                self.entry_list[i_var].grid(row=i_var, column=1, columnspan=1, sticky=W+E)\n                \n                i_var += 1\n            \n            def submit_pref():\n                # this function gets called when they submit the preference!\n                get_pref_no = self.entry_list[4].get()  #to get the preference\n                # dummy preference for conditional check later\n                if get_pref_no == """":\n                    get_pref_no = 0\n                # initialising etc.\n                self.entry_pref = [None]*int(get_pref_no)\n                self.text_pref = [None]*int(get_pref_no)\n                self.pf_text = [None]*int(get_pref_no)\n                self.label_pref = [None]*int(get_pref_no)\n\n\n                def onFrameConfigure(canvas):\n                    \'\'\'Reset the scroll region to encompass the inner frame\'\'\'\n                    canvas.configure(scrollregion=canvas.bbox(""all""))\n                \n                def populate(frame):\n                    \'\'\'Put in some fake data\'\'\'\n                    # automating the boring and tedious stuffs through list\n                    # basically, takes the input for the number of preferences!\n                    for iter_ in range(int(get_pref_no)):\n                        \n                        text_str = ""{}-{} :"".format(""preference"",iter_+1)\n                        \n                        self.pf_text[iter_] = text_str\n                        # creating the label\n                        self.text_pref[iter_] = StringVar()\n                        self.text_pref[iter_].set(self.pf_text[iter_])\n                        self.label_pref[iter_] = Label(frame, textvariable=self.text_pref[iter_],background=color_preference_label,foreground=color_preference_label_fg)\n                        self.label_pref[iter_].grid(row=5+iter_+1, column=0, sticky=W+N)\n\n                        # entry widget\n                        self.entry_pref[iter_] = Entry(frame,background=color_preference_entry,foreground=color_preference_entry_fg)\n                        self.entry_pref[iter_].grid(row=5+iter_+1, column=1, sticky=W+N)\n\n                """"""\n                This part creates the GUI for the upper labels and text box of the GUI\n                """"""\n\n                canvas = tk.Canvas(master, borderwidth=0,background=color_preference_canvas)\n                \n                canvas.config(width=250, height=200)\n                \n                frame = tk.Frame(canvas,background=color_preference_canvas)\n                vsb = tk.Scrollbar(master, orient=""vertical"", command=canvas.yview, background=color_pref_scrollbar)\n                canvas.configure(yscrollcommand=vsb.set)\n\n                # for the scrollbar\n                vsb.grid(row=8, column=1,rowspan=int(get_pref_no), sticky=""nsw"")\n\n                # for the grid\n                canvas.grid(row=8,column=0,rowspan=1,sticky=""nsew"")\n                canvas.create_window((4,4), window=frame, anchor=""nw"")\n                frame.bind(""<Configure>"", lambda event, canvas=canvas: onFrameConfigure(canvas))\n                populate(frame)\n\n                # disabling the button! for one-time use!\n                self.submit_pref_buttton.configure(state=DISABLED)\n\n                # making different types of maps for more feature rich visualizations\n                MAP_TYPES = [""Mapbox Bright"",""Stamen Toner"",""Stamen Terrain"",""OpenStreetMap"",""Mapbox Control Room""]\n\n                self.label_select_map = Label(master, text=""SELECT MAP-TYPE"",foreground=color_label_select_map_fg,background=color_label_select_map)\n                self.label_select_map.grid(row=int(get_pref_no)+8,column=0,columnspan=1,sticky=W+E+N+S)\n                self.dropdown_map_select = StringVar(master)\n                self.dropdown_map_select.set(MAP_TYPES[0])\n                \n                # foreground=color_dropdown_fg,background=color_dropdown,\n                self.dropdown_menu = OptionMenu(master,self.dropdown_map_select,*MAP_TYPES)\n                # to set the color of the dropdown menu to a different color\n                self.dropdown_menu.config(foreground=color_dropdown_fg,background=color_dropdown)\n\n                self.dropdown_menu.grid(row=int(get_pref_no)+8,column=1,columnspan=1,sticky=W+E+N+S)\n                # use dropdown_map_select.get() to get the contents of this list\n\n                # now save the file\'s entry\n\n                self.save_map = Label(master, text=""SAVE MAP AS (OPTIONAL)"",background=color_savemap_label,foreground=color_savemap_label_fg)\n                self.save_map.grid(row=int(get_pref_no)+9,column=0,columnspan=1,sticky=W+E+N+S)\n\n                # for the save map entry file\n                self.save_map_entry = Entry(master,background=color_save_map_entry,foreground=color_save_map_entry_fg)\n                self.save_map_entry.grid(row=int(get_pref_no)+9,column=1,columnspan=1, sticky=W+E)\n\n                self.show_map_button = Button(master, text=""show map"",command=self.show_map,background=color_show_map_button,foreground=color_show_map_button_fg)\n                self.show_map_button.grid(row=int(get_pref_no)+10,column=1,columnspan=1, sticky=W+E)\n\n\n            def def_sec():\n                # this function sets the default secrets by reading the file secrets.txt, the secrets are stored as JSON\n\n                global def_sec_dummy\n                try:\n                    test1,test2 =get_json_secrets()\n                    def_sec_dummy = 1\n                    time_now()\n                    if not args.quiet:\n                        print(""USING DEFAULT SECRETS FOR CLIENT_ID and CLIENT_SECRET "")\n                    self.entry_list[0].insert(END, \'using default client ID\')\n                    self.entry_list[1].insert(END, \'using default client secret\')\n                    # disabling things! lol\n                    self.use_default_sec.configure(state=DISABLED)\n                except:\n                    def_sec_dummy = 0\n                    time_now()\n                    if not args.quiet:\n                        print(""PLEASE ENTER SECRETS IN secrets.txt file in the current directory!"")\n                    time_now()\n                    if not args.quiet:\n                        print(""QUITTING"")\n                    exit(4)\n                \n            # place holder gets called when we use this! (default secret thingie)\n            self.use_default_sec = Button(master, text=""use default secrets"",command=def_sec,background=color_use_def_sec_button,foreground=color_use_def_sec_button_fg)\n            self.use_default_sec.grid(row=5,column=0, sticky=W+E)\n            # again button thing\n            self.submit_pref_buttton = Button(master, text=""submit"",command=submit_pref,background=color_submit_button,foreground=color_submit_button_fg)\n            self.submit_pref_buttton.grid(row=5,column=1,columnspan=1, sticky=W+E)\n\n        \n        def show_map(self):\n            # fetching the name of the map to be save here too!\n            time_now()\n            global save_name_map\n            try:\n                save_name_map = str(self.save_map_entry.get())\n                time_now()\n                if save_name_map == """":\n                    if not args.quiet:\n                        time_now()\n                        print(""NO FILE NAME GIVEN!..\\n SO NOT SAVING!"")\n                else:\n                    if not args.quiet:\n                        print(""FILE NAME GOT !!: "",save_name_map)\n            except:\n                if not args.quiet:\n                    time_now()\n                    print(""NO FILE NAME GIVEN!..\\n SO NOT SAVING!"")\n                save_name_map=None\n\n            # To get all the values and show the map!\n            all_values = []     # has all the values that is got from the GUI\n            for item in self.entry_list:\n                all_values.append(item.get())\n            pref_list = []      # gets the preference one by one!\n            for item in self.entry_pref:\n                pref_list.append(item.get())\n            #print(all_values)\n            string_gen = ""0123456789abcdef""     # this actually generated the random hex code for colors!\n            def get_random_col():\n                # unnecessary stuffs to make the visualization cool\n                ret_str = ""#""\n                for i in range(6):\n                    ret_str += random.choice(string_gen)\n                return ret_str\n            #get_random_col()\n            global def_sec_dummy\n            if def_sec_dummy == 1:\n                # default things! lol make sure to clear them!!!!\n                # this takes the tuple returned from the get_json_secrets() function which reads secrets from secrets.txt file\n                time_now()\n                CLIENT_ID, CLIENT_SECRET = get_json_secrets()\n                \n\n            elif def_sec_dummy == 0:\n                CLIENT_ID = all_values[0]                   #input(""Enter the client ID : "") # your Foursquare ID\n                CLIENT_SECRET = all_values[1]               #input(""Enter the Foursquare secret : "") # your Foursquare Secret\n                \n            VERSION = \'20190122\'\n            LIMIT = 1000\n            address = all_values[2]                                   #input(""Enter the location/ city :"")\n            time_now()\n            if not args.quiet:\n                print(\'Your credentails:\')\n                time_now()\n                print(\'CLIENT_ID: \' + CLIENT_ID)\n                time_now()\n                print(\'CLIENT_SECRET:\' + CLIENT_SECRET)\n                time_now()\n                print(\'Location of your choice : \', address)\n\n            geolocator = Nominatim(timeout = 10)\n            try:\n                # get\'s the lat and long for a place, it is kept under try catch for safety purpose\n                location = geolocator.geocode(address)\n                latitude = location.latitude\n                longitude = location.longitude\n                if not args.quiet:\n                    time_now()\n                    print(latitude, longitude)\n            except:\n                if not args.quiet:\n                    time_now()\n                    print(""CHECK INTERNET CONNECTION!\\n ELSE YOUR NET IS NOT IN FULL 3/4G"")\n                # directly closes the application\n                exit(4)\n\n            dots_html = """"\n            RADIUS = int(all_values[3])\n            if not args.quiet:\n                time_now()\n                print(""Total preference list : "",pref_list)\n\n            # To clean the list if by chance someone has given unnecessary values or empty values or unused text entry box\n            pref_list = list(filter(None, pref_list))\n            if not args.quiet:\n                time_now()\n                print(""New pref list : "",pref_list)\n\n            map_address = folium.Map(location=[latitude, longitude], zoom_start=11)\n            marker_cluster = MarkerCluster().add_to(map_address)\n            list_df = []\n            \n\n            col_fill = []\n            col_border = []\n            for item_pref in pref_list:\n                url = \'https://api.foursquare.com/v2/venues/search?client_id={}&client_secret={}&ll={},{}&v={}&query={}&radius={}&limit={}\'.format(CLIENT_ID, CLIENT_SECRET, latitude, longitude, VERSION, item_pref, RADIUS, LIMIT)\n                try :\n                    if not args.quiet:\n                        time_now()\n                        print(""url : "",url)\n                    results = requests.get(url).json()\n                    \n                    # assign relevant part of JSON to venues\n                    venues = results[\'response\'][\'venues\']\n\n                    # tranform venues into a dataframe\n                    dataframe = json_normalize(venues)\n                    if not args.quiet:\n                        time_now()\n                        print(dataframe.head())\n                    try:\n                        # keep only columns that include venue name, and anything that is associated with location\n                        filtered_columns = [\'name\', \'categories\'] + [col for col in dataframe.columns if col.startswith(\'location.\')] + [\'id\']\n                        dataframe_filtered = dataframe.loc[:, filtered_columns]\n                    except:\n                        if not args.quiet:\n                            time_now()\n                            print(""Something went wrong!"")\n                        continue\n                    # function that extracts the category of the venue\n                    def get_category_type(row):\n                        try:\n                            categories_list = row[\'categories\']\n                        except:\n                            categories_list = row[\'venue.categories\']\n\n                        if len(categories_list) == 0:\n                            return None\n                        else:\n                            return categories_list[0][\'name\']\n\n                    # filter the category for each row\n                    try:\n                        dataframe_filtered[\'categories\'] = dataframe_filtered.apply(get_category_type, axis=1)\n                    except:\n                        if not args.quiet:\n                            time_now()\n                            print(""Something went wrong!"")\n                        continue\n\n                    # clean column names by keeping only last term\n                    dataframe_filtered.columns = [column.split(\'.\')[-1] for column in dataframe_filtered.columns]\n\n                    #dataframe_filtered.head()\n\n                    # copying it to stationary shop dataframe\n\n                    data_frame = dataframe_filtered.copy()\n                    list_df.append(data_frame)\n                except:\n                    if not args.quiet:\n                        time_now()\n                        print(""Preference : "",item_pref,"" doesn\'t exists!!!"")\n            if not args.quiet:\n                time_now()\n                print(list_df)\n            # create map latitude and longitude values\n            if not args.quiet:\n                time_now()\n                print(""MAP SELECTED :=> "",self.dropdown_map_select.get())\n            \n            MAP_FINAL = folium.Map(location=[latitude, longitude], tiles=str(self.dropdown_map_select.get()),zoom_start=11)\n            # configuration for the dafault map to be created!\n            marker_cluster = MarkerCluster().add_to(MAP_FINAL)\n            \n            for list_item in list_df:\n                FILL_COL = str(get_random_col())\n                OVER_COL = str(get_random_col())\n                col_fill.append(FILL_COL)\n                col_border.append(OVER_COL)\n\n                # Check whether the values are actually present or not!\n                # for latitudes\n                try:\n                    len_data = len(list_item[\'lat\'])\n                    if not args.quiet:\n                        time_now()\n                        print(""TOTAL DATA FETCHED"",len_data)\n                        time_now()\n                        print(list_item[\'lat\'])\n                except:\n                    #pass\n                    if not args.quiet:\n                        print(""NOT got any \'lat\' values! using default"")\n                    list_item[\'lat\'] = [None]*int(len_data)\n                \n                # for longitudes\n                try:\n                    if not args.quiet:\n                        time_now()\n                        print(""TOTAL DATA FETCHED"",len(list_item[\'lng\']))\n                        time_now()\n                        print(list_item[\'lng\'])\n                except:\n                    #pass\n                    if not args.quiet:\n                        print(""NOT got any \'lng\' values! using default"")\n                    list_item[\'lng\'] = [None]*int(len_data)\n                    if not args.quiet:\n                        time_now()\n                        print(list_item[\'lng\'])\n                \n                # for categories\n                \n                try:\n                    if not args.quiet:\n                        time_now()\n                        print(""TOTAL DATA FETCHED"",len(list_item[\'categories\']))\n                        time_now()\n                        print(list_item[\'categories\'])\n                except:\n                    #pass\n                    if not args.quiet:\n                        print(""NOT got any \'categories\' values! using default"")\n                    list_item[\'categories\'] = [None]*int(len_data)\n                    if not args.quiet:\n                        time_now()\n                        print(list_item[\'categories\'])\n                \n                # for postalCode values\n\n                try:\n                    if not args.quiet:\n                        time_now()\n                        print(""TOTAL DATA FETCHED"",len(list_item[\'postalCode\']))\n                        time_now()\n                        print(list_item[\'postalCode\'])\n                except:\n                    #pass\n                    if not args.quiet:\n                        print(""NOT got any \'postalCode\' values! using default"")\n                    list_item[\'postalCode\'] = [None]*int(len_data)\n                    if not args.quiet:\n                        time_now()\n                        print(list_item[\'postalCode\'])\n                \n                \n                for lat, lng, cat, postcode in zip(list_item[\'lat\'], list_item[\'lng\'],  list_item[\'categories\'],  list_item[\'postalCode\']):\n                    f_format = str(""POSTCODE : ""+str(postcode))\n                    s_format = str(""CATEGORY : ""+str(cat))\n                    label = \'{}, {}\'.format(f_format,s_format )\n                    label = folium.Popup(label, parse_html=True)\n                    # the circle marker is done through this way! with custom pop-ups\n                    folium.CircleMarker(\n                        [lat, lng],\n                        radius=5,\n                        popup=label,\n                        color=OVER_COL,\n                        fill=True,\n                        fill_color=FILL_COL,\n                        fill_opacity=0.7).add_to(marker_cluster)  \n                dots_html = """"\n                for var1, var2, var3 in zip(pref_list,col_fill,col_border):\n                    dots_html = dots_html + """"""\n                    &nbsp; {} &nbsp;\n                    <svg height=""10"" width=""10"">\n                    <circle cx=""5"" cy=""5"" r=""4"" stroke=""{}"" stroke-width=""3"" fill=""{}"" />\n                    </svg><br/> """""".format(str(var1),str(var3),str(var2))\n                \n                if not args.quiet:\n                    time_now()\n                    print(dots_html)\n            legend_html = """"""\n                    <center>\n                        <h1 ><i style=""color:#c6ae0d; font face=Verdana,Arial,Helvetica ""> WISP </i></h1> \n                    </center>\n                    <div style=""position: fixed; \n                    bottom: 50px; left: 50px;  \n                    border:2px solid grey; z-index:9999; font-size:14px;"">&nbsp; \n                        <b>Legend <b>\n                        <br>{}\n                    </div>\n                    <div style=""position: fixed; \n                    bottom: 50px; right: 50px;  \n                    z-index:9999; font-size:10px;\n                    ""> \n                        <b style=""color:#f90404"" style=""align: justified"">\n                            WISP <br/> \n                            version: 0.0.8-beta <br/>\n                            &copyJimut Bahan Pal <br/> \n                            Author : jimutbahanpal@yahoo.com \n                        </b>\n                    </div>\n                    <div style=""position: fixed; \n                    top: 70px; left: 50px;  \n                    z-index:9999; font-size:15px;\n                    ""> \n                        <b style=""color:#16842c"" style=""align: justified"">\n                            Location: {} <br/>\n                            Lat, Lon: {},{} <br/>\n\t\t\t                Radius: {} <br/>\n                            Date: {} <br/>\n                        </b>\n                    </div> \n                    """""".format(str(dots_html),address,latitude,longitude,RADIUS,datetime.now().isoformat(timespec=\'seconds\'))\n            time_now()\n            if not args.quiet:\n                print(legend_html)\n\n            MAP_FINAL.get_root().html.add_child(folium.Element(legend_html))\n            # setting port addr, localhost for the custom http server\n            PORT = 7000\n            HOST = \'127.0.0.1\'\n            SERVER_ADDRESS = \'{host}:{port}\'.format(host=HOST, port=PORT)\n            FULL_SERVER_ADDRESS = \'http://\' + SERVER_ADDRESS\n            # ------------------------------------------------------------------------------------------------\n            # so let\'s write a custom temporary-HTML renderer\n            def TemproraryHttpServer(page_content_type, raw_data):\n                """"""\n                A simpe, temprorary http web server on the pure Python 3.\n                It has features for processing pages with a XML or HTML content.\n                """"""\n\n                class HTTPServerRequestHandler(BaseHTTPRequestHandler):\n                    """"""\n                    An handler of request for the server, hosting XML-pages.\n                    """"""\n\n                    def do_GET(self):\n                        """"""Handle GET requests""""""\n\n                        # response from page\n                        self.send_response(200)\n\n                        # set up headers for pages\n                        content_type = \'text/{0}\'.format(page_content_type)\n                        self.send_header(\'Content-type\', content_type)\n                        self.end_headers()\n\n                        # writing data on a page\n                        self.wfile.write(bytes(raw_data, encoding=\'utf\'))\n\n                        return\n\n                if page_content_type not in [\'html\', \'xml\']:\n                    raise ValueError(\'This server can serve only HTML or XML pages.\')\n\n                page_content_type = page_content_type\n\n                # kill a process, hosted on a localhost:PORT\n                time_now()\n                subprocess.call([\'fuser\', \'-k\', \'{0}/tcp\'.format(PORT)])\n\n                # Started creating a temprorary http server.\n                httpd = HTTPServer((HOST, PORT), HTTPServerRequestHandler)\n\n                # run a temprorary http server\n                httpd.serve_forever()\n\n\n            def run_html_server(html_data=None):\n\n                if html_data is None:\n                    html_data = """"""\n                    <!DOCTYPE html>\n                    <html>\n                    <head>\n                    <title>Page Title</title>\n                    </head>\n                    <body>\n                    <h1>This is a Heading</h1>\n                    <p>This is a paragraph.</p>\n                    </body>\n                    </html>\n                    """"""\n\n                # open in a browser URL and see a result\n                webbrowser.open(FULL_SERVER_ADDRESS)\n\n                # run server\n                TemproraryHttpServer(\'html\', html_data)\n\n            # ------------------------------------------------------------------------------------------------\n            # now let\'s save the visualization into the temp file and render it\n            tmp = NamedTemporaryFile()\n            MAP_FINAL.save(tmp.name)\n            with open(tmp.name) as f:\n                folium_map_html = f.read()\n            global root\n            root.destroy()\n            if not args.quiet:\n                time_now()\n                print(""Destroying window!! exiting from GUI to Web - Browser"")\n\n            # to get the name of the file to be saved!\n            if save_name_map == None:\n                pass\n            else:\n                name_final = save_name_map+"".html""\n                if save_name_map==None:\n                    pass\n                else:\n                    if not args.quiet:\n                        time_now()\n                        print(""WRITING TO HTML FILE !!!"")\n                    time_now()\n                    with open(name_final, \'w\') as file_:\n                        file_.write(folium_map_html)\n            try:\n                if not args.quiet:\n                    time_now()\n                os.remove("".html"")\n                if not args.quiet:\n                    print(""CACHES REMOVED!"")\n            except:\n                if not args.quiet:\n                    time_now()\n                    print(""...CLEANING CACHES!"")\n            \n            run_html_server(folium_map_html)\n        \n\n    def main():\n        global root\n        root = Tk()\n        root.configure(background=color_bg_app)\n        # initialising the app\n        guiProj(root)\n        # goes on and on loop for tkinter!\n        root.mainloop()\n\n    if __name__ == ""__main__"":\n        main()\n'"
wisp_v2.py,0,"b'""""""\n#   Copyright (c) 2019, Jimut Bahan Pal. All Rights Reserved.\n#\n#   Please refer to the GNU GENERAL PUBLIC LICENSE for more.\n#\n#   This is the application (probably simple) to find the location (almost any) in any Country \n#   according to the choices of your preference. Uses Foursquare API to get the data (geojson).\n#   Please provide the Access key for the API, if bychance not given! This then creates a map to visualise the locations\n#   in a web browser, because Folium (leaflet.js) doesn\'t work in GUI or Terminal.\n#   \n#   Caution: Please don\'t blame me if this doesn\'t works, cause the data may not be present for \n#            some location, since everyone will use free services of foursquare API.\n#\n#   e-mail : jimutbahanpal@yahoo.com\n#   website : https://jimut123.github.io\n#   Created for the purpose of final year project! :=> Almost data visualization project!\n#   \n#   Updated == version 2.0, uses JJ-Cluster custom made algorithm.\n#   Dated : 17-11-2019\n""""""\n\n\n\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom geopy.geocoders import Nominatim # module to convert an address into latitude and longitude values\nimport requests # library to handle requests\nimport pandas as pd # library for data analsysis\nimport numpy as np # library to handle data in a vectorized manner\nimport random # library for random number generation\n# tranforming json file into a pandas dataframe library\nfrom pandas.io.json import json_normalize\nfrom IPython.core.display import HTML \nfrom IPython.display import Image \nfrom datetime import datetime\nimport webbrowser\nimport subprocess\nimport argparse\nimport folium # plotting library\nimport json\n\nprint(\'Folium installed\')\nprint(\'Libraries imported.\')\n\nCLIENT_ID = \'\' # your Foursquare ID\nCLIENT_SECRET = \'\' # your Foursquare Secret\nVERSION = \'20180604\'\nLIMIT = 30\n\ndef time_now():\n    format = ""1;32;40""\n    s1 = \'\'\n    time_stmp = datetime.now().isoformat(timespec=\'seconds\')\n    s1 += \'\\x1b[%sm %s \\x1b[0m\' % (format, time_stmp)\n   \n    print(""running app : {} "".format(s1),end="""")\n\n# this reads the secrets from the secret.txt file and returns them in tuple format!\ntry:\n    time_now()\n    print(""Fetching credentials from secrets.txt file"")\n    with open(\'secrets.txt\', \'r\') as f:\n        array = json.load(f)\n    print(\'Your credentails:\')\n\n    CLIENT_ID = str(array[\'client_id\'])\n    CLIENT_SECRET = str(array[\'client_secret\'])\n    time_now()\n    print(\'CLIENT_ID: \' + CLIENT_ID)\n    time_now()\n    print(\'CLIENT_SECRET: \' + CLIENT_SECRET)\n   \nexcept:\n    print(""NO SECRETS PRESENT, please enter it in text file secrets.txt in future...\\n "")\n    print(""create a file named as secrets.txt and put these contents ::=> "")\n    print(""""""\\\n        {\n            ""client_id"":""your client ID"",\n            ""client_secret"":""your client secret""\n        }\n        """""")\n            \naddress = input(""ENTER ADDRESS : \\n"")\ntime_now()\nradius = input(""Enter radius :\\n"")\ntime_now()\ngeolocator = Nominatim(timeout=10)\nlocation = geolocator.geocode(address)\nlatitude = location.latitude\nlongitude = location.longitude\nprint(latitude, longitude)\ndata_ice = []\nNo_Q = input(""Enter number of Queries : \\n"")\ntime_now()\nimport json\n\n\n\n\nfor i in range(int(No_Q)):\n    print(""{} "".format(i),end="""")\n    time_now()\n    search_query = input(""Enter Search Query : "")\n    \n    print(search_query + \' .... OK!\')\n\n    url = \'https://api.foursquare.com/v2/venues/search?client_id={}&client_secret={}&ll={},{}&v={}&query={}&radius={}&limit={}\'.format(CLIENT_ID, CLIENT_SECRET, latitude, longitude, VERSION, search_query, radius, LIMIT)\n    #url\n    results = requests.get(url).json()\n    item = results[\'response\'][\'venues\']\n    #print(json.dumps(item, indent=4, sort_keys=True))\n    for item_ in item:\n        #print(json.dumps(item_, indent=4, sort_keys=True))\n        name = item_[""name""]\n        cat = item_[""categories""]\n        loc = \', \'.join(item_[""location""][""formattedAddress""])\n        lat_ = item_[""location""][""lat""]\n        lon_ = item_[""location""][""lng""]\n        #add = item_[""location""]\n        #print(name)\n        #print(cat)\n        #print(loc)\n        #print(lat_,""   +   "",lon_)\n        data_ice.append((search_query,""{}\\n and Location : {}"".format(name,loc),lat_,lon_))\n\n    #print(data_ice)    \n    print(""DONE COMPLETED"")\n""""""\n\nAlgorithm:\n    \n    Initialise vertex_list\n    \n    1. Find the minimum distance for class 1 and append it to vertex list.\n    2. For every other class find min distance to vertex_list and add it to vertex_list\n    3. find the minimum distance from addition of verteces to the list and add the next node to the list\n\n""""""\n\n\n\n\nfrom math import sin, cos, sqrt, atan2, radians\nimport random # library for random number generation\nimport folium # plotting library\n\n# approximate radius of earth in km\nR = 6373.0\n\ndef ret_dist(lat1,lon1,lat2,lon2):\n    lat1 = radians(lat1)\n    lon1 = radians(lon1)\n    lat2 = radians(lat2)\n    lon2 = radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n    distance = R * c\n    #print(""Result:"", distance)\n    #print(""Should be:"", 278.546, ""km"")\n    return distance\nstring_gen = ""0123456789abcdef""\ndef get_random_col():\n    # unnecessary stuffs to make the visualization cool\n    ret_str = ""#""\n    for i in range(6):\n        ret_str += random.choice(string_gen)\n    return ret_str\n\ndef Jimut_Wisp_Cluster3_Minimum(map_data):\n    time_now()\n    print(""Select the Map types [0/1/2/3/4] and then press Enter :: "")\n    MAP_TYPES = [""Mapbox Bright"",""Stamen Toner"",""Stamen Terrain"",""OpenStreetMap"",""Mapbox Control Room""]\n    name_type = int(input(""\\n 0 - Mapbox Bright\\n 1 - Stamen Toner\\n 2 - Stamen Terrain\\n 3 - OpenStreetMap\\n 4 - Mapbox Control Room ::=> \\n""))\n    MAP = folium.Map(location=[latitude, longitude],tiles=MAP_TYPES[name_type], zoom_start=11)\n\n    name=map_data[0][0]\n    LEGEND_DATA = []\n    full_tree = []\n    data_cate = []\n    OVER_COL = str(get_random_col())\n    FILL_COL = str(get_random_col())\n    LEGEND_DATA.append([name,OVER_COL,FILL_COL])\n    for item in map_data:\n        lat = item[2]\n        lng = item[3]\n        #print(item,"" => "")\n        if(item[0]!=name):\n            OVER_COL = str(get_random_col())\n            FILL_COL = str(get_random_col())\n            full_tree.append([name,data_cate])\n            name=item[0]\n            LEGEND_DATA.append([name,OVER_COL,FILL_COL])\n            data_cate=[]\n            #print(""got into first check"")\n        if(item[0]==name):\n            data_cate.append([item[1],lat,lng])\n            #print(""got into 2nd check"")\n        label = ""cat : {} \\n, Name : {}"".format(item[0],item[1])\n        folium.CircleMarker(\n                            [lat, lng],\n                            radius=5,\n                            popup=label,\n                            color=OVER_COL,\n                            fill=True,\n                            fill_color=FILL_COL,\n                            fill_opacity=0.7).add_to(MAP)\n    full_tree.append([name,data_cate])\n    min_dist_vert = []\n    vert_only = []\n    for i in full_tree:\n        time_now()\n        item_class = i[0]\n        print(item_class)\n        k_dummy=0\n        print(""i[1:][0] => "",i[1:][0])\n        for item in i[1:][0]:\n            # the upper class \n            name_point_ = item[0]\n            name_lat_ = item[1]\n            name_lon_ = item[2]\n\n            final_dist=0\n            print(""item loop => "",name_point_,"" == "",name_lat_,"" == "",name_lon_)\n            #\n            for k in full_tree:\n                # the sub class\n                item_class2 = k[0]\n                #print(""class 2 => "",item_class2)\n                if len(min_dist_vert) == 0:\n                    if item_class2!=item_class:\n                        #print(""class 2 "",k)\n                        for j in k[1:][0]:\n                            name_point = j[0]\n                            name_lat = j[1]\n                            name_lon = j[2]\n                            print(name_point,"" == "",name_lat,"" == "",name_lon,end="""")\n                            dist_from_item = ret_dist(name_lat_,name_lon_,name_lat,name_lon)\n                            print("" dist from "",name_point_,"" to "",name_point,"" is:=> "",dist_from_item)\n                            final_dist += dist_from_item\n            if len(min_dist_vert)>0:\n\n                if item_class2 not in vert_only:\n                    print(""class2 => "",item_class2)\n                    print(""\\n\\nmin_dist_vert => "",min_dist_vert)\n                    for j in min_dist_vert:\n                        name_point = j[0]\n                        name_lat = j[1][0]\n                        name_lon = j[1][1]\n                        print(""2nd check => "",name_point,"" == "",name_lat,"" == "",name_lon,end="""")\n                        dist_from_item = ret_dist(name_lat_,name_lon_,name_lat,name_lon)\n                        print(""[+] dist from "",name_point_,"" to "",name_point,"" is:=> "",dist_from_item)\n                        final_dist += dist_from_item\n            print(""Total dist of "",name_point_,"" is => "",final_dist)\n\n            if k_dummy==1:\n                if minimum_dist>=final_dist:\n                    minimum_dist = final_dist\n                    min_dist_lat = name_lat_\n                    min_dist_lon = name_lon_\n                    min_dist_name = name_point_\n                    print(""Minimum => "",min_dist_name,""dist => "",minimum_dist,"" + "",min_dist_lat,"" + "",min_dist_lon)\n            if k_dummy==0:\n                minimum_dist=final_dist\n                minimum_dist = final_dist\n                min_dist_lat = name_lat_\n                min_dist_lon = name_lon_\n                min_dist_name = name_point_\n                k_dummy=1\n                print(""dummy set to 1"")\n            print(""$$$$Minimum => "",min_dist_name,""dist => "",minimum_dist,"" + "",min_dist_lat,"" + "",min_dist_lon)\n        vert_only.append(item_class)\n        min_dist_vert.append([min_dist_name,[min_dist_lat,min_dist_lon]])\n        print(""MIN DIST VERT LIST => "",min_dist_vert)\n        \n    for i1 in min_dist_vert:\n        for j1 in min_dist_vert:\n            p1 = i1[1]\n            p2 = j1[1]\n            print(p1,"","",p2)\n            folium.PolyLine(locations=[p1, p2], color=\'red\',weight=1.5,opacity=1).add_to(MAP)\n    #print(LEGEND_DATA)\n    DOTS_HTML = """"\n    for item in LEGEND_DATA:\n        name_leg = item[0]\n        over_leg = item[1]\n        fill_leg = item[2]\n        DOTS_HTML +=""""""\n            &nbsp; {} &nbsp;\n            <svg height=""10"" width=""10"">\n            <circle cx=""5"" cy=""5"" r=""4"" stroke=""{}"" stroke-width=""3"" fill=""{}"" />\n            </svg><br/> """""".format(str(name_leg),str(over_leg),str(fill_leg))\n    LEGEND_HTML = """"""\n    <center>\n    <h1 ><i style=""color:#c6ae0d; font face=Arial,Helvetica ""> WISP v2.0 </i></h1> \n    </center>\n    \n    <div id=""legend-html"" style=""position: fixed; background-color: white; \n    bottom: 50px; left: 50px;  \n    border:2px solid grey; z-index:9999; font-size:14px;"" >&nbsp; \n    <b>Legend <b>\n    <br>{}\n    </div>\n    <div style=""position: fixed; \n    bottom: 50px; right: 50px;  \n    z-index:9999; font-size:10px;\n    ""> \n    <b style=""color:#f90404"" style=""align: justified"">\n        WISP <br/> \n        version: 2.0 <br/>\n        &copyJimut Bahan Pal <br/> \n        Author : jimutbahanpal@yahoo.com \n    </b>\n    </div>\n    <div style=""position: fixed; \n    top: 70px; left: 50px;  \n    z-index:9999; font-size:15px;\n    ""> \n    <b style=""color:#16842c"" style=""align: justified"">\n        Location: {} <br/>\n        Lat, Lon: {},{} <br/>\n        Radius: {} <br/>\n        Date: {} <br/>\n    </b>\n    </div> \n    """""".format(str(DOTS_HTML),address,latitude,longitude,radius,datetime.now().isoformat(timespec=\'seconds\'))\n    MAP.get_root().html.add_child(folium.Element(LEGEND_HTML))\n    \n    return MAP\n\n\nif __name__ == ""__main__"":\n    time_now()\n    MAP = Jimut_Wisp_Cluster3_Minimum(data_ice)\n    time_now()\n    print(""Saving file as ==> "",""{}_{}.html"".format(address,No_Q))\n    MAP.save(""{}_{}.html"".format(address,No_Q))\n    \n\n\n'"
