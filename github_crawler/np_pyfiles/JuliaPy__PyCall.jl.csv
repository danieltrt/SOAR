file_path,api_count,code
deps/find_libpython.py,0,"b'#!/usr/bin/env python\n\n""""""\nLocate libpython associated with this Python executable.\n""""""\n\n# License\n#\n# Copyright 2018, Takafumi Arakaki\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# ""Software""), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfrom __future__ import print_function, absolute_import\n\nfrom logging import getLogger\nimport ctypes.util\nimport functools\nimport os\nimport sys\nimport sysconfig\n\nlogger = getLogger(""find_libpython"")\n\nis_windows = os.name == ""nt""\nis_apple = sys.platform == ""darwin""\n\nSHLIB_SUFFIX = sysconfig.get_config_var(""SHLIB_SUFFIX"")\nif SHLIB_SUFFIX is None:\n    if is_windows:\n        SHLIB_SUFFIX = "".dll""\n    else:\n        SHLIB_SUFFIX = "".so""\nif is_apple:\n    # sysconfig.get_config_var(""SHLIB_SUFFIX"") can be "".so"" in macOS.\n    # Let\'s not use the value from sysconfig.\n    SHLIB_SUFFIX = "".dylib""\n\n\ndef linked_libpython():\n    """"""\n    Find the linked libpython using dladdr (in *nix).\n\n    Returns\n    -------\n    path : str or None\n        A path to linked libpython.  Return `None` if statically linked.\n    """"""\n    if is_windows:\n        return _linked_libpython_windows()\n    return _linked_libpython_unix()\n\n\nclass Dl_info(ctypes.Structure):\n    _fields_ = [\n        (""dli_fname"", ctypes.c_char_p),\n        (""dli_fbase"", ctypes.c_void_p),\n        (""dli_sname"", ctypes.c_char_p),\n        (""dli_saddr"", ctypes.c_void_p),\n    ]\n\n\ndef _linked_libpython_unix():\n    libdl = ctypes.CDLL(ctypes.util.find_library(""dl""))\n    libdl.dladdr.argtypes = [ctypes.c_void_p, ctypes.POINTER(Dl_info)]\n    libdl.dladdr.restype = ctypes.c_int\n\n    dlinfo = Dl_info()\n    retcode = libdl.dladdr(\n        ctypes.cast(ctypes.pythonapi.Py_GetVersion, ctypes.c_void_p),\n        ctypes.pointer(dlinfo))\n    if retcode == 0:  # means error\n        return None\n    path = os.path.realpath(dlinfo.dli_fname.decode())\n    if path == os.path.realpath(sys.executable):\n        return None\n    return path\n\n\ndef _linked_libpython_windows():\n    """"""\n    Based on: https://stackoverflow.com/a/16659821\n    """"""\n    from ctypes.wintypes import HANDLE, LPWSTR, DWORD\n\n    GetModuleFileName = ctypes.windll.kernel32.GetModuleFileNameW\n    GetModuleFileName.argtypes = [HANDLE, LPWSTR, DWORD]\n    GetModuleFileName.restype = DWORD\n\n    MAX_PATH = 260\n    try:\n        buf = ctypes.create_unicode_buffer(MAX_PATH)\n        GetModuleFileName(ctypes.pythonapi._handle, buf, MAX_PATH)\n        return buf.value\n    except (ValueError, OSError):\n        return None\n\n\n\ndef library_name(name, suffix=SHLIB_SUFFIX, is_windows=is_windows):\n    """"""\n    Convert a file basename `name` to a library name (no ""lib"" and "".so"" etc.)\n\n    >>> library_name(""libpython3.7m.so"")                   # doctest: +SKIP\n    \'python3.7m\'\n    >>> library_name(""libpython3.7m.so"", suffix="".so"", is_windows=False)\n    \'python3.7m\'\n    >>> library_name(""libpython3.7m.dylib"", suffix="".dylib"", is_windows=False)\n    \'python3.7m\'\n    >>> library_name(""python37.dll"", suffix="".dll"", is_windows=True)\n    \'python37\'\n    """"""\n    if not is_windows and name.startswith(""lib""):\n        name = name[len(""lib""):]\n    if suffix and name.endswith(suffix):\n        name = name[:-len(suffix)]\n    return name\n\n\ndef append_truthy(list, item):\n    if item:\n        list.append(item)\n\n\ndef uniquifying(items):\n    """"""\n    Yield items while excluding the duplicates and preserving the order.\n\n    >>> list(uniquifying([1, 2, 1, 2, 3]))\n    [1, 2, 3]\n    """"""\n    seen = set()\n    for x in items:\n        if x not in seen:\n            yield x\n        seen.add(x)\n\n\ndef uniquified(func):\n    """""" Wrap iterator returned from `func` by `uniquifying`. """"""\n    @functools.wraps(func)\n    def wrapper(*args, **kwds):\n        return uniquifying(func(*args, **kwds))\n    return wrapper\n\n\n@uniquified\ndef candidate_names(suffix=SHLIB_SUFFIX):\n    """"""\n    Iterate over candidate file names of libpython.\n\n    Yields\n    ------\n    name : str\n        Candidate name libpython.\n    """"""\n    LDLIBRARY = sysconfig.get_config_var(""LDLIBRARY"")\n    if LDLIBRARY:\n        yield LDLIBRARY\n\n    LIBRARY = sysconfig.get_config_var(""LIBRARY"")\n    if LIBRARY:\n        yield os.path.splitext(LIBRARY)[0] + suffix\n\n    dlprefix = """" if is_windows else ""lib""\n    sysdata = dict(\n        v=sys.version_info,\n        # VERSION is X.Y in Linux/macOS and XY in Windows:\n        VERSION=(sysconfig.get_python_version() or\n                 ""{v.major}.{v.minor}"".format(v=sys.version_info) or\n                 sysconfig.get_config_var(""VERSION"")),\n        ABIFLAGS=(sysconfig.get_config_var(""ABIFLAGS"") or\n                  sysconfig.get_config_var(""abiflags"") or """"),\n    )\n\n    for stem in [\n            ""python{VERSION}{ABIFLAGS}"".format(**sysdata),\n            ""python{VERSION}"".format(**sysdata),\n            ""python{v.major}"".format(**sysdata),\n            ""python"",\n            ]:\n        yield dlprefix + stem + suffix\n\n\n\n@uniquified\ndef candidate_paths(suffix=SHLIB_SUFFIX):\n    """"""\n    Iterate over candidate paths of libpython.\n\n    Yields\n    ------\n    path : str or None\n        Candidate path to libpython.  The path may not be a fullpath\n        and may not exist.\n    """"""\n\n    yield linked_libpython()\n\n    # List candidates for directories in which libpython may exist\n    lib_dirs = []\n    append_truthy(lib_dirs, sysconfig.get_config_var(\'LIBPL\'))\n    append_truthy(lib_dirs, sysconfig.get_config_var(\'srcdir\'))\n    append_truthy(lib_dirs, sysconfig.get_config_var(""LIBDIR""))\n\n    # LIBPL seems to be the right config_var to use.  It is the one\n    # used in python-config when shared library is not enabled:\n    # https://github.com/python/cpython/blob/v3.7.0/Misc/python-config.in#L55-L57\n    #\n    # But we try other places just in case.\n\n    if is_windows:\n        lib_dirs.append(os.path.join(os.path.dirname(sys.executable)))\n    else:\n        lib_dirs.append(os.path.join(\n            os.path.dirname(os.path.dirname(sys.executable)),\n            ""lib""))\n\n    # For macOS:\n    append_truthy(lib_dirs, sysconfig.get_config_var(""PYTHONFRAMEWORKPREFIX""))\n\n    lib_dirs.append(sys.exec_prefix)\n    lib_dirs.append(os.path.join(sys.exec_prefix, ""lib""))\n\n    lib_basenames = list(candidate_names(suffix=suffix))\n\n    for directory in lib_dirs:\n        for basename in lib_basenames:\n            yield os.path.join(directory, basename)\n\n    # In macOS and Windows, ctypes.util.find_library returns a full path:\n    for basename in lib_basenames:\n        yield ctypes.util.find_library(library_name(basename))\n\n# Possibly useful links:\n# * https://packages.ubuntu.com/bionic/amd64/libpython3.6/filelist\n# * https://github.com/Valloric/ycmd/issues/518\n# * https://github.com/Valloric/ycmd/pull/519\n\n\ndef normalize_path(path, suffix=SHLIB_SUFFIX, is_apple=is_apple):\n    """"""\n    Normalize shared library `path` to a real path.\n\n    If `path` is not a full path, `None` is returned.  If `path` does\n    not exists, append `SHLIB_SUFFIX` and check if it exists.\n    Finally, the path is canonicalized by following the symlinks.\n\n    Parameters\n    ----------\n    path : str ot None\n        A candidate path to a shared library.\n    """"""\n    if not path:\n        return None\n    if not os.path.isabs(path):\n        return None\n    if os.path.exists(path):\n        return os.path.realpath(path)\n    if os.path.exists(path + suffix):\n        return os.path.realpath(path + suffix)\n    if is_apple:\n        return normalize_path(_remove_suffix_apple(path),\n                              suffix="".so"", is_apple=False)\n    return None\n\n\ndef _remove_suffix_apple(path):\n    """"""\n    Strip off .so or .dylib.\n\n    >>> _remove_suffix_apple(""libpython.so"")\n    \'libpython\'\n    >>> _remove_suffix_apple(""libpython.dylib"")\n    \'libpython\'\n    >>> _remove_suffix_apple(""libpython3.7"")\n    \'libpython3.7\'\n    """"""\n    if path.endswith("".dylib""):\n        return path[:-len("".dylib"")]\n    if path.endswith("".so""):\n        return path[:-len("".so"")]\n    return path\n\n\n@uniquified\ndef finding_libpython():\n    """"""\n    Iterate over existing libpython paths.\n\n    The first item is likely to be the best one.\n\n    Yields\n    ------\n    path : str\n        Existing path to a libpython.\n    """"""\n    logger.debug(""is_windows = %s"", is_windows)\n    logger.debug(""is_apple = %s"", is_apple)\n    for path in candidate_paths():\n        logger.debug(""Candidate: %s"", path)\n        normalized = normalize_path(path)\n        if normalized:\n            logger.debug(""Found: %s"", normalized)\n            yield normalized\n        else:\n            logger.debug(""Not found."")\n\n\ndef find_libpython():\n    """"""\n    Return a path (`str`) to libpython or `None` if not found.\n\n    Parameters\n    ----------\n    path : str or None\n        Existing path to the (supposedly) correct libpython.\n    """"""\n    for path in finding_libpython():\n        return os.path.realpath(path)\n\n\ndef print_all(items):\n    for x in items:\n        print(x)\n\n\ndef cli_find_libpython(cli_op, verbose):\n    import logging\n    # Importing `logging` module here so that using `logging.debug`\n    # instead of `logger.debug` outside of this function becomes an\n    # error.\n\n    if verbose:\n        logging.basicConfig(\n            format=""%(levelname)s %(message)s"",\n            level=logging.DEBUG)\n\n    if cli_op == ""list-all"":\n        print_all(finding_libpython())\n    elif cli_op == ""candidate-names"":\n        print_all(candidate_names())\n    elif cli_op == ""candidate-paths"":\n        print_all(p for p in candidate_paths() if p and os.path.isabs(p))\n    else:\n        path = find_libpython()\n        if path is None:\n            return 1\n        print(path, end="""")\n\n\ndef main(args=None):\n    import argparse\n    parser = argparse.ArgumentParser(\n        description=__doc__)\n    parser.add_argument(\n        ""--verbose"", ""-v"", action=""store_true"",\n        help=""Print debugging information."")\n\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\n        ""--list-all"",\n        action=""store_const"", dest=""cli_op"", const=""list-all"",\n        help=""Print list of all paths found."")\n    group.add_argument(\n        ""--candidate-names"",\n        action=""store_const"", dest=""cli_op"", const=""candidate-names"",\n        help=""Print list of candidate names of libpython."")\n    group.add_argument(\n        ""--candidate-paths"",\n        action=""store_const"", dest=""cli_op"", const=""candidate-paths"",\n        help=""Print list of candidate paths of libpython."")\n\n    ns = parser.parse_args(args)\n    parser.exit(cli_find_libpython(**vars(ns)))\n\n\nif __name__ == ""__main__"":\n    main()\n'"
