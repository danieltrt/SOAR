file_path,api_count,code
python/Ddiff.py,6,"b""import numpy as np\nfrom sympy import *\n\n\ndef DDiff(xs,fxs):\n    ''' newtons divided difference'''\n    k = 1\n    while k < len(fxs[0]):\n        n = k\n        count = 0 # for counting how many calculations have been made on that trial\n        while n < len(fxs):\n            if(count < len(fxs[0])-k): #optimisation\n               # import ipdb; ipdb.set_trace()\n                fxs[n][k] = Rational((fxs[n+1][k-1]-fxs[n-1][k-1]) ,(xs[n+k][0]-xs[n-k][0]))\n                n += 2\n                count += 1\n            else:\n                break #no need to make any more calculations for this trial\n        k += 1\n    return (fxs , np.diag(fxs)) # return the upper diagonal\n\n\nx_in = np.asarray([[1],[2],[4]],Rational)     #seems to work regardless of input values\nxs = np.asarray(np.zeros((2*len(x_in)-1,1)),Rational)\nxs[::2] = x_in[:]                                    #add spacing\n\nfx_in = np.asarray([[0],[1],[2]],Rational)\nfxs = np.asarray(np.zeros((2*len(fx_in)-1,len(fx_in))),Rational)\nfxs[::2,0][:] = fx_in[:].T                              #add spacing\n\n#CALCULATE POLYNOMIAL AND SIMPLIFY\ndef poly(xs,diag):\n    xs = xs[~np.all(xs == 0, axis=1)] # remove zero rows\n\n    x = Symbol('x')\n    f = diag[0]\n\n    for d in range(1,len(diag)):\n        c=d-1\n        r=1\n        while c>=0:\n            r = r*(x-xs[c])                    #any linear function\n            c = c-1\n        #print(r)\n        f = f + diag[d]*r\n    f=simplify(f)\n    return f\n"""
python/GE_LU.py,14,"b""import numpy as np\nfrom pprint import pprint\ndef LU(A,b):\n    n = len(A)\n    A, b = np.asarray(A,dtype=np.float64),np.asarray(b,dtype=np.float64)\n    L = np.asarray(np.identity(n))\n    U = np.copy(A)\n    P = np.identity(n)\n\n    permutation = abs(U[:,0]).argsort()[::-1]\n    U=U[permutation]\n    P=P[permutation]\n\n    for k in range(n):                          #for each column of A in Ab\n\n        #Forward Elimination - Subtracting rows\n        for j in range(k+1,n):                      #for each row under the diagonal of the kth column\n            q = float(U[j][k]) / U[k][k]              #calculate the ratio to the value in the main diagonal\n\n            L[j][k] = q\n\n            for m in range(k, n):                     #for each each column in a Row j\n                # Ab[j][m] -=  q * Ab[k][m]                   #calculate Rj - q*Rk.  This will result in all zeros under the main diagonal\n                if m<len(U):\n                    U[j][m] -= q * U[k][m]\n    x = np.zeros(n)\n\n    U = np.triu(U)\n    return (np.asmatrix(L), np.asmatrix(U),np.asmatrix(P))\n\nA = [[1,  2,  1, 4], [2, 0, 4, 3], [4,  2,  2, 1], [-3, 1, 3, 2]]\nb = [[13], [28], [20], [6]]\n\nL,U,P = LU(A,b)\n\nprint('L: ')\npprint(L)\nprint('U: ')\npprint(U)\nprint('P: ')\npprint(P)\n\n#Ly=b\nbb = np.asmatrix(P) * np.asmatrix(b)\nprint('bb: ')\npprint(bb)\n\nn = len(L)\n#Lb = np.asarray(np.c_[L, bb],dtype=np.float64)\n\n\ny = np.zeros(n)\nfor i in range(n):\n    y[i] = bb[i]\n    for j in range(i):\n        y[i] -= L[i, j]*y[j]\n    y[i] = y[i]/L[i, i]\ny = np.asmatrix(y).T\nprint('y: ')\npprint(y)\n\n#Ux=y\nx = np.zeros(n)\nUy = np.asarray(np.c_[U, np.asarray(y)],dtype=np.float64)\n#Backwards Substitution - Solve for one variable and substite that back in to solve for another\nx[n-1] =float(Uy[n-1][n])/Uy[n-1][n-1]      #simply solve the last row, since there should be only one unknown\nfor i in range (n-1,-1,-1):                 #start,stop, step - starting from the second last row work back up the rows\n    z = 0.0                                     #let z=0 or reset to 0\n    for j in range(i+1,n):                      #for each column in a Row j\n        z = z  + float(Uy[i][j])*x[j]               #substitute answers from below(stored in x) into the equation of the current row\n    x[i] = float(Uy[i][n] - z) / Uy[i][i]       #solve for this row, where there should now be only one unknown\nx = np.asmatrix(x).T\nprint('x: ')\npprint(x)\n"""
python/GE_PP.py,3,"b'import numpy as np\n\ndef GE_PP(A,b):\n    n = len(A)\n    A, b = np.asarray(A,dtype=np.float64),np.asarray(b,dtype=np.float64)\n    Ab = np.asarray(np.c_[A, b],dtype=np.float64)\n    #print(Ab)\n\n    for k in range(n):                          #for each column of A in Ab\n        #Partial Pivoting\n        for i in range(k+1,n):                      #for each values in that column below the diagonal\n            if abs(Ab[i][k]) > abs(Ab[k][k]):           #if one |value| is greater than another\n                Ab[[k,i]]=Ab[[i,k]]                         #swap the rows containing those values\n                print(""this is a pivot \\n"",Ab)                                   #view the swap\n            else:                                       #otherwise\n                pass                                        #do nothing\n\n        #Forward Elimination - Subtracting rows\n        for j in range(k+1,n):                      #for each row under the diagonal of the kth column\n            q = float(Ab[j][k]) / Ab[k][k]              #calculate the ratio to the value in the main diagonal\n            for m in range(k, n+1):                     #for each each column in a Row j\n                Ab[j][m] -=  q * Ab[k][m]                   #calculate Rj - q*Rk.  This will result in all zeros under the main diagonal\n\n    # x = [0.0 for i in range(n)]                 #set of zeros\n    x = np.zeros(n)\n\n\n    #At this stage the matrix should be in row echelon form\n        # this means all zeros below the main diagonal\n\n    #Backwards Substitution - Solve for one variable and substite that back in to solve for another\n    x[n-1] =float(Ab[n-1][n])/Ab[n-1][n-1]      #simply solve the last row, since there should be only one unknown\n    for i in range (n-1,-1,-1):                 #start,stop, step - starting from the second last row work back up the rows\n        z = 0.0                                     #let z=0 or reset to 0\n        for j in range(i+1,n):                      #for each column in a Row j\n            z = z  + float(Ab[i][j])*x[j]               #substitute answers from below(stored in x) into the equation of the current row\n        x[i] = float(Ab[i][n] - z) / Ab[i][i]       #solve for this row, where there should now be only one unknown\n    print(x)                                    #print off your solution vector\n\n\n\nA = [[4,  1,  2,  -3,  5], \\\n    [-3,  3, -1,   4, -2], \\\n    [-1,  2,  5,   1,  3], \\\n    [ 5,  40,  3,  -1,  2], \\\n    [ 1, -2,  3,  -4,  5]]\nb = [[-16], [20], [-4],[-10],[3]]\n\nGE_PP(A,b)\n'"
python/GE_SP.py,7,"b'import numpy as np\n\ndef GE_SP(A,b):\n    n = len(A)\n    A, b = np.asarray(A,dtype=np.float64),np.asarray(b,dtype=np.float64)\n    Ab = np.asarray(np.c_[A, b],dtype=np.float64)\n\n\n    for k in range(n):\n        #Scaled Pivoting\n        ratiovects = np.zeros(n)\n        for i in range(k,n):\n            ratiovects[i] = abs(Ab[i][k])/abs(max(np.max(A[i]),np.min(A[i]), key = abs))\n        Ab[[k, np.argmax(ratiovects)]] = Ab[[np.argmax(ratiovects), k]]\n        A[[k, np.argmax(ratiovects)]] = A[[np.argmax(ratiovects), k]]\n\n        #Forward Elimination - Subtracting rows\n        for j in range(k+1,n):                      #for each row under the diagonal of the kth column\n            q = float(Ab[j][k]) / Ab[k][k]              #calculate the ratio to the value in the main diagonal\n            for m in range(k, n+1):                     #for each each column in a Row j\n                Ab[j][m] -=  q * Ab[k][m]                   #calculate Rj - q*Rk.  This will result in all zeros under the main diagonal\n\n    x = np.zeros(n)                #set of zeros\n\n    #At this stage the matrix should be in row echelon form\n        # this means all zeros below the main diagonal\n\n    #Backwards Substitution - Solve for one variable and substite that back in to solve for another\n    x[n-1] =float(Ab[n-1][n])/Ab[n-1][n-1]      #simply solve the last row, since there should be only one unknown\n    for i in range (n-1,-1,-1):                 #start,stop, step - starting from the second last row work back up the rows\n        z = 0.0                                     #let z=0 or reset to 0\n        for j in range(i+1,n):                      #for each column in a Row j\n            z = z  + float(Ab[i][j])*x[j]               #substitute answers from below(stored in x) into the equation of the current row\n        x[i] = float(Ab[i][n] - z) / Ab[i][i]       #solve for this row, where there should now be only one unknown\n    print(x)                                    #print off your solution vector\n\n\n\nA = [[4,  1,  2,  -3,  5], [-3,  3, -1,   4, -2], [-1,  2,  5,   1,  3], [ 5,  4,  3,  -1,  2], [ 1, -2,  3,  -4,  5]]\nb = [[-16], [20], [-4],[-10],[3]]\n\nGE_SP(A,b)\n'"
python/Gauss_Seidel.py,21,"b'import numpy as np\n\nA = np.asmatrix([[4,-1,0,0],[-1,4,-1,0],[0,-1,4,-1],[0,0,-1,3]])\nB = np.asmatrix([[15],[10],[10],[10]])\n\ndef GS3x3(A,B):\n    x = np.asmatrix(np.zeros(len(A),1))\n    #xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n\n    #precision specified in loop - not very specific\n    while RE >= 0.009:\n        xk = x.copy()\n        x[0] = (B[0] - (A[0,1] * x[1]) - (A[0,2] * x[2])) / A[0,0]\n        x[1] = (B[1] - (A[1,0] * x[0]) - (A[1,2] * x[2])) / A[1,1]\n        x[2] = (B[2] - (A[2,0] * x[0]) - (A[2,1] * x[1])) / A[2,2]\n        RE = (np.linalg.norm(x - xk,np.inf)) / (np.linalg.norm(x,np.inf) + 0)\n        #x = xk.copy()\n\n        print(x[0],""\\t"",x[1],""\\t"",x[2],""\\t"",RE)\n\ndef GSprint(A,B):\n    x = np.asmatrix(np.zeros((len(A),1)))\n    #xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n    trial_no = 1\n    print(""trial          x1          x2          x3          ..."")\n\n    while RE > 0.0009:\n        xk = x.copy()\n        for i  in range(0, len(x)):\n            x[i] = (B[i] + eqn(A[i], x,i)) / A[i,i]\n\n        RE = (np.linalg.norm(x - xk,np.inf)) / (np.linalg.norm(x,np.inf) + 0)\n        #x = xk.copy()\n\n        print(str(trial_no)+""\\t""+str(x.T)+""\\t""+str(RE))\n        trial_no +=1\n    print(""trial          x1          x2          x3          ..."")\n\n    return x\n\ndef GSrecord(A,B):\n    x = np.asmatrix(np.zeros((len(A),10)))\n    #xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n    trial_no = 1\n    print(""trial          x1          x2          x3          ..."")\n    t=0\n    while t < 10:\n        if t>0: x[:,t] = x[:,t-1].copy()\n        for i  in range(0, len(x)):\n            x[i,t] = (B[i] + eqn(A[i], x[:,t],i)) / A[i,i]\n\n        RE = (np.linalg.norm(x[:,t] - x[:,t-1],np.inf)) / (np.linalg.norm(x[:,t],np.inf) + 0)\n        #x = xk.copy()\n\n        print(str(trial_no)+""\\t""+str(x[:,t].T)+""\\t""+str(RE))\n        t += 1\n        trial_no +=1\n    print(""trial          x1          x2          x3          ..."")\n\n    return x.T\n\ndef GSrelax(A,B,w):\n    x = np.asmatrix(np.zeros((len(A),11)))\n    #xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n    trial_no = 1\n    print(""trial          x1          x2          x3          ..."")\n    t=0\n    while t < 11:\n        if t>0: x[:,t] = x[:,t-1].copy()\n        for i  in range(0, len(x)):\n            x[i,t] = (B[i] + eqn(A[i], x[:,t],i)) / A[i,i]\n            if(t>0): x[i,t] = w*x[i,t] + (1-w)*x[i,t-1]\n\n        RE = (np.linalg.norm(x[:,t] - x[:,t-1],np.inf)) / (np.linalg.norm(x[:,t],np.inf) + 0)\n        #x = xk.copy()\n\n        print(str(trial_no)+""\\t""+str(x[:,t].T)+""\\t""+str(RE))\n        t += 1\n        trial_no +=1\n    print(""trial          x1          x2          x3          ..."")\n\n    return x.T\n\ndef GSrelaximproved(A,B):\n    iterations = 17\n    x = np.asmatrix(np.zeros((len(A),iterations),np.float64),np.float64)\n    print(""trial          x1          x2          x3          ..."")\n    k=10\n    t=0\n    w=1\n    while t < iterations:\n        if t>0:\n            x[:,t] = x[:,t-1].copy()\n        for i in range(0, len(x)):\n            x[i,t] = (B[i] + eqn(A[i], x[:,t],i)) / A[i,i]\n            if(t>0):\n                x[i,t] = w*x[i,t] + (1-w)*x[i,t-1]\n\n        RE = (np.linalg.norm(x[:,t] - x[:,t-1],np.inf)) / (np.linalg.norm(x[:,t],np.inf) + 0)\n\n        print(str(t+1)+""\\t""+str(x[:,t].T)+""\\t""+str(RE)+"" \\t""+str(w))\n        t += 1\n\n        if t == k+1: #in order to get the same result as in the example in T.Dowling\'s notes\n            deltab = np.linalg.norm(x[:,t-1]-x[:,t-2],2)\n            deltas= np.linalg.norm(x[:,t-2]-x[:,t-3],2)\n            w = (2 / (1 + np.sqrt(1-(deltab / deltas))))\n\n    print(""trial          x1          x2          x3          ..."")\n    return (x.T,w)\n\ndef eqn(w,x,I):\n\n    w = -1 * w\n    res = np.multiply(w.T,x)\n    res[I] = 0\n    sum = np.sum(res)\n    return sum\n'"
python/Jacobi.py,10,"b'import numpy as np\n\nA = np.asmatrix([[10,-1,2,0],[-1,11,-1,3],[2,-1,10,-1],[0,3,-1,8]])\nB = np.asmatrix([[6],[25],[-11],[15]])\n\ndef Jacobi3x3(A,B):\n    x = np.asmatrix(np.zeros(len(A),1))\n    xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n\n    #precision specified in loop - not very specific\n    while RE >= 0.0009:\n        xk[0] = (B[0] - (A[0,1] * x[1]) - (A[0,2] * x[2])) / A[0,0]\n        xk[1] = (B[1] - (A[1,0] * x[0]) - (A[1,2] * x[2])) / A[1,1]\n        xk[2] = (B[2] - (A[2,0] * x[0]) - (A[2,1] * x[1])) / A[2,2]\n        RE = (np.linalg.norm(xk - x,np.inf)) / (np.linalg.norm(xk,np.inf) + 0)\n        x = xk.copy()\n\n        print(x[0],""\\t"",x[1],""\\t"",x[2],""\\t"",RE)\n\ndef Jacobi(A,B):\n    x = np.asmatrix(np.zeros((len(A),1)))\n    xk = np.asmatrix(np.zeros((len(x),1)))\n    RE = 1\n    trial_no = 1\n    print(""trial          x1          x2          x3          ..."")\n\n    while RE > 0.0009:\n        for i  in range(0, len(x)):\n            xk[i] = (B[i] + eqn(A[i], x,i)) / A[i,i]\n\n        RE = (np.linalg.norm(xk - x,np.inf)) / (np.linalg.norm(xk,np.inf) + 0)\n        x = xk.copy()\n\n        print(str(trial_no)+""\\t""+str(x.T)+""\\t""+str(RE))\n        trial_no +=1\n    print(""trial          x1          x2          x3          ..."")\n\n    return x\n\n\n\ndef eqn(w,x,I):\n\n    w = -1 * w\n    res = np.multiply(w.T,x)\n    res[I] = 0\n    sum = np.sum(res)\n    return sum\n'"
python/Raphson.py,8,"b'import numpy as np\nfrom numpy import linalg as lanp\nfrom sympy import * #probably don\'t need to import everything\n\nx = np.asarray([Symbol(\'x0\'),Symbol(\'x1\'),Symbol(\'x2\'),Symbol(\'x3\'),Symbol(\'x4\'),Symbol(\'x5\'),Symbol(\'x6\'),Symbol(\'x6\'),Symbol(\'x6\')]) #for 7 variables, not very convenient but hopefuly it will do\n\n#FUNCTIONS FROM TOM\'S NOTES - gives the same result\nf = np.asarray([\\\n                    1.4*x[0] -x[1] - 0.6,  \\\n                    x[0]**2 - 1.6*x[0] - x[1] - 4.6         \\\n                ])\n\n#CALCULATE THE JACOBIAN - the partial deivative of each funtion wrt(with respect to) each variable\n#Note: the length(depth) of f should correspond to the number of variables, otherwords we have too much or too little equations and none of this will work anyway\n#Note: len(f[0].atoms(Symbol)) will return the number of variables in 0th function\nJ = np.zeros((len(f),len(f)),object)                        #empty square array defined by the number of variable(again this should be the same as the number of functions)\nfor func in range(0,len(f)):                                 #cycle through all functions - func being an index for each function\n for var in range(0,len(f)):                                  #cycle through all the variables - var being an index for each variable\n     J[func,var] = f[func].diff(x[var])                          #calcuate the partial dervitive of the curren function wrt(with respect to) the current variable\n\nguess = np.asarray([5.0,5.0])              #initial guess - tedious to convert to matrix, easier to convert to matrix just when needed\niterations = 10\n\n#begin the Newton Raphson algorithm for specified iterations\nfor n in range(0,iterations):                                 #for each iteration\n    print(""guess no. "",n,""\\t"",guess)                            #print our current Jguess\n\n    #EVALUATE F(GUESS)\n    fguess = np.asmatrix(np.zeros((f.shape)))                                #create an array to store the evaluation\n    # the next line will only work properly if they are the same shape\n    for func in range(0,len(f)):                                #as before - for each function\n         ##here i am pairing variables with guess values, stooring them in an array and subbing that into the function\n        fguess[0,func] = f[func].subs(set(zip(x[:],guess)))           #initialise the corresponding element in fguess.\n\n\n    #EVALUATE J(GUESS)\n    Jguess = np.asmatrix(np.zeros((J.shape)))\n    for j in range(0,len(J)):\n        for var in range(0,len(f)):\n            Jguess[j,var] = J[j][var].subs(set(zip(x[:],guess)))\n\n    #CALCULATE THE DELTAGUESS\n    deltaG = lanp.inv(Jguess)*-fguess.T   #deltaguess = inverse(JacobianGuess) * -FunctionGuess. I had to convert to arrays here and transpose\n    # print(""Delta("",n,""): \\n"", deltaG)\n    # print(""J("",n,""):\\n"",Jguess)\n    # print(""f("",n,""):"",""\\n"",fguess)\n\n    #ADD DELTAGUESS TO GUESS TO CREATE A NEW GUESS\n    guess = np.asarray((np.asmatrix(guess).T+np.asmatrix(deltaG)).T)[0]     #update guess\n'"
python/matrixMan.py,8,"b'""""""This class wil contain utilities for manipulating matrices""""""\n\nimport numpy as np\nimport scipy as sc\nfrom numpy import linalg as lanp\nfrom scipy import linalg as lasc\nfrom sympy import *\n\ndef hilbertIT(n):\n    """""" Iterative method of populating an nxn hilbert matrix\n    Param:\n        n : int\n            square size of matrix\n\n    Returns:\n        H : matrix\n            The hilbert matrix\n    """"""\n\n    H = np.asmatrix(np.identity(n),Rational)    #doesn\'t need to be an identity matrix\n\n    for row in range(0,n):\n        for col in range(0,n):\n            H[row,col] = Rational(1,((row+1) + (col+1)-1))\n\n    return H\n\ndef hilbertLA(n):\n    """""" Utilisise scipy.linalg for populating an nxn hilbert matrix\n    Param:\n        n : int\n            square size of matrix\n\n    Returns:\n        H : matrix\n            The hilbert matrix\n    """"""\n    return lasc.hilbert(n)\n\ndef condInf(m):\n    """""" Utilises numpy.linalg for calculating the cond of a matrix (using inf order norms)\n    Param:\n        m : matrix\n\n    Returns:\n        c : float\n            The conditional number\n    """"""\n    return lanp.cond(m,np.inf)\n\ndef condInfIT(m):\n    """""" Iterative method for calculating the cond of a matrix (using inf order norms)\n    Param:\n        m : matrix\n\n    Returns:\n        c : float\n            The conditional number\n    """"""\n    return normInfIT(m) * normInfIT(inverse(m))\n\ndef condEst(A,x,B):\n    """""" """"""\n    return (normInf(A) * normInfIT(x))/normInf(B)\n\ndef condEstIT(A,x,B):\n    """""" """"""\n    return ((normInfIT(A) * normInfIT(x))/normInfIT(B))\n\ndef normInf(m):\n    """""" Utilises numpy.linalg for calculating the norm of a matrix (inf order)\n    Param:\n        m : matrix\n\n    Returns:\n        c : float\n            The norm\n    """"""\n    return lanp.norm(m, np.inf)\n\n#could probably be optimised significantly\ndef normInfIT(m):\n    """"""Iterative method for calculating the cond of a matrix (using inf order norms)\n    Param:\n        m : matrix\n\n    Returns:\n        c : float\n            The conditional number\n    """"""\n    m = abs(m[:,:])\n    res = np.ones(len(m))\n    for i in range(0,len(m)):\n        res[i] = np.sum(m[i,:])\n    return max(res)\n\ndef normEuclid(v):\n    """"""used for vectors(nx1)""""""\n    return lanp.norm(v)\n\ndef inverse(m):\n    """""" Utilises numpy.linalg for calculating the inverse of a matrix\n        m : matrix\n            Square Matrix\n\n    Returns:\n        mInv : matrix\n            The inverse matrix\n    """"""\n    return lanp.inv(m)\n\ndef detLA(m):\n    """""" Utilises numpy.linalg for calculating the determinant of a matrix\n    Param:\n        m : matrix\n\n    Returns:\n        c : float\n            The conditional number\n    """"""\n    return lanp.det(m)\n\n\n\ndef exportM(m):\n    s = """"\n    n = len(m)\n    for row in range(0,n):\n        for col in range(0,n):\n           s += str(m[row,col])\n           s += "";""\n\n        s += "";""\n    return s\n'"
python/minmax.py,3,"b'from sympy import *\nimport numpy as np\nimport scipy as sc\nfrom itertools import product\ninit_printing() #prints the equation nicely\n\n###############################################################################\n#                   FOR LINEAR EQUATIONS ONLY\n###############################################################################\nx = Symbol(\'x\') #x is our variable\n\n#####################################################\nf =  (0*x**4)+ (1*x**3) + (0*x**2) + (0*x) + (0)                     #any linear function\n#####################################################\n#df/dx = f\'(x)\nfd = f.diff(x,Real=true)        #using sympy to differentiate\n\n#d^2 f/ dx^2 = f\'\'(x)\nfdd = fd.diff(x,Real=true)   #using sympy to differentiate again\n\nroots_X = solveset(f,x)      #find the roots of the function f\n\ncriticalPts_X = np.asarray(list(solveset(fd,x)))    #the roots of f\'(x) give us the x coords of our max, min or point of inflection\ncriticalPts_X = np.append(criticalPts_X,list(solveset(fdd,x)))\n\n#lists for storing the XY coords of max, min, poi and the concavity of critical points\nmaxima_XY = []\nminima_XY = []\npoi_XY = []\nconcavity = []\n\nfor cp in range(0,len(criticalPts_X)):      #cycle through the critical points\n    #criticalPts_X = np.append(solveset(fdd,x))       #append poi s\n    corres_Y = f.subs(x,criticalPts_X[cp])      #f(criticalPt) = y\n    concavity.append(fdd.subs(x,criticalPts_X[cp])) #f\'\'(criticalPt), the sign of this tells us if it is positive or negative\n\n    if concavity[cp] < 0:\n        maxima_XY.append(tuple((criticalPts_X[cp], corres_Y)))\n    elif concavity[cp] > 0:\n        minima_XY.append(tuple((criticalPts_X[cp], corres_Y)))\n    else:#must be equal to 0\n         poi_XY.append(tuple((criticalPts_X[cp], f.subs(x,criticalPts_X[cp]))))\n\ninit_printing(pretty_print=true)\nprint(""f(x) = "")\npprint(f)\nprint(""\\nmaximum: \\n"", maxima_XY,\\\n      ""\\nminimum: \\n"", minima_XY,\\\n      ""\\nPoint of Inflection: \\n"", poi_XY)\n'"
python/tri_Lu.py,14,"b'import numpy as np\nfrom numpy import linalg as la\n\n#                [[d,e,.........],\\\n#                 [c,d,e,.......],\\\n#                 [0,c,d,e,.....],\\\n#                 [0,0,c,d,e,....]]\n\nM = np.asmatrix([[3,5,0,0],\\\n                [1,4,6,0],\\\n                [0,5,7,3],\\\n                [0,0,3,8]],np.float64)\nb = np.asmatrix([[13],\\\n                [27],\\\n                [43],\\\n                [41]],np.float64)\ndef tri_lu(M):\n    #diagonals\n    C = np.asmatrix(np.append(0,np.diag(M,-1))).T\n    D = np.asmatrix(np.diag(M)).T\n    E = np.asmatrix(np.append(np.diag(M,1),0)).T\n\n    #the algo\n    c = np.asmatrix(np.zeros(C.shape))\n    d = np.asmatrix(np.zeros(D.shape))\n    e = np.asmatrix(np.copy(E))\n\n    d[0] = D[0]\n    for i in range(1,len(D)):\n        c[i] = C[i]/d[i-1]\n        d[i] = (D[i] - (c[i] * E[i-1]))\n\n    #create L\n    L = np.asmatrix(np.identity(len(M)))\n    for i in range(1,len(M)):\n        L[i,i-1] = c[i]\n\n    #create U\n    U = np.asmatrix(np.triu(M))\n    for i in range(0, len(M)):\n        U[i,i] = d[i,0]\n\n    return (L,U,c,d,e)\n\ndef tri_solve(L,U,c,d,e,b):\n    #SOLVE Ly = b\n    y = np.asmatrix(np.zeros(d.shape))\n    y[0,0] = b[0,0]\n    for k in range(1,len(L)):\n        y[k,0] = b[k,0] - c[k] * y[k-1,0]\n\n    #Solve Ux = y\n    x = np.asmatrix(np.zeros(d.shape))\n    x[len(L)-1] = y[len(L)-1]/d[len(L)-1]\n    for n in range(len(L)-2, -1,-1):\n        x[n,0] = (y[n,0] - e[n,0]*x[n+1,0])/d[n,0]\n\n    return x\n'"
