file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n\nimport os\nimport sys\nimport os.path as op\nfrom distutils import dir_util\nfrom distutils import sysconfig\nfrom setuptools import setup, find_packages\n\nname = \'krysa\'\nfiles = [name, ]\n\nroot = op.dirname(op.abspath(__file__)) + op.sep\n\n# remove all *.pyc files here before packaging\nif \'sdist\' in sys.argv:\n    rem_files = []\n    for path, folders, filenames in os.walk(root):\n        for file in filenames:\n            rem_files.append(op.join(path, file))\n    for file in rem_files:\n        if \'.pyc\' in file:\n            print(\'Removing {}\'.format(file))\n            os.remove(file)\n\n# get version from main\nwith open(op.join(root, \'krysa\', \'main.py\')) as f:\n    for i, line in enumerate(f):\n        if i == 2:\n            version = line[len(\'# Version: \'):-1]\n        elif i > 2:\n            break\n\n# check version format\nver_split = version.split(\'.\')\nnum_check = [int(n) for n in ver_split]\nif len(ver_split) != 3:\n    raise Exception(\'No correct version! ( {0} )\'.format(version))\n\nsetup(\n    name=name,\n    packages=find_packages(),\n    include_package_data=True,\n    install_requires=[\'kivy\', \'numpy\', \'scipy\', \'matplotlib\'],\n    version=version,\n    description=\'KrySA - Statistical analysis for rats\',\n    author=\'Peter Badida\',\n    author_email=\'keyweeusr@gmail.com\',\n    url=\'https://github.com/KeyWeeUsr/KrySA\',\n    download_url=\'https://github.com/KeyWeeUsr/KrySA/tarball/\' + version,\n    classifiers=[\n        \'Development Status :: 2 - Pre-Alpha\',\n        \'Intended Audience :: Education\',\n        \'Intended Audience :: Science/Research\',\n        \'License :: OSI Approved :: GNU General Public License v3 (GPLv3)\',\n        \'Natural Language :: English\',\n        \'Operating System :: Android\',\n        \'Operating System :: MacOS\',\n        \'Operating System :: Microsoft :: Windows\',\n        \'Operating System :: POSIX :: Linux\',\n        \'Programming Language :: Python\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3.4\',\n        \'Topic :: Scientific/Engineering :: Information Analysis\',\n        \'Topic :: Scientific/Engineering :: Visualization\',\n    ],\n    keywords=[\'krysa\', \'statistics\', \'kivy\'],\n    license=""GNU General Public License v3 (GPLv3)"",\n)\n'"
docs/docs_modules.py,0,"b""# -*- coding: utf-8 -*-\nimport os\nimport sys\nimport os.path as op\n\nprint('Creating modules from {}'.format(op.basename(__file__)))\ninclude_exts = ('.py',)\nexclude_dirs = ('test_Project',)\nexclude_files = ('dropdown.py', '__main__.py', 'test_file_', 'test_tasks_')\n\nmod_sep = ' > '\n\npaths = []\nrootdir = op.join(op.dirname(op.dirname(op.abspath(__file__))), 'krysa')\nsourcedir = op.join(op.dirname(op.abspath(__file__)), 'source')\n\nprint('Getting paths...')\nfor path, folders, files in os.walk(rootdir):\n    dirname = op.basename(path)\n    for ex in exclude_dirs:\n        if ex not in path:\n            sys.path.insert(0, path)\n            paths.append(path)\n\nprint('Getting files... {}'.format(include_exts))\ndocs = []\nfor p in paths:\n    for path, folders, files in os.walk(p):\n        for f in files:\n            if op.splitext(f)[1] in include_exts:\n                docs.append(op.join(op.basename(path), f))\n\nfor doc in docs:\n    for ex in exclude_files:\n        docs = [d for d in docs if ex not in d]\n\nprint('Filtering files...')\nmods = []\nfor doc in docs:\n    mod = doc.lstrip('krysa' + op.sep).replace(op.sep, '.')\n    mod = mod.replace('__init__.py', '')\n    if not mod:\n        continue\n    if mod[-1] == '.':\n        mod = mod[:-1]\n    mod = op.splitext(mod)[0]\n    if 'main' not in mod:\n        name = 'KrySA' + mod_sep\n        if '.' in mod:\n            name += mod.replace('.', mod_sep).title()\n        else:\n            name += mod.title()\n    else:\n        name = 'KrySA'\n    if (name, mod) not in mods:\n        mods.append((name, mod))\n\nprint('Writing output...')\nfor mod in mods:\n    mod_name = mod[0].replace(mod_sep, '_').lower()\n    with open(op.join(sourcedir, 'mod_{}.rst'.format(mod_name)), 'w') as f:\n        f.write('{}\\n'.format(mod[0]))\n        f.write('=' * len(mod[0]))\n        f.write('\\n\\n.. automodule:: {}\\n'.format(mod[1]))\n        f.write('   :members:')\n\nwith open(op.join(sourcedir, 'mod_index.rst'), 'w') as f:\n    f.write('Modules\\n')\n    f.write('=======\\n\\n')\n    f.write('* `Index <py-modindex.html>`_\\n\\n')\n    f.write('.. toctree::\\n')\n    f.write('   mod_krysa\\n')\n    f.write('   mod_krysa_tasks\\n')\n    f.write('   mod_krysa_utils\\n')\n    f.write('   mod_krysa_tests\\n')\n\nprint('Full docs done...')\n"""
krysa/__init__.py,0,b''
krysa/__main__.py,0,b'from main import KrySA\nKrySA().run()\n'
krysa/dropdown.py,0,"b""# A customized DropDown allowing placing a dropdown to the side of a widget\n# it is sticked to. The original .py file was released by Kivy under the\n# MIT License. PR for it is on https://github.com/kivy/kivy/pull/4402\n# TLDR: This particular file is under MIT License.\n\n__all__ = ('DropDown', )\n\nfrom kivy.uix.scrollview import ScrollView\nfrom kivy.properties import ObjectProperty, NumericProperty, BooleanProperty\nfrom kivy.core.window import Window\nfrom kivy.lang import Builder\nfrom kivy.clock import Clock\nfrom kivy.config import Config\n\n_grid_kv = '''\nGridLayout:\n    size_hint_y: None\n    height: self.minimum_size[1]\n    cols: 1\n'''\n\n\nclass DropDownException(Exception):\n    '''DropDownException class.\n    '''\n    pass\n\n\nclass DropDown(ScrollView):\n    '''DropDown class. See module documentation for more information.\n\n    :Events:\n        `on_select`: data\n            Fired when a selection is done. The data of the selection is passed\n            in as the first argument and is what you pass in the :meth:`select`\n            method as the first argument.\n        `on_dismiss`:\n            .. versionadded:: 1.8.0\n\n            Fired when the DropDown is dismissed, either on selection or on\n            touching outside the widget.\n    '''\n\n    auto_width = BooleanProperty(True)\n    '''By default, the width of the dropdown will be the same as the width of\n    the attached widget. Set to False if you want to provide your own width.\n    '''\n\n    max_height = NumericProperty(None, allownone=True)\n    '''Indicate the maximum height that the dropdown can take. If None, it will\n    take the maximum height available until the top or bottom of the screen\n    is reached.\n\n    :attr:`max_height` is a :class:`~kivy.properties.NumericProperty` and\n    defaults to None.\n    '''\n\n    dismiss_on_select = BooleanProperty(True)\n    '''By default, the dropdown will be automatically dismissed when a\n    selection has been done. Set to False to prevent the dismiss.\n\n    :attr:`dismiss_on_select` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n    '''\n\n    auto_dismiss = BooleanProperty(True)\n    '''By default, the dropdown will be automatically dismissed when a\n    touch happens outside of it, this option allow to disable this\n    feature\n\n    :attr:`auto_dismiss` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to True.\n\n    .. versionadded:: 1.8.0\n    '''\n\n    min_state_time = NumericProperty(0)\n    '''Minimum time before the :class:`~kivy.uix.DropDown` is dismissed.\n    This is used to allow for the widget inside the dropdown to display\n    a down state or for the :class:`~kivy.uix.DropDown` itself to\n    display a animation for closing.\n\n    :attr:`min_state_time` is a :class:`~kivy.properties.NumericProperty`\n    and defaults to the `Config` value `min_state_time`.\n\n    .. versionadded:: 1.9.2\n    '''\n\n    allow_sides = BooleanProperty(False)\n    '''Property that will allow placement of a :class:`~kivy.uix.DropDown`\n    on the sides of a widget set in :attr:`attach_to`.\n\n    The default side is the right side of a widget. When there is no space\n    on the right side, it'll automatically switch to the left side of the\n    widget.\n\n    :attr:`allow_sides` is a :class:`~kivy.properties.BooleanProperty`\n    and defaults to False.\n    '''\n\n    attach_to = ObjectProperty(allownone=True)\n    '''(internal) Property that will be set to the widget to which the\n    drop down list is attached.\n\n    The :meth:`open` method will automatically set this property whilst\n    :meth:`dismiss` will set it back to None.\n    '''\n\n    container = ObjectProperty()\n    '''(internal) Property that will be set to the container of the dropdown\n    list. It is a :class:`~kivy.uix.gridlayout.GridLayout` by default.\n    '''\n\n    __events__ = ('on_select', 'on_dismiss')\n\n    def __init__(self, **kwargs):\n        self._win = None\n        if 'min_state_time' not in kwargs:\n            self.min_state_time = float(\n                Config.get('graphics', 'min_state_time'))\n        if 'container' not in kwargs:\n            c = self.container = Builder.load_string(_grid_kv)\n        else:\n            c = None\n        if 'allow_sides' not in kwargs:\n            self.allow_sides = False\n        if 'do_scroll_x' not in kwargs:\n            self.do_scroll_x = False\n        if 'size_hint' not in kwargs:\n            if 'size_hint_x' not in kwargs:\n                self.size_hint_x = None\n            if 'size_hint_y' not in kwargs:\n                self.size_hint_y = None\n        super(DropDown, self).__init__(**kwargs)\n        if c is not None:\n            super(DropDown, self).add_widget(c)\n            self.on_container(self, c)\n        Window.bind(\n            on_key_down=self.on_key_down,\n            size=self._reposition)\n        self.fbind('size', self._reposition)\n\n    def on_key_down(self, instance, key, scancode, codepoint, modifiers):\n        if key == 27 and self.get_parent_window():\n            self.dismiss()\n            return True\n\n    def on_container(self, instance, value):\n        if value is not None:\n            self.container.bind(minimum_size=self._container_minimum_size)\n\n    def open(self, widget):\n        '''Open the dropdown list and attach it to a specific widget.\n        Depending on the position of the widget within the window and\n        the height of the dropdown, the dropdown might be above or below\n        that widget.\n        '''\n        # ensure we are not already attached\n        if self.attach_to is not None:\n            self.dismiss()\n\n        # we will attach ourself to the main window, so ensure the\n        # widget we are looking for have a window\n        self._win = widget.get_parent_window()\n        if self._win is None:\n            raise DropDownException(\n                'Cannot open a dropdown list on a hidden widget')\n\n        self.attach_to = widget\n        widget.bind(pos=self._reposition, size=self._reposition)\n        self._reposition()\n\n        # attach ourself to the main window\n        self._win.add_widget(self)\n\n    def dismiss(self, *largs):\n        '''Remove the dropdown widget from the window and detach it from\n        the attached widget.\n        '''\n        Clock.schedule_once(lambda dt: self._real_dismiss(),\n                            self.min_state_time)\n\n    def _real_dismiss(self):\n        if self.parent:\n            self.parent.remove_widget(self)\n        if self.attach_to:\n            self.attach_to.unbind(pos=self._reposition, size=self._reposition)\n            self.attach_to = None\n        self.dispatch('on_dismiss')\n\n    def on_dismiss(self):\n        pass\n\n    def select(self, data):\n        '''Call this method to trigger the `on_select` event with the `data`\n        selection. The `data` can be anything you want.\n        '''\n        self.dispatch('on_select', data)\n        if self.dismiss_on_select:\n            self.dismiss()\n\n    def on_select(self, data):\n        pass\n\n    def _container_minimum_size(self, instance, size):\n        if self.max_height:\n            self.height = min(size[1], self.max_height)\n            self.do_scroll_y = size[1] > self.max_height\n        else:\n            self.height = size[1]\n            self.do_scroll_y = True\n\n    def add_widget(self, *largs):\n        if self.container:\n            return self.container.add_widget(*largs)\n        return super(DropDown, self).add_widget(*largs)\n\n    def remove_widget(self, *largs):\n        if self.container:\n            return self.container.remove_widget(*largs)\n        return super(DropDown, self).remove_widget(*largs)\n\n    def clear_widgets(self):\n        if self.container:\n            return self.container.clear_widgets()\n        return super(DropDown, self).clear_widgets()\n\n    def on_touch_down(self, touch):\n        if super(DropDown, self).on_touch_down(touch):\n            return True\n        if self.collide_point(*touch.pos):\n            return True\n        if (self.attach_to and self.attach_to.collide_point(\n                *self.attach_to.to_widget(*touch.pos))):\n            return True\n        if self.auto_dismiss:\n            self.dismiss()\n\n    def on_touch_up(self, touch):\n        if super(DropDown, self).on_touch_up(touch):\n            return True\n        if 'button' in touch.profile and touch.button.startswith('scroll'):\n            return\n        if self.collide_point(*touch.pos):\n            return True\n        if self.auto_dismiss:\n            self.dismiss()\n\n    def _reposition(self, *largs):\n        # calculate the coordinate of the attached widget in the window\n        # coordinate system\n        win = self._win\n        widget = self.attach_to\n        if not widget or not win:\n            return\n        wx, wy = widget.to_window(*widget.pos)\n        wright, wtop = widget.to_window(widget.right, widget.top)\n\n        # set width and x\n        if self.auto_width:\n            self.width = wright - wx\n\n        # ensure the dropdown list doesn't get out on the X axis, with a\n        # preference to 0 in case the list is too wide.\n        if self.allow_sides:\n            if not self.auto_width:\n                x = wx + widget.right\n            else:\n                x = wx + self.width\n            if x + self.width > win.width:\n                x = wx - self.width\n        else:\n            x = wx\n            if x + self.width > win.width:\n                x = win.width - self.width\n        if x < 0:\n            x = 0\n        self.x = x\n\n        # determine if we display the dropdown upper or lower to the widget\n        h_bottom = wy - self.height\n        h_top = win.height - (wtop + self.height)\n        if h_bottom > 0:\n            if self.allow_sides:\n                self.top = wy + widget.height\n            else:\n                self.top = wy\n            self.height = self.container.minimum_height\n        elif h_top > 0:\n            if self.allow_sides:\n                self.y = wtop - widget.height\n            else:\n                self.y = wtop\n            self.height = self.container.minimum_height\n        else:\n            # none of both top/bottom have enough place to display the\n            # widget at the current size. Take the best side, and fit to\n            # it.\n            height = max(h_bottom, h_top)\n            if height == h_bottom:\n                if self.allow_sides:\n                    self.top = wy + widget.height\n                else:\n                    self.top = wy\n                self.height = wy\n            else:\n                if self.allow_sides:\n                    self.y = wtop - widget.height\n                else:\n                    self.y = wtop\n                self.height = win.height - wtop\n\n\nif __name__ == '__main__':\n    from kivy.uix.button import Button\n    from kivy.base import runTouchApp\n\n    def show_dropdown(button, *largs):\n        dp = DropDown(allow_sides=True)\n        dp.bind(on_select=lambda instance, x: setattr(button, 'text', x))\n        for i in range(10):\n            item = Button(text='hello %d' % i, size_hint_y=None, height=44)\n            item.bind(on_release=lambda btn: dp.select(btn.text))\n            dp.add_widget(item)\n        dp.open(button)\n\n    def touch_move(instance, touch):\n        instance.center = touch.pos\n\n    btn = Button(text='SHOW', size_hint=(None, None), pos=(300, 200))\n    btn.bind(on_release=show_dropdown, on_touch_move=touch_move)\n\n    runTouchApp(btn)\n"""
krysa/main.py,0,"b'# -*- coding: utf-8 -*-\n# KrySA - Statistical analysis for rats\n# Version: 0.6.1\n# Copyright (C) 2016 - 2017, KeyWeeUsr(Peter Badida) <keyweeusr@gmail.com>\n# License: GNU GPL v3.0, More info in LICENSE.txt\n\n# Setting maximized Window\nfrom kivy.config import Config\nimport os\n\n# Local & RTD docs fix\nif not any([\'BUILDDIR\' in os.environ, \'READTHEDOCS\' in os.environ]):\n    Config.set(\'graphics\', \'window_state\', \'maximized\')\n\n# Python-only imports\nimport re\nimport json\nimport math\nimport string\nimport sqlite3\nfrom io import open\nimport os.path as op\nfrom functools import partial\nfrom time import gmtime, strftime\n\n# Kivy imports\nfrom kivy.app import App\nfrom kivy.metrics import dp\nfrom kivy.clock import Clock\nfrom dropdown import DropDown\nfrom kivy.logger import Logger\nfrom kivy.uix.popup import Popup\nfrom kivy.uix.image import Image\nfrom kivy.uix.label import Label\nfrom kivy.uix.widget import Widget\nfrom kivy.uix.button import Button\nfrom kivy.graphics import Color, Line\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.uix.textinput import TextInput\nfrom kivy.uix.scrollview import ScrollView\nfrom kivy.uix.gridlayout import GridLayout\nfrom kivy.uix.recycleview import RecycleView\nfrom kivy.uix.floatlayout import FloatLayout\nfrom kivy.uix.stencilview import StencilView\nfrom kivy.uix.behaviors import ButtonBehavior\nfrom kivy.uix.tabbedpanel import TabbedPanelItem\nfrom kivy.uix.treeview import TreeView, TreeViewLabel\nfrom kivy.uix.recyclegridlayout import RecycleGridLayout\nfrom kivy.properties import (\n    StringProperty,\n    ObjectProperty,\n    BooleanProperty,\n    ListProperty\n)\n\n# KrySA packages\nimport utils\nfrom tasks import Task\nfrom tasks.basic import Basic\nfrom tasks.avgs import Avgs\nfrom tasks.manipulate import Manipulate\nfrom tasks.plot import Plot\n\n\nclass ResultGrid(GridLayout):\n    \'\'\'A black gridlayout, together with :mod:`main.Wrap` makes a table\n    container for results that need a table.\n\n    .. versionadded:: 0.3.2\n    \'\'\'\n\n\nclass Wrap(Label):\n    \'\'\'A white label with automatically wrapped text.\n\n    .. versionadded:: 0.3.2\n    \'\'\'\n    background_color = ListProperty([0, 0, 0, 0])\n\n\nclass PageBox(BoxLayout):\n    \'\'\'A layout that includes Page widget together with transparent separator.\n    It\'s used for adding new results from Tasks.\n\n    .. versionadded:: 0.2.0\n    \'\'\'\n    def __init__(self, **kwargs):\n        super(PageBox, self).__init__(**kwargs)\n        self.add_widget = self.ids.page.add_widget\n\n\nclass PaperLabel(Label):\n    \'\'\'A label with visual properties as a paper sheet.\n\n    .. versionadded:: 0.2.0\n    \'\'\'\n\n\nclass ImgButton(Button):\n    \'\'\'A button with an image of square shape in the middle.\n\n    .. versionadded:: 0.2.0\n    \'\'\'\n    source = StringProperty(\'\')\n\n\nclass ErrorPop(Popup):\n    \'\'\'An error popup to let user know something is missing or typed wrong\n    when console is disabled.\n\n    .. versionadded:: 0.1.2\n    \'\'\'\n    message = StringProperty(\'\')\n\n    def __init__(self, msg=\'\', **kwargs):\n        self.message = msg\n        super(ErrorPop, self).__init__(**kwargs)\n\n\nclass NewDataValue(BoxLayout):\n    \'\'\'A layout handling the behavior of inputs and button for each new\n    value in :ref:`data`.\n\n    .. versionadded:: 0.1.4\n    \'\'\'\n    def __init__(self, filter=None, **kwargs):\n        self.app = App.get_running_app()\n        super(NewDataValue, self).__init__(**kwargs)\n        self.filter = filter\n\n\nclass NewDataColumn(BoxLayout):\n    \'\'\'A layout handling the behavior of type, values(``NewDataValue``) and\n    some buttons for each new column in :ref:`data`.\n\n    .. versionadded:: 0.1.4\n    \'\'\'\n    def __init__(self, **kw):\n        self.app = App.get_running_app()\n        super(NewDataColumn, self).__init__(**kw)\n\n    @staticmethod\n    def free(items):\n        \'\'\'Free all locked cells in the column except a column type. If\n        a wrong type is used, removing the whole column is necessary.\n        (protection against corrupting :ref:`sqlite`)\n\n        .. versionadded:: 0.1.4\n        \'\'\'\n        for item in items:\n            if hasattr(item, \'disabled\'):\n                try:\n                    if item.parent.ids[\'coltype\'] == item:\n                        continue\n                except:\n                    item.disabled = False\n            else:\n                # enable children\n                for i in item:\n                    try:\n                        if i.parent.ids[\'coltype\'] == item:\n                            continue\n                    except:\n                        i.disabled = False\n\n    def checklock(self, disable, coltype, check, *args):\n        \'\'\'Disable all cells in the column, then check them against a list\n        of strings that could be used to corrupt :ref:`sqlite` . If the check\n        is done without an error, another check is made to protect against\n        using an empty string ``\'\'`` as a value, which if used inappropriately\n        results in a crash.\n\n        .. versionadded:: 0.1.4\n        \'\'\'\n        msg = \'Please remove any SQL keyword present in the column!\'\n\n        for item in disable:\n            if hasattr(item, \'disabled\'):\n                item.disabled = True\n            else:\n                # disable children\n                for i in item:\n                    i.disabled = True\n\n        # check for any sql keywords and correct values\n        for item in check:\n            try:\n                for keyword in self.app.sql_blacklist:\n                    if keyword in item.text.upper():\n                        error = ErrorPop(msg=msg)\n                        error.open()\n                        return\n            except AttributeError:\n                for i in item.children:\n                    for keyword in self.app.sql_blacklist:\n                        if keyword in i.ids.value.text.upper():\n                            error = ErrorPop(msg=msg)\n                            error.open()\n                            return\n                    try:\n                        if not coltype.text == \'TEXT\':\n                            float(i.ids.value.text)\n                    except ValueError:\n                        if coltype.text == \'REAL\':\n                            i.ids.value.text = \'0.0\'\n                        elif coltype.text == \'INTEGER\':\n                            i.ids.value.text = \'0\'\n\n    def paste(self, values, sep):\n        \'\'\'Paste a value(s) from a user\'s clipboard as a column values. A user\n        can choose what kind of separator was used on the values, for example::\n\n            1 2 3 4 5     # (space)\n            1\\\\t2\\\\t3\\\\t4\\\\t  # (tab)\n            1\\\\n2\\\\n3\\\\n4\\\\n  # Unix-like new line character (<enter>/<return>)\n\n        If in doubt and your values were copied from a column (e.g.\n        spreadsheet), use `OS default`, which will choose between ``\\\\n``\n        (Unix-like) or ``\\\\r\\\\n`` (Windows) new line separators.\n\n        .. versionadded:: 0.3.4\n        \'\'\'\n        if sep == \'space\':\n            values = values.split(\' \')\n        elif sep == \'OS default\':\n            values = values.split(os.linesep)\n        else:\n            values = values.split(sep[1:])\n        for val in values:\n            v = NewDataValue(filter=self.filter)\n            v.ids.value.text = val\n            self.ids.vals.add_widget(v)\n        self.ids.vals.parent.scroll_to(self.ids.vals.children[0])\n\n\nclass NewDataLayout(BoxLayout):\n    \'\'\'A layout handling the behavior of ``NewDataColumn`` and some inputs for\n    each new value in :ref:`data`.\n\n    .. versionadded:: 0.1.3\n    \'\'\'\n    def __init__(self, **kw):\n        self.app = App.get_running_app()\n        super(NewDataLayout, self).__init__(**kw)\n\n\nclass CreateWizard(Popup):\n    \'\'\'A popup handling the behavior for creating a new :ref:`data`,\n    i.e a wizard.\n\n    .. versionadded:: 0.1.3\n    \'\'\'\n    run = ObjectProperty(None)\n\n    def __init__(self, wdg=None, run=None, **kwargs):\n        super(CreateWizard, self).__init__(**kwargs)\n        self.run = run\n        if wdg:\n            self.ids.container.add_widget(wdg)\n\n\nclass Dialog(Popup):\n    \'\'\'A dialog handling the behavior for creating or opening files e.g.\n    :ref:`project` or :ref:`data`.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    confirm = StringProperty(\'\')\n    run = ObjectProperty(None)\n    dirs = BooleanProperty(False)\n    project = BooleanProperty(False)\n    filter = ListProperty([])\n\n    def __init__(self, **kw):\n        super(Dialog, self).__init__(**kw)\n        self.confirm = kw.get(\'confirm\', \'\')\n        self.run = kw.get(\'run\')\n        self.dirs = kw.get(\'dirs\', False)\n        self.project = kw.get(\'project\', False)\n        if self.project:\n            self.ids.name.hint_text = \'Project.krysa\'\n            self.filter = [lambda folder, fname: fname.endswith(\'.krysa\')]\n        else:\n            self.ids.name.hint_text = \'example.sqlite\'\n            self.filter = [lambda folder, fname: fname.endswith(\'.sqlite\')]\n\n\nclass TableItem(TextInput):\n    \'\'\'An item handling the behavior or each separate value in the\n    :mod:`main.Table` such as updating/editing values in :ref:`data`.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    def __init__(self, **kwargs):\n        super(TableItem, self).__init__(**kwargs)\n        self.bind(focus=self.on_focus)\n\n    def on_focus(self, widget, focused):\n        \'\'\'Make sure the unconfirmed value is discarded e.g. when clicked\n        outside of the widget.\n        \'\'\'\n        if not focused:\n            self.text = self.old_text\n\n    def update_value(self, txt, *args):\n        \'\'\'Update a value in :mod:`main.TableItem.text` on ``<enter>``\n        (``<return>``) and change :mod:`main.TableItem.old_text` in\n        :mod:`main.Table`.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        data = []\n        cols = self.cols - 1\n\n        for i in self.origin.data:\n            if \'cell\' in i:\n                data.append(i)\n        chunks = [data[x:x + cols] for x in range(0, len(data), cols)]\n\n        orig_type = type(chunks[self.r][self.c - 1])\n        place = self.cols * (self.r + 1) - (self.cols - self.c)\n        self.origin.data[place][\'text\'] = txt\n        self.origin.data[place][\'old_text\'] = txt\n        self.origin.refresh_from_data()\n\n\nclass Table(ScrollView):\n    \'\'\'A view handling the behavior of the inputs from :ref:`sqlite`. Separates\n    the values from :ref:`sqlite` according to its :ref:`data`\'s column types\n    into three Python categories - `int`, `float` or `unicode` and assigns\n    an alphabetic order for each column together with row number to each value.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    # use with ....add_widget(Table(max_cols=3, max_rows=3))\n    # Grid -> Scroll, grid as container - better for sizing and placing\n\n    # set ""address"" for table pos in grid to item\n    number_size = (30, 30)\n    default_size = (100, 30)\n\n    def __init__(self, max_rows=1, max_cols=1, values=[], labels=None,\n                 types=None, **kwargs):\n        app = App.get_running_app()\n        self.rv = RecycleView(bar_width=\'10dp\',\n                              scroll_type=[\'bars\', \'content\'])\n        container = RecycleGridLayout(size_hint=(None, None))\n        container.viewclass = TableItem\n        container.bind(minimum_size=container.setter(\'size\'))\n\n        self.max_rows = max_rows\n        self.rows = self.max_rows + 1\n        self.max_cols = max_cols\n        self.cols = self.max_cols + 1\n        self.values = values\n        self.labels = labels\n        self.types = types\n\n        container.rows = self.rows\n        container.cols = self.cols\n\n        ltr = [\' (\' + letter + \')\' for letter in self.get_letters()]\n        self.rv.add_widget(container)\n\n        if \'item_size\' not in kwargs:\n            item_size = self.default_size\n        super(Table, self).__init__(**kwargs)\n        for r in range(self.rows):\n            for c in range(self.cols):\n                if r == 0:\n                    if c == 0:\n                        self.rv.data.append({\'text\': u\'\', \'disabled\': True,\n                                             \'size\': self.number_size,\n                                             \'origin\': self.rv})\n                    else:\n                        self.rv.data.append(\n                            {\n                                \'text\': self.labels[c - 1] + ltr[c - 1],\n                                \'_text\': self.labels[c - 1],\n                                \'disabled\': True,\n                                \'cell\': \'label\' + str(c - 1),\n                                \'type\': type(u\'\'),\n                                \'size\': self.default_size,\n                                \'origin\': self.rv\n                            }\n                        )\n                else:\n                    if c == 0:\n                        self.rv.data.append({\'text\': str(r),\n                                             \'disabled\': True,\n                                             \'size\': self.number_size,\n                                             \'origin\': self.rv})\n                    else:\n                        filter = app.root.simple_chars\n                        try:\n                            val = self.values.pop(0)\n                            text_type = type(val)\n                            filter_val = repr(text_type)[7:-2]\n                            if filter_val in [\'int\', \'float\']:\n                                filter = filter_val\n                        except IndexError:\n                            Logger.info(\'KrySA: values < space\')\n                            val = \'.\'\n\n                        if \'e+\' in str(val) or \'e-\' in str(val):\n                            val = \'{0:.10f}\'.format(val)\n                        if self.types:\n                            if self.types[c - 1] == \'INTEGER\':\n                                filter = \'int\'\n                                text_type = type(1)\n                            elif self.types[c - 1] == \'REAL\':\n                                filter = \'float\'\n                                text_type = type(1.1)\n                        self.rv.data.append(\n                            {\n                                \'text\': str(val),\n                                \'old_text\': str(val),\n                                \'disabled\': False,\n                                \'cell\': self.labels[c - 1] + str(r),\n                                \'r\': r,\n                                \'rows\': self.rows,\n                                \'c\': c,\n                                \'cols\': self.cols,\n                                \'type\': text_type,\n                                \'size\': self.default_size,\n                                \'input_filter\': filter,\n                                \'origin\': self.rv\n                            }\n                        )\n        if self.values:\n            raise Exception(\'Not enough space for all values! \\\n                            Increase rows/cols!\')\n        self.add_widget(self.rv)\n\n    def get_letters(self):\n        \'\'\'Get a list of letters the same length as :ref:`data`\'s columns.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        letters = [chr(letter + 65) for letter in range(26)]\n        result = []\n        label = []\n        cols = range(self.cols + 1)\n        for i in cols:\n            if i != 0:\n                while i:\n                    i, rem = divmod(i - 1, 26)\n                    label[:0] = letters[rem]\n                result.append(\'\'.join(label))\n                label = []\n        return result\n\n    def lock(self, disabled=True):\n        \'\'\'Disable cells in :mod:`main.Table` which can\'t be accessed\n        with the letter-number style (e.g. ``A1:B2``).\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        for i in self.rv.data:\n            if \'cell\' in i and \'label\' not in i[\'cell\']:\n                i[\'disabled\'] = disabled\n        self.rv.refresh_from_data()\n\n    def clean(self, *args):\n        \'\'\'Remove all data from :mod:`main.Table`\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        self.rv.data = []\n\n\nclass ProcessFlowSep(Widget):\n    \'\'\'A line separator between :mod:`main.ProcessFlowMain` items.\n    The line can be either horizontal or vertical.\n\n    :Parameters:\n       `orientation`: string\n          Choose a string from [\'horizontal\', \'vertical\'], defaults to\n          `horizontal`.\n\n    .. versionadded:: 0.5.0\n    \'\'\'\n    def __init__(self, orientation=\'horizontal\', **kwargs):\n        super(ProcessFlowSep, self).__init__(**kwargs)\n        self.orientation = orientation\n        if self.orientation == \'vertical\':\n            self.height = dp(64)\n            points = [self.pos[0],\n                      self.pos[1] + self.size[1] / 2.0,\n                      self.pos[0] + self.size[0],\n                      self.pos[1] + self.size[1] / 2.0]\n        elif self.orientation == \'horizontal\':\n            self.width = dp(64)\n            points = [self.pos[0] + self.size[0] / 2.0,\n                      self.pos[1],\n                      self.pos[0] + self.size[0] / 2.0,\n                      self.pos[1] + self.size[1]]\n        with self.canvas:\n            Color(0, 0, 0, 1)\n            Line(points=points, width=1)\n\n\nclass ProcessFlowMain(ButtonBehavior, BoxLayout):\n    \'\'\'An item on the :mod:`main.ProcessFlow`, provides a label\n    with its name, an icon and a touch behavior that opens its\n    target with system\'s default program for such target.\n\n    .. versionadded:: 0.5.0\n    \'\'\'\n    source = StringProperty(\'\')\n\n    def __init__(self, link=None, source=None, **kwargs):\n        self.name = kwargs.pop(\'name\')\n        app = App.get_running_app()\n        super(ProcessFlowMain, self).__init__(**kwargs)\n        if link:\n            self.bind(on_release=link)\n        if source:\n            self.source = source\n        else:\n            self.source = op.join(app.path, \'data\', \'head.png\')\n\n\nclass ProcessFlow(FloatLayout, StencilView):\n    \'\'\'A canvas on which are displayed files in project folders with\n    a touch event opening them in the default program.\n\n    ToDo: more items such as displaying tasks.\n\n    .. versionadded:: 0.1.0\n    .. versionchanged:: 0.5.0\n       Implemented icons with a behavior representing the :ref:`project`\n       structure.\n    \'\'\'\n    def __init__(self, **kwargs):\n        super(ProcessFlow, self).__init__(**kwargs)\n        self.app = App.get_running_app()\n        self.app.flow = self\n        self.texture = Image(source=self.app.path + \'/data/grid.png\').texture\n        self.texture.wrap = \'repeat\'\n        self.boxes = {}\n\n    def add_project(self):\n        \'\'\'Add a root item for the other items on the :mod:`main.ProcessFlow`.\n\n        .. versionadded:: 0.5.0\n        \'\'\'\n        project = ProcessFlowMain\n        pos = [dp(50), self.size[1] - dp(132)]\n        self.boxes[\'project\'] = pos\n        self.add_widget(project(name=self.app.project_name, pos=pos))\n\n    def add_mainitem(self, name, link):\n        \'\'\'Add a main item on the same level as the :ref:`project`.\n\n        :Parameters:\n           `name`: string\n              Used as a text for label.\n           `link`: path (string)\n              Used for a touch event.\n\n        .. versionadded:: 0.5.0\n        \'\'\'\n        mainitem = ProcessFlowMain\n        sep = ProcessFlowSep\n        if \'mainitems\' in self.boxes.keys():\n            sep_pos = [dp(66), self.boxes[\'mainitems\'][-1][1] - dp(132)]\n            pos = [dp(50), self.boxes[\'mainitems\'][-1][1] - dp(264), name]\n            sep_height = sep_pos[1] - pos[1] - dp(8)\n            self.boxes[\'mainitems\'].append(pos)\n        else:\n            sep_pos = [dp(66), self.boxes[\'project\'][1] - dp(132)]\n            pos = [dp(50), self.boxes[\'project\'][1] - dp(264), name]\n            sep_height = sep_pos[1] - pos[1] - dp(8)\n            self.boxes[\'mainitems\'] = [list(pos), ]\n        link = utils.create_bind(link)\n        path = op.join(self.app.path, \'data\')\n        if name == \'plots\':\n            image = op.join(path, \'head_plots.png\')\n        elif name == \'data\':\n            image = op.join(path, \'head_data.png\')\n        elif name == \'results\':\n            image = op.join(path, \'head_image.png\')\n        else:\n            image = \'\'\n        self.add_widget(sep(pos=sep_pos, height=sep_height))\n        self.add_widget(mainitem(name=name, pos=pos[:2],\n                                 link=link, source=image))\n\n    def add_subitem(self, name, link, parent):\n        \'\'\'Add a subitem under an existing :mod:`main.ProcessFlowMain`.\n\n        :Parameters:\n           `name`: string\n              Used as a text for label\n           `link`: path (string)\n              Used for a touch event\n           `parent`: string\n              Used to create a key for subitems e.g. `myparent-subitems`\n\n        .. versionadded:: 0.5.0\n        \'\'\'\n        mainitem = ProcessFlowMain\n        sep = ProcessFlowSep\n        parent_pos = None\n        for p in self.boxes[\'mainitems\']:\n            if parent in p[2]:\n                parent_pos, parent = p[:2], p[2]\n        subitems = \'{}-subitems\'.format(parent)\n\n        if subitems in self.boxes.keys():\n            sep_pos = [self.boxes[subitems][-1][0] + dp(100),\n                       self.boxes[subitems][-1][1] + dp(16)]\n            pos = [self.boxes[subitems][-1][0] + dp(200),\n                   self.boxes[subitems][-1][1]]\n            sep_width = pos[0] - sep_pos[0] - dp(16)\n            self.boxes[subitems].append(pos)\n        else:\n            sep_pos = [parent_pos[0] + dp(100), parent_pos[1] + dp(16)]\n            pos = [self.boxes[\'project\'][0] + dp(200), parent_pos[1]]\n            sep_width = pos[0] - sep_pos[0] - dp(16)\n            self.boxes[subitems] = [list(pos), ]\n        link = utils.create_bind(link)\n        self.add_widget(sep(pos=sep_pos, width=sep_width,\n                            orientation=\'vertical\'))\n        self.add_widget(mainitem(name=name, pos=pos, link=link))\n\n    def resize(self, *args):\n        \'\'\'Resize the :mod:`main.ProcessFlow` to encapsulate its children.\n\n        .. versionadded:: 0.5.0\n        \'\'\'\n        # should be better handled in the future\n        width = sum([c.width for c in self.children])\n        if width > dp(2000):\n            self.width = width\n\n    def flush(self):\n        \'\'\'Remove every item previously added to :mod:`main.ProcessFlow`\n        and clean all stored positions.\n\n        .. versionadded:: 0.5.0\n        \'\'\'\n        self.boxes = {}\n        self.clear_widgets()\n\n\nclass SizedButton(Button):\n    \'\'\'A button with width automatically customized according to text length of\n    its siblings, which makes every sibling the same size as the one with the\n    longest text string.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    def correct_width(self, *args):\n        self.width = self.texture_size[0] + 8\n        self.parent.parent.width = max([c.width for c in self.parent.children])\n        for child in self.parent.children:\n            child.width = self.parent.parent.width\n\n\nclass MenuDrop(DropDown):\n    \'\'\'A list of :mod:`main.SizedButton` s displayed as a menu, where each\n    button may create another menu depending on the function bound to it. The\n    main menu is handled through a single instance of :mod:`main.MenuDrop`\n    which is instantiated before :mod:`main.Krysa.build` function.\n\n    Each click/tap on the menu button then assigns a value to it from\n    ``App.menu`` dictionary according to its name in `kv` file.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    def __init__(self, **kwargs):\n        app = App.get_running_app()\n        app.drop = self\n        super(MenuDrop, self).__init__(**kwargs)\n\n    def click(self, instance, values):\n        for value in values:\n            btn = SizedButton(text=value[0])\n            btn.bind(on_release=value[1])\n            self.add_widget(btn)\n        self.open(instance)\n\n    def on_dismiss(self, *args):\n        self.clear_widgets()\n\n\nclass Body(FloatLayout):\n    \'\'\'The main layout for the application. It handles menu values, their\n    appropriate functions, filtering of user\'s input and functions for\n    accessing :ref:`sqlite` in :mod:`main.Table`.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n    def __init__(self, **kwargs):\n        self.app = App.get_running_app()\n        self.tables = []\n        self.app.menu = {\'file\': ([\'New...\', self.new],\n                                  [\'Open Project\', self.open_project],\n                                  [\'Close Project\', self.close_project],\n                                  [\'Save Project\', self.save_project],\n                                  [\'Import Data\', self.import_data],\n                                  [\'Export Data\', self.export_data],\n                                  [\'Recent Projects\', self.recent_projects],\n                                  [\'Exit\', self.app.stop],),\n                         \'edit\': ([\'_Undo\', self.test],\n                                  [\'_Redo\', self.test],\n                                  [\'_Cut\', self.test],\n                                  [\'_Copy\', self.test],\n                                  [\'_Paste\', self.test],\n                                  [\'_Delete\', self.test],\n                                  [\'_Find...\', self.test],\n                                  [\'_Replace...\', self.test],\n                                  [\'_Protect Data\', self.test],\n                                  [\'_Go To...\', self.test],),\n                         \'tasks\': ([\'Basic\', self.basic],\n                                   [\'Averages\', self.avgs],\n                                   [\'Manipulate\', self.manipulate],\n                                   [\'Plot\', self.plot],),\n                         \'help\': ([\'_KrySA Help\', self.test],\n                                  [\'_Getting Started Tutorial\', self.test],\n                                  [\'About KrySA\', self.about],),\n                         }\n        super(Body, self).__init__(**kwargs)\n\n    def new(self, button, *args):\n        d = DropDown(allow_sides=True, auto_width=False)\n        buttons = []\n        buttons.append(SizedButton(text=\'Project\'))\n        buttons[0].bind(on_release=self._new_project)\n        buttons.append(SizedButton(text=\'Data\'))\n        buttons[1].bind(on_release=self._new_data)\n        for b in buttons:\n            d.add_widget(b)\n        d.open(button)\n\n    def _new_project(self, *args):\n        \'\'\'Close already opened :ref:`project` if available and open a dialog\n        for creating a new one.\n\n        .. versionadded:: 0.1.2\n        \'\'\'\n        self.close_project()\n        self.savedlg = Dialog(title=\'New Project\',\n                              confirm=\'Save\',\n                              run=self._save_project,\n                              dirs=True,\n                              project=True)\n        self.savedlg.open()\n\n    def _new_data(self, *args):\n        \'\'\'Open a wizard for creating a new :ref:`data` if a :ref:`project` is\n        available or show a warning if it doesn\'t exist.\n\n        .. versionadded:: 0.1.3\n        \'\'\'\n        if not self.app.project_exists:\n            error = ErrorPop(msg=\'No project exists!\')\n            error.open()\n            return\n        widget = NewDataLayout()\n        self.wiz_newdata = CreateWizard(title=\'New Data\', wdg=widget,\n                                        run=partial(self._save_data, widget))\n        self.wiz_newdata.open()\n\n    def _save_data(self, wizard, *args):\n        \'\'\'Get data from the wizard, put them into :mod:`main.Table` and export them\n        into :ref:`sqlite`.\n\n        .. versionadded:: 0.1.4\n        \'\'\'\n        labels = []\n        types = []\n        values = []\n        table_name = wizard.ids.table_name.text\n\n        if not len(table_name):\n            error = ErrorPop(msg=\'Please name your data!\')\n            error.open()\n            return\n        if not len(wizard.ids.columns.children):\n            error = ErrorPop(msg=\'There must be at least one column!\')\n            error.open()\n            return\n\n        for child in reversed(wizard.ids.columns.children):\n            child.ids.checklock.dispatch(\'on_release\')\n        for child in reversed(wizard.ids.columns.children):\n            if child.ids.colname.text not in labels:\n                lbl = re.findall(r\'([a-zA-Z0-9])\', child.ids.colname.text)\n                if not len(lbl):\n                    error = ErrorPop(msg=\'Use only a-z A-Z 0-9 characters!\')\n                    error.open()\n                    return\n                labels.append(\'\'.join(lbl))\n            else:\n                error = ErrorPop(msg=\'Each column must have a unique name!\')\n                error.open()\n                return\n\n            types.append(child.ids.coltype.text)\n            column_values = []\n\n            for value_wdg in reversed(child.ids.vals.children):\n                column_values.append(value_wdg.ids.value.text)\n            values.append(column_values)\n\n        max_cols = len(values)\n        max_rows = len(max(values, key=len))\n\n        # create table in KrySA, then export\n        tabletab = TabbedPanelItem(text=table_name)\n        self.ids.tabpanel.add_widget(tabletab)\n        _values = values[:]\n        values = []\n\n        for i in range(max_rows):\n            for j in range(max_cols):\n                try:\n                    values.append(_values[j][i])\n                except IndexError:\n                    if types[j] == \'INTEGER\':\n                        values.append(0)\n                    elif types[j] == \'REAL\':\n                        values.append(0.0)\n                    else:\n                        values.append(u\'\')\n\n        self.tables.append((table_name, Table(max_cols=max_cols,\n                                              max_rows=max_rows, pos=self.pos,\n                                              size=self.size, values=values,\n                                              labels=labels, types=types)))\n        tabletab.content = self.tables[-1][1]\n\n        # export to data.sqlite in <project>/data directory\n        data = op.join(self.app.project_dir, \'data\')\n\n        self._export_data([data], \'data.sqlite\')\n        self.wiz_newdata.dismiss()\n\n    def open_project(self, *args):\n        self.close_project()\n        self.opendlg = Dialog(title=\'Open Project\',\n                              confirm=\'Open\',\n                              run=self._open_project,\n                              project=True)\n        self.opendlg.open()\n\n    def _open_project(self, selection, *args):\n        \'\'\'Open a :ref:`project` from path selected in ``Dialog`` and import\n        :ref:`sqlite`.\n\n        .. versionadded:: 0.1.7\n        \'\'\'\n        if not selection:\n            return\n        else:\n            selection, fname = op.split(selection[0])\n\n        data = op.join(selection, \'data\')\n        results = op.join(selection, \'results\')\n        plots = op.join(selection, \'plots\')\n\n        self.app.project_exists = True\n        self.app.project_dir = selection\n        self.app.project_name = fname.split(\'.\')[0]\n\n        # (dummy for now)\n        # dump widgets\' properties from process flow to dict, then to json\n        with open(op.join(selection, fname)) as f:\n            project = json.loads(f.read())\n        # print project\n\n        # import from project automatically\n        self._import_data([op.join(data, \'data.sqlite\')])\n\n        # import results\n        for file in sorted(os.listdir(results)):\n            self.set_page(\'\', op.join(results, file), result_type=\'import\')\n\n        # load items to ProcessFlow\n        self.flow_reload()\n        Logger.info(\'KrySA: Opened project {}.\'.format(self.app.project_name))\n\n    def close_project(self, *args):\n        \'\'\'Clear all important variables, remove all :ref:`data` available in\n        :mod:`main.Table`, clear results and switch to :mod:`main.ProcessFlow`.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        # call this before a new project\n\n        # Clear variables\n        self.app.project_exists = False\n        self.app.project_dir = \'\'\n        self.app.project_name = \'\'\n\n        # Clear tabs\n        tp = self.ids.tabpanel\n        while len(tp.tab_list) > 1:\n            self.tables.pop()\n            tp.remove_widget(tp.tab_list[0])\n        tp.switch_to(tp.tab_list[0])\n\n        # Flush Flow\n        self.app.flow.flush()\n\n        # Remove old results\n        self.ids.results.clear_widgets()\n        spacer = Widget(size_hint_y=None, height=\'5dp\')\n        self.ids.results.add_widget(spacer)\n\n    def save_project(self, *args):\n        # same as _new_project + export data & results\n\n        # make some output if unsaved changes available(e.g. * before name)\n        if self.app.project_exists:\n            self._save_project()\n            Logger.info(\'KrySA: Opened project exists, rewriting.\')\n            return\n        self.savedlg = Dialog(title=\'New Project\',\n                              confirm=\'Save\',\n                              run=self._save_project,\n                              dirs=True,\n                              project=True)\n        self.savedlg.open()\n\n    def _save_project(self, selection=None, fname=None, *args):\n        \'\'\'Save a :ref:`project` to path selected in ``Dialog`` and export\n        :ref:`sqlite`.\n\n        .. versionadded:: 0.1.2\n        \'\'\'\n        Logger.info(\'KrySA: Saving project.\')\n        if not selection:\n            if not self.app.project_exists:\n                return\n            selection = op.dirname(self.app.project_dir)\n            fname = self.app.project_name\n        else:\n            selection = selection[0]\n        if \'.\' not in fname:\n            fname = fname + \'.krysa\'\n\n        if selection != op.dirname(self.app.project_dir):\n            try:\n                os.mkdir(op.join(selection, fname.split(\'.\')[0]))\n            except OSError:\n                error = ErrorPop(msg=\'Project folder already exists!\')\n                error.open()\n                return\n\n        selection = op.join(selection, fname.split(\'.\')[0])\n        data = op.join(selection, \'data\')\n        results = op.join(selection, \'results\')\n        plots = op.join(selection, \'plots\')\n        if selection != self.app.project_dir:\n            os.mkdir(data)\n            os.mkdir(results)\n            os.mkdir(plots)\n        if op.exists(op.join(selection, fname)):\n            os.remove(op.join(selection, fname))\n\n        self.app.project_exists = True\n        self.app.project_dir = selection\n        self.app.project_name = fname.split(\'.\')[0]\n\n        # (dummy for now)\n        # dump widgets\' properties from process flow to dict, then to json\n        project = {u\'test\': u\'blah\'}\n        with open(op.join(selection, fname), \'w\', encoding=\'utf8\') as f:\n            dump = json.dumps(project, indent=4)\n            try:\n                dump = dump.decode(\'utf8\')\n            except AttributeError:\n                pass\n            f.write(dump)\n\n        # let user set table columns, add to tab, then:\n        self._export_data([data], \'data.sqlite\')\n\n        # exporting results to pdf -> 0.3.x\n        self._export_results(results)\n\n        # load items to ProcessFlow\n        self.flow_reload()\n        Logger.info(\'KrySA: Project successfully saved.\')\n\n    def import_data(self, *args):\n        self.opendlg = Dialog(title=\'Import Data\',\n                              confirm=\'Import\',\n                              run=self._import_data)\n        self.opendlg.open()\n\n    def _import_data(self, selection, *args):\n        \'\'\'Import :ref:`sqlite` from path selected in ``Dialog`` and put it\n        to :mod:`main.Table`.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        # limit table name and column name to [a-zA-Z]\n\n        # CREATE TABLE test(\n        #                   Column INTEGER NOT NULL CHECK(\n        #                               typeof(Column) = \'integer\'))\n        Logger.info(\'KrySA: Importing data from {}.\'.format(selection))\n        if not selection:\n            return\n        else:\n            selection = selection[0]\n            if \'.sqlite\' not in selection:\n                return\n\n        conn = sqlite3.connect(op.join(selection))\n        c = conn.cursor()\n\n        # get tables first!\n        c.execute(""SELECT name FROM sqlite_master WHERE type=\'table\'"")\n        tables = [tab[0] for tab in c.fetchall()]\n\n        for table in tables:\n            c.execute(""pragma table_info({0})"".format(table))\n            table_info = c.fetchall()\n            labels = [lbl[1] for lbl in table_info]\n\n            # allow only: INTEGER, REAL, TEXT\n            try:\n                types = [type[2][0] for type in table_info]\n            except IndexError:\n                error = ErrorPop(msg=\'Bad file: No defined types in columns!\')\n                error.open()\n                return\n\n            tabletab = TabbedPanelItem(text=table)\n            self.ids.tabpanel.add_widget(tabletab)\n            c.execute(\'select * from {0}\'.format(table))\n            values = [item for item in c.fetchone()]\n            max_cols = len(values)\n            values += [item for sublist in c.fetchall() for item in sublist]\n            max_rows = int(math.ceil(len(values) / float(max_cols)))\n            self.tables.append((table, Table(max_cols=max_cols,\n                                             max_rows=max_rows, pos=self.pos,\n                                             size=self.size, values=values,\n                                             labels=labels)))\n            tabletab.content = self.tables[-1][1]\n        self.opendlg.dismiss()\n        conn.close()\n        # ToDo: implement automatic saving to Project\'s data.sqlite\n        # ToDo: if the same table name exist in tables, add \' (2)\' or something\n\n    def export_data(self, *args):\n        self.savedlg = Dialog(title=\'Export Data\',\n                              confirm=\'Export\',\n                              run=self._export_data,\n                              dirs=True)\n        self.savedlg.open()\n\n    @staticmethod\n    def _extract_rows(data):\n        \'\'\'Extract values from :mod:`main.Table`\'s dictionary into a flat list.\n\n        Example:\n\n        ===== ===== =====\n        Data1 Data2 Data3\n          1    2.0    3\n        ===== ===== =====\n\n        [u\'Data1\', u\'Data2\', u\'Data3\', u\'1\', 2.0, 3, ...]\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        Logger.info(\'KrySA: Extracting rows.\')\n        rows = []\n        for item in data:\n            try:\n                item[\'cell\']\n                if issubclass(item[\'type\'], float):\n                    rows.append(float(item[\'text\']))\n                elif issubclass(item[\'type\'], int):\n                    rows.append(int(item[\'text\']))\n                else:\n                    rows.append(item[\'text\'])\n            except KeyError:\n                pass\n\n            # protect against \'\' values -> int(\'\'), float(\'\')\n            except ValueError:\n                # duplicated zeros to prevent sqlite3.IntegrityError\n                # - raised when there is type checking for inserting\n                # values to the table e.g. type(0) != type(0.0)\n                if issubclass(item[\'type\'], float):\n                    rows.append(0.0)\n                elif issubclass(item[\'type\'], int):\n                    rows.append(0)\n\n        data = []\n        return rows\n\n    def _export_data(self, selection, fname, *args):\n        \'\'\'Export all available :ref:`data` (visible as tabs) as :ref:`sqlite`\n        into path selected in ``Dialog``.\n\n        .. versionadded:: 0.1.1\n        \'\'\'\n        col_types = {""<type \'int\'>"": \'INTEGER\', ""<type \'float\'>"": \'REAL\',\n                     ""<class \'int\'>"": \'INTEGER\', ""<class \'float\'>"": \'REAL\'}\n        Logger.info(\'KrySA: Exporting data to {}, {}\'.format(selection, fname))\n        if not selection:\n            return\n        else:\n            selection = selection[0]\n        if op.exists(op.join(selection, fname)):\n            os.remove(op.join(selection, fname))\n\n        conn = sqlite3.connect(op.join(selection, fname))\n        c = conn.cursor()\n\n        for table in self.tables:\n            col_string = \'\'\n            max_cols = table[1].max_cols\n            columns = table[1].rv.data[1:max_cols + 1]  # types need whole dict\n            types = table[1].rv.data[max_cols + 2:2 * (max_cols + 1)]\n\n            for i, col in enumerate(columns):\n                try:\n                    type = col_types[repr(types[i][\'type\'])]\n                except KeyError:\n                    type = \'TEXT\'\n                # force column to check inserted values\n                col_string += (\n                    col[\'_text\'] + "" "" + type +\n                    "" NOT NULL CHECK(typeof("" + col[\'_text\'] +\n                    "") = \'"" + type.lower() + ""\'),""\n                )\n\n            if col_string.endswith(\',\'):\n                col_string = col_string[:-1]\n            Logger.info(\n                \'KrySA: SQL export - creating table {}.\'.format(table[0]))\n            c.execute(\n                ""CREATE TABLE "" + table[0] + ""("" + col_string + "")""\n            )\n            rows = self._extract_rows(table[1].rv.data)[max_cols:]\n\n            cnks = []\n            for x in range(0, len(rows), max_cols):\n                cnks.append(rows[x:x + max_cols])\n            Logger.info(\'KrySA: SQL export - inserting values.\')\n            for chunk in cnks:\n                _chunk = []\n                for cnk in chunk:\n                    if not isinstance(cnk, str):\n                        _chunk.append(str(cnk))\n                    else:\n                        _chunk.append(\'\\\'\' + cnk + \'\\\'\')\n                values = \',\'.join(_chunk)\n                c.execute(\n                    ""INSERT INTO "" + table[0] +\n                    "" VALUES("" + values + "")""\n                )\n            conn.commit()\n        conn.close()\n\n        try:\n            self.savedlg.dismiss()\n        except AttributeError:\n            # either closed, or wasn\'t even opened\n            pass\n\n    def _export_results(self, selection, *args):\n        Logger.info(\'KrySA: Exporting results to {}.\'.format(selection))\n        if not selection:\n            return\n        for file in os.listdir(selection):\n            os.remove(op.join(selection, file))\n        result_wdg = self.ids.results\n        for i, result in enumerate(reversed(self.ids.results.children)):\n            try:\n                where = op.join(selection, str(i).zfill(3) + \'.png\')\n                result.children[2].children[0].export_to_png(where)\n            except IndexError:\n                Logger.info(\'KrySA: No results available.\')\n\n    def flow_reload(self):\n        # get folders\n        fold = self.app.project_dir\n        data = op.join(fold, \'data\')\n        results = op.join(fold, \'results\')\n        plots = op.join(fold, \'plots\')\n\n        # remove anything in ProcessFlow\n        # and add a Project icon\n        self.app.flow.flush()\n        self.app.flow.add_project()\n        self.flow_init([data, results, plots])\n\n    def flow_init(self, folders=None):\n        # first create and place main items according\n        # to the Project item position, then place\n        # subitems according to the their parent\'s pos\n        Logger.info(\'KrySA: Initialising ProcessFlow.\')\n        for fold in folders:\n            if op.isdir(fold):\n                self.app.flow.add_mainitem(name=op.basename(fold),\n                                           link=fold)\n            for sub in sorted(os.listdir(fold)):\n                self.app.flow.add_subitem(name=op.basename(sub),\n                                          link=op.join(fold, sub),\n                                          parent=op.basename(fold))\n\n    def recent_projects(self, button, *args):\n        drop = DropDown(allow_sides=True, auto_width=False)\n        projects = self._recent_projects()\n        for proj in projects:\n            proj = proj.splitlines()\n            text = str(op.basename(proj[0]))\n            but = SizedButton(text=text.split(\'.\')[0])\n            but.bind(on_release=partial(self._open_recent, proj))\n            drop.add_widget(but)\n        drop.open(button)\n\n    def _open_recent(self, selection, *args):\n        self.close_project()\n        self.open_project()\n        if not isinstance(selection, list):\n            selection = list([selection])\n        self._open_project(selection)\n\n    def _recent_projects(self):\n        \'\'\'Return a list of recently opened :ref:`project` s from a file.\n\n        .. versionadded:: 0.6.0\n        \'\'\'\n        names = []\n        user_data = self.app.user_data_dir\n        project_dir = self.app.project_dir\n        project_name = self.app.project_name\n        project = op.join(project_dir, project_name + \'.krysa\')\n        recent = op.join(user_data, \'recent_projects.krysa\')\n\n        if op.exists(recent):\n            with open(recent, \'r\') as f:\n                names = f.readlines()\n            names = [n.splitlines()[0] for n in names]\n\n            # append if there\'s open project\n            if project not in names and project != \'.krysa\':\n                names.append(project)\n\n            while len(names) > 5:\n                names.pop(0)\n\n        with open(recent, \'w\', encoding=\'utf8\') as f:\n            dump = \'\\n\'.join([str(n) for n in names])\n            try:\n                dump = dump.decode(\'utf8\')\n            except AttributeError:\n                pass\n            f.write(dump)\n        Logger.info(\'KrySA: Fetched recent projects: {}.\'.format(names))\n        names = [str(n) for n in names]\n        names = [n[2:-1] if ""b\'"" in n else n for n in names]\n        return names\n\n    # menu showing functions\n    @staticmethod\n    def basic(button, *args):\n        drop = DropDown(allow_sides=True, auto_width=False)\n        for t in Basic.names:\n            but = SizedButton(text=t[0])\n            but.bind(on_release=t[1])\n            drop.add_widget(but)\n        drop.open(button)\n\n    @staticmethod\n    def avgs(button, *args):\n        drop = DropDown(allow_sides=True, auto_width=False)\n        for t in Avgs.names:\n            but = SizedButton(text=t[0])\n            but.bind(on_release=t[1])\n            drop.add_widget(but)\n        drop.open(button)\n\n    @staticmethod\n    def manipulate(button, *args):\n        drop = DropDown(allow_sides=True, auto_width=False)\n        for t in Manipulate.names:\n            but = SizedButton(text=t[0])\n            but.bind(on_release=t[1])\n            drop.add_widget(but)\n        drop.open(button)\n\n    @staticmethod\n    def plot(button, *args):\n        drop = DropDown(allow_sides=True, auto_width=False)\n        for t in Plot.names:\n            but = SizedButton(text=t[0])\n            but.bind(on_release=t[1])\n            drop.add_widget(but)\n        drop.open(button)\n\n    @staticmethod\n    def about(*args):\n        \'\'\'Display `about` page of the app and include other credits.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        aboutdlg = Popup(title=\'About\')\n        text = (\n            \'Copyright (C) 2016 - 2017, KeyWeeUsr(Peter Badida)\\n\'\n            \'License: GNU GPL v3.0\\n\'\n            \'Find me @ https://github.com/KeyWeeUsr\\n\\n\'\n            \'Used Software:\\n\\n\'\n            \'Python\\n\'\n            \'Copyright (C) 2001-2016 Python Software Foundation\\n\'\n            \'All rights reserved.\\n\\n\'\n            \'Kivy\\n\'\n            \'Copyright (C) 2010-2016 Kivy Team and other contributors\\n\\n\'\n            \'NumPy\\n\'\n            \'Copyright (C) 2005-2016, NumPy Developers.\\n\'\n            \'All rights reserved.\\n\\n\'\n            \'SciPy\\n\'\n            \'Copyright (C) 2003-2013 SciPy Developers.\\n\'\n            \'All rights reserved.\\n\\n\'\n            \'MatPlotLib\\n\'\n            \'Copyright (C) 2002-2016 John D. Hunter\\n\'\n            \'All Rights Reserved\\n\'\n        )\n\n        aboutdlg.content = Label(text=text)\n        aboutdlg.open()\n\n    @staticmethod\n    def test(*args):\n        Logger.info(\'KrySA: ping {}\'.format(str(args)))\n\n    # non-menu related functions\n    @staticmethod\n    def get_column(address):\n        col = 0\n        for c in address:\n            if c in string.ascii_letters:\n                col = col * 26 + (ord(c.upper()) - ord(\'A\')) + 1\n        return col\n\n    def from_address(self, table, address, extended=False, *args):\n        \'\'\'Get value(s) from :mod:`main.Table` according to the address such as\n        ``A1`` or ``A1:B2``. Values are fetched in the way that the final list\n        contains even empty (``u\'\'``) values. It is not expected of user to use\n        :ref:`task` for strings and most of them won\'t even run. To get\n        non-empty values for a :ref:`task` use for example Python\'s\n        ``filter()``::\n\n            values = filter(lambda x: len(str(x)), values)\n\n        This `filter`, however, will remain values such as ``None`` untouched.\n\n        .. versionadded:: 0.1.0\n\n        .. versionchanged:: 0.3.5\n           Added extended options and a possibility to get ``:all`` values from\n           data.\n        \'\'\'\n        values = []\n        col_row = []  # [column, row] such as [x, y] |_\n        if \':\' not in address:\n            match = re.findall(r\'([a-zA-Z]+)([0-9]+)\', address)\n            col_row.append([self.get_column(match[0][0]), match[0][1]])\n        else:\n            if \'all\' in address:\n                start_col = 1\n                start_row = 1\n                end_col = self.tables[table][1].cols\n                end_row = self.tables[table][1].rows\n            else:\n                addresses = address.split(\':\')\n                match = re.findall(r\'([a-zA-Z]+)([0-9]+)\', \' \'.join(addresses))\n                start_col = self.get_column(match[0][0])\n                start_row = int(match[0][1])\n                end_col = self.get_column(match[1][0])\n                end_row = int(match[1][1])\n            for col in range(start_col - 1, end_col):\n                for row in range(start_row - 1, end_row):\n                    col_row.append([col + 1, row + 1])\n\n        col_range = 0\n        row_range = 0\n        val_place = [None, None]  # [column, row]\n        table_cols = self.tables[table][1].cols\n        table_rows = self.tables[table][1].rows\n        labels = self.tables[table][1].labels\n\n        while col_row:\n            c, r = col_row.pop(0)\n            c = int(c)\n            r = int(r)\n\n            if 0 < r < table_rows and 0 < c < table_cols:\n                # increment ranges\n                if extended:\n                    if val_place[0] != c:\n                        val_place[0] = c\n                        col_range += 1\n                    if val_place[1] != r:\n                        val_place[1] = r\n                        row_range += 1\n\n                # get values\n                key = table_cols * (r + 1) - (table_cols - c)\n                item = self.tables[table][1].rv.data[key]\n                if item[\'r\'] == r and item[\'c\'] == c:\n                    if issubclass(item[\'type\'], float):\n                        values.append(float(item[\'text\']))\n                    elif issubclass(item[\'type\'], int):\n                        values.append(int(item[\'text\']))\n                    else:\n                        values.append(item[\'text\'])\n        if extended:\n            if row_range < col_range:\n                # return 1 manually if only one row\n                # otherwise row_range == 0\n                row_range = 1\n            else:\n                row_range = row_range / int(col_range)\n            return values, col_range, row_range, labels\n        else:\n            return values\n\n    def set_page(self, task, result, result_type=\'text\', footer=\'time\'):\n        \'\'\'Create a :mod:`main.PageBox` for a result. The header consists of the\n        :ref:`task`\'s name, the footer is by default the time when the result\n        was created and the content depends on `result_type` which can be -\n        text, image(path to image) or widget. If `result_type == \'widget\'`,\n        result has to be an instance of a widget (obviously containing the\n        output), e.g.::\n\n            b = Button(text=\'my output\')\n            set_page(\'MyTask\', b, result_type=\'widget\')\n\n        .. note:: When exporting pages, everything is converted into images\n           (pngs), therefore making fancy behaving widgets is irrelevant.\n\n        .. versionadded:: 0.2.0\n\n        .. versionchanged:: 0.3.2\n           Added tables as a result type.\n        \'\'\'\n        page = PageBox()\n        head = PaperLabel(text=task, size_hint_y=None, height=\'30dp\')\n\n        if result_type == \'text\':\n            content = PaperLabel(text=str(result))\n        elif result_type in [\'image\', \'import\']:\n            content = Image(source=result)\n        elif \'table\' in result_type:\n            # result == list of values\n            box = BoxLayout(orientation=\'vertical\')\n            grid = ResultGrid(cols=int(result_type.strip(\'table\')),\n                              padding=1, spacing=1, size_hint=[0.95, None],\n                              pos_hint={\'center_x\': 0.5})\n            grid.bind(minimum_height=grid.setter(\'height\'))\n\n            for value in result:\n                if isinstance(value, (float, int)):\n                    val = repr(value)\n                else:\n                    val = str(value)\n                grid.add_widget(Wrap(text=val, color=[0, 0, 0, 1],\n                                     background_color=[1, 1, 1, 1],\n                                     padding_x=3))\n\n            box.add_widget(Widget())\n            box.add_widget(grid)\n            box.add_widget(Widget())\n            content = box\n\n        elif result_type == \'widget\':\n            content = result\n\n        # turn off with footer=None\n        if result_type == \'import\':\n            pass\n        elif not footer:\n            foot = PaperLabel(size_hint_y=None, height=\'30dp\')\n        else:\n            if footer == \'time\':\n                t = strftime(""%a, %d %b %Y %H:%M:%S +0000"", gmtime())\n                foot = PaperLabel(text=t,\n                                  size_hint_y=None,\n                                  height=\'30dp\')\n            else:\n                foot = PaperLabel(text=footer, size_hint_y=None,\n                                  height=\'30dp\')\n\n        if not result_type == \'import\':\n            page.add_widget(head)\n            page.add_widget(content)\n            page.add_widget(foot)\n        else:\n            page.add_widget(content)\n        self.ids.results.add_widget(page, 1)\n\n        panel = self.ids.resultspanel\n        if panel.width == panel.min_size:\n            panel.width = panel.max_size\n\n    @staticmethod\n    def simple_chars(substring, from_undo):\n        chars = re.findall(r\'([a-zA-Z0-9.])\', substring)\n        return u\'\'.join(chars)\n\n    @staticmethod\n    def address_chars(substring, from_undo):\n        chars = re.findall(r\'([a-zA-Z0-9:])\', substring)\n        return u\'\'.join(chars)\n\n    def update_tree(self, dt):\n        tree = self.ids.tree\n        lab = TreeViewLabel\n        for node in tree.iterate_all_nodes():\n            tree.remove_node(node)\n        root = tree.add_node(lab(text=self.app.project_name, is_open=True))\n        for path, folders, files in os.walk(self.app.project_dir):\n            if op.basename(self.app.project_dir) != op.basename(path):\n                dirname = op.basename(path).title()\n                parent = tree.add_node(lab(text=dirname, is_open=True), root)\n                for file in files:\n                    filename = op.basename(file)\n                    tree.add_node(lab(text=filename, is_open=True), parent)\n\n\nclass KrySA(App):\n    \'\'\'The main class of the application through which is handled the\n    communication of other classes with getting an instance of the app via\n    ``App.get_running_app()``.\n\n    Other than that, it holds important variables of :ref:`project`, sql\n    blacklist for :ref:`sqlite` creating and updating or the application\n    properties themselves.\n    \'\'\'\n    path = op.dirname(op.abspath(__file__))\n    icon = op.join(path, \'data\', \'icon.png\')\n    project_exists = BooleanProperty(False)\n    project_name = StringProperty(\'\')\n    project_dir = StringProperty(\'\')\n    title = \'KrySA\'\n    errorcls = ErrorPop\n    tablecls = Table\n    sql_blacklist = [\'DROP\', \'EXEC\', \'DECLARE\', \'UPDATE\', \'CREATE\', \'DELETE\',\n                     \'INSERT\', \'JOIN\', \'=\', \'""\', ""\'"", \';\']\n\n    def on_project_exists(self, instance, exists):\n        \'\'\'Check change of :mod:`main.KrySA.project_exists` and if\n        :ref:`project` exists, schedule updating of its tree to 5 second\n        interval.\n\n        .. versionadded:: 0.3.0\n        \'\'\'\n        if exists:\n            self.treeclock = Clock.schedule_interval(self.root.update_tree, 5)\n        else:\n            Clock.unschedule(self.treeclock)\n\n    def build(self):\n        \'\'\'Default Kivy function for getting the root widget of application.\n        \'\'\'\n        # read MenuDrop if an idea of removing it comes up\n        MenuDrop()\n        return Body()\n\n\nif __name__ == \'__main__\':\n    KrySA().run()\n'"
docs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# KrySA documentation build configuration file, created by sphinx-quickstart\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n\nimport sys\nimport os.path as op\nfrom os.path import dirname as dn\n\nsys.path.insert(0, op.join(dn(dn(dn(op.abspath(__file__)))), \'krysa\'))\nsys.path.insert(0, dn(dn(op.abspath(__file__))))\n\ntry:\n    import kivy\n    import docs_modules\nexcept ImportError:\n    print(\'No Kivy installed...\\nBuilding simple docs...\')\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.4.4\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.viewcode\',\n]\n# \'undoc-members\' for members without docs\nautodoc_default_flags = [\'members\', \'private-members\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#\n# source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'KrySA\'\ncopyright = u\'2016 - 2017, Peter Badida\'\nauthor = u\'Peter Badida\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nfpath = dn(op.abspath(__file__))\ntry:\n    with open(op.join(dn(dn(fpath)), \'krysa\', \'main.py\')) as _f:\n        for i, line in enumerate(_f):\n            if i == 2:\n                version = line[len(\'# Version: \'):-1]\n            elif i > 2:\n                break\nexcept:\n    version = \'master\'\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#\n# today = \'\'\n#\n# Else, today_fmt is used as the format for a strftime call.\n#\n# today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#\n# default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'alabaster\'\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.\n# ""<project> v<release> documentation"" by default.\n#\n# html_title = u\'KrySA v1.0.0\'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#\nhtml_logo = \'_static/logo.png\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nhtml_theme_options = {\'github_user\': \'KeyWeeUsr\',\n                      \'github_repo\': \'KrySA\',\n                      \'github_banner\': True,\n                      \'github_button\': False,\n                      \'touch_icon\': html_logo,\n                      \'show_related\': True,\n                      \'fixed_sidebar\': True,\n                      }\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or\n# 32x32 pixels large.\n#\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#\n# html_extra_path = []\n\n# If not None, a \'Last updated on:\' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to \'%b %d, %Y\'.\n#\n# html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#\n# html_domain_indices = True\n\n# If false, no index is generated.\n#\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#\n# html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#\n# html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#\n# html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\', \'zh\'\n#\n# html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# \'ja\' uses this config value.\n# \'zh\' user can custom change `jieba` dictionary path.\n#\n# html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#\n# html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'KrySAdoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {}\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\n# \'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\n# \'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\n# \'preamble\': \'\',\n\n# Latex figure (float) alignment\n#\n# \'figure_align\': \'htbp\',\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'KrySA.tex\', u\'KrySA Documentation\',\n     u\'Peter Badida\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#\n# latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n#\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#\n# latex_appendices = []\n\n# If false, no module index is generated.\n#\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'krysa\', u\'KrySA Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'KrySA\', u\'KrySA Documentation\',\n     author, \'KrySA\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n#\n# texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#\n# texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#\n# texinfo_no_detailmenu = False\n\n\n# -- Options for Epub output ----------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\nepub_author = author\nepub_publisher = author\nepub_copyright = copyright\n\n# The basename for the epub file. It defaults to the project name.\n# epub_basename = project\n\n# The HTML theme for the epub output. Since the default themes are not\n# optimized for small screen space, using the same theme for HTML and epub\n# output is usually not wise. This defaults to \'epub\', a theme designed to save\n# visual space.\n#\n# epub_theme = \'epub\'\n\n# The language of the text. It defaults to the language option\n# or \'en\' if the language is not set.\n#\n# epub_language = \'\'\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n# epub_scheme = \'\'\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A tuple containing the cover image and cover page html template filenames.\n#\n# epub_cover = ()\n\n# A sequence of (type, uri, title) tuples for the guide element of content.opf.\n#\n# epub_guide = ()\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#\n# epub_pre_files = []\n\n# HTML files that should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n#\n# epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\'search.html\', \'mod_*\']\n\n# The depth of the table of contents in toc.ncx.\n#\n# epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n#\n# epub_tocdup = True\n\n# Choose between \'default\' and \'includehidden\'.\n#\n# epub_tocscope = \'default\'\n\n# Fix unsupported image types using the Pillow.\n#\n# epub_fix_images = False\n\n# Scale large images.\n#\n# epub_max_image_width = 0\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#\n# epub_show_urls = \'inline\'\n\n# If false, no index is generated.\n#\n# epub_use_index = True\n'"
krysa/tasks/__init__.py,0,"b""'''\n.. toctree::\n   mod_krysa_tasks_basic\n   mod_krysa_tasks_avgs\n   mod_krysa_tasks_manipulate\n   mod_krysa_tasks_plot\n'''\n\nfrom kivy.app import App\nfrom kivy.metrics import dp\nfrom kivy.lang import Builder\nfrom kivy.logger import Logger\nfrom kivy.uix.popup import Popup\nfrom kivy.uix.button import Button\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.uix.textinput import TextInput\nfrom kivy.properties import ObjectProperty\nimport re\nimport os.path as op\n\nBuilder.load_file(op.join(op.dirname(op.abspath(__file__)), 'tasks.kv'))\n\n\nclass LinePlotLayout(BoxLayout):\n    '''A layout that consists of two main columns for input of X and Y values\n    used to draw a plot and other inputs for setting plot's properties.\n\n    .. versionadded:: 0.4.3\n    '''\n\n\nclass AddressLayout(BoxLayout):\n    '''Simple layout that consists of single restricted input widget fetching\n    only ``[a-zA-Z0-9:]`` values i.e. address.\n    '''\n\n\nclass CountIfLayout(BoxLayout):\n    '''A layout providing a way to create conditions for counting values from\n    used :ref:`Data`.\n\n    .. versionadded:: 0.5.1\n    '''\n\n\nclass SmallLargeLayout(BoxLayout):\n    '''A layout that consists of multiple restricted input widgets for address\n    and `k` value.\n\n    .. versionadded:: 0.1.0\n    '''\n\n\nclass AvgsLayout(BoxLayout):\n    '''A layout that consists of multiple restricted input widgets for address\n    and `p` (power) value for the formula of generalized mean.\n\n    .. versionadded:: 0.2.4\n    '''\n\n\nclass FloatInput(TextInput):\n    '''A TextInput with float filter.\n\n    .. versionadded:: 0.3.8\n    '''\n    def __init__(self, **kwargs):\n        super(FloatInput, self).__init__(**kwargs)\n        self.input_filter = self.floatfilter\n\n    def floatfilter(self, substring, from_undo):\n        '''A function filtering everything that is not `-` symbol, floating\n        point symbol(`.`) or a number.\n        '''\n        txt = self.text\n        if '-' in txt and '.' not in txt:\n            chars = re.findall(r'([0-9.])', substring)\n        elif '.' in txt:\n            if '-' not in txt:\n                chars = re.findall(r'([\\-0-9])', substring)\n            else:\n                chars = re.findall(r'([0-9])', substring)\n        else:\n            chars = re.findall(r'([\\-0-9.])', substring)\n        return u''.join(chars)\n\n\nclass FreqLayout(BoxLayout):\n    '''A layout that consists of multiple checkboxes and restricted input\n    widgets for address, type of values, type of output frequency and\n    limits of the input values.\n\n    .. versionadded:: 0.3.2\n    '''\n\n\nclass SortLayout(BoxLayout):\n    '''A layout that consists only of a spinner with two values:\n\n    * Ascending\n    * Descending\n\n    The :ref:`task` with this layout is using\n    :mod:`tasks.manipulate.Manipulate._manip_sort`.\n\n    .. versionadded:: 0.3.5\n    '''\n\n\nclass AppendLayout(BoxLayout):\n    '''A layout that consists of a spinner with two values:\n\n    * Rows\n    * Columns\n\n    and a restricted input that allows only integers.\n\n    .. versionadded:: 0.3.6\n    .. versionchanged:: 0.5.3\n        Added layout for column input\n    '''\n    def __init__(self, **kwargs):\n        super(AppendLayout, self).__init__(**kwargs)\n        self._old_height = None\n\n    def change_ctx(self, text, *args):\n        popup = self.parent.parent.parent.parent.parent\n        container = self.ids.cols_container\n        amount = self.ids.amount\n\n        if not self._old_height:\n            self._old_height = self.height\n\n        if text == 'Columns':\n            # hide amount\n            amount.size_hint_x = 0\n            amount.width = 0\n            amount.background_color = (0, 0, 0, 0)\n\n            # add layout for columns\n            container.add_widget(AppendColsLayout())\n            self.height = self.height + dp(90)\n            container.height = dp(90)\n        else:\n            # show amount\n            amount.size_hint_x = 1\n            amount.background_color = (1, 1, 1, 1)\n\n            self.height = self._old_height\n            container.height = 0\n\n            if container.children:\n                container.clear_widgets()\n\n        popup.recalc_height(popup.ids.taskbody, self.parent)\n\n\nclass AppendColsLayout(BoxLayout):\n    '''A layout for adding columns into :mod:`tasks.AppendLayout`.\n\n    .. versionadded:: 0.5.3\n    '''\n\n\nclass StandLayout(BoxLayout):\n    '''(Not yet implemented)\n    A layout that consists of a spinner with types of available\n    standardization for values.\n\n    * Standard score\n        .. math:: X' = \\\\frac {X - \\\\mu}{\\\\sigma}\n\n    * Student's t-statistic\n        .. math:: X' = \\\\frac {X - {\\\\overline {X}}}{s}\n\n    * Studentized residual\n        .. math::\n           \\\\frac {{\\\\hat {\\\\epsilon}}_{i}}{{\\\\hat {\\\\sigma}}_{i}}\n           =\\\\frac {X_{i}-{\\\\hat {\\\\mu}}_{i}}{{\\\\hat {\\\\sigma}}_{i}}\n\n    * Standardized moment\n        .. math:: \\\\frac {\\\\mu _{k}}{\\\\sigma ^{k}}\n\n    * Coefficient of variation\n        .. math:: \\\\frac {\\\\sigma}{\\\\mu}\n\n    * Feature scaling\n        .. math:: X'=a + \\\\frac {(X-X_{\\\\min})(b-a)}{X_{\\\\max}-X_{\\\\min}}\n    '''\n\n\nclass Task(Popup):\n    '''A popup handling the basic choosing of :ref:`data` from available\n    :ref:`sqlite` in the application.\n\n    .. versionadded:: 0.1.0\n\n    .. versionchanged:: 0.2.3\n       Placed into a separated module.\n    '''\n    run = ObjectProperty(None)\n\n    def __init__(self, call=None, wdg=None, run=None, **kwargs):\n        super(Task, self).__init__(**kwargs)\n        self.app = App.get_running_app()\n        self.run = run\n        self.call = call\n        self.from_address = self.app.root.from_address\n        self.set_page = self.app.root.set_page\n        if wdg:\n            self.ids.container.add_widget(wdg)\n\n    def recalc_height(self, body, content):\n        '''Recalculate the height of :mod:`tasks.Task` after a layout is\n        added, so that the children are clearly visible without any stretching.\n\n        .. versionadded:: 0.3.2\n        '''\n        confirms = self.ids.confirms\n        content.height = sum([child.height for child in content.children])\n        body.height = sum([child.height for child in body.children])\n        self.height = body.height + confirms.height + self.separator_height\n\n    @staticmethod\n    def get_table_pos(text, values, *args):\n        '''Return an index of selected :mod:`main.Table` from all available\n        in the list.\n\n        .. versionadded:: 0.1.0\n        '''\n        gen = (i for i, val in enumerate(values) if val == text)\n        for i in gen:\n            return i\n\n    def try_run(self, *args):\n        '''Try to run a :ref:`task` from the input a user specified and\n        closes the popup. If no such an action is possible, show a popup\n        with an error and leave :mod:`tasks.Task` opened.\n\n        .. versionadded:: 0.2.0\n        '''\n        try:\n            self.run(*args)\n            if self.call:\n                but = Button(size_hint_y=None, height='25dp',\n                             text=self.call[0])\n                but.bind(on_release=self.call[1])\n                self.app.root.ids.recenttasks.add_widget(but)\n            self.dismiss()\n        except Exception as err:\n            Logger.exception(err)\n            error = self.app.errorcls(msg=repr(err))\n            error.open()\n"""
krysa/tasks/avgs.py,0,"b""from . import Task, AvgsLayout, AddressLayout\nfrom functools import partial, reduce\nfrom collections import Counter\nimport operator\nimport math\n\n\nclass Avgs(object):\n    '''All :ref:`Task` s categorized as `averages` under one roof.\n\n    .. versionadded:: 0.2.4\n    '''\n\n    def avgs_gen(*args):\n        '''Get the values from address and depending on `p` (power) value\n        returns either exceptional case for `p == 0` (geometric mean), or\n        a value from the generalized mean's formula:\n\n        .. math::\n           \\\\big(\\\\frac{1}{n}\\\\sum_{i=1}^n  x_{i}^{p} \\\\big)^\\\\frac{1}{p},\n           where:\n\n        * p == -1: harmonic\n        * p == 0: geometric\n        * p == 1: arithmetic\n        * p == 2: quadratic\n        * p == 3: cubic\n        * etc...\n\n        .. versionadded:: 0.2.4\n        '''\n        widget = AvgsLayout()\n        task = Task(title='Count', wdg=widget,\n                    call=['Count', Avgs.avgs_gen])\n        container = task.ids.container.children[0]\n        task.run = partial(Avgs._avgs_gen,\n                           task,\n                           container.ids.name,\n                           container.ids.power)\n        task.open()\n\n    @staticmethod\n    def _avgs_gen(task, address, p, *args):\n        if p == '-0':\n            p = 0.0\n        else:\n            p = float(p.text)\n\n        values = task.from_address(task.tablenum, address.text)\n        if p in [0, -0]:\n            multiples = reduce(operator.mul, values, 1)\n            result = math.pow(multiples, 1 / float(len(values)))\n            p = 'geometric'\n        else:\n            values = [math.pow(val, p) for val in values]\n            upper = math.fsum(values) / float(len(values))\n            result = math.pow(upper, 1 / float(p))\n        task.set_page('Generalized mean({})'.format(p), str(result), 'text')\n\n    def avgs_inter(*args):\n        '''(Not yet implemented)\n        '''\n\n    def avgs_mid(*args):\n        '''(Not yet implemented)\n        '''\n\n    def avgs_trim(*args):\n        '''(Not yet implemented)\n        '''\n\n    def avgs_median(*args):\n        '''Median:\n\n        .. math::\n            \\\\tilde x = \\\\left \\\\{ \\\\begin {array}{lr}\n                \\\\frac {n}{2} \\in \\\\mathbb{N}:&\n                    \\\\frac {x_{\\\\frac {n}{2}} + x_{\\\\frac {n}{2}+1}}{2}\n                \\\\\\\\\n                \\\\frac {n+1}{2} \\in \\\\mathbb{N}:&\n                    x_{\\\\lceil \\\\frac {n}{2} \\\\rceil}\n            \\\\end{array} \\\\right.\n\n        .. versionadded:: 0.3.10\n        '''\n        widget = AddressLayout()\n        task = Task(title='Median', wdg=widget,\n                    call=['Median', Avgs.avgs_median])\n        container = task.ids.container.children[0]\n        task.run = partial(Avgs._avgs_median,\n                           task,\n                           container.ids.name)\n        task.open()\n\n    @staticmethod\n    def _avgs_median(task, address, *args):\n        values = task.from_address(task.tablenum, address.text)\n        length = len(values)\n        pos = int(round(length / 2.0))\n        if length == 1:\n            result = values[0]\n        elif length % 2:\n            result = values[pos - 1]\n        else:\n            result = int(values[pos - 1] + values[pos]) / 2.0\n        task.set_page('Median', str(result), 'text')\n\n    def avgs_mode(*args):\n        '''Return the most common value from the list of values.\n        If there's more than a single value with the same amount of\n        occurency, all values with the same occurency are returned.\n\n        .. versionadded:: 0.3.10\n        '''\n        widget = AddressLayout()\n        task = Task(title='Mode', wdg=widget,\n                    call=['Mode', Avgs.avgs_mode])\n        container = task.ids.container.children[0]\n        task.run = partial(Avgs._avgs_mode,\n                           task,\n                           container.ids.name)\n        task.open()\n\n    @staticmethod\n    def _avgs_mode(task, address, *args):\n        values = task.from_address(task.tablenum, address.text)\n        length = len(values)\n        data = Counter(values)\n        occurs = data.most_common(length)\n        results = []\n        for oc in occurs:\n            if not results:\n                results.append(oc)\n            else:\n                if results[-1][1] == oc[1]:\n                    results.append(oc)\n        results = [str(r[0]) for r in results]\n        task.set_page('Mode', ', '.join(results), 'text')\n\n    names = (('Generalized', avgs_gen),\n             ('_Interquartile', avgs_inter),\n             ('_Midrange', avgs_mid),\n             ('_Trimmed', avgs_trim),\n             ('Median', avgs_median),\n             ('Mode', avgs_mode))\n"""
krysa/tasks/basic.py,0,"b'\'\'\'\n.. |b| replace:: bins\n.. _b: http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html\n\'\'\'\n\nfrom . import Task, AddressLayout, SmallLargeLayout, FreqLayout, CountIfLayout\nfrom functools import partial\nfrom numpy import histogram\nimport math\n\n\nclass Basic(object):\n    \'\'\'All :ref:`Task` s categorized as `basic` under one roof.\n\n    .. versionadded:: 0.1.0\n    \'\'\'\n\n    def basic_count(*args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.AddressLayout` that\n        gets from user :ref:`Data` address. Create a result page with count.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        widget = AddressLayout()\n        task = Task(title=\'Count\', wdg=widget,\n                    call=[\'Count\', Basic.basic_count])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_count,\n                           task,\n                           container.ids.name)\n        task.open()\n\n    @staticmethod\n    def _basic_count(task, address, *args):\n        values = task.from_address(task.tablenum, address.text)\n        task.set_page(\'Count\', str(len(values)), \'text\')\n\n    def basic_countif(self, *args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.CountIfLayout` that\n        gets from user :ref:`Data` address and conditions for getting values.\n        Create a result page with count and conditions.\n\n        This method uses Python\'s `eval()` and executing of boolean logic,\n        which means the order of executed conditions will be like this::\n\n            ((Cond and Cond) and Cond) or (Cond) or (Cond and Cond)\n              ^-- first   second --^       ^-- third   ^-- fourth\n\n        .. versionadded:: 0.5.1\n        \'\'\'\n        widget = CountIfLayout()\n        task = Task(title=\'Count If\', wdg=widget,\n                    call=[\'Count If\', Basic.basic_countif])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_countif,\n                           task,\n                           container.ids.name,\n                           container.ids.conditions)\n        task.open()\n\n    @staticmethod\n    def _basic_countif(task, address, conditions, *args):\n        values = task.from_address(task.tablenum, address.text)\n        result = \'\'\n        instruction = \'\'\n        count = 0\n\n        groups = []\n        grp = []\n        for child in reversed(conditions.children):\n            operation = child.children[-1].text\n            op_val = child.children[-2].text\n            logic = child.children[-3].text\n            if operation != \'---\' and op_val:\n                grp.append([operation, op_val])\n            if logic == \'---\':\n                groups.append(grp)\n                break\n            if logic == \'OR\':\n                groups.append(grp)\n                grp = []\n\n        for i, grp in enumerate(groups):\n            for g in grp:\n                vals = []\n                operation = g[0]\n                op_val = g[1]\n                last_op = instruction[-5:]\n                if last_op != \' and \' and \' or \' not in last_op and last_op:\n                    instruction += \' and \'\n                if operation == \'Less than\':\n                    instruction += \'val < \'\n                elif operation == \'Less than or equal\':\n                    instruction += \'val <= \'\n                elif operation == \'Greater than\':\n                    instruction += \'val > \'\n                elif operation == \'Greater than or equal\':\n                    instruction += \'val >= \'\n                elif operation == \'Equal to\':\n                    instruction += \'val == \'\n                elif operation == \'Not equal to\':\n                    instruction += \'val != \'\n                instruction += op_val\n                result += operation + \' \' + op_val + \'\\n\'\n            try:\n                groups[i + 1]\n                instruction += \' or \'\n            except IndexError:\n                pass\n\n        for val in values:\n            if eval(instruction):\n                count += 1\n\n        result += \'\\nCount: \' + str(count)\n        task.set_page(\'Count If\', result, \'text\')\n\n    def basic_min(*args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.AddressLayout` that\n        gets from user :ref:`Data` address. Create a result page with minimum.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        widget = AddressLayout()\n        task = Task(title=\'Minimum\', wdg=widget,\n                    call=[\'Minimum\', Basic.basic_min])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_min,\n                           task,\n                           container.ids.name)\n        task.open()\n\n    @staticmethod\n    def _basic_min(task, address, *args):\n        values = task.from_address(task.tablenum, address.text)\n        task.set_page(\'Minimum\', str(min(list(set(values)))), \'text\')\n\n    def basic_max(*args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.AddressLayout` that\n        gets from user :ref:`Data` address. Create a result page with maximum.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        widget = AddressLayout()\n        task = Task(title=\'Maximum\', wdg=widget,\n                    call=[\'Maximum\', Basic.basic_max])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_max,\n                           task,\n                           container.ids.name)\n        task.open()\n\n    @staticmethod\n    def _basic_max(task, address, *args):\n        values = task.from_address(task.tablenum, address.text)\n        task.set_page(\'Maximum\', str(max(list(set(values)))), \'text\')\n\n    def basic_small(*args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.SmallLargeLayout` that\n        gets from user :ref:`Data` address and `k` variable representing the\n        `k`-th value from the :ref:`Task` s output. Create a result page with\n        the `k`-th value.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        widget = SmallLargeLayout()\n        task = Task(title=\'Small\', wdg=widget,\n                    call=[\'Small\', Basic.basic_small])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_small,\n                           task,\n                           container.ids.name,\n                           container.ids.order)\n        task.open()\n\n    @staticmethod\n    def _basic_small(task, address, k, *args):\n        values = task.from_address(task.tablenum, address.text)\n        values = sorted(list(set(values)))\n        k = int(k.text) - 1\n        try:\n            task.set_page(\'Small ({}.)\'.format(k + 1),\n                          str(values[k]), \'text\')\n        except IndexError:\n            pass\n\n    def basic_large(self, *args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.SmallLargeLayout` that\n        gets from user :ref:`Data` address and `k` variable representing the\n        `k`-th value from the :ref:`Task` s output. Create a result page with\n        `k`-th value.\n\n        .. versionadded:: 0.1.0\n        \'\'\'\n        widget = SmallLargeLayout()\n        task = Task(title=\'Large\', wdg=widget,\n                    call=[\'Large\', Basic.basic_large])\n        container = task.ids.container.children[0]\n        task.run = partial(Basic._basic_large,\n                           task,\n                           container.ids.name,\n                           container.ids.order)\n        task.open()\n\n    @staticmethod\n    def _basic_large(task, address, k, *args):\n        values = task.from_address(task.tablenum, address.text)\n        values = sorted(list(set(values)), reverse=True)\n        k = int(k.text) - 1\n        try:\n            task.set_page(\'Large ({}.)\'.format(k + 1),\n                          str(values[k]), \'text\')\n        except IndexError:\n            pass  # throw error k out of len(values) bounds, same for *_small\n\n    def basic_freq(self, *args):\n        \'\'\'Open a :mod:`tasks.Task` with a :mod:`tasks.FreqLayout` that\n        gets from user:\n\n        * :ref:`data` address\n        * type of frequency (`absolute`, `relative` or `cumulative`\n        * |b|_\n        * lower and upper limit (optional, by default takes `min` and `max`)\n\n        Depending on the inputed bins:\n\n        * `Count` of equal-width bins\n        * `Edges` manually created edges for non-uniform bin widths. It already\n          contains minimum and maximum of the values list.\n        * `Calculate` uses NumPy\'s way for creating an optimal bin width.\n\n        The function creates a result page with a table for chosen types of\n        frequency. If necessary, you can set the maximal amount of decimal\n        digits for the frequency outputs.\n\n        .. versionadded:: 0.3.2\n        .. versionchanged:: 0.3.8\n           Switch from SciPy\'s frequency functions to NumPy\'s `histogram` which\n           removes `intervals` option as this is already handled by histogram.\n        .. versionchanged:: 0.3.9\n           Added precision.\n        \'\'\'\n\n        widget = FreqLayout()\n        task = Task(title=\'Frequency\', wdg=widget,\n                    call=[\'Frequency\', Basic.basic_freq])\n        container = task.ids.container.children[0]\n        task.run = partial(\n            Basic._basic_freq,\n            task,\n            container.ids.name,\n            container.ids.precision,\n            (container.ids.binmanager, container.ids.bins,\n             container.ids.bingrid, container.ids.binstr),\n            (container.ids.lowlimit, container.ids.uplimit,\n             container.ids.limits_auto),\n            (container.ids.absolute, container.ids.relative,\n             container.ids.cumulative))\n        task.open()\n\n    @staticmethod\n    def _basic_freq_prec(input_list, precision, *args):\n        if precision == \'\':\n            return input_list\n        try:\n            precision = int(precision)\n        except ValueError:\n            raise Exception(\'Bad precision input!\')\n\n        final = []\n        if precision:\n            for item in input_list:\n                if isinstance(item, str):\n                    final.append(item)\n                else:\n                    final.append(round(item, precision))\n        return final\n\n    @staticmethod\n    def _basic_freq(task, address, precision, bins, limits, freq_type, *args):\n        # input variables\n        bin_type, bins, bingrid, binstr = bins\n        lowlimit, uplimit, limits_auto = limits\n        absolute, relative, cumulative = freq_type\n        precision = precision.text\n\n        # setting variables\n        values = task.from_address(task.tablenum, address.text)\n        values = [float(val) for val in values]\n        values = sorted(values)\n        cols = 2\n\n        if limits_auto.active:\n            lowlimit = min(values)\n            uplimit = max(values)\n        else:\n            if lowlimit.text and uplimit.text:\n                lowlimit = float(lowlimit.text)\n                uplimit = float(uplimit.text)\n            else:\n                raise Exception(\n                    \'Manual limits enabled! \'\n                    \'You need to enter both lower and upper limit.\')\n\n        # get either int of bins or float list of edges\n        bin_type = bin_type.current\n        if bin_type == \'Count\':\n            if bins.text:\n                bins = int(bins.text)\n            else:\n                raise Exception(\'No count of bins entered!\')\n        elif bin_type == \'Edges\':\n            bins = [float(child.text) for child in bingrid.children]\n            bins = sorted(bins)\n            if bins[0] > min(values):\n                bins.insert(0, min(values))\n            if bins[-1] < max(values):\n                bins.extend([max(values)])\n        elif bin_type == \'Calculate\':\n            bins = binstr.value\n\n        # get base for results\n        histo, edges = histogram(values, bins=bins, range=(lowlimit, uplimit))\n        values_len = float(len(values))\n\n        # set edge values\n        left = []\n        right = []\n        for i in range(len(edges)):\n            left.append(float(edges[i]))\n            try:\n                right.append(float(edges[i + 1]))\n            except IndexError:\n                right.append(\'-\')\n\n        # ""float(val)"" to convert from numpy\'s type\n        absol = []\n        if absolute.active:\n            absol = [float(val) for val in histo]\n            absol.insert(0, \'Absolute\')\n            cols += 1\n\n        relat = []\n        if relative.active:\n            if absol:\n                relat = [val / values_len for val in absol[1:]]\n            else:\n                relat = [float(val) / values_len for val in histo]\n            relat = Basic._basic_freq_prec(relat, precision)\n            relat.insert(0, \'Relative\')\n            cols += 1\n\n        cumul = []\n        if cumulative.active:\n            if not relative.active:\n                _relat = [float(val) / values_len for val in histo]\n            else:\n                _relat = relat[1:]\n\n            previous = 0\n            for i in range(len(histo)):\n                cumul.append(previous + float(_relat[i]))\n                previous += float(_relat[i])\n            cumul = Basic._basic_freq_prec(cumul, precision)\n            cumul.insert(0, \'Cumulative\')\n            cols += 1\n\n        # zipping & exporting results\n        left = Basic._basic_freq_prec(left, precision)\n        right = Basic._basic_freq_prec(right, precision)\n        left.insert(0, \'Lower edge\')\n        right.insert(0, \'Upper edge\')\n\n        if absol and not relat and not cumul:\n            zipped = zip(left, right, absol)\n        elif absol and relat and not cumul:\n            zipped = zip(left, right, absol, relat)\n        elif absol and cumul and not relat:\n            zipped = zip(left, right, absol, cumul)\n        elif relat and not absol and not cumul:\n            zipped = zip(left, right, relat)\n        elif relat and cumul and not absol:\n            zipped = zip(left, right, relat, cumul)\n        elif cumul and not absol and not relat:\n            zipped = zip(left, right, cumul)\n        elif absol and relat and cumul:\n            zipped = zip(left, right, absol, relat, cumul)\n\n        result = [r for items in zipped for r in items]\n        bin_type = binstr.text if \'Calc\' in bin_type else bin_type\n        bins = \', bins=\' + str(bins) if \'Count\' in bin_type else \'\'\n        params = \'{}{}\'.format(bin_type, bins)\n        task.set_page(\'Frequency({})\'.format(params),\n                      result, \'table{}\'.format(cols))\n\n    names = ((\'Count\', basic_count),\n             (\'Count If\', basic_countif),\n             (\'Minimum\', basic_min),\n             (\'Maximum\', basic_max),\n             (\'Small\', basic_small),\n             (\'Large\', basic_large),\n             (\'Frequency\', basic_freq))\n'"
krysa/tasks/manipulate.py,0,"b""from . import Task, SortLayout, AppendLayout, StandLayout\nfrom kivy.uix.tabbedpanel import TabbedPanelItem\nfrom functools import partial\n\n\nclass Manipulate(object):\n    '''All :ref:`Task` s categorized as being able to `manipulate` data.\n    A result after manipulation is a new data.\n\n    .. versionadded:: 0.3.5\n    '''\n\n    def manip_sort(*args):\n        '''Open a :mod:`tasks.Task` with a :mod:`tasks.SortLayout` that gets\n        from user the table which will be sorted and the type of sorting\n        (`Ascending` or `Descending`). Create a new :mod:`main.Table`.\n\n        .. versionadded:: 0.3.5\n        '''\n        widget = SortLayout()\n        task = Task(title='Sort', wdg=widget,\n                    call=['Sort', Manipulate.manip_sort])\n        task.tablecls = task.app.tablecls\n        container = task.ids.container.children[0]\n        task.run = partial(Manipulate._manip_sort,\n                           task,\n                           container.ids.sort_type)\n        task.open()\n\n    @staticmethod\n    def _manip_sort(task, sort_type, *args):\n        sort_type = 'Asc' not in sort_type.text\n        from_address = task.from_address(task.tablenum, ':all', extended=True)\n        values, cols, rows, labels = from_address\n\n        # get separated cols to sort\n        chunks = []\n        for x in range(0, len(values), rows):\n            chunks.append(values[x:x + rows])\n\n        values = []\n        for val in chunks:\n            values.append(sorted(val, reverse=sort_type))\n\n        # add Table\n        table = task.ids.tablesel.text\n        table += ' (desc)' if sort_type else ' (asc)'\n        tabletab = TabbedPanelItem(text=table)\n        task.app.root.ids.tabpanel.add_widget(tabletab)\n\n        values = zip(*values)\n        values = [v for vals in values for v in vals]\n        task.app.root.tables.append((\n            table, task.tablecls(max_cols=cols, max_rows=rows,\n                                 pos=task.app.root.pos,\n                                 size=task.app.root.size,\n                                 values=values, labels=labels)\n        ))\n        tabletab.content = task.app.root.tables[-1][1]\n\n    def manip_filter(*args):\n        '''(Not yet implemented)\n        '''\n\n    def manip_append(*args):\n        '''Open a :mod:`tasks.Task` with a :mod:`tasks.AppendLayout` that gets\n        from user :mod:`main.Table`, type of append and an amount of empty\n        rows / cols to append.\n\n        The function either returns a new, altered :mod:`main.Table` of\n        selected one, or appends directly to the selected :class:`main.Table`.\n\n        .. versionadded:: 0.3.6\n        .. versionchanged:: 0.3.7\n            Added overwriting of selected :mod:`main.Table`\n        .. versionchanged:: 0.5.5\n            Added append for new columns\n        '''\n        widget = AppendLayout()\n        task = Task(title='Append', wdg=widget,\n                    call=['Append', Manipulate.manip_append])\n        task.tablecls = task.app.tablecls\n        container = task.ids.container.children[0]\n        task.run = partial(Manipulate._manip_append,\n                           task,\n                           container.ids.what,\n                           container.ids.amount,\n                           container.ids.cols_container,\n                           container.ids.overwrite)\n        task.open()\n\n    @staticmethod\n    def _manip_append(task, append_type, amount, container, overwrite, *args):\n        append_type = append_type.text\n        overwrite = overwrite.active\n        amount = int(amount.text) if amount.text else 0\n\n        if append_type == 'Append type':\n            raise Exception('No append type was chosen!')\n\n        # Stop the task if no amount (or =0) is specified\n        # or if no column is available\n        if not amount and not container.children:\n            raise Exception('No amount was specified!')\n\n        from_address = task.from_address(task.tablenum, ':all',\n                                         extended=True)\n        values, cols, rows, labels = from_address\n        rows = int(rows)\n\n        # get columns\n        chunks = []\n        for x in range(0, len(values), rows):\n            chunks.append(values[x:x + rows])\n        if append_type == 'Columns':\n            _cols = container.children[0].ids.columns.children\n            for c in reversed(_cols):\n                labels.append(c.ids.colname.text)\n                _type = c.ids.coltype.text\n                if _type == 'INTEGER':\n                    chunks.extend([[0 for _ in range(rows)]])\n                elif _type == 'REAL':\n                    chunks.extend([[0.0 for _ in range(rows)]])\n                else:\n                    chunks.extend([[u'' for _ in range(rows)]])\n                amount += 1\n                cols += 1\n\n        elif append_type == 'Rows':\n            # append to columns a zero value according\n            # to their type int(amount)-times\n            for r in range(amount):\n                for chunk in chunks:\n                    if isinstance(chunk[0], int):\n                        chunk.append(0)\n                    elif isinstance(chunk[0], float):\n                        chunk.append(0.0)\n                    else:\n                        chunk.append(u'')\n\n            # increase row count by new rows\n            rows += amount\n\n        # zip chunks to values, flatten values\n        values = zip(*chunks)\n        values = [v for vals in values for v in vals]\n\n        # add Table\n        tab_pos = 0\n        table = task.ids.tablesel.text\n        tabpanel = task.app.root.ids.tabpanel\n        tabpanel_len = len(tabpanel.tab_list)\n        if overwrite:\n            tab_pos = task.tablenum\n            # list of available tabs in Task is 0 -> n (from tables),\n            # but tab_list order is reversed in Kivy, therefore\n            # reverse the index by going backwards with -1\n            # and increase tab_pos, which is only index of\n            # value order in spinner\n            old_tab = tabpanel.tab_list[-1 - (tab_pos + 1)]\n            tabpanel.remove_widget(old_tab)\n            tabletab = TabbedPanelItem(text=table)\n            tabpanel.add_widget(tabletab, tabpanel_len - 1 - (tab_pos + 1))\n        else:\n            # if space in name, sql save boom\n            if append_type == 'Columns':\n                table += u'_append_{}_cols'.format(str(amount))\n            elif append_type == 'Rows':\n                table += u'_append_{}_rows'.format(str(amount))\n            tabletab = TabbedPanelItem(text=table)\n            tabpanel.add_widget(tabletab, 0)\n\n        # make new table\n        new_table = (\n            table, task.tablecls(max_cols=cols, max_rows=rows,\n                                 pos=task.app.root.pos,\n                                 size=task.app.root.size,\n                                 values=values, labels=labels)\n        )\n\n        # place newly created table into tab's content\n        if overwrite:\n            task.app.root.tables[tab_pos] = new_table\n            tabletab.content = task.app.root.tables[tab_pos][1]\n        else:\n            task.app.root.tables.append(new_table)\n            tabletab.content = task.app.root.tables[-1][1]\n\n    def manip_split(*args):\n        '''(Not yet implemented)\n        '''\n\n    def manip_merge(*args):\n        '''(Not yet implemented)\n        '''\n\n    def manip_stand(*args):\n        '''(Not yet implemented)\n        Standardizing specified columns from data according to various\n        types of standardiztion.\n        '''\n        widget = StandLayout()\n        task = Task(title='Standardize', wdg=widget,\n                    call=['Standardize', Manipulate.manip_stand])\n        task.tablecls = task.app.tablecls\n        container = task.ids.container.children[0]\n        task.run = partial(Manipulate._manip_stand,\n                           task)\n        task.open()\n\n    @staticmethod\n    def _manip_stand(task, *args):\n        pass\n\n    names = (('Sort', manip_sort),\n             ('_Filter', manip_filter),\n             ('Append', manip_append),\n             ('_Split', manip_split),   # split into two data(columns, rows)\n             ('_Merge', manip_merge),\n             ('_Standardize', manip_stand))\n"""
krysa/tasks/plot.py,0,"b""'''\n.. |pyplot| replace:: matplotlib.pyplot\n.. _pyplot: http://matplotlib.org/api/pyplot_api.html\n'''\n\nfrom . import Task, LinePlotLayout\nfrom functools import partial\nimport os.path as op\nimport numpy as np\nimport os\n\n# stop stealing Window focus\nimport matplotlib\nmatplotlib.use('Agg')\nfrom matplotlib import pyplot\n\n\nclass Plot(object):\n    '''All :ref:`Task` s categorized as `plot` under one roof. To draw plots\n    the app uses |pyplot|_ which is automatically dumped to a `*.png` file\n    and loaded into result page.\n\n    .. versionadded:: 0.4.3\n    '''\n\n    def plot_line(*args):\n        '''Open a :mod:`tasks.Task` with a :mod:`tasks.LinePlotLayout` that\n        gets from user :ref:`Data` address. Create a result page with a plot.\n\n        .. versionadded:: 0.4.3\n        '''\n        widget = LinePlotLayout()\n        task = Task(title='Line plot', wdg=widget,\n                    call=['Line plot', Plot.plot_line])\n        container = task.ids.container.children[0]\n        task.run = partial(Plot._plot_line,\n                           task,\n                           container.ids.title,\n                           container.ids.xname,\n                           container.ids.yname,\n                           container.ids.labelcheck,\n                           container.ids.xlabel,\n                           container.ids.ylabel,\n                           container.ids.xmin,\n                           container.ids.xmax,\n                           container.ids.ymin,\n                           container.ids.ymax,\n                           container.ids.plotcolor,\n                           container.ids.plotshape,\n                           container.ids.showgrid)\n        task.open()\n\n    @staticmethod\n    def _plot_line(task, title, xaddress, yaddress, labelcheck,\n                   xlabel, ylabel, xmin, xmax, ymin, ymax, plotcolor,\n                   plotshape, showgrid, *args):\n        res_dir = op.join(task.app.project_dir, 'plots')\n        idx = len([f for f in os.listdir(res_dir) if f.startswith('plot')]) + 1\n\n        # set yvalues to None if input contains only xvalues\n        yvalues = None\n        if yaddress.text:\n            yvalues = task.from_address(task.tablenum, yaddress.text)\n        xvalues = task.from_address(task.tablenum, xaddress.text)\n\n        # fetch values\n        drawoption = plotcolor.text + plotshape.text\n        ylabel = ylabel.text\n        xlabel = xlabel.text\n        xmin = xmin.text\n        xmax = xmax.text\n        ymin = ymin.text\n        ymax = ymax.text\n        axes = []\n\n        # set up plot\n        pyplot.hold(False)\n        fig = pyplot.figure()\n        fig.suptitle(title.text, fontsize='x-large')\n\n        # pop the first value to become axis label\n        if labelcheck.active:\n            xlabel = xvalues[0]\n            xvalues = xvalues[1:]\n            if yvalues:\n                ylabel = yvalues[0]\n                yvalues = yvalues[1:]\n\n        # draw either X & Y or X only values\n        if yvalues:\n            pyplot.plot(xvalues, yvalues, drawoption)\n            pyplot.ylabel(ylabel)\n            pyplot.xlabel(xlabel)\n        else:\n            pyplot.plot(xvalues, drawoption)\n            pyplot.xlabel(xlabel)\n\n        # check for axis input, use default if empty\n        for i, item in enumerate([xmin, xmax, ymin, ymax]):\n            if item:\n                axes.append(float(item))\n            else:\n                axes.append(pyplot.axis()[i])\n\n        # dump to file and clean\n        pyplot.axis(axes)\n        pyplot.grid(showgrid.active)\n        result = op.join(res_dir, 'plot{}.png'.format(idx))\n        pyplot.savefig(result)\n        pyplot.cla()\n        pyplot.clf()\n        pyplot.close(fig)\n\n        task.set_page('Line plot', result, 'image')\n\n    names = (('Line plot', plot_line),\n             ('_Bar chart', plot_line),\n             ('_Pie chart', plot_line))\n"""
krysa/tests/__init__.py,0,"b'\'\'\'\nTests need to run independently on each other, not in a single python\ninterpreter. After each test a fresh `python` is required, so either run them\nlike this one by one::\n\n    python test_<something>.py\n\nor use `KivyUnitTest <https://github.com/KeyWeeUsr/KivyUnitTest>`_ to do it\ninstead of you.\n\nTo test if your installation works properly, navigate to Python\'s\n`site-package` folder and run the tests with::\n\n    python -m kivyunittest --folder ""krysa/tests""\n\'\'\'\n'"
krysa/tests/test_file_closeproject.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n\n        # set columns for new data\n        cols = new_data.ids.columns.children\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        for i in range(5):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 4:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        for i in range(3):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 2:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = 'end'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        for i in range(4):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 3:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        # test project variables\n        self.assertTrue(app.project_exists)\n        self.assertFalse(app.project_dir is '')\n        self.assertFalse(app.project_name is '')\n\n        # test closed project\n        app.root.close_project()\n\n        self.assertFalse(app.project_exists)\n        self.assertTrue(app.project_dir is '')\n        self.assertTrue(app.project_name is '')\n        self.assertFalse(app.root.tables)\n        self.assertFalse(app.root.ids.flow.children)\n        self.assertTrue(len(app.root.ids.tabpanel.tab_list) is 1)\n\n        app.stop()\n\n    def test_file_closeproject(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_exportdata.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n\n        # set columns for new data\n        cols = new_data.ids.columns.children\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        for i in range(5):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 4:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        for i in range(3):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 2:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = 'end'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        for i in range(4):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 3:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        # create second data/sql table\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData2'\n        cols = new_data.ids.columns.children\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = 'text'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        app.root.export_data()\n        app.root._export_data([self.folder], 'test_export.sqlite')\n\n        # set testing data\n        newdata_values = [[0, u'', 0.0],\n                          [0, u'', 0.0],\n                          [0, u'end', 0.0],\n                          [0, u'', 1.1],\n                          [1, u'', 0.0]]\n        newdata2_values = [[1, u'text', 1.1]]\n\n        # get data from krysa table\n        ndv = []\n        for d in app.root.tables[0][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv.append(float(d['text']))\n                else:\n                    ndv.append(d['text'])\n        ndv = [ndv[x:x + 3] for x in range(0, len(ndv), 3)]\n\n        ndv2 = []\n        for d in app.root.tables[1][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv2.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv2.append(float(d['text']))\n                else:\n                    ndv2.append(d['text'])\n        ndv2 = [ndv2[x:x + 3] for x in range(0, len(ndv2), 3)]\n\n        # test data\n        self.assertTrue(op.exists(op.join(self.folder, 'test_export.sqlite')))\n        conn = sqlite3.connect(op.join(self.folder, 'test_export.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        conn = sqlite3.connect(op.join(self.folder, 'test_export.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData2')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('\\nNewData2:')\n        for i, v in enumerate(values):\n            self.assertEqual(v, newdata2_values[i])\n            self.assertEqual(ndv2[i], newdata2_values[i])\n            print(v)\n\n        app.stop()\n\n    def test_file_exportdata(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_importdata.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # set testing data\n        newdata_values = [[0, u'', 0.0],\n                          [0, u'', 0.0],\n                          [0, u'end', 0.0],\n                          [0, u'', 1.1],\n                          [1, u'', 0.0]]\n        newdata2_values = [[1, u'text', 1.1]]\n\n        app.root.import_data()\n        app.root._import_data([op.join(self.path, 'test_Project',\n                                       'data', 'data.sqlite')])\n\n        # get data from krysa table\n        ndv = []\n        for d in app.root.tables[0][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv.append(float(d['text']))\n                else:\n                    ndv.append(d['text'])\n        ndv = [ndv[x:x + 3] for x in range(0, len(ndv), 3)]\n\n        ndv2 = []\n        for d in app.root.tables[1][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv2.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv2.append(float(d['text']))\n                else:\n                    ndv2.append(d['text'])\n        ndv2 = [ndv2[x:x + 3] for x in range(0, len(ndv2), 3)]\n\n        # test data\n        self.assertTrue(op.exists(op.join(self.path, 'test_Project',\n                                          'data', 'data.sqlite')))\n        conn = sqlite3.connect(op.join(self.path, 'test_Project',\n                                       'data', 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        conn = sqlite3.connect(op.join(self.path, 'test_Project',\n                                       'data', 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData2')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('\\nNewData2:')\n        for i, v in enumerate(values):\n            self.assertEqual(v, newdata2_values[i])\n            self.assertEqual(ndv2[i], newdata2_values[i])\n            print(v)\n\n        app.stop()\n\n    def test_file_importdata(self):\n        self.path = op.dirname(op.abspath(__file__))\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_new.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # test if there is error popup for no Project available\n        app.root._new_data()\n        children = [str(c) for c in app.root.parent.children]\n        self.assertTrue(any('ErrorPop' in c for c in children))\n        for c in children:\n            if 'ErrorPop' in c:\n                app.root.parent.children[children.index(c)].dismiss()\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # tests Project tree\n        self.assertTrue(op.exists(op.join(project_folder, 'Test.krysa')))\n        self.assertTrue(op.exists(op.join(data, 'data.sqlite')))\n        self.assertTrue(op.exists(results))\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n\n        # test removing a value and a column\n        cols = new_data.ids.columns.children\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.valadd.dispatch('on_release')\n        vals = cols[0].ids.vals.children\n\n        vals[0].ids.valX.dispatch('on_release')\n        self.assertFalse(vals)\n        cols[0].ids.colX.dispatch('on_release')\n        self.assertFalse(cols)\n\n        # set columns for new data\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        for i in range(5):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 4:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        for i in range(3):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 2:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = 'end'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        for i in range(4):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 3:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        # create second data/sql table\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData2'\n        cols = new_data.ids.columns.children\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = 'text'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        cols[0].ids.valadd.dispatch('on_release')\n        vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        # set testing data\n        newdata_values = [[0, u'', 0.0],\n                          [0, u'', 0.0],\n                          [0, u'end', 0.0],\n                          [0, u'', 1.1],\n                          [1, u'', 0.0]]\n        newdata2_values = [[1, u'text', 1.1]]\n\n        # get data from krysa table\n        ndv = []\n        for d in app.root.tables[0][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv.append(float(d['text']))\n                else:\n                    ndv.append(d['text'])\n        ndv = [ndv[x:x + 3] for x in range(0, len(ndv), 3)]\n\n        ndv2 = []\n        for d in app.root.tables[1][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv2.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv2.append(float(d['text']))\n                else:\n                    ndv2.append(d['text'])\n        ndv2 = [ndv2[x:x + 3] for x in range(0, len(ndv2), 3)]\n\n        # test data\n        self.assertTrue(op.exists(op.join(data, 'data.sqlite')))\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData2')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('\\nNewData2:')\n        for i, v in enumerate(values):\n            self.assertEqual(v, newdata2_values[i])\n            self.assertEqual(ndv2[i], newdata2_values[i])\n            print(v)\n\n        app.stop()\n\n    def test_file_new(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_openproject.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open open_project dialog\n        app.root.open_project()\n        test_project = op.join(op.dirname(self.folder), 'test_Project')\n        app.root.opendlg.run([op.join(test_project, 'Test.krysa')])\n\n        self.assertTrue(app.project_exists)\n        self.assertEqual(app.project_dir, test_project)\n        self.assertEqual(app.project_name, 'Test')\n        data = op.join(test_project, 'data')\n        results = op.join(test_project, 'results')\n        plots = op.join(test_project, 'plots')\n\n        # set testing data\n        newdata_values = [[0, u'', 0.0],\n                          [0, u'', 0.0],\n                          [0, u'end', 0.0],\n                          [0, u'', 1.1],\n                          [1, u'', 0.0]]\n        newdata2_values = [[1, u'text', 1.1]]\n        results_count = 4\n        plots_count = 2\n        self.assertEqual(plots_count, len(os.listdir(plots)))\n        self.assertEqual(results_count, len(os.listdir(results)))\n\n        # get data from krysa table\n        ndv = []\n        for d in app.root.tables[0][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv.append(float(d['text']))\n                else:\n                    ndv.append(d['text'])\n        ndv = [ndv[x:x + 3] for x in range(0, len(ndv), 3)]\n\n        ndv2 = []\n        for d in app.root.tables[1][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv2.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv2.append(float(d['text']))\n                else:\n                    ndv2.append(d['text'])\n        ndv2 = [ndv2[x:x + 3] for x in range(0, len(ndv2), 3)]\n\n        # test data\n        self.assertTrue(op.exists(op.join(data, 'data.sqlite')))\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData2')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('\\nNewData2:')\n        for i, v in enumerate(values):\n            self.assertEqual(v, newdata2_values[i])\n            self.assertEqual(ndv2[i], newdata2_values[i])\n            print(v)\n\n        # test imported results\n        imported_results = 0\n        expected_files = ['000', '001', '002', '003']\n        expected_plots = ['plot1', 'plot2']\n        sources = [op.splitext(f)[0] for f in sorted(os.listdir(plots))]\n        self.assertEqual(sources, expected_plots)\n\n        sources = []\n        results = app.root.ids.results\n        for child in reversed(results.children):\n            if 'Page' in str(child):\n                imported_results += 1\n                for image in child.children[2].children[0].children:\n                    sources.append(op.splitext(op.basename(image.source))[0])\n\n        self.assertEqual(results_count, imported_results)\n        self.assertEqual(sources, expected_files)\n\n        app.stop()\n\n    def test_file_openproject(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_recentprojects.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # Run twice, test switching projects on True\n        recent_file = op.join(app.user_data_dir, 'recent_projects.krysa')\n        for create in range(2):\n            if create:\n                # Create new project\n                app.root._new_project()\n                app.root.savedlg.view.selection = [self.folder, ]\n                app.root.savedlg.ids.name.text = 'Test.krysa'\n                app.root.savedlg.run([self.folder, ], 'Test.krysa')\n                project_folder = op.join(self.path, 'test_folder', 'Test')\n                data = op.join(project_folder, 'data')\n                results = op.join(project_folder, 'results')\n\n                # Write paths\n                test_file = op.join(self.path, 'test_Project', 'Test.krysa\\n')\n                with open(recent_file, 'w') as f:\n                    paths = '/just/random/path.krysa\\n' * 4 + test_file\n                    f.write(paths)\n\n            # Show recent projects\n            app.root.recent_projects(app.root)\n            self.assertTrue(op.exists(recent_file))\n            with open(recent_file) as f:\n                lines = f.readlines()\n\n            if create:\n                self.assertEqual(len(lines), 5)\n            else:\n                self.assertEqual(lines, [])\n\n        # Check if correct path and open\n        self.assertTrue('test_Project' in lines[-2])\n        path = app.root._recent_projects()\n        for p in path:\n            if 'test_Project' in p:\n                path = p\n        app.root._open_recent(path)\n        app.stop()\n\n    def test_file_recentprojects(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        rmtree(app.user_data_dir)\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(app.user_data_dir)\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_file_saveproject.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA\n\n\nclass Test(unittest.TestCase):\n\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # test saving empty Project\n        app.root._save_project()\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        self.assertFalse(op.exists(project_folder))\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n        for i in range(5):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 4:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'TEXT'\n        vals = cols[0].ids.vals.children\n        for i in range(3):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 2:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = 'end'\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n        for i in range(4):\n            cols[0].ids.valadd.dispatch('on_release')\n            if i != 3:\n                vals[0].ids.value.text = ''\n            else:\n                vals[0].ids.value.text = '1.1'\n        new_data = app.root.wiz_newdata.run()\n\n        # set testing data\n        newdata_values = [[0, u'', 0.0],\n                          [0, u'', 0.0],\n                          [0, u'end', 0.0],\n                          [0, u'', 1.1],\n                          [1, u'', 0.0]]\n\n        # get data from krysa table\n        end_pos = None\n        ndv = []\n        for d in app.root.tables[0][1].rv.data:\n            if 'c' in d.keys():\n                if d['type'] == int:\n                    ndv.append(int(d['text']))\n                elif d['type'] == float:\n                    ndv.append(float(d['text']))\n                else:\n                    ndv.append(d['text'])\n            if not end_pos and d['text'] == u'end':\n                end_pos = app.root.tables[0][1].rv.data.index(d)\n        ndv = [ndv[x:x + 3] for x in range(0, len(ndv), 3)]\n        self.assertEqual(len(app.root.tables), 1)\n\n        # test data\n        self.assertTrue(op.exists(op.join(data, 'data.sqlite')))\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        try:\n            c.execute('SELECT * FROM NewData2')\n        except sqlite3.OperationalError:\n            print('No NewData2 check... OK\\n')\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        # change value in table\n        app.root.tables[0][1].rv.data[end_pos]['text'] = u'new_end'\n        ndv[2][1] = u'new_end'\n        newdata_values[2][1] = u'new_end'\n        app.root._save_project()\n        print(app.project_dir, app.project_exists)\n        # test new data\n        conn = sqlite3.connect(op.join(data, 'data.sqlite'))\n        c = conn.cursor()\n        c.execute('SELECT * FROM NewData')\n        values = [item for sublist in c.fetchall() for item in sublist]\n        values = [values[x:x + 3] for x in range(0, len(values), 3)]\n        conn.close()\n        print('NewData:')\n        for i, v in enumerate(values):\n            # values == sql values\n            self.assertEqual(v, newdata_values[i])\n            # values == KrySA values\n            self.assertEqual(ndv[i], newdata_values[i])\n            print(v)\n\n        app.stop()\n\n    def test_file_saveproject(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_count.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        address = ['B3', 'A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10', 'D13']\n\n        for addr in address:\n            taskcls = Basic()\n            taskcls.basic_count()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[0].text = addr\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([1, 52, 4, 4, 4, 4, 16, 1])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = int(results.children[i].ids.page.children[1].text)\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_count(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_countif.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        conditions = [\n            ['Equal to', '1'],\n            ['Not equal to', '13'],\n            ['Less than', '10.10'],\n            ['Less than or equal', '10'],\n            ['Greater than', '4.4'],\n            ['Greater than or equal', '5'],\n            ['Less than&,Greater than or equal|,Equal to', '13.13,10,1']\n        ]\n\n        for con in conditions:\n            taskcls = Basic()\n            taskcls.basic_countif()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            add_cond = body[-2].children[0].children[-1].children[0]\n            conds = body[-2].children[0].children[-2].children[0]\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[-1].children[-2].text = 'A1:D13'\n\n            # if multiple conditions\n            if ',' in con[0]:\n                cs = con[0].split(',')\n                vs = con[1].split(',')\n                for i in range(len(cs)):\n                    add_cond.dispatch('on_release')\n                    conds.children[0].children[-2].text = vs[i]\n                    if '&' in cs[i]:\n                        conds.children[0].children[-3].text = 'AND'\n                        conds.children[0].children[-1].text = cs[i][:-1]\n                    elif '|' in cs[i]:\n                        conds.children[0].children[-3].text = 'OR'\n                        conds.children[0].children[-1].text = cs[i][:-1]\n                    else:\n                        conds.children[0].children[-1].text = cs[i]\n\n            else:\n                add_cond.dispatch('on_release')\n                conds.children[0].children[-1].text = con[0]\n                conds.children[0].children[-2].text = con[1]\n\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([2, 50, 38, 38, 36, 36, 16])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = int(results.children[i].ids.page.children[1].text[-2:])\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_countif(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_freq.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(1, 31)\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n\n        for i in range_vals:  # -13 to -390\n            cols[0].ids.valadd.dispatch('on_release')\n            vals[0].ids.value.text = str(i * -13)\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n\n        for i in range_vals:  # 0.318.. to 9.554..\n            cols[0].ids.valadd.dispatch('on_release')\n            vals[0].ids.value.text = str(i / 3.14)\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'INTEGER'\n        vals = cols[0].ids.vals.children\n\n        for i in range_vals:  # 7 to 210\n            cols[0].ids.valadd.dispatch('on_release')\n            vals[0].ids.value.text = str(i * 7)\n\n        new_data.ids.columnadd.dispatch('on_release')\n        cols[0].ids.colname.text += str(len(cols))\n        cols[0].ids.coltype.text = 'REAL'\n        vals = cols[0].ids.vals.children\n\n        for i in range_vals:  # 10.10 to 213.213\n            cols[0].ids.valadd.dispatch('on_release')\n            num = str(i * 7 + 3)\n            vals[0].ids.value.text = num + '.' + num\n        # create new data\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        address = ['A1', 'A1:D30']\n\n        for bintype in ('Count', 'Edges', 'Calculate'):\n            for manual in range(2):\n                for addr in address:\n                    taskcls = Basic()\n                    taskcls.basic_freq()\n\n                    children = app.root_window.children\n                    for c in reversed(children):\n                        if 'Task' in str(c):\n                            index = children.index(c)\n                    task = children[index]\n\n                    # fill the task\n                    body = task.children[0].children[0].children[0].children\n                    body[-1].text = 'NewData'\n                    rows = body[-2].children[0].children\n\n                    # address & precision\n                    rows[-1].children[-2].text = addr\n                    rows[-1].children[-4].text = '4'\n\n                    # limits\n                    if manual:\n                        rows[-2].children[-2].children[0].active = False\n                        rows[-2].children[-3].children[-1].text = '-300'\n                        rows[-2].children[-3].children[-2].text = '500'\n\n                    # bins\n                    rows[-3].children\n                    rows[-3].children[-2].text = bintype\n                    screen = rows[-3].children[-3].children[0]\n\n                    if bintype == 'Count':\n                        # manually set 9 bins\n                        screen.children[0].text = '9'\n\n                    elif bintype == 'Edges':\n                        # set bin edges from -100.14 to 799.86 wide 100\n                        grid = screen.children[0].children[-1].children[0]\n                        delbutton = screen.children[0].children[-3]\n                        while grid.children:\n                            delbutton.dispatch('on_release')\n                        button = screen.children[0].children[-2]\n                        for j in range(10):\n                            button.dispatch('on_release')\n                            grid.children[0].text = str(-100.14 + j * 100)\n\n                    elif bintype == 'Calculate':\n                        screen.children[0].children[-1].text = 'Scott'\n\n                    # run task\n                    body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        # 2x Count with auto limits\n        # 2x Count with manual limits\n        # 2x Edges with auto limits\n        # 2x Edges with manual limits\n        # 2x Calcu with auto limits\n        # 2x Calcu with manual limits\n        expected = [\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-13.5', '-13.3889', '0.0', '0.0', '0.0',\n             '-13.3889', '-13.2778', '0.0', '0.0', '0.0',\n             '-13.2778', '-13.1667', '0.0', '0.0', '0.0',\n             '-13.1667', '-13.0556', '0.0', '0.0', '0.0',\n             '-13.0556', '-12.9444', '1.0', '1.0', '1.0',\n             '-12.9444', '-12.8333', '0.0', '0.0', '1.0',\n             '-12.8333', '-12.7222', '0.0', '0.0', '1.0',\n             '-12.7222', '-12.6111', '0.0', '0.0', '1.0',\n             '-12.6111', '-12.5', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-390.0', '-322.9763', '6.0', '0.05', '0.05',\n             '-322.9763', '-255.9527', '5.0', '0.0417', '0.0917',\n             '-255.9527', '-188.929', '5.0', '0.0417', '0.1334',\n             '-188.929', '-121.9053', '5.0', '0.0417', '0.1751',\n             '-121.9053', '-54.8817', '5.0', '0.0417', '0.2168',\n             '-54.8817', '12.142', '36.0', '0.3', '0.5168',\n             '12.142', '79.1657', '19.0', '0.1583', '0.6751',\n             '79.1657', '146.1893', '19.0', '0.1583', '0.8334',\n             '146.1893', '213.213', '20.0', '0.1667', '1.0001'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-300.0', '-211.1111', '0.0', '0.0', '0.0',\n             '-211.1111', '-122.2222', '0.0', '0.0', '0.0',\n             '-122.2222', '-33.3333', '0.0', '0.0', '0.0',\n             '-33.3333', '55.5556', '1.0', '1.0', '1.0',\n             '55.5556', '144.4444', '0.0', '0.0', '1.0',\n             '144.4444', '233.3333', '0.0', '0.0', '1.0',\n             '233.3333', '322.2222', '0.0', '0.0', '1.0',\n             '322.2222', '411.1111', '0.0', '0.0', '1.0',\n             '411.1111', '500.0', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-300.0', '-211.1111', '7.0', '0.0583', '0.0583',\n             '-211.1111', '-122.2222', '7.0', '0.0583', '0.1166',\n             '-122.2222', '-33.3333', '7.0', '0.0583', '0.1749',\n             '-33.3333', '55.5556', '46.0', '0.3833', '0.5582',\n             '55.5556', '144.4444', '26.0', '0.2167', '0.7749',\n             '144.4444', '233.3333', '20.0', '0.1667', '0.9416',\n             '233.3333', '322.2222', '0.0', '0.0', '0.9416',\n             '322.2222', '411.1111', '0.0', '0.0', '0.9416',\n             '411.1111', '500.0', '0.0', '0.0', '0.9416'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-100.14', '-0.14', '1.0', '1.0', '1.0',\n             '-0.14', '99.86', '0.0', '0.0', '1.0',\n             '99.86', '199.86', '0.0', '0.0', '1.0',\n             '199.86', '299.86', '0.0', '0.0', '1.0',\n             '299.86', '399.86', '0.0', '0.0', '1.0',\n             '399.86', '499.86', '0.0', '0.0', '1.0',\n             '499.86', '599.86', '0.0', '0.0', '1.0',\n             '599.86', '699.86', '0.0', '0.0', '1.0',\n             '699.86', '799.86', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-390.0', '-100.14', '23.0', '0.1917', '0.1917',\n             '-100.14', '-0.14', '7.0', '0.0583', '0.25',\n             '-0.14', '99.86', '57.0', '0.475', '0.725',\n             '99.86', '199.86', '29.0', '0.2417', '0.9667',\n             '199.86', '299.86', '4.0', '0.0333', '1.0',\n             '299.86', '399.86', '0.0', '0.0', '1.0',\n             '399.86', '499.86', '0.0', '0.0', '1.0',\n             '499.86', '599.86', '0.0', '0.0', '1.0',\n             '599.86', '699.86', '0.0', '0.0', '1.0',\n             '699.86', '799.86', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-100.14', '-0.14', '1.0', '1.0', '1.0',\n             '-0.14', '99.86', '0.0', '0.0', '1.0',\n             '99.86', '199.86', '0.0', '0.0', '1.0',\n             '199.86', '299.86', '0.0', '0.0', '1.0',\n             '299.86', '399.86', '0.0', '0.0', '1.0',\n             '399.86', '499.86', '0.0', '0.0', '1.0',\n             '499.86', '599.86', '0.0', '0.0', '1.0',\n             '599.86', '699.86', '0.0', '0.0', '1.0',\n             '699.86', '799.86', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-390.0', '-100.14', '23.0', '0.1917', '0.1917',\n             '-100.14', '-0.14', '7.0', '0.0583', '0.25',\n             '-0.14', '99.86', '57.0', '0.475', '0.725',\n             '99.86', '199.86', '29.0', '0.2417', '0.9667',\n             '199.86', '299.86', '4.0', '0.0333', '1.0',\n             '299.86', '399.86', '0.0', '0.0', '1.0',\n             '399.86', '499.86', '0.0', '0.0', '1.0',\n             '499.86', '599.86', '0.0', '0.0', '1.0',\n             '599.86', '699.86', '0.0', '0.0', '1.0',\n             '699.86', '799.86', '0.0', '0.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-13.5', '-12.5', '1.0', '1.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-390.0', '-289.4645', '8.0', '0.0667', '0.0667',\n             '-289.4645', '-188.929', '8.0', '0.0667', '0.1334',\n             '-188.929', '-88.3935', '8.0', '0.0667', '0.2001',\n             '-88.3935', '12.142', '38.0', '0.3167', '0.5168',\n             '12.142', '112.6775', '29.0', '0.2417', '0.7585',\n             '112.6775', '213.213', '29.0', '0.2417', '1.0002'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-300.0', '500.0', '1.0', '1.0', '1.0'],\n            ['Lower edge', 'Upper edge', 'Absolute', 'Relative', 'Cumulative',\n             '-300.0', '-220.0', '7.0', '0.0583', '0.0583',\n             '-220.0', '-140.0', '6.0', '0.05', '0.1083',\n             '-140.0', '-60.0', '6.0', '0.05', '0.1583',\n             '-60.0', '20.0', '38.0', '0.3167', '0.475',\n             '20.0', '100.0', '23.0', '0.1917', '0.6667',\n             '100.0', '180.0', '23.0', '0.1917', '0.8584',\n             '180.0', '260.0', '10.0', '0.0833', '0.9417',\n             '260.0', '340.0', '0.0', '0.0', '0.9417',\n             '340.0', '420.0', '0.0', '0.0', '0.9417',\n             '420.0', '500.0', '0.0', '0.0', '0.9417']\n        ]\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in reversed(results.children):\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        resvals = []\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # table-like widget\n            resgrid = results.children[i].ids.page.children[1].children[1]\n            # reverse children order\n            children = [child.text for child in reversed(resgrid.children)]\n            resvals.extend([children])\n        # reverse value order\n        resvals = [v for v in reversed(resvals)]\n        self.assertEqual(resvals, expected)\n        app.stop()\n\n    def test_tasks_basic_freq(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_large.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        k = '3'\n        address = ['A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10']\n        for addr in address:\n            taskcls = Basic()\n            taskcls.basic_large()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[-1].children[0].text = addr\n            body[-2].children[0].children[-2].children[0].text = k\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([12.12, 1.1, 1.1, 12.12, 12.12, 9.9])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = float(results.children[i].ids.page.children[1].text)\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_large(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_max.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        address = ['B3', 'A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10', 'D13']\n\n        for addr in address:\n            taskcls = Basic()\n            taskcls.basic_max()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[0].text = addr\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([3.3, 13.13, 2.2, 2.2, 13.13, 13.13, 10.10, 13.13])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = float(results.children[i].ids.page.children[1].text)\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_max(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_min.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        address = ['B3', 'A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10', 'D13']\n\n        for addr in address:\n            taskcls = Basic()\n            taskcls.basic_min()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[0].text = addr\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([3.3, 1, 1, 1, 12, 12, 3, 13.13])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = float(results.children[i].ids.page.children[1].text)\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_min(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_basic_small.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.basic import Basic\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        k = '3'\n        address = ['A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10']\n        for addr in address:\n            taskcls = Basic()\n            taskcls.basic_small()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData'\n            body[-2].children[0].children[-1].children[0].text = addr\n            body[-2].children[0].children[-2].children[0].text = k\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        expected = reversed([2, 2, 2, 13, 13, 4])\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in results.children:\n            if 'Widget' in str(c):\n                skipone = True\n                break\n\n        for i, exp in enumerate(expected):\n            i = i + 1 if skipone else i\n            # Result -> Page -> container -> result\n            result = float(results.children[i].ids.page.children[1].text)\n            self.assertEqual(result, exp)\n        app.stop()\n\n    def test_tasks_basic_small(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_manipulate_append.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.manipulate import Manipulate\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        for x in range(4):\n            # open New -> Data popup, set inputs\n            app.root._new_data()\n            new_data = app.root.wiz_newdata.ids.container.children[0]\n            new_data.ids.table_name.text = u'NewData' + str(x)\n            cols = new_data.ids.columns.children\n\n            # set columns for new data\n            range_vals = range(13)\n            for _ in range(2):\n                new_data.ids.columnadd.dispatch('on_release')\n                cols[0].ids.colname.text += str(len(cols))\n                cols[0].ids.coltype.text = 'INTEGER'\n                vals = cols[0].ids.vals.children\n\n                for i in range_vals:\n                    cols[0].ids.valadd.dispatch('on_release')\n                    vals[0].ids.value.text = str(i + 1)\n\n                new_data.ids.columnadd.dispatch('on_release')\n                cols[0].ids.colname.text += str(len(cols))\n                cols[0].ids.coltype.text = 'REAL'\n                vals = cols[0].ids.vals.children\n\n                for i in range_vals:\n                    cols[0].ids.valadd.dispatch('on_release')\n                    num = str(i + 1)\n                    vals[0].ids.value.text = num + '.' + num * x\n            new_data = app.root.wiz_newdata.run()\n\n        # (append type, overwrite, table)\n        amount = 1\n        options = [('Rows', False, '0'), ('Rows', True, '1'),\n                   ('Columns', False, '2'), ('Columns', True, '3')]\n\n        for opt in options:\n            # check for max len of coltype's Spinner list\n            self.assertTrue(amount < 5)\n\n            taskcls = Manipulate()\n            taskcls.manip_append()\n\n            children = app.root_window.children\n            for c in reversed(children):\n                if 'Task' in str(c):\n                    index = children.index(c)\n            task = children[index]\n\n            # fill the task\n            body = task.children[0].children[0].children[0].children\n            body[-1].text = 'NewData' + opt[2]\n            body[-2].children[0].ids.what.text = opt[0]\n            body[-2].children[0].ids.overwrite.active = opt[1]\n            col_con = body[-2].children[0].ids.cols_container\n\n            if opt[0] == 'Rows':\n                body[-2].children[0].ids.amount.text = str(amount)\n            elif opt[0] == 'Columns':\n                col_con = col_con.children[0]\n                addcol = col_con.ids.columnadd\n                for z in range(amount):\n                    addcol.dispatch('on_release')\n                    _col = col_con.ids.columns.children[0]\n                    _col.ids.colname.text = 'Column' + str(z)\n                    _col.ids.coltype.text = _col.ids.coltype.values[-z]\n\n            amount += 1\n            body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        tables = app.root.tables\n        exp_tables = [u'NewData0', u'NewData1', u'NewData2',\n                      u'NewData3', u'NewData0_append_1_rows',\n                      u'NewData2_append_3_cols']\n\n        # get table list from Task\n        taskcls = Manipulate()\n        taskcls.manip_append()\n\n        children = app.root_window.children\n        for c in reversed(children):\n            if 'Task' in str(c):\n                index = children.index(c)\n        task = children[index]\n        body = task.children[0].children[0].children[0].children\n        table_values = body[-1].values\n        body[-3].children[-1].dispatch('on_release')\n\n        # check table order in tab_list and in Task\n        self.assertEqual(table_values, exp_tables)\n        self.assertEqual([t[0] for t in tables], exp_tables)\n\n        _tables = [tables[4][1], tables[1][1],\n                   tables[5][1], tables[3][1]]\n        _exp_labels = [\n            [u'Data1 (A)', u'Data2 (B)', u'Data3 (C)', u'Data4 (D)'],\n            [u'Data1 (A)', u'Data2 (B)', u'Data3 (C)', u'Data4 (D)'],\n            [u'Data1 (A)', u'Data2 (B)', u'Data3 (C)', u'Data4 (D)',\n             u'Column0 (E)', u'Column1 (F)', u'Column2 (G)'],\n            [u'Data1 (A)', u'Data2 (B)', u'Data3 (C)', u'Data4 (D)',\n             u'Column0 (E)', u'Column1 (F)', u'Column2 (G)', u'Column3 (H)']\n        ]\n\n        for i, tbl in enumerate(_tables):\n            data = tbl.rv.data\n            labels = []\n            for d in data:\n                if 'cell' in d.keys():\n                    if 'label' in d['cell']:\n                        labels.append(d['text'])\n            self.assertEqual(labels, _exp_labels[i])\n            # check for zeros/order too?\n\n        # test saving at the end (space in table name test)\n        app.root.save_project()\n        app.stop()\n\n    def test_tasks_manipulate_append(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/tests/test_tasks_plot_lineplot.py,0,"b""import unittest\n\nimport os\nimport sys\nimport time\nimport sqlite3\nimport os.path as op\nfrom shutil import rmtree\nfrom functools import partial\nfrom kivy.clock import Clock\n\nmain_path = op.dirname(op.dirname(op.abspath(__file__)))\nsys.path.append(main_path)\nfrom main import KrySA, ErrorPop\nfrom tasks.plot import Plot\n\n\nclass Test(unittest.TestCase):\n    def pause(*args):\n        time.sleep(0.000001)\n\n    def run_test(self, app, *args):\n        Clock.schedule_interval(self.pause, 0.000001)\n\n        # open New -> Project popup, set inputs\n        app.root._new_project()\n        app.root.savedlg.view.selection = [self.folder, ]\n        app.root.savedlg.ids.name.text = 'Test.krysa'\n        app.root.savedlg.run([self.folder, ], 'Test.krysa')\n        project_folder = op.join(self.path, 'test_folder', 'Test')\n        data = op.join(project_folder, 'data')\n        results = op.join(project_folder, 'results')\n\n        # open New -> Data popup, set inputs\n        app.root._new_data()\n        new_data = app.root.wiz_newdata.ids.container.children[0]\n        new_data.ids.table_name.text = 'NewData'\n        cols = new_data.ids.columns.children\n\n        # set columns for new data\n        range_vals = range(13)\n        for _ in range(2):\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'INTEGER'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                vals[0].ids.value.text = str(i + 1)\n\n            new_data.ids.columnadd.dispatch('on_release')\n            cols[0].ids.colname.text += str(len(cols))\n            cols[0].ids.coltype.text = 'REAL'\n            vals = cols[0].ids.vals.children\n\n            for i in range_vals:\n                cols[0].ids.valadd.dispatch('on_release')\n                num = str(i + 1)\n                vals[0].ids.value.text = num + '.' + num\n        new_data = app.root.wiz_newdata.run()\n\n        # open Task's popup and get task\n        address = ['A1:D13', 'A1:B2', 'C1:D2',\n                   'A12:B13', 'C12:D13', 'B3:C10']\n        for addr in address:\n            for xonly in range(2):\n                taskcls = Plot()\n                taskcls.plot_line()\n\n                children = app.root_window.children\n                for c in reversed(children):\n                    if 'Task' in str(c):\n                        index = children.index(c)\n                task = children[index]\n\n                # fill the task\n                body = task.children[0].children[0].children[0].children\n                body[-1].text = 'NewData'\n                body[-2].children[0].children[-1].text = 'Test Title'\n\n                # fetching addresses and axes labels\n                box_values = body[-2].children[0].children[-2]\n                box_values.children[-1].children[-2].text = addr\n                body[-2].children[0].children[-3].children[0].active = True\n                if not xonly:\n                    box_values.children[-2].children[-2].text = addr\n\n                # set axes limits\n                box_values = body[-2].children[0].children[-5]\n                box_values.children[-1].children[-1].text = '-20'\n                box_values.children[-1].children[0].text = '20'\n\n                # set line options\n                box_values.children[-2].children[-3].text = 'g'\n                box_values.children[-2].children[-4].text = 's'\n                box_values.children[-3].children[0].active = True\n                body[-3].children[0].dispatch('on_release')\n\n        # get results and test\n        res_dir = op.join(app.project_dir, 'plots')\n        result = len([f for f in os.listdir(res_dir) if f.startswith('plot')])\n        self.assertEqual(result, 12)\n\n        results = app.root.ids.results\n        skipone = False  # if top padding with widget present\n        for c in reversed(results.children):\n            if 'Widget' in str(c):\n                skipone = True\n                break\n        results = len(results.children)\n        self.assertEqual(results - 1 if skipone else results, 12)\n        app.stop()\n\n    def test_tasks_plot_lineplot(self):\n        self.path = op.dirname(op.abspath(__file__))\n        if not op.exists(op.join(self.path, 'test_folder')):\n            os.mkdir(op.join(self.path, 'test_folder'))\n        else:\n            rmtree(op.join(self.path, 'test_folder'))\n            os.mkdir(op.join(self.path, 'test_folder'))\n        self.folder = op.join(self.path, 'test_folder')\n\n        app = KrySA()\n        p = partial(self.run_test, app)\n        Clock.schedule_once(p, .000001)\n        app.run()\n        rmtree(self.folder)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
krysa/utils/__init__.py,0,"b'\'\'\'\nA bunch of useful functions separated from the source.\n\'\'\'\n\nfrom kivy.utils import platform\nfrom functools import partial\nimport subprocess\nimport webbrowser\nimport os\n\n# probably only the first two will be in KrySA\nimage_ext = [\'.png\', \'.jpg\', \'.gif\', \'.tiff\']\n\n\n# linux & mac need testing\ndef create_bind(path):\n    \'\'\'Create a partial for opening a file in system\'s default program\n    for such file extensions.\n\n    .. versionadded:: 0.5.0\n    \'\'\'\n    if isimage(path):\n        if platform == \'macosx\':\n            return partial(subprocess.call, (\'open\', path))\n        elif platform == \'win\':\n            return partial(win_system, \'""\' + path + \'""\')\n        elif platform == \'linux\':\n            return partial(subprocess.call, (\'xdg-open\', path))\n    else:\n        return partial(webbrowser.open, path)\n\n\ndef win_system(arg, *args):\n    # just a wrapper, because it threw\n    # an error about too many args\n    os.system(arg)\n\n\ndef isimage(image):\n    \'\'\'Compare a file from path with the explicitly listed extensions\n    for images: `[\'.png\', \'.jpg\', \'.gif\', \'.tiff\']`.\n\n    :Returns:\n       `boolean`\n\n    .. versionadded:: 0.5.0\n    \'\'\'\n    global image_ext\n\n    if platform in [\'android\', \'ios\', \'unknown\']:\n        return None\n\n    for ext in image_ext:\n        if ext in image:\n            return True\n'"
