file_path,api_count,code
specaugment.py,23,"b'#!/usr/bin/env python3\n\nimport time\nimport random\nimport argparse\nimport sys\n\nimport numpy as np\nimport numpy.linalg as nl\nimport matplotlib.pyplot as plt\nimport librosa\nimport librosa.display\nfrom scipy import interpolate\nfrom scipy import signal\nfrom scipy.io import wavfile\nfrom scipy.fftpack import dct,idct\nfrom scipy.spatial.distance import pdist, cdist, squareform\n\n\ndef plot_spec(spec):\n    yrange=spec.shape[0]\n    plt.ylim(-.5,yrange-.5)\n    plt.imshow(spec, cmap=\'jet\', interpolation=\'nearest\')\n    plt.axes().set_aspect(\'auto\')\n    plt.show()\n\ndef makeT(cp):\n    # cp: [K x 2] control points\n    # T: [(K+3) x (K+3)]\n    K = cp.shape[0]\n    T = np.zeros((K+3, K+3))\n    T[:K, 0] = 1\n    T[:K, 1:3] = cp\n    T[K, 3:] = 1\n    T[K+1:, 3:] = cp.T\n    R = squareform(pdist(cp, metric=\'euclidean\'))\n    R = R * R\n    R[R == 0] = 1 # a trick to make R ln(R) 0\n    R = R * np.log(R)\n    np.fill_diagonal(R, 0)\n    T[:K, 3:] = R\n    return T\n\ndef liftPts(p, cp):\n    # p: [N x 2], input points\n    # cp: [K x 2], control points\n    # pLift: [N x (3+K)], lifted input points\n    N, K = p.shape[0], cp.shape[0]\n    pLift = np.zeros((N, K+3))\n    pLift[:,0] = 1\n    pLift[:,1:3] = p\n    R = cdist(p, cp, \'euclidean\')\n    R = R * R\n    R[R == 0] = 1\n    R = R * np.log(R)\n    pLift[:,3:] = R\n    return pLift\n    \ndef main(args):\n    time_sum = 0\n\n    audio, sampling_rate = librosa.load(args.input)\n    spec = librosa.feature.melspectrogram(y=audio,sr=sampling_rate,n_mels=80, fmax=8000)\n    spec = librosa.power_to_db(spec,ref=np.max)\n    \n    num = args.num\n    print(""start to SpecAugment %d times"" % num)\n    for n in range(num): \n        start = time.time()\n        W=40\n        T=30\n        F=13\n        mt=2\n        mf=2\n\n        # Nframe : number of spectrum frame\n        Nframe = spec.shape[1]\n        # Nbin : number of spectrum freq bin\n        Nbin = spec.shape[0]\n        # check input length\n        if Nframe < W*2+1:\n            W = int(Nframe/4)\n        if Nframe < T*2+1:\n            T = int(Nframe/mt)\n        if Nbin < F*2+1:\n            F = int(Nbin/mf)\n\n        # warping parameter initialize\n        w = random.randint(-W,W)\n        center = random.randint(W,Nframe-W)\n\n        src = np.asarray([[ float(center),  1], [ float(center),  0], [ float(center),  2], [0, 0], [0, 1], [0, 2], [Nframe-1, 0], [Nframe-1, 1], [Nframe-1, 2]])\n        dst = np.asarray([[ float(center+w),  1], [ float(center+w),  0], [ float(center+w),  2], [0, 0], [0, 1], [0, 2], [Nframe-1, 0], [Nframe-1, 1], [Nframe-1, 2]])\n        #print(src,dst)\n\n        # source control points\n        xs, ys = src[:,0],src[:,1]\n        cps = np.vstack([xs, ys]).T\n        # target control points\n        xt, yt = dst[:,0],dst[:,1]\n        # construct TT\n        TT = makeT(cps)\n\n        # solve cx, cy (coefficients for x and y)\n        xtAug = np.concatenate([xt, np.zeros(3)])\n        ytAug = np.concatenate([yt, np.zeros(3)])\n        cx = nl.solve(TT, xtAug) # [K+3]\n        cy = nl.solve(TT, ytAug)\n\n        # dense grid\n        x = np.linspace(0, Nframe-1,Nframe)\n        y = np.linspace(1,1,1)\n        x, y = np.meshgrid(x, y)\n\n        xgs, ygs = x.flatten(), y.flatten()\n\n        gps = np.vstack([xgs, ygs]).T\n\n        # transform\n        pgLift = liftPts(gps, cps) # [N x (K+3)]\n        xgt = np.dot(pgLift, cx.T)     \n        spec_warped = np.zeros_like(spec)\n        for f_ind in range(Nbin):\n            spec_tmp = spec[f_ind,:]\n            func = interpolate.interp1d(xgt, spec_tmp,fill_value=""extrapolate"")\n            xnew = np.linspace(0, Nframe-1,Nframe)\n            spec_warped[f_ind,:] = func(xnew)\n\n        # sample mt of time mask ranges\n        t = np.random.randint(T-1, size=mt)+1\n        # sample mf of freq mask ranges\n        f = np.random.randint(F-1, size=mf)+1\n        # mask_t : time mask vector\n        mask_t = np.ones((Nframe,1))\n        ind = 0\n        t_tmp = t.sum() + mt\n        for _t in t:\n            k = random.randint(ind,Nframe-t_tmp)\n            mask_t[k:k+_t] = 0\n            ind = k+_t+1\n            t_tmp = t_tmp - (_t+1)\n        mask_t[ind:] = 1\n\n        # mask_f : freq mask vector\n        mask_f = np.ones((Nbin,1))\n        ind = 0\n        f_tmp = f.sum() + mf\n        for _f in f:\n            k = random.randint(ind,Nbin-f_tmp)\n            mask_f[k:k+_f] = 0\n            ind = k+_f+1\n            f_tmp = f_tmp - (_f+1)\n        mask_f[ind:] = 1\n\n        # calculate mean\n        mean = np.mean(spec_warped)\n\n        # make spectrum to zero mean\n        spec_zero = spec_warped-mean\n\n        spec_masked = ((spec_zero * mask_t.T) * mask_f) + mean\n    #     spec_masked = ((spec_zero * mask_t).T * mask_f).T\n\n        end = time.time()\n        time_sum += (end - start)  \n    #     plot_spec(spec)\n    #     plot_spec(spec_warped)\n    #     plot_spec(spec_masked)\n    print(""whole processing time : %.4f second"" % (time_sum))   \n    print(""average processing time : %.2f ms"" % (time_sum*1000/num))\n\n                        \nif __name__ == ""__main__"":\n    parser = argparse.ArgumentParser(description=\'\')\n    parser.add_argument(\'-i\', \'--input\', dest=\'input\', type=str, default=""data/test.wav"", help=\'input file\')\n    parser.add_argument(\'-n\', \'--num\', dest=\'num\', type=int, default=100, help=\'number of test iteration\')\n    args = parser.parse_args()\n    main(args)\n'"
