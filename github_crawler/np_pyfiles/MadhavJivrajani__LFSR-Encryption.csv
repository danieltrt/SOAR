file_path,api_count,code
bit_image.py,1,"b'import lfsr\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport numpy as np\n\nrnglol = lfsr.LFSR(14, ""fib"", [0,0,0,0,0,0,0,0,0,0,1,1,1,1])\na = rnglol.generate_output_stream()\na = a.tolist()\na.append(0)\nprint(len(a))\nprint(a.count(1))\nprint(a.count(0))\nplt.imsave(\'filename.png\', np.array(a).reshape(128,128), cmap=cm.gray)\n'"
decrypt.py,0,"b'from PIL import Image\nfrom lfsr import LFSR\nfrom functools import reduce\nfrom feedback import feedback_poly, one_hot_encode\n\nlfsr = LFSR(15, \'gal\', [1 for _ in range(15)])\ns = """"\nints =  lfsr.encrypt_decrypt_ints()\nvalue  = 0\nim = Image.open(r""output.png"")\npx = im.load()\nwidth, height = im.size\nprint(""Height :"", height, "" And width : "", width)\nfor i in range(width):\n    for j in range(height):\n        r, g, b, temp = px[i, j]\n        r = (r) ^ ints[value]\n        value = (value+1) % (len(ints))\n        g = (g) ^ ints[value]\n        value = (value+1)%(len(ints))\n        b = (b) ^ ints[value]\n        value = (value+1) % (len(ints))\n        temp = (temp) ^ ints[value]\n        value = (value+1) % (len(ints))\n        px[i, j] = (r, g, b, temp)\n        \nim.show()\nim.save(""decode.png"")\n'"
encrypt.py,0,"b'from PIL import Image\nfrom lfsr import LFSR\nfrom functools import reduce\nfrom feedback import feedback_poly, one_hot_encode\n\nlfsr = LFSR(15, \'gal\', [1 for _ in range(15)])\ns = """"\nints =  lfsr.encrypt_decrypt_ints()\nvalue  = 0\nim = Image.open(r""yoda.png"")\npx = im.load()\nprint(px[0,0])\nwidth, height = im.size\nprint(""Height :"", height, "" And width : "", width)\nfor i in range(width):\n    for j in range(height):\n        r, g, b, temp = px[i, j]\n        r = (r) ^ ints[value]\n        value = (value+1) % (len(ints))\n        g = (g) ^ ints[value]\n        value = (value+1)%(len(ints))\n        b = (b) ^ ints[value]\n        value = (value+1) % (len(ints))\n        temp = (temp) ^ ints[value]\n        value = (value+1) % (len(ints))\n        px[i, j] = (r, g, b, temp)\n        \nim.show()\nim.save(""output.png"")\n'"
feedback.py,0,"b'feedback_poly = {\n    2: [1],\n    3: [2],\n    4: [3],\n    5: [3],\n    6: [5],\n    7: [6],\n    8: [6, 5, 4],\n    9: [5],\n    10: [7],\n    11: [9],\n    12: [11, 10, 4],\n    13: [12, 11, 8],\n    14: [13, 12, 2],\n    15: [14],\n    16: [14, 13, 11],\n    17: [14],\n    18: [11],\n    19: [18, 17, 14],\n    20: [17],\n    21: [19],\n    22: [21],\n    23: [18],\n    24: [23, 22, 17]\n}\n\ndef one_hot_encode(n):\n    coeffs = []\n    coeffs.append(1)\n    for i in range(1, n):\n        if i in feedback_poly[n]:\n            coeffs.append(1)\n        else:\n            coeffs.append(0)\n    return coeffs\n'"
lfsr.py,19,"b'import numpy as np\nfrom numpy.linalg import matrix_power\nfrom feedback import feedback_poly, one_hot_encode\n\nclass LFSR:\n    def __init__(self, n, count_type, seed):\n        """"""\n        n          : order of the minimal polynomial        \n        count_type : type of LFSR,\n                     ""fib"": Fibonacci\n                     ""gal"": Galois\n        seed       : Initial configuration of the LFSR\n        """"""\n        self.n = n\n        self.type = -1\n        if count_type == \'fib\':\n            self.type = 0\n        elif count_type == \'gal\':\n            self.type = 1\n        else:\n            raise ValueError(""Types of counters: \'fib\' and \'gal\'"")\n        \n        if self.type == 0:\n            self.companion = self.__generate_companion_fibonacci()\n        else:\n            self.companion = self.__generate_companion_galois()\n\n        self.seed = np.array(seed)\n    \n    def __generate_companion_galois(self):\n        diag = np.diag(np.ones(self.n - 1, dtype=np.int32))\n        zeros = np.zeros(self.n - 1, dtype=np.int32)\n        temp = np.vstack((diag, zeros))\n        return np.mod(np.column_stack((np.array(\n            one_hot_encode(self.n)[::-1]), temp)), 2)\n\n    def __generate_companion_fibonacci(self):\n        diag = np.diag(np.ones(self.n - 1, dtype=np.int32))\n        zeros = np.zeros(self.n - 1, dtype=np.int32)\n        temp = np.column_stack((zeros, diag))\n        return np.mod(np.vstack(\n            (temp, np.array(one_hot_encode(self.n)))), 2)\n        \n    def __generate_next(self, state, k):\n        if k < 0:\n            raise ValueError(""Power of matrix needs to be non-negative"")\n        else:\n            return np.mod(matrix_power(state, k%(self.get_max_period())), 2)\n        \n    def get_max_period(self):\n        return 2**self.n - 1\n    \n    def encrypt_decrypt_ints(self):\n        ints = []\n        for k in range(self.get_max_period()):\n            temp = self.__generate_next(self.companion, k)\n            new_state = np.array(np.mod(np.dot(temp, self.seed), 2), dtype=np.int32)\n            ints.append(int("""".join([str(int(i)) for i in list(new_state)]), 2)%255)\n        \n        return np.array(ints)\n\n    def get_ints(self):\n        ints = []\n        for k in range(self.get_max_period()):\n            temp = self.__generate_next(self.companion, k)\n            new_state = np.array(np.mod(np.dot(temp, self.seed), 2), dtype=np.int32)\n            ints.append(int("""".join([str(int(i)) for i in list(new_state)]), 2))\n        \n        return np.array(ints)\n    \n    def generate_output_stream(self):\n        stream = []\n        if self.type == 0:\n            for k in range(self.get_max_period()):\n                temp = self.__generate_next(self.companion, k)\n                new_state = np.mod(np.dot(temp, self.seed), 2)\n                stream.append(new_state[-1])\n        else:\n            for k in range(self.get_max_period()):\n                temp = self.__generate_next(self.companion, k)\n                new_state = np.mod(np.dot(temp, self.seed), 2)\n                stream.append(new_state[0])\n                \n        return np.array(stream)\n            \n    def print_states(self):\n        for k in range(self.get_max_period()):\n            temp = self.__generate_next(self.companion, k)\n            new_state = np.mod(np.dot(temp, self.seed), 2)\n            print("" "".join([str(int(i)) for i in list(new_state)]))\n'"
run_test.py,0,"b'import lfsr\n\nrng = lfsr.LFSR(14,""fib"",[0,0,0,0,0,0,0,1,0,1,0,1,1,1])\nk = rng.generate_output_stream()\nk = k.tolist()\nlmao = {}\nprev_k = k[0]\nct = 0\ntotal = 0\nfor i in k[1::]:\n    if i != prev_k:\n        total += 1\n        if(ct+1 not in lmao.keys()):\n                lmao[ct+1] = 1\n        else:\n                lmao[ct+1] += 1\n        ct = 0\n        prev_k = i\n    else:\n            ct+=1\n\nfor i in sorted(list(lmao.keys())):\n    print(i, lmao[i])\nprint(total)\n'"
series_test.py,0,"b'import lfsr\nimport numpy as np\n\nrng = lfsr.LFSR(14,""fib"",[0,0,0,0,0,0,0,1,0,1,0,1,1,1])\na = rng.generate_output_stream()\na = a.tolist()\na = list(map(str,a))\nb = \'\'.join(a)\nlst = {""11"": 0, ""00"":0, ""10"":0, ""01"":0,""000"":0, ""001"":0,""010"":0, ""011"":0, ""100"":0, ""101"":0, ""110"":0, ""111"":0}\nct = []\nfor i in lst:\n    lst[i] = b.count(i)\n\nprint(lst)\n'"
try.py,1,"b'import lfsr\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport numpy as np\n\nrnglol = lfsr.LFSR(14, ""fib"", [0,0,0,0,0,0,0,0,0,0,1,1,1,1])\na = rnglol.generate_output_stream()\na = a.tolist()\na.append(0)\nprint(len(a))\nprint(a.count(1))\nprint(a.count(0))\nplt.imsave(\'filename.png\', np.array(a).reshape(128,128), cmap=cm.gray)\n'"
