file_path,api_count,code
demo.py,10,"b'#!/usr/bin/env python\n# -*- encoding: utf-8\n\nfrom __future__ import absolute_import, division, print_function\n\nfrom kivy.app import App\n\nimport datetime\nimport numpy as np\nimport pandas as pd\nfrom dfguik import DfguiWidget\n\n\ndef create_dummy_data(size):\n\n    user_ids = np.random.randint(1, 1000000, 10)\n    product_ids = np.random.randint(1, 1000000, 100)\n\n    def choice(*values):\n        return np.random.choice(values, size)\n\n    random_dates = [\n        datetime.date(2016, 1, 1) + datetime.timedelta(days=int(delta))\n        for delta in np.random.randint(1, 50, size)\n    ]\n    return pd.DataFrame.from_items([\n        (""Date"", random_dates),\n        (""UserID"", choice(*user_ids)),\n        (""ProductID"", choice(*product_ids)),\n        (""IntColumn"", choice(1, 2, 3)),\n        (""FloatColumn"", choice(np.nan, 1.0, 2.0, 3.0)),\n        (""StringColumn"", choice(""A"", ""B"", ""C"")),\n        (""Gaussian 1"", np.random.normal(0, 1, size)),\n        (""Gaussian 2"", np.random.normal(0, 1, size)),\n        (""Uniform"", np.random.uniform(0, 1, size)),\n        (""Binomial"", np.random.binomial(20, 0.1, size)),\n        (""Poisson"", np.random.poisson(1.0, size)),\n    ])\n\nclass DataFrameApp(App):\n    def build(self):\n        df = create_dummy_data(1000)\n        return DfguiWidget(df)\n    \nif __name__ == \'__main__\':\n    DataFrameApp().run()\n    \n'"
dfguik.py,2,"b'import kivy\nkivy.require(\'1.10.0\')\nfrom kivy.lang import Builder\nfrom kivy.properties import ListProperty\nfrom kivy.uix.actionbar import ActionDropDown\nfrom kivy.uix.boxlayout import BoxLayout\nfrom kivy.uix.button import Button\nfrom kivy.uix.dropdown import DropDown\nfrom kivy.uix.label import Label\nfrom kivy.uix.popup import Popup\nfrom kivy.uix.tabbedpanel import TabbedPanel\nfrom kivy.uix.textinput import TextInput\nfrom kivy.uix.togglebutton import ToggleButton\nfrom kivy.uix.scrollview import ScrollView\nfrom kivy.uix.spinner import Spinner\nfrom kivy.uix.recycleview import RecycleView\nfrom kivy.properties import BooleanProperty,\\\n                            ObjectProperty,\\\n                            NumericProperty,\\\n                            StringProperty\n\nimport matplotlib\nmatplotlib.use(\'module://kivy.garden.matplotlib.backend_kivy\')\nfrom matplotlib.figure import Figure\nfrom kivy.garden.matplotlib.backend_kivyagg import FigureCanvas,\\\n                                                   NavigationToolbar2Kivy\nimport matplotlib.pyplot as plt\n\nfrom collections import OrderedDict\nimport numpy as np\nimport pandas as pd\n\nimport datetime\nfrom datetime import date\n\n\nBuilder.load_string(""""""\n<HeaderCell>\n    size_hint: (None, None)\n    text_size: self.size\n    halign: ""center""\n    valign: ""middle""\n    height: \'30dp\'\n    background_disabled_normal: \'\' \n    disabled_color: (1, 1, 1, 1)\n    canvas.before:\n        Color:\n            rgba: 0.165, 0.165, 0.165, 1\n        Rectangle:\n            pos: self.pos\n            size: self.size\n    on_release: root.parent.parent.parent.parent._generate_table(self.text)\n\n<TableHeader>:\n    header: header\n    bar_width: 0\n    do_scroll: False\n    size_hint: (1, None)\n    effect_cls: ""ScrollEffect""\n    height: \'30dp\'\n    GridLayout:\n        id: header\n        rows: 1\n        size_hint: (None, None)\n        width: self.minimum_width\n        height: self.minimum_height\n\n<ScrollCell>:\n    canvas.before:\n        Color:\n            rgba: [0.23, 0.23, 0.23, 1] if root.is_even else [0.2, 0.2, 0.2, 1]\n        Rectangle:\n            pos: self.pos\n            size: self.size\n    text: root.text\n    font_size: ""12dp""\n    halign: ""center""\n    valign: ""middle""\n    text_size: self.size\n    size_hint: 1, 1\n    height: 60\n    width: 400\n\n<TableData>:\n    rgrid: rgrid\n    scroll_type: [\'bars\', \'content\']\n    bar_color: [0.2, 0.7, 0.9, 1]\n    bar_inactive_color: [0.2, 0.7, 0.9, .5]\n    do_scroll_x: True\n    do_scroll_y: True\n    effect_cls: ""ScrollEffect""\n    viewclass: ""ScrollCell""\n    RecycleGridLayout:\n        id: rgrid\n        rows: root.nrows\n        cols: root.ncols\n        size_hint: (None, None)\n        width: self.minimum_width\n        height: self.minimum_height\n\n\n<DfguiWidget>:\n    panel1: data_frame_panel\n    panel2: col_select_panel\n    panel3: fil_select_panel\n    panel4: hist_graph_panel\n    panel5: scat_graph_panel\n\n    do_default_tab: False\n\n    TabbedPanelItem:\n        text: \'Data Frame\'\n        on_release: root.open_panel1()\n        DataframePanel:\n            id: data_frame_panel\n    TabbedPanelItem:\n        text: \'Columns\'\n        ColumnSelectionPanel:\n            id: col_select_panel\n    TabbedPanelItem:\n        text: \'Filters\'\n        FilterPanel:\n            id: fil_select_panel\n    TabbedPanelItem:\n        text: \'Histogram\'\n        HistogramPlot:\n            id: hist_graph_panel\n    TabbedPanelItem:\n        text: \'Scatter Plot\'\n        ScatterPlot:\n            id: scat_graph_panel\n\n<DataframePanel>:\n    orientation: \'vertical\'\n\n<ColumnSelectionPanel>:\n    col_list: col_list\n    orientation: \'vertical\'\n    ScrollView:\n        do_scroll_x: False\n        do_scroll_y: True\n        size_hint: 1, 1\n        scroll_timeout: 150\n        GridLayout:\n            id: col_list\n            padding: ""10sp""\n            spacing: ""5sp""\n            cols:1\n            row_default_height: \'55dp\'\n            row_force_default: True\n            size_hint_y: None\n\n<FilterPanel>:\n    filter_list: filter_list\n    orientation: \'vertical\'\n    ScrollView:\n        do_scroll_x: False\n        do_scroll_y: True\n        size_hint: 1, 1\n        scroll_timeout: 150\n        GridLayout:\n            id: filter_list\n            padding: ""10sp""\n            spacing: ""5sp""\n            cols:1\n            row_default_height: \'55dp\'\n            row_force_default: True\n            size_hint_y: None\n\n<HistogramPlot>:\n    select_btn: select_btn\n    histogram: histogram\n    orientation: \'vertical\'\n    Histogram:\n        id: histogram\n    BoxLayout:\n        size_hint_y: None\n        height: \'48dp\'\n        Button:\n            id: select_btn\n            text: \'Select Column\'\n            on_release: root.dropdown.open(self)\n            size_hint_y: None\n            height: \'48dp\'\n\n<Histogram>:\n    orientation: \'vertical\'\n\n<ScatterPlot>:\n    select_btn1: select_btn1\n    select_btn2: select_btn2\n    scatter: scatter\n    orientation: \'vertical\'\n    ScatterGraph:\n        id: scatter\n    BoxLayout:\n        size_hint_y: None\n        height: \'48dp\'\n        Button:\n            id: select_btn1\n            text: \'Select Column 1\'\n            on_release: root.dropdown1.open(self)\n            size_hint_y: None\n            height: \'48dp\'\n        Button:\n            id: select_btn2\n            text: \'Select Column 2\'\n            on_release: root.dropdown2.open(self)\n            size_hint_y: None\n            height: \'48dp\'\n\n\n<ScatterGraph>:\n    orientation: \'vertical\'\n\n\n<ColDropDown>:\n    #on_parent: self.dismiss()\n    #on_select: btn.text = \'{}\'.format(args[1])\n"""""")\n\n\n\'\'\' Table Code from https://stackoverflow.com/questions/44463773/kivy-recycleview-recyclegridlayout-scrollable-label-problems#comment75948118_44463773\n\'\'\'\n\nclass HeaderCell(Button):\n    pass\n\n\nclass TableHeader(ScrollView):\n    """"""Fixed table header that scrolls x with the data table""""""\n    header = ObjectProperty(None)\n\n    def __init__(self, list_dicts=None, *args, **kwargs):\n        super(TableHeader, self).__init__(*args, **kwargs)\n\n        titles = list_dicts[0].keys()\n\n        for title in titles:\n            self.header.add_widget(HeaderCell(text=title))\n\n\nclass ScrollCell(Label):\n    text = StringProperty(None)\n    is_even = BooleanProperty(None)\n\n\nclass TableData(RecycleView):\n    nrows = NumericProperty(None)\n    ncols = NumericProperty(None)\n    rgrid = ObjectProperty(None)\n\n    def __init__(self, list_dicts=[], *args, **kwargs):\n        self.nrows = len(list_dicts)\n        self.ncols = len(list_dicts[0])\n\n        super(TableData, self).__init__(*args, **kwargs)\n\n        self.data = []\n        for i, ord_dict in enumerate(list_dicts):\n            is_even = i % 2 == 0\n            row_vals = ord_dict.values()\n            for text in row_vals:\n                self.data.append({\'text\': text, \'is_even\': is_even})\n\n    def sort_data(self):\n        #TODO: Use this to sort table, rather than clearing widget each time.\n        pass\n        \n        \nclass Table(BoxLayout):\n\n    def __init__(self, list_dicts=[], *args, **kwargs):\n\n        super(Table, self).__init__(*args, **kwargs)\n        self.orientation = ""vertical""\n\n        self.header = TableHeader(list_dicts=list_dicts)\n        self.table_data = TableData(list_dicts=list_dicts)\n\n        self.table_data.fbind(\'scroll_x\', self.scroll_with_header)\n\n        self.add_widget(self.header)\n        self.add_widget(self.table_data)\n\n    def scroll_with_header(self, obj, value):\n        self.header.scroll_x = value\n\n\nclass DataframePanel(BoxLayout):\n    """"""\n    Panel providing the main data frame table view.\n    """"""\n\n    def populate_data(self, df):\n        self.df_orig = df\n        self.original_columns = self.df_orig.columns[:]\n        self.current_columns = self.df_orig.columns[:]\n        self._disabled = []\n        self.sort_key = None\n        self._reset_mask()\n        self._generate_table()\n\n    def _generate_table(self, sort_key=None, disabled=None):\n        self.clear_widgets()\n        df = self.get_filtered_df()\n        data = []\n        if disabled is not None:\n            self._disabled = disabled\n        keys = [x for x in df.columns[:] if x not in self._disabled]\n        if sort_key is not None:\n            self.sort_key = sort_key\n        elif self.sort_key is None or self.sort_key in self._disabled:\n            self.sort_key = keys[0]\n        for i1 in range(len(df.iloc[:, 0])):\n            row = OrderedDict.fromkeys(keys)\n            for i2 in range(len(keys)):\n                row[keys[i2]] = str(df.iloc[i1, i2])\n            data.append(row)\n        data = sorted(data, key=lambda k: k[self.sort_key]) \n        self.add_widget(Table(list_dicts=data))\n        \n    def apply_filter(self, conditions):\n        """"""\n        External interface to set a filter.\n        """"""\n        old_mask = self.mask.copy()\n\n        if len(conditions) == 0:\n            self._reset_mask()\n\n        else:\n            self._reset_mask()  # set all to True for destructive conjunction\n\n            no_error = True\n            for column, condition in conditions:\n                if condition.strip() == \'\':\n                    continue\n                condition = condition.replace(""_"", ""self.df_orig[\'{}\']"".format(column))\n                print(""Evaluating condition:"", condition)\n                try:\n                    tmp_mask = eval(condition)\n                    if isinstance(tmp_mask, pd.Series) and tmp_mask.dtype == np.bool:\n                        self.mask &= tmp_mask\n                except Exception as e:\n                    print(""Failed with:"", e)\n                    no_error = False\n\n        has_changed = any(old_mask != self.mask)\n\n    def get_filtered_df(self):\n        return self.df_orig.loc[self.mask, :]\n\n    def _reset_mask(self):\n        pass\n        self.mask = pd.Series([True] *\n                              self.df_orig.shape[0],\n                              index=self.df_orig.index)\n\n    \nclass ColumnSelectionPanel(BoxLayout):\n    """"""\n    Panel for selecting and re-arranging columns.\n    """"""\n\n    def populate_columns(self, columns):\n        """"""\n        When DataFrame is initialized, fill the columns selection panel.\n        """"""\n        self.col_list.bind(minimum_height=self.col_list.setter(\'height\'))\n        for col in columns:\n            self.col_list.add_widget(ToggleButton(text=col, state=\'down\'))\n    \n    def get_disabled_columns(self):\n        return [x.text for x in self.col_list.children if x.state != \'down\']\n\n    \nclass FilterPanel(BoxLayout):\n    \n    def populate(self, columns):            \n        self.filter_list.bind(minimum_height=self.filter_list.setter(\'height\'))\n        for col in columns:\n            self.filter_list.add_widget(FilterOption(columns))\n\n    def get_filters(self):\n        result=[]\n        for opt_widget in self.filter_list.children:\n            if opt_widget.is_option_set():\n                result.append(opt_widget.get_filter())\n        return [x.get_filter() for x in self.filter_list.children\n                if x.is_option_set]\n            \n            \n            \nclass FilterOption(BoxLayout):\n        \n    def __init__(self, columns, **kwargs):\n        super(FilterOption, self).__init__(**kwargs)\n        self.height=""30sp""\n        self.size_hint=(0.9, None)\n        self.spacing=10\n        options = [""Select Column""]\n        options.extend(columns)\n        self.spinner = Spinner(text=\'Select Column\',\n                               values= options,\n                               size_hint=(0.25, None),\n                               height=""30sp"",\n                               pos_hint={\'center_x\': .5, \'center_y\': .5})\n        self.txt = TextInput(multiline=False, size_hint=(0.75, None),\\\n                             font_size=""15sp"")\n        self.txt.bind(minimum_height=self.txt.setter(\'height\'))\n        self.add_widget(self.spinner)\n        self.add_widget(self.txt)\n\n    def is_option_set(self):\n        return self.spinner.text != \'Select Column\'\n\n    def get_filter(self):\n        return (self.spinner.text, self.txt.text)\n\n            \nclass ColDropDown(DropDown):\n    pass\n\n    \nclass HistogramPlot(BoxLayout):\n    """"""\n    Panel providing a histogram plot.\n    """"""\n    \n    def __init__(self, **kwargs):\n        super(HistogramPlot, self).__init__(**kwargs)\n        self.dropdown = ColDropDown()\n        self.dropdown.bind(on_select=lambda instance, x:\n                           setattr(self.select_btn, \'text\', x))\n\n    def populate_options(self, options):\n        for index, option in enumerate(options):\n            button = Button(text=option, size_hint=(1,None), height=\'48dp\')\n            button.bind(on_release=lambda x, y=index, z=option:\n                        self.on_combo_box_select(y,z))\n            self.dropdown.add_widget(button)\n            \n    \n    def on_combo_box_select(self, index, text):\n        self.dropdown.select(text)\n        self.histogram.redraw(index)\n\n    \nclass Histogram(BoxLayout):\n    """"""\n    Histogram portion of the histogram panel.\n    """"""\n    \n    def __init__(self, **kwargs):\n        super(Histogram, self).__init__(**kwargs)\n        self.figure, self.axes = plt.subplots()\n        self.add_widget(NavigationToolbar2Kivy(self.figure.canvas).actionbar)\n        self.add_widget(self.figure.canvas)\n\n    def redraw(self, selection):\n        column_index1 = selection\n        df = self.parent.parent.parent.df # TODO: Do this more elegantly.\n        if column_index1 < len(df.iloc[:]) and column_index1 >= 0 and len(df) > 0:\n            # NOTE: The following code generates a Type error  when attempting\n            # to graph string data. The original code also generates this error,\n            # but continues silently without alerting the user.\n            self.axes.clear()\n            try:\n                self.axes.hist(np.array(df.iloc[:, column_index1].dropna().values), bins=100)\n            except TypeError:\n                self.warning(""Invalid data type detected. Unable to generate graph."")\n            except:\n                self.warning(""An unexpected error has occured."")\n            finally:\n                self.figure.canvas.draw()\n\n    def warning(self, msg):\n        layout = BoxLayout(orientation=\'vertical\')\n        layout.add_widget(Label(text=msg,\n                                    size_hint_y=1,\n                                    text_size=(250,  None),\n                                    halign=\'left\',\n                                    valign=\'middle\'))\n        button_layout = BoxLayout()\n        close=Button(text=""Close"", size_hint=(0.8, 0.2))\n        close.bind(on_release = lambda x : popup.dismiss())\n        button_layout.add_widget(close)\n        layout.add_widget(button_layout)\n        popup = Popup(title=\'Histogram Error\',\n                      content=layout,\n                      size_hint=(0.9, 0.9))\n        popup.open()\n            \nclass ScatterPlot(BoxLayout):\n    """"""\n    Panel providing a histogram plot.\n    """"""\n    \n    def __init__(self, **kwargs):\n        super(ScatterPlot, self).__init__(**kwargs)\n        self.dropdown1 = ColDropDown()\n        self.dropdown2 = ColDropDown()\n        self.dropdown1.bind(on_select=lambda instance, x:\n                           setattr(self.select_btn1, \'text\', x))\n        self.dropdown2.bind(on_select=lambda instance, x:\n                           setattr(self.select_btn2, \'text\', x))\n        self.index1=-1\n        self.index2=-1\n\n    def populate_options(self, options):\n        for index, option in enumerate(options):\n            button = Button(text=option, size_hint=(1,None), height=\'48dp\')\n            button.bind(on_release=lambda x, y=index, z=option:\n                        self.on_combo_box_select1(y,z))\n            self.dropdown1.add_widget(button)\n        for index, option in enumerate(options):\n            button = Button(text=option, size_hint=(1,None), height=\'48dp\')\n            button.bind(on_release=lambda x, y=index, z=option:\n                        self.on_combo_box_select2(y,z))\n            self.dropdown2.add_widget(button)\n            \n    def on_combo_box_select1(self, index, text):\n        self.dropdown1.select(text)\n        self.index1 = index\n        if self.index1 >=0 and self.index2 >= 0:\n            self.scatter.redraw(self.index1, self.index2)\n\n    def on_combo_box_select2(self, index, text):\n        self.dropdown2.select(text)\n        self.index2 = index\n        if self.index1 >=0 and self.index2 >= 0:\n            self.scatter.redraw(self.index1, self.index2)\n\n    \nclass ScatterGraph(BoxLayout):\n    """"""\n    Histogram portion of the histogram panel.\n    """"""\n    \n    def __init__(self, **kwargs):\n        super(ScatterGraph, self).__init__(**kwargs)\n        self.figure, self.axes = plt.subplots()\n        self.add_widget(NavigationToolbar2Kivy(self.figure.canvas).actionbar)\n        self.add_widget(self.figure.canvas)\n\n    def redraw(self, selection1, selection2):\n        column_index1 = selection1\n        column_index2 = selection2\n        df = self.parent.parent.parent.df # TODO: Do this more elegantly.\n        if column_index1 < len(df.iloc[:]) and\\\n           column_index1 >= 0 and\\\n           column_index2 < len(df.iloc[:]) and\\\n           column_index2 >= 0 and len(df) > 0:\n            # NOTE: The following code generates a Type error  when attempting\n            # to graph string data. The original code also generates this\n            # error, but continues silently without alerting the user.\n            self.axes.clear()\n            try:\n                self.axes.plot(df.iloc[:, column_index1].values,\n                               df.iloc[:, column_index2].values,\n                               \'o\', clip_on=False)\n            except TypeError:\n                self.warning(""Invalid data type detected. Unable to generate graph."")\n            except:\n                self.warning(""An unexpected error has occured."")\n            finally:\n                self.figure.canvas.draw()\n\n    def warning(self, msg):\n        layout = BoxLayout(orientation=\'vertical\')\n        layout.add_widget(Label(text=msg,\n                                    size_hint_y=1,\n                                    text_size=(250,  None),\n                                    halign=\'left\',\n                                    valign=\'middle\'))\n        button_layout = BoxLayout()\n        close=Button(text=""Close"", size_hint=(0.8, 0.2))\n        close.bind(on_release = lambda x : popup.dismiss())\n        button_layout.add_widget(close)\n        layout.add_widget(button_layout)\n        popup = Popup(title=\'Histogram Error\',\n                      content=layout,\n                      size_hint=(0.9, 0.9))\n        popup.open()\n\nclass DfguiWidget(TabbedPanel):\n\n    def __init__(self, df, **kwargs):\n        super(DfguiWidget, self).__init__(**kwargs)\n        self.df = df\n        self.panel1.populate_data(df)\n        self.panel2.populate_columns(df.columns[:])\n        self.panel3.populate(df.columns[:])\n        self.panel4.populate_options(df.columns[:])\n        self.panel5.populate_options(df.columns[:])\n\n    # This should be changed so that the table isn\'t rebuilt\n    # each time settings change.\n    def open_panel1(self):\n        #arr = self.panel3.get_filters()\n        #print(str(arr))\n        self.panel1.apply_filter(self.panel3.get_filters())\n        self.panel1._generate_table(disabled=\n                                    self.panel2.get_disabled_columns())\n\n        \n'"
