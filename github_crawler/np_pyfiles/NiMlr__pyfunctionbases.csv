file_path,api_count,code
setup.py,0,"b'import os.path\nfrom setuptools import setup\n\nlong_description = open(\'./README.md\').read()\n\nsetup(name=\'pyfunctionbases\',\n      version=""1.7"",\n      description=\'A Python module to compute multidimensional arrays of evaluated functions.\',\n      long_description=long_description,\n      url=\'https://github.com/NiMlr/PyFunctionBases\',\n      author=\'Nils Mueller\',\n      author_email=\'nils.mueller@ini.rub.de\',\n      license=\'MIT\',\n      packages=[\'pyfunctionbases\'],\n      setup_requires=[\'setuptools_scm >= 1.7.0\'])\n'"
pyfunctionbases/__init__.py,0,b'from .expansions import *\n'
pyfunctionbases/expansions.py,6,"b'""""""\nImplementation of the core functionality of the package.\n\nThis module the core part of the project, that is, a general class\n``RecursiveExpansion`` that builds a multidimensional array of basis functions\nfor specified data. This is done on a relatively high level using a class\n``NDArrayManager``, that helps accessing specific parts of multi-dimensional\nNumpy arrays.\n""""""\nimport numpy as np\nfrom .function_definitions import recfs\n\n\nclass RecursiveExpansion(object):\n    """"""Multidimensional arrays of recursively computable evaluated\n    functions based on Numpy.\n\n    Specifically, the module evaluates basis functions on intervals\n    by employing a recursive formula of type\n\n    .. math:: f_{n+1}(x) = g(f_n(x), \\dots, f_0(x),x),\n\n    which must be implemented operating on an ND-array and can but is not\n    required to be implemented using ``NDArrayManager``. Preimplemented\n    are standard polynomials, Legendre polynomials, Legendre rational functions\n    and chebychev polynomials of first kind.\n\n    Parameters\n    ----------\n    degree : int\n        A positive integer containing the maximal recursion depth of the\n        formula, that is,  :math:`n \\in \\{0, \\dots ,degree\\}`.\n    recf : str or tuple\n        A string of either \'standard_poly\', \'legendre_poly\', \'legendre_rational\',\n        \'chebychev_poly\'. See ``recfs`` in ``function_definitions.py``.\n        In the custom case this must be a tuple of type\n\n        (index where recursion\n        starts, reach backwards regarding the arguments to the above specified\n        function g - this is n+1 in the extreme case, index of a special element\n        to be used in the recursion - so you do not have to increase the reach\n        to i.e. get the second basis function, initialization function that\n        precedes the recursion, recursion function, lower boundary of the\n        interval on which your functions are defined, upper boundary of the\n        interval on which your functions are defined)\n\n        For more concrete information, see the  ``function_definitions.py``\n        module or the examples in the README.\n    """"""\n\n    def __init__(self, degree, recf=\'standard_poly\', dtype=np.dtype(\'float64\')):\n        """"""Initialize a RecursiveExpansionNode.""""""\n\n        self.degree = degree\n        self.dtype = dtype\n        # if in dictionary\n        if recf in recfs:\n            # where the recursion starts\n            self.rec_start = recfs[recf][0]\n            # number of elements preceding to consider in the recursive step\n            self.reach = recfs[recf][1]\n            self.special = recfs[recf][2]\n            # intialises the elements not based on recursion formula\n            self.r_init = recfs[recf][3]\n            # the recursion function\n            self.recf = recfs[recf][4]\n            # interval on which data must be\n            self.upper = recfs[recf][6]\n            self.lower = recfs[recf][5]\n        # if supplied by user\n        else:\n            self.rec_start = recf[0]\n            self.reach = recf[1]\n            self.special = recf[2]\n            self.r_init = recf[3]\n            self.recf = recf[4]\n            self.upper = recf[6]\n            self.lower = recf[5]\n\n    def expanded_dim(self, num_dims):\n        """"""Return the number of elements in a multidimensional\n        array containing all basis functions to be returned.\n\n        Parameters\n        ----------\n        num_dims : int or numpy.ndarray\n            Dimension of the domain of the multidimensional basis functions\n            to compute.\n\n        Returns\n        -------\n        int or numpy.ndarray\n            The number of elements in a multidimensional\n            array containing all basis functions to be returned.\n        """"""\n        return (self.degree+1)**num_dims\n\n    def execute(self, x, prec=1e-6):\n        """"""Evaluate specified linearily independent (/ orthogonal)\n        basis functions with multidimensional domain on data.\n\n        After first generating bases on the factors of\n        :math:`\\mathbb{R}^{num\\_dims}`\n        (i.e. each one dimensional subspace) by employing the recursion\n        function supplied, the basis is translated to the product-space by\n        evaluating a tensor product pairwise using numpy\'s einsum function.\n\n        Parameters\n        ----------\n        x : numpy.ndarray\n            A two-dimensional numpy array, such that observations of\n            variables are stored in the rows of the array, individual variables\n            are stored in the columns. This means that one row contains one\n            particular observation/measurement of all variables, and one\n            column contains all observations/measurements of one particular\n            variable.\n\n            Mathematically this means\n            :math:`x \\in \\mathbb{R}^{num_samples \\times num_dims}`.\n        prec : float or None\n            (Numerical) tolerance when checking if the data is within the\n            bounds of the domain of the specified functions. No checks will\n            be run when set to None.\n\n        Returns\n        -------\n        numpy.ndarray\n            Array containing the evaluation of all generated functions on the\n            data points ``x`` supplied. Output is of shape\n            ``(num_samples, degree+1, ..., degree+1)``.\n        """"""\n        if prec is not None:\n            self.check_domain(x, prec=prec)\n        deg = self.degree\n        num_dims = x.shape[1]\n        num_samples = x.shape[0]\n        # preset memory\n        basetensor = np.empty((num_samples,)+(deg+1,) *\n                              num_dims, dtype=self.dtype)\n        # initialize index helper\n        ind = NDArrayManager(num_dims, self.reach, special=self.special)\n\n        # set elements not in the recursion\n        self.r_init(basetensor, ind, x)\n\n        for cur_dim in range(num_dims):\n            # preset index for current variable\n            ind.zeroAllBut(cur_dim, self.rec_start)\n            # single variable recursion\n            while ind.getN() <= deg:\n                # recursion step\n                basetensor[ind.all+ind.getCurrent()] \\\n                    = self.recf(basetensor, ind, x)\n                # next step\n                ind.incrementN()\n\n        # inplace tensorproduct\n        np.einsum(ind.einsum_notation, *ind.getElementaries(basetensor),\n                  out=basetensor, optimize=\'optimal\', dtype=self.dtype)\n        return basetensor\n\n    def check_domain(self, x, prec=1e-6):\n        """"""Checks for compliance of the data x with the domain on which\n            the function sequence selected is defined.\n\n        Parameters\n        ----------\n        x : numpy.ndarray\n            The data on which the functions will be evaluated.\n            Observations/samples must be along the first axis, variables\n            along the second. Check the docstring of\n            ``RecursiveExpansion.execute`` for a more detailed description.\n        prec : float\n            (Numerical) tolerance when checking validity.\n\n\n        Raises\n        ------\n        Exception\n            If one or more values lie outside of the function\n            specific domain.\n        """"""\n        xmax = np.amax(x)-prec\n        xmin = np.amin(x)+prec\n\n        if (self.upper < xmax) or (self.lower > xmin):\n            raise Exception(\n                ""One or more values lie outside of the function specific domain."")\n\n\nclass NDArrayManager(object):\n    """"""Helps manage the indices of an up to 52 dimensional multi-dim array.\n\n    This class helps manage the indices of an up to 52 dimensional\n    multi-dim array making use of several get and set methods for\n    the highly frequented parts of the array. The limit of 52 is due to\n    the Einstein-notation employing characters and at this time\n    close to impossible to exceed - even in the simplest case.\n    Having this a set of multiindices ``NDArrayManager.indices`` and \n    the following set of methods available greatly increases the ease\n    of handling multi-dimensional arrays and reduces the code\n    needed to specify the recursion formulas.\n\n    Attributes\n    ----------\n    indices : numpy.ndarray\n        Array of shape ``(reach+1, num_dims)``. Where each row corresponds\n        to a multiindex that is adapted using the methods of this class.\n        The first row is reserved for the index of a special function such as\n        the first order monomial in standard monomials. The remaining ones\n        are reserved for the backwards reaching indexes of the evaluated\n        functions that are arguments to the recursion.\n    """"""\n\n    letters = \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\n    def __init__(self, num_dims, reach, special=1):\n        """"""Initialize an ``NDArrayManager``.\n\n        Parameters\n        ----------\n        num_dims : int or numpy.ndarray\n            Dimension of the domain of the multi-dimensional basis functions\n            to compute.\n        reach : int\n            Number of function values preceding+current one to consider in the\n            recursive step, for Legendre polynomials for example 2+1 works.\n        special : int\n            Saves an index for the index of a function value in the\n            multi-dim array to be an argument to the recursive function. This\n            way there is no need to increase the reach if only one ""special""\n            function in the sequence is needed.\n        """"""\n        # create index array of the last elements\n        if num_dims + 1 > len(self.letters):\n            raise Exception(""Too many dimensions in order to use the einstein\\\n                            notation(requires letters)."")\n\n        self.indices = np.zeros((reach+1, num_dims), dtype=int)\n        self.num_dims = num_dims\n        # how many last elements are to consider\n        self.reach = reach\n        self.current_dim = 0\n        # a special element used in every recursive step (e.g. x)\n        self.special = special\n        # replaces "":"""" when tuple indexing numpy array\n        self.all = (slice(None),)\n\n        # generate the einstein summation convention string\n        # for numpys einsum function\n        self.einsum_notation = \'\'\n\n        for i in range(num_dims):\n            self.einsum_notation += self.letters[0]+self.letters[i+1]+\',\'\n\n        self.einsum_notation = self.einsum_notation[:-1] + \\\n            \'->\'+self.letters[:num_dims+1]\n\n    def zeroAllBut(self, current_dim, value=0):\n        """"""Zeros every index besides the column of the current variable\n        in the index helper.\n\n        That column is set to contain decreasing indices starting with\n        the current iteration step of the recursion representing the\n        reach backwards.\n\n        Parameters\n        ----------\n        current_dim : int\n            Index of the current dimension on which the recursion is applied.\n        """"""\n        self.indices[:, self.current_dim] = 0\n        self.current_dim = current_dim\n        self.indices[0, current_dim] = self.special\n        for i in range(self.reach):\n            self.indices[i+1, self.current_dim] = value-i\n\n    def incrementN(self, value=1):\n        """"""Increments the indices (that is all the indices that reach back)\n        by ``value`` in the index helper.""""""\n        self.indices[1:, self.current_dim] += value\n\n    def getCurrent(self):\n        """"""Returns the current multi-index that is a tuple of length\n        ``num_dims``.\n\n        Returns\n        -------\n        tuple\n            Returns the current set of indices that is a tuple of length\n            ``num_dims`` that represents the multiindex of the current\n            recursion step.\n        """"""\n        return tuple(self.indices[1, :])\n\n    def getPreceding(self, m):\n        """"""Returns the ``m``-th preceding multi-index that is a tuple of length\n        ``num_dims``.\n\n        This method is a generalization of ``getCurrent``.\n\n        Parameters\n        ----------\n        m : int\n            The number of steps the index of interest precedes the current.\n\n        Returns\n        -------\n        tuple\n            Returns the m-th preceding multi-index that is a tuple of length\n            ``num_dims``.\n        """"""\n        return tuple(self.indices[1+m, :])\n\n    def getSpecial(self):\n        """"""Returns the multi-index that corresponds\n        to the special function argument of the recursion. \n        It is a tuple of length ``num_dims``.\n\n        Returns\n        -------\n        tuple\n            Returns the multi-index that corresponds\n            to the special function argument of the recursion. \n            It is a tuple of length ``num_dims``.\n        """"""\n        return tuple(self.indices[0, :])\n\n    def getN(self):\n        """"""Returns the current recursion step along the current\n        dimension.\n\n        Returns\n        -------\n        int\n            Returns the current recursion step along the current\n            dimension.\n        """"""\n        return self.indices[1, self.current_dim]\n\n    def getElementaries(self, basetensor):\n        """"""Return pointers to the edges of the ``num_dims``-dimensional\n        array (the code is vectorized over the strictly speaking remaining\n        dimension).\n\n        Before the tensor product these are the only non-zero entries. In the\n        algorithm they are needed as input to the ``einsum`` function.\n\n        Parameters\n        ----------\n        basetensor : numpy.ndarray\n            The ``num_dims+1``-dimensional array considered, with samples\n            along the first dimension. For each sample we have ``num_dims``\n            -dimensional subarrays with non-zero values on the edges.\n\n        Returns\n        -------\n        tuple\n            Return pointers to the edges of the ``num_dims``-dimensional\n            array (the code is vectorized over the strictly speaking remaining\n            dimension). Return value is a list of ``num_dims`` edges\n            each having shape (num_samples, degree+1).\n        """"""\n        indexlist = [0]*self.num_dims\n        elementaries = []\n        for i in range(self.num_dims):\n            indexlist[i] = slice(None)\n            elementaries.append(basetensor[self.all+tuple(indexlist)])\n            indexlist[i] = 0\n        return elementaries\n'"
pyfunctionbases/function_definitions.py,0,"b'""""""\nFunction definitions that can be used for the ``RecursiveExpansion`` class.\n\nWithin this module you will find the recursive implementations of the\ncomputation of standard polynomials, Legendre polynomials, \nLegendre rational functions and Chebyshev polynomials of first kind.\nThe advantages of using these functions bases include orthogonality\nand numerical stability. Analytically part of the polynomial bases\ncover the same function space if they are of same degree and on the\nsame domain.\n""""""\n\n\ndef recf_standard_poly(basetensor, ind, x):\n    """"""Implementation of the recursion formula for standard polynomials.\n\n    Parameters\n    ----------\n    basetensor : numpy.ndarray\n        The ``num_dims+1``-dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind : numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x : numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n\n\n    Returns\n    -------\n    numpy.ndarray\n        Array of shape ``(num_samples,)`` containing the evaluation of\n        the most recent recursion step along the ``current_dim``.\n\n    References\n    ----------\n    .. [1] Wikipedia, ""Polynomials"",\n        https://en.wikipedia.org/wiki/Polynomial\n    """"""\n    return basetensor[ind.all+ind.getPreceding(1)] * \\\n        basetensor[ind.all+ind.getSpecial()]\n\n\ndef init_standard_poly(basetensor, ind, x):\n    """"""Initialize the 1 and x1,...,xn before starting the recursion.\n\n    Parameters\n    ----------\n    basetensor : numpy.ndarray\n        The ``num_dims+1``-dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind : numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x : numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n    """"""\n    ind.zeroAllBut(0, 0)\n    basetensor[ind.all+ind.getCurrent()] = 1.\n    for i in range(x.shape[1]):\n        ind.zeroAllBut(i, 1)\n        basetensor[ind.all + ind.getCurrent()] = x[:, i]\n\n\ndef recf_legendre_poly(basetensor, ind, x):\n    """"""Implementation of the recursion formula for Legendre polynomials.\n\n    Parameters\n    ----------\n    basetensor : numpy.ndarray\n        The ``num_dims+1``-dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind : numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x : numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n\n\n    Returns\n    -------\n    numpy.ndarray\n        Array of shape ``(num_samples,)`` containing the evaluation of\n        the most recent recursion step along the ``current_dim``.\n\n    References\n    ----------\n    .. [2] Wikipedia, ""Legendre polynomials"",\n        https://en.wikipedia.org/wiki/Legendre_polynomials\n    """"""\n    n = ind.getN()\n    return (2.*n-1.)/n*basetensor[ind.all+ind.getSpecial()] \\\n        * basetensor[ind.all + ind.getPreceding(1)] \\\n        - (n-1.)/n*basetensor[ind.all + ind.getPreceding(2)]\n\n\ndef init_legendre_rational(basetensor, ind, x):\n    """"""Initialize the initial values before starting the recursion.\n\n    Parameters\n    ----------\n    basetensor: numpy.ndarray\n        The ``num_dims+1``- dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind: numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x: numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n    """"""\n    ind.zeroAllBut(0, 0)\n    basetensor[ind.all+ind.getCurrent()] = 1.\n    for i in range(x.shape[1]):\n        ind.zeroAllBut(i, 1)\n        basetensor[ind.all + ind.getCurrent()] = (x[:, i]-1.)/(x[:, i]+1.)\n\n\ndef recf_legendre_rational(basetensor, ind, x):\n    """"""Implementation of the recursion formula for Legendre rational functions.\n\n    Parameters\n    ----------\n    basetensor: numpy.ndarray\n        The ``num_dims+1``- dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind: numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x: numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n\n    Returns\n    -------\n    numpy.ndarray\n        Array of shape ``(num_samples,)`` containing the evaluation of\n        the most recent recursion step along the ``current_dim``.\n\n    References\n    ----------\n    .. [3] Wikipedia, ""Legendre rational functions"",\n        https://en.wikipedia.org/wiki/Legendre_rational_functions\n    """"""\n    n = ind.getN()\n    xv = x[:, ind.current_dim]\n    Rnmin1 = basetensor[ind.all+ind.getPreceding(1)]\n    Rnmin2 = basetensor[ind.all+ind.getPreceding(2)]\n    return (2.*n-1.)/n*(xv-1.) / (xv+1.) * Rnmin1 - (n-1.) / n * Rnmin2\n\n\ndef recf_chebyshev_poly(basetensor, ind, x):\n    """"""Implementation of the recursion formula for Chebyshev polynomials.\n\n    Parameters\n    ----------\n    basetensor : numpy.ndarray\n        The ``num_dims+1``-dimensional array considered, with samples\n        along the first dimension. For each sample we have ``num_dims``\n        -dimensional subarrays with non-zero values on the edges.\n    ind : numpy.ndarray\n        Instance of the class ``NDArrayManager`` created in the\n        ``RecursiveExpansion.execute`` method and passed when\n        calling this function.\n    x : numpy.ndarray\n        A two-dimensional numpy array passed to\n        ``RecursiveExpansion.execute``. The recursion will be evaluated\n        on the data contained. Observations of\n        variables are stored in the rows of the array, individual variables\n        are stored in the columns. This means that one row contains one\n        particular observation/measurement of all variables, and one\n        column contains all observations/measurements of one particular\n        variable.\n\n\n    Returns\n    -------\n    numpy.ndarray\n        Array of shape ``(num_samples,)`` containing the evaluation of\n        the most recent recursion step along the ``current_dim``.\n\n    References\n    ----------\n    .. [4] Wikipedia, ""Chebyshev polynomials of first kind"",\n        https://en.wikipedia.org/wiki/Chebyshev_polynomials#First_kind\n    """"""\n\n    return 2. * x[:, ind.current_dim] * basetensor[ind.all+ind.getPreceding(1)] \\\n        - basetensor[ind.all+ind.getPreceding(2)]\n\n\nrecfs = {\'standard_poly\': (2, 2, 1, init_standard_poly, recf_standard_poly,\n                           -float(\'Inf\'), float(\'Inf\')),\n         \'legendre_poly\': (2, 3, 1, init_standard_poly, recf_legendre_poly,\n                           -1, 1),\n         \'legendre_rational\': (2, 3, 0, init_legendre_rational,\n                               recf_legendre_rational, 0, float(\'Inf\')),\n         \'chebyshev_poly\': (2, 3, 1, init_standard_poly,\n                            recf_chebyshev_poly, -1, 1)}\n""""""dict: Bundeling the recursions and relevant information.\n\nEach tuple contains the index of the first recursively defined function,\nthe number of preceding elements that are arguments to the recursion\n(+1 for the current), the index of an ""special"" function that is an argument\nto the recursion (may reduce the total amount arguments needed), the\ninitialization, recursion itself and the boundary of the one-dimensional domain\nof the function sequence.\n""""""\n'"
tests/__init__.py,0,b''
tests/test_RecursiveExpansion.py,12,"b'\'\'\'\nToDo:\n\'\'\'\n\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(\n    os.path.join(os.path.dirname(__file__), \'..\')))\n\nfrom pyfunctionbases.expansions import *\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal\nimport time\n\nDECIMAL = 7\n\n\ndef get_chebyshev_poly(x):\n    p = np.ndarray((x.shape[0], 7))\n    p[:, 0] = 1.\n    p[:, 1] = x\n    p[:, 2] = 2.*x*x-1.\n    p[:, 3] = 4.*x**3-3.*x\n    p[:, 4] = 8.*x**4-8.*x**2+1.\n    p[:, 5] = 16.*x**5-20.*x**3+5.*x\n    p[:, 6] = 32.*x**6-48.*x**4+18.*x*x-1.\n    return p\n\n\ndef get_legendre_ratio(x):\n    p = np.ndarray((x.shape[0], 5))\n    p[:, 0] = 1.\n    p[:, 1] = (x-1.)/(x+1.)\n    p[:, 2] = (x*x-4.*x+1.)/(x+1.)**2\n    p[:, 3] = (x**3-9.*x*x+9.*x-1.)/(x+1.)**3\n    p[:, 4] = (x**4-16.*x**3+36.*x*x-16.*x+1.)/(x+1.)**4\n    return p\n\n\ndef get_legendre_poly(x):\n    p = np.ndarray((x.shape[0], 7))\n    p[:, 0] = 1.\n    p[:, 1] = x\n    p[:, 2] = 0.5*(3.*x*x-1.)\n    p[:, 3] = 0.5*(5.*x*x-3.)*x\n    p[:, 4] = 1./8.*(35.*x**4-30.*x*x+3.)\n    p[:, 5] = 1./8.*(63.*x**5-70.*x**3+15.*x)\n    p[:, 6] = 1./16.*(231.*x**6-315.*x**4+105.*x*x-5.)\n    return p\n\n\ndef get_standard_poly(x):\n    p = np.ndarray((x.shape[0], 7))\n    p[:, 0] = 1.\n    p[:, 1] = x\n    p[:, 2] = x*x\n    p[:, 3] = x**3\n    p[:, 4] = x**4\n    p[:, 5] = x**5\n    p[:, 6] = x**6\n    return p\n\n\ndef get_handcomputed_function_tensor(x, func, degree):\n    """"""x must be of shape (3,).""""""\n    outtensor = np.zeros((degree+1,)*3)\n\n    outtensor[:, 0, 0] = func(x[np.newaxis, 0])\n    outtensor[0, :, 0] = func(x[np.newaxis, 1])\n    outtensor[0, 0, :] = func(x[np.newaxis, 2])\n\n    for i in range(degree+1):\n        outtensor[:, i, 0] = outtensor[:, 0, 0]*outtensor[0, i, 0]\n\n    for i in range(degree+1):\n        outtensor[:, :, i] = outtensor[:, :, 0]*outtensor[0, 0, i]\n\n    return outtensor\n\n\nfuncs = [(get_standard_poly, 6, \'standard_poly\'),\n         (get_legendre_poly, 6, \'legendre_poly\'),\n         (get_legendre_ratio, 4, \'legendre_rational\'),\n         (get_chebyshev_poly, 6, \'chebyshev_poly\')]\n\n\ndef test_RecursiveExpansionNode1():\n    """"""Testing the one-dimensional expansion.""""""\n    for functup in funcs:\n        func = functup[0]\n        degree = functup[1]\n        name = functup[2]\n        data = np.random.rand(1, 1)\n\n        expn = RecursiveExpansion(degree, recf=name)\n        nodeexp = expn.execute(data)\n        assert_array_almost_equal(nodeexp,\n                                  func(data[:, 0]), DECIMAL-3)\n        print(\'Single dim \'+name + \' equal\')\n\n\ndef test_RecursiveExpansionNode2():\n    """"""Testing the tensor-base.""""""\n    data = 1e-6+np.random.rand(4, 3)\n    for functup in funcs:\n        func = functup[0]\n        degree = functup[1]\n        name = functup[2]\n        recexpn = RecursiveExpansion(degree, recf=name)\n        resrec = recexpn.execute(data)\n\n        reshand = np.array([get_handcomputed_function_tensor(data[i, :], func, degree)\n                            for i in range(data.shape[0])])\n\n        if name == \'legendre_rational\':\n            prec = 1\n        else:\n            prec = 0\n        assert_array_almost_equal(resrec, reshand, DECIMAL-3-prec)\n        print(\'Multi dim \' + name + \' equal\')\n\n\ndef test_Runtime():\n    data = np.random.rand(100, 2)\n    degree = 120\n    REnode = RecursiveExpansion(degree, recf=\'legendre_poly\')\n\n    REstart = time.time()\n    REshape = REnode.execute(data).shape\n    REtime = time.time()-REstart\n\n    print(\'Computation took: % f for % d polynomials\' %\n          (REtime, (degree+1)**data.shape[1]))\n    print(\'Shapes: \', REshape)\n\n\nif __name__ == ""__main__"":\n    test_RecursiveExpansionNode1()\n    test_RecursiveExpansionNode2()\n    test_Runtime()\n'"
