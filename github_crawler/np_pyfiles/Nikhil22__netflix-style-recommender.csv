file_path,api_count,code
PythonNumpyWarmUp.py,0,"b'\n# coding: utf-8\n\n# In[25]:\n\n# Handy for matrix manipulations, likE dot product and tranpose\n\nfrom numpy import *\n\n\n# In[26]:\n\n# Declare and initialize a 2d numpy array (just call it a matrix, for simplicity)\n# This how we will be organizing our data. very simple, and easy to manipulate.\n\ndata = array([[1, 2, 3], [1, 2, 3]])\nprint data\n\n\n# In[27]:\n\n# Get dimensions of matrix\n\ndata.shape\n\n\n# In[28]:\n\n# Declare and initialize a matrix of zeros\n\nzeros_matrix = zeros((1,2))\nprint zeros_matrix\n\n\n# In[29]:\n\n# Declare and initialize a matrix of ones\n\nones_matrix = ones((1,2))\nprint ones_matrix\n\n\n# In[30]:\n\n# Declare and initialize a matrix of random integers from 0-10\n\nrand_matrix = random.randint(10, size = (10, 5))\nprint rand_matrix\n\n\n# In[31]:\n\n# Declare and initialize a column vector\n\ncol_vector = random.randint(10, size = (10, 1))\nprint col_vector\n\n\n# In[32]:\n\n# Access and print the first element of the column vector\n\nprint col_vector[0]\n\n\n# In[33]:\n\n# Change the first element of the column vector\n\ncol_vector[0] = 100\nprint col_vector\n\n\n# In[34]:\n\n# Access and print the first element of rand_matrix\nprint rand_matrix[0, 0]\n\n\n# In[35]:\n\n# Access and print the all rows of first column of rand_matrix\nprint rand_matrix[:, 0:1]\n\n\n# In[36]:\n\n# Access and print the all columns of first row of rand_matrix\nprint rand_matrix[0:1, :]\n\n\n# In[37]:\n\n# Access the 2nd, 3rd and 5th columns fo the first row rand_matrix\n# Get the result in a 2d numpy array\ncols = array([[1,2,3]])\nprint rand_matrix[0, cols]\n\n\n# In[38]:\n\n# Flatten a matrix\nflattened = rand_matrix.T.flatten()\nprint flattened\n\n\n# In[39]:\n\n# Dot product\nrand_matrix_2 = random.randint(10, size = (5,2))\ndot_product = rand_matrix.dot(rand_matrix_2)\nprint dot_product\n\n\n# In[ ]:\n'"
movie_recommender.py,0,"b""\n# coding: utf-8\n\n# In[16]:\n\nfrom numpy import *\n\n\n# In[17]:\n\n# define the number of movies in our 'database'\n\nnum_movies = 10\n\n\n# In[18]:\n\n# define the number of users in our 'database'\n\nnum_users = 5\n\n\n# In[19]:\n\n# randomly initialize some movie ratings \n# a 10 X 5 matrix\n\nratings = random.randint(11, size = (num_movies, num_users))\n\n\n# In[20]:\n\nprint ratings\n\n\n# In[21]:\n\n# create a logical matrix (matrix that represents whether a rating was made, or not)\n# != is the logical not operator\n\ndid_rate = (ratings != 0) * 1\n\n\n# In[22]:\n\nprint did_rate\n\n\n# In[23]:\n\n# Here's what happens if we don't multiply by 1\n\nprint (ratings != 0)\n\n\n# In[24]:\n\nprint (ratings != 0) * 1\n\n\n# In[25]:\n\n# Get the dimensions of a matrix using the shape property\n\nratings.shape\n\n\n# In[26]:\n\ndid_rate.shape\n\n\n# In[27]:\n\n# Let's make some ratings. A 10 X 1 column vector to store all the ratings I make\n\nnikhil_ratings = zeros((num_movies, 1))\nprint nikhil_ratings\n\n\n# In[28]:\n\n# Python data structures are 0 based\n\nprint nikhil_ratings[10] \n\n\n# In[29]:\n\n# I rate 3 movies\n\nnikhil_ratings[0] = 8\nnikhil_ratings[4] = 7\nnikhil_ratings[7] = 3\n\nprint nikhil_ratings\n\n\n# In[30]:\n\n# Update ratings and did_rate\n\nratings = append(nikhil_ratings, ratings, axis = 1)\ndid_rate = append(((nikhil_ratings != 0) * 1), did_rate, axis = 1)\n\n\n# In[31]:\n\nprint ratings\n\n\n# In[32]:\n\n\n\nratings.shape\n\n\n# In[33]:\n\ndid_rate\n\n\n# In[34]:\n\nprint did_rate\n\n\n# In[35]:\n\ndid_rate.shape\n\n\n# In[36]:\n\n# Simple explanation of what it means to normalize a dataset\n\na = [10, 20, 30]\naSum = sum(a)\n\n\n# In[37]:\n\nprint aSum\n\n\n# In[38]:\n\naMean = aSum / 3\n\n\n# In[39]:\n\nprint aMean\n\n\n# In[40]:\n\naMean = mean(a)\nprint aMean\n\n\n# In[41]:\n\na = [10 - aMean, 20 - aMean, 30 - aMean]\nprint a\n\n\n# In[42]:\n\nprint ratings\n\n\n# In[43]:\n\n# a function that normalizes a dataset\n\ndef normalize_ratings(ratings, did_rate):\n    num_movies = ratings.shape[0]\n    \n    ratings_mean = zeros(shape = (num_movies, 1))\n    ratings_norm = zeros(shape = ratings.shape)\n    \n    for i in range(num_movies): \n        # Get all the indexes where there is a 1\n        idx = where(did_rate[i] == 1)[0]\n        #  Calculate mean rating of ith movie only from user's that gave a rating\n        ratings_mean[i] = mean(ratings[i, idx])\n        ratings_norm[i, idx] = ratings[i, idx] - ratings_mean[i]\n    \n    return ratings_norm, ratings_mean\n\n        \n    \n\n\n# In[44]:\n\n# Normalize ratings\n\nratings, ratings_mean = normalize_ratings(ratings, did_rate)\n\n\n# In[45]:\n\n# Update some key variables now\n\nnum_users = ratings.shape[1]\nnum_features = 3\n\n\n# In[46]:\n\n# Simple explanation of what it means to 'vectorize' a linear regression\n\nX = array([[1, 2], [1, 5], [1, 9]])\nTheta = array([[0.23], [0.34]])\n\n\n# In[47]:\n\nprint X\n\n\n# In[48]:\n\nprint Theta\n\n\n# In[49]:\n\nY = X.dot(Theta)\nprint Y\n\n\n# In[50]:\n\n# Initialize Parameters theta (user_prefs), X (movie_features)\n\nmovie_features = random.randn( num_movies, num_features )\nuser_prefs = random.randn( num_users, num_features )\ninitial_X_and_theta = r_[movie_features.T.flatten(), user_prefs.T.flatten()]\n\n\n# In[51]:\n\nprint movie_features\n\n\n# In[52]:\n\nprint user_prefs\n\n\n# In[53]:\n\nprint initial_X_and_theta\n\n\n# In[54]:\n\ninitial_X_and_theta.shape\n\n\n# In[55]:\n\nmovie_features.T.flatten().shape\n\n\n# In[56]:\n\nuser_prefs.T.flatten().shape\n\n\n# In[57]:\n\ninitial_X_and_theta\n\n\n# In[58]:\n\ndef unroll_params(X_and_theta, num_users, num_movies, num_features):\n\t# Retrieve the X and theta matrixes from X_and_theta, based on their dimensions (num_features, num_movies, num_movies)\n\t# --------------------------------------------------------------------------------------------------------------\n\t# Get the first 30 (10 * 3) rows in the 48 X 1 column vector\n\tfirst_30 = X_and_theta[:num_movies * num_features]\n\t# Reshape this column vector into a 10 X 3 matrix\n\tX = first_30.reshape((num_features, num_movies)).transpose()\n\t# Get the rest of the 18 the numbers, after the first 30\n\tlast_18 = X_and_theta[num_movies * num_features:]\n\t# Reshape this column vector into a 6 X 3 matrix\n\ttheta = last_18.reshape(num_features, num_users ).transpose()\n\treturn X, theta\n\n\n# In[59]:\n\ndef calculate_gradient(X_and_theta, ratings, did_rate, num_users, num_movies, num_features, reg_param):\n\tX, theta = unroll_params(X_and_theta, num_users, num_movies, num_features)\n\t\n\t# we multiply by did_rate because we only want to consider observations for which a rating was given\n\tdifference = X.dot( theta.T ) * did_rate - ratings\n\tX_grad = difference.dot( theta ) + reg_param * X\n\ttheta_grad = difference.T.dot( X ) + reg_param * theta\n\t\n\t# wrap the gradients back into a column vector \n\treturn r_[X_grad.T.flatten(), theta_grad.T.flatten()]\n\n\n# In[60]:\n\ndef calculate_cost(X_and_theta, ratings, did_rate, num_users, num_movies, num_features, reg_param):\n\tX, theta = unroll_params(X_and_theta, num_users, num_movies, num_features)\n\t\n\t# we multiply (element-wise) by did_rate because we only want to consider observations for which a rating was given\n\tcost = sum( (X.dot( theta.T ) * did_rate - ratings) ** 2 ) / 2\n\t# '**' means an element-wise power\n\tregularization = (reg_param / 2) * (sum( theta**2 ) + sum(X**2))\n\treturn cost + regularization\n\n\n# In[64]:\n\n# import these for advanced optimizations (like gradient descent)\n\nfrom scipy import optimize\n\n\n# In[65]:\n\n# regularization paramater\n\nreg_param = 30\n\n\n# In[67]:\n\n# perform gradient descent, find the minimum cost (sum of squared errors) and optimal values of X (movie_features) and Theta (user_prefs)\n\nminimized_cost_and_optimal_params = optimize.fmin_cg(calculate_cost, fprime=calculate_gradient, x0=initial_X_and_theta, \t\t\t\t\t\t\t\targs=(ratings, did_rate, num_users, num_movies, num_features, reg_param), \t\t\t\t\t\t\t\tmaxiter=100, disp=True, full_output=True ) \n\n\n# In[ ]:\n\ncost, optimal_movie_features_and_user_prefs = minimized_cost_and_optimal_params[1], minimized_cost_and_optimal_params[0]\n\n\n# In[ ]:\n\n# unroll once again\n\nmovie_features, user_prefs = unroll_params(optimal_movie_features_and_user_prefs, num_users, num_movies, num_features)\n\n\n# In[ ]:\n\nprint movie_features\n\n\n# In[ ]:\n\nprint user_prefs\n\n\n# In[ ]:\n\n# Make some predictions (movie recommendations). Dot product\n\nall_predictions = movie_features.dot( user_prefs.T )\n\n\n# In[ ]:\n\nprint all_predictions\n\n\n# In[ ]:\n\n# add back the ratings_mean column vector to my (our) predictions\n\npredictions_for_nikhil = all_predictions[:, 0:1] + ratings_mean\n\n\n# In[ ]:\n\nprint predictions_for_nikhil\n\n\n# In[ ]:\n\nprint nikhil_ratings\n\n\n# In[ ]:\n\n\n\n"""
