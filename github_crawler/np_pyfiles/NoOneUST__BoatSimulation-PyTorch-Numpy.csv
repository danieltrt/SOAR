file_path,api_count,code
Discrete3DHull_Numpy.py,62,"b""from matplotlib import pyplot as plt\r\n# import multiprocessing\r\nimport numpy as np\r\n# from pathos.multiprocessing import ProcessingPool as Pool\r\n\r\n# from scipy.optimize import root, fsolve\r\n# from mpl_toolkits.mplot3d import Axes3D\r\n\r\n# cores = multiprocessing.cpu_count()\r\nfor loopIter in range(1):\r\n    print('This is Loop: ', loopIter)\r\n    D = 0.3 * 0.65  # meter\r\n    L, B = 0.3, 0.3\r\n\r\n    xRange = 0.20 * 2 * 0.65  # meter\r\n    yRange = 0.20 * 2 * 0.65  # meter\r\n    zUpperBound = np.maximum(D * 1.2, 0.7)  # meter\r\n    zLowerBound = D * 0.2\r\n\r\n    precision = 0.003  # meter\r\n    gravity = 9.8  # m/s^2\r\n    waterDensity = 997  # kg/m^3\r\n    hullDensity = 1.1  # kg/m^3\r\n    boatThick = 1e-2  # meter\r\n\r\n    hullMeshDensity = hullDensity * np.power(precision, 3)\r\n    waterMeshDensity = waterDensity * np.power(precision, 3)\r\n\r\n    def axis2MeshPositionZ(axis):\r\n        return list(map(int, (np.array(axis) + zLowerBound) / precision))\r\n\r\n    class ballast():\r\n        weight = 0.13  # kg\r\n        axisPosition = np.array([0, 0, 0])  # meter\r\n        meshPosition = axis2MeshPositionZ(axisPosition)\r\n        axisShape = np.array([0.03*4, 0.025*1.5, 0.025*1.5])  # meter\r\n        meshShape = list(map(int, axisShape / precision))\r\n        meshVolume = meshShape[0] * meshShape[1] * meshShape[2]\r\n        meshDensity = weight / meshVolume\r\n\r\n    ballast1 = ballast()\r\n\r\n    MidIndexX = int(xRange / precision + 1)\r\n    MidIndexY = int(yRange / precision + 1)\r\n    MidIndexZ = int(zLowerBound / precision + 1)\r\n\r\n    maxZIndex = int((D + zLowerBound) / precision)\r\n\r\n    xLen = int(2 * xRange / precision + 1)\r\n    yLen = int(2 * yRange / precision + 1)\r\n    zLen = int((zLowerBound + zUpperBound) / precision + 1)\r\n\r\n    xArray = np.linspace(-xRange, xRange, xLen)\r\n    yArray = np.linspace(-yRange, yRange, yLen)\r\n\r\n    xGrid, yGrid = np.meshgrid(xArray, yArray)\r\n    zGrid = D * (np.power(2 * xGrid / L, 4) + np.power(2 * yGrid / B, 2))\r\n\r\n    hullMesh = np.zeros((xLen, yLen, zLen))\r\n\r\n    minZIndexMat = (\r\n        (np.transpose(zGrid) +\r\n         zLowerBound) /\r\n        precision).astype(\r\n        np.int)\r\n\r\n    for i in range(xLen):\r\n        for j in range(yLen):\r\n            # minZIndex = int((zGrid[j, i] + zLowerBound) / precision)\r\n            hullMesh[i, j, minZIndexMat[i, j]:maxZIndex] = 1\r\n            # hullMesh[i, j, minZIndex:minZIndex + int(boatThick / precision)] = 1\r\n            # hullMesh[i, j, maxZIndex - int(boatThick / precision):maxZIndex] = 1\r\n\r\n    def caculWeight(weightMat):\r\n        M = np.sum(weightMat)\r\n        return M\r\n\r\n    def calculCOM(weightMat):\r\n        M = caculWeight(weightMat)\r\n        xCOMPre = np.linspace(\r\n            1, xLen, xLen).dot(\r\n            np.sum(\r\n                weightMat, axis=(\r\n                    2, 1)))\r\n        yCOMPre = np.linspace(\r\n            1, yLen, yLen).dot(\r\n            np.sum(\r\n                weightMat, axis=(\r\n                    0, 2)))\r\n        zCOMPre = np.linspace(\r\n            1, zLen, zLen).dot(\r\n            np.sum(\r\n                weightMat, axis=(\r\n                    1, 0)))\r\n        xCOM, yCOM, zCOM = [xCOMPre, yCOMPre, zCOMPre] / M\r\n        return np.array([xCOM, yCOM, zCOM]).astype(np.int)\r\n\r\n    def addBallast(weightMat, ballast1):\r\n        xCOM, yCOM, zCOM = calculCOM(weightMat)\r\n        shape = ballast1.meshShape\r\n        weightMat[int(xCOM -\r\n                      shape[0] /\r\n                      2):int(xCOM +\r\n                             shape[0] /\r\n                             2 +\r\n                             1), int(yCOM -\r\n                                     shape[1] /\r\n                                     2):int(yCOM +\r\n                                            shape[1] /\r\n                                            2 +\r\n                                            1), int(MidIndexZ +\r\n                                                    ballast1.meshShape[2]):int(MidIndexZ +\r\n                                                                               shape[2] +\r\n                                                                               ballast1.meshShape[2]) +\r\n                  1] += ballast1.meshDensity\r\n        return weightMat\r\n\r\n    hullMesh = hullMeshDensity * hullMesh\r\n\r\n    hullWeight = caculWeight(hullMesh)\r\n\r\n    xCOM, yCOM, zCOM = calculCOM(hullMesh)\r\n    print([xCOM, yCOM, zCOM])\r\n\r\n    hullMesh = addBallast(hullMesh, ballast1)\r\n\r\n    def addMast(weightMat):\r\n        DiaMeter = 9.5e-3  # meter\r\n        Radius = DiaMeter / 2  # meter\r\n        RadiusMesh = int(Radius / precision)\r\n        Length = 0.5  # meter\r\n        Weight = 96.7e-3  # kg\r\n        Volume = np.pi * Radius * Radius * Length\r\n        Density = Weight / Volume\r\n        DensityMesh = Density * np.power(precision, 3)\r\n\r\n        xCOM, yCOM, zCOM = calculCOM(weightMat)\r\n\r\n        iArray = np.linspace(- RadiusMesh, RadiusMesh, 2 *\r\n                             RadiusMesh + 1).astype(np.int)\r\n        jRadius = np.sqrt(\r\n            RadiusMesh *\r\n            RadiusMesh -\r\n            iArray *\r\n            iArray).astype(\r\n            np.int)\r\n        for i in range(iArray.shape[0]):\r\n            weightMat[iArray[i] +\r\n                      xCOM, yCOM -\r\n                      jRadius[i]:yCOM +\r\n                      jRadius[i], int(zLowerBound /\r\n                                      precision):int((zLowerBound +\r\n                                                      Length) /\r\n                                                     precision)] = DensityMesh\r\n\r\n        return weightMat\r\n\r\n    hullMesh = addMast(hullMesh)\r\n\r\n    xCOM, yCOM, zCOM = calculCOM(hullMesh)\r\n    print([xCOM, yCOM, zCOM], '\\n')\r\n\r\n    hullWeight = caculWeight(hullMesh)\r\n\r\n    DisplacementVolumeReal = hullWeight / waterDensity\r\n    DisplacementVolumeMesh = DisplacementVolumeReal / pow(precision, 3)\r\n\r\n    def fliTrans(mat):\r\n        return np.flipud(mat.transpose())\r\n\r\n    def calculDisplacementVolumeMesh(\r\n            hullMesh,\r\n            waterAngle,\r\n            waterOffset,\r\n            isFinal,\r\n            needInverse):\r\n        noWaterMesh = np.ones(\r\n            [hullMesh.shape[0], hullMesh.shape[1], hullMesh.shape[2]])\r\n        waterLineMesh = np.zeros(\r\n            [hullMesh.shape[0], hullMesh.shape[1], hullMesh.shape[2]])\r\n\r\n        rightXYArray = ((np.tan(waterAngle) *\r\n                         (np.arange(yLen) *\r\n                          precision -\r\n                          xRange) +\r\n                         yRange) /\r\n                        precision +\r\n                        waterOffset).astype(np.int)\r\n        rightXYArray = np.maximum(rightXYArray, 0)\r\n\r\n        if needInverse:\r\n            for i in range(yLen):\r\n                rightXY = rightXYArray[i]\r\n                noWaterMesh[:, i, rightXY:] = 0\r\n        else:\r\n            for i in range(yLen):\r\n                rightXY = rightXYArray[i]\r\n                noWaterMesh[:, i, :rightXY] = 0\r\n\r\n        unSubmergedMesh = np.logical_and(noWaterMesh, hullMesh) * hullMesh\r\n        DisplacedWaterWeight = np.sum(\r\n            np.logical_and(\r\n                np.logical_not(noWaterMesh),\r\n                hullMesh)) * waterMeshDensity\r\n        DisplacementVolume = np.sum(np.logical_and(\r\n            np.logical_not(noWaterMesh), hullMesh)) * np.power(precision, 3)\r\n        SubmergedVolume = np.sum(np.logical_and(\r\n            np.logical_not(noWaterMesh),\r\n            hullMesh)) * np.power(precision, 3)\r\n        SubmergedMesh = np.logical_and(\r\n            np.logical_not(noWaterMesh),\r\n            hullMesh) * hullMesh\r\n\r\n        if isFinal:\r\n            print('\\nSubmergedVolume: ', SubmergedVolume)\r\n            print(\r\n                'Weight of Displaced Water: ',\r\n                DisplacementVolume *\r\n                waterDensity)\r\n            print('Weight of Boat: ', hullWeight)\r\n\r\n        return [\r\n            unSubmergedMesh,\r\n            SubmergedMesh,\r\n            waterLineMesh,\r\n            DisplacedWaterWeight,\r\n            noWaterMesh]\r\n\r\n    def calculBestWaterOffsetMesh(hullMesh, waterAngle, hullWeight):\r\n        lastLoss = - 1\r\n        maxIteration = 5000\r\n        waterOffsetLowerBound = - 2 * zLen\r\n        waterOffsetUpperBound = 3 * zLen\r\n        waterOffset = int((waterOffsetLowerBound + waterOffsetUpperBound) / 2)\r\n\r\n        if (waterAngle >= 0 and waterAngle < np.pi /\r\n                2) or (waterAngle >= 1.5 * np.pi and waterAngle < 2 * np.pi):\r\n            needInverse = 0\r\n        else:\r\n            needInverse = 1\r\n\r\n        for i in range(maxIteration):\r\n            print('Processed: ' +\r\n                  str((i +\r\n                       1) /\r\n                      maxIteration *\r\n                      100) +\r\n                  '%' +\r\n                  '     Loss: ' +\r\n                  str(lastLoss) +\r\n                  '     waterOffsetLowerBound: ' +\r\n                  str(waterOffsetLowerBound) +\r\n                  '     waterOffsetUpperBound: ' +\r\n                  str(waterOffsetUpperBound))\r\n            unSubmergedMesh, SubmergedMesh, waterLineMesh, DisplacedWaterWeight, noWaterMesh = calculDisplacementVolumeMesh(\r\n                hullMesh, waterAngle, waterOffset, False, needInverse)\r\n            thisLoss = (DisplacedWaterWeight - hullWeight) / hullWeight\r\n\r\n            if i >= maxIteration - \\\r\n                    1 or abs(thisLoss) < 0.01 or waterOffsetLowerBound >= waterOffsetUpperBound - 1:\r\n                unSubmergedMesh, SubmergedMesh, waterLineMesh, DisplacedWaterWeight, noWaterMesh = calculDisplacementVolumeMesh(\r\n                    hullMesh, waterAngle, waterOffset, True, needInverse)\r\n                thisLoss = (DisplacedWaterWeight - hullWeight) / hullWeight\r\n                print(\r\n                    '\\nDone \\nLoss= ',\r\n                    thisLoss * 100,\r\n                    '%',\r\n                    '\\nOffset = ',\r\n                    waterOffset)\r\n                pass\r\n                return [\r\n                    waterOffset,\r\n                    unSubmergedMesh,\r\n                    SubmergedMesh,\r\n                    waterLineMesh,\r\n                    thisLoss,\r\n                    noWaterMesh]\r\n            else:\r\n                if thisLoss < 0 and not(needInverse):\r\n                    waterOffsetLowerBound = waterOffset\r\n                    waterOffset = int(\r\n                        (waterOffset + waterOffsetUpperBound) / 2)\r\n                elif thisLoss < 0 and needInverse:\r\n                    waterOffsetUpperBound = waterOffset\r\n                    waterOffset = int(\r\n                        (waterOffset + waterOffsetLowerBound) / 2)\r\n                elif thisLoss > 0 and not(needInverse):\r\n                    waterOffsetUpperBound = waterOffset\r\n                    waterOffset = int(\r\n                        (waterOffset + waterOffsetLowerBound) / 2)\r\n                else:\r\n                    waterOffsetLowerBound = waterOffset\r\n                    waterOffset = int(\r\n                        (waterOffset + waterOffsetUpperBound) / 2)\r\n                lastLoss = thisLoss\r\n\r\n    degreeAngle = 120  # degree\r\n\r\n    waterAngle = np.deg2rad(degreeAngle)\r\n\r\n    waterOffset, unSubmergedMesh, SubmergedMesh, waterLineMesh, Loss, noWaterMesh = calculBestWaterOffsetMesh(\r\n        hullMesh, waterAngle, hullWeight)\r\n\r\n    HullSubmergedMesh = np.logical_and(noWaterMesh < 0.5, SubmergedMesh)\r\n\r\n    [xCOB, yCOB, zCOB] = map(int, calculCOM(HullSubmergedMesh))\r\n\r\n    FBuoyancy = FGravity = hullWeight * gravity\r\n\r\n    buoyancyTorqueVector = np.cross([(yCOB - yCOM) * precision,\r\n                                     (zCOB - zCOM) * precision,\r\n                                     0],\r\n                                    [-FBuoyancy * np.sin(waterAngle),\r\n                                     FBuoyancy * np.cos(waterAngle), 0])\r\n\r\n    buoyancyTorque = buoyancyTorqueVector[2]\r\n\r\n    print(\r\n        '\\nBuoyancy Torque under ',\r\n        degreeAngle,\r\n        ' degrees: ',\r\n        buoyancyTorque,\r\n        ' N * M\\n')\r\n\r\n    print('COM: ', [xCOM, yCOM, zLen - zCOM])\r\n    print('COB: ', [xCOB, yCOB, zLen - zCOB])\r\n\r\n    if(buoyancyTorque > 0):\r\n        print('\\nIt can recover\\n')\r\n\r\n    # xCOMPre = np.linspace(\r\n    #     1, xLen, xLen).dot(\r\n    #     np.sum(\r\n    #         weightMat, axis=(\r\n    #             2, 1)))\r\n    # yCOMPre = np.linspace(\r\n    #     1, yLen, yLen).dot(\r\n    #     np.sum(\r\n    #         weightMat, axis=(\r\n    #             0, 2)))\r\n    # zCOMPre = np.linspace(\r\n    #     1, zLen, zLen).dot(\r\n    #     np.sum(\r\n    #         weightMat, axis=(\r\n    #             1, 0)))\r\n    plt.figure(1)\r\n    # plt.matshow(fliTrans(hullMesh[MidIndexX, :, :]))\r\n    plt.matshow(fliTrans(SubmergedMesh[MidIndexX, :, :] > 0))\r\n    plt.title('Submerged_yz ' + str(degreeAngle))\r\n    plt.show()\r\n\r\n    plt.figure(2)\r\n    # plt.matshow(fliTrans(hullMesh[MidIndexX, :, :]))\r\n    plt.matshow(fliTrans(hullMesh[MidIndexX, :, :] > 0))\r\n    plt.title('yz ' + str(degreeAngle))\r\n    plt.show()\r\n\r\n    plt.figure(3)\r\n    plt.matshow(fliTrans(hullMesh[:, MidIndexY, :] > 0))\r\n    plt.title('xz')\r\n    plt.show()\r\n\r\n    zWeightArray = np.sum(hullMesh > 0, axis=(1, 0))\r\n    xNoZeroIndexArray = np.where(np.sum(hullMesh, axis=(1, 2)) > 0)[0]\r\n    yNoZeroIndexArray = np.where(np.sum(hullMesh, axis=(2, 0)) > 0)[0]\r\n\r\n    def calculMaxZIndexOfBoat(zWeightArray):\r\n        for i in range(zLen -1):\r\n            if zWeightArray[i] > zWeightArray[i+1] * 1.1:\r\n                return i\r\n\r\n    boatHeightIndex = calculMaxZIndexOfBoat(zWeightArray)\r\n\r\n    plt.figure(4)\r\n    plt.matshow(fliTrans(hullMesh[:, :, boatHeightIndex]) > 0)\r\n    plt.title('xy')\r\n    plt.show()\r\n\r\n    print('The height of Boat is: ', (calculMaxZIndexOfBoat(zWeightArray) - np.where(zWeightArray > 0)[0][0]) * precision)\r\n    print('The Length of Boat is: ', (xNoZeroIndexArray[-1] - xNoZeroIndexArray[0]) * precision)\r\n    print('The Width of Boat is: ', (yNoZeroIndexArray[-1] - yNoZeroIndexArray[0]) * precision)\r\n\r\n\r\n    synthesisMap = noWaterMesh + (hullMesh[MidIndexX, :, :] > 0)\r\n    synthesisMap[xCOM - 2:xCOM - 2:, yCOM - 2:yCOM + 2, zCOM - 2:zCOM + 2] += 1\r\n    synthesisMap[xCOB - 2:xCOB + 2, yCOB - 2:yCOB + 2, zCOB - 2:zCOB + 2] += 1\r\n\r\n    plt.figure(5)\r\n    plt.matshow(fliTrans(synthesisMap[xCOM, :, :]))\r\n    plt.title('synthesisMap')\r\n    plt.show()\r\n\r\n    # fig1 = plt.figure(1)\r\n    # ax = Axes3D(fig1)\r\n    #\r\n    # ax.plot_surface(\r\n    #     xGrid,\r\n    #     yGrid,\r\n    #     zGrid,\r\n    #     rstride=1,\r\n    #     cstride=1,\r\n    #     cmap='rainbow')\r\n    # # ax.plot_surface(xGrid, yGrid, DPlane, rstride=1, cstride=1, cmap='rainbow')\r\n    #\r\n    # plt.show()\r\n\r\n    pass\r\n"""
Discrete3DHull_Pytorch.py,16,"b'import itertools\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport torch\nfrom mpl_toolkits.mplot3d import Axes3D\nimport os\n\nos.environ[""CUDA_VISIBLE_DEVICES""] = ""1,2,3""\n\nshowMode = True\nfinalMode = True\n\ndegreeAngleList = [120, 140]\n\ndef showMat(Mat):\n    return Mat.cpu().numpy()\n\n\nRightMomentList = [0, 0]\nfor loopIter in range(2):\n    device = torch.device(""cuda:""+str(loopIter))\n\n    degreeAngle = degreeAngleList[loopIter]\n    if finalMode:\n        print(\'This is Loop: \', loopIter)\n    D = 0.165 * 0.65  # meter\n    L, B = 0.18, 0.20\n\n    xRange = 0.2 * 2 * 0.65  # meter\n    yRange = 0.2 * 2 * 0.65  # meter\n    zUpperBound = np.maximum(D * 1.2, 0.7)  # meter\n    zLowerBound = D * 0.2\n\n    precision = 0.0011  # meter\n    gravity = 9.8  # m/s^2\n    waterDensity = 997  # kg/m^3\n    hullDensity = 1.3  # kg/m^3\n    boatThick = 1e-2  # meter\n\n    hullMeshDensity = hullDensity * np.power(precision, 3)\n    waterMeshDensity = waterDensity * np.power(precision, 3)\n    boatThickMesh = int(boatThick / precision)\n\n    class ballast():\n        weight = 1.2  # kg\n        axisPosition = torch.tensor([0, 0, 0], device=device)  # meter\n        meshPosition = ((axisPosition + zLowerBound) / precision).int()\n        axisShape = torch.tensor(\n            [0.03 * 2.5, 0.025 * 2.5, 0.025 * 2.5], device=device)  # meter\n        meshShape = (axisShape / precision).int()\n        meshVolume = meshShape[0] * meshShape[1] * meshShape[2]\n        meshDensity = weight / meshVolume.float()\n\n    ballast1 = ballast()\n\n    MidIndexX = int(xRange / precision + 1)\n    MidIndexY = int(yRange / precision + 1)\n    MidIndexZ = int(zLowerBound / precision + 1)\n\n    maxZIndex = int((D + zLowerBound + boatThick) / precision)\n    maxZIndexNoDeck = int((D + zLowerBound) / precision)\n\n    xLen = int(2 * xRange / precision + 1)\n    yLen = int(2 * yRange / precision + 1)\n    zLen = int((zLowerBound + zUpperBound) / precision + 1)\n\n    xArray = torch.linspace(-xRange, xRange, xLen, device=device)\n    yArray = torch.linspace(-yRange, yRange, yLen, device=device)\n\n    xGrid, yGrid = torch.meshgrid([xArray, yArray])\n    zGrid = D * (torch.pow(2 * xGrid / L, 4) + torch.pow(2 * yGrid / B, 2))\n\n    hullMesh = torch.zeros((xLen, yLen, zLen), device=device)\n\n    minZIndexMat = (\n        (torch.t(zGrid) +\n         zLowerBound) /\n        precision).int()\n\n    if showMode == True:\n        for index in itertools.product(range(xLen), range(yLen)):\n            hullMesh[index[0], index[1], minZIndexMat[index[0], index[1]]:min(maxZIndex, minZIndexMat[index[0], index[1]] + boatThickMesh)] = 1\n            # if index[0] < MidIndexX:\n            #     hullMesh[index[0]:index[0]+boatThickMesh, index[1], min(maxZIndexNoDeck, minZIndexMat[index[0], index[1]])] = 1\n            # if index[0] >= MidIndexX:\n            #     hullMesh[index[0]-boatThickMesh:index[0], index[1], min(maxZIndexNoDeck, minZIndexMat[index[0], index[1]])] = 1\n            # if index[1] < MidIndexY:\n            #     hullMesh[index[0], index[1]:index[1]+boatThickMesh, min(maxZIndexNoDeck, minZIndexMat[index[0], index[1]])] = 1\n            # if index[1] >= MidIndexY:\n            #     hullMesh[index[0], index[1]-boatThickMesh:index[1], min(maxZIndexNoDeck, minZIndexMat[index[0], index[1]])] = 1\n            # if minZIndexMat[index[0], index[1]] <= maxZIndexNoDeck:\n            #     hullMesh[index[0], index[1], maxZIndexNoDeck: maxZIndex] = 1\n        DeckArea = torch.sum(hullMesh, dim=2) > 0\n        for index in range(maxZIndexNoDeck, maxZIndex+1):\n            hullMesh[:, :, index] = DeckArea\n    else:\n        for index in itertools.product(range(xLen), range(yLen)):\n            hullMesh[index[0], index[1], minZIndexMat[index[0], index[1]]:maxZIndexNoDeck] = 1\n\n    def caculWeight(weightMat):\n        return weightMat.sum()\n\n    def calculCOM(weightMat):\n        M = caculWeight(weightMat)\n        xCOMPre = torch.dot(torch.linspace(\n            1, xLen, xLen, device=device),\n            torch.sum(\n                weightMat, dim=(\n                    2, 1)))\n        yCOMPre = torch.dot(torch.linspace(\n            1, yLen, yLen, device=device),\n            torch.sum(\n                weightMat, dim=(\n                    0, 2)))\n        zCOMPre = torch.dot(torch.linspace(\n            1, zLen, zLen, device=device),\n            torch.sum(\n                weightMat, dim=(\n                    1, 0)))\n        xCOM, yCOM, zCOM = map(lambda x: x / M, [xCOMPre, yCOMPre, zCOMPre])\n        return torch.tensor([xCOM, yCOM, zCOM], device=device).int()\n\n    def addBallast(weightMat, ballast1):\n        xCOM, yCOM, zCOM = calculCOM(weightMat)\n        shape = ballast1.meshShape\n        weightMat[int(xCOM -\n                      shape[0] /\n                      2):int(xCOM +\n                             shape[0] /\n                             2 +\n                             1), int(yCOM -\n                                     shape[1] /\n                                     2):int(yCOM +\n                                            shape[1] /\n                                            2 +\n                                            1), int(MidIndexZ +\n                                                    2.2 * boatThickMesh):int(MidIndexZ +\n                                                                               2.2 *\n                                                                               boatThickMesh + shape[2]) +\n                  1] += ballast1.meshDensity\n        return weightMat\n\n    hullMesh = hullMeshDensity * hullMesh\n\n    hullWeight = caculWeight(hullMesh)\n\n    xCOM, yCOM, zCOM = calculCOM(hullMesh)\n    if finalMode:\n        print(\'COM: \', xCOM.item(), yCOM.item(), zCOM.item())\n\n        print(\'Weight Before Ballast:\', caculWeight(hullMesh).item())\n\n    PureHullMeshNoDeck = torch.zeros(hullMesh.size())\n    PureHullMeshNoDeck[:, :, :int((D + zLowerBound) / precision)] = hullMesh[:, :, :int((D + zLowerBound) / precision)]\n\n    PureDeckMesh = torch.zeros(hullMesh.size())\n    PureDeckMesh[:, :, int((D + zLowerBound) / precision):] = hullMesh[:, :, int((D + zLowerBound) / precision):]\n\n    hullMesh = addBallast(hullMesh, ballast1)\n\n    PureHullMeshWithDeckAndBallast = hullMesh + 0\n\n    if finalMode:\n        print(\'Weight After Ballast: \', caculWeight(hullMesh).item())\n\n    def addMast(weightMat):\n        DiaMeter = 9.5e-3  # meter\n        Radius = DiaMeter / 2  # meter\n        RadiusMesh = int(Radius / precision)\n        Length = 0.5  # meter\n        Weight = 96.7e-3  # kg\n        Volume = np.pi * Radius * Radius * Length\n        Density = Weight / Volume\n        DensityMesh = Density * np.power(precision, 3)\n\n        xCOM, yCOM, zCOM = calculCOM(weightMat)\n\n        iArray = torch.linspace(- RadiusMesh, RadiusMesh, 2 *\n                                RadiusMesh + 1, device=device)\n        jRadius = torch.sqrt(\n            np.power(RadiusMesh, 2) -\n            (iArray ** 2)).long()\n        iArray = iArray.long()\n        for i in range(iArray.shape[0]):\n            weightMat[iArray[i] +\n                      xCOM, yCOM -\n                      jRadius[i]:yCOM +\n                      jRadius[i], int(zLowerBound /\n                                      precision):int((zLowerBound +\n                                                      Length) /\n                                                     precision)] += DensityMesh\n        return weightMat\n\n    hullMesh = addMast(hullMesh)\n\n    PureMastMesh = hullMesh - PureHullMeshWithDeckAndBallast\n\n    if finalMode:\n        print(\'Weight After Mast: \', caculWeight(hullMesh).item())\n\n    xCOM, yCOM, zCOM = calculCOM(hullMesh)\n    if finalMode:\n        print(\'COM: \', xCOM.item(), yCOM.item(), zCOM.item(), \'\\n\')\n\n    hullWeight = caculWeight(hullMesh)\n\n    DisplacementVolumeReal = hullWeight / waterDensity\n    DisplacementVolumeMesh = DisplacementVolumeReal / np.power(precision, 3)\n\n    def fliTrans(mat):\n        return torch.flip(torch.t(mat), [0])\n\n    def calculDisplacementVolumeMesh(\n            hullMesh,\n            waterAngle,\n            waterOffset,\n            isFinal,\n            needInverse):\n        noWaterMesh = torch.ones(\n            hullMesh.shape[0],\n            hullMesh.shape[1],\n            hullMesh.shape[2],\n            device=device)\n        waterLineMesh = torch.zeros(\n            hullMesh.shape[0],\n            hullMesh.shape[1],\n            hullMesh.shape[2],\n            device=device)\n\n        rightXYArray = ((np.tan(waterAngle) *\n                         (torch.arange(yLen, device=device).float() *\n                          precision -\n                          xRange) +\n                         yRange) /\n                        precision +\n                        waterOffset).int()\n        rightXYArray = torch.max(\n            rightXYArray, torch.zeros(\n                yLen, device=device).int())\n\n        if needInverse:\n            for i in range(yLen):\n                noWaterMesh[:, i, rightXYArray[i]:] = 0\n        else:\n            for i in range(yLen):\n                noWaterMesh[:, i, :rightXYArray[i]] = 0\n\n        hullArea = (hullMesh > 0).int()\n        waterArea = (~ noWaterMesh.byte() > 0).int()\n        unSubmergedMesh = (noWaterMesh.int() & hullArea).float() * hullMesh\n        DisplacedWaterWeight = torch.sum(\n            waterArea & hullArea).float() * waterMeshDensity\n        DisplacementVolume = torch.sum(\n            waterArea & hullArea).float() * np.power(precision, 3)\n        SubmergedVolume = torch.sum(\n            waterArea & hullArea).float() * np.power(precision, 3)\n        # SubmergedMesh = (waterArea & hullArea).float() * hullMesh\n        SubmergedMesh = (waterArea & hullArea).float()\n        if finalMode:\n            if isFinal:\n                print(\'\\nSubmergedVolume: \', SubmergedVolume.item())\n                print(\n                    \'Weight of Displaced Water: \',\n                    DisplacementVolume.item() *\n                    waterDensity)\n                print(\'Weight of Boat: \', hullWeight.item())\n\n        return [\n            unSubmergedMesh,\n            SubmergedMesh,\n            waterLineMesh,\n            DisplacedWaterWeight,\n            noWaterMesh]\n\n    def calculBestWaterOffsetMesh(hullMesh, waterAngle, hullWeight):\n        lastLoss = - 1\n        maxIteration = 5000\n        waterOffsetLowerBound = - 2 * zLen\n        waterOffsetUpperBound = 3 * zLen\n        waterOffset = int((waterOffsetLowerBound + waterOffsetUpperBound) / 2)\n\n        if (waterAngle >= 0 and waterAngle < np.pi /\n                2) or (waterAngle >= 1.5 * np.pi and waterAngle < 2 * np.pi):\n            needInverse = 0\n        else:\n            needInverse = 1\n\n        for i in range(maxIteration):\n            if finalMode:\n                print(\'Processed: \' +\n                      str((i +\n                           1) /\n                          maxIteration *\n                          100) +\n                      \'%\' +\n                      \'     Loss: \' +\n                      str(lastLoss) +\n                      \'     waterOffsetLowerBound: \' +\n                      str(waterOffsetLowerBound) +\n                      \'     waterOffsetUpperBound: \' +\n                      str(waterOffsetUpperBound))\n            unSubmergedMesh, SubmergedMesh, waterLineMesh, DisplacedWaterWeight, noWaterMesh = calculDisplacementVolumeMesh(\n                hullMesh, waterAngle, waterOffset, False, needInverse)\n            thisLoss = (DisplacedWaterWeight - hullWeight) / hullWeight\n\n            if i >= maxIteration - \\\n                    1 or abs(thisLoss) < 0.01 or waterOffsetLowerBound >= waterOffsetUpperBound - 1:\n                unSubmergedMesh, SubmergedMesh, waterLineMesh, DisplacedWaterWeight, noWaterMesh = calculDisplacementVolumeMesh(\n                    hullMesh, waterAngle, waterOffset, True, needInverse)\n                thisLoss = (DisplacedWaterWeight - hullWeight) / hullWeight\n                if finalMode:\n                    print(\n                        \'\\nDone \\nLoss= \',\n                        thisLoss.item() * 100,\n                        \'%\',\n                        \'\\nOffset = \',\n                        waterOffset)\n                return [\n                    waterOffset,\n                    unSubmergedMesh,\n                    SubmergedMesh,\n                    waterLineMesh,\n                    thisLoss,\n                    noWaterMesh]\n            else:\n                if thisLoss < 0 and not(needInverse):\n                    waterOffsetLowerBound = waterOffset\n                    waterOffset = int(\n                        (waterOffset + waterOffsetUpperBound) / 2)\n                elif thisLoss < 0 and needInverse:\n                    waterOffsetUpperBound = waterOffset\n                    waterOffset = int(\n                        (waterOffset + waterOffsetLowerBound) / 2)\n                elif thisLoss > 0 and not(needInverse):\n                    waterOffsetUpperBound = waterOffset\n                    waterOffset = int(\n                        (waterOffset + waterOffsetLowerBound) / 2)\n                else:\n                    waterOffsetLowerBound = waterOffset\n                    waterOffset = int(\n                        (waterOffset + waterOffsetUpperBound) / 2)\n                lastLoss = thisLoss.item()\n\n    # degreeAngle = 120  # degree\n\n    waterAngle = np.deg2rad(degreeAngle)\n\n    waterOffset, unSubmergedMesh, SubmergedMesh, waterLineMesh, Loss, noWaterMesh = calculBestWaterOffsetMesh(\n        hullMesh, waterAngle, hullWeight)\n\n    HullSubmergedMesh = (noWaterMesh.float() < 0.5).float() * SubmergedMesh\n\n    [xCOB, yCOB, zCOB] = calculCOM(HullSubmergedMesh)\n\n    FBuoyancy = FGravity = (hullWeight * gravity).item()\n\n    buoyancyTorqueVector = np.cross([(yCOB - yCOM).item() * precision,\n                                     (zCOB - zCOM).item() * precision,\n                                     0],\n                                    [-FBuoyancy * np.sin(waterAngle),\n                                        FBuoyancy * np.cos(waterAngle), 0])\n\n    buoyancyTorque = buoyancyTorqueVector[2]\n\n    if finalMode:\n        print(\n            \'\\nBuoyancy Torque under \',\n            degreeAngle,\n            \' degrees: \',\n            buoyancyTorque,\n            \' N * M\\n\')\n\n        print(\'COM: \', list(map(lambda x: x.item(), [xCOM, yCOM, zLen - zCOM])))\n        print(\'COB: \', list(map(lambda x: x.item(), [xCOB, yCOB, zLen - zCOB])))\n\n        if(buoyancyTorque > 0):\n            print(\'\\nIt can recover\\n\')\n\n        plt.figure(1)\n        plt.matshow(fliTrans(SubmergedMesh[MidIndexX, :, :] > 0).cpu().numpy())\n        plt.title(\'Submerged_yz \' + str(degreeAngle))\n        plt.show()\n\n        plt.figure(2)\n        plt.matshow(fliTrans(hullMesh[MidIndexX, :, :] > 0).cpu().numpy())\n        plt.title(\'yz \' + str(degreeAngle))\n        plt.show()\n\n        plt.figure(3)\n        plt.matshow(fliTrans(hullMesh[:, MidIndexY, :] > 0).cpu().numpy())\n        plt.title(\'xz\')\n        plt.show()\n\n    zWeightArray = torch.sum(hullMesh > 0, dim=(1, 0))\n    xNoZeroIndexArray = (torch.sum(hullMesh, dim=(1, 2)) > 0).nonzero()\n    yNoZeroIndexArray = (torch.sum(hullMesh, dim=(2, 0)) > 0).nonzero()\n\n    boatHeightIndex = (\n        (zWeightArray[:zLen - 2] - 1.1 * zWeightArray[1:zLen - 1]) > 0).nonzero()[-2][0]\n    if finalMode:\n        plt.figure(4)\n        plt.matshow((fliTrans(hullMesh[:, :, boatHeightIndex]) > 0).cpu().numpy())\n        plt.title(\'xy\')\n        plt.show()\n    if loopIter == 0:\n        print(\n            \'The height of Boat is: \',\n            (boatHeightIndex -\n             (zWeightArray > 0).nonzero()[0][0]).item() *\n            precision)\n        print(\'The Length of Boat is: \',\n              (xNoZeroIndexArray[-1][0] - xNoZeroIndexArray[0][0]).item() * precision)\n        print(\'The Width of Boat is: \',\n              (yNoZeroIndexArray[-1][0] - yNoZeroIndexArray[0][0]).item() * precision)\n    if finalMode:\n        synthesisMap = noWaterMesh + (hullMesh[MidIndexX, :, :] > 0).float()\n        synthesisMap[xCOM - 2:xCOM + 2:, yCOM - 2:yCOM + 2, zCOM - 2:zCOM + 2] += 1\n        synthesisMap[xCOB - 2:xCOB + 2, yCOB - 2:yCOB + 2, zCOB - 2:zCOB + 2] += 1\n\n        plt.figure(5)\n        plt.matshow(fliTrans(synthesisMap[xCOM, :, :]).cpu().numpy())\n        plt.title(\'synthesisMap\')\n        plt.show()\n\n        poolingOpt = torch.nn.AdaptiveAvgPool3d(200)\n        PureHullMeshNoDeck, PureDeckMesh, PureMastMesh = list(map(lambda x:poolingOpt(x.unsqueeze(\n            0)).squeeze().nonzero().cpu().numpy(), [PureHullMeshNoDeck, PureDeckMesh, PureMastMesh]))\n\n        plt.figure(6)\n        ax = plt.subplot(111, projection=\'3d\')\n        ax.scatter(PureHullMeshNoDeck[:, 0], PureHullMeshNoDeck[:, 1], PureHullMeshNoDeck[:, 2], c=\'b\')\n        # ax.scatter(PureDeckMesh[:, 0], PureDeckMesh[:, 1], PureDeckMesh[:, 2], c=\'w\')\n        ax.scatter(PureMastMesh[:, 0], PureMastMesh[:, 1], PureMastMesh[:, 2], c=\'y\')\n        ax.set_zlabel(\'Z\')\n        ax.set_ylabel(\'Y\')\n        ax.set_xlabel(\'X\')\n        plt.show()\n\n    RightMomentList[loopIter] = buoyancyTorque\n\n    torch.cuda.empty_cache()\n\nprint(\'RightMomentList: \', RightMomentList)\n'"
plotAlgebraic3DHull.py,5,"b""from matplotlib import pyplot as plt\r\nimport numpy as np\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\n\r\n\r\nx, y, L, B, D = 1, 1, 1, 1, 4\r\n\r\nPrecision = 101\r\nMidIndex = (Precision - 1) / 2\r\n\r\nxArray = np.linspace(-0.5, 0.5, Precision)\r\nyArray = np.linspace(-1, 1, Precision)\r\n\r\nxGrid, yGrid = np.meshgrid(xArray, yArray)\r\nzGrid = D * (np.power(2 * xGrid / L, 4) + np.power(2 * yGrid / B, 2))\r\nDPlane = np.zeros(zGrid.shape) + D\r\n\r\nfig1 = plt.figure(1)\r\nax = Axes3D(fig1)\r\n\r\nax.plot_surface(xGrid, yGrid, zGrid, rstride=1, cstride=1, cmap='rainbow')\r\n#ax.plot_surface(xGrid, yGrid, DPlane, rstride=1, cstride=1, cmap='rainbow')\r\n\r\nplt.show()\r\n\r\nfig2 = plt.figure(2)\r\n\r\nxNow = xGrid[:, MidIndex]\r\nyNow = yGrid[:, MidIndex]\r\nzNow = zGrid[:, MidIndex]\r\n\r\nplt.plot(yNow, zNow)\r\n\r\n# plt.show()\r\n\r\n#fig3 = plt.figure(3)\r\n\r\nxNow = xGrid[:, 0]\r\nyNow = yGrid[:, 0]\r\nzNow = zGrid[:, 0]\r\n\r\nplt.plot(yNow, zNow)\r\n\r\nplt.show()\r\n\r\nfig4 = plt.figure(4)\r\n\r\nxNow = xGrid[MidIndex, :]\r\nyNow = yGrid[MidIndex, :]\r\nzNow = zGrid[MidIndex, :]\r\n\r\nplt.plot(xNow, zNow)\r\n\r\nplt.show()\r\n\r\nfig5 = plt.figure(5)\r\n\r\ncontour = plt.contour(xGrid, yGrid, zGrid, [D], colors='k')\r\n\r\nplt.clabel(contour, fontsize=10, colors='k')\r\n\r\n#plt.contourf(xGrid, yGrid, zGrid)\r\n\r\n#plt.contour(xGrid, yGrid, zGrid)\r\n\r\nplt.show()\r\n"""
