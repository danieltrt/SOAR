file_path,api_count,code
setup.py,0,"b'from setuptools import setup\nfrom nsvision import __version__\nwith open(""README.md"", ""r"") as fh:\n    long_description = fh.read()\n\nclassifiers = [\n    ""Topic :: Scientific/Engineering :: Artificial Intelligence"",\n    ""Programming Language :: Python :: 3.6"",\n    ""Programming Language :: Python :: 3.7"",\n    ""License :: OSI Approved :: MIT License"",\n    ""Topic :: Utilities"",\n]\n\nCONSOLE_SCRIPTS = [\n    \'split_data = nsvision.tools.split_data:main\',\n    \'split_data_gui = nsvision.tools.split_data_gui:main\',\n    \'rename_files = nsvision.tools.rename_files:main\',\n    \'tumor_data_extractor = nsvision.tools.tumor_data_extractor:main\',\n]\n\nsetup(\n    name=""nsvision"",\n    version=__version__,\n    python_requires="">=3.6"",\n    description=""nsvision - Computer Vision Wrapper built on top of PIL, cv2 and Numpy"",\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    url=""https://github.com/Nsemble/nsvision"",\n    author=""Nsemble.ai"",\n    author_email=""admin@nsemble.ai"",\n    license=""MIT"",\n    packages=[""nsvision"", ""nsvision.tools""],\n    install_requires=[\n        \'numpy==1.18.3\',\n        \'Pillow==7.0.0\'\n    ],\n    classifiers=classifiers,\n    entry_points={\n        \'console_scripts\': CONSOLE_SCRIPTS,\n    },\n)\n'"
nsvision/__init__.py,0,b'from ._version import version as __version__\nfrom .image_utils import *\nfrom .video_utils import live_video\n'
nsvision/_version.py,0,"b'#Library version\nversion = ""0.0.9""'"
nsvision/classifier.py,0,"b'import os \nfrom shutil import copy2\nfrom random import sample\nfrom numpy import array as nparray\nfrom nsvision import get_image_from_array\ntry:\n\tfrom natsort import natsorted\n\tfrom h5py import File as h5py_file\nexcept:\n\tnatsorted = None\n\th5py_file = None\n\n\ndef check_ratio_sum(ratio):\n\t""""""\n\tCheck the given ratio is valid or not. Sum of ratio should be 100\n\t""""""\n\n\ttrain_ratio = int(ratio[0])\n\tval_ratio = int(ratio[1])\n\ttest_ratio = int(ratio[2])\n\tqa_ratio = int(ratio[3])\n\ttotal = train_ratio + test_ratio + val_ratio + qa_ratio\n\tif total != 100:\n\t\traise ValueError(""Sum of all the input ratio should be equal to 100 "")\n\treturn train_ratio, val_ratio, test_ratio, qa_ratio\n\n\ndef image_frequency(num,ratio):\n\t""""""\n\tFind the frequency per class\n\tParameter\n\t---------\n\tnum: Total number of images\n\tratio: split ratio\n\t""""""\n\tratio = ratio/100\n\treturn round( num * ratio, 0 )\n\n\ndef split_image_data(data_dir,ratio,generate_labels_txt=False):\n\t""""""\n\tDivides image data required for classification according to Train, Test, Validation and QA\n\n\tParameters:\n\tdata_dir:  path to image data folder\n\tratio: Tuple ratio\n\tgenerate_labels_txt: set to True if you want to generate labels.txt for the classes.\n\t\tDefault(False)\n\t""""""\n\tif not isinstance(ratio, tuple):\n\t\traise TypeError(f""ratio should be tuple of (train,val,test,qa) but got {ratio} of type {type(ratio)} instead"")\n\n\tif len(ratio) != 4:\n\t\traise ValueError(f""required ratio to be of length 4 but got length {len(ratio)} instead"")\n\t#ratio \n\ttrain_ratio, val_ratio, test_ratio, qa_ratio = check_ratio_sum(ratio)\n\n\t#making new_dir to save divided data\n\tfolder_name = os.path.splitext(os.path.basename(data_dir))[0]\n\tnew_folder = folder_name + ""_classified_data""\n\tmodel_data_dir = os.path.join(os.path.dirname(data_dir),new_folder)\n\tos.makedirs(model_data_dir,exist_ok = True)\n\n\tos.makedirs(os.path.join(model_data_dir,""train""),exist_ok = True)\n\tos.makedirs(os.path.join(model_data_dir,""test""),exist_ok = True)\n\tos.makedirs(os.path.join(model_data_dir,""val""),exist_ok = True)\n\tos.makedirs(os.path.join(model_data_dir,""qa""),exist_ok = True)\n\n\tfolder_names = [\'train\',\'val\',\'test\',\'qa\']\n\n\t#dividing the data into given ratio\n\tclasses_list = os.listdir(data_dir)\n\n\tprint(""Total number of classes"",len(classes_list))\n\ttry:\n\t\tfor class_name in classes_list:\n\t\t\tclass_path = os.path.join(data_dir,class_name)\n\t\t\t\n\t\t\tclass_images = os.listdir(class_path)\n\t\t\t\n\t\t\ttotal_class_images = len(class_images)\n\n\t\t\ttotal_train_images = image_frequency(total_class_images,train_ratio)\n\t\t\ttotal_val_images = image_frequency(total_class_images,val_ratio)\n\t\t\ttotal_test_images = image_frequency(total_class_images,test_ratio)\n\t\t\ttotal_qa_images = image_frequency(total_class_images,qa_ratio)\n\n\t\t\tratio_list = [total_train_images,total_val_images,total_test_images,total_qa_images]\n\n\t\t\tclass_images_new = class_images\n\t\t\tclass_images_new = sample(class_images_new,len(class_images_new))\n\n\t\t\tdiv1 = total_train_images\n\t\t\tdiv2 = div1 + total_val_images\n\t\t\tdiv3 = div2 + total_test_images\n\t\t\tprint(f""\\nData divided for class {class_name} as follows:-"",f""Train: {div1}"",f""Validation: {div2 - div1}"", f""Test: {div3 -div2}"",f""QA: {total_class_images - div3}\\n"",sep=\'\\n\')\n\t\t\ttrain_list = class_images_new[:int(div1)]\n\t\t\tval_list = class_images_new[int(div1):int(div2)]\n\t\t\ttest_list = class_images_new[int(div2):int(div3)]\n\t\t\tqa_list = class_images_new[int(div3):]\n\t\t\tsplit_lst = [train_list,val_list,test_list,qa_list]\n\t\t\tfor i,j in zip(folder_names,split_lst):\n\t\t\t\tfor img in j:\n\t\t\t\t\timg_path = os.path.join(class_path,img)\n\t\t\t\t\tif os.path.isfile(img_path):\n\t\t\t\t\t\t# src_path = os.path.join(class_path,img)\n\t\t\t\t\t\tdst_path = os.path.join(os.path.join(model_data_dir,i),class_name)\n\t\t\t\t\t\tos.makedirs(dst_path,exist_ok=True)\n\t\t\t\t\t\tcopy2(img_path,dst_path)\n\t\tif generate_labels_txt:\n\t\t\tprint(""Generating labels.txt"")\n\t\t\twith open(os.path.join(os.path.dirname(data_dir),\'labels.txt\'),\'w\') as labels_file:\n\t\t\t\tlabels_file.write(""\\n"".join(classes_list))\n\texcept:\n\t\traise Exception(""Failed to split data please check folder structure or check your OS Permission"")\n\tprint(""Splitting completed"",f""Splitted data is stored at {model_data_dir}"",sep=\'\\n\')\n\n\ndef rename_files(name,folder_path,number):\n\t""""""\n\tRename the files in the given folder path\n\tParameter\n\t---------\n\tpath - folder path\n\tname - common name for renaming\n\tnumber - number from which renaming is to start\n\t""""""\n\tif natsorted is None:\n\t\traise ImportError(""natsorted is required""\n\t\t\t""Install it using `pip install natsort`"")\n\n\n\tfolder_name = os.path.splitext(os.path.basename(folder_path))[0]\n\tnew_folder = folder_name + ""_renamed""\n\tdst_path = os.path.join(os.path.dirname(folder_path),new_folder)\n\tos.makedirs(dst_path,exist_ok = True)\n\tfor i,filename in enumerate(natsorted(os.listdir(folder_path)),number):\n\t\told_path = os.path.join(folder_path,filename)\n\t\ttry:\n\t\t\textension = os.path.splitext(os.path.basename(old_path))[1]\n\t\t\tif extension != \'\':\n\t\t\t\tnew_name = f""{name}_{i}{extension}""\n\t\t\t\tnew_path = os.path.join(dst_path,new_name)\n\t\t\t\tcopy2(old_path,new_path)\n\t\texcept:\n\t\t\traise Exception(""Failed to rename the files in the given folder please check the folder structure or os permission"")\n\tprint(""Renaming completed"",f""Renamed files are stored at {dst_path}"",sep=\'\\n\')\n\n\ndef get_image_from_mat(mat_filepath):\n\t""""""\n\tThis function convert .mat file to pil image\n\tArguments  -\n\tInput - 1. matfile path (type - str)\n\t\t\t2. data (type - boolean)\n\n\tOutput - pil_image, cjdata\n\t""""""\n\tif h5py_file is None:\n\t\traise ImportError(""h5py is required""\n\t\t\t""Install using `pip install h5py`"")\n\n\n\tmat_file =  h5py_file(mat_filepath,\'r\')\n\tcjdata = mat_file[\'cjdata\']\n\timage_array = nparray(cjdata.get(\'image\')).astype(""float64"")\n\tnv_image = get_image_from_array(image_array)\n\tlabel = cjdata.get(\'label\')[0][0]\n\treturn nv_image, label\n'"
nsvision/image_utils.py,0,"b'from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom io import BytesIO\nfrom warnings import warn\nfrom re import sub\nfrom base64 import b64encode,b64decode\n\n# Specify which functions to be imported to be used with nv as nv.__functionname__()\n# Functions included in __all__ will be imported on calling ""from nsvision.image_utils import *""\n# While creating a new function, don\'t forget to mention below incase you want to use with nv as nv.new_func()\n__all__ = [\n    ""imread"",""imurl"", ""load_image_as_object"", # image reading functions\n    ""expand_dims"",""reduce_dims"", # functions having numpy array operations \n    ""imshow"",""get_image_from_array"", # functions retriving / displaying images\n    ""imsave"", # functions writing image  \n    ""base64_to_bytes"",""image_to_base64"", # functions performing base64 operations\n]\n\n\ntry:\n    import requests as request_image\nexcept ImportError:\n    request_image = None\ntry:\n    from PIL import Image as pilimage\n    from numpy import asarray as toarray\n    from numpy import expand_dims as expand\n    from numpy import squeeze\n    from numpy import max as npmax\n    from numpy import min as npmin\nexcept ImportError:\n    raise ImportError(\'Could not import PIL.Image. or Numpy \'\n        \'This library requires PIL >= 7.0.0 and numpy >= 1.18.1\')\n\n\ninterpolation_methods = {\n        \'nearest\': pilimage.NEAREST,\n        \'bilinear\': pilimage.BILINEAR,\n        \'bicubic\': pilimage.BICUBIC,\n        \'hamming\': pilimage.HAMMING,\n        \'box\': pilimage.BOX,\n        \'lanczos\': pilimage.LANCZOS\n}\n\n\ndef imread(image_path,resize=None,color_mode = None,interpolation=\'nearest\',dtype=\'float32\',return_original = False,normalize=False):\n    """"""Converts a PIL Image instance to a Ndarray optimised for model.\n    Parameters\n    ----------\n        image_path: Image Path or bytes.\n        resize: (width,height) tuple\n        color_mode: default is None\n            you can also use color_mode as `rgb` or `rgba` or `grayscale`\n        interpolation:\n            Interpolation method used to resample the image if the\n            target size is different from that of the loaded image.\n            Supported methods are ""nearest"", ""bilinear"", and ""bicubic"".\n            If PIL version 1.1.3 or newer is installed, ""lanczos"" is also\n            supported. If PIL version 3.4.0 or newer is installed, ""box"" and\n            ""hamming"" are also supported.\n            Default: ""nearest"".\n        dtype: Dtype to use for the returned array.\n            Default: float32\n\n        return_original: Returns original image array along with resized image array.\n            Default: False\n            Note: This parameter only works with resize parameter\n\n        normalize: Returns normalized image if set to True\n            Default: False\n    # Returns\n        A 3D Numpy array.\n    # Raises\n        ValueError: if invalid `image_path` or `resize` or `color_mode` or `interpolation` or `dtype` is passed.\n        ValueError: if return_original is True and resize is None\n    """"""\n    image = pilimage.open(image_path)\n    if color_mode is not None:\n        if color_mode == \'grayscale\':\n            if image.mode not in (\'L\', \'I;16\', \'I\'):\n                image = image.convert(\'L\')\n        elif color_mode == \'rgba\':\n            if image.mode != \'RGBA\':\n                image = image.convert(\'RGBA\')\n        elif color_mode == \'rgb\':\n            if image.mode != \'RGB\':\n                image = image.convert(\'RGB\')\n        else:\n            raise ValueError(\'color_mode must be ""grayscale"", ""rgb"", or ""rgba""\')\n        \n    if resize is not None:\n        if not isinstance(resize,tuple):\n            raise TypeError(f\'resize must be tuple of (width,height) but got {resize} of type {type(resize)} instead\')\n\n        if len(resize) != 2:\n            raise ValueError(f\'Tuple with (width,height) required but got {resize} instead.\')\n\n        original_image_array = toarray(image,dtype=dtype)\n        if image.size != resize:\n            if interpolation not in interpolation_methods:\n                raise ValueError(f\'Invalid interpolation, currently supported interpolations:{interpolation_methods.keys()}\')\n            resample = interpolation_methods.get(interpolation)\n            image = image.resize(resize, resample)\n    \n    image_array = toarray(image,dtype=dtype)\n\n    if normalize:\n        image_array /= 255.\n    \n    if return_original:\n        if resize is None:\n            raise ValueError(""return_original parameter only works with resize parameter"")\n        return original_image_array , image_array\n    \n    return image_array\n\n\ndef load_image_as_object(image_path,color_mode=None,interpolation=\'nearest\',resize=None):\n    """"""Loads image as PIL object\n    image_path: path or bytes like object\n    Parameters\n    ----------\n        image_path: Image Path or bytes.\n        resize: (width,height) tuple\n        color_mode: default is None\n            you can also use color_mode as `rgb` or `rgba` or `grayscale`\n        interpolation:\n            Interpolation method used to resample the image if the\n            target size is different from that of the loaded image.\n            Supported methods are ""nearest"", ""bilinear"", and ""bicubic"".\n            If PIL version 1.1.3 or newer is installed, ""lanczos"" is also\n            supported. If PIL version 3.4.0 or newer is installed, ""box"" and\n            ""hamming"" are also supported.\n            Default: ""nearest"".\n\n    # Returns\n        A pil image object\n    # Raises\n        ValueError: if invalid `image_path` or `resize` or `color_mode` or `interpolation` is passed.    \n    """"""\n    image = pilimage.open(image_path)\n    if color_mode is not None:\n        if color_mode == \'grayscale\':\n            if image.mode not in (\'L\', \'I;16\', \'I\'):\n                image = image.convert(\'L\')\n        elif color_mode == \'rgba\':\n            if image.mode != \'RGBA\':\n                image = image.convert(\'RGBA\')\n        elif color_mode == \'rgb\':\n            if image.mode != \'RGB\':\n                image = image.convert(\'RGB\')\n        else:\n            raise ValueError(\'color_mode must be ""grayscale"", ""rgb"", or ""rgba""\')\n        \n    if resize is not None:\n        if not isinstance(resize,tuple):\n            raise TypeError(f\'resize must be tuple of (width,height) but got {resize} of type {type(resize)} instead\')\n\n        if len(resize) != 2:\n            raise ValueError(f\'Tuple with (width,height) required but got {resize} instead.\')\n\n        if image.size != resize:\n            if interpolation not in interpolation_methods:\n                raise ValueError(f\'Invalid interpolation, currently supported interpolations:{interpolation_methods.keys()}\')\n            resample = interpolation_methods.get(interpolation)\n            image = image.resize(resize, resample)\n    return image\n\n\ndef imurl(image_url, return_as_array = False , **kwargs):\n    """"""\n    Read image from url and convert to bytes or ndarray\n    \n    Paramters\n    ---------\n    image_url: http / https url of image\n    \n    return_as_array: Convert image directly to numpy array\n        default: False\n    \n    kwargs:\n        Keyword arguments of imread can be passed for image modification:\n        Example:\n            imurl(image_url,to_array=True,resize=(224,224),color_mode = \'rgb\',dtype=\'float32\')\n            \n        Note: kwargs only works with return_as_array = True\n        \n    Returns:\n    --------\n        PIL Image by default:\n        if return_as_array is True:\n            image will be returned as numpy array.\n        \n        Additional params like resize, color_mode, dtype , return_original can also be passed inorder to refine the image\n\n    Raises:\n    -------\n        ImportError if requests library is not installed    \n    """"""\n    if request_image is None:\n        raise ImportError(\'requests library is required from reading image from url \'\n                         \'Install it using pip install requests\')\n    \n    \n    if not image_url.startswith(\'http\'):\n        raise ValueError(f\'invalid url found. Required http or https url but got {image_url} instead\')\n        \n        \n    image_response = request_image.get(image_url)\n    imbytes = BytesIO(image_response.content)\n    \n    if return_as_array:\n        return imread(imbytes,**kwargs)\n    \n    image = pilimage.open(imbytes)\n    \n    return image\n\n\ndef expand_dims(array,axis=0,normalize=False):\n    """"""Expand the shape of an array.\n\n    Insert a new axis that will appear at the `axis` position in the expanded\n    array shape.\n\n    Parameters\n    ----------\n    array : numpy array.\n    axis : int or tuple of ints\n    Position in the expanded axes where the new axis is placed\n    normalize: \n        True : return normalized image\n        False : return just image array with expanded dimensions \n    """"""\n    array = expand(array,axis=axis)\n    if normalize:\n        array /= 255.\n    return array\n\n\ndef get_image_from_array(img_array, denormalize=True, dtype=\'float32\' ,is_cv2_image = False):\n    """"""Converts numpy image array to a PIL Image instance.\n    Parameters\n    ----------\n        img: Input Numpy image array.\n        denormalize: Revert back normalized image to unnormalized form\n            Default: True.\n        dtype: Dtype to use.\n            Default: ""float32"".\n        is_cv2_image: Set to True if image is loaded using cv2\n            Default: False\n    Returns\n    -------\n        A PIL Image.\n    Raises\n    ------\n        Raises TypeError if image_array is not an numpy ndarray\n    """"""\n    if not hasattr(img_array, \'ndim\'):\n        raise TypeError(f\'Required image_array to be of type numpy.ndarray but got {type(img_array)} instead\')\n\n    if img_array.ndim != 3:\n        if img_array.ndim == 2:\n            """"""expand image dimensions only if image is 2D grayscale\n            manually adding channel dimension `1` to image (only for 2D grayscale image)""""""\n            img_array = expand_dims(img_array,axis=2)\n        else:\n            raise ValueError(f\'Expected array with 3 dimensions Got array with shape {img_array.shape}\\n\'\n                \'Incase you have used expand_dims for preprocessing, use nv.reduce_dims() for reducing expanded dimensions\\n\'\n                \'make sure to check the axis position while expanding or reducing dimensions.\')\n\n    if is_cv2_image: #If numpy array is cv2 image\n        img_array = img_array[...,::-1] #Convert BGR to RGB\n\n    img_array = toarray(img_array,dtype=dtype)\n    # Original Numpy array x has format (height, width, channel)\n    # or (channel, height, width)\n    # but target PIL image has format (width, height, channel)\n\n    if denormalize:\n        img_array = img_array - npmin(img_array)\n        img_max = npmax(img_array)\n        if img_max != 0:\n            img_array /= img_max\n        img_array *= 255\n    if img_array.shape[2] == 4: #RGBA Image\n        return pilimage.fromarray(img_array.astype(\'uint8\'), \'RGBA\')\n    elif img_array.shape[2] == 3: #RGB image\n        return pilimage.fromarray(img_array.astype(\'uint8\'), \'RGB\')\n    elif img_array.shape[2] == 1: # grayscale image\n        if npmax(img_array) > 255:\n            # 32-bit signed integer grayscale image. PIL mode ""I""\n            return pilimage.fromarray(img_array[:, :, 0].astype(\'int32\'), \'I\')\n        return pilimage.fromarray(img_array[:, :, 0].astype(\'uint8\'), \'L\')\n    else:\n        raise ValueError(f\'Channel {img_array.shape[2]} not supported\')\n\n\ndef imshow(image,is_cv2_image=False):\n    """"""\n    Displays image in new window\n    Parameters\n    image: PIL or CV2 image array\n    is_cv2_image: If image_array is processed using cv2\n    """"""\n    if hasattr(image,\'show\'):\n        image.show()\n    else:\n        get_image_from_array(image,is_cv2_image=is_cv2_image).show()\n\n\ndef imsave(path,image,file_format = None ,is_cv2_image=False,denormalize=True,**kwargs):\n    """"""\n    Write image array or instance to a file.\n    Parameters\n    ----------\n    path: Location for writing image file\n    image: image array\n    file_format: file_format for image\n    is_cv2_image: Set to True if image is loaded using cv2 \n        Default: False\n    denormalize: Set to True if image was normalized during preprocessing\n        Default: True\n    kwargs:\n        other keyword args if required by PIL\n    """"""\n    if hasattr(image,\'save\'): \n        image.save(path,file_format=file_format,**kwargs)\n    else:\n        image = get_image_from_array(image, denormalize=denormalize , is_cv2_image=is_cv2_image)\n        if image.mode == \'RGBA\' and (file_format == \'jpg\' or file_format == \'jpeg\'):\n            warn(\'JPG format does not support RGBA images, converting to RGB.\')\n            image = image.convert(\'RGB\')\n        image.save(path, format=file_format, **kwargs)\n\n\ndef reduce_dims(array,axis=0):\n    """"""\n    Reduce array dimensions at given axis\n    Note: If trying on image array please check if expand_dims \n          is used by you during image preprocessing and axis too.\n\n    Parameters\n    ----------\n    array: numpy nd array\n    axis : int or tuple of ints\n    Position in the expanded axes where the new axis is placed.\n    default: 0\n    """"""\n    return squeeze(array,axis=axis)\n\n\ndef base64_to_bytes(base64_encoded_image):\n    """"""\n    Convert base64 image data to PIL image\n\n    Parameters\n    ----------\n    base64_encoded_image: base64 encoded image\n\n    Returns\n    -------\n    Decoded image as Bytes Array\n    """"""\n    image_data = sub(\'^data:image/.+;base64,\', \'\', base64_encoded_image)\n    return BytesIO(b64decode(image_data))\n\n\ndef image_to_base64(image,file_format=\'PNG\'):\n    """"""\n    Convert image from array to base64 string\n    Parameters\n    ----------\n    image: path or pil image object\n\n    file_format: file format of image\n    \n    Returns\n    -------\n    base64 encoded image as string\n    """"""\n    if isinstance(image,str):\n        image = load_image_as_object(image)\n\n    buffered = BytesIO()\n    image.save(buffered, format=file_format)\n    return u""data:image/png;base64,"" + b64encode(buffered.getvalue()).decode(""ascii"")'"
nsvision/video_utils.py,0,"b'try:\n\timport cv2\nexcept:\n\tcv2 = None\n\ndef live_video(source=0,color_mode=None,resize=None,preprocess_function=None):\n\t""""""\n\tDisplays live stream on window. You can press `q` to stop.\n\tParameters:\n\t\tsource: Camera port default is 0\n\t\tcolor_mode: convert image to \'rgb\' or \'grayscale\'\n\t\tresize: (height , width) tuple resize incoming video frame\n\t\tpreprocess_function: Submit preprocessing function if you need extra preprocessing for image\n\t\tPreprocessing Function Syntax:\n\t\t#defining function\n\t\tdef preprocessing_function(frame): #RGB frame as input\n\t\t\t// do preprocessing stuff here\n\t\t\treturn processed_frame (image as ndarray)\n\n\t\t#submitting to nv.live_video()\n\t\tnv.live_video(preprocessing_function)\n\t""""""\n\n\tif cv2 is None:\n\t\traise ImportError(\'OpenCV is required for running this function\\n\'\n\t\t\t\'Please install cv2 using `pip install opencv-python`\')\n\n\tvideo = cv2.VideoCapture(source)\n\n\tframe_height = int(video.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\tframe_width = int(video.get(cv2.CAP_PROP_FRAME_WIDTH))\n\twhile True:\n\t\t# Capture frame-by-frame\n\t\tretval, frame = video.read()\n\n\t\tif resize is not None:\n\t\t\tif not isinstance(resize, tuple):\n\t\t\t\traise ValueError(f\'resize must be tuple of (height,width) but got {resize} instead\')\n\t\t\tif (frame_height,frame_width) != resize:\n\t\t\t\tframe = cv2.resize(frame,resize)\n\t\t\n\t\tif color_mode is not None:\n\t\t\tif color_mode == \'rgb\':\n\t\t\t\tframe = frame[...,::-1] #convert image to RGB\n\t\t\telif color_mode == \'grayscale\':\n\t\t\t\tframe = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) #convert image to grayscale\n\t\t\telse:\n\t\t\t\traise ValueError(f\'Expected color_mode to be `rgb` or `grayscale` or None but got {color_mode} instead\')\n\t\tif callable(preprocess_function): #check if preprocess_function is present\n\t\t\tframe = preprocess_function(frame)\n\n\t\t# Display the resulting frame\n\t\tcv2.imshow(\'frame\', frame) #show image on screen\n\n\t\tif cv2.waitKey(1) & 0xFF == ord(\'q\'):\n\t\t\tbreak\n\n\t# When everything is done, release the capture\n\tvideo.release()\n\tcv2.destroyAllWindows()'"
tests/__init__.py,0,b''
nsvision/tools/rename_files.py,0,"b'import sys\nimport argparse\nfrom nsvision import classifier\n\ndescription = """"""\nThis script renames the files in the folder. \nRename format is as follow- {fix_name}_{number}.{extension}\nThere will be a fix or common name for all the files in the folder followed\nby a unique number and with the orignal file extension.\nThe folder should contain only files (like images,txt).\n""""""\n\nparser =  argparse.ArgumentParser(\n\t\tdescription = description,\n        usage = ""Rename the files in the given folder"",\n        formatter_class=argparse.RawTextHelpFormatter\n)\n\nrequired_args = parser.add_argument_group(\'required arguments\')\n\nrequired_args.add_argument(\n\t\t""-n"",\n\t\t""--name"",\n\t\trequired = True,\n\t\thelp = ""Common name for all the files to be rename""\n)\n\t\nrequired_args.add_argument(\n\t\t""-f"",\n\t\t""--folder_path"",\n\t\trequired=True,\n\t\thelp=\'Path of the folder in which files to be rename""\'\n)\n\nparser.add_argument(\n    ""-i"",\n    ""--number"",\n    default = 1,\n    help=\'Number from which renaming is to start\'\n)\n\ndef main():\n\targs = parser.parse_args()\n\tprint(""Renaming files in the folder"",f""folder path: {args.folder_path}\\n"",sep=\'\\n\')\n\tclassifier.rename_files(\n\t\tname = args.name,\n\t\tfolder_path=args.folder_path,\n\t\tnumber=int(args.number))\n\nif __name__ == \'__main__\':\n\tsys.exit(main())'"
nsvision/tools/split_data.py,0,"b'import sys\nimport argparse\nfrom nsvision import classifier\n\ndescription = """"""\nThis script is specifically design for image classification task\nto do image classification we need data into a specific format\nthis script divide the data folder containing class folder  into train, validation, test and qa folders.\nThe input folder shoud have the following format:\ndata/\n\tclass1/\n\t\timg1\n\t\timg2\n\t\t....\n\tclass2/\n\t\timg1\n...........\nIn order to give output in this format\nclassified_data/\n\ttrain/\n\t\tclass1/\n            img1\n\t\t\timg11\n            ....\n        class2/\n            img1\n            img2\n            ....\n    test/\n\t\tclass1/\n\t\t\timg1....\nthe order of splitting the data is train,validation,test and quality_assurance \nif anyone wants to divide the data only in two or three category, then let other value be zero\nthis works on any file types.\n""""""\n\nparser =  argparse.ArgumentParser(\n\t\tdescription = description,\n\t\tusage = ""Divide image data folder into train, validation, test and qa for image classification"",\n\t\tformatter_class=argparse.RawTextHelpFormatter\n)\n\nrequired_args = parser.add_argument_group(\'required arguments:\')\n\nrequired_args.add_argument(\n\t\t""-d"",\n\t\t""--data_dir"",\n\t\trequired = True,\n\t\thelp = ""Path to folder containing images""\n)\n\t\nrequired_args.add_argument(\n\t\t""-r"",\n\t\t""--ratio"",\n\t\trequired=True,\n\t\thelp=\'Tuple of ratio in the order of (train,val,test,qa) for ex class_split -r ""(70,10,10,10)""\'\n)\n\nparser.add_argument(\n\t""-l"",\n\t""--generate_labels_txt"",\n\tdefault=False,\n\thelp=\'Generate labels.txt containing class names\'\n)\n\ndef main():\n\targs = parser.parse_args()\n\tprint(""Image data splitting tool"",f""data path: {args.data_dir}\\n"",sep=\'\\n\')\n\tclassifier.split_image_data(\n\t\tdata_dir=args.data_dir,\n\t\tratio=tuple(eval(args.ratio)),\n\t\tgenerate_labels_txt=args.generate_labels_txt)\n\t\nif __name__ == \'__main__\':\n\tsys.exit(main())'"
nsvision/tools/split_data_gui.py,0,"b'import sys\nfrom tkinter import Tk, ttk, filedialog, Label, Entry, messagebox, StringVar, BooleanVar\nfrom threading import Thread\nfrom nsvision.classifier import split_image_data\nfrom pathlib import Path\n\nclass SplitDataGui(Tk):\n    def __init__(self):\n        super(SplitDataGui,self).__init__() #Initialize Tk constructor\n        self.title(""Split Data GUI"") #set gui title\n        self.minsize(900, 450) #set minimum size\n        vcmd = (self.register(self.validate))\n        \n        #variable for setting and getting input from textbox \n        self.trainvar = StringVar()\n        self.testvar = StringVar()\n        self.valvar = StringVar()\n        self.qavar = StringVar()\n        self.error_message = StringVar()\n        self.process_status = BooleanVar()\n        \n        #variable for storing source folder path, train, val, test and QA ration value\n        self.qa = None\n        self.val = None\n        self.test = None\n        self.train = None\n        self.source_browse_path = None\n        \n\n        #defining source and destination containers along with processing container\n        #for displaying browse button along with path after clicking on it\n        self.selectorLabelFrame = ttk.LabelFrame(self, text = ""Selector label frame"").grid(column = 0, row = 0)\n        \n        self.sourceLabelFrame = ttk.LabelFrame(self , text = ""Select Source Folder and set ratio"")\n        self.sourceLabelFrame.grid(column = 0, row = 0, padx = 10, pady = 50)\n        \n        self.ratioFrame = ttk.LabelFrame(self.sourceLabelFrame , text = ""Select Ratio"")\n        self.ratioFrame.grid(column = 1, row = 0, padx = 1, pady = 50)\n        \n        self.progressLabelFrame = ttk.LabelFrame(self, text = ""Main"")\n        self.progressLabelFrame.grid(column = 0 ,row = 1, padx = 30 , pady = 50)\n        \n        #Add a progress bar for displaying status\n        self.progress_bar = ttk.Progressbar(self.progressLabelFrame, orient = \'horizontal\', length = 600, mode = \'indeterminate\')\n        self.progress_bar.grid(column = 0 ,row = 0 , padx = 50 , pady = 50)\n\n        #Adding buttons for browsing source ,destination and path reset\n        self.source_button = ttk.Button(self.sourceLabelFrame, text = ""Browse"", command = self.source_browse)\n        self.source_button.grid(column = 0 ,row = 0 , padx = 10, pady = 10)\n        \n        self.set_ratio_button = ttk.Button(self.sourceLabelFrame, text = ""Set Ratio"", command = self.set_ratio).grid(column=1,row = 1, pady=10)\n        \n        \n        self.train_label = Label(self.ratioFrame, text = \'train\').grid(column = 0, row = 0)\n        self.val_label = Label(self.ratioFrame, text = \'val\').grid(column = 2, row = 0)\n        self.test_label = Label(self.ratioFrame, text = \'test\').grid(column = 0, row = 1)\n        self.qa_label = Label(self.ratioFrame, text = \'QA\').grid(column = 2, row = 1)\n        \n        \n        self.train_input_box = Entry(self.ratioFrame, state = \'normal\', textvariable=self.trainvar, validate = \'all\', validatecommand = (vcmd,\'%P\'))\n        self.train_input_box.grid(column = 1, row = 0)\n        \n        self.val_input_box = Entry(self.ratioFrame, state = \'normal\', textvariable=self.valvar, validate = \'all\', validatecommand = (vcmd,\'%P\'))\n        self.val_input_box.grid(column = 3, row = 0)\n        \n        self.test_input_box = Entry(self.ratioFrame, state = \'normal\', textvariable=self.testvar, validate = \'all\', validatecommand = (vcmd,\'%P\'))\n        self.test_input_box.grid(column = 1, row = 1)\n        \n        self.qa_input_box = Entry(self.ratioFrame, state = \'normal\',textvariable=self.qavar, validate = \'all\', validatecommand = (vcmd,\'%P\'))\n        self.qa_input_box.grid(column = 3, row = 1)\n        \n        self.reset_button = ttk.Button(self,text=""Reset"",command = self.reset)\n        self.reset_button.grid(column = 1 , row = 0 , padx = 2, pady = 50)\n        \n        self.progress_button = ttk.Button(self,text = ""Split Data"", command = self.process)\n        self.progress_button.grid(column = 1 , row = 1 , padx = 2, pady = 50)\n        \n        #label for displaying browse path for both source and destination\n        self.source_path_label = Label(self.sourceLabelFrame, wraplength=150)\n        self.source_path_label.grid(column = 0,row = 1)\n                \n\n    def source_browse(self):\n        self.source_browse_path = Path(filedialog.askdirectory()) #using Path() to get absolute path for linux as well as windows    \n        self.source_path_label.config(text = self.source_browse_path)\n\n\n    def update_input_state(self,state = ""normal""):\n        self.train_input_box.config(state=state)\n        self.test_input_box.config(state=state)\n        self.val_input_box.config(state=state)\n        self.qa_input_box.config(state=state)\n        \n        \n    def set_ratio(self):\n        self.train = int(self.trainvar.get()) if self.trainvar.get() else 0\n        self.test = int(self.testvar.get()) if self.testvar.get() else 0\n        self.val = int(self.valvar.get()) if self.valvar.get() else 0\n        self.qa = int(self.qavar.get()) if self.qavar.get() else 0\n        total = self.train + self.test + self.val + self.qa\n        if total != 100:\n            messagebox.showwarning(""Please check your ratio"", f""Total ratio must be 100 but your total ratio is {total}"")\n        else:\n            self.update_input_state(state=""readonly"")        \n        \n    \n    def clear_text(self):\n        self.train_input_box.delete(0,""end"")\n        self.val_input_box.delete(0,""end"")\n        self.test_input_box.delete(0,""end"")\n        self.qa_input_box.delete(0,""end"")\n        \n        \n    def reset_string_var(self):\n        self.trainvar.set(\'\')\n        self.testvar.set(\'\')\n        self.valvar.set(\'\')\n        self.qavar.set(\'\')\n        self.error_message.set(\'\')\n        \n    \n    def reset(self):\n        self.source_browse_path = None\n        self.process_status.set(False)\n        self.source_path_label.config(text = \'\')\n        self.progress_bar.config(value = 0)\n        self.reset_string_var()\n        self.update_input_state()\n        self.clear_text()\n        \n    \n    def validate(self, P):\n        if str.isdigit(P) or P == """":\n            return True\n        else:\n            return False\n        \n    \n    def split_data(self):\n        try:\n            split_image_data(self.source_browse_path,ratio=(self.train , self.val , self.test, self.qa))\n            self.process_status.set(True)\n        except Exception as e:\n            self.error_message.set(str(e))\n            self.process_status.set(False)\n            \n    \n    def check_thread(self):\n        if self.split_data_thread.is_alive():\n            self.after(50, self.check_thread)\n        else:\n            self.progress_bar.stop()\n            if self.process_status.get():\n                messagebox.showinfo(\'Success\',f\'Split data completed successfully\\nData is stored at {self.source_browse_path}_classified\')\n            else:\n                messagebox.showerror(\'Fail\',f\'{self.error_message.get()}\')\n\n        \n    def process(self):\n        if self.source_browse_path is None or self.train_input_box[\'state\'] == \'normal\':\n            messagebox.showwarning(""Warning"", ""Please set input path and ratio before pressing \'Split Data\'"")\n        else:\n            self.progress_bar.start()\n            self.split_data_thread = Thread(target = self.split_data)\n            self.split_data_thread.start()\n            self.after(50, self.check_thread)\n                    \ndef main():\n    split_data_gui = SplitDataGui()\n    split_data_gui.mainloop()\n\nif __name__ == \'__main__\':\n    sys.exit(main())'"
nsvision/tools/tumor_data_extractor.py,0,"b'import os\nimport sys\nimport argparse\nfrom nsvision import classifier\ntry:\n\tfrom zipfile import ZipFile as zip_file\nexcept:\n\tzip_file = None\n\ndescription = """"""\nThis python file is for the Downloaded zip file from https://ndownloader.figshare.com/articles/1512427/versions/5\nThis file converts all the .mat file in the above zip folder into the given extension file format(default .jpg)\nAll the converted files will be save in separate folder named brain_tumor_data in their respective tumor name folder\nArguments - \nInput \n1. base_dir - Filepath of zip downloaded file\n2. ext      - Extension in which mat files to be converted\n""""""\n\n\nparser =  argparse.ArgumentParser(\n\t\tdescription = description,\n        usage = ""converts all the .mat file in the given zip folder into the given extension file format(default jpg)"",\n        formatter_class=argparse.RawTextHelpFormatter\n)\n\nrequired_args = parser.add_argument_group(\'required arguments\')\n\nrequired_args.add_argument(\n\t\t""-b"",\n\t\t""--base_dir"",\n\t\trequired = True,\n\t\thelp = ""Folderpath of the zip folder downloaded from figshare""\n)\n\t\nparser.add_argument(\n\t\t""-e"",\n\t\t""--extension"",\n\t\tdefault = \'jpg\',\n\t\thelp=\'Extension of the converted image""\'\n)\n\ndef extract_zipfolder(zip_dir,unzip_dir):\n\t""""""\n\tThis function extract given zipfile""""""\n\tif zip_file is None:\n\t\traise ImportError(""zipfile is required""\n\t\t\t""Install using `pip install zipfile`"")\n\n\ttry:\n\t\tzf = zip_file(zip_dir, \'r\')\n\t\tzf.extractall(unzip_dir)\n\t\tzf.close()\n\t\treturn unzip_dir\n\texcept:\n\t\tprint(""Failed to unzip"",zip_dir)\n\n\ndef make_tumor_folder(label,dst_dir,num,ext,ns_image):\n\t""""""\n\tThis function converts save oil image into given image extension format\n\t""""""\n\ttumor_labels = {""1.0"":""meningioma"",""2.0"":""glioma"",""3.0"":""pituitary""}\n\ttumor_name = tumor_labels[str(label)]\n\ttumor_folder = os.path.join(os.path.dirname(dst_dir),""brain_tumor_data/"" + tumor_name)\n\tos.makedirs(tumor_folder,exist_ok=True)\n\tfilename = f""{tumor_name}_{num}.{ext}""\n\tdstpath = os.path.join(tumor_folder,filename)\n\tns_image.save(dstpath)\n\n\n\ndef convert_tumor_matdata_to_jpg(base_dir,extension):\n\t""""""\n\tThis function extract files from given zip folder, convert all files into jpg format\n\tand save all according to their respective classes in a dir named brain_tumor_data\n\tArguments:\n\tbase_dir - folderpath of zip folder (type - str) \n\t""""""\n\n\t\n\tif extension == \'jpg\' or extension == \'JPEG\' or extension == \'JPG\' or extension == \'jpeg\':\n\t\tprint(\'jpg supports upto 3 channels only\')\n\t\n\n\t\n\tdst_dir = os.path.join(os.path.dirname(base_dir),""tumor_mat_data"")\n\tos.makedirs(dst_dir,exist_ok=True)\n\tprint(""Extracting files from"",base_dir)\n\tbase_folder = extract_zipfolder(base_dir,dst_dir)\n\t\n\tfor folder in os.listdir(base_folder):\n\t\tfolderpath = os.path.join(base_folder,folder)\n\t\tif folderpath.endswith(\'.zip\'):\n\t\t\tfolder_name= os.path.splitext(os.path.basename(folderpath))[0]\n\t\t\tnew_path =  os.path.join(base_folder,folder_name)\n\t\t\tos.makedirs(new_path,exist_ok =True)\n\t\t\tsubbase_folder = extract_zipfolder(folderpath,new_path)\n\t\t\tfor file in os.listdir(subbase_folder):\n\t\t\t\tif file.endswith("".mat""):\n\t\t\t\t\tnum = os.path.splitext(file)[0]\n\t\t\t\t\tfilepath = os.path.join(subbase_folder,file)\n\t\t\t\t\tns_image, label = classifier.get_image_from_mat(filepath)\n\t\t\t\t\tmake_tumor_folder(label,dst_dir,num,extension,ns_image)\n\n\tprint(""Data has been saved in this directory"",os.path.join(os.path.dirname(dst_dir),""brain_tumor_data""))\n\ndef main():\n\targs = parser.parse_args()\n\tprint(""Converting all the .mat file in the given"",f""zip folder path: {args.base_dir}\\n"",sep=\'\\n\')\n\tconvert_tumor_matdata_to_jpg(args.base_dir,args.extension)\n\nif __name__ == \'__main__\':\n\tsys.exit(main())'"
