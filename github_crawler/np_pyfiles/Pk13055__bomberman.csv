file_path,api_count,code
__init__.py,0,b''
board.py,10,"b'\'\'\'\n    Contains the board class along with the methods and other features\n\'\'\'\n\nimport sys\nimport random\nfrom os import system\nfrom objects import Wall, Bomb\nfrom config import x_fac, y_fac\nimport numpy as np\nimport config\n\n\nclass Board:\n\n    \'\'\'# main board class that houses all board functions\'\'\'\n\n    def __init__(self, m, n, level):\n        \'\'\'# preferred size = (34, 76)\'\'\'\n\n        assert isinstance(n, int) == True\n        assert isinstance(m, int) == True\n\n        self.width = n\n        self.height = m\n        self.dimen = (n, m)\n        self._b = np.chararray((m, n))\n        self._b[:, :] = config._empty\n        self.frame_counter = 0\n        self.init_points = []\n        self.level = level\n\n        self.init_board()\n\n        # this stores all the bombs bricks and enemies that spawn\n        self._storage = {\n            config.types[config._bomb]: [],\n            config.types[config._bricks]: [],\n            config.types[config._enemy]: []\n        }\n\n        # this stores the player(s)\n        self.players = []\n\n    def init_board(self, reset=False):\n        \'\'\'# initialize and setup the frame of the board\'\'\'\n        if reset:\n            self.frame_counter = 0\n        # scaling the wall piece\n        w = Wall(self.width / 20, self.height / 20)\n        w_height, w_width = w.get_size()\n\n        # creating the rows\n        full_row, full_row[:, :] = \\\n            np.chararray((w_height, self.width)), config._wall\n        emp_row, emp_row[:, :] = \\\n            np.chararray((w_height, self.width)), config._empty\n        emp_row[:, :w_width] = emp_row[:, -w_width:] = w.structure\n\n        alt_row, alt_row[:, :] = \\\n            np.chararray((w_height, self.width)), config._empty\n        for c in range(1, int(self.width / w_width) + 1):\n            if c % 2:\n                alt_row[:, (c - 1) * w_width: (c * w_width)] = w.structure\n\n        # assigning top and bottom\n        self._b[:w_height, :] = self._b[-w_height:, :] = full_row\n        # assigning other rows\n        for r in range(2, int(self.height / w_height)):\n            # alt row\n            if r % 2:\n                cur_row = alt_row\n            else:\n                cur_row = emp_row\n\n            self._b[(r - 1) * w_height: (r * w_height), :] = cur_row\n\n        # create the inital points for spawning objects\n        # subtracting two edge blocks for each top bottom\n        # and dividing by two for range of motion\n        fp = (5, 3)\n        # each object is 4 px wide\n        total_block_x = int((self.width / config.x_fac - 2) / 2 + 1)\n        # each object is 2px tall\n        total_block_y = int((self.height / config.y_fac - 2) / 2 + 1)\n        for r in range(total_block_x):\n            for c in range(total_block_y):\n                self.init_points.append((fp[0] + r * (2 * config.x_fac),\n                                         fp[-1] + c * (2 * config.y_fac)))\n        self.init_points = list(set(self.init_points))\n\n    def reset_board(self):\n        \'\'\'# reset the borad at the end of a life\'\'\'\n        reset = True\n        self.init_board(reset)\n        self.clear_storage()\n\n    def update_frame(self):\n        \'\'\'# main function to check updates at every frame\'\'\'\n\n        # clean up debris of the previous bombs\n        for bomb in self._storage[config.types[config._bomb]]:\n            if not bomb.active:\n                bomb.structure[:, :] = config._empty\n                x, y = bomb.get_coords()\n                height, width = bomb.get_size()\n\n                # removing the bomb as well\n                bomb.blast_radius.insert(0, bomb.get_coords())\n\n                for x_i, y_i in bomb.blast_radius:\n                    self._b[y_i - 1: y_i - 1 + height, x_i -\n                            1: x_i - 1 + width] = config._empty\n\n                self._storage[config.types[config._bomb]].remove(bomb)\n\n        # check if any bomb needs to detonate\n        for bomb in self._storage[config.types[config._bomb]]:\n            if (not bomb.timer) and bomb.active:\n\n                bomb.structure[:, :] = config._expl\n                x, y = bomb.get_coords()\n                height, width = bomb.get_size()\n\n                for x_i, y_i in bomb.blast_radius:\n                    # if a wall blocks the way remove the blast coords\n                    try:\n                        if np.any(self._b[y_i -\n                                          1: y_i -\n                                          1 +\n                                          height, x_i -\n                                          1: x_i -\n                                          1 +\n                                          width] == Wall(0, 0).structure):\n                            raise IndexError\n                    except BaseException:\n                        if x - x_i == 1 * x_fac:\n                            bomb.blast_radius.remove((x + 2 * x_fac, y))\n                        elif x - x_i == -1 * x_fac:\n                            bomb.blast_radius.remove((x - 2 * x_fac, y))\n                        elif y - y_i == 1 * y_fac:\n                            bomb.blast_radius.remove((x, y - 2 * y_fac))\n                        elif y - y_i == -1 * y_fac:\n                            bomb.blast_radius.remove((x, y + 2 * y_fac))\n\n                        bomb.blast_radius.remove((x_i, y_i))\n                        continue\n\n                    # kill all enemies in trajectory\n                    for en in self._storage[config.types[config._enemy]]:\n                        if en.get_coords() == (x_i, y_i) and en.is_killable:\n                            self.clear_storage(en)\n                            bomb.owner.score += config.scores[config._enemy]\n                    # kill all players in trajectory\n                    for pl in self.players:\n                        if pl.get_coords() == (x_i, y_i) and pl.is_killable:\n                            pl.lives = 0\n                    # destory all bricks in trajectory\n                    for brick in self._storage[config.types[config._bricks]]:\n                        if brick.get_coords() == (x_i, y_i):\n                            self.clear_storage(brick)\n                            bomb.owner.score += config.scores[config._bricks]\n                    # detonate other bombs by chain\n                    for bmb in self._storage[config.types[config._bomb]]:\n                        if bmb.active and bmb != bomb and bmb.get_coords() in bomb.blast_radius:\n                            bmb.timer = 0\n\n                # rendering the ""explosion""\n                for x_i, y_i in bomb.blast_radius:\n                    self._b[y_i - 1: y_i - 1 + height, x_i -\n                            1: x_i - 1 + width] = config._expl\n\n                bomb.active = False\n\n        # countdown everybomb\n        for bomb in self._storage[config.types[config._bomb]]:\n            bomb.countdown()\n            self.refresh_obj(bomb)\n\n        # move the enemies randomly\n        for _ in self._storage[config.types[config._enemy]]:\n            _dir = random.choice(config.DIR)\n            self.process_input(_, _dir)\n\n        self.frame_counter += 1\n\n    def add_storage(self, obj):\n        \'\'\'# add to storage\'\'\'\n        try:\n            if obj not in self._storage[obj.get_type()]:\n                self._storage[obj.get_type()].append(obj)\n                return True\n            else:\n                return None\n        except KeyError:\n            return False\n\n    def clear_storage(self, obj=None):\n        \'\'\'# clear the objects on the board at every instance\'\'\'\n        if obj is None:\n            for object_type in self._storage:\n                for object_ in self._storage[object_type]:\n                    del object_\n                self._storage[object_type] = []\n            return True\n        else:\n            typ = obj.get_type()\n            try:\n                self._storage[typ].remove(obj)\n                return True\n            except BaseException:\n                return False\n\n    def path_check(self, obj):\n        \'\'\'# check if new binding space is occupied else if occupied\'\'\'\n\n        height, width = obj.get_size()\n        x_pos, y_pos = obj.get_coords()\n\n        emp_comp = np.chararray(obj.get_size())\n        emp_comp[:, :] = config._empty\n\n        # bomb can overwrite enemies\n        if obj.get_type() == config.types[config._bomb]:\n            for enemy in self._storage[config.types[config._enemy]]:\n                if enemy.get_coords() == obj.get_coords():\n                    self.clear_storage(enemy)\n            return True\n\n        # enemies can walk into players and kill\n        if obj.get_type() == config.types[config._enemy]:\n            for player in self.players:\n                if player.get_coords() == obj.get_coords():\n                    player.lives -= 1\n                    return True\n\n        # players can walk into enemies\n        elif obj in self.players:\n            for enemy in self._storage[config.types[config._enemy]]:\n                if obj.get_coords() == enemy.get_coords():\n                    obj.lives -= 1\n                    return True\n\n        return np.all(self._b[y_pos - 1: y_pos - 1 + height, x_pos - 1:\n                              x_pos - 1 + width] == emp_comp)\n\n    def refresh_obj(self, obj):\n        \'\'\'# refreshes the object on the board (meant to be used only with bombs)\'\'\'\n        if obj.get_type() == config.types[config._bomb]:\n            x, y = obj.get_coords()\n            height, width = obj.get_size()\n            self._b[y - 1: y - 1 + height,\n                    x - 1: x - 1 + width] = obj.structure\n            return True\n        return False\n\n    def draw_obj(self, obj):\n        \'\'\'# draws the object on the board\'\'\'\n        if self.path_check(obj):\n            height, width = obj.get_size()\n            x, y = obj.get_coords()\n            self._b[y - 1: y - 1 + height,\n                    x - 1: x - 1 + width] = obj.structure\n            return True\n\n        return False\n\n    def clear_obj(self, obj):\n        \'\'\'# clears the object from the board by an object\'\'\'\n        if obj.get_type() != config.types[config._wall]:\n            height, width = obj.get_size()\n            x, y = obj.get_coords()\n\n            # add exception for clearing the bomb\n            if np.all(self._b[y - 1: y - 1 + height, x - 1: x - 1 + width] ==\n                      Bomb(0, 0).structure):\n                return True\n\n            self._b[y - 1: y - 1 + height,\n                    x - 1: x - 1 + width] = config._empty\n            return True\n\n        return False\n\n    def attach_object(self, obj):\n        \'\'\'# size being a (height, width) tuple\'\'\'\n        if self.draw_obj(obj):\n            self.add_storage(obj)\n            return True\n        return False\n\n    def spawn(self, obj):\n        \'\'\'# method to spawn the main player\'\'\'\n        if obj.get_type() == config.types[config._bomb_man]:\n            height, width = obj.get_size()\n            x, y = obj.get_coords()\n            x, y = x - 1, y - 1\n            self._b[y: y + height, x: x + width] = obj.structure\n            self.players.append(obj)\n            return True\n        else:\n            print(""Cannot spawn non-player object"")\n            return False\n\n    def process_input(self, player, key_press):\n        \'\'\'# to process the key press and take according action\'\'\'\n        res = False\n        if key_press in config.DIR:\n            x, y = player.get_coords()\n\n            # inverted up down calc because of top left origin\n            if key_press == config.UP:\n                y -= config.y_fac\n            elif key_press == config.DOWN:\n                y += config.y_fac\n            elif key_press == config.LEFT:\n                x -= config.x_fac\n            elif key_press == config.RIGHT:\n                x += config.x_fac\n\n            res = player.update_location(self, x, y)\n\n        # place the bomb at the given location\n        elif player in self.players and key_press == config.BOMB:\n            x, y = player.get_coords()\n            if player.bombs:\n                bomb = Bomb(x, y)\n                bomb.owner = player\n                self.attach_object(bomb)\n                bomb.detonate(random.choice(config.timers[self.level]))\n                player.bombs -= 1\n            return True\n\n        return res\n\n    def is_over(self, player):\n        \'\'\'# check to see if all the enemies have been killed\'\'\'\n        if self.level:\n            if len(self._storage[config.types[config._enemy]]) == 0:\n                raise Exception(""Congratulations, all enemies killed!"")\n            elif player.bombs == 0 and \\\n                    len(self._storage[config.types[config._bomb]]) == 0:\n                raise Exception(""It\'s a tie!"")\n            elif player.lives == 0:\n                raise Exception(""No lives left! GAME OVER!"")\n        return True\n\n    def render(self):\n        \'\'\'# displaying the board at every frame\'\'\'\n        sys.stdout.flush()\n        # print(""\\x1b[{};{}H"".format(0,0))\n        try:\n            system(\'clear\')\n        except BaseException:\n            system(\'cls\')\n\n        temp_board = np.matrix(self._b)\n        for row in range(self.height):\n            for col in range(self.width):\n                try:\n                    sys.stdout.write(config.\n                                     getcc(temp_board[row, col].decode()))\n                except BaseException:\n                    sys.stdout.write(config.\n                                     getcc(temp_board[row, col]))\n            sys.stdout.write(""\\n"")\n        del temp_board\n\n    def __repr__(self):\n        \'\'\'# printing the board for debugging purposes\'\'\'\n        temp_board = np.matrix(self._b)\n        for row in range(self.height):\n            for col in range(self.width):\n                try:\n                    print(temp_board[row, col].decode(), end="""")\n                except BaseException:\n                    print(temp_board[row, col], end="""")\n            print()\n        del temp_board\n        return """"\n'"
config.py,0,"b'\'\'\'\n\ncontains all the symbols, constants\ndirections, etc\n\n\'\'\'\n\n# ch repr of objects\n_wall = ""X""\n_bricks = ""/""\n_bomb_man = ""B""\n_enemy = ""E""\n_expl = ""e""\n_bomb = ""O""\n_empty = "" ""\n\n# types of objects\ntypes = {\n\n    _empty : ""Unassigned"",\n\n    _wall : ""Wall"",\n    _bomb : ""Bomb"",\n    _bricks : ""Bricks"",\n\n    _bomb_man : ""Bomber"",\n    _enemy : ""Enemy""\n}\n# scores\nscores = {\n    _bricks : 20,\n    _enemy : 100\n}\n# number of properties per level (0 is debug)\nenemies = [0, 2, 3, 4]\nbricks = [0, 5, 7, 9]\nlives = [10, 3, 5, 7]\nbombs = [20, 5, 6, 7]\ntimelimit = [100, 90, 90, 80]\ntimers = [\n    [5],\n    [5],\n    [5, 7],\n    [4, 6, 9]\n]\n\n# scaling and move factor\nx_fac, y_fac = (4, 2)\n\n\n\'\'\'\n    Allow certain inputs and translate to easier to read format\n    UP : 0\n    DOWN : 1\n    LEFT : 2\n    RIGHT : 3\n    BOMB : 4\n\'\'\'\n\n# key presses\nUP, DOWN, LEFT, RIGHT, BOMB, QUIT = range(6)\nDIR = [UP, DOWN, LEFT, RIGHT]\nINVALID = -1\n\n# allowed inputs\n_allowed_inputs = {\n    UP      : [\'w\', \'\\x1b[A\'], \\\n    DOWN    : [\'s\', \'\\x1b[B\'], \\\n    LEFT    : [\'a\', \'\\x1b[D\'], \\\n    RIGHT   : [\'d\', \'\\x1b[C\'], \\\n    BOMB    : [\'b\'],           \\\n    QUIT    : [\'q\']\n}\n\ndef get_key(key):\n    for x in _allowed_inputs:\n        if key in _allowed_inputs[x]:\n            return x\n    return INVALID\n\n# Gets a single character from standard input.  Does not echo to the screen.\nclass _Getch:\n\n    def __init__(self):\n        try:\n            self.impl = _GetchWindows()\n        except ImportError:\n            self.impl = _GetchUnix()\n\n\n    def __call__(self):\n        return self.impl()\n\n\nclass _GetchUnix:\n\n\n    def __init__(self):\n        import tty, sys\n\n\n    def __call__(self):\n        import sys\n        import tty\n        import termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\n\n    def __call__(self):\n        import msvcrt\n        return msvcrt.getch()\n\n\n_getch = _Getch()\n\n\nclass AlarmException(Exception):\n    pass\n\n\ndef alarmHandler(signum, frame):\n    raise AlarmException\n\n\ndef get_input(timeout=1):\n    import signal\n    signal.signal(signal.SIGALRM, alarmHandler)\n    signal.alarm(timeout)\n    try:\n        text = _getch()\n        signal.alarm(0)\n        return text\n    except AlarmException:\n        pass\n    signal.signal(signal.SIGALRM, signal.SIG_IGN)\n    return \'\'\n\n# for printing colored people\ncolors = {\n    \'Black\'            : \'\\x1b[0;30m\',\n    \'Blue\'             : \'\\x1b[0;34m\',\n    \'Green\'            : \'\\x1b[0;32m\',\n    \'Cyan\'             : \'\\x1b[0;36m\',\n    \'Red\'              : \'\\x1b[0;31m\',\n    \'Purple\'           : \'\\x1b[0;35m\',\n    \'Brown\'            : \'\\x1b[0;33m\',\n    \'Gray\'             : \'\\x1b[0;37m\',\n    \'Dark Gray\'        : \'\\x1b[1;30m\',\n    \'Light Blue\'       : \'\\x1b[1;34m\',\n    \'Light Green\'      : \'\\x1b[1;32m\',\n    \'Light Cyan\'       : \'\\x1b[1;36m\',\n    \'Light Red\'        : \'\\x1b[1;31m\',\n    \'Light Purple\'     : \'\\x1b[1;35m\',\n    \'Yellow\'           : \'\\x1b[1;33m\',\n    \'White\'            : \'\\x1b[1;37m\'\n}\n\nENDC = \'\\x1b[0m\'\n\n\ndef getcc(ch):\n\n    try:\n        if ch == _empty:\n            return ch\n        elif ch == _wall:\n            color = \'Dark Gray\'\n        elif ch == _bomb_man:\n            color = \'Blue\'\n        elif ch == _enemy:\n            color = \'Red\'\n        elif ch == _bricks:\n            color = \'Brown\'\n        elif ch == _expl:\n            color = \'Yellow\'\n        elif ch in [str(x) for x in range(10)]:\n            color = \'White\'\n        elif ch == \'[\' or ch == \']\':\n            color = \'Purple\'\n        else:\n            color = \'None\'\n        return colors[color] + ch + ENDC\n    except KeyError:\n        return ch\n\n\ndef printcc(st, color):\n    try:\n        return colors[color] + st + ENDC\n    except KeyError:\n        return st\n'"
main.py,0,"b'#!/home/pratik/anaconda3/bin/python3.6\n\nimport random\nfrom sys import argv as rd\nfrom os import system\nfrom time import sleep\nimport datetime\nimport config\nimport board\nimport people\nimport objects\n\n\ndef spawn(typ, total, board):\n    \'\'\'# this attaches the enemies at random locations\'\'\'\n    for _ in range(total):\n        x, y = (1, 1)\n        if typ == config._enemy:\n            e = people.Enemy(x, y)\n        elif typ == config._bricks:\n            e = objects.Bricks(x, y)\n        else:\n            return False\n        run_count = 0\n        while True:\n            new_x, new_y = random.choice(board.init_points)\n            if e.update_location(board, new_x, new_y, True):\n                break\n            run_count += 1\n        board.add_storage(e)\n\n    return True\n\n\ndef main():\n    try:\n        height, width = tuple(map(int, rd[1:3]))\n    except BaseException:\n        height, width = (34, 76)\n\n    a = \'r\'\n\n    while a == \'r\':\n\n        try:\n            level = int(input(""Choose level [[1], 2, 3] :""))\n            if level not in [0, 1, 2, 3]:\n                raise Exception\n        except BaseException:\n            level = 1\n\n        # make the board and player\n        bd = board.Board(height, width, level)\n\n        player = people.Bomber(\n            5,\n            3,\n            config.lives[level],\n            config.bombs[level])  # always spawns at top left\n        # spawning the player on the board\n        bd.spawn(player)\n\n        print(""Initializing enemies, bricks ..."")\n        if not (spawn(config._enemy, config.enemies[level], bd) and\n                spawn(config._bricks, config.bricks[level], bd)):\n            print(""Object Spawn Error"")\n            return False\n\n        print(""Objects spawned successfully"", ""Rendering board"", sep=""\\n"")\n        sleep(1)\n\n        bd.render()\n\n        is_clean = False\n        p_input = -1\n        # main loop which renders the game\n        st_time = datetime.datetime.now()\n        prev_round = datetime.datetime.now()\n        while (datetime.datetime.now() - st_time) <= \\\n                datetime.timedelta(seconds=config.timelimit[level]):\n\n            print(config.printcc(""\'q\' : quit | \'b\' : drop bomb || Lives "", \'Gray\') +\n                  config.printcc(\'%s\' % (player.lives * \'\xe2\x99\xa5 \'), \'Red\') +\n                  config.printcc(\'| Bombs \', \'Gray\') +\n                  config.printcc(\'%s\' % (player.bombs * \'\xf0\x9f\x92\xa3 \'), \'Dark Gray\') +\n                  config.printcc(""| T : %d "" % (config.timelimit[level] - (datetime.datetime.now() -\n                                                                           st_time).seconds), \'Gray\'))\n\n            try:\n                bd.is_over(player)\n            except Exception as exc:\n                print(config.printcc(exc.args[0], \'Gray\'))\n                is_clean = True\n                break\n\n            p_input = config.get_key(config.get_input())\n\n            if p_input == config.QUIT:\n                break\n\n            cur_round = datetime.datetime.now()\n            bd.process_input(player, p_input)\n            if (cur_round - prev_round) >= datetime.timedelta(seconds=1):\n                bd.update_frame()\n                prev_round = cur_round\n\n            bd.render()\n\n        if not is_clean:\n            print(config.printcc(""TIME UP!"", \'Gray\'))\n\n        bd.clear_storage()\n        for c, player in enumerate(bd.players):\n            print(\n                config.printcc(\n                    ""Player %d score : %d"" %\n                    (c, player.score), \'White\'))\n\n        sleep(3)\n        print(\n            config.printcc(\n                ""Press ANY KEY to exit | Press \'r\' to restart"",\n                \'Gray\'))\n        a = config._getch()\n        system(\'reset\')\n\n\nif __name__ == \'__main__\':\n    main()\n'"
objects.py,2,"b'\'\'\'\n\n    contains the structure of each object\n\n\'\'\'\n\nimport config\nfrom config import x_fac, y_fac\nimport numpy as np\n\n\nclass Object:\n\n    \'\'\'# bombs, walls, bricks all will be of this type\'\'\'\n\n    def __init__(self, x, y, ch=config._empty):\n        \'\'\'# the x and y coords wrt top left of board\'\'\'\n        self._x = x\n        self._y = y\n        self.width = 4\n        self.height = 2\n        self.is_killable = False\n        self._ch = ch\n        self.structure = np.chararray((self.height, self.width))\n        self.structure[:, :] = self._ch\n        self._type = config.types[self._ch]\n\n    def get_type(self):\n        \'\'\'# returns whether ""Bomber"", ""Enemy"", etc\'\'\'\n        return self._type\n\n    def get_size(self):\n        \'\'\'# returns (height, willdth)\'\'\'\n        return self.structure.shape\n\n    def get_coords(self):\n        \'\'\'# returns (x, y)\'\'\'\n        return (self._x, self._y)\n\n    def update_location(self, board, new_x, new_y, init=False):\n        \'\'\'# update the location of the person\'\'\'\n        if board.draw_obj(type(self)(new_x, new_y)):\n            # if initial update, will not clear original\n            if not init:\n                board.clear_obj(self)\n            self._x, self._y = new_x, new_y\n            return True\n        return False\n\n\nclass Wall(Object):\n\n    \'\'\'# this is the repr of the wall object\n    it implements no methods and some data about each wall element\'\'\'\n\n    def __init__(self, n, m):\n        \'\'\'# preferred size = 2 x 4\'\'\'\n        super(Wall, self).__init__(n, m, config._wall)\n        self.height = int(m)\n        self.width = int(n)\n\n    def __repr__(self):\n        \'\'\' repr \'\'\'\n        for r in range(self.height):\n            print(""\\n"")\n            for c in range(self.width):\n                try:\n                    print(self.structure[r, c].decode(), end="""")\n                except UnicodeDecodeError:\n                    print(self.structure[r, c], end="""")\n        return """"\n\n\nclass Bomb(Object):\n\n    \'\'\'# this class implements the bomb object\'\'\'\n\n    def __init__(self, x, y):\n        \'\'\' init \'\'\'\n        super(Bomb, self).__init__(x, y, config._bomb)\n        self.timer = 0\n        self.active = False\n        self.is_killable = True\n        self.structure[:, :] = np.matrix([[\'[\', self._ch, self._ch, \']\'],\n                                          [\'[\', self._ch, self._ch, \']\']])\n        self.blast_radius = [(x + 1 * x_fac, y), (x + 2 * x_fac, y),\n                             (x - 1 * x_fac, y), (x - 2 * x_fac, y), (x,\n                                                                      y + 1 * y_fac), (x, y + 2 * y_fac),\n                             (x, y - 1 * y_fac), (x, y - 2 * y_fac)]\n        self.owner = None\n\n    def detonate(self, time):\n        \'\'\'# begin detonating the bomb (happens one frame after)\'\'\'\n        self.active = True\n        self.timer = time\n\n    def countdown(self):\n        \'\'\' countdown the bomb when active \'\'\'\n        if self.active:\n            self.timer -= 1\n            self.structure[:, 1:3] = str(self.timer)\n            return True\n\n        if not self.timer:\n            self.structure[:, :] = config._expl\n\n    def __repr__(self):\n        \'\'\' repr \'\'\'\n        return ""<Bomb (%d, %d) | Active : %s | %d frames left>"" % \\\n            (self._x, self._y, self.active, self.timer)\n\n\nclass Bricks(Object):\n\n    \'\'\'# this class implements the bricks Object\'\'\'\n\n    def __init__(self, x, y):\n        \'\'\' init \'\'\'\n        super(Bricks, self).__init__(x, y, config._bricks)\n        self.is_killable = True\n        self.structure[:, :] = self._ch\n\n    def __repr__(self):\n        \'\'\' repr \'\'\'\n        return ""<Bomb (%d, %d) | Active : %s | %d frames left>"" % \\\n            (self._x, self._y, self.active, self.timer)\n'"
people.py,3,"b'\n\'\'\'\n\n    contains the structure of each person\n\n\'\'\'\n\nimport config\nimport numpy as np\n\n\nclass Person:\n\n    """"""# bomber, enemies etc will be of this type""""""\n\n    def __init__(self, x, y, ch=config._empty):\n        \'\'\'# the x and y coords wrt top left of board\'\'\'\n        self._x = x\n        self._y = y\n        self.structure = np.chararray((2, 4))\n        self.structure[:, :] = config._empty\n        self._ch = ch\n        self._type = config.types[self._ch]\n        self.is_killable = True\n\n    def get_type(self):\n        \'\'\'# returns whether ""Bomber"", ""Enemy"", etc\'\'\'\n        return self._type\n\n    def get_size(self):\n        \'\'\'# returns (height, width)\'\'\'\n        return self.structure.shape\n\n    def get_coords(self):\n        \'\'\'# returns (x, y)\'\'\'\n        return (self._x, self._y)\n\n    def update_location(self, board, new_x, new_y, init=False):\n        \'\'\'# update the location of the person\'\'\'\n        if board.draw_obj(type(self)(new_x, new_y)):\n            # if initial update, will not clear original\n            if not init:\n                board.clear_obj(self)\n            self._x, self._y = new_x, new_y\n            return True\n        return False\n\n    def __repr__(self):\n        return ""<Person : %s | (%d, %d)>"" % (self.get_type(), self._x, self._y)\n\n\nclass Bomber(Person):\n\n    """"""# this is the class for the bomber\n    # methods that the bomber can execute are written here""""""\n\n    def __init__(self, x, y, lives=config.lives[1], bombs=config.bombs[1]):\n        super(Bomber, self).__init__(x, y, config._bomb_man)\n        temp_skel = np.matrix([[\'[\', self._ch, self._ch, \']\'],\n                               [config._empty, \']\', \'[\', config._empty]])\n        self.structure[:, :] = temp_skel\n        self.lives = lives\n        self.bombs = bombs\n        self.score = 0\n        del temp_skel\n\n\nclass Enemy(Person):\n\n    """"""# this is the enemy class\n    # enemy specific methods are added here""""""\n\n    def __init__(self, x, y):\n        super(Enemy, self).__init__(x, y, config._enemy)\n        temp_skel = np.matrix([[\'[\', self._ch, self._ch, \']\'],\n                               [config._empty, \']\', \'[\', config._empty]])\n        self.structure[:, :] = temp_skel\n        del temp_skel\n'"
