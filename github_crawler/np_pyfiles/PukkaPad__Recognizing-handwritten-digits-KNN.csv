file_path,api_count,code
MNIST_KNN_python.py,5,"b'# K-Nearest Neighbor Classification\n\nfrom __future__ import print_function\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import classification_report\nfrom sklearn import datasets\nfrom skimage import exposure\nimport numpy as np\nimport imutils\nimport cv2\n\n# load the MNIST digits dataset\nmnist = datasets.load_digits()\n\n#print (mnist.data)\n\n# Training and testing split,\n# 75% for training and 25% for testing\n(trainData, testData, trainLabels, testLabels) = train_test_split(np.array(mnist.data), mnist.target, test_size=0.25, random_state=42)\n\n# take 10% of the training data and use that for validation\n(trainData, valData, trainLabels, valLabels) = train_test_split(trainData, trainLabels, test_size=0.1, random_state=84)\n\n# Checking sizes of each data split\nprint(""training data points: {}"".format(len(trainLabels)))\nprint(""validation data points: {}"".format(len(valLabels)))\nprint(""testing data points: {}"".format(len(testLabels)))\n\n\n# initialize the values of k for our k-Nearest Neighbor classifier along with the\n# list of accuracies for each value of k\nkVals = range(1, 30, 2)\naccuracies = []\n\n# loop over kVals\nfor k in xrange(1, 30, 2):\n    # train the classifier with the current value of `k`\n    model = KNeighborsClassifier(n_neighbors=k)\n    model.fit(trainData, trainLabels)\n\n    # evaluate the model and print the accuracies list\n    score = model.score(valData, valLabels)\n    print(""k=%d, accuracy=%.2f%%"" % (k, score * 100))\n    accuracies.append(score)\n\n# largest accuracy\n# np.argmax returns the indices of the maximum values along an axis\ni = np.argmax(accuracies)\nprint(""k=%d achieved highest accuracy of %.2f%% on validation data"" % (kVals[i],\n    accuracies[i] * 100))\n\n\n# Now that I know the best value of k, re-train the classifier\nmodel = KNeighborsClassifier(n_neighbors=kVals[i])\nmodel.fit(trainData, trainLabels)\n\n# Predict labels for the test set\npredictions = model.predict(testData)\n\n# Evaluate performance of model for each of the digits\nprint(""EVALUATION ON TESTING DATA"")\nprint(classification_report(testLabels, predictions))\n\n# some indices are classified correctly 100% of the time (precision = 1)\n# high accuracy (98%)\n\n# check predictions against images\n# loop over a few random digits\nfor i in np.random.randint(0, high=len(testLabels), size=(5,)):\n    # np.random.randint(low, high=None, size=None, dtype=\'l\')\n    image = testData[i]\n    prediction = model.predict(image)[0]\n\n    # convert the image for a 64-dim array to an 8 x 8 image compatible with OpenCV,\n    # then resize it to 32 x 32 pixels for better visualization\n    image = image.reshape((8, 8)).astype(""uint8"")\n    image = exposure.rescale_intensity(image, out_range=(0, 255))\n    image = imutils.resize(image, width=32, inter=cv2.INTER_CUBIC)\n\n    # show the prediction\n    print(""I think that digit is: {}"".format(prediction))\n    cv2.imshow(""Image"", image)\n    cv2.waitKey(0) # press enter to view each one!\n'"
