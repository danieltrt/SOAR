file_path,api_count,code
bump_version_to.py,0,"b'#!/usr/bin/env python2\n\nimport sys, os\nimport subprocess\nimport re\nimport fileinput\n\ndef update_version(filename, version):\n    for line in fileinput.input(filename, inplace=True):\n        rexp = ""__version__\\s*=.*""\n        line = re.sub(rexp, ""__version__ = \\""%s\\"""" % version, line),\n        print(line[0], end=\'\')\n\nassert len(sys.argv) > 1, ""You need to specify the version (e.g. 6.6.6)""\nassert ""v"" not in sys.argv[1], ""You need to specify the version (e.g. 6.6.6)""\n\nupdate_version(os.path.abspath(""pyxrd/__version.py""), sys.argv[1])\nupdate_version(os.path.abspath(""mvc/__version.py""), sys.argv[1])\n\nprint( subprocess.check_output([\'git\', \'add\', \'pyxrd/__version.py\']))\nprint( subprocess.check_output([\'git\', \'add\', \'mvc/__version.py\']))\nprint( subprocess.check_output([\'git\', \'commit\', \'-m\', \'Version bump\', \'--allow-empty\']))\nprint( subprocess.check_output([\'git\', \'tag\', \'-a\', \'v%s\' % sys.argv[1], \'-m\', \'v%s\' % sys.argv[1]]))\n'"
run_tests.py,0,"b'#!/usr/bin/env python3\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport sys, os\nbase = os.path.dirname(__file__)\nsys.path.insert(0, os.path.join(base, ""pyxrd""))\n\nif __name__ == ""__main__"":\n    from test import run_all_tests\n    run_all_tests()\n'"
setup.py,0,"b'#!/usr/bin/env python3\n\nimport os\nfrom setuptools import setup, find_packages\n\ndef get_version():\n    from pyxrd.__version import __version__\n    if __version__.startswith(""v""):\n        __version__ = __version__.replace(""v"", """")\n    return ""%s"" % __version__\n\ndef get_install_requires():\n    return [\n        \'setuptools\',\n        \'numpy>=1.11\',\n        \'scipy>=1.1.0\',\n        \'matplotlib>=2.2.2\',\n        \'Pyro4>=4.41\',\n        \'deap>=1.0.1\',\n        \'cairocffi\',\n        \'pygobject>=3.20\'\n    ]\n\ndef read(fname):\n    with open(os.path.join(os.path.dirname(__file__), fname)) as f:\n        return f.read()\n\nsetup(\n    name=""PyXRD"",\n    version=get_version(),\n    description=""PyXRD is a python implementation of the matrix algorithm developed for the X-ray diffraction analysis of disordered lamellar structures"",\n    long_description=read(\'README.md\'),\n    keywords=""XRD disorder mixed-layers"",\n    author=""Mathijs Dumon"",\n    author_email=""mathijs.dumon@gmail.com"",\n    url=""http://github.org/mathijs-dumon/PyXRD"",\n\n    license=""BSD"",\n    setup_requires=[ ""setuptools_git >= 1.2"", ],\n    packages=find_packages(exclude=[""test.*"", ""test"", ""tests_mvc"", ""tests_mvc.*""]),\n    include_package_data=True,\n    install_requires=get_install_requires(),\n    zip_safe=False,\n\n    classifiers=[\n        ""Development Status :: 4 - Beta"",\n        ""Operating System :: Microsoft :: Windows"",\n        ""Operating System :: POSIX :: Linux"",\n        ""Programming Language :: Python :: 3.4"",\n        ""Environment :: Win32 (MS Windows)"",\n        ""Environment :: X11 Applications :: Gnome"",\n        ""Environment :: X11 Applications :: GTK"",\n        ""Intended Audience :: End Users/Desktop"",\n        ""Intended Audience :: Science/Research"",\n        ""Topic :: Utilities"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Scientific/Engineering :: Visualization"",\n        ""Natural Language :: English"",\n        ""License :: OSI Approved :: BSD License"",\n    ],\n)\n'"
versioning.py,0,"b'#!/usr/bin/env python2\n\n"""""" Git Versioning Script\n\nWill transform stdin to expand some keywords with git version/author/date information.\n\nSpecify --clean to remove this information before commit.\n\nSetup:\n\n1. Copy versioning.py into your git repository\n\n2. Run:\n\n git config filter.versioning.smudge \'python versioning.py\'\n git config filter.versioning.clean  \'python versioning.py --clean\'\n echo \'version.py filter=versioning\' >> .gitattributes\n git add versioning.py\n\n\n3. add a version.py file with this contents:\n\n __version__ = """"\n\n""""""\n\nimport sys\nimport subprocess\nimport re\n\n\ndef main():\n    clean = False\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \'--clean\':\n            clean = True\n\n    # initialise empty here. Otherwise: forkbomb through the git calls.\n    subst_list = {\n        ""version"": """",\n    }\n\n    for line in sys.stdin:\n        if not clean:\n            subst_list = {\n                # \'--dirty\' could be added to the following, too, but is not supported everywhere\n                ""version"": subprocess.check_output([\'git\', \'describe\', \'--always\']),\n            }\n            for k, v in subst_list.iteritems():\n                v = re.sub(r\'[\\n\\r\\t""\\\']\', """", v)\n                rexp = ""__%s__\\s*=[\\s\'\\""]+"" % k\n                line = re.sub(rexp, ""__%s__ = \\""%s\\""\\n"" % (k, v), line)\n            sys.stdout.write(line)\n        else:\n            for k in subst_list:\n                rexp = ""__%s__\\s*=.*"" % k\n                line = re.sub(rexp, ""__%s__ = \\""\\"""" % k, line)\n            sys.stdout.write(line)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# PyXRD documentation build configuration file, created by\n# sphinx-quickstart on Wed Feb 12 10:27:39 2014.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\ntop_dir = os.path.dirname(os.path.abspath("".""))\nif os.path.exists(os.path.join(top_dir, ""pyxrd"")):\n    sys.path.insert(0, top_dir)\n    pass\nimport pyxrd # @UnusedImport\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.autosummary\',\n    \'sphinx.ext.pngmath\',\n    \'sphinx.ext.intersphinx\'\n]\n\nintersphinx_mapping = {\'python\': (\'http://docs.python.org/2.7\', None)}\n\npngmath_latex_preamble = r""""""\n\\usepackage{mathtools}\n\\usepackage{units}\n\\usepackage[document]{ragged2e}\n\\usepackage[fontsize=8pt]{scrextend}\n""""""\n\n# User __init__ docstrings:\nautoclass_content = \'both\'\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n# source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'PyXRD\'\ncopyright = u\'2014, Mathijs Dumon\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'.\'.join(map(str, pyxrd.__version__.split(\'.\')[0:2]))\n# The full version, including alpha/beta/rc tags.\nrelease = pyxrd.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n# default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'nature\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pyxrddoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n# \'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n# \'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n# \'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\'index\', \'PyXRD.tex\', u\'PyXRD Documentation\',\n   u\'Mathijs Dumon\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'pyxrd\', u\'PyXRD Documentation\',\n     [u\'Mathijs Dumon\'], 1)\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'PyXRD\', u\'PyXRD Documentation\',\n   u\'Mathijs Dumon\', \'PyXRD\', \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n# texinfo_show_urls = \'footnote\'\n\nautodoc_member_order = \'bysource\'\n'"
mvc/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\n# FIXME clean this mess up\n\n""""""\nShortcuts are provided to the following classes defined in submodules:\n\n.. class:: Model\n   :noindex:\n.. class:: TreeStoreModel\n   :noindex:\n.. class:: ListStoreModel\n   :noindex:\n.. class:: TextBufferModel\n   :noindex:\n.. class:: ModelMT\n   :noindex:\n.. class:: Controller\n   :noindex:\n.. class:: View\n   :noindex:\n.. class:: Observer\n   :noindex:\n.. class:: Observable\n   :noindex:\n\n""""""\n\nfrom .support.version import LooseVersion \n\nfrom .__version import __version__\n\n# Class shortcuts:\nfrom .observers import Observer\nfrom .support.observables import Signal, Observable\nfrom .models import *\n\ntry:\n    from .view import View\n    from .controller import Controller\nexcept ImportError:\n    import logging\n    logging.getLogger(__name__).warning(""ImportError when trying to load View and/or Controller: do you have PyGTK/GObject installed?"")\n'"
mvc/__version.py,0,"b'# coding=UTF-8\r\n# ex:ts=4:sw=4:et=on\r\n#  -------------------------------------------------------------------------\r\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\r\n#  Copyright (c) 2007 by Guillaume Libersat <glibersat AT linux62.org>\r\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\r\n#\r\n#  mvc is a framework derived from the original pygtkmvc framework\r\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\r\n#\r\n#  mvc is free software; you can redistribute it and/or\r\n#  modify it under the terms of the GNU Lesser General Public\r\n#  License as published by the Free Software Foundation; either\r\n#  version 2 of the License, or (at your option) any later version.\r\n#\r\n#  mvc is distributed in the hope that it will be useful,\r\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n#  Lesser General Public License for more details.\r\n#\r\n#  You should have received a copy of the GNU Lesser General Public\r\n#  License along with this library; if not, write to the Free Software\r\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\r\n#  Boston, MA 02110, USA.\r\n#  -------------------------------------------------------------------------\r\n\r\n__version__ = ""0.8.4""\r\n\r\n\r\n\r\n\r\n\r\n'"
mvc/controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nfrom mvc.support.gui_loop import add_idle_call\nlogger = logging.getLogger(__name__)\n\nfrom .observers import Observer\nfrom .support.exceptions import TooManyCandidatesError\n\nclass Controller(Observer):\n\n    auto_adapt = True\n    auto_adapt_included = None\n    auto_adapt_excluded = None\n\n    register_lazy = True\n\n    __adapters = None\n    __parsed_user_props = None\n    _controller_scope_aplied = False\n\n    @property\n    def __user_props(self):\n        assert not (self.auto_adapt_included is not None and self.auto_adapt_excluded is not None), \\\n            ""Controller \'%s\' has set both auto_adapt_included and auto_adapt_excluded!"" % self\n        assert self.model is not None, \\\n            ""Controller \'%s\' has None as model! Did you forget to pass it as a keyword argument?"" % self\n        if not self._controller_scope_aplied:\n            props = [prop.label for prop in self.model.Meta.all_properties]\n            if self.auto_adapt_included is not None:\n                self.__parsed_user_props = self.__parsed_user_props.union(set([p for p in props if p not in self.auto_adapt_included]))\n            elif self.auto_adapt_excluded is not None:\n                self.__parsed_user_props = self.__parsed_user_props.union(set([p for p in props if p in self.auto_adapt_excluded]))\n            self._controller_scope_aplied = True\n        return self.__parsed_user_props\n\n    @__user_props.setter\n    def __user_props(self, value):\n        return # ignore\n        self.__parsed_user_props = set(value)\n\n\n    _model = None\n    def _get_model(self):\n        return self._model\n    def _set_model(self, model):\n        if self._model is not None:\n            self._clear_adapters()\n            self.relieve_model(self._model)\n        self._model = model\n        if self._model is not None:\n            self.observe_model(self._model)\n            if self.view is not None:\n                self.register_adapters()\n                if self.auto_adapt: self.adapt()\n    def _del_model(self):\n        del self._model\n        self._model = None\n    model = property(_get_model, _set_model, _del_model)\n\n    __view = None\n    def _get_view(self):\n        return self.__view\n    def _set_view(self, view):\n        if self.__view != view:\n            self.__view = view\n            if self.__view is not None:\n                if self.register_lazy:\n                    add_idle_call(self._idle_register_view, self.__view)\n                else:\n                    self._idle_register_view(self.__view)\n    def _del_view(self):\n        self.__view = None\n    view = property(_get_view, _set_view, _del_view, ""This controller\'s view"")\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Two positional and two optional keyword arguments.\n        \n        *model* will have the new instance registered as an observer.\n        It is made available as an attribute.\n        \n        *view* may contain signal connections loaded from XML. The handler\n        methods have to exist in this class.\n        \n        *spurious* denotes whether notifications in this class will be called\n        if a property of *model* is set to the same value it already has.\n        \n        *auto_adapt* denotes whether to call :meth:`adapt` with no arguments\n        as part of the view registration process.\n\n        View registration consists of connecting signal handlers,\n        :meth:`register_view` and :meth:`register_adapters`, and is scheduled\n        with the GTK main loop. It happens as soon as possible but after the\n        constructor returns. When it starts *view* is available as an\n        attribute.\n        \n        Subclasses can also override either the `auto_adapt_included` or\n        `auto_adapt_excluded` class attributes. These should be either None or\n        contain a list of properties to exclude (or include) from auto\n        adaptation for this controller. If not specified, all properties are\n        adapted if auto_adapt is True.\n        """"""\n\n        # set of properties explicitly adapted by the user:\n        self.__adapters = []\n        self.__parsed_user_props = set()\n\n        # Some general keyword arguments:\n        self.parent = kwargs.pop(""parent"", None)\n        self.auto_adapt = kwargs.pop(""auto_adapt"", self.auto_adapt)\n        self.register_lazy = kwargs.pop(""register_lazy"", self.register_lazy)\n\n        # Pop the view, keep the model as we pass it down to the observer\n        _view = kwargs.pop(""view"", None)\n        _model = kwargs.get(""model"", None)\n\n        # Init base classes\n        super(Controller, self).__init__(*args, **kwargs)\n\n        # Set model (will register controller as observer)\n        self.model = _model\n        # Set view (will register & adapt to view)\n        self.view = _view\n\n        return\n\n    def _idle_register_view(self, view):\n        """"""Internal method that calls register_view""""""\n        assert(self.view is not None)\n        if self.model is not None:\n            self.__autoconnect_signals()\n\n            self.register_view(self.view)\n            self.register_adapters()\n            if self.auto_adapt: self.adapt()\n            return False\n        else:\n            return True\n\n    def _clear_adapters(self):\n        """"""Clears & disconnects all adapters from this controller""""""\n        if self.__adapters:\n            for ad in self.__adapters:\n                ad.disconnect()\n            self.__adapters[:] = []\n\n    def register_view(self, view):\n        """"""\n        This does nothing. Subclasses can override it to connect signals\n        manually or modify widgets loaded from XML, like adding columns to a\n        TreeView. No super call necessary.\n        \n        *view* is a shortcut for ``self.view``.\n        """"""\n        assert(self.model is not None)\n        assert(self.view is not None)\n        return\n\n    def register_adapters(self):\n        """"""\n        This does nothing. Subclasses can override it to create adapters.\n        No super call necessary.\n        """"""\n        assert(self.model is not None)\n        assert(self.view is not None)\n        return\n\n    def adapt(self, *args):\n        """"""\n        There are four ways to call this:\n\n        .. method:: adapt()\n           :noindex:\n\n           Take properties from the model for which ``adapt`` has not yet been\n           called, match them to the view by name, and create adapters fitting\n           for the respective widget type.\n           \n           That information comes from :mod:`mvc.adapters.default`.\n           See :meth:`_find_widget_match` for name patterns.\n\n           .. versionchanged:: 1.99.1\n              Allow incomplete auto-adaption, meaning properties for which no\n              widget is found.\n\n        .. method:: adapt(ad)\n           :noindex:\n        \n           Keep track of manually created adapters for future ``adapt()``\n           calls.\n        \n           *ad* is an adapter instance already connected to a widget.\n\n        .. method:: adapt(prop_name)\n           :noindex:\n\n           Like ``adapt()`` for a single property.\n\n           *prop_name* is a string.\n\n        .. method:: adapt(prop_name, wid_name)\n           :noindex:\n\n           Like ``adapt(prop_name)`` but without widget name matching.\n           \n           *wid_name* has to exist in the view.\n        """"""\n\n        # checks arguments\n        n = len(args)\n        if n not in list(range(3)): raise TypeError(""adapt() takes 0, 1 or 2 arguments (%d given)"" % n)\n\n        if n == 0:\n            adapters = []\n            props = self.model.Meta.get_viewable_properties()\n            # matches all properties not previously adapted by the user:\n            for prop in [p for p in props if p.label not in self.__user_props]:\n                try: wid_name = self._find_widget_match(prop)\n                except TooManyCandidatesError as e:\n                    # multiple candidates, gives up\n                    raise e\n                except ValueError as e:\n                    # no widgets found for given property, continue after emitting a warning\n                    if e.args:\n                        logger.warn(e[0])\n                    else:\n                        logger.warn(""No widget candidates match property \'%s\'""\n                            % prop.label)\n                else:\n                    logger.debug(""Auto-adapting property %s and widget %s"" % \\\n                                     (prop.label, wid_name))\n                    adapters += self.__create_adapters__(prop, wid_name)\n                    pass\n                pass\n\n        elif n == 1: # one argument\n            from .adapters import AbstractAdapter\n\n            if isinstance(args[0], AbstractAdapter): adapters = (args[0],)\n\n            elif isinstance(args[0], str):\n                prop = getattr(type(self.model), args[0])\n                wid_name = self._find_widget_match(prop)\n                adapters = self.__create_adapters__(prop, wid_name)\n                pass\n            else: raise TypeError(""Argument of adapt() must be either an Adapter or a string"")\n\n        else: # two arguments\n            if not (isinstance(args[0], str) and isinstance(args[1], str)):\n                raise TypeError(""Arguments of adapt() must be two strings"")\n\n            # retrieves both property and widget, and creates an adapter\n            prop_name, wid_name = args #@UnusedVariable\n            adapters = self.__create_adapters__(prop, wid_name)\n            pass\n\n        for ad in adapters:\n            self.__adapters.append(ad)\n            # remember properties added by the user\n            if n > 0: self.__user_props.add(ad.get_property_name())\n            pass\n\n        return\n\n    def _find_widget_match(self, prop):\n        """"""\n        Checks if the view has defined a \'widget_format\' attribute (e.g. \n        ""view_%s"") If so, it uses this format to search for the widget in \n        the view, if not it takes the *first* widget with a name ending with the\n        property name.\n        """"""\n\n        widget_name = None\n        widget_format = getattr(self.view, \'widget_format\', ""%s"")\n\n        if widget_format:\n            widget_name = widget_format % prop.label\n            widget = self.view[widget_name]\n            if widget is None: # not in view\n                if prop is not None and prop.widget_type == \'scale\':\n                    self.view.add_scale_widget(prop)\n                else:\n                    widget_name = None\n\n        else:\n            for wid_name in self.view:\n                if wid_name.lower().endswith(prop.label.lower()):\n                    widget_name = wid_name\n                    break\n\n        if widget_name == None:\n            logger.setLevel(logging.INFO)\n            raise ValueError(""No widget candidates match property \'%s\'"" % prop.label)\n\n        return widget_name\n\n    # performs Controller\'s signals auto-connection:\n    def __autoconnect_signals(self):\n        """"""This is called during view registration, to autoconnect\n        signals in glade file with methods within the controller""""""\n        dic = {}\n        for name in dir(self):\n            method = getattr(self, name)\n            if (not callable(method)): continue\n            assert(name not in dic) # not already connected!\n            dic[name] = method\n            pass\n\n        # Auto connect builder if available:\n        if self.view._builder is not None:\n            self.view._builder.connect_signals(dic)\n            pass\n\n        return\n\n    def _get_handler_list(self):\n        from .adapters import AdapterRegistry\n\n        # Add default widget handlers:\n        local_handlers = {}\n        adapter_registry = AdapterRegistry.get_selected_adapter_registry()\n        local_handlers.update(adapter_registry)\n\n        # Override with class instance widget handlers:\n        for widget_type, handler in self.widget_handlers.items():\n            if isinstance(handler, str):\n                self.widget_handlers[widget_type] = getattr(self, handler)\n        local_handlers.update(self.widget_handlers)\n\n        return local_handlers\n\n    def __create_adapters__(self, prop, wid_name):\n        """"""\n            Private service that looks at property and widgets types,\n            and possibly creates one or more (best) fitting adapters\n            that are returned as a list.\n        """"""\n        try:\n            logger.debug(""Adapting property %s to widget names \'%s\'"" % (prop.label, wid_name))\n            if prop.visible:\n\n                wid = self.view[wid_name]\n                if wid == None:\n                    raise ValueError(""Widget \'%s\' not found in view \'%s\' by controller \'%s\'"" % (wid_name, self.view, self))\n\n                local_handlers = self._get_handler_list()\n\n                handler = local_handlers.get(prop.widget_type)\n                ad = handler(self, prop, wid)\n\n                return [ad]\n            else:\n                return []\n        except BaseException as error:\n            raise RuntimeError(""Unhandled error in \'%s\'.__create_adapters__ for property \'%s\' and widget \'%s\'!"" % (type(self), prop.label, wid_name)) from error\n\n    pass # end of class Controller\n'"
mvc/settings.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nTOOLKIT = ""gtk""'"
mvc/view.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (c) 2007 by Guillaume Libersat <glibersat AT linux62.org>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\n# TODO remove gladeXML: deprecated!\n\nfrom .support.exceptions import ViewError\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nBuilder = Gtk.Builder\n\n# ----------------------------------------------------------------------\n\nclass View (object):\n    top = None\n    builder = None\n\n    def __init__(self, top=None,\n                 parent=None,\n                 builder=None, *args, **kwargs):\n        """"""\n        Only the first three may be given as positional arguments. If an\n        argument is empty a class attribute of the same name is used. This\n        does not work for *parent*.\n\n        *builder* is a path to a Glade XML file.\n\n        *top* is a string containing the name of our top level widget.\n\n        *parent* is used to call :meth:`set_parent_view`.\n\n        The last two only work if *builder* is used, not if you\n        intend to create widgets later from code.\n        """"""\n        super(View, self).__init__(*args, **kwargs)\n\n        self.manualWidgets = {}\n        self.autoWidgets = {}\n        self.__autoWidgets_calculated = False\n\n        if top: self._top = top\n        else: self._top = self.top\n\n        # retrieves objects from builder if available\n        if builder: _builder = builder\n        else: _builder = self.builder\n        if _builder is not None:\n            # if the user passed a Builder, use it as it is, otherwise\n            # build one\n            if isinstance(_builder, Builder):\n                self._builder = _builder\n            else:\n                self._builder = Gtk.Builder()\n                self._builder.add_from_file(_builder)\n                pass\n            pass\n        else: self._builder = None # no gtk builder\n\n        if parent is not None: self.set_parent_view(parent)\n\n        return\n\n    def __getitem__(self, key):\n        """"""\n        Return the widget named *key*, or ``None``.\n        \n        .. note::\n        \n           In future versions this will likely change to raise ``KeyError``.\n        """"""\n        wid = None\n\n        # first try with manually-added widgets:\n        if key in self.manualWidgets:\n            wid = self.manualWidgets[key]\n            pass\n\n        if wid is None:\n            # then try with glade and builder, starting from memoized\n            if key in self.autoWidgets: wid = self.autoWidgets[key]\n            else:\n                # try with Gtk.builder\n                if wid is None and self._builder is not None:\n                    wid = self._builder.get_object(key)\n                    if wid is not None:\n                        self.autoWidgets[key] = wid\n                        pass\n                    pass\n                pass\n            pass\n\n        return wid\n\n    def __setitem__(self, key, wid):\n        """"""\n        Add a widget. This overrides widgets of the same name that were loaded\n        from XML. It does not affect GTK container/child relations.\n        \n        If no top widget is known, this sets it.\n        """"""\n        self.manualWidgets[key] = wid\n        return\n\n    def show(self):\n        """"""\n        Call `show()` on each top widget or `show_all()` if only one is known. \n        Otherwise does nothing.\n        """"""\n        top = self.get_top_widget()\n        if type(top) in (list, tuple):\n            for t in top:\n                if t is not None: t.show()\n                pass\n        elif (top is not None): top.show_all()\n        return\n\n\n    def hide(self):\n        """"""\n        Call `hide()` on all known top widgets.\n        """"""\n        top = self.get_top_widget()\n        if type(top) in (list, tuple):\n            for t in top:\n                if t is not None: t.hide()\n                pass\n        elif top is not None: top.hide()\n        return\n\n    def get_top_widget(self):\n        return self[self._top]\n\n    def set_parent_view(self, parent_view):\n        """"""\n        Set ``self.``:meth:`get_top_widget` transient for \n        ``parent_view.get_top_widget()``.\n        """"""\n        top = self.get_top_widget()\n        if type(top) in (list, tuple):\n            for t in top:\n                if t is not None and hasattr(t, ""set_transient_for""):\n                    t.set_transient_for(parent_view.get_top_widget())\n                    pass\n                pass\n        elif (top is not None) and hasattr(top, ""set_transient_for""):\n            top.set_transient_for(parent_view.get_top_widget())\n            pass\n\n        return\n\n    def set_transient(self, transient_view):\n        """"""\n        Set ``transient_view.get_top_widget()`` transient for\n        ``self.``:meth:`get_top_widget`.\n        """"""\n        top = self.get_top_widget()\n        if type(top) in (list, tuple):\n            for t in top:\n                if t is not None:\n                    transient_view.get_top_widget().set_transient_for(t)\n                    pass\n                pass\n        elif (top is not None):\n            transient_view.get_top_widget().set_transient_for(top)\n            pass\n        return\n\n    # Finds the right callback for custom widget creation and calls it\n    # Returns None if an undefined or invalid  handler is found\n    def _custom_widget_create(self, glade, function_name, widget_name,\n                              str1, str2, int1, int2):\n        # This code was kindly provided by Allan Douglas <zalguod at\n        # users.sourceforge.net>\n        if function_name is not None:\n            handler = getattr(self, function_name, None)\n            if handler is not None: return handler(str1, str2, int1, int2)\n            pass\n        return None\n\n    def __iter__(self):\n        """"""\n        Return an iterator over widgets added with :meth:`__setitem__` and\n        those loaded from XML.\n        \n        .. note::\n           In case of name conflicts this yields widgets that are not \n           accessible via :meth:`__getitem__`.\n        """"""\n        # precalculates if needed\n        self.__extract_autoWidgets()\n\n        import itertools\n        for i in itertools.chain(self.manualWidgets, self.autoWidgets): yield i\n        return\n\n    def __extract_autoWidgets(self):\n        """"""Extract autoWidgets map if needed, out of the glade\n        specifications and gtk builder""""""\n        if self.__autoWidgets_calculated: return\n\n        if self._builder is not None:\n            for wid in self._builder.get_objects():\n                # General workaround for issue\n                # https://bugzilla.gnome.org/show_bug.cgi?id=607492\n                try: name = Gtk.Buildable.get_name(wid)\n                except TypeError: continue\n\n                if name in self.autoWidgets and self.autoWidgets[name] != wid:\n                    raise ViewError(""Widget \'%s\' in builder also found in glade specification"" % name)\n\n                self.autoWidgets[name] = wid\n                pass\n            pass\n\n        self.__autowidgets_calculated = True\n        return\n\n    pass # end of class View\n'"
pyxrd/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\n    A python implementation of the matrix algorithm developed for the X-ray\n        diffraction analysis of disordered lamellar structures\n""""""\n\nimport pkg_resources\nfrom pyxrd.__version import __version__\n'"
pyxrd/__main__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, sys\n\n# Make sure the current path is used for loading PyXRD modules:\nmod = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nif not mod in sys.path:\n    sys.path.insert(1, mod)\n\nfrom pyxrd.core import run_main\nrun_main()\n'"
pyxrd/__version.py,0,"b'# coding=UTF-8\r\n# ex:ts=4:sw=4:et=on\r\n\r\n# Copyright (c) 2013, Mathijs Dumon\r\n# All rights reserved.\r\n# Complete license can be found in the LICENSE file.\r\n\r\n__version__ = ""0.8.4""\r\n\r\n\r\n\r\n\r\n\r\n'"
pyxrd/core.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport warnings\nimport os, sys\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.support.gui_loop import start_event_loop\n\ndef _run_user_script():\n    """"""\n        Runs the user script specified in the command-line arguments.\n    """"""\n    \n    available, nv, cv = check_for_updates()\n    if available:\n        print(""An update is available: current version is %s upstream version is %s - consider upgrading!"" % cv, nv)\n    \n    from pyxrd.data import settings\n\n    try:\n        import imp\n        user_script = imp.load_source(\'user_script\', settings.ARGS.script)\n    except BaseException as err:\n        err.args = ""Error when trying to import %s: %s"" % (settings.ARGS.script, err.args)\n        raise\n    user_script.run(settings.ARGS)\n\ndef _run_gui(project=None):\n\n    # Display a splash screen showing the loading status...\n    from pkg_resources import resource_filename # @UnresolvedImport\n    from pyxrd.application.splash import SplashScreen\n    from pyxrd import __version__\n\n    filename = resource_filename(__name__, ""application/icons/pyxrd.png"")\n    splash = SplashScreen(filename, __version__)\n\n    # Run GUI:\n    splash.set_message(""Checking for updates ..."")   \n    update_available, nv, cv = check_for_updates()\n\n    splash.set_message(""Loading GUI ..."")\n\n    # Now we can load these:\n    from pyxrd.data import settings\n    from pyxrd.file_parsers.json_parser import JSONParser\n    from pyxrd.application.models import AppModel\n    from pyxrd.application.views import AppView\n    from pyxrd.application.controllers import AppController\n    \n    # TODO move this to mvc:\n    from pyxrd.generic.gtk_tools.gtkexcepthook import plugin_gtk_exception_hook\n\n    filename = settings.ARGS.filename #@UndefinedVariable\n\n    # Check if a filename was passed, if so try to load it\n    if filename != """":\n        try:\n            logging.info(""Opening project: %s"" % filename)\n            project = JSONParser.parse(filename)\n        except IOError:\n            logging.info(""Could not load project file %s: IOError"" % filename)\n            # FIXME the user should be informed of this in a dialog...\n\n    # Disable unity overlay scrollbars as they cause bugs with modal windows\n    os.environ[\'LIBOVERLAY_SCROLLBAR\'] = \'0\'\n    os.environ[\'UBUNTU_MENUPROXY\'] = """"\n\n    if not settings.DEBUG:\n        warnings.filterwarnings(action=\'ignore\', category=Warning)\n\n    # Close splash screen\n    if splash: \n        splash.close()\n\n    # Nice GUI error handler:\n    gtk_exception_hook = plugin_gtk_exception_hook()\n\n    # setup MVC:\n    m = AppModel(project=project)\n    v = AppView()\n    AppController(m, v, gtk_exception_hook=gtk_exception_hook)\n\n    # Free this before continuing\n    del splash\n\n    if update_available:\n        from mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n        DialogFactory.get_information_dialog(\n            ""An update is available (%s) - consider upgrading!"" % nv, \n            False, v.get_toplevel(), title = ""Update available""\n        ).run()\n    else:\n        print(""PyXRD is up to date (current = %s)"" % cv)\n\n    # lets get this show on the road:\n    start_event_loop()\n\ndef check_for_updates():\n    """"""\n        Checks for updates and returns a tuple:\n            update_available, latest_version, current_version\n    """"""\n    from pyxrd.generic.outdated import check_outdated\n    from pyxrd.__version import __version__\n    is_outdated, latest_version = check_outdated(\'pyxrd\', __version__)\n    \n    return is_outdated, latest_version, __version__\n\ndef run_main():\n    """"""\n        Parsers command line arguments and launches PyXRD accordingly.\n    """"""\n\n    # Make sure the current path is used for loading PyXRD modules:\n    mod = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    if not mod in sys.path:\n        sys.path.insert(1, mod)\n\n    # Init settings, first import will trigger initialization\n    from pyxrd.data import settings\n    settings.initialize()\n\n    # Setup basic logging\n    from pyxrd.logs import setup_logging\n    setup_logging(basic=True)\n\n    if settings.DEBUG:\n        from pyxrd import stacktracer\n        stacktracer.trace_start(\n            ""trace.html"",\n            interval=5, auto=True) # Set auto flag to always update file!\n\n    try:\n        if settings.ARGS.script:\n            # Run the specified user script:\n            _run_user_script()\n        else:\n            # Run the GUI:\n            _run_gui()\n    except:\n        raise # re-raise the error\n    finally:\n        for finalizer in settings.FINALIZERS:\n            finalizer()\n        if settings.DEBUG: stacktracer.trace_stop()\n\nif __name__ == ""__main__"":\n    run_main()\n'"
pyxrd/logs.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nimport queue\nimport logging\nfrom logging.handlers import QueueHandler, QueueListener\n\ndef setup_logging(basic=False, prefix=None):\n    """"""\n        Setup logging module.\n    """"""\n    from pyxrd.data import settings\n\n    # Whether PyXRD should spew out debug messages\n    debug = settings.DEBUG\n    # Filename used for storing the logged messages\n    log_file = settings.LOG_FILENAME\n    # Flag indicating if a full logger should be setup (False) or\n    # if simple, sparse logging is enough (True)\n    basic = not settings.GUI_MODE\n\n    fmt = \'%(name)s - %(levelname)s: %(message)s\'\n    if prefix is not None:\n        fmt = prefix + "" "" + fmt \n\n    if log_file is not None and not os.path.exists(os.path.dirname(log_file)):\n        os.makedirs(os.path.dirname(log_file))\n\n    if not basic:\n        # Setup file log:\n        file_handler = logging.FileHandler(log_file, \'w\')\n        disk_fmt = logging.Formatter(\n            \'%(asctime)s %(levelname)-8s %(name)-40s %(message)s\',\n            datefmt=\'%m-%d %H:%M\')\n        file_handler.setFormatter(disk_fmt)\n\n        # Setup console log:\n        log_handler = logging.StreamHandler()\n        full = logging.Formatter(fmt)\n        log_handler.setFormatter(full)\n\n        # Setup queue handler:\n        log_que = queue.Queue(-1)\n        queue_handler = QueueHandler(log_que)\n        queue_listener = QueueListener(log_que, file_handler, log_handler, respect_handler_level=True)\n        queue_listener.start()\n        \n        # Add queue handler:\n        logger = logging.getLogger(\'\')\n        logger.setLevel(logging.DEBUG if debug else logging.INFO)\n        logger.addHandler(queue_handler)\n    else:\n        # Very basic output for the root object:\n        logging.basicConfig(format=fmt)\n        logger = logging.getLogger(\'\')\n        logger.addHandler(queue_handler)\n        \n    settings.FINALIZERS.append(queue_listener.stop)\n'"
pyxrd/stacktracer.py,0,"b'""""""Stack tracer for multi-threaded applications.\n\n\nUsage:\n\nimport stacktracer\nstacktracer.start_trace(""trace.html"",interval=5,auto=True) # Set auto flag to always update file!\n....\nstacktracer.stop_trace()\n""""""\n\n\n\nimport sys\nimport traceback\nfrom pygments import highlight\nfrom pygments.lexers import PythonLexer  # @UnresolvedImport\nfrom pygments.formatters import HtmlFormatter  # @UnresolvedImport\n\n# Taken from http://bzimmer.ziclix.com/2008/12/17/python-thread-dumps/\n\ndef stacktraces():\n    code = []\n    for threadId, stack in list(sys._current_frames().items()):\n        code.append(""\\n# ThreadID: %s"" % threadId)\n        for filename, lineno, name, line in traceback.extract_stack(stack):\n            code.append(\'File: ""%s"", line %d, in %s\' % (filename, lineno, name))\n            if line:\n                code.append(""  %s"" % (line.strip()))\n\n    return highlight(""\\n"".join(code), PythonLexer(), HtmlFormatter(\n      full=False,\n      # style=""native"",\n      noclasses=True,\n    ))\n\n\n# This part was made by nagylzs\nimport os\nimport time\nimport threading\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nclass TraceDumper(threading.Thread):\n    """"""Dump stack traces into a given file periodically.""""""\n    def __init__(self, fpath, interval, auto):\n        """"""\n        @param fpath: File path to output HTML (stack trace file)\n        @param auto: Set flag (True) to update trace continuously.\n            Clear flag (False) to update only if file not exists.\n            (Then delete the file to force update.)\n        @param interval: In seconds: how often to update the trace file.\n        """"""\n        assert(interval > 0.1)\n        self.auto = auto\n        self.interval = interval\n        self.fpath = os.path.abspath(fpath)\n        logger.info(""Tracing at file %s"" % self.fpath)\n        self.stop_requested = threading.Event()\n        threading.Thread.__init__(self)\n\n    def run(self):\n        while not self.stop_requested.isSet():\n            time.sleep(self.interval)\n            if self.auto or not os.path.isfile(self.fpath):\n                self.stacktraces()\n\n    def stop(self):\n        self.stop_requested.set()\n        self.join()\n        try:\n            if os.path.isfile(self.fpath):\n                os.unlink(self.fpath)\n        except:\n            pass\n\n    def stacktraces(self):\n        fout = open(self.fpath, ""w+"")\n        try:\n            fout.write(stacktraces())\n        finally:\n            fout.close()\n\n\n_tracer = None\ndef trace_start(fpath, interval=5, auto=True):\n    """"""Start tracing into the given file.""""""\n    global _tracer\n    if _tracer is None:\n        _tracer = TraceDumper(fpath, interval, auto)\n        _tracer.setDaemon(True)\n        _tracer.start()\n    else:\n        raise Exception(""Already tracing to %s"" % _tracer.fpath)\n\ndef trace_stop():\n    """"""Stop tracing.""""""\n    global _tracer\n    if _tracer is None:\n        raise Exception(""Not tracing, cannot stop."")\n    else:\n        _tracer.stop()\n        _tracer = None\n'"
test/__init__.py,0,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\ndef run_all_tests(*args, **kwargs):\n    all_tests = get_all_tests()\n    unittest.TextTestRunner().run(all_tests)\n\ndef get_all_tests():\n    return unittest.TestLoader().discover('.')\n"""
test/setup.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\n    This file contains some flags which (partially) control if certain tests\n    are run. This way lengthy tests can be skipped in the default set.\n""""""\n\nSKIP_REFINEMENT_TEST = True\n'"
test/utils.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport time\nimport mock\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\ndef create_object_attribute_test(object_name, attribute, value):\n    """"""\n        Helper function to create simple attribute setter/getter tests.\n    """"""\n    def test_attribute(self):\n        obj = getattr(self, object_name)\n        setattr(obj, attribute, value)\n        self.assertEqual(getattr(obj, attribute), value)\n    return test_attribute\n\n# Stolen from Kiwi\ndef refresh_gui(delay=0):\n    while Gtk.events_pending():\n        Gtk.main_iteration_do(block=False)\n    time.sleep(delay)\n    \ndef _mocked_parse_args():\n    args = mock.Mock()\n    args.script.return_value = True\n    args.script.filename = """"\n    args.script.debug = False\n    return args\n\ndef mock_settings():\n    from pyxrd.data import settings\n    settings._parse_args = mock.Mock(return_value=_mocked_parse_args())\n    settings.initialize()\n    '"
tests_mvc/__init__.py,0,"b""# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport unittest\n\ndef run_all_tests(*args, **kwargs):\n    all_tests = get_all_tests()\n    unittest.TextTestRunner().run(all_tests)\n\ndef get_all_tests():\n    return unittest.TestLoader().discover('.')\n"""
mvc/adapters/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2007 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .adapter_registry import AdapterRegistry\nfrom .abstract_adapter import AbstractAdapter\nfrom .dummy_adapter import DummyAdapter\nfrom .model_adapter import ModelAdapter\n\n__all__ = [\n    ""AdapterRegistry"",\n    ""AbstractAdapter"",\n    ""DummyAdapter"",\n    ""ModelAdapter"",\n]'"
mvc/adapters/abstract_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport weakref\n\nfrom .metaclasses import MetaAdapter\n\nclass AbstractAdapter(object, metaclass=MetaAdapter):\n    """"""\n        An semi-abstract class all Adapters have to derive from.\n    """"""\n\n    widget_types = []\n\n    __prop = None\n    @property\n    def _prop(self):\n        if callable(self.__prop):\n            return self.__prop()\n        else:\n            return self.__prop\n    @_prop.setter\n    def _prop(self, value):\n        if value is None:\n            self.__prop = None\n        else:\n            self.__prop = weakref.ref(value, lambda: self.disconnect())\n\n    __controller = None\n    @property\n    def _controller(self):\n        if callable(self.__controller):\n            return self.__controller()\n        else:\n            return self.__controller\n    @_controller.setter\n    def _controller(self, value):\n        if value is None:\n            self.__controller = None\n        else:\n            self.__controller = weakref.ref(value, lambda c: self.disconnect())\n\n    __widget = None\n    @property\n    def _widget(self):\n        if callable(self.__widget):\n            return self.__widget()\n        else:\n            return self.__widget\n    @_widget.setter\n    def _widget(self, value):\n        if value is None:\n            self.__widget = None\n        else:\n            self.__widget = weakref.ref(value, lambda w: self.disconnect(widget=w()))\n\n    # ----------------------------------------------------------------------\n    #  Construction:\n    # ----------------------------------------------------------------------\n    def __init__(self, controller, prop, widget, *args, **kwargs):\n        super(AbstractAdapter, self).__init__(*args, **kwargs)\n\n        self._prop = prop\n        self._controller = controller\n        self._widget = widget\n\n    # ----------------------------------------------------------------------\n    #  Public interface:\n    # ----------------------------------------------------------------------\n    def update_model(self):\n        """"""Forces the property to be updated from the value hold by\n        the widget. This method should be called directly by the\n        user in very unusual conditions.""""""\n        self._write_property(self._read_widget())\n        return\n\n    def update_widget(self):\n        """"""Forces the widget to be updated from the property\n        value. This method should be called directly by the user\n        when the property is not observable, or in very unusual\n        conditions.""""""\n        self._write_widget(self._read_property())\n        return\n\n    def disconnect(self, model=None, widget=None):\n        """"""Disconnects the adapter from the model and the widget.""""""\n        self._disconnect_model(model=model)\n        self._disconnect_widget(widget=widget)\n\n    # ----------------------------------------------------------------------\n    #  Widget connecting & disconnecting:\n    # ----------------------------------------------------------------------\n    def _connect_widget(self):\n        raise NotImplementedError(""Please Implement this method"")\n\n    def _disconnect_widget(self, widget=None):\n        raise NotImplementedError(""Please Implement this method"")\n\n    # ----------------------------------------------------------------------\n    #  Model connecting & disconnecting:\n    # ----------------------------------------------------------------------\n    def _connect_model(self):\n        raise NotImplementedError(""Please Implement this method"")\n\n    def _disconnect_model(self, model=None):\n        raise NotImplementedError(""Please Implement this method"")\n\n    # ----------------------------------------------------------------------\n    #  Widget-side reading and writing\n    # ----------------------------------------------------------------------\n    def _read_widget(self):\n        raise NotImplementedError(""Please Implement this method"")\n\n    def _write_widget(self, val):\n        raise NotImplementedError(""Please Implement this method"")\n\n    # ----------------------------------------------------------------------\n    #  Model-side reading and writing\n    # ----------------------------------------------------------------------\n    def _read_property(self, *args):\n        raise NotImplementedError(""Please Implement this method"")\n\n    def _write_property(self, value, *args):\n        raise NotImplementedError(""Please Implement this method"")\n\n    pass # end of class\n'"
mvc/adapters/adapter_registry.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport importlib\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom ..settings import TOOLKIT\nfrom ..support import gui_loop\n\nclass ToolkitRegistry(dict):\n    """"""\n        Dict subclass used to store all AdapterRegistry\'s.\n        Keys are toolkit names, values are AdapterRegistry instances\n    """"""\n    \n    # These will be loaded automatically when this module is first loaded:\n    toolkit_modules = [\n        "".gtk_support""\n    ]\n    selected_toolkit = None\n\n    def get_or_create_registry(self, toolkit_name):\n        if not toolkit_name in self:\n            adapter_registry = AdapterRegistry()\n            self.register(toolkit_name, adapter_registry)\n        return self[toolkit_name]\n\n    def register(self, toolkit_name, adapter_registry):\n        self[toolkit_name] = adapter_registry\n\n    def select_toolkit(self, toolkit_name):\n        if not toolkit_name in self:\n            raise ValueError(""Cannot select unknown toolkit \'%s\'"" % toolkit_name)\n        else:\n            self.selected_toolkit = toolkit_name\n            tkar = self.get_selected_adapter_registry()\n            tkar.load_toolkit_functions()\n            \n    def get_selected_adapter_registry(self):\n        if self.selected_toolkit is None:\n            raise ValueError(""No toolkit has been selected!"")\n        else:\n            return self[self.selected_toolkit]\n\nclass AdapterRegistry(dict):\n    """"""\n        A dict which maps Adapter class types to the widget types they\n        can handle. This relies on these classes being registered using\n        the \'register\' decorator also provided by this class.\n    """"""\n\n    toolkit_registry = ToolkitRegistry()\n\n    @classmethod\n    def get_selected_adapter_registry(cls):\n        return cls.toolkit_registry.get_selected_adapter_registry()\n\n    @classmethod\n    def get_adapter_for_widget_type(cls, widget_type):\n        return cls.toolkit_registry.get_selected_adapter_registry()[widget_type]\n\n    def set_toolkit_functions(self, *args, **kwargs):\n        setattr(self, ""_toolkit_functions"", (args, kwargs))\n\n    def load_toolkit_functions(self):\n        """"""\n            This function loads the toolkit functions passed to \n            set_toolkit_functions with the support module.\n        """"""\n        args, kwargs = getattr(self, ""_toolkit_functions"", ([],{}))\n        gui_loop.load_toolkit_functions(*args, ** kwargs)\n\n    @classmethod\n    def register(cls, adapter_cls):\n        """"""\n            This is called from metaclasses or used as a decorator.\n            An example metaclass is at mvc.adapters.metaclasses and a model\n            implementing it at adapters.gtk_support.basic\n        """"""\n        if hasattr(adapter_cls, ""widget_types"") and hasattr(adapter_cls, ""toolkit""):\n            adapter_registry = cls.toolkit_registry.get_or_create_registry(adapter_cls.toolkit)\n            logger.debug(""Registering %s as handler for widget types \'%s\' in toolkit \'%s\'"" % (adapter_cls, adapter_cls.widget_types, adapter_cls.toolkit))\n            for widget_type in adapter_cls.widget_types:\n                adapter_registry[widget_type] = adapter_cls\n        else:\n            logger.debug(""Ignoring \'%s\' as handler: no \'toolkit\' or \'widget_types\' defined"" % adapter_cls)\n        return adapter_cls\n\n    pass # end of class\n\nfor toolkit_module in ToolkitRegistry.toolkit_modules:\n    if toolkit_module.startswith(\'.\'):\n        package = __name__.rpartition(\'.\')[0]\n        try:\n            # Import and load toolkit module:\n            tk_mod = importlib.import_module(toolkit_module, package=package)\n            # Get or create the associated toolkit registry:\n            tkreg = AdapterRegistry.toolkit_registry.get_or_create_registry(tk_mod.toolkit)\n            # Load the toolkit and pass the registry:\n            tk_mod.load(tkreg)\n        except ImportError:\n            logger.warning(""Could not load toolkit support module \'%s\'"" % (toolkit_module,))\n\nAdapterRegistry.toolkit_registry.select_toolkit(TOOLKIT)\n'"
mvc/adapters/dummy_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .abstract_adapter import AbstractAdapter\n\nclass DummyAdapter(AbstractAdapter):\n    """"""\n        An adapter that does nothing. Really nothing.\n    """"""\n\n    def __init__(self, controller=None, prop=None, widget=None):\n        super(DummyAdapter, self).__init__(controller, prop, widget)\n\n    def _connect_widget(self):\n        pass # nothing to do\n\n    def _disconnect_widget(self, widget=None):\n        pass # nothing to do\n\n    def _connect_model(self):\n        pass # nothing to do\n\n    def _disconnect_model(self, model=None):\n        pass # nothing to do\n\n    def _read_widget(self):\n        pass # nothing to do\n\n    def _write_widget(self, val):\n        pass # nothing to do\n\n    def _read_property(self, *args):\n        pass # nothing to do\n\n    def _write_property(self, value, *args):\n        pass # nothing to do\n\n    pass # end of class'"
mvc/adapters/metaclasses.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .adapter_registry import AdapterRegistry\n\nclass MetaAdapter(type):\n    """"""\n        A meta class for adapter classes that automatically\n        registers them in the global \'adapter_registry\'. \n    """"""\n    def __new__(cls, clsname, bases, attrs):\n        newclass = super(MetaAdapter, cls).__new__(cls, clsname, bases, attrs)\n        AdapterRegistry.register(newclass)\n        return newclass\n\n    pass # end of class'"
mvc/adapters/model_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom contextlib import contextmanager\n\nfrom ..support.utils import not_none\nfrom ..observers import Observer\n\nfrom ..models import Model\nfrom ..models.properties import LabeledProperty\n\nfrom .abstract_adapter import AbstractAdapter\n\nclass ModelAdapter(Observer, AbstractAdapter):\n    """"""\n        Model-side implementation of the _AbstractAdapter interface.\n    """"""\n\n    # Mode-side property handling:\n    _prop_read = None\n    _prop_write = None\n    _value_error = None\n\n    @property\n    def property_name(self):\n        """"""Returns the property name the adapter is connected to""""""\n        return self._prop.label\n\n    _ignoring_notifs = False\n    @contextmanager\n    def _ignore_notifications(self):\n        """"""Context manager to temporarily (and exception-safe) ignore\n        property changed notifications (e.g. when we\'re setting the model\n        from the widget and vice versa)""""""\n        self._ignoring_notifs = True\n        yield\n        self._ignoring_notifs = False\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        Abstract class that implements the model side of the adapter.\n        For a fully implemented class check the corresponding widget toolkit\n        modules. \n\n        This class handles only assignments to properties. For other\n        kinds of setting (e.g. user-defined classes used as\n        observable properties, containers, etc.) use other types of\n        Adapters derived from this class.\n        \n        Controller is the controller creating this Adapter.\n        Prop is either a :class:`~..models.properties.LabeledProperty` instance\n        taken from the controller\'s model, or a \'dotted string\' describing a\n        property from the controller\'s model. E.g. it is possible to pass: \n        a.b.c which will then result in property c from attribute b from \n        attribute a from the controller\'s model to be observed.\n        This way nested properties can also be handled.\n        \n        prop_{read, write} are two optional functions that apply\n        custom modifications to the value of the property after\n        reading and before setting it on the model (e.g. transforming a float\n        to a string and vice-versa). Both take a value and must return a\n        transformed value.\n        \n        value_error can be a function to be called when a ValueError exception\n        occurs while trying to set an invalid value for the property on the\n        model. The function will receive: the adapter, the property name and\n        the value coming from the widget that offended the model.\n\n        spurious controls if the adapter should receive spurious\n        changes from the model (see spuriousness in class Observer for\n        further information).\n        """"""\n        controller = args[0]\n        prop = args[1]\n        widget = args[2]\n\n        prop_read = kwargs.pop(""prop_read"", None)\n        prop_write = kwargs.pop(""prop_write"", None)\n        value_error = kwargs.pop(""value_error"", None)\n        spurious = kwargs.get(""spurious"", False)\n\n        # First parse (optional) property strings:\n        prop, self._model = self._parse_prop(prop, controller.model)\n\n        # Call base __init__\'s:\n        super(ModelAdapter, self).__init__(*args, **kwargs)\n\n        # Mode-side property handling:\n        self._prop_read = not_none(prop_read, self._prop_read)\n        self._prop_write = not_none(prop_write, self._prop_write)\n        self._value_error = not_none(value_error, self._value_error)\n\n        # Connect the model\n        self._connect_model()\n        return\n\n    # ----------------------------------------------------------------------\n    #  Model connecting & disconnecting:\n    # ----------------------------------------------------------------------\n    def _parse_prop(self, prop, model):\n        """"""Parses (optional) prop strings for the given model""""""\n        if not isinstance(prop, LabeledProperty):\n            parts = prop.split(""."")\n            if len(parts) > 1:\n                # identifies the model\n                models = parts[:-1]\n                for name in models:\n                    model = getattr(model, name)\n                    if not isinstance(model, Model):\n                        raise TypeError(\n                            ""Attribute \'%s\' was expected to be a "" +\n                            ""Model, but found: \'%s\'"" % (name, model))\n                prop = getattr(type(model), parts[-1])\n            else: prop = parts[0]\n        return prop, model\n\n    def _connect_model(self):\n        """"""Used internally to connect the property into the model, and\n        register self as a value observer for that property""""""\n\n        # prop is inside model?\n        if not hasattr(self._model, self._prop.label):\n            raise ValueError(""Attribute \'"" + self._prop.label +\n                             ""\' not found in model "" + str(self._model))\n\n        # is it observable?\n        if self._prop.observable:\n            self.observe(self._on_prop_changed, self._prop.label, assign=True)\n            self.observe_model(self._model)\n\n    def _on_prop_changed(self, *args, **kwargs):\n        """"""Called by the observation code, when the value in the\n        observed property is changed""""""\n        if not self._ignoring_notifs:\n            self.update_widget()\n\n    def _disconnect_model(self, model=None):\n        # disconnects the model\n        model = not_none(self._model, model)\n        if model is not None:\n            self.relieve_model(self._model)\n            self._model = None\n\n    # ----------------------------------------------------------------------\n    #  Model-side reading and writing\n    # ----------------------------------------------------------------------\n    def _get_property_value(self):\n        """"""Private method that returns the property value currently stored\n        in the model, without transformations.""""""\n        return getattr(self._model, self._prop.label)\n\n    def _set_property_value(self, val):\n        """"""Private method that sets the property value stored in the model,\n        without transformations.""""""\n        return setattr(self._model, self._prop.label, val)\n\n    def _read_property(self, *args):\n        """"""Returns the (possibly transformed) property value stored in the \n        model""""""\n        if self._prop_read: return self._prop_read(self._get_property_value(*args))\n        return self._get_property_value(*args)\n\n    def _write_property(self, value, *args):\n        """"""Sets the value of property. The given value is transformed\n        using the prop_write function passed to the constructor.\n        An attempt at casting the value to the property type is also made.""""""\n        raw_value = value\n        try:\n            # transform if needed:\n            if self._prop_write: value = self._prop_write(value)\n\n            # set the property, ignore updates:\n            with self._ignore_notifications():\n                self._set_property_value(value, *args)\n\n        except ValueError:\n            # let the user handle the error if he wants that:\n            if self._value_error:\n                self._value_error(self, self._prop.label, raw_value)\n            else:\n                raise\n\n    pass # end of class\n'"
mvc/models/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom .base import Model\nfrom .treenode import TreeNode\n\n__all__ = [ ""Model"", ""TreeNode"" ]\n'"
mvc/models/base.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport inspect\nimport logging\nfrom mvc.support.gui_loop import add_idle_call\n\nlogger = logging.getLogger(__name__)\n\nfrom weakref import WeakKeyDictionary\n\ntry:\n    import threading as threading\nexcept ImportError: \n    import dummy_threading as threading\n    \ntry:\n    from fastrlock.rlock import FastRLock as RLock\nexcept ImportError:    \n    from threading import RLock\n\nfrom ..support.collections.weak_list import WeakList\n\nfrom ..support.observables import ObsWrapperBase, Signal\nfrom ..observers import Observer, NTInfo\n\nfrom .metaclasses import ModelMeta\nfrom .properties import UUIDProperty\n\nclass Model(Observer, metaclass=ModelMeta):\n    """"""\n    .. attribute:: __observables__\n    \n       Class attribute. A list or tuple of name strings. The metaclass\n       :class:`~mvc.support.metaclasses.ObservablePropertyMeta`\n       uses it to create properties.\n       \n       *Value properties* have to exist as an attribute with an\n       initial value, which may be ``None``.\n\n       *Logical properties* require a getter and may have a setter method in\n       the class.\n    """"""\n\n    """"""A base class for models whose observable properties can be\n    changed by threads different than the (gtk) main thread. Notification is\n    performed by exploiting the gtk idle loop only if needed,\n    otherwise the standard notification system (direct method call) is\n    used. In this model, the observer is expected to run in the gtk\n    main loop thread.""""""\n\n    class Meta(object):\n        """"""\n            A meta-data class providing some basic functionality \n        """"""\n\n        @classmethod\n        def get_column_properties(cls):\n            if not hasattr(cls, ""all_properties""):\n                raise RuntimeError(""Meta class \'%s\' has not been initialized"" \\\n                    "" properly: \'all_properties\' is not set!"" % type(cls))\n            else:\n                cls._mem_columns = getattr(cls, ""_mem_columns"", None)\n                if cls._mem_columns is None:\n                    cls._mem_columns = [(attr.label, attr.data_type) for attr in cls.all_properties if attr.tabular]\n                return cls._mem_columns\n\n        @classmethod\n        def get_local_persistent_properties(cls):\n            return [attr for attr in cls.properties if attr.persistent]\n\n        @classmethod\n        def get_viewless_properties(cls):\n            if not hasattr(cls, ""all_properties""):\n                raise RuntimeError(""Meta class \'%s\' has not been initialized"" \\\n                    "" properly: \'all_properties\' is not set!"" % type(self))\n            else:\n                return [attr for attr in cls.all_properties if not attr.visible]\n\n        @classmethod\n        def get_viewable_properties(cls):\n            if not hasattr(cls, ""all_properties""):\n                raise RuntimeError(""Meta class \'%s\' has not been initialized"" \\\n                    "" properly: \'all_properties\' is not set!"" % type(self))\n            else:\n                return [attr for attr in cls.all_properties if attr.visible]\n\n        pass # end of class\n\n    uuid = UUIDProperty(persistent=True, observable=False)\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        super(Model, self).__init__(*args, **kwargs)\n\n        self._prop_lock = RLock() # @UndefinedVariable\n        self.__observers = WeakList()\n        self.__observer_threads = WeakKeyDictionary()\n\n        # keys are properties names, values are pairs (method,\n        # kwargs|None) inside the observer. kwargs is the keyword\n        # argument possibly specified when explicitly defining the\n        # notification method in observers, and it is used to build\n        # the NTInfo instance passed down when the notification method\n        # is invoked. If kwargs is None (special case), the\n        # notification method is ""old style"" (property_<name>_...) and\n        # won\'t be receiving the property name.\n        self.__value_notifications = {}\n        self.__instance_notif_before = {}\n        self.__instance_notif_after = {}\n        self.__signal_notif = {}\n\n        for attr in self.Meta.all_properties: self.register_property(attr)\n        return\n\n    def register_property(self, prop):\n        """"""Registers an existing attribute to be monitored, and sets\n        up notifiers for notifications""""""\n        if prop.label not in self.__value_notifications:\n            self.__value_notifications[prop.label] = []\n            pass\n\n        # registers observable wrappers\n        propval = getattr(type(self), prop.label)._get(self)\n\n        if isinstance(propval, ObsWrapperBase):\n            propval.__add_model__(self, prop.label)\n\n            if isinstance(propval, Signal):\n                if prop.label not in self.__signal_notif:\n                    self.__signal_notif[prop.label] = []\n                    pass\n                pass\n            else:\n                if prop.label not in self.__instance_notif_before:\n                    self.__instance_notif_before[prop.label] = []\n                    pass\n                if prop.label not in self.__instance_notif_after:\n                    self.__instance_notif_after[prop.label] = []\n                    pass\n                pass\n            pass\n\n        return\n\n    def has_property(self, label):\n        """"""Returns true if given property name refers an observable\n        property inside self or inside derived classes.""""""\n        for prop in self.Meta.all_properties:\n            if prop.label == label:\n                return True\n\n    def register_observer(self, observer):\n        """"""Register given observer among those observers which are\n        interested in observing the model.""""""\n        if observer in self.__observers: return # not already registered\n\n        assert isinstance(observer, Observer)\n        self.__observers.append(observer)\n        self.__observer_threads[observer] = threading.current_thread() # @UndefinedVariable\n        for prop in self.Meta.all_properties:\n            self.__add_observer_notification(observer, prop)\n            pass\n\n        return\n\n    def unregister_observer(self, observer):\n        """"""Unregister the given observer that is no longer interested\n        in observing the model.""""""\n\n        assert isinstance(observer, Observer)\n\n        if observer not in self.__observers: return\n        for prop in self.Meta.all_properties:\n            self.__remove_observer_notification(observer, prop)\n            pass\n\n        self.__observers.remove(observer)\n        del self.__observer_threads[observer]\n\n        return\n\n    def _reset_property_notification(self, prop, old=None):\n        """"""Called when an assignment has been done that changes the\n        type of a property or the instance of the property has been\n        changed to a different instance. In this case it must be\n        unregistered and registered again. Optional parameter old has\n        to be used when the old value is an instance (derived from \n        ObsWrapperBase) which needs to unregistered from the model, via\n        a call to method old.__remove_model__(model, prop_name)""""""\n\n        # unregister_property\n        if isinstance(old, ObsWrapperBase):\n            old.__remove_model__(self, prop.label)\n            pass\n\n        self.register_property(prop)\n\n        for observer in self.__observers:\n            self.__remove_observer_notification(observer, prop)\n            self.__add_observer_notification(observer, prop)\n            pass\n        return\n\n    def __add_observer_notification(self, observer, prop):\n        """"""\n        Find observing methods and store them for later notification.\n\n        *observer* an instance.\n        \n        *label* a string.\n\n        This checks for magic names as well as methods explicitly added through\n        decorators or at runtime. In the latter case the type of the notification\n        is inferred from the number of arguments it takes.\n        """"""\n        value = getattr(type(self), prop.label)._get(self)\n\n        # --- Some services ---\n        def getmeth(format, numargs): # @ReservedAssignment\n            name = format % prop.label\n            meth = getattr(observer, name)\n            args, varargs, _, _ = inspect.getargspec(meth)\n            if not varargs and len(args) != numargs:\n                logger.warn(""Ignoring notification %s: exactly %d arguments""\n                    "" are expected"", name, numargs)\n                raise AttributeError\n            return meth\n\n        def add_value(notification, kw=None):\n            pair = (notification, kw)\n            if pair in self.__value_notifications[prop.label]: return\n            logger.debug(""Will call %s.%s after assignment to %s.%s"",\n                observer.__class__.__name__, notification.__name__,\n                self.__class__.__name__, prop.label)\n            self.__value_notifications[prop.label].append(pair)\n            return\n\n        def add_before(notification, kw=None):\n            if (not isinstance(value, ObsWrapperBase) or\n                isinstance(value, Signal)):\n                return\n\n            pair = (notification, kw)\n            if pair in self.__instance_notif_before[prop.label]: return\n            logger.debug(""Will call %s.%s before mutation of %s.%s"",\n                observer.__class__.__name__, notification.__name__,\n                self.__class__.__name__, prop.label)\n            self.__instance_notif_before[prop.label].append(pair)\n            return\n\n        def add_after(notification, kw=None):\n            if (not isinstance(value, ObsWrapperBase) or\n                isinstance(value, Signal)):\n                return\n            pair = (notification, kw)\n            if pair in self.__instance_notif_after[prop.label]: return\n            logger.debug(""Will call %s.%s after mutation of %s.%s"",\n                observer.__class__.__name__, notification.__name__,\n                self.__class__.__name__, prop.label)\n            self.__instance_notif_after[prop.label].append(pair)\n            return\n\n        def add_signal(notification, kw=None):\n            if not isinstance(value, Signal): return\n            pair = (notification, kw)\n            if pair in self.__signal_notif[prop.label]: return\n            logger.debug(""Will call %s.%s after emit on %s.%s"",\n                observer.__class__.__name__, notification.__name__,\n                self.__class__.__name__, prop.label)\n            self.__signal_notif[prop.label].append(pair)\n            return\n        # ---------------------\n\n        try: notification = getmeth(""property_%s_signal_emit"", 3)\n        except AttributeError: pass\n        else: add_signal(notification)\n\n        try: notification = getmeth(""property_%s_value_change"", 4)\n        except AttributeError: pass\n        else: add_value(notification)\n\n        try: notification = getmeth(""property_%s_before_change"", 6)\n        except AttributeError: pass\n        else: add_before(notification)\n\n        try: notification = getmeth(""property_%s_after_change"", 7)\n        except AttributeError: pass\n        else: add_after(notification)\n\n        # here explicit notification methods are handled (those which\n        # have been statically or dynamically registered)\n        type_to_adding_method = {\n            \'assign\' : add_value,\n            \'before\' : add_before,\n            \'after\'  : add_after,\n            \'signal\' : add_signal,\n            }\n\n        for meth in observer.get_observing_methods(prop.label):\n            added = False\n            kw = observer.get_observing_method_kwargs(prop.label, meth)\n            for flag, adding_meth in type_to_adding_method.items():\n                if flag in kw:\n                    added = True\n                    adding_meth(meth, kw)\n                    pass\n                pass\n            if not added: raise ValueError(""In %s notification method %s is ""\n                                           ""marked to be observing property ""\n                                           ""\'%s\', but no notification type ""\n                                           ""information were specified."" %\n                                           (observer.__class__,\n                                            meth.__name__, prop.label))\n            pass\n\n        return\n\n    def __remove_observer_notification(self, observer, prop):\n        """"""\n        Remove all stored notifications.\n        \n        *observer* an instance.\n        \n        *prop* a LabeledProperty instance.\n        """"""\n\n        def side_effect(seq):\n            for meth, kw in reversed(seq):\n                if meth.__self__ is observer:\n                    seq.remove((meth, kw))\n                    yield meth\n\n        for meth in side_effect(self.__value_notifications.get(prop.label, ())):\n            logger.debug(""Stop calling \'%s\' after assignment"", meth.__name__)\n\n        for meth in side_effect(self.__signal_notif.get(prop.label, ())):\n            logger.debug(""Stop calling \'%s\' after emit"", meth.__name__)\n\n        for meth in side_effect(self.__instance_notif_before.get(prop.label, ())):\n            logger.debug(""Stop calling \'%s\' before mutation"", meth.__name__)\n\n        for meth in side_effect(self.__instance_notif_after.get(prop.label, ())):\n            logger.debug(""Stop calling \'%s\' after mutation"", meth.__name__)\n\n        return\n\n    def __notify_observer__(self, observer, method, *args, **kwargs):\n        """"""This makes a call either through the Gtk.idle list or a\n        direct method call depending whether the caller\'s thread is\n        different from the observer\'s thread""""""\n\n        assert observer in self.__observer_threads\n        if threading.currentThread() == self.__observer_threads[observer]: # @UndefinedVariable\n            self.__idle_notify_observer(observer, method, args, kwargs)\n        else:\n            add_idle_call(self.__idle_notify_observer, observer, method, args, kwargs)\n\n    def __idle_notify_observer(self, observer, method, args, kwargs):\n        method(*args, **kwargs)\n\n\n    # -------------------------------------------------------------\n    #            Notifiers:\n    # -------------------------------------------------------------\n    def notify_property_value_change(self, prop_name, old, new):\n        """"""\n        Send a notification to all registered observers.\n\n        *old* the value before the change occured.\n        """"""\n        assert(prop_name in self.__value_notifications)\n        for method, kw in self.__value_notifications[prop_name] :\n            obs = method.__self__\n            # notification occurs checking spuriousness of the observer\n            if old != new or obs.accepts_spurious_change():\n                if kw is None: # old style call without name\n                    self.__notify_observer__(obs, method,\n                                             self, old, new)\n                elif \'old_style_call\' in kw:  # old style call with name\n                    self.__notify_observer__(obs, method,\n                                             self, prop_name, old, new)\n                else:\n                    # New style explicit notification.\n                    # notice that named arguments overwrite any\n                    # existing key:val in kw, which is precisely what\n                    # it is expected to happen\n                    info = NTInfo(\'assign\',\n                                  kw, model=self, prop_name=prop_name,\n                                  old=old, new=new)\n                    self.__notify_observer__(obs, method,\n                                             self, prop_name, info)\n                    pass\n                pass\n            pass\n        return\n\n    def notify_method_before_change(self, prop_name, instance, meth_name,\n                                    args, kwargs):\n        """"""\n        Send a notification to all registered observers.\n\n        *instance* the object stored in the property.\n\n        *meth_name* name of the method we are about to call on *instance*.\n        """"""\n        assert(prop_name in self.__instance_notif_before)\n        for method, kw in self.__instance_notif_before[prop_name]:\n            obs = method.__self__\n            # notifies the change\n            if kw is None: # old style call without name\n                self.__notify_observer__(obs, method,\n                                         self, instance,\n                                         meth_name, args, kwargs)\n            elif \'old_style_call\' in kw:  # old style call with name\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, instance,\n                                         meth_name, args, kwargs)\n            else:\n                # New style explicit notification.\n                # notice that named arguments overwrite any\n                # existing key:val in kw, which is precisely what\n                # it is expected to happen\n                info = NTInfo(\'before\',\n                              kw,\n                              model=self, prop_name=prop_name,\n                              instance=instance, method_name=meth_name,\n                              args=args, kwargs=kwargs)\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, info)\n                pass\n            pass\n        return\n\n    def notify_method_after_change(self, prop_name, instance, meth_name,\n                                   res, args, kwargs):\n        """"""\n        Send a notification to all registered observers.\n\n        *args* the arguments we just passed to *meth_name*.\n\n        *res* the return value of the method call.\n        """"""\n        assert(prop_name in self.__instance_notif_after)\n        for method, kw in self.__instance_notif_after[prop_name]:\n            obs = method.__self__\n            # notifies the change\n            if kw is None:  # old style call without name\n                self.__notify_observer__(obs, method,\n                                         self, instance,\n                                         meth_name, res, args, kwargs)\n            elif \'old_style_call\' in kw:  # old style call with name\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, instance,\n                                         meth_name, res, args, kwargs)\n            else:\n                # New style explicit notification.\n                # notice that named arguments overwrite any\n                # existing key:val in kw, which is precisely what\n                # it is expected to happen\n                info = NTInfo(\'after\',\n                              kw,\n                              model=self, prop_name=prop_name,\n                              instance=instance, method_name=meth_name,\n                              result=res, args=args, kwargs=kwargs)\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, info)\n                pass\n            pass\n        return\n\n    def notify_signal_emit(self, prop_name, arg):\n        """"""\n        Emit a signal to all registered observers.\n\n        *prop_name* the property storing the :class:`~mvc.observable.Signal`\n        instance.\n\n        *arg* one arbitrary argument passed to observing methods.\n        """"""\n        assert(prop_name in self.__signal_notif)\n\n        for method, kw in self.__signal_notif[prop_name]:\n            obs = method.__self__\n            # notifies the signal emit\n            if kw is None: # old style call, without name\n                self.__notify_observer__(obs, method,\n                                         self, arg)\n            elif \'old_style_call\' in kw:  # old style call with name\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, arg)\n            else:\n                # New style explicit notification.\n                # notice that named arguments overwrite any\n                # existing key:val in kw, which is precisely what\n                # it is expected to happen\n                info = NTInfo(\'signal\',\n                              kw,\n                              model=self, prop_name=prop_name, arg=arg)\n                self.__notify_observer__(obs, method,\n                                         self, prop_name, info)\n                pass\n            pass\n        return\n\n\n    pass # end of class Model\n# ----------------------------------------------------------------------\n'"
mvc/models/metaclasses.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport types\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom collections import OrderedDict\n\nfrom .properties import LabeledProperty\nfrom .object_pool import ThreadedObjectPool\n\nfrom ..support.utils import get_unique_list, get_new_uuid\n\nclass ModelMeta(type):\n    """"""\n    This is a meta-class that provides support to quickly set up a model with\n    observable properties. For the simplest attributes you can omit the usual\n    setters and getters if nothing else needs to be done but setting and getting\n    the property. You can also provide your own implementation of the setters \n    and getters (see below). Classes instantiated by this meta-class will be \n    also be registered in an object pool using a UUID attribute. You do not\n    need to add this property to your inner \'Meta\' class.\n    Classes instantiated by this metaclass must provide a method named\n    notify_property_value_change(self, prop_name, old, new), or notification of\n    property changes using \'Observer\' won\'t work.\n    ModelMeta also provides multi-threading support for accessing properties, \n    through a (very basic) locking mechanism. It is assumed a lock is\n    owned by the class that uses it. A Lock object called _prop_lock\n    is assumed to be a member of the using class.\n    \n    How can you use this metaclass?\n    First, \'__metaclass__ = ModelMeta\' must be class member of the class\n    you want to make the automatic properties handling.\n    \n    Second, the model class needs to define an inner \'Meta\' class in which\n    you define meta-data which is used by this class (also see \'ModelMeta.Meta\'\n    class).\n    This class defines several properties, the most important being \'properties\'.\n    This attribute is a list of descriptor objects, each of which describe\n    a single property. Aside from the basics (name, default, etc.) it can\n    contain additional information describing how/if other parts of the \n    framework can use this attribute (e.g. is it supposed to be stored?, does \n    it have a visual representation?). \n    That\'s all: after the instantiation, your class will contain all properties\n    you named inside \'properties\'. Each of them will be also associated\n    to a couple of automatically-generated functions which get and set the\n    property value inside a generated member variable.\n    \n    Custom setters and getters:\n    Suppose the property is called \'x\'.  The generated variable (which keeps\n    the real value of the property x) is called _x. The getter is called \n    \'get_x(self)\', and the setter is called \'set_x(self, value)\'. The base\n    implementation of this getter is to return the value stored in the variable\n    associated with the property. The setter simply sets its value.\n    Programmers can override basic behavior for getters or setters simply by\n    defining their getters and setters using the name convention above.\n    The customized function can lie anywhere in the user classes hierarchy.\n    Every overridden function will not be generated by the metaclass.\n\n    For some properties it can be interesting to create a new descriptor class, \n    and XXXXX TODO TODO\n\n    """"""\n\n    object_pool = ThreadedObjectPool()\n\n    # ------------------------------------------------------------\n    #      Type creation:\n    # ------------------------------------------------------------\n    def __new__(cls, name, bases, _dict):\n        # find all data descriptors, auto-set their labels\n        properties = {}\n        for label, _property in list(_dict.items()):\n            if isinstance(_property, LabeledProperty):\n                _property.label = label\n                properties[label] = _property\n\n        # Create the class type:\n        new_class = super(ModelMeta, cls).__new__(cls, name, bases, _dict)\n        # Get the meta class:\n        meta = cls.get_meta(new_class, name, bases, _dict)\n        # Set the properties for future reference:\n        meta.properties = sorted(properties.values(), key=lambda prop: getattr(prop, \'declaration_index\', 0))\n        # Return our new class:\n        return new_class\n\n    def __init__(cls, name, bases, _dict):\n        cls.process_properties(name, bases, _dict)\n        return super(ModelMeta, cls).__init__(name, bases, _dict)\n\n    # ------------------------------------------------------------\n    #      Instance creation:\n    # ------------------------------------------------------------\n    def __call__(cls, *args, **kwargs): # @NoSelf\n        """"""\n        This method checks if the passed keyword args contained a ""uuid"" key, if\n        so it is popped (the actual class\'s __init__ doesn\'t get it). If not\n        a new UUID is created. \n        The class instance is then created and the UUID is set accordingly. \n        """"""\n        # Check if uuid has been passed (e.g. when restored from disk)\n        # if not, generate a new one\n        try:\n            uuid = kwargs.pop(""uuid"")\n        except KeyError:\n            uuid = get_new_uuid()\n\n        # Create instance:\n        instance = type.__call__(cls, *args, **kwargs)\n\n        # Set the UUID\n        instance.uuid = uuid\n\n        return instance\n\n    # ------------------------------------------------------------\n    #               Services\n    # ------------------------------------------------------------\n    def get_meta(cls, name, bases, _dict): #@NoSelf\n        """""" Extracts or creates the meta class for this new model """"""\n        try:\n            meta = _dict[""Meta""]\n        except KeyError:\n            if len(bases) == 1:\n                meta = type(""Meta"", (bases[0].Meta,), dict(properties=[]))\n                cls.set_attribute(_dict, ""Meta"", meta)\n                _dict[""Meta""] = meta\n            else:\n                raise TypeError(""Class %s.%s has not defined an inner Meta class, and has multiple base classes!"" % (cls.__module__, cls.__name__))\n        return meta\n\n    def process_properties(cls, name, bases, _dict):  # @NoSelf\n        """"""Processes the properties defined in the class\'s metadata class.""""""\n\n        # Get the meta class:\n        meta = cls.get_meta(name, bases, _dict)\n\n        # Get the list of properties for this class type (excluding bases):\n        properties = get_unique_list(meta.properties)\n\n        # Check the list of observables is really an iterable:\n        if not isinstance(properties, list):\n            raise TypeError(""%s.%s.Meta \'properties\' must be a list, not \'%s\'"" %\n                            (cls.__module__, cls.__name__, type(properties)))\n\n        # Generates the list of _all_ properties available for this class\'s bases\n        all_properties = OrderedDict()\n\n        # Loop over bases in reverse order:\n        for class_type in bases[::-1]:\n            # Loop over their properties, and update the dictionary:\n            if hasattr(class_type, ""Meta""):\n                for attr in getattr(class_type.Meta, ""all_properties"", []):\n                    all_properties[attr.label] = attr\n\n        # Add new/Override old attributes:\n        for attr in properties:\n            all_properties[attr.label] = attr\n\n        # Set all_properties on the metadata class:\n        meta.all_properties = list(all_properties.values())\n\n        logger.debug(""Class %s.%s has properties: %s"" \\\n                     % (cls.__module__, cls.__name__, all_properties))\n\n        pass # end of method\n\n    def check_value_change(cls, old, new): # @NoSelf\n        """"""Checks whether the value of the property changed in type\n        or if the instance has been changed to a different instance.\n        If true, a call to model._reset_property_notification should\n        be called in order to re-register the new property instance\n        or type""""""\n        from ..support import observables\n        return  type(old) != type(new) or \\\n               isinstance(old, observables.ObsWrapperBase) and (old != new)\n\n    def set_attribute(cls, _dict, name, value): # @NoSelf\n        """"""Sets an attribute on the class and the dict""""""\n        _dict[name] = value\n        setattr(cls, name, value)\n\n    def del_attribute(cls, _dict, name): # @NoSelf\n        """"""Deletes an attribute from the class and the dict""""""\n        del _dict[name]\n        delattr(cls, name)\n\n    pass # end of class\n# ----------------------------------------------------------------------\n'"
mvc/models/object_pool.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom weakref import WeakValueDictionary\nimport threading\nimport multiprocessing\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom ..support.utils import get_new_uuid\n\nclass ObjectPool(object):\n    """"""\n        This class allows to fetch mvc model objects using their UUID.\n        This requires to model to have a property called ""uuid"". All\n        class inheriting from the base \'Model\' class will have this.\n        If implementing a custom model, the UUID property is responsible\n        for the removal and addition to the pool when it changes values.\n        Also see the UUIDProperty descriptor for an example implementation.\n        We can use this to store complex relations between objects where \n        references to each other can be replaced with the UUID.\n        For a multi-threaded version see ThreadedObjectPool. \n    """"""\n\n    def __init__(self, *args, **kwargs):\n        object.__init__(self)\n        self._objects = WeakValueDictionary()\n\n    def add_or_get_object(self, obj):\n        try:\n            self.add_object(obj, force=False, silent=False)\n            return obj\n        except KeyError:\n            return self.get_object(obj.uuid)\n\n    def add_object(self, obj, force=False, fail_on_duplicate=False):\n        if not obj.uuid in self._objects or force:\n            self._objects[obj.uuid] = obj\n        elif fail_on_duplicate:\n            raise KeyError(""UUID %s is already taken by another object %s, cannot add object %s"" % (obj.uuid, self._objects[obj.uuid], obj))\n        else:\n            # Just change the objects uuid, will break refs, but\n            # it prevents issues with inherited properties etc.\n            logger.warning(""A duplicate UUID was passed to an ObjectPool for a %s object."" % obj)\n            obj.uuid = get_new_uuid()\n\n    def change_all_uuids(self):\n        # first get a copy off all uuids & objects:\n        items = list(self._objects.items())\n        for uuid, obj in items: # @UnusedVariable\n            obj.uuid = get_new_uuid()\n\n    def remove_object(self, obj):\n        if obj.uuid in self._objects and self._objects[obj.uuid] == obj:\n            del self._objects[obj.uuid]\n\n    def get_object(self, uuid):\n        obj = self._objects.get(uuid, None)\n        return obj\n\n    def clear(self):\n        self._objects.clear()\n\nclass ThreadedObjectPool(object):\n\n    def __init__(self, *args, **kwargs):\n        object.__init__(self)\n        self.pools = {}\n\n    def clean_pools(self):\n        for ptkey in list(self.pools.keys()):\n            if (ptkey == (None, None) or not ptkey[0].is_alive() or not ptkey[1].is_alive()):\n                del self.pools[ptkey] # clear this sucker\n\n    def get_pool(self):\n        process = multiprocessing.current_process()\n        thread = threading.current_thread()\n        pool = self.pools.get((process, thread), ObjectPool())\n        self.pools[(process, thread)] = pool\n        return pool\n\n    def add_or_get_object(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.add_or_get_object(*args, **kwargs)\n\n    def add_object(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.add_object(*args, **kwargs)\n\n    def change_all_uuids(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.change_all_uuids(*args, **kwargs)\n\n    def remove_object(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.remove_object(*args, **kwargs)\n\n    def get_object(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.get_object(*args, **kwargs)\n\n    def clear(self, *args, **kwargs):\n        pool = self.get_pool()\n        return pool.clear(*args, **kwargs)\n\n    pass # end of class\n'"
mvc/models/treenode.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nclass TreeNode(object):\n    """"""\n        A TreeNode can be used to build a Tree of objects with parents & \n        children and support for inserting, appending, removing, iterating and\n        inspecting them.\n        This is the type that models should use.\n        The root object can than be wrapped easily by a UI-toolkit specific \n        wrapper, like the gtk ObjectTreeStore wrapper. \n    """"""\n    def insert(self, index, child_node):\n        """"""\n            Inserts the \'child_node\' in this TreeNode at the given index.\n            If the passed argument is not a TreeNode instance, it is wrapped\n            in one. So you can safely pass in arbitrary objects.\n            This functions returns the (wrapped) child_node.\n        """"""\n        assert isinstance(child_node, type(self))\n        child_node.parent = self\n        self._children.insert(index, child_node)\n        self.on_grandchild_inserted(child_node)\n        return child_node\n\n    def append(self, child_node):\n        """"""\n            Appends the \'child_node\' to this TreeNode. If the passed\n            argument is not a TreeNode instance, it is wrapped in one.\n            So you can safely pass in arbitrary objects.\n            This functions returns the (wrapped) child_node.\n        """"""\n        assert isinstance(child_node, TreeNode)\n        return self.insert(len(self._children), child_node)\n\n    def remove(self, child_node):\n        """"""\n            Removes the given child_node from this TreeNode\'s list of children.\n            \'child_node\' *must* be a TreeNode instance. \n        """"""\n        assert isinstance(child_node, type(self))\n        self.on_grandchild_removed(child_node)\n        self._children.remove(child_node)\n        child_node._parent = None\n\n    def on_grandchild_removed(self, child_node):\n        if self.parent is not None:\n            self.parent.on_grandchild_removed(child_node)\n\n    def on_grandchild_inserted(self, child_node):\n        if self.parent is not None:\n            self.parent.on_grandchild_removed(child_node)\n\n    _parent = None\n    @property\n    def parent(self):\n        return self._parent\n    @parent.setter\n    def parent(self, parent):\n        if self._parent:\n            self._parent.remove(self)\n        self._parent = parent\n\n    @property\n    def has_children(self):\n        return bool(self._children)\n\n    @property\n    def child_count(self):\n        return len(self._children)\n\n    def __init__(self, obj=None, children=()):\n        super(TreeNode, self).__init__()\n        self.object = obj\n        self._children = list()\n        for child in children: self.append(child)\n\n    def get_child_node_index(self, child_node):\n        return self._children.index(child_node)\n\n    def get_root_node(self):\n        parent = self.parent\n        while parent.parent is not None:\n            parent = parent.parent\n        return parent\n\n    def get_next_node(self):\n        try:\n            return self.parent.get_child_node(\n                self.parent.get_child_node_index(self) + 1)\n        except IndexError:\n            return None\n\n    def get_prev_node(self):\n        try:\n            return self.parent.get_child_node(\n                self.parent.get_child_node_index(self) - 1)\n        except IndexError:\n            return None\n\n    def get_indices(self):\n        parent = self.parent\n        node = self\n        indeces = tuple()\n        while parent is not None:\n            indeces += (parent.get_child_node_index(node),)\n            node = parent\n            parent = parent.parent\n        return indeces[::-1] or None\n\n    def get_child_node(self, *indeces):\n        node = self\n        for index in indeces:\n            try:\n                node = node._children[index]\n            except IndexError:\n                return None\n        return node\n\n    def get_first_child_node(self):\n        try:\n            return self._children[0]\n        except IndexError:\n            return None\n\n    def get_child_object(self, *indeces):\n        return self.get_child_node(*indeces).object\n\n    def clear(self):\n        for c in self.iter_children(reverse=True):\n            c.parent = None\n\n    def iter_children(self, reverse=False, recursive=True):\n        children = self._children if not reverse else self._children[::-1]\n        for child_node in children:\n            if recursive and child_node.has_children:\n                for c in child_node.iter_children(reverse=reverse, recursive=recursive):\n                    yield c\n            yield child_node\n\n    def __repr__(self):\n        return \'%s(%s - %s)\' % (type(self).__name__, self.object, ""%d child nodes"" % len(self._children))\n'"
mvc/models/xydata.py,23,"b'\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport types, json\nimport numpy as np\n\nfrom ..support.utils import pop_kwargs\n\nfrom .properties.labeled_property import LabeledProperty\nfrom .base import Model\n\nclass XYData(Model):\n    """"""\n        An XYData is a mixin model holding a list of x-y numbers.  \n        Its values can be indexed, e.g.:\n         >>> xydata = XYData(data=([1, 2, 3], [[4, 5], [6, 7], [8, 9]]))\n         >>> xydata[0]\n         (1, [4, 5])\n         \n        and iterated:\n         >>> xydata = XYData(data=([1, 2, 3], [[4, 5], [6, 7], [8, 9]]))\n         >>> for row in xydata:\n         ...  print row\n         ...\n         (1, [4, 5])\n         (2, [6, 7])\n         (3, [8, 9])\n         \n        You can also associate names with each column:\n         >>> xydata = XYData(data=([1, 2, 3], [[4, 5], [6, 7], [8, 9]]))\n         >>> xydata.y_names = [""First Column"", ""Second Column""]\n         >>> xydata.y_names.get(0, """")\n         \'First Column\'\n    """"""\n\n    # OBSERVABLE PROPERTIES:\n\n    #: The X Data\n    data_x = LabeledProperty(default=None, text=""X data"")\n    @data_x.setter\n    def data_x(self, value):\n        self.set_data(value, self.data_y)\n\n    #: The Y Data\n    data_y = LabeledProperty(default=None, text=""Y data"")\n    @data_y.setter\n    def data_y(self, value):\n        self.set_data(self.data_x, value)\n\n    # REGULAR PROPERTIES:\n    _y_names = []\n    @property\n    def y_names(self):\n        if len(self) < len(self._y_names):\n            return self._y_names[:len(self)]\n        else:\n            return self._y_names\n    @y_names.setter\n    def y_names(self, names):\n        self._y_names = names if names is not None else []\n\n    @property\n    def size(self):\n        return len(self)\n\n    @property\n    def num_columns(self):\n        return 1 + self.data_y.shape[1]\n\n    @property\n    def max_y(self):\n        if len(self.data_y) > 1:\n            return np.max(self.data_y)\n        else:\n            return 0\n\n    @property\n    def min_y(self):\n        if len(self.data_x) > 1:\n            return np.min(self.data_y)\n        else:\n            return 0\n\n    @property\n    def abs_max_y(self):\n        if len(self.data_x) > 1:\n            return np.max(np.absolute(self.data_y))\n        else:\n            return 0\n\n    @property\n    def abs_min_y(self):\n        if len(self.data_x) > 1:\n            return np.min(np.absolute(self.data_y))\n        else:\n            return 0\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for an XYData are:\n                data: the actual data containing x and y values, this can be a:\n                 - JSON string: ""[[x1, x2, ..., xn], [y11, y21, ..., yn1], ..., [y1m, y2m, ..., ynm]]""\n                 - A dictionary from a (deprecated) XYObjectListStore, containing\n                   a data property, which contains a JSON string as above.\n                 - A 2D-numpy array, in which its first axes contains the \n                   data rows, and its second axes contains the columns, first \n                   column being the x-data, and following columns the y-data, e.g.:\n                    np.array([[x1,y11,...,y1m],\n                              [x2,y21,...,y2m],\n                              ...,\n                              [xn,yn1,...,ynm]])\n                  - An iterable containing the x-data and y-data as if it would be\n                    passed to set_data(*data), e.g.:\n                     ([1, 2, 3], [[4, 5], [6, 7], [8, 9]])\n                names: names for the y columns (optional)\n        """"""\n\n        XYData.set_data(self, np.array([], dtype=float), np.zeros(shape=(0, 0), dtype=float))\n\n        my_kwargs = pop_kwargs(kwargs,\n            ""names"", ""data"",\n            *[prop.label for prop in type(self).Meta.get_local_persistent_properties()]\n        )\n        super(XYData, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self.y_names = kwargs.get(""names"", self.y_names)\n\n        data = kwargs.get(""data"", None)\n        if data is not None:\n            if isinstance(data, str):\n                XYData._set_from_serial_data(self, data)\n            elif isinstance(data, dict):\n                XYData._set_from_serial_data(self, data[""properties""][""data""])\n            elif isinstance(data, np.ndarray):\n                XYData.set_data(self, data[:, 0], data[:, 1:])\n            elif hasattr(data, \'__iter__\'):\n                XYData.set_data(self, *data)\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n\n    def _serialize_data(self):\n        """"""\n            Internal method, should normally not be used!\n            If you want to write data to a file, use the save_data method instead!\n        """"""\n        conc = np.insert(self.data_y, 0, self.data_x, axis=1)\n        return ""["" + "","".join(\n                [""["" + "","".join([""%f"" % val for val in row]) + ""]"" for row in conc]\n            ) + ""]""\n\n    def _deserialize_data(self, data):\n        """"""\n            Internal method, should normally not be used!\n            If you want to load data from a file, use the generic.io.file_parsers\n            classes in combination with the load_data_from_generator instead!\n            \'data\' argument should be a json string, containing a list of lists\n            of x and y values, i.e.:\n            [[x1, x2, ..., xn], [y11, y21, ..., yn1], ..., [y1m, y2m, ..., ynm]]\n            If there are n data points and m+1 columns.\n        """"""\n        data = data.replace(""nan"", ""\'nan\'"")\n        data = data.replace(""-inf"", ""\'-inf\'"")\n        data = data.replace(""+inf"", ""\'+inf\'"")\n        data = data.replace(""inf"", ""\'inf\'"")\n        data = json.JSONDecoder().decode(data)\n        return data\n\n    def _set_from_serial_data(self, sdata):\n        """"""Internal method, do not use!""""""\n        data = []\n        try:\n            data = self._deserialize_data(sdata)\n        except ValueError:\n            logger.exception(""Failed to deserialize xy-data string `%s`"" % sdata)\n        if data != []:\n            data = np.array(data, dtype=float)\n            try:\n                x = data[:, 0]\n                y = data[:, 1:]\n            except IndexError:\n                logger.exception(""Failed to load xy-data from serial string: %s"" % sdata)\n            else:\n                XYData.set_data(self, x, y)\n\n    def load_data_from_generator(self, generator, clear=True):\n        if clear: self.clear()\n        for x, y in generator:\n            self.append(x, y)\n\n    # ------------------------------------------------------------\n    #      X-Y Data Management Methods & Functions\n    # ------------------------------------------------------------\n    def _y_from_user(self, y_value):\n        return np.array(y_value, ndmin=2, dtype=float)\n\n    def set_data(self, x, y):\n        """"""\n            Sets data using the supplied x, y1, ..., yn arrays.\n        """"""\n        tempx = np.asarray(x)\n        tempy = np.asarray(y)\n        if tempy.ndim == 1:\n            tempy = tempy.reshape((tempy.size, 1))\n        if tempx.shape[0] != tempy.shape[0]:\n            raise ValueError(""Shape mismatch: x (shape = %s) and y (shape = %s) data need to have compatible shapes!"" % (tempx.shape, tempy.shape))\n        self._data_x = tempx\n        self._data_y = tempy\n\n    def set_value(self, i, j, value):\n        if i < len(self):\n            if j == 0:\n                self.data_x[i] = value\n            elif j >= 1:\n                self.data_y[i, j - 1] = np.array(value, dtype=float)\n            else:\n                raise IndexError(""Column indices must be positive values (is \'%d\')!"" % j)\n        else:\n            raise IndexError(""Row index \'%d\' out of bound!"" % i)\n\n    def append(self, x, y):\n        """"""\n            Appends data using the supplied x, y1, ..., yn arrays.\n        """"""\n        data_x = np.append(self.data_x, x)\n        _y = self._y_from_user(y)\n        if self.data_y.size == 0:\n            data_y = _y\n        else:\n            data_y = np.append(self.data_y, _y, axis=0)\n        self.set_data(data_x, data_y)\n\n    def insert(self, pos, x, y):\n        """"""\n            Inserts data using the supplied x, y1, ..., yn arrays at the given\n            position.\n        """"""\n        self.data_x = np.insert(self.data_x, pos, x)\n        self.data_y = np.insert(self.data_y, pos, self._y_from_user(y), axis=0)\n\n    def remove_from_indeces(self, *indeces):\n        if indeces != []:\n            indeces = np.sort(indeces)[::-1]\n            for index in indeces:\n                self.set_data(\n                    np.delete(self.data_x, index, axis=0),\n                    np.delete(self.data_y, index, axis=0)\n                )\n\n    def clear(self):\n        """"""\n            Clears all x and y values.\n        """"""\n        self.set_data(np.zeros((0,), dtype=float), np.zeros((0, 0), dtype=float))\n\n    # ------------------------------------------------------------\n    #      Convenience Methods & Functions\n    # ------------------------------------------------------------\n    def get_xy_data(self, column=1):\n        """"""\n            Returns a two-tuple containing 1D-numpy arrays with the x-data and\n            the y-data for a given column. If the column keyword is not passed, \n            the first column is returned.\n        """"""\n        if len(self) > 0:\n            return self.data_x, self.data_y[:, column - 1]\n        else:\n            return np.array([], dtype=float), np.array([], dtype=float)\n\n    def get_y_at_x(self, x, column=0):\n        """""" \n            Get the (interpolated) value for the y-column \'column\' for\n            a given x value\n        """"""\n        if self._data_x.size:\n            return np.interp(x, self._data_x, self._data_y[:, column])\n        else:\n            return 0\n\n    def get_y_name(self, column):\n        """"""\n            Returns the name of the given column. If the y_names attribute is \n            not properly set (e.g. too small or empty), it will return an empty\n            string. This method is \'safer\' to use then directly accessing the\n            y_names attribute (may result in an IndexError).\n        """"""\n        try:\n            return self.y_names[column]\n        except IndexError:\n            return """"\n\n    # ------------------------------------------------------------\n    #      Iterable & Indexable implementation\n    # ------------------------------------------------------------\n    def __len__(self):\n        return len(self.data_x)\n\n    def __getitem__(self, index):\n        return self.data_x[index], self.data_y[index].tolist()\n\n    def __iter__(self):\n        for i in range(len(self)):\n            yield self[i]\n\n    pass # end of class\n'"
mvc/observers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2006 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import Observer, NTInfo\nfrom .dict_observer import DictObserver\nfrom .list_item_observer import ListItemObserver\nfrom .list_observer import ListObserver\nfrom .tree_observer import TreeObserver\n\n__all__ = [\n    ""NTInfo"",\n    ""Observer"",\n    ""DictObserver"",\n    ""ListItemObserver"",\n    ""ListObserver"",\n    ""TreeObserver""\n]\n'"
mvc/observers/base.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2006 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom ..support import decorators\n\nimport inspect\n\nclass NTInfo (dict):\n    """"""\n    A container for information attached to a notification.\n    This class is a dictionary-like object used:\n\n    1. As class when defining notification methods in observers, as it\n       contains the flags identifying the notification types.\n\n    2. As class instance as parameter when a notification methods is\n       called in observers.\n\n\n    **Notification Type Flags**\n    \n    Notification methods are declared either statically or dynamically \n    through :meth:`Observer.observe`. In both cases the type of the\n    notification is defined by setting to `True` some flags. Flags can\n    be set in any combination for multi-type notification\n    methods. Flags are:\n\n    assign\n       For notifications issued when OPs are assigned.\n    before\n       For notifications called before a modifying method is called.\n    after\n       For notifications called after a modifying method is called.\n    signal\n       For notifications called when a signal is emitted.\n\n    \n    **Instance content**\n\n    Instances of class `NTInfo` will be received as the last argument\n    (`info`) of any notification method::\n\n      def notification_method(self, model, name, info)\n\n    NTInfo is a dictionary (with some particular behaviour added)\n    containing some information which is independent on the\n    notification type, and some other information wich depends on the\n    notification type.\n\n\n    **Common to all types**\n\n    For all notification types, NTInfo contains:\n\n    model\n       the model containing the observable property triggering the\n       notification. `model` is also passed as first argument of the\n       notification method.\n\n    prop_name\n       the name of the observable property triggering the notification. `name`\n       is also passed as second argument of the notification method.\n      \n    Furthermore, any keyword argument not listed here is copied\n    without modification into `info`.\n\n    There are further information depending on the specific\n    notification type:\n\n    **For Assign-type**\n\n    assign\n       flag set to `True`\n\n    old\n       the value that the observable property had before being\n       changed.\n\n    new\n       the new value that the observable property has been\n       changed to.\n\n\n    **For Before method call type**\n\n    before\n       flag set to `True`\n\n    instance\n       the object instance which the method that is being called belongs to.\n\n    method_name\n       the name of the method that is being called. \n\n    args\n       tuple of the arguments of the method that is being called. \n\n    kwargs\n       dictionary of the keyword arguments of the method that\n       is being called.\n\n\n    **For After method call type**\n\n    after\n       flag set to `True`\n\n    instance\n       the object instance which the method that has been \n       called belongs to.\n\n    method_name\n       the name of the method that has been called. \n\n    args\n       tuple of the arguments of the method that has been called. \n\n    kwargs\n       dictionary of the keyword arguments of the method that\n       has been called.\n\n    result\n       the value returned by the method which has been called. \n\n    **For Signal-type**\n\n    signal\n       flag set to `True`\n\n    arg\n       the argument which was optionally specified when invoking\n       emit() on the signal observable property.\n\n    **Information access**\n\n    The information carried by a NTInfo instance passed to a\n    notification method can be retrieved using the instance as a\n    dictionary, or accessing directly to the information as an\n    attribute of the instance. For example::\n       \n       # This is a multi-type notification\n       @Observer.observe(""op1"", assign=True, hello=""Ciao"")\n       @Observer.observe(""op2"", after=True, before=True)\n       def notify_me(self, model, name, info):\n           assert info[""model""] == model # access as dict key\n           assert info.prop_name == name # access as attribute\n\n           if ""assign"" in info:\n              assert info.old == info[""old""]\n              assert ""hello"" in info and ""ciao"" == info.hello\n              print ""Assign from"", info.old, ""to"", info.new\n           else:\n              assert ""before"" in info or ""after"" in info\n              assert ""hello"" not in info\n              print ""Method name="", info.method_name\n              if ""after"" in info: print ""Method returned"", info.result    \n              pass\n              \n           return   \n\n    As already told, the type carried by a NTInfo instance can be\n    accessed through boolean flags `assign`, `before`, `after` and\n    `signal`. Furthermore, any other information specified at\n    declaration time (keyword argument \'hello\' in the previous\n    example) will be accessible in the corresponding notification\n    method.\n\n    .. versionadded:: 1.99.1\n\n    """"""\n\n    # At least one of the keys in this set is required when constructing\n    __ONE_REQUESTED = frozenset(""assign before after signal"".split())\n    __ALL_REQUESTED = frozenset(""model prop_name"".split())\n\n    def __init__(self, _type, *args, **kwargs):\n        dict.__init__(self, *args, **kwargs)\n\n        # checks the content provided by the user\n        if not (_type in self and self[_type]):\n            raise KeyError(""flag \'%s\' must be set in given arguments"" % _type)\n\n        # all requested are provided by the framework, not the user\n        assert NTInfo.__ALL_REQUESTED <= set(self)\n\n        # now removes all type-flags not related to _type\n        for flag in NTInfo.__ONE_REQUESTED:\n            if flag != _type and flag in self: del self[flag]\n            pass\n\n        return\n\n    def __getattr__(self, name):\n        """"""\n        All dictionary keys are also available as attributes.\n        """"""\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(""NTInfo object has no attribute \'%s\'.\\n""\n                                 ""Existing attributes are: %s"" % (name, str(self)))\n        pass\n\n    pass # end of class NTInfo\n# ----------------------------------------------------------------------\n\n\nclass Observer (object):\n    """"""\n    .. note::\n\n       Most methods in this class are used internally by the\n       framework.  Do not override them in subclasses.\n    """"""\n\n    # this is internal\n    _CUST_OBS_ = ""__custom_observes__""\n    # ----------------------------------------------------------------------\n\n\n    @classmethod\n    @decorators.good_decorator_accepting_args\n    def observe(cls, *args, **kwargs):\n        """"""\n        Mark a method as recieving notifications. Comes in two flavours:\n\n        .. method:: observe(name, **types)\n           :noindex:\n\n           A decorator living in the class. Can be applied more than once to\n           the same method, provided the names differ.\n           \n           *name* is the property we want to be notified about as a string.\n           \n           *types* are boolean values denoting the types of\n           notifications desired. At least one of the following has to be\n           passed as True: assign, before, after, signal.\n\n           Excess keyword arguments are passed to the method as part of the\n           info dictionary.\n\n        .. method:: observe(callable, name, **types)\n           :noindex:\n\n           An instance method to define notifications at runtime. Works as\n           above.\n           \n           *callable* is the method to send notifications to. The effect will\n           be as if this had been decorated.\n\n        In all cases the notification method must take exactly three\n        arguments: the model object, the name of the property that changed,\n        and an :class:`NTInfo` object describing the change.\n\n        .. warning::\n      \n           Due to limitation in the dynamic registration (in version\n           1.99.1), declarations of dynamic notifications must occur\n           before registering self as an observer of the models whose\n           properties the notifications are supposed to be\n           observing. A hack for this limitation, is to first relieve\n           any interesting model before dynamically register the\n           notifications, and then re-observe those models.\n\n        .. versionadded:: 1.99.1\n        """"""\n\n        @decorators.good_decorator\n        def _decorator(_notified):\n            # marks the method with observed properties\n            _list = getattr(_notified, Observer._CUST_OBS_, list())\n            _list.append((name, kwargs))\n            setattr(_notified, Observer._CUST_OBS_, _list)\n            return _notified\n\n        # handles arguments\n        if args and isinstance(args[0], cls):\n            # used as instance method, for declaring notifications\n            # dynamically\n            if len(args) != 3:\n                raise TypeError(""observe() takes exactly three arguments""\n                                "" when called (%d given)"" % len(args))\n\n            self = args[0]\n            notified = args[1]\n            name = args[2]\n\n            assert isinstance(self, Observer), ""Method Observer.observe "" \\\n                ""must be called with an Observer instance as first argument""\n            if not callable(notified):\n                raise TypeError(""Second argument of observe() must be a callable"")\n            if type(name) != str:\n                raise TypeError(""Third argument of observe() must be a string"")\n\n            self.__register_notification(name, notified, kwargs)\n            return None\n\n        # used statically as decorator\n        if len(args) != 1:\n            raise TypeError(""observe() takes exactly one argument when used""\n                            "" as decorator (%d given)"" % len(args))\n        name = args[0]\n        if type(name) != str:\n            raise TypeError(""First argument of observe() must be a string"")\n        return _decorator\n    # ----------------------------------------------------------------------\n\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        *model* is passed to :meth:`observe_model` if given.\n        \n        *spurious* indicates interest to be notified even when\n        the value hasn\'t changed, like for: ::\n\n         model.prop = model.prop\n\n        .. versionadded:: 1.2.0\n           Before that observers had to filter out spurious\n           notifications themselves, as if the default was `True`. With\n           :class:`~mvc.observable.Signal` support this is no longer\n           necessary.\n        """"""\n        model = kwargs.pop(""model"", None)\n        spurious = kwargs.pop(""spurious"", False)\n        super(Observer, self).__init__(*args, **kwargs)\n\n        # --------------------------------------------------------- #\n        # This turns the decorator \'observe\' an instance method\n        def __observe(*args, **kwargs): self.__original_observe(self, *args, **kwargs)\n        __observe.__name__ = self.observe.__name__\n        __observe.__doc__ = self.observe.__doc__\n        self.__original_observe = self.observe\n        self.observe = __observe\n        # --------------------------------------------------------- #\n\n        self.__accepts_spurious__ = spurious\n\n        # NOTE: In rev. 202 these maps were unified into\n        #   __CUST_OBS_MAP only (the map contained pairs (method,\n        #   args). However, this broke backward compatibility of code\n        #   accessing the map through\n        #   get_observing_methods. Now the informatio is split\n        #   and the original information restored. To access the\n        #   additional information (number of additional arguments\n        #   required by observing methods) use the newly added methods.\n\n        # Private maps: do not change/access them directly, use\n        # methods to access them:\n        self.__CUST_OBS_MAP = {} # prop name --> set of observing methods\n        self.__CUST_OBS_KWARGS = {} # observing method --> flag\n\n        processed_props = set() # tracks already processed properties\n\n        # searches all custom observer methods\n        for cls in inspect.getmro(type(self)):\n            # list of (method-name, method-object, list of (prop-name, kwargs))\n            meths = [ (name, meth, getattr(meth, Observer._CUST_OBS_))\n                      for name, meth in cls.__dict__.items()\n                      if (inspect.isfunction(meth) and\n                          hasattr(meth, Observer._CUST_OBS_)) ]\n\n            # props processed in this class. This is used to avoid\n            # processing the same props in base classes.\n            cls_processed_props = set()\n\n            # since this is traversed top-bottom in the mro, the\n            # first found match is the one to care\n            for name, meth, pnames_ka in meths:\n                _method = getattr(self, name) # the most top avail method\n\n                # WARNING! Here we store the top-level method in the\n                # mro, not the (unbound) method which has been\n                # declared by the user with the decorator.\n                for pname, ka in pnames_ka:\n                    if pname not in processed_props:\n                        self.__register_notification(pname, _method, ka)\n                        cls_processed_props.add(pname)\n                        pass\n                    pass\n                pass\n\n            # accumulates props processed in this class\n            processed_props |= cls_processed_props\n            pass # end of loop over classes in the mro\n\n        if model is not None:\n            self.observe_model(model)\n        return\n\n    def observe_model(self, model):\n        """"""Starts observing the given model""""""\n        return model.register_observer(self)\n\n    def relieve_model(self, model):\n        """"""Stops observing the given model""""""\n        return model.unregister_observer(self)\n\n    def accepts_spurious_change(self):\n        """"""\n        Returns True if this observer is interested in receiving\n        spurious value changes. This is queried by the model when\n        notifying a value change.""""""\n        return self.__accepts_spurious__\n\n    def get_observing_methods(self, prop_name):\n        """"""\n        Return a possibly empty set of callables registered with\n        :meth:`observe` for *prop_name*.\n        \n        .. versionadded:: 1.99.1\n           Replaces :meth:`get_custom_observing_methods`.\n        """"""\n        return self.__CUST_OBS_MAP.get(prop_name, set())\n\n    # this is done to keep backward compatibility\n    get_custom_observing_methods = get_observing_methods\n\n\n    def get_observing_method_kwargs(self, prop_name, method):\n        """"""\n        Returns the keyword arguments which were specified when\n        declaring a notification method, either statically of\n        synamically with :meth:`Observer.observe`.\n\n        *method* a callable that was registered with\n        :meth:`observes`.\n        \n        :rtype: dict\n        """"""\n        return self.__CUST_OBS_KWARGS[(prop_name, method)]\n\n\n    def remove_observing_method(self, prop_names, method):\n        """"""\n        Remove dynamic notifications.\n        \n        *method* a callable that was registered with :meth:`observe`.\n        \n        *prop_names* a sequence of strings. This need not correspond to any\n        one `add` call.\n\n        .. note::\n\n           This can revert the effects of a decorator at runtime. Don\'t.\n        """"""\n        for prop_name in prop_names:\n            _set = self.__CUST_OBS_MAP.get(prop_name, set())\n            if method in _set: _set.remove(method)\n            key = (prop_name, method)\n            if key in self.__CUST_OBS_KWARGS: del self.__CUST_OBS_KWARGS[key]\n            pass\n\n        return\n\n    def is_observing_method(self, prop_name, method):\n        """"""\n        Returns `True` if the given method was previously added as an\n        observing method, either dynamically or via decorator.\n        """"""\n        return (prop_name, method) in self.__CUST_OBS_KWARGS\n\n\n    def __register_notification(self, prop_name, method, kwargs):\n        """"""Internal service which associates the given property name\n        to the method, and the (prop_name, method) with the given\n        kwargs dictionary. If needed merges the dictionary, if the\n        given (prop_name, method) pair was already registered (in this\n        case the last registration wins in case of overlapping.)\n\n        If given prop_name and method have been already registered, a\n        ValueError exception is raised.""""""\n\n        key = (prop_name, method)\n        if key in self.__CUST_OBS_KWARGS:\n            raise ValueError(""In %s method \'%s\' has been declared ""\n                             ""to be a notification for property \'%s\' ""\n                             ""multiple times (only one is allowed)."" % \\\n                                 (self.__class__,\n                                  method.__name__, prop_name))\n\n        # fills the internal structures\n        if prop_name not in self.__CUST_OBS_MAP:\n            self.__CUST_OBS_MAP[prop_name] = set()\n            pass\n        self.__CUST_OBS_MAP[prop_name].add(method)\n\n        self.__CUST_OBS_KWARGS[key] = kwargs\n        return\n\n    pass # end of class\n# ----------------------------------------------------------------------\n'"
mvc/observers/dict_observer.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import Observer\n\nclass DictObserver(Observer):\n    """"""\n        An observer that wraps the in-instance changes of a dict to on_inserted\n        and on_deleted handlers.\n    """"""\n\n    _deleted = []\n\n    def __init__(self, on_inserted, on_deleted, prop_name, model=None, spurious=False):\n        super(DictObserver, self).__init__(model=model, spurious=spurious)\n        self.on_inserted = on_inserted\n        self.on_deleted = on_deleted\n\n        self.observe(self.on_prop_mutation_before, prop_name, before=True)\n        self.observe(self.on_prop_mutation_after, prop_name, after=True)\n\n    def on_prop_mutation_before(self, model, prop_name, info):\n        if info.method_name in (""__setitem__"", ""__delitem__"", ""pop"", ""setdefault""):\n            key = info.args[0]\n            if key in info.instance:\n                self._deleted.append(info.instance[key])\n\n        if info.method_name == ""update"":\n            if len(info.args) == 1:\n                iterable = info.args[0]\n            elif len(info.kwargs) > 0:\n                iterable = info.kwargs\n            if hasattr(iterable, ""iteritems""):\n                iterable = iter(iterable.items())\n            for key, value in iterable: # @UnusedVariable\n                if key in info.instance:\n                    self._deleted.append(info.instance[key])\n\n        if info.method_name == ""clear"":\n            self._deleted.extend(list(info.instances.values()))\n\n    def on_prop_mutation_after(self, model, prop_name, info):\n\n        if self._deleted:\n            for old_item in self._deleted:\n                self.on_deleted(old_item)\n            self._deleted = []\n\n        if info.method_name == ""popitem"":\n            old_item = info.result[1]\n            self.on_deleted(old_item)\n\n    pass # end of class'"
mvc/observers/list_item_observer.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport weakref\nfrom .base import Observer\n\nclass ListItemObserver(Observer):\n    """"""\n        An observer that observes a single item in a list and informs us of changes.\n        The observed properties are defined in the list type\'s meta class by\n        setting their property descriptors \'tabular\' attribute to True.\n    """"""\n\n    _previous_model_ref = None\n    @property\n    def _previous_model(self):\n        if self._previous_model_ref is not None:\n            return self._previous_model_ref()\n        else:\n            return None\n    @_previous_model.setter\n    def _previous_model(self, value):\n        self._previous_model_ref = weakref.ref(value, self.clear)\n\n    def __init__(self, on_changed, model=None, spurious=False):\n        super(ListItemObserver, self).__init__(spurious=spurious)\n        self.on_changed = on_changed\n        self.observe_model(model)\n\n    def observe_model(self, model):\n        if self._previous_model is not None:\n            self.relieve_model(self._previous_model)\n        if model is not None:\n            for prop_name, data_type in model.Meta.get_column_properties():  # @UnusedVariable\n                self.observe(self.on_prop_mutation, prop_name, assign=True)\n            self._previous_model = model\n            super(ListItemObserver, self).observe_model(model)\n\n    def clear(self, *args):\n        self.on_changed = None\n        if len(args) == 0:\n            self.observe_model(None)\n\n    def on_prop_mutation(self, model, prop_name, info):\n        if callable(self.on_changed):\n            self.on_changed(model)\n\n    pass # end of class'"
mvc/observers/list_observer.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import Observer\nimport types\n\nclass ListObserver(Observer):\n    """"""\n        An observer that wraps the in-instance changes of a list to on_inserted\n        and on_deleted handlers.\n    """"""\n\n    _deleted = []\n\n    def __init__(self, on_inserted, on_deleted, prop_name, on_deleted_before=None, model=None, spurious=False):\n        super(ListObserver, self).__init__(spurious=spurious)\n        self.on_inserted = on_inserted\n        self.on_deleted = on_deleted\n        self.on_deleted_before = on_deleted_before\n\n        self.observe(self.on_prop_mutation_before, prop_name, before=True)\n        self.observe(self.on_prop_mutation_after, prop_name, after=True)\n        self.observe_model(model)\n\n    def on_prop_mutation_before(self, model, prop_name, info):\n        if info.method_name in (""__setitem__"", ""__delitem__""):\n            i = info.args[0]\n            if isinstance(i, slice):\n                self._deleted = info.instance[i]\n            elif i <= len(info.instance): # setting an existing item: need a on_delete as well\n                self._deleted = [info.instance[i], ]\n        if info.method_name == ""pop"":\n            if len(info.instance) > 0:\n                self._deleted = [info.instance[-1], ]\n        if info.method_name == ""remove"":\n            self._deleted = [info.args[0], ]\n\n        if callable(self.on_deleted_before):\n            for old_item in self._deleted[::-1]:\n                self.on_deleted_before(old_item)\n\n    def on_prop_mutation_after(self, model, prop_name, info):\n        if callable(self.on_deleted):\n            for old_item in self._deleted[::-1]:\n                self.on_deleted(old_item)\n            self._deleted = []\n\n        if info.method_name == ""__setitem__"":\n            i = info.args[0]\n            if type(i) is slice:\n                for item in info.instance[i]:\n                    self.on_inserted(item)\n            else:\n                new_item = info.args[1]\n                self.on_inserted(new_item)\n        if info.method_name == ""append"":\n            new_item = info.args[0]\n            self.on_inserted(new_item)\n        if info.method_name == ""extend"":\n            items = info.args[0]\n            for new_item in items:\n                self.on_inserted(new_item)\n        if info.method_name == ""insert"":\n            new_item = info.args[1]\n            self.on_inserted(new_item)\n\n    pass # end of class'"
mvc/observers/tree_observer.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import Observer\n\nclass TreeObserver(Observer):\n    """"""\n        An observer that wraps the in-instance changes of a Tree made by\n        TreeNodes to on_inserted and on_deleted handlers.\n    """"""\n\n    _deleted = []\n\n    def __init__(self, on_inserted, on_deleted, prop_name, on_deleted_before=None, model=None, spurious=False):\n        super(TreeObserver, self).__init__(spurious=spurious)\n        self.on_inserted = on_inserted\n        self.on_deleted = on_deleted\n        self.on_deleted_before = on_deleted_before\n\n        self.observe(self.on_prop_mutation_before, prop_name, before=True)\n        self.observe(self.on_prop_mutation_after, prop_name, after=True)\n        self.observe_model(model)\n\n    def on_prop_mutation_before(self, model, prop_name, info):\n        if info.method_name == ""on_grandchild_removed"":\n            self._deleted = [info.args[0], ]\n\n        if info.method_name == ""remove"":\n            self._deleted = [info.args[0], ]\n\n        if callable(self.on_deleted_before):\n            for old_item in self._deleted[::-1]:\n                self.on_deleted_before(old_item)\n\n    def on_prop_mutation_after(self, model, prop_name, info):\n        if callable(self.on_deleted):\n            for old_item in self._deleted[::-1]:\n                self.on_deleted(old_item)\n            self._deleted = []\n\n        if info.method_name == ""on_grandchild_removed"":\n            new_item = info.args[0]\n            self.on_inserted(new_item)\n\n        if info.method_name == ""insert"":\n            new_item = info.args[1]\n            self.on_inserted(new_item)\n\n    pass # end of class'"
mvc/support/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\n\n'"
mvc/support/cancellable_thread.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Author: Mathijs Dumon\n# Based on code from Rick Spencer\n# Copyright (c) 2013, Mathijs Dumon, Rick Spencer\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom threading import Thread, Event\n\nclass CancellableThread(Thread):\n    """"""\n        Class for use by ThreadedTaskBox.\n    """"""\n    def __init__(self, run_function, on_complete):\n        Thread.__init__(self)\n        self.setDaemon(True)\n        self.run_function = run_function\n        self.on_complete = on_complete\n        # Internal flag, for checking wether the user stopped.\n        self.__stop = Event()\n        # Internal flag, for checking wether the user cancelled.\n        self.__cancel = Event()\n\n    def run(self):\n        try:\n            # Tell the function to run\n            data = self.run_function(stop=self.__stop)\n            # Return function results, if not cancelled\n            if not self.__cancel.is_set():\n                self.on_complete(data)\n        except KeyboardInterrupt:\n            self.cancel()\n        except:\n            logger.exception(""Unhandled exception in CancellableThread run()"")\n\n    def stop(self):\n        """"""\n            Stops the thread, and calls the on_complete callback\n        """"""\n        self.__stop.set()\n\n    def cancel(self):\n        """"""\n            Stops the thread, and does not call the on_complete callback.\n        """"""\n        self.__cancel.set()\n        self.__stop.set()\n\n\n    pass #end of class\n'"
mvc/support/decorators.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2006 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\n\n# This file contains decorators to be used (privately) by other parts\n# of the framework\n\nimport types\n\ndef good_decorator(decorator):\n    """"""This decorator makes decorators behave well wrt to decorated\n    functions names, doc, etc.""""""\n    def new_decorator(f):\n        g = decorator(f)\n        g.__name__ = f.__name__\n        g.__doc__ = f.__doc__\n        g.__dict__.update(f.__dict__)\n        return g\n\n    new_decorator.__name__ = decorator.__name__\n    new_decorator.__doc__ = decorator.__doc__\n    new_decorator.__dict__.update(decorator.__dict__)\n\n    return new_decorator\n\n\ndef good_classmethod_decorator(decorator):\n    """"""This decorator makes class method decorators behave well wrt\n    to decorated class method names, doc, etc.""""""\n    def new_decorator(cls, f):\n        g = decorator(cls, f)\n        g.__name__ = f.__name__\n        g.__doc__ = f.__doc__\n        g.__dict__.update(f.__dict__)\n        return g\n\n    new_decorator.__name__ = decorator.__name__\n    new_decorator.__doc__ = decorator.__doc__\n    new_decorator.__dict__.update(decorator.__dict__)\n\n    return new_decorator\n\n\ndef good_decorator_accepting_args(decorator):\n    """"""This decorator makes decorators behave well wrt to decorated\n    functions names, doc, etc. \n\n    Differently from good_decorator, this accepts decorators possibly\n    receiving arguments and keyword arguments.\n\n    This decorato can be used indifferently with class methods and\n    functions.""""""\n    def new_decorator(*f, **k):\n        g = decorator(*f, **k)\n        if 1 == len(f) and isinstance(f[0], types.FunctionType):\n            g.__name__ = f[0].__name__\n            g.__doc__ = f[0].__doc__\n            g.__dict__.update(f[0].__dict__)\n            pass\n        return g\n\n    new_decorator.__name__ = decorator.__name__\n    new_decorator.__doc__ = decorator.__doc__\n    new_decorator.__dict__.update(decorator.__dict__)\n    # Required for Sphinx\' automodule.\n    new_decorator.__module__ = decorator.__module__\n    return new_decorator\n'"
mvc/support/exceptions.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\n\nclass DecoratorError (SyntaxError):\n    """"""Used to report syntax errors occurring when decorators are\n    used in models and observers.""""""\n    pass\n\n\nclass TooManyCandidatesError (ValueError):\n    """"""This class is used for distinguishing between a\n    multiple candidates matched and no candidates matched. The\n    latter is not necessarily an issue, as a missed match can\n    be skipped when searching for a match for *all* the\n    properties in the model (no params to adapt()), which may\n    fail in one single view, as multiple views may be used to\n    represent different parts of the model""""""\n    pass\n\n\nclass ViewError (ValueError):\n    """"""General issue with view content""""""\n    pass\n\n'"
mvc/support/file_utils.py,0,"b'import os\n\ndef get_case_insensitive_glob(*strings):\n    \'\'\'Ex: \'*.ora\' => \'*.[oO][rR][aA]\' \'\'\'\n    return [\'*.%s\' % \'\'.join([""[%s%s]"" % (c.lower(), c.upper()) for c in string.split(\'.\')[1]]) for string in strings]\n\ndef retrieve_lowercase_extension(glob):\n    \'\'\'Ex: \'*.[oO][rR][aA]\' => \'*.ora\' \'\'\'\n    return \'\'.join([ c.replace(""["", """").replace(""]"", """")[:-1] for c in glob.split(\'][\')])\n\n# ======================================================================\n# This is taken from python 2.6 (os.path.relpath is supported in 2.6)\n#\n# Copyright (c) 2001 Python Software Foundation; All Rights Reserved\n# This code about relpath is covered by the Python Software Foundation\n# (PSF) Agreement. See http://docs.python.org/license.html for details.\n# ======================================================================\ndef __posix_relpath(path, start=os.curdir):\n    """"""Return a relative version of a path""""""\n\n    if not path: raise ValueError(""no path specified"")\n\n    start_list = os.path.abspath(start).split(os.sep)\n    path_list = os.path.abspath(path).split(os.sep)\n\n    # Work out how much of the filepath is shared by start and path.\n    i = len(os.path.commonprefix([start_list, path_list]))\n\n    rel_list = [os.pardir] * (len(start_list) - i) + path_list[i:]\n    if not rel_list: return os.curdir\n    return os.path.join(*rel_list)\n\n# This is taken from python 2.6 (os.path.relpath is supported in 2.6)\n# This is for windows\ndef __nt_relpath(path, start=os.curdir):\n    """"""Return a relative version of a path""""""\n\n    if not path: raise ValueError(""no path specified"")\n\n    start_list = os.path.abspath(start).split(os.sep)\n    path_list = os.path.abspath(path).split(os.sep)\n    if start_list[0].lower() != path_list[0].lower():\n        unc_path, rest = os.path.splitunc(path)\n        unc_start, rest = os.path.splitunc(start)\n        if bool(unc_path) ^ bool(unc_start):\n            raise ValueError(""Cannot mix UNC and non-UNC paths (%s and %s)"" \\\n                             % (path, start))\n        else: raise ValueError(""path is on drive %s, start on drive %s"" \\\n                               % (path_list[0], start_list[0]))\n    # Work out how much of the filepath is shared by start and path.\n    for i in range(min(len(start_list), len(path_list))):\n        if start_list[i].lower() != path_list[i].lower():\n            break\n        else: i += 1\n        pass\n\n    rel_list = [os.pardir] * (len(start_list) - i) + path_list[i:]\n    if not rel_list: return os.curdir\n    return os.path.join(*rel_list)\ntry:\n    import os.path.relpath\n    relpath = os.path.relpath\nexcept ImportError:\n    if os.name == \'nt\':\n        relpath = __nt_relpath\n    else:\n        relpath = __posix_relpath\n        pass\n    pass\n# ======================================================================\n# End of code covered by PSF License Agreement\n# ======================================================================'"
mvc/support/gui_loop.py,0,"b'__add_idle_call = None\n__remove_idle_call = None\n__add_timeout_call = None\n__remove_timeout_call = None\n__setup_event_loop = None\n__start_event_loop = None\n__stop_event_loop = None\n\n__idle_call_dict = {}\n__timeout_call_dict = {}\n\ndef add_idle_call(func, *args, **kwargs):\n    global __add_idle_call\n    global __idle_call_dict\n    if __add_idle_call is not None:\n        __idle_call_dict[func] = __add_idle_call(func, *args, **kwargs)\n    else: # toolkit does not support this or is not loaded:\n        func(*args, **kwargs)\n        \ndef remove_idle_call(func):\n    global __remove_idle_call\n    global __idle_call_dict\n    if __remove_idle_call is not None:\n        __remove_idle_call(__idle_call_dict[func])\n        \ndef add_timeout_call(timeout, func, *args, **kwargs):\n    global __add_timeout_call\n    global __timeout_call_dict\n    if __add_timeout_call is not None:\n        __timeout_call_dict[func] = __add_timeout_call(timeout, func, *args, **kwargs)\n    else: # toolkit does not support this or is not loaded:\n        func(*args, **kwargs)\n\ndef remove_timeout_call(func):\n    global __remove_timeout_call\n    global __timeout_call_dict\n    if __remove_timeout_call is not None:\n        __remove_timeout_call(__timeout_call_dict[func])\n\ndef start_event_loop():\n    global __start_event_loop\n    if __start_event_loop is not None:\n        return __start_event_loop()\n\ndef stop_event_loop():\n    global __stop_event_loop\n    if __stop_event_loop is not None:\n        return __stop_event_loop()    \n\n\ndef load_toolkit_functions(\n        add_idle_call, \n        remove_idle_call,\n        add_timeout_call,\n        remove_timeout_call,\n        start_event_loop,\n        stop_event_loop):\n    """"""\n        \'add_idle_call\' should take a function as 1st argument, the return \n        value is passed back to \'remove_idle_call\'. Internally a cache is maintained\n        in which keys are functions and values are return values.\n        \'add_timeout_call\' and \'remove_timeout_call\' work analogously\n        start_event_loop and stop_event_loop don\'t take arguments and should be self-explanatory.\n    """"""\n    global __add_idle_call\n    global __remove_idle_call\n    global __add_timeout_call\n    global __remove_timeout_call\n    global __start_event_loop\n    global __stop_event_loop\n    assert callable(add_idle_call)\n    assert callable(remove_idle_call)\n    assert callable(add_timeout_call)\n    assert callable(remove_timeout_call)\n    assert callable(start_event_loop)\n    assert callable(stop_event_loop)\n    __add_idle_call = add_idle_call\n    __remove_idle_call = remove_idle_call\n    __add_timeout_call = add_timeout_call\n    __remove_timeout_call = remove_timeout_call\n    __start_event_loop = start_event_loop\n    __stop_event_loop = stop_event_loop\n\n""""""\n    Decorators:\n""""""\n\ndef run_when_idle(func):\n    def callback(*args, **kwargs):\n        return add_idle_call(func, *args, **kwargs)\n    return callback\n    \ndef run_every(timeout):\n    def wrapper(func):\n        def callback(*args, **kwargs):\n            return add_timeout_call(func, timeout, *args, **kwargs)\n        return callback\n    return wrapper\n'"
mvc/support/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2007 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport os\nfrom uuid import uuid4 as get_uuid\n\ndef rec_setattr(obj, attr, value):\n    """"""Set object\'s attribute. May use dot notation.\n\n    >>> class C(object): pass\n    >>> a = C()\n    >>> a.b = C()\n    >>> rec_setattr(a, \'b.c\', 4)\n    >>> a.b.c\n    4\n    """"""\n    if obj is None:\n        raise AttributeError(""Cannot recursively set attribute (%s) on NoneType"" % attr)\n    else:\n        if \'.\' not in attr:\n            setattr(obj, attr, value)\n        else:\n            attr, attrs = attr.split(\'.\', 1)\n            rec_setattr(getattr(obj, attr), attrs, value)\n\ndef rec_getattr(obj, attr, default):\n    """"""Get object\'s attribute. May use dot notation.\n\n    >>> class C(object): pass\n    >>> a = C()\n    >>> a.b = C()\n    >>> a.b.c = 4\n    >>> rec_getattr(a, \'b.c\')\n    4\n    """"""\n    if obj is None:\n        return default\n    else:\n        if \'.\' not in attr:\n            return getattr(obj, attr, default)\n        else:\n            attr, attrs = attr.split(\'.\', 1)\n            return rec_getattr(getattr(obj, attr), attrs, default)\n\ndef round_sig(x, sig=1):\n    if x == 0:\n        return 0\n    else:\n        return round(x, sig - int(floor(log10(abs(x)))) - 1)\n\ndef not_none(passed, default):\n    """"""Returns `passed` if not None, else `default` is returned""""""\n    return passed if passed is not None else default\n\ndef getmembers(_object, _predicate):\n    """"""This is an implementation of inspect.getmembers, as in some versions \n    of python it may be buggy. \n    See issue at http://bugs.python.org/issue1785""""""\n    # This should be:\n    # return inspect.getmembers(_object, _predicate)\n\n    # ... and it is re-implemented as:\n    observers = []\n    for key in dir(_object):\n        try: m = getattr(_object, key)\n        except AttributeError: continue\n        if _predicate(m): observers.append((key, m))\n        pass\n    return observers\n\ndef get_new_uuid():\n    return str(get_uuid().hex)\n\ndef get_unique_list(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]\n\ndef pop_kwargs(kwargs, *keys):\n    return {\n        key: kwargs.pop(key) for key in keys if key in kwargs\n    }'"
mvc/support/version.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom distutils.version import LooseVersion\n\ndef _cmp (self, other):\n    if isinstance(other, str):\n        other = LooseVersion(other)\n\n    stypes = map(lambda c: str if isinstance(c, str) else int, self.version)\n    otypes = map(lambda c: str if isinstance(c, str) else int, other.version)\n    \n    for i, (stype, otype) in enumerate(zip(stypes, otypes)):\n        if stype == str and otype == int:\n            other.version[i] = str(other.version[i])\n        if stype == int and otype == str:\n            self.version[i] = str(self.version[i])\n    \n    if self.version == other.version:\n        return 0\n    if self.version < other.version:\n        return -1\n    if self.version > other.version:\n        return 1\n            \nLooseVersion._cmp = _cmp'"
pyxrd/application/__init__.py,0,b''
pyxrd/application/controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nfrom os.path import basename, dirname\nfrom functools import wraps\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc.support.gui_loop import stop_event_loop, add_idle_call\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.plot.controllers import MainPlotController\nfrom pyxrd.generic.plot.eye_dropper import EyeDropper\n\nfrom pyxrd.file_parsers.project_parsers import JSONProjectParser\nfrom pyxrd.file_parsers.project_parsers import project_parsers\n\nfrom pyxrd.project.controllers import ProjectController\nfrom pyxrd.project.models import Project\nfrom pyxrd.specimen.controllers import SpecimenController, MarkersController\n\nfrom pyxrd.mixture.controllers import MixturesController #, InSituBehavioursController\nfrom pyxrd.phases.controllers import PhasesController\nfrom pyxrd.atoms.controllers import AtomTypesController\n\nclass AppController (BaseController):\n    """"""\n        Controller handling the main application interface.\n        In essence this delegates actions to its child controllers for Project,\n        Mixture, Specimen, Phase, Marker and Atoms actions. \n    """"""\n\n    # ------------------------------------------------------------\n    #      Dialog properties\n    # ------------------------------------------------------------\n    _save_project_dialog = None\n    @property\n    def save_project_dialog(self):\n        """""" Creates & returns the \'save project\' dialog """"""\n        if self._save_project_dialog is None:\n            # Check to see if we have a project loaded, if so,\n            # set the paths to match\n            current_name, current_folder = None, None\n            if self.model.current_filename is not None:\n                current_name = basename(self.model.current_filename)\n                current_folder = dirname(self.model.current_filename)\n            # Create the dialog once, and re-use its context\n            self._save_project_dialog = DialogFactory.get_save_dialog(\n                title=""Save project"",\n                current_name=current_name,\n                current_folder=current_folder,\n                filters=project_parsers.get_export_file_filters(),\n                persist=True,\n                parent=self.view.get_top_widget()\n            )\n        return self._save_project_dialog\n\n    _load_project_dialog = None\n    @property\n    def load_project_dialog(self):\n        """""" Creates & returns the \'load project\' dialog """"""\n        if self._load_project_dialog is None:\n            # Check to see if we have a project loaded, if so,\n            # set the paths to match\n            current_folder = None\n            if self.model.current_filename is not None:\n                current_folder = dirname(self.model.current_filename)\n            # Create the dialog once, and re-use\n            self._load_project_dialog = DialogFactory.get_load_dialog(\n                title=""Load project"",\n                current_folder=current_folder,\n                filters=project_parsers.get_import_file_filters(),\n                persist=True, multiple=False,\n                parent=self.view.get_top_widget()\n            )\n        return self._load_project_dialog\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, model, view, gtk_exception_hook=None, spurious=False, auto_adapt=False, parent=None):\n        """""" Initializes an AppController with the given arguments. """"""\n        super(AppController, self).__init__(model=model, view=view, spurious=spurious, auto_adapt=auto_adapt, parent=parent)\n\n        self.gtk_exception_hook = gtk_exception_hook\n        self.gtk_exception_hook.parent_view = view.get_toplevel()\n\n        # Plot controller:\n        self.plot_controller = MainPlotController(\n            self.update_plot_status,\n            self.show_marker\n        )\n\n        # Child controllers:\n        self.project = None\n        self.specimen = None\n        self.markers = None\n        self.phases = None\n        self.atom_types = None\n        self.mixtures = None\n\n        self.idle_redraw_plot()\n\n        if self.model.project_loaded:\n            self.reset_project_controller()\n\n        self.push_status_msg(""Done."")\n\n    def register_view(self, view):\n        """""" Registers the view with this controller """"""\n        view.setup_plot(self.plot_controller)\n        if self.model.project_loaded:\n            self.update_sensitivities()\n            view.set_layout_mode(self.model.current_project.layout_mode)\n        else:\n            view.set_layout_mode(settings.DEFAULT_LAYOUT)\n\n    def set_model(self, model):\n        """""" Sets the model in this controller """"""\n        super(self, AppController).set_model(model)\n        self.reset_project_controller()\n\n    def reset_project_controller(self):\n        """""" Recreates all child controllers """"""\n        self.view.reset_all_views()\n        self.project = ProjectController(model=self.model.current_project, view=self.view.project, parent=self)\n        self.phases = PhasesController(model=self.model.current_project, view=self.view.phases, parent=self)\n        #self.behaviours = InSituBehavioursController(model=self.model.current_project, view=self.view.behaviours, parent=self)\n        self.atom_types = AtomTypesController(model=self.model.current_project, view=self.view.atom_types, parent=self)\n        self.mixtures = MixturesController(model=self.model.current_project, view=self.view.mixtures, parent=self)\n        self.reset_specimen_controller()\n        self.view.update_project_sensitivities(self.model.project_loaded)\n        self.set_layout_mode(self.model.current_project.layout_mode)\n        self.update_title()\n\n    def reset_specimen_controller(self):\n        """""" Recreates only the specimen controllers """"""\n        if self.model.specimen_selected:\n            specimen_view = self.view.reset_child_view(""specimen"")\n            self.specimen = SpecimenController(model=self.model.current_specimen, view=specimen_view, parent=self)\n            self.show_markers_for(self.model.current_specimen)\n        else:\n            self.specimen = None\n            self.markers = None\n        self.view.update_specimen_sensitivities(\n            self.model.single_specimen_selected,\n            self.model.multiple_specimens_selected\n        )\n        self.idle_redraw_plot()\n\n    def show_markers_for(self, specimen):\n        markers_view = self.view.reset_child_view(""markers"")\n        self.markers = MarkersController(model=specimen, view=markers_view, parent=self)\n        \n    def show_marker(self, marker):\n        markers_view = self.view.reset_child_view(""markers"")\n        self.markers = MarkersController(model=marker.specimen, view=markers_view, parent=self)\n        self.view.markers.present()\n        add_idle_call(self.markers.select_object, marker)\n             \n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @BaseController.observe(""needs_plot_update"", signal=True)\n    def notif_needs_plot_update(self, model, prop_name, info):\n        """""" \n            This handles needs_plot_update signals emitted by the Application\n            model, in effect it is either a forwarded \'data_changed\' or \n            \'visuals_changed\' signal coming from the \n            :class:`pyxrd.project.models.Project` model.\n        """"""\n        self.idle_redraw_plot()\n\n    @BaseController.observe(""current_project"", assign=True, after=True)\n    def notif_project_update(self, model, prop_name, info):\n        self.reset_project_controller()\n\n    @BaseController.observe(""current_specimen"", assign=True, after=True)\n    @BaseController.observe(""current_specimens"", assign=True, after=True)\n    def notif_specimen_changed(self, model, prop_name, info):\n        self.reset_specimen_controller()\n\n    # ------------------------------------------------------------\n    #      View updating\n    # ------------------------------------------------------------\n\n    _idle_redraw_id = None\n    _needs_redraw = False\n    def idle_redraw_plot(self):\n        """"""Adds a redraw plot function as \'idle\' action to the main GTK loop.""""""\n        if self._idle_redraw_id is None:\n            self._idle_redraw_id = add_idle_call(self.redraw_plot)\n        self._needs_redraw = True\n\n    @BaseController.status_message(""Updating display..."")\n    def redraw_plot(self):\n        """"""Updates the plot""""""\n        if self._needs_redraw == True:\n            self._needs_redraw = False\n            self.plot_controller.update(\n                clear=True,\n                project=self.model.current_project,\n                specimens=self.model.current_specimens[::-1]\n            )\n        if self._needs_redraw:\n            return True\n        else:\n            self._idle_redraw_id = None\n            return False\n\n\n    def update_title(self):\n        """"""Convenience method for setting the application view\'s title""""""\n        self.view.set_title(self.model.current_project.name)\n\n    def update_sensitivities(self):\n        """"""Convenience method for updating the application view\'s sensitivities""""""\n        self.view.update_project_sensitivities(self.model.project_loaded)\n        self.view.update_specimen_sensitivities(\n            self.model.single_specimen_selected,\n            self.model.multiple_specimens_selected\n        )\n\n    def update_plot_status(self, x_pos, event):\n        if x_pos > 0 and self.model.current_specimen is not None:\n            # Get experimental data at the sampled point\n            exp_y = self.model.current_specimen.experimental_pattern.get_y_at_x(x_pos)\n            dspacing = self.model.current_specimen.goniometer.get_nm_from_2t(x_pos)\n            # Get calculated data if applicable\n            if self.model.current_project.layout_mode == ""FULL"":\n                calc_y = self.model.current_specimen.calculated_pattern.get_y_at_x(x_pos)\n                self.view.update_plot_status(x_pos, dspacing, exp_y, calc_y)\n            else:\n                self.view.update_plot_status(x_pos, dspacing, exp_y, None)\n        else:\n            self.view.update_plot_status(None, None, None, None)\n\n    def set_layout_mode(self, mode):\n        """"""Convenience method for updating the application view\'s layout mode""""""\n        self.view.set_layout_mode(mode)\n\n    # ------------------------------------------------------------\n    #      Loading and saving of projects\n    # ------------------------------------------------------------\n    def _save_project(self, filename=None):\n        # Set the filename to the current location if None or """" was given:\n        filename = filename or self.model.current_filename\n\n        # Try to save the project:\n        with DialogFactory.error_dialog_handler(\n                ""An error has occurred while saving!\\n<i>{0}</i>"",\n                parent=self.view.get_toplevel(), reraise=False):\n            JSONProjectParser.write(self.model.current_project, filename, zipped=True)\n            self.model.current_project.filename = filename\n            self.model.update_project_last_save_hash()\n            \n        # Update the title\n        self.update_title()\n\n    def confirm_discard_unsaved_changes(self,\n            confirm_msg=""The current project has unsaved changes,\\n""\n                        ""are you sure you want to continue?"",\n            on_reject=None):\n        """"""\n            Function decorator which will check if a project is opened with\n            unsaved changes and ask the user to confirm the action without first\n            saving the changes.\n        """"""\n        def accept_decorator(on_accept):\n            @wraps(on_accept)\n            def accept_wrapper(self, *args, **kwargs):\n                if self.model.check_for_changes():\n                    return DialogFactory.get_confirmation_dialog(\n                        confirm_msg, parent=self.view.get_top_widget()\n                    ).run(lambda d: on_accept(self, *args, **kwargs), on_reject)\n                else:\n                    return on_accept(self, *args, **kwargs)\n            return accept_wrapper\n        return accept_decorator\n\n    @confirm_discard_unsaved_changes(\n        ""The current project has unsaved changes,\\n""\n        ""are you sure you want to quit?"")\n    def quit(self, *args, **kwargs):\n        stop_event_loop()\n        return False\n\n    @confirm_discard_unsaved_changes(\n        ""The current project has unsaved changes,\\n""\n        ""are you sure you want to load another project?"")\n    def load_project(self):\n        """"""Convenience function for loading projects from different sources\n        following similar user interaction paths""""""\n        def on_accept(dialog):\n            # Try to load the project:\n            with DialogFactory.error_dialog_handler(\n                    ""An error has occurred:\\n<i>{0}</i>\\n Your project was not loaded!"",\n                    parent=self.view.get_toplevel(), title=""Parsing error"", reraise=False):\n                self.model.current_project = dialog.parser.parse(dialog.filename)\n                self.model.current_project.parent = self.model\n                self.model.update_project_last_save_hash()\n                # Update the title\n                self.update_title()\n\n        # Run the open/import project dialog:\n        self.load_project_dialog.run(on_accept)\n\n    @confirm_discard_unsaved_changes(\n        ""The current project has unsaved changes,\\n""\n        ""are you sure you want to create a new project?"")\n    def new_project(self, *args, **kwargs):\n        # Create a new project\n        self.model.current_project = Project(parent=self.model)\n\n        # Set the current filename property and update the title\n        self.update_title()\n\n        # Show the edit project dialog\n        self.view.project.present()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - general\n    # ------------------------------------------------------------\n    def on_manual_activate(self, widget, data=None):\n        try:\n            import webbrowser\n            webbrowser.open(settings.MANUAL_URL)\n        except:\n            pass # ignore errors\n        return True\n\n    def on_about_activate(self, widget, data=None):\n        self.view[""about_window""].show()\n        return True\n\n    def on_main_window_destroy_event(self, widget, event):\n        self.quit()\n        return True\n\n    def on_main_window_delete_event(self, widget, event):\n        self.quit()\n        return True\n\n    def on_menu_item_quit_activate (self, widget, data=None):\n        self.quit()\n        return True\n\n    def on_refresh_graph(self, event):\n        if self.model.current_project:\n            with self.model.current_project.data_changed.hold():\n                self.model.current_project.update_all_mixtures()\n                self.redraw_plot()\n\n    def on_save_graph(self, event):\n        filename = None\n        if self.model.single_specimen_selected:\n            filename = os.path.splitext(self.model.current_specimen.name)[0]\n        else:\n            filename = self.model.current_project.name\n        self.plot_controller.save(\n            parent=self.view.get_toplevel(),\n            current_name=filename,\n            num_specimens=len(self.model.current_specimens),\n            offset=self.model.current_project.display_plot_offset)\n\n    def on_toggled_plot_toolbar(self, action):\n        if action.get_active():\n            self.view.show_plot_toolbar()\n        else:\n            self.view.hide_plot_toolbar()\n\n    @BaseController.status_message(""Sampling..."", ""sampling"")\n    def on_sample_point(self, event):\n        """"""\n            Sample a point on the plot and display the (calculated and)\n            experimental data values in an information dialog.\n        """"""\n\n        self.edc = None\n\n        def parse_x_pos(x_pos, event):\n            # Clear the eye dropper controller\n            self.edc.enabled = False\n            self.edc.disconnect()\n            del self.edc\n            # Get experimental data at the sampled point\n            exp_y = self.model.current_specimen.experimental_pattern.get_y_at_x(x_pos)\n            message = ""Sampled point:\\n""\n            message += ""\\tExperimental data:\\t( %.4f , %.4f )\\n"" % (x_pos, exp_y)\n            # Get calculated data if applicable\n            if self.model.current_project.layout_mode == ""FULL"":\n                calc_y = self.model.current_specimen.calculated_pattern.get_y_at_x(x_pos)\n                message += ""\\tCalculated data:\\t\\t( %.4f , %.4f )"" % (x_pos, calc_y)\n            # Display message dialog\n            DialogFactory.get_information_dialog(\n                message, parent=self.view.get_toplevel()\n            ).run()\n\n\n        self.edc = EyeDropper(self.plot_controller, parse_x_pos)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Project related\n    # ------------------------------------------------------------\n    @BaseController.status_message(""Creating new project..."", ""new_project"")\n    def on_new_project_activate(self, widget, data=None):\n        self.new_project()\n\n    @BaseController.status_message(""Displaying project data..."", ""edit_project"")\n    def on_edit_project_activate(self, widget, data=None):\n        self.view.project.present()\n\n    @BaseController.status_message(""Open project..."", ""open_project"")\n    def on_open_project_activate(self, widget, data=None):\n        """"""Open an existing project. Asks the user if (s)he\'s sure when an \n        unsaved project is loaded.""""""\n        self.load_project()\n\n    @BaseController.status_message(""Save project..."", ""save_project"")\n    def on_save_project_activate(self, widget, *args):\n        # No filename yet: show a dialog\n        if not self.model.current_filename:\n            self.save_project_dialog.update(title=""Save project"").run(\n                lambda dialog: self._save_project(filename=dialog.filename)\n            )\n        else: # we already have a filename, overwrite:\n            self._save_project()\n\n    @BaseController.status_message(""Save project as..."", ""save_project_as"")\n    def on_save_project_as_activate(self, widget, *args):\n        self.save_project_dialog.update(title=""Save project as"").run(\n            lambda dialog: self._save_project(filename=dialog.filename)\n        )\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Mixtures related\n    # -----------------------------------------------------------\n    def on_edit_mixtures(self, widget, data=None):\n        if self.model.project_loaded:\n            self.view.mixtures.present()\n        pass\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Behaviour related\n    # ------------------------------------------------------------\n    def on_edit_behaviours(self, widget, data=None):\n        #if self.model.project_loaded:\n        #    self.view.behaviours.present()\n        return True\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Specimen related\n    # ------------------------------------------------------------\n    def on_edit_specimen_activate(self, event):\n        self.project.edit_specimen()\n        return True\n\n    def on_add_specimen_activate(self, event):\n        self.project.add_specimen()\n        return True\n\n    def on_add_multiple_specimens(self, event):\n        self.project.import_multiple_specimen()\n        return True\n\n    def on_del_specimen_activate(self, event):\n        self.project.delete_selected_specimens()\n        return True\n\n    def on_replace_specimen_data_activate(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.on_replace_experimental_data()\n        return True\n\n    def on_export_specimen_data_activate(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.on_export_experimental_data()\n        return True\n\n    def on_convert_to_fixed_activate(self, event):\n        for specimen in self.model.current_specimens:\n            specimen.convert_to_fixed()\n\n    def on_convert_to_ads_activate(self, event):\n        for specimen in self.model.current_specimens:\n            specimen.convert_to_ads()\n\n    def on_remove_background(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.remove_background()\n        else:\n            self.project.remove_backgrounds(self.model.current_specimens)\n        return True\n\n    def on_smooth_data(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.smooth_data()\n        return True\n\n    def on_add_noise(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.add_noise()\n        return True\n\n    def on_shift_data(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.shift_data()\n        return True\n\n    def on_strip_peak(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.strip_peak()\n        return True\n\n    def on_peak_properties(self, event):\n        if self.model.single_specimen_selected:\n            self.specimen.peak_properties()\n        return True\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Phases related\n    # ------------------------------------------------------------\n    def on_edit_phases_activate(self, event):\n        if self.model.project_loaded:\n            self.view.phases.present()\n        return True\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Atom Types related\n    # ------------------------------------------------------------\n    def on_edit_atom_types_activate(self, event):\n        if self.model.project_loaded:\n            self.view.atom_types.present()\n        return True\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers - Markers related\n    # ------------------------------------------------------------\n    def on_edit_markers_activate(self, event):\n        if self.model.current_specimen is not None:\n            self.view.markers.present()\n        return True\n\n    def edit_marker(self, marker):\n        self.show_markers_for(marker.specimen)\n\n    pass # end of class\n\n'"
pyxrd/application/icons.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n#TODO make this gtk agnostic\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GdkPixbuf  # @UnresolvedImport\n\ndef get_icon_list():\n    return [\n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_16x16.png"")), #@UndefinedVariable \n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_24x24.png"")), #@UndefinedVariable\n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_32x32.png"")), #@UndefinedVariable\n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_48x48.png"")), #@UndefinedVariable\n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_64x64.png"")), #@UndefinedVariable\n        GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd_icon_128x128.png"")) #@UndefinedVariable\n    ]\n'"
pyxrd/application/models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport hashlib\n\nfrom pyxrd.generic.models import PyXRDModel\nfrom pyxrd.generic.io.json_codec import PyXRDEncoder\n\nfrom mvc.models.properties.signal_property import SignalProperty\nfrom mvc.models.properties.labeled_property import LabeledProperty\n\nclass AppModel(PyXRDModel):\n    """"""\n        Simple model that stores the state of the application window.\n        Should never be made persistent.\n        \n        Attributes:\n            needs_plot_update: a mvc.Signal to indicate the plot needs an\n                update. This models listens for the \'needs_update\' signal on the\n                loaded project and propagates this accordingly.\n            current_project: the currently loaded project\n            current_specimen: the currently selected specimen, is None if more\n                than one specimen is selected.\n            current_specimens: a list of currently selected specimens, is never\n                None, even if only one specimen is selected.\n            single_specimen_selected: a boolean indicating whether or not a\n                single specimen is selected\n            multiple_specimen_selected: a boolean indicating whether or not\n                multiple specimen are selected\n    """"""\n\n    # SIGNALS:\n    needs_plot_update = SignalProperty()\n\n    # PROPERTIES:\n    current_project = LabeledProperty(default=None, text=""Current project"")\n    \n    @current_project.setter\n    def current_project(self, value):\n        _current_project = type(self).current_project._get(self)\n        if _current_project is not None: \n            self.relieve_model(_current_project)\n            self._project_hash = None\n        _current_project = value\n        type(self).current_project._set(self, value)\n        type(type(self)).object_pool.clear()\n        if _current_project is not None: self.observe_model(_current_project)\n        self.clear_selected()\n        self.needs_plot_update.emit()\n\n    @property\n    def current_filename(self):\n        return self.current_project.filename if self.current_project else None\n\n    current_specimen = LabeledProperty(default=None, text=""Current specimen"")\n    @current_specimen.setter\n    def current_specimen(self, value):\n        type(self).current_specimens._set(self, [value])\n        type(self).current_specimen._set(self, value)\n\n    current_specimens = LabeledProperty(default=[], text=""Current specimens"")\n    @current_specimens.setter\n    def current_specimens(self, value):\n        if value == None:\n            value = []\n        type(self).current_specimens._set(self, value)\n        if len(self._current_specimens) == 1:\n            type(self).current_specimen._set(self, self._current_specimens[0])\n        else:\n            type(self).current_specimen._set(self, None)\n\n    @property\n    def project_loaded(self):\n        return self.current_project is not None\n\n    @property\n    def specimen_selected(self):\n        return self.current_specimen is not None\n\n    @property\n    def single_specimen_selected(self):\n        return self.specimen_selected and len(self.current_specimens) == 1\n\n    @property\n    def multiple_specimens_selected(self):\n        return len(self.current_specimens) > 1\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, project=None):\n        """""" Initializes the AppModel with the given Project. """"""\n        super(AppModel, self).__init__()\n        self.current_project = project\n        if project: project.parent = self\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @PyXRDModel.observe(""data_changed"", signal=True)\n    @PyXRDModel.observe(""visuals_changed"", signal=True)\n    def notify_needs_update(self, model, prop_name, info):\n        self.needs_plot_update.emit()\n\n    def clear_selected(self):\n        self.current_specimens = None\n\n    # ------------------------------------------------------------\n    #      Project change management:\n    # ------------------------------------------------------------\n    _project_hash = None\n    def update_project_last_save_hash(self):\n        if self.current_project is not None:\n            dump = PyXRDEncoder.dump_object(self.current_project).encode(errors=\'ignore\')\n            self._project_hash = hashlib.sha224(dump).hexdigest()\n    def check_for_changes(self):\n        current_hash = None\n        if self.current_project is not None:\n            dump = PyXRDEncoder.dump_object(self.current_project).encode(errors=\'ignore\')\n            current_hash = hashlib.sha224(dump).hexdigest()\n        return current_hash != self._project_hash\n\n    pass # end of class\n'"
pyxrd/application/splash.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, Gdk, GdkPixbuf, GObject # @UnresolvedImport\n\nfrom time import time, sleep\nfrom pyxrd.application.icons import get_icon_list\n\ndef scale_ratio(src_width, src_height, dest_width, dest_height):\n    """"""Return a size fitting into dest preserving src\'s aspect ratio.""""""\n    if src_height > dest_height:\n        if src_width > dest_width:\n            ratio = min(float(dest_width) / src_width,\n                        float(dest_height) / src_height)\n        else:\n            ratio = float(dest_height) / src_height\n    elif src_width > dest_width:\n        ratio = float(dest_width) / src_width\n    else:\n        ratio = 1\n    return int(ratio * src_width), int(ratio * src_height)\n\nclass ScalableImage(Gtk.Image):\n    """"""A Gtk.Image that rescales to fit whatever size is available.\n\n    Only Pixbuf data is supported; it can be loaded from a file or\n    passed directly.\n    """"""\n    def __init__(self, pixbuf=None):\n        super(ScalableImage, self).__init__()\n        self._pixbuf = None\n        self.connect(\'size-allocate\', self._on_size_allocate)\n        self.set_size_request(1, 1)\n        self._hyper_id = None\n        if pixbuf is not None:\n            self.set_from_pixbuf(pixbuf)\n\n    def _on_timeout_hyper(self):\n        """"""Perform a delayed high-quality scale.""""""\n        self._hyper_id = None\n        allocation = self.get_allocation()\n        target_width, target_height = scale_ratio(\n            self._pixbuf.get_width(), self._pixbuf.get_height(),\n            allocation.width, allocation.height)\n        if target_width > 0 and target_height > 0:\n            pixbuf = self._pixbuf.scale_simple(\n                target_width, target_height, GdkPixbuf.InterpType.HYPER) # @UndefinedVariable\n            super(ScalableImage, self).set_from_pixbuf(pixbuf)\n\n    def _on_size_allocate(self, image, allocation, force=False):\n        """"""Scale the internal pixbuf copy to a new size.""""""\n        if self._pixbuf is None:\n            return\n        pix_width = self._pixbuf.get_width()\n        pix_height = self._pixbuf.get_height()\n        target_width, target_height = scale_ratio(\n            pix_width, pix_height, allocation.width, allocation.height)\n        old_pix = self.get_pixbuf()\n        if target_width < pix_width or target_height < pix_height:\n            if (force or not old_pix\n                or old_pix.get_width() != target_width\n                or old_pix.get_height() != target_height):\n                # If we\'re forcing an update we have a new image,\n                # since that\'s a ""big"" event we can afford to\n                # hyper-scale right away. On the other hand if it\'s\n                # not a forced update the window just resized, that\n                # needs responsiveness immediately, so delay the hyper\n                # scale until the window is stationary for at least\n                # 1/10 of a second.\n                if self._hyper_id:\n                    GObject.source_remove(self._hyper_id)\n                    self._hyper_id = None\n                if target_width > 0 and target_height > 0:\n                    pixbuf = self._pixbuf.scale_simple(\n                        target_width, target_height,\n                        GdkPixbuf.InterpType.HYPER if force else GdkPixbuf.InterpType.NEAREST) # @UndefinedVariable\n                    if not force:\n                        self._hyper_id = GObject.timeout_add(100, self._on_timeout_hyper)\n                    super(ScalableImage, self).set_from_pixbuf(pixbuf)\n        elif old_pix != self._pixbuf:\n            if self._hyper_id:\n                GObject.source_remove(self._hyper_id)\n                self._hyper_id = None\n            super(ScalableImage, self).set_from_pixbuf(self._pixbuf)\n\n    def set_from_file(self, filename):\n        """"""Set the image by loading a file.""""""\n        pixbuf = GdkPixbuf.Pixbuf.new_from_file(filename) #@UndefinedVariable\n        self.set_from_pixbuf(pixbuf)\n\n    def set_from_pixbuf(self, pixbuf):\n        """"""Set the image from a GdkPixbuf.Pixbuf.""""""\n        self._pixbuf = pixbuf\n        self._on_size_allocate(None, self.get_allocation(), force=True)\n\n    def __not_implemented(self, *args):\n        """"""This Gtk.Image storage type is not supported.""""""\n        raise NotImplementedError(""only pixbuf images are currently supported"")\n\n    set_from_animation = __not_implemented\n    set_from_gicon = __not_implemented\n    set_from_icon_name = __not_implemented\n    set_from_icon_set = __not_implemented\n    set_from_image = __not_implemented\n    set_from_pixmap = __not_implemented\n    set_from_stock = __not_implemented\n\nclass SplashScreen(object):\n    def __init__(self, filename, version=""""):\n        # DONT connect \'destroy\' event here!\n        self.window = Gtk.Window(Gtk.WindowType.TOPLEVEL)\n        self.window.set_auto_startup_notification(False)\n        self.window.set_default_icon_list(get_icon_list())\n        self.window.set_icon_list(get_icon_list())\n        self.window.set_title(\'PyXRD\')\n        self.window.set_skip_taskbar_hint(True)\n        self.window.set_position(Gtk.WindowPosition.CENTER)\n        self.window.set_decorated(False)\n        self.window.set_resizable(False)\n        self.window.set_border_width(1)\n        self.window.modify_bg(Gtk.StateType.NORMAL, Gdk.color_parse(\'white\')) # @UndefinedVariable\n\n        ebox = Gtk.EventBox() # prevent the black color from showing through...\n        self.window.add(ebox)\n\n        main_vbox = Gtk.VBox(False, 1)\n        main_vbox.set_border_width(10)\n        ebox.add(main_vbox)\n\n        self.img = ScalableImage()\n        self.img.set_from_file(filename)\n        self.img.set_size_request(500, 300)\n        main_vbox.pack_start(self.img, True, True, 0)\n\n        self.lbl = Gtk.Label()\n        self.lbl.set_markup(""<span size=\\""larger\\""><b>Loading ...</b></span>"")\n        self.lbl.set_alignment(0.5, 0.5)\n        main_vbox.pack_end(self.lbl, True, True, 0)\n\n        self.version_lbl = Gtk.Label()\n        self.version_lbl.set_markup(""<i>Version %s</i>"" % version)\n        self.version_lbl.set_alignment(0.5, 0.5)\n        main_vbox.pack_end(self.version_lbl, True, True, 0)\n\n        self.window.show_all()\n        while Gtk.events_pending():\n            Gtk.main_iteration()\n        self.start_time = time()\n\n        self.closed = False\n    \n    def set_message(self, message):\n        self.lbl.set_markup(""<span size=\\""larger\\""><b>%s</b></span>"" % message)\n        while Gtk.events_pending():\n            Gtk.main_iteration()\n\n    def close(self):\n        if not self.closed:\n            self.window.set_auto_startup_notification(True)\n            while (max(5 - (time() - self.start_time), 0) != 0):\n                sleep(0.1)\n                while Gtk.events_pending():\n                    Gtk.main_iteration()\n            self.window.destroy()\n            del self.window, self.lbl, self.img, self.version_lbl\n            self.closed = True\n\n\n    pass # end of class\n'"
pyxrd/application/views.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, GdkPixbuf  # @UnresolvedImport\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.views import ObjectListStoreView, BaseView, HasChildView, FormattedTitleView\n\nfrom pyxrd.project.views import ProjectView\nfrom pyxrd.specimen.views import SpecimenView, EditMarkersView\nfrom pyxrd.application.icons import get_icon_list\n\nclass AppView(HasChildView, FormattedTitleView):\n    """"""\n        The main application interface view.\n        \n        Attributes:\n            project: the project view\n            specimen: the specimen view\n            markers: the markers view\n            phases: the phases view\n            atom_types: the atom_types view\n            statistics: the statistics view\n            mixtures: the mixtures view\n            \n        \n    """"""\n    builder = resource_filename(__name__, ""glade/application.glade"")\n    top = ""main_window""\n    title_format = ""PyXRD - %s""\n\n    child_views = {\n        ""project"": ProjectView,\n        ""specimen"": SpecimenView,\n        ""markers"": EditMarkersView, # FIXME this should be part of the specimen view/controller code\n        ""phases"": ObjectListStoreView,\n        ""atom_types"": ObjectListStoreView,\n        ""behaviours"": ObjectListStoreView,\n        ""mixtures"": ObjectListStoreView\n    }\n\n    widget_groups = {\n        \'full_mode_only\': [\n            ""tbtn_edit_phases"",\n            #""tbtn_edit_behaviours"",\n            ""tbtn_edit_atom_types"",\n            ""tbtn_edit_mixtures"",\n            ""tbtn_separator1"",\n            ""btn_sample"",\n            ""separator3"",\n            ""separator4"",\n            ""separator5"",\n            ""main_menu_item_edit_phases"",\n            ""main_menu_item_edit_atom_types"",\n            ""main_menu_item_edit_mixtures""\n        ]\n    }\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        super(AppView, self).__init__(*args, **kwargs)\n\n        # Setup about window:\n        def on_aboutbox_response(dialog, response, *args):\n            if response < 0:\n                dialog.hide()\n                dialog.emit_stop_by_name(\'response\')\n\n        def on_aboutbox_close(widget, event=None):\n            self[""about_window""].hide()\n            return True\n\n        self[""about_window""].set_version(settings.VERSION)\n        self[""about_window""].set_website(""https://github.com/PyXRD/PyXRD/blob/v%s/Manual.pdf"" % settings.VERSION);\n        pixbuf = GdkPixbuf.Pixbuf.new_from_file(resource_filename(__name__, ""icons/pyxrd.png"")) # @UndefinedVariable\n        scaled_buf = pixbuf.scale_simple(212, 160, GdkPixbuf.InterpType.BILINEAR) # @UndefinedVariable\n        self[""about_window""].set_logo(scaled_buf)\n        self[""about_window""].connect(""response"", on_aboutbox_response)\n        self[""about_window""].connect(""close"", on_aboutbox_close)\n        self[""about_window""].connect(""delete_event"", on_aboutbox_close)\n\n        self[""main_window""].set_icon_list(get_icon_list())\n\n        self.reset_all_views()\n        if not settings.DEBUG:\n            self.get_top_widget().maximize()\n        self.set_layout_mode(settings.DEFAULT_LAYOUT)\n\n        self._clear_gdk_windows()\n        self.get_top_widget().show()\n\n        return\n\n    def _clear_gdk_windows(self):\n        gdktops = Gtk.Window.list_toplevels()\n        gtktop = self[""main_window""]\n        our_gdktop = gtktop.get_window()        \n        for gdktop in gdktops:\n            if not our_gdktop == gdktop:\n                gdktop.hide()\n\n    def setup_plot(self, plot_controller):\n        # Get plot canvas widget\n        self.canvas_widget = plot_controller.get_canvas_widget()\n        self.canvas_widget.set_name(""matplotlib_box2"")\n        self[""matplotlib_box2""] = self.canvas_widget\n        \n        # Get plot toolbar widget\n        self.nav_toolbar = plot_controller.get_toolbar_widget(self.get_top_widget())\n        self.nav_toolbar.set_name(""navtoolbar"")\n        self[""navtoolbar""] = self.nav_toolbar\n        \n        # Insert into the window hierarchy:\n        self[""matplotlib_box""].add(self.canvas_widget)\n        self[""matplotlib_box""].show_all()       \n        \n        self[""navtoolbar_box""].add(self.nav_toolbar)\n        self.nav_toolbar.hide()\n\n    def reset_child_view(self, view_name, class_type=None):\n        if getattr(self, view_name, None) is not None:\n            getattr(self, view_name).hide()\n            setattr(self, view_name, None)\n        if class_type == None:\n            class_type = self.child_views[view_name]\n        view = class_type(parent=self)\n        setattr(self, view_name, view)\n        view.set_layout_mode(self.current_layout_state)\n\n        if view_name.lower() == ""project"":\n            # Plug in this tree view in the main application:\n            self._add_child_view(\n                view.specimens_treeview_container, self[""specimens_container""])\n\n        return view\n\n    def reset_all_views(self):\n        for view_name, class_type in self.child_views.items():\n            self.reset_child_view(view_name, class_type)\n\n    # ------------------------------------------------------------\n    #      Sensitivity updates\n    # ------------------------------------------------------------\n    def update_project_sensitivities(self, project_loaded):\n        """"""\n            Updates the views sensitivities according to the flag \'project_loaded\'\n            indicating whether or not there\'s a project loaded.\n        """"""\n        self[""main_pained""].set_sensitive(project_loaded)\n        self[""project_actions""].set_sensitive(project_loaded)\n        for action in self[""project_actions""].list_actions():\n            action.set_sensitive(project_loaded)\n\n    def update_specimen_sensitivities(self, single_specimen_selected, multiple_specimen_selected):\n        """"""\n            Updates the views sensitivities according to the flags \n            \'single_specimen_active\' indicating whether or not there\'s a single\n            specimen selected (= active) and \'multiple_specimen_active\' \n            indicating whether or not there are multiple specimen selected.\n        """"""\n        self[""specimen_actions""].set_sensitive(single_specimen_selected)\n        self[""specimens_actions""].set_sensitive(single_specimen_selected or multiple_specimen_selected)\n\n    def update_plot_status(self, angularpos, dspacing, experimental, calculated=None):\n        wrapper = ""<span font_family=\\""monospace\\"">%s</span>""\n        text = """"\n        if angularpos is not None:\n            text = ""20=% 3.2f \xc2\xb0    d=% 3.2f nm    I<sub>e</sub>=% 5d"" % (angularpos, dspacing, experimental)\n            if calculated is not None:\n                text += ""    I<sub>c</sub>=% 5d"" % calculated\n        self[""lbl_plot_info""].set_markup(wrapper % text) \n        \n    # ------------------------------------------------------------\n    #      View update methods\n    # ------------------------------------------------------------\n    def set_layout_mode(self, mode):\n        super(AppView, self).set_layout_mode(mode)\n        for view_name in self.child_views:\n            getattr(self, view_name).set_layout_mode(mode)\n\n    def show_plot_toolbar(self):\n        self.nav_toolbar.show()\n        \n    def hide_plot_toolbar(self):\n        self.nav_toolbar.hide()\n\n    def show(self, *args, **kwargs):\n        BaseView.show(self, *args, **kwargs)\n\n    def get_toplevel(self):\n        return self[""main_window""]\n\n    pass # end of class\n'"
pyxrd/atoms/__init__.py,0,b''
pyxrd/atoms/controllers.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom contextlib import contextmanager\nfrom os.path import dirname\n\nimport numpy as np\n\nfrom mvc import Controller\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.controllers import BaseController, ObjectListStoreController\nfrom pyxrd.atoms.models import AtomType\nfrom pyxrd.atoms.views import EditAtomTypeView\nfrom pyxrd.data import settings\nfrom pyxrd.file_parsers.atom_type_parsers import atom_type_parsers\n\nclass EditAtomTypeController(BaseController):\n    """"""\n        The controller for the AtomType model and EditAtomTypeView view.\n    """"""\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def register_adapters(self):\n        self.update_plot()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update_plot(self):\n        x, y = (), ()\n        if self.model is not None:\n            x = np.arange(0, 90.0, 90.0 / 100.0)\n            y = self.model.get_atomic_scattering_factors(2 * np.sin(np.radians(x / 2)) / settings.DEFAULT_LAMBDA)\n        self.view.update_figure(x, y)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""parameters_changed"", signal=True)\n    def notif_parameter_changed(self, model, prop_name, info):\n        self.update_plot()\n\n    pass # end of class\n\nclass AtomTypesController(ObjectListStoreController): # FIXME THIS NEES CLEAN-UP AND TESTING!!\n    """"""\n        Controller for an AtomType ObjectListStore model and view.\n    """"""\n    file_filters = property(fget=lambda *a: atom_type_parsers.get_file_filters())\n    export_filters = property(fget=lambda *a: atom_type_parsers.get_export_file_filters())\n    treemodel_property_name = ""atom_types""\n    treemodel_class_type = AtomType\n    columns = [ (""Atom type name"", ""c_name"") ]\n    delete_msg = ""Deleting an atom type is irreversible!\\nAre You sure you want to continue?""\n    obj_type_map = [\n        (AtomType, EditAtomTypeView, EditAtomTypeController),\n    ]\n    title = ""Edit Atom Types""\n\n    _export_atomtypes_dialog = None\n    @property\n    def export_atomtypes_dialog(self):\n        """""" Creates & returns the \'export atom types\' dialog """"""\n        if self._export_atomtypes_dialog is None:\n            # Default location of the database:\n            current_folder = dirname(settings.DATA_REG.get_file_path(""ATOM_SCAT_FACTORS""))\n            # Create the dialog once, and re-use\n            self._export_atomtypes_dialog = DialogFactory.get_save_dialog(\n                title=""Export atom types"",\n                current_folder=current_folder,\n                persist=True,\n                filters=self.export_filters,\n                parent=self.view.get_top_widget()\n            )\n        return self._export_atomtypes_dialog\n\n    _import_atomtypes_dialog = None\n    @property\n    def import_atomtypes_dialog(self):\n        """""" Creates & returns the \'import atom types\' dialog """"""\n        if self._import_atomtypes_dialog is None:\n            # Default location of the database:\n            current_folder = dirname(settings.DATA_REG.get_file_path(""ATOM_SCAT_FACTORS""))\n            # Create the dialog once, and re-use\n            self._import_atomtypes_dialog = DialogFactory.get_load_dialog(\n                title=""Import atom types"",\n                current_folder=current_folder,\n                persist=True, multiple=False,\n                filters=self.file_filters,\n                parent=self.view.get_top_widget()\n            )\n        return self._import_atomtypes_dialog\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_atom_types_tree_model(self, *args):\n        return self.treemodel\n\n    def create_new_object_proxy(self):\n        return AtomType(name=""New Atom Type"", parent=self.model)\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.data_changed.hold():\n            yield\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_load_object_clicked(self, event):\n        self.import_atomtypes_dialog.run(\n            lambda dialog: self.model.load_atom_types(\n                dialog.filename,\n                dialog.parser\n            )\n        )\n\n    def on_save_object_clicked(self, event):\n        self.export_atomtypes_dialog.run(\n            lambda dialog: dialog.parser.write(\n                dialog.filename,\n                self.get_selected_objects(),\n                AtomType.Meta.get_local_persistent_properties()\n            )\n        )\n\n    pass # end of class\n\n'"
pyxrd/atoms/models.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom functools import partial\nfrom warnings import warn\n\nimport numpy as np\n\nfrom pyxrd.generic.io import storables, Storable, get_case_insensitive_glob\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.models.mixins import CSVMixin\nfrom pyxrd.calculations.data_objects import AtomTypeData, AtomData\nfrom pyxrd.calculations.atoms import get_atomic_scattering_factor, get_structure_factor\n\nfrom mvc import Observer\nfrom mvc.models.properties.string_properties import StringProperty\nfrom mvc.models.properties.signal_mixin import SignalMixin\nfrom mvc.models.properties.float_properties import FloatProperty\nfrom mvc.models.properties.bool_property import BoolProperty\nfrom mvc.models.properties.read_only_mixin import ReadOnlyMixin\nfrom mvc.models.properties.labeled_property import LabeledProperty\nfrom mvc.models.properties.integer_properties import IntegerProperty\n\n@storables.register()\nclass AtomType(CSVMixin, DataModel, Storable):\n    """"""\n    An AtomType model contains all the physical & chemical information for \n    one ion, e.g. Fe3+ & Fe2+ are two different AtomTypes.\n    """"""\n\n    # MODEL METADATA:\n    class Meta(DataModel.Meta):\n        store_id = ""AtomType""\n\n    #: The project this AtomType belongs to or None. Effectively an alias for `parent`.\n    project = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    _data_object = None\n    @property\n    def data_object(self):\n        """"""\n        The data object that is used in the calculations framework \n        (see :mod:`pyxrd.generic.calculations.atoms`).\n        Is an instance of :class:`~pyxrd.generic.calculations.data_objects.AtomTypeData`\n        """"""\n\n        self._data_object.par_c = self.par_c\n        self._data_object.debye = self.debye\n        self._data_object.charge = self.charge\n        self._data_object.weight = self.weight\n\n        return self._data_object\n\n    #: Name of the AtomType (e.g. :math:`Fe^{2+}`)\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The atomic number, or an arbitrarily high number (+300) for compounds\n    atom_nr = IntegerProperty(\n        default=0, text=""Atom Nr"",\n        visible=True, persistent=True,\n        widget_type=""entry""\n    )\n\n    def __get_par_a(self, index=0):\n        return self._data_object.par_a[index]\n\n    def __set_par_a(self, value, index=0):\n        assert (index >= 0 and index < 5)\n        self._data_object.par_a[index] = value\n\n    def __get_par_b(self, index=0):\n        return self._data_object.par_b[index]\n\n    def __set_par_b(self, value, index=0):\n        assert (index >= 0 and index < 5)\n        self._data_object.par_b[index] = value\n\n    #: Atomic scattering factor :math:`a_1`\n    par_a1 = FloatProperty(\n        default=0.0, text=""a1"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_a, index=0), fset=partial(__set_par_a, index=0)\n    )\n    #: Atomic scattering factor :math:`a_2`\n    par_a2 = FloatProperty(\n        default=0.0, text=""a2"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_a, index=1), fset=partial(__set_par_a, index=1)\n    )\n    #: Atomic scattering factor :math:`a_3`\n    par_a3 = FloatProperty(\n        default=0.0, text=""a3"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_a, index=2), fset=partial(__set_par_a, index=2)\n    )\n    #: Atomic scattering factor :math:`a_4`\n    par_a4 = FloatProperty(\n        default=0.0, text=""a4"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_a, index=3), fset=partial(__set_par_a, index=3)\n    )\n    #: Atomic scattering factor :math:`a_5`\n    par_a5 = FloatProperty(\n        default=0.0, text=""a5"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_a, index=4), fset=partial(__set_par_a, index=4)\n    )\n\n    #: Atomic scattering factor :math:`b_1`\n    par_b1 = FloatProperty(\n        default=0.0, text=""b1"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_b, index=0), fset=partial(__set_par_b, index=0)\n    )\n    #: Atomic scattering factor :math:`b_2`\n    par_b2 = FloatProperty(\n        default=0.0, text=""b2"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_b, index=1), fset=partial(__set_par_b, index=1)\n    )\n    #: Atomic scattering factor :math:`b_3`\n    par_b3 = FloatProperty(\n        default=0.0, text=""b3"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_b, index=2), fset=partial(__set_par_b, index=2)\n    )\n    #: Atomic scattering factor :math:`b_4`\n    par_b4 = FloatProperty(\n        default=0.0, text=""b4"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_b, index=3), fset=partial(__set_par_b, index=3)\n    )\n    #: Atomic scattering factor :math:`b_5`\n    par_b5 = FloatProperty(\n        default=0.0, text=""b5"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,),\n        fget=partial(__get_par_b, index=4), fset=partial(__set_par_b, index=4)\n    )\n\n    #: Atomic scattering factor c\n    par_c = FloatProperty(\n        default=0.0, text=""c"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Debye-Waller scattering factor\n    debye = FloatProperty(\n        default=0.0, text=""c"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The charge of the ion (eg. 3.0 for :math:`Al^{3+}`)\n    charge = FloatProperty(\n        default=0.0, text=""Charge"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The atomic weight for this ion\n    weight = FloatProperty(\n        default=0.0, text=""Weight"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"", widget_type=""entry"",\n        mix_with=(SignalMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Constructor takes any of its properties as a keyword argument.\n            Any other arguments or keywords are passed to the base class.\n        """"""\n        keys = [ ""data_%s"" % prop.label for prop in type(self).Meta.get_local_persistent_properties()]\n        keys.extend([ prop.label for prop in type(self).Meta.get_local_persistent_properties()])\n        my_kwargs = self.pop_kwargs(kwargs, *keys)\n        super(AtomType, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        # Set up data object\n        self._data_object = AtomTypeData(\n            par_a=np.zeros(shape=(5,), dtype=float),\n            par_b=np.zeros(shape=(5,), dtype=float),\n            par_c=0.0,\n            debye=0.0,\n            charge=0.0,\n            weight=0.0\n        )\n\n        # Set attributes:\n        self.name = str(self.get_kwarg(kwargs, """", ""name"", ""data_name""))\n        self.atom_nr = int(self.get_kwarg(kwargs, 0, ""atom_nr"", ""data_atom_nr""))\n        self.weight = float(self.get_kwarg(kwargs, 0, ""weight"", ""data_weight""))\n        self.charge = float(self.get_kwarg(kwargs, 0, ""charge"", ""data_charge""))\n        self.debye = float(self.get_kwarg(kwargs, 0, ""debye"", ""data_debye""))\n\n        for kw in [""par_a%d"" % i for i in range(1, 6)] + [""par_b%d"" % i for i in range(1, 6)] + [""par_c""]:\n            setattr(\n                self, kw, self.get_kwarg(kwargs, 0.0, kw, ""data_%s"" % kw)\n            )\n\n    def __str__(self):\n        return ""<AtomType %s (%s)>"" % (self.name, id(self))\n\n    def get_atomic_scattering_factors(self, stl_range):\n        """"""\n        Returns the atomic scattering factor for this `AtomType` for the given range\n        of sin(theta)/lambda (`stl_range`) values. \n        """"""\n        angstrom_range = ((stl_range * 0.05) ** 2)\n        return get_atomic_scattering_factor(angstrom_range, self.data_object)\n\n    pass # end of class\n\n@storables.register()\nclass Atom(DataModel, Storable):\n    """"""\n    Atom objects combine structural information (z coordinate and proportion)\n    and an AtomType. \n    """"""\n\n    # MODEL METADATA:\n    class Meta(DataModel.Meta):\n        store_id = ""Atom""\n        layer_filters = [\n            (""Layer file"", get_case_insensitive_glob(""*.lyr"")),\n        ]\n\n    _data_object = None\n    @property\n    def data_object(self):\n        """"""\n        The data object that is used in the calculations framework \n        (see :mod:`pyxrd.generic.calculations.atoms`).\n        Is an instance of :class:`~pyxrd.generic.calculations.data_objects.AtomData`  \n        """"""\n        self._data_object.default_z = self.default_z\n        self._data_object.stretch_z = self.stretch_z\n        self._data_object.pn = self.pn\n        self._data_object.atom_type = getattr(self.atom_type, ""data_object"", None)\n        return self._data_object\n\n    component = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: The name of the Atom\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Default z coordinate for this Atom. Also see :attr:`~z`\n    default_z = FloatProperty(\n        default=0.0, text=""Default z"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether or not z coordinates should be stretched\n    #: using the silicate lattice and unit cell dimensions from the Component.\n    #: Should be set for interlayer atoms, so their z coordinates are adjusted\n    #: when the component basal spacing is changed. Also see `z`.\n    stretch_z = BoolProperty(\n        default=False, text=""Stretch z values"",\n        visible=False, persistent=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The z coordinate for this atom. If `stretch_values` is False or if\n    #: this Atom\'s component is None, then this will return the `default_z`\n    #: value. If `stretch_values` is True and a component is set on this Atom,\n    #: it is calculated as::\n    #:\n    #:     `lattice_d + (default_z - lattice_d) * factor`\n    #:\n    #: where `lattice_d` and `factor` are given by calling\n    #:`get_interlayer_stretch_factors` on the :class:`~pyxrd.phases.models.Component`.\n    @FloatProperty(\n        default=None, text=""Z"",\n        visible=True, tabular=True,\n        mix_with=(ReadOnlyMixin,)\n    )\n    def z(self):\n        if self.stretch_values and self.component is not None:\n            lattice_d, factor = self.component.get_interlayer_stretch_factors()\n            return float(lattice_d + (self.default_z - lattice_d) * factor)\n        return self.default_z\n\n    #: The # of atoms (projected onto the c-axis for the considered unit cell)\n    pn = FloatProperty(\n        default=None, text=""Multiplicity"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    def _get_weight(self):\n        if self.atom_type is not None:\n            return self.pn * self.atom_type.weight\n        else:\n            return 0.0\n\n    #: The total weight for this Atom, taking `pn` into consideration.\n    weight = FloatProperty(\n        default=None, text=""Weight"", fget=_get_weight,\n        visible=False, persistent=False,\n        mix_with=(ReadOnlyMixin,)\n    )\n\n    _atom_type_uuid = None\n    _atom_type_name = None\n    def _set_atom_type(self, value):\n        old = type(self).atom_type._get(self)\n        if old is not None:\n            self.relieve_model(old)\n        type(self).atom_type._set(self, value)\n        if value is not None:\n            self.observe_model(value)\n\n    #: The AtomType to be used for this Atom.\n    atom_type = LabeledProperty(\n        default=None, text=""Atom Type"",\n        visible=True, persistent=False, tabular=True, data_type=AtomType,\n        signal_name=""data_changed"",\n        fset=_set_atom_type,\n        mix_with=(SignalMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Constructor takes any of its properties as a keyword argument.\n            \n            In addition to the above, the constructor still supports the \n            following deprecated keywords, maping to a current keyword:\n                - z: maps to the \'default_z\' keyword.\n                \n            Any other arguments or keywords are passed to the base class.\n        """"""\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""data_z"", ""z"", ""data_pn"", ""data_atom_type"", ""stretch_z"",\n            ""atom_type_uuid"", ""atom_type_name"", ""atom_type_index"", ""atom_type"",\n            *[prop.label for prop in type(self).Meta.get_local_persistent_properties()]\n        )\n        super(Atom, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        # Set up data object\n        self._data_object = AtomData(\n            default_z=0.0,\n            pn=0.0\n        )\n\n        # Set attributes\n        self.name = str(self.get_kwarg(kwargs, """", ""name"", ""data_name""))\n\n        self.stretch_values = bool(self.get_kwarg(kwargs, False, ""stretch_values""))\n        self.default_z = float(self.get_kwarg(kwargs, 0.0, ""default_z"", ""data_z"", ""z""))\n        self.pn = float(self.get_kwarg(kwargs, 0.0, ""pn"", ""data_pn""))\n\n        self.atom_type = self.get_kwarg(kwargs, None, ""atom_type"")\n        self._atom_type_uuid = self.get_kwarg(kwargs, None, ""atom_type_uuid"")\n        self._atom_type_name = self.get_kwarg(kwargs, None, ""atom_type_name"")\n\n    def __str__(self):\n        return ""<Atom %s(%s)>"" % (self.name, repr(self))\n\n    def _unattach_parent(self):\n        self.atom_type = None\n        super(Atom, self)._unattach_parent()\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Observer.observe(""removed"", signal=True)\n    def on_removed(self, model, prop_name, info):\n        """"""\n            This method observes the Atom types \'removed\' signal,\n            as such, if the AtomType gets removed from the parent project,\n            it is also cleared from this Atom\n        """"""\n        if model == self.atom_type:\n            self.atom_type = None\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_structure_factors(self, stl_range):\n        """"""\n        Get the atom\'s structure factor for a given range of 2*sin(\xce\xb8) / \xce\xbb values.\n        Expects \xce\xbb to be in nanometers!\n        """"""\n        if self.atom_type is not None:\n            return float(get_structure_factor(stl_range, self.data_object))\n        else:\n            return 0.0\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def resolve_json_references(self):\n        if getattr(self, ""_atom_type_uuid"", None) is not None:\n            self.atom_type = type(type(self)).object_pool.get_object(self._atom_type_uuid)\n        if getattr(self, ""_atom_type_name"", None) is not None:\n            assert(self.component is not None)\n            assert(self.component.phase is not None)\n            assert(self.component.phase.project is not None)\n            for atom_type in self.component.phase.project.atom_types:\n                if atom_type.name == self._atom_type_name:\n                    self.atom_type = atom_type\n                    break\n        self._atom_type_uuid = None\n        self._atom_type_name = None\n\n    def json_properties(self):\n        retval = super(Atom, self).json_properties()\n        if self.component is None or self.component.export_atom_types:\n            retval[""atom_type_name""] = self.atom_type.name if self.atom_type is not None else """"\n        else:\n            retval[""atom_type_uuid""] = self.atom_type.uuid if self.atom_type is not None else """"\n        return retval\n\n    @staticmethod\n    def get_from_csv(filename, callback=None, parent=None):\n        """"""\n        Returns a list of atoms fetched from the .CSV file `filename`.\n        If parent is passed, this will be used to resolve AtomType references,\n        and will be passed to the constructor of the Atom as a keyword.\n        If callback is passes it will be called with the loaded atom as the\n        first and only argument.\n        """"""\n        import csv\n        atl_reader = csv.reader(open(filename, \'rb\'), delimiter=\',\', quotechar=\'""\') # TODO create csv dialect!\n        header = True\n        atoms = []\n\n        types = dict()\n        if parent is not None:\n            for atom_type in parent.phase.project.atom_types:\n                if not atom_type.name in types:\n                    types[atom_type.name] = atom_type\n\n        for row in atl_reader:\n            if not header and len(row) >= 4:\n                if len(row) == 5:\n                    name, z, def_z, pn, atom_type = row[0], float(row[1]), float(row[2]), float(row[3]), types[row[4]] if parent is not None else None\n                else:\n                    name, z, pn, atom_type = row[0], float(row[1]), float(row[2]), types[row[3]] if parent is not None else None\n                    def_z = z\n\n                if atom_type in types:\n                    atom_type = types[atom_type]\n\n                new_atom = Atom(name=name, z=z, default_z=def_z, pn=pn, atom_type=atom_type, parent=parent)\n                atoms.append(new_atom)\n                if callback is not None and callable(callback):\n                    callback(new_atom)\n                del new_atom\n\n            header = False\n        return atoms\n\n    @staticmethod\n    def save_as_csv(filename, atoms):\n        """"""\n        Saves a list of atoms to the passed filename.\n        """"""\n        import csv\n        atl_writer = csv.writer(open(filename, \'wb\'), delimiter=\',\', quotechar=\'""\', quoting=csv.QUOTE_MINIMAL)\n        atl_writer.writerow([""Atom"", ""z"", ""def_z"", ""pn"", ""Element""])\n        for item in atoms:\n            if item is not None and item.atom_type is not None:\n                atl_writer.writerow([item.name, item.z, item.default_z, item.pn, item.atom_type.name])\n\n    pass # end of class\n\n'"
pyxrd/atoms/views.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom matplotlib.figure import Figure\n\n# TODO: move this to mvc somehow:\nfrom matplotlib.backends.backend_gtk3cairo import FigureCanvasGTK3Cairo as FigureCanvasGTK\n\nfrom pyxrd.generic.views import BaseView\n\n\nclass EditAtomTypeView(BaseView):\n    builder = resource_filename(__name__, ""glade/atoms.glade"")\n    top = ""edit_atom_type""\n    widget_format = ""atom_%s""\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.graph_parent = self[""view_graph""]\n        self.setup_matplotlib_widget()\n\n    def setup_matplotlib_widget(self):\n        self.figure = Figure(dpi=72)\n\n        self.plot = self.figure.add_subplot(111)\n        self.figure.subplots_adjust(bottom=0.20)\n\n        self.matlib_canvas = FigureCanvasGTK(self.figure)\n\n        self.plot.autoscale_view()\n\n        self.graph_parent.add(self.matlib_canvas)\n        self.graph_parent.show_all()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update_figure(self, x, y):\n        self.plot.cla()\n        self.plot.plot(x, y, \'k-\', aa=True)\n        self.plot.set_ylabel(\'Scattering factor\', size=14, weight=""heavy"")\n        self.plot.set_xlabel(\'2\xce\xb8\', size=14, weight=""heavy"")\n        self.plot.autoscale_view()\n        if self.matlib_canvas is not None:\n            self.matlib_canvas.draw()\n'"
pyxrd/calculations/CSDS.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom math import sqrt, log\n\nfrom .math_tools import lognormal\n\ndef calculate_distribution(CSDS):\n    r""""""\n    Returns a tuple containing a numpy array with the (log normal) CSDS\n    distribution and a float containing the arithmetic mean of that\n    distribution.\n    \n    Takes a single :class:`~CSDSData` object as argument.\n    """"""\n    a = CSDS.alpha_scale * log(CSDS.average) + CSDS.alpha_offset\n    b = sqrt(CSDS.beta_scale * log(CSDS.average) + CSDS.beta_offset)\n\n    steps = int(CSDS.maximum - CSDS.minimum) + 1\n\n    maxT = 0\n\n    smq = 0\n    q_log_distr = []\n    TQDistr = dict()\n    for i in range(steps):\n        T = max(CSDS.minimum + i, 1e-50)\n        q = lognormal(T, a, b)\n        smq += q\n\n        TQDistr[int(T)] = q\n        maxT = T\n\n    TQarr = np.zeros(shape=(maxT + 1,), dtype=float)\n    Rmean = 0\n    for T, q in TQDistr.items():\n        TQarr[T] = q / smq\n        Rmean += T * q\n    Rmean /= smq\n\n    return TQarr, Rmean\n'"
pyxrd/calculations/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\nThis module contains the basic implementation of the matrix formalism as\ndetailed in Drits and Tchoubar (1990) and Plan\xc3\xa7on (2001).\n\nIt was chosen to implement this using \'loose\' function calls. The disadvantage\nof this approach is that the functions are no longer bound to class instances,\nwhich makes them less intuitive to use. The advantage is we can more easily\ncall these functions asynchronously (e.g. using :py:class:`~multiprocessing.Pool`) \n\nDespite all this, most function calls in this module do expect to be passed a\n:class:`~pyxrd.calculations.DataObject` sub-class, which wraps all the data in a single object. \nThese :class:`~pyxrd.calculations.DataObject` s map onto the different models used. As such this \nmodule is also largely independent from the MVC framework used.\n  \nDrits, V.A., and Tchoubar, C., 1990. X-Ray Diffraction by Disordered Lamellar Structures: Theory and Applications to Microdivided Silicates and Carbons. Springer-Verlag, Berlin, Germany.\nPlan\xc3\xa7on, A., 2001. Order-disorder in clay mineral structures. Clay Miner 36, 1\xe2\x80\x9314.\n\n""""""'"
pyxrd/calculations/atoms.py,5,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom math import pi\nimport logging\nlogger = logging.getLogger(__name__)\n\ndef get_atomic_scattering_factor(angstrom_range, atom_type):\n    r""""""\n    Calculates the atomic scatter factor for \n        - angstrom_range: numpy array of (2*sin(\xce\xb8) / \xce\xbb)\xc2\xb2 values (= 1/A\xc2\xb2 units)\n        - atom_type: an :class:`~pyxrd.calculations.data_objects.AtomTypeData`\n          instance\n          \n    The atomic scattering factor is calculated as follows:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{flalign*}\n            & ASF = \\left[ c + \\sum_{i=1}^{5}{ \\left( a_i \\cdot e ^ { - b_i \\cdot {\\left(2 \\cdot \\frac{sin(\\theta)}{\\lambda}\\right)}^2 } \\right) } \\right] \n            \\cdot e ^ { B \\cdot {\\left(2 \\cdot \\frac{sin(\\theta)}{\\lambda}\\right)}^2 }  \n        \\end{flalign*}\n        \n    Where a_i, b_i and c are the scattering factors taken from `atom_type`\n    """"""\n    if atom_type is not None:\n        asf = np.sum(atom_type.par_a * np.exp(-atom_type.par_b * angstrom_range[..., np.newaxis]), axis=1) + atom_type.par_c\n        asf = asf * np.exp(-atom_type.debye * angstrom_range)\n        return asf\n    else:\n        logger.warning(""get_atomic_scattering_factor reports: \'None found!\'"")\n        return np.zeros_like(angstrom_range)\n\ndef get_structure_factor(range_stl, atom):\n    r""""""\n    Calculates the atom\'s structure factor for\n        - range_stl: numpy array of 2*sin(\xce\xb8) / \xce\xbb values (= 1/nm units)\n        - atom_type: an :class:`~pyxrd.calculations.data_objects.AtomData`\n          instance \n          \n    The structure factor is calculated using the atomic scattering factor ASF\n    (calculated by :meth:`~pyxrd.calculations.atoms.get_atomic_scattering_factor`)\n    as follows:\n\n    .. math::\n        :nowrap:\n        \n        \\begin{flalign*}\n            & SF = ASF \\cdot p \\cdot e ^ { 2 \\cdot \\pi \\cdot z \\cdot i \\cdot \\frac{2 \\cdot sin(\\theta)}{\\lambda} }\n        \\end{flalign*}\n       \n    """"""\n    if atom is not None and atom.atom_type is not None:\n        angstrom_range = ((range_stl * 0.05) ** 2)\n\n        asf = get_atomic_scattering_factor(angstrom_range, atom.atom_type)\n\n        return asf * atom.pn * np.exp(2 * pi * atom.z * range_stl * 1j)\n    else:\n        logger.warning(""get_structure_factor reports: \'None found!\'"")\n        return np.zeros_like(range_stl)\n'"
pyxrd/calculations/components.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom itertools import chain\nfrom math import pi\n\nimport numpy as np\n\nfrom .atoms import get_structure_factor\n\ndef calculate_z(default_z, lattice_d, z_factor):\n    return lattice_d + z_factor * (default_z - lattice_d)\n\ndef get_factors(range_stl, component):\n    r""""""\n    Returns a tuple containing the structure factor and phase difference for\n        - range_stl: numpy array of 2*sin(\xce\xb8) / \xce\xbb values\n        - component: a :class:`~pyxrd.calculations.data_objects.ComponentData`\n          instance containing two lists of layer and interlayer\n          :class:`~pyxrd.calculations.data_objects.Atom`\'s.\n          \n    This function calls \n    :meth:`~pyxrd.calculations.atoms.get_structure_factor` for each\n    atom in the layer and interlayer list of the component data object and\n    sums the result to obtain the component\'s structure factors.\n    \n    The component\'s phase differences are calculated as follows:\n      \n    .. math::\n        :nowrap:\n        \n        \\begin{flalign*}\n            & \\psi = e^ { 2 \\pi \\cdot { \\frac { 2 \\cdot sin(\\theta)} {\\lambda} } \\cdot \\left( d_{001} \\cdot i - \\pi \\cdot \\delta d_{001} \\cdot { \\frac {2 \\cdot sin(\\theta)} {\\lambda} } \\right) } \n        \\end{flalign*} \n        \n    """"""\n\n    z_factor = (component.d001 - component.lattice_d) / (component.default_c - component.lattice_d)\n\n    num_layer_atoms = len(component.layer_atoms)\n\n    sf_tot = 0.0 + 0.0j\n    for i, atom in enumerate(chain(component.layer_atoms, component.interlayer_atoms)):\n        atom.z = atom.default_z\n        if i >= num_layer_atoms:\n            atom.z = calculate_z(atom.z, component.lattice_d, z_factor)\n        sf_tot += get_structure_factor(range_stl, atom)\n\n    phi_tot = np.exp(2.*pi * range_stl * (component.d001 * 1j - pi * component.delta_c * range_stl))\n    return sf_tot, phi_tot\n'"
pyxrd/calculations/data_objects.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\n    The following classes are not meant to be used directly, rather you should\n    create the corresponding model instances and retrieve the DataObject from \n    them.\n    \n    The rationale behind not using the model instances directly is that\n    they are difficult to serialize or pickle (memory-)efficiently.\n    This is mainly due to all of the boiler-plate code that takes care of\n    references, saving, loading, calculating properties from other properties\n    etc. A lot of this is not needed for the actual calculation.    \n    The data objects below, on the other hand, only contain the data needed to\n    be able to calculate XRD patterns.\n""""""\n\nclass DataObject(object):\n    """"""\n    The base class for all DataObject instances.\n    \n    The constructor takes any number of keyword arguments it will set as\n    attributes on the instance.\n    """"""\n    def __init__(self, **kwargs):\n        for key, val in kwargs.items():\n            setattr(self, key, val)\n\n    pass # end of class\n\nclass AtomTypeData(DataObject):\n    """""" The DataObject describing an AtomType. """"""\n\n    #: a numpy array of `a` scattering factors\n    par_a = None\n    #: a numpy array of `b` scattering factors\n    par_b = None\n    #: the `c` scattering constant\n    par_c = None\n    #: the debye-waller temperature factor\n    debye = None\n\n    pass # end of class\n\nclass AtomData(DataObject):\n    """""" The DataObject describing an Atom. """"""\n\n    #: an :class:`~AtomTypeData` instance\n    atom_type = None\n    #: the # of atoms projected to this z coordinate\n    pn = None\n    #: the default z coordinate\n    default_z = None\n    #: the actual z coordinate\n    z = None\n\n    pass # end of class\n\nclass ComponentData(DataObject):\n    """""" The DataObject describing an Atom """"""\n\n    #: a list of :class:`~AtomData` instances\n    layer_atoms = None\n\n    #: a list of :class:`~AtomData` instances\n    interlayer_atoms = None\n\n    #: the component volume\n    volume = None\n\n    #: the component weight\n    weight = None\n\n    #: the d-spacing of the component\n    d001 = None\n\n    #: the default d-spacing of the component\n    default_c = None\n\n    #: the variation in d-spacing of the component\n    delta_c = None\n\n    #: the height of the silicate lattice (excluding the interlayer space)\n    lattice_d = None\n\n    pass # end of class\n\nclass CSDSData(DataObject):\n    """""" The DataObject describing the CSDS distribution. """"""\n\n    #: average CSDS\n    average = None\n\n    #: maximum CSDS\n    maximum = None\n\n    #: minimum CSDS\n    minimum = None\n\n    #: the alpha scale factor for the log-normal distribution\n    alpha_scale = None\n\n    #: the alpha offset factor for the log-normal distribution\n    alpha_offset = None\n\n    #: the beta scale factor for the log-normal distribution\n    beta_scale = None\n\n    #: the beta offset factor for the log-normal distribution\n    beta_offset = None\n\n    pass # end of class\n\nclass GonioData(DataObject):\n    """""" The DataObject describing the Goniometer setup. """"""\n\n    #: Lower 2-theta bound for calculated patterns\n    min_2theta = None\n\n    #: Upper 2-theta bound for calculated patterns\n    max_2theta = None\n\n    #: The number of steps in between the lower and upper 2-theta bounds\n    steps = None\n\n    #: If the first soller slits are present\n    has_soller1 = False\n    \n    #: The first soller slit size\n    soller1 = None\n\n    #: If the first soller slits are present\n    has_soller2 = False\n\n    #: The second soller slit size\n    soller2 = None\n\n    #: The divergence slit mode\n    divergence_mode = ""FIXED""\n\n    #: The divergence size (degrees (fixed) or mm (auto))\n    divergence = None\n\n    #: The Bragg angle of the monochromator (or 0\xc2\xb0 if not present)\n    mcr_2theta = 0\n\n    #: Flag indicating if intensities need to be corrected for absorption \n    has_absorption_correction = None\n    \n    #: The sample mass absorption coefficient (mg/cm\xc2\xb2)\n    absorption = 45.0\n    \n    #: The sample surface density (cm\xc2\xb2/g)\n    sample_surf_density = 20.0\n\n    #: The goniometer radius\n    radius = None\n\n    #: The goniometer wavelength\n    wavelength = None\n\n    #: The goniometer wavelength distribution\n    wavelength_distribution = None\n    \n    #: The sample length\n    sample_length = None\n\n    pass # end of class\n\nclass ProbabilityData(DataObject):\n    """""" The DataObject describing the layer stacking probabilities """"""\n\n    #: Whether this probability is really a valid one\n    valid = None\n\n    #: The number of components this probability describes\n    G = None\n\n    #: The weight fractions matrix\n    W = None\n\n    #: The probabilities matrix\n    P = None\n\n    pass # end of class\n\nclass PhaseData(DataObject):\n    """""" The DataObject describing a phase """"""\n\n    #: A flag indicating whether to apply Lorentz-polarization factor or not\n    apply_lpf = True\n\n    #: A flag indicating whether to apply machine corrections or not\n    apply_correction = True\n\n    #: A list of :class:`~ComponentData` instances\n    components = None\n\n    #: A :class:`~ProbabilityData` instance\n    probability = None\n\n    #: The sigma start value\n    sigma_star = None\n\n    #: A :class:`~CSDSData` instance\n    csds = None\n\n    pass # end of class\n\nclass SpecimenData(DataObject):\n    """""" The DataObject describing a specimen """"""\n\n    #: A :class:`~GonioData` instance\n    goniometer = None\n\n    #: The sample absorption\n    absorption = None\n\n    #: A list of :class:`~PhaseData` instances\n    phases = None\n\n    #: A numpy array with the observed intensities\n    observed_intensity = None\n\n    #: A numpy array with the calculated intensity\n    total_intensity = None\n\n    #: A nummpy array with the calculated phase profiles\n    phase_intensities = None\n\n    #: A numpy array with a correction factor taking the sample & goniometer\n    #  properties into account\n    correction = None\n\n    pass # end of class\n\nclass MixtureData(DataObject):\n    """""" The DataObject describing a mixture """"""\n\n    #: A list of :class:`~SpecimenData` instances\n    specimens = None\n\n    #: A numpy array with the phase fractions\n    fractions = None\n\n    #: A numpy array with the specimen background shifts\n    bgshifts = None\n\n    #: A numpy array with the specimen absolute scales\n    scales = None\n\n    #: Whether this MixtureData object has been parsed (internal flag)\n    parsed = False\n    \n    #: Whether this MixtureData object has been calculated (internal flag)\n    calculated = False\n\n    #: Whether this MixtureData object has been optimized (internal flag)\n    optimized = False\n\n    #: The number of specimens\n    n = 0\n\n    #: The number of phases\n    m = 0\n\n    pass # end of class\n'"
pyxrd/calculations/exceptions.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport multiprocessing\nfrom functools import wraps\nimport traceback, sys\n\nclass WrapException(Exception):\n    """"""\n        A wrapped exception used by the :meth:`~wrap_exceptions` decorator.\n    """"""\n    def __init__(self):\n        exc_type, exc_value, exc_tb = sys.exc_info()\n        self.exception = exc_value\n        self.formatted = \'\'.join(traceback.format_exception(exc_type, exc_value, exc_tb))\n    def __str__(self):\n        return \'%s\\nOriginal traceback:\\n%s\' % (Exception.__str__(self), self.formatted)\n\ndef wrap_exceptions(func):\n    """"""\n        Function decorator that allows to provide useable tracebacks when the\n        function is called asynchronously and raises an error.\n     """"""\n    @wraps(func)\n    def exception_wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except:\n            if multiprocessing.current_process().daemon:\n                raise WrapException()\n            else:\n                raise\n    return exception_wrapper'"
pyxrd/calculations/goniometer.py,7,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\n\nfrom scipy.special import erf\nfrom math import sqrt\n\nfrom .math_tools import sqrt2pi, sqrt8\n\ndef get_S(soller1, soller2):\n    _S = sqrt((soller1 * 0.5) ** 2 + (soller2 * 0.5) ** 2)\n    _S1S2 = soller1 * soller2\n    return _S, _S1S2\n\ndef get_T(range_theta, sigma_star, soller1, soller2):\n    sigma_star = float(max(sigma_star, 1e-18))\n    S, _ = get_S(soller1, soller2)\n    range_st = np.sin(range_theta)\n    Q = S / (sqrt8 * range_st * sigma_star)\n    return erf(Q) * sqrt2pi / (2.0 * sigma_star * S) - 2.0 * range_st * (1.0 - np.exp(-(Q ** 2.0))) / (S ** 2.0)\n \ndef get_lorentz_polarisation_factor(range_theta, sigma_star, soller1, soller2, mcr_2theta):\n    """"""\n        Get the lorentz polarisation factor for the given sigma-star value,\n        soller slits, monochromator Bragg angle and the given theta range\n    """"""\n    T = get_T(range_theta, sigma_star, soller1, soller2)\n    pol = np.cos(np.radians(mcr_2theta)) ** 2\n    return T * (1.0 + pol * (np.cos(2.0 * range_theta) ** 2)) / np.sin(range_theta)\n\ndef get_fixed_to_ads_correction_range(range_theta, goniometer):\n    return np.sin(range_theta)\n\ndef get_nm_from_t(theta, wavelength=0.154056, zero_for_inf=False):\n    """"""\n        Convert the given theta angles (scalar or np array) to\n        nanometer spacings using the given wavelength\n    """"""\n    return get_nm_from_2t(2.0 * theta, wavelength=wavelength, zero_for_inf=zero_for_inf)\n\ndef get_nm_from_2t(twotheta, wavelength=0.154056, zero_for_inf=False):\n    """"""\n        Convert the given 2-theta angles (scalar or np array) to\n        nanometer spacings using the given wavelength\n    """"""\n    if twotheta == 0:\n        return 0. if zero_for_inf else 1e16\n    else:\n        return wavelength / (2.0 * np.sin(np.radians(twotheta / 2.0)))\n\ndef get_t_from_nm(nm, wavelength=0.154056):\n    """"""\n        Convert the given nanometer spacings (scalar or np array) to\n        theta angles using the given wavelength\n    """"""\n    return get_2t_from_nm(nm, wavelength=wavelength) / 2\n\ndef get_2t_from_nm(nm, wavelength=0.154056):\n    """"""\n        Convert the given nanometer spacings (scalar or np array) to\n        2-theta angles using the given wavelength\n    """"""\n    twotheta = 0.0\n    if nm != 0:\n        twotheta = np.degrees(np.arcsin(max(-1.0, min(1.0, wavelength / (2.0 * nm))))) * 2.0\n    return twotheta\n\n'"
pyxrd/calculations/improve.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom io import StringIO\n\nfrom scipy.optimize import fmin_l_bfgs_b\n\nfrom .exceptions import wrap_exceptions\n\ndef setup_project(projectf):\n    from pyxrd.file_parsers.json_parser import JSONParser\n    from pyxrd.project.models import Project\n    type(Project).object_pool.clear()\n\n    f = StringIO(projectf)\n    project = JSONParser.parse(f)\n    f.close()\n\n    return project\n\n@wrap_exceptions\ndef run_refinement(projectf, mixture_index):\n    """"""\n        Runs a refinement setup for \n            - projectf: project data\n            - mixture_index: what mixture in the project to use\n    """"""\n    if projectf is not None:\n        from pyxrd.data import settings\n        settings.initialize()\n\n        # Retrieve project and mixture:\n        project = setup_project(projectf)\n        del projectf\n\n        import gc\n        gc.collect()\n\n        mixture = project.mixtures[mixture_index]\n        mixture.refinement.update_refinement_treestore()\n        refiner = mixture.refinement.get_refiner()\n        refiner.refine()\n\n        return list(refiner.history.best_solution), refiner.history.best_residual\n\n@wrap_exceptions\ndef improve_solution(projectf, mixture_index, solution, residual, l_bfgs_b_kwargs={}):\n    if projectf is not None:\n        from pyxrd.data import settings\n        settings.initialize()\n\n        # Retrieve project and mixture:\n        project = setup_project(projectf)\n        del projectf\n\n        mixture = project.mixtures[mixture_index]\n\n        with mixture.data_changed.ignore():\n\n            # Setup context again:\n            mixture.update_refinement_treestore()\n            refiner = mixture.refinement.get_refiner()\n\n            # Refine solution\n            vals = fmin_l_bfgs_b(\n                refiner.get_residual,\n                solution,\n                approx_grad=True,\n                bounds=refiner.ranges,\n                **l_bfgs_b_kwargs\n            )\n            new_solution, new_residual = tuple(vals[0:2])\n\n        # Return result\n        return new_solution, new_residual\n    else:\n        return solution, residual\n'"
pyxrd/calculations/math_tools.py,15,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom math import exp, sqrt, log, pi\n\nimport numpy as np\n\nsqrtpi = sqrt(pi)\nsqrt2pi = sqrt(2 * pi)\nsqrt8 = sqrt(8)\n\ndef mmult(A, B):\n    return np.sum(np.transpose(A, (0, 2, 1))[:, :, :, np.newaxis] * B[:, :, np.newaxis, :], -3)\n\ndef mdot(A, B):\n    C = np.zeros(shape=A.shape, dtype=np.complex)\n    for i in range(A.shape[0]):\n        C[i] = np.dot(A[i], B[i])\n    return C\n\ndef mtim(A, B): # currently unused?\n    C = np.zeros(shape=A.shape, dtype=np.complex)\n    for i in range(A.shape[0]):\n        C[i] = np.multiply(A[i], B[i])\n    return C\n\ndef solve_division(A, B): # currently unused?\n    bt = np.transpose(B, axes=(0, 2, 1))\n    at = np.transpose(A, axes=(0, 2, 1))\n    return np.array([np.transpose(np.linalg.lstsq(bt[i], at[i])[0]) for i in range(bt.shape[0])])\n\ndef lognormal(T, a, b):\n    return exp(-(log(T) - a) ** 2 / (2.0 * (b ** 2))) / (sqrt2pi * abs(b) * T)\n\ndef add_noise(x, noise_fraction=0.05):\n    if x.size > 0:\n        abs_value = noise_fraction * np.amax(x)\n        return x + np.random.standard_normal(x.shape) * abs_value\n    else:\n        return x\n\ndef smooth(x, half_window_len=3, window=\'blackman\'):\n    """"""smooth the data using a window with requested size.\n    \n    This method is based on the convolution of a scaled window with the signal.\n    The signal is prepared by introducing reflected copies of the signal \n    (with the window size) in both ends so that transient parts are minimized\n    in the beginning and end part of the output signal.\n    \n    input:\n        x: 1D array like (assumed to be spaced equally)\n        half_window_len: half of the dimension of the smoothing window, actual window\n            is calculated from this so that: window_len = 2*half_window_len + 1, this\n            ensures that the window is always an odd number, regardless of user input;\n        window: the type of window from \'flat\', \'hanning\', \'hamming\', \'bartlett\', \'blackman\'\n            flat window will produce a moving average smoothing.\n\n    output:\n        the smoothed signal\n        \n    example:\n\n    t=linspace(-2,2,0.1)\n    x=sin(t)+randn(len(t))*0.1\n    y=smooth(x)\n    \n    see also: \n    \n    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve\n    scipy.signal.lfilter\n \n    """"""\n\n    window_len = half_window_len * 2 + 1\n\n    if x.ndim != 1:\n        x = np.ndarray.flatten(x)\n\n    if x.size < window_len:\n        raise ValueError(""Input vector needs to be bigger than window size."")\n\n    if window_len < 3:\n        return x\n\n    if not window in [\'flat\', \'hanning\', \'hamming\', \'bartlett\', \'blackman\']:\n        raise ValueError(""Window is on of \'flat\', \'hanning\', \'hamming\', \'bartlett\', \'blackman\'"")\n\n\n    s = np.r_[x[window_len - 1:0:-1], x, x[-1:-window_len:-1]]\n    if window == \'flat\': # moving average\n        w = np.ones(window_len, \'d\')\n    else:\n        w = eval(\'np.\' + window + \'(window_len)\')\n\n    y = np.convolve(w / w.sum(), s, mode=\'valid\')\n    return y[half_window_len:-half_window_len]'"
pyxrd/calculations/mixture.py,21,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n\nimport time\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\n\nfrom pyxrd.data import settings\n\nfrom .specimen import calculate_phase_intensities, calculate_scaled_intensities, get_clipped_intensities\nfrom .exceptions import wrap_exceptions\nfrom .statistics import Rp, Rpw, Rpder, Rphase\n\n__residual_method_map = {\n    ""Rp"" : Rp,\n    ""Rpw"" : Rpw,\n    ""Rpder"": Rpder,\n    ""Rphase"": Rphase\n}\n\n#===============================================================================\n# Solution vector handling:\n#===============================================================================\ndef parse_solution(x, mixture):\n    # Get the original solution   \n    fractions = mixture.fractions\n    scales = mixture.scales\n    bgshifts = mixture.bgshifts\n    \n    # We normalize the new fractions so the sum of all fractions\n    # (including static fractions) is always 1\n    scaled_fracs = x[:mixture.m] * (1.0 - mixture.sum_static_fractions) / np.sum(x[:mixture.m])\n    \n    # Store the variables in the right positions:\n    np.put(fractions, mixture.selected_fractions, scaled_fracs)\n    np.put(scales, mixture.selected_scales, x[mixture.m:mixture.m + mixture.n])\n    np.put(bgshifts, mixture.selected_bgshifts, x[-mixture.o:])\n    \n    # Return the complete arrays (including static factors)\n    return fractions, scales, bgshifts\n\ndef get_solution(mixture):\n    return np.concatenate((\n        np.take(mixture.fractions, mixture.selected_fractions),\n        np.take(mixture.scales, mixture.selected_scales),\n        np.take(mixture.bgshifts, mixture.selected_bgshifts)\n    ))    \n\ndef set_solution(x, mixture):\n    mixture.fractions, mixture.scales, mixture.bgshifts = parse_solution(x, mixture)   \n\ndef get_zero_solution(mixture):\n    # Create complete solution array\n    x0 = np.ones(shape=(mixture.m+mixture.n+mixture.o,))\n    # Set all bg shifts to zero   \n    x0[-mixture.o:] = 0.0\n    # Set all fractions to equal size (of the remainder)\n    x0[:mixture.m] = 1.0 / (1.0 - mixture.sum_static_fractions)\n    \n    return x0\n\n#===============================================================================\n# Solution bounds handling:\n#===============================================================================\ndef get_bounds(mixture):\n    bounds = [(0., 1.) for _ in range(mixture.m)] # allow zero fractions\n    bounds += [(1e-3, None) for _ in range(mixture.n)] # don\'t allow zero scales\n    bounds += [(0., None) for _ in range(mixture.o)]\n    return bounds\n\n#===============================================================================\n# Residual calculations:\n#===============================================================================\ndef _get_specimen_residual(specimen):\n    """"""\n        Returns the residual error for the given specimen and the (otionally)\n        given calculated data. If no calculated data is passed, the calculated\n        data stored in the specimen object is used (and assumed to be set).\n    """"""\n    exp, cal = get_clipped_intensities(specimen)\n    return __residual_method_map[settings.RESIDUAL_METHOD](exp, cal)   \n\ndef _get_residuals(x, mixture):\n    set_solution(x, mixture)\n    mixture = calculate_mixture(mixture)\n    return mixture.residuals\n\ndef get_residual(mixture):\n    return _get_residuals(get_solution(mixture), mixture)\n\n#===============================================================================\n# Mixture calculations:\n#===============================================================================\n\ndef parse_mixture(mixture, force=False):\n    """"""\n        This calculates the phase intensities.\n    """"""\n    if not mixture.parsed or force:\n        mixture.parsed = False\n        # Sanity checks:\n        assert mixture.n > 0, ""Need at least 1 specimen to optimize phase fractions, scales and background.""\n        assert mixture.n == len(mixture.specimens), ""Invalid specimen count on mixture data object.""\n        assert mixture.m > 0, ""Need at least 1 phase in one of the specimen to optimize phase fractions, scales and background.""\n        \n        # We have some fixed fractions:\n        mixture.selected_fractions = np.asanyarray(np.nonzero(mixture.fractions_mask)).flatten()\n        mixture.selected_scales = np.asanyarray(np.nonzero(mixture.scales_mask)).flatten()\n        mixture.selected_bgshifts = np.asanyarray(np.nonzero(mixture.bgshifts_mask)).flatten()\n        mixture.real_m = mixture.m\n        mixture.real_n = mixture.n\n        mixture.real_o = mixture.n\n        mixture.m = len(mixture.selected_fractions)\n        mixture.n = len(mixture.selected_scales)\n        mixture.o = len(mixture.selected_bgshifts)\n        \n        # The first term should be 1.0, unless the user entered a custom fraction\n        sm = np.sum(mixture.fractions)\n        mixture.sum_static_fractions = sm - np.sum(np.take(mixture.fractions, mixture.selected_fractions))\n        if sm != 1.0 and mixture.sum_static_fractions < 0.0 or mixture.sum_static_fractions > 1.0:\n            mixture.fractions = mixture.fractions / sm\n            sm = 1.0\n        mixture.sum_static_fractions = sm - np.sum(np.take(mixture.fractions, mixture.selected_fractions))\n            \n        \n        mixture.z = 0\n        for specimen in mixture.specimens:\n            if specimen is not None:\n                mixture.z = len(specimen.z_list)\n                break\n        assert mixture.z > 0, ""Need at least 1 pattern in one of the specimens to optimize phase fractions, scales and background.""\n\n        for specimen in mixture.specimens:\n            if specimen is not None:\n                specimen.correction, specimen.phase_intensities = \\\n                    calculate_phase_intensities(specimen)\n            else:\n                logger.warning(""parse_mixture reports: \'None found!\'"")\n                \n        mixture.parsed = True\n\n@wrap_exceptions\ndef optimize_mixture(mixture, force=False):\n    """"""\n        Optimizes the mixture fractions, scales and bg shifts.\n        Returns the mixture data object.\n    """"""\n    if not mixture.optimized or force:\n        # 0. Calculate phase intensitities\n        try:\n            parse_mixture(mixture)\n        except AssertionError:\n            if settings.DEBUG:\n                raise\n            return mixture # ignore and return the original object back\n    \n        # 1. setup start point:\n        x0 = get_zero_solution(mixture)\n        bounds = get_bounds(mixture)\n    \n        # 2. Define target function:        \n        def _get_average_residual(x):\n            # Reset this flag so we actually recalculated stuff: \n            mixture.calculated = False\n            res = _get_residuals(x, mixture)[0]\n            return res\n    \n        # 3. Optimize:\n        t1 = time.time()\n        lastx, residual, info = fmin_l_bfgs_b(\n            _get_average_residual,\n            x0,\n            approx_grad=True,\n            bounds=bounds,\n            iprint=-1\n        )\n        if np.isscalar(residual): # Make sure this is an array:\n            residual = np.array([residual])\n    \n        t2 = time.time()\n        logger.debug(\'%s took %0.3f ms\' % (""optimize_mixture"", (t2 - t1) * 1000.0))\n        logger.debug(\' Solution: %s\' % lastx)\n        logger.debug(\' Average residual: %s\' % residual)\n        logger.debug(\' Info dict: %s\' % info)\n    \n        # 4. rescale scales and fractions so they fit into [0-1] range,\n        #    and round them to have 6 digits max:\n        fractions, scales, bgshifts = parse_solution(lastx, mixture)\n        fractions = fractions.flatten()\n    \n        sum_frac = np.sum(fractions)\n        if sum_frac == 0.0 and len(fractions) > 0: # prevent NaN errors\n            fractions[0] = 1.0\n            sum_frac = 1.0\n        fractions = np.around((fractions / sum_frac), 6)\n        scales *= sum_frac\n        scales = scales.round(6)\n    \n        # 5. Set properties on data object \n        mixture.fractions = fractions\n        mixture.scales = scales\n        mixture.bgshifts = bgshifts\n        mixture.residual = residual\n\n        # We still need to recalculated with the last solution\n        mixture.calculated = False \n        \n        # But we do have optimized fractions etc.\n        mixture.optimized = True\n\n    return mixture\n\n@wrap_exceptions\ndef calculate_mixture(mixture, force=False):\n    """"""\n        Calculates total intensities for the current mixture, without optimizing\n        fractions, scales & background shifts.\n        Returns the mixture data object.\n    """"""\n    if not mixture.calculated or force:\n        try:\n            parse_mixture(mixture)\n        except AssertionError:\n            for specimen in mixture.specimens:\n                if specimen is not None:\n                    specimen.total_intensity = None # clear pattern\n                    specimen.scaled_phase_intensities = None # clear pattern\n            return mixture\n        \n        fractions = np.asanyarray(mixture.fractions)\n    \n        # This will contain the following residuals:\n        # Average, Specimen1, Specimen2, ...\n        mixture.residuals = [0.0, ]\n        for scale, bgshift, specimen in zip(mixture.scales, mixture.bgshifts, mixture.specimens):\n            specimen_residual = 0.0\n            if specimen is not None:\n                bgshift = bgshift if settings.BGSHIFT else 0.0\n                specimen = calculate_scaled_intensities(specimen, scale, fractions, bgshift)\n                if specimen.observed_intensity.size > 0:\n                    specimen_residual = _get_specimen_residual(specimen)\n                else:\n                    logger.warning(""calculate_mixture reports: \'Zero observations found!\'"")\n            mixture.residuals.append(specimen_residual)\n        mixture.residuals[0] = np.average(mixture.residuals[1:])\n        \n        mixture.calculated = True\n        \n    return mixture\n\n@wrap_exceptions\ndef calculate_and_optimize_mixture(mixture):\n    """"""\n        Calculates total intensities for the current mixture, after optimizing\n        fractions, scales & background shifts.\n        Returns the mixture data object.\n    """"""\n    return calculate_mixture(optimize_mixture(mixture))\n\n@wrap_exceptions\ndef get_optimized_residual(mixture):\n    """"""\n        Calculates total intensities for the current mixture, after optimizing\n        fractions, scales & background shifts.\n        Returns the average residual instead of the mixture data object.\n    """"""\n    mixture = calculate_and_optimize_mixture(mixture)\n    return mixture.residual\n    '"
pyxrd/calculations/peak_detection.py,23,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom scipy import stats\n\nfrom .math_tools import smooth\n\ndef find_closest(value, array, col=0):\n    """"""\n        Find closest value to another value in an array \n    """"""\n    nparray = np.array(list(zip(*array))[col])\n    idx = (np.abs(nparray - value)).argmin()\n    return array[idx]\n\ndef score_minerals(peak_list, minerals):\n    """"""\n        Scoring function for mineral peaks\n        peak_list: list of tuples containing observed peak position and (abs) intensity\n        minerals: dict with the mineral name as key and a peak list as value,\n           analogeous to the first argument but with relative intensities\n           \n        Uses a simple appoach:\n        loop over the reference minerals, \n         loop over first 10 strongest peaks for that mineral (starting at \n          stronger reflections towards weaker)\n         find a peak in the observed peak data set that matches\n         if matching add to the list of matched peaks\n         if not matching and this is the strongest reflections, ignore mineral\n        after this initial loop we have a list of matched peaks,\n        this list is then used to calculate a score for the mineral by looking\n        at how well positions and intensities match with the reference and how\n        many peaks are actually matched of course. Higher values means a higher\n        likelihood this mineral is present.\n    """"""\n    max_pos_dev = 0.01 # fraction\n    scores = []\n    for mineral, abbreviation, mpeaks in minerals:\n        tot_score = 0\n        p_matches = []\n        i_matches = []\n        already_matched = []\n        mpeaks = sorted(mpeaks, key=lambda peak: peak[0], reverse=True)\n        if len(mpeaks) > 15:\n            mpeaks = mpeaks[:15]\n\n        for i, (mpos, mint) in enumerate(mpeaks):\n            epos, eint = find_closest(mpos, peak_list)\n            if abs(epos - mpos) / mpos <= max_pos_dev and not epos in already_matched:\n                p_matches.append([mpos, epos])\n                i_matches.append([mint, eint])\n                already_matched.append(epos)\n            elif i == 0:\n                break # if strongest peak does not match, ignore mineral\n\n        if len(p_matches) > 3:\n            p_matches = np.array(p_matches)\n            i_matches = np.array(i_matches)\n\n            i_matches[:, 1] = i_matches[:, 1] / np.max(i_matches[:, 1])\n\n            p_slope, p_intercept, p_r_value, p_value, p_std_err = stats.linregress(p_matches) # @UnusedVariable\n            i_slope, i_intercept, i_r_value, p_value, i_std_err = stats.linregress(i_matches) # @UnusedVariable\n\n            p_factor = (p_r_value ** 2) * min(1.0 / (abs(1.0 - p_slope) + 1E-50), 1000.) / 1000.0\n            i_factor = (1.0 - min(i_std_err / 0.25, 5.0) / 5.0) * min(1.0 / (abs(1.0 - i_slope) + 1E-50), 1000.) / 1000.0 # * max(1. / (abs(i_intercept) + 1E-50), 100.) / 100.\n            tot_score = len(p_matches) * p_factor * i_factor\n\n        if tot_score > 0:\n            scores.append((mineral, abbreviation, mpeaks, p_matches, tot_score))\n\n    scores = sorted(scores, key=lambda score: score[-1], reverse=True)\n    return scores\n\ndef peakdetect(y_axis, x_axis=None, lookahead=500, delta=0):\n    """""" single run of multi_peakdetect """"""\n    mintabs, maxtabs = multi_peakdetect(y_axis, x_axis, lookahead, [delta])\n    return mintabs[0], maxtabs[0]\n\ndef multi_peakdetect(y_axis, x_axis=None, lookahead=500, deltas=[0]):\n    """"""\n    Converted from/based on a MATLAB script at http://billauer.co.il/peakdet.html\n    \n    Algorithm for detecting local maximas and minmias in a signal.\n    Discovers peaks by searching for values which are surrounded by lower\n    or larger values for maximas and minimas respectively\n    \n    keyword arguments:\n    y_axis -- A list containg the signal over which to find peaks\n    x_axis -- A x-axis whose values correspond to the \'y_axis\' list and is used\n        in the return to specify the postion of the peaks. If omitted the index\n        of the y_axis is used. (default: None)\n    lookahead -- (optional) distance to look ahead from a peak candidate to\n        determine if it is the actual peak (default: 500) \n        \'(sample / period) / f\' where \'4 >= f >= 1.25\' might be a good value\n    deltas -- (optional) this specifies a minimum difference between a peak and\n        the following points, before a peak may be considered a peak. Useful\n        to hinder the algorithm from picking up false peaks towards to end of\n        the signal. To work well delta should be set to \'delta >= RMSnoise * 5\'.\n        (default: 0)\n            Delta function causes a 20% decrease in speed, when omitted\n            Correctly used it can double the speed of the algorithm\n    \n    return -- two lists [maxtab, mintab] containing the positive and negative\n        peaks respectively. Each cell of the lists contains a tupple of:\n        (position, peak_value) \n        to get the average peak value do \'np.mean(maxtab, 0)[1]\' on the results\n    """"""\n    rlen = list(range(len(deltas)))\n    maxtab = [ [] for i in rlen] # @UnusedVariable\n    mintab = [ [] for i in rlen] # @UnusedVariable\n    dump = [ [] for i in rlen] # Used to pop the first hit which always if false @UnusedVariable\n\n    length = len(y_axis)\n    y_axis = y_axis / np.max(y_axis)\n    if x_axis is None:\n        x_axis = list(range(length))\n\n    # perform some checks\n    if length != len(x_axis):\n        raise ValueError(""Input vectors y_axis and x_axis must have same length"")\n    if lookahead < 1:\n        raise ValueError(""Lookahead must be above \'1\' in value"")\n\n    # needs to be a numpy array\n    y_axis = np.asarray(y_axis)\n\n    # Only detect peak if there is \'lookahead\' amount of points after it\n    for j, delta in enumerate(deltas):\n\n        # maxima and minima candidates are temporarily stored in\n        # mx and mn respectively\n        mn, mx = np.Inf, -np.Inf\n\n        for index, (x, y) in enumerate(zip(x_axis[:-lookahead], y_axis[:-lookahead])):\n            if y > mx:\n                mx = y\n                mxpos = x\n            if y < mn:\n                mn = y\n                mnpos = x\n            ####look for max####\n            if y < mx - delta and mx != np.Inf:\n                # Maxima peak candidate found\n                # look ahead in signal to ensure that this is a peak and not jitter\n                if y_axis[index:index + lookahead].max() < mx:\n                    maxtab[j].append((mxpos, mx))\n                    dump[j].append(True)\n                    # set algorithm to only find minima now\n                    mx = np.Inf\n                    mn = np.Inf\n\n            ####look for min####\n            if y > mn + delta and mn != -np.Inf:\n                # Minima peak candidate found\n                # look ahead in signal to ensure that this is a peak and not jitter\n                if y_axis[index:index + lookahead].min() > mn:\n                    mintab[j].append((mnpos, mn))\n                    dump[j].append(False)\n                    # set algorithm to only find maxima now\n                    mn = -np.Inf\n                    mx = -np.Inf\n\n\n    # Remove the false hit on the first value of the y_axis\n    for j in rlen:\n        try:\n            if dump[j][0]:\n                maxtab[j].pop(0)\n            else:\n                mintab[j].pop(0)\n            # del dump[j]\n        except IndexError:\n            # no peaks were found, should the function return empty lists?\n            pass\n\n    return maxtab, mintab\n\ndef peakdetect_zero_crossing(y_axis, x_axis=None, window=49):\n    """"""\n    Algorithm for detecting local maximas and minmias in a signal.\n    Discovers peaks by dividing the signal into bins and retrieving the\n    maximum and minimum value of each the even and odd bins respectively.\n    Division into bins is performed by smoothing the curve and finding the\n    zero crossings.\n    \n    Suitable for repeatable sinusoidal signals with some amount of RMS noise\n    tolerable. Excecutes faster than \'peakdetect\', although this function will\n    break if the offset of the signal is too large. It should also be noted\n    that the first and last peak will probably not be found, as this algorithm\n    only can find peaks between the first and last zero crossing.\n    \n    keyword arguments:\n    y_axis -- A list containg the signal over which to find peaks\n    x_axis -- A x-axis whose values correspond to the \'y_axis\' list and is used\n        in the return to specify the postion of the peaks. If omitted the index\n        of the y_axis is used. (default: None)\n    window -- the dimension of the smoothing window; should be an odd integer\n        (default: 49)\n    \n    return -- two lists [maxtab, mintab] containing the positive and negative\n        peaks respectively. Each cell of the lists contains a tupple of:\n        (position, peak_value) \n        to get the average peak value do \'np.mean(maxtab, 0)[1]\' on the results\n    """"""\n    if x_axis is None:\n        x_axis = list(range(len(y_axis)))\n\n    length = len(y_axis)\n    if length != len(x_axis):\n        raise ValueError(\'Input vectors y_axis and x_axis must have same length\')\n\n    # needs to be a numpy array\n    y_axis = np.asarray(y_axis)\n\n    zero_indices = zero_crossings(y_axis, window=window)\n    period_lengths = np.diff(zero_indices)\n\n    bins = [y_axis[indice:indice + diff] for indice, diff in\n        zip(zero_indices, period_lengths)]\n\n    even_bins = bins[::2]\n    odd_bins = bins[1::2]\n    # check if even bin contains maxima\n    if even_bins[0].max() > abs(even_bins[0].min()):\n        hi_peaks = [even.max() for even in even_bins]\n        lo_peaks = [odd.min() for odd in odd_bins]\n    else:\n        hi_peaks = [odd.max() for odd in odd_bins]\n        lo_peaks = [even.min() for even in even_bins]\n\n\n    hi_peaks_x = [x_axis[np.where(y_axis == peak)[0]] for peak in hi_peaks]\n    lo_peaks_x = [x_axis[np.where(y_axis == peak)[0]] for peak in lo_peaks]\n\n    maxtab = [(x, y) for x, y in zip(hi_peaks, hi_peaks_x)]\n    mintab = [(x, y) for x, y in zip(lo_peaks, lo_peaks_x)]\n\n    return maxtab, mintab\n\ndef zero_crossings(y_axis, x_axis=None, window=24):\n    """"""\n    Algorithm to find zero crossings. Smoothens the curve and finds the\n    zero-crossings by looking for a sign change.\n    \n    \n    keyword arguments:\n    y_axis -- A list containg the signal over which to find zero-crossings\n    x_axis -- A x-axis whose values correspond to the \'y_axis\' list and is used\n        in the return to specify the postion of the zero-crossings. If omitted\n        then the indice of the y_axis is used. (default: None)\n    window -- half of the dimension of the smoothing window;\n        (default: 24)\n    \n    return -- the x_axis value or the indice for each zero-crossing\n    """"""\n    # smooth the curve\n    length = len(y_axis)\n    if x_axis == None:\n        x_axis = list(range(length))\n\n    x_axis = np.asarray(x_axis)\n\n    y_axis = smooth(y_axis, window)\n    zero_crossings = np.where(np.diff(np.sign(y_axis)))[0]\n    times = [x_axis[indice] for indice in zero_crossings]\n\n    # check if zero-crossings are valid\n    diff = np.diff(times)\n    if diff.std() / diff.mean() > 0.1:\n        raise ValueError(""smoothing window too small, false zero-crossings found"")\n\n    return times\n'"
pyxrd/calculations/phases.py,18,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nfrom .math_tools import mmult\n\nfrom .CSDS import calculate_distribution\nfrom .goniometer import get_lorentz_polarisation_factor\nfrom .components import get_factors\n\ndef get_structure_factors(range_stl, G, comp_list):\n    """"""\n        Calculates the structure factor and phase factor for:\n        \n            - range_stl: numpy array of 2*sin(\xce\xb8) / \xce\xbb values\n            - G: the number of components (layer types)\n            - comp_list: list of \n              :class:`~pyxrd.calculations.data_objects.ComponentData` instances\n               \n        This function calls :meth:`~pyxrd.calculations.components.get_factors`\n        for each component in `comp_list` and stores the returned structure \n        factors and phase difference factors in a numpy array (of type complex)\n        with shape (X, G) where X is expanded to fit the shape of `range_stl`.\n    """"""\n    shape = range_stl.shape + (G,)\n    SF = np.zeros(shape, dtype=np.complex_)\n    PF = np.zeros(shape, dtype=np.complex_)\n    for i, comp in enumerate(comp_list):\n        SF[:, i], PF[:, i] = get_factors(range_stl, comp) # @UndefinedVariable\n    return SF, PF\n\ndef get_Q_matrices(Q, CSDS_max):\n    Qn = np.zeros((CSDS_max + 1,) + Q.shape, dtype=complex)\n    Qn[0, ...] = np.copy(Q)\n    for n in range(1, CSDS_max + 1):\n        Qn[n, ...] = mmult(Qn[n - 1, ...], Q)\n    return Qn\n\ndef get_absolute_scale(components, CSDS_real_mean, W):\n    W = np.diag(W)\n    mean_volume = 0.0\n    mean_d001 = 0.0\n    mean_density = 0.0\n\n    for i, comp in enumerate(components):\n        if comp != None:\n            mean_volume += comp.volume * W[i]\n            mean_d001 += comp.d001 * W[i]\n            mean_density += (comp.weight * W[i] / comp.volume)\n        else:\n            logger.debug(""- calc: get_absolute_scale reports: \'Zero observations found!\'"")\n\n    mean_mass = (CSDS_real_mean * mean_volume ** 2 * mean_density)\n    if mean_mass != 0.0:\n        return mean_d001 / mean_mass\n    else:\n        return 0.0\n\ndef get_diffracted_intensity(range_theta, range_stl, phase):\n    """"""\n        Gets intensity for a single phase without taking the\n        lorentz polarization factor into account.\n    """"""\n    \n    if phase.type == ""AbtractPhase"":\n        raise NotImplementedError\n    elif phase.type == ""RawPatternPhase"":\n        return _get_raw_intensity(range_theta, range_stl, phase)\n    else:\n        return _get_diffracted_intensity(range_theta, range_stl, phase)\n\ndef get_intensity(range_theta, range_stl, soller1, soller2, mcr_2theta, phase):\n    """"""\n        Gets intensity for a single phase taking the\n        lorentz polarization factor into account.\n    """"""\n\n    intensity = get_diffracted_intensity(range_theta, range_stl, phase)\n    if phase.apply_lpf:\n        return intensity * get_lorentz_polarisation_factor(\n            range_theta,\n            phase.sigma_star,\n            soller1, soller2, mcr_2theta \n        )\n    else:\n        return intensity\n\ndef _get_raw_intensity(range_theta, range_stl, phase):\n    assert phase.type == ""RawPatternPhase"", ""Must be RawPatternPhase!""\n    f = interp1d(\n        phase.raw_pattern_x, phase.raw_pattern_y,\n        bounds_error=False, fill_value=0\n    )\n    i = f(np.rad2deg(2 * range_theta))\n    return i\n\ndef _get_diffracted_intensity(range_theta, range_stl, phase):\n    assert phase.type == ""Phase"", ""Must be Phase!""\n    # Check probability model, if invalid return zeros instead of the actual pattern:\n    if not phase.valid_probs:\n        logger.debug(""- calc: get_diffracted_intensity reports: \'Invalid probability found!\'"")\n        return np.zeros_like(range_stl)\n    else:\n        # Calculate CSDS distribution\n        CSDS_arr, CSDS_real_mean = calculate_distribution(phase.CSDS)\n\n        # Get absolute scale\n        abs_scale = get_absolute_scale(phase.components, CSDS_real_mean, phase.W)\n\n        # Create a helper function to \'expand\' certain arrays, for\n        # results which are independent of the 2-theta range\n        stl_dim = range_stl.shape[0]\n        repeat_to_stl = lambda arr: np.repeat(arr[np.newaxis, ...], stl_dim, axis=0)\n\n        # Repeat junction probabilities & weight fractions\n        W = repeat_to_stl(phase.W).astype(np.complex_)\n        P = repeat_to_stl(phase.P).astype(np.complex_)\n\n        # Repeat & get SFa and SFb (transpose conjugate) structure factor matrices:\n        SF, PF = get_structure_factors(range_stl, phase.G, phase.components)\n        SFa = np.repeat(SF[..., np.newaxis, :], SF.shape[1], axis=1)\n        SFb = np.transpose(np.conjugate(SFa), axes=(0, 2, 1))\n\n        # Calculate the repetition factor for R+ probabilities:\n        rank = P.shape[1]\n        reps = rank / phase.G\n\n        # Calculate the structure factor matrix:\n        F = np.repeat(np.repeat(np.multiply(SFb, SFa), reps, axis=2), reps, axis=1)\n\n        # Create Q phase factor matrices:\n        PF = np.repeat(PF[..., np.newaxis, :], PF.shape[1], axis=1)\n        Q = np.multiply(np.repeat(np.repeat(PF, reps, axis=2), reps, axis=1), P)\n        Qn = get_Q_matrices(Q, phase.CSDS.maximum)\n\n        # Calculate the intensity:\n        sub_total = np.zeros(Q.shape, dtype=np.complex)\n        for n in range(phase.CSDS.minimum, phase.CSDS.maximum + 1):\n            progression_factor = 0\n            for m in range(n + 1, phase.CSDS.maximum + 1):\n                progression_factor += (m - n) * CSDS_arr[m]\n            sub_total += 2 * progression_factor * Qn[n - 1, ...]\n\n        CSDS_I = repeat_to_stl(np.identity(rank, dtype=np.complex) * CSDS_real_mean)\n        sub_total = (CSDS_I + sub_total)\n        sub_total = mmult(mmult(F, W), sub_total)\n        intensity = np.real(np.trace(sub_total, axis1=2, axis2=1))\n\n        return intensity * abs_scale\n'"
pyxrd/calculations/specimen.py,10,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom math import radians, tan\nfrom scipy.interpolate.interpolate import interp1d\n\nfrom .goniometer import get_fixed_to_ads_correction_range\nfrom .phases import get_intensity\n\n\ndef get_clipped_intensities(specimen):\n    exp = specimen.observed_intensity.transpose()[...,specimen.selected_range]\n    cal = specimen.total_intensity[...,specimen.selected_range]\n    return exp, cal\n\ndef get_machine_correction_range(specimen):\n    """"""\n        Calculate a correction factor for a certain sample length,\n        sample absorption and machine setup.\n    """"""\n    goniometer = specimen.goniometer\n    range_st = np.sin(specimen.range_theta)\n    correction_range = np.ones_like(specimen.range_theta)\n    \n    # Correct for automatic divergence slits first:\n    if goniometer.divergence_mode == ""AUTOMATIC"":\n        correction_range *= get_fixed_to_ads_correction_range(\n            specimen.range_theta, goniometer)\n    # Then correct for sample absorption:\n    if goniometer.has_absorption_correction > 0.0:\n        absorption = goniometer.absorption * goniometer.sample_surf_density * 1e-3\n        if absorption > 0.0:\n            correction_range *= np.minimum(1.0 - np.exp(-2.0 * absorption / range_st), 1.0)\n    # And finally correct for sample length, if fixed slits were used:\n    if goniometer.divergence_mode == ""FIXED"" and goniometer.divergence > 0:\n        L_Rta = goniometer.sample_length / (goniometer.radius * tan(radians(goniometer.divergence)))\n        correction_range *= np.minimum(range_st * L_Rta, 1)\n    return correction_range\n\ndef calculate_phase_intensities(specimen):\n    """"""\n        Gets phase intensities for the provided phases\n        Returns a 2-tuple containing 2-theta values and phase intensities.\n    """"""\n    range_stl = 2 * np.sin(specimen.range_theta) / specimen.goniometer.wavelength\n\n    correction_range = get_machine_correction_range(specimen)\n\n    def get_phase_intensities(phases):\n        for phase in phases:\n            if phase != None:\n                correction = correction_range if phase.apply_correction else 1.0\n                yield get_intensity(\n                    specimen.range_theta, range_stl,\n                    specimen.goniometer.soller1, specimen.goniometer.soller2, specimen.goniometer.mcr_2theta,\n                    phase\n                ) * correction\n            else:\n                yield np.zeros_like(range_stl)\n\n    def interpolate_wavelength(I, new_wavelength, fraction):\n        new_theta = np.arcsin(range_stl * new_wavelength * 0.5)\n        f = interp1d(new_theta, I * fraction, bounds_error=False, fill_value=0.0)\n        return f(specimen.range_theta)\n\n    def apply_wavelength_distribution(I):\n        for new_wavelength, fraction in specimen.goniometer.wavelength_distribution:\n            I += interpolate_wavelength(I, new_wavelength, fraction)\n        return I\n\n    return (\n        correction_range,\n        np.swapaxes(np.array([\n            [ apply_wavelength_distribution(I) for I in get_phase_intensities(specimen.phases[z_index]) ]\n              for z_index in range(len(specimen.z_list))\n        ], dtype=np.float_), 0, 1) # is of shape num_phases, num_patterns, num_observations\n     )\n\ndef calculate_scaled_intensities(specimen, scale, fractions, bgshift):\n    specimen.background_intensity = bgshift * specimen.correction\n    specimen.scaled_phase_intensities = (fractions * specimen.phase_intensities.transpose()).transpose() * scale\n    specimen.total_intensity = np.sum(specimen.scaled_phase_intensities, axis=0) + specimen.background_intensity\n    return specimen\n'"
pyxrd/calculations/statistics.py,7,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom math import sqrt\nimport numpy as np\nfrom .math_tools import smooth\n\ndef R_squared(exp, calc, *args):\n    """"""\n        Calculate the \'coefficient of determination\' (aka R\xc2\xb2) for the given\n        experimental and calculated patterns (1D numpy arrays, y-values only) \n    """"""\n    avg = sum(exp) / exp.size\n    sserr = np.sum((exp - calc) ** 2)\n    sstot = np.sum((exp - avg) ** 2)\n    return 1 - (sserr / sstot)\n\ndef Rp(exp, calc, *args):\n    """"""\n        Calculate the \'pattern R factor\' (aka Rp) for the given experimental and\n        calculated patterns (1D numpy arrays, y-values only)\n    """"""\n    return np.sum(np.abs(exp - calc)) / np.sum(np.abs(exp)) * 100\n\ndef smooth_pattern(pattern):\n    """"""\n        Smooth the given pattern.\n    """"""\n    return smooth(pattern, 15)\n\ndef derive(pattern):\n    """"""\n        Calculate the first derivative pattern pattern. \n        Smoothes the input first, so noisy patterns shouldn\'t\n        be much of a problem.\n    """"""\n    return np.gradient(smooth_pattern(pattern))\n\ndef Rpder(exp, calc):\n    """"""\n        Calculated the \'derived pattern R factor\' (aka Rp\') for the given \n        experimental and calculated patterns.\n    """"""\n    return Rp(derive(exp), derive(calc))\n\ndef Rpw(exp, calc):\n    """"""\n        Calculates the \'weighted pattern R factor\' (aka Rwp) for the given experimental and\n        calculated patterns (1D numpy arrays, y-values only)\n        The weights are set equal to the inverse of the observed intensities.  \n    """"""\n    # weighted Rp:\n    # Rwp = Sqrt ( Sum[w * (obs - calc)\xc2\xb2] / Sum[w * obs\xc2\xb2] )  w = 1 / Iobs\n    sm1 = 0\n    sm2 = 0\n    for i in range(exp.size):\n        t = (exp[i] - calc[i]) ** 2 / exp[i]\n        if not (np.isnan(t) or np.isinf(t)):\n            sm1 += t\n            sm2 += abs(exp[i])\n    try:\n        return sqrt(sm1 / sm2) * 100\n    except:\n        return 0\n\ndef Rpe(exp, calc, num_params):\n    """"""\n        Calculate the \'expected pattern R factor\' (Rpe) for the given experimental and\n        calculated pattern and the number of refined parameters.\n         \n    """"""\n    # R expected:\n    # Re = Sqrt( (Points - Params) / Sum[ w * obs\xc2\xb2 ] )\n    num_points = exp.size\n    return np.sqrt((num_points - num_params) / np.sum(exp ** 2)) * 100\n\ndef Rphase(exp, calc, phase):\n    """"""\n        Calculates the \'weighted phase R factor\' (aka Rphase) for the given experimental and\n        calculated patterns (1D numpy arrays, y-values only)\n        The weights are set equal to the inverse of the observed intensities. \n    """"""\n    # weighted Rp:\n    # Rwp = Sqrt ( Sum[w * (obs - calc)\xc2\xb2] / Sum[w * obs\xc2\xb2] )  w = 1 / Iobs\n    sm1 = 0\n    sm2 = 0\n    exp = exp.flatten()\n    calc = calc.flatten()\n    phase = phase.flatten()   \n    for i in range(exp.size):\n        t = (exp[i] - calc[i]) ** 2 * phase[i] / (exp[i]**2)\n        if not (np.isnan(t) or np.isinf(t)):\n            sm1 += t\n            sm2 += abs(phase[i])\n    try:\n        return sqrt(sm1 / sm2) * 100\n    except:\n        return 0\n    \n'"
pyxrd/data/__init__.py,0,b''
pyxrd/data/appdirs.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright (c) 2005-2010 ActiveState Software Inc.\n# Copyright (c) 2013 Eddy Petri\xc8\x99or\n\n""""""Utilities for determining application-specific dirs.\n\nSee <http://github.com/ActiveState/appdirs> for details and usage.\n""""""\n# Dev Notes:\n# - MSDN on where to store app data files:\n#   http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120\n# - Mac OS X: http://developer.apple.com/documentation/MacOSX/Conceptual/BPFileSystem/index.html\n# - XDG spec for Un*x: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n\n__version_info__ = (1, 3, 0)\n__version__ = \'.\'.join(map(str, __version_info__))\n\n\nimport sys\nimport os\n\nPY3 = sys.version_info[0] == 3\n\nif PY3:\n    unicode = str\n\ndef user_data_dir(appname=None, appauthor=None, version=None, roaming=False):\n    r""""""Return full path to the user-specific data dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""roaming"" (boolean, default False) can be set True to use the Windows\n            roaming appdata directory. That means that for users on a Windows\n            network setup for roaming profiles, this user data will be\n            sync\'d on login. See\n            <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>\n            for a discussion of issues.\n\n    Typical user data directories are:\n        Mac OS X:               ~/Library/Application Support/<AppName>\n        Unix:                   ~/.local/share/<AppName>    # or in $XDG_DATA_HOME, if defined\n        Win XP (not roaming):   C:\\Documents and Settings\\<username>\\Application Data\\<AppAuthor>\\<AppName>\n        Win XP (roaming):       C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\<AppAuthor>\\<AppName>\n        Win 7  (not roaming):   C:\\Users\\<username>\\AppData\\Local\\<AppAuthor>\\<AppName>\n        Win 7  (roaming):       C:\\Users\\<username>\\AppData\\Roaming\\<AppAuthor>\\<AppName>\n\n    For Unix, we follow the XDG spec and support $XDG_DATA_HOME.\n    That means, by deafult ""~/.local/share/<AppName>"".\n    \n    On all platforms we support overriding all of this by setting the \n    $PYXRD_USER_DATA_DIR environment variable to the value of choice.\n    """"""\n    path = os.getenv(""PYXRD_USER_DATA_DIR"", None)\n    if path is None:\n        if sys.platform == ""win32"":\n            if appauthor is None:\n                appauthor = appname\n            const = roaming and ""CSIDL_APPDATA"" or ""CSIDL_LOCAL_APPDATA""\n            path = os.path.normpath(_get_win_folder(const))\n            if appname:\n                path = os.path.join(path, appauthor, appname)\n        elif sys.platform == \'darwin\':\n            path = os.path.expanduser(\'~/Library/Application Support/\')\n            if appname:\n                path = os.path.join(path, appname)\n        else:\n            path = os.getenv(\'XDG_DATA_HOME\', os.path.expanduser(""~/.local/share""))\n            if appname:\n                path = os.path.join(path, appname)\n        if appname and version:\n            path = os.path.join(path, version)\n    return path\n\n\ndef site_data_dir(appname=None, appauthor=None, version=None, multipath=False):\n    """"""Return full path to the user-shared data dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""multipath"" is an optional parameter only applicable to *nix\n            which indicates that the entire list of data dirs should be\n            returned. By default, the first item from XDG_DATA_DIRS is\n            returned, or \'/usr/local/share/<AppName>\',\n            if XDG_DATA_DIRS is not set\n\n    Typical user data directories are:\n        Mac OS X:   /Library/Application Support/<AppName>\n        Unix:       /usr/local/share/<AppName> or /usr/share/<AppName>\n        Win XP:     C:\\Documents and Settings\\All Users\\Application Data\\<AppAuthor>\\<AppName>\n        Vista:      (Fail! ""C:\\ProgramData"" is a hidden *system* directory on Vista.)\n        Win 7:      C:\\ProgramData\\<AppAuthor>\\<AppName>   # Hidden, but writeable on Win 7.\n\n    For Unix, this is using the $XDG_DATA_DIRS[0] default.\n\n    WARNING: Do not use this on Windows. See the Vista-Fail note above for why.\n    """"""\n    if sys.platform == ""win32"":\n        if appauthor is None:\n            appauthor = appname\n        path = os.path.normpath(_get_win_folder(""CSIDL_COMMON_APPDATA""))\n        if appname:\n            path = os.path.join(path, appauthor, appname)\n    elif sys.platform == \'darwin\':\n        path = os.path.expanduser(\'/Library/Application Support\')\n        if appname:\n            path = os.path.join(path, appname)\n    else:\n        # XDG default for $XDG_DATA_DIRS\n        # only first, if multipath is False\n        path = os.getenv(\'XDG_DATA_DIRS\',\n                        os.pathsep.join([\'/usr/local/share\', \'/usr/share\']))\n        pathlist = [ os.path.expanduser(x.rstrip(os.sep)) for x in path.split(os.pathsep) ]\n        if appname:\n            if version:\n                appname = os.path.join(appname, version)\n            pathlist = [ os.sep.join([x, appname]) for x in pathlist ]\n\n        if multipath:\n            path = os.pathsep.join(pathlist)\n        else:\n            path = pathlist[0]\n        return path\n\n    if appname and version:\n        path = os.path.join(path, version)\n    return path\n\n\ndef user_config_dir(appname=None, appauthor=None, version=None, roaming=False):\n    r""""""Return full path to the user-specific config dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""roaming"" (boolean, default False) can be set True to use the Windows\n            roaming appdata directory. That means that for users on a Windows\n            network setup for roaming profiles, this user data will be\n            sync\'d on login. See\n            <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>\n            for a discussion of issues.\n\n    Typical user data directories are:\n        Mac OS X:               same as user_data_dir\n        Unix:                   ~/.config/<AppName>     # or in $XDG_CONFIG_HOME, if defined\n        Win *:                  same as user_data_dir\n\n    For Unix, we follow the XDG spec and support $XDG_DATA_HOME.\n    That means, by deafult ""~/.local/share/<AppName>"".\n    """"""\n    if sys.platform in [ ""win32"", ""darwin"" ]:\n        path = user_data_dir(appname, appauthor, None, roaming)\n    else:\n        path = os.getenv(\'XDG_CONFIG_HOME\', os.path.expanduser(""~/.config""))\n        if appname:\n            path = os.path.join(path, appname)\n    if appname and version:\n        path = os.path.join(path, version)\n    return path\n\n\ndef site_config_dir(appname=None, appauthor=None, version=None, multipath=False):\n    """"""Return full path to the user-shared data dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""multipath"" is an optional parameter only applicable to *nix\n            which indicates that the entire list of config dirs should be\n            returned. By default, the first item from XDG_CONFIG_DIRS is\n            returned, or \'/etc/xdg/<AppName>\', if XDG_CONFIG_DIRS is not set\n\n    Typical user data directories are:\n        Mac OS X:   same as site_data_dir\n        Unix:       /etc/xdg/<AppName> or $XDG_CONFIG_DIRS[i]/<AppName> for each value in\n                    $XDG_CONFIG_DIRS\n        Win *:      same as site_data_dir\n        Vista:      (Fail! ""C:\\ProgramData"" is a hidden *system* directory on Vista.)\n\n    For Unix, this is using the $XDG_CONFIG_DIRS[0] default, if multipath=False\n\n    WARNING: Do not use this on Windows. See the Vista-Fail note above for why.\n    """"""\n    if sys.platform in [ ""win32"", ""darwin"" ]:\n        path = site_data_dir(appname, appauthor)\n        if appname and version:\n            path = os.path.join(path, version)\n    else:\n        # XDG default for $XDG_CONFIG_DIRS\n        # only first, if multipath is False\n        path = os.getenv(\'XDG_CONFIG_DIRS\', \'/etc/xdg\')\n        pathlist = [ os.path.expanduser(x.rstrip(os.sep)) for x in path.split(os.pathsep) ]\n        if appname:\n            if version:\n                appname = os.path.join(appname, version)\n            pathlist = [ os.sep.join([x, appname]) for x in pathlist ]\n\n        if multipath:\n            path = os.pathsep.join(pathlist)\n        else:\n            path = pathlist[0]\n    return path\n\ndef user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):\n    r""""""Return full path to the user-specific cache dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""opinion"" (boolean) can be False to disable the appending of\n            ""Cache"" to the base app data dir for Windows. See\n            discussion below.\n\n    Typical user cache directories are:\n        Mac OS X:   ~/Library/Caches/<AppName>\n        Unix:       ~/.cache/<AppName> (XDG default)\n        Win XP:     C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\<AppAuthor>\\<AppName>\\Cache\n        Vista:      C:\\Users\\<username>\\AppData\\Local\\<AppAuthor>\\<AppName>\\Cache\n\n    On Windows the only suggestion in the MSDN docs is that local settings go in\n    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming\n    app data dir (the default returned by `user_data_dir` above). Apps typically\n    put cache data somewhere *under* the given dir here. Some examples:\n        ...\\Mozilla\\Firefox\\Profiles\\<ProfileName>\\Cache\n        ...\\Acme\\SuperApp\\Cache\\1.0\n    OPINION: This function appends ""Cache"" to the `CSIDL_LOCAL_APPDATA` value.\n    This can be disabled with the `opinion=False` option.\n    \n    On all platforms we support overriding all of this by setting the \n    $PYXRD_USER_CACHE_DIR environment variable to the value of choice.\n    """"""\n    path = os.getenv(""PYXRD_USER_CACHE_DIR"", None)\n    if path is None:\n        if sys.platform == ""win32"":\n            if appauthor is None:\n                appauthor = appname\n            path = os.path.normpath(_get_win_folder(""CSIDL_LOCAL_APPDATA""))\n            if appname:\n                path = os.path.join(path, appauthor, appname)\n                if opinion:\n                    path = os.path.join(path, ""Cache"")\n        elif sys.platform == \'darwin\':\n            path = os.path.expanduser(\'~/Library/Caches\')\n            if appname:\n                path = os.path.join(path, appname)\n        else:\n            path = os.getenv(\'XDG_CACHE_HOME\', os.path.expanduser(\'~/.cache\'))\n            if appname:\n                path = os.path.join(path, appname)\n        if appname and version:\n            path = os.path.join(path, version)\n    return path\n\ndef user_log_dir(appname=None, appauthor=None, version=None, opinion=True):\n    r""""""Return full path to the user-specific log dir for this application.\n\n        ""appname"" is the name of application.\n            If None, just the system directory is returned.\n        ""appauthor"" (only required and used on Windows) is the name of the\n            appauthor or distributing body for this application. Typically\n            it is the owning company name. This falls back to appname.\n        ""version"" is an optional version path element to append to the\n            path. You might want to use this if you want multiple versions\n            of your app to be able to run independently. If used, this\n            would typically be ""<major>.<minor>"".\n            Only applied when appname is present.\n        ""opinion"" (boolean) can be False to disable the appending of\n            ""Logs"" to the base app data dir for Windows, and ""log"" to the\n            base cache dir for Unix. See discussion below.\n\n    Typical user cache directories are:\n        Mac OS X:   ~/Library/Logs/<AppName>\n        Unix:       ~/.cache/<AppName>/log  # or under $XDG_CACHE_HOME if defined\n        Win XP:     C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\<AppAuthor>\\<AppName>\\Logs\n        Vista:      C:\\Users\\<username>\\AppData\\Local\\<AppAuthor>\\<AppName>\\Logs\n\n    On Windows the only suggestion in the MSDN docs is that local settings\n    go in the `CSIDL_LOCAL_APPDATA` directory. (Note: I\'m interested in\n    examples of what some windows apps use for a logs dir.)\n\n    OPINION: This function appends ""Logs"" to the `CSIDL_LOCAL_APPDATA`\n    value for Windows and appends ""log"" to the user cache dir for Unix.\n    This can be disabled with the `opinion=False` option.\n    """"""\n    if sys.platform == ""darwin"":\n        path = os.path.join(\n            os.path.expanduser(\'~/Library/Logs\'),\n            appname)\n    elif sys.platform == ""win32"":\n        path = user_data_dir(appname, appauthor, version); version = False\n        if opinion:\n            path = os.path.join(path, ""Logs"")\n    else:\n        path = user_cache_dir(appname, appauthor, version); version = False\n        if opinion:\n            path = os.path.join(path, ""log"")\n    if appname and version:\n        path = os.path.join(path, version)\n    return path\n\n\nclass AppDirs(object):\n    """"""Convenience wrapper for getting application dirs.""""""\n    def __init__(self, appname, appauthor=None, version=None,\n                    roaming=False, multipath=False):\n        self.appname = appname\n        self.appauthor = appauthor\n        self.version = version\n        self.roaming = roaming\n        self.multipath = multipath\n    @property\n    def user_data_dir(self):\n        return user_data_dir(self.appname, self.appauthor,\n            version=self.version, roaming=self.roaming)\n    @property\n    def site_data_dir(self):\n        return site_data_dir(self.appname, self.appauthor,\n            version=self.version, multipath=self.multipath)\n    @property\n    def user_config_dir(self):\n        return user_config_dir(self.appname, self.appauthor,\n            version=self.version, roaming=self.roaming)\n    @property\n    def site_config_dir(self):\n        return site_data_dir(self.appname, self.appauthor,\n            version=self.version, multipath=self.multipath)\n    @property\n    def user_cache_dir(self):\n        return user_cache_dir(self.appname, self.appauthor,\n            version=self.version)\n    @property\n    def user_log_dir(self):\n        return user_log_dir(self.appname, self.appauthor,\n            version=self.version)\n\n\n\n\n#---- internal support stuff\n\ndef _get_win_folder_from_registry(csidl_name):\n    """"""This is a fallback technique at best. I\'m not sure if using the\n    registry for this guarantees us the correct answer for all CSIDL_*\n    names.\n    """"""\n    import winreg\n\n    shell_folder_name = {\n        ""CSIDL_APPDATA"": ""AppData"",\n        ""CSIDL_COMMON_APPDATA"": ""Common AppData"",\n        ""CSIDL_LOCAL_APPDATA"": ""Local AppData"",\n    }[csidl_name]\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,  # @UndefinedVariable\n        r""Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"")\n    dir, _ = winreg.QueryValueEx(key, shell_folder_name)  # @UndefinedVariable\n    return dir\n\ndef _get_win_folder_with_pywin32(csidl_name):\n    from win32com.shell import shellcon, shell  # @UnresolvedImport\n    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)\n    # Try to make this a unicode path because SHGetFolderPath does\n    # not return unicode strings when there is unicode data in the\n    # path.\n    try:\n        dir = unicode(dir)\n\n        # Downgrade to short path name if have highbit chars. See\n        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n        has_high_char = False\n        for c in dir:\n            if ord(c) > 255:\n                has_high_char = True\n                break\n        if has_high_char:\n            try:\n                import win32api\n                dir = win32api.GetShortPathName(dir)\n            except ImportError:\n                pass\n    except UnicodeError:\n        pass\n    return dir\n\ndef _get_win_folder_with_ctypes(csidl_name):\n    import ctypes\n\n    csidl_const = {\n        ""CSIDL_APPDATA"": 26,\n        ""CSIDL_COMMON_APPDATA"": 35,\n        ""CSIDL_LOCAL_APPDATA"": 28,\n    }[csidl_name]\n\n    buf = ctypes.create_unicode_buffer(1024)\n    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if have highbit chars. See\n    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.\n    has_high_char = False\n    for c in buf:\n        if ord(c) > 255:\n            has_high_char = True\n            break\n    if has_high_char:\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):  # @UndefinedVariable\n            buf = buf2\n\n    return buf.value\n\nif sys.platform == ""win32"":\n    try:\n        import win32com.shell  # @UnusedImport\n        _get_win_folder = _get_win_folder_with_pywin32\n    except ImportError:\n        try:\n            import ctypes  # @UnusedImport\n            _get_win_folder = _get_win_folder_with_ctypes\n        except ImportError:\n            _get_win_folder = _get_win_folder_from_registry\n\n\n\n#---- self test code\n\nif __name__ == ""__main__"":\n    appname = ""MyApp""\n    appauthor = ""MyCompany""\n\n    props = (""user_data_dir"", ""site_data_dir"",\n             ""user_config_dir"", ""site_config_dir"",\n             ""user_cache_dir"", ""user_log_dir"")\n\n    print(""-- app dirs (with optional \'version\')"")\n    dirs = AppDirs(appname, appauthor, version=""1.0"")\n    for prop in props:\n        print((""%s: %s"" % (prop, getattr(dirs, prop))))\n\n    print(""\\n-- app dirs (without optional \'version\')"")\n    dirs = AppDirs(appname, appauthor)\n    for prop in props:\n        print((""%s: %s"" % (prop, getattr(dirs, prop))))\n\n    print(""\\n-- app dirs (without optional \'appauthor\')"")\n    dirs = AppDirs(appname)\n    for prop in props:\n        print((""%s: %s"" % (prop, getattr(dirs, prop))))\n'"
pyxrd/data/settings.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport argparse, os\nfrom pyxrd.__version import __version__\nfrom .appdirs import user_data_dir, user_log_dir\n\n### General Information ###\nVERSION = __version__\n\nDEBUG = False\nFINALIZERS = [] #A list of callables that are called before the main function is left\nBGSHIFT = True\n\nLOG_FILENAME = os.path.join(user_log_dir(\'PyXRD\'), \'errors.log\')\n\n### The URL where PyXRD looks for updates & the online manual ###\nUPDATE_URL = \'http://users.ugent.be/~madumon/pyxrd/\'\nMANUAL_URL = UPDATE_URL\n\n### Factor to multiply the CSDS average with to obtain the maximum CSDS ###\nLOG_NORMAL_MAX_CSDS_FACTOR = 2.5\n\n### What type of residual error we use: ###\n#   ""Rp"" = \'standard\' pattern Rp factor\n#   ""Rpw"" = \'weighted\' pattern Rp factor\n#   ""Rpder"" = Rp factor of first-derivatives\nRESIDUAL_METHOD = ""Rp""\n\n### Default wavelength if no Goniometer is available ###\nDEFAULT_LAMBDA = 0.154056\n\n### GUI Mode (for HPC turn to False) ###\nGUI_MODE = True\n\n\n### Size of parameter space record in bytes ###\nPAR_SPACE_MEMORY_LIMIT = 25 * (1024 * 1024)\n\n### Default Styles & Colors ###\nDEFAULT_LAYOUT = ""VIEWER"" # one of the keys in DEFAULT_LAYOUTS!\nDEFAULT_LAYOUTS = {\n    ""FULL"": ""Full"",\n    ""VIEWER"": ""View-mode""\n}\n\nAXES_MANUAL_XMIN = 0.0\nAXES_MANUAL_XMAX = 70.0\nAXES_XSTRETCH = False\nAXES_DSPACING = False\nAXES_DEFAULT_WAVELENGTH = 0.154056\n\nAXES_XLIMIT = 0\nAXES_XLIMITS = {\n    0: ""Automatic"",\n    1: ""Manual""\n}\n\nAXES_MANUAL_YMIN = 0.0\nAXES_MANUAL_YMAX = 0.0\nAXES_YVISIBLE = False\n\nAXES_YNORMALIZE = 0\nAXES_YNORMALIZERS = {\n    0: ""Multi normalised"",\n    1: ""Single normalised"",\n    2: ""Unchanged raw counts"",\n}\n\nAXES_YLIMIT = 0\nAXES_YLIMITS = {\n    0: ""Automatic"",\n    1: ""Manual""\n}\n\nEXPERIMENTAL_COLOR = ""#000000""\nCALCULATED_COLOR = ""#FF0000""\n\nEXPERIMENTAL_LINEWIDTH = 1.0\nCALCULATED_LINEWIDTH = 2.0\n\nCALCULATED_LINESTYLE = ""-""\nEXPERIMENTAL_LINESTYLE = ""-""\n\nCALCULATED_MARKER = """"\nEXPERIMENTAL_MARKER = """"\n\nPATTERN_LINE_STYLES = {\n    """": ""Nothing"",\n    ""-"": ""Solid"",\n    ""--"": ""Dashed"",\n    ""-."": ""Dash Dot"",\n    "":"": ""Dotted""\n}\n\nPATTERN_MARKERS = {\n    """": ""No marker"",\n    ""."": ""Point"",\n    "","": ""Pixel"",\n    ""+"": ""Plus"",\n    ""x"": ""Cross"",\n    ""D"": ""Diamond"",\n    ""o"": ""Circle"",\n    ""v"": ""Triangle down"",\n    ""^"": ""Triangle up"",\n    ""<"": ""Triangle left"",\n    "">"": ""Triangle right"",\n    ""8"": ""Octagon"",\n    ""s"": ""Square"",\n    ""p"": ""Pentagon"",\n    ""*"": ""Star"",\n    ""h"": ""Hexagon"",\n}\n\nPATTERN_SHIFT_POSITIONS = {\n    0.42574: ""Quartz    0.42574   SiO2"",\n    0.3134:  ""Silicon   0.31355   Si"",\n    0.2476:  ""Zincite   0.24759   ZnO"",\n    0.2085:  ""Corundum  0.2085    Al2O3"",\n    0.4183:  ""Goethite  0.4183    FeO(OH)"",\n    0.48486: ""Gibbsite  0.48486   Al(OH)3"",\n}\nPATTERN_SHIFT_TYPE = ""Displacement"" # or ""Linear""\nPATTERN_SMOOTH_TYPES = { 0: ""Moving Triangle"" }\nPATTERN_BG_TYPES = { 0: ""Linear"", 1: ""Pattern"" }\n\nDIVERGENCE_MODES = {\n    ""AUTOMATIC"": ""Automatic divergence"",\n    ""FIXED"": ""Fixed divergence""\n}\nDEFAULT_DIVERGENCE_MODE = ""FIXED""\nDEFAULT_SAMPLE_LENGTH = 1.25 # in cm\n\nPLOT_OFFSET = 0.75\nPATTERN_GROUP_BY = 1\nLABEL_POSITION = 0.35\n\nMARKER_VISIBLE = True\nMARKER_X_OFFSET = 0.0\nMARKER_Y_OFFSET = 0.05\nMARKER_POSITION = 0.0\n\nMARKER_INHERIT_COLOR = True\nMARKER_COLOR = ""#000000""\nMARKER_INHERIT_ANGLE = True\nMARKER_ANGLE = 0.0\nMARKER_INHERIT_TOP_OFFSET = True\nMARKER_TOP_OFFSET = 0.0\nMARKER_INHERIT_BASE = True\nMARKER_BASE = 1\nMARKER_BASES = {\n    0: ""X-axis"",\n    1: ""Experimental profile"",\n    2: ""Calculated profile"",\n    3: ""Lowest of both"",\n    4: ""Highest of both""\n}\nMARKER_INHERIT_TOP = True\nMARKER_TOP = 0\nMARKER_TOPS = {\n     0: ""Relative to base"",\n     1: ""Top of plot""\n}\nMARKER_INHERIT_STYLE = True\nMARKER_STYLE = ""none""\nMARKER_STYLES = {\n    ""none"": ""None"", ""solid"": ""Solid"",\n    ""dashed"": ""Dash"", ""dotted"": ""Dotted"",\n    ""dashdot"": ""Dash-Dotted"", ""offset"": ""Display at Y-offset""\n}\nMARKER_INHERIT_ALIGN = True\nMARKER_ALIGN = ""left""\nMARKER_ALIGNS = {\n    ""left"": ""Left align"",\n    ""center"": ""Centered"",\n    ""right"": ""Right align""\n}\n\nEXCLUSION_FOREG = ""#999999""\nEXCLUSION_LINES = ""#333333""\n\n### Plot Information ###\nPLOT_TOP = 0.85\nMAX_PLOT_RIGHT = 0.95\nPLOT_BOTTOM = 0.0\nPLOT_LEFT = 0.05\nPLOT_HEIGHT = PLOT_TOP - PLOT_BOTTOM\n\nOUTPUT_PRESETS = [\n    (""Landscape Large print"", 8000, 4800, 300.0),\n    (""Landscape Medium print"", 6000, 3800, 300.0),\n    (""Landscape Small print"", 4000, 2800, 300.0),\n    (""Portrait Large print"", 4800, 8000, 300.0),\n    (""Portrait Medium print"", 3800, 6000, 300.0),\n    (""Portrait Small print"", 2800, 4000, 300.0),\n]\n\n### Default Directories & Files ###\nDATA_REG = None # set at run-time\nDATA_DIRS = [\n    (""DEFAULT_DATA"", ""./"", None),\n    (""USER_DATA"", user_data_dir(\'PyXRD\'), None),\n    (""LOG_DIR"", user_log_dir(\'PyXRD\'), None),\n    (""DEFAULT_PHASES"", ""default phases/"", ""USER_DATA""),\n    (""DEFAULT_COMPONENTS"", ""default components/"", ""DEFAULT_DATA""),\n    (""DEFAULT_GONIOS"", ""default goniometers/"", ""DEFAULT_DATA""),\n    (""DEFAULT_WL_DISTR"", ""default wavelength distributions/"", ""DEFAULT_DATA""),\n    (""APPLICATION_ICONS"", ""icons/"", ""DEFAULT_DATA""),\n]\nDATA_FILES = [\n    (""COMPOSITION_CONV"", ""composition_conversion.csv"", ""DEFAULT_DATA""),\n    (""ATOM_SCAT_FACTORS"", ""atomic scattering factors.atl"", ""DEFAULT_DATA""),\n    (""MINERALS"", ""mineral_references.csv"", ""DEFAULT_DATA""),\n]\n\n### Async calculation providers ###\nASYNC_SERER_PROVIDERS = [\n   ""pyxrd.server.provider.Pyro4AsyncServerProvider"",\n   ""pyxrd.generic.asynchronous.dummy_async_provider.DummyAsyncServerProvider"",\n]\nASYNC_SERVER_PRELOAD = True\n\n### Runtime Settings Retrieval ###\nSETTINGS_APPLIED = False\nARGS = None\n\ndef _parse_args():\n    """""" Parses command line arguments """"""\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        ""filename"", nargs=""?"", default="""",\n        help=""A PyXRD project filename""\n    )\n    parser.add_argument(\n        ""-s"", ""--script"", default="""",\n        help=""Can be used to pass a script containing a run() function""\n    )\n    parser.add_argument(\n        ""-d"", ""--debug"", dest=\'debug\', action=\'store_const\',\n        const=True, default=False,\n        help=\'Run in debug mode\'\n    )\n\n    args = parser.parse_args()\n    del parser # free some memory\n    return args\n\n__apply_lock__ = False\ndef initialize(override_debug=DEBUG):\n    """"""Apply runtime settings, can and needs to be called only once""""""\n    global __apply_lock__, SETTINGS_APPLIED\n    if not __apply_lock__ and not SETTINGS_APPLIED:\n        __apply_lock__ = True\n\n        # Get command line arguments\n        global ARGS\n        ARGS = _parse_args()\n\n        # Set gui flag\n        global GUI_MODE\n        GUI_MODE = not bool(ARGS.script)\n\n        # Set debug flag\n        global DEBUG\n        DEBUG = ARGS.debug or override_debug\n\n        # Setup data registry:\n        global DATA_REG, DATA_DIRS, DATA_FILES\n        from pyxrd.generic.io.data_registry import DataRegistry\n        DATA_REG = DataRegistry(dirs=DATA_DIRS, files=DATA_FILES)\n\n        # If we are running in GUI mode, setup GUI stuff:\n        if GUI_MODE:\n            import matplotlib\n            import gi\n            gi.require_version(\'Gtk\', \'3.0\')\n            from gi.repository import Gtk, GdkPixbuf\n\n            # Setup matplotlib fonts:\n            font = {\n                \'weight\' : \'heavy\', \'size\': 14,\n\t\t\'sans-serif\' : \'Helvetica, Arial, sans-serif\',\n                \'family\' : \'sans-serif\',\n            }\n            matplotlib.rc(\'font\', **font)\n            mathtext = {\n                \'default\': \'regular\',\n                \'fontset\': \'stixsans\',\n            }\n            matplotlib.rc(\'mathtext\', **mathtext)\n            # matplotlib.rc(\'text\', **{\'usetex\':True})\n            # Load our own icons:\n            iconfactory = Gtk.IconFactory()\n            icons_path = DATA_REG.get_directory_path(""APPLICATION_ICONS"")\n            for root, dirnames, filenames in os.walk(icons_path):\n                for filename in filenames:\n                    if filename.endswith("".png""):\n                        stock_id = filename[:-4] # remove extensions\n                        filename = ""%s/%s"" % (icons_path, filename)                        \n                        pixbuf = GdkPixbuf.Pixbuf.new_from_file(filename)\n                        iconset = Gtk.IconSet(pixbuf)\n                        iconfactory.add(stock_id, iconset)\n            iconfactory.add_default()\n\n        # Make sure default directories exist:\n        for path in DATA_REG.get_all_directories():\n            try:\n                os.makedirs(path)\n            except OSError:\n                pass\n\n        # Free some memory at this point:\n        import gc\n        gc.collect()\n\n        # Log that we did all of this:\n        import logging\n        logger = logging.getLogger(__name__)\n        logger.info(""Runtime settings applied"")\n\n    __apply_lock__ = False\n    SETTINGS_APPLIED = True\n\n# ## end of settings\n'"
pyxrd/file_parsers/__init__.py,0,b''
pyxrd/file_parsers/ascii_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\n\nfrom .base_parser import BaseParser\n\nclass ASCIIParser(BaseParser):\n    """"""\n        ASCII Parser\n    """"""\n    description = ""ASCII data""\n    mimetypes = [""text/plain"", ]\n    can_write = True\n\n    @classmethod\n    def get_last_line(cls, f):\n        i = -1\n        f.seek(0)\n        for i, l in enumerate(f):\n            pass\n        return i + 1, l\n\n    @classmethod\n    def write(cls, filename, x, ys, header="""", delimiter="","", **kwargs):\n        """"""\n            Writes the header to the first line, and will write x, y1, ..., yn\n            rows for each column inside the x and ys arguments.\n            Header argument should not include a newline, and can be a string or\n            any iterable containing strings.\n        """"""\n        f = open(filename, \'w\')\n        if not isinstance(header, str):\n            header = delimiter.join(header) # assume this is an iterable\n        f.write(""%s\\n"" % header)\n        np.savetxt(f, np.insert(ys, 0, x, axis=0).transpose(), fmt=""%.8f"", delimiter=delimiter)\n        f.close()\n\n    pass # end of class\n'"
pyxrd/file_parsers/base_group_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport types\nimport fnmatch\n\nfrom .base_parser import BaseParser\n\nclass BaseGroupBarser(BaseParser):\n    """"""\n        Base class for parsers that are composed of several sub-parsers (parsers\n        class attribute).\n        This allows to quickly find the correct parser based on the filename.\n        When a (python) file object is passed to the parse functions, the \'name\'\n        attribute must be present on the object, otherwise an error is raised.\n        Alternatively, you can pass in a file object, together with a (fake)\n        filename argument.\n    """"""\n    parsers = None\n\n    @classmethod\n    def _get_file(cls, fp, close=None):\n        """"""\n            Returns a three-tuple:\n            if fp is a filename:\n            filename, filename, close\n            or if fp is file-like object:\n            filename, file, close\n            where filename can be None\n            Opening of the file is left to the actual parser class if a filename\n            was passed. If a file is passed, care must be taken to ensure it is\n            opened in the correct mode (the __file_mode__ attribute on the \n            actual parsers class called). Therefore, it is safer to pass\n            filenames to a BaseGroupParser sub-class than it is to pass a \n            file-like object. \n        """"""\n        if isinstance(fp, str):\n            return fp, fp, True if close is None else close\n        else:\n            return getattr(fp, \'name\', None), fp, False if close is None else close\n\n    @classmethod\n    def get_parser(cls, filename, fp=None):\n        if not type(filename) is str and hasattr(fp, \'name\'):\n            filename = fp.name\n        if not type(filename) is str:\n            raise TypeError(""Wrong type for filename (%s), must be a string, but %s was given"" % (cls.description, type(filename)))\n        else:\n            try:\n                import gi\n                gi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\n                from gi.repository import Gio  # @UnresolvedImport\n                giof = Gio.File.new_for_path(filename) # @UndefinedVariable\n                file_mime = giof.query_info(\n                        \'standard::content-type\', \n                        Gio.FileQueryInfoFlags.NONE, None\n                    ).get_content_type()\n                del giof\n            except ImportError:\n                file_mime = ""NONE/NONE""\n                pass\n\n            # TODO init file_mime if importerror was raised...\n            for parser in cls.parsers:\n                passed = False\n                for mime in parser.mimetypes:\n                    if file_mime.split(\'/\')[0] == mime.split(\'/\')[0]: # TODO if an exact match can be made, even better\n                        passed = True\n                        break\n                    else:\n                        passed = False\n                for extension in parser.extensions:\n                    if fnmatch.fnmatch(filename, extension):\n                        passed = True\n                        break\n                    else:\n                        passed = False\n                if passed:\n                    return parser\n                    break # just for the sake of clarity\n\n    @classmethod\n    def parse(cls, fp, data_objects=None, close=True):\n        """"""\n            Parses the file \'fp\' using one of the parsers in this group.\n            \'fp\' should preferably be a filename (str), but can be a file-like\n            object. Take care to open the file in the correct mode when passing\n            a file-like object.  \n        """"""\n        filename, fp, close = cls._get_file(fp, close=close)\n        parser = cls.get_parser(filename, fp=fp)\n        return parser.parse(fp, data_objects=data_objects, close=close)\n\n    @classmethod\n    def setup_file_filter(cls):\n        """"""\n            Creates a file filter based on a list of extensions set in the\n            \'extensions\' attribute of the class using the \'description\' attribute\n            as the name for the filter. If the \'mimetypes\' attribute is also set,\n            it will also set these. If additional properties are needed, this function\n            should be overriden by subclasses.\n        """"""\n        try:\n            import gi\n            gi.require_version(\'Gtk\', \'3.0\')\n            from gi.repository import Gtk\n        except ImportError:\n            pass\n        else:\n            if cls.file_filter == None and cls.description and cls.parsers:\n                cls.file_filter = Gtk.FileFilter()\n                cls.file_filter.set_name(cls.description)\n                for parser in cls.parsers:\n                    for mtpe in parser.mimetypes:\n                        # cls.file_filter.add_mime_type(mtpe)\n                        pass\n                    for expr in parser.extensions:\n                        cls.file_filter.add_pattern(expr)\n                setattr(cls.file_filter, ""parser"", cls)\n\n    pass # end of class\n'"
pyxrd/file_parsers/base_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .meta_parser import MetaParser\nfrom .data_object import DataObject\nimport types\n\nclass BaseParser(object, metaclass=MetaParser):\n    """"""\n        Base class providing some common attributes and functions.\n        Do not register this class or subclasses without overriding the\n        following functions:\n            - parse_header\n            - parse_data\n            - parse (optional)\n            - setup_file_filter (optional)\n    """"""\n\n    # This should be changed by sub-classes\n    description = ""Base Parser""\n    extensions = []\n    mimetypes = []\n    @property\n    def can_write(self):\n        return getattr(self, ""write"", None) is not None\n    @property\n    def can_read(self):\n        return getattr(self, ""parse"", None) is not None\n    data_object_type = DataObject\n\n    # This should be changed by sub-classes\n    __file_mode__ = ""r""\n\n    file_filter = None\n\n    @classmethod\n    def _get_file(cls, fp, close=None):\n        """"""\n            Returns a three-tuple:\n            filename, file-object, close\n        """"""\n        if isinstance(fp, str):\n            return fp, open(fp, cls.__file_mode__), True if close is None else close\n        else:\n            return getattr(fp, \'name\', None), fp, False if close is None else close\n\n    @classmethod\n    def _adapt_data_object_list(cls, data_objects, num_samples, only_extend=False):\n        # If not yet created, create data_objects list:\n        if data_objects == None:\n            data_objects = [None, ]\n        # If not yet the same length, adapt:\n        num_data_objects = len(data_objects)\n        if num_data_objects < num_samples:\n            data_objects.extend([None] * int(num_samples - num_data_objects))\n        if not only_extend and num_data_objects > num_samples:\n            data_objects = data_objects[:num_samples]\n        # If not yet initialized, initialize:\n        for i in range(num_samples):\n            if not data_objects[i]:\n                data_objects[i] = cls.data_object_type()\n        return data_objects\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        """"""\n            This method is implemented by sub-classes.\n            It should parse the file and returns a list of DataObjects \n            with the header properties filled in accordingly.\n            The filename argument is always required. If no file object is passed\n            as keyword argument, it only serves as a label. Otherwise a new file\n            object is created. \n            File objects are not closed unless close is set to True.\n            Existing DataObjects can be passed as well and will then \n            be used instead of creating new ones.\n        """"""\n        # This should be implemented by sub-classes\n        raise NotImplementedError\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False):\n        """"""\n            This method is implemented by sub-classes.\n            It should parse the file and return a list of DataObjects\n            with the data properties filled in accordingly.\n            The filename argument is always required. If no file object is passed\n            as keyword argument, it only serves as a label. Otherwise a new file\n            object is created.\n            File objects are not closed unless close is set to True.\n            Existing DataObjects can be passed as well and will then \n            be used instead of creating new ones.\n        """"""\n        # This should be implemented by sub-classes\n        raise NotImplementedError\n\n\n    @classmethod\n    def parse(cls, fp, data_objects=None, close=True):\n        """"""\n            This method parses the file and return a list of DataObjects\n            with both header and data properties filled in accordingly.\n            The filename argument is always required. If no file object is passed\n            as keyword argument, it only serves as a label. Otherwise a new file\n            object is created.\n            File objects are closed unless close is set to False.\n            Existing DataObjects can be passed as well and will then \n            be used instead of creating new ones.\n        """"""\n        filename, fp, close = cls._get_file(fp, close=close)\n        data_objects = cls._parse_header(filename, fp, data_objects=data_objects)\n        data_objects = cls._parse_data(filename, fp, data_objects=data_objects)\n        if close: fp.close()\n        return data_objects\n\n    @classmethod\n    def setup_file_filter(cls):\n        """"""\n            Creates a file filter based on a list of extensions set in the\n            \'extensions\' attribute of the class using the \'description\' attribute\n            as the name for the filter. If the \'mimetypes\' attribute is also set,\n            it will also set these. If additional properties are needed, this function\n            should be overriden by subclasses.\n        """"""\n        if cls.file_filter == None and cls.description != """" and cls.extensions:\n            try:\n                import gi\n                gi.require_version(\'Gtk\', \'3.0\')\n                from gi.repository import Gtk\n            except ImportError:\n                pass\n            else:\n                # Init file filter:\n                cls.file_filter = Gtk.FileFilter()\n                cls.file_filter.set_name(cls.description)\n                for mtpe in cls.mimetypes:\n                    # cls.file_filter.add_mime_type(mtpe)\n                    pass\n                for expr in cls.extensions:\n                    cls.file_filter.add_pattern(expr)\n                setattr(cls.file_filter, ""parser"", cls)\n\n    pass # end of class'"
pyxrd/file_parsers/csv_base_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport csv\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom .ascii_parser import ASCIIParser\n\nclass CSVBaseParser(ASCIIParser):\n    """"""\n        CSV parser base functionality\n    """"""\n\n    default_fmt_params = {\n        ""delimiter"": \',\',\n        ""doublequote"": True,\n        ""escapechar"": None,\n        ""quotechar"": ""\\"""",\n        ""quoting"": csv.QUOTE_MINIMAL,\n        ""skipinitialspace"": True,\n        ""strict"": False\n    }\n\n    @classmethod\n    def parse_raw_line(cls, line, conv, **fmt_params):\n        """""" Parses a single raw line (read as a string) """"""\n        fmt_params = dict(cls.default_fmt_params, **fmt_params)\n        for row in csv.reader([line, ], **fmt_params):\n            return list(map(conv, row))\n            break # stop after first \'line\' (there should only be one anyway)\n\n    @classmethod\n    def sniff(cls, f, **fmt_params):\n        """""" CSV Dialect guessing - f needs to be a file object! """"""\n        # Guess dialect, and then:\n        # - update default class dialect parameters with the sniffed dialect\n        # - override the obtained dialect with any user-passed parameters\n        dialect = None\n        has_header = True\n        file_start = 0\n        if f is not None:\n            f.seek(file_start)\n            while True:\n                file_start = f.tell()\n                line = f.readline()\n                if not line: break\n                if not line.strip().startswith(""#""): \n                    break # first non-comment line, assume no more comments after this\n            try:\n                sniffer = csv.Sniffer()\n                f.seek(file_start)\n                has_header = sniffer.has_header(f.read(1024))\n                f.seek(file_start)\n                f.readline() # skip (potential) header as these are sometimes formatted differently\n                dialect = sniffer.sniff(f.read(1024))\n                f.seek(file_start)\n            except:\n                logger.warning(""Errors encountered while sniffing CSV dialect!"")\n                pass # ignore failures\n        default_fmt_params = dict(cls.default_fmt_params, **{\n            param: getattr(dialect, param) for param in list(cls.default_fmt_params.keys()) if hasattr(dialect, param)\n        })\n        return dict(default_fmt_params, **fmt_params), has_header, file_start\n\n    pass # end of class\n'"
pyxrd/file_parsers/data_object.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass DataObject(object):\n    """"""\n        A generic class holding all the information retrieved from a file\n        using a BaseParser class.\n    """"""\n\n    # general information\n    filename = None\n\n    def __init__(self, *args, **kwargs):\n        super(DataObject, self).__init__()\n        self.update(**kwargs)\n\n    def update(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    pass # end of class'"
pyxrd/file_parsers/json_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom distutils.version import LooseVersion\n\nimport json\nimport zipfile\nimport os, io\n\nfrom shutil import move\n\nfrom pyxrd.__version import __version__\n\nfrom pyxrd.file_parsers.base_parser import BaseParser\nfrom pyxrd.generic.io.json_codec import PyXRDDecoder, PyXRDEncoder\nfrom pyxrd.generic.io.custom_io import storables, COMPRESSION\n\nfrom pyxrd.generic.io.utils import unicode_open\n\nclass JSONParser(BaseParser):\n    """"""\n        PyXRD Object JSON Parser\n    """"""\n\n    description = ""PyXRD Object JSON""\n    mimetypes = [""application/octet-stream"", ""application/zip""]\n\n    __file_mode__ = ""r""\n\n    @classmethod\n    def _get_file(cls, fp, close=None):\n        """"""\n            Returns a three-tuple:\n            filename, zipfile-object, close\n        """"""\n        if isinstance(fp, str): # fp is a filename\n            filename = fp\n            if zipfile.is_zipfile(filename):\n                fp = zipfile.ZipFile(filename, cls.__file_mode__)\n            else:\n                fp = unicode_open(filename, cls.__file_mode__)\n            close = True if close is None else close\n        else: # fp is a file pointer\n            filename = getattr(fp, \'name\', None)\n            if zipfile.is_zipfile(fp):\n                fp = zipfile.ZipFile(fp)\n            close = False if close is None else close\n        return filename, fp, close\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        return data_objects # just pass it on, nothing to do\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=True):\n        # At this point filename is just there for information; fp can safely be\n        # assumed to be a file pointer - if not, not our problem\n        is_zipfile = isinstance(fp, zipfile.ZipFile)\n        if is_zipfile: # ZIP files\n                namelist = fp.namelist()\n                if \'content\' in namelist: # Multi-part object (e.g. project)\n                    obj = None\n                    decoder = json.JSONDecoder()\n\n                    def get_named_item(fpt, name):\n                        try:\n                            cf = fpt.open(name, cls.__file_mode__)\n                            obj = decoder.decode(cf.read().decode(""utf-8""))\n                        finally:\n                            cf.close()\n                        return obj\n                    \n                    # Parse the content file\n                    obj = get_named_item(fp, \'content\')\n                    \n                    # Check for a version tag:\n                    if \'version\' in namelist:\n                        namelist.remove(\'version\')\n                        version = get_named_item(fp, \'version\')\n                        if LooseVersion(version) > LooseVersion(__version__.replace(""v"", """")):\n                            raise RuntimeError(""Unsupported project"" + \\\n                                  ""version \'%s\', program version is \'%s\'"" % (\n                                version, __version__\n                            ))\n                    else:\n                        logging.warn(""Loading pre-v0.8 file format, "" +\n                                     ""might be deprecated!"")\n\n                    # Make sure we have a dict at this point\n                    if not hasattr(obj, ""update""):\n                        raise RuntimeError(""Decoding a multi-part JSON "" + \\\n                          ""object requires the root to be a dictionary object!"")\n\n                    # Parse all the other files, and set accordingly in the content dict\n                    for sub_name in namelist:\n                        if sub_name != ""content"":\n                            obj[""properties""][sub_name] = get_named_item(\n                                fp, sub_name)\n\n                    # Now parse the JSON dict to a Python object\n                    data_objects = PyXRDDecoder(mapper=storables).__pyxrd_decode__(obj) or obj\n                else: # Multiple objects in one zip file (e.g. phases)\n                    data_objects = []\n                    for sub_name in namelist:\n                        zpf = fp.open(sub_name, cls.__file_mode__)\n                        data_objects.append(cls.parse(zpf))\n                        zpf.close()\n        elif hasattr(fp, \'seek\'): # Regular file\n            try:\n                fp.seek(0) # reset file position\n            except io.UnsupportedOperation:\n                pass # ignore these\n            data_objects = PyXRDDecoder.decode_file(fp, mapper=storables)\n        else:\n            pass # use filename?\n\n        if close: fp.close()\n        return data_objects\n\n    @staticmethod\n    def write(obj, file, zipped=False): # @ReservedAssignment\n        """"""\n        Saves the output from dump_object() to `filename`, optionally zipping it.\n        File can be either a filename or a file-like object. If it is a filename\n        extra precautions are taken to prevent malformed data overwriting a good\n        file. With file objects this is not the case.\n        """"""\n        filename = None\n        if isinstance(file, str):\n            # We have a filename, not a file object\n            filename = file\n            # Create temporary filenames for output, and a backup filename if\n            # the file already exists.\n            file = filename + "".tmp"" # @ReservedAssignment\n            backup_name = filename + ""~""\n        try:\n            if zipped:\n                # Try to safe the file as a zipfile:\n                with zipfile.ZipFile(file, mode=""w"", compression=COMPRESSION) as f:\n                    for partname, json_object in obj.to_json_multi_part():\n                        f.writestr(partname, PyXRDEncoder.dump_object(json_object))\n            else:\n                # Regular text file:\n                if filename is not None:\n                    with unicode_open(file, \'w\') as f:\n                        PyXRDEncoder.dump_object_to_file(obj, f)\n                else:\n                    PyXRDEncoder.dump_object_to_file(obj, file)\n        except:\n            # In case saving fails, remove the temporary file:\n            if filename is not None and os.path.exists(file):\n                os.remove(file)\n            raise\n\n        if filename is not None:\n            # If target file exists, back it up:\n            if os.path.exists(filename):\n                move(filename, backup_name)\n            # Rename temporary saved file:\n            move(file, filename)\n\n    pass # end of class\n'"
pyxrd/file_parsers/meta_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass MetaParser(type):\n    """"""\n        Metatype for the parser sub classes, allowing for auto file filter\n        creation.\n    """"""\n    def __new__(meta, name, bases, attrs): # @NoSelf\n        res = super(MetaParser, meta).__new__(meta, name, bases, attrs)\n        res.setup_file_filter()\n        return res'"
pyxrd/file_parsers/registry.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base_group_parser import BaseGroupBarser\n\nclass ParserNamespace(object):\n    """"""\n        ParserNamespace instances can be used to register parsers and bundle\n        them for easier retrieval of file filters etc.\n    """"""\n\n    def __init__(self, name, group_description=""All supported files""):\n        self._parsers = []\n        self.name = name\n        self.group_description = group_description\n\n    def register_parser(self, first=False):\n        """""" \n            Register a parsers to this namespace\n        """"""\n        def wrapped_register(cls):\n            if first:\n                self._parsers.insert(0, cls)\n            else:\n                self._parsers.append(cls)\n            self._update_group_parser()\n            return cls\n        return wrapped_register\n\n    def get_file_filters(self):\n        """""" \n            Returns all the file filter object for the parsers registered in \n            this namespace \n        """"""\n        for parser in [self._group_parser, ] + self._parsers:\n            yield parser.file_filter\n\n    def get_export_file_filters(self):\n        for parser in self._parsers:\n            if parser.can_write:\n                yield parser.file_filter\n\n    def get_import_file_filters(self):\n        for parser in [self._group_parser, ] + self._parsers:\n            if parser.can_read:\n                yield parser.file_filter\n\n    def _update_group_parser(self):\n        """"""\n            Factory function for creating BaseGroupParser sub-classes,\n            using the namespace\'s name as the class name and the list of parser\n            classes as arguments.\n        """"""\n        self._group_parser = type(self.name, (BaseGroupBarser,), dict(\n             description=self.group_description,\n             parsers=self._parsers\n        ))\n\n    pass #end of class\n'"
pyxrd/file_parsers/xml_parser_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\ntry:\n    from lxml import ET\nexcept ImportError:\n    try:\n        # Python 2.5\n        import xml.etree.cElementTree as ET\n    except ImportError:\n        try:\n            # Python 2.5\n            import xml.etree.ElementTree as ET\n        except ImportError:\n            try:\n                # normal cElementTree install\n                import cElementTree as ET\n            except ImportError:\n                try:\n                    # normal ElementTree install\n                    import elementtree.ElementTree as ET\n                except ImportError:\n                    print(""Failed to import ElementTree from any known place"") \n\nclass XMLParserMixin(object):\n    """"""\n        XML Parser Mixin class\n    """"""\n\n    @classmethod\n    def get_xml_for_string(cls, s):\n        """""" Returns a tuple containing the XML tree and root objects """"""\n        root = ET.fromstring(s)\n        return ET.ElementTree(element=root), root\n\n    @classmethod\n    def get_xml_for_file(cls, f):\n        """""" Returns a tuple containing the XML tree and root objects """"""\n        tree = ET.parse(f)\n        return tree, tree.getroot()\n\n    @classmethod\n    def get_val(cls, root, path, attrib, default=None):\n        """""" Returns the attribute `attrib` from the first element found in\n        `root` using the given `path`or default if not found """"""\n        element = root.find(path)\n        if element is not None:\n            return element.get(attrib)\n        else:\n            return default\n\n    pass #end of class\n'"
pyxrd/generic/__init__.py,0,b''
pyxrd/generic/exceptions.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass AlreadyRegistered(Exception):\n    pass\n    \nclass NotRegistered(Exception):\n    pass\n'"
pyxrd/generic/mathtext_support.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport re\nfrom fractions import Fraction\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, Gdk, GdkPixbuf\n\ntry:\n    gi.require_foreign(""cairo"")\nexcept ImportError as orig:\n    try:\n        import cairocffi as cairo\n    except ImportError as snd:\n        logger.error(""No cairo integration :("")\n        raise snd from orig \n\nfrom matplotlib import rcParams\nimport matplotlib.mathtext as mathtext\n\npbmt_cache = dict() # maybe use a weak ref dict or a slowly GC-ed one?\ndisplay = Gdk.Display.get_default()  # @UndefinedVariable\nscreen = display.get_default_screen()\ndpi = screen.get_resolution() or 96\n\ndef create_pb_from_mathtext(text, align=\'center\', weight=\'heavy\', color=\'b\', style=\'normal\'):\n    """"""\n        Create a Gdk.Pixbuf from a mathtext string\n    """"""\n    \n    global pbmt_cache\n    global dpi\n    if not text in pbmt_cache:\n\n        parts, fontsize = _handle_customs(text)\n\n        pbs = []\n        width = 0\n        height = 0\n        # heights = []\n\n        # Temporarily set font properties:\n        old_params = rcParams[""font.weight""], rcParams[""text.color""], rcParams[""font.style""]\n        rcParams[""font.weight""] = weight\n        rcParams[""text.color""] = color\n        rcParams[""font.style""] = style\n        \n        # Create parser and load png fragments\n        parser = mathtext.MathTextParser(""Bitmap"")\n        for part in parts:\n            png_loader = GdkPixbuf.PixbufLoader.new_with_type(\'png\')  # @UndefinedVariable\n            parser.to_png(png_loader, part, dpi=dpi, fontsize=fontsize)\n            png_loader.close()\n            pb = png_loader.get_pixbuf()\n            w, h = pb.get_width(), pb.get_height()\n            width = max(width, w)\n            height += h\n            pbs.append((pb, w, h))\n        # Restore font properties\n        rcParams[""font.weight""], rcParams[""text.color""], rcParams[""font.style""] = old_params\n\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        cr = cairo.Context(surface)\n\n        cr.save()\n        cr.set_operator(cairo.OPERATOR_CLEAR)\n        cr.paint()\n        cr.restore()\n\n        cr.save()\n        offsetx = 0\n        offsety = 0\n        for pb, w, h in pbs:\n            if align == \'center\':\n                offsetx = int((width - w) / 2)\n            if align == \'left\':\n                offsetx = 0\n            if align == \'right\':\n                offsetx = int(width - w)\n            Gdk.cairo_set_source_pixbuf(cr, pb, offsetx, offsety)\n            cr.rectangle(offsetx, offsety, w, h)\n            cr.paint()\n            offsety += h\n        del pbs\n        cr.restore()\n\n        pbmt_cache[text] = Gdk.pixbuf_get_from_surface(surface, 0, 0, width, height)\n        \n    return pbmt_cache[text]\n\ndef create_image_from_mathtext(text, align=\'center\', weight=\'heavy\', color=\'b\', style=\'normal\'):\n    """"""\n        Create a Gtk.Image widget from a mathtext string\n    """"""\n    \n    image = Gtk.Image()\n    image.set_from_pixbuf(create_pb_from_mathtext(text, align=align))\n    return image\n\n###############################\n# Some convenience functions: #\n###############################\ndef _handle_customs(text):\n    text = text.decode(\'utf-8\')\n\n    if r""\\larger"" in text:\n        fontsize = 20\n    elif r""\\large"" in text:\n        fontsize = 15\n    else:\n        fontsize = 10\n\n    replacers = [\n        (r""\xc2\xb2"", r""$^{2}$""),\n        (r""\xc2\xb3"", r""$^{3}$""),\n        (r""\xce\xb1"", r""$\\alpha$""),\n        (r""\xce\xb2"", r""$\\beta$""),\n        (r""\xce\xb3"", r""$\\gamma$""),\n        (r""\xce\xb4"", r""$\\delta$""),\n        (r""\xce\xb3"", r""$\\digamma$""),\n        (r""\xce\xb7"", r""$\\eta$""),\n        (r""\xce\xb9"", r""$\\iota$""),\n        (r""\xce\xba"", r""$\\kappa$""),\n        (r""\xce\xbb"", r""$\\lambda$""),\n        (r""\xce\xbc"", r""$\\mu$""),\n        (r""\xcf\x89"", r""$\\omega$""),\n        (r""\xcf\x86"", r""$\\phi$""),\n        (r""\xcf\x80"", r""$\\pi$""),\n        (r""\xcf\x88"", r""$\\psi$""),\n        (r""\xcf\x81"", r""$\\rho$""),\n        (r""\xcf\x83"", r""$\\sigma$""),\n        (r""\xcf\x84"", r""$\\tau$""),\n        (r""\xce\xb8"", r""$\\theta$""),\n        (r""\xcf\x85"", r""$\\upsilon$""),\n        (r""\xce\xbe"", r""$\\xi$""),\n        (r""\xce\xb6"", r""$\\zeta$""),\n        (r""\\larger"", r""""),\n        (r""\\large"", r""""),\n        (r""\\newline"", r""$\\newline$""),\n    ]\n    for val, rep in replacers:\n        text = text.replace(val, rep)\n\n    parts = text.replace(""$$"", """").split(r""\\newline"")\n    while ""$$"" in parts: parts.remove(""$$"")\n    return parts, fontsize\n\ndef mt_frac(val):\n    val = Fraction(val).limit_denominator()\n    if val.denominator > 1:\n        return r""\\frac{%d}{%d}"" % (val.numerator, val.denominator)\n    else:\n        return r""%d"" % val.numerator\n\ndef mt_range(lower, name, upper):\n    return r""\\left({ %s \\leq %s \\leq %s }\\right)"" % (mt_frac(lower), name, mt_frac(upper))\n\ndef get_plot_safe(expression):\n    return r"""".join(_handle_customs(expression)[0])\n\ndef get_string_safe(expression):\n\n    replacers = [\n        (r""$"", r""""),\n        (r""\\larger"", r""""),\n        (r""\\left"", r""""),\n        (r""\\right"", r""""),\n        (r""\\leq"", r""\xe2\x89\xa4""),\n        (r""\\geq"", r""\xe2\x89\xa5""),\n        (r""\\large"", r""""),\n        (r""\\newline"", ""\\n""),\n    ]\n    for val, rep in replacers:\n        expression = expression.replace(val, rep)\n\n    regex_replacers = [\n        (r""\\\\sum_\\{(\\S+)\\}\\^\\{(\\S+)\\}"", r""\xce\xa3(\\1->\\2)""),\n        (r""(\\S+)_(?:\\{(\\S+)\\})"", r""\\1\\2""),\n        (r""(\\S+)_(\\S+)"", r""\\1\\2""),\n        (r""\\\\frac\\{([^}])\\}\\{([^}])\\}"", r""\\1\\\\\\2""), # single characters\n        (r""\\\\frac\\{(.+)\\}\\{(.+)\\}"", r""(\\1)\\\\(\\2)""), # multi charachters\n        (r""\\(\\{([^})]+)\\}\\)"", r""(\\1)"")\n    ]\n    for regexpr, sub in regex_replacers:\n        pattern = re.compile(regexpr)\n        expression = pattern.sub(sub, expression)\n\n    return expression'"
pyxrd/generic/utils.py,0,"b""# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport time\n\nfrom mvc.support.utils import not_none  # @UnusedImport but keep it as an alias\n\ndef u(string):\n    if isinstance(string, bytes):\n        return string.decode(errors='replace')\n    else:\n        return string\n\ndef print_timing(func):\n    def wrapper(*args, **kwargs):\n        t1 = time.time()\n        res = func(*args, **kwargs)\n        t2 = time.time()\n        print('%s took %0.3f ms' % (func.__name__, (t2 - t1) * 1000.0))\n        return res\n    return wrapper"""
pyxrd/goniometer/__init__.py,0,b''
pyxrd/goniometer/controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, locale\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.adapters.gtk_support.treemodels.utils import create_treestore_from_directory\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.views.cell_renderer_tools import get_default_renderer\nfrom pyxrd.file_parsers.wld_parsers import wld_parsers\nfrom pyxrd.file_parsers.goniometer_parsers import goniometer_parsers\n\nfrom pyxrd.data import settings\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.controllers.dialog_controller import DialogController\nfrom pyxrd.generic.controllers.objectliststore_controllers import TreeViewMixin\n\nfrom pyxrd.generic.views.treeview_tools import setup_treeview, new_text_column\n\nfrom pyxrd.goniometer.views import WavelengthDistributionView\n\nclass InlineGoniometerController(BaseController):\n    """"""\n        Goniometer controller. Is not expected to be used with a dialog view,\n        but rather in another view. \n    """"""\n\n    auto_adapt_excluded = [ \'wavelength_distribution\', ]\n\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def register_view(self, view):\n        self.generate_import_combo()\n        \n        self.wld_view = WavelengthDistributionView()\n        self.wld_ctrl = WavelengthDistributionController(model=self.model, view=self.wld_view, parent=self)\n        \n        self.update_soller_sensitivity()\n        self.update_divergence_label()\n        self.update_absorption_sensitivity()     \n\n    def update_soller_sensitivity(self):\n        self.view[""gonio_soller1_spb""].set_sensitive(self.model.has_soller1)\n        self.view[""gonio_soller2_spb""].set_sensitive(self.model.has_soller2)\n\n    def update_divergence_label(self):\n        if self.model.divergence_mode == ""AUTOMATIC"":\n            self.view[""unit_divergence_lbl""].set_markup(""<i>[mm]</i>"")\n        elif self.model.divergence_mode == ""FIXED"":\n            self.view[""unit_divergence_lbl""].set_markup(""<i>[\xc2\xb0]</i>"")\n\n    def update_absorption_sensitivity(self):\n        self.view[""sample_surf_density_spb""].set_sensitive(self.model.has_absorption_correction)\n        self.view[""absorption_spb""].set_sensitive(self.model.has_absorption_correction)\n\n    def generate_import_combo(self):\n        # TODO seperate this more the gtk level...\n        self.view.import_combo_box.clear()\n        \n        path = settings.DATA_REG.get_directory_path(""DEFAULT_GONIOS"")\n        cmb_model = create_treestore_from_directory(path)\n        self.view.import_combo_box.set_model(cmb_model)\n        cell = get_default_renderer(\'text\')\n        self.view.import_combo_box.pack_start(cell, True)\n        self.view.import_combo_box.add_attribute(cell, \'text\', 0)\n        self.view.import_combo_box.add_attribute(cell, \'sensitive\', 2)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_export_gonio_clicked(self, widget, *args):\n        def on_accept(dialog):\n            dialog.parser.write(self.model, dialog.filename)\n            self.generate_import_combo()\n        DialogFactory.get_save_dialog(\n            title=""Select the goniometer setup file to save to"",\n            filters=goniometer_parsers.get_export_file_filters(),\n            current_folder=settings.DATA_REG.get_directory_path(""DEFAULT_GONIOS""),\n            parent=self.view.parent.get_top_widget()\n        ).run(on_accept)\n\n    def on_cmb_import_gonio_changed(self, combobox, *args):\n        model = combobox.get_model()\n        itr = combobox.get_active_iter()\n        if itr:\n            # first column is the name, second column the path and third column\n            # a flag indicating if this can be selected\n            path = model.get_value(itr, 1)\n            if path:\n                def on_accept(dialog):\n                    self.model.reset_from_file(path)\n                DialogFactory.get_confirmation_dialog(\n                    ""Are you sure?\\nYou will loose the current settings!"",\n                    parent=self.view.get_toplevel()\n                ).run(on_accept)\n        combobox.set_active(-1) # deselect\n\n    def on_btn_edit_wld_clicked(self, widget, *args):\n        self.wld_view.show_all()\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @BaseController.observe(""has_soller1"", assign=True, after=True)\n    def notif_has_soller1(self, model, prop_name, info):\n        self.update_soller_sensitivity()\n\n    @BaseController.observe(""has_soller2"", assign=True, after=True)\n    def notif_has_soller2(self, model, prop_name, info):\n        self.update_soller_sensitivity()\n    \n    @BaseController.observe(""divergence_mode"", assign=True, after=True)\n    def notif_divergence(self, model, prop_name, info):\n        self.update_divergence_label()\n        \n    @BaseController.observe(""has_absorption_correction"", assign=True, after=True)\n    def notif_absorption(self, model, prop_name, info):\n        self.update_absorption_sensitivity()\n\n    pass # end of class\n\nclass WavelengthDistributionController(DialogController, TreeViewMixin):\n    """"""\n        Wavelength distribution controller.\n    """"""\n    \n    auto_adapt_included = [ ""wavelength_distribution"", ]\n \n    widget_handlers = {\n        \'custom\':  \'custom_handler\',\n    }\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    @staticmethod\n    def custom_handler(self, intel, widget):\n        print(""CUSTOM HANDLER CALLED FOR %s"" % intel.name)\n \n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def setup_wavelength_distribution_tree_view(self, store, widget):\n        """"""\n            Creates the wavelength distribution TreeView layout and behavior\n        """"""      \n        setup_treeview(widget, store,\n            on_cursor_changed=self.on_wld_tv_cursor_changed,\n            sel_mode=\'MULTIPLE\')\n        widget.set_model(store)\n        \n        def data_func(col, cell, model, iter, colnr):\n            cell.set_property(""text"", ""%g"" % model.get(iter, colnr)[0])\n            \n        # X Column:\n        widget.append_column(new_text_column(\n            \'Wavelength (nm)\', text_col=store.c_x, editable=True,\n            data_func = (data_func, (store.c_x,)),\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.wavelength_distribution, 0))))\n        # Y Column:\n        widget.append_column(new_text_column(\n            \'Fraction\', text_col=store.c_y, editable=True,\n            data_func = (data_func, (store.c_y,)),\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.wavelength_distribution, 1))))   \n         \n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_xy_data_cell_edited(self, cell, path, new_text, model, col):\n        try:\n            value = float(locale.atof(new_text))\n        except ValueError:\n            logger.exception(""ValueError: Invalid literal for float(): \'%s\'"" % new_text)\n        else:\n            model.set_value(int(path), col, value)\n        return True\n        \n    def on_wld_tv_cursor_changed(self, tv):\n        path, col = tv.get_cursor()  # @UnusedVariable\n        self.view[""btn_del_wavelength_distribution""].set_sensitive(path is not None)\n        return True\n    \n    def on_add_wavelength_distribution_clicked(self, widget):\n        self.model.wavelength_distribution.append(0, 0)\n        return True\n    \n    def on_del_wavelength_distribution_clicked(self, widget):\n        paths = self.get_selected_paths(self.view[""wld_wavelength_distribution""])\n        if paths is not None:\n            self.model.wavelength_distribution.remove_from_indeces(*paths)\n        return True\n    \n    def on_import_wavelength_distribution_clicked(self, widget, data=None):\n        def on_confirm(dialog):\n            def on_accept(dialog):\n                filename = dialog.filename\n                parser = dialog.parser\n                message = ""An unexpected error has occurred when trying to parse %s:\\n\\n<i>"" % os.path.basename(filename)\n                message += ""{}</i>\\n\\n""\n                message += ""This is most likely caused by an invalid or unsupported file format.""\n\n                with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                    self.model.wavelength_distribution.load_data(parser, filename, clear=True)\n            DialogFactory.get_load_dialog(\n                title=""Import wavelength distribution"", parent=self.view.get_top_widget(),\n                filters=wld_parsers.get_import_file_filters(),\n                current_folder=settings.DATA_REG.get_directory_path(""DEFAULT_WL_DISTR"")\n            ).run(on_accept)\n        DialogFactory.get_confirmation_dialog(\n            ""Importing a wavelength distribution will erase all current data.\\nAre you sure you want to continue?"",\n            parent=self.view.get_top_widget()\n        ).run(on_confirm)\n    \n    def on_export_wavelength_distribution_clicked(self, widget, data=None):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            message = ""An unexpected error has occurred when trying to save \'%s\'.\\n"" % os.path.basename(filename)\n            message += ""Contact the developer about this!""\n            with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                header = ""%s, %s"" % (""Wavelength"", ""Factor"")\n                self.model.wavelength_distribution.save_data(parser, filename, header=header)\n        DialogFactory.get_save_dialog(\n            ""Select file for wavelength distribution export"",\n            parent=self.view.get_top_widget(), \n            filters=wld_parsers.get_export_file_filters(),\n            current_folder=settings.DATA_REG.get_directory_path(""DEFAULT_WL_DISTR"")\n        ).run(on_accept)\n    \n    pass # end of class\n'"
pyxrd/goniometer/models.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom math import radians\nimport numpy as np\n\nfrom mvc.models.properties import (\n    LabeledProperty, FloatProperty, IntegerProperty, BoolProperty, StringChoiceProperty,\n    SignalMixin, ReadOnlyMixin, ObserveMixin\n)\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.refinement.refinables.properties import DataMixin\n\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.models.lines import StorableXYData\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\nfrom pyxrd.calculations.goniometer import (\n    get_lorentz_polarisation_factor,\n    get_fixed_to_ads_correction_range,\n    get_nm_from_2t, get_nm_from_t,\n    get_2t_from_nm, get_t_from_nm,\n)\nfrom pyxrd.calculations.data_objects import GonioData \n\n\n@storables.register()\nclass Goniometer(DataModel, Storable):\n    """"""\n    The Goniometer class contains all the information related to the\n    X-ray diffraction goniometer, e.g. wavelength, radius, slit sizes, ...\n    """"""\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Goniometer""\n\n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object.wavelength = self.wavelength\n        x, y = self.wavelength_distribution.get_xy_data()\n        self._data_object.wavelength_distribution = list(zip(x.tolist(), y.tolist()))\n        return self._data_object\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: Start angle (in \xc2\xb02-theta, only  used when calculating without\n    #: experimental data)\n    min_2theta = FloatProperty(\n        default=3.0, text=""Start angle"", minimum=0.0, maximum=180.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",  widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: End angle (in \xc2\xb02-theta, only  used when calculating without\n    #: experimental data)\n    max_2theta = FloatProperty(\n        default=3.0, text=""End angle"", minimum=0.0, maximum=180.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",  widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The number of steps between start and end angle\n    steps = IntegerProperty(\n        default=2500, text=""Steps"", minimum=0, maximum=10000,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",  widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The wavelength distribution\n    wavelength_distribution = LabeledProperty(\n        default=None, text=""Wavelength distribution"",\n        tabular=False, persistent=True, visible=True, \n        signal_name=""data_changed"", widget_type=""xy_list_view"",\n        mix_with=(SignalMixin, ObserveMixin)\n    )\n\n    @FloatProperty(\n        default=0.154056, text=""Wavelength"",\n        tabular=True, persistent=False, visible=False,\n        signal_name=""data_changed"",\n        mix_with=(ReadOnlyMixin,)\n    )\n    def wavelength(self):\n        """"""The wavelength of the generated X-rays (in nm)""""""\n        # Get the dominant wavelength in the distribution:\n        x, y = self.wavelength_distribution.get_xy_data()\n        wl = float(x[np.argmax(y)])\n        return wl\n\n    #: Flag indicating if the first soller slit is present or not\n    has_soller1 = BoolProperty(\n        default=True, text=""Soller 1"",\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The first Soller slit size (in \xc2\xb0)\n    soller1 = FloatProperty(\n        default=2.3, text=""Soller 1"", minimum=0.0, maximum=10.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: Flag indicating if the second soller slit is present or not\n    has_soller2 = BoolProperty(\n        default=True, text=""Soller 2"",\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The second Soller slit size (in \xc2\xb0)\n    soller2 = FloatProperty(\n        default=2.3, text=""Soller 2"", minimum=0.0, maximum=10.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The radius of the goniometer (in cm)\n    radius = FloatProperty(\n        default=24.0, text=""Radius"", minimum=0.0, maximum=200.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The divergence slit mode of the goniometer\n    divergence_mode = StringChoiceProperty(\n        default=settings.DEFAULT_DIVERGENCE_MODE, text=""Divergence mode"",\n        visible=True, persistent=True, choices=settings.DIVERGENCE_MODES,\n        signal_name=""data_changed"",\n        mix_with=(DataMixin, SignalMixin,)\n    )\n\n    #: The divergence slit size (if fixed) or irradiated sample length (if automatic)\n    divergence = FloatProperty(\n        default=0.5, text=""Divergence"", minimum=0.0, maximum=90.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: Flag indicating if the second soller slit is present or not\n    has_absorption_correction = BoolProperty(\n        default=False, text=""Absorption correction"",\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The actual sample length\n    sample_length = FloatProperty(\n        default=1.25, text=""Sample length [cm]"", minimum=0.0,\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n    \n    #: The sample surface density\n    sample_surf_density = FloatProperty(\n        default=20.0, text=""Sample surface density [mg/cm\xc2\xb2]"", minimum=0.0,\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n\n    #: The sample mass absorption coefficient\n    absorption = FloatProperty(\n        default=45.0, text=""Mass attenuation coeff. [cm\xc2\xb2/g]"", minimum=0.0,\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin)\n    )\n    \n    #: Angular value (in degrees) for a monochromator correction - use 28.44 for silicon and 26.53 for carbon.\n    mcr_2theta = FloatProperty(\n        default=0.0, text=""Monochromator 2\xce\xb8"", minimum=0.0, maximum=90.0,\n        tabular=True, persistent=True, visible=True,\n        signal_name=""data_changed"", widget_type=""spin"",\n        mix_with=(DataMixin, SignalMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Constructor takes any of its properties as a keyword argument.\n            \n            In addition to the above, the constructor still supports the \n            following deprecated keywords, mapping to a current keyword:\n                - lambda: maps to wavelength\n                \n            Any other arguments or keywords are passed to the base class.\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_radius"", ""data_divergence"", ""data_soller1"", ""data_soller2"",\n            ""data_min_2theta"", ""data_max_2theta"", ""data_lambda"", ""lambda"",\n            ""wavelength"", ""has_ads"", ""ads_fact"", ""ads_phase_fact"", ""ads_phase_shift"",\n            ""ads_const"",\n            *[prop.label for prop in Goniometer.Meta.get_local_persistent_properties()]\n        )\n        super(Goniometer, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self._data_object = GonioData()\n\n        with self.data_changed.hold():\n            self.radius = self.get_kwarg(kwargs, 24.0, ""radius"", ""data_radius"")\n            \n            #: Parse divergence mode (including old-style keywords):\n            new_div_mode = self.get_kwarg(kwargs, None, ""divergence_mode"")\n            if new_div_mode is None: # old style project\n                old_ads = self.get_kwarg(kwargs, None, ""has_ads"")\n                if old_ads is not None and old_ads: # if we have ads, set as such:\n                    new_div_mode = ""AUTOMATIC""\n                else: # otherwise it was angular fixed slits\n                    new_div_mode = settings.DEFAULT_DIVERGENCE_MODE\n            self.divergence_mode = new_div_mode\n\n            # Divergence value:                \n            self.divergence = self.get_kwarg(kwargs, 0.5, ""divergence"", ""data_divergence"")\n\n            # Monochromator correction:\n            self.mcr_2theta = float(self.get_kwarg(kwargs, 0, ""mcr_2theta""))\n\n            # Soller slits:\n            self.has_soller1 = self.get_kwarg(kwargs, True, ""has_soller1"")\n            self.soller1 = float(self.get_kwarg(kwargs, 2.3, ""soller1"", ""data_soller1""))\n            self.has_soller2 = self.get_kwarg(kwargs, True, ""has_soller2"")\n            self.soller2 = float(self.get_kwarg(kwargs, 2.3, ""soller2"", ""data_soller2""))\n\n            # Angular range settings for calculated patterns:\n            self.min_2theta = float(self.get_kwarg(kwargs, 3.0, ""min_2theta"", ""data_min_2theta""))\n            self.max_2theta = float(self.get_kwarg(kwargs, 45.0, ""max_2theta"", ""data_max_2theta""))\n            self.steps = int(self.get_kwarg(kwargs, 2500, ""steps""))\n\n            # Sample characteristics\n            self.sample_length = float(self.get_kwarg(kwargs, settings.DEFAULT_SAMPLE_LENGTH, ""sample_length""))\n            self.absorption = float(self.get_kwarg(kwargs, 45.0, ""absorption""))\n            self.sample_surf_density = float(self.get_kwarg(kwargs, 20.0, ""sample_surf_density""))\n            self.has_absorption_correction = bool(self.get_kwarg(kwargs, False, ""has_absorption_correction""))\n                       \n            wavelength = self.get_kwarg(kwargs, None, ""wavelength"", ""data_lambda"", ""lambda"")\n            if not ""wavelength_distribution"" in kwargs and wavelength is not None:\n                default_wld = [ [wavelength,1.0], ]\n            else:\n                # A Cu wld:\n                default_wld = [\n                    [0.1544426,0.955148885],\n                    [0.153475,0.044851115],\n                ]                \n            self.wavelength_distribution = StorableXYData(\n               data=self.get_kwarg(kwargs, list(zip(*default_wld)), ""wavelength_distribution"")\n            )           \n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def __reduce__(self):\n        return (type(self), ((), self.json_properties()))\n\n    def json_properties(self):\n        props = Storable.json_properties(self)\n        props[""wavelength_distribution""] = self.wavelength_distribution._serialize_data()\n        return props\n\n    def reset_from_file(self, gonfile):\n        """"""\n        Loads & sets the parameters from the goniometer JSON file\n        specified by `gonfile`, can be a filename or a file-like object.\n        """"""\n        new_gonio = JSONParser.parse(gonfile)\n        with self.data_changed.hold():\n            for prop in self.Meta.all_properties:\n                if prop.persistent:\n                    if prop.label == ""wavelength_distribution"":\n                        self.wavelength_distribution.clear()\n                        self.wavelength_distribution.set_data(\n                            *new_gonio.wavelength_distribution.get_xy_data())  \n                    elif prop.label != ""uuid"":\n                        setattr(self, prop.label, getattr(new_gonio, prop.label))\n                        \n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_nm_from_t(self, theta):\n        """"""Converts a theta position to a nanometer value""""""\n        return get_nm_from_t(\n            theta,\n            wavelength=self.wavelength, zero_for_inf=True\n        )\n\n    def get_nm_from_2t(self, twotheta):\n        """"""Converts a 2-theta position to a nanometer value""""""\n        return get_nm_from_2t(\n            twotheta,\n            wavelength=self.wavelength, zero_for_inf=True\n        )\n\n    def get_t_from_nm(self, nm):\n        """""" Converts a nanometer value to a theta position""""""\n        return get_t_from_nm(nm, wavelength=self.wavelength)\n\n    def get_2t_from_nm(self, nm):\n        """""" Converts a nanometer value to a 2-theta position""""""\n        return get_2t_from_nm(nm, wavelength=self.wavelength)\n\n    def get_default_theta_range(self, as_radians=True):\n        """"""\n        Returns a numpy array containing the theta values as radians from\n        `min_2theta` to `max_2theta` with `steps` controlling the interval.\n        When `as_radians` is set to False the values are returned as degrees. \n        """"""\n        def torad(val):\n            if as_radians:\n                return radians(val)\n            else:\n                return val\n        min_theta = torad(self.min_2theta * 0.5)\n        max_theta = torad(self.max_2theta * 0.5)\n        delta_theta = float(max_theta - min_theta) / float(self.steps)\n        theta_range = (min_theta + delta_theta * np.arange(0, self.steps, dtype=float)) + delta_theta * 0.5\n        return theta_range\n\n    def get_lorentz_polarisation_factor(self, range_theta, sigma_star):\n        """"""\n            Calculates Lorentz polarization factor for the given theta range\n            and sigma-star value using the information about the goniometer\'s\n            geometry.\n        """"""\n        return get_lorentz_polarisation_factor(\n            range_theta, sigma_star, self.soller1, self.soller2, self.mcr_2theta\n        )\n\n    def get_ADS_to_fixed_correction(self, range_theta):\n        """"""\n            Returns a correction range that will convert ADS data to fixed slit\n            data. Use with caution.\n        """"""\n        return 1.0 / get_fixed_to_ads_correction_range(range_theta, self.data_object)\n\n    pass # end of class\n'"
pyxrd/goniometer/views.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom pyxrd.generic.views import BaseView, DialogView\n\nclass InlineGoniometerView(BaseView):\n    """"""\n        The inline Goniometer view.\n    """"""\n\n    builder = resource_filename(__name__, ""glade/goniometer.glade"")\n    top = ""edit_goniometer""\n\n    widget_format = ""gonio_%s""\n\n    @property\n    def import_combo_box(self):\n        return self[""cmb_import_gonio""]\n\n    pass # end of class\n\n\nclass WavelengthDistributionView(DialogView):\n    """"""\n        The wavelength distribution view.\n    """"""   \n    subview_builder = resource_filename(__name__, ""glade/wavelength_distribution.glade"")\n    subview_toplevel = ""edit_wld""\n\n    widget_format = ""wld_%s""\n    \n    pass # end of class'"
pyxrd/mixture/__init__.py,0,b''
pyxrd/phases/__init__.py,0,b''
pyxrd/phases/views.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_gtk3cairo import FigureCanvasGTK3Cairo as FigureCanvasGTK\n\nfrom pyxrd.generic.views import BaseView, HasChildView, DialogView,\\\n    ObjectListStoreView\nfrom mvc.adapters.gtk_support.widgets import ScaleEntry\n\nclass EditPhaseView(HasChildView, BaseView):\n    title = ""Edit Phases""\n    builder = resource_filename(__name__, ""glade/phase.glade"")\n    top = ""edit_phase""\n    widget_format = ""phase_%s""\n\n    csds_view = None\n    csds_view_container = widget_format % ""CSDS_distribution""\n\n    probabilities_view = None\n    probabilities_view_container = widget_format % ""probabilities""\n\n    components_view = None\n    components_view_container = widget_format % ""components""\n\n    def set_csds_view(self, view):\n        self.csds_view = view\n        if view is not None:\n            self._add_child_view(view.get_top_widget(), self[self.csds_view_container])\n        return view\n\n    def set_csds_sensitive(self, sens):\n        self[self.csds_view_container].set_sensitive(sens)\n\n    def set_probabilities_view(self, view):\n        self.probabilities_view = view\n        if view is not None:\n            self._add_child_view(view.get_top_widget(), self[self.probabilities_view_container])\n        return view\n\n    def remove_probabilities(self):\n        num = self[""book_wrapper""].page_num(self[self.probabilities_view_container])\n        self[""book_wrapper""].remove_page(num)\n\n    def set_components_view(self, view):\n        self.components_view = view\n        if view is not None:\n            self._add_child_view(view.get_top_widget(), self[self.components_view_container])\n        return view\n\nclass EditRawPatternPhaseView(BaseView):\n    title = ""Edit Raw Pattern Phase""\n    builder = resource_filename(__name__, ""glade/raw_pattern_phase.glade"")\n    top = ""edit_raw_pattern_phase""\n    widget_format = ""rp_phase_%s""\n\nclass EditAtomRatioView(DialogView):\n    title = ""Edit Atom Ratio""\n    subview_builder = resource_filename(__name__, ""glade/ratio.glade"")\n    subview_toplevel = ""edit_ratio""\n    modal = True\n    widget_format = ""ratio_%s""\n\n    @property\n    def atom1_combo(self):\n        return self[""ratio_atom1""]\n\n    @property\n    def atom2_combo(self):\n        return self[""ratio_atom2""]\n\n    pass # end of class\n\nclass EditAtomContentsView(DialogView):\n    title = ""Edit Atom Contents""\n    subview_builder = resource_filename(__name__, ""glade/contents.glade"")\n    subview_toplevel = ""edit_contents""\n    modal = True\n    widget_format = ""contents_%s""\n\n    contents_list_view_container = ""atom_contents_container""\n\n    def set_contents_list_view(self, view):\n        self[self.widget_format % ""atom_contents""] = view\n        return self._add_child_view(view, self[self.contents_list_view_container])\n\n    @property\n    def atom_contents_container(self):\n        return self[""container_atom_contents""]\n\n    pass # end of class\n\nclass EditComponentView(HasChildView, BaseView):\n    title = ""Edit Component""\n    builder = resource_filename(__name__, ""glade/component.glade"")\n    top = ""edit_component""\n    widget_format = ""component_%s""\n\n    layer_view = None\n    layer_view_container = widget_format % ""layer_atoms""\n\n    interlayer_view = None\n    interlayer_view_container = widget_format % ""interlayer_atoms""\n\n    atom_relations_view = None\n    atom_relations_view_container = widget_format % ""atom_relations""\n\n    ucpa_view = None\n    ucpa_view_container = widget_format % ""ucp_a""\n\n    ucpb_view = None\n    ucpb_view_container = widget_format % ""ucp_b""\n\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n    def set_layer_view(self, view):\n        self.layer_view = view\n        return self._add_child_view(view, self[self.layer_view_container])\n\n    def set_atom_relations_view(self, view):\n        self.atom_relations_view = view\n        return self._add_child_view(view, self[self.atom_relations_view_container])\n\n    def set_interlayer_view(self, view):\n        self.interlayer_view = view\n        return self._add_child_view(view, self[self.interlayer_view_container])\n\n    def set_ucpa_view(self, view):\n        self.ucpa_view = view\n        return self._add_child_view(view, self[self.ucpa_view_container])\n\n    def set_ucpb_view(self, view):\n        self.ucpb_view = view\n        return self._add_child_view(view, self[self.ucpb_view_container])\n\nclass EditUnitCellPropertyView(BaseView):\n    builder = resource_filename(__name__, ""glade/unit_cell_prop.glade"")\n    top = ""box_ucf""\n    widget_format = ""ucp_%s""\n\nclass EditCSDSDistributionView(BaseView):\n    builder = resource_filename(__name__, ""glade/csds.glade"")\n    top = ""tbl_csds_distr""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.graph_parent = self[""distr_plot_box""]\n        self.setup_matplotlib_widget()\n\n    def setup_matplotlib_widget(self):\n        #style = Gtk.Style()\n        self.figure = Figure(dpi=72) #, edgecolor=str(style.bg[2]), facecolor=str(style.bg[2]))\n\n        self.plot = self.figure.add_subplot(111)\n        self.figure.subplots_adjust(bottom=0.20)\n\n        self.matlib_canvas = FigureCanvasGTK(self.figure)\n\n        self.plot.autoscale_view()\n\n        self.graph_parent.add(self.matlib_canvas)\n        self.graph_parent.show_all()\n\n    def update_figure(self, distr):\n        self.plot.cla()\n        self.plot.hist(list(range(len(distr))), len(distr), weights=distr, normed=1, ec=\'b\', histtype=\'stepfilled\')\n        self.plot.set_ylabel(\'\')\n        self.plot.set_xlabel(\'CSDS\', size=14, weight=""heavy"")\n        self.plot.relim()\n        self.plot.autoscale_view()\n        if self.matlib_canvas is not None:\n            self.matlib_canvas.draw()\n\n    def reset_params(self):\n        tbl = self[""tbl_params""]\n        for child in tbl.get_children():\n            tbl.remove(child)\n        tbl.resize(1, 2)\n\n    def add_param_widget(self, name, label, minimum, maximum):\n        tbl = self[""tbl_params""]\n        rows = tbl.get_property(""n-rows"") + 1\n        tbl.resize(rows, 2)\n\n        lbl = Gtk.Label(label=label)\n        lbl.set_alignment(1.0, 0.5)\n        tbl.attach(lbl, 0, 1, rows - 1, rows, Gtk.AttachOptions.FILL, Gtk.AttachOptions.FILL)\n\n        inp = ScaleEntry(minimum, maximum, enforce_range=True)\n        tbl.attach(inp, 1, 2, rows - 1, rows, Gtk.AttachOptions.FILL, Gtk.AttachOptions.FILL)\n\n        tbl.show_all()\n\n        self[name] = inp\n        inp.set_name(name)\n\n        return inp\n\nclass AddPhaseView(DialogView):\n    title = ""Add Phase""\n    subview_builder = resource_filename(__name__, ""glade/addphase.glade"")\n    subview_toplevel = ""add_phase_container""\n\n    active_type = ""empty"" # | default | raw\n\n    def __init__(self, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n\n    def get_G(self):\n        return int(self[""G""].get_value_as_int())\n\n    def get_R(self):\n        return int(self[""R""].get_value_as_int())\n\n    def get_phase_type(self):\n        if self.active_type == ""empty"":\n            return ""empty""\n        elif self.active_type == ""default"":\n            itr = self.phase_combo_box.get_active_iter()\n            val = self.phase_combo_box.get_model().get_value(itr, 1) if itr else None\n            return val\n        else:\n            return ""raw""\n\n    def update_sensitivities(self):\n        self[""cont_empty_phase""].set_sensitive(False)\n        self[""cont_default_phase""].set_sensitive(False)\n        if self[""rdb_empty_phase""].get_active():\n            self.active_type = ""empty""\n            self[""cont_empty_phase""].set_sensitive(True)\n        elif self[""rdb_default_phase""].get_active():\n            self.active_type = ""default""\n            self[""cont_default_phase""].set_sensitive(True)\n        else:\n            self.active_type = ""raw""\n\n    @property\n    def phase_combo_box(self):\n        return self[""cmb_default_phases""]\n\n    pass # end of class\n'"
pyxrd/probabilities/__init__.py,0,b''
pyxrd/probabilities/controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc import Controller\n\nfrom pyxrd.generic.controllers import BaseController\n\nfrom pyxrd.probabilities.views import get_correct_probability_views\nfrom pyxrd.probabilities.models import RGbounds\n\ndef get_correct_probability_controllers(probability, parent_controller, independents_view, dependents_view):\n    if probability is not None:\n        G = probability.G\n        R = probability.R\n        if (RGbounds[R, G - 1] > 0):\n            return BaseController(model=probability, parent=parent_controller, view=independents_view), \\\n                   MatrixController(current=R, model=probability, parent=parent_controller, view=dependents_view)\n        else:\n            raise ValueError(""Cannot (yet) handle R%d for %d layer structures!"" % (R, G))\n\nclass EditProbabilitiesController(BaseController):\n\n    independents_view = None\n    matrix_view = None\n    auto_adapt = False\n\n    def __init__(self, *args, **kwargs):\n        BaseController.__init__(self, *args, **kwargs)\n        self._init_views(kwargs[""view""])\n        self.update_views()\n\n    def _init_views(self, view):\n        self.independents_view, self.dependents_view = get_correct_probability_views(self.model, view)\n        self.independents_controller, self.dependents_controller = get_correct_probability_controllers(self.model, self, self.independents_view, self.dependents_view)\n        view.set_views(self.independents_view, self.dependents_view)\n\n    @BaseController.model.setter\n    def model(self, model):\n        if self.view is not None:\n            self.independents_controller.model = None # model\n            self.dependents_controller.model = None # model\n        super(EditProbabilitiesController, self)._set_model(model)\n        if self.view is not None:\n            self.independents_controller.model = model\n            self.dependents_controller.model = model\n            self.update_views()\n\n    def update_views(self): # needs to be called whenever an independent value changes\n        with self.model.data_changed.hold():\n            self.dependents_view.update_matrices(self.model)\n            self.independents_view.update_matrices(self.model)\n\n    def register_adapters(self):\n        return\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""data_changed"", signal=True)\n    def notif_updated(self, model, prop_name, info):\n        self.update_views()\n        return\n\n    pass # end of class\n\nclass MatrixController(BaseController):\n    auto_adapt = False\n\n    def __init__(self, current, *args, **kwargs):\n        BaseController.__init__(self, *args, **kwargs)\n        self.current_W = current\n        self.current_P = current\n\n    def register_adapters(self):\n        return\n\n    def on_w_prev_clicked(self, widget, *args):\n        self.current_W = self.view.show_w_matrix(self.current_W - 1)\n    def on_w_next_clicked(self, widget, *args):\n        self.current_W = self.view.show_w_matrix(self.current_W + 1)\n\n    def on_p_prev_clicked(self, widget, *args):\n        self.current_P = self.view.show_p_matrix(self.current_P - 1)\n    def on_p_next_clicked(self, widget, *args):\n        self.current_P = self.view.show_p_matrix(self.current_P + 1)\n\n    pass # end of class\n'"
pyxrd/probabilities/views.py,4,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom mvc.adapters.gtk_support.widgets import ScaleEntry\nfrom mvc.support.utils import rec_getattr\n\nfrom pyxrd.generic.views import BaseView, HasChildView\nfrom pyxrd.probabilities.models import RGbounds\n\ndef get_correct_probability_views(probability, parent_view):\n    """"""\n        Convenience function that creates both an `IndependentsView` and \n        `MatrixView` based on the probability model passed.\n    """"""\n    if probability is not None:\n        G = probability.G\n        R = probability.R\n        rank = probability.rank\n        if (RGbounds[R, G - 1] > 0):\n            return IndependentsView(meta=probability.Meta, parent=parent_view), MatrixView(R=R, G=G, rank=rank, parent=parent_view)\n        else:\n            raise ValueError(""Cannot (yet) handle R%d for %d layer structures!"" % (R, G))\n\nclass EditProbabilitiesView(HasChildView, BaseView):\n    """"""\n        Container view containing one `MatrixView` and one `IndependentsView`\n    """"""\n    builder = resource_filename(__name__, ""glade/probabilities.glade"")\n    top = ""edit_probabilities""\n\n    independents_container = ""independents_box""\n    independents_view = None\n    dependents_container = ""dependents_box""\n    dependents_view = None\n\n    widget_format = ""prob_%s""\n\n    def set_views(self, independents_view, dependents_view):\n        self.independents_view = independents_view\n        self._add_child_view(independents_view.get_top_widget(), self[self.independents_container])\n        self.dependents_view = dependents_view\n        self._add_child_view(dependents_view.get_top_widget(), self[self.dependents_container])\n        self.show_all()\n        return self.independents_view, self.dependents_view\n\nclass ProbabilityViewMixin():\n    """"""\n        Mixin class providing interface code for controllers\n        of both `MatrixView` and `IndependentsView`\n    """"""\n    def update_matrices(self, W, P):\n        raise NotImplementedError\n\nclass IndependentsView(HasChildView, ProbabilityViewMixin, BaseView):\n    """"""\n        Generic view that is able to generate an two-column list of inputs and \n        labels using the models Meta (passed to the constructor).\n    """"""\n    builder = resource_filename(__name__, ""glade/R0_independents.glade"")\n    top = ""R0independents_box""\n    # generated table of weight fractions! (split in two columns)\n\n    lbl_widget = ""lbl_independents""\n    sep_widget = ""seperator_i""\n\n    widget_format = ""prob_%s""\n\n    def __init__(self, meta, **kwargs):\n        assert (meta is not None), ""IndependentsView needs a model\'s Meta class!""\n        BaseView.__init__(self, **kwargs)\n\n        self.props = [ prop for prop in meta.all_properties if getattr(prop, ""is_independent"", False) ]\n        all_props = { prop.label: prop for prop in meta.all_properties }\n\n        N = len(self.props)\n\n        def create_inputs(table):\n            input_widgets = [None] * N\n            check_widgets = [None] * N\n\n\n            num_columns = 2\n            column_width = 3\n\n            for i, prop in enumerate(self.props):\n\n                new_lbl = self.create_mathtext_widget(prop.math_title, prop.label)\n\n                new_inp = ScaleEntry(lower=prop.minimum, upper=prop.maximum, enforce_range=True)\n                new_inp.set_tooltip_text(prop.title)\n                new_inp.set_name(self.widget_format % prop.label)\n                self[self.widget_format % prop.label] = new_inp\n                input_widgets[i] = new_inp\n\n                j = (i % num_columns) * column_width\n                table.attach(new_lbl, 0 + j, 1 + j, i / num_columns, (i / num_columns) + 1, xpadding=2, ypadding=2)\n                table.attach(new_inp, 2 + j, 3 + j, i / num_columns, (i / num_columns) + 1, xpadding=2, ypadding=2)\n\n                if prop.inheritable is not None:\n                    inh_prop = all_props.get(prop.inherit_flag, None)\n                    if inh_prop is None:\n                        raise ValueError(""The inherit flag property `%s` is missing for `%s` on meta model with store id `%s`"" % (\n                            prop.inherit_flag,\n                            prop.label,\n                            meta.store_id\n                        ))\n\n                    new_check = Gtk.CheckButton(label="""")\n                    new_check.set_tooltip_text(inh_prop.title)\n                    new_check.set_name(self.widget_format % inh_prop.label)\n                    new_check.set_sensitive(False)\n                    self[self.widget_format % inh_prop.label] = new_check\n                    check_widgets[i] = new_check\n                    table.attach(new_check, 1 + j, 2 + j, i / num_columns, (i / num_columns) + 1, xpadding=2, ypadding=2, xoptions=Gtk.AttachOptions.FILL)\n\n\n                del new_inp, new_lbl\n            return input_widgets, check_widgets\n        self.i_box = self[\'i_box\']\n\n        num_rows = int((N + 1) / 2)\n        if not num_rows == 0:\n            self.i_table = Gtk.Table(num_rows, 4, False)\n            self.i_inputs, self.i_checks = create_inputs(self.i_table)\n        else:\n            self.i_inputs, self.i_checks = [], []\n        if len(self.i_inputs) == 0:\n            self[self.lbl_widget].set_no_show_all(True)\n            self[self.sep_widget].set_no_show_all(True)\n            self[self.lbl_widget].hide()\n            self[self.sep_widget].hide()\n        else:\n            self._add_child_view(self.i_table, self.i_box)\n\n    def update_matrices(self, model):\n        for i, (inp, check) in enumerate(zip(self.i_inputs, self.i_checks)):\n            prop = self.props[i]\n            inp.set_value(getattr(model, prop.label))\n            if prop.inherit_flag is not None:\n                # Set checkbox sensitivity:\n                inh_from = rec_getattr(model, prop.inherit_flag, None)\n                check.set_sensitive(not inh_from is None)\n                # Set checkbox state:\n                inh_value = getattr(model, prop.inherit_flag)\n                check.set_active(inh_value)\n                # Set inherit value sensitivity\n                inp.set_sensitive(not inh_value)\n            elif check is not None:\n                check.set_senstive(False)\n\n    pass # end of class\n\nclass MatrixView(HasChildView, ProbabilityViewMixin, BaseView):\n    """"""\n        Generic view that is able to generate and update a P and W \'matrix\'\n        table with labels having correct tooltips (e.g. P110). Can be used for\n        any combination of R, G and rank.\n    """"""\n    builder = resource_filename(__name__, ""glade/matrix.glade"")\n    top = ""base_matrix_table""\n\n    def __init__(self, R, G, rank, **kwargs):\n        """"""\n            Eventhough only two of R,G and rank are required theoretically, \n            they are still required by the __init__ function as a validity\n            check.\n        """"""\n        BaseView.__init__(self, **kwargs)\n\n        # make sure valid params are passed:\n        assert(rank == (G ** max(R, 1)))\n        self.create_matrices(R, G, rank)\n\n    def create_matrices(self, R, G, rank):\n        # calculate moduli for parameter index calculation:\n        lR = max(R, 1)\n        mod = [0] * lR\n        for i in range(lR):\n            mod[i] = rank / (G ** (i + 1))\n        title_indeces = """".join([chr(105 + i) for i in range(lR + 1)])\n\n\n        # Generic function for both the W and P matrix labels setup\n        def create_labels(rank, table, current_lR, fmt, tooltip=lambda x, y, current_lR, fmt: """"):\n            labels = [[None] * rank for _ in range(rank)]\n            for x in range(rank):\n                for y in range(rank):\n                    new_lbl = Gtk.Label(label="""")\n                    new_lbl.set_tooltip_markup(tooltip(x, y, current_lR, fmt))\n                    new_lbl.set_justify(Gtk.Justification.CENTER)\n                    table.attach(new_lbl, y, y + 1, x, x + 1, xpadding=5, ypadding=5)\n                    labels[x][y] = new_lbl\n                    del new_lbl\n            return labels\n\n        # Generic functions for the tooltips:\n        def diagonal_tooltips(x, y, current_lR, fmt):\n            if x == y:\n                indeces = [0] * current_lR\n                for i in range(current_lR):\n                    indeces[i] = (int(x / mod[i + (lR - current_lR)]) % G) + 1\n                return fmt % tuple(indeces)\n            else:\n                return ""-""\n\n        def subdiagonal_tooltips(x, y, current_lR, fmt):\n            rowsuf = [0] * current_lR # e.g. i,j,k\n            colsuf = [0] * current_lR # e.g. l,m,n\n            for i in range(current_lR):\n                rowsuf[i] = (int(x / mod[i + (lR - current_lR)]) % G) + 1\n                colsuf[i] = (int(y / mod[i + (lR - current_lR)]) % G) + 1\n\n            # check if last n-1 and first n-1 of the suffices equal each other:\n            visible = True\n            for i in range(current_lR - 1):\n                if rowsuf[i + 1] != colsuf[i]: visible = False\n            if visible:\n                return fmt % (tuple(rowsuf) + (colsuf[-1],))\n            else:\n                return ""-""\n\n        # Create the matrices:\n\n        self.w_tables = []\n        self.w_labels = []\n        self.w_titles = []\n        self.w_valids = []\n\n        self.p_tables = []\n        self.p_labels = []\n        self.p_titles = []\n        self.p_valids = []\n\n        def setup_everything(tables, titles, valids, labels, title, rank, current_lR, lbl_fmt, tooltips):\n            w_table = Gtk.Table(rank, rank, True)\n            tables.append(w_table)\n            titles.append(title)\n            valids.append("""")\n            labels.append(create_labels(\n                rank, w_table,\n                current_lR, lbl_fmt,\n                tooltips\n            ))\n\n        for current_lR in range(1, lR + 1):\n            rank = G ** current_lR\n\n            setup_everything(\n                self.w_tables, self.w_titles, self.w_valids, self.w_labels,\n                ""<b>W<sub>"" + title_indeces[:current_lR] + ""</sub></b>"",\n                rank, current_lR,\n                ""W<sub>"" + ""%d""*current_lR + ""</sub>"",\n                diagonal_tooltips\n            )\n\n            setup_everything(\n                self.p_tables, self.p_titles, self.p_valids, self.p_labels,\n                ""<b>P<sub>"" + title_indeces[:current_lR + 1] + ""</sub></b>"",\n                rank, current_lR,\n                ""P<sub>"" + ""%d""*(current_lR + 1) + ""</sub>"",\n                subdiagonal_tooltips\n            )\n\n        # Add one extra W matrix:\n        setup_everything(\n            self.w_tables, self.w_titles, self.w_valids, self.w_labels,\n            ""<b>W<sub>"" + title_indeces + ""</sub></b>"",\n            G ** lR, lR,\n            ""W<sub>"" + ""%d""*(lR + 1) + ""</sub>"",\n            subdiagonal_tooltips\n        )\n\n        self.show_w_matrix(len(self.w_tables) - 2)\n        self.show_p_matrix(len(self.w_tables) - 1)\n\n        return\n\n    def update_matrices(self, model):\n        lW, lP = model.get_all_matrices()\n        def update_matrix(matrix, labels, mask=None, valid=False):\n            shape = matrix.shape\n            for i in range(shape[0]):\n                for j in range(shape[1]):\n                    markup = ""<small><span foreground=\\""%s\\"">%.3f</span></small>""\n                    if mask is not None:\n                        fgcol = ""#AA0000"" if mask[i, j] < 1 else ""#00AA00""\n                    else:\n                        fgcol = ""#000000""\n                    labels[i][j].set_markup(markup % (fgcol, matrix[i, j]))\n\n        for i, W in enumerate(lW):\n            update_matrix(W, self.w_labels[i], model.W_valid_mask[i])\n            fgcol, msg = (""#00AA00"", ""valid"") if model.W_valid[i] else (""#AA0000"", ""invalid"")\n            self.w_valids[i] = ""<small><span foreground=\\""%s\\"">%s</span></small>"" % (fgcol, msg)\n            self[""lbl_W_valid""].set_markup(self.w_valids[i])\n        for i, P in enumerate(lP):\n            update_matrix(P, self.p_labels[i], model.P_valid_mask[i])\n            fgcol, msg = (""#00AA00"", ""valid"") if model.P_valid[i] else (""#AA0000"", ""invalid"")\n            self.p_valids[i] = ""<small><span foreground=\\""%s\\"">%s</span></small>"" % (fgcol, msg)\n            self[""lbl_P_valid""].set_markup(self.p_valids[i])\n\n    def show_w_matrix(self, index):\n        index = max(min(index, len(self.w_tables) - 1), 0)\n        self._add_child_view(self.w_tables[index], self[\'w_box\'])\n        self[""lbl_W_title""].set_markup(self.w_titles[index])\n        self[""lbl_W_valid""].set_markup(self.w_valids[index])\n        self.show_all()\n        return index\n\n    def show_p_matrix(self, index):\n        index = max(min(index, len(self.p_tables) - 1), 0)\n        self._add_child_view(self.p_tables[index], self[\'p_box\'])\n        self[""lbl_P_title""].set_markup(self.p_titles[index])\n        self[""lbl_P_valid""].set_markup(self.w_valids[index])\n        self.show_all()\n        return index\n\n    pass # end of class\n\n'"
pyxrd/project/__init__.py,0,b''
pyxrd/project/controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport os\nfrom contextlib import contextmanager\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GObject, Pango, Gdk # @UnresolvedImport\n\nfrom mvc import Controller\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc.adapters.gtk_support.widgets.threaded_task_box import ThreadedTaskBox\nfrom mvc.support.cancellable_thread import CancellableThread\nfrom mvc.support.gui_loop import run_when_idle\n\nfrom pyxrd.generic.controllers.line_controllers import BackgroundController\nfrom pyxrd.generic.views.line_views import BackgroundView\nfrom pyxrd.generic.views.treeview_tools import new_text_column, new_toggle_column, new_pb_column\nfrom pyxrd.generic.controllers import BaseController, ObjectListStoreController\n\nfrom pyxrd.file_parsers.xrd_parsers import xrd_parsers\n\nfrom pyxrd.specimen.models import Specimen\n\n\n\nclass ProjectController(ObjectListStoreController):\n\n    treemodel_property_name = ""specimens""\n    treemodel_class_type = Specimen\n    columns = [ ]\n    delete_msg = ""Deleting a specimen is irreversible!\\nAre You sure you want to continue?""\n    auto_adapt = True\n\n    def register_view(self, view):\n        if view is not None and self.model is not None:\n            if self.parent is not None: # is this still needed?\n                tv = self.view[""project_specimens""]\n                tv.set_model(self.treemodel)\n                self.view.treeview = tv\n                self.view.set_x_range_sensitive(self.model.axes_xlimit == 1)\n                self.view.set_y_range_sensitive(self.model.axes_ylimit == 1)\n        return\n\n    def _idle_register_view(self, *args, **kwargs):\n        super(ProjectController, self)._idle_register_view(*args, **kwargs)\n\n    def adapt(self, *args, **kwargs):\n        super(ProjectController, self).adapt(*args, **kwargs)\n\n    def setup_treeview(self, widget):\n        super(ProjectController, self).setup_treeview(widget)\n        store = self.treemodel\n        widget.connect(\'button-press-event\', self.specimen_tv_button_press)\n\n        # First reset & then (re)create the columns of the treeview:\n        for col in widget.get_columns():\n            widget.remove_column(col)\n\n        # Name column:\n        col = new_text_column(\'Name\',\n            text_col=store.c_name,\n            min_width=125,\n            xalign=0.0,\n            ellipsize=Pango.EllipsizeMode.END)\n        setattr(col, ""colnr"", store.c_name)\n        widget.append_column(col)\n\n        # Check boxes:\n        def toggle_renderer(column, cell, model, itr, data=None):\n            active = False\n            if model.iter_is_valid(itr):\n                col = column.get_col_attr(""active"")\n                active = model.get_value(itr, col)\n            cell.set_property(\'active\', active)\n            return\n        def setup_check_column(title, colnr):\n            col = new_toggle_column(title,\n                    toggled_callback=(self.specimen_tv_toggled, (store, colnr)),\n                    data_func=toggle_renderer,\n                    resizable=False,\n                    expand=False,\n                    activatable=True,\n                    active_col=colnr)\n            setattr(col, ""colnr"", colnr)\n            widget.append_column(col)\n\n        setup_check_column(\'Exp\', store.c_display_experimental)\n        if self.model.layout_mode == ""FULL"":\n            setup_check_column(\'Cal\', store.c_display_calculated)\n            setup_check_column(\'Sep\', store.c_display_phases)\n\n        # Up and down arrows:\n        def setup_image_button(image, colnr):\n            col = new_pb_column("""", resizable=False, expand=False, stock_id=image)\n            setattr(col, ""colnr"", colnr)\n            widget.append_column(col)\n        setup_image_button(""213-up-arrow"", 501)\n        setup_image_button(""212-down-arrow"", 502)\n\n    def edit_object(self, obj):\n        pass # clear this method, we\'re not having an \'edit\' view pane...\n\n    @BaseController.status_message(""Importing multiple specimens..."", ""add_specimen"")\n    def import_multiple_specimen(self):\n        def on_accept(dialog):\n            ## TODO MOVE THIS (PARTIALLY?) TO THE MODEL LEVEL ##\n\n            filenames = dialog.get_filenames()\n            parser = getattr(dialog.get_filter(), ""parser"")\n\n            task = ThreadedTaskBox()\n            window = DialogFactory.get_custom_dialog(\n                 task, parent=self.view.get_top_widget())\n\n            # Status:\n            status_dict = dict(\n                total_files=len(filenames),\n                current_file=0,\n                specimens=[]\n            )\n\n            # Task:\n            def load_specimens(stop=None):\n                for filename in filenames:\n                    if stop is not None and stop.is_set():\n                        return\n                    # Error message is case parsing fails:\n                    message = ""An unexpected error has occurred when trying to parse %s:\\n\\n<i>"" % os.path.basename(filename)\n                    message += ""%s</i>\\n\\n""\n                    message += ""This is most likely caused by an invalid or unsupported file format.""\n                    # Run & report any errors:\n                    with DialogFactory.error_dialog_handler(\n                            message, self.view.get_top_widget(), \n                            title=""Failed to load file"", reraise=False):\n                        specimens = Specimen.from_experimental_data(filename=filename, parent=self.model, parser=parser)\n                        status_dict[""specimens""] += specimens\n                    status_dict[""current_file""] += 1\n\n            # Cancel & stop events:\n            def on_interrupted(*args, **kwargs):\n                window.hide()\n\n            # Status label update:\n            def gui_callback():\n                task.set_status(""Loading file %d/%d ..."" % (\n                    status_dict[""current_file""],\n                    status_dict[""total_files""]\n                ))\n                return True\n            gui_timeout_id = GObject.timeout_add(250, gui_callback)\n\n            # Complete event:\n            @run_when_idle\n            def on_complete(*args, **kwargs):\n                last_iter = None\n                for specimen in status_dict[""specimens""]:\n                    last_iter = self.model.specimens.append(specimen)\n                if last_iter is not None:\n                    self.view[""project_specimens""].set_cursor(last_iter)\n                GObject.source_remove(gui_timeout_id)\n                window.hide()\n                window.destroy()\n\n            # Run task box:\n            task.connect(""cancelrequested"", on_interrupted)\n            task.connect(""stoprequested"", on_interrupted)\n            task.set_status(""Loading ..."")\n            task.start()\n            window.show_all()\n\n            # Run thread:\n            self.thread = CancellableThread(load_specimens, on_complete)\n            self.thread.start()\n\n        DialogFactory.get_load_dialog(title=""Select XRD files for import"",\n                             filters=xrd_parsers.get_import_file_filters(),\n                             parent=self.view.get_top_widget(),\n                             multiple=True).run(on_accept)\n\n    @BaseController.status_message(""Deleting specimen..."", ""del_specimen"")\n    def delete_selected_specimens(self):\n        """"""\n            Asks the user for confirmation and if positive deletes all the \n            selected specimens. Does nothing when no specimens are selected.\n        """"""\n        selection = self.get_selected_objects()\n        if selection is not None and len(selection) >= 1:\n            def delete_objects(dialog):\n                for obj in selection:\n                    if obj is not None:\n                        self.model.specimens.remove(obj)\n            DialogFactory.get_confirmation_dialog(\n                message=\'Deleting a specimen is irreversible!\\nAre You sure you want to continue?\',\n                parent=self.view.get_top_widget()\n            ).run(delete_objects)\n\n    @BaseController.status_message(""Removing backgrounds..."", ""del_bg_specimen"")\n    def remove_backgrounds(self, specimens):\n        """"""\n            Opens the \'remove background\' dialog for the given specimens,\n            raises a ValueError error if (one of) the specimens is not part of\n            this project.\n        """"""\n\n        def on_automated(dialog):\n            for specimen in specimens:\n                if not specimen in self.model.specimens:\n                    raise ValueError(""Specimen `%s` is not part of this Project!"" % specimen)\n                else:\n                    specimen.experimental_pattern.bg_type = 0 # Linear see settings\n                    specimen.experimental_pattern.find_bg_position()\n                    specimen.experimental_pattern.remove_background()\n                    specimen.experimental_pattern.clear_bg_variables()\n\n        def on_not_automated(dialog):\n            for specimen in specimens:\n                if not specimen in self.model.specimens:\n                    raise ValueError(""Specimen `%s` is not part of this Project!"" % specimen)\n                else:\n                    bg_view = BackgroundView(parent=self.parent.view)\n                    BackgroundController(model=specimen.experimental_pattern, view=bg_view, parent=self)\n                    bg_view.present()\n\n        # Ask user if he/she wants automation:\n        DialogFactory.get_confirmation_dialog(\n            ""Do you want to perform an automated linear background subtraction?"",\n            parent=self.parent.view.get_top_widget()\n        ).run(on_automated, on_not_automated)\n\n    def edit_specimen(self):\n        selection = self.get_selected_objects()\n        if selection is not None and len(selection) == 1:\n            # TODO move the specimen view & controller into the project level\n            self.parent.view.specimen.present()\n\n    @BaseController.status_message(""Creating new specimen..."", ""add_specimen"")\n    def add_specimen(self):\n        specimen = Specimen(parent=self.model, name=""New Specimen"")\n        self.model.specimens.append(specimen)\n        self.view.specimens_treeview.set_cursor(self.treemodel.on_get_path(specimen))\n        self.edit_specimen()\n        return True\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.hold_mixtures_data_changed():\n            with self.model.data_changed.hold():\n                yield\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""name"", assign=True)\n    def notif_change_name(self, model, prop_name, info):\n        self.parent.update_title()\n        return\n\n    @Controller.observe(""axes_xlimit"", assign=True)\n    def notif_xlimit_toggled(self, model, prop_name, info):\n        self.view.set_x_range_sensitive(int(self.model.axes_xlimit) == 1)\n\n    @Controller.observe(""axes_ylimit"", assign=True)\n    def notif_ylimit_toggled(self, model, prop_name, info):\n        self.view.set_y_range_sensitive(int(self.model.axes_ylimit) == 1)\n\n    @Controller.observe(""layout_mode"", assign=True)\n    def notif_layout_mode(self, model, prop_name, info):\n        self.parent.set_layout_mode(self.model.layout_mode)\n        if self.view is not None:\n            self.setup_treeview(self.view.treeview)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def specimen_tv_toggled(self, cell, path, model, colnr):\n        if model is not None:\n            itr = model.get_iter(path)\n            model.set_value(itr, colnr, not cell.get_active())\n            return True\n        return False\n\n    def specimen_tv_button_press(self, tv, event):\n        specimen = None\n        current_specimens = self.parent.model.current_specimens or []\n        ret = tv.get_path_at_pos(int(event.x), int(event.y))\n        if ret is not None:\n            path, col, x, y = ret\n            specimen = self.treemodel.get_user_data_from_path(path)\n        if event.button == 3:\n            if specimen is not None:\n                # clicked a specimen which is not in the current selection,\n                # so clear selection and select it\n                if not specimen in current_specimens:\n                    self.select_object(specimen)\n            else:\n                # clicked an empty space, so clear selection\n                self.select_object(None)\n            self.view.show_specimens_context_menu(event)\n            return True\n        elif event.type == Gdk.EventType._2BUTTON_PRESS and specimen is not None and getattr(col, ""colnr"") == self.treemodel.c_name:  # @UndefinedVariable\n            self.parent.on_edit_specimen_activate(event)\n            return True\n        elif (event.button == 1 or event.type == Gdk.EventType._2BUTTON_PRESS) and specimen is not None:  # @UndefinedVariable\n            column = getattr(col, ""colnr"")\n            if column in (self.treemodel.c_display_experimental,\n                    self.treemodel.c_display_calculated,\n                    self.treemodel.c_display_phases):\n                if column == self.treemodel.c_display_experimental:\n                    specimen.display_experimental = not specimen.display_experimental\n                elif column == self.treemodel.c_display_calculated:\n                    specimen.display_calculated = not specimen.display_calculated\n                elif column == self.treemodel.c_display_phases:\n                    specimen.display_phases = not specimen.display_phases\n                # TODO FIXME self.treemodel.on_row_changed(ret)\n                return True\n            elif column == 501:\n                self.model.move_specimen_down(specimen)\n                self.parent.model.current_specimens = self.get_selected_objects()\n                return True\n            elif column == 502:\n                self.model.move_specimen_up(specimen)\n                self.parent.model.current_specimens = self.get_selected_objects()\n                return True\n\n    def objects_tv_selection_changed(self, selection):\n        ObjectListStoreController.objects_tv_selection_changed(self, selection)\n        self.parent.model.current_specimens = self.get_selected_objects()\n        return True\n\n    pass # end of class\n'"
pyxrd/project/importing.py,2,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, string\n\nimport numpy as np\nimport xml.etree.ElementTree as ET\n\nfrom pyxrd.mixture.models import Mixture\nfrom pyxrd.project.models import Project\nfrom pyxrd.specimen.models import Specimen\nfrom pyxrd.phases.models import Phase\nfrom pyxrd.atoms.models import Atom\n\ndef safe_float(num):\n    return float(num.replace("","", "".""))\n\ndef create_project_from_sybilla_xml(filename, **kwargs):\n    """"""\n        Creates a new project structure from a Sybilla XML file.\n        Some information (e.g. the actual XRD pattern) is not present and will\n        still need to be imported manually.\n    """"""\n\n    tree = ET.parse(filename)\n    root = tree.getroot()\n    basename = os.path.basename(filename)\n\n    # Create the project:\n    if ""name"" in kwargs: kwargs.pop(""name"")\n    if ""layout_mode"" in kwargs: kwargs.pop(""layout_mode"")\n    project = Project(name=basename, layout_mode=""FULL"", **kwargs)\n\n    # Add a specimen:\n    specimen = Specimen(name=basename, parent=project)\n    project.specimens.append(specimen)\n\n    # Add a mixture:\n    mixture = Mixture(name=basename, auto_run=False, parent=project)\n    mixture.add_specimen_slot(specimen, 1.0, 0.0)\n    project.mixtures.append(mixture)\n\n    with project.data_changed.ignore():\n        with mixture.data_changed.ignore():\n\n            for child in root:\n                if child.tag == ""basic_params"":\n                    # Goniometer parameters:\n                    step_size = safe_float(child.attrib[\'step_size\'])\n                    wavelength = safe_float(child.attrib[\'lambda\']) / 10.0\n                    steps = int(1 + (specimen.goniometer.max_2theta - specimen.goniometer.min_2theta) / step_size)\n\n                    specimen.goniometer.min_2theta = safe_float(child.attrib[\'min2theta\'])\n                    specimen.goniometer.max_2theta = safe_float(child.attrib[\'max2theta\'])\n                    specimen.goniometer.steps = steps\n                    specimen.goniometer.wavelength = wavelength\n                elif child.tag == ""diffractometer"":\n                    # Some more goniometer parameters, and specimen parameters:\n                    specimen.goniometer.radius = safe_float(child.attrib[\'gonio_radius\'])\n                    specimen.goniometer.divergence = safe_float(child.attrib[\'diverg_slit\'])\n                    specimen.goniometer.soller1 = safe_float(child.attrib[\'Soller1\'])\n                    specimen.goniometer.soller2 = safe_float(child.attrib[\'Soller2\'])\n                    specimen.sample_length = safe_float(child.attrib[\'sample_length\'])\n                elif child.tag == ""content"":\n                    # Content tag contains \'Mixture\' data\n                    for xmlPhaseContent in child:\n                        name = xmlPhaseContent.attrib[\'name\']\n                        fraction = safe_float(xmlPhaseContent.attrib[\'content\']) / 100.\n                        mixture.add_phase_slot(name, fraction)\n                elif child.tag == ""mixture"":\n                    # Mixture tag corresponds with the phases in the project level,\n                    # not an actual Mixture object:\n                    for xmlPhase in child:\n                        name = xmlPhase.attrib[\'name\']\n                        sigma = xmlPhase.attrib[\'sigma_star\']\n                        csds = safe_float(xmlPhase.find(\'distribution\').attrib[\'Tmean\'])\n                        G = 1\n                        R = 0\n                        W = [1.0, ]\n                        if xmlPhase.attrib[\'type\'] != \'mono\':\n                            prob = xmlPhase.find(\'probability\')\n                            G = int(prob.attrib[\'no_of_comp\'])\n                            R = int(prob.attrib[\'R\'])\n\n                        # create phase and add to project:\n                        phase = Phase(name=name, sigma_star=sigma, G=G, R=R, parent=project)\n                        phase.CSDS_distribution.average = csds\n                        project.phases.append(phase)\n\n                        # set probability:\n                        if R == 0 and G != 1:\n                            xmlW = prob.find(\'W\')\n                            W = np.array([ float(int(safe_float(xmlW.attrib[string.ascii_lowercase[i]]) * 1000.)) / 1000. for i in range(G) ])\n                            for i in range(G - 1):\n                                setattr(phase.probabilities, ""F%d"" % (i + 1), W[i] / np.sum(W[i:]))\n                        if R == 1 and G == 2:\n                            pass  # TODO\n                        # ... TODO other probs\n\n                        # parse components:\n                        for i, layer in enumerate(xmlPhase.findall(""./layer_and_edge/layer"")):\n\n                            component = phase.components[i]\n                            component.name = layer.attrib[\'name\']\n\n                            component.d001 = safe_float(layer.attrib[\'d_spacing\']) / 10.0\n                            component.default_c = safe_float(layer.attrib[\'d_spacing\']) / 10.0\n                            component.delta_c = safe_float(layer.attrib[\'d_spacing_delta\']) / 10.0\n\n                            component.ucp_b.value = 0.9\n\n                            component.ucp_a.factor = 0.57735\n                            component.ucp_a.prop = (component, \'cell_b\')\n                            component.ucp_a.enabled = True\n\n\n                            atom_type_map = {\n                                # ""NH4"": ""FIXME""\n                                ""K"": ""K1+"",\n                                ""O"": ""O1-"",\n                                ""Si"": ""Si2+"",\n                                ""OH"": ""OH1-"",\n                                ""Fe"": ""Fe1.5+"",\n                                ""Al"": ""Al1.5+"",\n                                ""Mg"": ""Mg1+"",\n                                ""H2O"": ""H2O"",\n                                ""Gly"": ""Glycol"",\n                                ""Ca"": ""Ca2+"",\n                                ""Na"": ""Na1+"",\n                            }\n\n                            # add atoms:\n                            fe_atom = None\n                            encountered_oxygen = False\n                            for atom in layer.findall(""atom""):\n                                atom_type_name = atom_type_map.get(atom.attrib[\'type\'], None)\n                                if atom_type_name:\n                                    if atom_type_name == ""O1-"":\n                                        # From this point we\'re dealing with layer atoms\n                                        encountered_oxygen = True\n                                    atom = Atom(\n                                        name=atom.attrib[\'type\'],\n                                        default_z=safe_float(atom.attrib[\'position\']) / 10.0,\n                                        pn=safe_float(atom.attrib[\'content\']),\n                                        atom_type_name=atom_type_name,\n                                        parent=component\n                                    )\n                                    if encountered_oxygen:\n                                        component.layer_atoms.append(atom)\n                                    else:\n                                        component.interlayer_atoms.append(atom)\n                                    atom.resolve_json_references()\n                                    # Assume this is the octahedral iron...\n                                    if encountered_oxygen and atom_type_name == ""Fe1.5+"":\n                                        fe_atom = atom\n\n                            # Set the atom relation\n                            if fe_atom is not None:\n                                component.ucp_b.constant = 0.9\n                                component.ucp_b.factor = 0.0043\n                                component.ucp_b.prop = (fe_atom, \'pn\')\n                                component.ucp_b.enabled = True\n\n                pass # end of if\n            pass # end of for\n\n\n            # Map phases onto mixture names:\n            for phase in project.phases:\n                for slot, phase_name in enumerate(mixture.phases):\n                    if phase.name == phase_name:\n                        mixture.set_phase(0, slot, phase)\n\n    return project\n'"
pyxrd/project/models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport time\nfrom contextlib import contextmanager\n\nfrom mvc.models.properties import (\n    FloatProperty, BoolProperty, StringProperty, ListProperty,\n    IntegerProperty, StringChoiceProperty, IntegerChoiceProperty, SignalMixin\n)\n\nfrom mvc.observers import ListObserver\n\nfrom pyxrd.__version import __version__\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.models.event_context_manager import EventContextManager\nfrom pyxrd.generic.io import storables, Storable, get_case_insensitive_glob\nfrom pyxrd.generic.utils import not_none\n\nfrom pyxrd.atoms.models import AtomType\nfrom pyxrd.phases.models import Phase\nfrom pyxrd.specimen.models import Specimen\nfrom pyxrd.mixture.models.mixture import Mixture\n#from pyxrd.mixture.models.insitu_behaviours import InSituBehaviour\n\n@storables.register()\nclass Project(DataModel, Storable):\n    """"""\n    This is the top-level object that servers the purpose of combining the\n    different objects (most notably :class:`~.atoms.models.AtomType`\'s,\n    :class:`~.phases.models.Phase`\'s, :class:`~.specimen.models.Specimen`\'s and\n    :class:`~.mixture.models.Mixture`\'s).\n    \n    It also provides a large number of display-related \'default\' properties \n    (e.g. for patterns and their markers, axes etc.). For more details: see the\n    property descriptions.\n    \n    Example usage:\n    \n    .. code-block:: python\n    \n        >>> from pyxrd.project.models import Project\n        >>> from pyxrd.generic.io.xrd_parsers import XRDParser\n        >>> from pyxrd.specimen.models import Specimen\n        >>> project = Project(name=""New Project"", author=""Mr. X"", layout_mode=""FULL"", axes_dspacing=True)\n        >>> for specimen in Specimen.from_experimental_data(""/path/to/xrd_data_file.rd"", parent=project):\n        ...   project.specimens.append(specimen)\n        ...\n        \n    """"""\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Project""\n        file_filters = [\n            (""PyXRD Project files"", get_case_insensitive_glob(""*.pyxrd"", ""*.zpd"")),\n        ]\n        import_filters = [\n            (""Sybilla XML files"", get_case_insensitive_glob(""*.xml"")),\n        ]\n\n    # PROPERTIES:\n\n    filename = None\n\n    #: The project name\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True\n    )\n\n    #: The project data (string)\n    date = StringProperty(\n        default="""", text=""Date"",\n        visible=True, persistent=True\n    )\n\n    #: The project description\n    description = StringProperty(\n        default=None, text=""Description"",\n        visible=True, persistent=True, widget_type=""text_view"",\n    )\n\n    #: The project author\n    author = StringProperty(\n        default="""", text=""Author"",\n        visible=True, persistent=True\n    )\n\n    #: Flag indicating whether this project has been changed since it was last saved.\n    needs_saving = BoolProperty(\n        default=True, visible=False, persistent=False\n    )\n\n    #: The layout mode this project should be displayed in\n    layout_mode = StringChoiceProperty(\n        default=settings.DEFAULT_LAYOUT, text=""Layout mode"",\n        visible=True, persistent=True, choices=settings.DEFAULT_LAYOUTS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The manual lower limit for the X-axis\n    axes_xmin = FloatProperty(\n        default=settings.AXES_MANUAL_XMIN, text=""min. [\xc2\xb02T]"",\n        visible=True, persistent=True, minimum=0.0, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The manual upper limit for the X-axis\n    axes_xmax = FloatProperty(\n        default=settings.AXES_MANUAL_XMAX, text=""max. [\xc2\xb02T]"",\n        visible=True, persistent=True, minimum=0.0, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: Whether or not to stretch the X-axis over the entire available display\n    axes_xstretch = BoolProperty(\n        default=settings.AXES_XSTRETCH, text=""Stetch x-axis to fit window"",\n        visible=True, persistent=True,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: Flag toggling between d-spacing (when True) or 2-Theta axes (when False)\n    axes_dspacing = BoolProperty(\n        default=settings.AXES_DSPACING, text=""Show d-spacing in x-axis"",\n        visible=True, persistent=True,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: Whether or not the y-axis should be shown\n    axes_yvisible = BoolProperty(\n        default=settings.AXES_YVISIBLE, text=""Y-axis visible"",\n        visible=True, persistent=True,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The manual lower limit for the Y-axis (in counts)\n    axes_ymin = FloatProperty(\n        default=settings.AXES_MANUAL_YMIN, text=""min. [counts]"",\n        visible=True, persistent=True, minimum=0.0, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The manual upper limit for the Y-axis (in counts)\n    axes_ymax = FloatProperty(\n        default=settings.AXES_MANUAL_YMAX, text=""max. [counts]"",\n        visible=True, persistent=True, minimum=0.0, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: What type of y-axis to use: raw counts, single or multi-normalized units\n    axes_ynormalize = IntegerChoiceProperty(\n        default=settings.AXES_YNORMALIZE, text=""Y scaling"",\n        visible=True, persistent=True, choices=settings.AXES_YNORMALIZERS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: Whether to use automatic or manual Y limits\n    axes_ylimit = IntegerChoiceProperty(\n        default=settings.AXES_YLIMIT, text=""Y limit"",\n        visible=True, persistent=True, choices=settings.AXES_YLIMITS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The offset between patterns as a fraction of the maximum intensity\n    display_plot_offset = FloatProperty(\n        default=settings.PLOT_OFFSET, text=""Pattern offset"",\n        visible=True, persistent=True, minimum=0.0, widget_type=""float_entry"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The number of patterns to group ( = having no offset)\n    display_group_by = IntegerProperty(\n        default=settings.PATTERN_GROUP_BY, text=""Group patterns by"",\n        visible=True, persistent=True, minimum=1, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The relative position (from the pattern offset) for pattern labels\n    #: as a fraction of the patterns intensity\n    display_label_pos = FloatProperty(\n        default=settings.LABEL_POSITION, text=""Default label position"",\n        visible=True, persistent=True, widget_type=""float_entry"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: What type of scale to use for X-axis, automatic or manual\n    axes_xlimit = IntegerChoiceProperty(\n        default=settings.AXES_XLIMIT, text=""X limit"",\n        visible=True, persistent=True,\n        choices=settings.AXES_XLIMITS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default angle at which marker labels are displayed\n    display_marker_angle = FloatProperty(\n        default=settings.MARKER_ANGLE, text=""Angle"",\n        visible=True, persistent=True, widget_type=""float_entry"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default offset for marker labels\n    display_marker_top_offset = FloatProperty(\n        default=settings.MARKER_TOP_OFFSET, text=""Offset from base"",\n        visible=True, persistent=True, widget_type=""float_entry"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default marker label alignment (one of settings.MARKER_ALIGNS)\n    display_marker_align = StringChoiceProperty(\n        default=settings.MARKER_ALIGN, text=""Label alignment"",\n        visible=True, persistent=True,\n        choices=settings.MARKER_ALIGNS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default marker label base (one of settings.MARKER_BASES)\n    display_marker_base = IntegerChoiceProperty(\n        default=settings.MARKER_BASE, text=""Base connection"",\n        visible=True, persistent=True,\n        choices=settings.MARKER_BASES,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default marker label top (one of settings.MARKER_TOPS)\n    display_marker_top = IntegerChoiceProperty(\n        default=settings.MARKER_TOP, text=""Top connection"",\n        visible=True, persistent=True,\n        choices=settings.MARKER_TOPS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default marker style (one of settings.MARKER_STYLES)\n    display_marker_style = StringChoiceProperty(\n        default=settings.MARKER_STYLE, text=""Line style"",\n        visible=True, persistent=True,\n        choices=settings.MARKER_STYLES,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default marker color\n    display_marker_color = StringProperty(\n        default=settings.MARKER_COLOR, text=""Color"",\n        visible=True, persistent=True, widget_type=""color"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default calculated profile color\n    display_calc_color = StringProperty(\n        default=settings.CALCULATED_COLOR, text=""Calculated color"",\n        visible=True, persistent=True, widget_type=""color"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default experimental profile color\n    display_exp_color = StringProperty(\n        default=settings.EXPERIMENTAL_COLOR, text=""Experimental color"",\n        visible=True, persistent=True, widget_type=""color"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default calculated profile line width\n    display_calc_lw = IntegerProperty(\n        default=settings.CALCULATED_LINEWIDTH, text=""Calculated line width"",\n        visible=True, persistent=True, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default experimental profile line width\n    display_exp_lw = IntegerProperty(\n        default=settings.EXPERIMENTAL_LINEWIDTH, text=""Experimental line width"",\n        visible=True, persistent=True, widget_type=""spin"",\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default calculated profile line style\n    display_calc_ls = StringChoiceProperty(\n        default=settings.CALCULATED_LINESTYLE, text=""Calculated line style"",\n        visible=True, persistent=True,\n        choices=settings.PATTERN_LINE_STYLES,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default experimental profile line style\n    display_exp_ls = StringChoiceProperty(\n        default=settings.EXPERIMENTAL_LINESTYLE, text=""Experimental line style"",\n        visible=True, persistent=True,\n        choices=settings.PATTERN_LINE_STYLES,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default calculated profile line style\n    display_calc_marker = StringChoiceProperty(\n        default=settings.CALCULATED_MARKER, text=""Calculated line marker"",\n        visible=True, persistent=True,\n        choices=settings.PATTERN_MARKERS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The default calculated profile line style\n    display_exp_marker = StringChoiceProperty(\n        default=settings.EXPERIMENTAL_MARKER, text=""Experimental line marker"",\n        visible=True, persistent=True,\n        choices=settings.PATTERN_MARKERS,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: The list of specimens\n    specimens = ListProperty(\n        default=[], text=""Specimens"", data_type=Specimen,\n        visible=True, persistent=True,\n    )\n\n    #: The list of phases\n    phases = ListProperty(\n        default=[], text=""Phases"", data_type=Phase,\n        visible=False, persistent=True\n    )\n\n    #: The list of atom types\n    atom_types = ListProperty(\n        default=[], text=""Atom types"", data_type=AtomType,\n        visible=False, persistent=True\n    )\n\n    #: The list of Behaviours\n    #behaviours = ListProperty(\n    #    default=[], text=""Behaviours"", data_type=InSituBehaviour,\n    #    visible=False, persistent=True\n    #)\n\n    #: The list of mixtures\n    mixtures = ListProperty(\n        default=[], text=""Mixture"", data_type=Mixture,\n        visible=False, persistent=True\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Constructor takes any of its properties as a keyword argument \n            except for:\n                - needs_saving\n            \n            In addition to the above, the constructor still supports the \n            following deprecated keywords, mapping to a current keyword:\n                - goniometer: the project-level goniometer, is passed on to the\n                  specimens\n                - axes_xscale: deprecated alias for axes_xlimit\n                - axes_yscale: deprecated alias for axes_ynormalize\n                \n            Any other arguments or keywords are passed to the base class.\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""goniometer"", ""data_goniometer"", ""data_atom_types"", ""data_phases"",\n            ""axes_yscale"", ""axes_xscale"", ""filename"", ""behaviours"",\n            *[prop.label for prop in Project.Meta.get_local_persistent_properties()]\n        )\n        super(Project, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n            with self.visuals_changed.hold():\n\n                self.filename = self.get_kwarg(kwargs, self.filename, ""filename"")\n                self.layout_mode = self.get_kwarg(kwargs, self.layout_mode, ""layout_mode"")\n\n                self.display_marker_align = self.get_kwarg(kwargs, self.display_marker_align, ""display_marker_align"")\n                self.display_marker_color = self.get_kwarg(kwargs, self.display_marker_color, ""display_marker_color"")\n                self.display_marker_base = self.get_kwarg(kwargs, self.display_marker_base, ""display_marker_base"")\n                self.display_marker_top = self.get_kwarg(kwargs, self.display_marker_top, ""display_marker_top"")\n                self.display_marker_top_offset = self.get_kwarg(kwargs, self.display_marker_top_offset, ""display_marker_top_offset"")\n                self.display_marker_angle = self.get_kwarg(kwargs, self.display_marker_angle, ""display_marker_angle"")\n                self.display_marker_style = self.get_kwarg(kwargs, self.display_marker_style, ""display_marker_style"")\n\n                self.display_calc_color = self.get_kwarg(kwargs, self.display_calc_color, ""display_calc_color"")\n                self.display_exp_color = self.get_kwarg(kwargs, self.display_exp_color, ""display_exp_color"")\n                self.display_calc_lw = self.get_kwarg(kwargs, self.display_calc_lw, ""display_calc_lw"")\n                self.display_exp_lw = self.get_kwarg(kwargs, self.display_exp_lw, ""display_exp_lw"")\n                self.display_calc_ls = self.get_kwarg(kwargs, self.display_calc_ls, ""display_calc_ls"")\n                self.display_exp_ls = self.get_kwarg(kwargs, self.display_exp_ls, ""display_exp_ls"")\n                self.display_calc_marker = self.get_kwarg(kwargs, self.display_calc_marker, ""display_calc_marker"")\n                self.display_exp_marker = self.get_kwarg(kwargs, self.display_exp_marker, ""display_exp_marker"")\n                self.display_plot_offset = self.get_kwarg(kwargs, self.display_plot_offset, ""display_plot_offset"")\n                self.display_group_by = self.get_kwarg(kwargs, self.display_group_by, ""display_group_by"")\n                self.display_label_pos = self.get_kwarg(kwargs, self.display_label_pos, ""display_label_pos"")\n\n                self.axes_xlimit = self.get_kwarg(kwargs, self.axes_xlimit, ""axes_xlimit"", ""axes_xscale"")\n                self.axes_xmin = self.get_kwarg(kwargs, self.axes_xmin, ""axes_xmin"")\n                self.axes_xmax = self.get_kwarg(kwargs, self.axes_xmax, ""axes_xmax"")\n                self.axes_xstretch = self.get_kwarg(kwargs, self.axes_xstretch, ""axes_xstretch"")\n                self.axes_ylimit = self.get_kwarg(kwargs, self.axes_ylimit, ""axes_ylimit"")\n                self.axes_ynormalize = self.get_kwarg(kwargs, self.axes_ynormalize, ""axes_ynormalize"", ""axes_yscale"")\n                self.axes_yvisible = self.get_kwarg(kwargs, self.axes_yvisible, ""axes_yvisible"")\n                self.axes_ymin = self.get_kwarg(kwargs, self.axes_ymin, ""axes_ymin"")\n                self.axes_ymax = self.get_kwarg(kwargs, self.axes_ymax, ""axes_ymax"")\n\n                goniometer = None\n                goniometer_kwargs = self.get_kwarg(kwargs, None, ""goniometer"", ""data_goniometer"")\n                if goniometer_kwargs:\n                    goniometer = self.parse_init_arg(goniometer_kwargs, None, child=True)\n\n                # Set up and observe atom types:\n                self.atom_types = self.get_list(kwargs, [], ""atom_types"", ""data_atom_types"", parent=self)\n                self._atom_types_observer = ListObserver(\n                    self.on_atom_type_inserted,\n                    self.on_atom_type_removed,\n                    prop_name=""atom_types"",\n                    model=self\n                )\n\n                # Resolve json references & observe phases\n                self.phases = self.get_list(kwargs, [], ""phases"", ""data_phases"", parent=self)\n                for phase in self.phases:\n                    phase.resolve_json_references()\n                    self.observe_model(phase)\n                self._phases_observer = ListObserver(\n                    self.on_phase_inserted,\n                    self.on_phase_removed,\n                    prop_name=""phases"",\n                    model=self\n                )\n\n                # Set goniometer if required & observe specimens\n                self.specimens = self.get_list(kwargs, [], ""specimens"", ""data_specimens"", parent=self)\n                for specimen in self.specimens:\n                    if goniometer: specimen.goniometer = goniometer\n                    self.observe_model(specimen)\n                self._specimens_observer = ListObserver(\n                    self.on_specimen_inserted,\n                    self.on_specimen_removed,\n                    prop_name=""specimens"",\n                    model=self\n                )\n\n                # Observe behaviours:\n                #self.behaviours = self.get_list(kwargs, [], ""behaviours"", parent=self)\n                #for behaviour in self.behaviours:\n                #    self.observe_model(behaviour)\n                #self._behaviours_observer = ListObserver(\n                #    self.on_behaviour_inserted,\n                #    self.on_behaviour_removed,\n                #    prop_name=""behaviours"",\n                #    model=self\n                #)\n\n                # Observe mixtures:\n                self.mixtures = self.get_list(kwargs, [], ""mixtures"", ""data_mixtures"", parent=self)\n                for mixture in self.mixtures:\n                    self.observe_model(mixture)\n                self._mixtures_observer = ListObserver(\n                    self.on_mixture_inserted,\n                    self.on_mixture_removed,\n                    prop_name=""mixtures"",\n                    model=self\n                )\n\n                self.name = str(self.get_kwarg(kwargs, ""Project name"", ""name"", ""data_name""))\n                self.date = str(self.get_kwarg(kwargs, time.strftime(""%d/%m/%Y""), ""date"", ""data_date""))\n                self.description = str(self.get_kwarg(kwargs, ""Project description"", ""description"", ""data_description""))\n                self.author = str(self.get_kwarg(kwargs, ""Project author"", ""author"", ""data_author""))\n\n                load_default_data = self.get_kwarg(kwargs, True, ""load_default_data"")\n                if load_default_data and self.layout_mode != 1 and \\\n                    len(self.atom_types) == 0: self.load_default_data()\n\n                self.needs_saving = True\n            pass # end with visuals_changed\n        pass # end with data_changed\n\n    def load_default_data(self):\n        for atom_type in AtomType.get_from_csv(settings.DATA_REG.get_file_path(""ATOM_SCAT_FACTORS"")):\n            self.atom_types.append(atom_type)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    def on_phase_inserted(self, item):\n        # Set parent on the new phase:\n        if item.parent != self: item.parent = self\n        item.resolve_json_references()\n\n    def on_phase_removed(self, item):\n        with self.data_changed.hold_and_emit():\n            # Clear parent:\n            item.parent = None\n            # Clear links with other phases:\n            if getattr(item, ""based_on"", None) is not None:\n                item.based_on = None\n            for phase in self.phases:\n                if getattr(phase, ""based_on"", None) == item:\n                    phase.based_on = None\n            # Remove phase from mixtures:\n            for mixture in self.mixtures:\n                mixture.unset_phase(item)\n\n    def on_atom_type_inserted(self, item, *data):\n        if item.parent != self: item.parent = self\n        # We do not observe AtomType\'s directly, if they change,\n        # Atoms containing them will be notified, and that event should bubble\n        # up to the project level.\n\n    def on_atom_type_removed(self, item, *data):\n        item.parent = None\n        # We do not emit a signal for AtomType\'s, if it was part of\n        # an Atom, the Atom will be notified, and the event should bubble\n        # up to the project level\n\n    def on_specimen_inserted(self, item):\n        # Set parent and observe the new specimen (visuals changed signals):\n        if item.parent != self: item.parent = self\n        self.observe_model(item)\n\n    def on_specimen_removed(self, item):\n        with self.data_changed.hold_and_emit():\n            # Clear parent & stop observing:\n            item.parent = None\n            self.relieve_model(item)\n            # Remove specimen from mixtures:\n            for mixture in self.mixtures:\n                mixture.unset_specimen(item)\n\n    def on_mixture_inserted(self, item):\n        # Set parent and observe the new mixture:\n        if item.parent != self: item.parent = self\n        self.observe_model(item)\n\n    def on_mixture_removed(self, item):\n        with self.data_changed.hold_and_emit():\n            # Clear parent & stop observing:\n            item.parent = None\n            self.relieve_model(item)\n\n    def on_behaviour_inserted(self, item):\n        # Set parent and observe the new mixture:\n        if item.parent != self: item.parent = self\n        self.observe_model(item)\n\n    def on_behaviour_removed(self, item):\n        with self.data_changed.hold_and_emit():\n            # Clear parent & stop observing:\n            item.parent = None\n            self.relieve_model(item)\n\n    @DataModel.observe(""data_changed"", signal=True)\n    def notify_data_changed(self, model, prop_name, info):\n        self.needs_saving = True\n        if isinstance(model, Mixture):\n            self.data_changed.emit()\n\n    @DataModel.observe(""visuals_changed"", signal=True)\n    def notify_visuals_changed(self, model, prop_name, info):\n        self.needs_saving = True\n        self.visuals_changed.emit() # propagate signal\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    @classmethod\n    def from_json(type, **kwargs): # @ReservedAssignment\n        project = type(**kwargs)\n        project.needs_saving = False # don\'t mark this when just loaded\n        return project\n\n    def to_json_multi_part(self):\n        to_json = self.to_json()\n        properties = to_json[""properties""]\n\n        for name in (""phases"", ""specimens"", ""atom_types"", ""mixtures""): #""behaviours""\n            yield (name, properties.pop(name))\n            properties[name] = ""file://%s"" % name\n\n        yield (""content"", to_json)\n        yield (""version"", __version__)\n\n    @staticmethod\n    def create_from_sybilla_xml(filename, **kwargs):\n        from pyxrd.project.importing import create_project_from_sybilla_xml\n        return create_project_from_sybilla_xml(filename, **kwargs)\n\n    # ------------------------------------------------------------\n    #      Draggable mix-in hook:\n    # ------------------------------------------------------------\n    def on_label_dragged(self, delta_y, button=1):\n        if button == 1:\n            self.display_label_pos += delta_y\n        pass\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_scale_factor(self, specimen=None):\n        """"""\n        Get the factor with which to scale raw data and the scaled offset\n                \n        :rtype: tuple containing the scale factor and the (scaled) offset\n        """"""\n        if self.axes_ynormalize == 0 or (self.axes_ynormalize == 1 and specimen is None):\n            return (1.0 / (self.get_max_display_y() or 1.0), 1.0)\n        elif self.axes_ynormalize == 1:\n            return (1.0 / (specimen.get_max_display_y or 1.0), 1.0)\n        elif self.axes_ynormalize == 2:\n            return (1.0, self.get_max_display_y())\n        else:\n            raise ValueError(""Wrong value for \'axes_ysnormalize\' in %s: is `%d`; should be 0, 1 or 2"" % (self, self.axes_ynormalize))\n\n    def get_max_display_y(self):\n        max_display_y = 0\n        if self.parent is not None:\n            for specimen in self.parent.current_specimens:\n                max_display_y = max(specimen.max_display_y, max_display_y)\n        return max_display_y\n\n    @contextmanager\n    def hold_child_signals(self):\n        logger.info(""Holding back all project child object signals"")\n        with self.hold_mixtures_needs_update():\n            with self.hold_mixtures_data_changed():\n                with self.hold_phases_data_changed():\n                    with self.hold_specimens_data_changed():\n                        with self.hold_atom_types_data_changed():\n                            yield\n\n    @contextmanager\n    def hold_mixtures_needs_update(self):\n        logger.info(""Holding back all \'needs_update\' signals from Mixtures"")\n        with EventContextManager(*[mixture.needs_update.hold() for mixture in self.mixtures]):\n            yield\n\n    @contextmanager\n    def hold_mixtures_data_changed(self):\n        logger.info(""Holding back all \'data_changed\' signals from Mixtures"")\n        with EventContextManager(*[mixture.data_changed.hold() for mixture in self.mixtures]):\n            yield\n\n    @contextmanager\n    def hold_phases_data_changed(self):\n        logger.info(""Holding back all \'data_changed\' signals from Phases"")\n        with EventContextManager(*[phase.data_changed.hold() for phase in self.phases]):\n            yield\n\n    @contextmanager\n    def hold_atom_types_data_changed(self):\n        logger.info(""Holding back all \'data_changed\' signals from AtomTypes"")\n        with EventContextManager(*[atom_type.data_changed.hold() for atom_type in self.atom_types]):\n            yield\n\n    @contextmanager\n    def hold_specimens_data_changed(self):\n        logger.info(""Holding back all \'data_changed\' signals from Specimens"")\n        with EventContextManager(*[specimen.data_changed.hold() for specimen in self.specimens]):\n            yield\n\n    def update_all_mixtures(self):\n        """"""\n        Forces all mixtures in this project to update. If they have auto\n        optimization enabled, this will also optimize them. \n        """"""\n        for mixture in self.mixtures:\n            with self.data_changed.ignore():\n                mixture.update()\n\n    def get_mixtures_by_name(self, mixture_name):\n        """"""\n        Convenience method that returns all the mixtures who\'s name match the\n        passed name as a list.\n        """"""\n        return [mixture for mixture in self.mixtures if (mixture.name == mixture_name)]\n\n    # ------------------------------------------------------------\n    #      Specimen list related\n    # ------------------------------------------------------------\n    def move_specimen_up(self, specimen):\n        """"""\n        Move the passed :class:`~pyxrd.specimen.models.Specimen` up one slot.\n        Will raise and IndexError if the passed specimen is not in this project.\n        """"""\n        index = self.specimens.index(specimen)\n        self.specimens.insert(min(index + 1, len(self.specimens)), self.specimens.pop(index))\n\n    def move_specimen_down(self, specimen):\n        """"""\n        Move the passed :class:`~pyxrd.specimen.models.Specimen` down one slot\n        Will raise and IndexError if the passed specimen is not in this project.\n        """"""\n        index = self.specimens.index(specimen)\n        self.specimens.insert(max(index - 1, 0), self.specimens.pop(index))\n        pass\n\n    # ------------------------------------------------------------\n    #      Phases list related\n    # ------------------------------------------------------------\n    def load_phases(self, filename, parser, insert_index=0):\n        """"""\n        Loads all :class:`~pyxrd.phase.models.Phase` objects from the file\n        \'filename\'. An optional index can be given where the phases need to be\n        inserted at.\n        """"""\n        # make sure we have no duplicate UUID\'s\n        insert_index = not_none(insert_index, 0)\n        type(Project).object_pool.change_all_uuids()\n        for phase in parser.parse(filename):\n            phase.parent = self\n            self.phases.insert(insert_index, phase)\n            insert_index += 1\n\n    # ------------------------------------------------------------\n    #      AtomType\'s list related\n    # ------------------------------------------------------------\n    def load_atom_types(self, filename, parser):\n        """"""\n        Loads all :class:`~pyxrd.atoms.models.AtomType` objects from the\n        file specified by *filename*.\n        """"""\n        # make sure we have no duplicate UUID\'s\n        type(Project).object_pool.change_all_uuids()\n        for atom_type in parser.parse(filename):\n            atom_type.parent = self\n            self.atom_types.append(atom_type)\n\n    pass # end of class\n'"
pyxrd/project/views.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom pyxrd.generic.views import DialogView\n\nclass ProjectView(DialogView):\n    title = ""Edit Project""\n    subview_builder = resource_filename(__name__, ""glade/project.glade"")\n    subview_toplevel = ""nbk_edit_project""\n    resizable = False\n\n    widget_format = ""project_%s""\n\n    widget_groups = {\n        \'full_mode_only\': [\n            ""algn_calc_color"",\n            ""lbl_calccolor"",\n            ""algn_calc_lw"",\n            ""calc_lw_lbl""\n        ]\n    }\n\n    @property\n    def specimens_treeview_container(self):\n        return self[""vbox_specimens""]\n\n    @property\n    def specimens_treeview(self):\n        return self[""project_specimens""]\n\n    def __init__(self, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n        self[""popup_menu_item_add_specimen""].set_related_action(self.parent[""add_specimen""])\n        self[""popup_menu_item_edit_specimen""].set_related_action(self.parent[""edit_specimen""])\n        self[""popup_menu_item_import_specimens""].set_related_action(self.parent[""import_specimens""])\n        self[""popup_menu_item_replace_data""].set_related_action(self.parent[""replace_specimen_data""])\n        self[""popup_menu_item_export_data""].set_related_action(self.parent[""export_specimen_data""])\n        self[""popup_menu_item_del_specimen""].set_related_action(self.parent[""del_specimen""])\n\n    def present(self, *args, **kwargs):\n        super(ProjectView, self).present(*args, **kwargs)\n        self[""nbk_edit_project""].set_current_page(0)\n\n    def show_specimens_context_menu(self, event):\n        self[""specimen_popup""].popup(None, None, None, None, event.button, event.time)\n\n    def hide_specimens_context_menu(self):\n        self[""specimen_popup""].hide()\n\n    def set_x_range_sensitive(self, sensitive):\n        self[""box_manual_xrange""].set_sensitive(sensitive)\n\n    def set_y_range_sensitive(self, sensitive):\n        self[""box_manual_yrange""].set_sensitive(sensitive)\n\n    def set_selection_state(self, value):\n        if value is None:\n            self.hide_specimens_context_menu()\n        pass\n\n    pass # end of class\n'"
pyxrd/refinement/__init__.py,0,b''
pyxrd/refinement/async_evaluatable.py,0,"b'\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport functools\n\n\nfrom pyxrd.generic.asynchronous.cancellable import Cancellable\nfrom pyxrd.generic.asynchronous.has_async_calls import HasAsyncCalls\n\nclass AsyncEvaluatable(HasAsyncCalls, Cancellable):\n    \n    # self.refiner.get_pickled_data_object_for_solution\n\n    def do_async_evaluation(self, iter_func, eval_func, data_func, result_func):\n        """""" \n            Utility that combines a submit and fetch cycle in a single function\n            call.\n            iter_func is a generation callback (generates solutions)\n            data_func transforms the given solutions to something eval_func can \n              work with (this can be a pass-through operation)\n            eval_func evaluates a single (generated) solution (this must be\n              picklable)\n            result_func receives each solution and its residual as arguments\n            \n        """"""\n        assert callable(iter_func)\n        assert callable(eval_func)\n        assert callable(data_func)\n        assert callable(result_func)\n        \n        results = []\n        solutions = []\n        for solution in iter_func():\n            result = self.submit_async_call(functools.partial(\n                eval_func, data_func(solution)\n            ))\n            solutions.append(solution)\n            results.append(result)\n            if self._user_cancelled(): # Stop submitting new individuals\n                break\n            \n        for solution, result in zip(solutions, map(self.fetch_async_result, results)): \n            result_func(solution, result)\n        \n        del results\n        \n        # Run the garbage collector once for good measure\n        import gc\n        gc.collect()\n        \n        return solutions'"
pyxrd/refinement/parspace.py,19,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom traceback import format_exc\nimport itertools\nfrom math import sqrt\n\nimport logging\nfrom pyxrd.data import settings\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\nfrom scipy.interpolate.ndgriddata import griddata\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport mpl_toolkits.axes_grid1.axes_size as Size\nfrom mpl_toolkits.axes_grid1 import Divider\nfrom pyxrd.generic.mathtext_support import get_plot_safe\n\nclass ParameterSpaceGenerator(object):\n\n    num_cross_sections = 0\n    grid = None\n\n    def initialize(self, ranges, density):\n        """"""\n            Create a new generator with the given minimum and maximum values\n            and the given grid density (expressed as # of data points for that \n            parameter axis).\n        """"""\n\n        self.num_params = len(ranges)\n        assert self.num_params >= 1, ""Need to have at least one refinable parameter!""\n\n        ranges = np.asarray(ranges, dtype=float)\n\n        self.minima = np.asarray(ranges[:, 0])\n        self.maxima = np.asarray(ranges[:, 1])\n        self.center_point = 0.5 * (self.minima + self.maxima)\n\n        self.num_cross_sections = int(self.num_params * (self.num_params + 1) / 2)\n        self.grid_dtype = np.dtype([(""point"", object), (""value"", float), (""distance"", float)])\n        self.density = self._calculate_density(density)\n\n        if self.num_params == 1:\n            self.grid = np.empty(shape=(self.density,), dtype=self.grid_dtype)\n        else:\n            self.grid = np.empty(shape=(self.num_cross_sections, self.density, self.density), dtype=self.grid_dtype)\n\n    def _calculate_density(self, density, memory_limit=settings.PAR_SPACE_MEMORY_LIMIT):\n        block_size = self.grid_dtype.itemsize\n        limited = sqrt(memory_limit / (block_size * self.num_cross_sections))\n        return max(min(density, limited), 3)\n\n    def _find_closest_grid_index(self, solution):\n        """""" Returns the closest grid point\'s indexes """"""\n\n        # Transform solution so center of grid is zero point and min-max goes from -1 to +1\n        transf = (np.asarray(solution) - self.center_point) / (self.maxima - self.minima)\n\n        if self.num_params > 1:\n            # Calculate distance to each cross section and find closest\n            smallest_distance = None\n            closest_cross_section = None\n\n            for index, (par1, par2) in enumerate(itertools.combinations(list(range(self.num_params)), 2)):\n                # Project on to the normal of the A/B plan at the center point:\n                projected = transf.copy()\n                projected[par1] = 0\n                projected[par2] = 0\n                distance = np.linalg.norm(projected)\n                if smallest_distance is None or smallest_distance > distance:\n                    smallest_distance = distance\n                    closest_cross_section = index, (par1, par2), distance\n\n            index, (par1, par2), distance = closest_cross_section\n\n            # Move back to 0->density space (was in -1 -> 1 space)\n            gridded_location = np.array(np.round(0.5 * (transf + 1) * (self.density - 1)), dtype=int)\n            closest_index = (index, int(gridded_location[par1]), int(gridded_location[par2]))\n        else:\n            # Only a single parameter, so only a single index:\n            gridded_location = 0.5 * (transf + 1.0) * (self.density - 1.0)\n            distance = np.abs(np.round(gridded_location) - gridded_location)\n            closest_index = (int(np.round(gridded_location)[0]),)\n\n        return closest_index, distance\n\n    total_record_calls = 0\n    total_actual_records = 0\n\n    def record(self, new_solution, new_residual):\n        """"""\n            Add a new solution to the list of solutions\n        """"""\n        self.total_record_calls += 1\n        # Get the best spot to store this one:\n        closest_index, new_distance = self._find_closest_grid_index(new_solution)\n\n        old_item = self.grid[closest_index]\n        old_solution = old_item[""point""]\n        #old_residual = old_item[""value""]\n        old_distance = old_item[""distance""]\n\n        # If we have a previous point, check which one is closer:\n        if (old_solution is not None and old_solution[0] is not None) and new_distance > old_distance:\n            return\n        else:\n            self.total_actual_records += 1\n            # If we got here, we can store the result:\n            self.grid[closest_index] = (new_solution, new_residual, new_distance)\n\n    def clear(self):\n        del self.grid\n\n    def clear_image(self, figure, message=""Interpolation Error""):\n        figure.clear()\n        figure.text(0.5, 0.5, message, va=""center"", ha=""center"")\n\n    def _setup_image_grid(self, figure, dims):\n        """"""\n            An example of how grid, parameter and view numbers change\n            for dims = 4\n            \n            The numbers in the grid are:\n            \n            parameter x, parameter y\n            grid x, grid y\n        \n            -----------------------------------------------------\n            |            |            |            |            |\n            |    0, 0    |    1, 0    |    2, 0    |    3, 0    |\n            |    -, -    |    -, -    |    -, -    |    -, -    |\n            |            |            |            |            |\n            ==============------------|------------|------------|\n            I            I            |            |            |\n            I    0, 1    I    1, 1    |    2, 1    |    3, 1    |\n            I    0, 0    I    1, 0    |    2, 0    |    -, -    |\n            I            I            |            |            |\n            I------------==============------------|------------|\n            I            |            I            |            |\n            I    0, 2    |    1, 2    I    2, 2    |    3, 2    |\n            I    0, 1    |    1, 1    I    2, 1    |    -, -    |\n            I            |            I            |            |\n            I------------|------------==============------------|\n            I            |            |            I            |\n            I    0, 3    |    1, 3    |    2, 3    I    3, 3    |\n            I    0, 2    |    1, 2    |    2, 2    I    -, -    |\n            I            |            |            I            |\n            I======================================I------------|\n            From the above it should be clear that:\n            \n            parameter x = grid x\n            parameter y = grid y + 1\n            grid nr = grid y + grid x * (dims - 1)\n            view nr = grid nr - (grid nr / dims) * ((grid nr / dims) +1) / 2\n            \n\n        """"""\n        image_grid = ImageGrid(\n            figure, 111,\n            nrows_ncols=(dims - 1, dims - 1),\n            cbar_location=""right"",\n            cbar_mode=""single"",\n            # add_all=False,\n            aspect=False,\n            axes_pad=0.1,\n            direction=""column""\n        )\n\n        rect = (0.1, 0.1, 0.8, 0.8)\n        horiz = [Size.Fixed(.1)] + [Size.Scaled(1.), Size.Fixed(.1)] * max(dims - 1, 1) + [Size.Fixed(0.15)]\n        vert = [Size.Fixed(.1)] + [Size.Scaled(1.), Size.Fixed(.1)] * max(dims - 1, 1)\n\n        # divide the axes rectangle into grid whose size is specified by horiz * vert\n        divider = Divider(figure, rect, horiz, vert) # , aspect=False)\n\n        # Helper to get the axis for par x and y:\n        def get_grid(parx, pary):\n            gridx = parx\n            gridy = pary - 1\n            return image_grid[gridy + gridx * (dims - 1)]\n\n        # Helper to get the grid locator for par x and par y\n        def get_locator(parx, pary):\n            gridx = parx\n            gridy = pary - 1\n            nx = 1 + gridx * 2\n            ny = 1 + (dims - gridy - 2) * 2\n            return divider.new_locator(nx=nx, ny=ny)\n\n        # Hide the unused plots & setup the used ones:\n        for parx, pary in itertools.product(list(range(self.num_params - 1)), list(range(1, self.num_params))):\n\n            # Calculate the grid position:\n            ax = get_grid(parx, pary)\n\n            # Setup axes:\n            if pary <= parx:\n                ax.set_visible(False)\n            else:\n                ax.set_axes_locator(get_locator(parx, pary))\n                ax.set_visible(True)\n\n        return image_grid, divider, get_grid\n\n    def plot_images(self, figure, centroid, labels, density=200, smooth=0.5):\n        """"""\n            Generate the parameter space plots\n        """"""\n\n        try:\n\n            def extraxt_points_from_grid(grid2D, parx=None, pary=None):\n                """""" Helper function that extract x,y(,z) points from all the data """"""\n                grid2D = grid2D.flatten()\n                if parx is not None and pary is not None:\n                    points_x = np.array([item[""point""][parx] for item in grid2D if item[""point""] is not None])\n                    points_y = np.array([item[""point""][pary] for item in grid2D if item[""point""] is not None])\n                    points_z = np.array([item[""value""] for item in grid2D if item[""point""] is not None])\n                    return points_x, points_y, points_z\n                else:\n                    points_x = np.array([item[""point""] for item in grid2D if item[""point""] is not None])\n                    points_y = np.array([item[""value""] for item in grid2D if item[""point""] is not None])\n                    points_x = points_x.flatten()\n                    points_y = points_y.flatten()\n                    xy = np.array(list(zip(points_x, points_y)), dtype=[(\'x\', float), (\'y\', float)])\n                    xy.sort(order=[\'x\'], axis=0)\n                    points_x = xy[\'x\']\n                    points_y = xy[\'y\']\n                    return points_x, points_y\n\n            if self.num_params == 1:\n                # Only one parameter refined:\n                points_x, points_y = extraxt_points_from_grid(self.grid)\n                ax = figure.add_subplot(1, 1, 1)\n                ax.plot(points_x, points_y)\n                ax.set_ylabel(""Residual error"")\n                ax.set_xlabel(get_plot_safe(labels[0]))\n\n            else:\n                # Multi-parameter space:\n                image_grid, divider, get_grid = self._setup_image_grid(figure, self.num_params)\n\n                # Keep a reference to the images created,\n                # so we can add a scale bar for all images (and they have the same range)\n                ims = []\n                tvmin, tvmax = None, None\n\n                for index, (parx, pary) in enumerate(itertools.combinations(list(range(self.num_params)), 2)):\n                    # Get the data for this cross section:\n                    grid2D = self.grid[index, ...]\n                    points_x, points_y, points_z = extraxt_points_from_grid(grid2D, parx, pary)\n\n                    # Setup axis:\n                    ax = get_grid(parx, pary)\n                    extent = (\n                        self.minima[parx], self.maxima[parx],\n                        self.minima[pary], self.maxima[pary]\n                    )\n                    aspect = \'auto\'\n\n                    # Try to interpolate the data:\n                    xi = np.linspace(self.minima[parx], self.maxima[parx], density)\n                    yi = np.linspace(self.minima[pary], self.maxima[pary], density)\n                    zi = griddata((points_x, points_y), points_z, (xi[None, :], yi[:, None]), method=\'cubic\')\n\n                    # Plot it:\n                    im = ax.imshow(zi, origin=\'lower\', aspect=aspect, extent=extent, alpha=0.75)\n                    ims.append(im)\n                    im.set_cmap(\'gray_r\')\n\n                    # Get visual limits:\n                    vmin, vmax = im.get_clim()\n                    if index == 0:\n                        tvmin, tvmax = vmin, vmax\n                    else:\n                        tvmin, tvmax = min(tvmin, vmin), max(tvmax, vmax)\n\n                    # Try to add a contour & labels:\n                    try:\n                        ct = ax.contour(xi, yi, zi, colors=\'k\', aspect=aspect, extent=extent, origin=\'lower\')\n                        ax.clabel(ct, colors=\'k\', fontsize=10, format=""%1.2f"")\n                    except ValueError:\n                        pass #ignore the ""zero-size array"" error for now.\n\n                    # Add a red cross where the \'best\' solution is:\n                    ax.plot((centroid[parx],), (centroid[pary],), \'r+\')\n\n                    # Rotate x labels\n                    for lbl in ax.get_xticklabels():\n                        lbl.set_rotation(90)\n\n                    # Reduce number of ticks:\n                    ax.locator_params(axis=\'both\', nbins=5)\n\n                    # Set limits:\n                    ax.set_xlim(extent[0:2])\n                    ax.set_ylim(extent[2:4])\n\n                    # Add labels to the axes so the user knows which is which:\n                    # TODO add some flags/color/... indicating which phase & component each parameter belongs to...\n                    if parx == 0:\n                        ax.set_ylabel(str(""#%d "" % (pary + 1)) + get_plot_safe(labels[pary]))\n                    if pary == (self.num_params - 1):\n                        ax.set_xlabel(str(""#%d "" % (parx + 1)) + get_plot_safe(labels[parx]))\n\n                # Set the data limits:\n                for im in ims:\n                    im.set_clim(tvmin, tvmax)\n\n                # Make it look PRO:\n                if im is not None:\n                    cbar_ax = image_grid.cbar_axes[0]\n                    nx = 1 + (self.num_params - 1) * 2\n                    ny1 = (self.num_params - 1) * 2\n                    cbar_ax.set_axes_locator(divider.new_locator(nx=nx, ny=1, ny1=ny1))\n                    cb = cbar_ax.colorbar(im) # @UnusedVariable\n\n        except:\n            print(""Unhandled exception while generating parameter space images:"")\n            print(format_exc())\n            # ignore error, tell the user via the plot and return\n            self.clear_image(figure)\n            return\n\n    pass #end of class\n'"
pyxrd/refinement/refine_async_helper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.refinement.async_evaluatable import AsyncEvaluatable\n\nclass RefineAsyncHelper(AsyncEvaluatable):\n    """"""\n        Helper class which can help classes having a refiner object\n        \n    """"""\n    def do_async_evaluation(self, iter_func, eval_func=None, data_func=None, result_func=None):\n        assert self.refiner is not None, ""RefineAsyncHelper can only work when a refiner is set!""\n        eval_func = not_none(eval_func, self.refiner.residual_callback)\n        data_func = not_none(data_func, self.refiner.get_data_object)\n        result_func = not_none(result_func, self.refiner.update)\n        return super(RefineAsyncHelper, self).do_async_evaluation(\n            iter_func, eval_func, data_func, result_func\n        )'"
pyxrd/refinement/refine_history.py,9,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np \n\nclass RefineHistory(object):\n    """"""\n    A history tracking class for refinements\n    """"""\n    \n    INITIAL_ITERATION_INDEX = -1\n    LAST_ITERATION_INDEX = -1\n    \n    ITERATION_INDEX = 0\n    RESIDUAL_INDEX = -1\n    SOLUTION_SELECTOR = np.s_[ITERATION_INDEX+1:RESIDUAL_INDEX]\n    PLOT_SAMPLE_SELECTOR = np.s_[ITERATION_INDEX+1:]\n    \n    samples = None\n    \n    _closed = False\n    \n    @property\n    def best_entry(self):\n        if self._closed:\n            samples = self.samples\n        else:\n            samples = np.asanyarray(self.samples)\n        residuals = samples[:,self.RESIDUAL_INDEX]\n        return samples[np.where(residuals == residuals.min()),:][-1].flatten()\n    \n    @property\n    def initial_entry(self):\n        if self._closed:\n            samples = self.samples\n        else:\n            samples = np.asanyarray(self.samples)\n        iterations = samples[:,self.ITERATION_INDEX]       \n        return samples[np.where(iterations == self.INITIAL_ITERATION_INDEX),:][-1].flatten()\n    \n    @property\n    def last_entry(self):\n        if self._closed:\n            samples = self.samples\n        else:\n            samples = np.asanyarray(self.samples)\n        iterations = samples[:,self.ITERATION_INDEX]\n        return samples[np.where(iterations == self.LAST_ITERATION_INDEX),:][-1].flatten()\n    \n    @property\n    def best_solution(self):\n        return self.best_entry[self.SOLUTION_SELECTOR].flatten()\n    \n    @property\n    def initial_solution(self):\n        return self.initial_entry[self.SOLUTION_SELECTOR]\n    \n    @property\n    def last_solution(self):\n        return self.last_entry[self.SOLUTION_SELECTOR]\n\n    @property\n    def initial_residual(self):\n        return float(self.initial_entry[self.RESIDUAL_INDEX])\n\n    @property\n    def best_residual(self):\n        return float(self.best_entry[self.RESIDUAL_INDEX])\n    \n    @property\n    def last_residual(self):\n        return float(self.last_entry[self.RESIDUAL_INDEX])\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self):\n        self.samples = []\n\n    def _sort_solutions_by_iteration(self):\n        self.samples.sort(key=lambda s: s[0])\n    \n    # ------------------------------------------------------------\n    #      ContextManager implementation\n    # ------------------------------------------------------------    \n    def close(self):\n        self._closed = True\n        self._sort_solutions_by_iteration()\n        self.samples = np.asanyarray(self.samples)\n    \n    def __enter__(self):\n        assert self._closed is False, ""Cannot use a closed refinement history!""\n        return self\n    \n    def __exit__(self, tp, value, traceback):\n        self.close()\n\n    # ------------------------------------------------------------\n    #      Solution registration:\n    # ------------------------------------------------------------    \n    def set_initial_solution(self, solution, residual):\n        if self._closed:\n            raise RuntimeError(""Cannot change a closed refinement history!"")\n        self.register_solution(self.INITIAL_ITERATION_INDEX, solution, residual)\n        \n    def register_solution(self, iteration, solution, residual):\n        if self._closed:\n            raise RuntimeError(""Cannot change a closed refinement history!"")\n        sample = [iteration,]+list(solution)+[residual,]\n        self.samples.append(sample)\n        if iteration > self.LAST_ITERATION_INDEX:\n            self.LAST_ITERATION_INDEX = iteration\n            \n    def get_residual_per_iteration(self):\n        if not self._closed:\n            raise RuntimeError(""Cannot perform analysis on an open refinement history"")\n        return self.samples[:,[self.ITERATION_INDEX,self.RESIDUAL_INDEX]].tolist()\n        \n    pass #end of class\n        '"
pyxrd/refinement/refine_method.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom .refine_method_meta import RefineMethodMeta\nfrom .refine_async_helper import RefineAsyncHelper\n\nfrom pyxrd.calculations.mixture import get_optimized_residual\n\nclass RefineMethod(RefineAsyncHelper, metaclass=RefineMethodMeta):\n    \n    """"""\n        The `RefineMethod` class is the base class for refinement methods.\n        Sub-classes will be registered in the metaclass.\n    """"""\n\n    name = ""Name of the algorithm""\n\n    description = ""A slightly longer explanation of algorithm""\n\n    # The value of this index is important;\n    # Some ranges are reserved to prevent immediate overlaps:\n    #  - negative values should not be used (not enforced)\n    #  - the range 0 - 999 is reserved for built-in methods\n    #  - all other values can be used for third-party methods, it is up to the\n    #    final user to check if they don\'t overlap. If these methods become\n    #    a built-in method, they\'ll receive a new index in the preserved range\n    index = -1\n\n    disabled = True\n    \n    residual_callback = property(fget=lambda *s: get_optimized_residual)\n\n    def __call__(self, refiner, stop=None, **kwargs):\n\n        self._stop = stop\n\n        options = self.get_options()\n        for arg in self.options:\n            options[arg] = kwargs.get(arg, getattr(self, arg))\n\n        return self.run(refiner, **options)\n\n    def run(self, refiner, **kwargs):\n        raise NotImplementedError(""The run method of RefineRun should be implemented by sub-classes..."")\n\n    def get_options(self):\n        """""" Returns a dict containing the option attribute names as keys and\n        their values as values """"""\n        return { name: getattr(self, name) for name in self.options }\n\n    pass #end of class\n'"
pyxrd/refinement/refine_method_manager.py,0,"b'from pyxrd.refinement.refine_method_meta import RefineMethodMeta\n\nfrom .methods import *  # @UnusedWildImport\n\nclass RefineMethodManager(object):\n    \n    @classmethod\n    def initialize_methods(cls, refine_options):\n        """"""\n            Returns a dict of refine methods as values and their index as key\n            with the passed refine_options dict applied.\n        """"""\n        # 1. Create a list of refinement instances:\n        refine_methods = {}\n        for index, method in cls.get_all_methods().items():\n            refine_methods[index] = method()\n\n        # 2. Create dict of default options\n        default_options = {}\n        for method in list(refine_methods.values()):\n            default_options[method.index] = {\n                name: getattr(type(method), name).default for name in method.options\n            }\n\n        # 3. Apply the refine options to the methods\n        if not refine_options == None:\n            for index, options in zip(list(refine_options.keys()), list(refine_options.values())):\n                index = int(index)\n                if index in refine_methods:\n                    method = refine_methods[index]\n                    for arg, value in zip(list(options.keys()), list(options.values())):\n                        if hasattr(method, arg):\n                            setattr(method, arg, value)\n\n        return refine_methods\n    \n    @classmethod\n    def get_all_methods(cls):\n        """""" Returns all the registered refinement methods """"""\n        return RefineMethodMeta.registered_methods\n    \n    @classmethod\n    def get_method_from_index(cls, index):\n        """""" Returns the actual refinement method defined by the index """"""\n        return cls.get_all_methods()[index]\n    \n    pass # end of class'"
pyxrd/refinement/refine_method_meta.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom .refine_method_option import RefineMethodOption\n\nclass RefineMethodMeta(type):\n    """"""\n        The metaclass for creating a RefineMethod (sub)class\n        Will register the class type so we can build a list of RefineMethod \n        classes dynamically.\n        If the (sub)class does not want to be registered, it should set\n        the \'disabled\' class attribute to True.\n    """"""\n    registered_methods = {}\n\n    def __new__(meta, name, bases, class_dict):  # @NoSelf\n        options = []\n        for name, value in class_dict.items():\n            if isinstance(value, RefineMethodOption):\n                options.append(name)\n                setattr(value, \'label\', name)\n        class_dict[\'options\'] = options\n\n        cls = type.__new__(meta, name, bases, class_dict)\n\n        if not getattr(cls, \'disabled\', False):\n            meta.registered_methods[getattr(cls, \'index\')] = cls\n\n        return cls\n\n    pass #end of class\n'"
pyxrd/refinement/refine_method_option.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass RefineMethodOption(object):\n    """""" Descriptor for refinement methods """"""\n    # TODO MERGE THIS WITH THE DESCRIPTORS FROM THE OTHER BRANCH\n\n    label = None\n\n    def __init__(self, description, default=None, limits=[None, None], value_type=object, fget=None, fset=None, fdel=None, doc=None, label=None):\n        self.description = description\n        self.limits = limits\n        self.value_type = value_type\n\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        if doc is None and fget is not None:\n            doc = fget.__doc__\n        self.__doc__ = doc\n\n        self.label = label\n        self.default = default\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        if self.fget is None:\n            return getattr(instance, ""_%s"" % self.label, self.default)\n        else:\n            return self.fget(instance)\n\n    def __set__(self, instance, value):\n        _min, _max = self.limits\n        if self.value_type in (str, int, float): value = self.value_type(value)\n        if _min is not None: value = max(value, _min)\n        if _max is not None: value = min(value, _max)\n\n        if self.fset is None:\n            setattr(instance, ""_%s"" % self.label, value)\n        else:\n            return self.fset(instance, value)\n\n    def __delete__(self, instance):\n        if self.fdel is None:\n            raise AttributeError(""can\'t delete attribute"")\n        self.fdel(instance)\n\n    pass # end of class\n'"
pyxrd/refinement/refine_status.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\nimport time\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass RefineStatus(object):\n    """"""\n    A status object for a refinement. This should provide some hints\n    for the UI to keep track of the status of the refinement.\n    \n    The error, running and finished flags are mutually exclusive but can be\n    False together. When the cancelled flag is set, the user cancelled the\n    refinement (the stop signal was set). When the error flag is true, an error\n    was encountered during the refinement. When the finished flag is true the \n    refinement has finished successfully. When the running flag is true the \n    refinement is still running. When all three flags are False, the refinement \n    has not started yet.\n    \n    The status message should be a textual description of these three flags,\n    but can be set to any value.\n    \n    The current error is retrieved from the RefinementHistory instance passed\n    in the constructor (it is the residual of the last solution registered).\n    \n    The best way to use the status object is with a context, like this:\n    \n     with RefineHistory() as history:\n         with RefineStatus(history) as status:\n             run_refinement()\n             \n    """"""\n    \n    _error = False\n    @property\n    def error(self):\n        return self._error\n    @error.setter\n    def error(self, value):\n        self._error = bool(value)\n        if self._error: \n            self.running = False\n            self.cancelled = False\n            self.finished = False\n    \n    _cancelled = False\n    @property\n    def cancelled(self):\n        return self._cancelled\n    @cancelled.setter\n    def cancelled(self, value):\n        self._cancelled = bool(value)\n        if self._cancelled: \n            self.running = False\n            self.error = False\n            self.finished = False\n    \n    _running = False\n    @property\n    def running(self):\n        return self._running\n    @running.setter\n    def running(self, value):\n        self._running = bool(value)\n        if self._running: \n            self.error = False\n            self.cancelled = False\n            self.finished = False\n        \n    _finished = False\n    @property\n    def finished(self):\n        return self._finished\n    @finished.setter\n    def finished(self, value):\n        self._finished = bool(value)\n        if self._finished:\n            self.error = False\n            self.cancelled = False\n            self.running = False\n     \n    message = ""Not initialized.""\n    \n    @property\n    def current_error(self):\n        return self.history.last_solution[self.history.RESIDUAL_INDEX]\n    \n    def __init__(self, history, stop_signal=None):\n        assert history is not None, ""The RefinementStatus needs a RefinementHistory instance!""\n        self.history = history\n        self.stop_signal = stop_signal\n        self.message = ""Initialized.""\n        \n        self.start_time = -1\n        self.end_time = -1\n    \n    def __enter__(self):\n        # Set flag\n        self.running = True\n        # Set message\n        self.message = ""Running...""\n        # Record start time\n        self.start_time = time.time()\n        # Return us\n        return self\n        \n    def __exit__(self, tp, value, traceback):\n        # Record end time\n        self.start_time = -1\n\n        if tp is not None:\n            self.message = ""Refinement error!""\n            self.error = True\n        else:\n            if self.stop_signal is not None and self.stop_signal.is_set():            \n                self.message = ""Refinement cancelled!""\n                self.cancelled = True\n            else:\n                self.message = ""Refinement finished!""\n                self.finished = True\n    \n    def get_total_time(self):\n        """""" Gets the total time the refinement has run in ms """"""\n        if self.start_time == -1:\n            return 0\n        else:\n            return (self.end_time - self.start_time) * 1000.0\n    \n    pass #end of class'"
pyxrd/refinement/refinement.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport random\n\nfrom mvc.models.properties import (\n    LabeledProperty, ListProperty, IntegerChoiceProperty, BoolProperty,\n    ReadOnlyMixin\n)\nfrom mvc.models import TreeNode\n\nfrom pyxrd.generic.models.event_context_manager import EventContextManager\nfrom pyxrd.generic.models.properties import InheritableMixin\nfrom pyxrd.generic.models import ChildModel\n\nfrom .refinables.mixins import RefinementValue, RefinementGroup\nfrom .refinables.wrapper import RefinableWrapper\nfrom .refine_method_manager import RefineMethodManager\nfrom .refiner import Refiner\n\nclass Refinement(ChildModel):\n    """"""\n        A simple model that plugs onto the Mixture model. It provides\n        the functionality related to refinement of parameters.\n    """"""\n\n    # MODEL INTEL:\n    class Meta(ChildModel.Meta):\n        store_id = ""Refinement""\n\n    mixture = property(ChildModel.parent.fget, ChildModel.parent.fset)\n\n    #: Flag, True if after refinement plots should be generated of the parameter space\n    make_psp_plots = BoolProperty(\n        default=False, text=""Make parameter space plots"",\n        tabular=False, visible=True, persistent=True\n    )\n\n    #: TreeNode containing the refinable properties\n    refinables = ListProperty(\n        default=None, text=""Refinables"",\n        tabular=True, persistent=False, visible=True, \n        data_type=RefinableWrapper,\n        cast_to=None, widget_type=""object_tree_view""\n    )\n\n    #: A dict containing an instance of each refinement method\n    refine_methods = None\n\n\n    #: An integer describing which method to use for the refinement\n    refine_method_index = IntegerChoiceProperty(\n        default=0, text=""Refinement method index"",\n        tabular=True, persistent=True, visible=True,\n        choices={ key: method.name for key, method in RefineMethodManager.get_all_methods().items() }\n    )\n\n    #: A dict containing the current refinement options\n    @LabeledProperty(\n        default=None, text=""Refine options"",\n        persistent=False, visible=False,\n        mix_with=(ReadOnlyMixin,)\n    )\n    def refine_options(self):\n        return self.get_refinement_method().get_options()\n    \n    #: A dict containing all refinement options\n    @property\n    def all_refine_options(self):\n        return {\n            method.index : method.get_options()\n            for method in list(self.refine_methods.values())\n        }\n\n    def __init__(self, *args, **kwargs):\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""refine_method_index"", ""refine_method"", ""refine_options""\n        )\n        super(Refinement, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        # Setup the refinables treestore\n        self.refinables = TreeNode()\n        self.update_refinement_treestore()\n\n        # Setup the refine methods\n        try:\n            self.refine_method_index = int(self.get_kwarg(kwargs, None, ""refine_method_index"", ""refine_method""))\n        except ValueError:\n            self.refine_method_index = self.refine_method_index\n            pass # ignore faulty values, these indices change from time to time.\n\n        self.refine_methods = RefineMethodManager.initialize_methods(\n            self.get_kwarg(kwargs, None, ""refine_options"")\n        )\n\n    # ------------------------------------------------------------\n    #      Refiner methods\n    # ------------------------------------------------------------\n    def get_refiner(self):\n        """"""\n            This returns a Refiner object which can be used to refine the\n            selected properties using the selected algorithm.\n            Just call \'refine(stop)\' on the returned object, with stop a\n            threading.Event or multiprocessing.Event which you can use to stop\n            the refinement before completion.\n            The Refiner object also has a RefineHistory and RefineStatus object\n            that can be used to track the status and history of the refinement.\n        """""" \n       \n        return Refiner(\n            method            = self.get_refinement_method(),\n            data_callback     = lambda: self.mixture.data_object,\n            refinables        = self.refinables,\n            event_cmgr        = EventContextManager(self.mixture.needs_update, self.mixture.data_changed),\n            metadata          = dict(\n                phases          = self.mixture.phases,\n                num_specimens   = len(self.mixture.specimens),\n            )\n        )\n\n    # ------------------------------------------------------------\n    #      Refinement Methods Management\n    # ------------------------------------------------------------\n    def get_refinement_method(self):\n        """"""\n            Returns the actual refinement method by translating the \n            `refine_method` attribute\n        """"""\n        return self.refine_methods[self.refine_method_index]\n\n    # ------------------------------------------------------------\n    #      Refinables Management\n    # ------------------------------------------------------------\n    # TODO set a restrict range attribute on the PropIntels, so we can use custom ranges for each property\n    def auto_restrict(self):\n        """"""\n            Convenience function that restricts the selected properties \n            automatically by setting their minimum and maximum values.\n        """"""\n        with self.mixture.needs_update.hold():\n            for node in self.refinables.iter_children():\n                ref_prop = node.object\n                if ref_prop.refine and ref_prop.refinable:\n                    ref_prop.value_min = ref_prop.value * 0.8\n                    ref_prop.value_max = ref_prop.value * 1.2\n\n    def randomize(self):\n        """"""\n            Convenience function that randomize the selected properties.\n            Respects the current minimum and maximum values.\n            Executes an optimization after the randomization.\n        """"""\n        with self.mixture.data_changed.hold_and_emit():\n            with self.mixture.needs_update.hold_and_emit():\n                for node in self.refinables.iter_children():\n                    ref_prop = node.object\n                    if ref_prop.refine and ref_prop.refinable:\n                        ref_prop.value = random.uniform(ref_prop.value_min, ref_prop.value_max)\n\n    def update_refinement_treestore(self):\n        """"""\n            This creates a tree store with all refinable properties and their\n            minimum, maximum and current value.\n        """"""\n        if self.parent is not None: # not linked so no valid phases!\n            self.refinables.clear()\n\n            def add_property(parent_node, obj, prop, is_grouper):\n                rp = RefinableWrapper(obj=obj, prop=prop, parent=self.mixture, is_grouper=is_grouper)\n                return parent_node.append(TreeNode(rp))\n\n            def parse_attribute(obj, prop, root_node):\n                """"""\n                    obj: the object\n                    attr: the attribute of obj or None if obj contains attributes\n                    root_node: the root TreeNode new iters should be put under\n                """"""\n                if prop is not None:\n                    if isinstance(prop, InheritableMixin):\n                        value = prop.get_uninherited(obj)\n                    else:\n                        value = getattr(obj, prop.label)\n                else:\n                    value = obj\n\n                if isinstance(value, RefinementValue): # AtomRelation and UnitCellProperty\n                    new_node = add_property(root_node, value, prop, False)\n                elif hasattr(value, ""__iter__""): # List or similar\n                    for new_obj in value:\n                        parse_attribute(new_obj, None, root_node)\n                elif isinstance(value, RefinementGroup): # Phase, Component, Probability\n                    if len(value.refinables) > 0:\n                        new_node = add_property(root_node, value, prop, True)\n                        for prop in value.refinables:\n                            parse_attribute(value, prop, new_node)\n                else: # regular values\n                    new_node = add_property(root_node, obj, prop, False)\n\n            for phase in self.mixture.project.phases:\n                if phase in self.mixture.phase_matrix:\n                    parse_attribute(phase, None, self.refinables)\n\n\n    pass # end of class\n'"
pyxrd/refinement/refiner.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\n\nfrom .refine_history import RefineHistory\nfrom .refine_status import RefineStatus\n\nclass RefineSetupError(ValueError):\n    """""" Raised if an error exists in the refinement setup """"""\n    pass\n\nclass Refiner(object):\n    """"""\n        A model for the refinement procedure.\n    """"""\n\n    method = None\n    \n    history = None\n    status = None\n\n    refinables = None\n\n    def __init__(self, method, data_callback, refinables, event_cmgr, metadata={}):\n        super(Refiner, self).__init__()\n        \n        assert method is not None, ""Cannot refine without a refinement method!""\n        residual_callback = method.residual_callback\n        assert callable(residual_callback), ""Cannot refine without a residual callback!""\n        assert callable(data_callback), ""Cannot refine without a data callback!""\n        assert refinables is not None, ""Cannot refine without refinables!""\n        assert event_cmgr is not None, ""Cannot refine without an event context manager!""\n        \n        # Set these:\n        self.method = method\n        self.residual_callback = residual_callback\n        self.data_callback = data_callback\n        self.event_cmgr = event_cmgr\n        self.metadata = metadata\n\n        # Create the refinement history object:\n        logger.info(""Setting up the refinement history."") \n        self.history = RefineHistory()\n\n        # Create the refinement status object:\n        logger.info(""Setting up the refinement status object."")        \n        self.status = RefineStatus(self.history)\n\n        # Setup the refinable property list:\n        logger.info(""Refinement with the following refinables:"")\n        self.refinables = []\n        self.ranges = ()\n        self.labels = ()\n        initial_values = []\n        for node in refinables.iter_children():\n            refinable = node.object\n            if refinable.refine and refinable.refinable:\n                logger.info("" - %s from %r"" % (refinable.text_title, refinable.obj))\n                self.refinables.append(refinable)\n                initial_values.append(refinable.value)\n                if not (refinable.value_min < refinable.value_max):\n                    logger.info(""Error in refinement setup!"")\n                    self.status.error = True\n                    self.status.message = ""Invalid parameter range for \'%s\'!"" % (refinable.text_descriptor,)\n                    raise RefineSetupError(""Invalid parameter range for \'%s\'!"" % (refinable.text_descriptor,))\n                self.ranges += ((refinable.value_min, refinable.value_max),)\n                self.labels += ((refinable.text_title, refinable.title),)\n\n        # Make sure we can refine something:\n        if len(self.refinables) == 0:\n            logger.error(""No refinables selected!"")\n            self.status.error = True\n            self.status.message = ""No parameters selected!""\n            raise RefineSetupError(""No parameters selected!"")      \n\n        # Register the initial solution:\n        initial_solution = np.array(initial_values, dtype=float)\n        self.history.set_initial_solution(\n            initial_solution,\n            self.get_history_residual(self.get_residual(initial_solution))\n        )\n\n    def apply_solution(self, solution):\n        """"""\n            Applies the given solution\n        """"""\n        solution = np.asanyarray(solution)\n        with self.event_cmgr.hold():\n            for i, ref_prop in enumerate(self.refinables):\n                if not (solution.shape == ()):\n                    ref_prop.value = float(solution[i])\n                else:\n                    ref_prop.value = float(solution[()])\n\n    def get_data_object(self, solution):\n        """"""\n            Gets the mixture data object after setting the given solution\n        """"""\n        with self.event_cmgr.ignore():\n            self.apply_solution(solution)\n            return self.data_callback()\n        \n    def get_residual(self, solution):\n        """"""\n            Gets the residual for the given solution after setting it\n        """"""\n        return self.residual_callback(self.get_data_object(solution))\n\n    def get_history_residual(self, residual):\n        try:\n            return residual[0]\n        except IndexError:\n            return residual \n\n    def update(self, solution, residual=None, iteration=0):\n        """"""\n            Update\'s the refinement contect with the given solution:\n                - applies the solution & gets the residual if not given\n                - stores it in the history\n        """"""\n        residual = self.get_history_residual(\n            residual if residual is not None else self.get_residual(solution)\n        )\n        self.history.register_solution(iteration, solution, residual)\n\n    def apply_best_solution(self):\n        self.apply_solution(self.history.best_solution)\n\n    def apply_last_solution(self):\n        self.apply_solution(self.history.last_solution)\n\n    def apply_initial_solution(self):\n        self.apply_solution(self.history.initial_solution)\n    \n    def get_plot_samples(self):\n        return self.history.samples[:,self.history.PLOT_SAMPLE_SELECTOR]\n    \n    def get_plot_labels(self):\n        return [plot_label for plot_label, _ in self.labels] + [""Rp"",]\n    \n    def refine(self, stop):       \n        # Suppress updates:\n        with self.event_cmgr.hold():\n            # Make sure the stop signal is not set from a previous run:\n            stop.clear()\n\n            # Log some information:\n            logger.info(""-""*80)\n            logger.info(""Starting refinement with this setup:"")\n            msg_frm = ""%22s: %s""\n            logger.info(msg_frm % (""refinement method"", self.method))\n            logger.info(msg_frm % (""number of parameters"", len(self.refinables)))\n\n            # Run the refinement:\n            with self.status:\n                with self.history:\n                    self.method(self, stop=stop)\n\n            # Log some more information:\n            logger.info(\'Total refinement took %0.3f ms\' % self.status.get_total_time())\n            logger.info(\'Best solution found was:\')                \n            for i, ref_prop in enumerate(self.refinables):\n                logger.info(""%25s: %f"" % (\n                    ref_prop.text_descriptor, \n                    self.history.best_solution[i]\n                ))\n            logger.info(""-""*80)\n                \n            # Return us to whatever called this\n            return self\n        \n    pass # end of class\n'"
pyxrd/scripts/__init__.py,0,b''
pyxrd/scripts/generate_default_phases.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nfrom pyxrd.data import settings\n\nfrom pyxrd.project.models import Project\nfrom pyxrd.phases.models import Component, Phase\n\ndef generate_expandables(\n            filename_format, phase_name, maxR,\n            phase_kwargs_AD, phase_kwargs_EG, phase_kwargs_350,\n            code_AD, code_EG, code_350,\n            comp_kwargs_AD, comp_kwargs_EG, comp_kwargs_350):\n        """"""\n            Generates a list of phase descriptions for a combination of an\n            AD, EG and 350\xc2\xb0 Ca-saturated phase linked together\n        """"""\n        return [\n            (\'%s\' + (filename_format % R), [\n                    (dict(R=R, name=phase_name + (\' R%d Ca-AD\' % R), **phase_kwargs_AD), code_AD, comp_kwargs_AD),\n                    (dict(R=R, name=phase_name + (\' R%d Ca-EG\' % R), based_on=phase_name + (\' R%d Ca-AD\' % R), **phase_kwargs_EG), code_EG, comp_kwargs_EG),\n                    (dict(R=R, name=phase_name + (\' R%d Ca-350\' % R), based_on=phase_name + (\' R%d Ca-AD\' % R), **phase_kwargs_350), code_350, comp_kwargs_350)\n            ]) for R in range(maxR)\n        ]\n\ndef run(args=None, ui_callback=None):\n\n    """""" \n    How this script works:\n    \n     - \'code_length\' is the length of the aliases keys (see below)\n     - \'aliases\' is a dictionary contain 4-character long keys describing a\n        specific layer-type (or with other words: a Component object)\n        E.g. dS2w stands for Di-octahedral Smectite with 2 layers of water.\n        The values are file path formats, in which a single \'%s\' string placeholder\n        will be filled with the absolute path to the default components folder.  \n     - \'default_phases\' is an initially empty list that will be filled with two-\n        tuples. The first element in this tuple is the filename of the generated\n        phases, the second element is describing what this phase contains. This\n        second element is again a tuple, containing three parts:\n            - A dictionary of key-word arguments passed on to the Phase\n              constructor. If a \'based_on\' keyword is defined, an attempt is\n              made to translate it to an earlier generated phase. This way, it\n              is possible to pass the name of an earlier generated phase, and\n              the script will pass in the actual Phase object instead.\n            - A component code (string) built by the keys of the \'aliases\'\n              dictionary. This string\'s length should be a multiple of \'code_length\'.\n              There is no separator, rather, the \'code_length\' is used to split the\n              code into its parts.   \n            - Component keyword arguments dictionaries: this is a dictionary in\n              which the keys match with the components code parts. The values are\n              property-value dictionaries used to set Component properties after\n              importing them. Similarly to the Phases\' \'based_on\' keyword, the\n              value for the \'linked_with\' key is translated to the actual\n              Component named as such.   \n     \n    ### Setup:\n    """"""\n    code_length = 4\n    aliases = {\n        \'C   \': \'%sChlorite.cmp\',\n        \'K   \': \'%sKaolinite.cmp\',\n        \'I   \': \'%sIllite.cmp\',\n        \'Se  \': \'%sSerpentine.cmp\',\n        \'T   \': \'%sTalc.cmp\',\n        \'Ma  \': \'%sMargarite.cmp\',\n        \'Pa  \': \'%sParagonite.cmp\',\n        \'L   \': \'%sLeucophyllite.cmp\',\n        \'dS2w\': \'%sDi-Smectite/Di-Smectite - Ca 2WAT.cmp\',\n        \'dS1w\': \'%sDi-Smectite/Di-Smectite - Ca 1WAT.cmp\',\n        \'dS0w\': \'%sDi-Smectite/Di-Smectite - Ca Dehydr.cmp\',\n        \'dS2g\': \'%sDi-Smectite/Di-Smectite - Ca 2GLY.cmp\',\n        \'dS1g\': \'%sDi-Smectite/Di-Smectite - Ca 1GLY.cmp\',\n        \'dSht\': \'%sDi-Smectite/Di-Smectite - Ca Heated.cmp\',\n        \'tS2w\': \'%sTri-Smectite/Tri-Smectite - Ca 2WAT.cmp\',\n        \'tS1w\': \'%sTri-Smectite/Tri-Smectite - Ca 1WAT.cmp\',\n        \'tS0w\': \'%sTri-Smectite/Tri-Smectite - Ca Dehydr.cmp\',\n        \'tS2g\': \'%sTri-Smectite/Tri-Smectite - Ca 2GLY.cmp\',\n        \'tS1g\': \'%sTri-Smectite/Tri-Smectite - Ca 1GLY.cmp\',\n        \'tSht\': \'%sTri-Smectite/Tri-Smectite - Ca Heated.cmp\',\n        \'dV2w\': \'%sDi-Vermiculite/Di-Vermiculite - Ca 2WAT.cmp\',\n        \'dV1w\': \'%sDi-Vermiculite/Di-Vermiculite - Ca 1WAT.cmp\',\n        \'dV0w\': \'%sDi-Vermiculite/Di-Vermiculite - Ca Dehydr.cmp\',\n        \'dV2g\': \'%sDi-Vermiculite/Di-Vermiculite - Ca 2GLY.cmp\',\n        \'dV1g\': \'%sDi-Vermiculite/Di-Vermiculite - Ca 1GLY.cmp\',\n        \'dVht\': \'%sDi-Vermiculite/Di-Vermiculite - Ca Heated.cmp\',\n    }\n    default_phases = []\n\n    """""" \n    ### Commonly used inherit flag dicts:\n    """"""\n    inherit_S = dict(\n        inherit_ucp_a=True,\n        inherit_ucp_b=True,\n        inherit_delta_c=True,\n        inherit_layer_atoms=True,\n    )\n\n    inherit_all = dict(\n        inherit_d001=True,\n        inherit_default_c=True,\n        inherit_interlayer_atoms=True,\n        inherit_atom_relations=True,\n        **inherit_S\n    )\n\n    inherit_phase = dict(\n        inherit_display_color=True,\n        inherit_sigma_star=True,\n        inherit_CSDS_distribution=True,\n        inherit_probabilities=True\n    )\n\n    """""" \n    ### Single-layer phases:\n    """"""\n    default_phases += [\n        (\'%sKaolinite.phs\', [(dict(R=0, name=\'Kaolinite\'), \'K   \', {}), ]),\n        (\'%sIllite.phs\', [(dict(R=0, name=\'Illite\'), \'I   \', {})]),\n        (\'%sSerpentine.phs\', [(dict(R=0, name=\'Serpentine\'), \'Se  \', {})]),\n        (\'%sTalc.phs\', [(dict(R=0, name=\'Talc\'), \'T   \', {})]),\n        (\'%sChlorite.phs\', [(dict(R=0, name=\'Chlorite\'), \'C   \', {})]),\n        (\'%sMargarite.phs\', [(dict(R=0, name=\'Margarite\'), \'Ma  \', {})]),\n        (\'%sLeucophyllite.phs\', [(dict(R=0, name=\'Leucophyllite\'), \'L   \', {})]),\n        (\'%sParagonite.phs\', [(dict(R=0, name=\'Paragonite\'), \'Pa  \', {})]),\n    ]\n\n    """"""      \n    ### Dioctahedral smectites:\n    """"""\n    S_code_AD = \'dS2w\'\n    S_code_EG = \'dS2g\'\n    S_code_350 = \'dSht\'\n    S_inh_comp_args = {\n        \'dS2g\': dict(linked_with=\'dS2w\', **inherit_S),\n        \'dSht\': dict(linked_with=\'dS2w\', **inherit_S),\n    }\n\n    SS_code_AD = S_code_AD + \'dS1w\'\n    SS_code_EG = S_code_EG + \'dS1g\'\n    SS_code_350 = S_code_350 + \'dS1g\'\n    SS_inh_comp_args = dict(S_inh_comp_args)\n    SS_inh_comp_args.update({\n        \'dS1g\': dict(linked_with=\'dS1w\', **inherit_S),\n    })\n\n\n    SSS_code_AD = SS_code_AD + \'dS0w\'\n    SSS_code_EG = SS_code_EG + \'dS0w\'\n    SSS_code_350 = SS_code_350 + \'dS0w\'\n    SSS_inh_comp_args = dict(SS_inh_comp_args)\n    SSS_inh_comp_args.update({\n        \'dS0w\': dict(linked_with=\'dS0w\', **inherit_S),\n    })\n\n    default_phases += [\n        (\'%sSmectites/Di-Smectite Ca.phs\', [\n                (dict(R=0, name=\'S R0 Ca-AD\'), S_code_AD, {}),\n                (dict(R=0, name=\'S R0 Ca-EG\', based_on=\'S R0 Ca-AD\', **inherit_phase), S_code_EG, S_inh_comp_args),\n                (dict(R=0, name=\'S R0 Ca-350\', based_on=\'S R0 Ca-AD\', **inherit_phase), S_code_350, S_inh_comp_args)\n        ]),\n    ]\n    default_phases += generate_expandables(\n        \'Smectites/SS/Di-SS R%d Ca.phs\', \'SS\', 4,\n        {}, inherit_phase, inherit_phase,\n        SS_code_AD, SS_code_EG, SS_code_350,\n        {}, SS_inh_comp_args, SS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Smectites/SSS/Di-SSS R%d Ca.phs\', \'SSS\', 3,\n        {}, inherit_phase, inherit_phase,\n        SSS_code_AD, SSS_code_EG, SSS_code_350,\n        {}, SSS_inh_comp_args, SSS_inh_comp_args,\n    )\n\n    """"""      \n    ### Trioctahedral smectites:\n    """"""\n    tS_code_AD = \'tS2w\'\n    tS_code_EG = \'tS2g\'\n    tS_code_350 = \'tSht\'\n    tS_inh_comp_args = {\n        \'tS2g\': dict(linked_with=\'tS2w\', **inherit_S),\n        \'tSht\': dict(linked_with=\'tS2w\', **inherit_S),\n    }\n\n    tSS_code_AD = tS_code_AD + \'tS1w\'\n    tSS_code_EG = tS_code_EG + \'tS1g\'\n    tSS_code_350 = tS_code_350 + \'tS1g\'\n    tSS_inh_comp_args = dict(S_inh_comp_args)\n    tSS_inh_comp_args.update({\n        \'tS1g\': dict(linked_with=\'tS1w\', **inherit_S),\n    })\n\n    tSSS_code_AD = tSS_code_AD + \'tS0w\'\n    tSSS_code_EG = tSS_code_EG + \'tS0w\'\n    tSSS_code_350 = tSS_code_350 + \'tS0w\'\n    tSSS_inh_comp_args = dict(SS_inh_comp_args)\n    tSSS_inh_comp_args.update({\n        \'tS0w\': dict(linked_with=\'tS0w\', **inherit_S),\n    })\n\n    default_phases += [\n        (\'%sSmectites/Tri-Smectite Ca.phs\', [\n                (dict(R=0, name=\'S R0 Ca-AD\'), tS_code_AD, {}),\n                (dict(R=0, name=\'S R0 Ca-EG\', based_on=\'S R0 Ca-AD\', **inherit_phase), tS_code_EG, tS_inh_comp_args),\n                (dict(R=0, name=\'S R0 Ca-350\', based_on=\'S R0 Ca-AD\', **inherit_phase), tS_code_350, tS_inh_comp_args)\n        ]),\n    ]\n    default_phases += generate_expandables(\n        \'Smectites/SS/Tri-SS R%d Ca.phs\', \'SS\', 4,\n        {}, inherit_phase, inherit_phase,\n        tSS_code_AD, tSS_code_EG, tSS_code_350,\n        {}, tSS_inh_comp_args, tSS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Smectites/SSS/Tri-SSS R%d Ca.phs\', \'SSS\', 3,\n        {}, inherit_phase, inherit_phase,\n        tSSS_code_AD, tSSS_code_EG, tSSS_code_350,\n        {}, tSSS_inh_comp_args, tSSS_inh_comp_args,\n    )\n\n    """"""      \n    ### Dioctahedral vermiculites:\n    """"""\n    V_code_AD = \'dV2w\'\n    V_code_EG = \'dV2g\'\n    V_code_350 = \'dVht\'\n    V_inh_comp_args = {\n        \'dV2g\': dict(linked_with=\'dV2w\', **inherit_S),\n        \'dVht\': dict(linked_with=\'dV2w\', **inherit_S),\n    }\n\n    VV_code_AD = V_code_AD + \'dV1w\'\n    VV_code_EG = V_code_EG + \'dV1g\'\n    VV_code_350 = V_code_350 + \'dV1g\'\n    VV_inh_comp_args = dict(V_inh_comp_args)\n    VV_inh_comp_args.update({\n        \'dV1g\': dict(linked_with=\'dV1w\', **inherit_S),\n    })\n\n\n    VVV_code_AD = VV_code_AD + \'dV0w\'\n    VVV_code_EG = VV_code_EG + \'dV0w\'\n    VVV_code_350 = VV_code_350 + \'dV0w\'\n    VVV_inh_comp_args = dict(VV_inh_comp_args)\n    VVV_inh_comp_args.update({\n        \'dV0w\': dict(linked_with=\'dV0w\', **inherit_S),\n    })\n\n    default_phases += [\n        (\'%sVermiculites/Di-Vermiculite Ca.phs\', [\n                (dict(R=0, name=\'V R0 Ca-AD\'), V_code_AD, {}),\n                (dict(R=0, name=\'V R0 Ca-EG\', based_on=\'V R0 Ca-AD\', **inherit_phase), V_code_EG, V_inh_comp_args),\n                (dict(R=0, name=\'V R0 Ca-350\', based_on=\'V R0 Ca-AD\', **inherit_phase), V_code_350, V_inh_comp_args)\n        ]),\n    ]\n    default_phases += generate_expandables(\n        \'Vermiculites/VV/Di-VV R%d Ca.phs\', \'VV\', 4,\n        {}, inherit_phase, inherit_phase,\n        VV_code_AD, VV_code_EG, VV_code_350,\n        {}, VV_inh_comp_args, VV_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Vermiculites/VVV/Di-VVV R%d Ca.phs\', \'VVV\', 3,\n        {}, inherit_phase, inherit_phase,\n        VVV_code_AD, VVV_code_EG, VVV_code_350,\n        {}, VVV_inh_comp_args, VVV_inh_comp_args,\n    )\n\n    """"""      \n    ### Kaolinite - Smectites:\n    """"""\n    K_code = \'K   \'\n    K_inh_comp_args = {\n        \'K   \': dict(linked_with=\'K   \', **inherit_all),\n    }\n\n    KS_code_AD = K_code + S_code_AD\n    KS_code_EG = K_code + S_code_EG\n    KS_code_350 = K_code + S_code_350\n    KS_inh_comp_args = dict(S_inh_comp_args)\n    KS_inh_comp_args.update(K_inh_comp_args)\n\n    KSS_code_AD = K_code + SS_code_AD\n    KSS_code_EG = K_code + SS_code_EG\n    KSS_code_350 = K_code + SS_code_350\n    KSS_inh_comp_args = dict(SS_inh_comp_args)\n    KSS_inh_comp_args.update(K_inh_comp_args)\n\n    KSSS_code_AD = K_code + SSS_code_AD\n    KSSS_code_EG = K_code + SSS_code_EG\n    KSSS_code_350 = K_code + SSS_code_350\n    KSSS_inh_comp_args = dict(SSS_inh_comp_args)\n    KSSS_inh_comp_args.update(K_inh_comp_args)\n\n    default_phases += generate_expandables(\n        \'Kaolinite-Smectites/KS/KS R%d Ca.phs\', \'KS\', 4,\n        {}, inherit_phase, inherit_phase,\n        KS_code_AD, KS_code_EG, KS_code_350,\n        {}, KS_inh_comp_args, KS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Kaolinite-Smectites/KSS/KSS R%d Ca.phs\', \'KSS\', 3,\n        {}, inherit_phase, inherit_phase,\n        KSS_code_AD, KSS_code_EG, KSS_code_350,\n        {}, KSS_inh_comp_args, KSS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Kaolinite-Smectites/KSSS/KSSS R%d Ca.phs\', \'KSSS\', 2,\n        {}, inherit_phase, inherit_phase,\n        KSSS_code_AD, KSSS_code_EG, KSSS_code_350,\n        {}, KSSS_inh_comp_args, KSSS_inh_comp_args,\n    )\n\n    """"""       \n    ### Illite - Smectites:\n    """"""\n    I_code = \'I   \'\n    I_inh_comp_args = {\n        \'I   \': dict(linked_with=\'I   \', **inherit_all),\n    }\n\n    IS_code_AD = I_code + S_code_AD\n    IS_code_EG = I_code + S_code_EG\n    IS_code_350 = I_code + S_code_350\n    IS_inh_comp_args = dict(S_inh_comp_args)\n    IS_inh_comp_args.update(I_inh_comp_args)\n\n    ISS_code_AD = I_code + SS_code_AD\n    ISS_code_EG = I_code + SS_code_EG\n    ISS_code_350 = I_code + SS_code_350\n    ISS_inh_comp_args = dict(SS_inh_comp_args)\n    ISS_inh_comp_args.update(I_inh_comp_args)\n\n    ISSS_code_AD = I_code + SSS_code_AD\n    ISSS_code_EG = I_code + SSS_code_EG\n    ISSS_code_350 = I_code + SSS_code_350\n    ISSS_inh_comp_args = dict(SSS_inh_comp_args)\n    ISSS_inh_comp_args.update(I_inh_comp_args)\n\n    default_phases += generate_expandables(\n        \'Illite-Smectites/IS/IS R%d Ca.phs\', \'IS\', 4,\n        {}, inherit_phase, inherit_phase,\n        IS_code_AD, IS_code_EG, IS_code_350,\n        {}, IS_inh_comp_args, IS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Illite-Smectites/ISS/ISS R%d Ca.phs\', \'ISS\', 3,\n        {}, inherit_phase, inherit_phase,\n        ISS_code_AD, ISS_code_EG, ISS_code_350,\n        {}, ISS_inh_comp_args, ISS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Illite-Smectites/ISSS/ISSS R%d Ca.phs\', \'ISSS\', 2,\n        {}, inherit_phase, inherit_phase,\n        ISSS_code_AD, ISSS_code_EG, ISSS_code_350,\n        {}, ISSS_inh_comp_args, ISSS_inh_comp_args,\n    )\n\n    """"""        \n    ### Chlorite - Smectites:\n    """"""\n    C_code = \'C   \'\n    C_inh_comp_args = {\n        \'C   \': dict(linked_with=\'C   \', **inherit_all),\n    }\n\n    CS_code_AD = C_code + tS_code_AD\n    CS_code_EG = C_code + tS_code_EG\n    CS_code_350 = C_code + tS_code_350\n    CS_inh_comp_args = dict(tS_inh_comp_args)\n    CS_inh_comp_args.update(C_inh_comp_args)\n\n    CSS_code_AD = C_code + tSS_code_AD\n    CSS_code_EG = C_code + tSS_code_EG\n    CSS_code_350 = C_code + tSS_code_350\n    CSS_inh_comp_args = dict(tSS_inh_comp_args)\n    CSS_inh_comp_args.update(C_inh_comp_args)\n\n    CSSS_code_AD = C_code + tSSS_code_AD\n    CSSS_code_EG = C_code + tSSS_code_EG\n    CSSS_code_350 = C_code + tSSS_code_350\n    CSSS_inh_comp_args = dict(tSSS_inh_comp_args)\n    CSSS_inh_comp_args.update(C_inh_comp_args)\n\n    default_phases += generate_expandables(\n        \'Chlorite-Smectites/CS/CS R%d Ca.phs\', \'CS\', 4,\n        {}, inherit_phase, inherit_phase,\n        CS_code_AD, CS_code_EG, CS_code_350,\n        {}, CS_inh_comp_args, CS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Chlorite-Smectites/CSS/CSS R%d Ca.phs\', \'CSS\', 3,\n        {}, inherit_phase, inherit_phase,\n        CSS_code_AD, CSS_code_EG, CSS_code_350,\n        {}, CSS_inh_comp_args, CSS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Chlorite-Smectites/CSSS/CSSS R%d Ca.phs\', \'CSSS\', 2,\n        {}, inherit_phase, inherit_phase,\n        CSSS_code_AD, CSSS_code_EG, CSSS_code_350,\n        {}, CSSS_inh_comp_args, CSSS_inh_comp_args,\n    )\n\n    """"""      \n    ### Talc - Smectites:\n    """"""\n    T_code = \'T   \'\n    T_inh_comp_args = {\n        \'T   \': dict(linked_with=\'T   \', **inherit_all),\n    }\n\n    TS_code_AD = T_code + S_code_AD\n    TS_code_EG = T_code + S_code_EG\n    TS_code_350 = T_code + S_code_350\n    TS_inh_comp_args = dict(S_inh_comp_args)\n    TS_inh_comp_args.update(T_inh_comp_args)\n\n    TSS_code_AD = T_code + SS_code_AD\n    TSS_code_EG = T_code + SS_code_EG\n    TSS_code_350 = T_code + SS_code_350\n    TSS_inh_comp_args = dict(SS_inh_comp_args)\n    TSS_inh_comp_args.update(T_inh_comp_args)\n\n    TSSS_code_AD = T_code + SSS_code_AD\n    TSSS_code_EG = T_code + SSS_code_EG\n    TSSS_code_350 = T_code + SSS_code_350\n    TSSS_inh_comp_args = dict(SSS_inh_comp_args)\n    TSSS_inh_comp_args.update(T_inh_comp_args)\n\n    default_phases += generate_expandables(\n        \'Talc-Smectites/TS/TS R%d Ca.phs\', \'TS\', 4,\n        {}, inherit_phase, inherit_phase,\n        TS_code_AD, TS_code_EG, TS_code_350,\n        {}, TS_inh_comp_args, TS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Talc-Smectites/TSS/TSS R%d Ca.phs\', \'TSS\', 3,\n        {}, inherit_phase, inherit_phase,\n        TSS_code_AD, TSS_code_EG, TSS_code_350,\n        {}, TSS_inh_comp_args, TSS_inh_comp_args,\n    )\n    default_phases += generate_expandables(\n        \'Talc-Smectites/TSSS/TSSS R%d Ca.phs\', \'TSSS\', 2,\n        {}, inherit_phase, inherit_phase,\n        TSSS_code_AD, TSSS_code_EG, TSSS_code_350,\n        {}, TSSS_inh_comp_args, TSSS_inh_comp_args,\n    )\n\n    """"""        \n    ### Illite - Chlorite - Smectites:\n    """"""\n    IC_code = I_code + C_code\n    IC_inh_comp_args = dict(I_inh_comp_args)\n    IC_inh_comp_args.update(C_inh_comp_args)\n\n    ICS_code_AD = IC_code + S_code_AD\n    ICS_code_EG = IC_code + S_code_EG\n    ICS_inh_comp_args = dict(S_inh_comp_args)\n    ICS_inh_comp_args.update(IC_inh_comp_args)\n\n    ICSS_code_AD = IC_code + SS_code_AD\n    ICSS_code_EG = IC_code + SS_code_EG\n    ICSS_inh_comp_args = dict(SS_inh_comp_args)\n    ICSS_inh_comp_args.update(IC_inh_comp_args)\n\n    ICSSS_code_AD = IC_code + SSS_code_AD\n    ICSSS_code_EG = IC_code + SSS_code_EG\n    ICSSS_inh_comp_args = dict(SSS_inh_comp_args)\n    ICSSS_inh_comp_args.update(IC_inh_comp_args)\n\n    default_phases += [\n        (\'%sIllite-Chlorite-Smectites/ICS/ICS R0 Ca.phs\', [\n                (dict(R=0, name=\'ICS R0 Ca-AD\'), ICS_code_AD, {}),\n                (dict(R=0, name=\'ICS R0 Ca-EG\', based_on=\'ICS R0 Ca-AD\', **inherit_phase), ICS_code_EG, ICS_inh_comp_args)\n        ]),\n        (\'%sIllite-Chlorite-Smectites/ICS/ICS R1 Ca.phs\', [\n                (dict(R=1, name=\'ICS R1 Ca-AD\'), ICS_code_AD, {}),\n                (dict(R=1, name=\'ICS R1 Ca-EG\', based_on=\'ICS R1 Ca-AD\', **inherit_phase), ICS_code_EG, ICS_inh_comp_args)\n        ]),\n        (\'%sIllite-Chlorite-Smectites/ICS/ICS R2 Ca.phs\', [\n                (dict(R=2, name=\'ICS R2 Ca-AD\'), ICS_code_AD, {}),\n                (dict(R=2, name=\'ICS R2 Ca-EG\', based_on=\'ICS R2 Ca-AD\', **inherit_phase), ICS_code_EG, ICS_inh_comp_args)\n        ]),\n\n        (\'%sIllite-Chlorite-Smectites/ICSS/ICSS R0 Ca.phs\', [\n                (dict(R=0, name=\'ICSS R0 Ca-AD\'), ICSS_code_AD, {}),\n                (dict(R=0, name=\'ICSS R0 Ca-EG\', based_on=\'ICSS R0 Ca-AD\', **inherit_phase), ICSS_code_EG, ICSS_inh_comp_args)\n        ]),\n        (\'%sIllite-Chlorite-Smectites/ICSS/ICSS R1 Ca.phs\', [\n                (dict(R=1, name=\'ICSS R1 Ca-AD\'), ICSS_code_AD, {}),\n                (dict(R=1, name=\'ICSS R1 Ca-EG\', based_on=\'ICSS R1 Ca-AD\', **inherit_phase), ICSS_code_EG, ICSS_inh_comp_args)\n        ]),\n\n        (\'%sIllite-Chlorite-Smectites/ICSSS/ICSSS R0 Ca.phs\', [\n                (dict(R=0, name=\'ICSSS R0 Ca-AD\'), ICSSS_code_AD, {}),\n                (dict(R=0, name=\'ICSSS R0 Ca-EG\', based_on=\'ICSSS R0 Ca-AD\', **inherit_phase), ICSSS_code_EG, ICSSS_inh_comp_args)\n        ]),\n    ]\n\n    """"""        \n    ### Kaolinite - Chlorite - Smectites:\n    """"""\n    KC_code = K_code + C_code\n    KC_inh_comp_args = dict(K_inh_comp_args)\n    KC_inh_comp_args.update(C_inh_comp_args)\n\n    KCS_code_AD = KC_code + S_code_AD\n    KCS_code_EG = KC_code + S_code_EG\n    KCS_inh_comp_args = dict(S_inh_comp_args)\n    KCS_inh_comp_args.update(KC_inh_comp_args)\n\n    KCSS_code_AD = KC_code + SS_code_AD\n    KCSS_code_EG = KC_code + SS_code_EG\n    KCSS_inh_comp_args = dict(SS_inh_comp_args)\n    KCSS_inh_comp_args.update(KC_inh_comp_args)\n\n    KCSSS_code_AD = KC_code + SSS_code_AD\n    KCSSS_code_EG = KC_code + SSS_code_EG\n    KCSSS_inh_comp_args = dict(SSS_inh_comp_args)\n    KCSSS_inh_comp_args.update(KC_inh_comp_args)\n\n    default_phases += [\n        (\'%sKaolinite-Chlorite-Smectites/KCS/KCS R0 Ca.phs\', [\n                (dict(R=0, name=\'KCS R0 Ca-AD\'), KCS_code_AD, {}),\n                (dict(R=0, name=\'KCS R0 Ca-EG\', based_on=\'KCS R0 Ca-AD\', **inherit_phase), KCS_code_EG, KCS_inh_comp_args)\n        ]),\n        (\'%sKaolinite-Chlorite-Smectites/KCS/KCS R1 Ca.phs\', [\n                (dict(R=1, name=\'KCS R1 Ca-AD\'), KCS_code_AD, {}),\n                (dict(R=1, name=\'KCS R1 Ca-EG\', based_on=\'KCS R1 Ca-AD\', **inherit_phase), KCS_code_EG, KCS_inh_comp_args)\n        ]),\n        (\'%sKaolinite-Chlorite-Smectites/KCS/KCS R2 Ca.phs\', [\n                (dict(R=2, name=\'KCS R2 Ca-AD\'), KCS_code_AD, {}),\n                (dict(R=2, name=\'KCS R2 Ca-EG\', based_on=\'KCS R2 Ca-AD\', **inherit_phase), KCS_code_EG, KCS_inh_comp_args)\n        ]),\n\n        (\'%sKaolinite-Chlorite-Smectites/KCSS/KCSS R0 Ca.phs\', [\n                (dict(R=0, name=\'KCSS R0 Ca-AD\'), KCSS_code_AD, {}),\n                (dict(R=0, name=\'KCSS R0 Ca-EG\', based_on=\'KCSS R0 Ca-AD\', **inherit_phase), KCSS_code_EG, KCSS_inh_comp_args)\n        ]),\n        (\'%sKaolinite-Chlorite-Smectites/KCSS/KCSS R1 Ca.phs\', [\n                (dict(R=1, name=\'KCSS R1 Ca-AD\'), KCSS_code_AD, {}),\n                (dict(R=1, name=\'KCSS R1 Ca-EG\', based_on=\'KCSS R1 Ca-AD\', **inherit_phase), KCSS_code_EG, KCSS_inh_comp_args)\n        ]),\n\n        (\'%sKaolinite-Chlorite-Smectites/KCSSS/KCSSS R0 Ca.phs\', [\n                (dict(R=0, name=\'KCSSS R0 Ca-AD\'), KCSSS_code_AD, {}),\n                (dict(R=0, name=\'KCSSS R0 Ca-EG\', based_on=\'KCSSS R0 Ca-AD\', **inherit_phase), KCSSS_code_EG, KCSSS_inh_comp_args)\n        ]),\n    ]\n\n    """"""\n    ### Actual object generation routine:\n    """"""\n    import queue\n    import threading\n\n    def ioworker(in_queue, stop):\n        """"""\n            Saves Phase objects from the in_queue.\n            If the Queue is empty this function will only stop\n            if the \'stop\' event is set.\n        """"""\n        while True:\n            try:\n                phases_path, phases = in_queue.get(timeout=0.5)\n                create_dir_recursive(phases_path)\n                Phase.save_phases(phases, phases_path)\n                in_queue.task_done()\n            except queue.Empty:\n                if not stop.is_set():\n                    continue\n                else:\n                    return\n\n    save_queue = queue.Queue()\n    io_stop = threading.Event()\n    iothread = threading.Thread(target=ioworker, args=(save_queue, io_stop))\n    iothread.start()\n\n    def phaseworker(in_queue, save_queue, stop):\n        """"""\n            Parses Phase descriptions into actual objects and passes them\n            to the save_queue.\n            \'stop\' should be a threading.Event() that should be toggled\n            once all elements have been Queued.\n            This way, the worker will only stop once the Queue is really empty,\n            and not when it\'s processing faster than the Queue can be filled. \n        """"""\n        while True:\n            try:\n                phases_path, phase_descr = in_queue.get(timeout=0.5)\n                project = Project()\n                phase_lookup = {}\n                component_lookup = {}\n\n                for phase_kwargs, code, comp_props in phase_descr:\n\n                    # create phase:\n                    G = len(code) / code_length\n                    based_on = None\n                    if ""based_on"" in phase_kwargs:\n                        based_on = phase_lookup.get(phase_kwargs.pop(""based_on""), None)\n                    phase = Phase(G=G, parent=project, **phase_kwargs)\n                    phase.based_on = based_on\n                    phase_lookup[phase.name] = phase\n\n                    # derive upper and lower limits for the codes using code lengths:\n                    limits = list(zip(\n                        list(range(0, len(code), code_length)),\n                        list(range(code_length, len(code) + 1, code_length))\n                    ))\n\n                    # create components:\n                    phase.components[:] = []\n                    for ll, ul in limits:\n                        part = code[ll: ul]\n                        for component in Component.load_components(aliases[part] % (settings.DATA_REG.get_directory_path(""DEFAULT_COMPONENTS"") + ""/""), parent=phase):\n                            component.resolve_json_references()\n                            phase.components.append(component)\n                            props = comp_props.get(part, {})\n                            for prop, value in props.items():\n                                if prop == \'linked_with\':\n                                    value = component_lookup[value]\n                                setattr(component, prop, value)\n\n                            component_lookup[part] = component\n\n                # put phases on the save queue:\n                phases_path = phases_path % (settings.DATA_REG.get_directory_path(""DEFAULT_PHASES"") + ""/"")\n                save_queue.put((phases_path, list(phase_lookup.values())))\n                # Flag this as finished\n                in_queue.task_done()\n            except queue.Empty:\n                if not stop.is_set():\n                    continue\n                else:\n                    return\n\n    phase_queue = queue.Queue()\n    phase_stop = threading.Event()\n    phasethread = threading.Thread(target=phaseworker, args=(phase_queue, save_queue, phase_stop))\n    phasethread.start()\n\n    # Queue phases:\n    for phases_path, phase_descr in default_phases:\n        phase_queue.put((phases_path, phase_descr))\n\n    # Signal phaseworker it can stop if the phase_queue is emptied:\n    phase_stop.set()\n    while phasethread.is_alive():\n        # Try to join the thread, but don\'t block, inform the UI\n        # of our progress if a callback is provided:\n        phasethread.join(timeout=0.1)\n        if callable(ui_callback):\n            progress = float(len(default_phases) - phase_queue.qsize()) / float(len(default_phases))\n            ui_callback(progress)\n\n    if callable(ui_callback):\n        ui_callback(1.0)\n\n    # Signal the IO worker the phaseworker has stopped, so it can stop\n    # if the save_queue is empty\n    io_stop.set()\n    while iothread.is_alive():\n        # Try to join the thread, but don\'t block\n        iothread.join(timeout=0.1)\n\n    pass # end of run\n\ndef create_dir_recursive(path):\n    """"""\n        Creates the path \'path\' recursively.\n    """"""\n    to_create = []\n    while not os.path.exists(path):\n        to_create.insert(0, path)\n        path = os.path.dirname(path)\n    for path in to_create[:-1]:\n        os.mkdir(path)\n'"
pyxrd/scripts/import_from_xml.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, sys\nfrom pyxrd.project.models import Project\n\n\ndef run(args):\n    # generates a project file containing the phases as described by the Sybilla XML output:\n    if args and args.filename != """":\n        # Import:\n        project = Project.create_from_sybilla_xml(args.filename)\n\n        # Save this right away:\n        project_filename = ""%s/%s"" % (os.path.dirname(args.filename), os.path.basename(args.filename).replace("".xml"", "".pyxrd"", 1))\n\n        from pyxrd.file_parsers.json_parser import JSONParser\n        JSONParser.write(project, project_filename, zipped=True)\n\n        # Relaunch processs\n        args = [sys.argv[0], project_filename, ]\n        args.insert(0, sys.executable)\n        if sys.platform == \'win32\':\n            args = [\'""%s""\' % arg for arg in args]\n        os.execv(sys.executable, args)\n        sys.exit(0)\n\n'"
pyxrd/scripts/interpolate_new_asf.py,6,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b as optim\n\n\n\nasf1 = np.array([0.126842, 4.708971, 1.194814, 1.558157, 1.170413, 3.239403, 4.875207, 108.506081, 0.111516, 48.292408, 1.928171])\nasf2 = np.array([0.058851, 3.062918, 4.135106, 0.853742, 1.036792, 0.85252, 2.015803, 4.417941, 0.065307, 9.66971, 0.187818])\n\ndef func(asf, stl_range):\n    f = np.zeros(stl_range.shape)\n    for i in range(1, 6):\n        f += asf[i] * np.exp(-asf[5 + i] * (stl_range) ** 2)\n    f += asf[0]\n    return f\n\nstl_range = np.arange(0, 1, 0.01)\n\nexpected1 = func(asf1, stl_range)\nexpected2 = func(asf2, stl_range)\n\nexpected = (expected1 + expected2) / 2.0\n\ndef calculate_R2(x0, *args):\n    global stl_range\n    global expected\n    calculated = func(x0, stl_range)\n    return np.sum((calculated - expected) ** 2)\n\nbounds = [\n    (0, None),\n\n    (None, None),\n    (None, None),\n    (None, None),\n    (None, None),\n    (None, None),\n\n    (0.001, None),\n    (0.001, None),\n    (0.001, None),\n    (0.001, None),\n    (0.001, None),\n]\n\nx0 = asf2\n\nlastx, lastR2, info = optim(calculate_R2, x0, approx_grad=True, pgtol=10e-24 , factr=2, iprint=-1, bounds=bounds)\n\nprint(lastR2)\nprint(""\\t"".join([(""%.10g"" % fl).replace(""."", "","") for fl in lastx]))\nprint(info)\n'"
pyxrd/scripts/refinement_generator.py,7,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nB_DO_PROFILING = False\nif B_DO_PROFILING:\n    import cProfile, pstats\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport multiprocessing\nimport os\nimport codecs\nimport numpy as np\n\n""""""\nADDED 0.01 NOISE\n""""""\n\ndef get_uniform_solutions(refiner, num):\n    """"""\n        Returns `num` solutions (uniformly distributed within their ranges) \n        for the selected parameters.\n    """"""\n    start_solutions = np.random.random_sample((num, len(refiner.ref_props)))\n    ranges = np.asarray(refiner.ranges, dtype=float)\n    return ranges[:, 0] + start_solutions * (ranges[:, 1] - ranges[:, 0])\n\ndef run(args):\n    """"""\n    This is a simple script that will open a PyXRD project file,\n    will run a refinement for a certain mixture, and store the results\n    in an overview file and the best solution as a new project file.\n    The refinement setup is left unchanged, so be sure you have correctly \n    defined parameter ranges and chosen a good refinement strategy (CMA-ES\n    is recommended).\n    \n    To use this script, launch it using PyXRD\'s core.py launcher script as:\n      python core.py -s pyxrd/scripts/refinement_generator.py ""$FILENAME###$I###$J""\n    in which: \n        - $FILENAME can be replaced with the absolute path to the actual\n          project filename\n        - $I is the index of the mixture to refine and\n        - $J is the \'trial\' number, which is added to the record file and to the\n          best solution project file.\n        - leave the three # (hashes) where they are, they are used as separators \n        \n    You can use this script (e.g. on high-performance computing clusters) to\n    run several iterations of the same project. Reasaons why you would want \n    to do this are for benchmarking, checking solution reliability, ... \n    Just change the trial number from e.g. 0 to 49 to have 50 iterations.\n    """"""\n\n    ## TODO:\n    ##  - use a uniform distribution of starting solutions:\n    ##      xs = np.random.uniform(size=50)\n    ##      ys = np.random.uniform(size=50)\n    ##      zs = np.random.uniform(size=50)\n\n    ##\n    ## When the jobs are submitted, load the project and mixture once,\n    ## create the # of staring solutions and store them in a file (using np IO)\n    ## Then here we can load them and pick the one we need.\n    ##\n\n    if args and args.filename != """":\n        logging.info(""Proccessing args..."")\n        project_file, k, mixture_index = tuple(args.filename.split(""###"", 2))\n        base_path = os.path.dirname(args.filename)\n        start_solutions_fname = os.path.join(\n            base_path,\n            ""start_solutions %s mixture %s"" % (os.path.basename(project_file), mixture_index)\n        )\n        stop_event = multiprocessing.Event()\n\n        logging.info(""Loading project file..."")\n        from pyxrd.file_parsers.json_parser import JSONParser\n        project = JSONParser.parse(project_file)\n        logging.info("" "".join([""Running Project"", os.path.basename(project_file), ""Trial"", k]))\n\n        for i, mixture in enumerate(project.mixtures):\n            if i == int(mixture_index):\n\n                if B_DO_PROFILING:\n                    pr = cProfile.Profile()\n                    pr.enable()\n                try:\n                    with mixture.data_changed.hold():\n\n                        mixture.refinement.update_refinement_treestore()\n                        refiner = mixture.refinement.get_refiner()\n\n                        if int(k) == 0: #First run, create solutions & store for later use:\n                            start_solutions = get_uniform_solutions(refiner, 50)\n                            np.savetxt(start_solutions_fname, start_solutions)\n                        else:\n                            start_solutions = np.loadtxt(start_solutions_fname)\n\n                        refiner.update(start_solutions[k, ...], iteration=-1)\n                        mixture.optimizer.optimize()\n                        \n                        refiner.refine(stop_event)\n                except:\n                    raise\n                finally:\n                    if B_DO_PROFILING:\n                        pr.disable()\n                        with open(""pyxrd_stats"", ""w+"") as f:\n                            sortby = \'cumulative\'\n                            ps = pstats.Stats(pr, stream=f).sort_stats(sortby)\n                            ps.print_stats()\n\n                recordf = os.path.basename(project_file).replace("".pyxrd"", """")\n                recordf = base_path + ""/"" + ""record#"" + str(k) + "" "" + recordf + "" "" + mixture.name\n                with codecs.open(recordf, \'w\', \'utf-8\') as f:\n\n                    f.write(""################################################################################\\n"")\n                    f.write(recordf + ""\\n"")\n                    f.write(""Mixture "" + str(i) + "" and trial "" + str(k) + ""\\n"")\n                    f.write(""Property name, initial, best, min, max"" + ""\\n"")\n                    for j, ref_prop in enumerate(refiner.refinable_properties):\n                        line = "", "".join([\n                            ref_prop.get_descriptor(),\n                            str(refiner.history.initial_solution[j]),\n                            str(refiner.history.best_solution[j]),\n                            str(ref_prop.value_min),\n                            str(ref_prop.value_max),\n                        ])\n                        f.write(line + ""\\n"")\n                    f.write(""################################################################################\\n"")\n\n                    def write_records(f, record_header, records):\n                        f.write("", "".join(record_header) + ""\\n"")\n                        for record in records:\n                            f.write("", "".join([""%.7f"" % f for f in record]) + ""\\n"")\n                        f.write(""################################################################################\\n"")\n\n                    # Apply found solution and save:\n                    refiner.apply_best_solution()\n                    mixture.optimizer.optimize()\n\n                    project_file_output = base_path + ""/"" + os.path.basename(project_file).replace("".pyxrd"", """") + "" - mixture %s - trial %s.pyxrd"" % (str(i), str(k))\n                    JSONParser.write(project, project_file_output, zipped=True)\n\n        pass # end\n'"
pyxrd/scripts/test_gtk_less.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.project.models import Project\n\ndef run(args):\n    project = Project(name=""Test"")\n    project.name = ""Test123""\n    pass\n'"
pyxrd/scripts/tools.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\n    Tools for making scripting easier\n""""""\n\ndef reload_settings(clear_script=True):\n    """"""\n        This will reload the PyXRD settings after clearing the script path from\n        the command line arguments. This allows to run the GUI when needed.\n    """"""\n    import sys\n    from copy import copy\n\n    # Make a copy to prevent errors\n    args = copy(sys.argv)\n    for i, arg in enumerate(args):\n        if arg == ""-s"":\n            # Clear the next key (contains the script name\n            del sys.argv[i + 1]\n            # Clear the flag\n            del sys.argv[i]\n            # Exit the loop\n            break\n\n    from pyxrd.data import settings\n    settings.SETTINGS_APPLIED = False # clear this flag to reload settings\n    settings.initialize() # reload settings\n\ndef launch_gui(project=None):\n    """""" Launches the GUI, you should run reload_settings before calling this! """"""\n    from pyxrd.core import _run_gui\n    _run_gui(project=project) # launch gui'"
pyxrd/server/__init__.py,0,b''
pyxrd/server/kill_server.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom traceback import print_exc\n\nfrom . import settings\nimport Pyro4\n\nif __name__ == ""__main__"":\n    try:\n        server = Pyro4.Proxy(""PYRONAME:%s"" % settings.PYRO_NAME)\n        server.shutdown()\n    except:\n        logging.error(""Error when trying to shut down Pyro server!"")\n        print_exc()'"
pyxrd/server/provider.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport time, atexit, os\nfrom traceback import print_exc\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport Pyro4\nimport Pyro4.naming\n\ntry:\n    import threading as threading\nexcept ImportError: \n    import dummy_threading as threading\n    \ntry:\n    from fastrlock.rlock import FastRLock as RLock\nexcept ImportError:\n    from threading import RLock\n\nfrom pyxrd.generic.asynchronous.exceptions import *\nfrom pyxrd.data.appdirs import user_log_dir\n\nfrom . import settings\nfrom .utils import start_script\nfrom .status_thread import StatusThread\n\nclass Pyro4AsyncServerProvider(object):\n    """"""\n        Provider for the Pyro4 PyXRD server\n    """"""\n    \n    _STATUS_NS_NOT_RUNNING = (""#FFFF00"", ""Nameserver Error"", ""Pyro4 Nameserver not running"")\n    _STATUS_ERR_NS_RUNNING = (""#FF0000"", ""Nameserver Exception"", ""Exception when checking if Pyro4 Nameserver is running"")\n    \n    _STATUS_NS_NOT_LISTED = (""#FFFF00"", ""Nameserver Error"", ""Pyro4 PyXRD server not listed"")\n    _STATUS_ERR_NS_LISTED = (""#FF0000"", ""Nameserver Exception"", ""Exception when checking if Pyro4 PyXRD server is listed"")\n    \n    _STATUS_NO_CONN_PYXRD_SERVER  = (""#FFFF00"", ""PyXRD Server Error"", ""Cannot connect to Pyro4 PyXRD server"")\n    _STATUS_ERR_CONN_PYXRD_SERVER = (""#FF0000"", ""PyXRD Server Exception"", ""Exception when connecting to Pyro4 PyXRD server"")\n    \n    _STATUS_SUCCESS = (""#00FF00"", ""Connected (Pyro4)"", ""Succesfully connected to Pyro4 PyXRD Server"")\n    \n    _updater = None\n    \n    status = _STATUS_NS_NOT_RUNNING\n    status_lock = RLock()\n    \n    NS_CACHE_TIMEOUT = 30\n    ns = None\n    ns_ts = 0\n    @classmethod\n    def _locate_ns(cls):\n        if cls.ns is None or time.time() - cls.ns_ts >= cls.NS_CACHE_TIMEOUT:\n            cls.ns = Pyro4.naming.locateNS()\n            cls.ns_ts = time.time()\n        return cls.ns\n    \n    PROXY_CACHE_TIMEOUT = 30\n    proxy = None\n    proxy_ts = 0\n    @classmethod\n    def _get_proxy(cls):\n        if cls.proxy is None or time.time() - cls.proxy_ts >= cls.PROXY_CACHE_TIMEOUT:\n            if cls.proxy is None:\n                cls.proxy = Pyro4.Proxy(""PYRONAME:%s"" % settings.PYRO_NAME)\n            else:\n                cls.proxy.pyroBind()\n            cls.proxy_ts = time.time()\n        return cls.proxy\n    \n    \n    @classmethod\n    def check_nameserver_alive(cls):\n        try:\n            ns = cls._locate_ns()\n            ns.ping()\n            return True\n        except:\n            print_exc()\n            return False\n    \n    @classmethod\n    def check_server_is_listed(cls):\n        try:\n            ns = cls._locate_ns()\n            objects = ns.list()\n            if settings.PYRO_NAME in objects:\n                return True\n            else:\n                return False\n        except:\n            print_exc()\n            return False\n    \n    """"""\n        Async Provider Implementation: \n    """"""\n    @classmethod\n    def get_status(cls):\n        """""" \n            Should return a three-tuple consisting of the status colour, label and a description:\n                (""#FF0000"", ""Error"", ""Nameserver not running"")\n            Status is updated periodically.\n        """"""\n        # first call:\n        if cls._updater == None:\n            cls._update_status(cls._get_status())\n            cls._updater = StatusThread(5, cls)\n            cls._updater.setDaemon(True)\n            cls._updater.start()\n        \n        return cls.status\n    \n    @classmethod\n    def _update_status(cls, status):\n        with cls.status_lock:\n            cls.status = status\n    \n    @classmethod\n    def _get_status(cls):\n        try:\n            if not cls.check_nameserver_alive():\n                return  cls._STATUS_NS_NOT_RUNNING\n        except:\n            print_exc()\n            return cls._STATUS_ERR_NS_RUNNING\n        try:         \n            if not cls.check_server_is_listed():\n                return cls._STATUS_NS_NOT_LISTED\n        except:\n            print_exc()\n            return cls._STATUS_ERR_NS_LISTED\n        try:         \n            if not cls.check_server_is_alive():\n                return cls._STATUS_NO_CONN_PYXRD_SERVER\n        except:\n            print_exc()\n            return cls._STATUS_ERR_CONN_PYXRD_SERVER\n        return cls._STATUS_SUCCESS\n    \n    @classmethod\n    def check_server_is_alive(cls):\n        try:\n            server = cls.get_server(auto_start=False)\n            return server.loopCondition()\n        except:\n            logging.info(""Pyro4 PyXRD server not (yet) running!"")\n            return False\n    \n    @classmethod\n    def get_server(cls, auto_start=True):\n        if auto_start: \n            cls.launch_server()\n        try:\n            return Pyro4.Proxy(""PYRONAME:%s"" % settings.PYRO_NAME)\n        except:\n            print_exc()\n            logging.error(""Could not connect to Pyro4 PyXRD server."")\n            raise ServerNotRunningException(""Pyro4 PyXRD Server is not running!"")\n    \n    @classmethod\n    def launch_server(cls):\n        if not cls.check_server_is_alive():\n            log_file = os.path.join(user_log_dir(\'PyXRD\'), \'server.log\')\n            start_script(""run_server.py"", auto_kill=not settings.KEEP_SERVER_ALIVE, log_file=log_file)\n            ttl = 15\n            delay = 0.2\n            while not cls.check_server_is_alive():\n                time.sleep(delay) # wait\n                ttl -= 1\n                if ttl == 0:\n                    raise ServerStartTimeoutExcecption(""Pyro4 PyXRD Server is not running!"")\n            logging.info(""Pyro4 PyXRD server is running!"")\n            if not settings.KEEP_SERVER_ALIVE:\n                atexit.register(cls.stop_server)\n        \n    @classmethod\n    def stop_server(cls):\n        try:\n            server = cls.get_server(auto_start=False)\n            server.shutdown()\n        except:\n            logging.error(""Error when trying to shut down Pyro4 PyXRD server!"")\n            print_exc()\n            raise ServerNotRunningException(""Pyro4 PyXRD Server is not running!"")\n        \n    pass #end of class\n'"
pyxrd/server/pyxrd_server.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport sys, os\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport multiprocessing\n\ndef _worker_initializer(pool_stop, debug, *args):\n    # Spoof command line arguments so settings are loaded with correct\n    # debugging flag\n    if debug and not ""-d"" in sys.argv:\n        sys.argv.insert(1, ""-d"")\n    if not debug and ""-d"" in sys.argv:\n        sys.argv.remove(""-d"")\n\n    # Load settings\n    from pyxrd.data import settings\n    settings.initialize()\n\n    if settings.DEBUG:\n        from pyxrd import stacktracer\n        stacktracer.trace_start(\n            ""trace-worker-%s.html"" % multiprocessing.current_process().name,\n            interval=5, auto=True) # Set auto flag to always update file!\n    logger.info(""Worker process initialized, DEBUG=%s"" % debug)\n    pass\n\nclass PyXRDServer(object):\n\n    pool = None\n    pool_stop = None\n\n    running = True\n\n    def loopCondition(self):\n        return self.running\n\n    def __init__(self):\n        from pyxrd.data import settings\n        settings.initialize()\n\n        logger.warning(""Creating pool, DEBUG=%s"" % settings.DEBUG)\n\n        self.pool_stop = multiprocessing.Event()\n        self.pool_stop.clear()\n\n        maxtasksperchild = 10 if \'nt\' == os.name else None\n\n        self.pool = multiprocessing.Pool(\n            initializer=_worker_initializer,\n            maxtasksperchild=maxtasksperchild,\n            initargs=(\n                self.pool_stop,\n                settings.DEBUG,\n            )\n        )\n\n        # register the shutdown\n        settings.FINALIZERS.append(self.shutdown)\n\n    def submit(self, func):\n        """"""\n            The callback \'func\' will be submitted to a multiprocessing\n            pool created by the server. The result object will be returned.\n        """"""\n        result = self.pool.apply_async(func)\n        self._pyroDaemon.register(result)\n        return result\n    \n    def submit_sync(self, func):\n        """"""\n            This will run the \'func\' callback directly on the server process.\n            Use this with care as it will block the server. \n            Can be used to pass in a full project refinement using the \n            pyxrd.calculations.run_refinement method.\n        """"""\n        result = func()\n        self._pyroDaemon.register(result)\n        return result\n\n    def shutdown(self):\n        """"""\n            Shuts down the server.\n        """"""\n        # Close the pool:\n        logging.info(""Closing multiprocessing pool ..."")\n        if self.pool is not None:\n            self.pool_stop.set()\n            self.pool.close()\n            self.pool.join()\n        self.running = False\n\n    pass #end of class\n'"
pyxrd/server/run_server.py,0,"b'#!/usr/bin/env python3\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nif __name__ == ""__main__"":\n    import logging\n    logger = logging.getLogger(__name__)\n    \n    import os, sys\n    sys.path.insert(1, os.path.join(sys.path[0], \'../..\'))\n\n    from pyxrd.data.appdirs import user_log_dir\n\n    from pyxrd.server import settings\n    from pyxrd.server.pyxrd_server import PyXRDServer\n    from pyxrd.server.utils import start_script\n    from pyxrd.logs import setup_logging\n    setup_logging(basic=True, prefix=""PYRO SERVER:"")\n\n    import Pyro4\n    try:\n        from Pyro4.naming import NamingError\n    except (AttributeError, ImportError):\n        from Pyro4.errors import NamingError\n\n\n    server = PyXRDServer()\n\n    daemon = Pyro4.Daemon()\n\n    try:\n        ns = Pyro4.locateNS()\n    except NamingError:\n        logger.info(""NamingError encountered when trying to locate the nameserver"")\n        log_file = os.path.join(user_log_dir(\'PyXRD\'), \'nameserver.log\')\n        start_script(""start_nameserver.py"", auto_kill=not settings.KEEP_SERVER_ALIVE, log_file=log_file)\n        ns = Pyro4.locateNS()\n\n    server_uri = daemon.register(server)\n    ns.register(settings.PYRO_NAME, server_uri) # settings.PYRO_NAME)\n\n    try:\n        daemon.requestLoop(server.loopCondition)\n    finally:\n        daemon.shutdown()\n'"
pyxrd/server/settings.py,0,"b'\nimport Pyro4\nPyro4.config.SERIALIZERS_ACCEPTED = [""json"", ""marshal"", ""serpent"", ""pickle""]\nPyro4.config.SERIALIZER = ""pickle""\nPyro4.config.PICKLE_PROTOCOL_VERSION = 3\nPyro4.config.COMPRESSION = True\nPyro4.config.SERVERTYPE = ""multiplex""\nPyro4.config.COMMTIMEOUT = 3.5\nPyro4.config.REQUIRE_EXPOSE = False\nPyro4.config.SOCK_REUSE = True\n\nimport platform\nif platform.system() == ""Windows"" and float(platform.release()) >= 6:\n    USE_MSG_WAITALL = True\n\nPYRO_NAME = ""pyxrd.server""\nKEEP_SERVER_ALIVE = False # setting this to false may produce unwanted results!'"
pyxrd/server/start_nameserver.py,0,"b'#!/usr/bin/env python3\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nif __name__ == ""__main__"":\n    # Add parent dir to the path:\n    import os, sys\n    sys.path.insert(1, os.path.join(sys.path[0], \'../..\'))    \n\n    from pyxrd.logs import setup_logging\n    from pyxrd.server import settings  # @UnusedImport\n    setup_logging(basic=True, prefix=""PYRO NAMESERVER:"")\n\n    import Pyro4.naming\n    Pyro4.naming.startNSloop()\n\n'"
pyxrd/server/status_thread.py,0,"b'import threading\nimport time\n\nclass StatusThread(threading.Thread):\n    \n    def __init__(self, interval, provider):\n        """"""\n            @param interval: In seconds: how often to update the status.\n        """"""\n        assert(interval > 0.1)\n        self.interval = interval\n        self.stop_requested = threading.Event()\n        self.provider = provider\n        threading.Thread.__init__(self)\n\n    def run(self):\n        while not self.stop_requested.isSet():\n            time.sleep(self.interval)\n            self.provider._update_status(self.provider._get_status())\n                \n    def stop(self):\n        self.stop_requested.set()\n        self.join()\n\n    pass #end of class'"
pyxrd/server/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport sys, os, time, subprocess, platform\nimport signal\nimport atexit\n\npythonexe = ""python3""\nif platform.system() == ""Windows"":\n    pythonexe = ""python3w""\n\ndef kill_child(child_pid):\n    if child_pid is None:\n        pass\n    else:\n        os.kill(child_pid, signal.SIGTERM)\n\ndef start_script(local_script_name, auto_kill=True, log_file=None):\n    global pythonexe\n    \n    if hasattr(sys, ""frozen""):\n        module_path = os.path.dirname(sys.executable)\n    else:\n        module_path = os.path.dirname(__file__)\n    path = os.path.join(module_path, local_script_name)\n\n    logging.info(""Starting server using script: \'%s\', logging to \'%s\'"" % (path, log_file))\n    log_file = log_file if log_file is not None else os.devnull\n    with open(log_file, \'w\') as output:\n        proc = subprocess.Popen([pythonexe, path], stdout=output)\n\n    # Register this child pid to be killed when the parent dies:\n    if auto_kill:\n        atexit.register(kill_child, proc.pid)\n\n    # Give it a sec\n    time.sleep(1)\n'"
pyxrd/specimen/__init__.py,0,b''
test/test_atoms/__init__.py,0,b'#TODO:\n# - Combined AtomType & Atom tests\n# - Test Controller & View creation etc.\n'
test/test_atoms/test_atom.py,1,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\nfrom mock import Mock\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.atoms.models import Atom\n\n__all__ = [\n    \'TestAtom\',\n]\n\nclass TestAtom(unittest.TestCase):\n\n    atom_type = None\n\n    def setUp(self):\n        self.atom = Atom()\n\n    def tearDown(self):\n        del self.atom\n\n    def get_mocked_hierarchy(self):       \n        oxygen = Mock()\n        oxygen.name = ""O1-""\n        hydrogen = Mock()\n        hydrogen.name = ""H+""\n                \n        project = Mock()\n        project.atom_types = [oxygen, hydrogen]\n        phase = Mock()\n        phase.attach_mock(project, \'project\')\n        component = Mock()\n        component.attach_mock(phase, \'phase\')\n        \n        return oxygen, hydrogen, component, phase, project\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.atom)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.atom.data_object)\n\n    test_name = create_object_attribute_test(""atom"", ""name"", ""Test Name"")\n    test_pn = create_object_attribute_test(""atom"", ""pn"", 3)\n    test_default_z = create_object_attribute_test(""atom"", ""default_z"", 5.3)\n    test_stretch_values = create_object_attribute_test(""atom"", ""stretch_values"", True)\n\n    def test_parent(self):\n        parent_atom = Atom(name=""Parent"")\n        self.atom.parent = parent_atom\n        self.assertEqual(self.atom.parent, parent_atom)\n\n    def test_set_atom_type(self):\n        oxygen, hydrogen, component, _, _ = self.get_mocked_hierarchy()\n        atom = Atom(\n            parent = component,\n            name = ""O"",\n            atom_type = oxygen,\n        )\n        atom.atom_type = hydrogen\n        self.assertEqual(atom.atom_type, hydrogen)\n\n    def test_z_calculations(self):\n        # Checks wether the atom can calculate stretched values:\n        # 1. When everything is set up the way it should be:\n        default_z = 9.0\n        lattice_d = 5.4\n        factor = 0.5\n        \n        parent = Mock()\n        parent.configure_mock(**{\n            \'get_interlayer_stretch_factors.return_value\': (lattice_d, factor)\n        })\n        \n        atom = Atom(parent=parent)\n        atom.stretch_values = True\n        atom.default_z = default_z\n        z = atom.z\n        self.assertEqual(z, lattice_d + (default_z - lattice_d) * factor)\n        # 2. When no component is set, but stretched is True: should not raise an error, but simple ignore the stretching\n        atom.parent = None\n        z = atom.z\n\n    def test_structure_factors(self):\n        import numpy as np\n        rng = 2.0 * np.sin(np.arange(30)) / 0.154056\n        res = self.atom.get_structure_factors(rng)\n        self.assertIsNotNone(res)\n        \n    def test_loads_atom_type_by_name(self):\n        atom_json_dict = {\n            ""uuid"": ""878341b04e9e11e2b238150ae229a525"", \n            ""name"": ""O"", \n            ""default_z"": 0.66, \n            ""pn"": 6.0, \n            ""atom_type_name"": ""O1-""\n        }\n        \n        oxygen, _, component, _, _ = self.get_mocked_hierarchy()\n        \n        atom = Atom.from_json(parent = component, **atom_json_dict)\n        atom.resolve_json_references()\n        self.assertEqual(atom.atom_type, oxygen)\n        \n\n    pass # end of class\n'"
test/test_atoms/test_atom_type.py,1,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.atoms.models import AtomType\n\n__all__ = [\n    \'TestAtomType\',\n]\n\nclass TestAtomType(unittest.TestCase):\n\n    atom_type = None\n\n    def setUp(self):\n        self.atom_type = AtomType()\n\n    def tearDown(self):\n        del self.atom_type\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.atom_type)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.atom_type.data_object)\n\n    test_name = create_object_attribute_test(""atom_type"", ""name"", ""Test Name"")\n    test_charge = create_object_attribute_test(""atom_type"", ""charge"", -5)\n    test_debye = create_object_attribute_test(""atom_type"", ""debye"", 1.0)\n    test_weight = create_object_attribute_test(""atom_type"", ""weight"", 60.123)\n    test_atom_nr = create_object_attribute_test(""atom_type"", ""atom_nr"", 20)\n    test_par_c = create_object_attribute_test(""atom_type"", ""par_c"", 10.2)\n    test_par_a1 = create_object_attribute_test(""atom_type"", ""par_a1"", 10.2)\n    test_par_a2 = create_object_attribute_test(""atom_type"", ""par_a2"", 10.2)\n    test_par_a3 = create_object_attribute_test(""atom_type"", ""par_a3"", 10.2)\n    test_par_a4 = create_object_attribute_test(""atom_type"", ""par_a4"", 10.2)\n    test_par_a5 = create_object_attribute_test(""atom_type"", ""par_a5"", 10.2)\n    test_par_b1 = create_object_attribute_test(""atom_type"", ""par_b1"", 10.2)\n    test_par_b2 = create_object_attribute_test(""atom_type"", ""par_b2"", 10.2)\n    test_par_b3 = create_object_attribute_test(""atom_type"", ""par_b3"", 10.2)\n    test_par_b4 = create_object_attribute_test(""atom_type"", ""par_b4"", 10.2)\n    test_par_b5 = create_object_attribute_test(""atom_type"", ""par_b5"", 10.2)\n\n    def test_parent(self):\n        parent_atom_type = AtomType(name=""Parent"")\n        self.atom_type.parent = parent_atom_type\n        self.assertEqual(self.atom_type.parent, parent_atom_type)\n        \n    def test_get_atomic_scattering_factors(self):\n        import numpy as np\n        stl_range = np.array([ 0.1152, 0.5756, 1.1469 ])\n        self.atom_type.par_a1 = 10.2\n        self.atom_type.par_a2 = 10.2\n        self.atom_type.par_a3 = 10.2\n        self.atom_type.par_a4 = 10.2\n        self.atom_type.par_a5 = 10.2\n        self.atom_type.par_b1 = 10.2\n        self.atom_type.par_b2 = 10.2\n        self.atom_type.par_b3 = 10.2\n        self.atom_type.par_b4 = 10.2\n        self.atom_type.par_b5 = 10.2\n        self.atom_type.par_c = 20.2\n        self.assertListEqual(\n            self.atom_type.get_atomic_scattering_factors(stl_range).tolist(),\n            [ 71.1827439324707, 70.77093939463964, 69.51772020477823 ]\n        )\n\n    pass # end of class\n'"
test/test_calculations/__init__.py,0,b''
test/test_calculations/test_CSDS.py,0,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nimport numpy as np\n\nfrom pyxrd.calculations.data_objects import CSDSData\nfrom pyxrd.calculations.CSDS import calculate_distribution\n\n__all__ = [\n    'TestCSDSCalcs',\n]\n\nclass TestCSDSCalcs(unittest.TestCase):\n\n    def setUp(self):\n        self.CSDS_data_kwargs = dict(\n            average = 10,\n            maximum = 50,\n            minimum = 1,\n            alpha_scale = 0.9485,\n            alpha_offset = 0.017,\n            beta_scale = 0.1032,\n            beta_offset = 0.0034\n        )\n        self.CSDS_data = CSDSData(**self.CSDS_data_kwargs)\n\n    def tearDown(self):\n        del self.CSDS_data\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.CSDS_data)\n        \n    def test_attributes(self):\n        for key, value in self.CSDS_data_kwargs.items():\n            self.assertEquals(getattr(self.CSDS_data, key), value)\n\n    def test_calculate_distribution(self):\n        result = calculate_distribution(\n            self.CSDS_data\n        )\n        self.assertIsNotNone(result)\n        self.assertEquals(len(result), 2)\n\n    pass # end of class\n\n\ncalculate_distribution"""
test/test_calculations/test_atoms.py,4,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nimport numpy as np\n\nfrom pyxrd.calculations.data_objects import AtomData, AtomTypeData\nfrom pyxrd.calculations.atoms import get_atomic_scattering_factor, get_structure_factor\n\n__all__ = [\n    'TestAtomCalcs',\n]\n\nclass TestAtomCalcs(unittest.TestCase):\n\n    def setUp(self):\n        self.atom_type_data = AtomTypeData( # this is the data for a H atom\n            par_a = np.asanyarray([0.413048,0.294953,0.187491,0.080701,0.023736]),\n            par_b = np.asanyarray([15.569946,32.398468,5.711404,61.889874,1.334118]),\n            par_c = 0.000049,\n            debye = 0\n        )\n        self.atom_data = AtomData(\n            atom_type = self.atom_type_data,\n            pn = 1,\n            default_z = 0,\n            z = 0\n        )       \n\n    def tearDown(self):\n        del self.atom_data\n        del self.atom_type_data\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.atom_type_data)\n        self.assertIsNotNone(self.atom_data)\n\n    def test_scattering_factor(self):\n        result = get_atomic_scattering_factor(\n            np.asanyarray([2.2551711385, 2.478038901, 2.7001518288, 2.9214422642, 3.1418428, 3.3612863, 3.5797059197, 3.7970351263]),\n            self.atom_type_data\n        )\n        self.assertIsNotNone(result)\n\n    def test_structure_factor(self):\n        result = get_structure_factor(\n            np.asanyarray([2.2551711385, 2.478038901, 2.7001518288, 2.9214422642, 3.1418428, 3.3612863, 3.5797059197, 3.7970351263]),\n            self.atom_data\n        )\n        self.assertIsNotNone(result)\n\n    pass # end of class\n"""
test/test_calculations/test_components.py,3,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nimport numpy as np\n\nfrom pyxrd.calculations.data_objects import AtomData, AtomTypeData, ComponentData\nfrom pyxrd.calculations.components import get_factors\n\n__all__ = [\n    'TestComponentCalcs',\n]\n\nclass TestComponentCalcs(unittest.TestCase):\n\n    def setUp(self):\n        self.atom_type_data = AtomTypeData( # this is the data for a H atom\n            par_a = np.asanyarray([0.413048,0.294953,0.187491,0.080701,0.023736]),\n            par_b = np.asanyarray([15.569946,32.398468,5.711404,61.889874,1.334118]),\n            par_c = 0.000049,\n            debye = 0\n        )\n        self.layer_atom = AtomData(\n            atom_type = self.atom_type_data,\n            pn = 1,\n            default_z = 0,\n            z = 0\n        )       \n        self.interlayer_atom = AtomData(\n            atom_type = self.atom_type_data,\n            pn = 1,\n            default_z = 0.55,\n            z = 0.55\n        )       \n        self.component_data = ComponentData(\n            layer_atoms = [self.layer_atom, ],\n            interlayer_atoms = [self.interlayer_atom, ],\n            volume = 1.0,\n            weight = 1.0,\n            d001 = 0.55,\n            default_c = 0.6,\n            delta_c = 0.02,\n            lattice_d = 0.45   \n        )\n        \n\n    def tearDown(self):\n        del self.interlayer_atom\n        del self.layer_atom\n        del self.atom_type_data\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.atom_type_data)\n        self.assertIsNotNone(self.layer_atom)\n        self.assertIsNotNone(self.interlayer_atom)\n\n    def test_get_factors(self):\n        result = get_factors(\n            np.asanyarray([2.2551711385, 2.478038901, 2.7001518288, 2.9214422642, 3.1418428, 3.3612863, 3.5797059197, 3.7970351263]),\n            self.component_data\n        )\n        self.assertIsNotNone(result)\n\n    pass # end of class\n"""
test/test_calculations/test_goniometer.py,4,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nimport numpy as np\n\nfrom pyxrd.calculations.data_objects import GonioData\nfrom pyxrd.calculations.goniometer import (\n    get_2t_from_nm,\n    get_nm_from_2t, \n    get_nm_from_t,\n    get_t_from_nm,\n    get_S, \n    get_fixed_to_ads_correction_range,\n    get_lorentz_polarisation_factor\n)\n\n__all__ = [\n    'TestGoniometerCalcs',\n]\n\nclass TestGoniometerCalcs(unittest.TestCase):\n\n    def setUp(self):\n        self.goniometer_data_kwargs = dict(\n            min_2theta = 3.0,\n            max_2theta = 45,\n            mcr_2theta = 0,\n            steps = 2500,\n            soller1 = 2.3,\n            soller2 = 2.3,\n            divergence = 0.5,\n            has_ads = False,\n            ads_fact = 1.0,\n            ads_phase_fact = 1.0,\n            ads_phase_shift = 0.0,\n            ads_const = 0.0,\n            radius = 24.0,\n            wavelength_distribution = [\n                [0.1544426,0.955148885],\n                [0.153475,0.044851115],\n            ]  \n        )\n        self.goniometer_data = GonioData(**self.goniometer_data_kwargs)\n\n    def tearDown(self):\n        del self.goniometer_data\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.goniometer_data)\n        \n    def test_attributes(self):\n        for key, value in self.goniometer_data_kwargs.items():\n            self.assertEquals(getattr(self.goniometer_data, key), value)\n\n    def test_fixed_to_ads_correction_range(self):\n        result = get_fixed_to_ads_correction_range(\n            np.asanyarray([2.2551711385, 2.478038901, 2.7001518288, 2.9214422642, 3.1418428, 3.3612863, 3.5797059197, 3.7970351263]),\n            self.goniometer_data\n        )\n        self.assertIsNotNone(result)\n        self.assertEquals(np.allclose(\n            result, \n            [7.74814435e-01, 6.15920411e-01, 4.27242611e-01, 2.18376385e-01, -2.50146408e-04, -2.17930643e-01, -4.24231682e-01, -6.09510086e-01]\n        ), True)\n\n    def test_lorentz_polarisation_factor(self):\n        result = get_lorentz_polarisation_factor(\n            np.asanyarray([2.2551711385, 2.478038901, 2.7001518288, 2.9214422642, 3.1418428, 3.3612863, 3.5797059197, 3.7970351263]),\n            12,\n            self.goniometer_data.soller1, self.goniometer_data.soller2, self.goniometer_data.mcr_2theta\n        )\n        self.assertIsNotNone(result)\n        self.assertEquals(np.allclose(\n            result, \n            [3.00643375e-03, 4.83799816e-03, 1.33173586e-02, 6.56714627e-02, 5.11941694e+02, 6.59637604e-02, 1.35695934e-02, 4.97673826e-03]\n            #[3.67253512e-01, 5.84371208e-01, 1.55735810e+00, 6.54044238e+00, 7.99531670e+03, 6.56417033e+00, 1.58546668e+00, 6.00742559e-01]\n        ), True)\n        pass\n\n    def test_S(self):\n        # \n        result = get_S(2.5, 2.5);\n        self.assertIsNotNone(result)\n        self.assertEquals(len(result), 2)\n        S, S1S2 = result\n        self.assertAlmostEquals(S, 1.7677669529663689)\n        self.assertAlmostEquals(S1S2, 6.25)\n\n    def test_2t_from_nm_positive(self):\n        # boundary condition: positive\n        result = get_2t_from_nm(0.716)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 12.351779659)\n    def test_2t_from_nm_zero(self):\n        # boundary condition: 0\n        result = get_2t_from_nm(0)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0)\n    def test_2t_from_nm_negative(self):\n        # boundary condition: negative\n        result = get_2t_from_nm(-0.716)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, -12.351779659)\n     \n    def test_nm_from_2t_positive(self):\n        # boundary condition: positive\n        result = get_nm_from_2t(12.351779659)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0.716)\n    def test_nm_from_2t_zero(self):\n        # boundary condition: 0\n        result = get_nm_from_2t(0)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 1e+16)\n        result = get_nm_from_2t(0, zero_for_inf=True)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0)\n    def test_nm_from_2t_negative(self):\n        # boundary condition: negative\n        result = get_nm_from_2t(-12.351779659)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, -0.716)\n        \n    def test_nm_from_t_positive(self):\n        # boundary condition: positive\n        result = get_nm_from_t(6.17588983)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0.716)        \n    def test_nm_from_t_zero(self):\n        # boundary condition: 0\n        result = get_nm_from_t(0)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 1e+16)\n        result = get_nm_from_t(0, zero_for_inf=True)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0)\n    def test_nm_from_t_negative(self):\n        # boundary condition: negative\n        result = get_nm_from_t(-6.17588983)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, -0.716)\n       \n    def test_t_from_nm_positive(self):\n        # boundary condition: positive\n        result = get_t_from_nm(0.716)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 6.17588983)\n    def test_t_from_nm_zero(self):\n        # boundary condition: 0\n        result = get_t_from_nm(0)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, 0)\n    def test_t_from_nm_negative(self):\n        # boundary condition: negative\n        result = get_t_from_nm(-0.716)\n        self.assertIsNotNone(result)\n        self.assertAlmostEquals(result, -6.17588983)\n\n    pass # end of class\n"""
test/test_generic/__init__.py,0,b''
test/test_mixture/__init__.py,0,b''
test/test_mixture/test_mixture.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test, mock_settings\n\nfrom pyxrd.phases.models import Phase\nfrom pyxrd.specimen.models import Specimen\nfrom pyxrd.project.models import Project\nfrom pyxrd.mixture.models import Mixture\nfrom _collections import defaultdict\n\n__all__ = [\n    \'TestMixture\',\n]\n\n# Requires properly working:\n#  - Phase\n#  - Specimen\n#  - Project\n\nclass TestMixture(unittest.TestCase):\n\n    atom_type = None\n\n    def setUp(self):\n        mock_settings()\n        self.project = Project(name=""TestProject"")\n        self.mixture = Mixture(name=""TestMixture"", parent=self.project)\n\n    def tearDown(self):\n        del self.mixture\n        del self.project\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.mixture)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.mixture.data_object)\n\n    test_name = create_object_attribute_test(""mixture"", ""name"", ""Test Name"")\n\n    def test_parent(self):\n        parent_project = Project(name=""Parent2"")\n        self.mixture.parent = parent_project\n        self.assertEqual(self.mixture.parent, parent_project)\n\n    def test_add_phase_slot(self):\n        index = self.mixture.add_phase_slot(""TestPhase"", 0.5)\n        self.assertEqual(index, 0, ""Adding a phase slot should return the correct index!"")\n\n    def test_add_specimen_slot(self):\n        index = self.mixture.add_specimen_slot(None, 1.0, 0)\n        self.assertEqual(index, 0, ""Adding a specimen slot should return the correct index!"")\n\n    def test_add_order1(self):\n        """"""Test if addition works when 1st specimen slot is added before 1st phase slot""""""\n        self.mixture.add_specimen_slot(None, 1.0, 0)\n        self.assertEqual(len(self.mixture.specimens), 1)\n        self.assertEqual(len(self.mixture.phases), 0)\n        self.assertEqual(len(self.mixture.fractions), 0)\n        self.assertEqual(self.mixture.phase_matrix.shape, (1, 0))\n        self.mixture.add_phase_slot(""TestPhase"", 0.5)\n        self.assertEqual(len(self.mixture.specimens), 1)\n        self.assertEqual(len(self.mixture.phases), 1)\n        self.assertEqual(len(self.mixture.fractions), 1)\n        self.assertEqual(self.mixture.phase_matrix.shape, (1, 1))\n        self.assertEqual(self.mixture.phase_matrix[0, 0], None)\n\n    def test_add_order2(self):\n        """"""Test if addition works when 1st phase slot is added before 1st specimen slot""""""\n        self.mixture.add_phase_slot(""TestPhase"", 0.5)\n        self.assertEqual(len(self.mixture.specimens), 0)\n        self.assertEqual(len(self.mixture.phases), 1)\n        self.assertEqual(len(self.mixture.fractions), 1)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 1))\n        self.mixture.add_specimen_slot(None, 1.0, 0)\n        self.assertEqual(len(self.mixture.specimens), 1)\n        self.assertEqual(len(self.mixture.phases), 1)\n        self.assertEqual(len(self.mixture.fractions), 1)\n        self.assertEqual(self.mixture.phase_matrix.shape, (1, 1))\n        self.assertEqual(self.mixture.phase_matrix[0, 0], None)\n\n    def test_add_multiple(self):\n        """"""Test if addition for multiple phases and specimens works as expected""""""\n        self.mixture.add_phase_slot(""TestPhase"", 0.5)\n        self.mixture.add_specimen_slot(None, 1.0, 0)\n        self.mixture.add_specimen_slot(None, 1.0, 0)\n        self.mixture.add_phase_slot(""TestPhase2"", 0.5)\n        self.mixture.add_phase_slot(""TestPhase3"", 0.5)\n        self.assertEqual(len(self.mixture.specimens), 2)\n        self.assertEqual(len(self.mixture.phases), 3)\n        self.assertEqual(len(self.mixture.fractions), 3)\n        self.assertEqual(self.mixture.phase_matrix.shape, (2, 3))\n\n    def test_del_phase_slot(self):\n        """"""Test if deleting a phase works as expected""""""\n        self.mixture.add_phase_slot(""TestPhase1"", 0.1)\n        self.mixture.add_phase_slot(""TestPhase2"", 0.1)\n        self.mixture.del_phase_slot(1)\n        self.assertEqual(len(self.mixture.phases), 1)\n        self.assertEqual(len(self.mixture.fractions), 1)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 1))\n        self.mixture.del_phase_slot(0)\n        self.assertEqual(len(self.mixture.phases), 0)\n        self.assertEqual(len(self.mixture.fractions), 0)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 0))\n\n    def test_del_specimen_slot(self):\n        """"""Test if deleting a specimen works as expected""""""\n        self.mixture.add_specimen_slot(None, 0.5, 0)\n        self.mixture.add_specimen_slot(None, 0.5, 0)\n        self.mixture.del_specimen_slot(1)\n        self.assertEqual(len(self.mixture.specimens), 1)\n        self.assertEqual(self.mixture.phase_matrix.shape, (1, 0))\n        self.mixture.del_specimen_slot(0)\n        self.assertEqual(len(self.mixture.specimens), 0)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 0))\n\n    def test_del_phase_slot_by_name(self):\n        self.mixture.add_phase_slot(""TestPhase1"", 0.1)\n        self.mixture.del_phase_slot_by_name(""TestPhase1"")\n        self.assertEqual(len(self.mixture.phases), 0)\n        self.assertEqual(len(self.mixture.fractions), 0)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 0))\n\n    def test_del_specimen_slot_by_object(self):\n        dummy = Specimen(name=""Test Specimen"", parent=self.project)\n        self.project.specimens.append(dummy)\n        self.mixture.add_specimen_slot(dummy, 0.5, 0)\n        self.mixture.del_specimen_slot_by_object(dummy)\n        self.assertEqual(len(self.mixture.specimens), 0)\n        self.assertEqual(self.mixture.phase_matrix.shape, (0, 0))\n\n    def test_set_specimen(self):\n        dummy = Specimen(name=""Test Specimen"", parent=self.project)\n        self.project.specimens.append(dummy)\n        self.mixture.add_specimen_slot(None, 0.5, 0)\n        self.mixture.set_specimen(0, dummy)\n        self.assertEqual(self.mixture.specimens[0], dummy)\n\n    def test_unset_specimen(self):\n        dummy = Specimen(name=""Test Specimen"", parent=self.project)\n        self.project.specimens.append(dummy)\n        self.mixture.add_specimen_slot(dummy, 0.5, 0)\n        self.mixture.unset_specimen(dummy)\n        self.assertEqual(self.mixture.specimens[0], None)\n\n    def test_unset_phase(self):\n        specimen = Specimen(name=""Test Specimen"", parent=self.project)\n        self.project.specimens.append(specimen)\n        self.mixture.add_specimen_slot(specimen, 0.5, 0)\n        self.mixture.add_phase_slot(""Test Phase1"", 0.5)\n\n        dummy = Phase(name=""Test Phase"", parent=self.project)\n        self.project.phases.append(dummy)\n        self.mixture.set_phase(0, 0, dummy)\n        self.mixture.unset_phase(dummy)\n        self.assertEqual(self.mixture.phase_matrix[0, 0], None)\n\n    def test_randomize_empty_mixture(self):\n        self.mixture.refinement.randomize()\n\n    def _refinement_setup(self):\n        # TODO maybe add some more variation in the type of Phases?\n        specimen = Specimen(name=""Test Specimen"", parent=self.project)\n        self.project.specimens.append(specimen)\n        phase1 = Phase(name=""Test Phase1"", parent=self.project)\n        self.project.phases.append(phase1)\n        phase2 = Phase(name=""Test Phase2"", parent=self.project)\n        self.project.phases.append(phase2)\n        self.mixture.add_specimen_slot(specimen, 0.5, 0)\n        self.mixture.add_phase_slot(""Test Phase1"", 0.5)\n        self.mixture.add_phase_slot(""Test Phase2"", 0.5)\n        self.mixture.set_phase(0, 0, phase1)\n        self.mixture.set_phase(0, 1, phase2)\n\n    def test_randomize(self):\n        self._refinement_setup()\n\n        # Mark the attribute(s) for refinement & get their values:\n        refinables = []\n        for node in self.mixture.refinables.iter_children():\n            ref_prop = node.object\n            if ref_prop.refinable:\n                ref_prop.refine = True\n                refinables.append((ref_prop, ref_prop.value))\n\n        # Randomize:\n        self.mixture.refinement.randomize()\n\n        # Check all of them have been randomized:\n        # It is possible (but unlikely) that the randomized value\n        # is the same as the pre-randomized value. If so run this test again\n        # to make sure it is really failing.\n        for ref_prop, pre_val in refinables:\n            self.assertNotEqual(pre_val, ref_prop.value)\n\n    def test_auto_restrict_empy_mixture(self):\n        self.mixture.refinement.auto_restrict()\n\n    def test_auto_restrict(self):\n        self._refinement_setup()\n\n        # Mark the attribute(s) for refinement & get their values:\n        refinables = []\n        for node in self.mixture.refinables.iter_children():\n            ref_prop = node.object\n            if ref_prop.refinable:\n                ref_prop.refine = True\n                refinables.append((ref_prop, ref_prop.value))\n\n        # Randomize:\n        self.mixture.refinement.auto_restrict()\n\n        # Check all of them have been restricted:\n        for ref_prop, pre_val in refinables:\n            self.assertEqual(pre_val * 0.8, ref_prop.value_min)\n            self.assertEqual(pre_val * 1.2, ref_prop.value_max)\n\n\n    # TODO:\n    #  - set_data_object\n    #  - optimize\n    #  - apply_current_data_object\n    #  - update\n    #  - get_refinement_method\n    #  - setup_refine_options\n\n    pass # end of class\n\nif __name__ == ""__main__"":\n    #import sys;sys.argv = [\'\', \'Test.testName\']\n    unittest.main()\n'"
test/test_mixture/test_refinement.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\nfrom test.setup import SKIP_REFINEMENT_TEST\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\n__all__ = [\n    \'TestRefinement\',\n]\n\n# Requires properly working:\n#  - Phase\n#  - Specimen\n#  - Project\n#  - Mixture\n\nclass TestRefinement(unittest.TestCase):\n\n    atom_type = None\n\n    def setUp(self):\n        self.project = JSONParser.parse(resource_filename(""test.test_mixture"", ""test refinement.pyxrd""))\n        self.mixture = self.project.mixtures[0]\n\n    def tearDown(self):\n        del self.mixture\n        del self.project\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.mixture)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.mixture.data_object)\n\n    @unittest.skipIf(SKIP_REFINEMENT_TEST, ""Skipping refinement test"")\n    def test_refine_methods(self):\n        for index, method in enumerate(self.mixture.refinement.refine_methods):\n            self.mixture.refinement.refine_method_index = index\n            self.mixture.refinement.randomize()\n            refiner = self.mixture.refinement.get_refiner()\n            refiner.refine(stop=None)\n\n    pass # end of class\n\n\nif __name__ == ""__main__"":\n    #import sys;sys.argv = [\'\', \'Test.testName\']\n    unittest.main()'"
test/test_phases/__init__.py,0,b''
test/test_phases/test_CSDS.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.phases.models.CSDS import LogNormalCSDSDistribution, DritsCSDSDistribution\n\n__all__ = [\n    \'TestLogNormalCSDSDistribution\',\n    \'TestDritsCSDSDistribution\'\n]\n\nclass TestLogNormalCSDSDistribution(unittest.TestCase):\n\n    component = None\n\n    def setUp(self):\n        self.CSDS = LogNormalCSDSDistribution()\n\n    def tearDown(self):\n        del self.CSDS\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.CSDS)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.CSDS.data_object)\n\n    test_average = create_object_attribute_test(""CSDS"", ""average"", 15)\n    test_alpha_scale = create_object_attribute_test(""CSDS"", ""alpha_scale"", 0.5)\n    test_alpha_offset = create_object_attribute_test(""CSDS"", ""alpha_offset"", 0.6)\n    test_beta_scale = create_object_attribute_test(""CSDS"", ""alpha_scale"", 0.5)\n    test_beta_offset = create_object_attribute_test(""CSDS"", ""alpha_offset"", 0.6)\n\n    pass # end of class\n\nclass TestDritsCSDSDistribution(unittest.TestCase):\n\n    component = None\n\n    def setUp(self):\n        self.CSDS = DritsCSDSDistribution()\n\n    def tearDown(self):\n        del self.CSDS\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.CSDS)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.CSDS.data_object)\n\n    test_average = create_object_attribute_test(""CSDS"", ""average"", 15)\n\n    pass # end of class'"
test/test_phases/test_atom_relations.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.phases.models.atom_relations import AtomRatio\n\n__all__ = [\n    \'TestAtomRatio\',\n]\n\nclass DummyHoldableSignal():\n    def ignore(self):\n        return self\n    def __enter__(self):\n        pass\n    def __exit__(self, *args):\n        pass\n\nclass DummyAtom():\n    data_changed = DummyHoldableSignal()\n    attribute = 0.0\n\nclass DummyParent():\n    inherit_atom_relations = False\n\nclass TestAtomRatio(unittest.TestCase):\n\n    phase = None\n\n    def setUp(self):\n        self.atom1 = DummyAtom()\n        self.atom2 = DummyAtom()\n        self.parent = DummyParent()\n        self.atom_ratio = AtomRatio(\n            name=""TestRatio"",\n            sum=2,\n            value=0.5,\n            atom1=[self.atom1, ""attribute""],\n            atom2=[self.atom2, ""attribute""],\n            parent=self.parent\n        )\n        self.atom_ratio.resolve_relations()\n\n    def tearDown(self):\n        del self.atom1\n        del self.atom2\n        del self.atom_ratio\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.atom_ratio)\n        self.assertIsNotNone(self.atom_ratio.atom1[0])\n        self.assertIsNotNone(self.atom_ratio.atom2[0])\n\n    def test_apply_relation(self):\n        self.atom_ratio.enabled = True\n        self.atom_ratio.apply_relation()\n        self.assertEqual(self.atom1.attribute, 1.0)\n        self.assertEqual(self.atom2.attribute, 1.0)\n        self.atom_ratio.value = 0.1\n        self.atom_ratio.apply_relation()\n        self.assertEqual(self.atom1.attribute, 0.2)\n        self.assertEqual(self.atom2.attribute, 1.8)\n\n    test_name = create_object_attribute_test(""atom_ratio"", ""name"", ""Test Name"")\n    test_name = create_object_attribute_test(""atom_ratio"", ""value"", 0.5)\n    test_name = create_object_attribute_test(""atom_ratio"", ""sum"", 6)\n    test_name = create_object_attribute_test(""atom_ratio"", ""atom1"", (None, ""Test""))\n    test_name = create_object_attribute_test(""atom_ratio"", ""atom2"", (None, ""Test""))\n\n    pass # end of class\n'"
test/test_phases/test_component.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.phases.models import Component\n\n__all__ = [\n    \'TestComponent\',\n]\n\nclass TestComponent(unittest.TestCase):\n\n    component = None\n\n    def setUp(self):\n        self.component = Component()\n\n    def tearDown(self):\n        del self.component\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.component)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.component.data_object)\n\n    test_name = create_object_attribute_test(""component"", ""name"", ""Test Name"")\n    test_d001 = create_object_attribute_test(""component"", ""d001"", 0.789)\n    test_default_c = create_object_attribute_test(""component"", ""default_c"", 0.646)\n    test_delta_c = create_object_attribute_test(""component"", ""delta_c"", 0.002)\n    test_inherit_atom_relations = create_object_attribute_test(""component"", ""inherit_atom_relations"", True)\n    test_inherit_interlayer_atoms = create_object_attribute_test(""component"", ""inherit_interlayer_atoms"", True)\n    test_inherit_layer_atoms = create_object_attribute_test(""component"", ""inherit_layer_atoms"", True)\n    test_inherit_delta_c = create_object_attribute_test(""component"", ""inherit_delta_c"", True)\n    test_inherit_default_c = create_object_attribute_test(""component"", ""inherit_default_c"", True)\n    test_inherit_ucp_a = create_object_attribute_test(""component"", ""inherit_ucp_a"", True)\n    test_inherit_ucp_b = create_object_attribute_test(""component"", ""inherit_ucp_b"", True)\n    test_inherit_d001 = create_object_attribute_test(""component"", ""inherit_d001"", True)\n\n    def _setup_inheritance(self):\n        self.component2 = Component()\n        self.component2.linked_with = self.component\n        self.component2.inherit_atom_relations = True # TODO\n        self.component2.inherit_interlayer_atoms = True # TODO\n        self.component2.inherit_layer_atoms = True # TODO\n        self.component2.inherit_delta_c = True\n        self.component2.inherit_default_c = True\n        self.component2.inherit_ucp_a = True # TODO\n        self.component2.inherit_ucp_b = True # TODO\n        self.component2.inherit_d001 = True\n\n    def test_inheritance_for_delta_c(self):\n        self._setup_inheritance()\n\n        self.component.delta_c = 0.005\n        self.assertEqual(self.component2.delta_c, 0.005)\n\n    def test_inheritance_for_default_c(self):\n        self._setup_inheritance()\n\n        self.component.default_c = 0.750\n        self.assertEqual(self.component2.default_c, 0.750)\n\n    def test_inheritance_for_d001(self):\n        self._setup_inheritance()\n\n        self.component.d001 = 0.750\n        self.assertEqual(self.component2.d001, 0.750)\n\n    pass # end of class'"
test/test_phases/test_phase.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.phases.models import Phase\nfrom pyxrd.file_parsers.phase_parsers import JSONPhaseParser\n\n__all__ = [\n    \'TestPhase\',\n]\n\nclass TestPhase(unittest.TestCase):\n\n    phase = None\n\n    def setUp(self):\n        settings.initialize()\n        self.phase = Phase(R=0, G=1)\n\n    def tearDown(self):\n        del self.phase\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.phase)\n\n    def test_data_object(self):\n        self.assertIsNotNone(self.phase.data_object)\n\n    def test_R_G(self):\n        self.assertIsNotNone(Phase(R=0, G=1))\n        self.assertIsNotNone(Phase(R=0, G=2))\n        self.assertIsNotNone(Phase(R=0, G=3))\n        self.assertIsNotNone(Phase(R=0, G=4))\n        self.assertIsNotNone(Phase(R=0, G=5))\n        self.assertIsNotNone(Phase(R=0, G=6))\n\n        self.assertIsNotNone(Phase(R=1, G=2))\n        self.assertIsNotNone(Phase(R=1, G=3))\n        self.assertIsNotNone(Phase(R=1, G=4))\n\n        self.assertIsNotNone(Phase(R=2, G=2))\n        self.assertIsNotNone(Phase(R=2, G=3))\n\n        self.assertIsNotNone(Phase(R=3, G=2))\n\n    test_name = create_object_attribute_test(""phase"", ""name"", ""Test Name"")\n    test_display_color = create_object_attribute_test(""phase"", ""display_color"", ""#FF00FF"")\n    test_default_c = create_object_attribute_test(""phase"", ""default_c"", 0.646)\n    test_sigma_star = create_object_attribute_test(""phase"", ""sigma_star"", 12.5)\n    test_inherit_display_color = create_object_attribute_test(""phase"", ""inherit_display_color"", True)\n    test_inherit_CSDS_distribution = create_object_attribute_test(""phase"", ""inherit_CSDS_distribution"", True)\n    test_inherit_sigma_star = create_object_attribute_test(""phase"", ""inherit_sigma_star"", True)\n    test_inherit_probabilities = create_object_attribute_test(""phase"", ""inherit_probabilities"", True)\n\n    def test_import_export(self):\n        from io import BytesIO\n        phases = [Phase(R=0, G=1), Phase(R=1, G=2)]\n        fn = BytesIO()\n        Phase.save_phases(phases, filename=fn)\n        loaded_phases = list(JSONPhaseParser.parse(fn))\n\n        def strip_uuid(data):\n            new_data = []\n            for line in data.split(\'\\n\'):\n                if ""uuid"" not in line:\n                    new_data.append(line)\n            return ""\\n"".join(new_data)\n\n        outp1 = [strip_uuid(phase.dump_object()) for phase in phases]\n        outp2 = [strip_uuid(phase.dump_object()) for phase in loaded_phases]\n        self.assertEqual(outp1, outp2)\n\n\n\n\n\n    pass # end of class\n'"
test/test_phases/test_unit_cell_property.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.phases.models.unit_cell_prop import UnitCellProperty\n\n__all__ = [\n    \'TestPhase\',\n]\n\nclass TestPhase(unittest.TestCase):\n\n    phase = None\n\n    def setUp(self):\n        self.ucp = UnitCellProperty(\n            name=""TestUCP"",\n            value=0.0,\n            enabled=False,\n            factor=0.0,\n            constant=0.0,\n            prop=None,\n            parent=None\n        )\n\n    def tearDown(self):\n        del self.ucp\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.ucp)\n\n    def test_value_of_prop(self):\n        class Dummy():\n            attribute = ""Test123""\n\n        dummy = Dummy()\n        self.ucp.prop = (dummy, ""attribute"")\n        self.assertEqual(self.ucp.get_value_of_prop(), dummy.attribute)\n\n        self.ucp.prop = (None, ""attribute"")\n        self.assertEqual(self.ucp.get_value_of_prop(), 0.0)\n\n    def test_update_value(self):\n        class Dummy():\n            attribute = 0.5\n\n        dummy = Dummy()\n        self.ucp.prop = (dummy, ""attribute"")\n        self.ucp.factor = 0.5\n        self.ucp.constant = 1.0\n\n        #Check that if the prop is disabled, it can be set manually:\n        self.ucp.value = 0.075\n        self.assertEqual(self.ucp.value, 0.075)\n\n        #Check that if the prop is enabled, it is calculated automatically:\n        self.ucp.enabled = True\n        self.assertEqual(self.ucp.value, 0.5 * 0.5 + 1.0)\n\n        #Check that if the prop is enabled, it can\'t be set manually:\n        self.ucp.value = 0.075\n        self.assertNotEqual(self.ucp.value, 0.075)\n\n    test_name = create_object_attribute_test(""ucp"", ""name"", ""Test Name"")\n    test_name = create_object_attribute_test(""ucp"", ""value"", 0.5)\n    test_name = create_object_attribute_test(""ucp"", ""factor"", 0.5)\n    test_name = create_object_attribute_test(""ucp"", ""constant"", 0.5)\n    test_name = create_object_attribute_test(""ucp"", ""prop"", (None, """"))\n    test_name = create_object_attribute_test(""ucp"", ""enabled"", True)\n    test_name = create_object_attribute_test(""ucp"", ""inherited"", True)\n\n    pass # end of class\n'"
test/test_probabilities/__init__.py,0,b''
test/test_probabilities/base.py,0,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n__all__ = [\n    'AbstractTestProbModel',\n]\n\nclass AbstractTestProbModel():\n\n    prob_model = None\n    prob_model_type = None\n\n    def setUp(self):\n        self.prob_model = self.prob_model_type()\n\n    def tearDown(self):\n        del self.prob_model\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.prob_model)\n\n    pass # end of class\n"""
test/test_probabilities/test_R0Models.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import AbstractTestProbModel\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.probabilities.models.R0models import *\nimport unittest\n\n__all__ = [\n    \'TestR0G1Model\',\n    \'TestR0G2Model\',\n    \'TestR0G3Model\',\n    \'TestR0G4Model\',\n    \'TestR0G5Model\',\n    \'TestR0G6Model\'\n]\n\nclass TestR0G1Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G1Model\n\n    pass # end of class\n\nclass TestR0G2Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G2Model\n\n    test_F1 = create_object_attribute_test(""prob_model"", ""F1"", 0.7)\n\n    pass # end of class\n\nclass TestR0G3Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G3Model\n\n    test_F1 = create_object_attribute_test(""prob_model"", ""F1"", 0.7)\n    test_F2 = create_object_attribute_test(""prob_model"", ""F2"", 0.7)\n\n    pass # end of class\n\nclass TestR0G4Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G4Model\n\n    test_F1 = create_object_attribute_test(""prob_model"", ""F1"", 0.7)\n    test_F2 = create_object_attribute_test(""prob_model"", ""F2"", 0.7)\n    test_F3 = create_object_attribute_test(""prob_model"", ""F3"", 0.7)\n\n    pass # end of class\n\nclass TestR0G5Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G5Model\n\n    test_F1 = create_object_attribute_test(""prob_model"", ""F1"", 0.7)\n    test_F2 = create_object_attribute_test(""prob_model"", ""F2"", 0.7)\n    test_F3 = create_object_attribute_test(""prob_model"", ""F3"", 0.7)\n    test_F4 = create_object_attribute_test(""prob_model"", ""F4"", 0.7)\n\n\n    pass # end of class\n\nclass TestR0G6Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R0G6Model\n\n    test_F1 = create_object_attribute_test(""prob_model"", ""F1"", 0.7)\n    test_F2 = create_object_attribute_test(""prob_model"", ""F2"", 0.7)\n    test_F3 = create_object_attribute_test(""prob_model"", ""F3"", 0.7)\n    test_F4 = create_object_attribute_test(""prob_model"", ""F4"", 0.7)\n    test_F5 = create_object_attribute_test(""prob_model"", ""F5"", 0.7)\n\n    pass # end of class\n'"
test/test_probabilities/test_R1Models.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import AbstractTestProbModel\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.probabilities.models.R1models import *\nimport unittest\n\n__all__ = [\n    \'TestR1G2Model\',\n    \'TestR1G3Model\',\n    \'TestR1G4Model\',\n]\n\nclass TestR1G2Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R1G2Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P11_or_P22 = create_object_attribute_test(""prob_model"", ""P11_or_P22"", 0.7)\n\n    pass # end of class\n\nclass TestR1G3Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R1G3Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P11_or_P22 = create_object_attribute_test(""prob_model"", ""P11_or_P22"", 0.7)\n    test_G1 = create_object_attribute_test(""prob_model"", ""G1"", 0.7)\n    test_G2 = create_object_attribute_test(""prob_model"", ""G2"", 0.7)\n    test_G3 = create_object_attribute_test(""prob_model"", ""G3"", 0.7)\n    test_G4 = create_object_attribute_test(""prob_model"", ""G4"", 0.7)\n\n    pass # end of class\n\nclass TestR1G4Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R1G4Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P11_or_P22 = create_object_attribute_test(""prob_model"", ""P11_or_P22"", 0.7)\n    test_R1 = create_object_attribute_test(""prob_model"", ""R1"", 0.7)\n    test_R2 = create_object_attribute_test(""prob_model"", ""R2"", 0.7)\n    test_G1 = create_object_attribute_test(""prob_model"", ""G1"", 0.7)\n    test_G2 = create_object_attribute_test(""prob_model"", ""G2"", 0.7)\n    test_G11 = create_object_attribute_test(""prob_model"", ""G11"", 0.7)\n    test_G12 = create_object_attribute_test(""prob_model"", ""G12"", 0.7)\n    test_G21 = create_object_attribute_test(""prob_model"", ""G21"", 0.7)\n    test_G22 = create_object_attribute_test(""prob_model"", ""G22"", 0.7)\n    test_G31 = create_object_attribute_test(""prob_model"", ""G31"", 0.7)\n    test_G22 = create_object_attribute_test(""prob_model"", ""G32"", 0.7)\n\n    pass # end of class\n'"
test/test_probabilities/test_R2Models.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import AbstractTestProbModel\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.probabilities.models.R2models import *\nimport unittest\n\n__all__ = [\n    \'TestR2G2Model\',\n    \'TestR2G3Model\',\n]\n\nclass TestR2G2Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R2G2Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P112_or_P211 = create_object_attribute_test(""prob_model"", ""P112_or_P211"", 0.7)\n    test_P21 = create_object_attribute_test(""prob_model"", ""P21"", 0.7)\n    test_P122_or_P221 = create_object_attribute_test(""prob_model"", ""P122_or_P221"", 0.7)\n\n    pass # end of class\n\nclass TestR2G3Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R2G3Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P111_or_P212 = create_object_attribute_test(""prob_model"", ""P111_or_P212"", 0.7)\n    test_G1 = create_object_attribute_test(""prob_model"", ""G1"", 0.7)\n    test_G2 = create_object_attribute_test(""prob_model"", ""G2"", 0.7)\n    test_G3 = create_object_attribute_test(""prob_model"", ""G3"", 0.7)\n    test_G4 = create_object_attribute_test(""prob_model"", ""G4"", 0.7)\n\n    pass # end of class\n'"
test/test_probabilities/test_R3Models.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import AbstractTestProbModel\n\nfrom test.utils import create_object_attribute_test\n\nfrom pyxrd.probabilities.models.R3models import *\nimport unittest\n\n__all__ = [\n    \'TestR3G2Model\'\n]\n\nclass TestR3G2Model(AbstractTestProbModel, unittest.TestCase):\n\n    prob_model_type = R3G2Model\n\n    test_W1 = create_object_attribute_test(""prob_model"", ""W1"", 0.7)\n    test_P1111_or_P2112 = create_object_attribute_test(""prob_model"", ""P1111_or_P2112"", 0.7)\n\n    pass # end of class\n'"
test/test_project/__init__.py,0,b''
test/test_project/test_project.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test, mock_settings\n\nfrom pyxrd.project.models import Project\n\n__all__ = [\n    \'TestProject\',\n]\n\nclass TestProject(unittest.TestCase):\n\n    project = None\n\n    def setUp(self):\n        mock_settings();\n        self.project = Project(name=""Test Project"")\n\n    def tearDown(self):\n        del self.project\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.project)\n\n    test_name = create_object_attribute_test(""project"", ""name"", ""Test Name"")\n    test_date = create_object_attribute_test(""project"", ""date"", ""19/09/1987"")\n    test_description = create_object_attribute_test(""project"", ""description"", ""Test Description"")\n    test_author = create_object_attribute_test(""project"", ""author"", ""Test Author"")\n    test_layout_mode = create_object_attribute_test(""project"", ""layout_mode"", ""FULL"")\n    test_display_marker_align = create_object_attribute_test(""project"", ""display_marker_align"", ""right"")\n    test_display_marker_color = create_object_attribute_test(""project"", ""display_marker_color"", ""#FF00FF"")\n    test_display_marker_base = create_object_attribute_test(""project"", ""display_marker_base"", 2)\n    test_display_marker_top = create_object_attribute_test(""project"", ""display_marker_top"", 1)\n    test_display_marker_top_offset = create_object_attribute_test(""project"", ""display_marker_top_offset"", 0.5)\n    test_display_marker_angle = create_object_attribute_test(""project"", ""display_marker_angle"", 45.6)\n    test_display_marker_style = create_object_attribute_test(""project"", ""display_marker_style"", ""dashed"")\n    test_display_calc_color = create_object_attribute_test(""project"", ""display_calc_color"", ""#FF0099"")\n    test_display_exp_color = create_object_attribute_test(""project"", ""display_exp_color"", ""#9900FF"")\n    test_display_calc_lw = create_object_attribute_test(""project"", ""display_calc_lw"", 5)\n    test_display_exp_lw = create_object_attribute_test(""project"", ""display_exp_lw"", 1)\n    test_display_plot_offset = create_object_attribute_test(""project"", ""display_plot_offset"", 1.5)\n    test_display_group_by = create_object_attribute_test(""project"", ""display_group_by"", 3)\n    test_display_label_pos = create_object_attribute_test(""project"", ""display_label_pos"", 0.75)\n    test_axes_xscale = create_object_attribute_test(""project"", ""axes_xscale"", 1)\n    test_axes_xmin = create_object_attribute_test(""project"", ""axes_xmin"", 15)\n    test_axes_xmax = create_object_attribute_test(""project"", ""axes_xmax"", 52)\n    test_axes_xstretch = create_object_attribute_test(""project"", ""axes_xstretch"", True)\n    test_axes_yscale = create_object_attribute_test(""project"", ""axes_yscale"", 1)\n    test_axes_yvisible = create_object_attribute_test(""project"", ""axes_yvisible"", True)\n\n    # TODO\n    #  - addition of phases, specimens & atom_types\n    #  - loading of phases, specimens & atom_types\n    #  - testing inherit properties (markers)\n    #  - testing initialization deprecated keywords etc.\n\n    pass # end of class\n'"
tests_mvc/adapters/__init__.py,0,b''
win_installer/misc/create-launcher.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright 2016 Christoph Reiter\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n""""""Creates simple Python .exe launchers for gui and cli apps\n\n./create-launcher.py ""3.8.0"" <target-dir>\n""""""\n\nimport os\nimport sys\nimport subprocess\nimport shlex\nimport tempfile\nimport shutil\nimport struct\n\n\ndef build_resource(rc_path, out_path):\n    """"""Raises subprocess.CalledProcessError""""""\n\n    def is_64bit():\n        return struct.calcsize(""P"") == 8\n\n    subprocess.check_call(\n        [""windres"", ""-O"", ""coff"", ""-F"",\n         ""pe-x86-64"" if is_64bit() else ""pe-i386"", rc_path,\n        ""-o"", out_path])\n\n\ndef get_build_args():\n    python_name = os.path.splitext(os.path.basename(sys.executable))[0]\n    python_config = os.path.join(\n        os.path.dirname(sys.executable), python_name + ""-config"")\n\n    cflags = subprocess.check_output(\n        [""sh"", python_config, ""--cflags""]).strip()\n    libs = subprocess.check_output(\n        [""sh"", python_config, ""--libs""]).strip()\n\n    cflags = os.fsdecode(cflags)\n    libs = os.fsdecode(libs)\n    return shlex.split(cflags) + shlex.split(libs)\n\n\ndef build_exe(source_path, resource_path, is_gui, out_path):\n    args = [""gcc"", ""-s""]\n    if is_gui:\n        args.append(""-mwindows"")\n    args.append(""-municode"")\n    args.extend([""-o"", out_path, source_path, resource_path])\n    args.extend(get_build_args())\n    subprocess.check_call(args)\n\n\ndef get_launcher_code(entry_point):\n    module, func = entry_point.split("":"", 1)\n\n    template = """"""\\\n#include ""Python.h""\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\n                    PWSTR lpCmdLine, int nCmdShow)\n{\n    int result;\n\n    Py_NoUserSiteDirectory = 1;\n    Py_IgnoreEnvironmentFlag = 1;\n    Py_DontWriteBytecodeFlag = 1;\n    Py_Initialize();\n    PySys_SetArgvEx(__argc, __wargv, 0);\n    result = PyRun_SimpleString(""%s"");\n    Py_Finalize();\n    return result;\n}\n    """"""\n\n    launch_code = ""import sys; from %s import %s; sys.exit(%s())"" % (\n        module, func, func)\n    return template % launch_code\n\n\ndef get_resource_code(filename, file_version, file_desc, icon_path,\n                     product_name, product_version, company_name):\n\n    template = """"""\\\n1 ICON ""%(icon_path)s""\n1 VERSIONINFO\nFILEVERSION     %(file_version_list)s\nPRODUCTVERSION  %(product_version_list)s\nFILEOS 0x4\nFILETYPE 0x1\nBEGIN\n    BLOCK ""StringFileInfo""\n    BEGIN\n        BLOCK ""040904E4""\n        BEGIN\n            VALUE ""CompanyName"",      ""%(company_name)s""\n            VALUE ""FileDescription"",  ""%(file_desc)s""\n            VALUE ""FileVersion"",      ""%(file_version)s""\n            VALUE ""InternalName"",     ""%(internal_name)s""\n            VALUE ""OriginalFilename"", ""%(filename)s""\n            VALUE ""ProductName"",      ""%(product_name)s""\n            VALUE ""ProductVersion"",   ""%(product_version)s""\n        END\n    END\n    BLOCK ""VarFileInfo""\n    BEGIN\n        VALUE ""Translation"", 0x409, 1252\n    END\nEND\n""""""\n\n    def to_ver_list(v):\n        return "","".join(map(str, (list(v.split(""."")) + [0] * 4)[:4]))\n\n    file_version_list = to_ver_list(file_version)\n    product_version_list = to_ver_list(product_version)\n\n    return template % {\n        ""icon_path"": icon_path, ""file_version_list"": file_version_list,\n        ""product_version_list"": product_version_list,\n        ""file_version"": file_version, ""product_version"": product_version,\n        ""company_name"": company_name, ""filename"": filename,\n        ""internal_name"": os.path.splitext(filename)[0],\n        ""product_name"": product_name, ""file_desc"": file_desc,\n    }\n\n\ndef build_launcher(out_path, icon_path, file_desc, product_name, product_version,\n                   company_name, entry_point, is_gui):\n\n    src_ico = os.path.abspath(icon_path)\n    target = os.path.abspath(out_path)\n\n    file_version = product_version\n\n    dir_ = os.getcwd()\n    temp = tempfile.mkdtemp()\n    try:\n        os.chdir(temp)\n        with open(""launcher.c"", ""w"") as h:\n            h.write(get_launcher_code(entry_point))\n        shutil.copyfile(src_ico, ""launcher.ico"")\n        with open(""launcher.rc"", ""w"") as h:\n            h.write(get_resource_code(\n                os.path.basename(target), file_version, file_desc,\n                ""launcher.ico"", product_name, product_version, company_name))\n\n        build_resource(""launcher.rc"", ""launcher.res"")\n        build_exe(""launcher.c"", ""launcher.res"", is_gui, target)\n    finally:\n        os.chdir(dir_)\n        shutil.rmtree(temp)\n\n\ndef main():\n    argv = sys.argv\n\n    version = argv[1]\n    target = argv[2]\n\n    company_name = ""Ghent University""\n    product_name = ""PyXRD""\n    misc = os.path.dirname(os.path.realpath(__file__))\n\n    build_launcher(\n        os.path.join(target, ""pyxrd.exe""),\n        os.path.join(misc, ""pyxrd.ico""), product_name, product_name,\n        version, company_name, ""pyxrd.core:run_main"", True)\n\n    build_launcher(\n        os.path.join(target, ""pyxrd-cmd.exe""),\n        os.path.join(misc, ""pyxrd.ico""), product_name, product_name,\n        version, company_name, ""pyxrd.core:run_main"", False)\n\nif __name__ == ""__main__"":\n    main()\n'"
win_installer/misc/depcheck.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# Copyright 2016,2017 Christoph Reiter\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n""""""\nDeletes unneeded DLLs and checks DLL dependencies.\nExecute with the build python, will figure out the rest.\n""""""\n\nimport subprocess\nimport os\nimport sys\nfrom multiprocessing import Process, Queue\n\nimport gi\ngi.require_version(""GIRepository"", ""2.0"")\nfrom gi.repository import GIRepository\n\n\ndef _get_shared_libraries(q, namespace, version):\n    repo = GIRepository.Repository()\n    repo.require(namespace, version, 0)\n    lib = repo.get_shared_library(namespace)\n    q.put(lib)\n\n\ndef get_shared_libraries(namespace, version):\n    # we have to start a new process because multiple versions can\'t be loaded\n    # in the same process\n    q = Queue()\n    p = Process(target=_get_shared_libraries, args=(q, namespace, version))\n    p.start()\n    result = q.get()\n    p.join()\n    return result\n\n\ndef get_required_by_typelibs():\n    deps = set()\n    repo = GIRepository.Repository()\n    for tl in os.listdir(repo.get_search_path()[0]):\n        namespace, version = os.path.splitext(tl)[0].split(""-"", 1)\n        lib = get_shared_libraries(namespace, version)\n        if lib:\n            libs = lib.lower().split("","")\n        else:\n            libs = []\n        for lib in libs:\n            deps.add((namespace, version, lib))\n    return deps\n\n\ndef get_dependencies(filename):\n    deps = []\n    try:\n        data = subprocess.check_output([""objdump"", ""-p"", filename],\n            stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError:\n        # can happen with wrong arch binaries\n        return []\n    data = data.decode(""utf-8"")\n    for line in data.splitlines():\n        line = line.strip()\n        if line.startswith(""DLL Name:""):\n            deps.append(line.split("":"", 1)[-1].strip().lower())\n    return deps\n\n\ndef find_lib(root, name):\n    system_search_path = os.path.join(""C:"", os.sep, ""Windows"", ""System32"")\n    if get_lib_path(root, name):\n        return True\n    elif os.path.exists(os.path.join(system_search_path, name)):\n        return True\n    elif name in [""gdiplus.dll""]:\n        return True\n    elif name.startswith(""msvcr""):\n        return True\n    return False\n\n\ndef get_lib_path(root, name):\n    search_path = os.path.join(root, ""bin"")\n    if os.path.exists(os.path.join(search_path, name)):\n        return os.path.join(search_path, name)\n\n\ndef get_things_to_delete(root):\n    extensions = ["".exe"", "".pyd"", "".dll""]\n\n    all_libs = set()\n    needed = set()\n    for base, dirs, files in os.walk(root):\n        for f in files:\n            lib = f.lower()\n            path = os.path.join(base, f)\n            ext_lower = os.path.splitext(f)[-1].lower()\n            if ext_lower in extensions:\n                if ext_lower == "".exe"":\n                    # we use .exe as dependency root\n                    needed.add(lib)\n                all_libs.add(f.lower())\n                for lib in get_dependencies(path):\n                    all_libs.add(lib)\n                    needed.add(lib)\n                    if not find_lib(root, lib):\n                        print(""MISSING:"", path, lib)\n\n    for namespace, version, lib in get_required_by_typelibs():\n        all_libs.add(lib)\n        needed.add(lib)\n        if not find_lib(root, lib):\n            print(""MISSING:"", namespace, version, lib)\n\n    to_delete = []\n    for not_depended_on in (all_libs - needed):\n        path = get_lib_path(root, not_depended_on)\n        if path:\n            to_delete.append(path)\n\n    return to_delete\n\n\ndef main(argv):\n    libs = get_things_to_delete(sys.prefix)\n\n    if ""--delete"" in argv[1:]:\n        while libs:\n            for l in libs:\n                print(""DELETE:"", l)\n                os.unlink(l)\n            libs = get_things_to_delete(sys.prefix)\n\n\nif __name__ == ""__main__"":\n    main(sys.argv)\n'"
mvc/adapters/gtk_support/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\ntoolkit = ""gtk""\n\ndef load(tkreg):\n    # Load adapters:\n    from .adjustment_adapter import AdjustmentAdapter\n    from .arrow_adapter import ArrowAdapter\n    from .check_menu_item_adapter import CheckMenuItemAdapter\n    from .color_button_adapter import ColorButtonAdapter\n    from .color_selection_adapter import ColorSelectionAdapter\n    from .combo_box_adapter import ComboBoxAdapter\n    from .entry_adapter import EntryAdapter\n    from .expander_adapter import ExpanderAdapter\n    from .file_chooser_adapter import FileChooserAdapter\n    from .float_entry_adapter import FloatEntryAdapter\n    from .label_adapter import LabelAdapter\n    from .link_button_adapter import LinkButtonAdapter\n    from .scale_adapter import ScaleEntryAdapter\n    from .text_view_adapter import TextViewAdapter\n    from .toggle_button_adapter import ToggleButtonAdapter\n    from .tree_view_adapters import XYListViewAdapter, ObjectListViewAdapter\n    \n    # Load main loop functions\n    from .toolkit_functions import (\n        add_idle_call, remove_source, \n        add_timeout_call, \n        start_event_loop, stop_event_loop\n    )\n    \n    # Register them\n    tkreg.set_toolkit_functions(\n        add_idle_call, remove_source, \n        add_timeout_call, remove_source, \n        start_event_loop, stop_event_loop\n    )\n'"
mvc/adapters/gtk_support/_gtk_color_utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gdk\n\ndef _parse_color_string(value):\n    """"""Converts a hex-formatted (e.g. #FFFFFF) string to a Gdk color object""""""\n    color = Gdk.RGBA()\n    color.parse(value)\n    return color  # @UndefinedVariable\n\ndef _parse_color_value(value):\n    """"""Converts a Gdk color object to a hex-formatted string (e.g. #FFFFFF)""""""\n    return ""#%02x%02x%02x"" % (int(value.red * 255), int(value.green * 255), int(value.blue * 255))'"
mvc/adapters/gtk_support/adjustment_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom .basic import GtkAdapter\n\nclass AdjustmentAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Adjustment widget\n    """"""\n    widget_types = [""spin"", ""spin_button""]\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.Adjustment.get_value)\n    _wid_write = GtkAdapter.static_to_class(Gtk.Adjustment.set_value)\n    _signal = ""value-changed""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/arrow_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom .basic import GtkAdapter\n\nclass ArrowAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Arrow widget\n    """"""\n    widget_types = [""arrow""]\n    _check_widget_type = Gtk.Arrow\n\n    _wid_read = lambda a: a.get_property(""arrow-type"")\n    _wid_write = lambda a, v: a.set(v, a.get_property(""shadow-type""))\n    _signal = ""changed""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/basic.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom contextlib import contextmanager\nfrom ...adapters.model_adapter import ModelAdapter\nfrom ...support.utils import not_none\n\nclass GtkAdapter(ModelAdapter):\n    """"""\n        A base class for Gtk-widget Adapters\n    """"""\n    toolkit = ""gtk""\n\n    # Widget-side value handling:\n    _wid_read = None\n    _wid_write = None\n    _signal = None\n    _signal_id = None\n    _signal_args = []\n    _check_widget_type = None\n\n    def __init__(self, controller, prop, widget,\n            prop_read=None, prop_write=None,\n            value_error=None, spurious=False,\n            wid_read=None, wid_write=None,\n            signal=None, signal_args=None, update=True):\n        """"""\n            wid_read and wid_write are the methods used for reading and writing the\n            widget\'s value.\n            \n            signal is the signal name to listen to for widget updates  \n            signal_args is the (optional) (list of) argument(s) that will be\n            passed when connecting the signal.\n    \n            Finally, if update is false, the widget will not be initially updated\n        """"""\n        super(GtkAdapter, self).__init__(\n            controller, prop, widget,\n            prop_read=prop_read, prop_write=prop_write,\n            value_error=value_error, spurious=spurious\n        )\n        # Widget-side value handling:\n        self._wid_read = not_none(wid_read, self._wid_read)\n        self._wid_write = not_none(wid_write, self._wid_write)\n        self._signal = not_none(signal, self._signal)\n        self._signal_id = None\n        self._signal_args = not_none(signal_args, self._signal_args)\n        self._update = update\n\n        if self._check_widget_type is not None:\n            widget_type = type(widget)\n            if not isinstance(widget, self._check_widget_type):\n                msg = ""Property \'%s\' from model \'%s\' has a widget type %s, "" \\\n                      ""which can only be used for (a subclass of) a %s "" \\\n                      ""widget, and not for a %s widget!"" % (\n                          prop.label, controller.model, type(self),\n                          self._check_widget_type, widget_type\n                      )\n                raise TypeError(msg)\n        # Connect the widget:\n        self._connect_widget()\n\n    # ----------------------------------------------------------------------\n    #  Widget connecting & disconnecting:\n    # ----------------------------------------------------------------------\n    def _connect_widget(self):\n        """"""Called when the adapter is ready to connect to the widget""""""\n\n        # Connect the widget\n        if self._signal:\n            try:\n                self._signal_id = self._widget.connect(\n                    self._signal, self._on_wid_changed, self._signal_args)\n            except TypeError:\n                logger.error(""Failed to connect signal named \'%s\' on widget \'%s\' for property \'%s\'!"" % (self._signal, self._widget, self._prop.label))\n                raise\n\n        # Updates the widget:\n        if self._update: self.update_widget()\n        return\n\n    def _on_wid_changed(self, wid, *args):\n        """"""Called when the widget is changed""""""\n        if self._ignoring_notifs: return\n        self.update_model()\n        return\n\n    def _disconnect_widget(self, widget=None):\n        """"""Disconnects the widget""""""\n        if self._signal is not None and self._signal_id is not None:\n            widget = not_none(self._widget, widget)\n            if widget is not None:\n                widget.disconnect(self._signal_id)\n            self._signal, self._signal_id = None, None\n\n    # ----------------------------------------------------------------------\n    #  Widget-side reading and writing\n    # ----------------------------------------------------------------------\n    @contextmanager\n    def _block_widget_signal(self):\n        if self._signal_id is not None: self._widget.handler_block(self._signal_id)\n        yield\n        if self._signal_id is not None: self._widget.handler_unblock(self._signal_id)\n\n    def _read_widget(self):\n        """"""Returns the value currently stored into the widget.""""""\n        return self._wid_read(self._widget)\n\n    def _write_widget(self, val):\n        """"""Writes value into the widget. If specified, user setter\n        is invoked.""""""\n        with self._ignore_notifications():\n            return self._wid_write(self._widget, val)\n\n    @staticmethod\n    def static_to_class(func):\n        def wrapper(c, *args, **kwargs):\n            return func(*args, **kwargs)\n        return wrapper\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/check_menu_item_adapter.py,0,"b'#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom .basic import GtkAdapter\n\nclass CheckMenuItemAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.CheckMenuItem widget\n    """"""\n    widget_types = [""check_menu""]\n    _check_widget_type = Gtk.CheckMenuItem\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.CheckMenuItem.get_active)\n    _wid_write = GtkAdapter.static_to_class(Gtk.CheckMenuItem.set_active)\n    _signal = ""toggled""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/color_button_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\nfrom ._gtk_color_utils import _parse_color_string, _parse_color_value\n\nclass ColorButtonAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Label widget\n    """"""\n    widget_types = [""color"", ""color_button""]\n    _check_widget_type = Gtk.ColorButton\n\n    _wid_read = lambda s, w: w.get_rgba()\n    _wid_write = lambda s, w, v: w.set_rgba(v) if w.get_realized() else None\n    _signal = ""color-set""\n\n    _prop_read = lambda s, *a: _parse_color_string(*a)\n    _prop_write = lambda s, *a: _parse_color_value(*a)\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/color_selection_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\nfrom ._gtk_color_utils import _parse_color_string, _parse_color_value\n\nclass ColorSelectionAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Label widget\n    """"""\n    widget_types = [""color_selection""]\n    _check_widget_type = Gtk.ColorSelection\n\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.ColorSelection.get_current_color)\n    _wid_write = GtkAdapter.static_to_class(Gtk.ColorSelection.set_current_color)\n    _signal = ""color-set""\n\n    _prop_read = _parse_color_string\n    _prop_write = _parse_color_value\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/combo_box_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom ...support.utils import not_none\nfrom .basic import GtkAdapter\n\n\nclass ComboBoxAdapter(GtkAdapter):\n    """"""\n        An adapter that adapts a ComboBox widget to an property which has a \n        choices attribute containing dictionary with allowed (value, description)\n        pairs as keys and values.\n    """"""\n    widget_types = [""option_list"", ]\n    _check_widget_type = Gtk.ComboBox\n\n    _wid_read = lambda c, w, *a: Gtk.ComboBox.get_active_iter(w, *a)\n    _wid_write = lambda c, w, *a: Gtk.ComboBox.set_active_iter(w, *a)\n    _signal = ""changed""\n\n    _prop_cast = False\n\n    def _parse_prop(self, prop, model):\n        """"""Parses (optional) prop strings for the given model""""""\n        prop, model = super(ComboBoxAdapter, self)._parse_prop(prop, model)\n        if not isinstance(prop.choices, dict):\n            raise ValueError(""ComboBox widget handler requires a property with a \'choices\' dictionary!"")\n        else:\n            self._store = Gtk.ListStore(str, str)\n            for key, value in prop.choices.items():\n                self._store.append([str(key), str(value)])\n        return prop, model\n\n    def _prop_write(self, itr):\n        if itr is not None:\n            return self._store.get_value(itr, 0)\n\n    def _prop_read(self, val):\n        for row in self._store:\n            if self._store.get_value(row.iter, 0) == str(val):\n                return row.iter\n\n    def _connect_widget(self):\n        # Set up the combo box layout:\n        cell = Gtk.CellRendererText()\n        self._widget.clear()\n        self._widget.pack_start(cell, True)\n        self._widget.add_attribute(cell, \'text\', 1)\n        cell.set_property(\'family\', \'Monospace\')\n        cell.set_property(\'size-points\', 10)\n\n        # Set the model:\n        self._widget.set_model(self._store)\n\n        # Continue as usual:\n        super(ComboBoxAdapter, self)._connect_widget()\n\n    def disconnect(self, model=None, widget=None):\n        widget = not_none(self._widget, widget)\n        if widget is not None: widget.set_model(None)\n        super(ComboBoxAdapter, self).disconnect(model=model, widget=widget)\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/entry_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\n\nclass EntryAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Entry widget\n    """"""\n    widget_types = [""entry"", ""input""]\n    _check_widget_type = Gtk.Entry\n\n    _wid_read = lambda c, w: Gtk.Entry.get_text(w)\n    _wid_write = lambda c, w, v: Gtk.Entry.set_text(w, str(v))\n    _signal = ""changed""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/expander_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\n\nclass ExpanderAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Expander widget\n    """"""\n    widget_types = [""expander""]\n    _check_widget_type = Gtk.Expander\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.Expander.get_expanded)\n    _wid_write = GtkAdapter.static_to_class(Gtk.Expander.set_expanded)\n    _signal = ""activate""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/file_chooser_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\n\nclass FileChooserAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.FileChooser widget\n    """"""\n    widget_types = [""file"", ""file_chooser""]\n    _check_widget_type = Gtk.FileChooser\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.FileChooser.get_filename)\n    _wid_write = GtkAdapter.static_to_class(Gtk.FileChooser.set_filename)\n    _signal = ""file-set""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/float_entry_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport re\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .entry_adapter import EntryAdapter\n\nclass FloatEntryAdapter(EntryAdapter):\n    """"""\n        An adapter for a Gtk.Entry widget holding a float.\n    """"""\n    widget_types = [""float_entry"", ""float_input""]\n    _check_widget_type = Gtk.Entry\n    _signal = ""changed""\n\n    def __init__(self, *args, **kwargs):\n        super(FloatEntryAdapter, self).__init__(*args, **kwargs)\n        numeric_const_pattern = r""""""\n        [-+]? # optional sign\n        (?:\n            (?: \\d* \\. \\d+ ) # .1 .12 .123 etc 9.1 etc 98.1 etc\n            |\n            (?: \\d+ \\.? ) # 1. 12. 123. etc 1 12 123 etc\n        )\n        # followed by optional exponent part if desired\n        (?: [Ee] [+-]? \\d+ ) ?\n        """"""\n        self.rx = re.compile(numeric_const_pattern, re.VERBOSE)\n\n    def _prop_read(self, *args):\n        return str(*args)\n\n    def _prop_write(self, *args):\n        try:\n            return float(*args)\n        except ValueError:\n            return self._get_property_value()\n\n    def _on_wid_changed(self, widget, *args):\n        """"""Called when the widget is changed""""""\n        with self._block_widget_signal():\n            if self._ignoring_notifs: return\n            self._validate_float(widget)\n            super(FloatEntryAdapter, self)._on_wid_changed(widget, *args)\n\n    def _validate_float(self, entry):\n        entry_text = entry.get_text()\n        newtext = self.rx.findall(entry_text)\n        if len(newtext) > 0:\n            entry.set_text(newtext[0])\n        else:\n            entry.set_text("""")\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/label_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\n\nclass LabelAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.Label widget\n    """"""\n    widget_types = [""label""]\n    _check_widget_type = Gtk.Label\n\n    _wid_read = lambda c, w: Gtk.Label.get_text(w)\n    _wid_write = lambda c, w, v: Gtk.Label.set_text(w, str(v))\n\n    _signal = None\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/link_button_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom .basic import GtkAdapter\n\nclass LinkButtonAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.LinkButton widget\n    """"""\n    widget_types = [""link"", ""link_button""]\n    _check_widget_type = Gtk.LinkButton\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.LinkButton.get_uri)\n    _wid_write = GtkAdapter.static_to_class(Gtk.LinkButton.set_uri)\n    _signal = ""clicked""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/scale_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .basic import GtkAdapter\nfrom .widgets.scale_entry import ScaleEntry\n\nclass ScaleEntryAdapter(GtkAdapter):\n    """"""\n        An adapter for a ScaleEntry widget.\n    """"""\n    widget_types = [""scale"", ]\n    _check_widget_type = ScaleEntry\n\n    _wid_read = GtkAdapter.static_to_class(ScaleEntry.get_value)\n    _wid_write = GtkAdapter.static_to_class(ScaleEntry.set_value)\n    _signal = ""changed""\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/text_view_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom .basic import GtkAdapter\n\nclass TextViewAdapter(GtkAdapter):\n    """"""\n        An adapter for a TextView widget.\n    """"""\n    widget_types = [""text_view"", ]\n    _check_widget_type = Gtk.TextView\n\n    _prop_cast = False\n\n    def _read_widget(self):\n        """"""Returns the value currently stored into the widget.""""""\n        return str(self._buffer.get_text(*self._buffer.get_bounds()))\n\n    def _write_widget(self, val):\n        """"""Writes value into the widget. If specified, user setter\n        is invoked.""""""\n        with self._ignore_notifications():\n            return self._buffer.set_text(val)\n\n\n    _signal = ""changed""\n\n    def __init__(self, controller, prop, widget,\n                 value_error=None, spurious=False, update=True):\n\n        if prop.data_type == object: # assume TextBuffer type\n            # TODO\n            self._buffer = self._read_property()\n        else: # assume string type\n            self._buffer = Gtk.TextBuffer()\n\n        super(TextViewAdapter, self).__init__(controller, prop, widget,\n                 value_error=value_error, spurious=spurious, update=update)\n\n        self._widget.set_buffer(self._buffer)\n\n    def _connect_widget(self):\n        """"""Called when the adapter is ready to connect to the widget""""""\n\n        # Connect the widget\n        if self._signal:\n            self._signal_id = self._buffer.connect(\n               self._signal, self._on_wid_changed, self._signal_args)\n\n        # Updates the widget:\n        if self._update: self.update_widget()\n        return\n\n    def _disconnect_widget(self, widget=None):\n        """"""Disconnects the widget""""""\n        if self._signal is not None and self._signal_id is not None:\n            self._buffer.disconnect(self._signal_id)\n\n    def _set_property_value(self, val):\n        """"""Private method that sets the property value stored in the model,\n        without transformations.""""""\n        return setattr(self._model, self._prop.label, val)\n\n    pass # end of class\n\n'"
mvc/adapters/gtk_support/toggle_button_adapter.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom .basic import GtkAdapter\n\nclass ToggleButtonAdapter(GtkAdapter):\n    """"""\n        An adapter for a Gtk.ToggleButton widget\n    """"""\n    widget_types = [""toggle"", ""toggle_button""]\n    _check_widget_type = Gtk.ToggleButton\n\n    _wid_read = GtkAdapter.static_to_class(Gtk.ToggleButton.get_active)\n    _wid_write = GtkAdapter.static_to_class(Gtk.ToggleButton.set_active)\n    _signal = ""toggled""\n\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/toolkit_functions.py,0,"b""# coding=UTF-8\n# ex:ts=4:sw=4r:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version('Gtk', '3.0')  # @UndefinedVariable\nfrom gi.repository import Gtk, GLib  # @UnresolvedImport\n\ndef add_idle_call(func, *args):\n    source = GLib.MainContext.default().find_source_by_id(\n        GLib.idle_add(func, *args, priority=GLib.PRIORITY_HIGH_IDLE))\n    return source\n\ndef remove_source(source):\n    return source.destroy()\n\ndef add_timeout_call(timeout, func, *args):\n    source = GLib.MainContext.default().find_source_by_id(\n        GLib.timeout_add(timeout, func, priority=GLib.PRIORITY_HIGH, *args))\n    return source\n\ndef start_event_loop():\n    return Gtk.main()\n\ndef stop_event_loop():\n    return Gtk.main_quit()"""
mvc/adapters/gtk_support/tree_view_adapters.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nfrom ..abstract_adapter import AbstractAdapter\n\ndef wrap_property_to_treemodel_type(model, prop, treemodel_type):\n    prop_value = getattr(model, prop.label)\n    if not isinstance(prop_value, Gtk.TreeModel):\n        wrapper = getattr(model, ""__%s_treemodel_wrapper"" % prop.label, None)\n        if wrapper is None or not wrapper.is_wrapping(model, prop.label):\n            wrapper = treemodel_type(model, prop)\n        setattr(model, ""__%s_treemodel_wrapper"" % prop.label, wrapper)\n        prop_value = wrapper\n    return prop_value\n\ndef wrap_treenode_property_to_treemodel(model, prop):\n    """"""\n        Convenience function that (sparsely) wraps a TreeNode property\n        to an ObjectTreeStore. If the property is a Gtk.TreeModel instance,\n        it returns it without wrapping.\n    """"""\n    from .treemodels import ObjectTreeStore\n    return wrap_property_to_treemodel_type(model, prop, ObjectTreeStore)\n\ndef wrap_list_property_to_treemodel(model, prop):\n    """"""\n        Convenience function that (sparsely) wraps a list property\n        to an ObjectListStore. If the property is an Gtk.TreeModel instance,\n        it returns it without wrapping.\n    """"""\n    from .treemodels import ObjectListStore\n    return wrap_property_to_treemodel_type(model, prop, ObjectListStore)\n\ndef wrap_xydata_to_treemodel(model, prop):\n    """"""\n        Convenience function that (sparsely) wraps an XYData model\n        to an XYListStore. If the property is an Gtk.TreeModel instance,\n        it returns it without wrapping.\n    """"""\n    from .treemodels import XYListStore\n    return wrap_property_to_treemodel_type(model, prop, XYListStore)\n\nclass AbstractTreeViewAdapter(AbstractAdapter):\n    """"""\n        Abstract base class for the ObjectTreeViewAdapter and\n        XYTreeViewAdapter.\n    """"""\n    toolkit = ""gtk""\n    _check_widget_type = Gtk.TreeView\n\n    _signal = ""changed""\n\n    def __init__(self, controller, prop, widget):\n        super(AbstractTreeViewAdapter, self).__init__(controller, prop, widget)\n        if self._check_widget_type is not None:\n            widget_type = type(widget)\n            if not isinstance(widget, self._check_widget_type):\n                raise TypeError(""A \'%s\' can only be used for (a subclass of) a \'%s\' widget, and not for a \'%s\'!"" % (\n                       type(self), self._check_widget_type, widget_type\n                ))\n        self._connect_widget()\n\n    def _connect_widget(self):\n        self._widget.set_model(self._treestore)\n        setup = getattr(self._controller, ""setup_%s_tree_view"" % self._prop.label, None)\n        if callable(setup):\n            setup(self._treestore, self._widget)\n        else:\n            logger.error(""Could not find setup callable for tree view widget \'%s\' adapted to \'%s\'"" % (\n                self._widget,\n                self._prop.label\n            ))\n\n    def _disconnect_widget(self, widget=None):\n        # TODO reset_tree_view support\n        self._widget.set_model(None)\n\n    def _connect_model(self):\n        pass # nothing to do\n\n    def _disconnect_model(self, model=None):\n        pass # nothing to do\n\n    def _read_widget(self):\n        pass # nothing to do\n\n    def _write_widget(self, val):\n        pass # nothing to do\n\n    def _read_property(self, *args):\n        pass # nothing to do\n\n    def _write_property(self, value, *args):\n        pass # nothing to do\n\n    pass # end of class\n\nclass ObjectListViewAdapter(AbstractTreeViewAdapter):\n    """"""\n        An adapter for a TreeView widget, representing a list of objects.\n    """"""\n\n    widget_types = [""object_list_view"", ]\n\n    def __init__(self, controller, prop, widget):\n        assert hasattr(prop, ""data_type""), ""ObjectTreeViewAdapter requires the "" + \\\n            ""\'data_type\' attribute to be set on the property descriptor.\\n"" + \\\n            ""Controller: \'%s\', Model: \'%s\', Property: \'%s\'"" % (controller, controller.model, prop.label)\n        self._treestore = wrap_list_property_to_treemodel(controller.model, prop)\n        super(ObjectListViewAdapter, self).__init__(controller, prop, widget)\n\n    pass # end of class\n\nclass XYListViewAdapter(AbstractTreeViewAdapter): # TODO move this back outside this namespace or move the XYData object back in here...\n    """"""\n        An adapter for a TreeView widget, representing an XYData model.\n    """"""\n\n    widget_types = [""xy_list_view"", ]\n\n    def __init__(self, controller, prop, widget):\n        self._treestore = wrap_xydata_to_treemodel(controller.model, prop)\n        super(XYListViewAdapter, self).__init__(controller, prop, widget)\n\n    pass # end of class\n\nclass ObjectTreeViewAdapter(AbstractTreeViewAdapter):\n    """"""\n        An adapter for a TreeView widget, representing a tree of objects.\n    """"""\n\n    widget_types = [""object_tree_view"", ]\n\n    def __init__(self, controller, prop, widget):\n        self._treestore = wrap_treenode_property_to_treemodel(controller.model, prop)\n        super(ObjectTreeViewAdapter, self).__init__(controller, prop, widget)\n\n    pass # end of class'"
mvc/models/properties/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .labeled_property import LabeledProperty\nfrom .signal_property import SignalProperty\nfrom .cast_property import CastProperty\nfrom .cast_choice_property import CastChoiceProperty\nfrom .list_property import ListProperty\n\nfrom .uuid_property import UUIDProperty\n\nfrom .bool_property import BoolProperty\nfrom .integer_properties import IntegerChoiceProperty, IntegerProperty\nfrom .float_properties import FloatChoiceProperty, FloatProperty\nfrom .string_properties import StringChoiceProperty, StringProperty, ColorProperty\n\nfrom .signal_mixin import SignalMixin\nfrom .read_only_mixin import ReadOnlyMixin\nfrom .action_mixins import GetActionMixin, SetActionMixin\nfrom .observe_mixin import ObserveMixin\n\n\n__all__ = [\n    ""LabeledProperty"",\n    ""SignalProperty"",\n    ""CastProperty"",\n    ""CastChoiceProperty"",\n    ""ListProperty"",\n    ""UUIDProperty"",\n    ""BoolProperty"",\n    ""IntegerChoiceProperty"", ""IntegerProperty"",\n    ""FloatChoiceProperty"", ""FloatProperty"",\n    ""StringChoiceProperty"", ""StringProperty"", ""ColorProperty"",\n    ""SignalMixin"",\n    ""ReadOnlyMixin"",\n    ""GetActionMixin"", ""SetActionMixin"",\n    ""ObserveMixin"",\n]'"
mvc/models/properties/action_mixins.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom mvc.support.utils import rec_getattr\n\nclass SetActionMixin(object):\n    """"""\n    A descriptor mixin that will invoke a method on the instance\n    owning this property after setting it.\n    \n    Expects two more keyword arguments to be passed to the property constructor:\n        - set_action_name: a dotted string describing where to get the method\n          from the instance\n        - set_action_before: flag indicating whether this action should be \n          invoked before setting the property (default False) \n    """"""\n\n    set_action_name = None\n    set_action_before = False\n\n    def __set__(self, instance, value):\n        action = rec_getattr(instance, self.set_action_name, None)\n        assert callable(action), ""The action in a SetActionMixin (%s) should be callable!"" % self.label\n        if self.set_action_before: action()\n        super(SetActionMixin, self).__set__(instance, value)\n        if not self.set_action_before: action()\n\n\n    pass # end of class\n\nclass GetActionMixin(object):\n    """"""\n    A descriptor mixin that will invoke a method on the instance\n    owning this property before getting it.\n    \n    Expects two more keyword arguments to be passed to the property constructor:\n        - get_action_name: a dotted string describing where to get the method\n          from the instance\n        - get_action_after: flag indicating whether this action should be \n          invoked after setting the property (default False) \n    """"""\n\n    get_action_name = None\n    get_action_after = False\n\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        action = rec_getattr(instance, self.get_action_name, None)\n        assert callable(action), ""The action in a GetActionMixin (%s) should be callable!"" % self.label\n        if self.get_action_after: action()\n        value = super(GetActionMixin, self).__get__(instance, owner=owner)\n        if not self.get_action_after: action()\n        return value\n\n    pass # end of class\n\n'"
mvc/models/properties/bool_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\n\nclass BoolProperty(CastProperty):\n    """"""\n     A descriptor that will cast values to booleans.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = bool\n    widget_type = \'toggle\' # check_menu | expander\n\n    def __init__(self, *args, **kwargs):\n        super(BoolProperty, self).__init__(cast_to=bool, *args, **kwargs)\n\n    pass #end of class'"
mvc/models/properties/cast_choice_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\n\nclass CastChoiceProperty(CastProperty):\n    """"""\n     A descriptor that can cast the values to a given type, clamp values to a\n     minimum and maximum.\n     It also expects the (cast and clamped) value to be in a list or dict of\n     choices or it will raise a ValueError.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    choices = None\n    widget_type = \'option_list\'\n\n    def __init__(self, choices=[], *args, **kwargs):\n        super(CastChoiceProperty, self).__init__(*args, **kwargs)\n        self.choices = choices\n\n    def __set__(self, instance, value):\n        value = self.__cast_and_clamp__(instance, value)\n        if value in self.choices:\n            super(CastProperty, self).__set__(instance, value) #Call grandparent __set__\n        else:\n            raise ValueError(""\'%s\' is not a valid value for %s!"" % (value, self.label))\n\n    pass #end of class\n'"
mvc/models/properties/cast_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .labeled_property import LabeledProperty\n\nclass CastProperty(LabeledProperty):\n    """"""\n     A descriptor that can cast the values to a given type and clamp values to a\n     minimum and maximum. \n     Expects its label to be set or passed to __init__.\n    """"""\n\n    def __init__(self,\n            minimum=None, maximum=None,\n            cast_to=None,\n            *args, **kwargs):\n        super(CastProperty, self).__init__(*args, **kwargs)\n        self.minimum = minimum\n        self.maximum = maximum\n        self.cast_to = cast_to\n\n    def __cast_and_clamp__(self, instance, value):\n        if self.minimum is not None:\n            value = max(value, self.minimum)\n        if self.maximum is not None:\n            value = min(value, self.maximum)\n        if self.cast_to is not None and value is not None:\n            value = self.cast_to(value)\n        return value\n\n    def __set__(self, instance, value):\n        value = self.__cast_and_clamp__(instance, value)\n        if getattr(instance, self.label) != value:\n            super(CastProperty, self).__set__(instance, value)\n\n    pass #end of class'"
mvc/models/properties/float_properties.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\nfrom .cast_choice_property import CastChoiceProperty\n\n\nclass FloatProperty(CastProperty):\n    """"""\n     A descriptor that will cast values to floats and can optionally clamp\n     values to a minimum and maximum.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = float\n    widget_type = \'scale\' # | float_entry | entry | spin | label\n\n    def __init__(self, *args, **kwargs):\n        super(FloatProperty, self).__init__(cast_to=float, *args, **kwargs)\n\n    pass #end of class\n\nclass FloatChoiceProperty(CastChoiceProperty):\n    """"""\n     A descriptor that will cast values to floats and can optionally clamp\n     values to a minimum and maximum.\n     It also expects the (cast and clamped) value to be in a set of choices or\n     it will raise a ValueError.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = float\n    widget_type = \'option_list\'\n\n    def __init__(self, choices=[], *args, **kwargs):\n        super(FloatChoiceProperty, self).__init__(\n            cast_to=float,\n            choices=choices,\n            *args, **kwargs\n        )\n\n    pass #end of class'"
mvc/models/properties/integer_properties.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\nfrom .cast_choice_property import CastChoiceProperty\n\nclass IntegerProperty(CastProperty):\n    """"""\n     A descriptor that will cast values to integers and can optionally clamp\n     values to a minimum and maximum.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = int\n    widget_type = \'spin\' # | label | entry\n\n    def __init__(self, *args, **kwargs):\n        super(IntegerProperty, self).__init__(cast_to=int, *args, **kwargs)\n\n    pass #end of class\n\nclass IntegerChoiceProperty(CastChoiceProperty):\n    """"""\n     A descriptor that will cast values to integers and can optionally clamp\n     values to a minimum and maximum.\n     It also expects the (cast and clamped) value to be in a list or dict of\n     choices or it will raise a ValueError.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = int\n    widget_type = \'option_list\'\n\n    def __init__(self, choices=[], *args, **kwargs):\n        super(IntegerChoiceProperty, self).__init__(\n            cast_to=int,\n            choices=choices,\n            *args, **kwargs\n        )\n\n    pass #end of class\n'"
mvc/models/properties/labeled_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom mvc.support.utils import  rec_getattr, rec_setattr\nfrom mvc.support.observables.value_wrapper import ValueWrapper\nimport inspect\n\nclass Mixable(object):\n    """"""\n    Base class that allows to mix-in any other new-style class\n    passed in the constructor, using the mix_with keyword argument\n    (tuple of class types).\n    """"""\n\n    def __init__(self, mix_with=None, *args, **kwargs):\n        super(Mixable, self).__init__(*args, **kwargs)\n        # Nifty hook so we can mix-in any other class:\n        if mix_with is not None:\n            name = type(self).__name__\n            for klass in mix_with:\n                name = ""%s_%s"" % (klass.__name__.replace(""Mixin"", """"), name)\n            bases = tuple(mix_with) + (type(self),)\n            self.__class__ = type(name, bases, {})\n\n    pass #end of class\n\nclass LabeledProperty(Mixable):\n    """"""\n     Property descriptor base class to be used in combination with a\n     ~:class:`mvc.models.Model` (sub)class.\n     Expects it\'s label (attribute name) to be set or passed to __init__, for\n     ~:class:`mvc.models.Model` (sub)class this is done automagically using\n     its metaclass.\n     \n     Additional keyword arguments will be set as attributes on the descriptor.\n     \n     Some of these keywords have been given sane default values, even though\n     they are not required for the implementation:\n     \n         - title = label\n         - math_title = label\n         - description = label\n         - persistent (False)\n         - store_private = (False)\n         - visible (False)\n         - data_type (object)\n         - observable (True)\n         - widget_type (\'custom\')\n         \n     To use this class, use it like the regular Property or property decorators.\n     E.g.:\n         attribute = LabeledProperty(...)\n     or\n         @LabeledProperty(...)\n         def get_attribute(self):\n             return self.attribute\n             \n     The setter function is expected to accept either a single argument (the \n     new value) or two arguments (the property descriptor instance and the new \n     value). Similarly, the getter and deleter function are expected to accept\n     no arguments or a single argument (the property descriptor function instance).\n    """"""\n\n    #: The actual attribute name used to access the value on the class instance.\n    _label = None\n    @property\n    def label(self): return self._label\n    @label.setter\n    def label(self, value):\n        self._label = value\n        # Wrap the underlying variable if needed\n        # (e.g. if it\'s a list, tuple, dict, or other mutable class):\n        if self.default is not None:\n            self.default = ValueWrapper.wrap_value(self.label, self.default, verbose=bool(value == ""specimens""))\n\n    #: Whether this attribute is persistent (needs to be stored)\n    persistent = False\n\n    #: Either False (use the actual attribute), True (use the private attribute value) or\n    #: the name of the attribute to use when storing this attribute (if persistent = True)\n    store_private = False\n\n    #: A short textual description of this attribute\n    title = None\n\n    #: A short MathText description of this attribute\n    math_title = None\n\n    #: A flag indicating whether this attribute is visible in a GUI\n    visible = False\n\n    #: A string describing what kind of GUI widget can be used to display the\n    #: contents of this property. Check the :mod:`mvc.adapters` module.\n    widget_type = \'custom\'\n\n    #: A flag indicating whether this attribute should be visible in a table GUI\n    tabular = False\n\n    #: The type of the value stored in the attribute, or in the case of a\n    #: collection (i.e. lists, dicts and tuples) the type of the collection\n    #: items.\n    data_type = object\n\n    #: A flag indicating whether this attribute can be observed for changes\n    observable = True\n\n    #: The default value for this property\n    default = None\n\n    #: Declaration index: used to allow sorting in order of declaration\n    declaration_index = 0\n\n    ############################################################################\n    #    Generic private attribute getters and setters\n    ############################################################################\n    private_attribute_format = ""_%(label)s""\n    def _get_private_label(self):\n        """""" Private attribute label (holds the actual value on the model) """"""\n        return self.private_attribute_format % { \'label\': self.label }\n\n    def _set(self, instance, value):\n        """""" Private setter """"""\n        rec_setattr(instance, self._get_private_label(), value)\n\n    def _get(self, instance):\n        """""" Private getter """"""\n        return rec_getattr(instance, self._get_private_label(), self.default)\n\n    ############################################################################\n    #    Decorator calls:\n    ############################################################################\n    def __call__(self, fget):\n        return self.getter(fget)\n\n    def _inject_self(self, f):\n        """""" Injects self into the arguments of function `f`\n           (first argument after self) """"""\n        def wrapper(*args, **kwargs):\n            return f(*(args[0] + (self,) + args[1:]), **kwargs)\n        return wrapper\n\n    def getter(self, fget):\n        # Getter expects to be passed the descriptor\n        if len(inspect.getargspec(fget).args) > 1:\n            fget = self._inject_self(fget)\n        self.fget = fget\n        return self\n\n    def setter(self, fset):\n        # Setter expects to be passed the descriptor\n        if len(inspect.getargspec(fset).args) > 2:\n            fset = self._inject_self(fset)\n        self.fset = fset\n        return self\n\n    def deleter(self, fdel):\n        # Deleter expects to be passed the descriptor\n        if len(inspect.getargspec(fdel).args) > 1:\n            fdel = self._inject_self(fdel)\n        self.fdel = fdel\n        return self\n\n    ############################################################################\n    #    Initialization:\n    ############################################################################\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None, default=None, label=None, mix_with=None, **kwargs):\n        super(LabeledProperty, self).__init__(mix_with=mix_with)\n\n        #Increment declaration counter\n        LabeledProperty.declaration_index += 1\n        self.declaration_index = LabeledProperty.declaration_index\n\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        if doc is None and fget is not None:\n            doc = fget.__doc__\n        self.__doc__ = doc\n\n        self.label = self.math_title = self.title = self.description = label\n        self.persistent_label = label\n        self.default = default\n\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    ############################################################################\n    #    Comparison protocol:\n    ############################################################################\n    def __eq__(self, other):\n        # Descriptors are equal if they describe the same attribute\n        return other is not None and self.label == other.label\n\n    def __hash__(self):\n        return hash(self.label)\n\n    def __neq__(self, other):\n        # Descriptors are equal if they describe the same attribute\n        return not self.__eq__(other)\n\n    ############################################################################\n    #    Descriptor protocol:\n    ############################################################################\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n\n        with instance._prop_lock:\n            if self.fget is None:\n                return self._get(instance)\n            else:\n                return self.fget(instance)\n\n    def __set__(self, instance, value):\n        with instance._prop_lock:\n\n            # Get the old value\n            old = getattr(instance, self.label)\n\n            # Wrap the new value\n            value = ValueWrapper.wrap_value(self.label, value, instance)\n\n            # Set the new value\n            if self.fset is None:\n                self._set(instance, value)\n            else:\n                self.fset(instance, value)\n\n            # Notify any observers\n            if self.observable:\n                # Check if we\'ve really changed it, and send notifications if so:\n                if type(instance).check_value_change(old, value):\n                    instance._reset_property_notification(self, old)\n                    pass\n\n                # Notify any interested party we have set this property!\n                if hasattr(instance, \'notify_property_value_change\'):\n                    instance.notify_property_value_change(self.label, old, value)\n\n    def __delete__(self, instance):\n        if self.fdel is None:\n            raise AttributeError(""Can\'t delete attribute `%s`!"" % self.label)\n        self.fdel(instance)\n\n    def __repr__(self):\n        return \'<%s %s>\' % (self.__class__.__name__, self.label)\n\n    pass #end of class\n'"
mvc/models/properties/list_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\n\nclass ListProperty(CastProperty):\n    """"""\n     A descriptor that will cast values to lists.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    widget_type = \'object_list_view\' # | object_tree_view | xy_list_view | custom\n\n    def __cast_and_clamp__(self, instance, value):\n        if self.cast_to is not None and value is not None and not isinstance(value, self.cast_to):\n            value = self.cast_to(value)\n        return value\n\n    def __init__(self, *args, **kwargs):\n        if not ""cast_to"" in kwargs:\n            kwargs[""cast_to""] = list\n        super(ListProperty, self).__init__(*args, **kwargs)\n\n    pass #end of class'"
mvc/models/properties/observe_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nclass ObserveMixin(object):\n    """"""\n    A descriptor mixin that will make the instance observe and relieve the\n    objects set.\n    """"""\n\n    def __relieve_old(self, instance, old, new):\n        if old is not None:\n            instance.relieve_model(old)\n\n    def __observe_new(self, instance, old, new):\n        if new is not None:\n            instance.observe_model(new)\n\n    def _set(self, instance, value):\n        old = getattr(instance, self.label)\n        if old != value:\n            self.__relieve_old(instance, old, value)\n            super(ObserveMixin, self)._set(instance, value)\n            self.__observe_new(instance, old, value)\n\n    pass\n'"
mvc/models/properties/read_only_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom warnings import warn\n\nclass ReadOnlyMixin(object):\n    """"""\n    A descriptor mixin that will make the property read only and raise a\n    warning whenever somebody tries to set the property.\n    """"""\n\n    def __set__(self, instance, value):\n        warn(""The `%s` property can not be set!"" % self.label, RuntimeWarning)\n\n    pass # end of class\n'"
mvc/models/properties/signal_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom mvc.support.utils import rec_getattr\nfrom mvc.support import observables\n\nclass SignalMixin(object):\n    """"""\n    A descriptor mixin that will invoke a signal on the instance\n    owning this property when set. \n    \n    Expects two more keyword arguments to be passed to the property constructor:\n        - signal_name: a dotted string describing where to get the signal object\n          from the instance\n    """"""\n\n    signal_name = ""data_changed""\n\n    def __set__(self, instance, value):\n        signal = rec_getattr(instance, self.signal_name, None)\n        if signal is not None:\n            # Get the old value\n            old = getattr(instance, self.label)\n            with signal.ignore():\n                super(SignalMixin, self).__set__(instance, value)\n            # Get the new value\n            new = getattr(instance, self.label)\n            # Check if we\'re dealing with some special class (in case we\n            # emit the signal anyway) or immutables (in case we only emit\n            # when the value has changed)  \n            if isinstance(old, observables.ObsWrapperBase) or old != new:\n                signal.emit()\n        else:\n            super(SignalMixin, self).__set__(instance, value)\n            \n    pass # end of class\n'"
mvc/models/properties/signal_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom mvc.support.observables.signal import Signal\n\nfrom .labeled_property import LabeledProperty\n\nclass SignalProperty(LabeledProperty):\n    """"""\n    A descriptor for signals.\n    Expects a single additional keyword argument (or not for default of Signal):\n        - data_type: the type of signal to initialize this property with.\n    """"""\n\n    data_type = Signal\n\n    def _get(self, instance):\n        signal = getattr(instance, self._get_private_label(), None)\n        if signal is None: # If accesed for the first time set the Signal\n            signal = self.data_type()\n            setattr(instance, self._get_private_label(), signal)\n        return signal\n\n    def __set__(self, instance, value):\n        raise AttributeError(""Cannot set a Signal property!"")\n\n    pass # end of class\n'"
mvc/models/properties/string_properties.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .cast_property import CastProperty\nfrom .cast_choice_property import CastChoiceProperty\n\nclass StringProperty(CastProperty):\n    """"""\n     A descriptor that will cast values to strings and can optionally clamp\n     values to a minimum and maximum.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = str\n    widget_type = \'entry\' # | label | color | color-selection | file | link | text_view\n\n    def __init__(self, *args, **kwargs):\n        super(StringProperty, self).__init__(cast_to=str, *args, **kwargs)\n\n    pass #end of class\n\nclass ColorProperty(StringProperty):\n    """"""\n     A descriptor that will cast values to strings and can optionally clamp\n     values to a minimum and maximum. Has a color widget as the default widget.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    widget_type = \'color\' # entry | label | color-selection | file | link | text_view\n\n    pass #end of class\n\nclass StringChoiceProperty(CastChoiceProperty):\n    """"""\n     A descriptor that will cast values to strings and can optionally clamp\n     values to a minimum and maximum.\n     It also expects the (cast and clamped) value to be in a set of choices or\n     it will raise a ValueError.\n     Expects its label to be set or passed to __init__.\n    """"""\n\n    data_type = str\n    widget_type = \'option_list\'\n\n    def __init__(self, choices=[], *args, **kwargs):\n        super(StringChoiceProperty, self).__init__(\n            cast_to=str,\n            choices=choices,\n            *args, **kwargs\n        )\n\n    pass #end of class\n'"
mvc/models/properties/tools.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom copy import deepcopy\n\ndef modify(descriptor, **kwargs):\n    """"""\n        Makes a deep copy of descriptor and then applies all passed keywords.\n        Can be used to modify the descriptor attributes in subclasses,\n        without changing the behavior of the superclass.\n    """"""\n    new_descriptor = deepcopy(descriptor)\n    for name, value in kwargs.items():\n        setattr(new_descriptor, name, value)\n    return new_descriptor\n'"
mvc/models/properties/uuid_property.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .labeled_property import LabeledProperty\n\n\nclass UUIDProperty(LabeledProperty):\n    """"""\n     A descriptor that handles removing and adding objects to a pool of unique\n     objects. Expects the class type of the instance having this property to\n     implement a \'remove_object\' and \'add_object\' method.\n    """"""\n\n    def __set__(self, instance, value):\n        type(instance).object_pool.remove_object(instance)\n        retval = super(UUIDProperty, self).__set__(instance, value)\n        type(instance).object_pool.add_object(instance)\n        return retval\n\n    pass #end of class\n'"
mvc/support/collections/__init__.py,0,b''
mvc/support/collections/weak_list.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et:\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport weakref\n\nclass WeakList(list):\n    """"""\n        A list subclass referring to its items using weak references if possible \n    """"""\n    \n    def __init__(self, items=list()):\n        list.__init__(self)\n        tuple(map(self.append, items))\n\n    def get_value(self, item):\n        try:\n            item = item()\n        finally:\n            return item\n\n    def make_ref(self, item):\n        try:\n            item = weakref.ref(item, self.remove)\n        finally:\n            return item\n\n    def __contains__(self, item):\n        return list.__contains__(self, self.make_ref(item))\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return type(self)(self.get_value(item) for item in list.__getitem__(self, key))\n        return self.get_value(list.__getitem__(self, key))\n\n    def __getslice__(self, i, j):\n        return self.__getitem__(slice(i, j))\n\n    def __setitem__(self, key, item):\n        return list.__setitem__(self, key, self.make_ref(item))\n\n    def __iter__(self):\n        return iter([self[key] for key in range(len(self))])\n\n    def append(self, item):\n        list.append(self, self.make_ref(item))\n\n    def remove(self, item):\n        item = self.make_ref(item)\n        while list.__contains__(self, item):\n            list.remove(self, item)\n\n    def index(self, item):\n        return list.index(self, self.make_ref(item))\n\n    def pop(self, item):\n        return list.pop(self, self.make_ref(item))\n\n    pass #end of class\n'"
mvc/support/observables/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import ObsWrapperBase\nfrom .obs_wrapper import ObsWrapper\nfrom .obs_seq_wrapper import ObsSeqWrapper\nfrom .obs_map_wrapper import ObsMapWrapper\nfrom .obs_treenode_wrapper import ObsTreeNodeWrapper\nfrom .obs_list_wrapper import ObsListWrapper\nfrom .observable import Observable\nfrom .signal import Signal\n\n__all__ = [\n    ""ObsWrapperBase"",\n    ""ObsWrapper"",\n    ""ObsSeqWrapper"",\n    ""ObsMapWrapper"",\n    ""ObsTreeNodeWrapper"",\n    ""ObsListWrapper"",\n    ""Observable"",\n    ""Signal"",\n]'"
mvc/support/observables/base.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport weakref\n\nclass ObsWrapperBase (object):\n    """"""\n    This class is a base class wrapper for user-defined classes and\n    containers like lists, maps, signals, etc.\n    """"""\n\n    def __init__(self):\n        # all model instances owning self (can be multiple due to\n        # inheritance). Each element of the set is a pair (model,\n        # property-name)\n        self.__models = set()\n        return\n\n    def __add_model__(self, model, prop_name):\n        """"""Registers the given model to hold the wrapper among its\n        properties, within a property whose name is given as well""""""\n        ref = weakref.ref(model)\n        self.__models.add((ref, prop_name))\n        return\n\n    def __remove_model__(self, model, prop_name):\n        """"""Unregisters the given model, to release the wrapper. This\n        method reverts the effect of __add_model__""""""\n        delete_models = set()\n        for ref, prop_name in self.__models:\n            if ref() == model and prop_name == prop_name:\n                delete_models.add((ref, prop_name))\n        self.__models -= delete_models\n        return\n\n    def __get_models__(self):\n        delete_models = set()\n        for ref, prop_name in self.__models:\n            model = ref()\n            if model is not None:\n                yield model, prop_name\n            else:\n                delete_models.add((ref, prop_name))\n        self.__models -= delete_models\n\n    def _notify_method_before(self, instance, name, args, kwargs):\n        for m, n in self.__get_models__():\n            m.notify_method_before_change(n, instance, name,\n                                          args, kwargs)\n            pass\n        return\n\n    def _notify_method_after(self, instance, name, res_val, args, kwargs):\n        for m, n in self.__get_models__():\n            m.notify_method_after_change(n, instance, name, res_val,\n                                         args, kwargs)\n            pass\n        return\n\n    pass # end of class\n'"
mvc/support/observables/obs_list_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .obs_seq_wrapper import ObsSeqWrapper\nfrom .value_wrapper import ValueWrapper\n\n@ValueWrapper.register_wrapper(position=0)\nclass ObsListWrapper (ObsSeqWrapper):\n\n    @classmethod\n    def wrap_value(cls, label, value, model=None):\n        if isinstance(value, list):\n            res = cls(value)\n            if model: res.__add_model__(model, label)\n            return res\n\n    def __init__(self, l):\n        methods = (""append"", ""extend"", ""insert"",\n                   ""pop"", ""remove"", ""reverse"", ""sort"")\n        ObsSeqWrapper.__init__(self, l, methods)\n\n        for _m in (""add"", ""mul""):\n            meth = ""__%s__"" % _m\n            assert hasattr(self._obj, meth), ""Not found method %s in %s"" % (meth, str(type(self._obj)))\n            setattr(self.__class__, meth, getattr(self._obj, meth))\n            pass\n        return\n\n    def __radd__(self, other): return other.__add__(self._obj)\n    def __rmul__(self, other): return self._obj.__mul__(other)\n\n    pass # end of class\n'"
mvc/support/observables/obs_map_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .obs_seq_wrapper import ObsSeqWrapper\nfrom .value_wrapper import ValueWrapper\n\n@ValueWrapper.register_wrapper(position=1)\nclass ObsMapWrapper (ObsSeqWrapper):\n\n    @classmethod\n    def wrap_value(cls, label, value, model=None):\n        if isinstance(value, dict):\n            res = cls(value)\n            if model: res.__add_model__(model, label)\n            return res\n\n    def __init__(self, m):\n        methods = (""clear"", ""pop"", ""popitem"", ""update"",\n                   ""setdefault"")\n        ObsSeqWrapper.__init__(self, m, methods)\n        return\n    pass # end of class\n'"
mvc/support/observables/obs_seq_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\nfrom .obs_wrapper import ObsWrapper\n\nclass ObsSeqWrapper (ObsWrapper):\n    """"""\n        Base class for ObsListWrapper, ObsMapWrapper, ...\n        Use sub-classes, not this base class!\n    """"""\n\n    def __init__(self, obj, method_names):\n        ObsWrapper.__init__(self, obj, method_names)\n\n        for _m in ""lt le eq ne gt ge len iter"".split():\n            meth = ""__%s__"" % _m\n            assert hasattr(self._obj, meth), ""Not found method %s in %s"" % (meth, str(type(self._obj)))\n            setattr(self.__class__, meth, getattr(self._obj, meth))\n            pass\n        return\n\n    def __setitem__(self, key, val):\n        self._notify_method_before(self._obj, ""__setitem__"", (key, val), {})\n        res = self._obj.__setitem__(key, val)\n        self._notify_method_after(self._obj, ""__setitem__"", res, (key, val), {})\n        return res\n\n    def __delitem__(self, key):\n        self._notify_method_before(self._obj, ""__delitem__"", (key,), {})\n        res = self._obj.__delitem__(key)\n        self._notify_method_after(self._obj, ""__delitem__"", res, (key,), {})\n        return res\n\n    def __getitem__(self, key):\n        return self._obj.__getitem__(key)\n\n    pass # end of class\n'"
mvc/support/observables/obs_treenode_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .obs_wrapper import ObsWrapper\nfrom .value_wrapper import ValueWrapper\n\n@ValueWrapper.register_wrapper(position=2)\nclass ObsTreeNodeWrapper(ObsWrapper):\n\n    @classmethod\n    def wrap_value(cls, label, value, model=None):\n        from ...models.treenode import TreeNode\n        if isinstance(value, TreeNode):\n            res = cls(value)\n            if model: res.__add_model__(model, label)\n            return res\n\n    def __init__(self, t):\n        methods = (""insert"", ""remove"", ""on_grandchild_inserted"", ""on_grandchild_removed"")\n        ObsWrapper.__init__(self, t, methods)\n    pass # end of class\n'"
mvc/support/observables/obs_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .base import ObsWrapperBase\n\nclass ObsWrapper (ObsWrapperBase):\n    """"""\n    Base class for wrappers, like user-classes and sequences.\n    Use sub-classes!\n    """"""\n\n    def __init__(self, obj, method_names):\n        ObsWrapperBase.__init__(self)\n\n        self._obj = obj\n        self.__doc__ = obj.__doc__\n\n        # Creates a derived class which is a singleton which self is\n        # going to be an instance of. All method_names are then\n        # wrapped within it.\n        # See http://stackoverflow.com/questions/1022499/emulating-membership-test-in-python-delegating-contains-to-contained-object\n        d = dict((name, self.__get_wrapper(name)) for name in method_names)\n        self.__class__ = type(self.__class__.__name__, (self.__class__,), d)\n        return\n\n    def __get_wrapper(self, name):\n        def _wrapper_fun(self, *args, **kwargs):\n            self._notify_method_before(self._obj, name, args, kwargs)\n            res = getattr(self._obj, name)(*args, **kwargs)\n            self._notify_method_after(self._obj, name, res, args, kwargs)\n            return res\n        return _wrapper_fun\n\n    # For all fall backs\n    def __getattr__(self, name): return getattr(self._obj, name)\n    def __repr__(self): return self._obj.__repr__()\n    def __str__(self): return self._obj.__str__()\n\n    pass # end of class\n'"
mvc/support/observables/observable.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom ..decorators import good_classmethod_decorator\nfrom .base import ObsWrapperBase\n\nclass Observable (ObsWrapperBase):\n\n    @classmethod\n    @good_classmethod_decorator\n    def observed(cls, _func):\n        """"""\n        Decorate methods to be observable. If they are called on an instance\n        stored in a property, the model will emit before and after\n        notifications.\n        """"""\n\n        def wrapper(*args, **kwargs):\n            self = args[0]\n            assert(isinstance(self, Observable))\n\n            self._notify_method_before(self, _func.__name__, args, kwargs)\n            res = _func(*args, **kwargs)\n            self._notify_method_after(self, _func.__name__, res, args, kwargs)\n            return res\n\n        return wrapper\n\n    pass # end of class'"
mvc/support/observables/signal.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#  Copyright (C) 2005 by Tobias Weber\n#  Copyright (C) 2005 by Roberto Cavada <roboogle@gmail.com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport threading\n\nfrom .observable import Observable\n\nclass Signal(Observable):\n    """"""\n        A Signal that can either:\n         - be \'held\' from firing until a code block has finished, e.g. to\n           prevent numerous events from firing, when one final event would\n           be enough\n         - be stopped from firing altogether, even after the code block has\n           finished \n        \n        Holding signals back:\n         ...\n         object.hold_signal = HoldableSignal()\n         ...\n         with object.hold_signal.hold():\n             # this code block can call emit() on the hold_signal but it will not\n             # actually emit the signal until the \'with\' block is left\n         ...\n         \n        Ignoring signals:\n         ...\n         object.hold_signal =  HoldableSignal()\n         ...\n         with object.hold_signal.ignore():\n             # this code block can call emit() on the hold_signal but it will not\n             # actually emit the signal, even after leaving the \'with\' block\n    """"""\n    # PROPERTIES:\n    clock = threading.RLock()\n\n    # INIT:\n    def __init__(self, *args, **kwargs):\n        super(Signal, self).__init__(*args, **kwargs)\n        self._counter = 0\n        self._emissions_pending = False\n        self._ignore_levels = []\n\n    # WITH FUNCTIONALITY:\n    def __enter__(self):\n        with self.clock:\n            self._counter += 1;\n\n    def __exit__(self, *args):\n        with self.clock:\n            self._counter -= 1;\n            if self._counter < 0:\n                raise RuntimeError(""Negative counter in CounterLock object! Did you call __exit__ too many times?"")\n            if len(self._ignore_levels) > 0 and self._counter == self._ignore_levels[-1]:\n                self._ignore_levels.pop()\n            elif self._counter == 0 and self._emissions_pending:\n                # Fire the signal when we leave the with block\n                self.emit()\n\n    def hold(self):\n        return self\n\n    def ignore(self):\n        self._ignore_levels.append(self._counter)\n        return self\n\n    def hold_and_emit(self):\n        self._emit_pending() # set our pending flag\n        return self\n\n    def emit(self, arg=None):\n        if self._counter == 0:\n            self._emissions_pending = False\n            for model, name in self.__get_models__():\n                model.notify_signal_emit(name, arg)\n                pass\n        else:\n            self._emit_pending()\n\n    def _emit_pending(self):\n        if not self._emissions_pending:\n            self._emissions_pending = bool(len(self._ignore_levels) == 0)\n\n    pass #end of class'"
mvc/support/observables/value_wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom mvc.support.utils import not_none\n\nclass ValueWrapper(object):\n\n    wrappers = []\n\n    @staticmethod\n    def register_wrapper(cls=None, position=None):\n        """"""\n            Decorator that can be applied to wrapper classes (need to \n            define a wrap_value(label, value, model=None) method).\n            Can also be called with a position keyword argument to\n            force that wrapper to be at a certain position in the list of\n            wrappers.\n            Otherwise appends the wrapper to the end of wrapper list.\n        """"""\n        def inner(cls, position=None):\n            position = not_none(position, len(ValueWrapper.wrappers))\n            ValueWrapper.wrappers.insert(position, cls.wrap_value)\n        if cls == None:\n            return inner\n        else:\n            return inner(cls, position=position)\n\n    @staticmethod\n    def wrap_value(label, val, model=None, verbose=False):\n        """"""This is used to wrap a value to be assigned to a\n        property. Depending on the type of the value, different values\n        are created and returned. For example, for a list, a\n        ListWrapper is created to wrap it, and returned for the\n        assignment. model is different from None when the value is\n        changed (a model exists). Otherwise, during property creation\n        model is None""""""\n\n        for wrapper in ValueWrapper.wrappers:\n            wrapped = wrapper(label, val, model)\n            if wrapped is None:\n                continue\n            else:\n                return wrapped\n\n        return val\n\n    pass #end of class\n'"
pyxrd/file_parsers/atom_type_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .namespace import atom_type_parsers\n\nfrom .atl_parser import ATLAtomTypeParser\nfrom .json_parser import JSONAtomTypeParser'"
pyxrd/file_parsers/atom_type_parsers/atl_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport csv, os\n\nfrom pyxrd.generic.io import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom pyxrd.file_parsers.csv_base_parser import CSVBaseParser\n\nfrom .namespace import atom_type_parsers\n\n@atom_type_parsers.register_parser()\nclass ATLAtomTypeParser(CSVBaseParser):\n    """"""\n        Atomic scattering factors CSV file parser\n    """"""\n\n    namespace = ""atl""\n    description = ""Atom types CSV file""\n    extensions = get_case_insensitive_glob(""*.ATL"")\n\n    default_fmt_params = {\n        ""delimiter"": \',\',\n        ""doublequote"": True,\n        ""escapechar"": None,\n        ""quotechar"": ""\\"""",\n        ""quoting"": csv.QUOTE_MINIMAL,\n        ""skipinitialspace"": True,\n        ""strict"": False\n    }\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False, **fmt_params):\n        try:\n            fmt_params = dict(cls.default_fmt_params, **fmt_params)\n    \n            # Goto start of file\n            fp.seek(0)\n    \n            # Get base filename:\n            basename = u(os.path.basename(filename))\n    \n            # Read in the first and last data line and put the file cursor back\n            # at its original position\n            header = cls.parse_raw_line(fp.readline().strip(), str)\n            replace = [\n                ""a%d"" % i for i in range (1, 6)\n            ] + [\n                ""b%d"" % i for i in range (1, 6)\n            ] + [ ""c"", ]\n            header = [ ""par_%s"" % val if val in replace else val for val in header ]\n            data_start_pos = fp.tell()\n            line_count, _ = cls.get_last_line(fp)\n            fp.seek(data_start_pos)\n    \n            # Adapt DataObject list\n            data_objects = cls._adapt_data_object_list(data_objects, num_samples=line_count)\n    \n            # Fill in header info:\n            for i in range(line_count):\n                data_objects[i].update(\n                    filename=basename,\n                    header=header\n                )\n        finally:\n            if close: fp.close()\n        return data_objects\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False, **fmt_params):\n        if fp is not None:\n            for row, data_object in zip(csv.reader(fp, **fmt_params), data_objects):\n                if row:\n                    for key, val in zip(data_object.header, row):\n                        setattr(data_object, key, val)\n                    data_object.is_json = False\n\n        if close: fp.close()\n        return data_objects\n\n    @classmethod\n    def parse(cls, filename, fp, data_objects=None, close=True, **fmt_params):\n        """"""\n            Files are sniffed for the used csv dialect, but an optional set of\n            formatting parameters can be passed that will override the sniffed\n            parameters.\n        """"""\n        filename, fp, close = cls._get_file(filename, fp, close=close)\n\n        # Guess dialect\n        fmt_params, _, _ = cls.sniff(fp, **fmt_params)\n\n        # Parse header\n        data_objects = cls.parse_header(filename, fp, data_objects=data_objects, **fmt_params)\n\n        # Parse data\n        data_objects = cls.parse_data(filename, fp, data_objects=data_objects, **fmt_params)\n\n        if close: fp.close()\n        return data_objects\n\n    @classmethod\n    def write(cls, filename, items, props):\n        """"""\n            Writes the header to the first line, and will write x, y1, ..., yn\n            rows for each column inside the x and ys arguments.\n            Header argument should not include a newline, and can be a string or\n            any iterable containing strings.\n        """"""\n        atl_writer = csv.writer(open(filename, \'wb\'), delimiter=\',\', quotechar=\'""\', quoting=csv.QUOTE_MINIMAL)\n        atl_writer.writerow([ name for prop, name in props])\n        for item in items:\n            prop_row = []\n            for prop, name in props:\n                prop_row.append(getattr(item, prop))\n            atl_writer.writerow(prop_row)\n\n    pass # end of class\n'"
pyxrd/file_parsers/atom_type_parsers/json_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport zipfile\n\nfrom pyxrd.generic.io import get_case_insensitive_glob, COMPRESSION\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\nfrom .namespace import atom_type_parsers\n\n@atom_type_parsers.register_parser()\nclass JSONAtomTypeParser(JSONParser):\n    """"""\n        Atomic scattering factors JSON file parser\n    """"""\n\n    description = ""Atom types JSON file *.ZTL""\n    extensions = get_case_insensitive_glob(""*.ZTL"")\n    mimetypes = [""application/octet-stream"", ""application/zip""]\n\n    __file_mode__ = ""rb""\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        return data_objects # just pass it on, nothing to do\n\n    @classmethod\n    def write(cls, filename, items, props):\n        """"""\n            Saves multiple AtomTypes to a single (JSON) file.\n        """"""\n        with zipfile.ZipFile(filename, \'w\', compression=COMPRESSION) as zfile:\n            for i, atom_type in enumerate(items):\n                zfile.writestr(""%d###%s"" % (i, atom_type.uuid), atom_type.dump_object())\n\n    pass # end of class\n'"
pyxrd/file_parsers/atom_type_parsers/namespace.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.file_parsers.registry import ParserNamespace\n\natom_type_parsers = ParserNamespace(""AtomTypeParsers"")'"
pyxrd/file_parsers/exc_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\n\nfrom pyxrd.file_parsers.registry import ParserNamespace\nfrom pyxrd.file_parsers.xrd_parsers.csv_parser import GenericXYCSVParser\n\nexc_parsers = ParserNamespace(""EXCParsers"")\n\n@exc_parsers.register_parser()\nclass EXCParser(GenericXYCSVParser):\n    """"""\n        ASCII *.DAT, *.CSV and *.TAB format parser\n    """"""\n\n    description = ""Exclusion range file""\n    extensions = get_case_insensitive_glob(""*.EXC"")\n\n    pass # end of class'"
pyxrd/file_parsers/goniometer_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport zipfile\n\nfrom pyxrd.generic.io import get_case_insensitive_glob, COMPRESSION\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\nfrom pyxrd.file_parsers.registry import ParserNamespace\n\ngoniometer_parsers = ParserNamespace(""GoniometerParsers"")\n\n@goniometer_parsers.register_parser()\nclass JSONGoniometerParser(JSONParser):\n\n    description = ""Goniometer file *.GON""\n    extensions = get_case_insensitive_glob(""*.GON"")\n    mimetypes = [""application/octet-stream"", ""application/zip""]\n\n    pass #end of class\n'"
pyxrd/file_parsers/phase_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport zipfile\n\nfrom pyxrd.generic.io import get_case_insensitive_glob, COMPRESSION\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\nfrom pyxrd.file_parsers.registry import ParserNamespace\n\nphase_parsers = ParserNamespace(""PhaseParsers"")\n\n@phase_parsers.register_parser()\nclass JSONPhaseParser(JSONParser):\n\n    description = ""Phase file *.PHS""\n    extensions = get_case_insensitive_glob(""*.PHS"")\n    mimetypes = [""application/octet-stream"", ""application/zip""]\n\n    pass #end of class\n'"
pyxrd/file_parsers/project_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .namespace import project_parsers\n\nfrom .json_project_parser import JSONProjectParser\nfrom .sybilla_project_parser import SybillaProjectParser'"
pyxrd/file_parsers/project_parsers/json_project_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.io import get_case_insensitive_glob\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\nfrom .namespace import project_parsers\n\n@project_parsers.register_parser()\nclass JSONProjectParser(JSONParser):\n\n    description = ""Project file *.PYXRD""\n    extensions = get_case_insensitive_glob(""*.PYXRD"")\n    mimetypes = [""application/octet-stream"", ""application/zip""]\n\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=True):\n        project = super(JSONProjectParser, cls)._parse_data(filename, fp, data_objects=data_objects, close=close)\n        project.filename = filename\n        return project\n\n    pass #end of class\n'"
pyxrd/file_parsers/project_parsers/namespace.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.file_parsers.registry import ParserNamespace\n\nproject_parsers = ParserNamespace(""ProjectParsers"")'"
pyxrd/file_parsers/project_parsers/sybilla_project_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.io import get_case_insensitive_glob\n\nfrom pyxrd.project.importing import create_project_from_sybilla_xml\n\nfrom ..base_parser import BaseParser\nfrom ..xml_parser_mixin import XMLParserMixin\nfrom .namespace import project_parsers\n\n@project_parsers.register_parser()\nclass SybillaProjectParser(XMLParserMixin, BaseParser):\n\n    description = ""Sybilla XML files""\n    extensions = get_case_insensitive_glob(""*.XML"")\n    mimetypes = [""application/xml"", ""text/xml""]\n\n    @classmethod\n    def parse(cls, fp, data_objects=None, close=True):\n        """"""\n            This method parses the file and return a list of DataObjects\n            with both header and data properties filled in accordingly.\n            The filename argument is always required. If no file object is passed\n            as keyword argument, it only serves as a label. Otherwise a new file\n            object is created.\n            File objects are closed unless close is set to False.\n            Existing DataObjects can be passed as well and will then \n            be used instead of creating new ones.\n        """"""\n        filename, fp, close = cls._get_file(fp, close=close)\n        data_objects = create_project_from_sybilla_xml(filename)\n        if close: fp.close()\n        return data_objects\n\n    pass #end of class\n'"
pyxrd/file_parsers/wld_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\n\nfrom pyxrd.file_parsers.registry import ParserNamespace\nfrom pyxrd.file_parsers.xrd_parsers.csv_parser import GenericXYCSVParser\n\nwld_parsers = ParserNamespace(""WLDParsers"")\n\n@wld_parsers.register_parser()\nclass WLDParser(GenericXYCSVParser):\n    """"""\n        ASCII *.WLD format parser\n    """"""\n\n    description = ""Wavelength distribution file""\n    extensions = get_case_insensitive_glob(""*.WLD"")\n\n    pass # end of class'"
pyxrd/file_parsers/xrd_parsers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .namespace import xrd_parsers\n\nfrom .brk_brml_parser import BrkBRMLParser\nfrom .brk_raw_parser import BrkRAWParser\nfrom .cpi_parser import CPIParser\nfrom .csv_parser import CSVParser\nfrom .rd_parser import RDParser\nfrom .udf_parser import UDFParser'"
pyxrd/file_parsers/xrd_parsers/brk_brml_parser.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, types\nfrom zipfile import ZipFile\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import not_none\n\nfrom ..base_parser import BaseParser\nfrom ..xml_parser_mixin import XMLParserMixin\nfrom .xrd_parser_mixin import XRDParserMixin\nfrom .namespace import xrd_parsers\n\n@xrd_parsers.register_parser()\nclass BrkBRMLParser(XRDParserMixin, XMLParserMixin, BaseParser):\n    """"""\n        Bruker *.BRML format parser\n    """"""\n\n    description = ""Bruker BRML files *.BRML""\n    extensions = get_case_insensitive_glob(""*.BRML"")\n    mimetypes = [""application/zip"", ]\n\n    __file_mode__ = ""r""\n\n    @classmethod\n    def _get_file(cls, fp, close=None):\n        """"""\n            Returns a three-tuple:\n            filename, zipfile-object, close\n        """"""\n        if isinstance(fp, str):\n            return fp, ZipFile(fp, cls.__file_mode__), True if close is None else close\n        else:\n            return getattr(fp, \'name\', None), ZipFile(fp, cls.__file_mode__), False if close is None else close\n\n    @classmethod\n    def _get_raw_data_files(cls, f, folder):\n        """"""\n            Processes DataContainer.xml and returns a list of xml raw data\n            filepaths and the sample name\n        """"""\n        \n        contf = f.open(r""%s/DataContainer.xml"" % folder, cls.__file_mode__)\n        data = contf.read()\n        contf.close()\n        \n        _, root = cls.get_xml_for_string(data)\n        sample_name = root.find(""./MeasurementInfo"").get(""SampleName"")\n\n        raw_data_files = []\n        for child in root.find(""./RawDataReferenceList""):\n            raw_data_files.append(child.text)\n            \n        return raw_data_files, sample_name\n\n    @classmethod\n    def _get_header_dict(cls, f, folder):\n        header_d = {}\n\n        contf = f.open(r""%s/MeasurementContainer.xml"" % folder, cls.__file_mode__)\n        data = contf.read()\n        contf.close()\n        \n        _, root = cls.get_xml_for_string(data)\n\n        radius_path = ""./HardwareLogicExt/Instrument/BeamPathContainers"" + \\\n               ""/BeamPathContainerAbc[@VisibleName=\'PrimaryTrack\']/%s""\n\n        tube_path = ""./HardwareLogicExt/Instrument/BeamPathContainers"" + \\\n               ""/BeamPathContainerAbc[@VisibleName=\'PrimaryTrack\']/BankPositions/"" + \\\n               ""BankPosition/MountedComponent/MountedTube/%s""\n\n        soller1_path = ""./HardwareLogicExt/Instrument/BeamPathContainers"" + \\\n               ""/BeamPathContainerAbc[@VisibleName=\'PrimaryTrack\']/BankPositions/"" + \\\n               ""BankPosition/MountedComponent[@VisibleName=\'SollerMount\']/%s""\n\n        soller2_path = ""./HardwareLogicExt/Instrument/BeamPathContainers"" + \\\n               ""/BeamPathContainerAbc[@VisibleName=\'SecondaryTrack\']/BankPositions/"" + \\\n               ""BankPosition/MountedComponent[@VisibleName=\'SollerMount\']/%s""\n\n        divergence_path = ""./HardwareLogicExt/Instrument/BeamPathContainers"" + \\\n               ""/BeamPathContainerAbc[@VisibleName=\'PrimaryTrack\']/BankPositions/"" + \\\n               ""BankPosition/MountedComponent/Restrictions[@FieldName=\'OpeningDegree\']/%s""\n\n        header_d.update(\n            alpha1=float(cls.get_val(root, tube_path % ""WaveLengthAlpha1"", ""Value"")) / 10,\n            alpha2=float(cls.get_val(root, tube_path % ""WaveLengthAlpha2"", ""Value"")) / 10,\n            alpha_average=float(cls.get_val(root, tube_path % ""WaveLengthAverage"", ""Value"")) / 10,\n            beta=float(cls.get_val(root, tube_path % ""WaveLengthBeta"", ""Value"")) / 10,\n            alpha_factor=cls.get_val(root, tube_path % ""WaveLengthRatio"", ""Value""),\n            target_type=cls.get_val(root, tube_path % ""TubeMaterial"", ""Value""),\n            soller1=cls.get_val(root, soller1_path % ""Deflection"", ""Value""),\n            soller2=cls.get_val(root, soller2_path % ""Deflection"", ""Value""),\n            radius=float(cls.get_val(root, radius_path % ""Radius"", ""Value"", 0)) / 10.0, #convert to cm\n            divergence=cls.get_val(root, divergence_path % ""Data"", ""Value"")\n        )\n        \n        return header_d\n\n    @classmethod\n    def parse(cls, fp, data_objects=None, close=False):\n        filename, fp, close = cls._get_file(fp, close=close)\n\n        try:\n            basename = os.path.basename(filename)\n        except AttributeError:\n            basename = None\n\n        num_samples = 0\n\n        zipinfos = fp.infolist()\n\n        processed_folders = []\n\n        data_objects = not_none(data_objects, [])\n\n        for zipinfo in zipinfos:\n            if zipinfo.filename.count(\'/\') == 1 and ""DataContainer.xml"" in zipinfo.filename:\n\n                folder = os.path.dirname(zipinfo.filename)\n                if not folder in processed_folders:\n\n                    processed_folders.append(folder)\n\n                    header_d = cls._get_header_dict(fp, folder)\n                    raw_data_files, sample_name = cls._get_raw_data_files(fp, folder)\n               \n                    for raw_data_filename in raw_data_files:\n                        contf = fp.open(raw_data_filename)\n                        \n                        _, root = cls.get_xml_for_file(contf)\n                        \n                        isScan = not (""NonAmbientModeData"" in root.find(""./DataRoutes/DataRoute/ScanInformation"").get(""ScanName""))\n\n                        if isScan:\n                            for route in root.findall(""./DataRoutes/DataRoute""):\n                                # Adapt XRDFile list & get last addition:\n                                data_objects = cls._adapt_data_object_list(\n                                    data_objects,\n                                    num_samples=(num_samples + 1),\n                                    only_extend=True\n                                )\n                                data_object = data_objects[num_samples]\n    \n                                # Get the Datum tags:\n                                datums = route.findall(""Datum"")\n                                data = []\n    \n                                # Parse the RawDataView tags to find out what index in\n                                # the datum is used for what type of data:\n                                enabled_datum_index = None\n                                twotheta_datum_index = None\n                                intensity_datum_index = None\n                                steptime_datum_index = None\n                                relative_humidity_data, relative_humidity_index = None, None\n                                temperature_data, temperature_index = None, None\n                                temperature_index = None\n                                for dataview in route.findall(""./DataViews/RawDataView""):\n                                    index = int(dataview.get(""Start"", 0))\n                                    name = dataview.get(""LogicName"") or ""Undefined""\n                                    xsi_type = dataview.get(""{http://www.w3.org/2001/XMLSchema-instance}type"") or ""Undefined""\n                                    if name == ""MeasuredTime"":\n                                        steptime_datum_index = index\n                                    elif name == ""AbsorptionFactor"":\n                                        enabled_datum_index = index\n                                    elif name == ""Undefined"" and xsi_type == ""VaryingRawDataView"":\n                                        for i, definition in enumerate(dataview.findall(""./Varying/FieldDefinitions"")):\n                                            if definition.get(""TwoTheta""):\n                                                index += i\n                                                break\n                                        twotheta_datum_index = index\n                                    elif name == ""Undefined"" and xsi_type == ""RecordedRawDataView"":\n                                        logic_name = dataview.find(""Recording"").get(""LogicName"")\n                                        if logic_name == ""ScanCounter"":\n                                            intensity_datum_index = index\n                                        elif logic_name == ""modeActualHum"":\n                                            relative_humidity_index = index\n                                            relative_humidity_data = []\n                                        elif logic_name == ""modeActualTemp"":\n                                            temperature_index = index\n                                            temperature_data = []\n                                            \n                                # Parse the SubScanInfo list (usually only one), and\n                                # then parse the datums accordingly\n                                twotheta_min = None\n                                twotheta_max = None\n                                twotheta_count = 0\n                                for subscan in route.findall(""./SubScans/SubScanInfo""):\n                                    # Get the steps, where to start and the planned\n                                    # time per step (measuredTimePerStep deviates\n                                    # if the recording was interrupted):\n                                    steps = int(subscan.get(""MeasuredSteps""))\n                                    start = int(subscan.get(""StartStepNo""))\n                                    steptime = float(subscan.get(""PlannedTimePerStep""))\n    \n                                    for datum in datums[start:start + steps]:\n                                        values = datum.text.split("","")\n                                        if values[enabled_datum_index] == ""1"":\n                                            # Fetch values from the list:\n                                            datum_steptime = float(values[steptime_datum_index])\n                                            intensity = float(values[intensity_datum_index])\n                                            intensity /= float(steptime * datum_steptime)\n                                            twotheta = float(values[twotheta_datum_index])\n                                            \n                                            # If we have temperature or RH data, get them as well:\n                                            if temperature_index is not None:\n                                                temperature = float(values[temperature_index])\n                                                temperature_data.append(temperature) \n                                            if relative_humidity_index is not None:\n                                                relative_humidity = float(values[relative_humidity_index])\n                                                relative_humidity_data.append(relative_humidity)                                        \n    \n                                            # Keep track of min 2theta:\n                                            if twotheta_min is None:\n                                                twotheta_min = twotheta\n                                            else:\n                                                twotheta_min = min(twotheta_min, twotheta)\n    \n                                            # Keep track of max 2theta:\n                                            if twotheta_max is None:\n                                                twotheta_max = twotheta\n                                            else:\n                                                twotheta_max = min(twotheta_max, twotheta)\n    \n                                            # Append point and increase count:\n                                            data.append([twotheta, intensity])\n                                            twotheta_count += 1\n    \n                                #Update header:\n                                data_object.update(\n                                    filename=basename,\n                                    name=sample_name,\n                                    time_step=1, # we converted to CPS\n                                    twotheta_min=twotheta_min,\n                                    twotheta_max=twotheta_max,\n                                    twotheta_count=twotheta_count,\n                                    **header_d\n                                )\n    \n                                data_object.data = data\n                                \n                                # These might be None:\n                                data_object.temperature_data = temperature_data\n                                data_object.relative_humidity_data = relative_humidity_data\n    \n                                num_samples += 1\n\n                        #end for\n                        contf.close()\n                        \n                    #end for\n                #end if\n            #end if\n        #end for\n\n        if close: fp.close()\n        return data_objects\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/brk_raw_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, struct\nfrom io import SEEK_SET, SEEK_CUR\n\nimport numpy as np\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom ..base_parser import BaseParser\nfrom .namespace import xrd_parsers\nfrom .xrd_parser_mixin import XRDParserMixin\n\n@xrd_parsers.register_parser()\nclass BrkRAWParser(XRDParserMixin, BaseParser):\n    """"""\n        Bruker *.RAW format parser\n    """"""\n\n    description = ""Bruker/Siemens Binary V1/V2/V3 *.RAW""\n    extensions = get_case_insensitive_glob(""*.RAW"")\n    mimetypes = [""application/octet-stream"", ]\n\n    __file_mode__ = ""rb""\n\n    @classmethod\n    def _clean_bin_str(cls, val):\n        return u(val.replace(""\\0"".encode(), """".encode()).strip())\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n\n        try:\n            basename = u(os.path.basename(filename))\n        except:\n            basename = None\n\n        # Go to the start of the file\n        f.seek(0, SEEK_SET)\n\n        # Read file format version:\n        version = f.read(4).decode(""utf-8"")\n        if version == ""RAW "":                             version = ""RAW1""\n        elif version == ""RAW2"":                           version = ""RAW2""\n        elif version == ""RAW1"" and str(f.read(3)) == "".01"": version = ""RAW3""\n\n        if version == ""RAW1"":\n\n            # This format does not allow getting the exact number of samples,\n            # so start with one and append where needed:\n            isfollowed = 1\n            num_samples = 0\n            while isfollowed > 0:\n\n                twotheta_count = int(struct.unpack(""I"", f.read(4))[0])\n                # Check if this is an early ""RAW "" formatted file where the\n                # ""RAW "" is repeated for each sample:\n                if num_samples > 0 and twotheta_count == int(struct.unpack(""I"", ""RAW "")[0]):\n                    twotheta_count = int(struct.unpack(""I"", f.read(4))[0])\n\n                # Step counting time, 2-theta step size and scanning mode:\n                time_step, twotheta_step, scan_mode = struct.unpack(""fff"", f.read(12)) #@UnusedVariable\n                # Skip 4 bytes, and read 2-theta starting position:\n                f.seek(4, SEEK_CUR)\n                twotheta_min, = struct.unpack(""f"", f.read(4))\n                twotheta_max = twotheta_min + twotheta_step * float(twotheta_count)\n                # Skip 12 bytes\n                # (contain theta, khi and phi start point for eularian craddles)\n                f.seek(12, SEEK_CUR)\n                # Read sample name and wavelengths:\n                sample_name = cls._clean_bin_str(f.read(32))\n                alpha1, alpha2 = struct.unpack(""ff"", f.read(8))\n                # Skip 72 bytes:\n                f.seek(72, SEEK_CUR)\n                isfollowed, = struct.unpack(""I"", f.read(4))\n\n                # Get data position and skip for now:\n                data_start = f.tell()\n                f.seek(twotheta_count * 4, SEEK_CUR)\n\n                # Adapt XRDFile list\n                data_objects = cls._adapt_data_object_list(\n                    data_objects,\n                    num_samples=(num_samples + 1),\n                    only_extend=True\n                )\n\n                data_objects[num_samples].update(\n                    filename=basename,\n                    version=version,\n                    name=sample_name,\n                    time_step=time_step,\n                    twotheta_min=twotheta_min,\n                    twotheta_max=twotheta_max,\n                    twotheta_step=twotheta_step,\n                    twotheta_count=twotheta_count,\n                    alpha1=alpha1,\n                    alpha2=alpha2,\n                    data_start=data_start\n                )\n\n                num_samples += 1\n\n        elif version == ""RAW2"":\n\n            # Read number of sample ranges:\n            num_samples, = struct.unpack(""H"", f.read(2))\n\n            # Adapt XRDFile list\n            data_objects = cls._adapt_data_object_list(data_objects, num_samples=num_samples)\n\n            # Read sample name:\n            f.seek(8, SEEK_SET)\n            sample_name = cls._clean_bin_str(f.read(32))\n            # Meta-data description, skip for now:\n            # description = u(str(f.read(128)).replace(""\\0"", """").strip())\n            # date = u(str(f.read(10)).replace(""\\0"", """").strip())\n            # time = u(str(f.read(5)).replace(""\\0"", """").strip())\n\n            # Read wavelength information:\n            f.seek(148, SEEK_CUR)\n            target_type = u(str(f.read(2)).replace(""\\0"", """").strip()) #@UnusedVariable\n            alpha1, alpha2, alpha_factor = struct.unpack(""fff"", f.read(12))\n\n            # Total runtime in seconds: (not used fttb)\n            f.seek(8, SEEK_CUR)\n            time_total, = struct.unpack(""f"", f.read(4)) #@UnusedVariable\n\n            # Move to first sample header start:\n            f.seek(256, SEEK_SET)\n\n            # Read in per-sample meta data\n            for i in range(num_samples):\n                header_start = f.tell()\n                header_length, twotheta_count = struct.unpack(""HH"", f.read(4))\n                data_start = header_start + header_length\n\n                # Read step size and start angle:\n                f.seek(header_start + 12) # = 256 + 4 + 8 skipped bytes\n                twotheta_step, twotheta_min = struct.unpack(""ff"", f.read(8))\n                twotheta_max = twotheta_min + twotheta_step * float(twotheta_count)\n\n                # Read up to end of data:\n                f.seek(data_start + twotheta_count * 4, SEEK_SET)\n\n                # Update XRDFile object:\n                data_objects[i].update(\n                    filename=basename,\n                    version=version,\n                    name=sample_name,\n                    twotheta_min=twotheta_min,\n                    twotheta_max=twotheta_max,\n                    twotheta_step=twotheta_step,\n                    twotheta_count=twotheta_count,\n                    alpha1=alpha1,\n                    alpha2=alpha2,\n                    alpha_factor=alpha_factor,\n                    data_start=data_start\n                )\n\n        elif version == ""RAW3"":\n\n            # Read file status:    \n            f.seek(8, SEEK_SET)       \n            file_status = { #@UnusedVariable\n                1: ""done"",\n                2: ""active"",\n                3: ""aborted"",\n                4: ""interrupted""\n            }[int(struct.unpack(""I"", f.read(4))[0])]\n\n            # Read number of samples inside this file:\n            f.seek(12, SEEK_SET)\n            num_samples, = struct.unpack(""I"", f.read(4))\n\n            # Read in sample name:\n            f.seek(326, SEEK_SET)\n            sample_name =  cls._clean_bin_str(f.read(60))\n\n            # Goniometer radius:\n            f.seek(564, SEEK_SET)\n            radius = float(struct.unpack(""f"", f.read(4))[0])\n\n            # Fixed divergence:\n            f.seek(568, SEEK_SET)\n            divergence = float(struct.unpack(""f"", f.read(4))[0])\n\n            # Primary soller\n            f.seek(576, SEEK_SET)\n            soller1 = float(struct.unpack(""f"", f.read(4))[0])\n\n            # Secondary soller\n            f.seek(592, SEEK_SET)\n            soller2 = float(struct.unpack(""f"", f.read(4))[0])\n\n            # Get anode type:\n            f.seek(608, SEEK_SET)\n            target_type = str(f.read(4)) #@UnusedVariable\n\n            # Get wavelength info:\n            f.seek(616, SEEK_SET)\n            alpha_average, alpha1, alpha2, beta, alpha_factor = (#@UnusedVariable\n                struct.unpack(""ddddd"", f.read(8 * 5)))\n\n            # Get total recording time:\n            f.seek(664, SEEK_SET)\n            time_total, = struct.unpack(""f"", f.read(4)) #@UnusedVariable\n            \n            # Adapt XRDFile lis & Skip to first block:t\n            data_objects = cls._adapt_data_object_list(data_objects, num_samples=num_samples)\n            f.seek(712, SEEK_SET)\n            \n            # Read in per-sample meta data\n            for i in range(num_samples):\n                # Store the start of the header:\n                header_start = f.tell()\n\n                # Get header length\n                f.seek(header_start + 0, SEEK_SET)\n                header_length, = struct.unpack(""I"", f.read(4))\n                assert header_length == 304, ""Invalid format!""\n                \n                # Get data count and\n                f.seek(header_start + 4, SEEK_SET)\n                twotheta_count, = struct.unpack(""I"", f.read(4))\n                \n                # Get theta start positions\n                f.seek(header_start + 8, SEEK_SET)\n                theta_min, twotheta_min = struct.unpack(""dd"", f.read(8 * 2))#@UnusedVariable               \n\n                # Read step size\n                f.seek(header_start + 176, SEEK_SET)\n                twotheta_step, = struct.unpack(""d"", f.read(8))\n\n                # Read counting time\n                f.seek(header_start + 192, SEEK_SET)\n                time_step, = struct.unpack(""d"", f.read(8))\n\n                # Read the used wavelength\n                f.seek(header_start + 240, SEEK_SET)\n                alpha_used, = struct.unpack(""d"", f.read(8))#@UnusedVariable\n\n                # Supplementary header size:\n                f.seek(header_start + 256, SEEK_SET)\n                supp_headers_size, = struct.unpack(""I"", f.read(4))\n                data_start = header_start + header_length + supp_headers_size\n\n                # Move to the end of the data:\n                f.seek(data_start + twotheta_count * 4)\n                \n                # Calculate last data point\n                twotheta_max = twotheta_min + twotheta_step * float(twotheta_count - 0.5)\n                \n                data_objects[i].update(\n                    filename=basename,\n                    version=version,\n                    name=sample_name,\n                    twotheta_min=twotheta_min,\n                    twotheta_max=twotheta_max,\n                    twotheta_step=twotheta_step,\n                    twotheta_count=twotheta_count,\n                    alpha1=alpha1,\n                    alpha2=alpha2,\n                    alpha_factor=alpha_factor,\n                    data_start=data_start,\n                    radius=radius,\n                    soller1=soller1,\n                    soller2=soller2,\n                    divergence=divergence\n                )\n\n        else:\n            raise IOError(""Only verson 1, 2 and 3 *.RAW files are supported!"")\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False):\n        for data_object in data_objects:\n            if data_object.data == None:\n                data_object.data = []\n            \n            # Parse data:\n            if fp is not None:\n                if data_object.version in (""RAW1"", ""RAW2"", ""RAW3""):\n                    fp.seek(data_object.data_start)\n                    n = 0\n                    while n < data_object.twotheta_count:\n                        y, = struct.unpack(""f"", fp.read(4))\n                        x = data_object.twotheta_min + data_object.twotheta_step * float(n + 0.5)\n                        data_object.data.append([x,y])\n                        n += 1\n                else:\n                    raise IOError(""Only verson 1, 2 and 3 *.RAW files are supported!"")\n\n\n            data_object.data = np.array(data_object.data)\n\n        if close: fp.close()\n        return data_objects\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/cpi_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nfrom datetime import date\n\nimport numpy as np\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom ..base_parser import BaseParser\nfrom .namespace import xrd_parsers\nfrom .xrd_parser_mixin import XRDParserMixin\n\n@xrd_parsers.register_parser()\nclass CPIParser(XRDParserMixin, BaseParser):\n    """"""\n        ASCII Sietronics *.CPI format parser\n    """"""\n\n    description = ""Sietronics *.CPI""\n    extensions = get_case_insensitive_glob(""*.CPI"", ""*.CPD"", ""*.CPS"")\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n        \n        try:\n            basename = u(os.path.basename(filename))\n        except:\n            basename = None\n        \n        # Adapt XRDFile list\n        data_objects = cls._adapt_data_object_list(data_objects, num_samples=1)\n\n        # Move to the start of the file\n        f.seek(0)\n        # Skip a line: file type header\n        f.readline()\n        # Read data limits\n        twotheta_min = float(f.readline().replace("","", ""."").strip())\n        twotheta_max = float(f.readline().replace("","", ""."").strip())\n        twotheta_step = float(f.readline().replace("","", ""."").strip())\n        twotheta_count = int((twotheta_max - twotheta_min) / twotheta_step)\n        # Read target element name\n        target_type = f.readline()\n        # Read wavelength\n        alpha1 = float(f.readline().replace("","", ""."").strip())\n        # Read up to SCANDATA and keep track of the line before,\n        # it contains the sample description\n        name = """"\n        while True:\n            line = f.readline().strip()\n            if line == ""SCANDATA"" or line == """":\n                data_start = f.tell()\n                break;\n            else:\n                name = line\n\n        data_objects[0].update(\n            filename=basename,\n            name=name,\n            target_type=target_type,\n            alpha1=alpha1,\n            twotheta_min=twotheta_min,\n            twotheta_max=twotheta_max,\n            twotheta_step=twotheta_step,\n            twotheta_count=twotheta_count,\n            data_start=data_start,\n        )\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n\n        # CPI files are singletons, so no need to iterate over the list,\n        # there is only one data object instance:\n        if data_objects[0].data == None:\n            data_objects[0].data = []\n\n        if f is not None:\n            f.seek(data_objects[0].data_start)\n            n = 0\n            while n <= data_objects[0].twotheta_count:\n                line = f.readline().strip(""\\n"").replace("","", ""."")\n                if line != """":\n                    data_objects[0].data.append([ float(data_objects[0].twotheta_min + data_objects[0].twotheta_step * n), float(line) ])\n                n += 1\n\n        data_objects[0].data = np.array(data_objects[0].data)\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def write(cls, filename, x, ys, radiation=""Cu"", wavelength=1.54060, tps=48.0, sample="""", **kwargs):\n        """"""\n            Writes a SIETRONICS cpi text file. x and ys should be numpy arrays.\n        """"""\n        start_angle = x[0]\n        end_angle = x[-1]\n        step_size = (end_angle - start_angle) / (x.size - 1)\n        with open(filename, \'w\') as f:\n            f.write(""SIETRONICS XRD SCAN\\n"")\n            f.write(""%.4f\\n"" % start_angle)\n            f.write(""%.4f\\n"" % end_angle)\n            f.write(""%.4f\\n"" % step_size)\n            f.write(""%s\\n"" % radiation)\n            f.write(""%.5f\\n"" % wavelength)\n            f.write(""%s\\n"" % date.today().strftime(\'%d/%m/%y %H:%M:%S\'))\n            f.write(""%.1f\\n"" % tps)\n            f.write(""%s\\n"" % sample)\n            f.write(""SCANDATA\\n"")\n            for y in ys[0, :]:\n                f.write(""%.7f\\n"" % y)\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/csv_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, csv\n\nimport numpy as np\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom ..csv_base_parser import CSVBaseParser\nfrom .namespace import xrd_parsers\nfrom .xrd_parser_mixin import XRDParserMixin\n\nclass GenericXYCSVParser(XRDParserMixin, CSVBaseParser):\n    """"""\n        Generic xy-data CSV parser. Does not care about extensions. \n        Should be sub-classed!\n    """"""\n\n    description = ""ASCII XY data""\n\n    default_fmt_params = {\n        ""delimiter"": \',\',\n        ""doublequote"": True,\n        ""escapechar"": None,\n        ""quotechar"": ""\\"""",\n        ""quoting"": csv.QUOTE_MINIMAL,\n        ""skipinitialspace"": True,\n        ""strict"": False\n    }\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False, split_columns=True, has_header=True, file_start=0, **fmt_params):\n        fmt_params = dict(cls.default_fmt_params, **fmt_params)\n        f = fp\n\n        # Goto start of file\n        f.seek(file_start)\n\n        # Get base filename:\n        try:\n            basename = u(os.path.basename(filename))\n        except:\n            basename = None\n\n        # Read in the first and last data line and put the file cursor back\n        # at its original position\n        header = f.readline().strip()\n        if not has_header:\n            f.seek(file_start) # go back to the start, we still use the first line as header, but also as data\n        data_start_pos = f.tell()\n        first_line = f.readline().strip()\n        twotheta_count, last_line = cls.get_last_line(f)\n        last_line = last_line.strip()\n        f.seek(data_start_pos)\n\n        # Extract the data from the first & last data lines:\n        first_line_vals = cls.parse_raw_line(first_line, float, **fmt_params)\n        last_line_vals = cls.parse_raw_line(last_line, float, **fmt_params)\n        num_samples = len(first_line_vals) - 1 # first column is 2-theta\n        twotheta_min = first_line_vals[0]\n        twotheta_max = last_line_vals[0]\n        twotheta_step = int((twotheta_max - twotheta_min) / twotheta_count)\n\n        # Parse the header line:\n        sample_names = cls.parse_raw_line(header, lambda s: s, **fmt_params)[1:]\n        if len(sample_names) < num_samples:\n            sample_names.extend([""""] * (num_samples - len(sample_names)))\n        if len(sample_names) > num_samples:\n            sample_names = sample_names[:num_samples]\n\n        # Adapt DataObject list\n        data_objects = cls._adapt_data_object_list(data_objects, num_samples=num_samples)\n\n        # Fill in header info:\n        for i, sample_name in enumerate(sample_names):\n            data_objects[i].update(\n                filename=basename,\n                name=sample_name,\n                twotheta_min=twotheta_min,\n                twotheta_max=twotheta_max,\n                twotheta_step=twotheta_step,\n                twotheta_count=twotheta_count\n            )\n\n        if close: f.close()\n        return data_objects\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False, split_columns=True, has_header=True, **fmt_params):\n        f = fp\n\n        if f is not None:\n            for row in csv.reader(f, **fmt_params):\n                if row:\n                    data = list(map(float, row))\n                    x, ay = data[0], data[1:] # ay contains columns with y values\n                    for data_object, y in zip(data_objects, ay):\n                        if getattr(data_object, ""data"", None) is None:\n                            data_object.data = []\n                        data_object.data.append([x, y])\n\n            for data_object in data_objects:\n                data_object.data = np.array(data_object.data)\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def parse(cls, fp, data_objects=None, close=True, split_columns=True, **fmt_params):\n        """"""\n            Files are sniffed for the used csv dialect, but an optional set of\n            formatting parameters can be passed that will override the sniffed\n            parameters.\n        """"""\n        filename, f, close = cls._get_file(fp, close=close)\n\n        # Guess dialect:\n        fmt_params, has_header, file_start = cls.sniff(f, **fmt_params)\n\n        # Parse header:\n        data_objects = cls._parse_header(filename, f, data_objects=data_objects, split_columns=split_columns, has_header=has_header, file_start=file_start, **fmt_params)\n\n        # Parse data:\n        data_objects = cls._parse_data(filename, f, data_objects=data_objects, split_columns=split_columns, has_header=has_header, **fmt_params)\n\n        if close: f.close()\n        return data_objects\n\n    pass # end of class\n\n@xrd_parsers.register_parser()\nclass CSVParser(GenericXYCSVParser):\n    """"""\n        ASCII *.DAT, *.CSV, *.TAB and *.XY format parser\n    """"""\n\n    description = ""CSV XRD data""\n    extensions = get_case_insensitive_glob(""*.DAT"", ""*.CSV"", ""*.TAB"", ""*.XY"")\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/namespace.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.file_parsers.registry import ParserNamespace\n\nxrd_parsers = ParserNamespace(""XRDParsers"")'"
pyxrd/file_parsers/xrd_parsers/rd_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, struct\nfrom io import SEEK_SET #, SEEK_CUR, SEEK_END\n\nimport numpy as np\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom ..base_parser import BaseParser\nfrom .namespace import xrd_parsers\nfrom .xrd_parser_mixin import XRDParserMixin\n\n\ndef cap(lower, value, upper, out=None):\n    if value < lower or value > upper:\n        return out if out is not None else min(max(value, lower), upper)\n    else:\n        return value\n\n@xrd_parsers.register_parser()\nclass RDParser(XRDParserMixin, BaseParser):\n    """"""\n        Philips Binary V3 & V5 *.RD format parser\n    """"""\n\n    description = ""Phillips Binary V3/V5 *.RD""\n    extensions = get_case_insensitive_glob(""*.RD"")\n    mimetypes = [""application/octet-stream"", ]\n\n    __file_mode__ = ""rb""\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n\n        try:\n            basename = u(os.path.basename(filename))\n        except:\n            basename = None\n\n        # Adapt XRDFile list\n        data_objects = cls._adapt_data_object_list(data_objects, num_samples=1)\n\n        # Go to the start of the file\n        f.seek(0, SEEK_SET)\n\n        # Read file format version:\n        version = f.read(2).decode()\n\n        if version in (""V3"", ""V5""):\n\n            # Read diffractometer, target and focus type:\n            f.seek(84, SEEK_SET)\n            diffractomer_type, target_type, focus_type = struct.unpack(""bbb"", f.read(3))\n            diffractomer_type = {\n                0: b""PW1800"",\n                1: b""PW1710 based system"",\n                2: b""PW1840"",\n                3: b""PW3710 based system"",\n                4: b""Undefined"",\n                5: b""X\'Pert MPD""\n            }[cap(0, diffractomer_type, 5, 4)]\n            target_type = {\n                0: b""Cu"",\n                1: b""Mo"",\n                2: b""Fe"",\n                3: b""Cr"",\n                4: b""Other""\n            }[cap(0, target_type, 3, 4)]\n            focus_type = {\n                0: b""BF"",\n                1: b""NF"",\n                2: b""FF"",\n                3: b""LFF"",\n                4: b""Unkown"",\n            }[cap(0, focus_type, 3, 4)]\n\n            # Read wavelength information:\n            f.seek(94, SEEK_SET)\n            alpha1, alpha2, alpha_factor = struct.unpack(""ddd"", f.read(24))\n            # Read sample name:\n            f.seek(146, SEEK_SET)\n            sample_name = u(f.read(16).replace(b""\\0"", b""""))\n\n            # Read data limits:\n            f.seek(214)\n            twotheta_step, twotheta_min, twotheta_max = struct.unpack(""ddd"", f.read(24))\n            twotheta_count = int((twotheta_max - twotheta_min) / twotheta_step)\n\n            # Set data start:\n            data_start = {\n                ""V3"": 250,\n                ""V5"": 810\n            }[version]\n\n            data_objects[0].update(\n                filename=basename,\n                name=sample_name,\n                twotheta_min=twotheta_min,\n                twotheta_max=twotheta_max,\n                twotheta_step=twotheta_step,\n                twotheta_count=twotheta_count,\n                target_type=target_type,\n                alpha1=alpha1,\n                alpha2=alpha2,\n                alpha_factor=alpha_factor,\n                data_start=data_start,\n                version=version\n            )\n\n        else:\n            raise IOError(""Only V3 and V5 *.RD files are supported!"")\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n\n        # RD files are singletons, so no need to iterate over the list,\n        # there is only one XRDFile instance:\n        if data_objects[0].data == None:\n            data_objects[0].data = []\n\n        # Parse data:\n        if f is not None:\n            if data_objects[0].version in (""V3"", ""V5""):\n                # Move to start of data:\n                f.seek(data_objects[0].data_start)\n                n = 0\n                while n < data_objects[0].twotheta_count:\n                    y, = struct.unpack(""H"", f.read(2))\n                    data_objects[0].data.append([\n                        data_objects[0].twotheta_min + data_objects[0].twotheta_step * float(n + 0.5),\n                        float(y)\n                    ])\n                    n += 1\n            else:\n                raise IOError(""Only V3 and V5 *.RD files are supported!"")\n\n        data_objects[0].data = np.array(data_objects[0].data)\n\n        if close: f.close()\n        return data_objects\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/udf_parser.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\n\nimport numpy as np\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\nfrom pyxrd.generic.utils import u\n\nfrom ..base_parser import BaseParser\nfrom .namespace import xrd_parsers\nfrom .xrd_parser_mixin import XRDParserMixin\n\n@xrd_parsers.register_parser()\nclass UDFParser(XRDParserMixin, BaseParser):\n    """"""\n        ASCII Philips *.UDF format\n    """"""\n\n    description = ""Philips *.UDF""\n    extensions = get_case_insensitive_glob(""*.UDF"")\n\n    @classmethod\n    def _parse_header(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n        try:\n            basename = u(os.path.basename(filename))\n        except:\n            basename = None\n        # Adapt XRDFile list\n        data_objects = cls._adapt_data_object_list(data_objects, num_samples=1)\n\n        # Move to the start of the file\n        f.seek(0)\n\n        # Go over the header:\n        header_dict = {}\n\n        for lineno, line in enumerate(f):\n            # Start of data after this line:\n            if line.strip() == ""RawScan"":\n                data_start = f.tell()\n                break\n            else:\n                # Break header line into separate parts, and strip trailing whitespace:\n                parts = list(map(str.strip, line.split(\',\')))\n\n                # If length is shorter then three, somethings wrong\n                if len(parts) < 3:\n                    raise IOError(""Header of UDF file is malformed at line %d"" % lineno)\n\n                # Handle some of the header\'s arguments manually, the rest is\n                # just passed to the data object as keyword arguments...\n                if parts[0] == ""SampleIdent"":\n                    name = parts[1]\n                elif parts[0] == ""DataAngleRange"":\n                    twotheta_min = float(parts[1])\n                    twotheta_max = float(parts[2])\n                elif parts[0] == ""ScanStepSize"":\n                    twotheta_step = float(parts[1])\n\n                # TODO extract other keys and replace with default names\n                header_dict[parts[0]] = \',\'.join(parts[1:-1])\n\n        twotheta_count = int((twotheta_max - twotheta_min) / twotheta_step)\n\n        data_objects[0].update(\n            filename=basename,\n            name=name,\n            twotheta_min=twotheta_min,\n            twotheta_max=twotheta_max,\n            twotheta_step=twotheta_step,\n            twotheta_count=twotheta_count,\n            data_start=data_start,\n            **header_dict\n        )\n\n        if close: f.close()\n        return data_objects\n\n    @classmethod\n    def _parse_data(cls, filename, fp, data_objects=None, close=False):\n        f = fp\n\n        # UDF files are singletons, so no need to iterate over the list,\n        # there is only one data object instance:\n        if data_objects[0].data == None:\n            data_objects[0].data = []\n\n        if f is not None:\n            f.seek(data_objects[0].data_start)\n            n = 0\n            last_value_reached = False\n            while n <= data_objects[0].twotheta_count and not last_value_reached:\n                parts = list(map(str.strip, f.readline().split(\',\')))\n                for part in parts:\n                    # Last value ends with a slash:\n                    if part.endswith(\'/\'):\n                        part = part[:-1] # remove the ending ""/""\n                        last_value_reached = True\n                    n += 1\n                    data_objects[0].data.append([ float(data_objects[0].twotheta_min + data_objects[0].twotheta_step * n), float(part) ])\n\n        data_objects[0].data = np.array(data_objects[0].data)\n\n        if close: f.close()\n        return data_objects\n\n    pass # end of class\n'"
pyxrd/file_parsers/xrd_parsers/xrd_data_object.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom io import StringIO\n\nfrom ..data_object import DataObject\nfrom pyxrd.generic.utils import not_none\n\nclass XRDDataObject(DataObject):\n    """"""\n        A generic class holding all the information retrieved from an XRD data\n        file using an XRD-parser class.\n    """"""\n\n    # General information\n    name = None\n    date = None\n\n    # x-axis range\n    twotheta_min = None\n    twotheta_max = None\n    twotheta_count = None\n    twotheta_step = None\n\n    # Wavelength and target information\n    target_type = None\n    alpha1 = None\n    alpha2 = None\n    alpha_average = None\n    beta = None\n    alpha_factor = None\n\n    # Goniometer setup\n    radius = None\n    soller1 = None\n    soller2 = None\n    divergence = None\n\n    # Generator or list of x,y data\n    data = None\n\n    def create_gon_file(self):\n\n        output = """"""        {\n            ""type"": ""Goniometer"", \n            ""properties"": {\n                ""radius"": %(radius)f, \n                ""divergence"": %(divergence)f, \n                ""soller1"": %(soller1)f, \n                ""soller2"": %(soller2)f, \n                ""min_2theta"": %(twotheta_min)f, \n                ""max_2theta"": %(twotheta_max)f, \n                ""steps"": %(twotheta_count)f, \n                ""wavelength"": %(alpha_average)f, \n                ""has_ads"": false, \n                ""ads_fact"": 1.0, \n                ""ads_phase_fact"": 1.0, \n                ""ads_phase_shift"": 0.0, \n                ""ads_const"": 0.0\n            }\n        }"""""" % dict(\n            radius=float(not_none(self.radius, 25)),\n            divergence=float(not_none(self.divergence, 0.5)),\n            soller1=float(not_none(self.soller1, 2.5)),\n            soller2=float(not_none(self.soller2, 2.5)),\n            twotheta_min=float(not_none(self.twotheta_min, 3.0)),\n            twotheta_max=float(not_none(self.twotheta_max, 45.0)),\n            twotheta_count=float(not_none(self.twotheta_count, 2500)),\n            alpha_average=float(not_none(self.alpha_average, 0.154056)),\n        )\n        f = StringIO(output)\n        f.flush()\n        return f\n\n\n    pass #end of class\n'"
pyxrd/file_parsers/xrd_parsers/xrd_parser_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .xrd_data_object import XRDDataObject\n\nclass XRDParserMixin(object):\n    """"""\n        This is a mixin class which provides common functionality and attributes\n        for XRD-data parser classes.\n    """"""\n\n    data_object_type = XRDDataObject\n\n    pass #end of class\n'"
pyxrd/generic/asynchronous/__init__.py,0,b''
pyxrd/generic/asynchronous/cancellable.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n\nclass Cancellable(object):\n    """"""\n        Object which has a (threaded) action that can be cancelled by the user.\n    """"""\n    _stop = None\n\n    def _user_cancelled(self):\n        return bool(self._stop is not None and self._stop.is_set())\n\n    pass #end of class'"
pyxrd/generic/asynchronous/dummy_async_provider.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n\nfrom .dummy_async_server import DummyAsyncServer\n\nclass DummyAsyncServerProvider(object):\n    \n    _server = DummyAsyncServer()\n    \n    @classmethod\n    def get_status(cls):\n        """""" should return a three-tuple consisting of the status colour, label and a description:\n            (""#FF0000"", ""Error"", ""Nameserver not running"")\n        """"""            \n        return (""#00FF00"", ""Connected (Dummy)"", ""Succesfully connected to Dummy PyXRD Server"")\n    \n    @classmethod\n    def get_server(cls):\n        return cls._server\n    \n    @classmethod\n    def launch_server(cls):\n        if cls._server is None:\n            cls._server = DummyAsyncServer()\n        \n    @classmethod\n    def stop_server(cls):\n        cls._server.shutdown()\n        del cls._server\n        \n    pass #end of class'"
pyxrd/generic/asynchronous/dummy_async_result.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n\nclass DummyAsyncResult(object):\n    """""" A non-asynchronous dummy implementation of the AsyncResult object """"""\n    def __init__(self, func):\n        self.result = func()\n        \n    def get(self):\n        return self.result\n    \n    pass #end of class'"
pyxrd/generic/asynchronous/dummy_async_server.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n\nfrom .dummy_async_result import DummyAsyncResult\n\nclass DummyAsyncServer(object):\n    """""" A non-asynchronous dummy implementation of the AsyncServer object """"""\n    \n    def loopCondition(self):\n        return True\n\n    def submit(self, func):\n        return DummyAsyncResult(func)\n\n    def shutdown(self):\n        pass\n    \n    pass #end of class'"
pyxrd/generic/asynchronous/exceptions.py,0,b'\nclass ServerNotRunningException(Exception):\n    pass\n\nclass ServerStartTimeoutExcecption(Exception):\n    pass'
pyxrd/generic/asynchronous/has_async_calls.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom .providers import get_provider\nfrom .exceptions import *\nfrom .dummy_async_server import DummyAsyncServer\n\nclass HasAsyncCalls(object):\n    """"""\n        Class providing utility functions for async calls\n    """"""\n    \n    def submit_async_call(self, func):\n        """""" Utility that passes function calls down to the async server """"""\n        try:\n            self._async_server = get_provider().get_server()\n        except (ServerNotRunningException, ServerStartTimeoutExcecption):\n            logger.warning(""Could not get the default provided async server, using dummy implementation"")\n            self._async_server = DummyAsyncServer()\n        return self._async_server.submit(func)\n        \n\n    def fetch_async_result(self, result):\n        """""" Utility that parses the result objects returned by submit_async_call""""""\n        return result.get()\n\n    pass #end of class'"
pyxrd/generic/asynchronous/providers.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom pyxrd.data.settings import ASYNC_SERER_PROVIDERS, ASYNC_SERVER_PRELOAD\n\n_async_provider = None\n\ndef load_provider():\n    global _async_provider\n    logger.info(""Loading async server provider"")\n    for class_path in ASYNC_SERER_PROVIDERS:\n        logger.info(""Trying to load async server provider at %s"" % class_path)\n        try:\n            components = class_path.split(\'.\')\n            class_name = components[-1]\n            mod = __import__(\'.\'.join(components[:-1]), fromlist=[class_name])\n            klass = getattr(mod, class_name)\n        except (ImportError, AttributeError):\n            logger.warning(""Failed to import async provider %s!"" % class_path)\n            continue\n        _async_provider = klass\n        break\n    logger.info(""Loaded async server provider \'%s\'"" % _async_provider)\n    \n# Pre-load async server if needed:\nif ASYNC_SERVER_PRELOAD:\n    load_provider()\n    if _async_provider is not None:\n        _async_provider.launch_server()\n    \ndef get_provider():\n    global _async_provider\n    if _async_provider is None:\n        load_provider()\n    return _async_provider\n\ndef get_status():\n    return get_provider().get_status()'"
pyxrd/generic/controllers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .objectliststore_controllers import (\n    TreeViewMixin,\n    TreeModelMixin,\n    TreeControllerMixin,\n    ObjectListStoreController,\n    ChildObjectListStoreController,\n    InlineObjectListStoreController,\n)\nfrom .base_controller import BaseController\nfrom .dialog_controller import DialogController\n\n__all__ = [\n    ""TreeViewMixin"",\n    ""TreeModelMixin"",\n    ""TreeControllerMixin"",\n    ""ObjectListStoreController"",\n    ""ChildObjectListStoreController"",\n    ""InlineObjectListStoreController"",\n    ""BaseController"",\n    ""DialogController""\n]\n'"
pyxrd/generic/controllers/base_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.controller import Controller\n\nfrom .status_bar_mixin import StatusBarMixin\n\nclass BaseController(StatusBarMixin, Controller):\n    file_filters = (""All Files"", ""*.*"")\n    widget_handlers = {} # handlers can be string representations of a class method\n\n    pass # end of class\n'"
pyxrd/generic/controllers/dialog_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gdk\n\nfrom pyxrd.generic.controllers.base_controller import BaseController\n\nclass DialogController(BaseController):\n    """"""\n        Simple controller which has a DialogView subclass instance as view.\n    """"""\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        self.on_cancel()\n        return True\n\n    def on_keypress(self, widget, event):\n        if event.keyval == Gdk.keyval_from_name(""Escape""):\n            self.on_cancel()\n            return True\n\n    def on_window_edit_dialog_delete_event(self, event, args=None):\n        self.on_cancel()\n        return True # do not propagate\n\n    def on_cancel(self):\n        self.view.hide()\n\n    pass #end of class'"
pyxrd/generic/controllers/line_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.controllers import BaseController, DialogController\nfrom pyxrd.generic.plot.eye_dropper import EyeDropper\nfrom pyxrd.file_parsers.xrd_parsers import xrd_parsers\nfrom pyxrd.data import settings\n\nclass LinePropertiesController(BaseController):\n    """"""\n        Controller for Line models\' general properties\n    """"""\n    auto_adapt_excluded = [\n        ""noise_fraction"",\n        ""shift_value"",\n        ""shift_position"",\n        ""smooth_type"",\n        ""smooth_degree"",\n        ""strip_startx"",\n        ""strip_endx"",\n        ""noise_level"",\n        ""bg_type"",\n        ""bg_position"",\n        ""bg_scale"",\n        ""peak_startx"",\n        ""peak_endx"",\n        ""peak_area_result"",\n        ""peak_fwhm_result""\n    ] # these are handled by other controllers\n\n    __LINEID__ = ""TRUE""\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def register_adapters(self):\n        super(LinePropertiesController, self).register_adapters()\n        self.update_sensitivities()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update_sensitivities(self):\n        """"""\n            Updates the views sensitivities according to the model state.\n        """"""\n        self.view[self.view.widget_format % ""color""].set_sensitive(not self.model.inherit_color)\n        self.view[""spb_%s"" % self.view.widget_format % ""lw""].set_sensitive(not self.model.inherit_lw)\n        self.view[self.view.widget_format % ""ls""].set_sensitive(not self.model.inherit_ls)\n        self.view[self.view.widget_format % ""marker""].set_sensitive(not self.model.inherit_marker)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @BaseController.observe(""inherit_color"", assign=True)\n    @BaseController.observe(""inherit_lw"", assign=True)\n    @BaseController.observe(""inherit_ls"", assign=True)\n    @BaseController.observe(""inherit_marker"", assign=True)\n    def notif_color_toggled(self, model, prop_name, info):\n        self.update_sensitivities()\n\n    pass  # end of class\n\n\nclass PatternActionController(DialogController):\n    """"""\n        General class for actions that can be applied on ExperimentalPattern\n        models.\n        \n        Attributes:\n         model_setup_method: the name of the method to call on the model to\n          auto-setup any variables for the action. Optional; can be None.\n        model_action_method: the name of the method to call on the model when\n         the user decides to apply the action. Required, cannot be None.\n        model_cancel_method: the name of the method to call on the model when\n         the user decides to cancel the action. Optional; can be None.\n    """"""\n    model_setup_method = None\n    model_action_method = None\n    model_cancel_method = None\n\n    def register_adapters(self):\n        if self.model_setup_method is not None:\n            getattr(self.model, self.model_setup_method)()\n        return super(PatternActionController, self).register_adapters()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        try:\n            action = getattr(self.model, self.model_action_method)\n        except AttributeError:\n            raise ValueError(""Subclasses of PatternActionController should specify a valid action method name (was \'%s\')!"" % self.model_action_method)\n        else:\n            action()\n        return super(PatternActionController, self).on_btn_ok_clicked(event)\n\n    def on_cancel(self):\n        if self.model_cancel_method is not None:\n            getattr(self.model, self.model_cancel_method)()\n        return super(PatternActionController, self).on_cancel()\n\n    pass # end of class\n\nclass AddNoiseController(PatternActionController):\n    """"""\n        Controller for the experimental pattern \'add noise\' action view.\n    """"""\n\n    auto_adapt_included = [\n        ""noise_fraction"",\n    ]\n    model_setup_method = None\n    model_action_method = ""add_noise""\n    model_cancel_method = ""clear_noise_variables""\n\n    pass # end of class\n\n\nclass ShiftDataController(PatternActionController):\n    """"""\n        Controller for the experimental pattern \'shift data\' action view.\n    """"""\n    auto_adapt_included = [\n        ""shift_value"",\n        ""shift_position"",\n    ]\n    model_setup_method = ""setup_shift_variables""\n    model_action_method = ""shift_data""\n    model_cancel_method = ""clear_shift_variables""\n\n    pass # end of class\n\nclass SmoothDataController(PatternActionController):\n\n    auto_adapt_included = [\n        ""smooth_type"",\n        ""smooth_degree"",\n    ]\n    model_setup_method = ""setup_smooth_variables""\n    model_action_method = ""smooth_data""\n    model_cancel_method = ""clear_smooth_variables""\n\n    pass # end of class\n\nclass CalculatePeakPropertiesController(PatternActionController):\n\n    auto_adapt_included = [\n        ""peak_startx"",\n        ""peak_endx"",\n        ""peak_fwhm_result"",\n        ""peak_area_result""\n    ]\n    model_setup_method = None\n    model_action_method = ""clear_peak_properties_variables""\n    model_cancel_method = ""clear_peak_properties_variables""\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_sample_start_clicked(self, event):\n        self.sample(""peak_startx"")\n        return True\n\n    def on_sample_end_clicked(self, event):\n        self.sample(""peak_endx"")\n        return True\n\n    def sample(self, attribute):\n\n        def onclick(x_pos, *args):\n            if self.edc is not None:\n                self.edc.enabled = False\n                self.edc.disconnect()\n                self.edc = None\n            if x_pos != -1:\n                setattr(self.model, attribute, x_pos)\n            self.view.get_toplevel().present()\n\n        self.edc = EyeDropper(\n            self.parent.parent.plot_controller,\n            onclick\n        )\n\n        self.view.get_toplevel().hide()\n        self.parent.parent.view.get_toplevel().present()\n\n    pass # end of class\n\nclass StripPeakController(PatternActionController):\n\n    auto_adapt_included = [\n        ""strip_startx"",\n        ""strip_endx"",\n        ""noise_level"",\n    ]\n    model_setup_method = None\n    model_action_method = ""strip_peak""\n    model_cancel_method = ""clear_strip_variables""\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_sample_start_clicked(self, event):\n        self.sample(""strip_startx"")\n        return True\n\n    def on_sample_end_clicked(self, event):\n        self.sample(""strip_endx"")\n        return True\n\n    def sample(self, attribute):\n\n        def onclick(x_pos, *args):\n            if self.edc is not None:\n                self.edc.enabled = False\n                self.edc.disconnect()\n                self.edc = None\n            if x_pos != -1:\n                setattr(self.model, attribute, x_pos)\n            self.view.get_toplevel().present()\n\n        self.edc = EyeDropper(\n            self.parent.parent.plot_controller,\n            onclick\n        )\n\n        self.view.get_toplevel().hide()\n        self.parent.parent.view.get_toplevel().present()\n\n    pass # end of class\n\nclass BackgroundController(PatternActionController):\n    """"""\n        Controller for the experimental pattern \'remove background\' action view.\n    """"""\n\n    file_filters = xrd_parsers.get_import_file_filters()\n\n    auto_adapt_included = [\n        ""bg_type"",\n        ""bg_position"",\n        ""bg_scale"",\n    ]\n    model_setup_method = ""find_bg_position""\n    model_action_method = ""remove_background""\n    model_cancel_method = ""clear_bg_variables""\n\n    def register_view(self, view):\n        super(BackgroundController, self).register_view(view)\n        view.set_file_dialog(\n            DialogFactory.get_load_dialog(\n                title=""Open XRD file for import"",\n                parent=view.get_top_widget(),\n                filters=self.file_filters\n            ),\n            self.on_pattern_file_set\n        )\n        view.select_bg_view(self.model.get_bg_type_lbl().lower())\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @PatternActionController.observe(""bg_type"", assign=True)\n    def notif_bg_type_changed(self, model, prop_name, info):\n        self.view.select_bg_view(self.model.get_bg_type_lbl().lower())\n        return\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_pattern_file_set(self, button, dialog):\n        # TODO\n        # This should allow more flexibility:\n        #  Patterns should be allowed to not have the exact same shape,\n        #  add an x-shift variable to align them\n        filename = dialog.filename\n        parser = dialog.parser\n        data_objects = None\n\n        message = ""An unexpected error has occurred when trying to parse %s:\\n\\n<i>"" % os.path.basename(filename)\n        message += ""{}</i>\\n\\n""\n        message += ""This is most likely caused by an invalid or unsupported file format.""\n        with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=settings.DEBUG):\n            # Parse the pattern file\n            data_objects = parser.parse(filename)\n            pattern = data_objects[0].data\n            bg_pattern_x = pattern[:, 0].copy()\n            bg_pattern_y = pattern[:, 1].copy()\n            del pattern\n\n            # Interpolate/Extrapolate where needed to match data shape and range\n            from scipy.interpolate import interp1d\n            f = interp1d(\n                bg_pattern_x, bg_pattern_y,\n                bounds_error=False, fill_value=0\n            )\n            bg_xnew = self.model.data_x\n            bg_ynew = f(bg_xnew)\n            self.model.bg_pattern = bg_ynew\n\n    pass # end of class\n'"
pyxrd/generic/controllers/objectliststore_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom contextlib import contextmanager\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom mvc.adapters.gtk_support.tree_view_adapters import wrap_list_property_to_treemodel\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.views.treeview_tools import new_text_column, setup_treeview\n\nfrom .base_controller import BaseController\nfrom .dialog_controller import DialogController\n\n\nclass TreeModelMixin(object):\n    """"""\n        A mixin providing functionality to get a TreeModel property from a model.\n        If that property is an actual TreeModel, it will use it directly.\n        Otherwise it will first wrap it in an ObjectListStore\n    """"""\n\n    treemodel_getter_format = ""get_%s_tree_model""\n\n    treemodel_property_name = """"\n    treemodel_class_type = None\n\n    _treemodel = None\n    @property\n    def treemodel(self):\n        self._update_treemodel_property()\n        return self._treemodel\n\n    @property\n    def treemodel_data(self):\n        if getattr(self, ""model"", None) is not None:\n            return getattr(self.model, self.treemodel_property_name, None)\n        else:\n            return None\n\n    def __init__(self, treemodel_property_name=None, treemodel_class_type=None, *args, **kwargs):\n        super(TreeModelMixin, self).__init__(*args, **kwargs)\n        self.treemodel_property_name = not_none(treemodel_property_name, self.treemodel_property_name)\n        self.treemodel_class_type = not_none(treemodel_class_type, self.treemodel_class_type)\n\n    def _update_treemodel_property(self):\n        if getattr(self, ""model"", None) is not None:\n            self._treemodel = wrap_list_property_to_treemodel(\n                self.model,\n                getattr(type(self.model), self.treemodel_property_name)\n            )\n\n\nclass TreeViewMixin(object):\n    """"""\n        Mixin that provides some generic methods to access or set the objects selected in a treeview.\n    """"""\n\n    def get_selected_object(self, tv):\n        # call this implementation, not the overriden method:\n        objects = TreeViewMixin.get_selected_objects(self, tv)\n        if objects is not None and len(objects) == 1:\n            return objects[0]\n        return None\n\n    def get_selected_objects(self, tv):\n        selection = tv.get_selection()\n        if selection.count_selected_rows() >= 1:\n            model, paths = selection.get_selected_rows()\n            if hasattr(model, ""get_tree_node_object_from_path""):\n                return list(map(model.get_tree_node_object_from_path, paths))    \n            else:\n                return list(map(model.get_user_data_from_path, paths))\n        return None\n\n    def get_selected_paths(self, tv):\n        selection = tv.get_selection()\n        if selection.count_selected_rows() >= 1:\n            model, paths = selection.get_selected_rows() # @UnusedVariable\n            return paths\n        return None\n\n    def get_all_objects(self, tv):\n        return tv.get_model()._data\n\n    def set_selected_paths(self, tv, paths):\n        selection = tv.get_selection()\n        selection.unselect_all()\n        for path in paths:\n            selection.select_path(path)\n\nclass TreeControllerMixin(TreeViewMixin, TreeModelMixin):\n    """"""\n        Mixin that can be used for regular ObjectListStoreControllers (two-pane view).\n        \n        Attributes:\n            model_property_name: the property name in the model corresponding to\n             the ObjectListStore\n            multi_selection: whether or not to allow multiple items to be selected\n            columns: a list of tuples (name, column index or name) detailing which\n             columns should be added to the TreeView. If a column name is passed,\n             it is translated to the corresponding index.\n             By default a text column is added, for custom setups you can define\n             a custom method name according to this format: setup_treeview_col_name_%s\n             Replace the %s with the column name you specified in this list.\n            delete_msg: the default message to display when a user wants to delete one or more items.\n            obj_type_map: a list of three-tuples (object type, view type, controller type)\n             used to create the controller and view for editing a selected object.\n    """"""\n\n    multi_selection = True\n    columns = [ (""Object name"", 0) ]\n    delete_msg = ""Deleting objects is irreversible!\\nAre You sure you want to continue?""\n    obj_type_map = [] # list of three-tuples (object type, view type, controller type)\n\n    _edit_controller = None\n    _edit_view = None\n\n    def __init__(self, *args, **kwargs):\n        self.multi_selection = kwargs.pop(""multi_selection"", True)\n        self.columns = kwargs.pop(""columns"", self.columns)\n        self.delete_msg = kwargs.pop(""delete_msg"", self.delete_msg)\n\n        super(TreeControllerMixin, self).__init__(*args, **kwargs)\n\n    __row_signal_ids = None\n    def _update_treemodel_property(self):\n        # If we\'ve connected to a treemodel before, clean up first:\n        if self.__row_signal_ids is not None:\n            old_treemodel, deleted_id, inserted_id = self.__row_signal_ids\n            old_treemodel.disconnect(deleted_id)\n            old_treemodel.disconnect(inserted_id)\n            self.__row_signal_ids = None\n        # If the new treemodel is set, connect it up:\n        if getattr(self, ""model"", None) is not None:\n            super(TreeControllerMixin, self)._update_treemodel_property()\n            # Use private _treemodel attribute, otherwise we get infinite recursions\n            self.__row_signal_ids = (\n                self._treemodel,\n                self._treemodel.connect(""row-deleted"", self.on_item_removed),\n                self._treemodel.connect(""row-inserted"", self.on_item_inserted)\n            )\n\n\n    def get_new_edit_view(self, obj):\n        """"""\n            Gets a new \'edit object\' view for the given obj, view and parent\n            view. Default implementation loops over the `obj_type_map` attribute\n            until it encounters a match.\n        """"""\n        if obj == None:\n            return self.view.none_view\n        else:\n            for obj_tp, view_tp, ctrl_tp in self.obj_type_map: # @UnusedVariable\n                if isinstance(obj, obj_tp):\n                    return view_tp(parent=self.view)\n            raise NotImplementedError(""Unsupported object type %s; subclasses of""\n                "" TreeControllerMixin need to define an obj_type_map attribute!"" % obj)\n\n    def get_new_edit_controller(self, obj, view, parent=None):\n        """"""\n            Gets a new \'edit object\' controller for the given obj, view and parent\n            controller. Default implementation loops over the `obj_type_map` attribute\n            until it encounters a match.\n        """"""\n        if obj == None:\n            return None\n        else:\n            for obj_tp, view_tp, ctrl_tp in self.obj_type_map: # @UnusedVariable\n                if isinstance(obj, obj_tp):\n                    return ctrl_tp(model=obj, view=view, parent=parent)\n            raise NotImplementedError(""Unsupported object type; subclasses of""\n                "" TreeControllerMixin need to define an obj_type_map attribute!"")\n\n    def edit_object(self, obj):\n        self._edit_view = self.view.set_edit_view(self.get_new_edit_view(obj))\n        self._edit_controller = self.get_new_edit_controller(obj, self._edit_view, parent=self.parent)\n        self._edit_view.show_all()\n        return True\n\n    def register_adapters(self):\n        # connects the treeview to the treemodel\n        self.setup_treeview(self.view.treeview)\n        # we can now edit \'nothing\':\n        self.view.set_selection_state(None)\n        self.edit_object(None)\n\n    def setup_treeview(self, tv):\n        """"""\n            Sets up the treeview with columns based on the columns-tuple passed\n            to the __init__ or set in the class definition.\n            Subclasses can override either this method completely or provide\n            custom column creation code on a per-column basis.\n            To do this, create a method for e.g. column with colnr = 2:\n            def setup_treeview_col_2(self, treeview, name, col_descr, col_index, tv_col_nr):\n                ...\n            If a string description of the column number was given, e.g. for the\n            column c_name the definition should be:\n            def setup_treeview_col_c_name(self, treeview, name, col_descr, col_index, tv_col_nr):\n                ...\n                \n            The method should return True upon success or False otherwise.\n        """"""\n        sel_mode = \'MULTIPLE\' if self.multi_selection else \'SINGLE\' # @UndefinedVariable\n        setup_treeview(\n            tv, self.treemodel,\n            sel_mode=sel_mode,\n            on_selection_changed=self.objects_tv_selection_changed)\n        tv.set_model(self.treemodel)\n\n        # reset:\n        for col in tv.get_columns():\n            tv.remove_column(col)\n\n        # add columns\n        for tv_col_nr, (name, col_descr) in enumerate(self.columns):\n            try:\n                col_index = int(col_descr)\n            except:\n                col_index = getattr(self.treemodel, str(col_descr), col_descr)\n\n            handled = False\n            if hasattr(self, ""setup_treeview_col_%s"" % str(col_descr)):\n                handler = getattr(self, ""setup_treeview_col_%s"" % str(col_descr))\n                if callable(handler):\n                    handled = handler(tv, name, col_descr, col_index, tv_col_nr)\n            # custom handler failed or not present, default text column:\n            if not handled:\n                tv.append_column(new_text_column(\n                    name, text_col=col_index,\n                    resizable=(tv_col_nr == 0),\n                    expand=(tv_col_nr == 0),\n                    xalign=0.0 if tv_col_nr == 0 else 0.5))\n\n        return True\n\n    def get_selected_index(self):\n        cur_obj = self.get_selected_object()\n        if cur_obj is not None:\n            return self.treemodel_data.index(cur_obj)\n        else:\n            return None\n\n    def get_selected_object(self):\n        return super(TreeControllerMixin, self).get_selected_object(self.view.treeview)\n\n    def get_selected_objects(self):\n        return super(TreeControllerMixin, self).get_selected_objects(self.view.treeview)\n\n    def get_all_objects(self):\n        return super(TreeControllerMixin, self).get_all_objects(self.view.treeview)\n\n    def select_object(self, obj, path=None, unselect_all=True):\n        selection = self.view.treeview.get_selection()\n        if unselect_all: selection.unselect_all()\n        if obj is not None or path is not None:\n            if path is None:\n                path = self.treemodel.on_get_path(obj)\n            if path is not None: selection.select_path(path)\n\n    def select_objects(self, objs):\n        for obj in objs: self.select_object(obj, unselect_all=False)\n\n    def add_object(self, new_object):\n        if new_object is not None:\n            index = self.get_selected_index()\n            if index is not None:\n                self.treemodel_data.insert(index + 1, new_object)\n            else:\n                self.treemodel_data.append(new_object)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n\n    def on_item_removed(self, *args):\n        self.select_object(None, unselect_all=True)\n\n    def on_item_inserted(self, model, path, iter):\n        self.select_object(None, path=path, unselect_all=True)\n\n    def objects_tv_selection_changed(self, selection):\n        obj = self.get_selected_object()\n        objs = self.get_selected_objects()\n        self.view.set_selection_state(len(objs) if objs is not None else None)\n        if self._edit_controller == None or obj != self._edit_controller.model:\n            self.edit_object(obj)\n\n    def on_load_object_clicked(self, event):\n        raise NotImplementedError\n\n    def on_save_object_clicked(self, event):\n        raise NotImplementedError\n\n    def create_new_object_proxy(self):\n        raise NotImplementedError\n\n    def on_add_object_clicked(self, event):\n        new_object = self.create_new_object_proxy()\n        if new_object:\n            self.add_object(new_object)\n            self.select_object(new_object)\n        return True\n\n    @contextmanager\n    def _multi_operation_context(self):\n        """"""\n            This method should be called as a context manager (with self._multi_...)\n            anytime more then one object is changed at the same time.\n            Default implementation does not do anything, but this can be used\n            to e.g. hold signals from firing until all objects have changed.  \n        """"""\n        yield # default implementation doesn\'t do anything.\n\n    def on_del_object_clicked(self, event, del_callback=None, callback=None):\n        tv = self.view.treeview\n        selection = tv.get_selection()\n        if selection.count_selected_rows() >= 1:\n            def delete_objects(dialog):\n                with self._multi_operation_context():\n                    for obj in self.get_selected_objects():\n                        if callable(del_callback):\n                            del_callback(obj)\n                        else:\n                            self.treemodel_data.remove(obj)\n                        if callable(callback): callback(obj)\n                    self.edit_object(None)\n            parent = self.view.get_top_widget()\n            if not isinstance(parent, Gtk.Window): # @UndefinedVariable\n                parent = None\n            DialogFactory.get_confirmation_dialog(\n                message=self.delete_msg, parent=parent\n            ).run(delete_objects)\n\n\nclass ObjectListStoreController(DialogController, TreeControllerMixin):\n    """"""\n        A stand-alone, regular ObjectListStore controller (left pane with objects and right pane with object properties)\n    """"""\n    title = ""Edit Dialog""\n    auto_adapt = False\n\n    def __init__(self, *args, **kwargs):\n        self.title = not_none(kwargs.pop(""title"", None), self.title)\n        super(ObjectListStoreController, self).__init__(*args, **kwargs)\n\n    def register_view(self, view):\n        super(ObjectListStoreController, self).register_view(view)\n        view.set_title(self.title)\n\n    @DialogController.model.setter\n    def _set_model(self, model):\n        super(ObjectListStoreController, self)._set_model(model)\n        if self.view is not None:\n            self._update_treemodel_property()\n\n    def register_adapters(self):\n        TreeControllerMixin.register_adapters(self)\n\n\nclass ChildObjectListStoreController(BaseController, TreeControllerMixin):\n    """"""\n        An embeddable, regular ObjectListStore controller (left pane with objects and right pane with object properties)\n    """"""\n    auto_adapt = False\n\n    @DialogController.model.setter\n    def _set_model(self, model):\n        super(ObjectListStoreController, self)._set_model(model)\n        if self.view is not None:\n            self._update_treemodel_property()\n\n    def register_adapters(self):\n        TreeControllerMixin.register_adapters(self)\n\nclass InlineObjectListStoreController(BaseController, TreeControllerMixin):\n    """"""\n        ObjectListStore controller that consists of a single TreeView, \n        with import & export and add & delete buttons and an optional combo box\n        for type selection\n        Subclasses should override the _setup_treeview method to setup their \n        columns and edit support.\n    """"""\n    treeview = None\n    enable_import = False\n    enable_export = False\n    add_types = list()\n    auto_adapt = False\n\n    _edit_dict = None\n    def _edit_item(self, item):\n        item_type = type(item)\n        if self._edit_dict is None:\n            # Create a edit dict which keeps track of our controllers\n            self._edit_dict = {}\n\n        # If the first time, create the view & controller\n        if not item in self._edit_dict:        \n            for name, tpe, view, ctrl in self.add_types: # @UnusedVariable\n                if tpe == item_type:\n                    vw = view()\n                    ctrl = ctrl(model=item, view=vw, parent=self)\n                    self._edit_dict[item] = (vw, ctrl)\n                    break\n        # Re-use previously created controllers\n        vw, ctrl = self._edit_dict[item]\n        vw.present()\n\n\n    def _setup_combo_type(self, combo): # TODO this is view-related!\n        if self.add_types:\n            store = Gtk.ListStore(str, object, object, object) # @UndefinedVariable\n            for name, type, view, ctrl in self.add_types: # @ReservedAssignment\n                store.append([name, type, view, ctrl])\n\n            combo.set_model(store)\n\n            cell = Gtk.CellRendererText() # @UndefinedVariable\n            combo.pack_start(cell, True)\n            combo.add_attribute(cell, \'text\', 0)\n\n            def on_changed(combo, user_data=None):\n                itr = combo.get_active_iter()\n                if itr is not None:\n                    val = combo.get_model().get_value(itr, 1)\n                    self.add_type = val\n            combo.connect(\'changed\', on_changed)\n            combo.set_active_iter(store[0].iter)\n            combo.set_visible(True)\n            combo.set_no_show_all(False)\n            combo.show_all()\n\n    def _setup_treeview(self, tv, model):\n        raise NotImplementedError\n\n    def __init__(self, *args, **kwargs):\n        self.enable_import = kwargs.pop(""enable_import"", self.enable_import)\n        self.enable_export = kwargs.pop(""enable_export"", self.enable_export)\n        super(InlineObjectListStoreController, self).__init__(*args, **kwargs)\n\n    @BaseController.model.setter\n    def _set_model(self, model):\n        super(ObjectListStoreController, self)._set_model(model)\n        if self.view is not None:\n            self._update_treemodel_property()\n\n    def register_adapters(self):\n        if self.treemodel is not None:\n            self.treeview = self.view.treeview\n            self.treeview.connect(\'cursor-changed\', self.on_treeview_cursor_changed, self.treemodel)\n            self._setup_treeview(self.treeview, self.treemodel)\n            self.type_combobox = self.view.type_combobox_widget\n            self._setup_combo_type(self.type_combobox)\n            self.update_sensitivities()\n        return\n\n    def update_sensitivities(self):\n        self.view.del_item_widget.set_sensitive((self.treeview.get_cursor() != (None, None)))\n        self.view.add_item_widget.set_sensitive((self.treemodel is not None))\n        self.view.export_items_widget.set_visible(self.enable_export)\n        self.view.export_items_widget.set_sensitive(len(self.treemodel_data) > 0)\n        self.view.import_items_widget.set_visible(self.enable_import)\n\n    def get_selected_object(self):\n        return TreeViewMixin.get_selected_object(self, self.treeview)\n\n    def get_selected_objects(self):\n        return TreeViewMixin.get_selected_objects(self, self.treeview)\n\n    def get_all_objects(self):\n        return TreeViewMixin.get_all_objects(self, self.treeview)\n\n    def select_object(self, obj, path=None, unselect_all=True):\n        selection = self.treeview.get_selection()\n        if unselect_all: selection.unselect_all()\n        if obj is not None and hasattr(self.treemodel, ""on_get_path""):\n            selection.select_path(self.treemodel.on_get_path(obj))\n        elif path is not None:\n            selection.select_path(path)\n\n    def create_new_object_proxy(self):\n        raise NotImplementedError\n\n    def edit_object(self, obj):\n        pass\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_treeview_cursor_changed(self, widget, model):\n        self.update_sensitivities()\n\n    def on_item_cell_edited(self, cell, path, new_text, model, col):\n        model.set_value(model.get_iter(path), col, model.convert(col, new_text))\n        pass\n\n    pass # end of class\n'"
pyxrd/generic/controllers/status_bar_mixin.py,0,"b""# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom functools import wraps\n\nclass StatusBarMixin(object):\n    @property\n    def statusbar(self):\n        if self.parent is not None:\n            return self.parent.statusbar\n        elif self.view is not None:\n            return self.view['statusbar']\n        else:\n            return None\n\n    @property\n    def status_cid(self):\n        if self.statusbar is not None:\n            return self.statusbar.get_context_id(self.__class__.__name__)\n        else:\n            return None\n\n    @staticmethod\n    def status_message(message, cid=None):\n        def decorator(func):\n            @wraps(func)\n            def wrapper(self, *args, **kwargs):\n                self.push_status_msg(message, cid)\n                res = func(self, *args, **kwargs)\n                self.pop_status_msg(cid)\n                return res\n            return wrapper\n        return decorator\n\n    def push_status_msg(self, msg, cid=None):\n        if cid is not None:\n            cid = self.statusbar.get_context_id(cid)\n        else:\n            cid = self.status_cid\n        if cid is not None:\n            self.statusbar.push(cid, msg)\n\n    def pop_status_msg(self, cid=None):\n        if cid is not None:\n            cid = self.statusbar.get_context_id(cid)\n        else:\n            cid = self.status_cid\n        if cid is not None:\n            self.statusbar.pop(cid)\n\n    pass # end of class\n"""
pyxrd/generic/gtk_tools/__init__.py,0,b''
pyxrd/generic/gtk_tools/dummy_gobject.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nSIGNAL_RUN_LAST = None\nTYPE_NONE = None\nTYPE_PYOBJECT = None\n\ndef type_register(self, *args, **kwargs):\n    pass'"
pyxrd/generic/gtk_tools/dummy_gtk.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.support.utils import get_new_uuid\n\n\n__all__ = [\n    ""gobject"",\n    ""GtkTreeIter"",\n    ""GenericTreeModel""\n    ""TREE_MODEL_LIST_ONLY""\n]\n\nTREE_MODEL_LIST_ONLY = 0x00\nTREE_MODEL_ITERS_PERSIST = 0x00\n\nevents_pending = lambda: False\n\nclass GtkTreeIter():\n    def __init__(self, user_data, path=None):\n        self.user_data = user_data\n        self.path = path\n\n    pass # end of class\n\n\n\n\nclass GenericTreeModel(object):\n    __connected_signals__ = None\n\n    def __init__(self):\n        self.__connected_signals__ = {}\n\n    def connect(self, signal_name, handler, *args):\n        handlers = self.__connected_signals__.get(signal_name, {})\n        handler_id = get_new_uuid()\n        handlers[handler_id] = (handler, args)\n        self.__connected_signals__[signal_name] = handlers\n        return handler_id\n\n    def disconnect(self, signal_name, handler_id):\n        try:\n            handlers = self.__connected_signals__.get(signal_name, {})\n            del handlers[handler_id]\n        except KeyError:\n            pass\n        return\n\n    def emit(self, signal_name, args=()):\n        handlers = self.__connected_signals__.get(signal_name, {})\n        for id, (handler, user_args) in handlers.items(): # @ReservedAssignment\n            handler(self, *((args,) + user_args))\n        pass\n\n    def set_property(self, *args, **kwargs):\n        pass\n\n    def create_tree_iter(self, user_data):\n        return GtkTreeIter(user_data)\n\n    def get_path(self, itr):\n        return self.on_get_path(itr.user_data)\n\n    def get_iter(self, path):\n        return self.create_tree_iter(self.on_get_iter(path))\n\n    def row_inserted(self, path, itr):\n        self.emit(""row-inserted"", (path, itr))\n\n    def row_deleted(self, indeces):\n        self.emit(""row-deleted"", (indeces,))\n\n    def invalidate_iters(self):\n        pass # TOD0!\n\n    def iter_is_valid(self, itr):\n        return True # TODO!\n\n    def __len__(self):\n        return len(self._model_data)\n\n    pass # end of class\n'"
pyxrd/generic/gtk_tools/gtkexcepthook.py,0,"b'# (c) 2003 Gustavo J A M Carneiro gjc at inescporto.pt\n#     2004-2005 Filip Van Raemdonck\n#\n# http://www.daa.com.au/pipermail/pygtk/2003-August/005775.html\n# Message-ID: <1062087716.1196.5.camel@emperor.homelinux.net>\n#     ""The license is whatever you want.""\n#\n# This file was downloaded from http://www.sysfs.be/downloads/\n# Adaptions 2009-2010 by Martin Renold:\n# - let KeyboardInterrupt through\n# - print traceback to stderr before showing the dialog\n# - nonzero exit code when hitting the ""quit"" button\n# - suppress more dialogs while one is already active\n# - fix Details button when a context in the traceback is None\n# - remove email features\n# - fix lockup with dialog.run(), return to mainloop instead\n# see also http://faq.pyGtk.org/index.py?req=show&file=faq20.010.htp\n# Changes 2012 by Mathijs Dumon:\n# - removed the gtkcompat import statement\n\nimport inspect, linecache, pydoc, sys, traceback\nfrom io import StringIO\nfrom gettext import gettext as _\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, Gdk, Pango  # @UnresolvedImport\n\noriginal_excepthook = sys.excepthook\n\nclass GtkExceptionHook():\n    """"""\n        Exception handling GTK-dialog hook \n    """"""\n\n    # Function that will be called when the user presses ""Quit""\n    # Return True to confirm quit, False to cancel\n    quit_confirmation_func = None\n\n    exception_dialog_active = False\n\n    RESPONSE_QUIT = 1\n\n    def analyze_simple (self, exctyp, value, tb):\n        """"""\n            Analyzes the exception into a human readable stack trace\n        """"""\n        trace = StringIO()\n        traceback.print_exception (exctyp, value, tb, None, trace)\n        return trace\n\n    def lookup (self, name, frame, lcls):\n        \'\'\'Find the value for a given name in the given frame\'\'\'\n        if name in lcls:\n            return \'local\', lcls[name]\n        elif name in frame.f_globals:\n            return \'global\', frame.f_globals[name]\n        elif \'__builtins__\' in frame.f_globals:\n            builtins = frame.f_globals[\'__builtins__\']\n            if type (builtins) is dict:\n                if name in builtins:\n                    return \'builtin\', builtins[name]\n            else:\n                if hasattr (builtins, name):\n                    return \'builtin\', getattr (builtins, name)\n        return None, []\n\n    _parent_window = [None]\n    _level = 0\n    @property\n    def parent_window(self):\n        return self._parent_window[self._level]\n    @parent_window.setter\n    def parent_window(self, value):\n        self._parent_window[self._level] = value\n\n    def overriden_parent_window(self, parent):\n        """"""\n            Sets the parent window temporarily to another value\n            and returns itself, so this can be used as a context\n            manager.\n        """"""\n        self._parent_window.append(parent)\n        self._level = len(self._parent_window)\n        return self\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self):\n        if self._level > 0:\n            self._parent_window.pop(self._level)\n            self._level = len(self._parent_window)\n\n    def analyze (self, exctyp, value, tb):\n        """"""\n            Analyzes the exception into a human readable stack trace\n        """"""\n        import tokenize, keyword\n\n        trace = StringIO()\n        nlines = 3\n        frecs = inspect.getinnerframes (tb, nlines)\n        trace.write (\'Traceback (most recent call last):\\n\')\n        for frame, fname, lineno, funcname, context, _ in frecs:\n            trace.write (\'  File ""%s"", line %d, \' % (fname, lineno))\n            args, varargs, varkw, lcls = inspect.getargvalues (frame)\n\n            def readline (lno=[lineno], *args):\n                if args: print(args)\n                try: return linecache.getline (fname, lno[0])\n                finally: lno[0] += 1\n            all, prev, name, scope = {}, None, \'\', None\n            for ttype, tstr, stup, etup, line in tokenize.generate_tokens (readline):\n                if ttype == tokenize.NAME and tstr not in keyword.kwlist:\n                    if name:\n                        if name[-1] == \'.\':\n                            try:\n                                val = getattr (prev, tstr)\n                            except AttributeError:\n                                # XXX skip the rest of this identifier only\n                                break\n                            name += tstr\n                    else:\n                        assert not name and not scope\n                        scope, val = self.lookup(tstr, frame, lcls)\n                        name = tstr\n                    if val is not None:\n                        prev = val\n                elif tstr == \'.\':\n                    if prev:\n                        name += \'.\'\n                else:\n                    if name:\n                        all[name] = (scope, prev)\n                    prev, name, scope = None, \'\', None\n                    if ttype == tokenize.NEWLINE:\n                        break\n\n            try:\n                details = inspect.formatargvalues (args, varargs, varkw, lcls, formatvalue=lambda v: \'=\' + pydoc.text.repr (v))\n            except:\n                # seen that one on Windows (actual exception was KeyError: self)\n                details = \'(no details)\'\n            trace.write (funcname + details + \'\\n\')\n            if context is None:\n                context = [\'<source context missing>\\n\']\n            trace.write (\'\'.join ([\'    \' + x.replace (\'\\t\', \'  \') for x in [a for a in context if a.strip()]]))\n            if len (all):\n                trace.write (\'  variables: %s\\n\' % str (all))\n\n        trace.write (\'%s: %s\' % (exctyp.__name__, value))\n        return trace\n\n    def __call__ (self, exctyp, value, tb):\n        """"""\n            This is called when an exception occurs.\n        """"""\n        if exctyp is KeyboardInterrupt:\n            return original_excepthook(exctyp, value, tb)\n        sys.stderr.write(self.analyze_simple (exctyp, value, tb).getvalue())\n        if self.exception_dialog_active:\n            return\n\n        Gdk.pointer_ungrab(Gdk.CURRENT_TIME)  # @UndefinedVariable\n        Gdk.keyboard_ungrab(Gdk.CURRENT_TIME)  # @UndefinedVariable\n\n        self.exception_dialog_active = True\n        # Create the dialog\n        dialog = Gtk.MessageDialog(\n            parent=self.parent_window,\n            flags=0, type=Gtk.MessageType.WARNING, buttons=Gtk.ButtonsType.NONE\n        )\n        dialog.set_title (_(""Bug Detected""))\n\n        primary = _(""<big><b>A programming error has been detected.</b></big>"")\n        secondary = _(""It probably isn\'t fatal, but the details should be reported to the developers nonetheless."")\n\n        try:\n            setsec = dialog.format_secondary_text\n        except AttributeError:\n            raise\n            dialog.vbox.get_children()[0].get_children()[1].set_markup (\'%s\\n\\n%s\' % (primary, secondary))\n        else:\n            del setsec\n            dialog.set_markup (primary)\n            dialog.format_secondary_text (secondary)\n\n        dialog.add_button (Gtk.STOCK_CLOSE, Gtk.ResponseType.CLOSE)\n        dialog.add_button (Gtk.STOCK_QUIT, self.RESPONSE_QUIT)\n\n        # Add an expander with details of the problem to the dialog\n        def expander_cb(expander, *ignore):\n            # Ensures that on deactivating the expander, the dialog is resized down\n            if expander.get_expanded():\n                dialog.set_resizable(True)\n            else:\n                dialog.set_resizable(False)\n        details_expander = Gtk.Expander()\n        details_expander.set_label(_(""Details...""))\n        details_expander.connect(""notify::expanded"", expander_cb)\n\n        textview = Gtk.TextView(); textview.show()\n        textview.set_editable (False)\n        textview.modify_font (Pango.FontDescription (""Monospace""))\n\n        sw = Gtk.ScrolledWindow(); sw.show()\n        sw.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)\n        sw.set_size_request(800, 400)\n        sw.add (textview)\n\n        details_expander.add (sw)\n        details_expander.show_all()\n        dialog.get_content_area().pack_start(details_expander, True, True, 0)\n\n        # Get the traceback and set contents of the details\n        try:\n            trace = self.analyze(exctyp, value, tb).getvalue()\n        except:\n            trace = _(""Exception while analyzing the exception."")\n        buf = textview.get_buffer()\n        buf.set_text (trace)\n\n        # Connect callback and present the dialog\n        dialog.connect(\'response\', self._dialog_response_cb, trace)\n        dialog.set_modal(True)\n        dialog.show()\n        dialog.present()\n\n\n    def _dialog_response_cb(self, dialog, resp, trace):\n\n        if resp == self.RESPONSE_QUIT and Gtk.main_level() > 0:\n            if not callable(self.quit_confirmation_func):\n                sys.exit(1) # Exit code is important for IDEs\n            else:\n                if self.quit_confirmation_func():\n                    sys.exit(1) # Exit code is important for IDEs\n                else:\n                    dialog.destroy()\n                    self.exception_dialog_active = False\n\n        else:\n            dialog.destroy()\n            self.exception_dialog_active = False\n\ndef plugin_gtk_exception_hook():\n    hook = GtkExceptionHook()\n    sys.excepthook = hook\n    return hook\n'"
pyxrd/generic/gtk_tools/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gdk\n\ndef convert_string_to_gdk_color_int(color):\n    """"""\n        Converts a string hexadecimal color description to an integer that can\n        be used by gdk functions.\n    """"""\n    color = Gdk.color_parse(color) # @UndefinedVariable\n    return (int(color.red_float * 255) << 24) + (int(color.green_float * 255) << 16) + (int(color.blue_float * 255) << 8) + 255\n\ndef get_color_pb(color, width, height):\n    """"""\n        Gets a Gdk.Pixbuf filled with color (str)\n    """"""\n    pb = GdkPixbuf.Pixbuf.new(GdkPixbuf.Colorspace.RGB, True, 8, width, height)  # @UndefinedVariable\n    pb.fill(convert_string_to_gdk_color_int(color))\n    return pb'"
pyxrd/generic/io/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom io import *\nfrom .custom_io import *\nfrom .utils import get_case_insensitive_glob, retrieve_lowercase_extension\n'"
pyxrd/generic/io/custom_io.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom collections import OrderedDict\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom io import StringIO\n\nfrom zipfile import ZipFile\ntry:\n    # Check if zlib is available, if so, we can use compression when saving\n    import zlib #@UnusedImport\n    from zipfile import ZIP_DEFLATED as COMPRESSION\nexcept ImportError:\n    from zipfile import ZIP_STORED as COMPRESSION\n\nfrom ..utils import not_none\nfrom .json_codec import PyXRDDecoder, PyXRDEncoder\n\nclass StorableRegistry(dict):\n    """"""\n        Basically a dict which maps class names to the actual\n        class types. This relies on the classes being registered using\n        the \'register\' decorator provided in this class type.\n        It also has a number of aliases, for backwards-compatibility (e.g.\n        when class names change or from the era before using this method\n        when we stored the entire class path, we might remove these at\n        some point)\n    """"""\n\n    # For backwards compatibility:\n    aliases = {\n        \'generic.treemodels/XYListStore\': \'XYListStore\',\n        \'generic.treemodels/ObjectListStore\': \'ObjectListStore\',\n        \'generic.treemodels/ObjectTreeStore\': \'ObjectTreeStore\',\n        \'generic.treemodels/IndexListStore\': \'IndexListStore\',\n        \'generic.models.treemodels/ObjectListStore\': \'ObjectListStore\',\n        \'generic.models.treemodels/ObjectTreeStore\': \'ObjectTreeStore\',\n        \'generic.models.treemodels/IndexListStore\': \'IndexListStore\',\n        \'generic.models.treemodels/XYListStore\': \'XYListStore\',\n        \'generic.models/PyXRDLine\': \'PyXRDLine\',\n        \'generic.models/CalculatedLine\': \'CalculatedLine\',\n        \'generic.models/ExperimentalLine\': \'ExperimentalLine\',\n        \'goniometer.models/Goniometer\': \'Goniometer\',\n        \'specimen.models/Specimen\': \'Specimen\',\n        \'specimen.models/Marker\': \'Marker\',\n        \'mixture.models/Mixture\': \'Mixture\',\n        \'atoms.models/AtomType\': \'AtomType\',\n        \'atoms.models/Atom\': \'Atom\',\n        \'probabilities.R0models/R0G1Model\': \'R0G1Model\',\n        \'probabilities.R0models/R0G2Model\': \'R0G2Model\',\n        \'probabilities.R0models/R0G3Model\': \'R0G3Model\',\n        \'probabilities.R0models/R0G4Model\': \'R0G4Model\',\n        \'probabilities.R0models/R0G5Model\': \'R0G5Model\',\n        \'probabilities.R0models/R0G6Model\': \'R0G6Model\',\n        \'probabilities.R1models/R1G2Model\': \'R1G2Model\',\n        \'probabilities.R1models/R1G3Model\': \'R1G3Model\',\n        \'probabilities.R1models/R1G4Model\': \'R1G4Model\',\n        \'probabilities.R2models/R2G2Model\': \'R2G2Model\',\n        \'probabilities.R2models/R2G3Model\': \'R2G3Model\',\n        \'probabilities.R3models/R3G2Model\': \'R3G2Model\',\n        \'phases.CSDS_models/LogNormalCSDSDistribution\': \'LogNormalCSDSDistribution\',\n        \'phases.CSDS_models/DritsCSDSDistribution\': \'DritsCSDSDistribution\',\n        \'phases.atom_relations/AtomRelation\': \'AtomRelation\',\n        \'phases.atom_relations/AtomRatio\': \'AtomRatio\',\n        \'phases.atom_relations/AtomContents\': \'AtomContents\',\n        \'phases.models/UnitCellProperty\': \'UnitCellProperty\',\n        \'phases.models/Component\': \'Component\',\n        \'phases.models/Phase\': \'Phase\',\n        \'project.models/Project\': \'Project\',\n        \'InSituMixture\': None\n    }\n\n    def __getitem__(self, key):\n        key = self.aliases.get(key, key)\n        return super(StorableRegistry, self).__getitem__(key) if key is not None else None\n\n    def register(self):\n        """"""\n            Returns a decorator that will register Storable sub-classes.\n        """"""\n        return self.register_decorator\n\n    def register_decorator(self, cls):\n        if hasattr(cls, \'Meta\') and hasattr(cls.Meta, \'store_id\'):\n            logger.debug(""Registering %s as storage type with id \'%s\'"" % (cls, cls.Meta.store_id))\n            self[cls.Meta.store_id] = cls\n        else:\n            raise TypeError(""Cannot register type \'%s\' without a Meta.store_id!"" % cls)\n        return cls\n\n    pass # end of class\n\n# This is filled using register decorator\nstorables = StorableRegistry()\n\n# Needs to be importable, could be used for more compact Python pickling:\ndef __map_reduce__(json_obj):\n    decoder = PyXRDDecoder(mapper=storables)\n    return decoder.decode(json_obj)\n\nclass Storable(object):\n    """"""\n        A class with a number of default implementations to serialize objects\n        to JSON strings. It used the PyXRDDecoder en PyXRDEncoder.\n        Subclasses should override their \'Meta.store_id\' property\n        and register themselves by calling the storables.register method\n        and applying it as decorator to the subclass:\n        \n         @storables.register()\n         class StorableSubclass(Storable, ...):\n            ...\n            \n        Sub-classes can optionally implement the following methods:\n         - \'json_properties\' or for more fine-grained control \'to_json\'\n         - \'from_json\'\n         \n    """"""\n    __storables__ = []\n\n    class Meta():  # Sub classes need to override this and set store_id!!\n        store_id = None\n\n    ###########################################################################\n    # High-level JSON (de)serialisiation related methods & functions:\n    ###########################################################################\n    def dump_object(self, zipped=False):\n        """"""\n            Returns this object serialized as a JSON string.\n            If `zipped` is true it returns an in-memory ZipFile.\n        """"""\n        content = PyXRDEncoder.dump_object(self)\n        if zipped:\n            f = StringIO()\n            with ZipFile(f, mode=""w"", compression=COMPRESSION) as z:\n                z.writestr(\'content\', content)\n            return f\n        else:\n            return content\n\n    def print_object(self):\n        """"""\n        Prints the output from dump_object().\n        """"""\n        print(self.dump_object())\n\n    ###########################################################################\n    # Low-level JSON (de)serialisiation related methods & functions:\n    ###########################################################################\n    def to_json(self):\n        """"""\n        Method that should return a dict containing two keys:\n         - \'type\' -> registered class Meta.store_id\n         - \'properties\' -> a dict containg all the properties neccesary to \n           re-create the object when serialized as JSON.\n        """"""\n        return {\n            ""type"": self.Meta.store_id,\n            ""properties"": self.json_properties()\n        }\n\n    def to_json_multi_part(self):\n        """"""\n            This should generate a list of two-tuples:\n            (partname, json_dict), (partname, json_dict), ...\n            These can then be saved as seperate files (e.g. in a ZIP file)\n        """"""\n        yield (\'content\', self.to_json())\n\n    def json_properties(self):\n        """"""\n        Method that should return a dict containing all the properties necessary to \n        re-create the object when serialized as JSON.\n        """"""\n        retval = OrderedDict()\n        def add_prop(label, store_private):\n            if not store_private:\n                retval[label] = getattr(self, label)\n            else:\n                try:\n                    retval[label] = getattr(self, store_private)\n                except (TypeError, AttributeError):\n                    retval[label] = getattr(type(self), label)._get(self)\n\n        from mvc.models import Model\n        if isinstance(self, Model):\n            for prop in self.Meta.all_properties:\n                if prop.persistent:\n                    add_prop(prop.label, not_none(prop.store_private, False))\n                    if getattr(prop, \'refinable\', False):\n                        add_prop(prop.get_refinement_info_name(), False)\n        elif hasattr(self, ""__storables__""): # Fallback:\n            for val in self.__storables__:\n                add_prop(val, False)\n        else:\n            raise RuntimeError(""Cannot find either a \'__storables__\' or Meta class attribute on Storable \'%s\' instance!"" % type(self))\n        return retval\n\n    def parse_init_arg(self, arg, default, child=False, default_is_class=False, **kwargs):\n        """"""\n        Can be used to transform an argument passed to a __init__ method of a\n        Storable (sub-)class containing a JSON dict into the actual object it\n        is representing.\n        \n        *arg* the passed argument\n        \n        *default* the default value if argument is None\n        \n        **child* boolean flag indicating wether or not the object is a child,\n        if true, self is passed as the parent keyword to the JSON decoder if\n        the passed argument is a JSON dict\n        \n        **default_is_class** boolean flag indicating whether or not the passed\n        default value is an unitialized type. If True, the type will be initialized\n        using the kwargs passed to this function.\n        \n        **kwargs* any other kwargs are passed to the JSON decoder if the passed\n        argument is a JSON dict\n        \n        :rtype: the argument (not a JSON dict), the actual object (argument was\n        a JSON dict) or the default value (argument was None)\n        """"""\n        if arg == None:\n            if not default_is_class:\n                return default\n            else:\n                if child: kwargs[""parent""] = self\n                return default(**kwargs)\n        elif isinstance(arg, dict) and ""type"" in arg and ""properties"" in arg:\n            arg = PyXRDDecoder(mapper=storables, parent=self if child else None).__pyxrd_decode__(arg, **kwargs)\n            return arg\n        else:\n            return arg\n\n    @classmethod\n    def from_json(cls, *args, **kwargs):\n        """"""\n        Class method transforming JSON kwargs into an instance of this class.\n        By default this assumes a 1-on-1 mapping to the __init__ method.\n        """"""\n        return cls(*args, **kwargs)\n\n    ###########################################################################\n    # Others:\n    ###########################################################################\n    def __reduce__(self):\n        props = self.dump_object()\n        return __map_reduce__, (props,), None\n\n    pass # end of class\n'"
pyxrd/generic/io/data_registry.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom pyxrd.generic.exceptions import AlreadyRegistered, NotRegistered\n\nclass DataRegistry(object):\n    """"""\n        Class for registering data directories and files so they\'re\n        not hard-coded everywhere.\n    """"""\n\n    __data_directories = None\n    __data_files = None\n    _base_dir = None\n\n    def __init__(self, dirs=[], files=[], *args, **kwargs):\n        super(DataRegistry, self).__init__(*args, **kwargs)\n        self.__data_directories = {}\n        self.__data_files = {}\n        for name, path, parent in dirs:\n            self.register_data_directory(name, path, parent=parent)\n\n        for name, path, parent in files:\n            self.register_data_file(name, path, parent=parent)\n\n    def __parse_parent(self, path, parent=None):\n        # Adds parent path:\n        if parent is not None:\n            if parent is not None:\n                try:\n                    path = os.path.join(self.__data_directories[parent], path)\n                except KeyError:\n                    raise NotRegistered(""The data directory named \'%s\' was not found in the registry"" % parent)\n        elif path.startswith(""./""):\n            path = resource_filename(""pyxrd.data"", path)\n        return path\n\n    def register_data_file(self, name, path, parent=None):\n        """"""\n            Registers a data file at \'path\' called \'name\'.\n            If this file is inside a registered data directory, you\n            can use a relative path by setting the \'parent\' keyword argument\n            to the name of the parent data-directory. The parent path\n            will then be appended to the file\'s path. Paths are considered to be\n            relative to data package.\n            \n            Note: names are always made full-caps!\n            \n            If you try to re-register an existing data file, an AlreadyRegistered\n            exception will be raised. Similarly if you pass in an unregistered\n            parent directory name, NotRegistered will be raised.\n        """"""\n        name = name.upper()\n        if not name in self.__data_files:\n            path = self.__parse_parent(path, parent=parent)\n            self.__data_files[name] = path\n        else:\n            raise AlreadyRegistered(""the data file named \'%s\' was already registered"" % name)\n\n    def register_data_directory(self, name, path, parent=None):\n        """"""\n            Registers a data directory at \'path\' called \'name\'.\n            If this is a sub-directory of another registered data directory, you\n            can use a relative path by setting the \'parent\' keyword argument\n            to the name of the parent data-directory. The parent path\n            will then be appended to the child\'s path. Paths are considered to be\n            relative to data package.\n            \n            Note: names are always made full-caps!\n            \n            If you try to re-register an existing data directory, an AlreadyRegistered\n            exception will be raised. Similarly if you pass in an unregistered\n            parent directory name, NotRegistered will be raised.\n        """"""\n        name = name.upper()\n        if not name in self.__data_directories:\n            path = self.__parse_parent(path, parent=parent)\n            self.__data_directories[name] = path\n            try: # Try to create this path:\n                os.makedirs(path)\n            except OSError:\n                pass\n        else:\n            raise AlreadyRegistered(""The data directory named \'%s\' was already registered"" % name)\n\n    def get_directory_path(self, name):\n        """"""\n            Gets the absolute path to a data directory named \'name\'\n        """"""\n        try:\n            path = self.__data_directories[name]\n            if not os.path.isdir(path):\n                return path\n            else:\n                return path\n        except KeyError:\n            raise NotRegistered(""The data directory named \'%s\' was not found in the registry"" % name)\n\n    def get_all_directories(self):\n        """"""\n            Returns a generator looping over all directories in the registry,\n            excluding the project path.\n        """"""\n        for path in list(self.__data_directories.values()):\n            yield path\n\n    def get_file_path(self, name):\n        """"""\n            Gets the absolute path to a data file named \'name\'\n        """"""\n        try:\n            return self.__data_files[name]\n        except KeyError:\n            raise NotRegistered(""The data file named \'%s\' was not found in the registry"" % name)\n\n    def get_all_files(self):\n        """"""\n            Returns a generator looping over all directories in the registry,\n            excluding the project path.\n        """"""\n        for path in list(self.__data_directories.values()):\n            yield resource_filename(""pyxrd.data"", path)\n\n    pass # end of class\n'"
pyxrd/generic/io/json_codec.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport json\nimport numpy as np\n\nclass PyXRDEncoder(json.JSONEncoder):\n    """"""\n        A custom JSON encoder that checks if:\n            - the object has a to_json callable method, if so it is called to\n              convert the object to a JSON encodable object.\n              E.g. the default implementation from the Storable class is a dict object\n              containing:\n               - a \'type\' key mapped to the storage type id of the storable class\n               - a \'properties\' key mapped to a dict of name-values for each\n                 property that needs to be stored in order to be able to \n                 recreate the object.\n              If the user registered this class as a storable\n              (see the \'registes_storable\' method or the Storable class)\n              then the JSON object is transformed back into the actual Python\n              object using its from_json(...) method. Default implementation\n              finds the registered class using the \'type\' value and passes the\n              \'properties\' value to its constructor as keyword arguments.  \n            - if the object is a numpy array, it is converted to a list\n            - if the object is a wrapped list, dictionary, ... (ObsWrapper \n              subclass) then the wrapped object is returned, as these are\n              directly JSON encodable.\n            - fall back to the default JSONEncoder methods\n    """"""\n\n    ###########################################################################\n    # Convenience functions: use these!\n    ###########################################################################\n    @classmethod\n    def dump_object(cls, obj):\n        """""" Serialize an object using this encoder and return it as a string """"""\n        return json.dumps(obj, indent=4, cls=cls)\n\n    @classmethod\n    def dump_object_to_file(cls, obj, f):\n        """""" Serialize an object using this encoder and dump it into a file""""""\n        return json.dump(obj, f, indent=4, cls=cls)\n\n    ###########################################################################\n    # Sub class implementation:\n    ###########################################################################\n    def default(self, obj):\n        from mvc.support.observables import ObsWrapper\n        if hasattr(obj, ""to_json"") and callable(getattr(obj, ""to_json"")):\n            return obj.to_json()\n        if isinstance(obj, np.ndarray):\n            return obj.tolist()\n        if isinstance(obj, ObsWrapper):\n            return obj._obj # return the wrapped object\n        return json.JSONEncoder(self).default(obj)\n\n\nclass PyXRDDecoder(json.JSONDecoder):\n    """"""\n        A custom JSON decoder that can decode objects, following these steps:\n            - decode the JSON object at once using the default decoder\n            - the resulting dict is then parsed:\n               - if a valid \'type\' and a \'properties\' key is given,\n                 the object is translated using the mapped class type\'s \n                 \'from_json\' method. This mapping is done using a dict mapping\n                 the json class name to an actual class type (`mapper` __init__ keyword)\n               - parent keyword arguments are passed on (e.g. a project) to\n                 the from_json method as well\n    """"""\n\n    def __init__(self, mapper=None, parent=None, **kwargs):\n        super(PyXRDDecoder, self).__init__(**kwargs)\n        self.mapper = mapper\n        self.parent = parent\n\n    ###########################################################################\n    # Convenience functions: use these!\n    ###########################################################################\n    @classmethod\n    def decode_file(cls, f, mapper, parent=None):\n        data = f.read()\n        data = data.decode(""utf-8"") if isinstance(data, bytes) else data \n        return json.loads(data, cls=PyXRDDecoder, mapper=mapper, parent=parent)\n\n    @classmethod\n    def decode_string(cls, string, mapper, parent=None):\n        return json.loads(string, cls=PyXRDDecoder, mapper=mapper, parent=parent)\n\n    ###########################################################################\n    # Sub class implementation:\n    ###########################################################################\n    def decode(self, string):\n        """""" Decodes a json string into an object """"""\n        # First use a regular decode:\n        obj = super(PyXRDDecoder, self).decode(string)\n        # Then parse this dict into an actual python object:\n        return self.__pyxrd_decode__(obj) or obj\n\n    def __pyxrd_decode__(self, obj, **kwargs):\n        """""" Decodes the PyXRD JSON object serialization """"""\n        if isinstance(obj, list):\n            for index, subobj in enumerate(obj):\n                obj[index] = self.__pyxrd_decode__(subobj) or subobj\n            return obj\n        if ""type"" in obj:\n            objtype = self.mapper[obj[""type""]]\n            if ""properties"" in obj and hasattr(objtype, ""from_json""):\n                if self.parent is not None and not ""parent"" in kwargs:\n                    kwargs[""parent""] = self.parent\n                return objtype.from_json(**dict(obj[""properties""], **kwargs))\n        logger.warn(""__pyxrd_decode__ will return None for %s!"" % str(obj)[:30] + ""..."" + str(obj)[:-30])\n        return None\n'"
pyxrd/generic/io/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n""""""\n    Input/Output related utility functions\n""""""\n\nimport os, sys\n\nfrom mvc.support.file_utils import get_case_insensitive_glob, retrieve_lowercase_extension, relpath\n\n# Small workaround to provide a unicode-aware open method:\nif sys.version_info[0] < 3: # Pre Python 3.0\n    import codecs\n    _open_func_bak = open # Make a back up, just in case\n    open = codecs.open #@ReservedAssignment\n\ndef sizeof_fmt(num):\n    \'\'\' Returns a human-friendly string when given a size in bytes \'\'\'\n    for x in [\'bytes\', \'kB\', \'MB\', \'GB\', \'TB\']:\n        if num < 1024.0:\n            return ""%3.1f %s"" % (num, x)\n        num /= 1024.0\n\ndef get_size(path=\'.\', maxsize=None):\n    \'\'\' Gets the recursive size of a path, can be limited to a maxsize \'\'\'\n    total_size = 0\n    for dirpath, dirnames, filenames in os.walk(path): #@UnusedVariable\n        for f in filenames:\n            fp = os.path.join(dirpath, f)\n            total_size += os.path.getsize(fp)\n            if maxsize is not None and total_size > maxsize:\n                break\n        if maxsize is not None and total_size > maxsize:\n            break\n    return total_size\n\ndef unicode_open(*args, **kwargs):\n    """"""\n        Opens files in UTF-8 encoding by default, unless an \'encoding\'\n        keyword argument is passed. Returns a file object.\n    """"""\n    if not ""encoding"" in kwargs:\n        kwargs[""encoding""] = ""utf-8""\n    return open(*args, **kwargs)'"
pyxrd/generic/models/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import PyXRDModel, ChildModel, DataModel\nfrom .lines import PyXRDLine, CalculatedLine, ExperimentalLine\n\n__all__ = [\n    ""PyXRDModel"", ""ChildModel"", ""DataModel"",\n    ""PyXRDLine"", ""CalculatedLine"", ""ExperimentalLine"",\n]\n'"
pyxrd/generic/models/base.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport weakref\nfrom warnings import warn\n\nfrom mvc import Model\nfrom mvc.models.properties import LabeledProperty, SignalProperty\nfrom mvc.support.utils import pop_kwargs, not_none\n\nclass PyXRDModel(Model):\n    """"""\n        A UUIDModel with some common PyXRD functionality\n    """"""\n\n    class Meta(Model.Meta):\n        @classmethod\n        def get_refinable_properties(cls):\n            if not hasattr(cls, ""all_properties""):\n                raise RuntimeError(""Meta class \'%s\' has not been initialized"" \\\n                    "" properly: \'all_properties\' is not set!"" % type(self))\n            else:\n                return [attr for attr in cls.all_properties if getattr(attr, ""refinable"", False)]\n\n        pass # end of class\n\n    # ------------------------------------------------------------\n    #      Methods & functions\n    # ------------------------------------------------------------\n    def pop_kwargs(self, kwargs, *keys):\n        return pop_kwargs(kwargs, *keys)\n\n    def get_kwarg(self, fun_kwargs, default, *keywords):\n        """"""\n        Convenience function to get a certain keyword \'kw\' value from the passed\n        keyword arguments \'fun_kwargs\'. If the key \'kw\' is not in \'fun_kwargs\'\n        a list of deprecated keywords to be searched for can be passed as an\n        optional argument list \'depr_kws\'. If one of these is found, its value\n        is returned and a deprecation warning is emitted. \n        If neither the \'kw\' nor any of the \'depr_kws\' are found the \'default\'\n        value is returned. \n        """"""\n        if len(keywords) < 1:\n            raise AttributeError(""get_kwarg() requires at least one keyword (%d given)"" % (len(keywords)))\n\n        value = default\n        for i, key in enumerate(keywords[::-1]):\n            if key in fun_kwargs:\n                value = not_none(fun_kwargs[key], default)\n                if i != 0:\n                    warn(""The use of the keyword \'%s\' is deprecated for %s!"" %\n                        (key, type(self)), DeprecationWarning)\n        return value\n\n    def get_list(self, fun_kwargs, default, *keywords, **kwargs):\n        """"""\n            Convenience function to get a \'list\' type keyword. Supports\n            deprecated serialized ObjectListStores (replaced by regular lists).\n        """"""\n        return self.parse_list(self.get_kwarg(fun_kwargs, default, *keywords), **kwargs)\n\n    def parse_list(self, list_arg, **kwargs):\n        """"""\n            Parses a list keyword argument (be it an actual list, or a\n            former JSON-serialized ObjectListStore object).\n        """"""\n        if isinstance(list_arg, dict) and ""type"" in list_arg:\n            list_arg = list_arg[""properties""][""model_data""]\n        if list_arg is not None:\n            return [\n                self.parse_init_arg(json_obj, None, child=True, **kwargs)\n                for json_obj in list_arg\n             ]\n        else:\n            return list()\n\n    pass # end of class\n\nclass ChildModel(PyXRDModel):\n    """"""\n        A PyXRDModel with child-parent relation support.\n    """"""\n\n    # MODEL INTEL:\n    class Meta(PyXRDModel.Meta):\n\n        @classmethod\n        def get_inheritable_properties(cls): # TODO MOVE THIS TO THE CHILD MODEL!!\n            if not hasattr(cls, ""all_properties""):\n                raise RuntimeError(""Meta class \'%s\' has not been initialized"" \\\n                    "" properly: \'all_properties\' is not set!"" % type(cls))\n            else:\n                return [attr for attr in cls.all_properties if getattr(attr, ""inheritable"", False)]\n\n    # SIGNALS:\n    removed = SignalProperty()\n    added = SignalProperty()\n\n    # PROPERTIES:\n    __parent = None\n    def __get_parent(self):\n        if callable(self.__parent):\n            return self.__parent()\n        else:\n            return self.__parent\n    def __set_parent(self, value):\n        if not self.parent == value:\n            if self.parent is not None:\n                self.removed.emit()\n            try:\n                self.__parent = weakref.ref(value, self.__on_parent_finalize)\n            except TypeError:\n                self.__parent = value\n            if self.parent is not None:\n                self.added.emit()\n    def __on_parent_finalize(self, ref):\n        self.removed.emit()\n        self.__parent = None\n    parent = LabeledProperty(fget=__get_parent, fset=__set_parent)\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, parent=None, *args, **kwargs):\n        super(ChildModel, self).__init__(*args, **kwargs)\n        self.parent = parent\n\n    pass # end of class\n\nclass DataModel(ChildModel):\n    """"""\n        A ChildModel with support for having \'calculation data\' and \'visual data\'            \n    """"""\n\n    # SIGNALS:\n    data_changed = SignalProperty()\n    visuals_changed = SignalProperty()\n\n    pass # end of class\n'"
pyxrd/generic/models/event_context_manager.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom contextlib import contextmanager, ExitStack\n\nclass EventContextManager(object):\n    """"""\n        Event context manager class, to be used as follows:\n        \n         ecm = EventContextManager(model.event1, model.event2, ...)\n        \n         with ecm.ignore():\n             pass #do something here that will cause events to be ignored\n        \n         with ecm.hold():\n             pass #do something here that will cause events to be held back\n        \n    """"""\n    \n    events = []\n    \n    def __init__(self, *events):\n        self.events = events\n        \n    @contextmanager\n    def ignore(self):\n        if len(self.events):\n            with ExitStack() as stack:\n                for event in self.events:\n                    stack.enter_context(event.ignore())\n                yield\n        else:\n            yield\n\n    @contextmanager\n    def hold(self):\n        if len(self.events):\n            with ExitStack() as stack:\n                for event in self.events:\n                    stack.enter_context(event.hold())\n                yield\n        else:\n            yield\n\n    pass #end of class'"
pyxrd/generic/models/mathtext_support.py,0,b''
pyxrd/generic/models/mixins.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport csv\n\nclass CSVMixin(object):\n    """"""\n        Model mixin providing CSV export and import functionality\n    """"""\n\n    @classmethod\n    def save_as_csv(cls, filename, items):\n        atl_writer = csv.writer(open(filename, \'w\'), delimiter=\',\', quotechar=\'""\', quoting=csv.QUOTE_MINIMAL)\n        labels = [prop.label for prop in cls.Meta.get_local_persistent_properties()]\n        atl_writer.writerow(labels)\n        for item in items:\n            prop_row = []\n            for label in labels:\n                prop_row.append(getattr(item, label))\n            atl_writer.writerow(prop_row)\n\n    @classmethod\n    def get_from_csv(cls, filename, parent=None):\n        with open(filename, \'r\') as csvfile:\n            atl_reader = csv.DictReader(csvfile, delimiter=\',\', quotechar=\'""\')\n            labels = [prop.label for prop in cls.Meta.get_local_persistent_properties()]\n            for row in atl_reader:\n                yield cls(parent=parent, **{\n                    prop: row[prop] for prop in labels if prop in row\n                })\n\n    pass # end of class\n'"
pyxrd/generic/models/properties.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties.observe_mixin import ObserveMixin\n\nfrom mvc.support.utils import rec_getattr\n\nclass ObserveChildMixin(ObserveMixin):\n    """"""\n    A descriptor mixin that will make the instance observe and relieve the\n    objects set and clear and set the parent property on the old and new object respectively\n    """"""\n\n    def __relieve_old(self, instance, old, new):\n        if old is not None:\n            instance.relieve_model(old)\n            old.parent = None\n\n    def __observe_new(self, instance, old, new):\n        if new is not None:\n            new.parent = instance\n            instance.observe_model(new)\n\n    pass\n\nclass InheritableMixin(object):\n    """"""\n    Mixing for the ~:class:`mvc.models.properties.LabeledProperty` descriptor\n    that allows the property to be inheritable from another property.\n    When this Mixin is used, the user should pass two additional keyword \n    arguments to the descriptor:\n        - inheritable: boolean set to True if inheriting should be enabled\n        - inherit_flag: dotted string describing where to get the flag \n          indicating the property is inherited yes/no\n        - inherit_from: dotted string describing where to get the attribute if\n          the inherit_flag is True \n    """"""\n\n    inheritable = True\n    inherit_flag = None\n    inherit_from = None\n\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        value = self.get_uninherited(instance, owner)\n        if self.inheritable and rec_getattr(instance, self.inherit_flag, False):\n            value = rec_getattr(instance, self.inherit_from, value)\n        return value\n\n    def get_uninherited(self, instance, owner=None):\n        return super(InheritableMixin, self).__get__(instance, owner)\n\n    pass #end of class\n\nclass IndexProperty(object):\n    """"""Descriptor used to create indexable properties (e.g. W[1,1])""""""\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        if doc is None and fget is not None and hasattr(fget, ""__doc__""):\n            doc = fget.__doc__\n        self._get = fget\n        self._set = fset\n        self._del = fdel\n        self.__doc__ = doc\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        else:\n            return BoundIndexProperty(self, instance)\n\n    def __set__(self, instance, value):\n        raise AttributeError(""can\'t set attribute"")\n\n    def __delete__(self, instance):\n        raise AttributeError(""can\'t delete attribute"")\n\n    def getter(self, fget):\n        return IndexProperty(fget, self._set, self._del, self.__doc__)\n\n    def setter(self, fset):\n        return IndexProperty(self._get, fset, self._del, self.__doc__)\n\n    def deleter(self, fdel):\n        return IndexProperty(self._get, self._set, fdel, self.__doc__)\n\n    pass #end of class\n\nclass BoundIndexProperty(object):\n\n    def __init__(self, item_property, instance):\n        self.__item_property = item_property\n        self.__instance = instance\n\n    def __getitem__(self, key):\n        fget = self.__item_property._get\n        if fget is None:\n            raise AttributeError(""unreadable attribute item"")\n        return fget(self.__instance, key)\n\n    def __setitem__(self, key, value):\n        fset = self.__item_property._set\n        if fset is None:\n            raise AttributeError(""can\'t set attribute item"")\n        fset(self.__instance, key, value)\n\n    def __delitem__(self, key):\n        fdel = self.__item_property._del\n        if fdel is None:\n            raise AttributeError(""can\'t delete attribute item"")\n        fdel(self.__instance, key)\n\n    pass #end of class\n'"
pyxrd/generic/outdated/__init__.py,0,"b'import json\nfrom datetime import datetime\nfrom threading import Thread\nfrom warnings import warn\n\nfrom . import utils\nfrom .mywarnings import *\n\n__version__ = \'0.1.2\'\n\n\ndef check_outdated(package, version):\n    """"""\n    Given the name of a package on PyPI and a version (both strings), checks\n    if the given version is the latest version of the package available.\n\n    Returns a 2-tuple (is_outdated, latest_version) where\n    is_outdated is a boolean which is True if the given version is earlier\n    than the latest version, which is the string latest_version.\n\n    Attempts to cache on disk the HTTP call it makes for 24 hours. If this\n    somehow fails the exception is converted to a warning (OutdatedCacheFailedWarning)\n    and the function continues normally.\n    """"""\n\n    from pkg_resources import parse_version\n\n    parsed_version = parse_version(version)\n    latest = None\n\n    with utils.cache_file(package, \'r\') as f:\n        content = f.read()\n        if content:  # in case cache_file fails and so f is a dummy file\n            latest, cache_dt = json.loads(content)\n            if not utils.cache_is_valid(cache_dt):\n                latest = None\n\n    def get_latest():\n        url = \'https://pypi.python.org/pypi/%s/json\' % package\n        response = utils.get_url(url)\n        return json.loads(response)[\'info\'][\'version\']\n\n    if latest is None:\n        latest = get_latest()\n\n    parsed_latest = parse_version(latest)\n\n    if parsed_version > parsed_latest:\n\n        # Probably a stale cached value\n        latest = get_latest()\n        parsed_latest = parse_version(latest)\n\n\t\t# Don\'t be stupid - I\'m building more recent version locally that have not been released yet\n        #if parsed_version > parsed_latest:\n        #    raise ValueError(\'Version %s is greater than the latest version on PyPI: %s\' %\n        #                     (version, latest))\n\n    is_latest = parsed_version == parsed_latest\n    #assert is_latest or parsed_version < parsed_latest again don\'t be stupid\n\n    with utils.cache_file(package, \'w\') as f:\n        data = [latest, utils.format_date(datetime.now())]\n        json.dump(data, f)\n\n    return not is_latest, latest\n\n\ndef warn_if_outdated(package,\n                     version,\n                     raise_exceptions=False,\n                     background=True,\n                     ):\n    """"""\n    Higher level convenience function using check_outdated.\n\n    The package and version arguments are the same.\n\n    If the package is outdated, a warning (OutdatedPackageWarning) will\n    be emitted.\n\n    Any exception in check_outdated will be converted to a warning (OutdatedCheckFailedWarning)\n    unless raise_exceptions if True.\n\n    If background is True (the default), the check will run in\n    a background thread so this function will return immediately.\n    In this case if an exception is raised and raise_exceptions if True\n    the traceback will be printed to stderr but the program will not be\n    interrupted.\n\n    This function doesn\'t return anything.\n    """"""\n\n    def check():\n        # noinspection PyUnusedLocal\n        is_outdated = False\n        with utils.exception_to_warning(\'check for latest version of %s\' % package,\n                                        OutdatedCheckFailedWarning,\n                                        always_raise=raise_exceptions):\n            is_outdated, latest = check_outdated(package, version)\n\n        if is_outdated:\n            warn(\'The package %s is out of date. Your version is %s, the latest is %s.\'\n                 % (package, version, latest),\n                 OutdatedPackageWarning)\n\n    if background:\n        thread = Thread(target=check)\n        thread.start()\n    else:\n        check()\n\n\nwarn_if_outdated(\'outdated\', __version__)\n'"
pyxrd/generic/outdated/mywarnings.py,0,"b'from warnings import filterwarnings\n\n\nclass OutdatedWarningBase(Warning):\n    """"""\n    Base class for warnings in this module. Use this to filter all\n    warnings from this module.\n    """"""\n\n\nclass OutdatedPackageWarning(OutdatedWarningBase):\n    """"""\n    Warning emitted when a package is found to be out of date.\n    """"""\n\n\nfilterwarnings(""always"", category=OutdatedPackageWarning)\n\n\nclass OutdatedCheckFailedWarning(OutdatedWarningBase):\n    """"""\n    Warning emitted when checking the version of a package fails\n    with an exception.\n    """"""\n\n\nclass OutdatedCacheFailedWarning(OutdatedWarningBase):\n    """"""\n    Warning emitted when writing to or reading from the cache\n    fails with an exception.\n    """"""\n'"
pyxrd/generic/outdated/utils.py,0,"b'import os\nfrom time import sleep\nimport tempfile\nimport functools\nfrom contextlib import contextmanager\nfrom datetime import datetime, timedelta\nfrom warnings import warn\n\nfrom .mywarnings import OutdatedCacheFailedWarning\n\ndef retry(num_attempts=3, exception_class=Exception, log=None, sleeptime=1):\n    """"""\n    >>> def fail():\n    ...     runs[0] += 1\n    ...     {}[1]\n    >>> runs = [0]; retry(sleeptime=0)(fail)()\n    Traceback (most recent call last):\n    ...\n    KeyError: 1\n    >>> runs\n    [3]\n    >>> runs = [0]; retry(2, sleeptime=0)(fail)()\n    Traceback (most recent call last):\n    ...\n    KeyError: 1\n    >>> runs\n    [2]\n    >>> runs = [0]; retry(exception_class=IndexError, sleeptime=0)(fail)()\n    Traceback (most recent call last):\n    ...\n    KeyError: 1\n    >>> runs\n    [1]\n    >>> logger = DoctestLogger()\n    >>> runs = [0]; retry(log=logger, sleeptime=0)(fail)()\n    Traceback (most recent call last):\n    ...\n    KeyError: 1\n    >>> runs\n    [3]\n    >>> logger.print_logs()\n    Failed with error KeyError(1,), trying again\n    Failed with error KeyError(1,), trying again\n    """"""\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(num_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exception_class as e:\n                    if i == num_attempts - 1:\n                        raise\n                    else:\n                        if log:\n                            log.warn(\'Failed with error %r, trying again\', e)\n                        sleep(sleeptime)\n\n        return wrapper\n\n    return decorator\n\ndef format_date(dt):\n    return dt.strftime(\'%Y-%m-%d %H:%M:%S\')\n\n\ndef cache_is_valid(cache_dt):\n    return format_date(datetime.now() - timedelta(days=1)) < cache_dt\n\n\n# noinspection PyCompatibility\n@retry()\ndef get_url(url):\n    try:\n        from urllib.request import urlopen\n    except ImportError:\n        # noinspection PyUnresolvedReferences\n        from urllib2 import urlopen\n\n    return urlopen(url).read().decode(\'utf8\')\n\n\n@contextmanager\ndef cache_file(package, mode):\n    """"""\n    Yields a file-like object for the purpose of writing to or\n    reading from the cache.\n\n    The code:\n\n        with cache_file(...) as f:\n            # do stuff with f\n\n    is guaranteed to convert any exceptions to warnings (*),\n    both in the cache_file(...) call and the \'do stuff with f\'\n    block.\n\n    The file is automatically closed upon exiting the with block.\n\n    If getting an actual file fails, yields a DummyFile.\n\n    :param package: the name of the package being checked as a string\n    :param mode: the mode to open the file in, either \'r\' or \'w\'\n    """"""\n\n    f = DummyFile()\n\n    # We have to wrap the whole function body in this block to guarantee\n    # catching all exceptions. In particular the yield needs to be inside\n    # to catch exceptions coming from the with block.\n    with exception_to_warning(\'use cache while checking for outdated package\',\n                              OutdatedCacheFailedWarning):\n        try:\n            cache_path = os.path.join(tempfile.gettempdir(),\n                                      get_cache_filename(package))\n            if mode == \'w\' or os.path.exists(cache_path):\n                f = open(cache_path, mode)\n        finally:\n            # Putting the yield in the finally section ensures that exactly\n            # one thing is yielded once, otherwise @contextmanager would\n            # raise an exception.\n            with f:  # closes the file afterards\n                yield f\n\n\ndef get_cache_filename(package):\n    return \'outdated_cache_\' + package\n\n\n@contextmanager\ndef exception_to_warning(description, category, always_raise=False):\n    """"""\n    Catches any exceptions that happen in the corresponding with block\n    and instead emits a warning of the given category, with a message\n    containing the given description and the exception message,\n    unless always_raise is True or the environment variable\n    OUTDATED_RAISE_EXCEPTION is set to 1, in which caise the exception\n    will not be caught.\n    """"""\n\n    try:\n        yield\n    except Exception as e:\n        # We check for the presence of various globals because we may be seeing the death\n        # of the process if this is in a background thread, during which globals\n        # get \'cleaned up\' and set to None\n        if always_raise or os and os.environ and os.environ.get(\'OUTDATED_RAISE_EXCEPTION\') == \'1\':\n            raise\n\n        if warn:\n            warn(\'Failed to %s:\\n\'\n                 \'%s\\n\'\n                 \'Set the environment variable OUTDATED_RAISE_EXCEPTION=1 for a full traceback.\'\n                 % (description, e),\n                 category)\n\n\ndef constantly(x):\n    return lambda *_, **__: x\n\n\nclass DummyFile(object):\n    """"""\n    File-like object that does nothing. All methods take any arguments\n    and return an empty string.\n    """"""\n\n    write = read = close = __enter__ = __exit__ = constantly(\'\')\n'"
pyxrd/generic/plot/__init__.py,0,b''
pyxrd/generic/plot/axes_setup.py,17,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom functools import partial\n\nimport numpy as np\nfrom matplotlib.ticker import FixedLocator, FixedFormatter\n\nfrom pyxrd.calculations.goniometer import get_2t_from_nm, get_nm_from_2t\nfrom pyxrd.data import settings\n\ndef _get_ticks():\n\n    def create_flat_array(*arrays):\n        arr = np.array([], dtype=float)\n        for new_arr in arrays:\n            arr = np.append(arr, new_arr)\n        return arr\n\n    minor_ticks_nm = create_flat_array(\n        np.arange(6.0, 2.0, -0.5),\n        np.arange(2.0, 1.0, -0.1),\n        np.arange(1.0, 0.8, -0.05),\n        np.arange(0.80, 0.00, -0.01)\n    )\n    major_ticks_nm = create_flat_array(\n        np.arange(6.0, 1.0, -1.0),\n        np.arange(2.0, 1.0, -0.5),\n        np.arange(1.0, 0.8, -0.1),\n        np.arange(0.80, 0.00, -0.05)\n    )\n    label_ticks_nm = create_flat_array(\n        np.arange(6.0, 1.0, -2.0),\n        np.arange(2.0, 1.0, -0.5),\n        np.arange(1.0, 0.8, -0.1),\n        np.arange(0.80, 0.40, -0.1),\n        np.arange(0.40, 0.00, -0.05)\n    )\n\n    return minor_ticks_nm, major_ticks_nm, label_ticks_nm\n\ndef set_nm_ticks(axis, wavelength, xmin, xmax):\n    """"""\n        Sets the tick positions and labels for a nanometer x-axes using\n        the given lower & upper limits and the wavelength\n    """"""\n\n    np_nm2a = np.vectorize(partial(get_2t_from_nm, wavelength=wavelength))\n\n    def get_tick_labels(a, b):\n        def in_close(value, arr):\n            for val in arr:\n                if np.isclose(value, val):\n                    return True\n            return False\n        return [ ""%g"" % val if in_close(val, b) else """" for val in a ]\n\n    minor_ticks_nm, major_ticks_nm, label_ticks_nm = _get_ticks()\n\n    dmax = min(get_nm_from_2t(xmin, wavelength), 100) #limit this so we don\'t get an ""infinite"" scale\n    dmin = get_nm_from_2t(xmax, wavelength)\n\n    # Extract the part we need:\n    selector = (minor_ticks_nm >= dmin) & (minor_ticks_nm <= dmax)\n    minor_ticks_pos = np_nm2a(minor_ticks_nm[selector])\n    selector = (major_ticks_nm >= dmin) & (major_ticks_nm <= dmax)\n    major_ticks_pos = np_nm2a(major_ticks_nm[selector])\n\n    major_ticks_labels = get_tick_labels(major_ticks_nm[selector], label_ticks_nm)\n\n    # Set the ticks\n    helper = axis.get_helper()\n\n    helper.axis.minor.locator = FixedLocator(minor_ticks_pos)\n    helper.axis.minor.formatter = FixedFormatter([""""] * len(minor_ticks_pos))\n\n    helper.axis.major.locator = FixedLocator(major_ticks_pos)\n    helper.axis.major.formatter = FixedFormatter(major_ticks_labels)\n\n    pass #end of func\n\ndef update_xaxis(axes, title=\'Angle (\xc2\xb02$\\\\theta$)\', weight=\'heavy\',\n            rotation=0, ha=""center"", va=""center"",\n            pad=0, size=16, nm_ticks=False, wavelength=None):\n\n    axis = axes.axis[""bottom""]\n\n    axis.major_ticks.set_tick_out(True)\n    axis.minor_ticks.set_tick_out(True)\n\n    axis.label.set_text(title)\n    axis.label.set_weight(weight)\n    axis.label.set_size(size)\n    axis.label.set_pad(pad)\n\n    axis.major_ticklabels.set_visible(True)\n    axis.major_ticklabels.set_rotation(rotation)\n    axis.major_ticklabels.set_ha(ha)\n    axis.major_ticklabels.set_va(va)\n\n    if nm_ticks: set_nm_ticks(axis, wavelength, *axes.get_xlim())\n\ndef update_lim(axes, pos_setup, project):\n    # Autoscale the view:\n    axes.autoscale_view(tight=True)\n    xmin, xmax = axes.get_xlim()\n\n    axes.set_ylim(bottom=0, auto=True)\n\n    # Adjust x limits if needed:\n    if project is None or project.axes_xlimit == 0:\n        xmin, xmax = max(xmin, 0.0), max(xmax, 20.0)\n    else:\n        xmin, xmax = max(project.axes_xmin, 0.0), project.axes_xmax\n    axes.set_xlim(left=xmin, right=xmax, auto=False)\n\n\n    # Adjust y limits if needed\n    if project is not None and project.axes_ylimit != 0:\n        scale, _ = project.get_scale_factor()\n\n        ymin = max(project.axes_ymin, 0.0)\n        ymax = project.axes_ymax\n        if ymax <= 0:\n            ymax = axes.get_ylim()[1]\n        else:\n            ymax = ymax * scale\n        ymin = ymin * scale\n\n        axes.set_ylim(bottom=ymin, top=ymax, auto=False)\n\n    # Update plot position setup:\n    pos_setup.xdiff = xmax - xmin\n    pos_setup.xstretch = project.axes_xstretch if project is not None else False\n\ndef update_axes(axes, pos_setup, project, specimens):\n    """"""\n        Internal generic plot update method.\n    """"""\n\n    update_lim(axes, pos_setup, project)\n\n    axes.axis[""right""].set_visible(False)\n    axes.axis[""top""].set_visible(False)\n    axes.get_xaxis().tick_bottom()\n    axes.get_yaxis().tick_left()\n    if project is None or not project.axes_yvisible:\n        axes.axis[""left""].set_visible(False)\n    else:\n        axes.axis[""left""].set_visible(True)\n\n    axes.set_position(pos_setup.position)\n\n    if project is not None and project.axes_dspacing:\n        if specimens is None or len(specimens) == 0:\n            wavelength = settings.AXES_DEFAULT_WAVELENGTH\n        else:\n            wavelength = specimens[0].goniometer.wavelength\n        update_xaxis(axes,\n            title=\'d (nm)\',\n            rotation=-90, ha=""left"", pad=25,\n            nm_ticks=True, wavelength=wavelength,\n        )\n    else:\n        update_xaxis(axes)\n\nclass PositionSetup(object):\n    """"""\n        Keeps track of the positioning of a plot\n    """"""\n    left = settings.PLOT_LEFT\n    top = settings.PLOT_TOP\n    bottom = settings.PLOT_BOTTOM\n\n    xdiff = 20\n    xstretch = settings.AXES_XSTRETCH\n\n    @property\n    def right(self):\n        return self.left + self.width\n\n    @property\n    def width(self):\n        MAX_PLOT_WIDTH = settings.MAX_PLOT_RIGHT - self.left\n        if self.xstretch:\n            return MAX_PLOT_WIDTH\n        else:\n            return min((self.xdiff / 70), 1.0) * MAX_PLOT_WIDTH\n\n    @property\n    def height(self):\n        return abs(self.top - self.bottom)\n\n    @property\n    def position(self):\n        return [self.left, self.bottom, self.width, self.height]\n\n    def to_string(self):\n        return "":"".join(map(str, [self.left,self.right,self.top,self.bottom,self.xdiff,self.xstretch])) \n\n    @property\n    def default_bottom(self):\n        return settings.PLOT_BOTTOM\n\n    @property\n    def default_left(self):\n        return settings.PLOT_LEFT\n    \n    @property\n    def default_top(self):\n        return settings.PLOT_TOP\n\n    pass #end of class\n'"
pyxrd/generic/plot/click_catcher.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .event_delegator import MPLCanvasEventDelegator\n\nclass ClickCatcher():\n    """"""\n        This class can be used to register matplotlib artists, which will\n        fire the update_callback method when clicked. When registering\n        the artist, an arbitrary object can be passed which is passed to the\n        callback. \n    """"""\n    def __init__(self, plot_controller, update_callback=None):\n        self.plot_controller = plot_controller\n        self._canvas = plot_controller.canvas\n        self._window = self._canvas.get_window()\n        self._update_callback = update_callback\n        self.connect()\n        self._artists = {}\n\n    def register_artist(self, artist, obj):\n        self._artists[artist] = obj\n        artist.set_picker(True)\n   \n    def _on_pick(self, event):\n        if event.artist is not None:\n            obj = self._artists.get(event.artist, None)\n            self._update_callback(obj)\n        return False\n\n    def connect(self):\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n        delegator.connect(\'pick_event\', self._on_pick, first=True)\n\n    def disconnect(self):\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n        delegator.disconnect(\'pick_event\', self._on_pick)\n\n    pass #end of class'"
pyxrd/generic/plot/controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\nfrom pyxrd.generic.plot.click_catcher import ClickCatcher\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nimport matplotlib\nimport matplotlib.transforms as transforms\nfrom matplotlib.figure import Figure\nfrom matplotlib.tight_layout import get_renderer\nfrom matplotlib.backends.backend_gtk3 import NavigationToolbar2GTK3 as NavigationToolbar\nfrom matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvasGTK\ntry:\n    from matplotlib.pyparsing import ParseFatalException\nexcept ImportError:\n    from pyparsing import ParseFatalException\n\nfrom mpl_toolkits.axisartist import Subplot\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.data import settings\nfrom pyxrd.generic.plot.motion_tracker import MotionTracker\nfrom pyxrd.generic.plot.axes_setup import PositionSetup, update_axes\nfrom pyxrd.generic.plot.plotters import plot_specimens, plot_mixtures\n\nclass MainPlotController(object):\n    """"""\n        A controller for the main plot canvas.\n        Sets up the widgets and has image exporting functionality.\n    """"""\n    \n    file_filters = (""Portable Network Graphics (PNG)"", ""*.png""), \\\n                   (""Scalable Vector Graphics (SVG)"", ""*.svg""), \\\n                   (""Portable Document Format (PDF)"", ""*.pdf"")\n\n    _canvas = None\n    @property\n    def canvas(self):\n        if not self._canvas:\n            self.setup_figure()\n            self.setup_canvas()\n            self.setup_content()\n        return self._canvas\n\n    # ------------------------------------------------------------\n    #      View integration getters\n    # ------------------------------------------------------------\n    def get_toolbar_widget(self, window):\n        return NavigationToolbar(self.canvas, window)\n\n    def get_canvas_widget(self):\n        return self.canvas\n    \n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, status_callback, marker_callback, *args, **kwargs):\n        self.setup_layout_cache()\n        self.setup_figure()\n        self.setup_canvas()\n        self.setup_content(status_callback, marker_callback)\n\n    def setup_layout_cache(self):\n        self.position_setup = PositionSetup()\n        self.labels = list()\n        self.marker_lbls = list()\n        self._proxies = dict()\n        self.scale = 1.0\n        self.stats = False\n        self._last_pos = None\n\n    def setup_figure(self):\n        self.figure = Figure(dpi=72, facecolor=""#FFFFFF"", linewidth=0)\n        self.figure.subplots_adjust(hspace=0.0, wspace=0.0)\n\n    def setup_canvas(self):\n        self._canvas = FigureCanvasGTK(self.figure)\n\n    def setup_content(self, status_callback, marker_callback):\n        # Create subplot and add it to the figure:\n        self.plot = Subplot(self.figure, 211, facecolor=(1.0, 1.0, 1.0, 0.0))\n        self.plot.set_autoscale_on(False)\n        self.figure.add_axes(self.plot)\n\n        # Connect events:\n        self.canvas.mpl_connect(\'draw_event\', self.fix_after_drawing)\n        self.canvas.mpl_connect(\'resize_event\', self.fix_after_drawing)\n\n        self.mtc = MotionTracker(self, status_callback)\n        self.cc = ClickCatcher(self, marker_callback)\n\n        #self.update()\n\n    # ------------------------------------------------------------\n    #      Update methods\n    # ------------------------------------------------------------\n    def draw(self):\n        self._last_pos = self.fix_before_drawing()\n        self.figure.canvas.draw()\n\n    def fix_after_drawing(self, *args):\n        _new_pos = self.fix_before_drawing()\n        \n        if _new_pos != self._last_pos:\n            self._last_pos = _new_pos\n            self._redraw_later()\n\n        return False\n\n    def _redraw_later(self):\n        self.timer = self.figure.canvas.new_timer(interval=10)\n        self.timer.single_shot = True\n        self.timer.add_callback(lambda : self.figure.canvas.draw_idle())\n        self.timer.start()\n\n    def fix_before_drawing(self, *args):\n        """"""\n            Fixes alignment issues due to longer labels or smaller windows\n            Is executed after an initial draw event, since we can then retrieve\n            the actual label dimensions and shift/resize the plot accordingly.\n        """"""\n        renderer = get_renderer(self.figure)        \n        if not renderer or not self._canvas.get_realized():\n            return False\n        \n        # Fix left side for wide specimen labels:\n        if len(self.labels) > 0:\n            bbox = self._get_joint_bbox(self.labels, renderer)\n            if bbox is not None: \n                self.position_setup.left = self.position_setup.default_left + bbox.width\n        # Fix top for high marker labels:\n        if len(self.marker_lbls) > 0:\n            bbox = self._get_joint_bbox([ label for label, flag, _ in self.marker_lbls if flag ], renderer)\n            if bbox is not None: \n                self.position_setup.top = self.position_setup.default_top - bbox.height\n        # Fix bottom for x-axis label:\n        bottom_label = self.plot.axis[""bottom""].label\n        if bottom_label is not None:\n            bbox = self._get_joint_bbox([bottom_label], renderer)\n            if bbox is not None:\n                self.position_setup.bottom = self.position_setup.default_bottom + (bbox.ymax - bbox.ymin) * 2.0 # somehow we need this?\n\n        # Calculate new plot position & set it:\n        plot_pos = self.position_setup.position\n        self.plot.set_position(plot_pos)\n\n        # Adjust specimen label position\n        for label in self.labels:\n            label.set_x(plot_pos[0] - 0.025)\n\n        # Adjust marker label position\n        for label, flag, y_offset in self.marker_lbls:\n            if flag:\n                newy = plot_pos[1] + plot_pos[3] + y_offset - 0.025\n                label.set_y(newy)\n        \n        _new_pos = self.position_setup.to_string()\n        return _new_pos\n    \n    def update(self, clear=False, project=None, specimens=None):\n        """"""\n            Updates the entire plot with the given information.\n        """"""\n        if clear: self.plot.cla()\n\n        if project and specimens:\n            self.labels, self.marker_lbls = plot_specimens(\n                self.plot, self.position_setup, self.cc,\n                project, specimens\n            )\n            # get mixtures for the selected specimens:\n            plot_mixtures(self.plot, project, [ mixture for mixture in project.mixtures if any(specimen in mixture.specimens for specimen in specimens) ])\n\n        update_axes(\n            self.plot, self.position_setup,\n            project, specimens\n        )\n\n        self.draw()\n\n    # ------------------------------------------------------------\n    #      Plot position and size calculations\n    # ------------------------------------------------------------\n    def _get_joint_bbox(self, container, renderer):\n        bboxes = []\n        try:\n            for text in container:\n                bbox = text.get_window_extent(renderer=renderer)\n                # the figure transform goes from relative coords->pixels and we\n                # want the inverse of that\n                bboxi = bbox.inverse_transformed(self.figure.transFigure)\n                bboxes.append(bboxi)\n        except (RuntimeError, ValueError):\n            logger.exception(""Caught unhandled exception when joining boundig boxes"")\n            return None # don\'t continue\n        # this is the bbox that bounds all the bboxes, again in relative\n        # figure coords\n        if len(bboxes) > 0:\n            bbox = transforms.Bbox.union(bboxes)\n            return bbox\n        else:\n            return None\n\n    # ------------------------------------------------------------\n    #      Graph exporting\n    # ------------------------------------------------------------\n    def save(self, parent=None, current_name=""graph"", size=""auto"", num_specimens=1, offset=0.75):\n        """"""\n            Displays a save dialog to export an image from the current plot.\n        """"""\n        # Parse arguments:\n        width, height = 0, 0\n        if size == ""auto"":\n            descr, width, height, dpi = settings.OUTPUT_PRESETS[0]\n        else:\n            width, height, dpi = list(map(float, size.replace(""@"", ""x"").split(""x"")))\n\n        # Load gui:\n        builder = Gtk.Builder()\n        builder.add_from_file(resource_filename(""pyxrd.specimen"", ""glade/save_graph_size.glade"")) # FIXME move this to this namespace!!\n        size_expander = builder.get_object(""size_expander"")\n        cmb_presets = builder.get_object(""cmb_presets"")\n\n        # Setup combo with presets:\n        cmb_store = Gtk.ListStore(str, int, int, float)\n        for row in settings.OUTPUT_PRESETS:\n            cmb_store.append(row)\n        cmb_presets.clear()\n        cmb_presets.set_model(cmb_store)\n        cell = Gtk.CellRendererText()\n        cmb_presets.pack_start(cell, True)\n        cmb_presets.add_attribute(cell, \'text\', 0)\n        def on_cmb_changed(cmb, *args):\n            itr = cmb.get_active_iter()\n            w, h, d = cmb_store.get(itr, 1, 2, 3)\n            entry_w.set_text(str(w))\n            entry_h.set_text(str(h))\n            entry_dpi.set_text(str(d))\n        cmb_presets.connect(\'changed\', on_cmb_changed)\n\n        # Setup input boxes:\n        entry_w = builder.get_object(""entry_width"")\n        entry_h = builder.get_object(""entry_height"")\n        entry_dpi = builder.get_object(""entry_dpi"")\n        entry_w.set_text(str(width))\n        entry_h.set_text(str(height))\n        entry_dpi.set_text(str(dpi))\n\n        # What to do when the user wants to save this:\n        def on_accept(dialog):\n            # Get the width, height & dpi\n            width = float(entry_w.get_text())\n            height = float(entry_h.get_text())\n            dpi = float(entry_dpi.get_text())\n            i_width, i_height = width / dpi, height / dpi\n            # Save it all right!\n            self.save_figure(dialog.filename, dpi, i_width, i_height)\n\n        # Ask the user where, how and if he wants to save:\n        DialogFactory.get_save_dialog(\n            ""Save Graph"", parent=parent,\n            filters=self.file_filters, current_name=current_name,\n            extra_widget=size_expander\n        ).run(on_accept)\n\n    def save_figure(self, filename, dpi, i_width, i_height):\n        """"""\n            Save the current plot\n            \n            Arguments:\n             filename: the filename to save to (either .png, .pdf or .svg)\n             dpi: Dots-Per-Inch resolution\n             i_width: the width in inch\n             i_height: the height in inch\n        """"""\n        # Get original settings:\n        original_dpi = self.figure.get_dpi()\n        original_width, original_height = self.figure.get_size_inches()\n        # Set everything according to the user selection:\n        self.figure.set_dpi(dpi)\n        self.figure.set_size_inches((i_width, i_height))\n        self.figure.canvas.draw() # replot\n        bbox_inches = matplotlib.transforms.Bbox.from_bounds(0, 0, i_width, i_height)\n        # Save the figure:\n        self.figure.savefig(filename, dpi=dpi, bbox_inches=bbox_inches)\n        # Put everything back the way it was:\n        self.figure.set_dpi(original_dpi)\n        self.figure.set_size_inches((original_width, original_height))\n        self.figure.canvas.draw() # replot\n\n    pass # end of class\n'"
pyxrd/generic/plot/draggables.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gdk\n\nfrom .event_delegator import MPLCanvasEventDelegator\n\nclass DraggableMixin(object):\n    """"""\n        A mixin that can be used to make any matplotlib artist draggable.\n        The constructor takes two callbacks, `on_dragged` and `on_released`\n        which are called when the artist is dragged and released respectively.\n        \n        These callbacks are passed 3 coordinate tuples: the starting point of\n        the drag operation, the previous cursor position and the current cursor\n        position. All of these are in display coordinates. If these need to be \n        converted you can use the `convert_display_to_*` methods where * should\n        be one of figure, axes or data. Aside from these coordinates, the callbacks\n        are also passed the last event object.\n        \n        For more advanced usage the user can also override the \n        `_draggable_on_press`, `_draggable_on_motion` and `_draggable_on_release`\n        event handlers, be sure to call the base implementation if so.\n    """"""\n\n    lock = None  # only one can be animated at a time\n    _prev_event_data = None\n    _draggable_artist = None\n    _draggable_figure = None\n    _draggable_canvas = None\n    _draggable_axes = None\n    _on_dragged = None\n    _on_released = None\n\n    _first_event_data = None\n    _prev_event_data = None\n\n    @property\n    def _is_dragging(self):\n        return not bool(\n            self._draggable_artist is None or \\\n            self._first_event_data is None or \\\n            self._prev_event_data is None\n        )\n\n    def __init__(self,\n            artist=None,\n            on_dragged=None, on_released=None,\n            *args, **kwargs):\n        super(DraggableMixin, self).__init__(*args, **kwargs)\n        self.update(artist, on_dragged, on_released)\n\n    def update(self, artist=None, on_dragged=None, on_released=None):\n        self._on_dragged = on_dragged\n        self._on_released = on_released\n        self.set_draggable_artist(artist)\n\n    def disconnect(self):\n        self.set_draggable_artist(None)\n\n    def set_draggable_artist(self, artist):\n        if self._draggable_artist is not None:\n            self._draggable_disconnect()\n\n        self._draggable_artist = artist\n        self._draggable_figure = artist.figure if artist is not None else None\n        self._draggable_canvas = artist.figure.canvas if artist is not None else None\n        self._draggable_axes = artist.axes if artist is not None else None\n\n        if self._draggable_artist is not None:\n            self._draggable_connect()\n\n    def _convert_to_inverse_transform(self, x, y, transf):\n        inverse = transf.inverted()\n        return inverse.transform((x, y))\n\n    def convert_display_to_figure(self, x, y):\n        return self._convert_to_inverse_transform(\n            x, y, self._draggable_figure.transFigure)\n\n    def convert_display_to_axes(self, x, y):\n        return self._convert_to_inverse_transform(\n            x, y, self._draggable_axes.transAxes)\n\n    def convert_display_to_data(self, x, y):\n        return self._convert_to_inverse_transform(\n            x, y, self._draggable_axes.transData)\n\n    # -- EVENT HANDLERS:\n\n    def _draggable_on_press(self, event):\n        if self._draggable_figure is None: return False\n\n        contains, attrd = self._draggable_artist.contains(event) # @UnusedVariable\n        if not contains: return False\n\n        self._prev_event_data = event.x, event.y\n        self._first_event_data = self._prev_event_data\n\n        return True\n\n    def _draggable_on_motion(self, event):\n        if not self._is_dragging: return\n\n        x0, y0 = self._first_event_data\n        x1, y1 = self._prev_event_data\n        x2, y2 = event.x, event.y\n\n        if callable(self._on_dragged):\n            self._on_dragged(\n                (x0, y0), (x1, y1), (x2, y2),\n                event=event\n            )\n\n        self._prev_event_data = x2, y2\n\n    def _draggable_on_release(self, event):\n        if not self._is_dragging: return\n\n        x0, y0 = self._first_event_data\n        x1, y1 = self._prev_event_data\n        x2, y2 = event.x, event.y\n\n        if callable(self._on_released):\n            self._on_released(\n                (x0, y0), (x1, y1), (x2, y2),\n                event=event\n            )\n\n        self._prev_event_data = None\n        self._first_event_data = None\n\n    # -- CONECTION & DISCONNECTION:\n\n    __connected = False\n    def _draggable_connect(self):\n        if not self.__connected:\n            delegator = MPLCanvasEventDelegator.wrap_canvas(self._draggable_canvas)\n\n            delegator.connect(\'button_press_event\', self._draggable_on_press)\n            delegator.connect(\'button_release_event\', self._draggable_on_release)\n            delegator.connect(\'motion_notify_event\', self._draggable_on_motion)\n\n            self.__connected = True\n\n    def _draggable_disconnect(self):\n        if self.__connected:\n            delegator = MPLCanvasEventDelegator.wrap_canvas(self._draggable_canvas)\n\n            delegator.disconnect(\'button_press_event\', self._draggable_on_press)\n            delegator.disconnect(\'button_release_event\', self._draggable_on_release)\n            delegator.disconnect(\'motion_notify_event\', self._draggable_on_motion)\n\n            self.__connected = False\n\n    pass #end of class\n\n\nclass DraggableVLine(DraggableMixin):\n    """"""\n        A draggable vertical line with a callback called with the new x position\n        of the line after the user released it.\n    """"""\n    def __init__(self, line, callback=None, window=None):\n        super(DraggableVLine, self).__init__(\n            artist=line,\n            on_dragged=self._on_dragged,\n            on_released=self._on_released)\n        self.line = line\n        self.line_x0 = None\n        self.callback = callback\n        self.window = window\n\n    def _check_cursor(self, event):\n        if self.window is not None:\n            change_cursor, _ = self.line.contains(event)\n            if not change_cursor:\n                self.window.set_cursor(None)\n            else:\n                arrows = Gdk.Cursor.new(Gdk.CursorType.SB_H_DOUBLE_ARROW) #@UndefinedVariable\n                self.window.set_cursor(arrows)\n\n    def _draggable_on_motion(self, event):\n        super(DraggableVLine, self)._draggable_on_motion(event)\n        self._check_cursor(event)\n\n    def _on_dragged(self, x0_y0, x1_y1, x2_y2, event):\n        (x0, y0) = x0_y0\n        (x1, y1) = x1_y1\n        (x2, y2) = x2_y2\n        self._check_cursor(event)\n        if self.line_x0 == None:\n            self.line_x0 = self.line.get_xdata()[0]\n\n        diff = self.convert_display_to_data(x2, 0)[0] - self.convert_display_to_data(x0, 0)[0]\n        x = max(self.line_x0 + diff, 0)\n        self.line.set_xdata((x, x))\n\n        self.line.figure.canvas.draw()\n\n    def _on_released(self, x0_y0, x1_y1, x2_y2, event):\n        """"""(x0, y0) = x0_y0\n        (x1, y1) = x1_y1\n        (x2, y2) = x2_y2""""""\n        self._check_cursor(event)\n        if callable(self.callback):\n            self.callback(self.line.get_xdata()[0])\n        self.line_x0 = None\n\n        # redraw the full figure\n        self.line.figure.canvas.draw()\n\n    pass #end of class\n'"
pyxrd/generic/plot/event_delegator.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nclass MPLCanvasEventDelegator(object):\n    """"""\n        An event delegator object that supports stopping event propagation by\n        returning \'True\' and setting event handlers as the first.\n    """"""\n\n    canvas = None\n    _handler_dict = None\n\n    @classmethod\n    def wrap_canvas(cls, canvas):\n        delegator = getattr(canvas, ""__mpl_canvas_delegator"", None)\n        if delegator is None:\n            delegator = MPLCanvasEventDelegator(canvas)\n            setattr(canvas, ""__mpl_canvas_delegator"", delegator)\n        else:\n            assert (delegator.canvas == canvas)\n        return delegator\n\n    def __init__(self, canvas):\n        self.canvas = canvas\n        self._handler_dict = {\n            ""button_press_event"": [],\n            ""button_release_event"": [],\n            ""draw_event"": [],\n            ""key_press_event"": [],\n            ""key_release_event"": [],\n            ""motion_notify_event"": [],\n            ""pick_event"": [],\n            ""resize_event"": [],\n            ""scroll_event"": [],\n            ""figure_enter_event"": [],\n            ""figure_leave_event"": [],\n            ""axes_enter_event"": [],\n            ""axes_leave_event"": [],\n            ""close_event"": [],\n        }\n\n    def _get_handlers(self, event_name):\n        try:\n            handlers = self._handler_dict[event_name]\n        except KeyError:\n            raise ValueError(""Unknown event name!"")\n        return handlers\n\n    def _handle_event(self, event_name):\n        handlers = self._get_handlers(event_name)\n        def _event_handler(event):\n            for handler in handlers:\n                if handler(event): # Returning true stops propagation\n                    break\n                else:\n                    continue\n        return _event_handler\n\n    def connect(self, event_name, handler, first=False):\n        """"""\n            Connects the given handler with the given event_name.\n            If first is set to True the handler will be the first in the list\n            of event handlers. There is no absolute guarantee the handler will\n            remain the first (e.g. later handlers can also call this with \n            first=True).\n        """"""\n        handlers = self._get_handlers(event_name)\n\n        if len(handlers) == 0:\n            setattr(self, ""_event_id_%s"" % event_name, self.canvas.mpl_connect(\n                event_name, self._handle_event(event_name)\n            ))\n\n        if not first:\n            handlers.append(handler)\n        else:\n            handlers.insert(0, handler)\n\n    def disconnect(self, event_name, handler):\n        """"""\n            Disconnects the given handler for the given event_name. \n        """"""\n\n        handlers = self._get_handlers(event_name)\n\n        try:\n            handlers.remove(handler)\n        except ValueError:\n            logger.warning(\n                ""Tried to disconnect an unregistered handler `%r` on `%r`"" % (\n                    handler, self))\n\n        if len(handlers) == 0:\n            event_id = getattr(self, ""_event_id_%s"" % event_name, None)\n            if event_id is not None:\n                self.canvas.mpl_disconnect(event_id)\n            setattr(self, ""_event_id_%s"" % event_name, None)\n\n    pass # end of class\n'"
pyxrd/generic/plot/eye_dropper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gdk\n\nfrom .event_delegator import MPLCanvasEventDelegator\n\nclass EyeDropper():\n    """"""\n        A wrapper that makes eye-dropping a plot possible. Will call\n        the click_callback with an x position and the click event object as\n        arguments.\n    """"""\n    def __init__(self, plot_controller, click_callback=None):\n        self._canvas = plot_controller.canvas\n        self._window = self._canvas.get_window()\n        self._click_callback = click_callback\n        self.connect()\n\n    def _on_motion(self, event):\n        if self._window is not None:\n            self._window.set_cursor(Gdk.Cursor.new(Gdk.CursorType.CROSSHAIR)) # @UndefinedVariable\n        return False\n\n    def _on_click(self, event):\n        x_pos = -1\n        if event.inaxes:\n            x_pos = event.xdata\n        if callable(self._click_callback):\n            self._click_callback(x_pos, event)\n        if self._window is not None:\n            self._window.set_cursor(None)\n        return True\n\n    def connect(self):\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n\n        delegator.connect(\'motion_notify_event\', self._on_motion, first=True)\n        delegator.connect(\'button_press_event\', self._on_click, first=True)\n\n    def disconnect(self):\n        if self._window is not None:\n            self._window.set_cursor(None)\n\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n        delegator.disconnect(\'motion_notify_event\', self._on_motion)\n        delegator.disconnect(\'button_press_event\', self._on_click)\n\n    pass #end of class\n'"
pyxrd/generic/plot/motion_tracker.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .event_delegator import MPLCanvasEventDelegator\n\nclass MotionTracker():\n    """"""\n        A wrapper that tracks mouse movements on a plot. Will call\n        the update_callback with an x position and the click event object as\n        arguments.\n    """"""\n    def __init__(self, plot_controller, update_callback=None):\n        self._canvas = plot_controller.canvas\n        self._window = self._canvas.get_window()\n        self._update_callback = update_callback\n        self.connect()\n\n    def _on_motion(self, event):\n        x_pos = -1\n        if event.inaxes:\n            x_pos = event.xdata\n        if callable(self._update_callback):\n            self._update_callback(x_pos, event)\n        return False\n\n    def connect(self):\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n        delegator.connect(\'motion_notify_event\', self._on_motion, first=True)\n\n    def disconnect(self):\n        delegator = MPLCanvasEventDelegator.wrap_canvas(self._canvas)\n        delegator.disconnect(\'motion_notify_event\', self._on_motion)\n\n    pass #end of class\n'"
pyxrd/generic/plot/plotters.py,11,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\n\nimport matplotlib\nimport matplotlib.colors as mcolors\nimport matplotlib.transforms as transforms\nfrom matplotlib.patches import FancyBboxPatch, Rectangle\nfrom matplotlib.offsetbox import VPacker, HPacker, AnchoredOffsetbox, TextArea, AuxTransformBox\nfrom matplotlib.text import Text\n\nfrom pyxrd.data import settings\nfrom pyxrd.calculations.math_tools import smooth, add_noise\n\nfrom .draggables import DraggableMixin\n\ndef getattr_or_create(obj, attr, create):\n    value = getattr(obj, attr, None)\n    if value == None:\n        class_type, args, kwargs = create\n        value = class_type(*args, **kwargs)\n    return value\n\ndef plot_marker_text(project, marker, offset, marker_scale, base_y, axes):\n    """"""\n        Plots a markers text using the given offset and scale\n    """"""\n    text = getattr(marker, ""__plot_text"", None)\n    within_range = bool(\n        project.axes_xlimit == 0 or\n        (marker.position >= project.axes_xmin and\n        marker.position <= project.axes_xmax)\n    )\n    if marker.visible and marker.style != ""offset"" and within_range:\n        # prevent empty $$ from causing an error:\n        save_label = marker.label.replace(""$$"", """")\n\n        # Calculate position and set transform:\n        x = float(marker.position) + float(marker.x_offset)\n        if marker.top == 0: # relative to base\n            y = base_y + (marker.top_offset + marker.y_offset) * marker_scale\n            transform = axes.transData\n        elif marker.top == 1: # top of plot\n            y = settings.PLOT_TOP + float(marker.y_offset)\n            transform = transforms.blended_transform_factory(axes.transData, axes.get_figure().transFigure)\n\n        kws = dict(text=save_label,\n                   x=x, y=y,\n                   clip_on=False,\n                   transform=transform,\n                   horizontalalignment=marker.align, verticalalignment=""center"",\n                   rotation=(90 - marker.angle), rotation_mode=""anchor"",\n                   color=marker.color,\n                   weight=""heavy"")\n\n        if text:\n            for key in kws: getattr(text, ""set_%s"" % key)(kws[key])\n        else:\n            text = Text(**kws)\n        if not text in axes.get_children():\n            axes.add_artist(text)\n    elif text:\n        try: text.remove()\n        except: pass\n    marker.__plot_text = text\n    return text\n\ndef plot_marker_line(project, marker, offset, base_y, axes):\n    """"""\n        Plots a markers connector line using the given offset\n    """"""\n    line = getattr(marker, ""__plot_line"", None)\n    within_range = bool(\n        project.axes_xlimit == 0 or\n        (marker.position >= project.axes_xmin and\n        marker.position <= project.axes_xmax)\n    )\n    if marker.visible and within_range:\n        # We need to strip away the units for comparison with\n        # non-unitized bounds\n        trans = transforms.blended_transform_factory(axes.transData, axes.transAxes)\n\n        # Calculate top and bottom positions:\n        ymin, ymax = axes.get_ybound()\n        y = base_y\n        y0 = (y - ymin) / (ymax - ymin)\n        if marker.top == 0: # relative to base\n            y1 = y0 + (marker.top_offset - ymin) / (ymax - ymin)\n        elif marker.top == 1: # top of plot\n            y1 = 1.0\n\n        # If style is \'offset\', re-calculate positions accordingly\n        style = marker.style\n        if style == ""offset"":\n            style = ""solid""\n            y0 = (offset - ymin) / (ymax - ymin)\n            y1 = y0 + (marker.y_offset - ymin) / (ymax - ymin)\n\n        data = [y0, y1]\n\n        if line:\n            line.set_xdata(np.array([marker.position, marker.position]))\n            line.set_ydata(np.array(data))\n            line.set_transform(trans)\n            line.set_color(marker.color)\n            line.set_linestyle(style)\n        else:\n            line = matplotlib.lines.Line2D([marker.position, marker.position], data , transform=trans, color=marker.color, ls=style)\n            line.y_isdata = False\n\n        if not line in axes.get_lines():\n            axes.add_line(line)\n    elif line:\n        try: line.remove()\n        except: pass\n    marker.__plot_line = line\n\ndef plot_markers(cc, project, specimen, marker_lbls, offset, scale, marker_scale, axes):\n    """"""\n        Plots a specimens markers using the given offset and scale\n    """"""\n\n    for marker in specimen.markers:\n        base_y = 0\n        if marker.base == 1:\n            base_y = specimen.experimental_pattern.get_plotted_y_at_x(marker.position)\n        elif marker.base == 2:\n            base_y = specimen.calculated_pattern.get_plotted_y_at_x(marker.position)\n        elif marker.base == 3:\n            base_y = min(\n                specimen.experimental_pattern.get_plotted_y_at_x(marker.position),\n                specimen.calculated_pattern.get_plotted_y_at_x(marker.position)\n            )\n        elif marker.base == 4:\n            base_y = max(\n                specimen.experimental_pattern.get_plotted_y_at_x(marker.position),\n                specimen.calculated_pattern.get_plotted_y_at_x(marker.position)\n            )\n\n        plot_marker_line(project, marker, offset, base_y, axes)\n        text = plot_marker_text(project, marker, offset, marker_scale, base_y, axes)\n        if text is not None:\n            cc.register_artist(text, marker)\n            marker_lbls.append((text, marker.base == 0, marker.y_offset))\n\ndef plot_hatches(project, specimen, offset, scale, axes):\n    """"""\n        Plots a specimens exclusion \'hatched\' areas using the given offset and\n        scale\n    """"""\n    # calculate the Y limits\n    y0 = offset\n    y1 = offset + max(specimen.max_display_y * scale, 1.0)\n\n    # these are easier to just remove for now, not too expensive\n    leftborder, hatch, rightborder = getattr(specimen, ""__plot_hatches_artists"", (None, None, None))\n    if leftborder:\n        try: leftborder.remove()\n        except: pass\n    if hatch:\n        try: hatch.remove()\n        except: pass\n    if rightborder:\n        try: rightborder.remove()\n        except: pass\n\n    # Create & add new hatches:\n    for x0, x1 in zip(*specimen.exclusion_ranges.get_xy_data()):\n        leftborder = axes.plot([x0, x0], [y0, y1], c=settings.EXCLUSION_LINES)\n        axes.add_patch(Rectangle(\n            (x0, y0), x1 - x0, y1 - y0,\n            fill=True, hatch=""/"", linewidth=0,\n            facecolor=settings.EXCLUSION_FOREG,\n            edgecolor=settings.EXCLUSION_LINES)\n        )\n        rightborder = axes.plot([x1, x1], [y0, y1], c=settings.EXCLUSION_LINES)\n\ndef plot_label(specimen, labels, label_offset, plot_left, axes):\n    text = getattr(specimen, ""__plot_label_artist"", None)\n\n    # prevent empty $$ from causing an error:\n    save_label = specimen.label.replace(""$$"", """")\n\n    props = dict(\n        text=save_label,\n        x=plot_left - 0.05,\n        y=label_offset,\n        clip_on=False,\n        horizontalalignment=\'right\',\n        verticalalignment=\'center\',\n        transform=transforms.blended_transform_factory(axes.get_figure().transFigure, axes.transData)\n    )\n    if text:\n        for key in props: getattr(text, ""set_%s"" % key)(props[key])\n    else:\n        text = Text(**props)\n    if not text in axes.get_children():\n        axes.add_artist(text)\n    labels.append(text)\n    specimen.__plot_label_artist = text\n\ndef apply_transform(data, scale=1, offset=0, cap=0):\n    data_x, data_y = data\n    data_y = np.array(data_y) # make a copy\n    if cap > 0:\n        np.copyto(data_y, [cap], where=(data_y >= cap)) # copy the cap where values are larger then cap\n    data_y = data_y * scale + offset # scale and offset the capped data\n    return data_x, data_y\n\ndef plot_pattern(pattern, axes, scale=1, offset=0, cap=0, z_data=[None], **kwargs):\n    \n    if len(z_data) > 1 and pattern.data_y.size > 0:\n        # Update the 2d image   \n        colors = [mcolors.colorConverter.to_rgba(pattern.color, 0), mcolors.colorConverter.to_rgba(pattern.color, 1)]\n        cmap = mcolors.LinearSegmentedColormap.from_list(\'mycmap\', colors, N=100)\n        \n        angles = np.array(pattern.data_x, dtype=float)\n        intensities = np.array(pattern.data_y[:,:len(z_data)], dtype=float) * scale + offset\n        rh = np.array(list(map(float, z_data)), dtype=float)\n        \n        rh = rh * scale + offset\n        \n        cols = intensities.shape[0]\n        rows = intensities.shape[1]\n        X = np.ones(shape=(rows, cols), dtype=float) * angles #ANGLE\n        Y = (np.ones(shape=(cols, rows), dtype=float) * rh).transpose() #RH\n        Z = intensities.transpose()\n        axes.pcolormesh(X,Y,Z, cmap=cmap, shading=\'flat\', edgecolors=\'None\', rasterized=False)       \n        \n    else:\n        # setup or update the line\n        line = getattr_or_create(pattern, ""__plot_line"", (matplotlib.lines.Line2D, ([], []), {}))\n    \n        if kwargs:\n            line.update(kwargs)\n        line.update(dict(\n            data=apply_transform(pattern.get_xy_data(), scale=scale, offset=offset, cap=cap),\n            color=pattern.color,\n            linewidth=pattern.lw,\n            ls=getattr(pattern, ""ls"", ""-""),\n            marker=getattr(pattern, ""marker"", """")\n        ))\n        if not line in axes.get_lines():\n            axes.add_line(line)\n        pattern.__plot_line = line\n\ndef make_draggable(artist, drag_x_handler=None, drag_y_handler=None):\n    if artist != None:\n        draggable = getattr(artist, ""__draggable"", None)\n        if draggable == None:\n            draggable = DraggableMixin(artist, drag_x_handler, drag_y_handler)\n        else:\n            draggable.update(artist, drag_x_handler, drag_y_handler)\n        artist.__draggable = draggable\n\ndef plot_specimen(cc, project, specimen, labels, marker_lbls, label_offset, plot_left,\n        offset, scale, marker_scale, axes):\n    """"""\n        Plots a specimens patterns, markers and hatches using the given\n        offset and scale\n    """"""\n    # Plot the patterns;\n\n    z_data = specimen.get_z_list()\n\n    if specimen.display_experimental:\n        pattern = specimen.experimental_pattern\n\n        # plot the experimental pattern:\n        plot_pattern(pattern, axes, scale=scale, offset=offset, cap=pattern.cap_value, z_data=z_data)\n        #make_draggable(getattr(pattern, ""__plot_line"", None), drag_y_handler=specimen.on_pattern_dragged)\n\n        # get some common data for the next lines:\n        x_data, y_data = pattern.get_xy_data()\n        xmin, xmax = (np.min(x_data), np.max(x_data)) if x_data.size > 0 else (0, 0)\n        ymin, ymax = (np.min(y_data), np.max(y_data)) if y_data.size > 0 else (0, 0)\n\n        ########################################################################\n        # plot the background pattern:\n        bg_line = getattr_or_create(pattern, ""__plot_bg_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""2"", zorder=10)))\n        if pattern.bg_type == 0 and pattern.bg_position != 0.0:\n            bg_line.update(dict(\n                data=apply_transform(([xmin, xmax], [pattern.bg_position, pattern.bg_position]), scale=scale, offset=offset),\n                visible=True\n            ))\n        elif pattern.bg_type == 1 and pattern.bg_pattern is not None:\n            bg_line.update(dict(\n                data=apply_transform((x_data, (pattern.bg_pattern * pattern.bg_scale) + pattern.bg_position), scale=scale, offset=offset),\n                visible=True\n            ))\n        else:\n            bg_line.update(dict(\n                data=([], []),\n                visible=True\n            ))\n\n        if bg_line.get_visible() and not bg_line in axes.get_lines():\n            axes.add_line(bg_line)\n        elif not bg_line.get_visible():\n            try: bg_line.remove()\n            except: pass\n        pattern.__plot_bg_line = bg_line\n        ########################################################################\n\n        ########################################################################\n        # plot the smooth pattern:\n        smooth_line = getattr_or_create(pattern, ""__plot_smooth_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""2"", zorder=10)))\n\n        if int(pattern.smooth_degree) > 1:\n            data = x_data, smooth(y_data, pattern.smooth_degree)\n        else:\n            data = [], []\n        smooth_line.update(dict(\n            data=apply_transform(data, scale=scale, offset=offset),\n            visible=bool(pattern.smooth_degree > 1)\n        ))\n        if smooth_line.get_visible() and not smooth_line in axes.get_lines():\n            axes.add_line(smooth_line)\n        elif not smooth_line.get_visible():\n            try: smooth_line.remove()\n            except: pass\n        pattern.__plot_smooth_line = smooth_line\n        ########################################################################\n\n        ########################################################################\n        # plot the noisified pattern:\n        noise_line = getattr_or_create(pattern, ""__plot_noise_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""2"", zorder=10)))\n\n\n        if pattern.noise_fraction > 0.0:\n            data = x_data, add_noise(y_data, pattern.noise_fraction)\n        else:\n            data = [], []\n        noise_line.update(dict(\n            data=apply_transform(data, scale=scale, offset=offset),\n            visible=bool(pattern.noise_fraction > 0.0)\n        ))\n        if noise_line.get_visible() and not noise_line in axes.get_lines():\n            axes.add_line(noise_line)\n        elif not noise_line.get_visible():\n            try: noise_line.remove()\n            except: pass\n        pattern.__plot_noise_line = noise_line\n        ########################################################################\n\n        ########################################################################\n        # plot the shift & reference lines:\n        shifted_line = getattr_or_create(pattern, ""__plot_shifted_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""2"", zorder=10)))\n        reference_line = getattr_or_create(pattern, ""__plot_reference_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""2"", ls=""--"", zorder=10)))\n\n        if pattern.shift_value != 0.0:\n            shifted_line.update(dict(\n                data=apply_transform((x_data - pattern._shift_value, y_data.copy()), scale=scale, offset=offset),\n                visible=True\n            ))\n            position = specimen.goniometer.get_2t_from_nm(pattern.shift_position)\n            reference_line.update(dict(\n                data=apply_transform(([position, position], [0, ymax]), scale=scale, offset=offset),\n                visible=True\n            ))\n            if not shifted_line in axes.get_lines():\n                axes.add_line(shifted_line)\n            if not reference_line in axes.get_lines():\n                axes.add_line(reference_line)\n        else:\n            shifted_line.set_data([], [])\n            shifted_line.set_visible(False)\n            try: shifted_line.remove()\n            except: pass\n            reference_line.set_data([], [])\n            reference_line.set_visible(False)\n            try: reference_line.remove()\n            except: pass\n        pattern.__plot_shifted_line = shifted_line\n        pattern.__plot_reference_line = reference_line\n        ########################################################################\n\n        ########################################################################\n        # plot the pattern after peak stripping:\n        stripped_line = getattr_or_create(pattern, ""__plot_stripped_line"", (matplotlib.lines.Line2D, ([], []), dict(c=""#660099"", lw=""1"", zorder=10)))\n\n\n        if pattern.strip_startx != 0.0 and pattern.strip_endx != 0.0:\n            strip_xdata, strip_ydata = pattern.stripped_pattern\n            stripped_line.update(dict(\n                data=apply_transform((strip_xdata.copy(), strip_ydata.copy()), scale=scale, offset=offset),\n                visible=True\n            ))\n            if not stripped_line in axes.get_lines():\n                axes.add_line(stripped_line)\n        else:\n            stripped_line.set_data([], [])\n            stripped_line.set_visible(False)\n            try: stripped_line.remove()\n            except: pass\n\n        pattern.__plot_stripped_line = stripped_line\n        ########################################################################\n\n        ########################################################################\n        # plot the pattern after peak stripping:\n        artists = getattr(specimen, ""__plot_peak_area"", None)\n        peak_area, peak_fwhm_line = artists if artists is not None else (None, None)\n        if peak_area is not None and peak_area in axes.get_children():\n            peak_area.remove()\n        if peak_fwhm_line is not None and peak_fwhm_line in axes.get_children():\n            peak_fwhm_line.remove()\n        if pattern.peak_startx != 0.0 and pattern.peak_endx != 0.0 and pattern.peak_properties_pattern is not None:\n            peak_xdata, peak_bg, peak_ydata, peak_rootsx, peak_rootsy = pattern.peak_properties_pattern\n            _, peak_bg = apply_transform((peak_xdata.copy(), peak_bg.copy()), scale=scale, offset=offset)\n            peak_xdata, peak_ydata = apply_transform((peak_xdata.copy(), peak_ydata.copy()), scale=scale, offset=offset)\n            peak_rootsx, peak_rootsy = apply_transform((peak_rootsx.copy(), peak_rootsy.copy()), scale=scale, offset=offset)\n            peak_area = axes.fill_between(peak_xdata, peak_bg, peak_ydata, interpolate=True, facecolor=""#660099"", zorder=10)\n            peak_fwhm_line = axes.plot(peak_rootsx, peak_rootsy, color=""#330033"", zorder=11)\n        setattr(specimen, ""__plot_peak_area"", (peak_area, peak_fwhm_line))\n\n    if specimen.display_calculated:\n        pattern = specimen.calculated_pattern\n        plot_pattern(pattern, axes, scale=scale, offset=offset, z_data=z_data)\n        #if not specimen.display_experimental:\n        #    make_draggable(getattr(pattern, ""__plot_line"", None), drag_y_handler=specimen.on_pattern_dragged)\n\n        # setup or update the calculated lines (phases)\n        if specimen.display_phases:\n            phase_lines = getattr(specimen, ""__plot_phase_lines"", [])\n\n            # Clear previous phase lines:\n            for phase_line in phase_lines:\n                if phase_line in axes.get_lines():\n                    axes.remove_line(phase_line)\n\n            # Update & add phase lines:\n            for i in range(2, pattern.num_columns):\n                phase_data = pattern.get_xy_data(i)\n                # Get the line object or create it:\n                try:\n                    phase_line = phase_lines[i - 2]\n                except IndexError:\n                    phase_line = matplotlib.lines.Line2D(*phase_data)\n                    phase_lines.append(phase_line)\n                # Get the phase color or use a default color:\n                try:\n                    phase_color = pattern.phase_colors[i - 2]\n                except IndexError:\n                    phase_color = pattern.color\n                # Update the line object properties:\n                phase_line.update(dict(\n                    data=apply_transform(phase_data, scale=scale, offset=offset),\n                    color=phase_color,\n                    linewidth=pattern.lw\n                ))\n\n                # Add to axes:\n                axes.add_line(phase_line)\n\n            specimen.__plot_phase_lines = phase_lines\n\n    # mineral preview sticks\n    if hasattr(specimen, ""mineral_preview"") and specimen.mineral_preview is not None:\n        name, peaks = specimen.mineral_preview\n        lines = getattr(specimen, ""__plot_mineral_preview"", [])\n        for line in lines:\n            try: line.remove()\n            except: pass\n\n        lines = []\n        for position, intensity in peaks:\n            position = specimen.goniometer.get_2t_from_nm(position / 10.)\n            intensity /= 100.\n\n            trans = transforms.blended_transform_factory(axes.transData, axes.transAxes)\n            ymin, ymax = axes.get_ybound()\n            style = ""solid""\n            color = ""#FF00FF""\n            y0 = (offset - ymin) / (ymax - ymin)\n            y1 = y0 + (intensity - ymin) / (ymax - ymin)\n            line = matplotlib.lines.Line2D(\n                [position, position], [y0, y1],\n                transform=trans, color=color, ls=style\n            )\n            axes.add_line(line)\n            lines.append(line)\n        setattr(specimen, ""__plot_mineral_preview"", lines)\n\n\n    # exclusion ranges;\n    plot_hatches(project, specimen, offset, scale, axes)\n    # markers;\n    plot_markers(cc, project, specimen, marker_lbls, offset, scale, marker_scale, axes)\n    # & label:\n    plot_label(specimen, labels, label_offset, plot_left, axes)\n    #make_draggable(getattr(specimen, ""__plot_label_artist"", None), drag_y_handler=project.on_label_dragged)\n\ndef plot_statistics(project, specimen, spec_scale, stats_y_pos, stats_height, axes):\n\n    # Scales & shifts the pattern so the zero line plots in the middle.\n    def plot_pattern_middle(pattern, axes, height, vscale, offset, **kwargs):\n        """"""\n            Height is the fraction of the plot reserved for the residual pattern\n            vscale is a user scaling factor applied to the residual pattern\n            offset is the offset of the residual pattern position from the x-axis of the plot\n        """"""\n        # Offset to the middle of the available space:\n        offset = offset + 0.5 * height\n        # If the intensity difference is smaller then the space available, don\'t scale\n        scale = spec_scale * 0.5 * vscale\n        plot_pattern(pattern, axes, scale=scale, offset=offset, **kwargs)\n\n    if specimen.display_residuals and specimen.statistics.residual_pattern is not None:\n        plot_pattern_middle(\n            specimen.statistics.residual_pattern,\n            axes, height=stats_height,\n            vscale=specimen.display_residual_scale,\n            offset=stats_y_pos, alpha=0.75\n        )\n    if specimen.display_derivatives:\n        for pattern in (\n                specimen.statistics.der_residual_pattern,\n                specimen.statistics.der_exp_pattern,\n                specimen.statistics.der_calc_pattern):\n            if pattern is not None:\n                plot_pattern_middle(\n                    pattern, axes, height=stats_height,\n                    vscale=specimen.display_residual_scale,\n                    offset=stats_y_pos, alpha=0.65\n                )\n\ndef plot_specimens(axes, pos_setup, cc, project, specimens):\n    """"""\n        Plots multiple specimens within the context of a project\n    """"""\n\n    base_offset = project.display_plot_offset\n    base_height = 1.0\n    label_offset = project.display_label_pos\n\n    scale, scale_unit = project.get_scale_factor()\n\n    labels, marker_lbls = list(), list()\n    current_y_pos = 0\n    lbl_y_offset = 0\n    group_counter = 0 # \'group by\' specimen counter\n\n    ylim = 0 # used to keep track of maximum y-value, for a tight y-axis\n\n    for _, specimen in enumerate(specimens):\n\n        spec_max_display_y = float(specimen.max_display_y)\n\n        # single specimen normalization:\n        if project.axes_ynormalize == 1:\n            scale = (1.0 / spec_max_display_y) if spec_max_display_y != 0.0 else 1.0\n\n        spec_y_offset = specimen.display_vshift * scale_unit\n        spec_y_pos = current_y_pos * scale_unit + spec_y_offset\n        spec_alloc_height = base_height * scale_unit\n        spec_reqst_height = spec_alloc_height * specimen.display_vscale\n\n        lbl_y_offset = (label_offset + specimen.display_vshift) * scale_unit\n        lbl_y_pos = current_y_pos * scale_unit + lbl_y_offset\n\n        # For the y-limit we do not add the specimens vscale or vshift:\n        ylim = current_y_pos * scale_unit + spec_alloc_height\n\n        # Specimen scale = global scale, adjusted by specimen vscale\n        spec_scale = scale * specimen.display_vscale\n\n        # when statistics are plotted,\n        # 65% of the height goes to the actual specimen plots\n        # 35% goes to the statistics plot:\n        if project.layout_mode == ""FULL"" and (specimen.display_residuals or specimen.display_derivatives):\n            stats_y_pos = spec_y_pos\n            stats_height = 0.35 * spec_reqst_height\n\n            spec_y_pos = spec_y_pos + stats_height\n            spec_scale = spec_scale * 0.65\n\n            plot_statistics(\n                project, specimen, spec_scale,\n                stats_y_pos, stats_height,\n                axes\n            )\n\n        plot_specimen(\n            cc, project, specimen, labels, marker_lbls,\n            lbl_y_pos, pos_setup.left, spec_y_pos, spec_scale, scale_unit,\n            axes\n        )\n\n        # increase offsets:\n        group_counter += 1\n        if group_counter >= project.display_group_by:\n            group_counter = 0\n            current_y_pos += base_offset\n\n    axes.set_ylim(top=ylim)\n\n    return labels, marker_lbls\n\ndef plot_mixtures(axes, project, mixtures):\n    legend = getattr(project, ""__plot_mixture_legend"", None)\n    if legend:\n        try: legend.remove()\n        except ValueError: pass\n\n    figure = axes.get_figure()\n    trans = figure.transFigure\n\n    def create_rect_patch(ec=""#000000"", fc=None):\n        _box = AuxTransformBox(transforms.IdentityTransform())\n        rect = FancyBboxPatch(\n            xy=(0, 0),\n            width=0.02,\n            height=0.02,\n            boxstyle=\'square\',\n            ec=ec,\n            fc=fc,\n            mutation_scale=14, # font size\n            transform=trans,\n            alpha=1.0 if (ec is not None or fc is not None) else 0.0\n        )\n        _box.add_artist(rect)\n        return _box\n\n    legends = []\n    for mixture in mixtures:\n        legend_items = []\n\n        # Add title:\n        title = TextArea(mixture.name)\n        title_children = [create_rect_patch(ec=None) for spec in mixture.specimens]\n        title_children.insert(0, title)\n        title_box = HPacker(children=title_children, align=""center"", pad=5, sep=3)\n        legend_items.append(title_box)\n\n        # Add phase labels & boxes\n        for i, (phase, fraction) in enumerate(zip(mixture.phases, mixture.fractions)):\n            label_text = ""{}: {:>5.1f}"".format(phase, fraction * 100.0)\n            label = TextArea(label_text)\n            phase_children = [\n                create_rect_patch(fc=phase.display_color)\n                for phase in mixture.phase_matrix[:, i].flat if phase is not None\n            ]\n            phase_children.insert(0, label)\n            legend_items.append(\n                HPacker(children=phase_children, align=""center"", pad=0, sep=3)\n            )\n\n        # Add created legend to the list:\n        legends.append(\n            VPacker(children=legend_items, align=""right"", pad=0, sep=3)\n        )\n\n    # Only add this if there\'s something to add!\n    if legends:\n        # Pack legends & plot:\n        legend = AnchoredOffsetbox(\n            loc=1,\n            pad=0.1,\n            borderpad=0.1,\n            frameon=False,\n            child=VPacker(children=legends, align=""right"", pad=0, sep=5)\n        )\n\n        axes.add_artist(legend)\n        setattr(project, ""__plot_mixture_legend"", legend)\n\n\n'"
pyxrd/generic/views/__init__.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\nfrom warnings import warn\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom mvc.view import View\nfrom mvc.adapters.gtk_support.widgets import ScaleEntry\n\nfrom pyxrd.data import settings\nfrom pyxrd.generic.mathtext_support import get_string_safe\n\nclass BaseView(View):\n    """"""\n        Basic view providing some common code\n        TODO attribute docs!\n    """"""\n    builder = """"\n    modal = False\n    resizable = True\n    widget_format = ""%s""\n    container_format = ""container_%s""\n\n    # A mapping of layout states and actions to be taken when switching to them.\n    # Actions should be of the form `action::widget_group`, where the action is one\n    # of either hide or show and the widget_group is a key in the `widget_groups`\n    # mapping, with the value being the list of widgets to apply the action on to.\n    current_layout_state = ""FULL""\n    layout_state_actions = {\n        \'FULL\': [\n            \'show::full_mode_only\'\n        ],\n        \'VIEWER\': [\n            \'hide::full_mode_only\'\n        ]\n    }\n    widget_groups = { }\n\n    def __init__(self, *args, **kwargs):\n        super(BaseView, self).__init__(*args, **kwargs)\n        self.parent = kwargs.get(""parent"", None)\n        top = self.get_toplevel()\n        if isinstance(top, Gtk.Window):\n            top.set_resizable(self.resizable)\n            top.set_modal(self.modal)\n        if self.parent:\n            self.set_layout_mode(self.parent.current_layout_state)\n\n    def create_mathtext_widget(self, text, fallback_text=""""):\n        # TODO move these to a separate controller namespace module!\n        try:\n            from pyxrd.generic.mathtext_support import create_image_from_mathtext\n            widget = create_image_from_mathtext(text)\n        except:\n            if fallback_text: text = fallback_text\n            widget = Gtk.Label(label=text)\n            widget.set_use_markup(True)\n            widget.set_justify(Gtk.Justification.CENTER)\n        return widget\n\n    def _get_widget_container(self, prop):\n        return self[self.container_format % prop.label]\n\n    def _add_widget_to_container(self, widget, container):\n        if container is not None:\n            child = container.get_child()\n            if child is not None:\n                container.remove(child)\n            container.add(widget)\n        widget.show_all()\n        return widget\n\n    def add_widget(self, prop, *args, **kwargs):\n        method = {\n           str: self.add_entry_widget,\n           float: self.add_scale_widget,\n        }.get(prop.data_type, None)\n        if method is not None:\n            return method(prop, *args, **kwargs)\n\n    def add_scale_widget(self, prop, enforce_range=True):\n        # Create the widget:        \n        inp = ScaleEntry(prop.minimum, prop.maximum, enforce_range=enforce_range)\n        inp.set_tooltip_text(prop.title)\n        self[self.widget_format % prop.label] = inp\n            \n        # Add & return the widget\n        return self._add_widget_to_container(inp, self._get_widget_container(prop))\n\n    def add_entry_widget(self, prop):\n        # Create the widget:        \n        inp = Gtk.Entry()\n        inp.set_tooltip_text(prop.title)\n        self[self.widget_format % prop.label] = inp\n\n        # Add & return the widget\n        return self._add_widget_to_container(inp, self._get_widget_container(prop))\n\n    def create_input_table(self, table, props, num_columns = 1, widget_callbacks=[]):\n        """"""\n            Places widgets (returned by the widget_callbacks) in the given table\n            for each property in props. The widget groups (i.e. list of widgets \n            returned by the callbacks for a single property) can be placed in a\n            multi-column layout by increasing the num_columns value.\n        """"""\n        # total number of properties\n        num_props = len(props)\n        # number of widgets in each column\n        column_width = len(widget_callbacks)\n        # 2D array of widgets (each row is a group of widgets returned for a property)\n        widgets = [[None for _ in range(column_width)] for _ in range(num_props)]  \n        \n        # The actual number of rows needed in the table\n        num_table_rows = int(num_props / num_columns)\n        # The actual number of columns needed in the table\n        num_table_columns = num_columns*column_width\n        \n        # Resize the table widget accordingly\n        table.resize(num_table_rows,  num_table_columns)          \n\n        for i, prop in enumerate(props): # i = 0, 1, 2, 3, ...\n            # Calculate the column: column_index = 0, cw, 2*cw, 3*cw, ...\n            column_index = (i % num_columns) * column_width                \n            for widget_index in range(column_width):\n                # Create the widget:\n                widget = widget_callbacks[widget_index](prop)\n                \n                # Store it for the return value:\n                widgets[i][widget_index] = widget\n                \n                # Calculate where to place the widget:\n                column_offset = column_index + widget_index\n                row_offset = int(i / num_columns)\n                \n                # Attach it to the table               \n                table.attach(\n                    widget,\n                    column_offset, column_offset + 1,\n                    row_offset, row_offset + 1,\n                    xpadding=2, ypadding=2\n                )\n        return widgets\n\n    def set_layout_mode(self, state):\n        self.current_layout_state = state\n        for action in self.layout_state_actions.get(state, []):\n            parts = tuple(action.split(""::"", 1))\n            command, group_name = parts\n            widgets = []\n            if group_name != ""all"":\n                widget_names = self.widget_groups.get(group_name, [])\n                widgets = map(lambda name: self[name], widget_names)\n            else:\n                widgets = self._builder.get_objects()\n\n            if command == ""show"":\n                for widget in widgets:\n                    try:\n                        widget.set_no_show_all(False)\n                        widget.show_all()\n                    except AttributeError:\n                        pass\n            elif command == ""hide"":\n                for widget in widgets:\n                    try:\n                        widget.set_no_show_all(True)\n                        widget.set_visible(False)\n                    except AttributeError:\n                        pass\n            else:\n                raise ValueError(""Unknown layout state command `%s`!"" % command)\n\n    def show_all(self, *args, **kwargs):\n        self.show(*args, **kwargs)\n\n    def present(self):\n        toplevel = self.get_toplevel()\n        toplevel.set_resizable(self.resizable)\n        toplevel.set_modal(self.modal)\n        toplevel.show_all()\n        toplevel.present()\n        self.show()\n\n    def get_toplevel(self):        \n        for w in [self.top,] + list(self):\n            try:\n                return self[w].get_toplevel()\n            except AttributeError:\n                pass\n            else:\n                break # just for ref\n\nclass TitleView(BaseView):\n    """"""\n        Mix-in that provides title support for views.\n        The class attribute \'title\' can be set, if so, this class will\n        attempt to set the title attribute upon initialization unless it is \'None\'. \n    """"""\n    title = None\n\n    def __init__(self, *args, **kwargs):\n        super(TitleView, self).__init__(*args, **kwargs)\n        if self.title is not None: self.set_title(self.title)\n\n    def set_title(self, title):\n        self.title = title\n        self.get_toplevel().set_title(title)\n\n    pass # end of class\n\nclass FormattedTitleView(TitleView):\n    """"""\n        Mix-in that provides a formatted title support for views.\n        The \'title_format\' class attribute should be set to a string format\n        containing a single string (%s) specifier. When set_title is called, \n        only that part of the string is updated.\n    """"""\n    title_format = ""%s""\n    title = """"\n\n    def set_title(self, title, *args, **kwargs):\n        self.title = title\n        self.get_toplevel().set_title(self.title_format % self.title)\n\n    pass # end of class\n\nclass HasChildView(object):\n    """"""\n        Mixin that provides a function to add childviews to containers\n    """"""\n    def _add_child_view(self, new_child, container):\n        child = container.get_child()\n        if child is not None:\n            container.remove(child)\n        if isinstance(container, Gtk.ScrolledWindow) and not (type(new_child) in (Gtk.TextView, Gtk.TreeView, Gtk.IconView, Gtk.Viewport)):\n            container.add_with_viewport(new_child)\n        else:\n            container.add(new_child)\n        new_child.show_all()\n        return new_child\n\n    pass # end of class\n\nclass DialogView(HasChildView, TitleView):\n    """"""\n        Generalised view for editing stuff with an OK button\n    """"""\n    builder = resource_filename(__name__, ""glade/edit_dialog.glade"")\n    top = ""window_edit_dialog""\n    container_widget = ""edit_child_box""\n\n    # These should be overriden by the subclass:\n    subview_builder = """"\n    subview_toplevel = None\n\n    def __init__(self, container_widget=None, subview_builder=None, subview_toplevel=None, *args, **kwargs):\n        self.container_widget = container_widget or self.container_widget\n        self.subview_builder = subview_builder or self.subview_builder\n        self.subview_toplevel = subview_toplevel or self.subview_toplevel\n        super(DialogView, self).__init__(*args, **kwargs)\n        self._builder.add_from_file(self.subview_builder)\n        self._add_child_view(self[self.subview_toplevel], self[self.container_widget])\n        return\n\n\nclass ObjectListStoreViewMixin(HasChildView):\n    edit_view = None\n    edit_view_container = ""vwp_edit_object""\n\n    extra_widget_builder = None\n    extra_widget_toplevel = """"\n\n    treeview_widget = ""edit_objects_treeview""\n\n    @property\n    def treeview(self):\n        return self[self.treeview_widget]\n\n    @property\n    def load_label(self):\n        return self[""button_load_object""].get_label()\n\n    @load_label.setter\n    def load_label(self, value):\n        self[""button_load_object""].set_label(value)\n\n    @property\n    def save_label(self):\n        return self[""button_save_object""].get_label()\n\n    @save_label.setter\n    def save_label(self, value):\n        self[""button_save_object""].set_label(value)\n\n    @property\n    def extra_widget(self):\n        return self.extra_widget_box.get_child()\n\n    @extra_widget.setter\n    def extra_widget(self, widget):\n        child = self.extra_widget_box.get_child()\n        if child:\n            self.extra_widget_box.remove(child)\n        if widget is not None:\n            self[""extra_box""].add(widget)\n\n    _none_view = None\n    @property\n    def none_view(self):\n        return NoneView()\n\n    def set_selection_state(self, value):\n        """"""\n            Sets the state of the view to correspond with the number of currently\n            selected objects. Value is either None or a number indicating the number of selected objects.\n        """"""\n        self[""button_del_object""].set_sensitive(value is not None)\n        self[""button_save_object""].set_sensitive(value is not None)\n\n    def __init__(self, edit_view_container=None, display_buttons=True, load_label=None, save_label=None, **kwargs):\n        self.edit_view_container = edit_view_container or self.edit_view_container\n        self.load_label = load_label or self.load_label\n        self.save_label = save_label or self.save_label\n\n        if not display_buttons:\n            self[""vbox_objects""].remove(self[""table_data""])\n\n        self.extra_widget_box = self[""extra_box""]\n        if self.extra_widget_builder is not None:\n            self._builder.add_from_file(self.extra_widget_builder)\n            self.extra_widget = self._builder.get_object(self.extra_widget_toplevel)\n        return\n\n    _on_sr_id = None\n    def on_size_requested(self, *args):\n        sr = self.child_view.size_request()\n        self[self.edit_view_container].set_size_request(sr.height + 20, -1)\n\n    def set_edit_view(self, view):\n        if self._on_sr_id is not None and self.child_view is not None:\n            self.child_view.disconnect(self._on_sr_id)\n        self.edit_view = view\n        self.child_view = view.get_top_widget()\n        self._add_child_view(self.child_view, self[self.edit_view_container])\n        if isinstance(self[self.edit_view_container], Gtk.ScrolledWindow):\n            sr = self.child_view.get_size_request()\n            self[self.edit_view_container].set_size_request(sr[0], -1)\n            self[self.edit_view_container].set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n            self._on_sr_id = self.child_view.connect(""size-allocate"", self.on_size_requested)\n\n\n        return self.edit_view\n\nclass ObjectListStoreView(ObjectListStoreViewMixin, DialogView):\n    """"""\n        Generalised view for editing objects inside an ObjectListStore (using a customisable child view)\n         - Standalone version (inside a DialogView)\n    """"""\n    subview_builder = resource_filename(__name__, ""glade/object_store.glade"")\n    subview_toplevel = ""edit_object_store""\n\n    def __init__(self, edit_view_container=None, display_buttons=True, load_label=None, save_label=None, **kwargs):\n        DialogView.__init__(self, **kwargs)\n        ObjectListStoreViewMixin.__init__(self, edit_view_container=edit_view_container, display_buttons=display_buttons, load_label=load_label, save_label=save_label, **kwargs)\n\nclass ChildObjectListStoreView(ObjectListStoreViewMixin, BaseView):\n    """"""\n        Generalised view for editing objects inside an ObjectListStore (using a customisable child view)\n         - Child version (to be embedded by a controller)\n    """"""\n    edit_view_container = ""frame_object_param""\n\n    builder = resource_filename(__name__, ""glade/object_store.glade"")\n    top = ""edit_object_store""\n\n    def __init__(self, edit_view_container=None, display_buttons=True, load_label=None, save_label=None, **kwargs):\n        BaseView.__init__(self, **kwargs)\n        ObjectListStoreViewMixin.__init__(self, edit_view_container=edit_view_container, display_buttons=display_buttons, load_label=load_label, save_label=save_label, **kwargs)\n\n        self[""frm_objects_tv""].set_size_request(150, 150)\n\nclass InlineObjectListStoreView(BaseView):\n    builder = resource_filename(__name__, ""glade/inline_ols.glade"")\n    top = ""edit_item""\n\n    @property\n    def treeview(self):\n        return self[\'tvw_items\']\n\n    @property\n    def del_item_widget(self):\n        return self[\'btn_del_item\']\n\n    @property\n    def add_item_widget(self):\n        return self[\'btn_add_item\']\n\n    @property\n    def export_items_widget(self):\n        return self[\'btn_export_item\']\n\n    @property\n    def import_items_widget(self):\n        return self[\'btn_import_item\']\n\n    @property\n    def type_combobox_widget(self):\n        return self[\'cmb_add_type\']\n\nclass NoneView(BaseView):\n    builder = resource_filename(__name__, ""glade/none.glade"")\n    top = ""lbl_caption""\n    caption_widget = ""lbl_caption""\n\n    def __init__(self, label=None, **kwargs):\n        BaseView.__init__(self, **kwargs)\n        self._label = self[self.caption_widget]\n        if label is not None: self.label = label\n\n    _label = None\n    @property\n    def label(self):\n        return self._label.get_label()\n\n    @label.setter\n    def label(self, value):\n        self._label.set_label(value)\n'"
pyxrd/generic/views/cell_renderer_tools.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nrenderer_map = {\n    \'text\': Gtk.CellRendererText,\n    \'accel\': Gtk.CellRendererAccel,\n    \'combo\': Gtk.CellRendererCombo,\n    \'spin\': Gtk.CellRendererSpin,\n    \'pixbuf\': Gtk.CellRendererPixbuf,\n    \'progress\': Gtk.CellRendererProgress,\n    \'spinner\': Gtk.CellRendererSpinner,\n    \'toggle\': Gtk.CellRendererToggle,\n}\n\ndef get_default_renderer(type, **kwargs):\n    """"""\n        Creates a CellRendere of type \'type\' and sets any attributes passed with\n        the key-word arguments. Underscores in variable names are replaced with\n        dashes in the proces.\n    """"""\n    rend = renderer_map.get(type, type)()\n    for key, val in kwargs.items():\n        rend.set_property(key.replace(""_"", ""-""), val)\n    return rend\n    \ndef parse_callback(callback, reduce=True):\n    """"""\n        Parses callbacks for CellRenderers: it splits the \n        callback from its arguments if present. Additionally this method will \n        not create singleton argument lists, but pass them as a single argument.\n        \n        Returns the callback and its argument(s) (or an empty tuple)\n    """"""\n    args = tuple()\n    try:\n        callback, args = callback\n    except TypeError as ValueError:\n        pass\n    #deconvolve things:\n    if reduce and len(args) == 1: args = args[0]\n    return callback, args\n    \ndef parse_kwargs(**kwargs):\n    """"""\n        Parses key-word arguments.\n        It checks for the presence of key-words ending with \'_col\', these are\n        popped and stored in a seperate dictionary, as they are to be passed\n        to the constructor of the actual column or combobox (attribute mappings)\n        In addition it sets a number of default attributes for the CellRenderer.\n        \n        Returns a tuple containing a dict with the CellRenderer attributes and a\n        dict with the TreeViewColumn attribute mappings\n    """"""\n    kwargs[""xalign""] = kwargs.get(""xalign"", 0.5)\n    kwargs[""yalign""] = kwargs.get(""yalign"", 0.5)\n    \n    col_attrs = dict()\n    for key, value in dict(kwargs).items():\n        if key.endswith(""_col""):\n            col_attrs[key[:-4]] = value\n            kwargs.pop(key)\n    return kwargs, col_attrs\n'"
pyxrd/generic/views/combobox_tools.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .cell_renderer_tools import get_default_renderer, parse_callback, parse_kwargs\n\ndef add_renderer_with_attrs(combo, col_attrs, rend):\n    combo.pack_start(rend, True)\n    for attr, val in col_attrs.items():\n        combo.add_attribute(rend, attr, val)\n\ndef add_combo_text_column(combo,\n        data_func=None,\n        **kwargs):\n    kwargs[""xalign""] = kwargs.get(""xalign"", 0.0)\n    kwargs, col_attrs = parse_kwargs(**kwargs)\n    rend = get_default_renderer(\'text\', **kwargs)\n    add_renderer_with_attrs(combo, col_attrs, rend)\n    if data_func!=None:\n        callback, args = parse_callback(data_func)\n        combo.set_cell_data_func(rend, callback, args)\n    return rend\n'"
pyxrd/generic/views/line_views.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom pyxrd.generic.views import DialogView, BaseView\n\nclass CalculatedLinePropertiesView(BaseView):\n    builder = resource_filename(__name__, ""glade/lines/calculated_props.glade"")\n    top = ""cal_line_props""\n    widget_format = ""cal_%s""\n\n    widget_groups = {\n        \'full_mode_only\': [\n            ""cal_line_props""\n        ]\n    }\n\n    pass # end of class\n\nclass ExperimentalLinePropertiesView(BaseView):\n    builder = resource_filename(__name__, ""glade/lines/experimental_props.glade"")\n    top = ""exp_line_props""\n    widget_format = ""exp_%s""\n\n    pass # end of class\n\nclass BackgroundView(DialogView):\n    title = ""Remove Background""\n    subview_builder = resource_filename(__name__, ""glade/lines/background.glade"")\n    subview_toplevel = ""edit_background""\n    modal = True\n    resizable = False\n\n    def_bg_view = ""bg_linear""\n    bg_view_cont = ""bg_view_container""\n\n    def select_bg_view(self, bg_view=None):\n        if bg_view is not None:\n            bg_view = ""bg_%s"" % bg_view\n        else:\n            bg_view = self.def_bg_view\n        self._add_child_view(self[bg_view], self[self.bg_view_cont])\n\n    def set_file_dialog(self, dialog, callback):\n        fcb_bg_pattern = Gtk.FileChooserButton(dialog)\n        fcb_bg_pattern.connect(""file-set"", callback, dialog)\n        self[""fcb_bg_container""].add(fcb_bg_pattern)\n\n    pass #end of class\n\nclass AddNoiseView(DialogView):\n    title = ""Add Noise""\n    subview_builder = resource_filename(__name__, ""glade/lines/add_noise.glade"")\n    subview_toplevel = ""add_noise""\n    modal = True\n    resizable = False\n\n    pass # end of class\n\nclass SmoothDataView(DialogView):\n    title = ""Smooth Data""\n    subview_builder = resource_filename(__name__, ""glade/lines/smoothing.glade"")\n    subview_toplevel = ""smooth_data""\n    modal = True\n    resizable = False\n\n    pass # end of class\n\nclass ShiftDataView(DialogView):\n    title = ""Shift Pattern""\n    subview_builder = resource_filename(__name__, ""glade/lines/shifting.glade"")\n    subview_toplevel = ""shift_pattern""\n    modal = True\n    resizable = False\n\n    pass # end of class\n\nclass StripPeakView(DialogView):\n    title = ""Strip Peak""\n    subview_builder = resource_filename(__name__, ""glade/lines/strip_peak.glade"")\n    subview_toplevel = ""strip_peak""\n    modal = True\n    resizable = False\n\n    pass # end of class\n\nclass CalculatePeakPropertiesView(DialogView):\n    title = ""Calculate Peak Properties""\n    subview_builder = resource_filename(__name__, ""glade/lines/peak_properties.glade"")\n    subview_toplevel = ""peak_properties""\n    modal = True\n    resizable = False\n\n    pass # end of class\n'"
pyxrd/generic/views/treeview_tools.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nsel_modes = {\n    \'NONE\': Gtk.SelectionMode.NONE,\n    \'SINGLE\': Gtk.SelectionMode.SINGLE,\n    \'BROWSE\': Gtk.SelectionMode.BROWSE,\n    \'MULTIPLE\': Gtk.SelectionMode.MULTIPLE\n}\n\nsort_types = {\n    \'ASCENDING\': Gtk.SortType.ASCENDING,\n    \'DESCENDING\': Gtk.SortType.DESCENDING\n}\n\nfrom .cell_renderer_tools import get_default_renderer, parse_callback, parse_kwargs\n\nclass PyXRDTreeViewColumn(Gtk.TreeViewColumn):\n    """"""\n        A custom TreeViewColumn that stores information about its attribute \n        mappings and provides acces to them with the get_col_attr function.\n    """"""\n\n    def __init__(self, title=None, cell_renderer=None, **kwargs):\n        Gtk.TreeViewColumn.__init__(self, title, cell_renderer)\n        self._attrs = dict()\n        self.set_attributes(cell_renderer, **kwargs)\n\n    def set_attributes(self, cell_renderer, **kwargs):\n        for key, val in kwargs.items():\n            self._attrs[key] = val\n        Gtk.TreeViewColumn.set_attributes(self, cell_renderer, **kwargs)\n\n    def add_attribute(self, cell_renderer, attribute, column):\n        self._attrs[attribute] = column\n        Gtk.TreeViewColumn.set_attributes(self, cell_renderer, attribute, column)\n\n    def clear_attributes(self, cell_renderer):\n        self._attrs = dict()\n        Gtk.TreeViewColumn.clear_attributes(self, cell_renderer)\n\n    def get_col_attr(self, attr):\n        return self._attrs.get(attr, -1)\n\ndef _get_default_column(title, rend,\n        data_func=None,\n        spacing=0,\n        visible=True,\n        resizable=True,\n        sizing=1,\n        fixed_width=-1,\n        min_width=-1,\n        max_width=-1,\n        expand=True,\n        clickable=False,\n        alignment=0.0,\n        reorderable=False,\n        sort_column_id=-1,\n        sort_indicator=False,\n        sort_order=\'ASCENDING\',\n        col_attrs={}):\n    """"""\n        Creates a PyXRDTreeViewColumn using the arguments passed. Column \n        attribute mappings are to be passed as a single dict,\n        not as key-word arguments.\n    """"""\n    try:\n        sort_order = sort_types[sort_order]\n    except KeyError as err:\n        raise ValueError(""Invalid value \'%s\' for sort order!"" % sort_order) from err \n    col = PyXRDTreeViewColumn(title, rend, **col_attrs)\n    if data_func is not None:\n        callback, args = parse_callback(data_func)\n        col.set_cell_data_func(rend, callback, args)\n    col.set_spacing(spacing)\n    col.set_visible(visible)\n    col.set_resizable(resizable)\n    col.set_sizing(sizing)\n    if fixed_width >= 0:\n        col.set_sizing(Gtk.TreeViewColumnSizing.Fixed)\n        col.set_fixed_width(fixed_width)\n    else:\n        col.set_sizing(Gtk.TreeViewColumnSizing.GROW_ONLY)\n    col.set_min_width(min_width)\n    col.set_max_width(max_width)\n    col.set_title(title)\n    col.set_expand(expand)\n    col.set_clickable(clickable)\n    col.set_alignment(alignment)\n    col.set_reorderable(reorderable)\n    col.set_sort_column_id(sort_column_id)\n    col.set_sort_indicator(sort_indicator)\n    col.set_sort_order(sort_order)\n    col.set_resizable(resizable)\n    col.set_expand(expand)\n    col.set_alignment(alignment)\n    return col\n\ndef new_text_column(title,\n        edited_callback=None,\n        data_func=None,\n        spacing=0,\n        visible=True,\n        resizable=True,\n        sizing=1,\n        fixed_width=-1,\n        min_width=-1,\n        max_width=-1,\n        expand=True,\n        clickable=False,\n        alignment=None,\n        reorderable=False,\n        sort_column_id=-1,\n        sort_indicator=False,\n        sort_order=\'ASCENDING\',\n        **kwargs):\n    """"""\n        Creates a TreeViewColumn packed with a CellRendererText .\n    """"""\n    kwargs, col_attrs = parse_kwargs(**kwargs)\n    alignment = alignment if alignment is not None else kwargs[""xalign""]\n\n    rend = get_default_renderer(Gtk.CellRendererText, **kwargs)\n    if edited_callback is not None:\n        callback, args = parse_callback(edited_callback, reduce=False)\n        rend.connect(\'edited\', callback, *args)\n\n    col = _get_default_column(\n        title, rend,\n        data_func=data_func,\n        spacing=spacing,\n        visible=visible,\n        resizable=resizable,\n        sizing=sizing,\n        fixed_width=fixed_width,\n        min_width=min_width,\n        max_width=max_width,\n        expand=expand,\n        clickable=clickable,\n        alignment=alignment,\n        reorderable=reorderable,\n        sort_column_id=sort_column_id,\n        sort_indicator=sort_indicator,\n        sort_order=sort_order,\n        col_attrs=col_attrs)\n    return col\n\ndef new_pb_column(title,\n        data_func=None,\n        spacing=0,\n        visible=True,\n        resizable=True,\n        sizing=1,\n        fixed_width=-1,\n        min_width=-1,\n        max_width=-1,\n        expand=True,\n        clickable=False,\n        alignment=None,\n        reorderable=False,\n        sort_column_id=-1,\n        sort_indicator=False,\n        sort_order=\'ASCENDING\',\n        **kwargs):\n    """"""\n        Creates a TreeViewColumn packed with a CellRendererPixbuf.\n    """"""\n    kwargs, col_attrs = parse_kwargs(**kwargs)\n    alignment = alignment if alignment is not None else kwargs[""xalign""]\n\n    rend = get_default_renderer(Gtk.CellRendererPixbuf, **kwargs)\n\n    col = _get_default_column(\n        title, rend,\n        data_func=data_func,\n        spacing=spacing,\n        visible=visible,\n        resizable=resizable,\n        sizing=sizing,\n        fixed_width=fixed_width,\n        min_width=min_width,\n        max_width=max_width,\n        expand=expand,\n        clickable=clickable,\n        alignment=alignment,\n        reorderable=reorderable,\n        sort_column_id=sort_column_id,\n        sort_indicator=sort_indicator,\n        sort_order=sort_order,\n        col_attrs=col_attrs)\n    return col\n\ndef new_toggle_column(title,\n        data_func=None,\n        toggled_callback=None,\n        spacing=0,\n        visible=True,\n        resizable=True,\n        sizing=1,\n        fixed_width=-1,\n        min_width=-1,\n        max_width=-1,\n        expand=True,\n        clickable=False,\n        alignment=None,\n        reorderable=False,\n        sort_column_id=-1,\n        sort_indicator=False,\n        sort_order=\'ASCENDING\',\n        **kwargs):\n    """"""\n        Creates a TreeViewColumn packed with a CellRendererToggle.\n    """"""\n    kwargs, col_attrs = parse_kwargs(**kwargs)\n    alignment = alignment if alignment is not None else kwargs[""xalign""]\n\n    rend = get_default_renderer(Gtk.CellRendererToggle, **kwargs)\n    if toggled_callback is not None:\n        callback, args = parse_callback(toggled_callback, reduce=False)\n        rend.connect(\'toggled\', callback, *args)\n\n    col = _get_default_column(\n        title, rend,\n        data_func=data_func,\n        spacing=spacing,\n        visible=visible,\n        resizable=resizable,\n        sizing=sizing,\n        fixed_width=fixed_width,\n        min_width=min_width,\n        max_width=max_width,\n        expand=expand,\n        clickable=clickable,\n        alignment=alignment,\n        reorderable=reorderable,\n        sort_column_id=sort_column_id,\n        sort_indicator=sort_indicator,\n        sort_order=sort_order,\n        col_attrs=col_attrs)\n    return col\n\ndef new_combo_column(title,\n        data_func=None,\n        changed_callback=None,\n        edited_callback=None,\n        editing_started_callback=None,\n        editing_canceled_callback=None,\n        spacing=0,\n        visible=True,\n        resizable=True,\n        sizing=1,\n        fixed_width=-1,\n        min_width=-1,\n        max_width=-1,\n        expand=True,\n        clickable=False,\n        alignment=None,\n        reorderable=False,\n        sort_column_id=-1,\n        sort_indicator=False,\n        sort_order=\'ASCENDING\',\n        **kwargs):\n    """"""\n        Creates a TreeViewColumn packed with a CellRendererCombo.\n    """"""\n    kwargs, col_attrs = parse_kwargs(**kwargs)\n    alignment = alignment if alignment is not None else kwargs[""xalign""]\n\n    rend = get_default_renderer(Gtk.CellRendererCombo, **kwargs)\n    if changed_callback is not None:\n        callback, args = parse_callback(changed_callback, reduce=False)\n        rend.connect(\'changed\', callback, *args)\n    if edited_callback is not None:\n        callback, args = parse_callback(edited_callback, reduce=False)\n        rend.connect(\'edited\', callback, *args)\n    if editing_started_callback is not None:\n        callback, args = parse_callback(editing_started_callback, reduce=False)\n        rend.connect(\'editing-started\', callback, *args)\n    if editing_canceled_callback is not None:\n        callback, args = parse_callback(editing_canceled_callback, reduce=False)\n        rend.connect(\'editing-canceled\', callback, *args)\n\n    col = _get_default_column(\n        title, rend,\n        data_func=data_func,\n        spacing=spacing,\n        visible=visible,\n        resizable=resizable,\n        sizing=sizing,\n        fixed_width=fixed_width,\n        min_width=min_width,\n        max_width=max_width,\n        expand=expand,\n        clickable=clickable,\n        alignment=alignment,\n        reorderable=reorderable,\n        sort_column_id=sort_column_id,\n        sort_indicator=sort_indicator,\n        sort_order=sort_order,\n        col_attrs=col_attrs)\n\n    return col\n\ndef create_float_data_func(attribute=\'text\', fmt=""%.5f"", invalid=""#NA#""):\n    """"""\n        Creates a data function that can be used to render floats as formatted\n        strings, with detection of invalid values (e.g. None)\n    """"""\n    def float_renderer(column, cell, model, itr, args=None):\n        nr = model.get_value(itr, column.get_col_attr(attribute))\n        try:\n            cell.set_property(\'text\', fmt % nr)\n        except:\n            cell.set_property(\'text\', invalid)\n    return float_renderer\n\ndef reset_columns(tv):\n    """"""\n        Remove all columns from the treeview\n    """"""\n    for col in tv.get_columns():\n        tv.remove_column(col)\n\ndef setup_treeview(tv, model,\n        reset=False,\n        on_cursor_changed=None,\n        on_selection_changed=None,\n        sel_mode=\'SINGLE\'):\n    """"""\n        Sets up a treeview (signal connection, sets selection mode).\n    """"""\n    try:\n        sel_mode = sel_modes[sel_mode]\n    except KeyError as err:\n        raise ValueError(""Invalid value \'%s\' for selection mode!"" % sel_mode) from err\n    if reset: reset_columns(tv)\n    sel = tv.get_selection()\n    sel.set_mode(sel_mode)\n    ids = ()\n    if on_cursor_changed is not None:\n        ids += (tv.connect(\'cursor_changed\', on_cursor_changed),)\n    if on_selection_changed is not None:\n        ids += (sel.connect(\'changed\', on_selection_changed),)\n    return ids\n\n'"
pyxrd/generic/views/validators.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.support.gui_loop import add_idle_call\n\nclass FloatEntryValidator:\n    def __init__(self, entry):\n        self.last_valid_val = 0\n        self.has_valid_val = True\n    \n        self.entry = entry\n        self.entry.connect(""activate"", self.entry_activate)\n        self.entry.connect(""focus_out_event"", self.entry_focus_out)\n        self.insert_handlerid = self.entry.connect(""insert-text"", self.entry_insert_text)\n        self.delete_handlerid = self.entry.connect(""delete-text"", self.entry_delete_text)\n\n    def validate(self, text=None, reset_if_invalid=False):\n        text = text or self.entry.get_chars(0, -1)\n        try:\n            self.last_valid_val = float(text)\n            self.has_valid_val = True\n        except Exception as e:\n            self.has_valid_val = False\n        if reset_if_invalid and not self.has_valid_val:\n            self.entry.handler_block(self.insert_handlerid)\n            self.entry.set_text(""%f"" % self.last_valid_val)\n            self.has_valid_val = True\n            self.entry.handler_unblock(self.insert_handlerid)\n\n    def entry_activate(self, entry):\n        self.validate(reset_if_invalid=True)\n\n    def entry_focus_out(self, entry, event):\n        self.validate(reset_if_invalid=True)\n        return False\n\n    def entry_insert_text(self, entry, new_text, new_text_length, position):\n        self.entry.stop_emission(\'insert-text\')\n        self.entry.handler_block(self.insert_handlerid)\n        pos = self.entry.get_position()\n        \n        text = self.entry.get_chars(0, -1)\n        old_text = text\n        \n        text = text[:pos] + new_text + text[pos:]\n        \n        self.validate(text)\n        if self.has_valid_val:\n            new_text = text\n            self.entry.set_text(new_text)\n            add_idle_call(lambda: self.entry.set_position(pos + (len(new_text) - len(old_text))))\n        #while Gtk.events_pending():\n        #    Gtk.main_iteration(False)\n        self.entry.handler_unblock(self.insert_handlerid)        \n        \n    def entry_delete_text(self, entry, start, end):\n        self.validate()\n'"
pyxrd/mixture/controllers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .edit_mixture_controller import EditMixtureController\nfrom .mixtures_controller import MixturesController\n\n#from .edit_insitu_mixture_controller import EditInSituMixtureController\n#from .insitu_behaviours_controller import InSituBehavioursController\n\n#from .edit_insitu_behaviour_controller import EditInSituBehaviourController\n\n\n__all__ = [\n    #""EditInSituMixtureController"",\n    ""EditMixtureController"",\n    ""MixturesController"",\n    \n    #""EditInSituBehaviourController""\n    #""InSituBehavioursController"",\n]'"
pyxrd/mixture/controllers/add_insitu_behaviour_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, Gdk as gdk\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom pyxrd.generic.views.combobox_tools import add_combo_text_column\n\nfrom pyxrd.generic.controllers import DialogController\n\nclass AddInSituBehaviourController(DialogController):\n    """""" \n        Controller for the add InSituBehaviour dialog\n    """"""\n\n    auto_adapt = False\n\n    def __init__(self, model=None, view=None, parent=None, callback=None):\n        super(AddInSituBehaviourController, self).__init__(\n            model=model, view=view, parent=parent)\n        self.callback = callback\n\n    def generate_combo(self):\n        cmb_model = Gtk.ListStore(str, object)\n        print(""Adding rows from:"", self.parent.obj_type_map)\n        for cls, _, _ in self.parent.obj_type_map:\n            print(""Adding row:"", cls)\n            cmb_model.append([cls.Meta.store_id, cls])\n        self.view.behaviour_combo_box.set_model(cmb_model)\n        add_combo_text_column(\n            self.view.behaviour_combo_box, text_col=0)\n\n    def register_view(self, view):\n        self.generate_combo()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        self.view.hide()\n        self.callback(self.view.get_behaviour_type())\n        return True\n\n    def on_keypress(self, widget, event):\n        if event.keyval == Gdk.KEY_Escape:\n            self.view.hide()\n            return True\n        if event.keyval == Gdk.KEY_Return:\n            return self.on_btn_ok_clicked(event)\n\n    def on_window_edit_dialog_delete_event(self, event, args=None):\n        self.view.hide()\n        return True # do not propagate\n\n    pass # end of class'"
pyxrd/mixture/controllers/add_mixture_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, Gdk\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom pyxrd.generic.controllers import DialogController\n\nclass AddMixtureController(DialogController):\n    """""" \n        Controller for the add mixture dialog\n    """"""\n\n    auto_adapt = False\n\n    def __init__(self, model=None, view=None, parent=None, callback=None):\n        super(AddMixtureController, self).__init__(\n            model=model, view=view, parent=parent)\n        self.callback = callback\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        self.view.hide()\n        self.callback(self.view.get_mixture_type())\n        return True\n\n    def on_keypress(self, widget, event):\n        if event.keyval == Gdk.keyval_from_name(""Escape""):\n            self.view.hide()\n            return True\n        if event.keyval == Gdk.keyval_from_name(""Return""):\n            return self.on_btn_ok_clicked(event)\n\n    def on_window_edit_dialog_delete_event(self, event, args=None):\n        self.view.hide()\n        return True # do not propagate\n\n    pass # end of class'"
pyxrd/mixture/controllers/edit_insitu_behaviour_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.controllers import BaseController\n\nclass EditInSituBehaviourController(BaseController):\n    """"""\n        The controller for the Behaviour model\n    """"""\n\n    pass # end of class'"
pyxrd/mixture/controllers/edit_insitu_mixture_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc import Controller\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.controllers.objectliststore_controllers import wrap_list_property_to_treemodel\n\nfrom pyxrd.refinement.views.refinement_view import RefinementView\nfrom pyxrd.refinement.controllers.refinement_controller import RefinementController\n\nclass EditInSituMixtureController(BaseController):\n    """"""\n        The controller for the edit InSituMixture view\n    """"""\n\n    auto_adapt_excluded = [\n        ""refine_method_index"",\n        ""refinables"",\n        ""make_psp_plots""\n    ]\n\n    ref_view = None\n\n    @property\n    def specimens_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(self.model.project, type(self.model.project).specimens)\n        else:\n            return None\n\n    @property\n    def phases_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(self.model.project, type(self.model.project).phases)\n        else:\n            return None\n\n    @property\n    def behavs_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(self.model.project, type(self.model.project).behaviours)\n        else:\n            return None\n\n    def register_adapters(self):\n        self.create_ui()\n\n    def create_ui(self):\n        """"""\n            Creates a complete new UI for the Mixture model\n        """"""\n        self.view.reset_view()\n        for index in range(len(self.model.phases)):\n            self._add_phase_view(index)\n        for index in range(len(self.model.specimens)):\n            self._add_specimen_view(index)\n\n    def _is_behav_visible(self, model, itr, indcs):\n        behav = self.behavs_treemodel.get_user_data(itr) if itr is not None else None\n        if behav is not None:\n            phase = self.model.phase_matrix[indcs[0], indcs[1]]\n            return behav.is_compatible_with(phase)\n        else:\n            return False\n\n    def _add_phase_view(self, phase_slot):\n        """"""\n            Adds a new view for the given phase slot.\n        """"""\n        def on_label_changed(editable):\n            self.model.phases[phase_slot] = editable.get_text()\n\n        def on_fraction_changed(editable):\n            try: self.model.fractions[phase_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_phase_delete(widget):\n            self.model.del_phase_slot(phase_slot)\n            widget.disconnect(getattr(widget, ""deleventid""))\n\n        self.view.add_phase_slot(\n            self.phases_treemodel, self.behavs_treemodel, \n            on_phase_delete, on_label_changed, on_fraction_changed,\n            None, self.on_phase_combo_changed, \n            self._is_behav_visible, self.on_behav_combo_changed, \n            label=self.model.phases[phase_slot], fraction=self.model.fractions[phase_slot], \n            phases=self.model.phase_matrix, behavs=self.model.behaviour_matrix)        \n\n    def _add_specimen_view(self, specimen_slot):\n        """"""\n            Adds a new view for the given specimen slot\n        """"""\n        def on_scale_changed(editable):\n            try: self.model.scales[specimen_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_bgs_changed(editable):\n            try: self.model.bgshifts[specimen_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_specimen_changed(combobox):\n            itr = combobox.get_active_iter()\n            specimen = self.specimens_treemodel.get_user_data(itr) if itr is not None else None\n            self.model.set_specimen(specimen_slot, specimen)\n\n        def on_specimen_delete(widget):\n            self.model.del_specimen_slot(specimen_slot)\n            widget.disconnect(getattr(widget, ""deleventid""))\n\n        self.view.add_specimen_slot(\n            self.phases_treemodel, self.behavs_treemodel, self.specimens_treemodel, \n            on_specimen_delete, on_scale_changed, on_bgs_changed, on_specimen_changed, \n            None, self.on_phase_combo_changed, \n            self._is_behav_visible, self.on_behav_combo_changed,\n            scale=self.model.scales[specimen_slot], bgs=self.model.bgshifts[specimen_slot],\n            specimen=self.model.specimens[specimen_slot], \n            phases=self.model.phase_matrix, behavs=self.model.behaviour_matrix)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""data_changed"", signal=True)\n    def notif_has_changed(self, model, prop_name, info):\n        self.view.update_all(self.model.fractions, self.model.scales, self.model.bgshifts)\n\n    @Controller.observe(""needs_reset"", signal=True)\n    def notif_needs_reset(self, model, prop_name, info):\n        self.create_ui()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_phase_combo_changed(self, combobox, row, col):\n        itr = combobox.get_active_iter()\n        phase = self.phases_treemodel.get_user_data(itr) if itr is not None else None\n        self.model.set_phase(row, col, phase)\n        \n    def on_behav_combo_changed(self, combobox, row, col):\n        itr = combobox.get_active_iter()\n        behav = self.behavs_treemodel.get_user_data(itr) if itr is not None else None\n        self.model.set_behaviour(row, col, behav)\n\n    def on_add_phase(self, widget, *args):\n        with self.model.data_changed.hold():\n            index = self.model.add_phase_slot(""New Phase"", 1.0)\n            self._add_phase_view(index)\n\n    def on_add_specimen(self, widget, *args):\n        with self.model.data_changed.hold():\n            index = self.model.add_specimen_slot(None, 1.0, 0.0)\n            self._add_specimen_view(index)\n\n    def on_add_both(self, widget, *args):\n        with self.model.data_changed.hold():\n            self.on_add_specimen(widget, *args)\n            self.on_add_phase(widget, *args)\n\n    def on_optimize_clicked(self, widget, *args):\n        self.model.optimize()\n\n    def on_refine_clicked(self, widget, *args):\n        self.model.refinement.update_refinement_treestore()\n        if self.ref_view is not None:\n            self.ref_view.hide()\n            self.ref_ctrl.cleanup()\n        self.view.parent.hide()\n        self.ref_view = RefinementView(parent=self.parent.view)\n        self.ref_ctrl = RefinementController(model=self.model.refinement, view=self.ref_view, parent=self)\n        self.ref_view.present()\n\n    def on_composition_clicked(self, widget, *args):\n        comp = ""The composition of the specimens in this mixture:\\n\\n\\n""\n        comp += ""<span font-family=\\""monospace\\"">""\n        # get the composition matrix (first columns contains strings with elements, others are specimen compositions)\n        import re\n        for row in self.model.get_composition_matrix():\n            comp += ""%s %s\\n"" % (re.sub(r\'(\\d+)\', r\'<sub>\\1</sub>\', row[0]), "" "".join(row[1:]))\n        comp += ""</span>""\n        DialogFactory.get_information_dialog(\n            comp, parent=self.view.get_toplevel()\n        ).run()\n\n    pass # end of class\n'"
pyxrd/mixture/controllers/edit_mixture_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc import Controller\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.controllers.objectliststore_controllers import wrap_list_property_to_treemodel\n\nfrom pyxrd.refinement.views.refinement_view import RefinementView\nfrom pyxrd.refinement.controllers.refinement_controller import RefinementController\n\nclass EditMixtureController(BaseController):\n\n    auto_adapt_excluded = [\n        ""refine_method_index"",\n        ""refinables"",\n        ""make_psp_plots""\n    ]\n\n    ref_view = None\n\n    @property\n    def specimens_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(self.model.project, type(self.model.project).specimens)\n        else:\n            return None\n\n    @property\n    def phases_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(self.model.project, type(self.model.project).phases)\n        else:\n            return None\n\n    def register_adapters(self):\n        self.create_ui()\n\n    def create_ui(self):\n        """"""\n            Creates a complete new UI for the Mixture model\n        """"""\n        self.view.reset_view()\n        for index in range(len(self.model.phases)):\n            self._add_phase_view(index)\n        for index in range(len(self.model.specimens)):\n            self._add_specimen_view(index)\n\n    def _add_phase_view(self, phase_slot):\n        """"""\n            Adds a new view for the given phase slot.\n        """"""\n        def on_label_changed(editable):\n            self.model.phases[phase_slot] = editable.get_text()\n\n        def on_check_toggled(check):\n            self.model.fractions_mask[phase_slot] = 1 if check.get_active() else 0\n\n        def on_fraction_changed(editable):\n            try: self.model.fractions[phase_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_phase_delete(widget):\n            self.model.del_phase_slot(phase_slot)\n            widget.disconnect(getattr(widget, ""deleventid""))\n\n        self.view.add_phase_slot(self.phases_treemodel,\n            on_phase_delete, on_label_changed, on_check_toggled, on_fraction_changed,\n            self.on_combo_changed, label=self.model.phases[phase_slot],\n            fraction=self.model.fractions[phase_slot], phases=self.model.phase_matrix)\n\n    def _add_specimen_view(self, specimen_slot):\n        """"""\n            Adds a new view for the given specimen slot\n        """"""\n        def on_scale_changed(editable):\n            try: self.model.scales[specimen_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_bgs_changed(editable):\n            try: self.model.bgshifts[specimen_slot] = float(editable.get_text())\n            except ValueError: return # ignore ValueErrors\n\n        def on_specimen_changed(combobox):\n            itr = combobox.get_active_iter()\n            specimen = self.specimens_treemodel.get_user_data(itr) if itr is not None else None\n            self.model.set_specimen(specimen_slot, specimen)\n\n        def on_specimen_delete(widget):\n            self.model.del_specimen_slot(specimen_slot)\n            widget.disconnect(getattr(widget, ""deleventid""))\n\n        self.view.add_specimen_slot(self.phases_treemodel,\n            self.specimens_treemodel, on_specimen_delete, on_scale_changed,\n            on_bgs_changed, on_specimen_changed, self.on_combo_changed,\n            scale=self.model.scales[specimen_slot], bgs=self.model.bgshifts[specimen_slot],\n            specimen=self.model.specimens[specimen_slot], phases=self.model.phase_matrix)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""data_changed"", signal=True)\n    def notif_has_changed(self, model, prop_name, info):\n        self.view.update_all(self.model.fractions, self.model.scales, self.model.bgshifts)\n\n    @Controller.observe(""needs_reset"", signal=True)\n    def notif_needs_reset(self, model, prop_name, info):\n        self.create_ui()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_combo_changed(self, combobox, row, col):\n        itr = combobox.get_active_iter()\n        phase = self.phases_treemodel.get_user_data(itr) if itr is not None else None\n        self.model.set_phase(row, col, phase)\n\n    def on_add_phase(self, widget, *args):\n        with self.model.data_changed.hold():\n            index = self.model.add_phase_slot(""New Phase"", 1.0)\n            self._add_phase_view(index)\n\n    def on_add_specimen(self, widget, *args):\n        with self.model.data_changed.hold():\n            index = self.model.add_specimen_slot(None, 1.0, 0.0)\n            self._add_specimen_view(index)\n\n    def on_add_both(self, widget, *args):\n        with self.model.data_changed.hold():\n            self.on_add_specimen(widget, *args)\n            self.on_add_phase(widget, *args)\n\n    def on_optimize_clicked(self, widget, *args):\n        self.model.optimize()\n\n    def on_refine_clicked(self, widget, *args):\n        self.model.refinement.update_refinement_treestore()\n        if self.ref_view is not None:\n            self.ref_view.hide()\n            self.ref_ctrl.cleanup()\n        self.view.parent.hide()\n        self.ref_view = RefinementView(parent=self.parent.view)\n        self.ref_ctrl = RefinementController(model=self.model.refinement, view=self.ref_view, parent=self)\n        self.ref_view.present()\n\n    def on_composition_clicked(self, widget, *args):\n        comp = ""The composition of the specimens in this mixture:\\n\\n\\n""\n        comp += ""<span font-family=\\""monospace\\"">""\n        # get the composition matrix (first columns contains strings with elements, others are specimen compositions)\n        import re\n        for row in self.model.get_composition_matrix():\n            comp += ""%s %s\\n"" % (re.sub(r\'(\\d+)\', r\'<sub>\\1</sub>\', row[0]), "" "".join(row[1:]))\n        comp += ""</span>""\n        DialogFactory.get_information_dialog(\n            comp, parent=self.view.get_toplevel()\n        ).run()\n\n    pass # end of class\n'"
pyxrd/mixture/controllers/insitu_behaviours_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n\nfrom contextlib import contextmanager\n\nfrom mvc.models.base import Model\n\nfrom pyxrd.generic.controllers import ObjectListStoreController\n\nfrom pyxrd.mixture.models import InSituBehaviour, insitu_behaviours\nfrom pyxrd.mixture.views import EditInSituBehaviourView\n\n\nfrom pyxrd.mixture.views.add_insitu_behaviour_view import AddInSituBehaviourView\n\nfrom .edit_insitu_behaviour_controller import EditInSituBehaviourController\nfrom .add_insitu_behaviour_controller import AddInSituBehaviourController\n\nclass InSituBehavioursController(ObjectListStoreController):\n\n    treemodel_property_name = ""behaviours""\n    treemodel_class_type = InSituBehaviour\n    columns = [ (""Mixture name"", ""c_name"") ]\n    delete_msg = ""Deleting a mixture is irreverisble!\\nAre You sure you want to continue?""\n    obj_type_map = [\n        (cls, EditInSituBehaviourView, EditInSituBehaviourController)\n        for name, cls in list(insitu_behaviours.__dict__.items()) if hasattr(cls, \'Meta\') and cls.Meta.concrete\n    ]\n\n    def get_behaviours_tree_model(self, *args):\n        return self.treemodel\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_load_object_clicked(self, event):\n        pass # cannot load behaviours\n    \n    def on_save_object_clicked(self, event):\n        pass # cannot save behaviours\n\n    def get_new_edit_view(self, obj):\n        """"""\n            Gets a new \'edit object\' view for the given obj, view and parent\n            view.\n        """"""\n        if obj == None:\n            return self.view.none_view\n        else:\n            for obj_tp, view_tp, ctrl_tp in self.obj_type_map: # @UnusedVariable\n                if isinstance(obj, obj_tp):\n                    return view_tp(obj.Meta, parent=self.view)\n            raise NotImplementedError(""Unsupported object type; subclasses of""\n                "" TreeControllerMixin need to define an obj_type_map attribute!"")\n\n    def create_new_object_proxy(self):\n        \n        def on_accept(behaviour_type):\n            if behaviour_type is not None:\n                self.add_object(behaviour_type(parent=self.model))\n\n        # TODO re-use this and reset the COMBO etc.\n        self.add_model = Model()\n        self.add_view = AddInSituBehaviourView(parent=self.view)\n        self.add_ctrl = AddInSituBehaviourController(\n            model=self.add_model, view=self.add_view, parent=self,\n            callback=on_accept\n        )\n\n        self.add_view.present()\n        return None\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.data_changed.hold():\n            yield\n\n    pass # end of class'"
pyxrd/mixture/controllers/mixtures_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom contextlib import contextmanager\n\nfrom mvc.models.base import Model\n\nfrom pyxrd.generic.controllers import ObjectListStoreController\n\nfrom pyxrd.mixture.models import Mixture #, InSituMixture\nfrom pyxrd.mixture.views import EditMixtureView, AddMixtureView #EditInSituMixtureView,\n\nfrom .edit_mixture_controller import EditMixtureController\n#from .edit_insitu_mixture_controller import EditInSituMixtureController\nfrom .add_mixture_controller import AddMixtureController\n\n\nclass MixturesController(ObjectListStoreController):\n\n    treemodel_property_name = ""mixtures""\n    treemodel_class_type = Mixture\n    columns = [ (""Mixture name"", ""c_name"") ]\n    delete_msg = ""Deleting a mixture is irreverisble!\\nAre You sure you want to continue?""\n    obj_type_map = [\n        #(InSituMixture, EditInSituMixtureView, EditInSituMixtureController),\n        (Mixture, EditMixtureView, EditMixtureController),\n    ]\n\n    def get_mixtures_tree_model(self, *args):\n        return self.treemodel\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_load_object_clicked(self, event):\n        pass # cannot load mixtures\n    \n    def on_save_object_clicked(self, event):\n        pass # cannot save mixtures\n\n    def create_new_object_proxy(self):\n        """"""def on_accept(mixture_type):\n            if mixture_type == ""mixture"":\n                self.add_object(Mixture(parent=self.model))\n            #elif mixture_type == ""insitu"":\n            #    self.add_object(InSituMixture(parent=self.model))\n                \n        # TODO re-use this and reset the COMBO etc.\n        self.add_model = Model()\n        self.add_view = AddMixtureView(types_dict={\n            \'mixture\': ""Create a regular mixture"", \n            #\'insitu\': ""Create an in-situ mixture""\n        }, parent=self.view)\n        self.add_ctrl = AddMixtureController(\n            model=self.add_model, view=self.add_view, parent=self.parent,\n            callback=on_accept\n        )\n\n        self.add_view.present()""""""\n        return Mixture(parent=self.model) #None\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.data_changed.hold():\n            yield\n\n    pass # end of class'"
pyxrd/mixture/models/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .mixture import Mixture\n#from .insitu_mixture import InSituMixture\n#from .insitu_behaviours import InSituBehaviour\n\n__all__ = [\n    ""Mixture"",\n    #""InSituMixture"",\n    #""InSituBehaviour""\n]\n'"
pyxrd/mixture/models/insitu_mixture.py,9,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nraise NotImplemented(""This module is not yet implemented"") \n\nimport sys, imp\n\nfrom contextlib import contextmanager\n\nimport numpy as np\n\nfrom pyxrd.generic.io.custom_io import storables\nfrom pyxrd.mixture.models.mixture import Mixture\nfrom copy import deepcopy\n\n@storables.register()\nclass InSituMixture(Mixture):\n    """"""\n        Advanced model for optimizing and refining of calculated in-situ XRD data.\n        Is a sub-class of the basic Mixture class.\n        \n        Each phase is linked with an additional Behaviour instance - these are created at the\n        project level.\n    """"""\n    \n    # MODEL INTEL:\n    class Meta(Mixture.Meta):\n        store_id = ""InSituMixture""\n    \n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object = Mixture.data_object.fget(self)  # @UndefinedVariable\n        return self._data_object\n    \n    def get_phase_data_object(self, specimen_index, z_index, phase_index):\n        behav = self.behaviour_matrix[specimen_index, ...].flatten()[phase_index] if self.behaviour_matrix is not None else None\n        phase = self.phase_matrix[specimen_index, ...].flatten()[phase_index] if self.phase_matrix is not None else None\n        if behav is not None and phase is not None:\n            behav.apply(phase, self.specimens[specimen_index].get_z_list()[z_index])\n        return deepcopy(phase.data_object) if phase is not None else None\n    \n    # Lists and matrices:\n    \n    #: A 2D numpy object array containing the behaviour paths\n    behaviour_matrix = None \n    \n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""behaviour_uuids"",\n            *[prop.label for prop in InSituMixture.Meta.get_local_persistent_properties()]\n        )\n        super(InSituMixture, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n        \n        with self.data_changed.hold():\n            # 2D matrix, rows match specimens, columns match mixture \'phase behaviours\'; contains the actual behaviour objects           \n            behaviour_uuids = self.get_kwarg(kwargs, None, ""behaviour_uuids"")\n            if behaviour_uuids is not None:\n                self.behaviour_matrix = np.array([[type(type(self)).object_pool.get_object(uuid) if uuid else None for uuid in row] for row in behaviour_uuids], dtype=np.object_)\n            else:\n                self.behaviour_matrix = np.empty(shape=(0, 0), dtype=np.object_)\n        \n            print(behaviour_uuids, self.behaviour_matrix)\n        \n            pass # end hold data_changed\n        \n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        retval = super(InSituMixture, self).json_properties()\n        retval[""behaviour_uuids""] = [[item.uuid if item else None for item in row] for row in map(list, self.behaviour_matrix)]\n        return retval\n        \n    @staticmethod\n    def from_json(**kwargs):\n        # Remove this deprecated kwarg:\n        if ""refinables"" in kwargs:\n            del kwargs[""refinables""]\n        return InSituMixture(**kwargs)\n        \n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n       \n    def get_behaviour(self, specimen_slot, phase_slot):\n        """"""Returns the behaviour at the given slot positions or None if not set""""""\n        return self.behaviour_matrix[specimen_slot, phase_slot]\n\n    def set_behaviour(self, specimen_slot, phase_slot, behaviour):\n        """"""Sets the behaviour at the given slot positions""""""\n        if self.parent is not None: #no parent = no valid phases\n            with self.needs_update.hold_and_emit():\n                with self.data_changed.hold():\n                    if behaviour is None:\n                        raise RuntimeError(""Behaviour can not be set to None, use unset_behaviour to clear!"")\n                    self.behaviour_matrix[specimen_slot, phase_slot] = behaviour\n                    self.refinement.update_refinement_treestore()\n                    \n    def unset_behaviour(self, behaviour):\n        """""" Clears a behaviour slot in the phase matrix """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                shape = self.behaviour_matrix.shape\n                for i in range(shape[0]):\n                    for j in range(shape[1]):\n                        if self.behaviour_matrix[i, j] == behaviour:\n                            self.behaviour_matrix[i, j] = None\n                self.refinement.update_refinement_treestore()\n    \n    @contextmanager\n    def _relieve_and_observe_behaviours(self):\n        self._relieve_behaviours()\n        yield\n        self._observe_behaviours()\n\n    def _observe_behaviours(self):\n        """""" Starts observing behaviour in the behaviour matrix""""""\n        for behaviour in self.behaviour_matrix.flat:\n            if behaviour is not None:\n                self.observe_model(behaviour)\n\n    def _relieve_behaviours(self):\n        """""" Relieves behaviour observer calls """"""\n        for behaviour in self.behaviour_matrix.flat:\n            if behaviour is not None:\n                self.relieve_model(behaviour)\n    \n    def add_phase_slot(self, phase_name, fraction):\n        """""" Adds a new phase column to the phase matrix """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                n, m = self.behaviour_matrix.shape if self.behaviour_matrix.ndim == 2 else (0, 0)\n                if self.behaviour_matrix.size == 0:\n                    self.behaviour_matrix = np.resize(self.behaviour_matrix.copy(), (n, m + 1))\n                    self.behaviour_matrix[:] = None\n                else:\n                    self.behaviour_matrix = np.concatenate([self.behaviour_matrix.copy(), [[None]] * n ], axis=1)\n                    self.behaviour_matrix[:, m] = None\n                return super(InSituMixture, self).add_phase_slot(phase_name, fraction)\n                \n    def del_phase_slot(self, phase_slot):\n        """""" Deletes a phase column using its index """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                with self._relieve_and_observe_behaviours():\n                    self.behaviour_matrix = np.delete(self.behaviour_matrix, phase_slot, axis=1)\n                return super(InSituMixture, self).del_phase_slot(phase_slot)\n\n    def add_specimen_slot(self, specimen, scale, bgs):\n        """""" Adds a new specimen to the phase matrix (a row) and specimen list """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():                   \n                n, m = self.behaviour_matrix.shape if self.behaviour_matrix.ndim == 2 else (0, 0)\n                if self.behaviour_matrix.size == 0:\n                    self.behaviour_matrix = np.resize(self.behaviour_matrix.copy(), (n + 1, m))\n                    self.behaviour_matrix[:] = None\n                else:\n                    self.behaviour_matrix = np.concatenate([self.behaviour_matrix.copy(), [[None] * m] ], axis=0)\n                    self.behaviour_matrix[n, :] = None\n                return super(InSituMixture, self).add_specimen_slot(specimen, scale, bgs)           \n    \n    def del_specimen_slot(self, specimen_slot):\n        """""" Deletes a specimen slot using its slot index """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                self.behaviour_matrix = np.delete(self.behaviour_matrix, specimen_slot, axis=0)\n                return super(InSituMixture, self).del_specimen_slot(specimen_slot)\n               \n    # ------------------------------------------------------------\n    #      Refinement stuff:\n    # ------------------------------------------------------------\n    def set_data_object(self, mixture, calculate=False):\n        """"""\n            Sets the fractions, scales and bgshifts of this mixture.\n        """"""\n        if mixture is not None:\n            with self.needs_update.ignore():\n                with self.data_changed.hold_and_emit():\n                    self.fractions[:] = list(mixture.fractions)\n                    self.scales[:] = list(mixture.scales)\n                    self.bgshifts[:] = list(mixture.bgshifts)\n\n                    if calculate: # (re-)calculate if requested:\n                        mixture = self.optimizer.calculate(mixture)\n\n                    for i, (specimen_data, specimen) in enumerate(zip(mixture.specimens, self.specimens)):\n                        if specimen is not None:\n                            with specimen.data_changed.ignore():\n                                specimen.update_pattern(\n                                    specimen_data.total_intensity,\n                                    specimen_data.phase_intensities * self.fractions[:, np.newaxis] * self.scales[i],\n                                    self.phase_matrix[i, :]\n                                )\n                    \n                   \n    def load_behaviour_from_module(self, path):\n        """"""Loads the behaviour class from the given filepath""""""\n        mod = imp.load_source(\'Behaviour\', path)\n        del sys.modules[\'Behaviour\'] # move the module to a better spot\n        sys.modules[mod.BEHAVIOUR_CLASS] = mod\n        klass = mod[mod.BEHAVIOUR_CLASS]\n        \n        behaviour = klass()\n        behaviour.__path = path # FIXME \n        \n        return behaviour\n        \n    pass # end of class'"
pyxrd/mixture/models/mixture.py,27,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport csv\nfrom warnings import warn\nfrom itertools import chain\nfrom collections import OrderedDict\nfrom contextlib import contextmanager\nimport logging\n\nimport numpy as np\n\nfrom mvc.models.properties import (\n    SignalProperty, LabeledProperty, SignalMixin, StringProperty,\n    BoolProperty, IntegerProperty\n)\nlogger = logging.getLogger(__name__)\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.models import DataModel\n\nfrom pyxrd.refinement.refinement import Refinement\n\nfrom pyxrd.calculations.data_objects import MixtureData\nfrom pyxrd.phases.models import Phase\n\nfrom .optimizers import Optimizer\n\n@storables.register()\nclass Mixture(DataModel, Storable):\n    """"""\n        The base model for optimization and refinement of calculated data\n        and experimental data. This is the main model you want to interact with,\n        lower-level classes\' functionality (mainly \n        :class:`~pyxrd.mixture.models.optimizers.Optimizer` and \n        :class:`~pyxrd.mixture.models.refiner.Refinement`) are integrated into this\n        class. \n        \n        The Mixture is responsible for managing the phases and specimens lists\n        and combination-matrix and for delegating any optimization, calculation\n        or refinement calls to the appropriate helper class.\n    """"""\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Mixture""\n\n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object.parsed = False\n        self._data_object.optimized = False\n        self._data_object.calculated = False\n        self._data_object.specimens = [None] * len(self.specimens)\n                \n        self._data_object.n = len(self.specimens)\n        self._data_object.m = len(self.phases)\n               \n        self._data_object.scales_mask = np.ones_like(self.scales)\n        if self.auto_scales:\n            self._data_object.scales_mask = np.ones_like(self.bgshifts)\n        else:\n            self._data_object.scales_mask = np.zeros_like(self.bgshifts)\n            \n        if self.auto_bg:\n            self._data_object.bgshifts_mask = np.ones_like(self.bgshifts)\n        else:\n            self._data_object.bgshifts_mask = np.zeros_like(self.bgshifts)\n        \n        for i, specimen in enumerate(self.specimens):\n            if specimen is not None:\n                data_object = specimen.data_object\n                data_object.phases = [[None] * self._data_object.m for _ in data_object.z_list]\n                for z_index in range(len(specimen.get_z_list())):\n                    for phase_index in range(self.phase_matrix.shape[1]):\n                        data_object.phases[z_index][phase_index] = self.get_phase_data_object(i, z_index, phase_index)\n                self._data_object.specimens[i] = data_object\n            else:\n                self._data_object.specimens[i] = None\n        return self._data_object\n\n    def get_phase_data_object(self, specimen_index, z_index, phase_index):\n        phase = self.phase_matrix[specimen_index, ...].flatten()[phase_index]\n        return phase.data_object if phase is not None else None\n\n    project = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # SIGNALS:\n    #: Signal, emitted when the # of phases or specimens changes\n    needs_reset = SignalProperty()\n    #: Signal, emitted when the patterns of the specimens need an update\n    needs_update = SignalProperty()\n\n    #: The name of this Mixture\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag, True if the mixture will automatically adjust phase fractions and scales\n    auto_run = BoolProperty(\n        default=False, text=""Auto Run"",\n        visible=True, persistent=True, tabular=True\n    )\n\n    #: Flag, True if the mixture is allowed to also update the background level\n    auto_bg = BoolProperty(\n        default=False, text=""Auto Bg"",\n        visible=True, persistent=True, tabular=True\n    )\n\n    #: Flag, True if the mixture is allowed to also update the background level\n    auto_scales = BoolProperty(\n        default=True, text=""Auto Scales"",\n        visible=True, persistent=True, tabular=True\n    )\n\n    #: The tree of refinable properties\n    @LabeledProperty(\n        default=None, text="""",\n        visible=True, persistent=False, tabular=True,\n        data_type=object,\n    )\n    def refinables(self):\n        return self.refinement.refinables\n\n    #: An integer describing which method to use for the refinement (see\n    #: mixture.models.methods.get_all_refine_methods)\n    @IntegerProperty(\n        default=0, text=""Refinement method index"",\n        visible=False, persistent=True,\n    )\n    def refine_method_index(self):\n        return self.refinement.refine_method_index\n\n    #: A dict containing the current refinement options\n    @LabeledProperty(\n        default=None, text=""Current refinement method options"",\n        visible=False, persistent=True, tabular=False,\n        data_type=object, store_private=""all_refine_options""\n    )\n    def refine_options(self):\n        return  self.refinement.refine_options\n\n    #: A dict containing all refinement options\n    @LabeledProperty(\n        default=None, text=""All refinement methods options"",\n        visible=False, persistent=False, tabular=False,\n        data_type=object\n    )\n    def all_refine_options(self):\n        return self.refinement.all_refine_options\n\n    # Lists and matrices:\n    #: A 2D numpy object array containing the combination matrix\n    phase_matrix = None\n    #: The list of specimen objects\n    specimens = None\n    #: The list of phase names\n    phases = None\n\n    @property\n    def scales(self):\n        """""" A list of floats containing the absolute scales for the calculated patterns """"""\n        return self._data_object.scales\n    @scales.setter\n    def scales(self, value):\n        self._data_object.scales = value\n\n    @property\n    def bgshifts(self):\n        """""" A list of background shifts for the calculated patterns """"""\n        return self._data_object.bgshifts\n    @bgshifts.setter\n    def bgshifts(self, value):\n        self._data_object.bgshifts = value\n\n    @property\n    def fractions(self):\n        """""" A list of phase fractions for this mixture """"""\n        return self._data_object.fractions\n    @fractions.setter\n    def fractions(self, value):\n        self._data_object.fractions = value\n\n    @property\n    def fractions_mask(self):\n        """""" A mask indicating which fractions are to be optimized """"""\n        return self._data_object.fractions_mask\n    @fractions_mask.setter\n    def fractions_mask(self, value):\n        self._data_object.fractions_mask = value\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Constructor takes any of its properties as a keyword argument.\n            It also support two UUID list keyword arguments:\n                - phase_uuids: a list of UUID\'s for the phases in the mixture\n                - specimen_uuids: a list of UUID\'s for the specimens in the mixture\n            These should be *instead* of the phases and specimens keywords.\n            \n            In addition to the above, the constructor still supports the \n            following deprecated keywords, mapping to a current keyword:\n                - phase_indeces: a list of project indices for the phases in the mixture\n                - specimen_indeces: a list of project indices for the specimens in the mixture\n                \n            Any other arguments or keywords are passed to the base class.\n        """"""\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""phase_uuids"", ""phase_indeces"", ""specimen_uuids"",\n            ""specimen_indeces"", ""data_phases"", ""data_scales"", ""data_bgshifts"",\n            ""data_fractions"", ""refine_method"", ""data_refine_method"",\n            ""fractions"", ""fractions_mask"", ""bgshifts"", ""scales"", ""phases"",\n            *[prop.label for prop in Mixture.Meta.get_local_persistent_properties()]\n        )\n        super(Mixture, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n\n            self._data_object = MixtureData()\n\n            self.name = self.get_kwarg(kwargs, ""New Mixture"", ""name"", ""data_name"")\n            self.auto_run = self.get_kwarg(kwargs, False, ""auto_run"")\n            self.auto_bg = self.get_kwarg(kwargs, True, ""auto_bg"")\n            self.auto_scales = self.get_kwarg(kwargs, True, ""auto_scales"")\n\n            # 2D matrix, rows match specimens, columns match mixture \'phases\'; contains the actual phase objects\n            phase_uuids = self.get_kwarg(kwargs, None, ""phase_uuids"")\n            phase_indeces = self.get_kwarg(kwargs, None, ""phase_indeces"")\n            if phase_uuids is not None:\n                self.phase_matrix = np.array([[type(type(self)).object_pool.get_object(uuid) if uuid else None for uuid in row] for row in phase_uuids], dtype=np.object_)\n            elif phase_indeces and self.parent is not None:\n                warn(""The use of object indices is deprecated since version 0.4. Please switch to using object UUIDs."", DeprecationWarning)\n                self.phase_matrix = np.array([[self.parent.phases[index] if index != -1 else None for index in row] for row in phase_indeces], dtype=np.object_)\n            else:\n                self.phase_matrix = np.empty(shape=(0, 0), dtype=np.object_)\n\n            # list with actual specimens, indexes match with rows in phase_matrix\n            specimen_uuids = self.get_kwarg(kwargs, None, ""specimen_uuids"")\n            specimen_indeces = self.get_kwarg(kwargs, None, ""specimen_indeces"")\n            if specimen_uuids:\n                self.specimens = [type(type(self)).object_pool.get_object(uuid) if uuid else None for uuid in specimen_uuids]\n            elif specimen_indeces and self.parent is not None:\n                warn(""The use of object indices is deprecated since version 0.4. Please switch to using object UUIDs."", DeprecationWarning)\n                self.specimens = [self.parent.specimens[index] if index != -1 else None for index in specimen_indeces]\n            else:\n                self.specimens = list()\n\n            # list with mixture phase names, indexes match with cols in phase_matrix\n            self.phases = self.get_kwarg(kwargs, list(), ""phases"", ""data_phases"")\n\n            # list with scale values, indexes match with rows in phase_matrix (= specimens)\n            self.scales = np.asarray(self.get_kwarg(kwargs, [1.0] * len(self.specimens), ""scales"", ""data_scales""))\n            # list with specimen background shift values, indexes match with rows in phase_matrix (=specimens)\n            self.bgshifts = np.asarray(self.get_kwarg(kwargs, [0.0] * len(self.specimens), ""bgshifts"", ""data_bgshifts""))\n            # list with phase fractions, indexes match with cols in phase_matrix (=phases)\n            self.fractions = np.asarray(self.get_kwarg(kwargs, [0.0] * len(self.phases), ""fractions"", ""data_fractions""))\n            # list with phase fractions mask, indexes match with cols in phase_matrix (=phases)\n            self.fractions_mask = np.asarray(self.get_kwarg(kwargs, [1] * len(self.phases), ""fractions_mask""))\n\n            # sanity check:\n            n, m = self.phase_matrix.shape if self.phase_matrix.ndim == 2 else (0, 0)\n            if len(self.scales) != n or len(self.specimens) != n or len(self.bgshifts) != n:\n                raise IndexError(""Shape mismatch: scales (%d), background shifts (%d) or specimens (%d) list lengths do not match with row count (%d) of phase matrix"" % (len(self.scales), len(self.specimens), len(self.bgshifts), n))\n            if len(self.phases) != m or len(self.fractions) != m:\n                raise IndexError(""Shape mismatch: fractions (%s) or phases (%d) lists do not match with column count of phase matrix (%d)"" % (len(self.fractions), len(self.phases), m))\n\n            self._observe_specimens()\n            self._observe_phases()\n\n            self.optimizer = Optimizer(parent=self)\n            self.refinement = Refinement(\n                refine_method_index=self.get_kwarg(kwargs, 0, ""refine_method_index"", ""refine_method"", ""data_refine_method""),\n                refine_options=self.get_kwarg(kwargs, dict(), ""refine_options""),\n                parent=self)\n\n            self.update()\n\n            self.observe_model(self)\n\n            pass # end hold data_changed\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @DataModel.observe(""removed"", signal=True)\n    def notify_removed(self, model, prop_name, info):\n        if model == self:\n            self._relieve_phases()\n            self._relieve_specimens()\n\n    @DataModel.observe(""needs_update"", signal=True)\n    def notify_needs_update(self, model, prop_name, info):\n        with self.data_changed.hold():\n            self.update()\n\n    @DataModel.observe(""data_changed"", signal=True)\n    def notify_data_changed(self, model, prop_name, info):\n        if not model == self and not (\n            info.arg == ""based_on"" and model.based_on is not None and\n            model.based_on in self.phase_matrix):\n                self.needs_update.emit()\n\n    @DataModel.observe(""visuals_changed"", signal=True)\n    def notify_visuals_changed(self, model, prop_name, info):\n        if isinstance(model, Phase) and \\\n           not (info.arg == ""based_on"" and model.based_on is not None and model.based_on in self.phase_matrix):\n            for i, specimen in enumerate(self.specimens):\n                if specimen is not None:\n                    specimen.update_visuals(self.phase_matrix[i, :])\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        self.refinement.update_refinement_treestore()\n        retval = Storable.json_properties(self)\n\n        retval[""phase_uuids""] = [[item.uuid if item else """" for item in row] for row in map(list, self.phase_matrix)]\n        retval[""specimen_uuids""] = [specimen.uuid if specimen else """" for specimen in self.specimens]\n        retval[""phases""] = self.phases\n        retval[""fractions""] = self.fractions.tolist()\n        retval[""fractions_mask""] = self.fractions_mask.tolist()\n        retval[""bgshifts""] = self.bgshifts.tolist()\n        retval[""scales""] = self.scales.tolist()\n\n        return retval\n\n    @staticmethod\n    def from_json(**kwargs):\n        # Remove this deprecated kwarg:\n        if ""refinables"" in kwargs:\n            del kwargs[""refinables""]\n        return Mixture(**kwargs)\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def unset_phase(self, phase):\n        """""" Clears a phase slot in the phase matrix """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                shape = self.phase_matrix.shape\n                with self._relieve_and_observe_phases():\n                    for i in range(shape[0]):\n                        for j in range(shape[1]):\n                            if self.phase_matrix[i, j] == phase:\n                                self.phase_matrix[i, j] = None\n                self.refinement.update_refinement_treestore()\n\n    def unset_specimen(self, specimen):\n        """""" Clears a specimen slot in the specimen list """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                with self._relieve_and_observe_specimens():\n                    for i, spec in enumerate(self.specimens):\n                        if spec == specimen:\n                            self.specimens[i] = None\n\n    def get_phase(self, specimen_slot, phase_slot):\n        """"""Returns the phase at the given slot positions or None if not set""""""\n        return self.phase_matrix[specimen_slot, phase_slot]\n\n    def set_phase(self, specimen_slot, phase_slot, phase):\n        """"""Sets the phase at the given slot positions""""""\n        if self.parent is not None: #no parent = no valid phases\n            with self.needs_update.hold_and_emit():\n                with self.data_changed.hold():\n                    with self._relieve_and_observe_phases():\n                        if phase is not None and not phase in self.parent.phases:\n                            raise RuntimeError(""Cannot add a phase to a Mixture which is not inside the project!"")\n                        self.phase_matrix[specimen_slot, phase_slot] = phase\n                    self.refinement.update_refinement_treestore()\n\n    def get_specimen(self, specimen_slot):\n        """"""Returns the specimen at the given slot position or None if not set""""""\n        return self.specimens[specimen_slot]\n\n    def set_specimen(self, specimen_slot, specimen):\n        """"""Sets the specimen at the given slot position""""""\n        if self.parent is not None: #no parent = no valid specimens\n            with self.needs_update.hold_and_emit():\n                with self.data_changed.hold():\n                    with self._relieve_and_observe_specimens():\n                        if specimen is not None and not specimen in self.parent.specimens:\n                            raise RuntimeError(""Cannot add a specimen to a Mixture which is not inside the project!"")\n                        self.specimens[specimen_slot] = specimen\n\n    @contextmanager\n    def _relieve_and_observe_specimens(self):\n        self._relieve_specimens()\n        yield\n        self._observe_specimens()\n\n    def _observe_specimens(self):\n        """""" Starts observing specimens in the specimens list""""""\n        for specimen in self.specimens:\n            if specimen is not None:\n                self.observe_model(specimen)\n\n    def _relieve_specimens(self):\n        """""" Relieves specimens observer calls """"""\n        for specimen in self.specimens:\n            if specimen is not None:\n                self.relieve_model(specimen)\n\n    @contextmanager\n    def _relieve_and_observe_phases(self):\n        self._relieve_phases()\n        yield\n        self._observe_phases()\n\n    def _observe_phases(self):\n        """""" Starts observing phases in the phase matrix""""""\n        for phase in self.phase_matrix.flat:\n            if phase is not None:\n                self.observe_model(phase)\n\n    def _relieve_phases(self):\n        """""" Relieves phase observer calls """"""\n        for phase in self.phase_matrix.flat:\n            if phase is not None:\n                self.relieve_model(phase)\n\n    def add_phase_slot(self, phase_name, fraction):\n        """""" Adds a new phase column to the phase matrix """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                self.phases.append(phase_name)\n                self.fractions = np.append(self.fractions, fraction)\n                self.fractions_mask = np.append(self.fractions_mask, 1)\n                n, m = self.phase_matrix.shape if self.phase_matrix.ndim == 2 else (0, 0)\n                if self.phase_matrix.size == 0:\n                    self.phase_matrix = np.resize(self.phase_matrix.copy(), (n, m + 1))\n                    self.phase_matrix[:] = None\n                else:\n                    self.phase_matrix = np.concatenate([self.phase_matrix.copy(), [[None]] * n ], axis=1)\n                    self.phase_matrix[:, m] = None\n                self.refinement.update_refinement_treestore()\n        return m\n\n    def del_phase_slot(self, phase_slot):\n        """""" Deletes a phase column using its index """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                with self._relieve_and_observe_phases():\n                    # Remove the corresponding phase name, fraction & references:\n                    del self.phases[phase_slot]\n                    self.fractions = np.delete(self.fractions, phase_slot)\n                    self.fractions_mask = np.delete(self.fractions_mask, phase_slot)\n                    self.phase_matrix = np.delete(self.phase_matrix, phase_slot, axis=1)\n                # Update our refinement tree store to reflect current state\n                self.refinement.update_refinement_treestore()\n        # Inform any interested party they need to update their representation\n        self.needs_reset.emit()\n\n    def del_phase_slot_by_name(self, phase_name):\n        """""" Deletes a phase slot using its name """"""\n        self.del_phase_slot(self.phases.index(phase_name))\n\n    def add_specimen_slot(self, specimen, scale, bgs):\n        """""" Adds a new specimen to the phase matrix (a row) and specimen list """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                self.specimens.append(None)\n                self.scales = np.append(self.scales, scale)\n                self.bgshifts = np.append(self.bgshifts, bgs)\n                n, m = self.phase_matrix.shape if self.phase_matrix.ndim == 2 else (0, 0)\n                if self.phase_matrix.size == 0:\n                    self.phase_matrix = np.resize(self.phase_matrix.copy(), (n + 1, m))\n                    self.phase_matrix[:] = None\n                else:\n                    self.phase_matrix = np.concatenate([self.phase_matrix.copy(), [[None] * m] ], axis=0)\n                    self.phase_matrix[n, :] = None\n                if specimen is not None:\n                    self.set_specimen(n, specimen)\n        return n\n\n    def del_specimen_slot(self, specimen_slot):\n        """""" Deletes a specimen slot using its slot index """"""\n        with self.needs_update.hold_and_emit():\n            with self.data_changed.hold():\n                # Remove the corresponding specimen name, scale, bg-shift & phases:\n                with self._relieve_and_observe_specimens():\n                    del self.specimens[specimen_slot]\n                    self.scales = np.delete(self.scales, specimen_slot)\n                    self.bgshifts = np.delete(self.bgshifts, specimen_slot)\n                    self.phase_matrix = np.delete(self.phase_matrix, specimen_slot, axis=0)\n                # Update our refinement tree store to reflect current state\n                self.refinement.update_refinement_treestore()\n        # Inform any interested party they need to update their representation\n        self.needs_reset.emit()\n\n    def del_specimen_slot_by_object(self, specimen):\n        """""" Deletes a specimen slot using the actual object """"""\n        try:\n            self.del_specimen_slot(self.specimens.index(specimen))\n        except ValueError:\n            logger.exception(""Caught a ValueError when deleting a specimen from  mixture \'%s\'"" % self.name)\n\n    # ------------------------------------------------------------\n    #      Refinement stuff:\n    # ------------------------------------------------------------\n    def set_data_object(self, mixture, calculate=False):\n        """"""\n            Sets the fractions, scales and bgshifts of this mixture.\n        """"""\n        if mixture is not None:\n            with self.needs_update.ignore():\n                with self.data_changed.hold_and_emit():\n                    self.fractions[:] = list(mixture.fractions)\n                    self.scales[:] = list(mixture.scales)\n                    self.bgshifts[:] = list(mixture.bgshifts)\n\n                    # reset flag when needed:\n                    mixture.calculated = mixture.calculated and not calculate\n                    mixture = self.optimizer.calculate(mixture)\n\n                    for i, (specimen_data, specimen) in enumerate(zip(mixture.specimens, self.specimens)):\n                        if specimen is not None:\n                            with specimen.data_changed.ignore():\n                                specimen.update_pattern(\n                                    specimen_data.total_intensity,\n                                    specimen_data.scaled_phase_intensities,\n                                    self.phase_matrix[i, :]\n                                )\n\n    def optimize(self):\n        """"""\n            Optimize the current solution (fractions, scales, bg shifts & calculate\n            phase intensities)\n        """"""\n        with self.needs_update.ignore():\n            with self.data_changed.hold():\n                # no need to re-calculate, is already done by the optimization\n                self.set_data_object(self.optimizer.optimize())\n\n    def apply_current_data_object(self):\n        """"""\n            Recalculates the intensities using the current fractions, scales\n            and bg shifts without optimization\n        """"""\n        with self.needs_update.ignore():\n            with self.data_changed.hold():\n                self.set_data_object(self.data_object, calculate=True)\n\n    # @print_timing\n    def update(self):\n        """"""\n            Optimizes or re-applies the current mixture \'solution\'.\n            Effectively re-calculates the entire patterns.\n        """"""\n        with self.needs_update.ignore():\n            with self.data_changed.hold():\n                if self.auto_run:\n                    self.optimize()\n                else:\n                    self.apply_current_data_object()\n\n    # ------------------------------------------------------------\n    #      Various other things:\n    # ------------------------------------------------------------\n    def get_composition_matrix(self):\n        """"""\n            Returns a matrix containing the oxide composition for each specimen \n            in this mixture. It uses the COMPOSITION_CONV file for this purpose\n            to convert element weights into their oxide weight equivalent.\n        """"""\n\n        # create an atom nr -> (atom name, conversion) mapping\n        # this is used to transform most of the elements into their oxides\n        atom_conv = OrderedDict()\n        with open(settings.DATA_REG.get_file_path(""COMPOSITION_CONV""), \'r\') as f:\n            reader = csv.reader(f)\n            next(reader) # skip header\n            for row in reader:\n                nr, name, fact = row\n                atom_conv[int(nr)] = (name, float(fact))\n\n        comps = list()\n        for i, row in enumerate(self.phase_matrix):\n            comp = dict()\n            for j, phase in enumerate(row):\n                phase_fract = self.fractions[j]\n                for k, component in enumerate(phase.components):\n                    comp_fract = phase.probabilities.mW[k] * phase_fract\n                    for atom in chain(component.layer_atoms,\n                            component.interlayer_atoms):\n                        nr = atom.atom_type.atom_nr\n                        if nr in atom_conv:\n                            wt = atom.pn * atom.atom_type.weight * comp_fract * atom_conv[nr][1]\n                            comp[nr] = comp.get(nr, 0.0) + wt\n            comps.append(comp)\n\n        final_comps = np.zeros(shape=(len(atom_conv) + 1, len(comps) + 1), dtype=\'a15\')\n        final_comps[0, 0] = "" ""*8\n        for j, comp in enumerate(comps):\n            fact = 100.0 / sum(comp.values())\n            for i, (nr, (oxide_name, conv)) in enumerate(atom_conv.items()):\n                wt = comp.get(nr, 0.0) * fact\n                # set relevant cells:\n                if i == 0:\n                    final_comps[i, j + 1] = self.specimens[j].name.ljust(15)[:15]\n                if j == 0:\n                    final_comps[i + 1, j] = (""%s  "" % oxide_name).rjust(8)[:8]\n                final_comps[i + 1, j + 1] = (""%.1f"" % wt).ljust(15)[:15]\n\n        return final_comps\n\n    pass # end of class\n'"
pyxrd/mixture/models/optimizers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.models import ChildModel\n\nfrom pyxrd.calculations.mixture import (\n    calculate_mixture,\n    calculate_and_optimize_mixture,\n    get_residual,\n    get_optimized_residual\n)\n\n\nclass Optimizer(ChildModel):\n    """"""\n        A simple model that plugs onto the Mixture model. It provides\n        the functionality related to optimizing the weight fractions, scales\n        and background shifts and residual calculation for the phases.\n    """"""\n    parent_alias = ""mixture""\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_current_residual(self):\n        """"""\n            Gets the residual for the current mixture solution.\n            Convenience function.\n        """"""\n        return self.get_residual()\n\n    def get_optimized_residual(self, data_object=None):\n        """"""\n            Gets an optimized residual for the current mixture setup. If no\n            data_object is passed it is retrieved from the mixture.\n        """"""\n        return get_optimized_residual(*self.get_data_object(data_object))[0]\n\n    def get_residual(self, data_object=None):\n        """"""\n            Calculates the residual for the given solution in combination with\n            the given optimization arguments. If no data_object is passed it is \n            retrieved from the mixture.\n        """"""\n        return get_residual(*self.get_data_object(data_object))[0]\n\n    def calculate(self, data_object=None):\n        """"""\n            Calculates the total and phase intensities. If no data_object is\n            passed it is retrieved from the mixture.\n        """"""\n        return calculate_mixture(*self.get_data_object(data_object))\n\n    def optimize(self, data_object=None):\n        """"""\n            Optimizes the mixture fractions, scales and bg shifts and returns the\n            optimized result. If no data_object is passed it is retrieved from\n            the mixture.\n        """"""\n        try:\n            return calculate_and_optimize_mixture(*self.get_data_object(data_object))\n        except AssertionError:\n            return None\n\n    def get_data_object(self, data_object=None):\n        return (data_object if data_object is not None else self.parent.data_object,)\n\n    pass # end of class\n'"
pyxrd/mixture/views/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .edit_mixture_view import EditMixtureView\n#from .edit_insitu_mixture_view import EditInSituMixtureView\n#from .edit_insitu_behaviour_view import EditInSituBehaviourView\nfrom .add_mixture_view import AddMixtureView \n\n__all__ = [\n    ""EditMixtureView"",\n    #""EditInSituMixtureView"",\n    ""AddMixtureView"",\n    #""EditInSituBehaviourView""\n]'"
pyxrd/mixture/views/add_insitu_behaviour_view.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom pyxrd.generic.views import DialogView\n\nclass AddInSituBehaviourView(DialogView):\n    title = ""Add Behaviour""\n    subview_builder = resource_filename(__name__, ""glade/add_behaviour.glade"")\n    subview_toplevel = ""add_behaviour_container""\n\n    def __init__(self, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n\n    def get_behaviour_type(self):\n        itr = self.behaviour_combo_box.get_active_iter()\n        val = self.behaviour_combo_box.get_model().get_value(itr, 1) if itr else None\n        return val\n\n    @property\n    def behaviour_combo_box(self):\n        return self[""cmb_behaviours""]\n\n    pass # end of class'"
pyxrd/mixture/views/add_mixture_view.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom pyxrd.generic.views import DialogView\n\nclass AddMixtureView(DialogView):\n    title = ""Add Mixture""\n    subview_builder = resource_filename(__name__, ""glade/add_mixture.glade"")\n    subview_toplevel = ""add_mixture_container""\n\n    active_type = ""mixture"" # | insitu\n\n    def __init__(self, type_dict, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n        self.type_dict = type_dict\n        self.active_type=list(type_dict.keys())[0]\n        self.create_radios()\n\n    def create_radios(self):\n        box = self[""add_mixture_box""]\n        box.clear()\n        group = None\n        self.radios = []\n        for mixture_type, label in self.type_dict.items():\n            radio = Gtk.RadioButton.new(group, label)\n            radio.mixture_type = mixture_type\n            group = radio if group is None else group \n            self.radios.append(radio)\n            radio.connect(\'toggled\', self.on_rdb_toggled)\n            box.pack_start(radio, False, False, 2)\n\n    def get_mixture_type(self):\n        return self.active_type\n\n    def on_rdb_toggled(self):\n        for radio in self.radios:\n            if radio.get_active():\n                self.active_type = radio.mixture_type\n    pass # end of class'"
pyxrd/mixture/views/edit_insitu_behaviour_view.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom pyxrd.generic.views import BaseView\n\nclass EditInSituBehaviourView(BaseView):\n    builder = resource_filename(__name__, ""glade/edit_insitu_behaviour.glade"")\n    top = ""edit_insitu_behaviour""\n\n    widget_format = ""behaviour_%s""\n    parameter_table = ""edit_insitu_behaviour""\n\n    def __init__(self, meta, **kwargs):\n        assert (meta is not None), ""EditInSituBehaviourView needs a model\'s Meta class!""\n        BaseView.__init__(self, **kwargs)\n\n        self.props = [ prop for prop in meta.all_properties if getattr(prop, ""visible"", False) ]\n\n        def create_label(prop):\n            new_lbl = Gtk.Label(label=prop.text)\n            new_lbl.set_use_markup(True)\n            return new_lbl\n\n        def create_input(prop):\n            new_inp = self.add_widget(prop)\n            new_inp.set_name(self.widget_format % prop.label)\n            return new_inp\n\n        self.create_input_table(\n            self[self.parameter_table], self.props, \n            num_columns=1, widget_callbacks = [\n                create_label,\n                create_input\n            ]\n        )\n\n    pass #end of class'"
pyxrd/mixture/views/edit_insitu_mixture_view.py,2,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename  # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom pyxrd.generic.views import BaseView\nfrom pyxrd.generic.views.validators import FloatEntryValidator\n\nclass EditInSituMixtureView(BaseView):   \n    builder = resource_filename(__name__, ""glade/edit_mixture.glade"")\n    top = ""edit_mixture""\n\n    base_width = 4\n    base_height = 5\n\n    matrix_widget = ""tbl_matrix""\n    wrapper_widget = ""tbl_wrapper""\n    widget_format = ""mixture_%s""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.parent.set_title(""Edit In Situ Mixtures"")\n        self.matrix = self[self.matrix_widget]\n        self.wrapper = self[self.wrapper_widget]\n\n        self.labels = [ self[""lbl_scales""], self[""lbl_fractions""], self[""lbl_phases""], self[""lbl_bgshifts""], self[""lbl_specimens""] ]\n\n        self[""scolled_window""].set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        self.matrix.connect(""size-request"", self.on_size_requested)\n\n        self.reset_view()\n\n    def reset_view(self):\n        def remove(item):\n            if not item in self.labels: self.matrix.remove(item)\n        self.matrix.foreach(remove)\n        self.matrix.resize(self.base_height, self.base_width)\n\n        self.phase_inputs = []\n        self.fraction_inputs = []\n        self.specimen_combos = []\n        self.scale_inputs = []\n        self.bgs_inputs = []\n        self.phase_combos = np.empty(shape=(0, 0), dtype=np.object_) # 2D list\n        self.behav_combos = np.empty(shape=(0, 0), dtype=np.object_) # 2D list\n\n        self.on_size_requested()\n\n    def on_size_requested(self, *args):\n        sr = self.matrix.size_request()\n        self[self.top].set_size_request(sr[0] + 100, -1)\n\n    def set_edit_view(self, view):\n        if self._on_sr_id is not None and self.child_view is not None:\n            self.child_view.disconnect(self._on_sr_id)\n        self.edit_view = view\n        self.child_view = view.get_top_widget()\n        self._add_child_view(self.child_view, self[self.edit_view_container])\n        if isinstance(self[self.edit_view_container], Gtk.ScrolledWindow):\n            sr = self.child_view.get_size_request()\n            self[self.edit_view_container].set_size_request(sr[0], -1)\n\n    def update_all(self, fractions, scales, bgs):\n        for i, fraction in enumerate(fractions):\n            if not i >= len(self.fraction_inputs):\n                self.fraction_inputs[i].set_text(str(fraction))\n        for i, scale in enumerate(scales):\n            if not i >= len(self.scale_inputs):\n                self.scale_inputs[i].set_text(str(scale))\n        for i, bgs in enumerate(bgs):\n            if not i >= len(self.bgs_inputs):\n                self.bgs_inputs[i].set_text(str(bgs))\n\n    def add_phase_slot(self, \n           phase_store, behav_store, \n           del_phase_callback, label_callback, fraction_callback, \n           phase_visible_callback, phase_combo_callback,\n           behav_visible_callback, behav_combo_callback, \n           label, fraction,\n           phases, behavs):\n        r, c = self.matrix.get_property(\'n_rows\'), self.matrix.get_property(\'n_columns\')\n        self.matrix.resize(r + 1, c)\n\n        del_icon = Gtk.Image()\n        del_icon.set_from_stock (""192-circle-remove"", Gtk.IconSize.SMALL_TOOLBAR)\n        new_phase_del_btn = Gtk.Button()\n        new_phase_del_btn.set_image(del_icon)\n        rid = new_phase_del_btn.connect(""clicked"", del_phase_callback)\n        setattr(new_phase_del_btn, ""deleventid"", rid)\n        self.matrix.attach(new_phase_del_btn, 0, 1, r, r + 1, Gtk.AttachOptions.FILL, 0)\n\n        new_phase_input = self._get_new_input(label, callback=label_callback)\n        self.phase_inputs.append(new_phase_input)\n        self.matrix.attach(new_phase_input, 1, 2, r, r + 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_fraction_input = self._get_new_input(str(fraction), callback=fraction_callback)\n        FloatEntryValidator(new_fraction_input)\n        self.fraction_inputs.append(new_fraction_input)\n        self.matrix.attach(new_fraction_input, 2, 3, r, r + 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        self.phase_combos.resize((c - self.base_width, r + 1 - self.base_height))\n        self.behav_combos.resize((c - self.base_width, r + 1 - self.base_height))\n        for col in range(c - self.base_width):\n            mcol, mrow = r - self.base_height, col\n            self._add_new_phase_behav_combo(\n                mrow, mcol,\n                phase_store, phase_store.c_name, phases[mrow, mcol], phase_visible_callback, phase_combo_callback,\n                behav_store, behav_store.c_name, behavs[mrow, mcol], behav_visible_callback, behav_combo_callback\n            )\n\n        self.wrapper.show_all()\n\n    def add_specimen_slot(self,\n            phase_store, behav_store, specimen_store, \n            del_specimen_callback, scale_callback, bgs_callback, specimen_callback, \n            phase_visible_callback, phase_combo_callback,\n            behav_visible_callback, behav_combo_callback, \n            scale, bgs, specimen, \n            phases, behavs):\n        r, c = self.matrix.get_property(\'n_rows\'), self.matrix.get_property(\'n_columns\')\n        self.matrix.resize(r, c + 1)\n\n        del_icon = Gtk.Image()\n        del_icon.set_from_stock(""192-circle-remove"", Gtk.IconSize.SMALL_TOOLBAR)\n        new_specimen_del_btn = Gtk.Button()\n        new_specimen_del_btn.set_image(del_icon)\n        rid = new_specimen_del_btn.connect(""clicked"", del_specimen_callback)\n        setattr(new_specimen_del_btn, ""deleventid"", rid)\n        self.matrix.attach(new_specimen_del_btn, c, c + 1, 0, 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_specimen_combo = self._get_new_combo(specimen_store, specimen_store.c_name, specimen, None, specimen_callback)\n        self.specimen_combos.append(new_specimen_combo)\n        self.matrix.attach(new_specimen_combo, c, c + 1, 1, 2, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_bgs_input = self._get_new_input(str(bgs), callback=bgs_callback)\n        FloatEntryValidator(new_bgs_input)\n        self.bgs_inputs.append(new_bgs_input)\n        self.matrix.attach(new_bgs_input, c, c + 1, 2, 3, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_scale_input = self._get_new_input(str(scale), callback=scale_callback)\n        FloatEntryValidator(new_scale_input)\n        self.scale_inputs.append(new_scale_input)\n        self.matrix.attach(new_scale_input, c, c + 1, 3, 4, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        self.phase_combos.resize((c + 1 - self.base_width, r - self.base_height))\n        self.behav_combos.resize((c + 1 - self.base_width, r - self.base_height))\n        for row in range(r - self.base_height):\n            mcol, mrow = row, c - self.base_width\n            self._add_new_phase_behav_combo(\n                mrow, mcol,\n                phase_store, phase_store.c_name, phases[mrow, mcol], phase_visible_callback, phase_combo_callback,\n                behav_store, behav_store.c_name, behavs[mrow, mcol], behav_visible_callback, behav_combo_callback\n            )\n            \n        self.wrapper.show_all()\n\n    def _get_new_input(self, text="""", width=7, callback=None):\n        """"""\n            Creates a new text input box.\n        """"""\n        new_input = Gtk.Entry()\n        new_input.set_text(text)\n        new_input.set_alignment(0.0)\n        new_input.set_width_chars(width)\n        if callback is not None: new_input.connect(""changed"", callback)\n        return new_input\n\n    def _add_new_phase_behav_combo(self, \n            r, c,\n            phase_model, phase_text_column, default_phase, phase_visible_callback, phase_callback,\n            behav_model, behav_text_column, default_behav, behav_visible_callback, behav_callback):\n        """"""\n            Creates new \'phase\' and \'behaviour\' combo boxes, and adds them to the table at\n            the given row and column indices.\n        """"""\n        new_phase_combo = self._get_new_combo(phase_model, phase_text_column, default_phase, phase_visible_callback, phase_callback, r, c)\n        self.phase_combos[r, c] = new_phase_combo\n        \n        new_behav_combo = self._get_new_combo(behav_model, behav_text_column, default_behav, behav_visible_callback, behav_callback, r, c)\n        self.behav_combos[r, c] = new_behav_combo\n\n        box = Gtk.HBox(spacing = 5)\n        box.pack_start(new_phase_combo, True, True, padding = 2)\n        box.pack_end(new_behav_combo, True, True, padding = 2)\n       \n        self.matrix.attach(box, self.base_width + r, self.base_width + r + 1, self.base_height + c, self.base_height + c + 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n    def _get_new_combo(self, model, text_column, default, visible_callback, callback, *args):\n        """"""\n            Creates a new combo box with the given model as ListStore, setting\n            the given column as text column, the given default value set as \n            active row, and connecting the given callback with \'changed\' signal.\n        """"""\n        combobox = Gtk.ComboBox(model)\n        combobox.set_size_request(75, -1)\n        cell = Gtk.CellRendererText()\n        combobox.pack_start(cell, True)\n\n        def combo_func(cmb, cell, model, itr, args):\n            text = model.get_value(itr, text_column)\n            cell.set_property(\'text\', text)\n            if callable(visible_callback):\n                cell.set_property(\'sensitive\', visible_callback(model, itr, args))\n        combobox.set_cell_data_func(cell, combo_func, args)       \n            \n        if default is not None:\n            index = model.on_get_path(default)[0]\n            combobox.set_active(index)\n        combobox.connect(""changed"", callback, *args)\n        return combobox\n\n    pass # end of class\n'"
pyxrd/mixture/views/edit_mixture_view.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename  # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nimport numpy as np\n\nfrom pyxrd.generic.views import BaseView\nfrom pyxrd.generic.views.validators import FloatEntryValidator\n\nclass EditMixtureView(BaseView):\n    builder = resource_filename(__name__, ""glade/edit_mixture.glade"")\n    top = ""edit_mixture""\n\n    base_width = 4\n    base_height = 5\n\n    matrix_widget = ""tbl_matrix""\n    wrapper_widget = ""tbl_wrapper""\n    widget_format = ""mixture_%s""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.parent.set_title(""Edit Mixtures"")\n        self.matrix = self[self.matrix_widget]\n        self.wrapper = self[self.wrapper_widget]\n\n        self.labels = [\n            self[""lbl_scales""], self[""lbl_fractions""], self[""lbl_phases""], self[""lbl_bgshifts""], self[""lbl_specimens""], \n            self[""mixture_auto_scales""], self[""mixture_auto_bg""] \n        ]\n\n        self[""scolled_window""].set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)\n        # TODO FIXME self.matrix.connect(""size-request"", self.on_size_requested)\n\n        self.reset_view()\n\n    def reset_view(self):\n        def remove(item):\n            if not item in self.labels: self.matrix.remove(item)\n        self.matrix.foreach(remove)\n        self.matrix.resize(self.base_height, self.base_width)\n\n        self.phase_inputs = []\n        self.fraction_inputs = []\n        self.fraction_checks = []\n        self.specimen_combos = []\n        self.scale_inputs = []\n        self.bgs_inputs = []\n        self.phase_combos = np.empty(shape=(0, 0), dtype=np.object_) # 2D list\n\n        self.on_size_requested()\n\n    def on_size_requested(self, *args):\n        sr = self.matrix.size_request()\n        self[self.top].set_size_request(sr.width + 100, -1)\n\n    def set_edit_view(self, view):\n        if self._on_sr_id is not None and self.child_view is not None:\n            self.child_view.disconnect(self._on_sr_id)\n        self.edit_view = view\n        self.child_view = view.get_top_widget()\n        self._add_child_view(self.child_view, self[self.edit_view_container])\n        if isinstance(self[self.edit_view_container], Gtk.ScrolledWindow):\n            sr = self.child_view.get_size_request()\n            self[self.edit_view_container].set_size_request(sr[0], -1)\n\n\n\n    def update_all(self, fractions, scales, bgs):\n        for i, fraction in enumerate(fractions):\n            if not i >= len(self.fraction_inputs):\n                self.fraction_inputs[i].set_text(str(fraction))\n        for i, scale in enumerate(scales):\n            if not i >= len(self.scale_inputs):\n                self.scale_inputs[i].set_text(str(scale))\n        for i, bgs in enumerate(bgs):\n            if not i >= len(self.bgs_inputs):\n                self.bgs_inputs[i].set_text(str(bgs))\n\n    def add_phase_slot(self, phase_store, del_phase_callback, label_callback, check_callback, fraction_callback, combo_callback, label, fraction, phases):\n        r, c = self.matrix.get_property(\'n_rows\'), self.matrix.get_property(\'n_columns\')\n        self.matrix.resize(r + 1, c)\n\n        del_icon = Gtk.Image.new()\n        del_icon.set_from_stock (""192-circle-remove"", Gtk.IconSize.SMALL_TOOLBAR)\n        new_phase_del_btn = Gtk.Button.new()\n        new_phase_del_btn.set_image(del_icon)\n        rid = new_phase_del_btn.connect(""clicked"", del_phase_callback)\n        setattr(new_phase_del_btn, ""deleventid"", rid)\n        self.matrix.attach(new_phase_del_btn, 0, 1, r, r + 1, Gtk.AttachOptions.FILL, 0)\n\n        new_phase_input = self._get_new_input(label, callback=label_callback)\n        self.phase_inputs.append(new_phase_input)\n        self.matrix.attach(new_phase_input, 1, 2, r, r + 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_fraction_check = self._get_new_check(callback=check_callback)\n        self.fraction_checks.append(new_fraction_check)\n        self.matrix.attach(new_fraction_check, 2, 3, r, r + 1, Gtk.AttachOptions.FILL, 0)\n\n        new_fraction_input = self._get_new_input(str(fraction), callback=fraction_callback)\n        FloatEntryValidator(new_fraction_input)\n        self.fraction_inputs.append(new_fraction_input)\n        self.matrix.attach(new_fraction_input, 3, 4, r, r + 1, Gtk.AttachOptions.FILL, 0)\n\n        self.phase_combos.resize((c - self.base_width, r + 1 - self.base_height))\n        for col in range(c - self.base_width):\n            mcol, mrow = r - self.base_height, col\n            self._add_new_phase_combo(phase_store, phase_store.c_name, phases[mrow, mcol], mrow, mcol, combo_callback)\n\n        self.wrapper.show_all()\n\n    def add_specimen_slot(self, phase_store, specimen_store, del_specimen_callback, scale_callback, bgs_callback, specimen_callback, combo_callback, scale, bgs, specimen, phases):\n        r, c = self.matrix.get_property(\'n_rows\'), self.matrix.get_property(\'n_columns\')\n        self.matrix.resize(r, c + 1)\n\n        del_icon = Gtk.Image.new()\n        del_icon.set_from_stock(""192-circle-remove"", Gtk.IconSize.SMALL_TOOLBAR)\n        new_specimen_del_btn = Gtk.Button.new()\n        new_specimen_del_btn.set_image(del_icon)\n        rid = new_specimen_del_btn.connect(""clicked"", del_specimen_callback)\n        setattr(new_specimen_del_btn, ""deleventid"", rid)\n        self.matrix.attach(new_specimen_del_btn, c, c + 1, 0, 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_specimen_combo = self._get_new_combo(specimen_store, specimen_store.c_name, default=specimen, callback=specimen_callback)\n        self.specimen_combos.append(new_specimen_combo)\n        self.matrix.attach(new_specimen_combo, c, c + 1, 1, 2, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_bgs_input = self._get_new_input(str(bgs), callback=bgs_callback)\n        FloatEntryValidator(new_bgs_input)\n        self.bgs_inputs.append(new_bgs_input)\n        self.matrix.attach(new_bgs_input, c, c + 1, 2, 3, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        new_scale_input = self._get_new_input(str(scale), callback=scale_callback)\n        FloatEntryValidator(new_scale_input)\n        self.scale_inputs.append(new_scale_input)\n        self.matrix.attach(new_scale_input, c, c + 1, 3, 4, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n        self.phase_combos.resize((c + 1 - self.base_width, r - self.base_height))\n        for row in range(r - self.base_height):\n            mcol, mrow = row, c - self.base_width\n            self._add_new_phase_combo(phase_store, phase_store.c_name, phases[mrow, mcol], mrow, mcol, combo_callback)\n        self.wrapper.show_all()\n\n    def _get_new_check(self, callback=None):\n        """"""\n            Creates a new toggle button.\n        """"""\n        new_check = Gtk.CheckButton.new()\n        new_check.set_active(True)\n        new_check.set_tooltip_text(""Tick this box if you want to include this fraction in optimizations and refinements"")\n        if callback is not None: new_check.connect(""toggled"", callback)\n        return new_check\n\n    def _get_new_input(self, text="""", width=7, callback=None):\n        """"""\n            Creates a new text input box.\n        """"""\n        new_input = Gtk.Entry.new()\n        new_input.set_text(text)\n        new_input.set_alignment(0.0)\n        new_input.set_width_chars(width)\n        if callback is not None: new_input.connect(""changed"", callback)\n        return new_input\n\n    def _add_new_phase_combo(self, model, text_column, default, r, c, callback):\n        """"""\n            Creates a new \'phase slot\' combo box, and adds it to the table at\n            the given row and column indices.\n        """"""\n        new_phase_combo = self._get_new_combo(model, text_column, default, callback, r, c)\n        self.phase_combos[r, c] = new_phase_combo\n        self.matrix.attach(new_phase_combo, self.base_width + r, self.base_width + r + 1, self.base_height + c, self.base_height + c + 1, Gtk.AttachOptions.EXPAND | Gtk.AttachOptions.FILL, 0)\n\n    def _get_new_combo(self, model, text_column, default, callback, *args):\n        """"""\n            Creates a new combo box with the given model as ListStore, setting\n            the given column as text column, the given default value set as \n            active row, and connecting the given callback with \'changed\' signal.\n        """"""\n        combobox = Gtk.ComboBox.new_with_model(model)\n        combobox.set_size_request(75, -1)\n        cell = Gtk.CellRendererText.new()\n        combobox.pack_start(cell, True)\n        combobox.add_attribute(cell, \'text\', text_column)\n        if default is not None:\n            index = model.on_get_path(default)[0]\n            combobox.set_active(index)\n        combobox.connect(""changed"", callback, *args)\n        return combobox\n\n    pass # end of class\n'"
pyxrd/phases/controllers/CSDS_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom mvc import Controller\n\nfrom pyxrd.generic.controllers import BaseController\n\nfrom pyxrd.phases.models.CSDS import CSDS_distribution_types\n\nclass EditCSDSTypeController(BaseController):\n    """""" \n        Controller for the selection of the type of CSDS Model\n    """"""\n    auto_adapt = False\n\n    distributions_controller = None\n\n    def reset_type_store(self):\n        if self.view is not None:\n            combo = self.view[""cmb_type""]\n            store = Gtk.ListStore(str, object) # @UndefinedVariable\n\n            for cls in CSDS_distribution_types:\n                store.append([cls.Meta.description, cls])\n            combo.set_model(store)\n\n            for row in store:\n                if type(self.model.CSDS_distribution) == store.get_value(row.iter, 1):\n                    combo.set_active_iter(row.iter)\n                    break\n            return store\n\n    def register_view(self, view):\n        self.view = view\n        combo = self.view[""cmb_type""]\n        combo.connect(\'changed\', self.on_changed)\n        cell = Gtk.CellRendererText() # @UndefinedVariable\n        combo.pack_start(cell, True)\n        combo.add_attribute(cell, \'markup\', 0)\n        self.reset_type_store()\n        self.reset_distributions_controller()\n\n    @BaseController.model.setter\n    def _set_model(self, model):\n        super(EditCSDSTypeController, self)._set_model(model)\n        self.reset_distributions_controller()\n\n\n    def reset_distributions_controller(self):\n        if self.view is not None:\n            if self.distributions_controller is None:\n                self.distributions_controller = EditCSDSDistributionController(\n                    model=self.model.CSDS_distribution,\n                    view=self.view,\n                    parent=self)\n            else:\n                self.distributions_controller.model = self.model.CSDS_distribution\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_changed(self, combo, user_data=None):\n        itr = combo.get_active_iter()\n        if itr is not None:\n            cls = combo.get_model().get_value(itr, 1)\n            if not type(self.model.CSDS_distribution) == cls:\n                new_csds_model = cls(parent=self.model)\n                self.model.CSDS_distribution = new_csds_model\n                self.distributions_controller.model = new_csds_model\n\n    pass # end of class\n\nclass EditCSDSDistributionController(BaseController):\n    """""" \n        Controller for the CSDS Models \n        Handles the creation of widgets based on the property descriptor settings\n    """"""\n\n    auto_adapt = False\n\n    def reset_view(self):\n        if self.view is not None:\n            self.view.reset_params()\n            for prop in self.model.Meta.all_properties:\n                if getattr(prop, ""refinable"", False):\n                    self.view.add_param_widget(\n                        self.view.widget_format % prop.label, prop.label,\n                        prop.minimum, prop.maximum\n                    )\n            self.view.update_figure(self.model.distrib[0])\n            self.register_adapters()\n            self.adapt()\n\n    def register_view(self, view):\n        if self.model is not None:\n            self.reset_view()\n\n    @BaseController.model.setter\n    def model(self, model):\n        super(EditCSDSDistributionController, self)._set_model(model)\n        self.reset_view()\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""updated"", signal=True)\n    def notif_updated(self, model, prop_name, info):\n        if self.model.distrib is not None and not self.model.phase.project.before_needs_update_lock:\n            try: self.view.update_figure(self.model.distrib[0])\n            except BaseException as error:\n                logger.exception(""Caught unhandled exception: %s"" % error)\n\n    pass # end of class\n'"
pyxrd/phases/controllers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .atom_relation_controllers import (\n    EditUnitCellPropertyController,\n    EditAtomRatioController,\n    EditAtomContentsController,\n    ContentsListController,\n    EditAtomRelationsController\n)\n\nfrom .CSDS_controllers import (\n    EditCSDSTypeController,\n    EditCSDSDistributionController\n)\n\nfrom .layer_controllers import EditLayerController\n\nfrom .component_controllers import (\n    ComponentsController,\n    EditComponentController\n)\n\nfrom .add_phase_controller import AddPhaseController\nfrom .edit_phase_controller import EditPhaseController\nfrom .raw_pattern_phase_controller import EditRawPatternPhaseController\nfrom .phases_controller import PhasesController'"
pyxrd/phases/controllers/add_phase_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, Gdk\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.adapters.gtk_support.treemodels.utils import create_treestore_from_directory\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.views.combobox_tools import add_combo_text_column\nfrom pyxrd.generic.controllers import DialogController\n\nfrom pyxrd.probabilities.models import get_Gbounds_for_R, get_Rbounds_for_G\n\nclass AddPhaseController(DialogController):\n    """""" \n        Controller for the add phase dialog\n    """"""\n\n    auto_adapt = False\n\n    def __init__(self, model=None, view=None, parent=None, callback=None):\n        super(AddPhaseController, self).__init__(\n            model=model, view=view, parent=parent)\n        self.callback = callback\n\n    def register_view(self, view):\n        self.update_bounds()\n        self.generate_combo()\n\n    def register_adapters(self):\n        pass # has no intel, or a model!\n\n    def update_R_bounds(self):\n        if self.view is not None:\n            min_R, max_R, R = get_Rbounds_for_G(\n                self.view.get_G(), self.view.get_R())\n            self.view[""adj_R""].set_upper(max_R)\n            self.view[""adj_R""].set_lower(min_R)\n            self.view[""R""].set_value(R)\n\n    def update_G_bounds(self):\n        if self.view is not None:\n            min_G, max_G, G = get_Gbounds_for_R(\n                self.view.get_R(), self.view.get_G())\n            self.view[""adj_G""].set_upper(max_G)\n            self.view[""adj_G""].set_lower(min_G)\n            self.view[""G""].set_value(G)\n\n    def update_bounds(self):\n        self.update_G_bounds()\n        self.update_R_bounds()\n\n    def generate_combo(self):\n        self.reload_combo_model()\n        add_combo_text_column(\n            self.view.phase_combo_box, text_col=0, sensitive_col=2)\n\n    def reload_combo_model(self):\n        cmb_model = create_treestore_from_directory(\n            settings.DATA_REG.get_directory_path(""DEFAULT_PHASES""))\n        self.view.phase_combo_box.set_model(cmb_model)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        self.view.hide()\n        self.callback(\n            self.view.get_phase_type(), self.view.get_G(), self.view.get_R())\n        return True\n\n    def on_rdb_toggled(self, widget):\n        self.view.update_sensitivities()\n\n    def on_btn_generate_phases_clicked(self, event):\n        from pyxrd.scripts.generate_default_phases import run\n        def ui_callback(progress):\n            self.view[""gen_progress_bar""].set_fraction(progress)\n            while Gtk.events_pending():\n                Gtk.main_iteration()\n        self.view[""img_repeat""].set_visible(False)\n        self.view[""gen_spinner""].start()\n        self.view[""gen_spinner""].set_visible(True)\n        self.view[""gen_progress_bar""].set_visible(True)\n        while Gtk.events_pending():\n            Gtk.main_iteration()\n        run(ui_callback=ui_callback)\n        self.view[""gen_progress_bar""].set_visible(False)\n        self.view[""img_repeat""].set_visible(True)\n        self.view[""gen_spinner""].stop()\n        self.view[""gen_spinner""].set_visible(False)\n        self.reload_combo_model()\n        return True\n\n    def on_r_value_changed(self, *args):\n        self.update_G_bounds()\n        return True\n\n    def on_g_value_changed(self, *args):\n        self.update_R_bounds()\n        return True\n\n    def on_keypress(self, widget, event):\n        if event.keyval == Gdk.keyval_from_name(""Escape""):\n            self.view.hide()\n            return True\n        if event.keyval == Gdk.keyval_from_name(""Enter""):\n            self.view.hide()\n            self.callback(\n                self.view.get_phase_type(), self.view.get_G(), self.view.get_R())\n            return True\n\n    def on_window_edit_dialog_delete_event(self, event, args=None):\n        self.view.hide()\n        return True # do not propagate\n\n    pass # end of class'"
pyxrd/phases/controllers/atom_relation_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, Pango\n\nfrom pyxrd.generic.views.treeview_tools import (\n    new_text_column,\n    new_pb_column,\n    new_combo_column,\n    create_float_data_func,\n    setup_treeview\n)\nfrom pyxrd.generic.views.combobox_tools import add_combo_text_column\nfrom pyxrd.generic.views import InlineObjectListStoreView\nfrom pyxrd.generic.controllers import (\n    DialogController,\n    InlineObjectListStoreController,\n    BaseController,\n)\n\nfrom pyxrd.phases.views import EditAtomRatioView, EditAtomContentsView\nfrom pyxrd.phases.models.atom_relations import AtomRelation, AtomRatio, AtomContents, AtomContentObject\n\nclass AtomComboMixin(object):\n\n    extra_props = []\n    custom_handler_names = []\n\n    def reset_combo_box(self, name):\n        if self.model.component is not None:\n            # Get store, reset combo\n            store = self.model.create_prop_store(self.extra_props)\n            combo = self.view[self.view.widget_format % name]\n            combo.clear()\n            combo.set_model(store)\n\n            # Add text column:\n            def get_name(layout, cell, model, itr, data=None):\n                obj, lbl = model.get(itr, 0, 2)\n                if callable(lbl): lbl = lbl(obj)\n                cell.set_property(""markup"", lbl)\n            add_combo_text_column(combo, data_func=get_name)\n\n            # Set the selected item to active:\n            prop = getattr(self.model, name)\n            if prop is not None:\n                prop = tuple(prop)\n                for row in store:\n                    if tuple(store.get(row.iter, 0, 1)) == prop:\n                        combo.set_active_iter(row.iter)\n                        break\n\n            return combo, store\n        else:\n            return None, None\n\n    @staticmethod\n    def custom_handler(controller, prop, prefix):\n        if prop.label in controller.custom_handler_names:\n            combo, store = controller.reset_combo_box(prop.label) # @UnusedVariable\n\n            if combo is not None and store is not None:\n                def on_changed(combo, user_data=None):\n                    itr = combo.get_active_iter()\n                    if itr is not None:\n                        val = combo.get_model().get(itr, 0, 1)\n                        setattr(controller.model, getattr(combo, \'model_prop\'), val)\n                setattr(combo, \'model_prop\', prop.label)\n                combo.connect(\'changed\', on_changed)\n\n                def on_item_changed(*args):\n                    controller.reset_combo_box(prop.label)\n\n                if controller.is_observing_method(""atoms_changed"", on_item_changed):\n                    controller.remove_observing_method(""atoms_changed"", on_item_changed)\n                controller.observe(on_item_changed, ""atoms_changed"", signal=True)\n\n        else: return False\n        return True\n\n    pass # end of class\n\nclass EditUnitCellPropertyController(BaseController, AtomComboMixin):\n    """""" \n        Controller for the UnitCellProperty models (a and b cell lengths)\n    """"""\n\n    custom_handler_names = [""prop"", ]\n    widget_handlers = {\n        \'combo\': \'custom_handler\',\n    }\n\n    def __init__(self, extra_props, **kwargs):\n        super(EditUnitCellPropertyController, self).__init__(**kwargs)\n        self.extra_props = extra_props\n\n    def register_adapters(self):\n        BaseController.register_adapters(self)\n        self.update_sensitivities()\n\n    def update_sensitivities(self):\n        self.view[\'ucp_value\'].set_sensitive(not self.model.enabled)\n        self.view[\'box_enabled\'].set_sensitive(self.model.enabled)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @BaseController.observe(""enabled"", assign=True)\n    def notif_enabled_changed(self, model, prop_name, info):\n        self.update_sensitivities()\n\n    pass # end of class\n\nclass EditAtomRatioController(DialogController, AtomComboMixin):\n    """""" \n        Controller for the atom ratio edit dialog\n    """"""\n    custom_handler_names = [""atom1"", ""atom2""]\n    widget_handlers = {\n        \'custom\': \'custom_handler\',\n    }\n\n    pass # end of class\n\nclass EditAtomContentsController(DialogController):\n    """""" \n        Controller for the atom contents edit dialog\n    """"""\n    \n    auto_adapt_excluded = [\n        ""atom_contents"",\n    ]\n\n    contents_list_view = None\n    contents_list_controller = None\n\n    def __init__(self, *args, **kwargs):\n        super(EditAtomContentsController, self).__init__(*args, **kwargs)\n        # Create atom contents controller:\n        self.contents_list_view = InlineObjectListStoreView(parent=self.view)\n        self.contents_list_controller = ContentsListController(""atom_contents"", model=self.model, view=self.contents_list_view, parent=self)\n        # Set subview:\n        self.view.set_contents_list_view(self.contents_list_view.get_top_widget())\n\n    pass # end of class\n\nclass ContentsListController(InlineObjectListStoreController):\n    """""" \n        Controller for the atom contents ListStore\n    """"""\n    new_val = None\n    auto_adapt = False # FIXME\n\n    treemodel_class_type = AtomContentObject\n\n    def _reset_treeview(self, tv, model):\n        setup_treeview(tv, model, sel_mode=\'MULTIPLE\', reset=True)\n        tv.set_model(model)\n\n        # Atom column:\n        self.combo_model = self.model.create_prop_store()\n        self.combo_model2 = Gtk.ListStore(str)\n        for row in self.combo_model:\n            self.combo_model2.append(row[2:3])\n              \n        def atom_renderer(column, cell, model, itr, *args):\n            obj = model.get_value(itr, 0)\n            if hasattr(obj, ""name""):\n                cell.set_property(\'text\', obj.name)\n            else:\n                cell.set_property(\'text\', \'#NA#\')      \n        \n        tv.append_column(new_combo_column(\n            ""Atoms"",\n            data_func=atom_renderer,\n            changed_callback=self.on_atom_changed,\n            edited_callback=self.on_atom_edited,\n            xalign=0.0,\n            expand=False,\n            has_entry=False,\n            model=self.combo_model2,\n            text_column=0,\n            editable=True))\n\n        # Content column:\n        def on_float_edited(rend, path, new_text, col):\n            itr = model.get_iter(path)\n            try:\n                model.set_value(itr, col, float(new_text))\n            except ValueError:\n                logger.exception(""Invalid value entered (\'%s\')!"" % new_text)\n            return True\n        tv.append_column(new_text_column(\'Default contents\', text_col=2, xalign=0.0,\n            editable=True,\n            data_func=create_float_data_func(),\n            edited_callback=(on_float_edited, (2,))))\n\n    def _setup_treeview(self, tv, model):\n        self._reset_treeview(tv, model)\n\n    def __init__(self, treemodel_property_name, **kwargs):\n        super(ContentsListController, self).__init__(\n            treemodel_property_name=treemodel_property_name,\n            enable_import=False, enable_export=False, **kwargs\n        )\n\n    def create_new_object_proxy(self):\n        return AtomContentObject(None, None, 1.0)\n\n    def on_atom_changed(self, combo, path, new_iter):\n        # translate dummy iter to real iter:\n        new_iter = self.combo_model.get_iter(self.combo_model2.get_path(new_iter))\n        self.new_val = self.combo_model.get(new_iter, 0, 1)\n        pass\n\n    def on_atom_edited(self, combo, path, new_text, model=None):\n        if self.new_val:\n            new_atom, new_prop = self.new_val\n            self.model.set_atom_content_values(path, new_atom, new_prop)\n            self.new_val = None\n        return True\n\n\n    pass # end of class\n\nclass EditAtomRelationsController(InlineObjectListStoreController):\n    """""" \n        Controller for the components\' atom relations ObjectListStore\n    """"""\n    file_filters = AtomRelation.Meta.file_filters\n    auto_adapt = False\n    treemodel_class_type = AtomRelation\n\n    add_types = [\n        (""Ratio"", AtomRatio, EditAtomRatioView, EditAtomRatioController),\n        (""Contents"", AtomContents, EditAtomContentsView, EditAtomContentsController),\n    ]\n\n    def _reset_treeview(self, tv, model):\n        setup_treeview(tv, model, sel_mode=\'MULTIPLE\', reset=True)\n        tv.set_model(model)\n\n        # Name column:\n        def text_renderer(column, cell, model, itr, args=None):\n            driven_by_other = model.get_value(itr, model.c_driven_by_other)\n            cell.set_property(\'editable\', not driven_by_other)\n            cell.set_property(\'style\', Pango.Style.ITALIC if driven_by_other else Pango.Style.NORMAL)\n        col = new_text_column(\n            \'Name\',\n            data_func=text_renderer,\n            editable=True,\n            edited_callback=(self.on_item_cell_edited, (model, model.c_name)),\n            resizable=False,\n            text_col=model.c_name)\n        setattr(col, ""col_descr"", \'Name\')\n        tv.append_column(col)\n\n        # Value of the relation:\n        float_rend = create_float_data_func()\n        def data_renderer(column, cell, model, itr, args=None):\n            text_renderer(column, cell, model, itr, args)\n            float_rend(column, cell, model, itr, args)\n        col = new_text_column(\n            \'Value\',\n            data_func=data_renderer,\n            editable=True,\n            edited_callback=(self.on_item_cell_edited, (model, model.c_value)),\n            resizable=False,\n            text_col=model.c_value)\n        setattr(col, ""col_descr"", \'Value\')\n        tv.append_column(col)\n\n        # Up, down and edit arrows:\n        def setup_image_button(image, colnr):\n            col = new_pb_column("" "", resizable=False, expand=False, stock_id=image)\n            setattr(col, ""col_descr"", colnr)\n            tv.append_column(col)\n        setup_image_button(""213-up-arrow"", ""Up"")\n        setup_image_button(""212-down-arrow"", ""Down"")\n        setup_image_button(""030-pencil"", ""Edit"")\n\n    def _setup_treeview(self, tv, model):\n        tv.connect(\'button-press-event\', self.tv_button_press)\n        self._reset_treeview(tv, model)\n\n    def __init__(self, **kwargs):\n        super(EditAtomRelationsController, self).__init__(\n            enable_import=False, enable_export=False, **kwargs)\n\n    def create_new_object_proxy(self):\n        return self.add_type(parent=self.model)\n\n    def tv_button_press(self, tv, event):\n        relation = None\n        ret = tv.get_path_at_pos(int(event.x), int(event.y))\n\n        if ret is not None:\n            path, col, x, y = ret\n            model = tv.get_model()\n            relation = model.get_user_data_from_path(path)\n            column = getattr(col, ""col_descr"")\n        if event.button == 1 and relation is not None:\n            column = getattr(col, ""col_descr"")\n            if column == ""Edit"":\n                self._edit_item(relation)\n                return True\n            elif column == ""Up"":\n                self.model.move_atom_relation_up(relation)\n                return True\n            elif column == ""Down"":\n                self.model.move_atom_relation_down(relation)\n                return True\n\n\n    pass # end of class\n'"
pyxrd/phases/controllers/component_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nlogger = logging.getLogger(__name__)\n\nfrom mvc import Controller\nfrom mvc.adapters.dummy_adapter import DummyAdapter\n\nfrom pyxrd.generic.views import InlineObjectListStoreView\nfrom pyxrd.generic.views.combobox_tools import add_combo_text_column\nfrom pyxrd.generic.controllers import BaseController, ChildObjectListStoreController\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\n\nfrom pyxrd.phases.controllers import EditLayerController, EditAtomRelationsController, EditUnitCellPropertyController\nfrom pyxrd.phases.views import EditComponentView, EditUnitCellPropertyView\nfrom pyxrd.phases.models import Phase, Component\nfrom pyxrd.generic.controllers.objectliststore_controllers import wrap_list_property_to_treemodel\n\nclass EditComponentController(BaseController):\n    """""" \n        Controller for the component edit view\n    """"""\n    layer_view = None\n    layer_controller = None\n\n    interlayer_view = None\n    interlayer_controller = None\n\n    atom_relations_view = None\n    atom_relations_controller = None\n\n    ucpa_view = None\n    ucpa_controller = None\n\n    ucpb_view = None\n    ucpb_controller = None\n\n    widget_handlers = {\n        \'custom\': \'custom_handler\',\n    }\n\n    @property\n    def components_treemodel(self):\n        if self.model.phase.based_on:\n            return wrap_list_property_to_treemodel(\n                self.model.phase.based_on, Phase.components\n            )\n        else:\n            return None\n\n    def reset_combo_box(self):\n        """"""\n            Reset the `linked_with` combo box.\n        """"""\n        if self.model is not None and self.model.parent is not None:\n            combo = self.view[""component_linked_with""]\n            combo.clear()\n            combo.set_model(self.components_treemodel)\n            if self.components_treemodel is not None:\n                add_combo_text_column(combo, text_col=self.components_treemodel.c_name)\n                for row in self.components_treemodel:\n                    comp = self.components_treemodel.get_user_data(row.iter)\n                    if comp == self.model.linked_with:\n                        combo.set_active_iter (row.iter)\n                        break\n\n    @staticmethod\n    def custom_handler(self, prop, widget):\n        if prop.label == ""layer_atoms"":\n            self.view.set_layer_view(self.layer_view.get_top_widget())\n        elif prop.label == ""interlayer_atoms"":\n            self.view.set_interlayer_view(self.interlayer_view.get_top_widget())\n        elif prop.label == ""atom_relations"":\n            self.view.set_atom_relations_view(self.atom_relations_view.get_top_widget())\n        elif prop.label in (""ucp_a"", ""ucp_b""):\n            self.view.set_ucpa_view(self.ucpa_view.get_top_widget())\n            self.view.set_ucpb_view(self.ucpb_view.get_top_widget())\n        elif prop.label == ""linked_with"":\n            self.reset_combo_box()\n        return DummyAdapter(controller=self, prop=prop)\n\n    def register_view(self, view):\n        super(EditComponentController, self).register_view(view)\n\n        self.layer_view = InlineObjectListStoreView(parent=view)\n        self.layer_controller = EditLayerController(treemodel_property_name=""layer_atoms"", model=self.model, view=self.layer_view, parent=self)\n\n        self.interlayer_view = InlineObjectListStoreView(parent=view)\n        self.interlayer_controller = EditLayerController(treemodel_property_name=""interlayer_atoms"", model=self.model, view=self.interlayer_view, parent=self)\n\n        self.atom_relations_view = InlineObjectListStoreView(parent=view)\n        self.atom_relations_controller = EditAtomRelationsController(treemodel_property_name=""atom_relations"", model=self.model, view=self.atom_relations_view, parent=self)\n\n        self.ucpa_view = EditUnitCellPropertyView(parent=view)\n        self.ucpa_controller = EditUnitCellPropertyController(extra_props=[(self.model, ""cell_b"", ""B cell length""), ], model=self.model._ucp_a, view=self.ucpa_view, parent=self)\n\n        self.ucpb_view = EditUnitCellPropertyView(parent=view)\n        self.ucpb_controller = EditUnitCellPropertyController(extra_props=[(self.model, ""cell_a"", ""A cell length""), ], model=self.model._ucp_b, view=self.ucpb_view, parent=self)\n\n    def register_adapters(self):\n        self.update_sensitivities()\n\n    def update_sensitivities(self):\n        can_inherit = (self.model.linked_with is not None)\n\n        def update(widget, name):\n            self.view[widget].set_sensitive(not (can_inherit and getattr(self.model, ""inherit_%s"" % name)))\n            self.view[widget].set_visible(not (can_inherit and getattr(self.model, ""inherit_%s"" % name)))\n            self.view[""component_inherit_%s"" % name].set_sensitive(can_inherit)\n        for name in (""default_c"", ""delta_c"", ""d001""):\n            update(""container_%s"" % name, name)\n        for name in (""interlayer_atoms"", ""layer_atoms"", ""atom_relations"", ""ucp_a"", ""ucp_b""):\n            update(self.view.widget_format % name, name)\n\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""inherit_layer_atoms"", assign=True)\n    @Controller.observe(""inherit_interlayer_atoms"", assign=True)\n    @Controller.observe(""inherit_atom_relations"", assign=True)\n    @Controller.observe(""inherit_ucp_a"", assign=True)\n    @Controller.observe(""inherit_ucp_b"", assign=True)\n    @Controller.observe(""inherit_d001"", assign=True)\n    @Controller.observe(""inherit_default_c"", assign=True)\n    @Controller.observe(""inherit_delta_c"", assign=True)\n    def notif_change_inherit(self, model, prop_name, info):\n        self.update_sensitivities()\n\n    @Controller.observe(""linked_with"", assign=True)\n    def notif_linked_with_changed(self, model, prop_name, info):\n        self.reset_combo_box()\n\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_linked_with_changed(self, combo, user_data=None):\n        itr = combo.get_active_iter()\n        if itr is not None:\n            val = combo.get_model().get_user_data(itr)\n            self.model.linked_with = val\n            self.update_sensitivities()\n            return\n        combo.set_active(-1)\n        self.update_sensitivities()\n        self.model.linked_with = None\n\nclass ComponentsController(ChildObjectListStoreController):\n    """""" \n        Controller for the components ObjectListStore\n    """"""\n    treemodel_property_name = ""components""\n    treemodel_class_type = Component\n    columns = [ (""Component name"", ""c_name"") ]\n    delete_msg = ""Deleting a component is irreversible!\\nAre You sure you want to continue?""\n    file_filters = [(""Component file"", get_case_insensitive_glob(""*.CMP"")), ]\n    obj_type_map = [\n        (Component, EditComponentView, EditComponentController),\n    ]\n\n    def load_components(self, filename):\n        old_comps = self.get_selected_objects()\n        if old_comps:\n            num_oc = len(old_comps)\n            new_comps = list()\n            for comp in Component.load_components(filename, parent=self.model):\n                comp.resolve_json_references()\n                new_comps.append(comp)\n            num_nc = len(new_comps)\n            if num_oc != num_nc:\n                DialogFactory.get_information_dialog(\n                    ""The number of components to import must equal the number of selected components!""\n                ).run()\n                return\n            else:\n                self.select_object(None)\n                logger.info(""Importing components..."")\n                # replace component(s):\n                for old_comp, new_comp in zip(old_comps, new_comps):\n                    i = self.model.components.index(old_comp)\n                    self.model.components[i] = new_comp\n        else:\n            DialogFactory.get_information_dialog(\n                ""No components selected to replace!""\n            ).run()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_save_object_clicked(self, event):\n        def on_accept(dialog):\n            logger.info(""Exporting components..."")\n            Component.save_components(self.get_selected_objects(), filename=dialog.filename)\n        DialogFactory.get_save_dialog(\n            ""Export components"", parent=self.view.get_toplevel(),\n            filters=self.file_filters\n         ).run(on_accept)\n        return True\n\n    def on_load_object_clicked(self, event):\n        def on_accept(dialog):\n            self.load_components(dialog.filename)\n        DialogFactory.get_load_dialog(\n            ""Import components"", parent=self.view.get_toplevel(),\n            filters=self.file_filters\n        ).run(on_accept)\n        return True\n    \n    pass #end of class\n'"
pyxrd/phases/controllers/edit_phase_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc import Controller\nfrom mvc.adapters.dummy_adapter import DummyAdapter\n\nfrom pyxrd.generic.views import ChildObjectListStoreView\nfrom pyxrd.generic.views.combobox_tools import add_combo_text_column\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.controllers.objectliststore_controllers import wrap_list_property_to_treemodel\n\nfrom pyxrd.probabilities.controllers import EditProbabilitiesController\nfrom pyxrd.probabilities.views import EditProbabilitiesView\n\nfrom pyxrd.phases.controllers import (\n    EditCSDSTypeController, ComponentsController\n)\nfrom pyxrd.phases.views import EditCSDSDistributionView\n\nclass EditPhaseController(BaseController):\n    """""" \n        Controller for the phase edit view\n    """"""\n    probabilities_view = None\n    probabilities_controller = None\n\n    csds_view = None\n    csds_controller = None\n\n    components_view = None\n    components_controller = None\n\n    widget_handlers = {\n        \'custom\': \'custom_handler\',\n    }\n\n    @property\n    def phases_treemodel(self):\n        if self.model.project is not None:\n            return wrap_list_property_to_treemodel(\n                self.model.project, type(self.model.project).phases)\n        else:\n            return None\n\n    def register_view(self, view):\n        BaseController.register_view(self, view)\n\n        self.csds_view = EditCSDSDistributionView(parent=self.view)\n        self.view.set_csds_view(self.csds_view)\n\n        if self.model.G > 1:\n            self.probabilities_view = EditProbabilitiesView(parent=self.view)\n            self.view.set_probabilities_view(self.probabilities_view)\n        else:\n            self.view.remove_probabilities()\n\n        self.components_view = ChildObjectListStoreView(parent=self.view)\n        self.components_view[""button_add_object""].set_visible(False)\n        self.components_view[""button_add_object""].set_no_show_all(True)\n        self.components_view[""button_del_object""].set_visible(False)\n        self.components_view[""button_del_object""].set_no_show_all(True)\n        self.view.set_components_view(self.components_view)\n\n    @staticmethod\n    def custom_handler(self, prop, widget): # TODO split out these 4 properties in their own adapters\n        if prop.label in (""CSDS_distribution"", ""components"", ""probabilities"", ""based_on""):\n            if prop.label == ""CSDS_distribution"":\n                self.reset_csds_controller()\n            elif prop.label == ""components"":\n                self.reset_components_controller()\n            elif prop.label == ""probabilities"":\n                self.reset_probabilities_controller()\n            elif prop.label == ""based_on"" and self.phases_treemodel is not None:\n                combo = self.view[""phase_based_on""]\n\n                combo.set_model(self.phases_treemodel)\n                combo.connect(\'changed\', self.on_based_on_changed)\n\n                def phase_renderer(celllayout, cell, model, itr, user_data=None):\n                    phase = model.get_user_data(itr)\n                    if phase: # FIXME an error can occur here if the phase list is cleared and the view is still open\n                        cell.set_sensitive(phase.R == self.model.R and phase.G == self.model.G and phase.get_based_on_root() != self.model)\n                add_combo_text_column(combo, data_func=phase_renderer, text_col=self.phases_treemodel.c_name)\n\n                for row in self.phases_treemodel:\n                    if self.phases_treemodel.get_user_data(row.iter) == self.model.based_on:\n                        combo.set_active_iter (row.iter)\n                        break\n\n            return DummyAdapter(controller=self, prop=prop)\n\n    def reset_csds_controller(self):\n        if self.csds_controller is None:\n            self.csds_controller = EditCSDSTypeController(\n                model=self.model, view=self.csds_view, parent=self)\n        else:\n            self.csds_controller.model = self.model\n\n    def reset_components_controller(self):\n        self.components_controller = ComponentsController(\n            model=self.model, view=self.components_view, parent=self)\n\n    def reset_probabilities_controller(self):\n        if self.probabilities_controller is None:\n            if self.model.G > 1: # False if model is a multi-component phase\n                self.probabilities_controller = EditProbabilitiesController(\n                    model=self.model.probabilities,\n                    view=self.probabilities_view, parent=self)\n        else:\n            self.probabilities_controller.model = self.model.probabilities\n\n    def register_adapters(self):\n        self.update_sensitivities()\n\n    def update_sensitivities(self):\n        can_inherit = (self.model.based_on is not None)\n\n        for name in (""sigma_star"", ""display_color""):\n            widget_name = ""container_%s"" % name\n            self.view[widget_name].set_sensitive(not (can_inherit and getattr(self.model, ""inherit_%s"" % name)))\n            self.view[widget_name].set_visible(not (can_inherit and getattr(self.model, ""inherit_%s"" % name)))\n            self.view[""phase_inherit_%s"" % name].set_sensitive(can_inherit)\n\n        for name in (""CSDS_distribution"",):\n            sensitive = not (can_inherit and getattr(self.model, ""inherit_%s"" % name))\n            self.view[""phase_inherit_%s"" % name].set_sensitive(can_inherit)\n            self.view.set_csds_sensitive(sensitive)\n            self.reset_csds_controller()\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""inherit_display_color"", assign=True)\n    @Controller.observe(""inherit_sigma_star"", assign=True)\n    @Controller.observe(""inherit_CSDS_distribution"", assign=True)\n    def notif_change_inherit(self, model, prop_name, info):\n        self.update_sensitivities()\n        return\n\n    @Controller.observe(""probabilities"", assign=True)\n    def notif_change_probabilities(self, model, prop_name, info):\n        self.reset_probabilities_controller()\n        return\n\n    @Controller.observe(""name"", assign=True)\n    def notif_name_changed(self, model, prop_name, info):\n        self.phases_treemodel.on_item_changed(self.model)\n        return\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_based_on_changed(self, combo, user_data=None):\n        itr = combo.get_active_iter()\n        if itr is not None:\n            val = combo.get_model().get_user_data(itr)\n            # cannot be based on itself == not based on anything\n            # cannot be based on a model with a different # of components\n            if val != self.model and val.get_based_on_root() != self.model and val.G == self.model.G:\n                self.model.based_on = val\n                self.update_sensitivities()\n                return\n        combo.set_active(-1)\n        self.update_sensitivities()\n        self.model.based_on = None\n'"
pyxrd/phases/controllers/layer_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.views.treeview_tools import new_text_column, new_combo_column, create_float_data_func, setup_treeview\nfrom pyxrd.generic.controllers.objectliststore_controllers import wrap_list_property_to_treemodel\nfrom pyxrd.generic.controllers import InlineObjectListStoreController\n\nfrom pyxrd.atoms.models import Atom\nfrom pyxrd.project.models import Project\n\nclass EditLayerController(InlineObjectListStoreController):\n    """""" \n        Controller for the (inter)layer atom ObjectListStores\n    """"""\n    auto_adapt = False\n    enable_import = True\n    enable_export = True\n    treemodel_class_type = Atom\n    file_filters = Atom.Meta.layer_filters\n    new_atom_type = None\n\n    @property\n    def atom_types_treemodel(self):\n        return wrap_list_property_to_treemodel(\n            self.model.phase.project, Project.atom_types)\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def _setup_treeview(self, tv, model):\n        setup_treeview(tv, model, sel_mode=\'MULTIPLE\', reset=True)\n        tv.set_model(model)\n\n        # Add Atom name, default z, calculated z and #:\n        def add_text_col(title, colnr, is_float=True, editable=True):\n            tv.append_column(new_text_column(\n                title,\n                data_func=create_float_data_func() if is_float else None,\n                editable=editable,\n                edited_callback=(self.on_item_cell_edited, (model, colnr)) if editable else None,\n                resizable=True,\n                text_col=colnr))\n        add_text_col(\'Atom name\', model.c_name, is_float=False)\n        add_text_col(\'Def. Z (nm)\', model.c_default_z)\n        add_text_col(\'Calc. Z (nm)\', model.c_z, editable=False)\n        add_text_col(\'#\', model.c_pn)\n\n        # Add atom type column (combo box with atom types from pyxrd.project level):\n        def atom_type_renderer(column, cell, model, itr, col=None):\n            try:\n                name = model.get_user_data_from_path(model.get_path(itr)).atom_type.name\n            except:\n                name = \'#NA#\'\n            cell.set_property(\'text\', name)\n            return\n        def adjust_combo(cell, editable, path, data=None):\n            editable.set_wrap_width(10)\n        tv.append_column(new_combo_column(\n            ""Element"",\n            data_func=(atom_type_renderer, (3,)),\n            changed_callback=self.on_atom_type_changed,\n            edited_callback=(self.on_atom_type_edited, (model,)),\n            editing_started_callback=adjust_combo,\n            model=self.atom_types_treemodel,\n            text_column=self.atom_types_treemodel.c_name,\n            editable=True,\n            has_entry=True))\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def create_new_object_proxy(self):\n        return Atom(name=""New Atom"", parent=self.model)\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_save_object_clicked(self, widget, user_data=None):\n        def on_accept(save_dialog):\n            Atom.save_as_csv(save_dialog.filename, self.get_all_objects())\n        current_name = ""%s%s"" % (\n            self.model.name.lower(),\n            self.treemodel_property_name.replace(""data"", """").lower()\n        )\n        DialogFactory.get_save_dialog(\n            ""Export atoms"", parent=self.view.get_toplevel(),\n            current_name=current_name, filters=self.file_filters,\n        ).run(on_accept)\n\n    def on_load_object_clicked(self, widget, user_data=None):\n        def import_layer(dialog):\n            def on_accept(dialog):\n                del self.treemodel_data[:] # clears the list\n                Atom.get_from_csv(dialog.filename, self.treemodel_data.append, self.model)\n            DialogFactory.get_load_dialog(\n                ""Import atoms"", parent=self.view.get_toplevel(),\n                filters=self.file_filters\n            ).run(on_accept)\n        DialogFactory.get_confirmation_dialog(\n            message=""Are you sure?\\nImporting a layer file will clear the current list of atoms!"",\n            parent=self.view.get_toplevel()\n        ).run(import_layer)\n\n    def on_atom_type_changed(self, combo, path, new_iter, user_data=None):\n        """"""Called when the user selects an AtomType from the combo box""""""\n        self.new_atom_type = self.atom_types_treemodel.get_user_data(new_iter)\n        return True\n\n    def on_atom_type_edited(self, combo, path, new_text, user_data=None):\n        """"""Called when the user has closed the AtomType combo box \n        (so after the on_atom_type_changed call)""""""\n        atom = self.treemodel_data[int(path)]\n        if atom is not None:\n            # If new_atom_type is not set, but the user has typed in the name\n            # of an atom_type, find it (index search):\n            if self.new_atom_type is None and not new_text in (None, """"):\n                for atom_type in self.model.phase.project.atom_types:\n                    if atom_type.name == new_text:\n                        self.new_atom_type = atom_type\n            # Set the new atom type if it is not None:\n            if self.new_atom_type is not None:\n                atom.atom_type = self.new_atom_type\n            # Clear variable and leave\n            self.new_atom_type = None\n            return True\n        return False\n\n    pass # end of class\n'"
pyxrd/phases/controllers/phases_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom contextlib import contextmanager\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc import Model\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\n\nfrom pyxrd.generic.views.treeview_tools import new_text_column\nfrom pyxrd.generic.controllers import ObjectListStoreController\nfrom pyxrd.generic.utils import not_none\n\nfrom pyxrd.phases.views import (\n    EditPhaseView, AddPhaseView, EditRawPatternPhaseView\n)\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\nfrom pyxrd.file_parsers.phase_parsers import phase_parsers\n\nfrom ..models import Phase, RawPatternPhase\n\nfrom .edit_phase_controller import EditPhaseController\nfrom .raw_pattern_phase_controller import EditRawPatternPhaseController\nfrom .add_phase_controller import AddPhaseController\n\n\nclass PhasesController(ObjectListStoreController):\n    """""" \n        Controller for the phases list\n    """"""\n    file_filters = Phase.Meta.file_filters\n    treemodel_property_name = ""phases""\n    treemodel_class_type = Phase\n    obj_type_map = [\n        (Phase, EditPhaseView, EditPhaseController),\n        (RawPatternPhase, EditRawPatternPhaseView, EditRawPatternPhaseController),\n    ]\n    multi_selection = True\n    columns = [\n        (""Phase name"", ""c_name""),\n        ("" "", ""c_display_color""),\n        (""R"", ""c_R""),\n        (""#"", ""c_G""),\n    ]\n    delete_msg = ""Deleting a phase is irreversible!\\nAre You sure you want to continue?""\n    title = ""Edit Phases""\n\n    def get_phases_tree_model(self, *args):\n        return self.treemodel\n\n    def load_phases(self, filename, parser=JSONParser):\n        index = self.get_selected_index()\n        if index is not None: index += 1\n        self.model.load_phases(filename, parser=parser, insert_index=index)\n\n    def setup_treeview_col_c_display_color(self, treeview, name, col_descr, col_index, tv_col_nr):\n        def set_background(column, cell_renderer, tree_model, iter, col_index):\n            try:\n                color = tree_model.get_value(iter, col_index)\n            except TypeError:\n                pass  # invalid iter\n            else:\n                cell_renderer.set_property(\'background\', color)\n                cell_renderer.set_property(\'text\', """")\n\n        treeview.append_column(new_text_column(\n            name,\n            data_func=(set_background, (col_index,)),\n            text_col=col_index,\n            resizable=False,\n            expand=False))\n\n        return True\n\n    def create_new_object_proxy(self):\n        def on_accept(phase_type, G, R):\n            index = int(not_none(self.get_selected_index(), -1)) + 1\n            if phase_type == ""empty"":\n                self.add_object(Phase(G=int(G), R=int(R)))\n            elif phase_type == ""raw"":\n                self.add_object(RawPatternPhase())\n            else:\n                filename = phase_type\n                if filename != None:\n                    self.model.load_phases(filename, parser=JSONParser, insert_index=index)\n\n        # TODO re-use this and reset the COMBO etc.\n        self.add_model = Model()\n        self.add_view = AddPhaseView(parent=self.view)\n        self.add_ctrl = AddPhaseController(\n            model=self.add_model, view=self.add_view, parent=self.parent,\n            callback=on_accept\n        )\n\n        self.add_view.present()\n        return None\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.hold_mixtures_data_changed():\n            with self.model.hold_mixtures_needs_update():\n                with self.model.hold_phases_data_changed():\n                    yield\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_save_object_clicked(self, event):\n        def on_accept(dialog):\n            logger.info(""Exporting phases..."")\n            Phase.save_phases(self.get_selected_objects(), filename=dialog.filename)\n        DialogFactory.get_save_dialog(\n            ""Export phase"", parent=self.view.get_top_widget(),\n            filters=phase_parsers.get_export_file_filters()\n        ).run(on_accept)\n        return True\n\n\n    def on_load_object_clicked(self, event):\n        def on_accept(dialog):\n            logger.info(""Importing phases..."")\n            self.load_phases(dialog.filename, parser=dialog.parser)\n        DialogFactory.get_load_dialog(\n            ""Import phase"", parent=self.view.get_top_widget(),\n            filters=phase_parsers.get_import_file_filters()\n        ).run(on_accept)\n        return True\n'"
pyxrd/phases/controllers/raw_pattern_phase_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, locale\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc.adapters.gtk_support.tree_view_adapters import wrap_xydata_to_treemodel, \\\n    wrap_list_property_to_treemodel\n\nfrom pyxrd.generic.controllers import BaseController\nfrom pyxrd.generic.controllers.objectliststore_controllers import TreeViewMixin\nfrom pyxrd.generic.views.treeview_tools import setup_treeview, new_text_column\n\nfrom ..models import RawPatternPhase\n\nclass EditRawPatternPhaseController(TreeViewMixin, BaseController):\n    """""" \n        Controller for the phase edit view\n    """"""\n\n    file_filters = RawPatternPhase.Meta.rp_filters\n    rp_export_filters = RawPatternPhase.Meta.rp_export_filters\n\n    widget_handlers = {\n        \'custom\': \'custom_handler\',\n    }\n\n    @property\n    def phases_treemodel(self):\n        if self.model.project is not None:\n            prop = self.model.project.Meta.get_prop_intel_by_name(""phases"")\n            return wrap_list_property_to_treemodel(self.model.project, prop)\n        else:\n            return None\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    @staticmethod\n    def custom_handler(self, intel, widget):\n        pass # nothing to do\n\n    def setup_raw_pattern_tree_view(self, store, widget):\n        """"""\n            Creates the raw pattern TreeView layout and behavior\n        """"""\n\n        setup_treeview(widget, store,\n            on_cursor_changed=self.on_raw_pattern_tv_cursor_changed,\n            sel_mode=\'MULTIPLE\')\n        # X Column:\n        widget.append_column(new_text_column(\n            \'\xc2\xb02\xce\xb8\', text_col=store.c_x, editable=True,\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.raw_pattern, 0)),\n            resizable=True, expand=True))\n        # Y Column:\n        widget.append_column(new_text_column(\n            \'Intensity\', text_col=store.c_y, editable=True,\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.raw_pattern, 1)),\n            resizable=True, expand=True))\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_raw_pattern_tree_model(self):\n        return wrap_xydata_to_treemodel(self.model, self.model.Meta.get_prop_intel_by_name(""raw_pattern""))\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @BaseController.observe(""name"", assign=True)\n    def notif_name_changed(self, model, prop_name, info):\n        self.phases_treemodel.on_item_changed(self.model)\n        return\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_raw_pattern_tv_cursor_changed(self, tv):\n        path, _ = tv.get_cursor()\n        self.view[""btn_del_raw_data""].set_sensitive(path is not None)\n        return True\n\n    def on_add_raw_pattern_clicked(self, widget):\n        self.model.raw_pattern.append(0, 0)\n        return True\n\n    def on_del_raw_pattern_clicked(self, widget):\n        paths = self.get_selected_paths(self.view[""phase_rp_raw_pattern""])\n        if paths is not None:\n            self.model.raw_pattern.remove_from_indeces(*paths)\n        return True\n\n    def on_xy_data_cell_edited(self, cell, path, new_text, model, col):\n        try:\n            value = float(locale.atof(new_text))\n        except ValueError:\n            logger.exception(""ValueError: Invalid literal for float(): \'%s\'"" % new_text)\n        else:\n            model.set_value(int(path), col, value)\n        return True\n\n    def on_replace_raw_pattern(self, *args, **kwargs):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            try:\n                self.model.raw_pattern.load_data(parser, filename, clear=True)\n            except Exception:\n                message = ""An unexpected error has occured when trying to parse \'%s\'.\\n"" % os.path.basename(filename)\n                message += ""This is most likely caused by an invalid or unsupported file format.""\n                DialogFactory.get_information_dialog(\n                    message=message, parent=self.view.get_toplevel()\n                ).run()\n                raise\n        DialogFactory.get_load_dialog(\n            ""Open XRD file for import"", parent=self.view.get_toplevel(),\n            filters=self.file_filters\n        ).run(on_accept)\n        return True\n\n    def on_btn_import_raw_pattern_clicked(self, widget, data=None):\n        def on_confirm(dialog):\n            self.on_replace_raw_pattern()\n        DialogFactory.get_confirmation_dialog(\n            ""Importing a new experimental file will erase all current data.\\nAre you sure you want to continue?"",\n            parent=self.view.get_toplevel()\n        ).run(on_confirm)\n        return True\n\n    def on_export_raw_pattern(self, *args, **kwargs):\n        return self._export_data(self.model.raw_pattern)\n\n    def on_btn_export_raw_pattern_clicked(self, widget, data=None):\n        return self.on_export_raw_pattern()\n\n    def _export_data(self, line):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            try:\n                line.save_data(parser, filename, **self.model.get_export_meta_data())\n            except Exception:\n                message = ""An unexpected error has occured when trying to save to \'%s\'."" % os.path.basename(filename)\n                DialogFactory.get_information_dialog(\n                    message=message, parent=self.view.get_toplevel()\n                ).run()\n                raise\n        ext_less_fname = os.path.splitext(self.model.name)[0]\n        DialogFactory.get_save_dialog(\n            ""Select file for export"", parent=self.view.get_toplevel(),\n            filters=self.rp_export_filters,\n            current_name=ext_less_fname\n        ).run(on_accept)\n\n    pass #end of class\n'"
pyxrd/phases/models/CSDS.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.calculations.CSDS import calculate_distribution\nfrom pyxrd.calculations.data_objects import CSDSData\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.io import storables, Storable\n\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup, RefinementValue\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\nfrom pyxrd.refinement.refinables.properties import DataMixin, RefinableMixin\n\nfrom mvc.models.properties import (\n    GetActionMixin, LabeledProperty, BoolProperty, FloatProperty,\n    ReadOnlyMixin, SetActionMixin\n)\nfrom mvc.models.properties.signal_mixin import SignalMixin\n\nclass _AbstractCSDSDistribution(DataModel, Storable, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        description = ""Abstract CSDS distr.""\n        explanation = """"\n\n    phase = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n    _data_object = None\n    @property\n    def data_object(self):\n        return self._data_object\n\n    inherited = BoolProperty(\n        default=False, text=""Inherited"",\n        visible=False, persistent=False,\n        signal_name=""data_changed"", mix_with=(SignalMixin,)\n    )\n\n    distrib = LabeledProperty(\n        default=None, text=""CSDS Distribution"",\n        tabular=True, visible=False, persistent=False,\n        get_action_name=""_update_distribution"",\n        signal_name=""data_changed"", \n        mix_with=(SignalMixin, GetActionMixin,)\n    )\n\n    # PROPERTIES:\n    #: The maximum value of this distribution\n    maximum = FloatProperty(\n        default=0.0, text=""Maximum CSDS"",\n        minimum=1, maximum=1000,\n        tabular=True, persistent=False, visible=False,\n        mix_with=(ReadOnlyMixin, DataMixin)\n    )\n\n    #: The minimum value of this distribution\n    minimum = FloatProperty(\n        default=0.0, text=""Maximum CSDS"",\n        minimum=1, maximum=1000,\n        tabular=True, persistent=False, visible=False,\n        mix_with=(ReadOnlyMixin, DataMixin)\n    )\n\n    average = FloatProperty(\n        default=0.0, text=""Average CSDS"",\n        minimum=1, maximum=200,\n        tabular=True, persistent=True, visible=True, refinable=True,\n        signal_name=""data_changed"", \n        set_action_name=""_update_distribution"",\n        mix_with=(SignalMixin, DataMixin, RefinableMixin, SetActionMixin)\n    )\n\n    alpha_scale = FloatProperty(\n        default=0.0, text=""\xce\xb1 scale factor"",\n        minimum=0.0, maximum=10.0,\n        tabular=True, persistent=True, visible=True, refinable=True,\n        signal_name=""data_changed"", \n        set_action_name=""_update_distribution"",\n        mix_with=(SignalMixin, DataMixin, RefinableMixin, SetActionMixin)\n    )\n\n    alpha_offset = FloatProperty(\n        default=0.0, text=""\xce\xb1 offset factor"",\n        minimum=-5, maximum=5,\n        tabular=True, persistent=True, visible=True, refinable=True,\n        signal_name=""data_changed"", \n        set_action_name=""_update_distribution"",\n        mix_with=(SignalMixin, DataMixin, RefinableMixin, SetActionMixin)\n    )\n\n    beta_scale = FloatProperty(\n        default=0.0, text=""\xce\xb2\xc2\xb2 scale factor"",\n        minimum=0.0, maximum=10.0,\n        tabular=True, persistent=True, visible=True, refinable=True,\n        signal_name=""data_changed"", \n        set_action_name=""_update_distribution"",\n        mix_with=(SignalMixin, DataMixin, RefinableMixin, SetActionMixin)\n    )\n\n    beta_offset = FloatProperty(\n        default=0.0, text=""\xce\xb2\xc2\xb2 offset factor"",\n        minimum=-5, maximum=5,\n        tabular=True, persistent=True, visible=True, refinable=True,\n        signal_name=""data_changed"", \n        set_action_name=""_update_distribution"",\n        mix_with=(SignalMixin, DataMixin, RefinableMixin, SetActionMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, average=10, alpha_scale=0.9485, alpha_offset=-0.0017,\n            beta_scale=0.1032, beta_offset=0.0034, *args, **kwargs):\n\n        super(_AbstractCSDSDistribution, self).__init__(*args, **kwargs)\n\n        self._data_object = CSDSData()\n\n        type(self).average._set(self, average)\n        type(self).maximum._set(self, int(settings.LOG_NORMAL_MAX_CSDS_FACTOR * average))\n        type(self).minimum._set(self, 1)\n        type(self).alpha_scale._set(self, alpha_scale)\n        type(self).alpha_offset._set(self, alpha_offset)\n        type(self).beta_scale._set(self, beta_scale)\n        type(self).beta_offset._set(self, beta_offset)\n\n        self._update_distribution()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def _update_distribution(self):\n        type(self).maximum._set(self, int(settings.LOG_NORMAL_MAX_CSDS_FACTOR * self.average))\n        self._distrib = calculate_distribution(self.data_object)\n\n    pass # end of class\n\n@storables.register()\nclass LogNormalCSDSDistribution(_AbstractCSDSDistribution, RefinementGroup):\n\n    # MODEL INTEL:\n    class Meta(_AbstractCSDSDistribution.Meta):\n        description = ""Generic log-normal CSDS distr. (Eberl et al. 1990)""\n        store_id = ""LogNormalCSDSDistribution""\n\n    # REFINEMENT GROUP IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return ""CSDS Distribution""\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.phase.name,\n            component_name=""*""\n        )\n\n    pass # end of class\n\n@storables.register()\nclass DritsCSDSDistribution(_AbstractCSDSDistribution, RefinementValue):\n\n    # MODEL INTEL:\n    class Meta(_AbstractCSDSDistribution.Meta):\n        description = ""Log-normal CSDS distr. (Drits et. al, 1997)""\n        store_id = ""DritsCSDSDistribution""\n\n    # PROPERTIES:\n    alpha_scale = FloatProperty(\n        default=0.9485, text=""\xce\xb1 scale factor"",\n        minimum=0.0, maximum=10.0,\n        tabular=True, persistent=False, visible=False, refinable=False,\n        mix_with=(ReadOnlyMixin, DataMixin, RefinableMixin)\n    )\n\n    alpha_offset = FloatProperty(\n        default=0.017, text=""\xce\xb1 offset factor"",\n        minimum=-5, maximum=5,\n        tabular=True, persistent=False, visible=False, refinable=False,\n        mix_with=(ReadOnlyMixin, DataMixin, RefinableMixin)\n    )\n\n    beta_scale = FloatProperty(\n        default=0.1032, text=""\xce\xb2\xc2\xb2 scale factor"",\n        minimum=0.0, maximum=10.0,\n        tabular=True, persistent=False, visible=False, refinable=False,\n        mix_with=(ReadOnlyMixin, DataMixin, RefinableMixin)\n    )\n\n    beta_offset = FloatProperty(\n        default=0.0034, text=""\xce\xb2\xc2\xb2 offset factor"",\n        minimum=-5, maximum=5,\n        tabular=True, persistent=False, visible=False, refinable=False,\n        mix_with=(ReadOnlyMixin, DataMixin, RefinableMixin)\n    )\n\n    # REFINEMENT VALUE IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return ""Average CSDS""\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.phase.name,\n            component_name=""*"",\n            property_name=self.refine_title\n        )\n\n    @property\n    def refine_value(self):\n        return self.average\n    @refine_value.setter\n    def refine_value(self, value):\n        self.average = value\n\n    @property\n    def refine_info(self):\n        return self.average_ref_info\n\n    @property\n    def is_refinable(self):\n        return not self.inherited\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        for key in [""alpha_scale"", ""alpha_offset"", ""beta_scale"", ""beta_offset""]:\n            kwargs.pop(key, None)\n        super(DritsCSDSDistribution, self).__init__(*args, **kwargs)\n\n    pass # end of class\n\nCSDS_distribution_types = [\n    LogNormalCSDSDistribution,\n    DritsCSDSDistribution\n]\n'"
pyxrd/phases/models/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .phase import Phase\nfrom .raw_pattern_phase import RawPatternPhase\nfrom .component import Component\n\n__all__ = [\n    ""Phase"",\n    ""RawPatternPhase"",\n    ""Component"",\n]\n'"
pyxrd/phases/models/abstract_phase.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport zipfile\nfrom random import choice\n\nfrom mvc.models.properties import (\n    StringProperty, SignalMixin, IntegerProperty, ReadOnlyMixin\n)\n\nfrom pyxrd.generic.io import storables, Storable, COMPRESSION\nfrom pyxrd.generic.models import DataModel\n\nfrom pyxrd.calculations.data_objects import PhaseData\nfrom pyxrd.calculations.phases import get_diffracted_intensity\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\n@storables.register()\nclass AbstractPhase(DataModel, Storable):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""AbstractPhase""\n\n    _data_object = None\n    @property\n    def data_object(self):\n        return self._data_object\n\n    project = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: The name of this Phase\n    name = StringProperty(\n        default=""New Phase"", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n    )\n\n    #: The # of components\n    @IntegerProperty(\n        default=0, text=""# of components"",\n        visible=True, persistent=True, tabular=True, widget_type=""entry"",\n        mix_with=(ReadOnlyMixin,)\n    )\n    def G(self):\n        return 0\n\n    #: The Reichweite\n    @IntegerProperty(\n        default=0, text=""Reichweite"",\n        visible=True, persistent=False, tabular=True, widget_type=""entry"",\n        mix_with=(ReadOnlyMixin,)\n    )\n    def R(self):\n        return 0\n\n    #: The color this phase\'s X-ray diffraction pattern should have.\n    display_color = StringProperty(\n        default=""#FFB600"", text=""Display color"",\n        visible=True, persistent=True, tabular=True, widget_type=\'color\',\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    line_colors = [\n        ""#004488"",\n        ""#FF4400"",\n        ""#559911"",\n        ""#770022"",\n        ""#AACC00"",\n        ""#441177"",\n    ]\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""data_G"", ""data_R"",\n            *[prop.label for prop in AbstractPhase.Meta.get_local_persistent_properties()]\n        )\n        super(AbstractPhase, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n\n            self._data_object = PhaseData()\n\n            self.name = self.get_kwarg(kwargs, self.name, ""name"", ""data_name"")\n            self.display_color = self.get_kwarg(kwargs, choice(self.line_colors), ""display_color"")\n\n    def __repr__(self):\n        return ""AbstractPhase(name=\'%s\')"" % (self.name)\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def resolve_json_references(self):\n        pass # nothing to do, sub-classes should override\n\n    def _pre_multi_save(self, phases, ordered_phases):\n        pass # nothing to do, sub-classes should override\n\n    def _post_multi_save(self):\n        pass # nothing to do, sub-classes should override\n\n    @classmethod\n    def save_phases(cls, phases, filename):\n        """"""\n            Saves multiple phases to a single file.\n        """"""\n        ordered_phases = list(phases) # make a copy\n        for phase in phases:\n            phase._pre_multi_save(phases, ordered_phases)\n\n        with zipfile.ZipFile(filename, \'w\', compression=COMPRESSION) as zfile:\n            for i, phase in enumerate(ordered_phases):\n                zfile.writestr(""%d###%s"" % (i, phase.uuid), phase.dump_object())\n\n        for phase in ordered_phases:\n            phase._post_multi_save()\n\n        # After export we change all the UUID\'s\n        # This way, we\'re sure that we\'re not going to import objects with\n        # duplicate UUID\'s!\n        type(cls).object_pool.change_all_uuids()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_diffracted_intensity(self, range_theta, range_stl, *args):\n        return get_diffracted_intensity(range_theta, range_stl, self.data_object)\n\n    pass # end of class\n'"
pyxrd/phases/models/atom_relations.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport types\nfrom functools import partial\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom mvc.models.properties import (\n    LabeledProperty, StringProperty, BoolProperty, FloatProperty,\n    SignalMixin, ReadOnlyMixin, ListProperty\n)\nfrom mvc.observers import ListObserver\nfrom mvc import Model\n\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.io import storables, Storable, get_case_insensitive_glob\n\nfrom pyxrd.refinement.refinables.mixins import RefinementValue\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\n\nclass ComponentPropMixin(object):\n    """"""\n        A mixin which provides some common utility functions for retrieving\n        properties using a string description (e.g. \'layer_atoms.1\' or \'b_cell\')\n    """"""\n\n    def _parseattr(self, attr):\n        """"""\n            Function used for handling (deprecated) \'property strings\':\n            attr contains a string (e.g. cell_a or layer_atoms.2) which can be \n            parsed into an object and a property.\n            Current implementation uses UUID\'s, however this is still here for\n            backwards-compatibility...\n            Will be removed at some point!\n        """"""\n        if not isinstance(attr, str):\n            return attr\n\n        if attr == """" or attr == None:\n            return None\n\n        def get_atom_by_index(atoms, index):\n            for atom in atoms:\n                if atom.atom_nr == index:\n                    return atom\n            return None\n\n        attr = attr.replace(""data_"", """", 1) # for backwards compatibility\n        attrs = attr.split(""."")\n        if attrs[0] == ""layer_atoms"":\n            atom = get_atom_by_index(self.component._layer_atoms, int(attrs[1]))\n            if atom is not None:\n                return atom, ""pn""\n            else:\n                return None\n        elif attrs[0] == ""interlayer_atoms"":\n            atom = get_atom_by_index(self.component._interlayer_atoms, int(attrs[1]))\n            if atom is not None:\n                return atom, ""pn""\n            else:\n                return None\n        else:\n            return self.component, attr\n\n@storables.register()\nclass AtomRelation(ComponentPropMixin, RefinementValue, DataModel, Storable, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""AtomRelation""\n        file_filters = [\n            (""Atom relation"", get_case_insensitive_glob(""*.atr"")),\n        ]\n        allowed_relations = {}\n\n    component = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n    #: The name of this AtomRelation\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The value of this AtomRelation\n    value = FloatProperty(\n        default=0.0, text=""Value"",\n        visible=True, persistent=True, tabular=True, widget_type=\'float_entry\',\n        signal_name=""data_changed"", refinable=True,\n        mix_with=(SignalMixin, RefinableMixin)\n    )\n\n    #: Flag indicating whether this AtomRelation is enabled or not\n    enabled = BoolProperty(\n        default=True, text=""Enabled"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Is True when this AtomRelation\'s value is driven by another AtomRelation.\n    #: Should never be set directly or things might break!\n    driven_by_other = BoolProperty(\n        default=False, text=""Driven by other"",\n        visible=False, persistent=False, tabular=True\n    )\n\n    @property\n    def applicable(self):\n        """"""\n        Is True when this AtomRelation was passed a component of which the atom\n        ratios are not set to be inherited from another component.\n        """"""\n        return (self.parent is not None and not self.parent.inherit_atom_relations)\n\n    # REFINEMENT VALUE IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return self.name\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.component.phase.refine_title,\n            component_name=self.component.refine_title\n        )\n\n    @property\n    def refine_value(self):\n        return self.value\n    @refine_value.setter\n    def refine_value(self, value):\n        self.value = value\n\n    @property\n    def inside_linked_component(self):\n        return (self.component.linked_with is not None) and self.component.inherit_atom_relations\n\n    @property\n    def is_refinable(self):\n        return self.enabled and not self.driven_by_other and not self.inside_linked_component\n\n    @property\n    def refine_info(self):\n        return self.value_ref_info\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for an AtomRelation are:\n                name: the name of this AtomRelation\n                value: the value for this AtomRelation\n                enabled: boolean indicating whether or not this AtomRelation is \n                 enabled\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""data_ratio"", ""ratio"",\n            *[prop.label for prop in AtomRelation.Meta.get_local_persistent_properties()]\n        )\n        super(AtomRelation, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self.name = self.get_kwarg(kwargs, """", ""name"", ""data_name"")\n        self.value = self.get_kwarg(kwargs, 0.0, ""value"", ""ratio"", ""data_ratio"")\n        self.enabled = bool(self.get_kwarg(kwargs, True, ""enabled""))\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def resolve_relations(self):\n        raise NotImplementedError(""Subclasses should implement the resolve_relations method!"")\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def create_prop_store(self, prop=None):\n        if self.component is not None:\n            store = Gtk.ListStore(object, str, str)\n            for atom in self.component._layer_atoms:\n                store.append([atom, ""pn"", atom.name])\n            for atom in self.component._interlayer_atoms:\n                store.append([atom, ""pn"", atom.name])\n            for relation in self.component._atom_relations:\n                tp = relation.Meta.store_id\n                if tp in self.Meta.allowed_relations:\n                    for prop, name in self.Meta.allowed_relations[tp]:\n                        if callable(name):\n                            name = name(relation)\n                        store.append([relation, prop, name])\n            return store\n\n    def iter_references(self):\n        raise NotImplementedError(""\'iter_references\' should be implemented by subclasses!"")\n\n    def _safe_is_referring(self, value):\n        if value is not None and hasattr(value, ""is_referring""):\n            return value.is_referring([self, ])\n        else:\n            return False\n\n    def is_referring(self, references=None):\n        """"""\n            Checks whether this AtomRelation is causing circular references.\n            Can be used to check this before actually setting references by\n            setting the \'references\' keyword argument to a list containing the\n            new reference value(s).\n        """"""\n        if references == None:\n            references = []\n        # 1. Bluntly check if we\'re not already somewhere referred to,\n        #    if not, add ourselves to the list of references\n        if self in references:\n            return True\n        references.append(self)\n\n        # 2. Loop over our own references, check if they cause a circular\n        #    reference, if not add them to the list of references.\n        for reference in self.iter_references():\n            if reference is not None and hasattr(reference, ""is_referring""):\n                if reference.is_referring(references):\n                    return True\n                else:\n                    references.append(reference)\n\n        return False\n\n    def _set_driven_flag_for_prop(self, prop=None):\n        """"""Internal method used to safely set the driven_by_other flag on an object.\n        Subclasses can override to provide a check on the property set by the driver.""""""\n        self.driven_by_other = True\n\n    def apply_relation(self):\n        raise NotImplementedError(""Subclasses should implement the apply_relation method!"")\n\n    pass # end of class\n\n@storables.register()\nclass AtomRatio(AtomRelation):\n\n    # MODEL INTEL:\n    class Meta(AtomRelation.Meta):\n        store_id = ""AtomRatio""\n        allowed_relations = {\n            ""AtomRatio"": [\n                (""__internal_sum__"", lambda o: ""%s: SUM"" % o.name),\n                (""value"", lambda o: ""%s: RATIO"" % o.name),\n            ],\n            ""AtomContents"": [(""value"", lambda o: o.name)],\n        }\n\n    # SIGNALS:\n\n    # PROPERTIES:\n    #: The sum of the two atoms\n    sum = FloatProperty(\n        default=1.0, text=""Sum"", minimum=0.0,\n        visible=True, persistent=True, tabular=True, widget_type=\'float_entry\',\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    def __internal_sum__(self, value):\n        """"""\n        Special setter for other AtomRelation objects depending on the value of\n        the sum of the AtomRatio. This can be used to have multi-substitution by\n        linking two (or more) AtomRatio\'s. Eg Al-by-Mg-&-Fe:\n        \n        AtomRatioMgAndFeForAl -> links together Al content and Fe+Mg content\n        \n                              => sum = e.g. 4 set by user\n                              \n        AtomRatioMgForFe      -> links together the Fe and Mg content\n        \n                              => sum = set by previous ratio.\n        """"""\n        self._sum = float(value)\n        self.apply_relation()\n    __internal_sum__ = property(fset=__internal_sum__)\n\n    def _set_driven_flag_for_prop(self, prop, *args):\n        """"""Internal method used to safely set the driven_by_other flag on an object.\n        Subclasses can override to provide a check on the property set by the driver.""""""\n        if prop != ""__internal_sum__"":\n            super(AtomRatio, self)._set_driven_flag_for_prop(prop)\n\n    def _set_atom(self, value, label=None):\n        if not self._safe_is_referring(value[0]):\n            getattr(type(self), label)._set(self, value)\n\n    #: The substituting atom\n    atom1 = LabeledProperty(\n        default=[None, None], text=""Substituting Atom"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", fset=partial(_set_atom, label=""atom1""),\n        mix_with=(SignalMixin,)\n    )\n\n    #: The Original atom\n    atom2 = LabeledProperty(\n        default=[None, None], text=""Original Atom"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", fset=partial(_set_atom, label=""atom2""),\n        mix_with=(SignalMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs): # @ReservedAssignment\n        """"""\n            Valid keyword arguments for an AtomRatio are:\n                sum: the sum of the atoms contents\n                atom1: a tuple containing the first atom and its property name to read/set\n                atom2: a tuple containing the first atom and its property name to read/set\n            The value property is the \'ratio\' of the first atom over the sum of both\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_sum"", ""prop1"", ""data_prop1"", ""data_prop2"", ""prop2"",\n            *[prop.label for prop in AtomRatio.Meta.get_local_persistent_properties()]\n        )\n        super(AtomRatio, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self.sum = self.get_kwarg(kwargs, self.sum, ""sum"", ""data_sum"")\n\n        self._unresolved_atom1 = self._parseattr(self.get_kwarg(kwargs, [None, None], ""atom1"", ""prop1"", ""data_prop1""))\n        self._unresolved_atom2 = self._parseattr(self.get_kwarg(kwargs, [None, None], ""atom2"", ""prop2"", ""data_prop2""))\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        retval = Storable.json_properties(self)\n        retval[""atom1""] = [retval[""atom1""][0].uuid if retval[""atom1""][0] else None, retval[""atom1""][1]]\n        retval[""atom2""] = [retval[""atom2""][0].uuid if retval[""atom2""][0] else None, retval[""atom2""][1]]\n        return retval\n\n    def resolve_relations(self):\n        if isinstance(self._unresolved_atom1[0], str):\n            self._unresolved_atom1[0] = type(type(self)).object_pool.get_object(self._unresolved_atom1[0])\n        self.atom1 = list(self._unresolved_atom1)\n        del self._unresolved_atom1\n        if isinstance(self._unresolved_atom2[0], str):\n            self._unresolved_atom2[0] = type(type(self)).object_pool.get_object(self._unresolved_atom2[0])\n        self.atom2 = list(self._unresolved_atom2)\n        del self._unresolved_atom2\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def apply_relation(self):\n        if self.enabled and self.applicable:\n            for value, (atom, prop) in [(self.value, self.atom1), (1.0 - self.value, self.atom2)]:\n                if atom and prop:\n                    # do not fire events, just set attributes:\n                    with atom.data_changed.ignore():\n                        setattr(atom, prop, value * self.sum)\n                        if hasattr(atom, ""_set_driven_flag_for_prop""):\n                            atom._set_driven_flag_for_prop(prop)\n\n    def iter_references(self):\n        for atom in [self.atom1[0], self.atom2[0]]:\n            yield atom\n\n    pass # end of class\n\nclass AtomContentObject(Model):\n    """"""\n        Wrapper around an atom object used in the AtomContents model.\n        Stores the atom, the property to set and it\'s default amount.\n    """"""\n\n    atom = LabeledProperty(\n        default=None, text=""Atom"",\n        visible=False, persistent=False, tabular=True,\n    )\n\n    prop = LabeledProperty(\n        default=None, text=""Prop"",\n        visible=False, persistent=False, tabular=True,\n    )\n\n    amount = FloatProperty(\n        default=0.0, text=""Amount"", minimum=0.0,\n        visible=False, persistent=False, tabular=True,\n    )\n\n    def __init__(self, atom, prop, amount, *args, **kwargs):\n        super(AtomContentObject, self).__init__(*args, **kwargs)\n        self.atom = atom\n        self.prop = prop\n        self.amount = amount\n\n    def update_atom(self, value):\n        if not (self.atom == """" or self.atom is None or self.prop is None):\n            with self.atom.data_changed.ignore():\n                setattr(self.atom, self.prop, self.amount * value)\n                if hasattr(self.atom, ""_set_driven_flag_for_prop""):\n                    self.atom._set_driven_flag_for_prop(self.prop)\n\n    pass\n\n@storables.register()\nclass AtomContents(AtomRelation):\n\n    # MODEL INTEL:\n    class Meta(AtomRelation.Meta):\n        store_id = ""AtomContents""\n        allowed_relations = {\n            ""AtomRatio"": [\n                (""__internal_sum__"", lambda o: ""%s: SUM"" % o.name),\n                (""value"", lambda o: ""%s: RATIO"" % o.name),\n            ],\n        }\n\n    # SIGNALS:\n\n    # PROPERTIES:\n    atom_contents = ListProperty(\n        default=None, text=""Atom contents"",\n        visible=True, persistent=True, tabular=True,\n        data_type=AtomContentObject,\n        mix_with=(ReadOnlyMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for an AtomContents are:\n                atom_contents: a list of tuples containing the atom content \n                 object uuids, property names and default amounts \n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            *[prop.label for prop in AtomContents.Meta.get_local_persistent_properties()]\n        )\n        super(AtomContents, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        # Load atom contents:\n        atom_contents = []\n        for uuid, prop, amount in self.get_kwarg(kwargs, [], ""atom_contents""):\n            # uuid\'s are resolved when resolve_relations is called\n            atom_contents.append(AtomContentObject(uuid, prop, amount))\n        type(self).atom_contents._set(self, atom_contents)\n\n        def on_change(*args):\n            if self.enabled: # no need for updates otherwise\n                self.data_changed.emit()\n\n        self._atom_contents_observer = ListObserver(\n            on_change, on_change,\n            prop_name=""atom_contents"",\n            model=self\n        )\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        retval = Storable.json_properties(self)\n        retval[""atom_contents""] = list([\n            [\n                atom_contents.atom.uuid if atom_contents.atom else None,\n                atom_contents.prop,\n                atom_contents.amount\n            ] for atom_contents in retval[""atom_contents""]\n        ])\n        return retval\n\n    def resolve_relations(self):\n        # Disable event dispatching to prevent infinite loops\n        enabled = self.enabled\n        self.enabled = False\n        # Change rows with string references to objects (uuid\'s)\n        for atom_content in self.atom_contents:\n            if isinstance(atom_content.atom, str):\n                atom_content.atom = type(type(self)).object_pool.get_object(atom_content.atom)\n        # Set the flag to its original value\n        self.enabled = enabled\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def apply_relation(self):\n        if self.enabled and self.applicable:\n            for atom_content in self.atom_contents:\n                atom_content.update_atom(self.value)\n\n    def set_atom_content_values(self, path, new_atom, new_prop):\n        """"""    \n            Convenience function that first checks if the new atom value will\n            not cause a circular reference before actually setting it.\n        """"""\n        with self.data_changed.hold():\n            atom_content = self.atom_contents[int(path[0])]\n            if atom_content.atom != new_atom:\n                old_atom = atom_content.atom\n                atom_content.atom = None # clear...\n                if not self._safe_is_referring(new_atom):\n                    atom_content.atom = new_atom\n                else:\n                    atom_content.atom = old_atom\n            else:\n                atom_content.atom = None\n            atom_content.prop = new_prop\n\n    def iter_references(self):\n        for atom_content in self.atom_contents:\n            yield atom_content.atom\n\n    pass # end of class\n'"
pyxrd/phases/models/component.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport zipfile\nfrom warnings import warn\n\nfrom mvc.models.properties import (\n    FloatProperty, SignalMixin, BoolProperty, StringProperty,\n    LabeledProperty, SignalProperty, ObserveMixin, ListProperty,\n\n)\nfrom mvc.observers.list_observer import ListObserver\n\nfrom pyxrd.generic.io import storables, Storable, COMPRESSION\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.models.properties import InheritableMixin\n\nfrom pyxrd.calculations.components import get_factors\nfrom pyxrd.calculations.data_objects import ComponentData\n\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom pyxrd.atoms.models import Atom\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\nfrom .atom_relations import AtomRelation\nfrom .unit_cell_prop import UnitCellProperty\n\n@storables.register()\nclass Component(RefinementGroup, DataModel, Storable, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Component""\n\n    _data_object = None\n    @property\n    def data_object(self):\n        weight = 0.0\n\n        self._data_object.layer_atoms = [None] * len(self.layer_atoms)\n        for i, atom in enumerate(self.layer_atoms):\n            self._data_object.layer_atoms[i] = atom.data_object\n            weight += atom.weight\n\n        self._data_object.interlayer_atoms = [None] * len(self.interlayer_atoms)\n        for i, atom in enumerate(self.interlayer_atoms):\n            self._data_object.interlayer_atoms[i] = atom.data_object\n            weight += atom.weight\n\n        self._data_object.volume = self.get_volume()\n        self._data_object.weight = weight\n        self._data_object.d001 = self.d001\n        self._data_object.default_c = self.default_c\n        self._data_object.delta_c = self.delta_c\n        self._data_object.lattice_d = self.lattice_d\n\n        return self._data_object\n\n    phase = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # SIGNALS:\n    atoms_changed = SignalProperty()\n\n    # UNIT CELL DIMENSION SHORTCUTS:\n    @property\n    def cell_a(self):\n        return self._ucp_a.value\n    @property\n    def cell_b(self):\n        return self._ucp_b.value\n    @property\n    def cell_c(self):\n        return self.d001\n\n    # PROPERTIES:\n\n    #: The name of the Component\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit the UCP a from :attr:`~linked_with`\n    @BoolProperty(\n        default=False, text=""Inh. cell length a"",\n        visible=True, persistent=True, tabular=True,\n    )\n    def inherit_ucp_a(self):\n        return self._ucp_a.inherited\n    @inherit_ucp_a.setter\n    def inherit_ucp_a(self, value):\n        self._ucp_a.inherited = value\n\n    #: Flag indicating whether to inherit the UCP b from :attr:`~linked_with`\n    @BoolProperty(\n        default=False, text=""Inh. cell length b"",\n        visible=True, persistent=True, tabular=True,\n    )\n    def inherit_ucp_b(self):\n        return self._ucp_b.inherited\n    @inherit_ucp_b.setter\n    def inherit_ucp_b(self, value):\n        self._ucp_b.inherited = value\n\n    #: Flag indicating whether to inherit d001 from :attr:`~linked_with`\n    inherit_d001 = BoolProperty(\n        default=False, text=""Inh. cell length c"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit default_c from :attr:`~linked_with`\n    inherit_default_c = BoolProperty(\n        default=False, text=""Inh. default length c"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit delta_c from :attr:`~linked_with`\n    inherit_delta_c = BoolProperty(\n        default=False, text=""Inh. c length dev."",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit layer_atoms from :attr:`~linked_with`\n    inherit_layer_atoms = BoolProperty(\n        default=False, text=""Inh. layer atoms"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit interlayer_atoms from :attr:`~linked_with`\n    inherit_interlayer_atoms = BoolProperty(\n        default=False, text=""Inh. interlayer atoms"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit atom_relations from :attr:`~linked_with`\n    inherit_atom_relations = BoolProperty(\n        default=False, text=""Inh. atom relations"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    _linked_with_index = None\n    _linked_with_uuid = None\n\n    #: The :class:`~Component` this component is linked with\n    linked_with = LabeledProperty(\n        default=None, text=""Linked with"",\n        visible=True, persistent=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n    @linked_with.setter\n    def linked_with(self, value):\n        old = type(self).linked_with._get(self)\n        if old != value:\n            if old is not None:\n                self.relieve_model(old)\n            type(self).linked_with._set(self, value)\n            if value is not None:\n                self.observe_model(value)\n            else:\n                for prop in self.Meta.get_inheritable_properties():\n                    setattr(self, prop.inherit_flag, False)\n\n    #: The silicate lattice\'s c length\n    lattice_d = FloatProperty(\n        default=0.0, text=""Lattice c length [nm]"",\n        visible=False, persistent=True,\n        signal_name=""data_changed""\n    )\n\n    ucp_a = LabeledProperty(\n        default=None, text=""Cell length a [nm]"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_ucp_a"", inherit_from=""linked_with.ucp_a"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, InheritableMixin, ObserveMixin, RefinableMixin)\n    )\n\n    ucp_b = LabeledProperty(\n        default=None, text=""Cell length b [nm]"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_ucp_b"", inherit_from=""linked_with.ucp_b"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, InheritableMixin, ObserveMixin, RefinableMixin)\n    )\n\n    d001 = FloatProperty(\n        default=1.0, text=""Cell length c [nm]"", minimum=0.0, maximum=5.0,\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_default_c"", inherit_from=""linked_with.d001"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, InheritableMixin, RefinableMixin)\n    )\n\n    default_c = FloatProperty(\n        default=1.0, text=""Default c length [nm]"", minimum=0.0, maximum=5.0,\n        visible=True, persistent=True, tabular=True,\n        inheritable=True, inherit_flag=""inherit_default_c"", inherit_from=""linked_with.default_c"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, InheritableMixin)\n    )\n\n    delta_c = FloatProperty(\n        default=0.0, text=""C length dev. [nm]"", minimum=0.0, maximum=0.05,\n        visible=True, persistent=True, tabular=True,\n        inheritable=True, inherit_flag=""inherit_delta_c"", inherit_from=""linked_with.delta_c"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, InheritableMixin, RefinableMixin)\n    )\n\n    layer_atoms = ListProperty(\n        default=None, text=""Layer atoms"",\n        visible=True, persistent=True, tabular=True, widget_type=""custom"",\n        inheritable=True, inherit_flag=""inherit_layer_atoms"", inherit_from=""linked_with.layer_atoms"",\n        signal_name=""data_changed"", data_type=Atom,\n        mix_with=(SignalMixin, InheritableMixin)\n    )\n\n    interlayer_atoms = ListProperty(\n        default=None, text=""Interlayer atoms"",\n        visible=True, persistent=True, tabular=True, widget_type=""custom"",\n        inheritable=True, inherit_flag=""inherit_interlayer_atoms"", inherit_from=""linked_with.interlayer_atoms"",\n        signal_name=""data_changed"", data_type=Atom,\n        mix_with=(SignalMixin, InheritableMixin)\n    )\n\n    atom_relations = ListProperty(\n        default=None, text=""Atom relations"", widget_type=""custom"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_atom_relations"", inherit_from=""linked_with.atom_relations"",\n        signal_name=""data_changed"", data_type=AtomRelation,\n        mix_with=(SignalMixin, InheritableMixin, RefinableMixin)\n    )\n\n    # Instance flag indicating whether or not linked_with & inherit flags should be saved\n    save_links = True\n    # Class flag indicating whether or not atom types in the component should be\n    # exported using their name rather then their project-uuid.\n    export_atom_types = False\n\n    # REFINEMENT GROUP IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return self.name\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.phase.refine_title,\n            component_name=self.refine_title\n        )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, **kwargs):\n        """"""\n        Valid keyword arguments for a Component are:\n        *ucp_a*: unit cell property along a axis\n        *ucp_b*: unit cell property along b axis\n        *d001*: unit cell length c (aka d001)\n        *default_c*: default c-value\n        *delta_c*: the variation in basal spacing due to defects\n        *layer_atoms*: ObjectListStore of layer Atoms\n        *interlayer_atoms*: ObjectListStore of interlayer Atoms\n        *atom_relations*: ObjectListStore of AtomRelations\n        *inherit_ucp_a*: whether or not to inherit the ucp_a property from\n         the linked component (if linked)\n        *inherit_ucp_b*: whether or not to inherit the ucp_b property from\n         the linked component (if linked)\n        *inherit_d001*: whether or not to inherit the d001 property from\n         the linked component (if linked)\n        *inherit_default_c*: whether or not to inherit the default_c \n         property from the linked component (if linked)\n        *inherit_delta_c*: whether or not to inherit the delta_c \n         property from the linked component (if linked)\n        *inherit_layer_atoms*: whether or not to inherit the layer_atoms \n         property from the linked component (if linked)\n        *inherit_interlayer_atoms*: whether or not to inherit the\n         interlayer_atoms property from the linked component (if linked)\n        *inherit_atom_relations*: whether or not to inherit the \n         atom_relations property from the linked component (if linked)\n        *linked_with_uuid*: the UUID for the component this one is linked\n         with\n    Deprecated, but still supported:\n        *linked_with_index*: the index of the component this one is \n         linked with in the ObjectListStore of the parent based on phase.\n        """"""\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""data_layer_atoms"", ""data_interlayer_atoms"", ""data_atom_relations"",\n            ""data_atom_ratios"", ""data_d001"", ""data_default_c"", ""data_delta_c"", ""lattice_d"",\n            ""data_cell_a"", ""data_ucp_a"", ""data_cell_b"", ""data_ucp_b"",\n            ""linked_with_uuid"", ""linked_with_index"", ""inherit_cell_a"", ""inherit_cell_b"",\n            *[prop.label for prop in Component.Meta.get_local_persistent_properties()]\n        )\n        super(Component, self).__init__(**kwargs)\n        kwargs = my_kwargs\n\n        # Set up data object\n        self._data_object = ComponentData(\n            d001=0.0,\n            delta_c=0.0\n        )\n\n        # Set attributes:\n        self.name = self.get_kwarg(kwargs, """", ""name"", ""data_name"")\n\n        # Load lists:\n        self.layer_atoms = self.get_list(kwargs, [], ""layer_atoms"", ""data_layer_atoms"", parent=self)\n        self.interlayer_atoms = self.get_list(kwargs, [], ""interlayer_atoms"", ""data_interlayer_atoms"", parent=self)\n        self.atom_relations = self.get_list(kwargs, [], ""atom_relations"", ""data_atom_relations"", parent=self)\n\n        # Add all atom ratios to the AtomRelation list\n        for atom_ratio in self.get_list(kwargs, [], ""atom_ratios"", ""data_atom_ratios"", parent=self):\n            self.atom_relations.append(atom_ratio)\n\n        # Observe the inter-layer atoms, and make sure they get stretched\n        for atom in self.interlayer_atoms:\n            atom.stretch_values = True\n            self.observe_model(atom)\n\n        # Observe the layer atoms\n        for atom in self.layer_atoms:\n            self.observe_model(atom)\n\n        # Resolve their relations and observe the atom relations\n        for relation in self.atom_relations:\n            relation.resolve_relations()\n            self.observe_model(relation)\n\n        # Connect signals to lists and dicts:\n        self._layer_atoms_observer = ListObserver(\n            self._on_layer_atom_inserted,\n            self._on_layer_atom_removed,\n            prop_name=""layer_atoms"",\n            model=self\n        )\n        self._interlayer_atoms_observer = ListObserver(\n            self._on_interlayer_atom_inserted,\n            self._on_interlayer_atom_removed,\n            prop_name=""interlayer_atoms"",\n            model=self\n        )\n        self._atom_relations_observer = ListObserver(\n            self._on_atom_relation_inserted,\n            self._on_atom_relation_removed,\n            prop_name=""atom_relations"",\n            model=self\n        )\n\n        # Update lattice values:\n        self.d001 = self.get_kwarg(kwargs, self.d001, ""d001"", ""data_d001"")\n        self._default_c = float(self.get_kwarg(kwargs, self.d001, ""default_c"", ""data_default_c""))\n        self.delta_c = float(self.get_kwarg(kwargs, self.delta_c, ""delta_c"", ""data_delta_c""))\n        self.update_lattice_d()\n\n        # Set/Create & observe unit cell properties:\n        ucp_a = self.get_kwarg(kwargs, None, ""ucp_a"", ""data_ucp_a"", ""data_cell_a"")\n        if isinstance(ucp_a, float):\n            ucp_a = UnitCellProperty(name=""cell length a"", value=ucp_a, parent=self)\n        ucp_a = self.parse_init_arg(\n            ucp_a, UnitCellProperty, child=True,\n            default_is_class=True, name=""Cell length a [nm]"", parent=self\n        )\n        type(self).ucp_a._set(self, ucp_a)\n        self.observe_model(ucp_a)\n\n        ucp_b = self.get_kwarg(kwargs, None, ""ucp_b"", ""data_ucp_b"", ""data_cell_b"")\n        if isinstance(ucp_b, float):\n            ucp_b = UnitCellProperty(name=""cell length b"", value=ucp_b, parent=self)\n        ucp_b = self.parse_init_arg(\n            ucp_b, UnitCellProperty, child=True,\n            default_is_class=True, name=""Cell length b [nm]"", parent=self\n        )\n        type(self).ucp_b._set(self, ucp_b)\n        self.observe_model(ucp_b)\n\n        # Set links:\n        self._linked_with_uuid = self.get_kwarg(kwargs, """", ""linked_with_uuid"")\n        self._linked_with_index = self.get_kwarg(kwargs, -1, ""linked_with_index"")\n\n        # Set inherit flags:\n        self.inherit_d001 = self.get_kwarg(kwargs, False, ""inherit_d001"")\n        self.inherit_ucp_a = self.get_kwarg(kwargs, False, ""inherit_ucp_a"", ""inherit_cell_a"")\n        self.inherit_ucp_b = self.get_kwarg(kwargs, False, ""inherit_ucp_b"", ""inherit_cell_b"")\n        self.inherit_default_c = self.get_kwarg(kwargs, False, ""inherit_default_c"")\n        self.inherit_delta_c = self.get_kwarg(kwargs, False, ""inherit_delta_c"")\n        self.inherit_layer_atoms = self.get_kwarg(kwargs, False, ""inherit_layer_atoms"")\n        self.inherit_interlayer_atoms = self.get_kwarg(kwargs, False, ""inherit_interlayer_atoms"")\n        self.inherit_atom_relations = self.get_kwarg(kwargs, False, ""inherit_atom_relations"")\n\n    def __repr__(self):\n        return ""Component(name=\'%s\', linked_with=%r)"" % (self.name, self.linked_with)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @DataModel.observe(""data_changed"", signal=True)\n    def _on_data_model_changed(self, model, prop_name, info):\n        # Check whether the changed model is an AtomRelation or Atom, if so\n        # re-apply the atom_relations.\n        with self.data_changed.hold():\n            if isinstance(model, AtomRelation) or isinstance(model, Atom):\n                self._apply_atom_relations()\n                self._update_ucp_values()\n            if isinstance(model, UnitCellProperty):\n                self.data_changed.emit() # propagate signal\n\n    @DataModel.observe(""removed"", signal=True)\n    def _on_data_model_removed(self, model, prop_name, info):\n        # Check whether the removed component is linked with this one, if so\n        # clears the link and emits the data_changed signal.\n        if model != self and self.linked_with is not None and self.linked_with == model:\n            with self.data_changed.hold_and_emit():\n                self.linked_with = None\n\n    def _on_layer_atom_inserted(self, atom):\n        """"""Sets the atoms parent and stretch_values property,\n        updates the components lattice d-value, and emits a data_changed signal""""""\n        with self.data_changed.hold_and_emit():\n            with self.atoms_changed.hold_and_emit():\n                atom.parent = self\n                atom.stretch_values = False\n                self.observe_model(atom)\n                self.update_lattice_d()\n\n    def _on_layer_atom_removed(self, atom):\n        """"""Clears the atoms parent, updates the components lattice d-value, and\n        emits a data_changed signal""""""\n        with self.data_changed.hold_and_emit():\n            with self.atoms_changed.hold_and_emit():\n                self.relieve_model(atom)\n                atom.parent = None\n                self.update_lattice_d()\n\n    def _on_interlayer_atom_inserted(self, atom):\n        """"""Sets the atoms parent and stretch_values property, \n        and emits a data_changed signal""""""\n        with self.data_changed.hold_and_emit():\n            with self.atoms_changed.hold_and_emit():\n                atom.stretch_values = True\n                atom.parent = self\n    def _on_interlayer_atom_removed(self, atom):\n        """"""Clears the atoms parent property, \n        and emits a data_changed signal""""""\n        with self.data_changed.hold_and_emit():\n            with self.atoms_changed.hold_and_emit():\n                atom.parent = None\n\n    def _on_atom_relation_inserted(self, item):\n        item.parent = self\n        self.observe_model(item)\n        self._apply_atom_relations()\n\n    def _on_atom_relation_removed(self, item):\n        self.relieve_model(item)\n        item.parent = None\n        self._apply_atom_relations()\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def resolve_json_references(self):\n        for atom in type(self).layer_atoms._get(self):\n            atom.resolve_json_references()\n        for atom in type(self).interlayer_atoms._get(self):\n            atom.resolve_json_references()\n\n        type(self).ucp_a._get(self).resolve_json_references()\n        type(self).ucp_a._get(self).update_value()\n        type(self).ucp_b._get(self).resolve_json_references()\n        type(self).ucp_b._get(self).update_value()\n\n        if getattr(self, ""_linked_with_uuid"", None):\n            self.linked_with = type(type(self)).object_pool.get_object(self._linked_with_uuid)\n            del self._linked_with_uuid\n        elif getattr(self, ""_linked_with_index"", None) and self._linked_with_index != -1:\n            warn(""The use of object indeces is deprected since version 0.4. Please switch to using object UUIDs."", DeprecationWarning)\n            self.linked_with = self.parent.based_on.components.get_user_from_index(self._linked_with_index)\n            del self._linked_with_index\n\n    @classmethod\n    def save_components(cls, components, filename):\n        """"""\n            Saves multiple components to a single file.\n        """"""\n        Component.export_atom_types = True\n        for comp in components:\n            comp.save_links = False\n        with zipfile.ZipFile(filename, \'w\', compression=COMPRESSION) as zfile:\n            for component in components:\n                zfile.writestr(component.uuid, component.dump_object())\n        for comp in components:\n            comp.save_links = True\n        Component.export_atom_types = False\n\n        # After export we change all the UUID\'s\n        # This way, we\'re sure that we\'re not going to import objects with\n        # duplicate UUID\'s!\n        type(cls).object_pool.change_all_uuids()\n\n    @classmethod\n    def load_components(cls, filename, parent=None):\n        """"""\n            Returns multiple components loaded from a single file.\n        """"""\n        # Before import, we change all the UUID\'s\n        # This way we\'re sure that we\'re not going to import objects\n        # with duplicate UUID\'s!\n        type(cls).object_pool.change_all_uuids()\n        if zipfile.is_zipfile(filename):\n            with zipfile.ZipFile(filename, \'r\') as zfile:\n                for uuid in zfile.namelist():\n                    obj = JSONParser.parse(zfile.open(uuid))\n                    obj.parent = parent\n                    yield obj\n        else:\n            obj = JSONParser.parse(filename)\n            obj.parent = parent\n            yield obj\n\n    def json_properties(self):\n        if self.phase == None or not self.save_links:\n            retval = Storable.json_properties(self)\n            for prop in self.Meta.all_properties:\n                if getattr(prop, ""inherit_flag"", False):\n                    retval[prop.inherit_flag] = False\n        else:\n            retval = Storable.json_properties(self)\n            retval[""linked_with_uuid""] = self.linked_with.uuid if self.linked_with is not None else """"\n        return retval\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_factors(self, range_stl):\n        """"""\n        Get the structure factor for the given range of sin(theta)/lambda values.\n        :param range_stl: A 1D numpy ndarray\n        """"""\n        return get_factors(range_stl, self.data_object)\n\n    def get_interlayer_stretch_factors(self):\n        z_factor = (self.cell_c - self.lattice_d) / (self.default_c - self.lattice_d)\n        return self.lattice_d, z_factor\n\n    def update_lattice_d(self):\n        """"""\n            Updates the lattice_d attribute for this :class:`~.Component`. \n            Should normally not be called from outside the component.\n        """"""\n        for atom in self.layer_atoms:\n            self.lattice_d = float(max(self.lattice_d, atom.default_z))\n\n    def _apply_atom_relations(self):\n        """"""\n        Applies the :class:`~..atom_relations.AtomRelation` objects\n        in this component. Should normally not be called from outside the component.\n        """"""\n        with self.data_changed.hold_and_emit():\n            for relation in self.atom_relations:\n                # Clear the \'driven by\' flags:\n                relation.driven_by_other = False\n            for relation in self.atom_relations:\n                # Apply the relations, will also take care of flag setting:\n                relation.apply_relation()\n\n    def _update_ucp_values(self):\n        """"""\n        Updates the :class:`~..unit_cell_prop.UnitCellProperty` objects in this\n        component. Should normally not be called from outside the component.\n        """"""\n        with self.data_changed.hold():\n            for ucp in [self._ucp_a, self._ucp_b]:\n                ucp.update_value()\n\n    def get_volume(self):\n        """"""\n        Get the volume for this :class:`~.Component`.\n        Will always return a value >= 1e-25, to prevent division-by-zero\n        errors in calculation code.  \n        """"""\n        return max(self.cell_a * self.cell_b * self.cell_c, 1e-25)\n\n    def get_weight(self):\n        """"""\n        Get the total atomic weight for this \n        :class:`~.Component`. \n        """"""\n        weight = 0\n        for atom in (self.layer_atoms + self.interlayer_atoms):\n            weight += atom.weight\n        return weight\n\n    # ------------------------------------------------------------\n    #      AtomRelation list related\n    # ------------------------------------------------------------\n    def move_atom_relation_up(self, relation):\n        """"""\n        Move the passed :class:`~..atom_relations.AtomRelation`\n        up one slot\n        """"""\n        index = self.atom_relations.index(relation)\n        del self.atom_relations[index]\n        self.atom_relations.insert(max(index - 1, 0), relation)\n\n    def move_atom_relation_down(self, relation):\n        """"""\n        Move the passed :class:`~..atom_relations.AtomRelation`\n        down one slot\n        """"""\n        index = self.atom_relations.index(relation)\n        del self.atom_relations[index]\n        self.atom_relations.insert(min(index + 1, len(self.atom_relations)), relation)\n\n    pass # end of class\n'"
pyxrd/phases/models/phase.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom warnings import warn\nfrom random import choice\n\nfrom mvc import Observer\nfrom mvc.observers import ListObserver\nfrom mvc.models.properties import (\n    StringProperty, SignalMixin, BoolProperty, LabeledProperty,\n    FloatProperty, ListProperty\n)\n\nfrom pyxrd.generic.io import storables, get_case_insensitive_glob\n\nfrom pyxrd.generic.models.properties import InheritableMixin, ObserveChildMixin\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\n\nfrom pyxrd.probabilities.models import get_correct_probability_model\n\nfrom .abstract_phase import AbstractPhase\nfrom .CSDS import DritsCSDSDistribution\nfrom .component import Component\n\n@storables.register()\nclass Phase(RefinementGroup, AbstractPhase, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(AbstractPhase.Meta):\n        store_id = ""Phase""\n        file_filters = [\n            (""Phase file"", get_case_insensitive_glob(""*.PHS"")),\n        ]\n\n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object.type = ""Phase""\n        self._data_object.valid_probs = (all(self.probabilities.P_valid) and all(self.probabilities.W_valid))\n\n        if self._data_object.valid_probs:\n            self._data_object.sigma_star = self.sigma_star\n            self._data_object.CSDS = self.CSDS_distribution.data_object\n\n            self._data_object.G = self.G\n            self._data_object.W = self.probabilities.get_distribution_matrix()\n            self._data_object.P = self.probabilities.get_probability_matrix()\n\n            self._data_object.components = [None] * len(self.components)\n            for i, comp in enumerate(self.components):\n                self._data_object.components[i] = comp.data_object\n        else:\n            self._data_object.sigma_star = None\n            self._data_object.CSDS = None\n            self._data_object.G = None\n            self._data_object.W = None\n            self._data_object.P = None\n            self._data_object.components = None\n\n        return self._data_object\n\n    project = property(AbstractPhase.parent.fget, AbstractPhase.parent.fset)\n\n    # PROPERTIES:\n\n    #: Flag indicating whether the CSDS distribution is inherited from the\n    #: :attr:`based_on` phase or not.\n    @BoolProperty(\n        default=False, text=""Inh. mean CSDS"",\n        visible=True, persistent=True, tabular=True\n    )\n    def inherit_CSDS_distribution(self):\n        return self._CSDS_distribution.inherited\n    @inherit_CSDS_distribution.setter\n    def inherit_CSDS_distribution(self, value):\n        self._CSDS_distribution.inherited = value\n\n    #: Flag indicating whether to inherit the display color from the\n    #: :attr:`based_on` phase or not.\n    inherit_display_color = BoolProperty(\n        default=False, text=""Inh. display color"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether to inherit the sigma start value from the\n    #: :attr:`based_on` phase or not.\n    inherit_sigma_star = BoolProperty(\n        default=False, text=""Inh. sigma star"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    _based_on_index = None # temporary property\n    _based_on_uuid = None # temporary property\n\n    #: The :class:`~Phase` instance this phase is based on\n    based_on = LabeledProperty(\n        default=None, text=""Based on phase"",\n        visible=True, persistent=False, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, ObserveChildMixin)\n    )\n    @based_on.setter\n    def based_on(self, value):\n        old = type(self).based_on._get(self)\n        if value == None or value.get_based_on_root() == self or value.parent != self.parent:\n            value = None\n        if value != old:\n            type(self).based_on._set(self, value)\n            for component in self.components:\n                component.linked_with = None\n\n    # INHERITABLE PROPERTIES:\n\n    #: The sigma star orientation factor\n    sigma_star = FloatProperty(\n        default=3.0, text=""\xcf\x83* [\xc2\xb0]"", math_text=""$\\sigma^*$ [\xc2\xb0]"",\n        minimum=0.0, maximum=90.0,\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_sigma_star"", inherit_from=""based_on.sigma_star"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # A :class:`~pyxrd.phases.models.CSDS` instance\n    CSDS_distribution = LabeledProperty(\n        default=None, text=""CSDS Distribution"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        inheritable=True, inherit_flag=""inherit_CSDS_distribution"", inherit_from=""based_on.CSDS_distribution"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, RefinableMixin, InheritableMixin, ObserveChildMixin)\n    )\n\n    # A :class:`~pyxrd._probabilities.models._AbstractProbability` subclass instance\n    probabilities = LabeledProperty(\n        default=None, text=""Probablities"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, RefinableMixin, ObserveChildMixin)\n    )\n    @probabilities.setter\n    def probabilities(self, value):\n        type(self).probabilities._set(self, value)\n        if value is not None:\n            value.update()\n\n    #: The color this phase\'s X-ray diffraction pattern should have.\n    display_color = StringProperty(\n        fset=AbstractPhase.display_color.fset,\n        fget=AbstractPhase.display_color.fget,\n        fdel=AbstractPhase.display_color.fdel,\n        doc=AbstractPhase.display_color.__doc__,\n        default=""#008600"", text=""Display color"",\n        visible=True, persistent=True, tabular=True, widget_type=\'color\',\n        inheritable=True, inherit_flag=""inherit_display_color"", inherit_from=""based_on.display_color"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin, InheritableMixin)\n    )\n\n    #: The list of components this phase consists of\n    components = ListProperty(\n        default=None, text=""Components"",\n        visible=True, persistent=True, tabular=True, refinable=True,\n        widget_type=""custom"", data_type=Component,\n        mix_with=(RefinableMixin,)\n    )\n\n    #: The # of components\n    @AbstractPhase.G.getter\n    def G(self):\n        if self.components is not None:\n            return len(self.components)\n        else:\n            return 0\n\n    #: The # of components\n    @AbstractPhase.R.getter\n    def R(self):\n        if self.probabilities:\n            return self.probabilities.R\n\n    # Flag indicating whether or not the links (based_on and linked_with) should\n    # be saved as well.\n    save_links = True\n\n    # REFINEMENT GROUP IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return self.name\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.refine_title,\n            component_name=""*""\n        )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_CSDS_distribution"", ""data_sigma_star"", ""data_components"",\n            ""data_G"", ""G"", ""data_R"", ""R"",\n            ""data_probabilities"", ""based_on_uuid"", ""based_on_index"",\n            ""inherit_probabilities"",\n            *[prop.label for prop in Phase.Meta.get_local_persistent_properties()]\n        )\n        super(Phase, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n\n            CSDS_distribution = self.get_kwarg(kwargs, None, ""CSDS_distribution"", ""data_CSDS_distribution"")\n            self.CSDS_distribution = self.parse_init_arg(\n                CSDS_distribution, DritsCSDSDistribution, child=True,\n                default_is_class=True, parent=self\n            )\n            self.inherit_CSDS_distribution = self.get_kwarg(kwargs, False, ""inherit_CSDS_distribution"")\n\n            self.display_color = self.get_kwarg(kwargs, choice(self.line_colors), ""display_color"")\n            self.inherit_display_color = self.get_kwarg(kwargs, False, ""inherit_display_color"")\n\n            self.sigma_star = self.get_kwarg(kwargs, self.sigma_star, ""sigma_star"", ""data_sigma_star"")\n            self.inherit_sigma_star = self.get_kwarg(kwargs, False, ""inherit_sigma_star"")\n\n            self.components = self.get_list(kwargs, [], ""components"", ""data_components"", parent=self)\n\n            G = int(self.get_kwarg(kwargs, 1, ""G"", ""data_G""))\n            R = int(self.get_kwarg(kwargs, 0, ""R"", ""data_R""))\n            if G is not None and G > 0:\n                for i in range(len(self.components), G):\n                    new_comp = Component(name=""Component %d"" % (i + 1), parent=self)\n                    self.components.append(new_comp)\n                    self.observe_model(new_comp)\n\n            # Observe components\n            for component in self.components:\n                self.observe_model(component)\n\n            # Connect signals to lists and dicts:\n            self._components_observer = ListObserver(\n                self.on_component_inserted,\n                self.on_component_removed,\n                prop_name=""components"",\n                model=self\n            )\n\n            self.probabilities = self.parse_init_arg(\n                self.get_kwarg(kwargs, None, ""probabilities"", ""data_probabilities""),\n                get_correct_probability_model(R, G), default_is_class=True, child=True)\n            self.probabilities.update() # force an update\n            inherit_probabilities = kwargs.pop(""inherit_probabilities"", None)\n            if inherit_probabilities is not None:\n                for prop in self.probabilities.Meta.get_inheritable_properties():\n                    setattr(self.probabilities, prop.inherit_flag, bool(inherit_probabilities))\n\n            self._based_on_uuid = self.get_kwarg(kwargs, None, ""based_on_uuid"")\n            self._based_on_index = self.get_kwarg(kwargs, None, ""based_on_index"")\n\n    def __repr__(self):\n        return ""Phase(name=\'%s\', based_on=%r)"" % (self.name, self.based_on)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    def on_component_inserted(self, item):\n        # Set parent and observe the new component (visuals changed signals):\n        if item.parent != self: item.parent = self\n        self.observe_model(item)\n\n    def on_component_removed(self, item):\n        with self.data_changed.hold_and_emit():\n            # Clear parent & stop observing:\n            item.parent = None\n            self.relieve_model(item)\n\n    @Observer.observe(""data_changed"", signal=True)\n    def notify_data_changed(self, model, prop_name, info):\n        if isinstance(model, Phase) and model == self.based_on:\n            with self.data_changed.hold():\n                # make sure inherited probabilities are up-to-date\n                self.probabilities.update()\n                self.data_changed.emit(arg=""based_on"")\n        else:\n            self.data_changed.emit()\n\n    @Observer.observe(""visuals_changed"", signal=True)\n    def notify_visuals_changed(self, model, prop_name, info):\n        self.visuals_changed.emit()\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def resolve_json_references(self):\n        # Set the based on and linked with variables:\n        if hasattr(self, ""_based_on_uuid"") and self._based_on_uuid is not None:\n            self.based_on = type(type(self)).object_pool.get_object(self._based_on_uuid)\n            del self._based_on_uuid\n        elif hasattr(self, ""_based_on_index"") and self._based_on_index is not None and self._based_on_index != -1:\n            warn(""The use of object indices is deprecated since version 0.4. Please switch to using object UUIDs."", DeprecationWarning)\n            self.based_on = self.parent.phases.get_user_from_index(self._based_on_index)\n            del self._based_on_index\n        for component in self.components:\n            component.resolve_json_references()\n        with self.data_changed.hold():\n            # make sure inherited probabilities are up-to-date\n            self.probabilities.update()\n\n    def _pre_multi_save(self, phases, ordered_phases):\n        ## Override from base class\n\n        if self.based_on != """" and not self.based_on in phases:\n            self.save_links = False\n        Component.export_atom_types = True\n        for component in self.components:\n            component.save_links = self.save_links\n\n        # Make sure parent is first in ordered list:\n        if self.based_on in phases:\n            index = ordered_phases.index(self)\n            index2 = ordered_phases.index(self.based_on)\n            if index < index2:\n                ordered_phases.remove(self.based_on)\n                ordered_phases.insert(index, self.based_on)\n\n    def _post_multi_save(self):\n        ## Override from base class\n        self.save_links = True\n        for component in self.components:\n            component.save_links = True\n        Component.export_atom_types = False\n\n    def json_properties(self):\n        retval = super(Phase, self).json_properties()\n        if not self.save_links:\n            for prop in self.Meta.all_properties:\n                if getattr(prop, ""inherit_flag"", False):\n                    retval[prop.inherit_flag] = False\n            retval[""based_on_uuid""] = """"\n        else:\n            retval[""based_on_uuid""] = self.based_on.uuid if self.based_on else """"\n        return retval\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def _update_interference_distributions(self):\n        return self.CSDS_distribution.distrib\n\n    def get_based_on_root(self):\n        """"""\n            Gets the root object in the based_on chain\n        """"""\n        if self.based_on is not None:\n            return self.based_on.get_based_on_root()\n        else:\n            return self\n\n    pass # end of class\n'"
pyxrd/phases/models/raw_pattern_phase.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom random import choice\nimport numpy as np\n\nfrom mvc.models.properties import LabeledProperty\nfrom mvc.models.properties.signal_mixin import SignalMixin\nfrom mvc.models.properties.observe_mixin import ObserveMixin\n\nfrom pyxrd.generic.io import storables, get_case_insensitive_glob\nfrom pyxrd.generic.models.lines import PyXRDLine\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup\nfrom pyxrd.file_parsers.xrd_parsers import xrd_parsers\n\nfrom .abstract_phase import AbstractPhase\n\n@storables.register()\nclass RawPatternPhase(RefinementGroup, AbstractPhase, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(AbstractPhase.Meta):\n        store_id = ""RawPatternPhase""\n        file_filters = [\n            (""Phase file"", get_case_insensitive_glob(""*.PHS"")),\n        ]\n        rp_filters = xrd_parsers.get_import_file_filters()\n        rp_export_filters = xrd_parsers.get_export_file_filters()\n\n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object.type = ""RawPatternPhase""\n\n        self._data_object.raw_pattern_x = self.raw_pattern.data_x\n        self._data_object.raw_pattern_y = self.raw_pattern.data_y[:, 0]\n        self._data_object.apply_lpf = False\n        self._data_object.apply_correction = False\n\n        return self._data_object\n\n    project = property(AbstractPhase.parent.fget, AbstractPhase.parent.fset)\n\n    @property\n    def refine_title(self):\n        return ""Raw Pattern Phase""\n\n    @property\n    def is_refinable(self):\n        return False\n\n    @property\n    def children_refinable(self):\n        return False\n\n    @property\n    def refinables(self):\n        return []\n\n    raw_pattern = LabeledProperty(\n        default=None, text=""Raw pattern"",\n        visible=True, persistent=True, tabular=True,\n        inheritable=True, inherit_flag=""inherit_CSDS_distribution"", inherit_from=""based_on.CSDS_distribution"",\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, ObserveMixin,)\n    )\n\n    @property\n    def spec_max_display_y(self):\n        """"""The maximum intensity (y-axis) of the current loaded profile""""""\n        _max = 0.0\n        if self.raw_pattern is not None:\n            _max = max(_max, np.max(self.raw_pattern.max_display_y))\n        return _max\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        my_kwargs = self.pop_kwargs(kwargs,\n            *[prop.label for prop in RawPatternPhase.Meta.get_local_persistent_properties()]\n        )\n        super(RawPatternPhase, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n            self.raw_pattern = PyXRDLine(\n                data=self.get_kwarg(kwargs, None, ""raw_pattern""),\n                parent=self\n            )\n            self.display_color = self.get_kwarg(kwargs, choice(self.line_colors), ""display_color"")\n            self.inherit_display_color = self.get_kwarg(kwargs, False, ""inherit_display_color"")\n\n    def __repr__(self):\n        return ""RawPatternPhase(name=\'%s\')"" % (self.name)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @AbstractPhase.observe(""data_changed"", signal=True)\n    def notify_data_changed(self, model, prop_name, info):\n        self.data_changed.emit() # propagate signal\n\n    pass #end of class\n'"
pyxrd/phases/models/unit_cell_prop.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.models.properties import (\n    StringProperty, BoolProperty, LabeledProperty, FloatProperty,\n    SignalMixin, SetActionMixin\n)\n\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.models import DataModel\n\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\nfrom pyxrd.refinement.refinables.mixins import RefinementValue\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\n\nfrom .atom_relations import ComponentPropMixin\n\n@storables.register()\nclass UnitCellProperty(ComponentPropMixin, RefinementValue, DataModel, Storable, metaclass=PyXRDRefinableMeta):\n    """"""\n        UnitCellProperty\'s are an integral part of a component and allow to \n        calculate the dimensions of the unit cell based on compositional\n        information such as the iron content.\n        This class is not responsible for keeping its value up-to-date.\n        With other words, it is the responsibility of the higher-level class\n        to call the \'update_value\' method on this object whenever it emits a\n        \'data_changed\' signal. The reason for this is to prevent infinite \n        recursion errors. \n    """"""\n    class Meta(DataModel.Meta):\n        store_id = ""UnitCellProperty""\n\n    component = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: The UnitCellProperty name\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=False, persistent=False,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating if this UnitCellProperty is enabled\n    enabled = BoolProperty(\n        default=False, text=""Enabled"",\n        visible=True, persistent=True,\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: Flag indicating if this UnitCellProperty is inherited\n    inherited = BoolProperty(\n        default=False, text=""Inherited"",\n        visible=False, persistent=False,\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The value of the UnitCellProperty\n    value = FloatProperty(\n        default=0.0, text=""Value"",\n        visible=True, persistent=True, refinable=True, widget_type=\'float_entry\',\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin, RefinableMixin)\n    )\n\n    #: The factor of the UnitCellProperty (if enabled and not constant)\n    factor = FloatProperty(\n        default=1.0, text=""Factor"",\n        visible=True, persistent=True, widget_type=\'float_entry\',\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The constant of the UnitCellProperty (if enabled and not constant)\n    constant = FloatProperty(\n        default=0.0, text=""Constant"",\n        visible=True, persistent=True, widget_type=\'float_entry\',\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin,)\n    )\n\n    _temp_prop = None # temporary, JSON-style prop\n    prop = LabeledProperty(\n        default=None, text=""Property"",\n        visible=True, persistent=True, widget_type=\'combo\',\n        set_action_name=""update_value"",\n        mix_with=(SetActionMixin,)\n    )\n\n    # REFINEMENT VALUE IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return self.name\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.component.phase.refine_title,\n            component_name=self.component.refine_title\n        )\n\n    @property\n    def refine_value(self):\n        return self.value\n    @refine_value.setter\n    def refine_value(self, value):\n        if not self.enabled:\n            self.value = value\n\n    @property\n    def refine_info(self):\n        return self.value_ref_info\n\n    @property\n    def is_refinable(self):\n        return not (self.enabled or self.inherited)\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        keys = [prop.label for prop in UnitCellProperty.Meta.get_local_persistent_properties()]\n        keys.extend([""data_%s"" % prop.label for prop in UnitCellProperty.Meta.get_local_persistent_properties()])\n        my_kwargs = self.pop_kwargs(kwargs, ""name"", *keys)\n        super(UnitCellProperty, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold_and_emit():\n            self.name = self.get_kwarg(kwargs, self.name, ""name"", ""data_name"")\n            self.value = self.get_kwarg(kwargs, self.value, ""value"", ""data_value"")\n            self.factor = self.get_kwarg(kwargs, self.factor, ""factor"", ""data_factor"")\n            self.constant = self.get_kwarg(kwargs, self.constant, ""constant"", ""data_constant"")\n            self.enabled = self.get_kwarg(kwargs, self.enabled, ""enabled"", ""data_enabled"")\n\n            self._temp_prop = self.get_kwarg(kwargs, self.prop, ""prop"", ""data_prop"")\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        retval = Storable.json_properties(self)\n        if retval[""prop""]:\n            # Try to replace objects with their uuid\'s:\n            try:\n                retval[""prop""] = [getattr(retval[""prop""][0], \'uuid\', retval[""prop""][0]), retval[""prop""][1]]\n            except:\n                logger.exception(""Error when trying to interpret UCP JSON properties"")\n                pass # ignore\n        return retval\n\n    def resolve_json_references(self):\n        if getattr(self, ""_temp_prop"", None):\n            self._temp_prop = list(self._temp_prop)\n            if isinstance(self._temp_prop[0], str):\n                obj = type(type(self)).object_pool.get_object(self._temp_prop[0])\n                if obj:\n                    self._temp_prop[0] = obj\n                    self.prop = self._temp_prop\n                else:\n                    self._temp_prop = None        \n            self.prop = self._temp_prop\n            del self._temp_prop\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def create_prop_store(self, extra_props=[]):\n        assert(self.component is not None)\n        store = Gtk.ListStore(object, str, str)\n        # use private properties so we connect to the actual object stores and not the inherited ones\n        for atom in self.component._layer_atoms:\n            store.append([atom, ""pn"", atom.name])\n        for atom in self.component._interlayer_atoms:\n            store.append([atom, ""pn"", atom.name])\n        for prop in extra_props:\n            store.append(prop)\n        return store\n\n    def get_value_of_prop(self):\n        try:\n            return getattr(*self.prop)\n        except:\n            return 0.0\n\n    def update_value(self):\n        if self.enabled:\n            self._value = float(self.factor * self.get_value_of_prop() + self.constant)\n            self.data_changed.emit()\n\n    pass # end of class\n'"
pyxrd/probabilities/models/R0models.py,4,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\n\nfrom mvc.models.properties import SetActionMixin, FloatProperty, BoolProperty\n\nfrom pyxrd.generic.io import storables\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.models.properties import InheritableMixin\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom .base_models import _AbstractProbability\n\ndef R0_model_generator(pasG):\n\n    class _R0Meta(_AbstractProbability.Meta):\n        store_id = ""R0G%dModel"" % pasG\n\n    class _BaseR0Model(object):\n        """"""\n        Probability model for Reichweite = 0\n        (g-1) independent variables:\n        \n        W0 = W0/sum(W0>Wg)\n        W1/sum(W1>Wg)\n        W2/sum(W2>Wg)\n        etc.\n        \n    \n        Pij = Wj\n        \xe2\x88\x91W = 1\n        \xe2\x88\x91P = 1\n    \n        indexes are NOT zero-based in external property names!\n        """"""\n\n        # ------------------------------------------------------------\n        #      Initialization and other internals\n        # ------------------------------------------------------------\n        def __init__(self, *args, **kwargs):\n            my_kwargs = self.pop_kwargs(kwargs, *[prop.label for prop in self.Meta.get_local_persistent_properties()])\n            super(_BaseR0Model, self).__init__(R=0, *args, **kwargs)\n\n            with self.data_changed.hold():\n                if self.G > 1 and ""W1"" in my_kwargs: # old-style model\n                    for i in range(self.G - 1):\n                        name = ""W%d"" % (i + 1)\n                        self.mW[i] = not_none(my_kwargs.get(name, None), 0.8)\n                        name = ""F%d"" % (i + 1)\n                        setattr(self, name, self.mW[i] / (np.sum(np.diag(self._W)[i:]) or 1.0))\n                else:\n                    for i in range(self.G - 1):\n                        name = ""inherit_F%d"" % (i + 1)\n                        setattr(self, name, my_kwargs.get(name, False))\n                        name = ""F%d"" % (i + 1)\n                        setattr(self, name, not_none(my_kwargs.get(name, None), 0.8))\n\n                self.update()\n\n        # ------------------------------------------------------------\n        #      Methods & Functions\n        # ------------------------------------------------------------\n        def update(self):\n            with self.monitor_changes():\n                if self.G > 1:\n                    for i in range(self.G - 1):\n                        name = ""F%d"" % (i + 1)\n                        if i > 0:\n                            self.mW[i] = getattr(self, name) * (1.0 - np.sum(np.diag(self._W)[0:i]))\n                        else:\n                            self.mW[i] = getattr(self, name)\n                    self.mW[self.G - 1] = 1.0 - np.sum(np.diag(self._W)[:-1])\n                else:\n                    self.mW[0] = 1.0\n                self._P[:] = np.repeat(np.diag(self._W)[np.newaxis, :], self.G, 0)\n\n                self.solve()\n                self.validate()\n\n        pass # end of class\n\n\n\n    _dict = dict()\n    _dict[""Meta""] = _R0Meta\n\n    def set_attribute(name, value): # @NoSelf\n        """"""Sets an attribute on the class and the dict""""""\n        _dict[name] = value\n        setattr(_BaseR0Model, name, value)\n\n    set_attribute(""G"", pasG)\n\n    # PROPERTIES:\n    for g in range(pasG - 1):\n        label = ""F%d"" % (g + 1)\n        text = ""W%(g)d/Sum(W%(g)d+...+W%(G)d)"" % {\'g\':g + 1, \'G\':pasG }\n        math_text = r""$\\large\\frac{W_{%(g)d}}{\\sum_{i=%(g)d}^{%(G)d} W_i}$"" % {\'g\':g + 1, \'G\':pasG }\n        inh_flag = ""inherit_F%d"" % (g + 1)\n        inh_from = ""parent.based_on.probabilities.F%d"" % (g + 1)\n\n        set_attribute(label, FloatProperty(\n            default=0.8, text=text, math_text=math_text,\n            refinable=True, persistent=True, visible=True,\n            minimum=0.0, maximum=1.0,\n            inheritable=True, inherit_flag=inh_flag, inherit_from=inh_from,\n            is_independent=True, store_private=True,\n            set_action_name=""update"",\n            mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n        ))\n\n        label = ""inherit_F%d"" % (g + 1)\n        text = ""Inherit flag for F%d"" % (g + 1)\n        set_attribute(label, BoolProperty(\n            default=False, text=text,\n            refinable=False, persistent=True, visible=True,\n            set_action_name=""update"",\n            mix_with=(SetActionMixin,)\n        ))\n\n    # CREATE TYPE AND REGISTER AS STORABLE:\n    cls = type(""R0G%dModel"" % pasG, (_BaseR0Model, _AbstractProbability), _dict)\n    storables.register_decorator(cls)\n\n    return cls\n\nR0G1Model = R0_model_generator(1)\nR0G2Model = R0_model_generator(2)\nR0G3Model = R0_model_generator(3)\nR0G4Model = R0_model_generator(4)\nR0G5Model = R0_model_generator(5)\nR0G6Model = R0_model_generator(6)\n\n__all__ = [\n    ""R0G1Model"",\n    ""R0G2Model"",\n    ""R0G3Model"",\n    ""R0G4Model"",\n    ""R0G5Model"",\n    ""R0G6Model""\n]\n'"
pyxrd/probabilities/models/R1models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n\nfrom mvc.models.properties import FloatProperty, BoolProperty\n\nfrom pyxrd.generic.mathtext_support import mt_range\nfrom pyxrd.generic.io import storables\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.models.properties import InheritableMixin\n\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom .base_models import _AbstractProbability\nfrom mvc.models.properties.action_mixins import SetActionMixin\n\n__all__ = [\n    ""R1G2Model"",\n    ""R1G3Model"",\n    ""R1G4Model"",\n]\n\n@storables.register()\nclass R1G2Model(_AbstractProbability):\n    r""""""\n    Probability model for Reichweite 1 with 2 components.\n    \n    The 2(=g*(g-1)) independent variables are:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{flalign*}\n            & W_1 \\\\\n            & \\text{$P_{11} (W_1 < 0.5)$ or $P_{22} (W_1 > 0.5)$}\n        \\end{flalign*}\n    \n    Calculation of the other variables happens as follows:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & W_2 = 1 \xe2\x80\x93 W_1 \\\\\n            & \\begin{aligned}\n                & \\text{$P_{11}$ is given:}  \\\\\n                & \\quad P_{12} = 1 - P_{11} \\\\\n                & \\quad P_{21} = \\frac{W_1 \\cdot P_{12}}{W2} \\\\\n                & \\quad P_{22} = 1 - P_{21} \\\\\n            \\end{aligned}\n            \\quad \\quad\n            \\begin{aligned}\n                & \\text{$P_{22}$ is given:} \\\\\n                & \\quad P_{21} = 1 - P_{22} \\\\\n                & \\quad P_{12} = \\frac{W_2 \\cdot P_{21}}{W1} \\\\\n                & \\quad P_{11} = 1 - P_{12} \\\\            \n            \\end{aligned} \\\\\n        \\end{align*}\n        \n    """"""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R1G2Model""\n\n    # PROPERTIES:\n    _G = 2\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n\n    W1 = FloatProperty(\n        default=0.0, text=""W1"", math_text=r""$W_1$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P11_or_P22 = BoolProperty(\n        default=False, text=""Inherit flag for P11_or_P22"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n\n    P11_or_P22 = FloatProperty(\n        default=0.0, text=""P11_or_P22"",\n        math_text=r""$P_{11} %s$ or $\\newline P_{22} %s$"" % (\n            mt_range(0.0, ""W_1"", 0.5),\n            mt_range(0.5, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P11_or_P22"", inherit_from=""parent.based_on.probabilities.P11_or_P22"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, W1=0.75, P11_or_P22=0.5, inherit_W1=False, inherit_P11_or_P22=False, *args, **kwargs):\n        super(R1G2Model, self).__init__(R=1, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.75)\n            self.inherit_W1 = inherit_W1\n            self.P11_or_P22 = not_none(P11_or_P22, 0.5)\n            self.inherit_P11_or_P22 = inherit_P11_or_P22\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n            self.mW[0] = self.W1\n            self.mW[1] = 1.0 - self.mW[0]\n            if self.mW[0] <= 0.5:\n                self.mP[0, 0] = self.P11_or_P22\n                self.mP[0, 1] = 1.0 - self.mP[0, 0]\n                self.mP[1, 0] = self.mW[0] * self.mP[0, 1] / self.mW[1]\n                self.mP[1, 1] = 1.0 - self.mP[1, 0]\n            else:\n                self.mP[1, 1] = self.P11_or_P22\n                self.mP[1, 0] = 1.0 - self.mP[1, 1]\n                self.mP[0, 1] = self.mW[1] * self.mP[1, 0] / self.mW[0]\n                self.mP[0, 0] = 1.0 - self.mP[0, 1]\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n\n@storables.register()\nclass R1G3Model(_AbstractProbability):\n    r""""""\n    Probability model for Reichweite 1 with 3 components.\n    \n    The 6 (=g*(g-1)) independent variables are:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n                & W_1\n                & \\text{$P_{11} (W_1 < 0.5)$ or $P_{xx} (W_1 > 0.5)$}\n                with P_{xx} = \\frac {W_{22} + W_{23} + W_{32} + W_{33} + W_{42} + W_{43}}{W_2 + W_3} \\\\\n                & G_1 = \\frac{W_2}{W_2 + W_3}\n                & G_2 = \\frac{W_{22} + W_{23}}{W_{22} + W_{23} + W_{32} + W_{33}} \\\\\n                & G_3 = \\frac{W_{22}}{W_{22} + W_{23}}\n                & G_4 = \\frac{W_{32}}{W_{32} + W_{33}} \\\\\n        \\end{align*}\n            \n    Calculation of the other variables happens as follows:\n    \n    \n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & \\text{Calculate the \'inverted\' ratios of $G_2$, $G_3$ and $G_4$ as follows:} \\\\\n            & \\quad G_i^{\\text{-1}} =\n            \\begin{cases}\n                G_i^{-1} - 1.0, & \\text{if } G_i > 0 \\\\\n                0,              & \\text{otherwise}\n            \\end{cases} \\quad \\forall i \\in \\left\\{ {2, 3, 4}\\right\\} \\\\\n            & \\\\\n            & \\text{Calculate the base weight fractions of each component:} \\\\\n            & \\quad W_2 = (1 - W_1) \\cdot G_1\\\\\n            & \\quad W_3 = 1.0 - W_1 - W_2 \\\\\n            & \\\\\n            & \\text{if $W_1 \\leq 0.5$:} \\\\\n            & \\quad \\text{$P_{11}$ is given and W_xx is derived as} \\\\\n            & \\quad W_{xx} = W_{22} + W_{23} + W_{32} + W_{23} = W_1 \\cdot (1 - P_{11}) + W_2 + W_3 \\\\ \n            & \\\\\n            & \\text{if $W_1 > 0.5$:} \\\\\n            & \\quad \\text{$P_{xx}$ is given and $P_{11}$ is derived further down} \\\\\n            & \\quad W_{xx} = W_{22} + W_{23} + W_{32} + W_{23} = P_{xx} \\cdot (W_2 + W_3) \\\\\n            & \\\\\n            & W_{22} = W_{xx} \\cdot G_2 \\cdot G_3 \\\\\n            & W_{23} = W_{22} \\cdot G_3^{-1} \\\\\n            & W_{32} = W_{xx} \\cdot (1 - G_2) \\\\\n            & W_{33} = G_4^{-1} \\cdot W_{32} \\\\\n            & \\\\\n            & P_{23} = \n            \\begin{dcases}\n                \\dfrac{W_{23}}{W_2}, & \\text{if $W_2 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{12} = 1 - P_{22} - P_{23} \\\\\n            & \\\\\n            & P_{32} =\n            \\begin{dcases}\n                \\frac{W_{32}}{W_3}, & \\text{if $W_3 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{33} =\n            \\begin{dcases}\n                \\frac{W_{33}}{W_3}, & \\text{if $W_3 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{31} = 1 - P_{32} - P_{33} \\\\\n            & \\\\\n            & P_{12} =\n            \\begin{dcases}\n                \\frac{W_2 - W_{22} - W_{32}}{W_1}, & \\text{if $W_1 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{13} =\n            \\begin{dcases}\n                \\frac{W_3 - W_{23} - W_{33}}{W_1}, & \\text{if $W_1 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & \\text{if $W_1 > 0.5$}: \\\\\n            & \\quad P_{11} = 1 - P_{12} - P_{13} \\\\\n            & \\\\\n            & \\text{Remainder of weight fraction can be calculated as follows:} \\\\\n            & \\quad W_{ij} = {W_{ii}} \\cdot {P_{ij}} \\quad \\forall {i,j} \\in \\left[ {1, 3} \\right] \\\\\n        \\end{align*}\n        \n    """"""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R1G3Model""\n\n    # PROPERTIES\n    _G = 3\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    W1 = FloatProperty(\n        default=0.8, text=""W1"", math_text=r""$W_1$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P11_or_P22 = BoolProperty(\n        default=False, text=""Inherit flag for P11_or_P22"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P11_or_P22 = FloatProperty(\n        default=0.7, text=""P11_or_P22"",\n        math_text=r""$P_{11} %s$ or $\\newline P_{22} %s$"" % (\n            mt_range(0.0, ""W_1"", 0.5),\n            mt_range(0.5, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P11_or_P22"", inherit_from=""parent.based_on.probabilities.P11_or_P22"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G1 = BoolProperty(\n        default=False, text=""Inherit flag for G1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G1 = FloatProperty(\n        default=0.7, text=""W2/(W2+W3)"",\n        math_text=r""$\\large\\frac{W_2}{W_3 + W_2}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G1"", inherit_from=""parent.based_on.probabilities.G1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G2 = BoolProperty(\n        default=False, text=""Inherit flag for G2"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G2 = FloatProperty(\n        default=0.7, text=""(W22+W23)/(W22+W23+W32+W33)"",\n        math_text=r""$\\large\\frac{W_{22} + W_{23}}{W_{22} + W_{23} + W_{32} + W_{33}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G2"", inherit_from=""parent.based_on.probabilities.G2"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G3 = BoolProperty(\n        default=False, text=""Inherit flag for G3"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G3 = FloatProperty(\n        default=0.7, text=""W22/(W22+W23)"",\n        math_text=r""$\\large\\frac{W_{22}}{W_{22} + W_{23}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G3"", inherit_from=""parent.based_on.probabilities.G3"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G4 = BoolProperty(\n        default=False, text=""Inherit flag for G4"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G4 = FloatProperty(\n        default=0.7, text=""W23/(W32+W33)"",\n        math_text=r""$\\large\\frac{W_{22}}{W_{22} + W_{23}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G4"", inherit_from=""parent.based_on.probabilities.G4"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, W1=0.8, P11_or_P22=0.7, G1=0.7, G2=0.7, G3=0.7, G4=0.7,\n            inherit_W1=False, inherit_P11_or_P22=False, inherit_G1=False,\n            inherit_G2=False, inherit_G3=False, inherit_G4=False, *args, **kwargs):\n        super(R1G3Model, self).__init__(R=1, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.8)\n            self.inherit_W1 = bool(inherit_W1)\n            self.P11_or_P22 = not_none(P11_or_P22, 0.7)\n            self.inherit_P11_or_P22 = bool(inherit_P11_or_P22)\n            self.G1 = not_none(G1, 0.7)\n            self.inherit_G1 = bool(inherit_G1)\n            self.G2 = not_none(G2, 0.7)\n            self.inherit_G2 = bool(inherit_G2)\n            self.G3 = not_none(G3, 0.7)\n            self.inherit_G3 = bool(inherit_G3)\n            self.G4 = not_none(G4, 0.7)\n            self.inherit_G4 = bool(inherit_G4)\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n            self.mW[0] = self.W1\n            self.mW[1] = (1 - self.mW[0]) * self.G1\n            self.mW[2] = 1.0 - self.mW[0] - self.mW[1]\n\n            W0inv = 1.0 / self.mW[0] if self.mW[0] > 0.0 else 0.0\n\n            Wxx = 0\n            if self.mW[0] <= 0.5: # P00 given\n                self.mP[0, 0] = self.P11_or_P22\n                # Wxx = W11 + W12 + W21 + W22\n                Wxx = self.mW[0] * (self.mP[0, 0] - 1) + self.mW[1] + self.mW[2]\n            else: # Pxx given\n                # Wxx = W11 + W12 + W21 + W22\n                Wxx = (1.0 - self.mW[0]) * self.P11_or_P22\n\n            # W11 + W12 = Wxx * G2:\n            self.mW[1, 1] = Wxx * self.G2 * self.G3\n            self.mW[1, 2] = Wxx * self.G2 * (1 - self.G3)\n            self.mP[1, 1] = self.mW[1, 1] / self.mW[1] if self.mW[1] > 0.0 else 0.0\n\n            self.mW[2, 1] = Wxx * (1 - self.G2) * self.G4\n            self.mW[2, 2] = Wxx * (1 - self.G2) * (1 - self.G4)\n\n            self.mP[1, 2] = (self.mW[1, 2] / self.mW[1]) if self.mW[1] > 0.0 else 0.0\n            self.mP[1, 0] = 1 - self.mP[1, 1] - self.mP[1, 2]\n\n            self.mP[2, 1] = (self.mW[2, 1] / self.mW[2]) if self.mW[2] > 0.0 else 0.0\n            self.mP[2, 2] = (self.mW[2, 2] / self.mW[2]) if self.mW[2] > 0.0 else 0.0\n            self.mP[2, 0] = 1 - self.mP[2, 1] - self.mP[2, 2]\n\n            self.mP[0, 1] = (self.mW[1] - self.mW[1, 1] - self.mW[2, 1]) * W0inv\n            self.mP[0, 2] = (self.mW[2] - self.mW[1, 2] - self.mW[2, 2]) * W0inv\n\n            if self.mW[0] > 0.5:\n                self.mP[0, 0] = 1 - self.mP[0, 1] - self.mP[0, 2]\n\n            for i in range(3):\n                for j in range(3):\n                    self.mW[i, j] = self.mW[i, i] * self.mP[i, j]\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n\n@storables.register()\nclass R1G4Model(_AbstractProbability):\n\n    r""""""\n    Probability model for Reichweite 1 with 4 components.\n    \n    The independent variables (# = g*(g-1) = 12) are:\n    \n    .. math::\n        :nowrap:\n        \n            \\begin{align*}\n                & W_1\n                & P_{11} (W_1 < 0,5)\\text{ or }P_{xx} (W_1 > 0,5) \n                with P_{xx} = \\frac {W_{22} + W_{23} + W_{24} + W_{32} + W_{33} + W_{34} + W_{42} + W_{43} + W_{44}}{W_2 + W_3 + W_4} \\\\\n                & R_2 = \\frac{ W_2 }{W_2 + W_3 + W_4}\n                & R_3 = \\frac{ W_3 }{W_3 + W_4} \\\\\n                & G_2 = \\frac{W_{22} + W_{23} + W_{24}}{\\sum_{i=2}^{4}\\sum_{j=2}^4{W_{ij}}}\n                & G_3 = \\frac{W_{32} + W_{33} + W_{34}}{\\sum_{i=3}^{4}\\sum_{j=2}^4{W_{ij}}} \\\\\n                & G_{22} = \\frac{W_{22}}{W_{22} + W_{23} + W_{24}}\n                & G_{23} = \\frac{W_{23}}{W_{23} + W_{24}} \\\\\n                & G_{32} = \\frac{W_{32}}{W_{32} + W_{33} + W_{34}}\n                & G_{33} = \\frac{W_{33}}{W_{33} + W_{34}} \\\\\n                & G_{42} = \\frac{W_{42}}{W_{42} + W_{43} + W_{44}}\n                & G_{44} = \\frac{W_{43}}{W_{43} + W_{44}}\n            \\end{align*} \n    \n    Calculation of the other variables happens as follows:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & \\text{Calculate the base weight fractions of each component:} \\\\\n            & W_2 = (1 - W_1) \\cdot R_1 \\\\\n            & W_3 = (1 - W_1 - W_2) \\cdot R_2 \\\\\n            & W_4 = (1 - W_1 - W_2 - W_3) \\\\\n            & \\\\\n            & \\text{if $W_1 \\leq 0.5$:} \\\\\n            & \\quad \\text{$P_{11}$ is given}\\\\\n            & \\quad W_{xx} = W_{22} + W_{23} + W_{24} + W_{32} + W_{33} + W_{34} + W_{42} + W_{43} + W_{44} = W_1 \\cdot (1 - P_{11}) + W_2 + W_3 + W_4 \\\\\n            & \\text{if $W_1 > 0.5$:} \\\\\n            & \\quad \\text{$P_{xx}$ is given and $P_{11}$ is derived further down} \\\\\n            & \\quad W_{xx} = W_{22} + W_{23} + W_{24} + W_{32} + W_{33} + W_{34} + W_{42} + W_{43} + W_{44} = P_{xx} \\cdot (W_2 + W_3 + W_4) \\\\  \n            & \\\\\n            & \\text{Caclulate a partial sum of the $2^{nd}$ component\'s contributions: } \\\\\n            & W_{2x} = W_{xx} \\cdot G_2 \\\\\n            & \\text{Calculate a partial sum of the $3^{d}$ and $4^{th}$ component\'s contributions:} \\\\\n            & W_{yx} = W_{xx} - W_{2x} \\\\\n            & \\text{Calculate a partial sum of the $3^{d}$ component\'s contributions:} \\\\\n            & W_{3x} = W_{yx} \\cdot G_3 \\\\\n            & \\text{Calculate a partial sum of the $4^{th}$ component\'s contributions:} \\\\\n            & W_{4x} = W_{yx} - W_{3x} \\\\\n            & \\\\\n            & W_{22} = G_{22} \\cdot W_{2x} \\\\\n            & W_{23} = G_{23} \\cdot (W_{2x} - W_{22}) \\\\\n            & W_{24} = W{2x} - W_{22} - W_{23} \\\\\n            & \\\\\n            & W_{32} = G_{32} \\cdot W_{3x} \\\\\n            & W_{33} = G_{33} \\cdot (W_{3x} - W_{32}) \\\\\n            & W_{34} = W{3x} - W_{32} - W_{33} \\\\\n            & \\\\\n            & W_{42} = G_{42} \\cdot W_{4x} \\\\\n            & W_{43} = G_{43} \\cdot (W_{4x} - W_{42}) \\\\\n            & W_{44} = W{4x} - W_{42} - W_{43} \\\\\n            & \\\\\n            & \\text{ From the above weight fractions the junction probabilities \n                for any combination of $2^{nd}$, $3^{d}$ and $4^{th}$ type\n                components can be calculated. } \\\\\n            & \\text{ The remaining probabilities are: } \\\\\n            & P_{12} = \\begin{dcases}\n                \\frac{W_2 - W_{22} - W_{32} - W_{42}}{W_1}, & \\text{if $W_1 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{13} = \\begin{dcases}\n                \\frac{W_3 - W_{23} - W_{33} - W_{43}}{W_1}, & \\text{if $W_1 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{14} = \\begin{dcases}\n                \\frac{W_4 - W_{24} - W_{34} - W_{44}}{W_1}, & \\text{if $W_1 > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & \\text{if $W_1 \\leq 0.5$}: \\\\\n            & \\quad P_{11} = 1 - P_{12} - P_{13} - P_{14} \\\\\n            & \\text{Remainder of weight fraction can now be calculated as follows:} \\\\\n            & \\quad W_{ij} = {W_{ii}} \\cdot {P_{ij}} \\quad \\forall {i,j} \\in \\left[ {1, 4} \\right] \\\\\n        \\end{align*}\n    """"""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R1G4Model""\n\n    # PROPERTIES\n    _G = 4\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    W1 = FloatProperty(\n        default=0.6, text=""W1"", math_text=r""$W_1$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P11_or_P22 = BoolProperty(\n        default=False, text=""Inherit flag for P11_or_P22"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P11_or_P22 = FloatProperty(\n        default=0.25, text=""P11_or_P22"",\n        math_text=r""$P_{11} %s$ or $\\newline P_{22} %s$"" % (\n            mt_range(0.0, ""W_1"", 0.5),\n            mt_range(0.5, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P11_or_P22"", inherit_from=""parent.based_on.probabilities.P11_or_P22"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_R1 = BoolProperty(\n        default=False, text=""Inherit flag for R1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    R1 = FloatProperty(\n        default=0.5, text=""W2/(W2+W3+W4)"",\n        math_text=r""$\\large\\frac{W_2}{W_2 + W_3 + W_4}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_R1"", inherit_from=""parent.based_on.probabilities.R1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_R2 = BoolProperty(\n        default=False, text=""Inherit flag for R2"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    R2 = FloatProperty(\n        default=0.5, text=""W3/(W3+W4)"",\n        math_text=r""$\\large\\frac{W_3}{W_3 + W_4}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_R2"", inherit_from=""parent.based_on.probabilities.R2"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G1 = BoolProperty(\n        default=False, text=""Inherit flag for G1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G1 = FloatProperty(\n        default=0.5, text=""(W22+W23+W24)/(W22+W23+W24+W32+W33+W34+W42+W43+W44)"",\n        math_text=r""$\\large\\frac{\\sum_{j=2}^{4} W_{2j}}{\\sum_{i=2}^{4} \\sum_{j=2}^{4} W_{ij}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G1"", inherit_from=""parent.based_on.probabilities.G1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G2 = BoolProperty(\n        default=False, text=""Inherit flag for G2"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G2 = FloatProperty(\n        default=0.4, text=""(W32+W33+W34)/(W32+W33+W34+W42+W43+W44)"",\n        math_text=r""$\\large\\frac{\\sum_{j=2}^{4} W_{3j}}{\\sum_{i=3}^{4} \\sum_{j=2}^{4} W_{ij}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G2"", inherit_from=""parent.based_on.probabilities.G2"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G11 = BoolProperty(\n        default=False, text=""Inherit flag for G11"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G11 = FloatProperty(\n        default=0.5, text=""W22/(W22+W23+W24)"",\n        math_text=r""$\\large\\frac{W_{22}}{\\sum_{j=2}^{4} W_{2j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G11"", inherit_from=""parent.based_on.probabilities.G11"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G12 = BoolProperty(\n        default=False, text=""Inherit flag for G12"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G12 = FloatProperty(\n        default=0.5, text=""W23/(W23+W24)"",\n        math_text=r""$\\large\\frac{W_{23}}{\\sum_{j=3}^{4} W_{2j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G12"", inherit_from=""parent.based_on.probabilities.G12"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G21 = BoolProperty(\n        default=False, text=""Inherit flag for G21"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G21 = FloatProperty(\n        default=0.8, text=""W32/(W32+W33+W34)"",\n        math_text=r""$\\large\\frac{W_{32}}{\\sum_{j=2}^{4} W_{3j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G21"", inherit_from=""parent.based_on.probabilities.G21"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G22 = BoolProperty(\n        default=False, text=""Inherit flag for G22"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G22 = FloatProperty(\n        default=0.8, text=""W33/(W32+W34)"",\n        math_text=r""$\\large\\frac{W_{33}}{\\sum_{j=3}^{4} W_{3j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G22"", inherit_from=""parent.based_on.probabilities.G22"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G31 = BoolProperty(\n        default=False, text=""Inherit flag for G31"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G31 = FloatProperty(\n        default=0.7, text=""W42/(W42+W43+W44)"",\n        math_text=r""$\\large\\frac{W_{42}}{\\sum_{j=2}^{4} W_{4j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G31"", inherit_from=""parent.based_on.probabilities.G31"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G32 = BoolProperty(\n        default=False, text=""Inherit flag for G32"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G32 = FloatProperty(\n        default=0.5, text=""W43/(W43+W44)"",\n        math_text=r""$\\large\\frac{W_{43}}{\\sum_{j=3}^{4} W_{4j}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G32"", inherit_from=""parent.based_on.probabilities.G32"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n\n    def __init__(self, W1=0.6, P11_or_P22=0.25, R1=0.5, R2=0.5, G1=0.5, G2=0.4,\n            G11=0.5, G12=0.5, G21=0.8, G22=0.75, G31=0.7, G32=0.5,\n            inherit_W1=False, inherit_P11_or_P22=False, inherit_R1=False,\n            inherit_R2=False, inherit_G1=False, inherit_G2=False,\n            inherit_G11=False, inherit_G12=False, inherit_G21=False,\n            inherit_G22=False, inherit_G31=False, inherit_G32=False, *args, **kwargs):\n        super(R1G4Model, self).__init__(R=1, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.6)\n            self.inherit_W1 = inherit_W1\n            self.P11_or_P22 = not_none(P11_or_P22, 0.25)\n            self.inherit_P11_or_P22 = inherit_P11_or_P22\n            self.R1 = not_none(R1, 0.5)\n            self.inherit_R1 = inherit_R1\n            self.R2 = not_none(R2, 0.5)\n            self.inherit_R2 = inherit_R2\n            self.G1 = not_none(G1, 0.5)\n            self.inherit_G1 = inherit_G1\n            self.G2 = not_none(G2, 0.4)\n            self.inherit_G2 = inherit_G2\n            self.G11 = not_none(G11, 0.5)\n            self.inherit_G11 = inherit_G11\n            self.G12 = not_none(G12, 0.5)\n            self.inherit_G12 = inherit_G12\n            self.G21 = not_none(G21, 0.8)\n            self.inherit_G21 = inherit_G21\n            self.G22 = not_none(G22, 0.75)\n            self.inherit_G22 = inherit_G22\n            self.G31 = not_none(G31, 0.7)\n            self.inherit_G31 = inherit_G31\n            self.G32 = not_none(G32, 0.5)\n            self.inherit_G32 = inherit_G32\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n            self.mW[0] = self.W1\n            self.mW[1] = (1.0 - self.mW[0]) * self.R1\n            self.mW[2] = (1.0 - self.mW[0] - self.mW[1]) * self.R2\n            self.mW[3] = 1.0 - self.mW[0] - self.mW[1] - self.mW[2]\n\n            W0inv = 1.0 / self.mW[0] if self.mW[0] > 0.0 else 0.0\n\n            if self.mW[0] < 0.5: # P11 is given\n                self.mP[0, 0] = self.P11_or_P22\n                Wxx = self.mW[0] * (self.mP[0, 0] - 1) + self.mW[1] + self.mW[2] + self.mW[3]\n            else: # P22 is given\n                Wxx = self.P11_or_P22 * (self.mW[1] + self.mW[2] + self.mW[3])\n\n            W1x = Wxx * self.G1 # = W11 + W12 + W13\n            Wyx = (Wxx - W1x)   # = W21 + W22 + W23 + W31 + W32 + W33\n            W2x = Wyx * self.G2 # = W21 + W22 + W23\n            W3x = Wyx - W2x     # = W31 + W32 + W33\n\n            self.mW[1, 1] = self.G11 * W1x\n            self.mW[1, 2] = self.G12 * (W1x - self.mW[1, 1])\n            self.mW[1, 3] = W1x - self.mW[1, 1] - self.mW[1, 2]\n\n            self.mW[2, 1] = self.G21 * W2x\n            self.mW[2, 2] = self.G22 * (W2x - self.mW[2, 1])\n            self.mW[2, 3] = W2x - self.mW[2, 1] - self.mW[2, 2]\n\n            self.mW[3, 1] = self.G31 * W3x\n            self.mW[3, 2] = self.G32 * (W3x - self.mW[3, 1])\n            self.mW[3, 3] = W3x - self.mW[3, 1] - self.mW[3, 2]\n\n            for i in range(1, 4):\n                self.mP[i, 0] = 1\n                for j in range(1, 4):\n                    self.mP[i, j] = self.mW[i, j] / self.mW[i] if self.mW[i] > 0 else 0\n                    self.mP[i, 0] -= self.mP[i, j]\n                self.mW[i, 0] = self.mW[i] * self.mP[i, 0]\n\n            self.mP[0, 1] = (self.mW[1] - self.mW[1, 1] - self.mW[2, 1] - self.mW[3, 1]) * W0inv\n            self.mP[0, 2] = (self.mW[2] - self.mW[1, 2] - self.mW[2, 2] - self.mW[3, 2]) * W0inv\n            self.mP[0, 3] = (self.mW[3] - self.mW[1, 3] - self.mW[2, 3] - self.mW[3, 3]) * W0inv\n\n            if self.mW[0] >= 0.5:\n                self.mP[0, 0] = 1 - self.mP[0, 1] - self.mP[0, 2] - self.mP[0, 3]\n\n            for i in range(4):\n                for j in range(4):\n                    self.mW[i, j] = self.mW[i] * self.mP[i, j]\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n'"
pyxrd/probabilities/models/R2models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties import BoolProperty, FloatProperty\n\nfrom pyxrd.generic.mathtext_support import mt_range\nfrom pyxrd.generic.io import storables\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.models.properties import InheritableMixin\n\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom .base_models import _AbstractProbability\nfrom mvc.models.properties.action_mixins import SetActionMixin\n\n__all__ = [\n    ""R2G2Model"",\n    ""R2G3Model""\n]\n\n@storables.register()\nclass R2G2Model(_AbstractProbability):\n    r""""""\n    Probability model for Reichweite 2 with 2 components.\n    \n    The 4 (=g^2) independent variables are:\n    \n    .. math::\n        :nowrap:\n    \n        \\begin{align*}\n            & W_1\n            & P_{112} (W_1 leq \\nicefrac{2}{3})\n            \\text{ or }P_{211} (W_1 > \\nicefrac{2}{3}) \\\\\n            & P_{21}\n            & P_{122} (P_{21} leq \\nicefrac{1}{2})\n            \\text{ or }P_{221} (P_{21} > \\nicefrac{1}{2}) \\\\\n        \\end{align*}\n            \n    Calculation of the other variables happens as follows:\n    \n    .. math::\n        :nowrap:\n\n        \\begin{align*}\n            & W_2 = 1 - W_1 \\\\\n            & P_{22} = 1 - P_{21} \\\\\n            & \\\\\n            & W_{21} = W_2 \\cdot P_{21} \\\\\n            & W_{21} = W_{12} \\\\\n            & W_{11} = W_1 - W_{21} \\\\\n            & W_{22} = W_{2} \\cdot P_{22} \\\\\n            & \\\\\n            & \\text{if $W_1 leq \\nicefrac{2}{3}$:} \\\\\n            & \\quad \\text{$P_{112}$ is given}\\\\\n            & \\quad P_{211} =\n            \\begin{dcases}\n                \\frac{W_{11}}{W_{21}} \\cdot P_{112} , & \\text{if $W_{21} > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & \\text{if $W_1 > \\nicefrac{2}{3}$:} \\\\\n            & \\quad \\text{$P_{211}$ is given}\\\\\n            & \\quad P_{112} =\n            \\begin{dcases}\n                \\frac{W_{21}}{W_{11}} \\cdot P_{211} , & \\text{if $W_{11} > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & P_{212} = 1 - P_{211} \\\\\n            & P_{111} = 1 - P_{112} \\\\\n            & \\\\\n            & \\text{if $P_{21} leq \\nicefrac{1}{2}$:} \\\\\n            & \\quad \\text{$P_{122}$ is given}\\\\\n            & \\quad P_{221} =\n            \\begin{dcases}\n                \\frac{W_{12}}{W_{22}} \\cdot P_{122} , & \\text{if $W_{22} > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & \\text{if $P_{21} > \\nicefrac{1}{2}$:} \\\\\n            & \\quad \\text{$P_{221}$ is given}\\\\\n            & \\quad P_{122} =\n            \\begin{dcases}\n                \\frac{W_{22}}{W_{12}} \\cdot P_{221} , & \\text{if $W_{12} > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & P_{121} = 1 - P_{122} \\\\\n            & P_{222} = 1 - P_{221} \\\\\n        \\end{align*}\n    \n    """"""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R2G2Model""\n\n    # PROPERTIES:\n    _G = 2\n    twothirds = 2.0 / 3.0\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    W1 = FloatProperty(\n        default=0.75, text=""W1 (> 0.5)"", math_text=r""$W_1 (> 0.5)$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.5, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P112_or_P211 = BoolProperty(\n        default=False, text=""Inherit flag for P112_or_P211"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P112_or_P211 = FloatProperty(\n        default=0.75, text=""P112 (W1 < 2/3) or\\nP211 (W1 > 2/3)"",\n        math_text=r""$P_{112} %s$ or $\\newlineP_{211} %s$"" % (\n            mt_range(1.0 / 2.0, ""W_1"", 2.0 / 3.0),\n            mt_range(2.0 / 3.0, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P112_or_P211"", inherit_from=""parent.based_on.probabilities.P112_or_P211"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P21 = BoolProperty(\n        default=False, text=""Inherit flag for P21"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P21 = FloatProperty(\n        default=0.75, text=""P21"", math_text=r""$P_{21}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P21"", inherit_from=""parent.based_on.probabilities.P21"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P122_or_P221 = BoolProperty(\n        default=False, text=""Inherit flag for P122_or_P221"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P122_or_P221 = FloatProperty(\n        default=0.75, text=""P112 (W1 < 1/2) or\\nP221 (W1 > 1/2)"",\n        math_text=r""$P_{122} %s$ or $\\newlineP_{221} %s$"" % (\n            mt_range(0.0, ""W_1"", 1.0 / 2.0),\n            mt_range(1.0 / 2.0, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P122_or_P221"", inherit_from=""parent.based_on.probabilities.P122_or_P221"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, W1=0.75, P112_or_P211=0.75, P21=0.75, P122_or_P221=0.75,\n            inherit_W1=False, inherit_P112_or_P211=False,\n            inherit_P21=False, inherit_P122_or_P221=False, *args, **kwargs):\n        super(R2G2Model, self).__init__(R=2, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.75)\n            self.inherit_W1 = inherit_W1\n            self.P112_or_P211 = not_none(P112_or_P211, 0.75)\n            self.inherit_P112_or_P211 = inherit_P112_or_P211\n            self.P21 = not_none(P21, 0.75)\n            self.inherit_P21 = inherit_P21\n            self.P122_or_P221 = not_none(P122_or_P221, 0.75)\n            self.inherit_P122_or_P221 = inherit_P122_or_P221\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n            self.mW[0] = self.W1\n            self.mW[1] = 1.0 - self.mW[0]\n\n            self.mP[1, 0] = self.P21\n            self.mP[1, 1] = 1.0 - self.mP[1, 0]\n\n            self.mW[1, 0] = self.mW[1] * self.mP[1, 0]\n            self.mW[1, 1] = self.mW[1] * self.mP[1, 1]\n            self.mW[0, 1] = self.mW[1, 0]\n            self.mW[0, 0] = self.mW[0] - self.mW[1, 0]\n\n            if self.mW[0] <= self.twothirds:\n                self.mP[0, 0, 1] = self.P112_or_P211\n                if self.mW[1, 0] == 0.0:\n                    self.mP[1, 0, 0] = 0.0\n                else:\n                    self.mP[1, 0, 0] = self.mP[0, 0, 1] * self.mW[0, 0] / self.mW[1, 0]\n            else:\n                self.mP[1, 0, 0] = self.P112_or_P211\n                if self.mW[0, 0] == 0.0:\n                    self.mP[0, 0, 1] = 0.0\n                else:\n                    self.mP[0, 0, 1] = self.mP[1, 0, 0] * self.mW[1, 0] / self.mW[0, 0]\n            self.mP[1, 0, 1] = 1.0 - self.mP[1, 0, 0]\n            self.mP[0, 0, 0] = 1.0 - self.mP[0, 0, 1]\n\n            if self.mP[1, 0] <= 0.5:\n                self.mP[0, 1, 1] = self.P122_or_P221\n                self.mP[1, 1, 0] = self.mP[0, 1, 1] * self.mW[0, 1] / self.mW[1, 1]\n            else:\n                self.mP[1, 1, 0] = self.P122_or_P221\n                self.mP[0, 1, 1] = self.mP[1, 1, 0] * self.mW[1, 1] / self.mW[0, 1]\n            self.mP[0, 1, 0] = 1.0 - self.mP[0, 1, 1]\n            self.mP[1, 1, 1] = 1.0 - self.mP[1, 1, 0]\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n\n@storables.register()\nclass R2G3Model(_AbstractProbability):\n    r""""""\n    \n    (Restricted) probability model for Reichweite 2 with 3 components.\n    \n    The (due to restrictions only) 6 independent variables are:\n    \n    .. math::\n        :nowrap:\n\n        \\begin{align*}\n            & W_{1}\n            & P_{111} \\text{(if $\\nicefrac{1}{2} \\leq W_1 < \\nicefrac{2}{3}$) or} P_{x1x} \\text{(if $\\nicefrac{2}{3} \\leq W_1 \\leq 1)$ with $x \\in \\left\\{ {2,3} \\right\\}$} \\\\\n            & G_1 = \\frac{W_2}{W_2 + W_3}\n            & G_2 = \\frac{W_{212} + W_{213}}{W_{212} + W_{213} + W_{312} + W_{313}} \\\\\n            & G_3 = \\frac{W_{212}}{W_{212} + W_{213}}\n            & G_4 = \\frac{W_{312}}{W_{312} + W_{313}} \\\\\n        \\end{align*}\n        \n    This model can not describe mixed layers in which the last two components\n    occur right after each other in a stack. In other words there is always\n    an alternation between (one or more) layers of the first component and a \n    single layer of the second or third component. Therefore, the weight \n    fraction of the first component (:math:`W_1`) needs to be > than 1/2.\n    \n    The restriction also translates in the following:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & P_{22} = P_{23} = P_{32} = P_{33} = 0 \\\\\n            & P_{21} = P_{31} = 1 \\\\\n            & \\\\\n            & P_{122} = P_{123} = P_{132} = P_{133} = 0 \\\\\n            & P_{121} = P_{131} = 1 \\\\\n            & \\\\\n            & P_{222} = P_{223} = P_{232} = P_{233} = 0 \\\\\n            & P_{221} = P_{231} = 1 \\\\\n            & \\\\\n            & P_{322} = P_{323} = P_{332} = P_{333} = 0 \\\\\n            & P_{321} = P_{331} = 1 \\\\\n        \\end{align*}\n    \n    Using the above, we can calculate a lot of the weight fractions of stacks:\n    \n    .. math::\n        :nowrap:\n    \n        \\begin{align*}\n            & W_{22} = W_{23} = W_{32} = W_{33} 0 \\\\\n            & W_{21} = W_{2} \\\\\n            & W_{31} = W_{3} \\\\\n            & \\\\\n            & W_{122} = W_{123} = W_{132} = W_{133} = 0 \\\\\n            & W_{121} = W_{12} = W_{21} = W_2 \\\\\n            & W_{131} = W_{13} = W_{31} = W_3 \\\\\n            & W_{11} = W_1 - W_{12} - W_{13} \\\\\n            & \\\\\n            & W_{221} = W_{231} = W_{222} = W_{223} = W_{232} = W_{233} = 0 \\\\\n            & W_{331} = W_{331} = W_{322} = W_{323} = W_{332} = W_{333} = 0 \\\\             \n        \\end{align*}\n\n    Then the remaining fractions and probablities can be calculated as follows:\n    \n    .. math::\n        :nowrap:\n    \n        \\begin{align*}\n            & W_2 = G_1 * (1 - W_1) \\\\\n            & W_3 = 1 - W_1 - W_2 \\\\\n            & \\\\\n            & W_x = W_2 + W_3 &\n            & \\text{if $W_1 < \\nicefrac{2}{3}$:} \\\\\n            & \\quad \\text{$P_{111}$ is given}\\\\\n            & \\quad P_{x1x} = \n            \\begin{dcases}\n                1 - \\frac{W_1 - W_x}{W_x} \\cdot (1 - P_{111}, & \\text{if $W_x > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\ \n            & \\\\\n            & \\text{if $W_1 \\geq \\nicefrac{2}{3}$:} \\\\\n            & \\quad \\text{$P_{x1x}$ is given}\\\\\n            & \\quad P_{111} = \n            \\begin{dcases}\n                1 - \\frac{W_x}{W_1 - W_x} \\cdot (1 - P_{x1x}, & \\text{if $(W_1 - W_x) > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\\n            & \\\\\n            & W_{x1x} = W_x \\cdot P_{x1x} \\\\\n            & W_{21x} = G_2 \\cdot W_{x1x} \\\\\n            & W_{31x} = W_{x1x} - W_{21x} \\\\\n            & \\\\\n            & W_{212} = G_3 \\cdot W_{21x} \\\\\n            & W_{213} = (1 - G_3) \\cdot W_{21x} \\\\\n            & W_{211} = W_{21} - W_{212} - W_{213} \\\\\n            & \\\\\n            & W_{312} = G_4 \\cdot W_{31x} \\\\\n            & W_{313} = (1 - G_4) \\cdot W_{31x} \\\\\n            & W_{311} = W_{31} - W_{312} - W_{313} \\\\\n            & \\\\\n            & W_{111} = W_{11} \\cdot P_{111} \\\\\n            & W_{112} = W_{12} - W_{212} - W_{312} \\\\\n            & W_{112} = W_{13} - W_{213} - W_{313} \\\\\n            & \\\\\n            & \\text{Calculate the remaining P using:} \\\\\n            & P_{ijk} = \n            \\begin{dcases}\n                \\frac{W_{ijk}}{W_{ij}}, & \\text{if $W_{ij} > 0$} \\\\\n                0, & \\text{otherwise}\n            \\end{dcases} \\\\ \n        \\end{align*}\n        \n    """"""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R2G3Model""\n\n    # PROPERTIES:\n    _G = 3\n    twothirds = 2.0 / 3.0\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    W1 = FloatProperty(\n        default=0.8, text=""W1 (> 0.5)"", math_text=r""$W_1 (> 0.5)$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.5, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P111_or_P212 = BoolProperty(\n        default=False, text=""Inherit flag for P112_or_P211"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P111_or_P212 = FloatProperty(\n        default=0.9, text=""P111 (W1 < 2/3) or\\nPx1x (W1 > 2/3)"",\n        math_text=r""$P_{111} %s$ or $\\newline P_{x1x} %s$"" % (\n            mt_range(0.5, ""W_1"", 2.0 / 3.0),\n            mt_range(2.0 / 3.0, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P111_or_P212"", inherit_from=""parent.based_on.probabilities.P111_or_P212"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G1 = BoolProperty(\n        default=False, text=""Inherit flag for G1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G1 = FloatProperty(\n        default=0.9, text=""W2/(W2+W3)"",\n        math_text=r""$\\large\\frac{W_2}{W_3 + W_2}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G1"", inherit_from=""parent.based_on.probabilities.G1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G2 = BoolProperty(\n        default=False, text=""Inherit flag for G2"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G2 = FloatProperty(\n        default=0.9, text=""(W212+W213)/(W212+W213+W312+W313)"",\n        math_text=r""$\\large\\frac{W_{212} + W_{213}}{W_{212} + W_{213} + W_{312} + W_{313}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G2"", inherit_from=""parent.based_on.probabilities.G2"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G3 = BoolProperty(\n        default=False, text=""Inherit flag for G3"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G3 = FloatProperty(\n        default=0.9, text=""W212/(W212+W213)"",\n        math_text=r""$\\large\\frac{W_{212}}{W_{212} + W_{213}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G3"", inherit_from=""parent.based_on.probabilities.G3"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_G4 = BoolProperty(\n        default=False, text=""Inherit flag for G4"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    G4 = FloatProperty(\n        default=0.9, text=""W312/(W312+W313)"",\n        math_text=r""$\\large\\frac{W_{312}}{W_{312} + W_{313}}$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_G4"", inherit_from=""parent.based_on.probabilities.G4"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, W1=0.8, P111_or_P212=0.9, G1=0.9, G2=0.9, G3=0.9, G4=0.9,\n        inherit_W1=False, inherit_P111_or_P212=False, inherit_G1=False,\n        inherit_G2=False, inherit_G3=False, inherit_G4=False, *args, **kwargs):\n        super(R2G3Model, self).__init__(R=2, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.8)\n            self.inherit_W1 = inherit_W1\n            self.P111_or_P212 = not_none(P111_or_P212, 0.9)\n            self.inherit_P111_or_P212 = inherit_P111_or_P212\n            self.G1 = not_none(G1, 0.9)\n            self.inherit_G1 = inherit_G1\n            self.G2 = not_none(G2, 0.9)\n            self.inherit_G2 = inherit_G2\n            self.G3 = not_none(G3, 0.9)\n            self.inherit_G3 = inherit_G3\n            self.G4 = not_none(G4, 0.9)\n            self.inherit_G4 = inherit_G4\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n\n            # calculate Wx\'s:\n            self.mW[0] = self.W1\n            self.mW[1] = (1.0 - self.mW[0]) * self.G1\n            self.mW[2] = 1.0 - self.mW[0] - self.mW[1]\n\n            # consequences of restrictions:\n            self.mW[1, 1] = 0\n            self.mW[1, 2] = 0\n            self.mW[2, 1] = 0\n            self.mW[2, 2] = 0\n            self.mW[0, 1, 0] = self.mW[0, 1] = self.mW[1, 0] = self.mW[1]\n            self.mW[0, 2, 0] = self.mW[0, 2] = self.mW[2, 0] = self.mW[2]\n            self.mW[0, 0] = self.mW[0] - self.mW[0, 1] - self.mW[0, 2]\n\n            # continue calculations:\n            Wx = self.mW[1] + self.mW[2]\n            if self.mW[0] < self.twothirds:\n                self.mP[0, 0, 0] = self.P111_or_P212\n                Px0x = 1 - (self.mW[0] - Wx) / Wx * (1 - self.mP[0, 0, 0]) if Wx != 0 else 0.0\n            else:\n                Px0x = self.P111_or_P212\n                self.mP[0, 0, 0] = 1 - Wx / (self.mW[0] - Wx) * (1 - Px0x) if (self.mW[0] - Wx) != 0 else 0.0\n\n            Wx0x = Wx * Px0x\n            W10x = self.G2 * Wx0x\n            W20x = Wx0x - W10x\n\n            self.mW[1, 0, 1] = self.G3 * W10x\n            self.mW[1, 0, 2] = (1 - self.G3) * W10x\n            self.mW[1, 0, 0] = self.mW[1, 0] - self.mW[1, 0, 1] - self.mW[1, 0, 2]\n\n            self.mW[2, 0, 1] = self.G4 * W20x\n            self.mW[2, 0, 2] = (1 - self.G4) * W20x\n            self.mW[2, 0, 0] = self.mW[2, 0] - self.mW[2, 0, 1] - self.mW[2, 0, 2]\n\n            self.mW[0, 0, 0] = self.mW[0, 0] * self.mP[0, 0, 0]\n            self.mW[0, 0, 1] = self.mW[0, 1] - self.mW[1, 0, 1] - self.mW[2, 0, 1]\n            self.mW[0, 0, 2] = self.mW[0, 2] - self.mW[1, 0, 2] - self.mW[2, 0, 2]\n\n            # Calculate remaining P:\n            for i in range(3):\n                for j in range(3):\n                    for k in range(3):\n                        self.mP[i, j, k] = self.mW[i, j, k] / self.mW[i, j] if self.mW[i, j] > 0 else 0.0\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n'"
pyxrd/probabilities/models/R3models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties import BoolProperty, FloatProperty\n\nfrom pyxrd.generic.mathtext_support import mt_range\nfrom pyxrd.generic.io import storables\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.models.properties import InheritableMixin\n\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom .base_models import _AbstractProbability\nfrom mvc.models.properties.action_mixins import SetActionMixin\n\n__all__ = [\n    ""R3G2Model""\n]\n\n@storables.register()\nclass R3G2Model(_AbstractProbability):\n    r""""""\n    (Restricted) probability model for Reichweite 3 with 2 components.\n    \n    The (due to restrictions only) 2 independent variables are:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & W_1\n            & P_{1111} \\text{(if $\\nicefrac{2}{3} \\leq W_1 < \\nicefrac{3}{4}$) or} P_{2112} \\text{(if $\\nicefrac{3}{4} \\leq W_1 \\leq 1)$} \\\\\n        \\end{align*}\n    \n    This model can only describe mixed layers with more than \n    :math:`\\nicefrac{2}{3}` of the layers being of the first type, no two layers\n    of the second type occur after each other, and in which the probability of\n    finding a layer of the first type in between two layers of the second type\n    is zero. This translates to the following conditions:\n    \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n\t        & \\nicefrac{2}{3} <= W_1 <= 1 \\\\\n\t        & P_{22} = 0  \\\\\n\t        & P_{212} = 0 \\\\\n\t        & \\\\\n\t        & \\text{Since $P_{22} = 0$ and $P_{212} = 0$:} \\\\\n            & P_{1122} = P_{1212} = 0 \\\\\n            & \\text{And thus:} \\\\\n            & P_{1121} = P_{1211} = 1 \\\\\n        \\end{align*} \n        \n    The following probabilities are undefined, but are set to zero or one to\n    make the validation correct. This doesn\'t matter much, since the weight\n    fractions these probabilities are multiplied with, equal zero anyway\n    (e.g. :math:`W_{2211} = W_{22} * P_{221} * P_{2211}` and :math:`W_{22}` \n    is zero since :math:`P_{22}` is zero):\n        \n    .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & P_{1121} &= P_{1211} &= P_{2211} \n            &= P_{2121} &= P_{2221} &= P_{1221} = 0 \\\\\n            & P_{1122} &= P_{1212} &= P_{2212} \n            &= P_{2122} &= P_{2222} &= P_{1222} = 1 \\\\\n        \\end{align*}  \n\n    The remaining probabilities and weight fractions can be calculated as \n    follows:\n    \n   .. math::\n        :nowrap:\n        \n        \\begin{align*}\n            & W_2 = 1 - W_1 \\\\\n            & \\\\\n            & \\text{if $W_1 < \\nicefrac{3}{4}$:} \\\\\n            & \\quad \\text{$P_{1111}$ is given}\\\\\n            & \\quad P_{1112} = 1 - P_{1111} \\\\\n            & \\quad P_{2111} = P_{1112} * \\frac{W_1 - 2 \\cdot W_2}{W_2} \\\\\n            & \\quad P_{2112} = 1 - P_{2111} \\\\  \n            & \\\\\n            & \\text{if $W_1 \\geq \\nicefrac{3}{4}$:} \\\\\n            & \\quad \\text{$P_{2112}$ is given}\\\\\n            & \\quad P_{2111} = 1 - P_{2112} \\\\\n            & \\quad P_{1111} = P_{2111} * \\frac{W_2}{W_1 - 2 \\cdot W_2} \\\\\n            & \\quad P_{1112} = 1 - P_{1111} \\\\  \n            & \\\\\n            & W_{111} = 3 \\cdot W_1 - 2 \\\\\n            & W_{212} = W_{221} = W_{222} = W_{122} = 0 \\\\\n            & W_{211} = W_{121} = W_{112} = 1 - W_1 \\\\\n        \\end{align*}\n\t\n\t""""""\n\n    # MODEL METADATA:\n    class Meta(_AbstractProbability.Meta):\n        store_id = ""R3G2Model""\n\n    # PROPERTIES:\n    _G = 2\n\n    inherit_W1 = BoolProperty(\n        default=False, text=""Inherit flag for W1"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    W1 = FloatProperty(\n        default=0.85, text=""W1 (> 2/3)"", math_text=r""$W_1 (> \\frac{2}{3})$"",\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=2.0 / 3.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_W1"", inherit_from=""parent.based_on.probabilities.W1"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    inherit_P1111_or_P2112 = BoolProperty(\n        default=False, text=""Inherit flag for P1111_or_P2112"",\n        persistent=True, visible=True,\n        set_action_name=""update"",\n        mix_with=(SetActionMixin,)\n    )\n    P1111_or_P2112 = FloatProperty(\n        default=0.75, text=""P1111 (W1 < 3/4) or\\nP2112 (W1 > 3/4)"",\n        math_text=r""$P_{1111} %s$ or $\\newline P_{2112} %s$"" % (\n            mt_range(2.0 / 3.0, ""W_1"", 3.0 / 4.0),\n            mt_range(3.0 / 4.0, ""W_1"", 1.0)),\n        persistent=True, visible=True, refinable=True, store_private=True,\n        minimum=0.0, maximum=1.0, is_independent=True, inheritable=True,\n        inherit_flag=""inherit_P1111_or_P2112"", inherit_from=""parent.based_on.probabilities.P1111_or_P2112"",\n        set_action_name=""update"",\n        mix_with=(SetActionMixin, RefinableMixin, InheritableMixin)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, W1=0.85, P1111_or_P2112=0.75, *args, **kwargs):\n        super(R3G2Model, self).__init__(R=3, *args, **kwargs)\n\n        with self.data_changed.hold():\n            self.W1 = not_none(W1, 0.85)\n            self.P1111_or_P2112 = not_none(P1111_or_P2112, 0.75)\n\n            self.update()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        with self.monitor_changes():\n            self.mW[0] = self.W1\n            self.mW[1] = 1.0 - self.W1\n\n            if self.mW[0] <= 0.75: # 0,0,0,0 is given\n                self.mP[0, 0, 0, 0] = self.P1111_or_P2112\n                self.mP[0, 0, 0, 1] = max(min(1.0 - self.mP[0, 0, 0, 0], 1.0), 0.0)\n                self.mP[1, 0, 0, 0] = max(min(self.mP[0, 0, 0, 1] * (self.mW[0] - 2 * self.mW[1]) / self.mW[1], 1.0), 0.0)\n                self.mP[1, 0, 0, 1] = max(min(1.0 - self.mP[1, 0, 0, 0], 1.0), 0.0)\n            else: # 1,0,0,1 is given\n                self.mP[1, 0, 0, 1] = self.P1111_or_P2112\n                self.mP[1, 0, 0, 0] = max(min(1.0 - self.mP[1, 0, 0, 1], 1.0), 0.0)\n                self.mP[0, 0, 0, 0] = max(min(1.0 - self.mP[1, 0, 0, 0] * self.mW[1] / (self.mW[0] - 2 * self.mW[1]), 1.0), 0.0)\n                self.mP[0, 0, 0, 1] = max(min(1.0 - self.mP[0, 0, 0, 0], 1.0), 0.0)\n\n            # since P11=0 and P101=0, actual values don\'t matter:\n            self.mP[0, 0, 1, 0] = 1.0\n            self.mP[0, 0, 1, 1] = 0.0\n\n            self.mP[0, 1, 0, 0] = 1.0\n            self.mP[0, 1, 0, 1] = 0.0\n\n            self.mP[0, 1, 1, 0] = 1.0\n            self.mP[0, 1, 1, 1] = 0.0\n\n            self.mP[1, 0, 1, 0] = 1.0\n            self.mP[1, 0, 1, 1] = 0.0\n\n            self.mP[1, 1, 0, 0] = 1.0\n            self.mP[1, 1, 0, 1] = 0.0\n\n            self.mP[1, 1, 1, 0] = 1.0\n            self.mP[1, 1, 1, 1] = 0.0\n\n            self.mW[0, 0, 0] = max(min(3 * self.mW[0] - 2, 1.0), 0.0)\n            self.mW[1, 0, 1] = self.mW[1, 1, 0] = self.mW[1, 1, 1] = self.mW[0, 1, 1] = 0.0\n            self.mW[1, 0, 0] = self.mW[0, 1, 0] = self.mW[0, 0, 1] = max(min(1 - self.mW[0], 1.0), 0.0)\n\n            self.solve()\n            self.validate()\n\n    pass # end of class\n'"
pyxrd/probabilities/models/__init__.py,3,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\n\nfrom .R0models import R0G1Model, R0G2Model, R0G3Model, R0G4Model, R0G5Model, R0G6Model # @UnusedImport\nfrom .R1models import R1G2Model, R1G3Model, R1G4Model # @UnusedImport\nfrom .R2models import R2G2Model, R2G3Model # @UnusedImport\nfrom .R3models import R3G2Model # @UnusedImport\n\n# Overview of what is:\n#   x   = currently implemented\n#   np  = not possible\n#   -/o = not yet implemented\n#   o   = priority\n#\n#       G1  G2  G3  G4  G5  G6\n#   R0  x   x   x   x   x   x\n#   R1  np  x   x   x   -   -\n#   R2  np  x   x   -   -   -\n#   R3  np  x   -   -   -   -\n\nRGbounds = np.array([\n    [1, 1, 1, 1, 1, 1],\n    [-1, 1, 1, 1, 0, 0],\n    [-1, 1, 1, 0, 0, 0],\n    [-1, 1, 0, 0, 0, 0],\n])\n\ndef get_Gbounds_for_R(R, G):\n    global RGbounds\n    maxR, maxG = RGbounds.shape\n    low, upp = 1, 6\n    if R >= 0 and R < maxR:\n        bounds = RGbounds[R]\n        low, upp = 1 + np.argmax(bounds == 1), maxG - np.argmax(bounds[::-1] == 1)\n    else:\n        raise ValueError(""Cannot yet handle R%d!"" % R)\n    return (low, upp, max(min(G, upp), low))\n\ndef get_Rbounds_for_G(G, R):\n    global RGbounds\n    maxR, maxG = RGbounds.shape\n    low, upp = 0, 0\n    if G >= 1 and G <= maxG:\n        bounds = RGbounds[:, G - 1]\n        low, upp = np.argmax(bounds == 1), maxR - np.argmax(bounds[::-1] == 1) - 1\n    else:\n        raise ValueError(""Cannot yet handle %d layer structures!"" % G)\n    return (low, upp, max(min(R, upp), low))\n\ndef get_correct_probability_model(R, G):\n    global RGbounds\n    if (RGbounds[R, G - 1] > 0):\n        return globals()[""R%dG%dModel"" % (R, G)]\n    else:\n        raise ValueError(""Cannot (yet) handle R%d for %d layer structures!"" % (R, G))\n'"
pyxrd/probabilities/models/base_models.py,25,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom itertools import product\nfrom copy import deepcopy\nfrom contextlib import contextmanager\n\nimport numpy as np\n\nfrom mvc.models.properties import StringProperty, LabeledProperty\n\nfrom pyxrd.generic.io import Storable\nfrom pyxrd.generic.models import DataModel\nfrom pyxrd.generic.models.properties import IndexProperty\n\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup\nfrom pyxrd.refinement.refinables.metaclasses import PyXRDRefinableMeta\n\nclass _AbstractProbability(RefinementGroup, DataModel, Storable, metaclass=PyXRDRefinableMeta):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        pass\n\n    phase = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n    name = StringProperty(default=""Probabilities"", text=""Name"")\n    W_valid = LabeledProperty(default=None, text=""Valid W matrix"")\n    W_valid_mask = None\n    P_valid = LabeledProperty(default=None, text=""Valid P matrix"")\n    P_valid_mask = None\n\n    _R = -1\n    @property\n    def R(self):\n        return self._R\n\n    @property\n    def rank(self):\n        return self.G ** max(self.R, 1)\n\n    _G = 0\n    @property\n    def G(self):\n        return self._G\n\n    _W = None\n    _P = None\n\n    @IndexProperty\n    def mP(self, indeces):\n        r, ind = self._get_Pxy_from_indeces(indeces)\n        return self._lP[r][ind]\n    @mP.setter\n    def mP(self, indeces, value):\n        r, ind = self._get_Pxy_from_indeces(indeces)\n        self._lP[r][ind] = value\n\n    @IndexProperty\n    def mW(self, indeces):\n        r, ind = self._get_Wxy_from_indeces(indeces)\n        return self._lW[r][ind]\n    @mW.setter\n    def mW(self, indeces, value):\n        r, ind = self._get_Wxy_from_indeces(indeces)\n        self._lW[r][ind] = value\n\n    @property\n    def _flags(self):\n        return [\n            1 if getattr(self, prop.inherit_flag, False) else 0\n            for prop in self.Meta.all_properties if getattr(prop, ""inheritable"", False) \n        ]\n\n    # REFINEMENT GROUP IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return self.name\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.phase.name,\n            component_name=""*""\n        )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, R=-1, *args, **kwargs):\n        super(_AbstractProbability, self).__init__(*args, **kwargs)\n        self._R = R\n        self._create_matrices()\n\n    def _create_matrices(self):\n        """"""\n            Creates a list of matrices for different \'levels\' of R:\n                e.g. when R=3 with g layers there can be 4 different W matrixes:\n                    Wi = gxg matrix\n                    Wij = g\xc2\xb2xg\xc2\xb2 matrix\n                    Wijk = g\xc2\xb3xg\xc2\xb3 matrix\n                    Wijkl = another g\xc2\xb3xg\xc2\xb3 matrix (= Wijk * Pijkl)\n                and 3 different P matrices:\n                    Pij = gxg matrix\n                    Pijk = g\xc2\xb2xg\xc2\xb2 matrix\n                    Pijkl = g\xc2\xb3xg\xc2\xb3 matrix\n        """"""\n        R = max(self.R, 1)\n        self._lW = [None] * (R + 1)\n        self._lP = [None] * R\n        for r in range(R):\n            lrank = self.G ** (r + 1)\n            self._lW[r] = np.zeros(shape=(lrank, lrank), dtype=float)\n            self._lP[r] = np.zeros(shape=(lrank, lrank), dtype=float)\n        self._lW[-1] = np.zeros(shape=(lrank, lrank), dtype=float)\n        self._W = self._lW[-2]\n        self._P = self._lP[-1]\n\n        # validity matrices:\n        self.W_valid = np.array([False] * (R + 1))\n        self.W_valid_mask = np.array([None] * (R + 1))\n        self.P_valid = np.array([False] * R)\n        self.P_valid_mask = np.array([None] * R)\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update(self):\n        raise NotImplementedError\n\n    def _clamp_set_and_update(self, name, value, minimum=0.0, maximum=1.0):\n        clamped = min(max(value, minimum), maximum)\n        if getattr(self, name) != clamped:\n            setattr(self, name, clamped)\n            self.update()\n\n    def solve(self):\n        """"""\n            This \'solves\' the other W and P matrices using the \'top\' P and W\n            matrix calculated in the update method.\n        """"""\n\n        for num in range(1, self.R):\n            # W matrices:\n            for base in product(list(range(self.G)), repeat=num):\n                self.mW[base] = 0\n                for i in range(self.G):\n                    self.mW[base] += self.mW[(i,) + base]\n            # P matrices:\n            p_num = num + 1\n            for base in product(list(range(self.G)), repeat=p_num):\n                W = self.mW[base[:-1]]\n                self.mP[base] = self.mW[base] / W if W > 0 else 0.0\n\n        # one extra W matrix:\n        self._lW[-1][:] = np.dot(self._W, self._P)\n\n    def validate(self):\n        """"""\n            Checks wether the calculated matrices are valid, and stores the\n            validation results in \'masks\': matrices of the same size, in which\n            the values correspond with 1 minus the number of validation rules\n            that specific W or P value has failed for.\n        """"""\n        def _validate_WW(W, R):\n            """"""Validation rules for the product of a W and P matrix""""""\n            W_valid_mask = np.ones_like(W)\n            rank = self.G ** max(R, 1)\n\n            # sum of the cols (W...x\'s) need to equal W...\n            for i in range(rank):\n                if abs(np.sum(W[..., i]) - self._W[i, i]) > 1e4:\n                    W_valid_mask[..., i] -= 1\n\n            # sum of the entire matrix must equal one:\n            if abs(np.sum(W) - 1.0) > 1e4:\n                W_valid_mask -= 1\n\n            # values need to be between 0 and 1\n            for i in range(rank):\n                for j in range(rank):\n                    if W[i, j] < 0.0 or W[i, j] > 1.0:\n                        W_valid_mask[i, i] -= 1\n\n            # if the sum of the mask values equals the square of the rank,\n            # no rules have been broken:\n            W_valid = (np.sum(W_valid_mask) == rank ** 2)\n\n            return W_valid, W_valid_mask\n\n        def _validate_W(W, R):\n            """"""Validation rules for a diagonal W matrix""""""\n            W_valid_mask = np.ones_like(W)\n            rank = self.G ** max(R, 1)\n\n            # sum of the diagonal nees to be one\n            if abs(np.sum(W) - 1.0) > 1e6:\n                for i in range(rank):\n                    W_valid_mask[i, i] -= 1\n\n            # values need to be between 0 and 1\n            for i in range(rank):\n                for j in range(rank):\n                    if W[i, j] < 0.0 or W[i, j] > 1.0:\n                        W_valid_mask[i, i] -= 1\n\n            # if the sum of the mask values equals the square of the rank,\n            # no rules have been broken:\n            W_valid = (np.sum(W_valid_mask) == rank ** 2)\n\n            return W_valid, W_valid_mask\n\n        def _validate_P(P, R):\n            P_valid_mask = np.ones_like(P)\n            rank = self.G ** max(R, 1)\n\n            # sum of the rows need to be one\n            for i in range(rank):\n                if abs(np.sum(P[i, ...]) - 1.0) > 1e6:\n                    P_valid_mask[i, ...] -= 1\n\n            # values need to be between 0 and 1\n            for i in range(rank):\n                for j in range(rank):\n                    if P[i, j] < 0.0 or P[i, j] > 1.0:\n                        P_valid_mask[i, j] -= 1\n\n            # if the sum of the mask values equals the square of the rank,\n            # no rules have been broken:\n            P_valid = (np.sum(P_valid_mask) == rank ** 2)\n\n            return P_valid, P_valid_mask\n\n        for i in range(max(self.R, 1)):\n            self.W_valid[i], self.W_valid_mask[i] = _validate_W(self._lW[i], i + 1)\n            self.P_valid[i], self.P_valid_mask[i] = _validate_P(self._lP[i], i + 1)\n\n        # the extra W matrix validates differently:\n        self.W_valid[-1], self.W_valid_mask[-1] = _validate_WW(self._lW[-1], self.R)\n\n    def _get_Pxy_from_indeces(self, indeces):\n        if not hasattr(indeces, ""__iter__""):\n            indeces = [indeces]\n        l = len(indeces)\n        assert(l > 1), ""Two or more indeces needed to acces P elements, not %s"" % indeces\n        assert(l <= max(self.R, 1) + 1), ""Too many indeces for an R%d model: %s"" % (self.R, indeces)\n        R = max(l - 1, 1)\n        x, y = 0, 0\n        for i in range(1, R + 1):\n            f = self.G ** (R - i)\n            x += indeces[i - 1] * f\n            y += indeces[i] * f\n        return (l - 2), (x, y)\n\n    def _get_Wxy_from_indeces(self, indeces):\n        if not hasattr(indeces, ""__iter__""):\n            indeces = [indeces]\n        l = len(indeces)\n        assert(l > 0), ""One or more indeces needed to acces W elements""\n        assert(l <= max(self.R, 1) + 1), ""Too many indeces for an R%d model: %s"" % (self.R, indeces)\n        if l == (max(self.R, 1) + 1):\n            R = max(l - 1, 1)\n            x, y = 0, 0\n            for i in range(1, R + 1):\n                f = self.G ** (R - i)\n                x += indeces[i - 1] * f\n                y += indeces[i] * f\n            return (l - 1), (x, y)\n        else:\n            R = max(l, 1)\n            x = 0\n            for i in range(R):\n                x += indeces[i] * self.G ** (R - (i + 1))\n            return (l - 1), (x, x)\n\n    def get_all_matrices(self): return self._lW, self._lP\n\n    def get_distribution_matrix(self): return self._W\n\n    def get_distribution_array(self): return np.diag(self._W)\n\n    def get_probability_matrix(self): return self._P\n\n    _stashed_lP = None\n    _stashed_lW = None\n    _stashed_flags = None\n    def _stash_matrices(self):\n        """""" Stashes the matrices for an update """"""\n        self._stashed_lW = deepcopy(np.asanyarray(self._lW))\n        self._stashed_lP = deepcopy(np.asanyarray(self._lP))\n        self._stashed_flags = deepcopy(np.asarray(self._flags))\n        \n    def _compare_stashed_matrices(self):\n        """""" Unstashed matrices and compares with current values, if identical returns True """"""\n        if self._stashed_lP is not None and self._stashed_lW is not None:\n            result = np.array_equal(self._stashed_lW, np.asanyarray(self._lW))\n            result = result and np.array_equal(self._stashed_lP, np.asanyarray(self._lP))\n            result = result and np.array_equal(self._stashed_flags, np.asanyarray(self._flags))\n            self._stashed_lW = None\n            self._stashed_lP = None\n            return result\n        else:\n            return False\n        \n    @contextmanager\n    def monitor_changes(self):\n        with self.data_changed.hold():\n            self._stash_matrices()\n            yield\n            if not self._compare_stashed_matrices():\n                self.data_changed.emit()\n\n    pass # end of class\n'"
pyxrd/probabilities/models/properties.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties import FloatProperty\n\nclass ProbabilityProperty(FloatProperty):\n    """"""\n     A descriptor that will invoke the \'update\' method on the instance\n     it belongs to.\n    """"""\n\n    def __init__(self, clamp=False, **kwargs):\n        super(ProbabilityProperty, self).__init__(**kwargs)\n\n    def __set__(self, instance, value):\n        super(ProbabilityProperty, self).__set__(instance, value)\n        instance.update()\n\n    pass # end of class\n'"
pyxrd/refinement/controllers/__init__.py,0,b''
pyxrd/refinement/controllers/refinement_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\nimport sys\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc.support.cancellable_thread import CancellableThread\nfrom mvc.support.gui_loop import run_when_idle, add_timeout_call,\\\n    remove_timeout_call\n\nfrom pyxrd.generic.asynchronous.providers import get_status\nfrom pyxrd.generic.views.treeview_tools import new_text_column, new_pb_column, new_toggle_column\nfrom pyxrd.generic.mathtext_support import create_pb_from_mathtext\nfrom pyxrd.generic.controllers import DialogController\n\nfrom pyxrd.refinement.views.refiner_view import RefinerView\nfrom pyxrd.refinement.controllers.refiner_controller import RefinerController\n\nclass RefinementController(DialogController):\n\n    auto_adapt_included = [\n        ""refine_method_index"",\n        ""refinables"",\n        ""make_psp_plots"",\n    ]\n\n    @property\n    def treemodel(self):\n        return self.model.refinables\n\n    def setup_refinables_tree_view(self, store, widget):\n        """"""\n            Setup refinables TreeView layout\n        """"""\n        widget.set_show_expanders(True)\n\n        if sys.platform == ""win32"":\n            def get_label(column, cell, model, itr, user_data=None):\n                ref_prop = model.get_tree_node_object(itr)\n                cell.set_property(""text"", ref_prop.text_title)\n                return\n            widget.append_column(new_text_column(\'Name/Prop\', xalign=0.0, data_func=get_label))\n        else:\n            # Labels are parsed for mathtext markup into pb\'s:\n            def get_pb(column, cell, model, itr, user_data=None):\n                ref_prop = model.get_tree_node_object(itr)\n                try:\n                    if not hasattr(ref_prop, ""pb"") or not ref_prop.pb:\n                        ref_prop.pb = create_pb_from_mathtext(\n                            ref_prop.title,\n                            align=\'left\',\n                            weight=\'medium\'\n                        )\n                    cell.set_property(""pixbuf"", ref_prop.pb)\n                except RuntimeError:\n                    logger.warning(""An error occured when trying to convert a property title to a PixBuf"")\n                    raise\n                return\n            widget.append_column(new_pb_column(\'Name/Prop\', xalign=0.0, data_func=get_pb))\n\n        # Editable floats:\n        def get_value(column, cell, model, itr, *args):\n            col = column.get_col_attr(\'markup\')\n            try:\n                value = model.get_value(itr, col)\n                value = ""%.5f"" % value\n            except TypeError: value = """"\n            cell.set_property(""markup"", value)\n            return\n        def on_float_edited(rend, path, new_text, model, col):\n            itr = model.get_iter(path)\n            try:\n                model.set_value(itr, col, float(new_text))\n            except ValueError:\n                return False\n            return True\n\n        def_float_args = {\n            ""sensitive_col"": store.c_refinable,\n            ""editable_col"": store.c_refinable,\n            ""visible_col"": store.c_refinable,\n            ""data_func"": get_value\n        }\n\n        widget.append_column(new_text_column(\n            ""Value"", markup_col=store.c_value,\n            edited_callback=(\n                on_float_edited,\n                (store, store.c_value,)\n            ), **def_float_args\n        ))\n        widget.append_column(new_text_column(\n            ""Min"", markup_col=store.c_value_min,\n            edited_callback=(\n                on_float_edited,\n                (store, store.c_value_min,)\n            ), **def_float_args\n        ))\n        widget.append_column(new_text_column(\n            ""Max"", markup_col=store.c_value_max,\n            edited_callback=(\n                on_float_edited,\n                (store, store.c_value_max,)\n            ), **def_float_args\n        ))\n\n        # The \'refine\' checkbox:\n        widget.append_column(new_toggle_column(\n            ""Refine"",\n            toggled_callback=(self.refine_toggled, (store,)),\n            resizable=False,\n            expand=False,\n            active_col=store.c_refine,\n            sensitive_col=store.c_refinable,\n            activatable_col=store.c_refinable,\n            visible_col=store.c_refinable\n        ))\n\n    def _update_method_options_store(self):\n        """"""\n            Update the method options tree store (when a new method is selected)\n        """"""\n        tv = self.view[\'tv_method_options\']\n        store = Gtk.ListStore(str, str)\n        method = self.model.get_refinement_method()\n        for arg in method.options:\n            description = getattr(type(method), arg).description\n            store.append([arg, description])\n        tv.set_model(store)\n        return tv\n\n    def _setup_method_options_treeview(self):\n        """"""\n            Initial method options tree view layout & behavior setup\n        """"""\n        # Update the method options store to match the currently selected\n        # refinement method\n        tv = self._update_method_options_store()\n\n        # The name of the option:\n        tv.append_column(new_text_column(""Name"", text_col=1))\n\n        # The value of the option:\n        def get_value(column, cell, model, itr, *args):\n            option_name, = tv.get_model().get(itr, 0)\n            method = self.model.get_refinement_method()\n            cell.set_property(""sensitive"", True)\n            cell.set_property(""editable"", True)\n            cell.set_property(""markup"", ""%g"" % getattr(method, option_name))\n            return\n        \n        def on_value_edited(rend, path, new_text, col):\n            store = tv.get_model()\n            itr = store.get_iter(path)\n            option_name, = store.get(itr, 0)\n            method = self.model.get_refinement_method()\n            try:\n                setattr(method, option_name, new_text)\n            except ValueError:\n                pass\n            return True\n        tv.append_column(new_text_column(\n            ""Value"", text_col=0,\n            data_func=get_value,\n            edited_callback=(on_value_edited, (0,)),\n        ))\n\n    def register_view(self, view):\n        # Create the method treeview:\n        self._setup_method_options_treeview()\n        # Update the server status:\n        self.view.update_server_status(get_status())\n\n    def cleanup(self):\n        if hasattr(self, ""view""):\n            del self.view\n        if hasattr(self, ""results_view""):\n            del self.results_view\n        if hasattr(self, ""results_controller""):\n            del self.results_controller\n        if hasattr(self, ""model""):\n            self.relieve_model(self.model)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @DialogController.observe(""refine_method_index"", assign=True)\n    def on_prop_changed(self, model, prop_name, info):\n        self._update_method_options_store()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_cancel(self):\n        if self.view is not None:\n            self.view.hide()\n            self.parent.view.parent.show()\n\n    def refine_toggled(self, cell, path, model):\n        if model is not None:\n            itr = model.get_iter(path)\n            model.set_value(itr, model.c_refine, not cell.get_active())\n        return True\n\n    def on_btn_randomize_clicked(self, event):\n        self.model.randomize()\n\n    def on_auto_restrict_clicked(self, event):\n        self.model.auto_restrict()\n\n    def _launch_gui_updater(self, refiner):\n        def _on_update_gui():\n            if self.view is not None and refiner is not None:\n                self.view.update_refinement_info(\n                    refiner.history.last_residual,\n                    refiner.status.message,\n                    get_status()\n                )\n                return True\n            else:\n                return False\n        add_timeout_call(500, _on_update_gui)\n        return _on_update_gui\n\n    def _launch_refine_thread(self, refiner, gui_timeout_id):\n        @run_when_idle\n        def thread_completed(*args, **kwargs):\n            """""" Called when the refinement is completed """"""\n            self.thread = None\n            \n            remove_timeout_call(gui_timeout_id)\n            self.view.stop_spinner()\n            \n            # Make some plots:\n            if self.model.make_psp_plots:\n                self.view.update_refinement_status(""Processing..."")\n                self.results_controller.generate_images()\n            \n            # Set the labels:\n            self.results_controller.update_labels()\n                \n            # Hide our shit:\n            self.view.hide_refinement_info()\n            self.view.hide()\n            \n            # Show results:\n            self.results_view.present()\n\n        thread = CancellableThread(refiner.refine, thread_completed)\n        thread.start()\n        return thread\n\n    def _connect_cancel_button(self, refiner, gui_timeout_id, thread):\n        # Connect the cancel button (custom widget):\n        def thread_cancelled(*args, **kwargs):\n            """""" Called when the refinement is cancelled by the user """"""\n            remove_timeout_call(gui_timeout_id)\n            self.view.stop_spinner()\n            \n            self.view.update_refinement_status(""Cancelling..."")\n            thread.cancel()\n            \n            self.view.hide_refinement_info()\n        self.view.connect_cancel_request(thread_cancelled)\n\n    @DialogController.status_message(""Refining mixture..."", ""refine_mixture"")\n    def on_refine_clicked(self, event):\n        with self.model.mixture.needs_update.hold():\n            with self.model.mixture.data_changed.hold():\n                if len(self.model.mixture.specimens) > 0:\n                    # Create the refiner object\n                    with DialogFactory.error_dialog_handler(\n                            ""There was an error when creating the refinement setup:\\n{}"", \n                            parent=self.view.get_toplevel(), reraise=False):\n                        refiner = self.model.get_refiner()\n\n                        # Setup results controller\n                        self.results_view = RefinerView(parent=self.view.parent)\n                        self.results_controller = RefinerController(\n                            refiner=refiner,\n                            model=self.model,\n                            view=self.results_view,\n                            parent=self\n                        )\n    \n                        # Gtk timeout loop for our GUI updating:\n                        gui_timeout_id = self._launch_gui_updater(refiner)\n                        \n                        # This creates a thread that will run the refiner.refine method:\n                        thread = self._launch_refine_thread(refiner, gui_timeout_id)\n                        \n                        # Connect the cancel button:\n                        self._connect_cancel_button(refiner, gui_timeout_id, thread)\n    \n                        # Show the context updates in the gui:\n                        self.view.show_refinement_info()\n                        self.view.start_spinner()\n\n                else:\n                    DialogFactory.get_information_dialog(\n                        ""Cannot refine an empty mixture!"", parent=self.view.get_toplevel()\n                    ).run()\n\n    pass # end of class'"
pyxrd/refinement/controllers/refiner_controller.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pyxrd.generic.controllers.dialog_controller import DialogController\nfrom pyxrd.refinement.parspace import ParameterSpaceGenerator\n\nclass RefinerController(DialogController):\n    """"""\n        A controller for a Refiner object that keeps track\n        of the solutions and residuals generated by the refinement\n        algorithm. This allows to show a nice dialog with the end\n        results and some graphs about the parameter space.\n    """"""\n\n    auto_adapt_excluded = [\n        ""refine_method_index"",\n        ""refinables"",\n        ""make_psp_plots"",\n    ]\n\n    register_lazy = False\n    samples = None\n\n    def __init__(self, refiner, *args, **kwargs):\n        super(RefinerController, self).__init__(*args, **kwargs)\n        self.refiner = refiner\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_cancel(self):\n        self.view.hide()\n        self.parent.parent.view.parent.show()\n\n    def on_btn_initial_clicked(self, event):\n        self.refiner.apply_initial_solution()\n        del self.refiner\n        self.on_cancel()\n        return True\n\n    def on_btn_best_clicked(self, event):\n        self.refiner.apply_best_solution()\n        del self.refiner\n        self.on_cancel()\n        return True\n\n    def on_btn_last_clicked(self, event):\n        self.refiner.apply_last_solution()\n        del self.refiner\n        self.on_cancel()\n        return True\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def update_labels(self):\n        self.view.update_labels(\n            self.refiner.history.initial_residual,\n            self.refiner.history.best_residual,\n            self.refiner.history.last_residual,\n        )\n    \n    def generate_images(self, output_dir="""", density=200):\n        """"""\n            Generate the parameter space plots\n        """"""\n        samples = self.refiner.get_plot_samples()\n        labels = self.refiner.get_plot_labels()\n        truths = self.refiner.history.best_solution\n       \n        psg = ParameterSpaceGenerator()\n        psg.initialize(self.refiner.ranges, 199)\n        for sample in samples:\n            psg.record(sample[:-1], sample[-1])\n        psg.plot_images(self.view.figure, truths, labels[:-1])\n\n    def clear_images(self):\n        self.view.figure.clear()\n        self.view.figure.text(0.5, 0.5, ""no plots to show"", va=""center"", ha=""center"")\n\n    pass # end of class'"
pyxrd/refinement/methods/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport traceback\nimport sys\nimport importlib, pkgutil\n\nfrom imp import find_module\n\nimport logging\nlogger = logging.getLogger(__name__)\n\n""""""\n    This scans the module for submodules and imports them. This will\n    trigger the registration of any refinement method classes \n    (i.e. RefineRun subclasses).\n    \n    Every RefineRun class is callable. \n    When calling a RefineRun sub-class, you should pass the RefineContext as the first\n    argument, a stop signal, and an optional dict of options (see the class\n    definitions for what options you can use). \n    Internally, this will set-up the class and then call its own `run()` method, \n    starting the refinement.  \n\n    As such, to an external user, these \'classes\' appear as simple functions.\n""""""\n\n\ndef import_submodules(package_name):\n    """""" Import all submodules of a module, recursively\n\n    :param package_name: Package name\n    :type package_name: str\n    :rtype: dict[types.ModuleType]\n    """"""\n    package = sys.modules[package_name]\n\n    modules = {}\n    for _, name, _ in pkgutil.walk_packages(package.__path__):\n        try:\n            modules[name] = importlib.import_module(package_name + \'.\' + name)\n        except:\n            logger.warning(""Could not import %s refinement method modules, are all dependencies installed? Error was:"" % name)\n            _, _, tb = sys.exc_info()\n            traceback.print_tb(tb)\n    return modules\n\n__all__ = list(import_submodules(__name__).keys())\n\n\n'"
pyxrd/refinement/methods/custom_brute.py,3,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom itertools import product, combinations\n\nimport numpy as np\n\nfrom ..refine_method import RefineMethod\nfrom ..refine_method_option import RefineMethodOption\n\nclass RefineBruteForceRun(RefineMethod):\n    name = ""Brute force algorithm""\n    description = ""Refinement using a Brute Force algorithm""\n    index = 3\n    disabled = False\n\n    num_samples = RefineMethodOption(\'Number of samples\', 11, [3, 1000], int)\n\n    def run(self, refiner, num_samples=11, stop=None, **kwargs):\n        """"""\n            Refinement using a Brute Force algorithm\n        """"""\n\n        self.refiner = refiner\n\n        num_params = len(refiner.ranges)\n\n        npbounds = np.array(refiner.ranges, dtype=float)\n        npmins = npbounds[:, 0]\n        npranges = npbounds[:, 1] - npbounds[:, 0]\n\n        def generate():\n            # Generates the solutions for async evaluation\n            if num_params == 1:\n                for index in range(num_samples):\n                    npindex = np.array([index / float(num_samples - 1)], dtype=float)\n                    solution = npmins + npranges * npindex\n                    yield solution\n            else:\n                # Generate a grid for each possible combination of parameters:\n                for par1, par2 in combinations(list(range(num_params)), 2):\n                    # produce the grid indices for those parameters\n                    # keep the others half-way their range:\n                    indeces = np.ones(shape=(num_params,), dtype=float) * 0.5\n                    for par_indeces in product(list(range(num_samples)), repeat=2):\n                        indeces[par1] = par_indeces[0] / float(num_samples - 1)\n                        indeces[par2] = par_indeces[1] / float(num_samples - 1)\n                        # Make the solution:\n                        solution = npmins + npranges * indeces\n                        yield solution\n\n        self.do_async_evaluation(generate)\n        \n        refiner.apply_initial_solution()\n\n    pass #end of class\n'"
pyxrd/refinement/methods/deap_cma.py,34,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\n\n\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nfrom math import sqrt\n\nimport numpy as np\nimport scipy\n\nfrom deap import cma, base, creator, tools #@UnresolvedImport\n\nfrom pyxrd.refinement.refine_method import RefineMethod\nfrom pyxrd.refinement.refine_method_option import RefineMethodOption\nfrom pyxrd.refinement.refine_async_helper import RefineAsyncHelper\n\nfrom .deap_utils import pyxrd_array, PyXRDParetoFront, FitnessMin, result_func\n\n# Default settings:\nNGEN = 100\nSTAGN_NGEN = 10\nSTAGN_TOL = 0.001\n\nclass Strategy(cma.Strategy):\n    """"""\n        This evolutionary strategy supports the hybrid PSO-CMA runs using the\n        rotate_and_bias function (should be called after an update).\n    """"""\n\n    def __init__(self, centroid, sigma, ranges, **kwargs):\n        self.ranges = ranges\n        super(Strategy, self).__init__(centroid, sigma, **kwargs)\n\n    def update(self, population):\n        """"""Update the current covariance matrix strategy from the\n        *population*.\n        \n        :param population: A list of individuals from which to update the\n                           parameters.\n        """"""\n        population.sort(key=lambda ind: ind.fitness, reverse=True)\n        selected_pop = self._translate_external(\n            np.array([ind.to_ndarray() for ind in population[0:self.mu]]))\n\n        old_centroid = self._translate_external(self.centroid)\n        centroid = np.dot(self.weights, selected_pop)\n\n        c_diff = centroid - old_centroid\n\n        # Cumulation : update evolution path\n        self.ps = (1 - self.cs) * self.ps \\\n             + sqrt(self.cs * (2 - self.cs) * self.mueff) / self.sigma \\\n             * np.dot(self.B, (1. / self.diagD) \\\n                          * np.dot(self.B.T, c_diff))\n\n        hsig = float((np.linalg.norm(self.ps) /\n                sqrt(1. - (1. - self.cs) ** (2. * (self.update_count + 1.))) / self.chiN\n                < (1.4 + 2. / (self.dim + 1.))))\n\n        self.update_count += 1\n\n        self.pc = (1 - self.cc) * self.pc + hsig \\\n                  * sqrt(self.cc * (2 - self.cc) * self.mueff) / self.sigma \\\n                  * c_diff\n\n        # Update covariance matrix\n        artmp = selected_pop - old_centroid\n        new_C = (1 - self.ccov1 - self.ccovmu + (1 - hsig) \\\n                   * self.ccov1 * self.cc * (2 - self.cc)) * self.C \\\n                + self.ccov1 * np.outer(self.pc, self.pc) \\\n                + self.ccovmu * np.dot((self.weights * artmp.T), artmp) \\\n                / self.sigma ** 2\n\n        self.sigma *= np.exp((np.linalg.norm(self.ps) / self.chiN - 1.) \\\n                                * self.cs / self.damps)\n\n        try:\n            self.diagD, self.B = np.linalg.eigh(new_C)\n        except np.linalg.LinAlgError:\n            logger.warning(\n                ""LinAlgError occurred when calculating eigenvalues"" \\\n                "" and vectors for matrix C!\\n%r"" % new_C\n            )\n        else:\n            self.C = new_C\n            indx = np.argsort(self.diagD)\n\n            self.cond = self.diagD[indx[-1]] / self.diagD[indx[0]]\n\n            self.diagD = self.diagD ** 0.5\n\n            self.B = self.B[:, indx]\n            self.BD = self.B * self.diagD\n\n        self.centroid = self._translate_internal(centroid)\n\n    def rotate_and_bias(self, global_best, tc=0.1, b=0.5, cp=0.5):\n        """"""\n            Rotates the covariance matrix and biases the centroid of this\n            CMA population towards a global mean. Can be used to implement a\n            PSO-CMA hybrid algorithm. \n        """"""\n\n        global_best = self._translate_external(global_best)\n        centroid = self._translate_external(self.centroid)\n\n        # Rotate towards global:\n        pg = np.array(global_best) - np.array(centroid)\n        Brot = self.__rotation_matrix(self.B[:, 0], pg) * self.B\n        Crot = Brot * (self.diagD ** 2) * Brot.T\n        self.C = cp * self.C + (1.0 - cp) * Crot\n\n        # Bias our mean towards global best mean:\n        npg = np.linalg.norm(pg)\n        nsigma = np.amax(self.sigma)\n        if nsigma < npg:\n            if nsigma / npg <= tc * npg:\n                bias = b * pg\n            else:\n                bias = nsigma / npg * pg\n        else:\n            bias = 0\n\n        centroid = centroid + bias\n\n        self.centroid = self._translate_internal(centroid)\n\n        pass\n\n    def _translate_internal(self, solutions):\n        # rule is: anything given as an argument in a public function or\n        # available as a public property should be within the external boundaries\n\n        return self.ranges[:, 0] + (self.ranges[:, 1] - self.ranges[:, 0]) * (1.0 - np.cos(solutions * np.pi)) / 2.0\n\n    def _translate_external(self, solutions):\n        return np.arccos(1 - 2 * (solutions - self.ranges[:, 0]) / (self.ranges[:, 1] - self.ranges[:, 0])) / np.pi\n\n    def generate(self, ind_init):\n        """"""Generate a population from the current strategy using the \n        centroid individual as parent.\n        \n        :param ind_init: A function object that is able to initialize an\n                         individual from a list.\n        :returns: an iterator yielding the generated individuals.\n        """"""\n\n        centroid = self._translate_external(self.centroid)\n\n        arz = np.random.standard_normal((self.lambda_, self.dim)) #@UndefinedVariable\n        arz = np.array(centroid) + self.sigma * np.dot(arz, self.BD.T) #@UndefinedVariable\n\n        arz = self._translate_internal(arz)\n\n        for arr in arz:\n            yield ind_init(arr)\n\n    def __rotation_matrix(self, vector, target):\n        """""" Rotation matrix from one vector to another target vector.\n     \n        The solution is not unique as any additional rotation perpendicular to\n        the target vector will also yield a solution)\n         \n        However, the output is deterministic.\n        """"""\n\n        R1 = self.__rotation_to_pole(target)\n        R2 = self.__rotation_to_pole(vector)\n\n        return np.dot(R1.T, R2)\n\n    def __rotation_to_pole(self, target):\n        """""" Rotate to 1,0,0... """"""\n        n = len(target)\n        working = target\n        rm = np.eye(n)\n        for i in range(1, n):\n            angle = np.arctan2(working[0], working[i])\n            rm = np.dot(self.__rotation_matrix_inds(angle, n, 0, i), rm)\n            working = np.dot(rm, target)\n\n        return rm\n\n    def __rotation_matrix_inds(self, angle, n, ax1, ax2):\n        """""" \'n\'-dimensional rotation matrix \'angle\' radians in coordinate plane with\n            indices \'ax1\' and \'ax2\' """"""\n\n\n        s = np.sin(angle)\n        c = np.cos(angle)\n\n        i = np.eye(n)\n\n        i[ax1, ax1] = s\n        i[ax1, ax2] = c\n        i[ax2, ax1] = c\n        i[ax2, ax2] = -s\n\n        return i\n\n    pass #end of class\n\nclass Algorithm(RefineAsyncHelper):\n    """"""\n        This algorithm implements the ask-tell model proposed in \n        [Colette2010]_, where ask is called `generate` and tell is called `update`.\n        \n        Modified (Mathijs Dumon) so it checks for stagnation.\n    """"""\n\n    @property\n    def ngen(self):\n        return self._ngen\n    @ngen.setter\n    def ngen(self, value):\n        self._ngen = value\n        logger.info(""Setting ngen to %d"" % value)\n    _ngen = 100\n\n    gen = -1\n    halloffame = None\n\n    refiner = None\n\n    toolbox = None\n    stats = None\n    stagn_ngen = None\n    stagn_tol = None\n    verbose = False\n\n    #--------------------------------------------------------------------------\n    #    Initialization\n    #--------------------------------------------------------------------------\n    def __init__(self, toolbox, halloffame, stats, ngen=NGEN,\n                         verbose=__debug__, stagn_ngen=STAGN_NGEN,\n                         stagn_tol=STAGN_TOL, refiner=None, stop=None):\n        """"""\n        :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                        operators.\n        :param ngen: The number of generations.\n        :param halloffame: A :class:`~deap.tools.ParetoFront` object that will\n                           contain the best individuals.\n        :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                      inplace.\n        :param verbose: Whether or not to log the statistics.\n        :param stagn_gens: The minimum number of generations to wait before\n                            checking for stagnation\n        :param stagn_tol: The stagnation tolerance. Higher values means a \n                            harsher tolerance, values should fall between 0 and 1\n                    \n        :param refiner: PyXRD refiner object\n    \n        :returns: The best individual and the final population.\n        \n        The toolbox should contain a reference to the generate and the update method \n        of the chosen strategy.\n        \n        Call the run() method when the algorithm should be run.\n    \n        .. [Colette2010] Collette, Y., N. Hansen, G. Pujol, D. Salazar Aponte and\n           R. Le Riche (2010). On Object-Oriented Programming of Optimizers -\n           Examples in Scilab. In P. Breitkopf and R. F. Coelho, eds.:\n           Multidisciplinary Design Optimization in Computational Mechanics,\n           Wiley, pp. 527-565;\n    \n        """"""\n        self.stats = stats\n        self.toolbox = toolbox\n        self.ngen = ngen\n        self.halloffame = halloffame\n        self.verbose = verbose\n        self.stagn_ngen = stagn_ngen\n        self.stagn_tol = stagn_tol\n        self.refiner = refiner\n\n        self.gen = 0\n\n        self._stop = stop\n\n    #--------------------------------------------------------------------------\n    #    Run method:\n    #--------------------------------------------------------------------------\n    def run(self):\n        """"""Will run this algorithm""""""\n        if self.verbose:\n            column_names = [""gen"", ""evals"", ""best""]\n            if self.stats is not None:\n                column_names += list(self.stats.functions.keys())\n            self.logbook = tools.Logbook()\n            self.logbook.header = column_names\n\n        for _ in range(self.ngen):\n            # Check if the user has cancelled:\n            if self._user_cancelled():\n                self.refiner.status.message = ""Stopping...""\n                logger.info(""User cancelled execution, stopping ..."")\n                break\n\n            #ASK: Generate a new population:\n            population = self._ask()\n            #TELL: Update the strategy with the evaluated individuals\n            self._tell(population)\n            #RECORD: For stagnation checking & logging:\n            self._record(population)\n            #CHECK: whether we are stagnating:\n            if self._is_stagnating():\n                logging.info(""CMA: stagnation detected!"")\n                break\n\n        return self.refiner.history.best_solution, population\n\n    #--------------------------------------------------------------------------\n    #    Stagnation calls:\n    #--------------------------------------------------------------------------\n    def _is_flat(self, yvals, xvals, slope_tolerance=0.001):\n        slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(xvals, yvals) #@UndefinedVariable @UnusedVariable\n        val = bool(abs(slope) <= slope_tolerance)\n        return val\n\n    def _is_stagnating(self):\n        self.refiner.status.message = ""Checking for stagnation""\n        if self.gen >= self.stagn_ngen: # 10\n            std, best = self.logbook.select(""std"", ""best"")\n            std = np.array(std)[:, 0]\n            yvals1 = std[-(self.stagn_ngen - 1):]\n            xvals1 = list(range(len(yvals1)))\n            yvals2 = best[-(self.stagn_ngen - 1):]\n            xvals2 = list(range(len(yvals2)))\n            return self._is_flat(yvals1, xvals1, self.stagn_tol) and \\\n                self._is_flat(yvals2, xvals2, self.stagn_tol)\n        else:\n            return False\n\n    #--------------------------------------------------------------------------\n    #    Ask, tell & record:\n    #--------------------------------------------------------------------------\n    def _ask(self):\n        self.gen += 1\n        self.refiner.status.message = ""Creating generation #%d"" % self.gen\n\n        def result_f(*args):\n            self.refiner.update(*args)\n            result_func(*args)\n\n        population = self.do_async_evaluation(\n            self.toolbox.generate, result_func=result_f\n        )\n        \n        if self.halloffame is not None:\n            self.halloffame.update(population)\n\n        return population\n\n    def _tell(self, population):\n        self.refiner.status.message = ""Updating strategy""\n        self.toolbox.update(population)\n\n    def _record(self, population):\n        self.refiner.status.message = ""Processing ...""\n        \n        # Get the best solution so far:\n        best = self.halloffame.get_best()\n        best_f = best.fitness.values[0]\n        pop_size = len(population)\n\n        # Calculate stats & print something if needed:\n        record = self.stats.compile(population)\n        if self.verbose:\n            self.logbook.record(gen=self.gen, evals=pop_size, best=best_f, **record)\n            print(self.logbook.stream)\n\n        self.refiner.status.message = ""Refiner update ...""\n        # Update the refiner:\n        self.refiner.update(best, iteration=self.gen, residual=best_f)\n\n    pass #end of class\n\nclass RefineCMAESRun(RefineMethod):\n    """"""\n        The DEAP CMA-ES algorithm implementation with added stagnation thresholds\n    """"""\n    name = ""CMA-ES refinement""\n    description = ""This algorithm uses the CMA-ES refinement strategy as implemented by DEAP""\n    index = 1\n    disabled = False\n\n    ngen = RefineMethodOption(\'Maximum # of generations\', NGEN, [1, 10000], int)\n    stagn_ngen = RefineMethodOption(\'Minimum # of generations\', STAGN_NGEN, [1, 10000], int)\n    stagn_tol = RefineMethodOption(\'Fitness slope tolerance\', STAGN_TOL, [0., 100.], float)\n\n    def _individual_creator(self, refiner, bounds):\n        creator.create(\n            ""Individual"", pyxrd_array,\n            fitness=FitnessMin, # @UndefinedVariable\n            refiner=refiner,\n            min_bounds=bounds[:, 0].copy(),\n            max_bounds=bounds[:, 1].copy(),\n        )\n\n        def create_individual(lst):\n            arr = np.array(lst).clip(bounds[:, 0], bounds[:, 1]) #@UndefinedVariable\n            return creator.Individual(arr) # @UndefinedVariable\n\n        return create_individual\n\n    def _create_stats(self):\n        stats = tools.Statistics(lambda ind: ind.fitness.values)\n        stats.register(""avg"", np.mean, axis=0) #@UndefinedVariable\n        stats.register(""std"", np.std, axis=0) #@UndefinedVariable\n        stats.register(""min"", np.min, axis=0) #@UndefinedVariable\n        stats.register(""max"", np.max, axis=0) #@UndefinedVariable\n        return stats\n\n    _has_been_setup = False\n    def _setup(self, refiner, ngen=NGEN, stagn_ngen=STAGN_NGEN, stagn_tol=STAGN_TOL, **kwargs):\n        if not self._has_been_setup:\n            logger.info(""Setting up the DEAP CMA-ES refinement algorithm (ngen=%d)"" % ngen)\n            refiner.status.message = ""Setting up algorithm...""\n\n            # Process some general stuff:\n            bounds = np.array(refiner.ranges) #@UndefinedVariable\n            create_individual = self._individual_creator(refiner, bounds)\n\n            # Setup strategy:\n            centroid = create_individual(refiner.history.initial_solution)\n            strat_kwargs = {}\n            if ""lambda_"" in kwargs:\n                strat_kwargs[""lambda_""] = kwargs.pop(""lambda_"")\n            strategy = Strategy(\n                centroid=centroid, sigma=1.0 / 10.0, ranges=bounds,\n                stop=self._stop, **strat_kwargs\n            )\n\n            # Toolbox setup:\n            toolbox = base.Toolbox()\n            toolbox.register(""generate"", strategy.generate, create_individual)\n            toolbox.register(""update"", strategy.update)\n\n            # Hall of fame & stats:\n            logger.info(""Creating hall-off-fame and statistics"")\n            halloffame = PyXRDParetoFront(similar=lambda a1, a2: np.all(a1 == a2)) #@UndefinedVariable\n            stats = self._create_stats()\n\n            # Create algorithm\n            self.algorithm = Algorithm(\n                toolbox, halloffame, stats, ngen=ngen,\n                stagn_ngen=stagn_ngen, stagn_tol=stagn_tol, refiner=refiner, stop=self._stop)\n\n            self._has_been_setup = True\n        return self.algorithm\n\n    def run(self, refiner, **kwargs):\n        logger.info(""CMA-ES run invoked with %s"" % kwargs)\n        self._has_been_setup = False #clear this for a new refinement\n        algorithm = self._setup(refiner, **kwargs)\n        # Get this show on the road:\n        logger.info(""Running the CMA-ES algorithm..."")\n        algorithm.run()\n\n    pass # end of class\n'"
pyxrd/refinement/methods/deap_pso_cma.py,8,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nimport random, copy\n\nimport numpy as np\n\nfrom deap.tools import HallOfFame\nfrom deap import creator, base, tools #@UnresolvedImport\n\nfrom pyxrd.generic.asynchronous.cancellable import Cancellable\nfrom pyxrd.refinement.refine_async_helper import RefineAsyncHelper\n\nfrom ..refine_method import RefineMethod\nfrom ..refine_method_option import RefineMethodOption\n\nfrom .deap_utils import pyxrd_array, FitnessMin, result_func\nfrom .deap_cma import Strategy\n\n# Default settings:\nNGEN = 100\nNGEN_COMM = 5\nNSWARMS = 4\n\nclass SwarmStrategy(Cancellable):\n\n    def __create_strategy(self, parent, sigma, ranges, **kwargs):\n        return Strategy(\n            centroid=parent, sigma=sigma, ranges=ranges,\n            stop=self._stop, **kwargs\n        )\n\n    def __init__(self, parents, sigma, ranges, stop, ** kwargs):\n        self.nswarms = len(parents)\n        self._stop = stop\n        self.strategies = [self.__create_strategy(parents[i], sigma, ranges, **kwargs) for i in range(self.nswarms)]\n        self.global_best = None\n\n    def update(self, swarms, communicate=False):\n        if self._user_cancelled():\n            return\n\n        for i, population in enumerate(swarms):\n            self.strategies[i].update(population)\n            # Keep track of the global best:\n            best = population[0]\n            try:\n                if self.global_best is None or np.all(self.global_best.fitness < best.fitness):\n                    self.global_best = copy.deepcopy(best)\n            except ValueError:\n                logger.warn(""Got a value error comparing \'%s\' and \'%s\'"" % (self.global_best.fitness, best.fitness))\n\n        if communicate:\n            for i, population in enumerate(swarms):\n                self.strategies[i].rotate_and_bias(self.global_best)\n\n    def generate(self, ind_init):\n        for strategy in self.strategies:\n            yield strategy.generate(ind_init)\n\n    pass #end of class\n\n\nclass SwarmAlgorithm(RefineAsyncHelper):\n\n    @property\n    def ngen(self):\n        return self._ngen\n    @ngen.setter\n    def ngen(self, value):\n        self._ngen = value\n        logger.info(""Setting ngen to %d"" % value)\n    _ngen = 100\n\n    gen = -1\n    halloffame = None\n\n    refiner = None\n\n    toolbox = None\n    stats = None\n    verbose = False\n\n    #--------------------------------------------------------------------------\n    #    Initialization\n    #--------------------------------------------------------------------------\n    def __init__(self, toolbox, halloffame, stats, ngen=NGEN, ngen_comm=NGEN_COMM,\n                 verbose=__debug__, refiner=None, stop=None, eval_func=None, result_func=None):\n        """"""\n        :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution\n                        operators.\n        :param ngen: The number of generations.\n        :param ngen_comm: At each multiple generation of this number swarms will\n                         communicate\n        :param halloffame: A :class:`~deap.tools.ParetoFront` object that will\n                           contain the best individuals.\n        :param stats: A :class:`~deap.tools.Statistics` object that is updated\n                      inplace.\n        :param verbose: Whether or not to log the statistics.\n                    \n        :param refiner: PyXRD refiner object\n    \n        :returns: The best individual and the final population.\n        \n        The toolbox should contain a reference to the generate and the update method \n        of the chosen strategy.\n        \n        Call the run() method when the algorithm should be run.\n    \n        .. [Colette2010] Collette, Y., N. Hansen, G. Pujol, D. Salazar Aponte and\n           R. Le Riche (2010). On Object-Oriented Programming of Optimizers -\n           Examples in Scilab. In P. Breitkopf and R. F. Coelho, eds.:\n           Multidisciplinary Design Optimization in Computational Mechanics,\n           Wiley, pp. 527-565;\n    \n        """"""\n        self.stats = stats\n        self.toolbox = toolbox\n        self.ngen = ngen\n        self.ngen_comm = ngen_comm\n        self.halloffame = halloffame\n        self.verbose = verbose\n        self.refiner = refiner\n\n        self.eval_func = eval_func\n        self.result_func = result_func\n\n        self.gen = 0\n\n        self._stop = stop\n\n    #--------------------------------------------------------------------------\n    #    Run method:\n    #--------------------------------------------------------------------------\n    def run(self):\n        """"""Will run this algorithm""""""\n        if self.verbose:\n            column_names = [""gen"", ""evals"", ""best""]\n            if self.stats is not None:\n                column_names += list(self.stats.functions.keys())\n            self.logbook = tools.Logbook()\n            self.logbook.header = column_names\n\n        for _ in range(self.ngen):\n            # Check if the user has cancelled:\n            if self._user_cancelled():\n                self.refiner.status.message = ""Stopping...""\n                logger.info(""User cancelled execution, stopping ..."")\n                break\n\n            #ASK: Generate a new population:\n            swarms = self._ask()\n            #TELL: Update the strategy with the evaluated individuals\n            self._tell(swarms)\n            #RECORD: For logging:\n            self._record(swarms)\n\n        return self.refiner.history.best_solution, [ind for population in swarms for ind in population]\n\n    #--------------------------------------------------------------------------\n    #    Ask, tell & record:\n    #--------------------------------------------------------------------------\n    def _ask(self):\n        self.gen += 1\n        self.refiner.status.message = ""Creating generation #%d"" % self.gen\n\n        swarms = []\n        def iter_func():\n            for generator in self.toolbox.generate():\n                swarm = []\n                for solution in generator:\n                    swarm.append(solution)\n                    yield solution\n                swarms.append(swarm)\n\n        if self.result_func is None:\n            self.result_func = result_func\n            \n        def result_f(*args):\n            self.refiner.update(*args)\n            self.result_func(*args)\n\n        population = self.do_async_evaluation(\n            iter_func=iter_func,\n            eval_func=self.eval_func,\n            result_func=result_f\n        )\n\n        if self.halloffame is not None:\n            self.halloffame.update(population)\n\n        del population\n\n        return swarms\n\n    def _tell(self, swarms):\n        self.refiner.status.message = ""Updating strategy""\n        communicate = bool(self.gen > 0 and self.gen % self.ngen_comm == 0)\n        self.toolbox.update(swarms, communicate=communicate)\n\n    def _record(self, swarms):\n        self.refiner.status.message = ""Processing ...""\n\n        # Get the best solution so far:\n        if hasattr(self.halloffame, ""get_best""):\n            best = self.halloffame.get_best()\n        else:\n            best = self.halloffame[0]\n        best_f = best.fitness.values[0]\n\n        flat_pop = [ind for population in swarms for ind in population]\n        pop_size = len(flat_pop)\n\n        # Calculate stats & print something if needed:\n        record = self.stats.compile(flat_pop)\n        if self.verbose:\n            self.logbook.record(gen=self.gen, evals=pop_size, best=best_f, **record)\n            print(self.logbook.stream)\n\n\n        self.refiner.status.message = ""Refiner update ...""\n        # Update the refiner history:\n        self.refiner.update(best, iteration=self.gen, residual=best_f)\n\n    pass #end of class\n\nclass RefinePSOCMAESRun(RefineMethod):\n    """"""\n        The PS-CMA-ES hybrid algorithm implementation\n    """"""\n    name = ""PS-CMA-ES refinement""\n    description = ""This algorithm uses the PS-CMA-ES hybrid refinement strategy""\n    index = 6\n    disabled = False\n\n    ngen = RefineMethodOption(\'Maximum # of generations\', NGEN, [1, 10000], int)\n    nswarms = RefineMethodOption(\'# of CMA swarms\', NSWARMS, [1, 100], int)\n    ngen_comm = RefineMethodOption(\'Communicate each x gens\', NGEN_COMM, [1, 10000], int)\n\n    def _individual_creator(self, refiner, bounds):\n        creator.create(\n            ""Individual"", pyxrd_array,\n            fitness=FitnessMin, # @UndefinedVariable\n            refiner=refiner,\n            min_bounds=bounds[:, 0].copy(),\n            max_bounds=bounds[:, 1].copy(),\n        )\n\n        def create_individual(lst):\n            arr = np.array(lst).clip(bounds[:, 0], bounds[:, 1]) #@UndefinedVariable\n            return creator.Individual(arr) # @UndefinedVariable\n\n        return create_individual\n\n    def _create_stats(self):\n        stats = tools.Statistics(lambda ind: ind.fitness.values)\n        stats.register(""avg"", np.mean, axis=0) #@UndefinedVariable\n        stats.register(""std"", np.std, axis=0) #@UndefinedVariable\n        stats.register(""min"", np.min, axis=0) #@UndefinedVariable\n        stats.register(""max"", np.max, axis=0) #@UndefinedVariable\n        return stats\n\n    _has_been_setup = False\n    def _setup(self, refiner, ngen=NGEN, ngen_comm=NGEN_COMM, nswarms=NSWARMS, **kwargs):\n        if not self._has_been_setup:\n            logger.info(""Setting up the DEAP CMA-ES refinement algorithm (ngen=%d)"" % ngen)\n            refiner.status.message = ""Setting up algorithm...""\n\n            # Process some general stuff:\n            bounds = np.array(refiner.ranges) #@UndefinedVariable\n            create_individual = self._individual_creator(refiner, bounds)\n\n            # Setup strategy:\n\n            #TODO make the others random\n            parents = [None] * nswarms\n            parents[0] = create_individual(refiner.history.initial_solution)\n\n            for i in range(1, nswarms):\n                parents[i] = create_individual([\n                   random.uniform(bounds[j, 0], bounds[j, 1]) for j in range(len(refiner.history.initial_solution))\n                ])\n\n            strategy = SwarmStrategy(\n                parents=parents, sigma=1.0 / 10.0, ranges=bounds,\n                stop=self._stop,\n            )\n\n            # Toolbox setup:\n            toolbox = base.Toolbox()\n            toolbox.register(""generate"", strategy.generate, create_individual)\n            toolbox.register(""update"", strategy.update)\n\n            # Hall of fame & stats:\n            logger.info(""Creating hall-off-fame and statistics"")\n            halloffame = HallOfFame(1, similar=lambda a1, a2: np.all(a1 == a2)) #PyXRDParetoFront(similar=lambda a1, a2: np.all(a1 == a2))\n            stats = self._create_stats()\n\n            # Create algorithm\n            self.algorithm = SwarmAlgorithm(\n                toolbox, halloffame, stats, ngen=ngen, ngen_comm=ngen_comm,\n                refiner=refiner, stop=self._stop)\n\n            self._has_been_setup = True\n        return self.algorithm\n\n    def run(self, refiner, **kwargs):\n        logger.info(""CMA-ES run invoked with %s"" % kwargs)\n        self._has_been_setup = False #clear this for a new refinement\n        algorithm = self._setup(refiner, **kwargs)\n        # Get this show on the road:\n        logger.info(""Running the CMA-ES algorithm..."")\n        algorithm.run()\n\n    pass # end of class\n'"
pyxrd/refinement/methods/deap_swarm.py,19,"b'#    This file is part of DEAP.\n#\n#    DEAP is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Lesser General Public License as\n#    published by the Free Software Foundation, either version 3 of\n#    the License, or (at your option) any later version.\n#\n#    DEAP is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n#    GNU Lesser General Public License for more details.\n#\n#    You should have received a copy of the GNU Lesser General Public\n#    License along with DEAP. If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\nimport numpy as np\nimport scipy\nimport itertools\nimport random\n\nfrom pyxrd.refinement.refine_method import RefineMethod\nfrom pyxrd.refinement.refine_method_option import RefineMethodOption\nfrom pyxrd.refinement.refine_async_helper import RefineAsyncHelper\n\nfrom deap import base, creator, tools #@UnresolvedImport\n\nfrom .deap_utils import pyxrd_array, PyXRDParetoFront, FitnessMin, result_func\n\n# Default settings:\nNGEN = 100\nNSWARMS = 1\nNEXCESS = 3\nNPARTICLES = 15\nCONV_FACTR = 0.3 # 5.*1e-2\n\nclass MultiPSOStrategy(object):\n\n    def generate_particle(self, pclass, dim, pmin, pmax, smin, smax):\n        """""" Generate a particle """"""\n        part = pclass(random.uniform(pmin[i], pmax[i]) for i in range(dim))\n        part.speed = np.array([random.uniform(smin[i], smax[i]) for i in range(dim)])\n        return part\n\n    def update_particle(self, part, best, chi, c):\n        """"""\n            Update a particle\'s position & speed\n            part: the particle\n            best: the global best\n            chi ~ recombination factor\n            c ~ scale factor(s)\n        """"""\n        part_pos = np.asarray(part)\n        best_pos = np.asarray(best)\n        pers_pos = np.asarray(part.best)\n        speed = np.asarray(part.speed)\n\n        ce1 = c * np.random.uniform(0, 1, size=len(part))\n        ce2 = c * np.random.uniform(0, 1, size=len(part))\n        ce1_p = ce1 * np.array(best_pos - part_pos)\n        ce1_g = ce2 * np.array(pers_pos - part_pos)\n\n        f = (ce1_p + ce1_g)\n\n        # Calculate velocity:\n        a = chi * (f + speed) - speed\n\n        # Adjust speed:\n        speed = a + speed\n        # Set position & speed:\n        part[:] = part_pos + speed\n        part.speed = speed\n        # Clear fitness:\n        del part.fitness.values\n\n    def create_swarm(self, container, iterable):\n        """""" Returns a swarm container using the iterable """"""\n        return container(iterable)\n\n    def generate_particles(self, func, n):\n        """""" Returns a particle generator """"""\n        for _ in range(n):\n            yield func()\n\n    def update_swarm(self, swarm, part):\n        """""" Update swarm\'s attractors personal best and global best """"""\n        if not part.fitness.valid:\n            raise RuntimeError(""Particles need to have a valid fitness before calling update_swarm!"")\n        if part.best == None or part.fitness > part.bestfit:\n            part.best = creator.Particle(part)          # Get the position @UndefinedVariable\n            part.bestfit.values = part.fitness.values   # Get the fitness\n        if swarm.best == None or part.fitness > swarm.bestfit:\n            swarm.best = creator.Particle(part)         # Get the position @UndefinedVariable\n            swarm.bestfit.values = part.fitness.values  # Get the fitness\n\n    def give_reinit_swarms(self, population):\n        """""" Gives a set of swarm indeces that need to be reinitialized (overlap)""""""\n        reinit_swarms = set()\n        for s1, s2 in itertools.combinations(list(range(len(population))), 2):\n            # Swarms must have a best and not already be set to reinitialize\n            if population[s1].best is not None and population[s2].best is not None and not (s1 in reinit_swarms or s2 in reinit_swarms):\n                # if t-test is True, then we reinit the worst of the two swarms\n                t, _ = scipy.stats.ttest_ind(population[s1], population[s2]) #@UndefinedVariable\n                if np.all(t < 0.1):\n                    if population[s1].bestfit <= population[s2].bestfit:\n                        reinit_swarms.add(s1)\n                    else:\n                        reinit_swarms.add(s2)\n        return reinit_swarms\n\n    def give_converged_swarms(self, population, conv_factr, converged_bests=[]):\n        """""" Returns the number of converged swarms and the worst swarm index """"""\n        # Convergence check:\n        not_converged = 0\n        worst_swarm_idx = None\n        worst_swarm = None\n        for i, swarm in enumerate(population):\n            # Compute the diameter of the swarm:\n            std = np.std([ind.fitness.values for ind in swarm])\n            # If it\'s larger then a given factor, we\'ve not converged yet:\n            if std > conv_factr:\n                not_converged += 1\n                if worst_swarm is None or swarm.bestfit < worst_swarm.bestfit:\n                    worst_swarm_idx = i\n                    worst_swarm = swarm\n            else:\n                converged_bests.append(swarm.best)\n\n        converged_bests.sort(key=lambda i: i.fitness)\n\n        return not_converged, worst_swarm_idx, converged_bests\n\n    pass #end of class\n\nclass MPSOAlgorithm(RefineAsyncHelper):\n    """"""\n        Multi-particle-swarm optimization method adapted from the examples found\n        in the DEAP project. Employs a T-test (two independent sample lists) to\n        differentiate between swarms instead of the diameter and average of the\n        swarms. Seemed to work better for scaled parameters (YMMV).\n        \n        Implementation of the Multiswarm Particle Swarm Optimization algorithm as\n        presented in *Blackwell, Branke, and Li, 2008, Particle Swarms for Dynamic\n        Optimization Problems.*\n    """"""\n\n    gen = -1\n    converged_bests = None\n\n    #--------------------------------------------------------------------------\n    #    Initialization\n    #--------------------------------------------------------------------------\n    def __init__(self, toolbox, bounds, norms,\n        ngen=NGEN, nswarms=NSWARMS, nexcess=NEXCESS,\n        nparticles=NPARTICLES, conv_factr=CONV_FACTR,\n        stats=None, halloffame=None, verbose=True, refiner=None, stop=None):\n        """"""\n            TODO\n        """"""\n        self.converged_bests = []\n        self.toolbox = toolbox\n        self.bounds = bounds\n        self.norms = norms\n        self.ngen = ngen\n        self.nswarms = nswarms\n        self.nexcess = nexcess\n        self.nparticles = nparticles\n        self.conv_factr = conv_factr\n        self.stats = stats\n        self.halloffame = halloffame\n        self.verbose = verbose\n        self.refiner = refiner\n\n        self._stop = stop\n\n    #--------------------------------------------------------------------------\n    #    Convenience functions:\n    #--------------------------------------------------------------------------\n\n    def _evaluate_swarms(self, population):\n        # Only evaluate invalid particles:\n        def give_unevaluated_particles():\n            for p in itertools.chain(*population):\n                if p.fitness.valid: continue\n                else: yield p\n        self.do_async_evaluation(iter_func=give_unevaluated_particles, result_func=result_func)\n        for swarm in population:\n            for part in swarm:\n                self.toolbox.update_swarm(swarm, part)\n        return population\n\n    def _create_and_evaluate_swarm(self):\n        """""" Helper function that creates, evaluates and returns a new swarm """"""\n        particles = self.do_async_evaluation(iter_func=self.toolbox.generate_particles, result_func=result_func)\n        return self.toolbox.swarm(particles)\n\n    def _create_and_evaluate_population(self):\n        """""" Helper function that creates, evaluates and returns a population of swarms """"""\n        population = [self._create_and_evaluate_swarm() for _ in range(self.nswarms)]\n        if self.halloffame is not None:\n            self.halloffame.update(itertools.chain(*population))\n        return population\n\n    #--------------------------------------------------------------------------\n    #    Run method:\n    #-------------------------------------------------------------------------\n    def run(self):\n        """"""Will run this algorithm""""""\n        self._setup_logging()\n        population = []\n        for _ in range(self.ngen):\n\n            # Check if the user has cancelled:\n            if self._user_cancelled():\n                logger.info(""User cancelled execution of PCMA-ES, stopping ..."")\n                break\n\n            #ASK: Generate a new population:\n            population = self._ask(population)\n            #RECORD: For stagnation checking & logging:\n            self._record(population)\n            #CHECK: whether we are stagnating:\n            if self._is_stagnating():\n                break\n            #TELL: Update the strategy with the evaluated individuals\n            self._tell(population)\n\n        return (\n            self.refiner.history.best_solution,\n            list(itertools.chain(*population)),\n            self.converged_bests\n        )\n\n    #--------------------------------------------------------------------------\n    #    Ask, tell & record:\n    #--------------------------------------------------------------------------\n    def _ask(self, population):\n        """"""\n            Calculates how many swarms have converged, and keeps track of the\n            worst swarm. If all swarms have converged, it will add a new swarm.\n            If too many swarms are roaming, it will remove the worst.\n        """"""\n\n        self.gen += 1\n        self.refiner.status.message = ""Creating generation #%d"" % (self.gen + 1)\n\n        if not population:\n            # First iteration: create a new population of swarms\n            population = self._create_and_evaluate_population()\n        else:\n            # Second and later iterations: check for overlapping swarms\n            reinit_swarms = self.toolbox.give_reinit_swarms(population)\n            # Reinitialize and evaluate swarms\n            for sindex in reinit_swarms:\n                population[sindex] = self._create_and_evaluate_swarm()\n\n        # Get unconverged swarm count and worst swarm id:\n        not_converged, worst_swarm_idx, self.converged_bests = self.toolbox.give_converged_swarms(population, self.conv_factr, self.converged_bests)\n\n        # If all swarms have converged, add a swarm:\n        if not_converged == 0:\n            population.append(self._create_and_evaluate_swarm())\n\n        # If too many swarms are roaming, remove the worst swarm:\n        elif not_converged > self.nexcess:\n            population.pop(worst_swarm_idx)\n\n        return population\n\n    def _tell(self, population):\n        # Update and evaluate the swarm\n        for swarm in population:\n            # Update particles and swarm:\n            for part in swarm:\n                if swarm.best is not None and part.best is not None:\n                    self.toolbox.update_particle(part, swarm.best)\n        self._evaluate_swarms(population)\n        self.halloffame.update(itertools.chain(*population))\n\n    def _is_stagnating(self):\n        return False # TODO FIXME\n\n    def _setup_logging(self):\n        if self.verbose:\n            column_names = [""gen"", ""nswarm"", ""indiv""]\n            if self.stats is not None:\n                column_names += list(self.stats.functions.keys())\n            self.logbook = tools.Logbook()\n            self.logbook.header = column_names\n\n    def _record(self, population):\n        # Get pop size:\n        pop_size = len(population)\n\n        # Get the best solution so far:\n        best = self.halloffame.get_best()\n        best_f = best.fitness.values[0]\n\n        # Calculate stats & print something if needed:\n        pop = list(itertools.chain(*population))\n        record = self.stats.compile(pop)\n        if self.verbose:\n            self.logbook.record(gen=self.gen, nswarm=pop_size, indiv=len(pop), **record)\n            print(self.logbook.stream)\n\n        # Update the context:\n        self.refiner.update(best, iteration=self.gen, residual=best_f)\n\n    pass #end of class\n\n\nclass RefineMPSORun(RefineMethod):\n    """"""\n        The DEAP MPSO algorithm implementation\n    """"""\n    name = ""MPSO refinement""\n    description = ""This algorithm uses the MPSO refinement strategy""\n    index = 2\n    disabled = False\n\n    ngen = RefineMethodOption(\'Maximum # of generations\', NGEN, [1, 1000], int)\n    nswarms = RefineMethodOption(\'Start # of swarms\', NSWARMS, [1, 50], int)\n    nexcess = RefineMethodOption(\'Max # of unconverged swarms\', NEXCESS, [1, 50], int)\n    nparticles = RefineMethodOption(\'Swarm size\', NPARTICLES, [1, 50], int)\n    conv_factr = RefineMethodOption(\'Convergence tolerance\', CONV_FACTR, [0., 10.], float)\n\n    def _individual_creator(self, context, bounds):\n        creator.create(\n            ""Particle"", pyxrd_array,\n            fitness=FitnessMin, #@UndefinedVariable\n            speed=list,\n            best=None,\n            bestfit=FitnessMin, #@UndefinedVariable\n            context=context,\n            min_bounds=bounds[:, 0],\n            max_bounds=bounds[:, 1],\n        )\n        creator.create(""Swarm"", list, best=None, bestfit=FitnessMin) #@UndefinedVariable\n\n    def _create_stats(self):\n        stats = tools.Statistics(lambda ind: ind.fitness.values)\n        stats.register(""avg"", np.mean, axis=0)\n        stats.register(""std"", np.std, axis=0)\n        stats.register(""min"", np.min, axis=0)\n        stats.register(""max"", np.max, axis=0)\n        return stats\n\n    def run(self, refiner, ngen=NGEN, nswarms=NSWARMS, nexcess=NEXCESS,\n            conv_factr=CONV_FACTR, nparticles=NPARTICLES, **kwargs):\n\n        logger.info(""Setting up the DEAP MPSO refinement algorithm"")\n\n        # Process some general stuff:\n        ndim = len(refiner.refinables)\n        bounds = np.array(refiner.ranges)\n        norms = np.abs(bounds[:, 1] - bounds[:, 0])\n        self._individual_creator(refiner, bounds)\n\n        # Strategy setup\n        strategy = MultiPSOStrategy()\n\n        # Hall of fame & stats:\n        logger.info(""Creating hall-off-fame and statistics"")\n        halloffame = PyXRDParetoFront(similar=lambda a1, a2: np.all(a1 == a2))\n        stats = self._create_stats()\n\n        # Our toolbox:\n        toolbox = base.Toolbox()\n        toolbox.register(\n            ""particle"", strategy.generate_particle, creator.Particle, #@UndefinedVariable\n            dim=ndim,\n            pmin=bounds[:, 0], pmax=bounds[:, 1],\n            smin=-norms / 2.0, smax=norms / 2.0\n        )\n        toolbox.register(""update_particle"", strategy.update_particle, chi=0.729843788, c=norms / np.amax(norms))\n        toolbox.register(""generate_particles"", strategy.generate_particles, toolbox.particle, n=NPARTICLES)\n\n        toolbox.register(""swarm"", strategy.create_swarm, creator.Swarm) #@UndefinedVariable\n        toolbox.register(""update_swarm"", strategy.update_swarm)\n        toolbox.register(""give_reinit_swarms"", strategy.give_reinit_swarms)\n        toolbox.register(""give_converged_swarms"", strategy.give_converged_swarms)\n\n        # Create algorithm\n        algorithm = MPSOAlgorithm(\n            toolbox, bounds, norms,\n            ngen, nswarms, nexcess, nparticles, conv_factr,\n            stats=stats, halloffame=halloffame,\n            refiner=refiner, stop=self._stop, **kwargs\n        )\n\n        # Get this show on the road:\n        logger.info(""Running the MPSO algorithm..."")\n        best, population, converged_bests = algorithm.run() # returns (best, population) tuple\n\n        return best, population, converged_bests\n\n    pass # end of class\n'"
pyxrd/refinement/methods/deap_utils.py,3,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom math import sqrt\n\nimport sys\nfrom operator import mul, truediv\n\nimport numpy as np\n\nfrom deap import creator, base\nfrom deap.tools import ParetoFront\n\nclass pyxrd_array(creator._numpy_array):\n    """"""\n        Helper DEAP.creator._numpy_array subclass that tracks changes to its\n        underlying numerical data object, and if changed gets the corresponding\n        data object from the context (if set). Allows for async evaluation of\n        fitnesses for PyXRD parameter solutions.\n    """"""\n    min_bounds = None\n    max_bounds = None\n\n    def to_ndarray(self):\n        return np.ndarray.copy(self)\n\n    def __setitem__(self, i, y):\n        y = min(y, self.max_bounds[i])\n        y = max(y, self.min_bounds[i])\n        creator._numpy_array.__setitem__(self, i, y)\n\n    def __setslice__(self, i, j, y):\n        y = np.array(y)\n        np.clip(y, self.min_bounds[i:j], self.max_bounds[i:j], y)\n        creator._numpy_array.__setslice__(self, i, j, y)\n\n    pass # end of class\n\ndef result_func(individual, fitness):\n    individual.fitness.values = fitness\n\nclass FitnessMin(base.Fitness):\n    weights = []\n\n    def getValues(self):\n        return tuple(map(truediv, self.wvalues, (-1,) * len(self.wvalues)))\n\n    def setValues(self, values):\n        try:\n            self.wvalues = tuple(map(mul, values, (-1,) * len(values)))\n        except TypeError:\n            _, _, traceback = sys.exc_info()\n            raise TypeError(""Both weights and assigned values must be a ""\n            ""sequence of numbers when assigning to values of ""\n            ""%r. Currently assigning value(s) %r of %r to a fitness with ""\n            ""weights %s.""\n            % (self.__class__, values, type(values), (-1,) * len(values))).with_traceback(traceback)\n\n    values = property(getValues, setValues, base.Fitness.delValues,\n    (""Fitness values. Use directly ``individual.fitness.values = values`` ""\n     ""in order to set the fitness and ``del individual.fitness.values`` ""\n     ""in order to clear (invalidate) the fitness. The (unweighted) fitness ""\n     ""can be directly accessed via ``individual.fitness.values``.""))\n\n    def __eq__(self, other):\n        return tuple(self.wvalues) == tuple(other.wvalues)\n\n    pass #end of class\n\nclass PyXRDParetoFront(ParetoFront):\n\n    def get_best_n(self, n):\n        inds = []\n        for ind in self:\n            d = 0.0\n            for f in ind.fitness.wvalues:\n                d += f ** 2\n            d = sqrt(d)\n            inds.append((d, ind))\n\n        inds.sort(key=lambda ind:-ind[0])\n        return inds[:n]\n\n    def get_best(self):\n        _, ind = self.get_best_n(1)[0]\n        return ind\n\n    def update(self, population):\n        """"""Update the Pareto front hall of fame with the *population* by adding \n        the individuals from the population that are not dominated by the hall\n        of fame. If any individual in the hall of fame is dominated it is\n        removed.\n        \n        :param population: A list of individual with a fitness attribute to\n                           update the hall of fame with.\n        """"""\n        for ind in population:\n            is_dominated = False\n            has_twin = False\n            to_remove = []\n            for i, hofer in enumerate(self):    # hofer = hall of famer\n                try:\n                    if hofer.fitness.dominates(ind.fitness):\n                        is_dominated = True\n                        break\n                    elif ind.fitness.dominates(hofer.fitness):\n                        to_remove.append(i)\n                    elif ind.fitness == hofer.fitness and self.similar(ind, hofer):\n                        has_twin = True\n                        break\n                except ValueError:\n                    print(ind, ind.fitness)\n                    print(hofer, hofer.fitness)\n                    raise\n\n            for i in reversed(to_remove):       # Remove the dominated hofer\n                self.remove(i)\n            if not is_dominated and not has_twin:\n                self.insert(ind)\n        # Run the garbage collector once for good measure\n        import gc\n        gc.collect()\n'"
pyxrd/refinement/methods/scipy_runs.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nimport scipy\n\nfrom ..refine_method import RefineMethod\nfrom ..refine_method_option import RefineMethodOption\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nMAXFUN = 15000\nMAXITER = 15000\nIPRINT = 0\n\nclass RefineLBFGSBRun(RefineMethod):\n    """"""\n        An implementation of the L BFGS B refinement algorithm.\n    """"""\n\n    name = ""L BFGS B algorithm""\n    description = ""Refinement using the L BFGS B algorithm""\n    index = 0\n    disabled = False\n\n    maxfun = RefineMethodOption(\'Maximum # of function calls\', MAXFUN, [1, 1000000], int)\n    maxiter = RefineMethodOption(\'Maximum # of iterations\', MAXITER, [1, 1000000], int)\n    iprint = RefineMethodOption(\'Output level [-1,0,1]\', IPRINT, [-1, 1], int)\n\n    def run(self, refiner, maxfun=MAXFUN, maxiter=MAXITER, iprint=IPRINT, **kwargs):\n        """"""\n            Refinement using the L BFGS B algorithm\n        """"""\n        solution, residual, d = scipy.optimize.fmin_l_bfgs_b(# @UnusedVariable @UndefinedVariable\n            refiner.get_residual,\n            refiner.history.initial_solution,\n            approx_grad=True,\n            bounds=refiner.ranges,\n            iprint=iprint,\n            epsilon=1e-4,\n            callback=refiner.update,\n            maxfun=maxfun, maxiter=maxiter\n        )\n        \n        refiner.update(solution, residual=residual)\n        \n        logger.debug(""fmin_l_bfgs_b returned: %s"" % d)\n\n    pass # end of class\n\nclass RefineBasinHoppingRun(RefineMethod):\n    """"""\n        An implementation of the Basin Hopping refinement algorithm.\n    """"""\n\n    name = ""Basin Hopping Algorithm""\n    description = ""Refinement using a basin hopping algorithm""\n    index = 4\n    disabled = False\n\n    niter = RefineMethodOption(\'Number of iterations\', 100, [10, 10000], int)\n    T = RefineMethodOption(\'Temperature criterion\', 1.0, [0.0, None], int)\n    stepsize = RefineMethodOption(\'Displacement step size\', 0.5, [0.0, None], float)\n\n    def run(self, refiner, niter=100, T=1.0, stepsize=0.5, **kwargs):\n        """"""\n            Refinement using a Basin Hopping Algorithm\n        """"""\n        vals = scipy.optimize.basinhopping(  # @UndefinedVariable\n            refiner.get_residual,\n            refiner.history.initial_solution,\n            niter=niter,\n            T=T, # this can be quite large\n            stepsize=stepsize,\n            minimizer_kwargs={\n                \'method\': \'L-BFGS-B\',\n                \'bounds\': refiner.ranges,\n            },\n            callback=lambda s,r, a: refiner.update(s,r),\n        )\n        solution = np.asanyarray(vals.x)\n        residual = vals.fun\n        refiner.update(solution, residual=residual)\n\n    pass # end of class\n\n'"
pyxrd/refinement/refinables/__init__.py,0,b''
pyxrd/refinement/refinables/metaclasses.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.metaclasses import ModelMeta\nfrom .models import RefinementInfo\n\nclass PyXRDRefinableMeta(ModelMeta):\n    """"""\n        A metaclass for regular mvc Models with refinable properties.\n    """"""\n\n    # ------------------------------------------------------------\n    #      Instance creation:\n    # ------------------------------------------------------------\n    def __call__(cls, *args, **kwargs):   # @NoSelf\n        """"""\n        Strips the refinement info data from the keyword argument dictionary,\n        passes the stripped dictionary to create the actual class instance,\n        creates the attributes on the instance and returns it.\n        """"""\n        # Pop & parse any refinement info keyword arguments that might be present:\n        prop_infos = dict()\n        for prop in cls.Meta.all_properties:\n            if getattr(prop, ""refinable"", False):\n                ref_info_name = prop.get_refinement_info_name()\n                info_args = kwargs.pop(ref_info_name, None)\n                if info_args:\n                    prop_infos[ref_info_name] = RefinementInfo.from_json(*info_args)\n                else:\n                    prop_infos[ref_info_name] = RefinementInfo(prop.minimum, prop.maximum, False)\n\n        # Create the instance passing the stripped keyword arguments:\n        instance = ModelMeta.__call__(cls, *args, **kwargs)\n\n        # Set the refinement attributes on the newly created instance:\n        for ref_info_name, ref_info in prop_infos.items():\n            setattr(instance, ref_info_name, ref_info)\n\n        # Return the instance:\n        return instance\n\n    pass # end of class\n'"
pyxrd/refinement/refinables/mixins.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass _RefinementBase(object):\n    """"""\n    Base class for `RefinementGroup` and `RefinementValue` mixins. It\'s \n    used to provide common functionality and a way to check for the kind of\n    refinement class we\'re dealing with when building the refinement tree.\n            \n    .. attribute:: refine_title\n\n        A string used as the title for the group in the refinement tree\n\n    .. attribute:: refine_descriptor\n\n        A longer title string which gives more information (phase, component, etc) \n        \n    .. attribute:: is_refinable\n\n        Whether or not this instance is refinable\n        \n    .. attribute:: refinables\n        \n        An iterable with the names of the refinable properties \n        \n    .. attribute:: refine_value\n    \n        Mapper for the actual refinable value (if available). This should be\n        overriden by deriving classes.\n        \n    """"""\n\n    @property\n    def refine_title(self):\n        return ""Refinement Base""\n\n    @property\n    def refine_descriptor_data(self):\n        return dict()\n\n    @property\n    def is_refinable(self):\n        return True\n\n    @property\n    def refinables(self):\n        return []\n\n    @property\n    def refine_info(self):\n        return None\n\n    @property\n    def refine_value(self):\n        return None\n    @refine_value.setter\n    def refine_value(self, value):\n        pass\n\n    pass # end of class\n\nclass RefinementGroup(_RefinementBase):\n    """"""\n    Mixin for objects that are not refinable themselves,\n    but have refinable properties. They are presented in the refinement\n    tree using their title value.\n    Subclasses should override refine_title to make it more descriptive.\n    \n    .. attribute:: children_refinable\n\n        Whether or not the child properties of this group can be refinable.\n        This should normally always be True, unless for example if the entire\n        group of properties have a single inherit property.\n    \n    """"""\n\n    @property\n    def refine_title(self):\n        return ""Refinement Group""\n\n    @property\n    def is_refinable(self):\n        return False\n\n    @property\n    def children_refinable(self):\n        return True\n\n    @property\n    def refinables(self):\n        return self.Meta.get_refinable_properties()\n\n    pass # end of class\n\nclass RefinementValue(_RefinementBase):\n    """"""\n        Mixin for objects that hold a single refinable property. They are\n        collapsed into one line in the refinement tree. \n        Subclasses should override both the refine_title property to make it\n        more descriptive, and the refine_value property to return and set the\n        correct (refinable) attribute.\n    """"""\n\n    @property\n    def refine_title(self):\n        return ""Refinement Value""\n\n    pass # end of class\n'"
pyxrd/refinement/refinables/models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties import FloatProperty, BoolProperty\n\nfrom pyxrd.generic.models.base import PyXRDModel\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.utils import not_none\n\n@storables.register()\nclass RefinementInfo(PyXRDModel, Storable):\n    """"""\n        A model that is used to store the refinement information for each\n        refinable value (in other models): minimum and maximum value and\n        a flag to indicate whether this value is selected for refinement.\n    """"""\n\n    # MODEL INTEL:\n    class Meta(PyXRDModel.Meta, Storable.Meta):\n        store_id = ""RefinementInfo""\n\n    minimum = FloatProperty(default=0.0, text=""Minimum"", persistent=True)\n    maximum = FloatProperty(default=1.0, text=""Maximum"", persistent=True)\n    refine = BoolProperty(default=False, text=""Refine"", persistent=True)\n\n    def __init__(self, minimum, maximum, refine, *args, **kwargs):\n        """"""\n            Valid *positional* arguments for a RefinementInfo are:\n                refine: whether or not the linked parameter is selected for refinement\n                minimum: the minimum allowable value for the linked parameter\n                maximum: the maximum allowable value for the linked parameter   \n        """"""\n        super(RefinementInfo, self).__init__()\n        self.refine = refine\n        self.minimum = not_none(minimum, 0.0)\n        self.maximum = not_none(maximum, 1.0)\n\n    def to_json(self):\n        return self.json_properties()\n\n    def json_properties(self):\n        return [self.minimum, self.maximum, self.refine]\n\n    pass # end of class\n'"
pyxrd/refinement/refinables/wrapper.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.models.properties import (\n    LabeledProperty, StringProperty, BoolProperty,\n    ReadOnlyMixin\n)\n\nfrom pyxrd.generic.models.base import ChildModel\n\nfrom .mixins import _RefinementBase, RefinementValue, RefinementGroup\n\nclass RefinableWrapper(ChildModel):\n    """"""\n        Wrapper class for refinables easing the retrieval of certain\n        properties for the different types of refinables.\n        Can be used with an ObjectTreeStore.\n    """"""\n\n    # MODEL INTEL:\n    class Meta(ChildModel.Meta):\n        parent_alias = ""mixture""\n\n    # PROPERTIES:\n\n    #: The wrapped object\n    obj = LabeledProperty(\n        default=None, text=""Wrapped object"", tabular=True)\n\n    #: The property descriptor object for the attribute\n    prop_descr = LabeledProperty(\n        default=None, text=""Property descriptor"", tabular=True)\n\n    #: The Property label:\n    @StringProperty(\n        default="""", text=""Property label"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def label(self):\n        return self.prop_descr.label\n\n    #: A flag indicating whether this is wrapper is representing the group\n    #: (True) or a member of the group (False):\n    is_grouper = BoolProperty(\n        default=False, text=""Is grouper"", tabular=True, mix_with=(ReadOnlyMixin,))\n\n    #: The inherit attribute name:\n    @LabeledProperty(\n        default=None, text=""Inherit from label"", mix_with=(ReadOnlyMixin,))\n    def inherit_from(self):\n        return self.prop_descr.inherit_from if self.prop_descr else None\n\n    #: The (possibly mathtext) label for the refinable property:\n    @StringProperty(\n        default="""", text=""Title"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def title(self):\n        if (isinstance(self.obj, RefinementGroup) and self.is_grouper) or isinstance(self.obj, RefinementValue):\n            return self.obj.refine_title\n        else:\n            if getattr(self.prop_descr, ""math_text"", None) is not None:\n                return self.prop_descr.math_text\n            else:\n                return self.prop_descr.text\n\n    #: The (pure text) label for the refinable property:\n    @StringProperty(\n        default="""", text=""Text title"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def text_title(self):\n        if (isinstance(self.obj, RefinementGroup) and self.is_grouper) or isinstance(self.obj, RefinementValue):\n            return self.obj.refine_title\n        else:\n            return self.prop_descr.text\n\n    @StringProperty(\n        default="""", text=""Descriptor"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def text_descriptor(self):\n        """""" Return a longer title that also describes this property\'s relations """"""\n\n        # This gets the phase and/or component name for the group or value:\n        data = self.obj.refine_descriptor_data\n\n        # Here we still need to get the actual property title:\n        data[""property_name""] = self.text_title\n\n        return ""%(phase_name)s | %(component_name)s | %(property_name)s"" % data\n\n    #: The actual value of the refinable property:\n    @LabeledProperty(\n        default=None, text=""Value"", tabular=True)\n    def value(self):\n        if isinstance(self.obj, RefinementValue):\n            return self.obj.refine_value\n        elif not self.is_grouper:\n            return getattr(self.obj, self.label)\n        else:\n            return """"\n    @value.setter\n    def value(self, value):\n        value = max(min(value, self.value_max), self.value_min)\n        if self.is_grouper:\n            raise AttributeError(""Cannot set the value for a grouping RefinableWrapper"")\n        elif isinstance(self.obj, RefinementValue):\n            self.obj.refine_value = value\n        else:\n            setattr(self.obj, self.label, value)\n\n    #: Whether or not this property is inherited from another object\n    @BoolProperty(\n        default=False, text=""Inherited"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def inherited(self):\n        return self.inherit_from is not None and hasattr(self.obj, self.inherit_from) and getattr(self.obj, self.inherit_from)\n\n    #: Whether or not this property is actually refinable\n    @BoolProperty(\n        default=False, text=""Refinable"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def refinable(self):\n        if isinstance(self.obj, _RefinementBase):\n            # We have a _RefinementBase property (group or value)\n            if isinstance(self.obj, RefinementGroup):\n                if self.is_grouper: # the grouper itself\n                    return False\n                else: # attribute of the grouper\n                    return (not self.inherited) and self.obj.children_refinable\n            elif isinstance(self.obj, RefinementValue):\n                return (not self.inherited) and self.obj.is_refinable\n        else:\n            # This is actually impossible, but what the hack...\n            return (not self.inherited)\n\n    #: The refinement info object for the refinable property\n    @LabeledProperty(\n        default=None, text=""Refinement info"", tabular=True, mix_with=(ReadOnlyMixin,))\n    def ref_info(self):\n        if (isinstance(self.obj, RefinementGroup) and self.is_grouper) or isinstance(self.obj, RefinementValue):\n            return self.obj.refine_info\n        else:\n            name = self.prop_descr.get_refinement_info_name()\n            if name is not None:\n                ref_info = getattr(self.obj, name)\n                return ref_info\n            else:\n                raise AttributeError(""Cannot find refine info model for attribute \'%s\' on \'%s\'"" % (self.label, self.obj))\n\n    #: The minimum value for the refinable property\n    @LabeledProperty(\n        default=None, text=""Minimum value"", tabular=True)\n    def value_min(self):\n        return self.ref_info.minimum if self.ref_info else None\n    @value_min.setter\n    def value_min(self, value):\n        if self.ref_info:\n            self.ref_info.minimum = value\n\n    #: The maximum value of the refinable property\n    @LabeledProperty(\n        default=None, text=""Maximum value"", tabular=True)\n    def value_max(self):\n        return self.ref_info.maximum if self.ref_info else None\n    @value_max.setter\n    def value_max(self, value):\n        if self.ref_info:\n            self.ref_info.maximum = value\n\n    #: Wether this property is selected for refinement\n    @BoolProperty(\n        default=False, text=""Refine"", tabular=True)\n    def refine(self):\n        return self.ref_info.refine if self.ref_info else False\n    @refine.setter\n    def refine(self, value):\n        if self.ref_info:\n            self.ref_info.refine = value and self.refinable\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for a RefinableWrapper are:\n                obj: the object we are wrapping a parameter for\n                prop or prop_descr: the property descriptor\n                is_grouper: whether or not this is a grouper object\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs, ""obj"", ""prop"", ""prop_descr"", ""is_grouper"")\n        super(RefinableWrapper, self).__init__(**kwargs)\n        kwargs = my_kwargs\n\n        self.obj = self.get_kwarg(kwargs, None, ""obj"")\n        self.prop_descr = self.get_kwarg(kwargs, None, ""prop_descr"", ""prop"")\n        self._is_grouper = self.get_kwarg(kwargs, False, ""is_grouper"")\n\n    pass # end of class\n'"
pyxrd/refinement/views/__init__.py,0,b''
pyxrd/refinement/views/refinement_view.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename  # @UnresolvedImport\n\nfrom math import isnan\n\nfrom mvc.adapters.gtk_support.widgets.threaded_task_box import ThreadedTaskBox\n\nfrom pyxrd.generic.views import  DialogView\nfrom pyxrd.generic.utils import not_none\n\nclass RefinementView(DialogView):\n    title = ""Refine Phase Parameters""\n    subview_builder = resource_filename(__name__, ""glade/refinement.glade"")\n    subview_toplevel = ""refine_params""\n    modal = True\n\n    refine_status_builder = resource_filename(__name__, ""glade/refine_status.glade"")\n    refine_status_toplevel = ""tbl_refine_info""\n    refine_status_container = ""refine_status_box""\n\n    refine_spin_container = ""refine_spin_box""\n    refine_spin_box = None\n\n    refine_method_builder = resource_filename(__name__, ""glade/refine_method.glade"")\n    refine_method_toplevel = ""tbl_refine_method""\n    refine_method_container = ""refine_method_box""\n\n    def __init__(self, *args, **kwargs):\n        super(RefinementView, self).__init__(*args, **kwargs)\n\n        # Add the status box\n        self._builder.add_from_file(self.refine_status_builder)\n        self._add_child_view(self[self.refine_status_toplevel], self[self.refine_status_container])\n\n        # Add the method and options box\n        self._builder.add_from_file(self.refine_method_builder)\n        self._add_child_view(self[self.refine_method_toplevel], self[self.refine_method_container])\n\n        # Add the refinement thread box\n        self.refine_spin_box = ThreadedTaskBox()\n        self._add_child_view(self.refine_spin_box, self[self.refine_spin_container])\n        self.hide_refinement_info()\n\n    def connect_cancel_request(self, callback):\n        return self.refine_spin_box.connect(""cancelrequested"", callback)\n\n    def show_refinement_info(self,):\n        self[""hbox_actions""].set_sensitive(False)\n        self[""btn_auto_restrict""].set_sensitive(False)\n        self[self.refine_method_toplevel].set_sensitive(False)\n        self[""refinables""].set_visible(False)\n        self[""refinables""].set_no_show_all(True)\n\n        self[self.refine_status_toplevel].show_all()\n\n    def hide_refinement_info(self):\n        self[self.refine_status_toplevel].hide()\n\n        self[""hbox_actions""].set_sensitive(True)\n        self[""btn_auto_restrict""].set_sensitive(True)\n        self[self.refine_method_toplevel].set_sensitive(True)\n        self[""refinables""].set_visible(True)\n        self[""refinables""].set_no_show_all(False)\n\n    def update_refinement_info(self, current_rp=None, message=None, server_status=None):\n        if not isnan(current_rp):\n            self[""current_residual""].set_text(""%.2f"" % current_rp)\n        self[""message""].set_text(not_none(message, """"))\n        self.update_server_status(server_status)\n        \n    def update_server_status(self, server_status):\n        color, title, descr = server_status\n        self[""lbl_server_status""].set_markup(""<span foreground=\\""%s\\"">%s</span>"" % (color, title))\n        self[""lbl_server_status""].set_property(""tooltip-text"", descr)\n        self[""lbl_server_status""].set_property(""tooltip-text"", descr)\n        self[""lbl_server_status""].set_tooltip_text(descr)\n\n    def update_refinement_status(self, status):\n        self.refine_spin_box.set_status(status)\n\n    def start_spinner(self):\n        self.refine_spin_box.start()\n\n    def stop_spinner(self):\n        self.refine_spin_box.stop()\n\n    pass # end of class'"
pyxrd/refinement/views/refiner_view.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename  # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nimport matplotlib\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_gtk3cairo import FigureCanvasGTK3Cairo as FigureCanvasGTK\nfrom matplotlib.backends.backend_gtk3 import NavigationToolbar2GTK3 as NavigationToolbar\n\nfrom pyxrd.generic.views import BaseView\n\nclass RefinerView(BaseView):\n    """"""\n        A view for the Refiner object\n    """"""\n    \n    builder = resource_filename(__name__, ""glade/refine_results.glade"")\n    top = ""window_refine_results""\n    modal = True\n\n    graph_parent = ""plot_box""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.graph_parent = self[self.graph_parent]\n\n        self.get_toplevel().set_transient_for(self.parent.get_toplevel())\n\n        self.setup_matplotlib_widget()\n\n    def update_labels(self, initial, best, last):\n        self[""initial_residual""].set_text(""%f"" % initial)\n        self[""best_residual""].set_text(""%f"" % best)\n        self[""last_residual""].set_text(""%f"" % last)\n\n    def setup_matplotlib_widget(self):\n        # TODO Create a mixin for this kind of thing!!\n        #style = Gtk.Style()\n        self.figure = Figure(dpi=72) #, edgecolor=str(style.bg[2]), facecolor=str(style.bg[2]))\n\n        self.figure.subplots_adjust(bottom=0.20)\n\n        self.canvas = FigureCanvasGTK(self.figure)\n\n        box = Gtk.VBox()\n        box.pack_start(NavigationToolbar(self.canvas, self.get_top_widget()), False, True, 0)\n        box.pack_start(self.canvas, True, True, 0)\n        self.graph_parent.add(box)\n        self.graph_parent.show_all()\n\n        cdict = {\'red\': ((0.0, 0.0, 0.0),\n                         (0.5, 1.0, 1.0),\n                         (1.0, 0.0, 0.0)),\n                \'green\': ((0.0, 0.0, 0.0),\n                         (0.5, 1.0, 1.0),\n                         (1.0, 0.0, 0.0)),\n                \'blue\': ((0.0, 0.0, 0.0),\n                         (0.5, 1.0, 1.0),\n                         (1.0, 0.0, 0.0))}\n        self.wbw_cmap = matplotlib.colors.LinearSegmentedColormap(\'WBW\', cdict, 256)\n\n    pass # end of class'"
pyxrd/specimen/controllers/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .specimen_controllers import SpecimenController, StatisticsController\n\nfrom .marker_controllers import (\n    MarkersController,\n    EditMarkerController,\n    MatchMineralController,\n    ThresholdController\n)\n\nfrom pyxrd.generic.controllers.line_controllers import (\n    BackgroundController,\n    SmoothDataController,\n    AddNoiseController,\n    ShiftDataController,\n    StripPeakController\n)\n\n__all__ = [\n    ""SpecimenController"",\n    ""StatisticsController"",\n    ""MarkersController"",\n    ""EditMarkerController"",\n    ""MatchMineralController"",\n    ""ThresholdController"",\n    ""BackgroundController"",\n    ""SmoothDataController"",\n    ""AddNoiseController"",\n    ""ShiftDataController"",\n    ""StripPeakController"",\n]\n'"
pyxrd/specimen/controllers/marker_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom contextlib import contextmanager\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc import Controller\n\nfrom pyxrd.generic.plot.eye_dropper import EyeDropper\nfrom pyxrd.generic.plot.draggables import DraggableVLine\nfrom pyxrd.generic.controllers import DialogController, BaseController, ObjectListStoreController\nfrom pyxrd.generic.views.treeview_tools import setup_treeview, new_text_column, new_toggle_column\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\n\nfrom pyxrd.specimen.models import Marker, ThresholdSelector, MineralScorer\nfrom pyxrd.specimen.views import (\n    EditMarkerView,\n    DetectPeaksView,\n    MatchMineralsView\n)\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.data import settings\n\nclass EditMarkerController(BaseController):\n\n    def register_view(self, view):\n        self.update_sensitivities()\n        self.update_nanometer()\n\n    def update_sensitivities(self):\n        for name in (""style"", ""base"", ""align"", ""top"", ""color""):\n            wid = self.view[""marker_%s"" % name]\n            wid.set_sensitive(not getattr(self.model, ""inherit_%s"" % name)) \n        for name in (""angle"", ""top_offset""):\n            self.view[""spb_%s"" % name].set_sensitive(not getattr(self.model, ""inherit_%s"" % name))\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""position"", assign=True, after=True)\n    def notif_parameter_changed(self, model, prop_name, info):\n        if prop_name == ""position"":\n            self.update_nanometer()\n\n    @Controller.observe(""inherit_style"", assign=True)\n    @Controller.observe(""inherit_align"", assign=True)\n    @Controller.observe(""inherit_base"", assign=True)\n    @Controller.observe(""inherit_top"", assign=True)\n    @Controller.observe(""inherit_top_offset"", assign=True)\n    @Controller.observe(""inherit_angle"", assign=True)\n    @Controller.observe(""inherit_color"", assign=True)\n    def notif_angle_toggled(self, model, prop_name, info):\n        self.update_sensitivities()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_nanometer_changed(self, widget):\n        try:\n            position = float(widget.get_value())\n        except ValueError:\n            logger.exception(""User set nanometers to an invalid value: %s"", widget.get_value())\n        else:\n            self.model.set_nm_position(position)\n        pass\n\n    def update_nanometer(self):\n        self.view[""entry_nanometer""].set_value(self.model.get_nm_position())\n\n    def on_sample_clicked(self, widget):\n\n        def click_callback(x_pos, event):\n            if self.edc is not None:\n                self.edc.disconnect()\n            self.view.get_toplevel().present()\n            if x_pos != -1:\n                self.model.position = x_pos\n\n        self.edc = EyeDropper(\n            self.parent.plot_controller,\n            click_callback\n        )\n\n        self.view.get_toplevel().hide()\n        self.parent.view.get_toplevel().present()\n\nclass MarkersController(ObjectListStoreController):\n    """""" \n        Controller for the markers list\n    """"""\n\n    file_filters = (""Marker file"", get_case_insensitive_glob(""*.MRK"")),\n    treemodel_property_name = ""markers""\n    treemodel_class_type = Marker\n    columns = [\n        ("" "", ""c_visible""),\n        (""Marker label"", ""c_label"")\n    ]\n    delete_msg = ""Deleting a marker is irreversible!\\nAre You sure you want to continue?""\n    obj_type_map = [\n        (Marker, EditMarkerView, EditMarkerController),\n    ]\n    title = ""Edit Markers""\n\n    def get_markers_tree_model(self, *args):\n        return self.treemodel\n\n    def setup_treeview_col_c_visible(self, treeview, name, col_descr, col_index, tv_col_nr):\n        def toggle_renderer(column, cell, model, itr, data=None):\n            try:\n                col = column.get_col_attr(""active"")\n                value = model.get_value(itr, col)\n                cell.set_property(\'active\', not_none(value, False))\n            except TypeError:\n                if settings.DEBUG: raise\n                pass\n\n        col = new_toggle_column("" "",\n                toggled_callback=(self.on_marker_visible_toggled, (treeview.get_model(), col_index)),\n                data_func=toggle_renderer,\n                resizable=False,\n                expand=False,\n                activatable=True,\n                active_col=col_index)\n        setattr(col, ""colnr"", col_index)\n        treeview.append_column(col)\n        return True\n\n    def select_markers(self, markers):\n        self.set_selected_objects()\n\n    @contextmanager\n    def _multi_operation_context(self):\n        with self.model.visuals_changed.hold():\n            yield\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_load_object_clicked(self, event):\n        def on_accept(dialog):\n            with self._multi_operation_context():\n                for marker in Marker.get_from_csv(dialog.filename, self.model):\n                    self.model.markers.append(marker)\n        DialogFactory.get_load_dialog(\n            ""Import markers"", parent=self.view.get_top_widget(),\n            filters=self.file_filters\n        ).run(on_accept)\n\n    def on_save_object_clicked(self, event):\n        def on_accept(dialog):\n            Marker.save_as_csv(dialog.filename, self.get_selected_objects())\n        DialogFactory.get_save_dialog(\n            ""Export markers"", parent=self.view.get_top_widget(),\n            filters=self.file_filters\n        ).run(on_accept)\n\n    def create_new_object_proxy(self):\n        return Marker(label=""New Marker"", parent=self.model)\n\n    def on_marker_visible_toggled(self, cell, path, model, colnr):\n        if model is not None:\n            itr = model.get_iter(path)\n            model.set_value(itr, colnr, not cell.get_active())\n            return True\n        return False\n\n    @BaseController.status_message(""Finding peaks..."", ""find_peaks"")\n    def on_find_peaks_clicked(self, widget):\n        def after_cb(threshold):\n            self.model.auto_add_peaks(threshold)\n\n        sel_model = ThresholdSelector(parent=self.model)\n        sel_view = DetectPeaksView(parent=self.view)\n        sel_ctrl = ThresholdController(model=sel_model, view=sel_view, parent=self, callback=after_cb) #@UnusedVariable\n        \n        show_threshold_plot = DialogFactory.get_progress_dialog(\n            action=sel_model.update_threshold_plot_data,\n            complete_callback=lambda *a, **k: sel_view.present(),\n            gui_message=""Finding peaks {progress:.0f}%..."",\n            toplevel=self.view.get_top_widget()\n        )\n\n        if len(self.model.markers) > 0:\n            def on_accept(dialog):\n                self.model.clear_markers()\n                show_threshold_plot()\n            def on_reject(dialog):\n                show_threshold_plot()\n            DialogFactory.get_confirmation_dialog(\n                ""Do you want to clear the current markers for this pattern?"",\n                parent=self.view.get_top_widget()\n            ).run(on_accept, on_reject)\n        else:\n            show_threshold_plot()          \n\n    def on_match_minerals_clicked(self, widget):\n        def apply_cb(matches):\n            with self._multi_operation_context():\n                for name, abbreviation, peaks, matches, score in matches: #@UnusedVariable\n                    for marker in self.get_selected_objects():\n                        for mpos, epos in matches: #@UnusedVariable\n                            if marker.get_nm_position() * 10. == epos:\n                                marker.label += "", %s"" % abbreviation\n\n        def close_cb():\n            self.model.visuals_changed.emit()\n            self.view.show()\n\n        marker_peaks = [] # position, intensity\n\n        for marker in self.get_selected_objects():\n            intensity = self.model.experimental_pattern.get_y_at_x(\n                marker.position)\n            marker_peaks.append((marker.get_nm_position() * 10., intensity))\n\n        scorer_model = MineralScorer(marker_peaks=marker_peaks, parent=self.model)\n        scorer_view = MatchMineralsView(parent=self.view)\n        scorer_ctrl = MatchMineralController(model=scorer_model, view=scorer_view, parent=self, apply_callback=apply_cb, close_callback=close_cb) #@UnusedVariable\n\n        self.view.hide()\n        scorer_view.present()\n\n    pass # end of class\n\nclass MatchMineralController(DialogController):\n\n    apply_callback = None\n    close_callback = None\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, model, view, spurious=False, auto_adapt=False, parent=None, apply_callback=None, close_callback=None):\n        DialogController.__init__(self, model=model, view=view, spurious=spurious, auto_adapt=auto_adapt, parent=parent)\n        self.apply_callback = apply_callback\n        self.close_callback = close_callback\n\n    def register_adapters(self):\n        super(MatchMineralController, self).register_adapters()\n        if self.model is not None:\n            self.reload_minerals()\n            self.reload_matches()\n\n    def register_view(self, view):\n        super(MatchMineralController, self).register_view(view)\n        if view is not None:\n            # MATCHES Treeview:\n            tv = self.view[\'tv_matches\']\n\n            setup_treeview(tv, None,\n                reset=True,\n                on_selection_changed=self.selection_changed,\n            )\n\n            tv.append_column(new_text_column(\n                ""Name"", markup_col=0,\n                xalign=0,\n            ))\n\n            tv.append_column(new_text_column(\n                ""Abbr."", markup_col=1,\n                expand=False,\n            ))\n\n            def get_value(column, cell, model, itr, *args):\n                value = model.get_value(itr, column.get_col_attr(\'markup\'))\n                try: value = ""%.5f"" % value\n                except TypeError: value = """"\n                cell.set_property(""markup"", value)\n                return\n            tv.append_column(new_text_column(\n                ""Score"",\n                markup_col=4,\n                expand=False,\n                data_func=get_value\n            ))\n\n            # ALL MINERALS Treeview:\n            tv = self.view[\'tv_minerals\']\n            setup_treeview(tv, None,\n                reset=True,\n                on_selection_changed=self.selection_changed,\n            )\n\n            tv.append_column(new_text_column(\n                ""Name"", markup_col=0,\n                xalign=0,\n            ))\n\n            tv.append_column(new_text_column(\n                ""Abbr."", markup_col=1,\n                expand=False,\n            ))\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""matches_changed"", signal=True)\n    def notif_parameter_changed(self, model, prop_name, info):\n        self.reload_matches()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def selection_changed(self, selection, *args):\n        if selection.count_selected_rows() >= 1:\n            model, paths = selection.get_selected_rows()\n            itr = model.get_iter(paths[0])\n            name, _, peaks = model.get(itr, 0, 1, 2)\n            self.model.specimen.mineral_preview = (name, peaks)\n            self.model.specimen.visuals_changed.emit()\n\n    def on_auto_match_clicked(self, event):\n        self.model.auto_match()\n\n    def on_add_match_clicked(self, event):\n        selection = self.view.tv_minerals.get_selection()\n        if selection.count_selected_rows() >= 1:\n            model, paths = selection.get_selected_rows()\n            itr = model.get_iter(paths[0])\n            name, abbreviation, peaks = model.get(itr, 0, 1, 2)\n            self.model.add_match(name, abbreviation, peaks)\n\n    def on_del_match_clicked(self, event):\n        selection = self.view.tv_matches.get_selection()\n        if selection.count_selected_rows() >= 1:\n            _, paths = selection.get_selected_rows()\n            self.model.del_match(*paths[0])\n\n    def on_apply_clicked(self, event):\n        if self.apply_callback is not None and callable(self.apply_callback):\n            self.model.specimen.mineral_preview = None\n            self.apply_callback(self.model.matches)\n        self.view.hide()\n\n    def on_cancel(self):\n        if self.close_callback is not None and callable(self.close_callback):\n            self.model.specimen.mineral_preview = None\n            self.close_callback()\n        self.view.hide()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def reload_matches(self):\n        if not hasattr(self, \'tv_matches_model\'):\n            self.tv_matches_model = Gtk.ListStore(str, str, object, object, float)\n        else:\n            self.tv_matches_model.clear()\n        for name, abbreviation, peaks, matches, score in self.model.matches:\n            self.tv_matches_model.append([name, abbreviation, peaks, matches, score])\n\n        tv = self.view.tv_matches\n        tv.set_model(self.tv_matches_model)\n\n    def reload_minerals(self):\n        if not hasattr(self, \'tv_matches_model\'):\n            self.tv_minerals_model = Gtk.ListStore(str, str, object)\n        else:\n            self.tv_minerals_model.clear()\n        for name, abbreviation, peaks in self.model.minerals:\n            self.tv_minerals_model.append([name, abbreviation, peaks])\n\n        tv = self.view.tv_minerals\n        tv.set_model(self.tv_minerals_model)\n\n    pass # end of class\n\n\nclass ThresholdController(DialogController):\n\n    auto_adapt_included = [\n        ""pattern"",\n        ""sel_threshold"",\n        ""max_threshold"",\n        ""sel_num_peaks"",\n        ""steps""\n    ]\n\n    callback = None\n    dline = None\n\n    def __init__(self, *args, **kwargs):\n        callback = kwargs.pop(""callback"", None)\n        super(ThresholdController, self).__init__(*args, **kwargs)\n        self.callback = callback\n        self.dline = None\n\n    def update_plot(self):\n        if self.view is not None:\n            self.view.plot.cla()\n            if self.dline is not None:\n                self.dline.disconnect()\n                self.dline = None\n\n            def dline_cb(x):\n                self.model.sel_threshold = x\n\n            if self.model is not None and self.model.threshold_plot_data is not None:\n                x, y = self.model.threshold_plot_data\n                self.view.plot.plot(x, y, \'k-\')\n                self.line = self.view.plot.axvline(x=self.model.sel_threshold, color=""#0000FF"", linestyle=""-"")\n                self.dline = DraggableVLine(self.line, callback=dline_cb, window=self.view.matlib_canvas.get_window())\n            self.view.plot.set_ylabel(\'# of peaks\', labelpad=1)\n            self.view.plot.set_xlabel(\'Threshold\', labelpad=1)\n            self.view.figure.subplots_adjust(left=0.15, right=0.875, top=0.875, bottom=0.15)\n            self.view.plot.autoscale_view()\n            self.view.matlib_canvas.draw()\n\n    def register_adapters(self):\n        self.update_plot()\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @Controller.observe(""sel_threshold"", assign=True)\n    @Controller.observe(""threshold_plot_data"", assign=True)\n    def notif_parameter_changed(self, model, prop_name, info):\n        self.update_plot()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_btn_ok_clicked(self, event):\n        if self.callback is not None and callable(self.callback):\n            self.callback(self.model)\n        return DialogController.on_btn_ok_clicked(self, event)\n\n    pass # end of class\n'"
pyxrd/specimen/controllers/specimen_controllers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, locale\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom mvc.adapters.gtk_support.tree_view_adapters import wrap_xydata_to_treemodel\nfrom mvc.adapters import DummyAdapter\n\nfrom pyxrd.generic.controllers import BaseController, DialogController, TreeViewMixin\nfrom pyxrd.generic.views.treeview_tools import setup_treeview, new_text_column\nfrom pyxrd.file_parsers.xrd_parsers import xrd_parsers\nfrom pyxrd.file_parsers.exc_parsers import exc_parsers\n\nfrom pyxrd.goniometer.controllers import InlineGoniometerController\n\nfrom pyxrd.generic.controllers.line_controllers import (\n    LinePropertiesController,\n    BackgroundController,\n    SmoothDataController,\n    AddNoiseController,\n    ShiftDataController,\n    StripPeakController,\n    CalculatePeakPropertiesController\n)\n\nfrom pyxrd.generic.views.line_views import (\n    BackgroundView,\n    SmoothDataView,\n    AddNoiseView,\n    ShiftDataView,\n    StripPeakView,\n    CalculatePeakPropertiesView\n)\n\nclass SpecimenController(DialogController, TreeViewMixin):\n    """"""\n        Specimen controller.\n    """"""\n\n    widget_handlers = {\n        \'custom\':  \'custom_handler\',\n    }\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    @staticmethod\n    def custom_handler(self, prop, widget):\n        if prop.label in (""goniometer""):\n            self.gonio_ctrl = InlineGoniometerController(view=self.view.gonio_view, model=self.model.goniometer, parent=self)\n            ad = DummyAdapter(controller=self, prop=prop) # TODO FIXME\n            return ad\n\n    def setup_experimental_pattern_tree_view(self, store, widget):\n        """"""\n            Creates the experimental data TreeView layout and behavior\n        """"""\n        setup_treeview(widget, store,\n            on_cursor_changed=self.on_exp_data_tv_cursor_changed,\n            sel_mode=\'MULTIPLE\')\n        store.connect(\'columns_changed\', self.on_exp_columns_changed)\n        self.update_exp_treeview(widget)\n        # Other properties:\n        self.exp_line_ctrl = LinePropertiesController(model=self.model.experimental_pattern, view=self.view.exp_line_view, parent=self)\n\n    def setup_calculated_pattern_tree_view(self, store, widget):\n        """"""\n            Creates the calculated data TreeView layout and behavior\n        """"""\n        setup_treeview(widget, store,\n            on_cursor_changed=self.on_exp_data_tv_cursor_changed,\n            sel_mode=\'NONE\')\n        store.connect(\'columns_changed\', self.on_calc_columns_changed)\n        self.update_calc_treeview(widget)\n        # Other properties:\n        self.calc_line_ctrl = LinePropertiesController(model=self.model.calculated_pattern, view=self.view.calc_line_view, parent=self)\n\n    def setup_exclusion_ranges_tree_view(self, store, widget):\n        """"""\n            Creates the exclusion ranges TreeView layout and behavior\n        """"""\n        setup_treeview(widget, store,\n            on_cursor_changed=self.on_exclusion_ranges_tv_cursor_changed,\n            sel_mode=\'MULTIPLE\')\n        \n        def data_func(col, cell, model, iter, colnr):\n            cell.set_property(""text"", ""%g"" % model.get(iter, colnr)[0])\n        \n        widget.append_column(new_text_column(\n            \'From [\xc2\xb02\xce\xb8]\', text_col=store.c_x, editable=True,\n            data_func = (data_func, (store.c_x,)),\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.exclusion_ranges, 0)),\n            resizable=True, expand=True))\n        widget.append_column(new_text_column(\n            \'To [\xc2\xb02\xce\xb8]\', text_col=store.c_y, editable=True,\n            data_func = (data_func, (store.c_y,)),\n            edited_callback=(self.on_xy_data_cell_edited, (self.model.exclusion_ranges, 1)),\n            resizable=True, expand=True))\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_experimental_pattern_tree_model(self):\n        return wrap_xydata_to_treemodel(self.model, type(self.model).experimental_pattern)\n    def get_calculated_pattern_tree_model(self):\n        return wrap_xydata_to_treemodel(self.model, type(self.model).calculated_pattern)\n    def get_exclusion_ranges_tree_model(self):\n        return wrap_xydata_to_treemodel(self.model, type(self.model).exclusion_ranges)\n\n    #used to keep a permanent fix on a child controller, prevents early GC\n    _child_ctrl_ref = None\n\n    def update_calc_treeview(self, tv):\n        """"""\n            Updates the calculated pattern TreeView layout\n        """"""\n        model = self.get_calculated_pattern_tree_model()\n\n        for column in tv.get_columns():\n            tv.remove_column(column)\n\n        def get_num(column, cell, model, itr, col_id):\n            cell.set_property(\'text\', \'%.3f\' % model.get_value(itr, col_id))\n\n        tv.append_column(new_text_column(\'2\xce\xb8\', data_func=(get_num, (model.c_x,))))\n        tv.append_column(new_text_column(\'Cal\', data_func=(get_num, (model.c_y,)) ))\n        for i in range(model.get_n_columns() - 2):\n            tv.append_column(new_text_column(\n                self.model.calculated_pattern.get_y_name(i), data_func=(get_num, (i+2,))))\n\n    def update_exp_treeview(self, tv):\n        """"""\n            Updates the experimental pattern TreeView layout\n        """"""\n        model = self.get_experimental_pattern_tree_model()\n\n        for column in tv.get_columns():\n            tv.remove_column(column)\n\n        def get_num(column, cell, model, itr, col_id):\n            cell.set_property(\'text\', \'%.3f\' % model.get_value(itr, col_id))\n        \n        n_columns = model.get_n_columns()\n        \n        if n_columns > 2:\n            for i in range(n_columns):\n                tv.append_column(new_text_column(\n                    self.model.calculated_pattern.get_y_name(i), editable=True,\n                    edited_callback=(self.on_xy_data_cell_edited, (self.model.experimental_pattern, i)),\n                    data_func=(get_num, (i,))\n                ))\n        else:\n            # X Column:\n            tv.append_column(new_text_column(\n                \'\xc2\xb02\xce\xb8\', editable=True,\n                data_func=(get_num, (model.c_x,)),\n                edited_callback=(self.on_xy_data_cell_edited, (self.model.experimental_pattern, 0))))\n            # Y Column:\n            tv.append_column(new_text_column(\n                \'Intensity\', editable=True,\n                data_func=(get_num, (model.c_y,)),\n                edited_callback=(self.on_xy_data_cell_edited, (self.model.experimental_pattern, 1))))\n\n    def remove_background(self):\n        """"""\n            Opens the \'remove background\' dialog.\n        """"""\n        bg_view = BackgroundView(parent=self.view)\n        self._child_ctrl_ref = BackgroundController(model=self.model.experimental_pattern, view=bg_view, parent=self)\n        bg_view.present()\n\n    def add_noise(self):\n        """"""\n            Opens the \'add noise\' dialog.\n        """"""\n        an_view = AddNoiseView(parent=self.view)\n        self._child_ctrl_ref = AddNoiseController(model=self.model.experimental_pattern, view=an_view, parent=self)\n        an_view.present()\n\n    def smooth_data(self):\n        """"""\n            Opens the \'smooth data\' dialog.\n        """"""\n        sd_view = SmoothDataView(parent=self.view)\n        self._child_ctrl_ref = SmoothDataController(model=self.model.experimental_pattern, view=sd_view, parent=self)\n        sd_view.present()\n\n    def shift_data(self):\n        """"""\n            Opens the \'shift data\' dialog.\n        """"""\n        sh_view = ShiftDataView(parent=self.view)\n        self._child_ctrl_ref = ShiftDataController(model=self.model.experimental_pattern, view=sh_view, parent=self)\n        sh_view.present()\n\n    def strip_peak(self):\n        """"""\n            Opens the \'strip peak\' dialog.\n        """"""\n        st_view = StripPeakView(parent=self.view)\n        self._child_ctrl_ref = StripPeakController(model=self.model.experimental_pattern, view=st_view, parent=self)\n        st_view.present()\n\n    def peak_properties(self):\n        """"""\n            Opens the \'peak properties\' dialog.\n        """"""\n        pa_view = CalculatePeakPropertiesView(parent=self.view)\n        self._child_ctrl_ref = CalculatePeakPropertiesController(model=self.model.experimental_pattern, view=pa_view, parent=self)\n        pa_view.present()\n\n    # ------------------------------------------------------------\n    #      GTK Signal handlers\n    # ------------------------------------------------------------\n    def on_calc_columns_changed(self, *args, **kwargs):\n        self.update_calc_treeview(self.view[""specimen_calculated_pattern""])\n\n    def on_exp_columns_changed(self, *args, **kwargs):\n        self.update_exp_treeview(self.view[""specimen_experimental_pattern""])\n\n    def on_btn_ok_clicked(self, event):\n        self.parent.pop_status_msg(\'edit_specimen\')\n        return super(SpecimenController, self).on_btn_ok_clicked(event)\n\n    def on_exclusion_ranges_tv_cursor_changed(self, tv):\n        path, col = tv.get_cursor()  # @UnusedVariable\n        self.view[""btn_del_exclusion_ranges""].set_sensitive(path is not None)\n        return True\n\n    def on_exp_data_tv_cursor_changed(self, tv):\n        path, col = tv.get_cursor()  # @UnusedVariable\n        self.view[""btn_del_experimental_data""].set_sensitive(path is not None)\n        return True\n\n    def on_add_experimental_data_clicked(self, widget):\n        self.model.experimental_pattern.append(0, 0)\n        return True\n\n    def on_add_exclusion_range_clicked(self, widget):\n        self.model.exclusion_ranges.append(0, 0)\n        return True\n\n    def on_del_experimental_data_clicked(self, widget):\n        paths = self.get_selected_paths(self.view[""specimen_experimental_pattern""])\n        if paths is not None:\n            self.model.experimental_pattern.remove_from_indeces(*paths)\n        return True\n\n    def on_del_exclusion_ranges_clicked(self, widget):\n        paths = self.get_selected_paths(self.view[""specimen_exclusion_ranges""])\n        if paths is not None:\n            self.model.exclusion_ranges.remove_from_indeces(*paths)\n        return True\n\n    def on_xy_data_cell_edited(self, cell, path, new_text, model, col):\n        try:\n            value = float(locale.atof(new_text))\n        except ValueError:\n            logger.exception(""ValueError: Invalid literal for float(): \'%s\'"" % new_text)\n        else:\n            model.set_value(int(path), col, value)\n        return True\n\n    def on_import_exclusion_ranges_clicked(self, widget, data=None):\n        def on_confirm(dialog):\n            def on_accept(dialog):\n                filename = dialog.filename\n                parser = dialog.parser\n                message = ""An unexpected error has occured when trying to parse %s:\\n\\n<i>"" % os.path.basename(filename)\n                message += ""{}</i>\\n\\n""\n                message += ""This is most likely caused by an invalid or unsupported file format.""\n\n                with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                    self.model.exclusion_ranges.load_data(parser, filename, clear=True)\n            DialogFactory.get_load_dialog(\n                title=""Import exclusion ranges"", parent=self.view.get_top_widget(),\n                filters=exc_parsers.get_import_file_filters()\n            ).run(on_accept)\n        DialogFactory.get_confirmation_dialog(\n            ""Importing exclusion ranges will erase all current data.\\nAre you sure you want to continue?"",\n            parent=self.view.get_top_widget()\n        ).run(on_confirm)\n\n    def on_export_exclusion_ranges_clicked(self, widget, data=None):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            message = ""An unexpected error has occurred when trying to save \'%s\'.\\n"" % os.path.basename(filename)\n            message += ""Contact the developer about this!""\n            with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                header = ""%s %s"" % (self.model.name, self.model.sample_name)\n                self.model.exclusion_ranges.save_data(parser, filename, header=header)\n        DialogFactory.get_save_dialog(\n            ""Select file for exclusion ranges export"",\n            parent=self.view.get_top_widget(), filters=exc_parsers.get_export_file_filters()\n        ).run(on_accept)\n\n    def on_replace_experimental_data(self, *args, **kwargs):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            message = ""An unexpected error has occurred when trying to parse \'%s\'.\\n"" % os.path.basename(filename)\n            message += ""This is most likely caused by an invalid or unsupported file format.""\n            with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                self.model.experimental_pattern.load_data(parser, filename, clear=True)\n        DialogFactory.get_load_dialog(\n            ""Open XRD file for import"", parent=self.view.get_top_widget(),\n            filters=xrd_parsers.get_import_file_filters()\n        ).run(on_accept)\n        return True\n\n    def on_btn_import_experimental_data_clicked(self, widget, data=None):\n        def on_confirm(dialog):\n            self.on_replace_experimental_data()\n        DialogFactory.get_confirmation_dialog(\n            ""Importing a new experimental file will erase all current data.\\nAre you sure you want to continue?"",\n            parent=self.view.get_top_widget()\n        ).run(on_confirm)\n        return True\n\n    def on_export_experimental_data(self, *args, **kwargs):\n        return self._export_data(self.model.experimental_pattern)\n\n    def on_btn_export_experimental_data_clicked(self, widget, data=None):\n        return self.on_export_experimental_data()\n\n    def on_btn_export_calculated_data_clicked(self, widget, data=None):\n        return self._export_data(self.model.calculated_pattern)\n\n    def _export_data(self, line):\n        def on_accept(dialog):\n            filename = dialog.filename\n            parser = dialog.parser\n            message = ""An unexpected error has occurred when trying to save to \'%s\'."" % os.path.basename(filename)\n            with DialogFactory.error_dialog_handler(message, parent=self.view.get_toplevel(), reraise=False):\n                line.save_data(parser, filename, **self.model.get_export_meta_data())\n        ext_less_fname = os.path.splitext(self.model.name)[0]\n        DialogFactory.get_save_dialog(\n            ""Select file for export"", parent=self.view.get_top_widget(),\n            filters=xrd_parsers.get_export_file_filters(), current_name=ext_less_fname\n        ).run(on_accept)\n\n    pass # end of class\n\nclass StatisticsController(BaseController):\n\n    def register_adapters(self):\n        if self.model is not None:\n            for name in self.model.get_properties():\n                if name in self.model.__have_no_widget__:\n                    pass\n                else:\n                    self.adapt(name)\n            return\n\n    pass # end of class\n'"
pyxrd/specimen/models/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .base import Specimen\nfrom .markers import ThresholdSelector, Marker, MineralScorer\nfrom .statistics import Statistics\n\n__all__ = [\n    ""Specimen"",\n    ""Thresholdselector"",\n    ""Marker"",\n    ""MineralScorer"",\n    ""Statistics""\n]\n'"
pyxrd/specimen/models/base.py,14,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom math import pi, log\n\nimport numpy as np\n\nfrom mvc.observers import ListObserver\nfrom mvc.models.properties import (\n    StringProperty, SignalMixin, ReadOnlyMixin, FloatProperty, LabeledProperty,\n    ObserveMixin, ListProperty, BoolProperty\n)\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.models import ExperimentalLine, CalculatedLine, DataModel\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.models.lines import PyXRDLine\n\nfrom pyxrd.calculations.peak_detection import peakdetect\nfrom pyxrd.calculations.data_objects import SpecimenData\n\nfrom pyxrd.goniometer.models import Goniometer\n\nfrom pyxrd.file_parsers.xrd_parsers import xrd_parsers\nfrom pyxrd.file_parsers.exc_parsers import exc_parsers\n\nfrom .markers import Marker\nfrom .statistics import Statistics\n\n\n@storables.register()\nclass Specimen(DataModel, Storable):\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Specimen""\n\n        export_filters = xrd_parsers.get_export_file_filters()\n        excl_filters = exc_parsers.get_import_file_filters()\n\n    _data_object = None\n    @property\n    def data_object(self):\n        self._data_object.goniometer = self.goniometer.data_object\n        self._data_object.range_theta = self.__get_range_theta()\n        self._data_object.selected_range = self.get_exclusion_selector()\n        self._data_object.z_list = self.get_z_list()\n        try:\n            self._data_object.observed_intensity = np.copy(self.experimental_pattern.data_y)\n        except IndexError:\n            self._data_object.observed_intensity = np.array([], dtype=float)\n        return self._data_object\n\n    def get_z_list(self):\n        return list(self.experimental_pattern.z_data)\n\n    project = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: The sample name\n    sample_name = StringProperty(\n        default="""", text=""Sample"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The sample name\n    name = StringProperty(\n        default="""", text=""Name"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n\n    @StringProperty(\n        default="""", text=""Label"",\n        visible=False, persistent=False, tabular=True,\n        mix_with=(ReadOnlyMixin,)\n    )\n    def label(self):\n        if self.display_stats_in_lbl and (self.project is not None and self.project.layout_mode == ""FULL""):\n            label = self.sample_name\n            label += ""\\nRp = %.1f%%"" % not_none(self.statistics.Rp, 0.0)\n            label += ""\\nRwp = %.1f%%"" % not_none(self.statistics.Rwp, 0.0)\n            return label\n        else:\n            return self.sample_name\n\n    display_calculated = BoolProperty(\n        default=True, text=""Display calculated diffractogram"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_experimental = BoolProperty(\n        default=True, text=""Display experimental diffractogram"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_vshift = FloatProperty(\n        default=0.0, text=""Vertical shift of the plot"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"", widget_type=""spin"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_vscale = FloatProperty(\n        default=0.0, text=""Vertical scale of the plot"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"", widget_type=""spin"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_phases = BoolProperty(\n        default=True, text=""Display phases seperately"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_stats_in_lbl = BoolProperty(\n        default=True, text=""Display Rp in label"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_residuals = BoolProperty(\n        default=True, text=""Display residual patterns"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_residual_scale = FloatProperty(\n        default=1.0, text=""Residual pattern scale"", minimum=0.0,\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"", widget_type=""spin"",\n        mix_with=(SignalMixin,)\n    )\n\n    display_derivatives = BoolProperty(\n        default=False, text=""Display derivative patterns"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: A :class:`~pyxrd.generic.models.lines.CalculatedLine` instance\n    calculated_pattern = LabeledProperty(\n        default=None, text=""Calculated diffractogram"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""xy_list_view"",\n        mix_with=(SignalMixin, ObserveMixin,)\n    )\n\n    #: A :class:`~pyxrd.generic.models.lines.ExperimentalLine` instance\n    experimental_pattern = LabeledProperty(\n        default=None, text=""Experimental diffractogram"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""xy_list_view"",\n        mix_with=(SignalMixin, ObserveMixin,)\n    )\n\n    #: A list of 2-theta ranges to exclude for the calculation of the Rp factor\n    exclusion_ranges = LabeledProperty(\n        default=None, text=""Excluded ranges"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"", widget_type=""xy_list_view"",\n        mix_with=(SignalMixin, ObserveMixin)\n    )\n\n    #: A :class:`~pyxrd.goniometer.models.Goniometer` instance\n    goniometer = LabeledProperty(\n        default=None, text=""Goniometer"",\n        visible=True, persistent=True, tabular=True,\n        signal_name=""data_changed"",\n        mix_with=(SignalMixin, ObserveMixin,)\n    )\n\n    #: A :class:`~pyxrd.specimen.models.Statistics` instance\n    statistics = LabeledProperty(\n        default=None, text=""Markers"",\n        visible=False, persistent=False, tabular=True,\n    )\n\n    #: A list :class:`~pyxrd.specimen.models.Marker` instances\n    markers = ListProperty(\n        default=None, text=""Markers"", data_type=Marker,\n        visible=False, persistent=True, tabular=True,\n        signal_name=""visuals_changed"", widget_type=""object_list_view"",\n        mix_with=(SignalMixin,)\n    )\n\n    @property\n    def max_display_y(self):\n        """"""\n         The maximum intensity or z-value (display y axis) \n         of the current profile (both calculated and observed)\n        """"""\n        _max = 0.0\n        if self.experimental_pattern is not None:\n            _max = max(_max, np.max(self.experimental_pattern.max_display_y))\n        if self.calculated_pattern is not None:\n            _max = max(_max, np.max(self.calculated_pattern.max_display_y))\n        return _max\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for a Specimen are:\n                name: the name of the specimen\n                sample_name: the sample name of the specimen\n                calculated_pattern: the calculated pattern\n                experimental_pattern: the experimental pattern\n                exclusion_ranges: the exclusion ranges XYListStore\n                goniometer: the goniometer used for recording data\n                markers: the specimen\'s markers\n                display_vshift: the patterns vertical shift from its default position\n                display_vscale: the patterns vertical scale (default is 1.0)\n                display_calculated: whether or not to show the calculated pattern\n                display_experimental: whether or not to show the experimental pattern\n                display_residuals: whether or not to show the residuals\n                display_derivatives: whether or not to show the 1st derivative patterns\n                display_phases: whether or not to show the separate phase patterns\n                display_stats_in_lbl: whether or not to display the Rp values \n                 in the pattern label\n        """"""\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_name"", ""data_sample"", ""data_sample_length"",\n            ""data_calculated_pattern"", ""data_experimental_pattern"",\n            ""calc_color"", ""calc_lw"", ""inherit_calc_color"", ""inherit_calc_lw"",\n            ""exp_color"", ""exp_lw"", ""inherit_exp_color"", ""inherit_exp_lw"",\n            ""project_goniometer"", ""data_markers"", ""bg_shift"", ""abs_scale"",\n            ""exp_cap_value"", ""sample_length"", ""absorption"", ""sample_z_dev"",\n            *[prop.label for prop in Specimen.Meta.get_local_persistent_properties()]\n        )\n        super(Specimen, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self._data_object = SpecimenData()\n\n        with self.visuals_changed.hold_and_emit():\n            with self.data_changed.hold_and_emit():\n                self.name = self.get_kwarg(kwargs, """", ""name"", ""data_name"")\n                sample_name = self.get_kwarg(kwargs, """", ""sample_name"", ""data_sample"")\n                if isinstance(sample_name, bytes):\n                    sample_name = sample_name.decode(""utf-8"", ""ignore"")\n                self.sample_name = sample_name\n                \n                calc_pattern_old_kwargs = {}\n                for kw in (""calc_color"", ""calc_lw"", ""inherit_calc_color"", ""inherit_calc_lw""):\n                    if kw in kwargs:\n                        calc_pattern_old_kwargs[kw.replace(""calc_"", """")] = kwargs.pop(kw)\n                self.calculated_pattern = self.parse_init_arg(\n                    self.get_kwarg(kwargs, None, ""calculated_pattern"", ""data_calculated_pattern""),\n                    CalculatedLine,\n                    child=True, default_is_class=True,\n                    label=""Calculated Profile"",\n                    parent=self,\n                    **calc_pattern_old_kwargs\n                )\n\n                exp_pattern_old_kwargs = {}\n                for kw in (""exp_color"", ""exp_lw"", ""inherit_exp_color"", ""inherit_exp_lw""):\n                    if kw in kwargs:\n                        exp_pattern_old_kwargs[kw.replace(""exp_"", """")] = kwargs.pop(kw)\n                self.experimental_pattern = self.parse_init_arg(\n                    self.get_kwarg(kwargs, None, ""experimental_pattern"", ""data_experimental_pattern""),\n                    ExperimentalLine,\n                    child=True, default_is_class=True,\n                    label=""Experimental Profile"",\n                    parent=self,\n                    **exp_pattern_old_kwargs\n                )\n\n                self.exclusion_ranges = PyXRDLine(data=self.get_kwarg(kwargs, None, ""exclusion_ranges""), parent=self)\n                \n                # Extract old kwargs if they are there:\n                gonio_kwargs = {}\n                sample_length = self.get_kwarg(kwargs, None, ""sample_length"", ""data_sample_length"")\n                if sample_length is not None:\n                    gonio_kwargs[""sample_length""] = float(sample_length)\n                absorption = self.get_kwarg(kwargs, None, ""absorption"")\n                if absorption is not None: # assuming a surface density of at least 20 mg/cm\xc2\xb2:\n                    gonio_kwargs[""absorption""] = float(absorption) / 0.02\n                    \n                # Initialize goniometer (with optional old kwargs):\n                self.goniometer = self.parse_init_arg(\n                    self.get_kwarg(kwargs, None, ""goniometer"", ""project_goniometer""),\n                    Goniometer, child=True, default_is_class=True,\n                    parent=self, **gonio_kwargs\n                )\n\n                self.markers = self.get_list(kwargs, None, ""markers"", ""data_markers"", parent=self)\n                for marker in self.markers:\n                    self.observe_model(marker)\n                self._specimens_observer = ListObserver(\n                    self.on_marker_inserted,\n                    self.on_marker_removed,\n                    prop_name=""markers"",\n                    model=self\n                )\n\n                self.display_vshift = float(self.get_kwarg(kwargs, 0.0, ""display_vshift""))\n                self.display_vscale = float(self.get_kwarg(kwargs, 1.0, ""display_vscale""))\n                self.display_calculated = bool(self.get_kwarg(kwargs, True, ""display_calculated""))\n                self.display_experimental = bool(self.get_kwarg(kwargs, True, ""display_experimental""))\n                self.display_residuals = bool(self.get_kwarg(kwargs, True, ""display_residuals""))\n                self.display_residual_scale = float(self.get_kwarg(kwargs, 1.0, ""display_residual_scale""))\n                self.display_derivatives = bool(self.get_kwarg(kwargs, False, ""display_derivatives""))\n                self.display_phases = bool(self.get_kwarg(kwargs, False, ""display_phases""))\n                self.display_stats_in_lbl = bool(self.get_kwarg(kwargs, True, ""display_stats_in_lbl""))\n\n                self.statistics = Statistics(parent=self)\n\n                pass # end of with\n            pass # end of with\n        pass # end of __init__\n\n    def __str__(self):\n        return ""<Specimen %s(%s)>"" % (self.name, repr(self))\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @DataModel.observe(""data_changed"", signal=True)\n    def notify_data_changed(self, model, prop_name, info):\n        if model == self.calculated_pattern:\n            self.visuals_changed.emit() # don\'t propagate this as data_changed\n        else:\n            self.data_changed.emit() # propagate signal\n\n    @DataModel.observe(""visuals_changed"", signal=True)\n    def notify_visuals_changed(self, model, prop_name, info):\n        self.visuals_changed.emit() # propagate signal\n\n    def on_marker_removed(self, item):\n        with self.visuals_changed.hold_and_emit():\n            self.relieve_model(item)\n            item.parent = None\n\n    def on_marker_inserted(self, item):\n        with self.visuals_changed.hold_and_emit():\n            self.observe_model(item)\n            item.parent = self\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    @staticmethod\n    def from_experimental_data(filename, parent, parser=xrd_parsers._group_parser, load_as_insitu=False):\n        """"""\n            Returns a list of new :class:`~.specimen.models.Specimen`\'s loaded\n            from `filename`, setting their parent to `parent` using the given\n            parser. If the load_as_insitu flag is set to true, \n        """"""\n        specimens = list()\n        xrdfiles = parser.parse(filename)\n        if len(xrdfiles):\n            if getattr(xrdfiles[0], ""relative_humidity_data"", None) is not None: # we have relative humidity data\n                specimen = None\n                \n                # Setup list variables:\n                x_data = None\n                y_datas = []\n                rh_datas = []\n                \n                for xrdfile in xrdfiles:\n                    # Get data we need:\n                    name, sample, xy_data, rh_data = (\n                        xrdfile.filename, xrdfile.name, \n                        xrdfile.data, xrdfile.relative_humidity_data\n                    )\n                    # Transform into numpy array for column selection\n                    xy_data = np.array(xy_data)\n                    rh_data = np.array(rh_data)\n                    if specimen is None:\n                        specimen = Specimen(parent=parent, name=name, sample_name=sample)\n                        specimen.goniometer.reset_from_file(xrdfile.create_gon_file())\n                        # Extract the 2-theta positions once:\n                        x_data = np.copy(xy_data[:,0])\n                    \n                    # Add a new sub-pattern:\n                    y_datas.append(np.copy(xy_data[:,1]))\n                    \n                    # Store the average RH for this pattern:\n                    rh_datas.append(np.average(rh_data))\n                    \n                specimen.experimental_pattern.load_data_from_generator(zip(x_data, np.asanyarray(y_datas).transpose()), clear=True)\n                specimen.experimental_pattern.y_names = [""%.1f"" % f for f in rh_datas]\n                specimen.experimental_pattern.z_data = rh_datas\n                specimens.append(specimen)    \n            else: # regular (might be multi-pattern) file\n                for xrdfile in xrdfiles:\n                    name, sample, generator = xrdfile.filename, xrdfile.name, xrdfile.data\n                    specimen = Specimen(parent=parent, name=name, sample_name=sample)\n                    # TODO FIXME:\n                    specimen.experimental_pattern.load_data_from_generator(generator, clear=True)\n                    specimen.goniometer.reset_from_file(xrdfile.create_gon_file())\n                    specimens.append(specimen)\n        return specimens\n\n    def json_properties(self):\n        props = Storable.json_properties(self)\n        props[""exclusion_ranges""] = self.exclusion_ranges._serialize_data()\n        return props\n\n    def get_export_meta_data(self):\n        """""" Returns a dictionary with common meta-data used in export functions\n            for experimental or calculated data """"""\n        return dict(\n            sample=self.label + "" "" + self.sample_name,\n            wavelength=self.goniometer.wavelength,\n            radius=self.goniometer.radius,\n            divergence=self.goniometer.divergence,\n            soller1=self.goniometer.soller1,\n            soller2=self.goniometer.soller2,\n        )\n\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def clear_markers(self):\n        with self.visuals_changed.hold():\n            for marker in list(self.markers)[::-1]:\n                self.markers.remove(marker)\n\n    def auto_add_peaks(self, tmodel):\n        """"""\n        Automagically add peak markers\n        \n        *tmodel* a :class:`~specimen.models.ThresholdSelector` model\n        """"""\n        threshold = tmodel.sel_threshold\n        base = 1 if (tmodel.pattern == ""exp"") else 2\n        data_x, data_y = tmodel.get_xy()\n        maxtab, mintab = peakdetect(data_y, data_x, 5, threshold) # @UnusedVariable\n\n        mpositions = [marker.position for marker in self.markers]\n\n        with self.visuals_changed.hold():\n            i = 1\n            for x, y in maxtab: # @UnusedVariable\n                if not x in mpositions:\n                    nm = self.goniometer.get_nm_from_2t(x) if x != 0 else 0\n                    new_marker = Marker(label=""%%.%df"" % (3 + min(int(log(nm, 10)), 0)) % nm, parent=self, position=x, base=base)\n                    self.markers.append(new_marker)\n                i += 1\n\n    def get_exclusion_selector(self):\n        """"""\n        Get the numpy selector array for non-excluded data\n        \n        :rtype: a numpy ndarray\n        """"""\n        x = self.__get_range_theta() * 360.0 / pi # convert to degrees\n        selector = np.ones(x.shape, dtype=bool)\n        data = np.sort(np.asarray(self.exclusion_ranges.get_xy_data()), axis=0)\n        for x0, x1 in zip(*data):\n            new_selector = ((x < x0) | (x > x1))\n            selector = selector & new_selector\n        return selector\n\n    def get_exclusion_xy(self):\n        """"""\n        Get an numpy array containing only non-excluded data X and Y data\n                \n        :rtype: a tuple containing 4 numpy ndarray\'s: the experimental X and Y\n        data and the calculated X and Y data\n        """"""\n        ex, ey = self.experimental_pattern.get_xy_data()\n        cx, cy = self.calculated_pattern.get_xy_data()\n        selector = self.get_exclusion_selector(ex)\n        return ex[selector], ey[selector], cx[selector], cy[selector]\n\n    # ------------------------------------------------------------\n    #      Draggable mix-in hook:\n    # ------------------------------------------------------------\n    def on_pattern_dragged(self, delta_y, button=1):\n        if button == 1:\n            self.display_vshift += delta_y\n        elif button == 3:\n            self.display_vscale += delta_y\n        elif button == 2:\n            self.project.display_plot_offset += delta_y\n        pass\n\n    def update_visuals(self, phases):\n        """"""\n            Update visual representation of phase patterns (if any)\n        """"""\n        if phases is not None:\n            self.calculated_pattern.y_names = [\n               phase.name if phase is not None else """" for phase in phases\n            ]\n            self.calculated_pattern.phase_colors = [\n                phase.display_color if phase is not None else ""#FF00FF"" for phase in phases\n            ]\n\n    # ------------------------------------------------------------\n    #      Intensity calculations:\n    # ------------------------------------------------------------\n    def update_pattern(self, total_intensity, phase_intensities, phases):\n        """"""\n        Update calculated patterns using the provided total and phase intensities\n        """"""\n        if len(phases) == 0:\n            self.calculated_pattern.clear()\n        else:\n            maxZ = len(self.get_z_list())\n            new_data = np.zeros((phase_intensities.shape[-1], maxZ + maxZ*len(phases))) \n            for z_index in range(maxZ):   \n                # Set the total intensity for this z_index:\n                new_data[:, z_index] = total_intensity[z_index]\n                # Calculate phase intensity offsets:\n                phase_start_index = maxZ + z_index * len(phases)\n                phase_end_index = phase_start_index + len(phases)\n                # Set phase intensities for this z_index:                \n                new_data[:,phase_start_index:phase_end_index] = phase_intensities[:,z_index,:].transpose()\n                # Store in pattern:\n                self.calculated_pattern.set_data(\n                    self.__get_range_theta() * 360. / pi,\n                    new_data\n                )\n            self.update_visuals(phases)\n        if settings.GUI_MODE:\n            self.statistics.update_statistics(derived=self.display_derivatives)\n\n    def convert_to_fixed(self):\n        """"""\n        Converts the experimental data from ADS to fixed slits in-place \n        (disregards the `has_ads` flag in the goniometer, but uses the settings\n        otherwise) \n        """"""\n        correction = self.goniometer.get_ADS_to_fixed_correction(self.__get_range_theta())\n        self.experimental_pattern.apply_correction(correction)\n\n    def convert_to_ads(self):\n        """"""\n        Converts the experimental data from fixed slits to ADS in-place \n        (disregards the `has_ads` flag in the goniometer, but uses the settings\n        otherwise) \n        """"""\n        correction = 1.0 / self.goniometer.get_ADS_to_fixed_correction(self.__get_range_theta())\n        self.experimental_pattern.apply_correction(correction)\n\n    def __get_range_theta(self):\n        if len(self.experimental_pattern) <= 1:\n            return self.goniometer.get_default_theta_range()\n        else:\n            return np.radians(self.experimental_pattern.data_x * 0.5)\n\n    def __repr__(self):\n        return ""Specimen(name=\'%s\')"" % self.name\n\n    pass # end of class\n'"
pyxrd/specimen/models/markers.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nfrom mvc.models.properties import (\n    LabeledProperty, StringProperty, StringChoiceProperty, ColorProperty,\n    FloatProperty, IntegerProperty, IntegerChoiceProperty, BoolProperty,\n    ListProperty, SignalProperty,\n    SignalMixin, ReadOnlyMixin, SetActionMixin\n)\n\nfrom pyxrd.data import settings\nfrom pyxrd.calculations.peak_detection import score_minerals\nfrom pyxrd.generic.io import storables, Storable\nfrom pyxrd.generic.models import ChildModel, DataModel\nfrom pyxrd.generic.models.properties import InheritableMixin\nfrom pyxrd.generic.models.mixins import CSVMixin\nfrom pyxrd.generic.io.utils import unicode_open\n\nclass MineralScorer(DataModel):\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    matches_changed = SignalProperty()\n\n    matches = ListProperty(\n        default=None, text=""Matches"", visible=True, persistent=False,\n        mix_with=(ReadOnlyMixin,)\n    )\n\n    @ListProperty(\n        default=None, text=""Minerals"", visible=True, persistent=False,\n        mix_with=(ReadOnlyMixin,)\n    )\n    def minerals(self):\n        # Load them when accessed for the first time:\n        _minerals = type(self).minerals._get(self)\n        if _minerals == None:\n            _minerals = list()\n            with unicode_open(settings.DATA_REG.get_file_path(""MINERALS"")) as f:\n                mineral = """"\n                abbreviation = """"\n                position_flag = True\n                peaks = []\n                for line in f:\n                    line = line.replace(\'\\n\', \'\')\n                    try:\n                        number = float(line)\n                        if position_flag:\n                            position = number\n                        else:\n                            intensity = number\n                            peaks.append((position, intensity))\n                        position_flag = not position_flag\n                    except ValueError:\n                        if mineral != """":\n                            _minerals.append((mineral, abbreviation, peaks))\n                        position_flag = True\n                        if len(line) > 25:\n                            mineral = line[:24].strip()\n                        if len(line) > 49:\n                            abbreviation = line[49:].strip()\n                        peaks = []\n            sorted(_minerals, key=lambda mineral:mineral[0])\n        type(self).minerals._set(self, _minerals)\n        return _minerals\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, marker_peaks=[], *args, **kwargs):\n        super(MineralScorer, self).__init__(*args, **kwargs)\n        self._matches = []\n\n        self.marker_peaks = marker_peaks # position, intensity\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def auto_match(self):\n        self._matches = score_minerals(self.marker_peaks, self.minerals)\n        self.matches_changed.emit()\n\n    def del_match(self, index):\n        if self.matches:\n            del self.matches[index]\n            self.matches_changed.emit()\n\n    def add_match(self, name, abbreviation, peaks):\n        matches = score_minerals(self.marker_peaks, [(name, abbreviation, peaks)])\n        if len(matches):\n            name, abbreviation, peaks, matches, score = matches[0]\n        else:\n            matches, score = [], 0.\n        self.matches.append([name, abbreviation, peaks, matches, score])\n        sorted(self._matches, key=lambda match: match[-1], reverse=True)\n        self.matches_changed.emit()\n\n    pass # end of class\n\nclass ThresholdSelector(ChildModel):\n\n    # MODEL INTEL:\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    pattern = StringChoiceProperty(\n        default=""exp"", text=""Pattern"",\n        visible=True, persistent=False,\n        choices={ ""exp"": ""Experimental Pattern"", ""calc"": ""Calculated Pattern"" },\n        set_action_name=""update_threshold_plot_data"",\n        mix_with=(SetActionMixin,)\n    )\n\n    max_threshold = FloatProperty(\n        default=0.32, text=""Maximum threshold"",\n        visible=True, persistent=False,\n        minimum=0.0, maximum=1.0, widget_type=""float_entry"",\n        set_action_name=""update_threshold_plot_data"",\n        mix_with=(SetActionMixin,)\n    )\n\n    steps = IntegerProperty(\n        default=20, text=""Steps"",\n        visible=True, persistent=False,\n        minimum=3, maximum=50,\n        set_action_name=""update_threshold_plot_data"",\n        mix_with=(SetActionMixin,)\n    )\n\n    sel_num_peaks = IntegerProperty(\n        default=0, text=""Selected number of peaks"",\n        visible=True, persistent=False,\n        widget_type=""label""\n    )\n\n    def set_sel_threshold(self, value):\n        _sel_threshold = type(self).sel_threshold._get(self)\n        if value != _sel_threshold and len(self.threshold_plot_data[0]) > 0:\n            _sel_threshold = value\n            if _sel_threshold >= self.threshold_plot_data[0][-1]:\n                self.sel_num_peaks = self.threshold_plot_data[1][-1]\n            elif _sel_threshold <= self.threshold_plot_data[0][0]:\n                self.sel_num_peaks = self.threshold_plot_data[1][0]\n            else:\n                self.sel_num_peaks = int(interp1d(*self.threshold_plot_data)(_sel_threshold))\n            type(self).sel_threshold._set(self, _sel_threshold)\n    sel_threshold = FloatProperty(\n        default=0.1, text=""Selected threshold"",\n        visible=True, persistent=False,\n        widget_type=""float_entry"",\n        fset = set_sel_threshold\n    )\n\n    threshold_plot_data = LabeledProperty(\n        default=None, text=""Threshold plot data"",\n        visible=False, persistent=False\n    )\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        super(ThresholdSelector, self).__init__(*args, **kwargs)\n\n        self.max_threshold = self.get_kwarg(kwargs, self.max_threshold, ""max_threshold"")\n        self.steps = self.get_kwarg(kwargs, self.steps, ""steps"")\n        self.sel_threshold = self.get_kwarg(kwargs, self.sel_threshold, ""sel_threshold"")\n\n        if self.parent.experimental_pattern.size > 0:\n            self.pattern = ""exp""\n        else:\n            self.pattern = ""calc""\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_xy(self):\n        if self.pattern == ""exp"":\n            data_x, data_y = self.parent.experimental_pattern.get_xy_data()\n        elif self.pattern == ""calc"":\n            data_x, data_y = self.parent.calculated_pattern.get_xy_data()\n        if data_y.size > 0:\n            data_y = data_y / np.max(data_y)\n        return data_x, data_y\n\n    _updating_plot_data = False\n    def update_threshold_plot_data(self, status_dict=None):\n        if self.parent is not None and not self._updating_plot_data:\n            self._updating_plot_data = True\n            if self.pattern == ""exp"":\n                p, t, m = self.parent.experimental_pattern.get_best_threshold(\n                            self.max_threshold, self.steps, status_dict)\n            elif self.pattern == ""calc"":\n                p, t, m = self.parent.calculated_pattern.get_best_threshold(\n                            self.max_threshold, self.steps, status_dict)\n            self.threshold_plot_data = p\n            self.sel_threshold = t\n            self.max_threshold = m\n            self._updating_plot_data = False\n    pass # end of class\n\n@storables.register()\nclass Marker(DataModel, Storable, CSVMixin):\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""Marker""\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: This marker\'s label\n    label = StringProperty(\n        default=""New Marker"", text=""Label"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether the color of this marker is inherited\n    inherit_color = BoolProperty(\n        default=settings.MARKER_INHERIT_COLOR, text=""Inherit color"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This maker\'s color:\n    color = ColorProperty(\n        default=settings.MARKER_COLOR, text=""Color"",\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_color"",\n        inherit_from=""specimen.project.display_marker_color"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Flag indicating whether the angle of this marker is inherited\n    inherit_angle = BoolProperty(\n        default=settings.MARKER_INHERIT_ANGLE, text=""Inherit angle"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This maker\'s angle:\n    angle = FloatProperty(\n        default=settings.MARKER_ANGLE, text=""Angle"", widget_type=""spin"",\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_angle"",\n        inherit_from=""specimen.project.display_marker_angle"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Flag indicating whether the top offset of this marker is inherited\n    inherit_top_offset = BoolProperty(\n        default=settings.MARKER_INHERIT_TOP_OFFSET, text=""Inherit top offset"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This maker\'s top offset:\n    top_offset = FloatProperty(\n        default=settings.MARKER_TOP_OFFSET, text=""Top offset"", widget_type=""spin"",\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_top_offset"",\n        inherit_from=""specimen.project.display_marker_top_offset"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Whether this marker is visible\n    visible = BoolProperty(\n        default=settings.MARKER_VISIBLE, text=""Visible"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The marker\'s position\n    position = FloatProperty(\n        default=settings.MARKER_POSITION, text=""Position"", widget_type=""spin"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The marker\'s x offset\n    x_offset = FloatProperty(\n        default=settings.MARKER_X_OFFSET, text=""X offset"", widget_type=""spin"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The marker\'s y offset\n    y_offset = FloatProperty(\n        default=settings.MARKER_Y_OFFSET, text=""Y offset"", widget_type=""spin"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Flag indicating whether the alignment of this marker is inherited\n    inherit_align = BoolProperty(\n        default=settings.MARKER_INHERIT_ALIGN, text=""Inherit align"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This marker\'s alignment\n    align = StringChoiceProperty(\n        default=settings.MARKER_ALIGN, text=""Align"",\n        choices=settings.MARKER_ALIGNS,\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_align"",\n        inherit_from=""specimen.project.display_marker_align"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Flag indicating whether the base of this marker is inherited\n    inherit_base = BoolProperty(\n        default=settings.MARKER_INHERIT_BASE, text=""Inherit base"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This marker\'s base\n    base = IntegerChoiceProperty(\n        default=settings.MARKER_BASE, text=""Base"",\n        choices=settings.MARKER_BASES,\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_base"",\n        inherit_from=""specimen.project.display_marker_base"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Flag indicating whether the top of this marker is inherited\n    inherit_top = BoolProperty(\n        default=settings.MARKER_INHERIT_TOP, text=""Inherit top"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This marker\'s top\n    top = IntegerChoiceProperty(\n        default=settings.MARKER_TOP, text=""Top"",\n        choices=settings.MARKER_TOPS,\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_top"",\n        inherit_from=""specimen.project.display_marker_top"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    #: Flag indicating whether the line style of this marker is inherited\n    inherit_style = BoolProperty(\n        default=settings.MARKER_INHERIT_STYLE, text=""Inherit line style"",\n        persistent=True, visible=True, tabular=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n    #: This marker\'s line style\n    style = StringChoiceProperty(\n        default=settings.MARKER_STYLE, text=""Line style"",\n        choices=settings.MARKER_STYLES,\n        persistent=True, visible=True, tabular=True, inheritable=True,\n        signal_name=""visuals_changed"", inherit_flag=""inherit_style"",\n        inherit_from=""specimen.project.display_marker_style"",\n        mix_with=(InheritableMixin, SignalMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n\n        my_kwargs = self.pop_kwargs(kwargs,\n            ""data_label"", ""data_visible"", ""data_position"", ""data_x_offset"", ""data_y_offset""\n            ""data_color"", ""data_base"", ""data_angle"", ""data_align"",\n            *[prop.label for prop in type(self).Meta.get_local_persistent_properties()]\n        )\n        super(Marker, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        self.label = self.get_kwarg(kwargs, """", ""label"", ""data_label"")\n        self.visible = self.get_kwarg(kwargs, True, ""visible"", ""data_visible"")\n        self.position = float(self.get_kwarg(kwargs, 0.0, ""position"", ""data_position""))\n        self.x_offset = float(self.get_kwarg(kwargs, 0.0, ""x_offset"", ""data_x_offset""))\n        self.y_offset = float(self.get_kwarg(kwargs, 0.05, ""y_offset"", ""data_y_offset""))\n        self.top_offset = float(self.get_kwarg(kwargs, 0.0, ""top_offset""))\n        self.color = self.get_kwarg(kwargs, settings.MARKER_COLOR, ""color"", ""data_color"")\n        self.base = int(self.get_kwarg(kwargs, settings.MARKER_BASE, ""base"", ""data_base""))\n        self.angle = float(self.get_kwarg(kwargs, 0.0, ""angle"", ""data_angle""))\n        self.align = self.get_kwarg(kwargs, settings.MARKER_ALIGN, ""align"")\n        self.style = self.get_kwarg(kwargs, settings.MARKER_STYLE, ""style"", ""data_align"")\n\n        # if top is not set and style is not ""none"",\n        # assume top to be ""Top of plot"", otherwise (style is not ""none"")\n        # assume top to be relative to the base point (using top_offset)\n        self.top = int(self.get_kwarg(kwargs, 0 if self.style == ""none"" else 1, ""top""))\n\n        self.inherit_align = self.get_kwarg(kwargs, True, ""inherit_align"")\n        self.inherit_color = self.get_kwarg(kwargs, True, ""inherit_color"")\n        self.inherit_base = self.get_kwarg(kwargs, True, ""inherit_base"")\n        self.inherit_top = self.get_kwarg(kwargs, True, ""inherit_top"")\n        self.inherit_top_offset = self.get_kwarg(kwargs, True, ""inherit_top_offset"")\n        self.inherit_angle = self.get_kwarg(kwargs, True, ""inherit_angle"")\n        self.inherit_style = self.get_kwarg(kwargs, True, ""inherit_style"")\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_nm_position(self):\n        if self.parent is not None:\n            return self.parent.goniometer.get_nm_from_2t(self.position)\n        else:\n            return 0.0\n\n    def set_nm_position(self, position):\n        if self.parent is not None:\n            self.position = self.parent.goniometer.get_2t_from_nm(position)\n        else:\n            self.position = 0.0\n\n    pass # end of class\n'"
pyxrd/specimen/models/statistics.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nfrom mvc.models.properties import (\n    IntegerProperty, ReadOnlyMixin, FloatProperty, LabeledProperty\n)\n\nfrom pyxrd.generic.models import PyXRDLine, ChildModel\nfrom pyxrd.calculations.statistics import Rpw, Rp, derive\n\nclass Statistics(ChildModel):\n    # PROPERTIES:\n    specimen = property(ChildModel.parent.fget, ChildModel.parent.fset)\n\n    @IntegerProperty(default=0, label=""Points"", visible=False, mix_with=(ReadOnlyMixin,))\n    def points(self):\n        try:\n            e_ex, e_ey, e_cx, e_cy = self.specimen.get_exclusion_xy() #@UnusedVariable\n            return e_ex.size\n        except: pass\n        return 0\n\n    Rp = FloatProperty(default=None, label=""Rp"", visible=True)\n    Rwp = FloatProperty(default=None, label=""Rwp"", visible=True)\n    Rpder = FloatProperty(default=None, label=""Rpder"", visible=True)\n\n    residual_pattern = LabeledProperty(default=None, label=""Residual pattern"")\n    der_exp_pattern = LabeledProperty(default=None, label=""Derived experimental pattern"")\n    der_calc_pattern = LabeledProperty(default=None, label=""Derived calculated pattern"")\n    der_residual_pattern = LabeledProperty(default=None, label=""Derived residual pattern"")\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        super(Statistics, self).__init__(*args, **kwargs)\n        self.observe_model(self.parent)\n\n    # ------------------------------------------------------------\n    #      Notifications of observable properties\n    # ------------------------------------------------------------\n    @ChildModel.observe(""parent"", assign=True, after=True)\n    def on_parent_changed(self, model, prop_name, info):\n        self.update_statistics()\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def _get_experimental(self):\n        if self.specimen is not None:\n            x, y = self.specimen.experimental_pattern.get_xy_data()\n            return x.copy(), y.copy()\n        else:\n            return None, None\n    def _get_calculated(self):\n        if self.specimen is not None:\n            x, y = self.specimen.calculated_pattern.get_xy_data()\n            return x.copy(), y.copy()\n        else:\n            return None, None\n\n    def scale_factor_y(self, offset):\n        return self.specimen.scale_factor_y(offset) if self.specimen else (1.0, offset)\n\n    def update_statistics(self, derived=False):\n        # Clear factors:\n        self.Rp = 0\n        self.Rwp = 0\n        self.Rpder = 0\n\n        # Setup lines if not yet done:\n        if self.residual_pattern == None:\n            self.residual_pattern = PyXRDLine(label=""Residual"", color=""#000000"", lw=0.5, parent=self)\n\n        if self.der_exp_pattern == None:\n            self.der_exp_pattern = PyXRDLine(label=""Exp. 1st der."", color=""#000000"", lw=2, parent=self)\n\n        if self.der_calc_pattern == None:\n            self.der_calc_pattern = PyXRDLine(label=""Calc. 1st der."", color=""#AA0000"", lw=2, parent=self)\n\n        if self.der_residual_pattern == None:\n            self.der_residual_pattern = PyXRDLine(label=""1st der. residual"", color=""#AA00AA"", lw=1, parent=self)\n\n        # Get data:\n        exp_x, exp_y = self._get_experimental()\n        cal_x, cal_y = self._get_calculated()\n        der_exp_y, der_cal_y = None, None\n        del cal_x # don\'t need this, is the same as exp_x\n\n        # Try to get statistics, if it fails, just clear and inform the user\n        try:\n            if cal_y is not None and exp_y is not None and cal_y.size > 0 and exp_y.size > 0:\n                # Get the selector for areas to consider in the statistics:\n                selector = self.specimen.get_exclusion_selector()\n\n                if derived:\n                    # Calculate and set first derivate patterns:\n                    der_exp_y, der_cal_y = derive(exp_y), derive(cal_y)\n                    self.der_exp_pattern.set_data(exp_x, der_exp_y)\n                    self.der_calc_pattern.set_data(exp_x, der_cal_y)\n\n                # Calculate and set residual pattern:\n                self.residual_pattern.set_data(exp_x, exp_y - cal_y)\n                if derived:\n                    self.der_residual_pattern.set_data(exp_x, der_exp_y - der_cal_y)\n\n                # Calculate \'included\' R values:\n                self.Rp = Rp(exp_y[selector], cal_y[selector])\n                self.Rwp = Rpw(exp_y[selector], cal_y[selector])\n                if derived:\n                    self.Rpder = Rp(der_exp_y[selector], der_cal_y[selector])\n            else:\n                self.residual_pattern.clear()\n                self.der_exp_pattern.clear()\n                self.der_calc_pattern.clear()\n        except:\n            self.residual_pattern.clear()\n            self.der_exp_pattern.clear()\n            self.der_calc_pattern.clear()\n            logger.error(""Error occurred when trying to calculate statistics, aborting calculation!"")\n            raise\n\n    pass # end of class\n'"
pyxrd/specimen/views/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .specimens import SpecimenView\nfrom .markers import (\n    DetectPeaksView,\n    EditMarkersView,\n    EditMarkerView,\n    MatchMineralsView\n)\n\n__all__ = [\n    ""SpecimenView"",\n    ""DetectPeaksView"",\n    ""EditMarkersView"",\n    ""EditMarkerView"",\n    ""MatchMineralsView""\n]'"
pyxrd/specimen/views/markers.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_gtk3cairo import FigureCanvasGTK3Cairo as FigureCanvasGTK\n\nfrom pyxrd.generic.views import ObjectListStoreView, DialogView, BaseView\n\nclass EditMarkerView(BaseView):\n    builder = resource_filename(__name__, ""../glade/edit_marker.glade"")\n    top = ""edit_marker""\n\n    widget_format = ""marker_%s""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n        self.parent.set_title(""Edit Markers"")\n\nclass EditMarkersView(ObjectListStoreView):\n    extra_widget_builder = resource_filename(__name__, ""../glade/find_peaks.glade"")\n    extra_widget_toplevel = ""vbox_find_peaks""\n    resizable = False\n\n    def __init__(self, *args, **kwargs):\n        ObjectListStoreView.__init__(self, *args, **kwargs)\n\n        self[self.subview_toplevel].child_set_property(self[""frame_object_param""], ""resize"", False)\n\n    def set_selection_state(self, value):\n        super(EditMarkersView, self).set_selection_state(value)\n        self[""cmd_match_minerals""].set_sensitive(value is not None)\n\n    pass # end of class\n\nclass MatchMineralsView(DialogView):\n    title = ""Match minerals""\n    subview_builder = resource_filename(__name__, ""../glade/match_minerals.glade"")\n    subview_toplevel = ""tbl_match_minerals""\n    modal = True\n\n    def __init__(self, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n        self.tv_minerals = self[""tv_minerals""]\n        self.tv_matches = self[""tv_matches""]\n\n    pass # end of class\n\nclass DetectPeaksView(DialogView):\n    title = ""Auto detect peaks""\n    subview_builder = resource_filename(__name__, ""../glade/find_peaks_dialog.glade"")\n    subview_toplevel = ""tbl_find_peaks""\n    modal = True\n    resizable = False\n\n    widget_groups = {\n        \'full_mode_only\': [\n            ""pattern"",\n            ""lbl_pattern"",\n            ""hseparator1""\n        ]\n    }\n\n    def __init__(self, *args, **kwargs):\n        DialogView.__init__(self, *args, **kwargs)\n\n        self.graph_parent = self[""view_graph""]\n        self.setup_matplotlib_widget()\n\n    def setup_matplotlib_widget(self):\n        #style = Gtk.Style()\n        self.figure = Figure(dpi=72) #, edgecolor=str(style.bg[2]), facecolor=str(style.bg[2]))\n\n        self.plot = self.figure.add_subplot(111)\n        self.plot.set_ylabel(\'# of peaks\', labelpad=1)\n        self.plot.set_xlabel(\'Threshold\', labelpad=1)\n        self.plot.autoscale_view()\n\n        self.figure.subplots_adjust(left=0.15, right=0.875, top=0.875, bottom=0.15)\n        self.matlib_canvas = FigureCanvasGTK(self.figure)\n\n        self.graph_parent.add(self.matlib_canvas)\n        self.graph_parent.show_all()\n\n    pass # end of class'"
pyxrd/specimen/views/specimens.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom pkg_resources import resource_filename # @UnresolvedImport\n\nfrom pyxrd.generic.views import DialogView, BaseView, HasChildView\n\nfrom pyxrd.goniometer.views import InlineGoniometerView\nfrom pyxrd.generic.views.line_views import CalculatedLinePropertiesView, ExperimentalLinePropertiesView\n\nclass SpecimenView(DialogView, HasChildView):\n    title = ""Edit Specimen""\n    subview_builder = resource_filename(__name__, ""../glade/specimen.glade"")\n    subview_toplevel = ""edit_specimen""\n    resizable = False\n\n    widget_format = ""specimen_%s""\n\n    widget_groups = {\n        \'full_mode_only\': [\n            ""specimen_display_calculated"",\n            ""specimen_display_stats_in_lbl"",\n            ""specimen_display_phases"",\n            ""vbox_calculated_data_tv"",\n            ""lbl_specimen_calculated"",\n            ""vbox_exclusion_ranges_tv"",\n            ""lbl_tabexclusions"",\n            ""general_separator"",\n            ""specimen_display_residuals"",\n            ""specimen_display_derivatives""\n        ]\n    }\n\n    gonio_container = widget_format % ""goniometer""\n    gonio_view = None\n\n    calc_line_container = widget_format % ""calc_line""\n    calc_line_view = None\n\n    exp_line_container = widget_format % ""exp_line""\n    exp_line_view = None\n\n\n    def __init__(self, *args, **kwargs):\n        super(SpecimenView, self).__init__(*args, **kwargs)\n        self._init_child_views()\n        self._add_child_views()\n\n    _children_ready = False\n    def _init_child_views(self):\n        if not self._children_ready:\n            self.gonio_view = InlineGoniometerView(parent=self)\n            self.calc_line_view = CalculatedLinePropertiesView(parent=self)\n            self.exp_line_view = ExperimentalLinePropertiesView(parent=self)\n            self._children_ready = True\n\n    def _add_child_views(self):\n        self._init_child_views()\n\n        # Add in-line gonio view:\n        top = self.gonio_view.get_top_widget()\n        self._add_child_view(top, self[self.gonio_container])\n\n        # Add in-line calculated line properties view:\n        top = self.calc_line_view.get_top_widget()\n        self._add_child_view(top, self[self.calc_line_container])\n\n        # Add in-line experimental line properties view:\n        top = self.exp_line_view.get_top_widget()\n        self._add_child_view(top, self[self.exp_line_container])\n\n    def set_layout_mode(self, state):\n        super(SpecimenView, self).set_layout_mode(state)\n        if self._children_ready:\n            self.gonio_view.set_layout_mode(state)\n            self.calc_line_view.set_layout_mode(state)\n            self.exp_line_view.set_layout_mode(state)\n\n\n    pass # end of class\n\nclass StatisticsView(BaseView):\n    builder = resource_filename(__name__, ""../specimen/glade/statistics.glade"")\n    top = ""statistics_box""\n\n    def __init__(self, *args, **kwargs):\n        BaseView.__init__(self, *args, **kwargs)\n\n    pass # end of class\n'"
test/test_generic/test_io/__init__.py,0,b''
test/test_generic/test_io/test_custom_io.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os\nimport unittest\nfrom io import StringIO\n\nfrom pyxrd.generic.io import storables, Storable\n\nfrom pyxrd.file_parsers.json_parser import JSONParser\n\n__all__ = [\n    \'TestParserMixin\',\n]\n\n\ndef load_data_from_files(*files):\n    basepath = os.path.realpath(os.getcwd())\n    for fname in files:\n        with open(basepath + ""/"" + fname, \'rb\') as f:\n            yield f.read()\n\nclass TestStorable(unittest.TestCase):\n\n    @storables.register()\n    class DummyStorable(Storable):\n\n        __storables__ = [\n            ""name"",\n            ""data"",\n            ""my_daddy""\n        ]\n\n        class Meta(Storable.Meta):\n            store_id = ""DummyStorable""\n\n        def __init__(self, name, data, my_daddy):\n            super(TestStorable.DummyStorable, self).__init__()\n            self.name = name\n            self.data = data\n            self.my_daddy = my_daddy\n\n    def setUp(self):\n        self.daddy = self.DummyStorable(\'Daddy Dummy\', list(range(50)), None)\n        self.child = self.DummyStorable(\'Child Dummy\', list(range(5)), self.daddy)\n\n    def tearDown(self):\n        del self.daddy\n        del self.child\n\n    def test_setup(self):\n        self.assertNotEqual(self.daddy, None)\n        self.assertNotEqual(self.child, None)\n\n    def test_encoding(self):\n        self.daddy_dump = self.daddy.dump_object()\n        self.child_dump = self.child.dump_object()\n        self.assertIn("""".join(self.daddy_dump.split()), """".join(self.child_dump.split()))\n\n\n    def test_decoding(self):\n\n        child_encoded = """"""\n{\n    ""type"": ""DummyStorable"", \n    ""properties"": {\n        ""name"": ""Child Dummy"", \n        ""data"": [\n            0, \n            1, \n            2, \n            3, \n            4\n        ], \n        ""my_daddy"": {\n            ""type"": ""DummyStorable"", \n            ""properties"": {\n                ""name"": ""Daddy Dummy"", \n                ""data"": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], \n                ""my_daddy"": null\n            }\n        }\n    }\n}""""""\n        f = StringIO(child_encoded)\n        decoded_child = JSONParser.parse(f)\n\n        self.assertNotEqual(decoded_child, None)\n        self.assertNotEqual(decoded_child.my_daddy, None)\n\n    pass # end of class\n'"
test/test_generic/test_io/test_data_registry.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport shutil\nimport os\nimport tempfile\n\nimport unittest\n\nfrom pyxrd.generic.exceptions import AlreadyRegistered, NotRegistered\nfrom pyxrd.generic.io.data_registry import DataRegistry\n\n__all__ = [\n    \'TestDataRegistry\',\n]\n\n\nclass TestDataRegistry(unittest.TestCase):\n\n    def setUp(self):\n\n        self.base_temp_dir = tempfile.mkdtemp()\n\n        self.dirs = [\n            (""TEST1"", os.path.join(self.base_temp_dir, ""test1/""), None),\n            (""TEST2"", ""test2/"", ""TEST1""),\n        ]\n        self.files = [\n            (""ROOTFILE"", ""root.txt"", None),\n            (""TEST1_FILE"", ""test1file.txt"", ""TEST1""),\n            (""TEST2_FILE"", ""test2file.txt"", ""TEST2""),\n        ]\n        self.data_reg = DataRegistry(dirs=self.dirs, files=self.files)\n        pass\n\n    def tearDown(self):\n        shutil.rmtree(self.base_temp_dir)\n        del self.data_reg\n        pass\n\n    def test_exceptions(self):\n        with self.assertRaises(NotRegistered):\n            self.data_reg.get_directory_path(""TEST3"")\n\n        with self.assertRaises(AlreadyRegistered):\n            self.data_reg.register_data_directory(""TEST1"", ""false_test1/"", None)\n\n    def test_iter(self):\n        for path in self.data_reg.get_all_files():\n            self.assertNotIn(path, [None, """"])\n\n    pass # end of class\n'"
test/test_generic/test_io/test_file_parsers.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport os, unittest\n\nfrom pyxrd.file_parsers.base_parser import BaseParser\n\n__all__ = [\n    \'TestParserMixin\',\n]\n\n\ndef load_data_from_files(*files):\n    basepath = os.path.realpath(os.getcwd())\n    for fname in files:\n        with open(basepath + ""/"" + fname, \'rb\') as fp:\n            yield fp\n\nclass BaseTestParsers(object):\n\n    class BaseTestParser(unittest.TestCase):\n\n        parser_class = BaseParser\n        file_data = [\n            """",\n        ]\n\n        def test_description(self):\n            self.assertNotEqual(self.parser_class.description, """")\n\n        def test_filters(self):\n            self.assertIsNotNone(self.parser_class.file_filter)\n\n        def test_parsing(self):\n            for fp in self.file_data:\n                data_objects = self.parser_class.parse(fp)\n                self.assertGreater(len(data_objects), 0)\n\n        # TODO:\n        # - check arguments such as close.\n'"
test/test_generic/test_models/__init__.py,0,b''
test/test_generic/test_models/test_childmodel.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom mvc import Observer\nfrom pyxrd.generic.models import ChildModel\n\n__all__ = [\n    \'TestChildModel\',\n]\n\nclass TestChildModel(unittest.TestCase):\n\n    def setUp(self):\n        self.childmodel = ChildModel()\n\n        class ChildObserver(Observer):\n\n            added_recieved = False\n            @Observer.observe(""added"", signal=True)\n            def notify_added(self, model, prop_name, info):\n                self.added_recieved = True\n\n            removed_recieved = False\n            @Observer.observe(""removed"", signal=True)\n            def notify_removed(self, model, prop_name, info):\n                self.removed_recieved = True\n\n        self.observer = ChildObserver(model=self.childmodel)\n\n    def tearDown(self):\n        self.observer.relieve_model(self.childmodel)\n        del self.observer\n        del self.childmodel\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.childmodel)\n\n    def test_signals(self):\n        # Reset flags:\n        self.observer.removed_recieved = False\n        self.observer.added_recieved = False\n\n        # No parent set, only the added signal is fired,\n        self.childmodel.parent = object()\n\n        self.assertFalse(self.observer.removed_recieved)\n        self.assertTrue(self.observer.added_recieved)\n\n        # Reset flags:\n        self.observer.removed_recieved = False\n        self.observer.added_recieved = False\n\n        # Setting a parent when there is one set; both signals should be fired:\n        parent = object()\n        self.childmodel.parent = parent\n\n        self.assertTrue(self.observer.removed_recieved)\n        self.assertTrue(self.observer.added_recieved)\n\n        # Reset flags:\n        self.observer.removed_recieved = False\n        self.observer.added_recieved = False\n\n        # Setting an identical parent does not fire anything:\n        self.childmodel.parent = parent\n\n        self.assertFalse(self.observer.removed_recieved)\n        self.assertFalse(self.observer.added_recieved)\n\n        # Reset flags:\n        self.observer.removed_recieved = False\n        self.observer.added_recieved = False\n\n        # Setting the parent to None when it was set; should only fire the removed signal:\n        self.childmodel.parent = None\n\n        self.assertTrue(self.observer.removed_recieved)\n        self.assertFalse(self.observer.added_recieved)\n\n    pass # end of class\n'"
test/test_generic/test_models/test_lines.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.utils import create_object_attribute_test\n\nfrom mvc import Observer\nfrom pyxrd.generic.models import (\n    PyXRDLine,\n    CalculatedLine,\n    ExperimentalLine,\n)\n\n__all__ = [\n    \'TestPyXRDLine\',\n    \'TestCalculatedLine\',\n    \'TestExperimentalLine\',\n]\n\nclass LineObserver(Observer):\n    needs_update_recieved = False\n    @Observer.observe(""data_changed"", signal=True)\n    @Observer.observe(""visuals_changed"", signal=True)\n    def on_update_needed(self, model, prop_name, info):\n        self.needs_update_recieved = True\n\nclass BaseTestLines():\n\n    class BaseTestLine(unittest.TestCase):\n\n        def setUp(self):\n            self.line = self.line_type()\n            self.observer = LineObserver(model=self.line)\n\n        def tearDown(self):\n            self.observer.relieve_model(self.line)\n            del self.observer\n            del self.line\n\n        def test_not_none(self):\n            self.assertIsNotNone(self.line)\n\n        test_lw = create_object_attribute_test(\'line\', \'lw\', 5)\n        test_color = create_object_attribute_test(\'line\', \'color\', \'#FF0000\')\n        test_label = create_object_attribute_test(\'line\', \'label\', \'#FF0000\')\n\n        def _set_some_data(self):\n            x = [1, 2, 3, 4, 5, 6, 7 , 8 , 9 , 10, 11, 12 , 13, 14, 15, 16, 17, 18, 19, 20]\n            y = [0, 0, 0, 0, 0, 0, 10, 20, 30, 40, 80, 160, 80, 40, 30, 20, 10, 0 , 0 , 0 ]\n            y = list(zip(y, y))\n            self.line.set_data(x, y)\n\n        def test_updates(self):\n            self.observer.needs_update_recieved = False\n            self._set_some_data()\n            self.assertTrue(self.observer.needs_update_recieved)\n\n        def test_data(self):\n            self._set_some_data()\n            self.assertEqual(self.line.num_columns, 3)\n            self.assertEqual(self.line.max_display_y, 160)\n            self.assertEqual(self.line.size, 20)\n            self.assertEqual(self.line.get_y_at_x(7), 10)\n            self.assertEqual(self.line.get_y_at_x(10.5), 60)\n\n        def test_names(self):\n            self.observer.needs_update_recieved = False\n            self._set_some_data()\n            names = [""TestName""]\n            self.line.y_names = names\n            self.assertEqual(self.line.get_y_name(0), names[0])\n\n        def test_append_valid(self):\n            self.line.append(0, 0)\n            self.assertEqual(self.line[0], (0.0, [0.0]))\n\n        def test_append_valid_multi(self):\n            self.line.append(0, [0, 1, 2])\n            self.assertEqual(self.line[0], (0.0, [0.0, 1.0, 2.0]))\n\n        def test_signal(self):\n            self.observer.needs_update_recieved = False\n            self.line.lw = 10\n            self.assertTrue(self.observer.needs_update_recieved)\n\n        def test_serialisation(self):\n            x = [1, 2, 3, 4, 5, 6, 7 , 8 , 9 , 10, 11, 12 , 13, 14, 15, 16, 17, 18, 19, 20]\n            y = [0, 0, 0, 0, 0, 0, 10, 20, 30, 40, 80, 160, 80, 40, 30, 20, 10, 0 , 0 , 0 ]\n            self.line.set_data(x, y)\n            serialised1 = self.line._serialize_data()\n            self.line._set_from_serial_data(serialised1)\n            serialised2 = self.line._serialize_data()\n            self.assertEqual(serialised1, serialised2)\n\n        pass # end of class\n        \n    pass # end of class\n\nclass TestPyXRDLine(BaseTestLines.BaseTestLine):\n\n    line_type = PyXRDLine\n\n    pass # end of class\n\nclass TestCalculatedLine(BaseTestLines.BaseTestLine):\n\n    line_type = CalculatedLine\n\n    pass # end of class\n\nclass TestExperimentalLine(BaseTestLines.BaseTestLine):\n\n    line_type = ExperimentalLine\n\n    # TODO:\n    # test bg substr\n    # test smooth\n    # test strip\n    # test capping -> max intensity\n\n    pass # end of class\n'"
test/test_generic/test_models/test_pyxrdmodel.py,0,"b""#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom pyxrd.generic.models import PyXRDModel\n\n__all__ = [\n    'TestPyXRDModel',\n]\n\nclass TestPyXRDModel(unittest.TestCase):\n\n    def setUp(self):\n        self.pyxrdmodel = PyXRDModel()\n\n    def tearDown(self):\n        del self.pyxrdmodel\n\n    def test_not_none(self):\n        self.assertIsNotNone(self.pyxrdmodel)\n\n    # TODO everything else\n\n    pass # end of class\n"""
tests_mvc/adapters/gtk_support/__init__.py,0,b''
mvc/adapters/gtk_support/dialogs/__init__.py,0,b''
mvc/adapters/gtk_support/dialogs/dialog_factory.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport sys, html\nfrom contextlib import contextmanager\n\nimport gi\nfrom mvc.adapters.gtk_support.widgets.threaded_task_box import ThreadedTaskBox\nfrom mvc.support.gui_loop import run_when_idle, add_timeout_call,\\\n    remove_timeout_call\nfrom mvc.support.cancellable_thread import CancellableThread\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, GObject  # @UnresolvedImport\n\nfrom .message_dialog import MessageDialog\nfrom .file_chooser_dialog import FileChooserDialog\n\nclass DialogFactory(object):\n\n    # ------------------------------------------------------------\n    #      File dialog creators\n    # ------------------------------------------------------------\n\n    @staticmethod\n    def get_file_dialog_from_context(context, parent=None, **kwargs):\n        return FileChooserDialog(context, parent=parent, **kwargs)\n\n    @staticmethod\n    def get_file_dialog(\n            action, title, parent=None,\n            current_name=None, current_folder=None,\n            extra_widget=None, filters=[],\n            multiple=False, confirm_overwrite=True, persist=False):\n        """""" Generic file dialog creator """"""\n        return FileChooserDialog(\n            title=title, action=action, parent=parent,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,\n                     Gtk.STOCK_OK, Gtk.ResponseType.ACCEPT),\n            current_name=current_name, current_folder=current_folder,\n            extra_widget=extra_widget, filters=filters,\n            multiple=multiple, confirm_overwrite=confirm_overwrite, persist=persist\n        )\n\n    @staticmethod\n    def get_save_dialog(\n            title, parent=None,\n            current_name=None, current_folder=None,\n            extra_widget=None, filters=[],\n            confirm_overwrite=True, persist=False):\n        """""" Save file dialog creator """"""\n        # Forces save action\n        # Does not allow selecting multiple files\n        return DialogFactory.get_file_dialog(\n            action=Gtk.FileChooserAction.SAVE, title=title, parent=parent,\n            current_name=current_name, current_folder=current_folder,\n            extra_widget=extra_widget, filters=filters,\n            multiple=False, confirm_overwrite=confirm_overwrite, persist=persist)\n\n    @staticmethod\n    def get_load_dialog(\n            title, parent=None,\n            current_name=None, current_folder=None,\n            extra_widget=None, filters=[],\n            multiple=True, persist=False):\n        """""" Load file dialog creator """"""\n        # Forces open action\n        # Disables overwrite confirmation (doesn\'t matter really)\n        return DialogFactory.get_file_dialog(\n            action=Gtk.FileChooserAction.OPEN, title=title, parent=parent,\n            current_name=current_name, current_folder=current_folder,\n            extra_widget=extra_widget, filters=filters,\n            multiple=multiple, confirm_overwrite=False, persist=persist)\n\n    # ------------------------------------------------------------\n    #      Message dialog creators\n    # ------------------------------------------------------------\n    @staticmethod\n    def get_message_dialog(message, type, buttons=Gtk.ButtonsType.YES_NO, persist=False, parent=None, title=None):  # @ReservedAssignment\n        """""" Generic message dialog creator """"""\n        return MessageDialog(\n            message=message,\n            parent=parent,\n            type=type,\n            flags=Gtk.DialogFlags.DESTROY_WITH_PARENT,\n            buttons=buttons,\n            persist=persist,\n            title=title)\n\n    @staticmethod\n    def get_confirmation_dialog(message, persist=False, parent=None, title=None):\n        """""" Confirmation dialog creator """"""\n        return DialogFactory.get_message_dialog(\n            message,\n            parent=parent,\n            type=Gtk.MessageType.WARNING,\n            persist=persist,\n            title=title\n        )\n\n    @staticmethod\n    def get_information_dialog(message, persist=False, parent=None, title=None):\n        """""" Information dialog creator """"""\n        return DialogFactory.get_message_dialog(\n            message,\n            parent=parent,\n            type=Gtk.MessageType.INFO,\n            buttons=Gtk.ButtonsType.OK,\n            persist=persist,\n            title=title\n        )\n\n    @staticmethod\n    def get_error_dialog(message, persist=False, parent=None, title=None):\n        """""" Error dialog creator """"""\n        return DialogFactory.get_message_dialog(\n            message,\n            parent=parent,\n            type=Gtk.MessageType.ERROR,\n            buttons=Gtk.ButtonsType.OK,\n            persist=persist,\n            title=title\n        )\n\n    # ------------------------------------------------------------\n    #      Custom dialog creator\n    # ------------------------------------------------------------\n    @staticmethod\n    def get_custom_dialog(content, parent=None):\n        window = Gtk.Window()\n        window.set_border_width(10)\n        window.set_modal(True)\n        window.set_transient_for(parent)\n        window.connect(\'delete-event\', lambda widget, event: True)\n        window.add(content)\n        return window\n\n    pass #end of class\n\n\n    @staticmethod\n    @contextmanager  \n    def error_dialog_handler(message, parent=None, title=None, reraise=True, print_tb=True):\n        """""" Context manager that can be used to wrap error-prone code. If an error\n        is risen, a dialog will inform the user, optionally the error can be re-raised """"""\n        try:\n            yield\n        except:\n            msg = message.format(html.escape(""%s"" % sys.exc_info()[1]))\n            DialogFactory.get_error_dialog(\n               msg, title=title, parent=parent\n            ).run()\n            if reraise: raise # This should be handled by the default UI bug dialog\n            elif print_tb:\n                from traceback import print_exc\n                print_exc()\n                \n    @staticmethod\n    def get_progress_dialog(action, complete_callback=None, gui_message=""Processing ..."", toplevel=None):\n        """"""\n            Returns a callable that will show a progress dialog\n            for the given action - which will be run in a different \n            thread from the GUI.\n            The action is expected to take a single argument: `status_dict`\n            which is used to format the gui_message (new-style formatting).\n            toplevel is the top level window.\n            complete_callback is called when the action has completed with\n            its return value.\n            When interrupted or cancelled by the user, the dialog just hides.  \n        """"""\n        def run_action_and_show_progress():\n\n            taskgui = ThreadedTaskBox()\n            window = DialogFactory.get_custom_dialog(\n                 taskgui, parent=toplevel)\n\n            # Status:\n            status_dict = dict()\n\n            # Task:\n            def load_peak_thresholds(stop=None):\n                action(status_dict)\n\n            # Cancel & stop events:\n            def on_interrupted(*args, **kwargs):\n                window.hide()\n\n            # Status label update:\n            def gui_callback():\n                taskgui.set_status(gui_message.format(**status_dict))\n                return True\n            add_timeout_call(250, gui_callback)\n\n            # Complete event:\n            @run_when_idle\n            def on_complete(*args, **kwargs):\n                remove_timeout_call(gui_callback)\n                taskgui.stop()\n                window.destroy()\n                if callable(complete_callback):\n                    complete_callback(*args, **kwargs)\n                \n            # Run thread:\n            thread = CancellableThread(load_peak_thresholds, on_complete)\n            thread.start()\n            \n            # Run task box:\n            taskgui.connect(""cancelrequested"", on_interrupted)\n            taskgui.connect(""stoprequested"", on_interrupted)\n            taskgui.set_status(""Loading ..."")\n            taskgui.start()\n            window.show_all()\n\n        return run_action_and_show_progress\n'"
mvc/adapters/gtk_support/dialogs/file_chooser_dialog.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom .utils import adjust_filename_to_globs, retrieve_lowercase_extension, run_dialog\nimport os\n\nclass FileChooserDialog(Gtk.FileChooserDialog):\n\n    accept_responses = (\n        Gtk.ResponseType.ACCEPT, # @UndefinedVariable\n        Gtk.ResponseType.YES, # @UndefinedVariable\n        Gtk.ResponseType.APPLY, # @UndefinedVariable\n        Gtk.ResponseType.OK # @UndefinedVariable\n    )\n\n    persist = False\n\n    @property\n    def parser(self):\n        try:\n            return getattr(self.get_filter(), ""parser"")\n        except AttributeError:\n            return None\n\n    @property\n    def filename(self):\n        """""" Extracts the selected filename from a Gtk.Dialog """"""\n        filename = super(FileChooserDialog, self).get_filename()\n        if filename is not None:\n            filename = adjust_filename_to_globs(filename, self.selected_globs)\n            self.set_filename(filename)\n        return filename\n\n    @property\n    def selected_globs(self):\n        """""" Returns the extension glob corresponding to the selected filter """"""\n        fltr = self.get_filter() # THIS RETURNS NONE??\n        if fltr is None:\n            return None\n        else:\n            selected_name = fltr.get_name()\n            for fltr in self.filters:\n                try:\n                    name, globs = fltr\n                except TypeError: # filter is not a tuple, perhaps it is a FileFilter from a parser\n                    parser = getattr(fltr, ""parser"")\n                    name, globs = parser.description, parser.extensions\n                if selected_name == name:\n                    if len(globs) and globs[0] != ""*.*"":\n                        return [retrieve_lowercase_extension(glob) for glob in globs]\n                    else:\n                        return None\n\n    def __init__(self, title, action, parent=None, buttons=None,\n            current_name=None, current_folder=os.path.expanduser(\'~\'),\n            extra_widget=None, filters=[],\n            multiple=False, confirm_overwrite=True, persist=False):\n        super(FileChooserDialog, self).__init__(\n            title=title, action=action, parent=parent, buttons=buttons\n        )\n        self.update(\n            multiple=multiple, confirm_overwrite=confirm_overwrite,\n            extra_widget=extra_widget, filters=filters,\n            current_name=current_name, current_folder=current_folder,\n            persist=persist\n        )\n\n    def update(self, **kwargs):\n        """""" Updates the dialog with the given set of keyword arguments, \n            and then returns itself """"""\n        if ""title"" in kwargs and kwargs[""title""] is not None:\n            self.set_title(kwargs.pop(""title""))\n\n        if ""action"" in kwargs and kwargs[""action""] is not None:\n            self.set_action(kwargs.pop(""action""))\n\n        if ""parent"" in kwargs and kwargs[""parent""] is not None:\n            self.set_parent(kwargs.pop(""parent""))\n\n        if ""buttons"" in kwargs:\n            self.get_action_area().foreach(lambda w: w.destroy())\n            self.add_buttons(*kwargs.pop(""buttons""))\n\n        # Multiple files are allowed or not:\n        if ""multiple"" in kwargs:\n            self.set_select_multiple(kwargs.pop(""multiple""))\n\n        # Ask before overwriting yes/no\n        if ""confirm_overwrite"" in kwargs:\n            self.set_do_overwrite_confirmation(kwargs.pop(""confirm_overwrite""))\n\n        # Extra widget packed at the bottom:\n        if ""extra_widget"" in kwargs and kwargs[""extra_widget""] is not None:\n            self.set_extra_widget(kwargs.pop(""extra_widget""))\n\n        # Set suggested file name\n        if ""current_name"" in kwargs and kwargs[""current_name""] is not None:\n            self.set_current_name(kwargs.pop(""current_name""))\n\n        # Set suggested folder\n        if ""current_folder"" in kwargs and kwargs[""current_folder""] is not None:\n            self.set_current_folder(kwargs.pop(""current_folder""))\n\n        # Add file filters\n        if ""filters"" in kwargs:\n            # Clear old filters:\n            for fltr in self.list_filters():\n                self.remove_filter(fltr) \n            # Set new filters:\n            self.filters = list(kwargs.pop(""filters""))\n            for fltr in self._get_object_file_filters(self.filters):\n                self.add_filter(fltr)\n\n        self.persist = kwargs.pop(""persist"", self.persist)\n\n        return self\n\n    def _get_object_file_filters(self, filters=[]):\n        """""" Parses a list of textual file filter globs or Gtk.FileFilter objects\n         into Gtk.FileFilter objects """"""\n        for obj in filters:\n            if isinstance(obj, Gtk.FileFilter):\n                yield obj\n            else:\n                # if not a Gtk.FileFilter we assume it is a glob tuple\n                name, re = obj\n                ffilter = Gtk.FileFilter()\n                ffilter.set_name(name)\n                if isinstance(re, str):\n                    ffilter.add_pattern(re)\n                else: # if not a single glob, assume an iterable is given\n                    for expr in re:\n                        ffilter.add_pattern(expr)\n                yield ffilter\n\n    #override\n    def run(self, *args, **kwargs):\n        kwargs[\'destroy\'] = not self.persist\n        return run_dialog(self, *args, **kwargs)\n\n    pass #end of class\n'"
mvc/adapters/gtk_support/dialogs/message_dialog.py,0,"b""# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version('Gtk', '3.0')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom .utils import run_dialog\n\nclass MessageDialog(Gtk.MessageDialog):\n\n    accept_responses = (\n        Gtk.ResponseType.ACCEPT, # @UndefinedVariable\n        Gtk.ResponseType.YES, # @UndefinedVariable\n        Gtk.ResponseType.APPLY, # @UndefinedVariable\n        Gtk.ResponseType.OK # @UndefinedVariable\n    )\n\n    def __init__(self,\n             message, parent=None,\n             type=Gtk.MessageType.INFO,  # @ReservedAssignment\n             flags=Gtk.DialogFlags.DESTROY_WITH_PARENT,\n             buttons=Gtk.ButtonsType.NONE,\n             persist=False,\n             title=None):\n        super(MessageDialog, self).__init__(\n            parent=parent,\n            type=type,\n            flags=flags,\n            buttons=buttons)\n        self.persist = persist\n        self.set_markup(message)\n        if title is not None:\n            self.set_title(title)\n\n    #override\n    def run(self, *args, **kwargs):\n        kwargs['destroy'] = not self.persist\n        return run_dialog(self, *args, **kwargs)\n\n    pass #end of class\n"""
mvc/adapters/gtk_support/dialogs/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\ndef _toggle_cb(dialog, event, cb):\n    cb_id_name = ""%s_cb_id"" % event.replace(""-"", ""_"")\n    cb_id = getattr(dialog, cb_id_name, None)\n    if cb_id is not None: dialog.disconnect(cb_id)\n    cb_id = dialog.connect(event, cb)\n    setattr(dialog, cb_id_name, cb_id)\n\ndef run_dialog(dialog,\n        on_accept_callback=None, on_reject_callback=None, destroy=True):\n    """""" Helper method - do not call directly """"""\n\n    if not (on_accept_callback is None or callable(on_accept_callback)):\n        raise ValueError(""Accept callback must be None or callable"")\n    if not (on_reject_callback is None or callable(on_reject_callback)):\n        raise ValueError(""Reject callback must be None or callable"")      \n   \n    def _dialog_response_cb(dialog, response): \n        if response in dialog.accept_responses and on_accept_callback is not None:\n            on_accept_callback(dialog)\n        elif on_reject_callback is not None:\n            on_reject_callback(dialog)\n        if destroy:\n            dialog.destroy()\n        else:\n            dialog.hide()\n        return not destroy\n    _toggle_cb(dialog, ""response"", _dialog_response_cb)\n    \n    # Adding the delete event prevents the dialog from being destroyed if the\n    # user indicated it should persist\n    def delete_event_cb(dialog, event):\n        if on_reject_callback is not None:\n            on_reject_callback(dialog)\n        if destroy:\n            dialog.destroy()\n        else:\n            dialog.hide()\n        return not destroy\n    _toggle_cb(dialog, ""delete_event"", delete_event_cb)\n    \n    # Present the dialog\n    dialog.set_modal(True)\n    dialog.show_all()\n\ndef retrieve_lowercase_extension(glob):\n    \'\'\'Ex: \'*.[oO][rR][aA]\' => \'*.ora\' \'\'\'\n    return \'\'.join([ c.replace(""["", """").replace(""]"", """")[:-1] for c in glob.split(\'][\')])\n\ndef adjust_filename_to_globs(filename, globs):\n    """""" Adjusts a given filename so it ends with the proper extension """"""\n    if globs: # If given use file extensions globs\n        possible_fns = []\n        # Loop over globs, if the current filenames extensions matches\n        # a given glob, the filename is returned as is, otherwise\n        # the extension of the first glob is added at the end of filename\n        for glob in globs:\n            if glob is not None:\n                extension = glob[1:]\n                if filename[len(filename) - len(extension):].lower() != extension.lower():\n                    possible_fns.append(""%s%s"" % (filename, glob[1:]))\n                else:\n                    return filename # matching extension is returned immediately\n        return possible_fns[0] # otherwise add extension of the first filter\n    else: # If no globs are given, return filename as is\n        return filename\n\n'"
mvc/adapters/gtk_support/treemodels/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom .object_list_store import ObjectListStore\nfrom .base_models import BaseObjectListStore\nfrom .object_tree_store import ObjectTreeStore\nfrom .xy_list_store import XYListStore\n\n__all__ = [\n    ""BaseObjectListStore"",\n    ""ObjectListStore"",\n    ""ObjectTreeStore"",\n    ""XYListStore""\n]\n'"
mvc/adapters/gtk_support/treemodels/base_models.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport weakref\nimport types\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk  # @UnresolvedImport\n\nfrom .generic_tree_model import GenericTreeModel\n\nclass BaseObjectListStore(GenericTreeModel):\n    """"""\n        Base mixin for creating GenericTreeModel implementations for lists of\n        objects. It maps the columns of the store with properties of the object.\n        If the PyGTK modules are not available (e.g. on a headless HPC cluster),\n        a dummy gtk module is loaded. Not all (GTK) functionality is enabled in that case.\n    """"""\n\n    # PROPERTIES\n    _columns = None # list of tuples (name, type)\n    _class_type = None\n\n    __weakref_model = None\n    @property\n    def _model(self):\n        if self.__weakref_model is not None:\n            return self.__weakref_model()\n        else:\n            return None\n    @_model.setter\n    def _model(self, value):\n        if value is not None:\n            self.__weakref_model = weakref.ref(value)\n        else:\n            self.__weakref_model = None\n\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, class_type):\n        GenericTreeModel.__init__(self)\n        self.set_property(""leak-references"", False)\n        if class_type is None:\n            raise ValueError(\n                 \'Invalid class_type for %s! Expecting object, but None was given\' \n                 % type(self)\n             )\n        elif not hasattr(class_type, ""Meta""):\n            raise ValueError(\n                 \'Invalid class_type for `%s`! `%s` does not have a `Meta` attribute!\' \n                 % (type(self), class_type)\n             )\n        elif not hasattr(class_type.Meta, \'get_column_properties\'):\n            raise ValueError(\n                 \'Invalid class_type for %s! %s.Meta does not have get_column_properties method!\' \n                 % (type(self), class_type)\n             )\n        else:\n            self.setup_class_type(class_type)\n\n    def setup_class_type(self, class_type):\n        self._class_type = class_type\n        self._columns = []\n        for item in self._class_type.Meta.get_column_properties():\n            title, col_type = item\n            if isinstance(col_type, str):\n                col_type = \'gchararray\'\n            # TODO map other types we might encounter...\n            self._columns.append((title, col_type))\n\n        i = 0\n        for col in self._columns:\n            setattr(self, ""c_%s"" % col[0], i)\n            i += 1\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def on_get_flags(self):\n        return Gtk.TreeModelFlags.LIST_ONLY | Gtk.TreeModelFlags.ITERS_PERSIST\n\n    def on_get_n_columns(self):\n        return len(self._columns)\n\n    def on_get_column_type(self, index):\n        return self._columns[index][1]\n\n    def get_user_data_from_path(self, path):\n        return self.on_get_iter(path)\n\n    def convert(self, col, new_val):\n        if isinstance(self._columns[col][1], str):\n            return str(new_val)\n        else:\n            return self._columns[col][1](new_val)\n\n    def get_objects(self):\n        raise NotImplementedError()\n\n    def iter_objects(self):\n        raise NotImplementedError()\n\n    def __reduce__(self):\n        raise NotImplementedError()\n\n    pass # end of class\n'"
mvc/adapters/gtk_support/treemodels/generic_tree_model.py,0,"b'# -*- Mode: Python; py-indent-offset: 4 -*-\n# generictreemodel - GenericTreeModel implementation for pygtk compatibility.\n# Copyright (C) 2013 Simon Feltman\n#\n#   generictreemodel.py: GenericTreeModel implementation for pygtk compatibility\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\n# System\nimport sys\nimport random\nimport collections\nimport ctypes\nimport platform\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GObject  # @UnresolvedImport\nfrom gi.repository import Gtk  # @UnresolvedImport\n\n\nclass _CTreeIter(ctypes.Structure):\n    _fields_ = [(\'stamp\', ctypes.c_int),\n                (\'user_data\', ctypes.c_void_p),\n                (\'user_data2\', ctypes.c_void_p),\n                (\'user_data3\', ctypes.c_void_p)]\n\n    @classmethod\n    def from_iter(cls, iter):\n        offset = sys.getsizeof(object())  # size of PyObject_HEAD\n        return ctypes.POINTER(cls).from_address(id(iter) + offset)\n\n\nif platform.python_implementation() == ""PyPy"":\n    def _get_user_data_as_pyobject(iter):\n        raise NotImplementedError(""Not yet supported under PyPy"")\nelse:\n    def _get_user_data_as_pyobject(iter):\n        citer = _CTreeIter.from_iter(iter)\n        try:\n            return ctypes.cast(citer.contents.user_data, ctypes.py_object).value\n        except ValueError as err:\n            logger.warning(""Could not cast ctypes PyObject to native python object: %s"" % err)\n            return None\n\n\ndef handle_exception(default_return):\n    """"""Returns a function which can act as a decorator for wrapping exceptions and\n    returning ""default_return"" upon an exception being thrown.\n\n    This is used to wrap Gtk.TreeModel ""do_"" method implementations so we can return\n    a proper value from the override upon an exception occurring with client code\n    implemented by the ""on_"" methods.\n    """"""\n    def decorator(func):\n        def wrapped_func(*args, **kargs):\n            try:\n                return func(*args, **kargs)\n            except:\n                # Use excepthook directly to avoid any printing to the screen\n                # if someone installed an except hook.\n                sys.excepthook(*sys.exc_info())\n            return default_return\n        return wrapped_func\n    return decorator\n\n\nclass GenericTreeModel(GObject.GObject, Gtk.TreeModel):\n    """"""A base implementation of a Gtk.TreeModel for python.\n\n    The GenericTreeModel eases implementing the Gtk.TreeModel interface in Python.\n    The class can be subclassed to provide a TreeModel implementation which works\n    directly with Python objects instead of iterators.\n\n    All of the on_* methods should be overridden by subclasses to provide the\n    underlying implementation a way to access custom model data. For the purposes of\n    this API, all custom model data supplied or handed back through the overridable\n    API will use the argument names: node, parent, and child in regards to user data\n    python objects.\n\n    The create_tree_iter, set_user_data, invalidate_iters, iter_is_valid methods are\n    available to help manage Gtk.TreeIter objects and their Python object references.\n\n    GenericTreeModel manages a pool of user data nodes that have been used with iters.\n    This pool stores a references to user data nodes as a dictionary value with the\n    key being the integer id of the data. This id is what the Gtk.TreeIter objects\n    use to reference data in the pool.\n    References will be removed from the pool when the model is deleted or explicitly\n    by using the optional ""node"" argument to the ""row_deleted"" method when notifying\n    the model of row deletion.\n    """"""\n\n    leak_references = GObject.Property(default=True, type=bool,\n                                       blurb=""If True, strong references to user data attached to iters are ""\n                                       ""stored in a dictionary pool (default). Otherwise the user data is ""\n                                       ""stored as a raw pointer to a python object without a reference."")\n\n    #\n    # Methods\n    #\n    def __init__(self):\n        """"""Initialize. Make sure to call this from derived classes if overridden.""""""\n        super(GenericTreeModel, self).__init__()\n        self.stamp = 0\n\n        #: Dictionary of (id(user_data): user_data), used when leak-refernces=False\n        self._held_refs = dict()\n\n        # Set initial stamp\n        self.invalidate_iters()\n\n    def iter_depth_first(self):\n        """"""Depth-first iteration of the entire TreeModel yielding the python nodes.""""""\n        stack = collections.deque([None])\n        while stack:\n            it = stack.popleft()\n            if it is not None:\n                yield self.get_user_data(it)\n            children = [self.iter_nth_child(it, i) for i in range(self.iter_n_children(it))]\n            stack.extendleft(reversed(children))\n\n    def invalidate_iter(self, iter):\n        """"""Clear user data and its reference from the iter and this model.""""""\n        iter.stamp = 0\n        if iter.user_data:\n            if iter.user_data in self._held_refs:\n                del self._held_refs[iter.user_data]\n            iter.user_data = None\n\n    def invalidate_iters(self):\n        """"""\n        This method invalidates all TreeIter objects associated with this custom tree model\n        and frees their locally pooled references.\n        """"""\n        self.stamp = random.randint(-2147483648, 2147483647)\n        self._held_refs.clear()\n\n    def iter_is_valid(self, iter):\n        """"""\n        :Returns:\n            True if the Gtk.TreeIter specified by iter is valid for the custom tree model.\n        """"""\n        return iter.stamp == self.stamp\n\n    def get_user_data(self, iter):\n        """"""Get the user_data associated with the given TreeIter.\n\n        GenericTreeModel stores arbitrary Python objects mapped to instances of Gtk.TreeIter.\n        This method allows to retrieve the Python object held by the given iterator.\n        """"""\n        if self.leak_references:\n            return self._held_refs[iter.user_data]\n        else:\n            return _get_user_data_as_pyobject(iter)\n\n    def set_user_data(self, iter, user_data):\n        """"""Applies user_data and stamp to the given iter.\n\n        If the models ""leak_references"" property is set, a reference to the\n        user_data is stored with the model to ensure we don\'t run into bad\n        memory problems with the TreeIter.\n        """"""\n        iter.user_data = id(user_data)\n\n        if user_data is None:\n            self.invalidate_iter(iter)\n        else:\n            iter.stamp = self.stamp\n            if self.leak_references:\n                self._held_refs[iter.user_data] = user_data\n\n    def create_tree_iter(self, user_data):\n        """"""Create a Gtk.TreeIter instance with the given user_data specific for this model.\n\n        Use this method to create Gtk.TreeIter instance instead of directly calling\n        Gtk.Treeiter(), this will ensure proper reference managment of wrapped used_data.\n        """"""\n        iter = Gtk.TreeIter()\n        self.set_user_data(iter, user_data)\n        return iter\n\n    def _create_tree_iter(self, data):\n        """"""Internal creation of a (bool, TreeIter) pair for returning directly\n        back to the view interfacing with this model.""""""\n        if data is None:\n            return (False, None)\n        else:\n            it = self.create_tree_iter(data)\n            return (True, it)\n\n    def row_deleted(self, path, node=None):\n        """"""Notify the model a row has been deleted.\n\n        Use the node parameter to ensure the user_data reference associated\n        with the path is properly freed by this model.\n\n        :Parameters:\n            path : Gtk.TreePath\n                Path to the row that has been deleted.\n            node : object\n                Python object used as the node returned from ""on_get_iter"". This is\n                optional but ensures the model will not leak references to this object.\n        """"""\n        super(GenericTreeModel, self).row_deleted(path)\n        node_id = id(node)\n        if node_id in self._held_refs:\n            del self._held_refs[node_id]\n\n    #\n    # GtkTreeModel Interface Implementation\n    #\n    @handle_exception(0)\n    def do_get_flags(self):\n        """"""Internal method.""""""\n        return self.on_get_flags()\n\n    @handle_exception(0)\n    def do_get_n_columns(self):\n        """"""Internal method.""""""\n        return self.on_get_n_columns()\n\n    @handle_exception(GObject.TYPE_INVALID)\n    def do_get_column_type(self, index):\n        """"""Internal method.""""""\n        return self.on_get_column_type(index)\n\n    @handle_exception((False, None))\n    def do_get_iter(self, path):\n        """"""Internal method.""""""\n        return self._create_tree_iter(self.on_get_iter(path))\n\n    @handle_exception(False)\n    def do_iter_next(self, iter):\n        """"""Internal method.""""""\n        if iter is None:\n            next_data = self.on_iter_next(None)\n        else:\n            next_data = self.on_iter_next(self.get_user_data(iter))\n\n        self.set_user_data(iter, next_data)\n        return next_data is not None\n\n    @handle_exception(None)\n    def do_get_path(self, iter):\n        """"""Internal method.""""""\n        path = self.on_get_path(self.get_user_data(iter))\n        if path is None:\n            return None\n        else:\n            return Gtk.TreePath(path)\n\n    @handle_exception(None)\n    def do_get_value(self, iter, column):\n        """"""Internal method.""""""\n        return self.on_get_value(self.get_user_data(iter), column)\n\n    @handle_exception((False, None))\n    def do_iter_children(self, parent):\n        """"""Internal method.""""""\n        data = self.get_user_data(parent) if parent else None\n        return self._create_tree_iter(self.on_iter_children(data))\n\n    @handle_exception(False)\n    def do_iter_has_child(self, parent):\n        """"""Internal method.""""""\n        return self.on_iter_has_child(self.get_user_data(parent))\n\n    @handle_exception(0)\n    def do_iter_n_children(self, iter):\n        """"""Internal method.""""""\n        if iter is None:\n            return self.on_iter_n_children(None)\n        return self.on_iter_n_children(self.get_user_data(iter))\n\n    @handle_exception((False, None))\n    def do_iter_nth_child(self, parent, n):\n        """"""Internal method.""""""\n        if parent is None:\n            data = self.on_iter_nth_child(None, n)\n        else:\n            data = self.on_iter_nth_child(self.get_user_data(parent), n)\n        return self._create_tree_iter(data)\n\n    @handle_exception((False, None))\n    def do_iter_parent(self, child):\n        """"""Internal method.""""""\n        return self._create_tree_iter(self.on_iter_parent(self.get_user_data(child)))\n\n    @handle_exception(None)\n    def do_ref_node(self, iter):\n        self.on_ref_node(self.get_user_data(iter))\n\n    @handle_exception(None)\n    def do_unref_node(self, iter):\n        self.on_unref_node(self.get_user_data(iter))\n\n    #\n    # Python Subclass Overridables\n    #\n    def on_get_flags(self):\n        """"""Overridable.\n\n        :Returns Gtk.TreeModelFlags:\n            The flags for this model. See: Gtk.TreeModelFlags\n        """"""\n        raise NotImplementedError\n\n    def on_get_n_columns(self):\n        """"""Overridable.\n\n        :Returns:\n            The number of columns for this model.\n        """"""\n        raise NotImplementedError\n\n    def on_get_column_type(self, index):\n        """"""Overridable.\n\n        :Returns:\n            The column type for the given index.\n        """"""\n        raise NotImplementedError\n\n    def on_get_iter(self, path):\n        """"""Overridable.\n\n        :Returns:\n            A python object (node) for the given TreePath.\n        """"""\n        raise NotImplementedError\n\n    def on_iter_next(self, node):\n        """"""Overridable.\n\n        :Parameters:\n            node : object\n                Node at current level.\n\n        :Returns:\n            A python object (node) following the given node at the current level.\n        """"""\n        raise NotImplementedError\n\n    def on_get_path(self, node):\n        """"""Overridable.\n\n        :Returns:\n            A TreePath for the given node.\n        """"""\n        raise NotImplementedError\n\n    def on_get_value(self, node, column):\n        """"""Overridable.\n\n        :Parameters:\n            node : object\n            column : int\n                Column index to get the value from.\n\n        :Returns:\n            The value of the column for the given node.""""""\n        raise NotImplementedError\n\n    def on_iter_children(self, parent):\n        """"""Overridable.\n\n        :Returns:\n            The first child of parent or None if parent has no children.\n            If parent is None, return the first node of the model.\n        """"""\n        raise NotImplementedError\n\n    def on_iter_has_child(self, node):\n        """"""Overridable.\n\n        :Returns:\n            True if the given node has children.\n        """"""\n        raise NotImplementedError\n\n    def on_iter_n_children(self, node):\n        """"""Overridable.\n\n        :Returns:\n            The number of children for the given node. If node is None,\n            return the number of top level nodes.\n        """"""\n        raise NotImplementedError\n\n    def on_iter_nth_child(self, parent, n):\n        """"""Overridable.\n\n        :Parameters:\n            parent : object\n            n : int\n                Index of child within parent.\n\n        :Returns:\n            The child for the given parent index starting at 0. If parent None,\n            return the top level node corresponding to ""n"".\n            If ""n"" is larger then available nodes, return None.\n        """"""\n        raise NotImplementedError\n\n    def on_iter_parent(self, child):\n        """"""Overridable.\n\n        :Returns:\n            The parent node of child or None if child is a top level node.""""""\n        raise NotImplementedError\n\n    def on_ref_node(self, node):\n        pass\n\n    def on_unref_node(self, node):\n        pass'"
mvc/adapters/gtk_support/treemodels/object_list_store.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GObject  # @UnresolvedImport\n\nfrom ....observers import ListObserver, ListItemObserver\n\nfrom .base_models import BaseObjectListStore\nfrom weakref import WeakKeyDictionary\n\nclass ObjectListStore(BaseObjectListStore):\n    """"""\n        GenericTreeModel implementation that wraps a python list of \n        mvc model objects. In addition, it expects all objects \n        to be of a certain type, which needs to be passed to the __init__ as \n        the first argument.This way, the wrapper can inspect the type and\n        find out what properties can be represented as columns and report this\n        to Gtk.\n    """"""\n\n    # PROPERTIES:\n    _deleted_paths = None\n\n    @property\n    def _data(self):\n        if self._model is not None:\n            return getattr(self._model, self._prop_name, None)\n        else:\n            return []\n\n    def is_wrapping(self, model, prop_name):\n        return self._model == model and self._prop_name == prop_name\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, model, prop):\n        BaseObjectListStore.__init__(self, prop.data_type)\n        self._model = model\n        self._prop_name = prop.label\n\n        self._deleted_paths = []\n\n        self._observer = ListObserver(\n            self.on_item_inserted, self.on_item_deleted,\n            on_deleted_before=self.on_item_deleted_before,\n            prop_name=self._prop_name, model=self._model\n        )\n\n        self._list_item_observers = WeakKeyDictionary()\n        for item in self._data:\n            self._observe_item(item)\n\n    def _observe_item(self, item):\n        obs = ListItemObserver(self.on_item_changed, model=item)\n        self._list_item_observers[item] = obs\n\n    def _unobserve_item(self, item):\n        observer = self._list_item_observers.get(item, None)\n        if observer is not None: observer.clear()\n\n    def on_item_changed(self, item):\n        itr = self.create_tree_iter(item)\n        path = self.get_path(itr)\n        try:\n            self.row_changed(path, itr)\n        except TypeError as err:\n            err.args += (""when emitting row_changed using:"", path, itr)\n            raise\n\n    def on_item_inserted(self, item):\n        try:\n            itr = self.create_tree_iter(item)\n            path = self.get_path(itr)\n            self._observe_item(item)\n            self.row_inserted(path, itr)\n        except ValueError:\n            logger.debug(""Invalid rowref passed: %s"", item)\n            pass # invalid rowref\n\n    def on_item_deleted_before(self, item):\n        self._unobserve_item(item)\n        self._deleted_paths.append((self._data.index(item),))\n\n    def on_item_deleted(self, item):\n        for path in self._deleted_paths:\n            self.row_deleted(path)\n        self._deleted_paths = []\n\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def on_get_iter(self, path):\n        try:\n            return self._data[path[0]]\n        except IndexError:\n            return None\n\n    def on_get_path(self, rowref):\n        try:\n            return (self._data.index(rowref),)\n        except ValueError:\n            logger.exception(""ValueError in on_get_path of %s caused by %s"" % (self, rowref))\n\n    def set_value(self, itr, column, value):\n        user_data = self.get_user_data(itr)\n        setattr(user_data, self._columns[column][0], value)\n        self.row_changed(self.get_path(itr), itr)\n\n    def on_get_value(self, rowref, column):\n        value = getattr(rowref, self._columns[column][0])\n        try:\n            default = self._columns[column][1]()\n        except TypeError:\n            default = """"\n        return value if value is not None else default\n\n    def on_iter_next(self, rowref):\n        n, = self.on_get_path(rowref)\n        try:\n            return self._data[n + 1]\n        except IndexError:\n            pass\n\n    def on_iter_children(self, rowref):\n        if rowref:\n            return None\n        if self._data:\n            return self.on_get_iter((0,))\n        return None\n\n    def on_iter_has_child(self, rowref):\n        if rowref:\n            return False\n        if len(self._data) > 0:\n            return True\n        return False\n\n    def on_iter_n_children(self, rowref):\n        if rowref:\n            return 0\n        return len(self._data)\n\n    def on_iter_nth_child(self, parent, n):\n        if parent:\n            return None\n        if n < 0 or n >= len(self._data):\n            return None\n        return self._data[n]\n\n    def on_iter_parent(self, rowref):\n        return None\n\n    pass # end of class\n\nGObject.type_register(ObjectListStore) # @UndefinedVariable\n'"
mvc/adapters/gtk_support/treemodels/object_tree_store.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom traceback import print_exc\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, GObject  # @UnresolvedImport\n\nfrom .base_models import BaseObjectListStore\nfrom ....observers import TreeObserver\n\nclass ObjectTreeStore(BaseObjectListStore):\n    """"""\n        GenericTreeModel implementation that holds a tree with objects.\n        It expects all objects to be of a certain type, which needs to be\n        passed to the __init__ as the first argument. \n    """"""\n\n    # PROPERTIES:\n    _object_node_map = None\n\n    @property\n    def _root_node(self):\n        return getattr(self._model, self._prop_name, None)\n\n    def is_wrapping(self, model, prop_name):\n        return self._model == model and self._prop_name == prop_name\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, model, prop):\n        _root = getattr(model, prop.label, None)\n\n        # Then continue:\n        try:\n            BaseObjectListStore.__init__(self, prop.data_type)\n        except ValueError as err:\n            msg = ""ValueError (%r) was raised when initializing ObjectTreeStore for model \'%s\' and data type \'%s\'"" % (err, model, prop.data_type)\n            msg += ""\\n Did you forget to set the data_type on the list property \'%s\'?"" % prop.label\n            raise ValueError(msg)\n        self._model = model\n        self._prop_name = prop.label\n        self._object_node_map = dict()\n\n        self._observer = TreeObserver(\n            self.on_item_inserted, self.on_item_deleted,\n            on_deleted_before=self.on_item_deleted_before,\n            prop_name=self._prop_name, model=self._model\n        )\n\n    def on_item_inserted(self, item):\n        try:\n            itr = self.create_tree_iter(item)\n            path = self.get_path(itr)\n            # self._observe_item(item)\n            self.row_inserted(path, itr)\n        except ValueError:\n            logger.debug(""Invalid rowref passed: %s"", item)\n            pass # invalid rowref\n\n    _deleted_paths = []\n    def on_item_deleted_before(self, item):\n        # self._unobserve_item(item)\n        self._deleted_paths.append(self.on_get_path(item))\n\n    def on_item_deleted(self, item):\n        for path in self._deleted_paths:\n            self.row_deleted(path)\n        self._deleted_paths = []\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def on_get_flags(self):\n        return Gtk.TreeModelFlags.ITERS_PERSIST\n\n    def on_get_iter(self, path):\n        try:\n            if hasattr(path, \'split\'): path = list(map(int, path.split("":"")))\n            return self._root_node.get_child_node(*path)\n        except IndexError as err:\n            err.args = ""IndexError in on_get_iter of %s caused by %s"" % (self, path)\n            print_exc()\n            return None\n\n    def on_get_path(self, node):\n        try:\n            return "":"".join(map(str, node.get_indices()))\n        except ValueError as err:\n            err.args = ""ValueError in on_get_path of %s caused by %s"" % (self, node)\n            print_exc()\n            return None\n\n    def set_value(self, itr, column, value):\n        user_data = self.get_tree_node_object(itr)\n        setattr(user_data, self._columns[column][0], value)\n        self.row_changed(self.get_path(itr), itr)\n\n    def on_get_value(self, node, column):\n        try:\n            return getattr(node.object, self._columns[column][0])\n        except:\n            return """"\n\n    def on_iter_next(self, node):\n        return node.get_next_node()\n\n    def on_iter_children(self, node):\n        node = node or self._root_node\n        return node.get_first_child_node()\n\n    def on_iter_has_child(self, node):\n        node = node or self._root_node\n        return node.has_children\n\n    def on_iter_n_children(self, node):\n        node = node or self._root_node\n        return node.child_count\n\n    def on_iter_nth_child(self, parent, n):\n        node = parent or self._root_node\n        try:\n            return node.get_child_node(n)\n        except:\n            return None\n\n    def on_iter_parent(self, node):\n        return node.parent\n\n    def iter_objects(self):\n        for node in self._root_node.iter_children():\n            yield node.object\n\n    def get_tree_node(self, itr):\n        return BaseObjectListStore.get_user_data(self, itr)\n\n    def get_tree_node_from_path(self, path):\n        return BaseObjectListStore.get_user_data_from_path(self, path)\n\n    def get_tree_node_object(self, itr):\n        return self.get_tree_node(itr).object\n\n    def get_tree_node_object_from_path(self, path):\n        return self.get_tree_node_from_path(path).object\n\n    pass # end of class\n\nGObject.type_register(ObjectTreeStore) # @UndefinedVariable\n'"
mvc/adapters/gtk_support/treemodels/utils.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk  # @UnresolvedImport\n\n\nimport os\nimport csv\n\n################################################################################\n# Array-like item repositioning:\n################################################################################\ndef repos(ln, old_pos, new_pos):\n    """"""\n        Return a new list in which each item contains the index of the item\n        in the old order.\n        Uses the ranges approach (best for large arrays).\n    """"""\n    lb = min(new_pos, old_pos)\n    ub = max(new_pos, old_pos)\n    adj_range = []\n    if new_pos < old_pos:\n        adj_range.append(old_pos)\n        adj_range += list(range(lb, ub))\n    else:\n        adj_range += list(range(lb + 1, ub + 1))\n        adj_range.append(old_pos)\n    return list(range(0, lb)) + adj_range + list(range(ub, ln - 1))\n\ndef simple_repos(ln, old_pos, new_pos):\n    """"""\n        Return a new list in which each item contains the index of the item\n        in the old order.\n        Uses the delete/insert approach (best for small arrays).\n    """"""\n    r1 = list(range(ln))\n    val = r1[old_pos]\n    del r1[old_pos]\n    r1.insert(new_pos, val)\n    return r1\n\ndef smart_repos(ln, old_pos, new_pos):\n    """"""\n        Return a new list in which each item contains the index of the item\n        in the old order.\n        Decides which algorithm to use based on the size of the arrays.\n    """"""\n    if ln > 65:\n        return repos(ln, old_pos, new_pos)\n    else:\n        return simple_repos(ln, old_pos, new_pos)\n\n################################################################################\n# Treestore creation from filesystem\n################################################################################\ndef create_valuestore_from_file(filename, data_type=float):\n    liststore = Gtk.ListStore(str, data_type)\n    with open(filename, \'r\') as f:\n        reader = csv.reader(f)\n        next(reader) # skip header\n        for row in reader:\n            row[1] = data_type(row[1])\n            liststore.append(row)\n    return liststore\n\ndef create_treestore_from_directory(directory):\n    treestore = Gtk.TreeStore(str, str, bool)\n    treestore.append(None, ("""", """", True))\n    parents = {}\n    for root, dirnames, filenames in os.walk(directory):\n        for dirname in dirnames:\n            parents[os.path.join(root, dirname)] = treestore.append(parents.get(root, None), (dirname, """", False))\n        for filename in filenames:\n            treestore.append(parents.get(root, None), (os.path.splitext(filename)[0], ""%s/%s"" % (root, filename), True))\n    return treestore\n'"
mvc/adapters/gtk_support/treemodels/xy_list_store.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nfrom collections import namedtuple\n\nfrom ....observers import Observer\nfrom ....models.xydata import XYData\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, GLib, GObject  # @UnresolvedImport\n\nfrom .base_models import BaseObjectListStore\n\nclass PointMeta():\n    @classmethod\n    def get_column_properties(cls):\n        return [\n            (\'x\', float),\n            (\'y\', float)\n        ]\nPoint = namedtuple(\'Point\', [\'x\', \'y\'])\nPoint.Meta = PointMeta\n\nclass XYListStore(BaseObjectListStore, Observer):\n    """"""\n        GenericTreeModel implementation that wraps an XYData model.\n    """"""\n    _model = None\n    _prop_name = None\n    _last_lenght = 0\n\n    __gsignals__ = {\n        \'columns-changed\' : (GObject.SignalFlags.RUN_LAST, None, ())  # @UndefinedVariable\n    }\n\n    @property\n    def _data(self):\n        return getattr(self._model, self._prop_name, None)\n\n    def is_wrapping(self, model, prop_name):\n        return self._model == model and self._prop_name == prop_name\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, model, prop):\n        # Continue initialisation:\n        BaseObjectListStore.__init__(self, Point)\n        \n        # Check this really is an XYData property:\n        self._flush()\n        self._model = model\n        self._prop_name = prop.label\n        _data = getattr(self._model, self._prop_name, None)\n        assert isinstance(_data, XYData), \\\n            ""Can only wrap XYData (or subclasses) instances to a XYListStore,"" + \\\n            ""but got \'%s\' instead from property \'%s\' on model \'%s\'."" % (\n                _data, self._prop_name, self._model)\n        \n        Observer.__init__(self, model=self._data)\n        self.set_property(""leak-references"", False)\n\n        self._last_length = len(self)\n        self._last_num_col = self._data.num_columns\n\n        # Force update:\n        self._emit_update()\n\n    @Observer.observe(""data_changed"", signal=True)\n    def on_data_changed(self, model, name, info):\n        if model == self._data:\n            self._emit_update()\n\n    def _emit_update(self):\n        # Invalidate iters, we\'re (probably) changing stuff:\n        self._schedule_flush()\n\n        # 1. check if number of columns has changed since last update\n        #    if it has changed, emit the corresponding event\n        if self._last_num_col != self._data.num_columns:\n            self.emit(""columns-changed"")\n            self._last_num_col = self._data.num_columns\n\n        # 2. check if length has changed, if shorter emit removed signals\n        #    for the lost elements, if longer emit insert signals\n        row_diff = len(self._data) - self._last_length\n        if row_diff > 0:\n            for i in range(self._last_length, self._last_length + row_diff, 1):\n                path = self.on_get_path(i)\n                itr = self.get_iter(path)\n                self.row_inserted(path, itr)\n        elif row_diff < 0:\n            for i in range(self._last_length, self._last_length + row_diff - 1, -1):\n                path = self.on_get_path(i)\n                self.row_deleted(path)\n        self._last_length = len(self._data)\n\n        # 3. Emit row-changed signals for all other rows:\n        for i in range(0, len(self._data)):\n            path = self.on_get_path(i)\n            itr = self.get_iter(path)\n            self.row_changed(path, itr)\n\n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def on_get_flags(self):\n        return Gtk.TreeModelFlags.LIST_ONLY\n\n    def on_get_iter(self, path): # returns a rowref, they\'re actually just paths\n        if hasattr(path, ""get_indices""):\n            path = path.get_indices()\n        sp = "":"".join(map(lambda i: ""%d"" % i, path))\n        if not sp in self._cache:\n            try:\n                i = path[0]\n                if i >= 0 and i < len(self):\n                    self._cache[sp] = [i, ]\n            except IndexError:\n                pass\n        return self._cache.get(sp, None)\n        self._schedule_flush()\n        return\n\n    def _schedule_flush(self):\n        if not self._flush_scheduled:\n            def idle_add():\n                GLib.idle_add(self._flush)\n                return False # delete timeout\n\n            GLib.timeout_add(500, idle_add)\n            self._flush_scheduled = True\n\n    def _flush(self):\n        self.invalidate_iters()\n        self._cache = {} # del _cache - keep no ref to this dict\n        self._flush_scheduled = False\n        return False # In case we are called from idle signal\n\n    def on_get_value(self, rowref, column):\n        if column == self.c_x:\n            return self._data.data_x[rowref[0]]\n        elif column >= self.c_y:\n            return self._data.data_y[rowref[0], column - 1]\n        else:\n            raise AttributeError\n\n    def on_get_path(self, rowref): # rowrefs are paths, unless they\'re None\n        if rowref is None:\n            return None\n        if isinstance(rowref, tuple):\n            return rowref\n        elif isinstance(rowref, list):\n            return tuple(rowref)\n        else:\n            return rowref,\n\n    def on_iter_next(self, rowref):\n        if rowref is not None:\n            itr = self.on_get_iter((rowref[0] + 1,))\n            return itr\n        else:\n            return None\n\n    def on_iter_children(self, rowref):\n        if rowref is not None:\n            return None\n        elif len(self) > 0:\n            return self.on_get_iter((0,))\n        return None\n\n    def on_iter_has_child(self, rowref):\n        if rowref is not None:\n            return False\n        elif len(self) > 0:\n            return True\n        return False\n\n    def on_iter_n_children(self, rowref):\n        if rowref is not None:\n            return 0\n        return len(self)\n\n    def on_iter_nth_child(self, rowref, n):\n        if rowref is not None:\n            return None\n        if n < 0 or n >= len(self):\n            return None\n        return self.on_get_iter((n,))\n\n    def on_iter_parent(self, rowref):\n        return None\n\n    def on_get_n_columns(self):\n        return self._data.num_columns\n\n    def on_get_column_type(self, index):\n        return float\n\n    def __len__(self):\n        return self._data.size\n\n    pass # end of class\n\nGObject.type_register(XYListStore)  # @UndefinedVariable\n'"
mvc/adapters/gtk_support/widgets/__init__.py,0,b'\nfrom .scale_entry import ScaleEntry'
mvc/adapters/gtk_support/widgets/scale_entry.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et:\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2014 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import Gtk, GObject, GLib  # @UnresolvedImport\n\nfrom mvc.support.utils import round_sig\n\nclass ScaleEntry(Gtk.HBox):\n    """"""\n        The ScaleEntry combines the generic GtkEntry and GtkScale widgets in\n        one widget, with synchronized values and one changed signal.\n    """"""\n\n    __gsignals__ = {\n        \'changed\' : (GObject.SignalFlags.RUN_LAST, None, []), #@UndefinedVariable\n    }\n\n    @property\n    def lower(self):\n        return self.adjustment.get_lower()\n    @lower.setter\n    def lower(self, value):\n        return self.adjustment.set_lower(value)\n\n    @property\n    def upper(self):\n        return self.adjustment.get_upper()\n    @upper.setter\n    def upper(self, value):\n        return self.adjustment.set_upper(value)\n\n    def __init__(self, lower=0, upper=10, enforce_range=False):\n        GObject.GObject.__init__(self, spacing=5)\n\n        self.enforce_range = enforce_range\n\n        if lower == None: lower = 0\n        if upper == None: upper = 10\n        lower = min(upper, lower)\n        upper = max(upper, lower)\n\n        step = max((upper - lower) / 200.0, 0.01)\n        self.adjustment = Gtk.Adjustment(\n            0.0, lower, upper, step, step, 0.0)\n\n        self.adjustment.connect(\'value-changed\', self.on_adj_value_changed)\n\n        self.scale = Gtk.Scale.new(Gtk.Orientation.HORIZONTAL, self.adjustment)\n        self.scale.set_draw_value(False)\n        self.scale.set_size_request(50, -1)\n\n        self.entry = Gtk.SpinButton()\n        self.entry.set_adjustment(self.adjustment)\n        self.entry.set_digits(5)\n        self.entry.set_numeric(True)\n        self.entry.set_size_request(150, -1)\n\n        self.set_value(self.scale.get_value())\n\n        Gtk.HBox.pack_start(self, self.scale, False, True, 0)\n        Gtk.HBox.pack_start(self, self.entry, False, True, 0)\n        self.set_focus_chain((self.entry,))\n\n\n    _idle_changed_id = None\n    def _idle_emit_changed(self):\n        if self._idle_changed_id is not None:\n            GLib.source_remove(self._idle_changed_id)\n        self._idle_changed_id = GLib.idle_add(self._emit_changed)\n\n    def _emit_changed(self):\n        self.emit(\'changed\')\n        self._idle_changed_id = None;\n\n    def on_adj_value_changed(self, adj, *args):\n        self._idle_emit_changed()\n\n    def _update_adjustment(self, lower, upper):\n        step = round_sig(max((upper - lower) / 200.0, 0.0005))\n        self.adjustment.configure(lower, upper,\n            step, step, 0.0)\n\n    def _update_range(self, value):\n        lower, upper = self.lower, self.upper\n        if not self.enforce_range:\n            if value < (lower + abs(lower) * 0.05):\n                lower = value - abs(value) * 0.2\n            if value > (upper - abs(lower) * 0.05):\n                upper = value + abs(value) * 0.2\n            self._update_adjustment(lower, upper)\n\n    def set_value(self, value):\n        self._update_range(value)\n        self.adjustment.set_value(value)\n\n    def get_value(self):\n        return self.adjustment.get_value()\n\n    def get_children(self, *args, **kwargs):\n        return []\n    def add(self, *args, **kwargs):\n        raise NotImplementedError\n    def add_with_properties(self, *args, **kwargs):\n        raise NotImplementedError\n    def child_set(self, *args, **kwargs):\n        raise NotImplementedError\n    def child_get(self, *args, **kwargs):\n        raise NotImplementedError\n    def child_set_property(self, *args, **kwargs):\n        raise NotImplementedError\n    def child_get_property(self, *args, **kwargs):\n        raise NotImplementedError\n    def remove(self, *args, **kwargs):\n        raise NotImplementedError\n    def set_child_packing(self, *args, **kwargs):\n        raise NotImplementedError\n    def query_child_packing(self, *args, **kwargs):\n        raise NotImplementedError\n    def reorder_child(self, *args, **kwargs):\n        raise NotImplementedError\n    def pack_start(self, *args, **kwargs):\n        raise NotImplementedError\n    def pack_end(self, *args, **kwargs):\n        raise NotImplementedError\n\n    pass # end of class\n\nGObject.type_register(ScaleEntry) #@UndefinedVariable\n'"
mvc/adapters/gtk_support/widgets/threaded_task_box.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Author: Mathijs Dumon\n# ThreadedTaskBox based on code from Rick Spencer\n# This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.\n# To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send\n# a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.\n\nimport gi   \ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk, GObject\n\nfrom mvc.support.cancellable_thread import CancellableThread\nfrom mvc.support.gui_loop import add_timeout_call, remove_timeout_call,\\\n    run_when_idle\n\n\nclass ThreadedTaskBox(Gtk.Table):\n    """"""\n        ThreadedTaskBox: encapsulates a spinner, label and a cancel button for\n        threaded tasks.\n    """"""\n\n    __gsignals__ = {\n        \'cancelrequested\' : (GObject.SignalFlags.RUN_LAST, None, (GObject.TYPE_PYOBJECT,)), #@UndefinedVariable\n        \'stoprequested\' : (GObject.SignalFlags.RUN_LAST, None, (GObject.TYPE_PYOBJECT,)) #@UndefinedVariable\n    }\n\n    def __init__(self, cancelable=True, stoppable=False):\n        """"""\n            Create a ThreadedTaskBox\n\n            Keyword arguments:\n            cancelable -- optional value to determine whether to show cancel button. Defaults to True.\n            stoppable -- optional value to determine whether to show the stop button. Default to False.\n        """"""\n        super(ThreadedTaskBox, self).__init__()\n        self.setup_ui(cancelable=cancelable, stoppable=stoppable)\n\n    def setup_ui(self, cancelable=True, stoppable=False):\n        GObject.GObject.__init__(self, 3, 3)\n        self.set_row_spacings(10)\n        self.set_col_spacings(10)\n\n        self.descrlbl = Gtk.Label(label=""Status:"")\n        self.descrlbl.show()\n        self.attach(self.descrlbl, 0, 3, 0, 1, xoptions=Gtk.AttachOptions.FILL, yoptions=0)\n\n        self.spinner = Gtk.Spinner()\n        self.spinner.show()\n        self.attach(self.spinner, 0, 1, 1, 3, xoptions=0, yoptions=0)\n\n        self.label = Gtk.Label()\n        self.label.show()\n        self.attach(self.label, 1, 2, 1, 3, xoptions=Gtk.AttachOptions.FILL, yoptions=0)\n\n        self.cancel_button = Gtk.Button(stock=Gtk.STOCK_CANCEL)\n        self.cancel_button.set_sensitive(False)\n        self.cancel_button.connect(""clicked"", self.__cancel_clicked)\n        if cancelable:\n            self.attach(self.cancel_button, 2, 3, 1, 2, xoptions=0, yoptions=0)\n\n        self.stop_button = Gtk.Button(stock=Gtk.STOCK_STOP)\n        self.stop_button.set_sensitive(False)\n        self.stop_button.connect(""clicked"", self.__stop_clicked)\n        if stoppable:\n            self.attach(self.stop_button, 2, 3, 2, 3, xoptions=0, yoptions=0)\n\n        self.set_no_show_all(False)\n        self.set_visible(True)\n        self.show_all()\n\n    def start(self):\n        # Start the spinner\n        self.spinner.start()\n\n        # Enable the buttons so the user can try to cancel the task\n        self.cancel_button.set_sensitive(True)\n        self.stop_button.set_sensitive(True)\n\n    def set_status(self, caption):\n        self.label.set_text(caption)\n\n    def stop(self, join=False, cancel=False):\n        """"""\n            Stops spinning the spinner and emits the correct event.\n        """"""\n        # disable the cancel button since the task is about to be told to stop\n        self.cancel_button.set_sensitive(False)\n        self.stop_button.set_sensitive(False)\n\n        if cancel:\n            self.emit(""cancelrequested"", self)\n        else:\n            self.emit(""stoprequested"", self)\n\n        self.spinner.stop()\n        self.label.set_text(""Done"")\n\n    def cancel(self):\n        self.stop(cancel=True)\n\n    def __cancel_clicked(self, widget):\n        self.cancel()\n\n    def __stop_clicked(self, widget):\n        self.stop()\n\n    pass # end of class\n\nGObject.type_register(ThreadedTaskBox) #@UndefinedVariable\n'"
pyxrd/generic/models/lines/__init__.py,0,"b'from .storable_xy_data import StorableXYData\nfrom .pyxrd_line import PyXRDLine\nfrom .calculated_line import CalculatedLine\nfrom .experimental_line import ExperimentalLine\n\n__all__ = [\n    ""StorableXYData"",\n    ""PyXRDLine"",\n    ""CalculatedLine"",\n    ""ExperimentalLine""\n]'"
pyxrd/generic/models/lines/calculated_line.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nfrom mvc.models.properties.tools import modify\nlogger = logging.getLogger(__name__)\n\nfrom mvc.models.properties import (\n    ListProperty, SignalMixin\n)\n\nfrom pyxrd.data import settings\nfrom pyxrd.generic.io import storables\n\nfrom pyxrd.generic.models.base import DataModel\n\nfrom .pyxrd_line import PyXRDLine\n\n@storables.register()\nclass CalculatedLine(PyXRDLine):\n\n    # MODEL INTEL:\n    class Meta(PyXRDLine.Meta):\n        store_id = ""CalculatedLine""\n        inherit_format = ""display_calc_%s""\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    phase_colors = ListProperty(\n        default=[], test=""Phase colors"",\n        mix_with=(SignalMixin,),\n        signal_name=""visuals_changed"",\n    )\n\n    #: The line color\n    color = modify(PyXRDLine.color,\n        default=settings.CALCULATED_COLOR,\n        inherit_from=""parent.parent.display_calc_color""\n    )\n\n    #: The linewidth in points\n    lw = modify(PyXRDLine.lw,\n        default=settings.CALCULATED_LINEWIDTH,\n        inherit_from=""parent.parent.display_calc_lw""\n    )\n\n    #: A short string describing the (matplotlib) linestyle\n    ls = modify(PyXRDLine.ls,\n        default=settings.CALCULATED_LINESTYLE,\n        inherit_from=""parent.parent.display_calc_ls""\n    )\n\n    #: A short string describing the (matplotlib) marker\n    marker = modify(PyXRDLine.marker,\n        default=settings.CALCULATED_MARKER,\n        inherit_from=""parent.parent.display_calc_marker""\n    )\n\n    pass # end of class'"
pyxrd/generic/models/lines/experimental_line.py,22,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\nfrom scipy.integrate import trapz\nfrom scipy.interpolate import UnivariateSpline\n\nfrom mvc.models.properties.tools import modify\nfrom mvc.models.properties import (\n    FloatProperty, LabeledProperty, IntegerProperty, FloatChoiceProperty,\n    IntegerChoiceProperty, SetActionMixin, SignalMixin\n)\n\nfrom pyxrd.data import settings\nfrom pyxrd.generic.io import storables\nfrom pyxrd.calculations.math_tools import smooth, add_noise\n\nfrom pyxrd.generic.models.base import DataModel\n\nfrom .pyxrd_line import PyXRDLine\n\n@storables.register()\nclass ExperimentalLine(PyXRDLine):\n\n    # MODEL INTEL:\n    class Meta(PyXRDLine.Meta):\n        store_id = ""ExperimentalLine""\n\n    specimen = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # PROPERTIES:\n\n    #: The line color\n    color = modify(PyXRDLine.color,\n        default=settings.EXPERIMENTAL_COLOR,\n        inherit_from=""parent.parent.display_exp_color""\n    )\n    #: The linewidth in points\n    lw = modify(PyXRDLine.lw,\n        default=settings.EXPERIMENTAL_LINEWIDTH,\n        inherit_from=""parent.parent.display_exp_lw""\n    )\n\n    #: A short string describing the (matplotlib) linestyle\n    ls = modify(PyXRDLine.ls,\n        default=settings.EXPERIMENTAL_LINESTYLE,\n        inherit_from=""parent.parent.display_exp_ls""\n    )\n\n    #: A short string describing the (matplotlib) marker\n    marker = modify(PyXRDLine.marker,\n        default=settings.EXPERIMENTAL_MARKER,\n        inherit_from=""parent.parent.display_exp_marker""\n    )\n\n    #: The value to cap the pattern at (in raw values)\n    cap_value = FloatProperty(\n        default=0.0, text=""Cap value"",\n        persistent=True, visible=True, widget_type=""float_entry"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    @property\n    def max_display_y(self):\n        max_value = super(ExperimentalLine, self).max_display_y\n        # Only cap single and multi-line patterns, not 2D images:\n        if self.cap_value > 0 and not (self.num_columns > 2 and len(self.z_data)):\n            max_value = min(max_value, self.cap_value)\n        return max_value\n\n    ###########################################################################\n\n    #: The background offset value\n    bg_position = FloatProperty(\n        default=0.0, text=""Background offset"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The background scale\n    bg_scale = FloatProperty(\n        default=1.0, text=""Background scale"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The background pattern or None for linear patterns\n    bg_pattern = LabeledProperty(\n        default=None, text=""Background pattern"",\n        persistent=False, visible=False,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The background type: pattern or linear\n    bg_type = IntegerChoiceProperty(\n        default=0, text=""Background type"", choices=settings.PATTERN_BG_TYPES,\n        persistent=False, visible=True,\n        signal_name=""visuals_changed"", set_action_name=""find_bg_position"",\n        mix_with=(SignalMixin, SetActionMixin,)\n    )\n\n    def get_bg_type_lbl(self):\n        return settings.PATTERN_BG_TYPES[self.bg_type]\n\n    ###########################################################################\n\n    #: Pattern smoothing type\n    smooth_type = IntegerChoiceProperty(\n        default=0, text=""Smooth type"", choices=settings.PATTERN_SMOOTH_TYPES,\n        persistent=False, visible=True,\n        signal_name=""visuals_changed"", set_action_name=""setup_smooth_variables"",\n        mix_with=(SignalMixin, SetActionMixin,)\n    )\n\n    smooth_pattern = None\n\n    #: The smooth degree\n    smooth_degree = IntegerProperty(\n        default=0, text=""Smooth degree"",\n        persistent=False, visible=True,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    ###########################################################################\n\n    #: The noise fraction to add\n    noise_fraction = FloatProperty(\n        default=0.0, text=""Noise fraction"",\n        persistent=False, visible=True, widget_type=""spin"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    ###########################################################################\n\n    #: The pattern shift correction value\n    shift_value = FloatProperty(\n        default=0.0, text=""Shift value"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: Shift reference position\n    shift_position = FloatChoiceProperty(\n        default=0.42574, text=""Shift position"", choices=settings.PATTERN_SHIFT_POSITIONS,\n        persistent=False, visible=True,\n        signal_name=""visuals_changed"", set_action_name=""setup_shift_variables"",\n        mix_with=(SignalMixin, SetActionMixin,)\n    )\n\n    ###########################################################################\n\n    #: The peak properties calculation start position\n    peak_startx = FloatProperty(\n        default=0.0, text=""Peak properties start position"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        set_action_name=""update_peak_properties"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The peak properties calculation end position\n    peak_endx = FloatProperty(\n        default=0.0, text=""Peak properties end position"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        set_action_name=""update_peak_properties"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The peak fwhm value\n    peak_fwhm_result = FloatProperty(\n        default=0.0, text=""Peak FWHM value"",\n        persistent=False, visible=True, widget_type=""label"",\n    )\n    \n    #: The peak area value\n    peak_area_result = FloatProperty(\n        default=0.0, text=""Peak area value"",\n        persistent=False, visible=True, widget_type=""label"",\n    )\n\n    #: The patterns peak properties are calculated from\n    peak_properties_pattern = LabeledProperty(\n        default=None, text=""Peak properties pattern"",\n        persistent=False, visible=False,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    ###########################################################################\n\n    #: The strip peak start position\n    strip_startx = FloatProperty(\n        default=0.0, text=""Strip peak start position"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        set_action_name=""update_strip_pattern"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The strip peak end position\n    strip_endx = FloatProperty(\n        default=0.0, text=""Strip peak end position"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        set_action_name=""update_strip_pattern"",\n        mix_with=(SetActionMixin,)\n    )\n\n    #: The stripped peak pattern\n    stripped_pattern = LabeledProperty(\n        default=None, text=""Strip peak pattern"",\n        persistent=False, visible=False,\n        signal_name=""visuals_changed"",\n        mix_with=(SignalMixin,)\n    )\n\n    #: The stripped peak pattern noise\n    noise_level = FloatProperty(\n        default=0.0, text=""Strip peak noise level"",\n        persistent=False, visible=True, widget_type=""float_entry"",\n        set_action_name=""update_strip_pattern_noise"",\n        mix_with=(SetActionMixin,)\n    )\n\n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, cap_value=0.0, *args, **kwargs):\n        """"""\n            Valid keyword arguments for a ExperimentalLine are:\n                cap_value: the value (in raw counts) at which to cap\n                 the experimental pattern  \n        """"""\n        super(ExperimentalLine, self).__init__(*args, **kwargs)\n        self.cap_value = cap_value\n\n    # ------------------------------------------------------------\n    #      Background Removal\n    # ------------------------------------------------------------\n    def remove_background(self):\n        with self.data_changed.hold_and_emit():\n            bg = None\n            if self.bg_type == 0:\n                bg = self.bg_position\n            elif self.bg_type == 1 and self.bg_pattern is not None and not (self.bg_position == 0 and self.bg_scale == 0):\n                bg = self.bg_pattern * self.bg_scale + self.bg_position\n            if bg is not None and self.data_y.size > 0:\n                self.data_y[:, 0] -= bg\n            self.clear_bg_variables()\n\n    def find_bg_position(self):\n        try:\n            self.bg_position = np.min(self.data_y)\n        except ValueError:\n            return 0.0\n\n    def clear_bg_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self.bg_pattern = None\n            self.bg_scale = 0.0\n            self.bg_position = 0.0\n\n    # ------------------------------------------------------------\n    #       Data Smoothing\n    # ------------------------------------------------------------\n    def smooth_data(self):\n        with self.data_changed.hold_and_emit():\n            if self.smooth_degree > 0:\n                degree = int(self.smooth_degree)\n                self.data_y[:, 0] = smooth(self.data_y[:, 0], degree)\n            self.smooth_degree = 0.0\n\n    def setup_smooth_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self.smooth_degree = 5.0\n\n    def clear_smooth_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self.smooth_degree = 0.0\n\n    # ------------------------------------------------------------\n    #       Noise adding\n    # ------------------------------------------------------------\n    def add_noise(self):\n        with self.data_changed.hold_and_emit():\n            if self.noise_fraction > 0:\n                noisified = add_noise(self.data_y[:, 0], self.noise_fraction)\n                self.set_data(self.data_x, noisified)\n            self.noise_fraction = 0.0\n\n    def clear_noise_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self.noise_fraction = 0.0\n\n    # ------------------------------------------------------------\n    #       Data Shifting\n    # ------------------------------------------------------------\n    def shift_data(self):\n        with self.data_changed.hold_and_emit():\n            if self.shift_value != 0.0:\n                if settings.PATTERN_SHIFT_TYPE == ""Linear"":\n                    self.data_x = self.data_x - self.shift_value\n                    if self.specimen is not None:\n                        with self.specimen.visuals_changed.hold():\n                            for marker in self.specimen.markers:\n                                marker.position = marker.position - self.shift_value\n                elif settings.PATTERN_SHIFT_TYPE == ""Displacement"":\n                    position = self.specimen.goniometer.get_t_from_nm(self.shift_position)\n                    displacement = 0.5 * self.specimen.goniometer.radius * self.shift_value / np.cos(position / 180 * np.pi)\n                    correction = 2 * displacement * np.cos(self.data_x / 2 / 180 * np.pi) / self.specimen.goniometer.radius\n                    self.data_x = self.data_x - correction\n\n            self.shift_value = 0.0\n\n    def setup_shift_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            position = self.specimen.goniometer.get_2t_from_nm(self.shift_position)\n            if position > 0.1:\n                max_x = position + 0.5\n                min_x = position - 0.5\n                condition = (self.data_x >= min_x) & (self.data_x <= max_x)\n                section_x, section_y = np.extract(condition, self.data_x), np.extract(condition, self.data_y[:, 0])\n                try:\n                    #TODO to exclude noise it\'d be better to first interpolate\n                    # or smooth the data and then find the max.\n                    actual_position = section_x[np.argmax(section_y)]\n                except ValueError:\n                    actual_position = position\n                self.shift_value = actual_position - position\n\n    def clear_shift_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self.shift_value = 0\n\n    # ------------------------------------------------------------\n    #       Peak area calculation\n    # ------------------------------------------------------------\n    peak_bg_slope = 0.0\n    avg_starty = 0.0\n    avg_endy = 0.0\n    def update_peak_properties(self):\n        with self.visuals_changed.hold_and_emit():\n            if self.peak_endx < self.peak_startx:\n                self.peak_endx = self.peak_startx + 1.0\n                return # previous line will have re-invoked this method\n\n            # calculate average starting point y value\n            condition = (self.data_x >= self.peak_startx - 0.1) & (self.data_x <= self.peak_startx + 0.1)\n            section = np.extract(condition, self.data_y[:, 0])\n            self.avg_starty = np.min(section)\n\n            # calculate average ending point y value\n            condition = (self.data_x >= self.peak_endx - 0.1) & (self.data_x <= self.peak_endx + 0.1)\n            section = np.extract(condition, self.data_y[:, 0])\n            self.avg_endy = np.min(section)\n\n            # Calculate new bg slope\n            self.peak_bg_slope = (self.avg_starty - self.avg_endy) / (self.peak_startx - self.peak_endx)\n\n            # Get the x-values in between start and end point:\n            condition = (self.data_x >= self.peak_startx) & (self.data_x <= self.peak_endx)\n            section_x = np.extract(condition, self.data_x)\n            section_y = np.extract(condition, self.data_y)\n            bg_curve = (self.peak_bg_slope * (section_x - self.peak_startx) + self.avg_starty)\n\n            #Calculate the peak area:\n            self.peak_area_result = abs(trapz(section_y, x=section_x) - trapz(bg_curve, x=section_x))\n\n            # create a spline of of the peak (shifted down by half of its maximum)\n            fwhm_curve = section_y - bg_curve\n            peak_half_max = np.max(fwhm_curve)*0.5\n            spline = UnivariateSpline(section_x, fwhm_curve-peak_half_max, s=0)\n            roots = spline.roots() # find the roots = where the splin = 0\n            self.peak_fwhm_result = np.abs(roots[0] - roots[-1]) if (len(roots) >= 2) else 0\n\n            # Calculate the new y-values: x values, bg_curve y values, original pattern y values, x values for the FWHM, y values for the FWHM\n            self.peak_properties_pattern = (section_x, bg_curve, section_y, roots, spline(roots)+peak_half_max)\n\n    def clear_peak_properties_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self._peak_startx = 0.0\n            self._peak_properties_pattern = None\n            self._peak_endx = 0.0\n            self.peak_properties = 0.0\n\n    # ------------------------------------------------------------\n    #       Peak stripping\n    # ------------------------------------------------------------\n    def strip_peak(self):\n        with self.data_changed.hold_and_emit():\n            if self.stripped_pattern is not None:\n                stripx, stripy = self.stripped_pattern\n                indeces = ((self.data_x >= self.strip_startx) & (self.data_x <= self.strip_endx)).nonzero()[0]\n                np.put(self.data_y[:, 0], indeces, stripy)\n            self._strip_startx = 0.0\n            self._stripped_pattern = None\n            self.strip_endx = 0.0\n\n    strip_slope = 0.0\n    avg_starty = 0.0\n    avg_endy = 0.0\n    block_strip = False\n\n    def update_strip_pattern_noise(self):\n        with self.visuals_changed.hold_and_emit():\n            # Get the x-values in between start and end point:\n            condition = (self.data_x >= self.strip_startx) & (self.data_x <= self.strip_endx)\n            section_x = np.extract(condition, self.data_x)\n\n            # Calculate the new y-values, add noise according to noise_level\n            noise = self.avg_endy * 2 * (np.random.rand(*section_x.shape) - 0.5) * self.noise_level\n            section_y = (self.strip_slope * (section_x - self.strip_startx) + self.avg_starty) + noise\n            self.stripped_pattern = (section_x, section_y)\n\n    def update_strip_pattern(self):\n        with self.visuals_changed.hold_and_emit():\n            if self.strip_endx < self.strip_startx:\n                self.strip_endx = self.strip_startx + 1.0\n                return # previous line will have re-invoked this method\n\n            if not self.block_strip:\n                self.block_strip = True\n\n                # calculate average starting point y value\n                condition = (self.data_x >= self.strip_startx - 0.1) & (self.data_x <= self.strip_startx + 0.1)\n                section = np.extract(condition, self.data_y[:, 0])\n                self.avg_starty = np.average(section)\n                noise_starty = 2 * np.std(section) / self.avg_starty\n\n                # calculate average ending point y value\n                condition = (self.data_x >= self.strip_endx - 0.1) & (self.data_x <= self.strip_endx + 0.1)\n                section = np.extract(condition, self.data_y[:, 0])\n                self.avg_endy = np.average(section)\n                noise_endy = 2 * np.std(section) / self.avg_starty\n\n                # Calculate new slope and noise level\n                self.strip_slope = (self.avg_starty - self.avg_endy) / (self.strip_startx - self.strip_endx)\n                self.noise_level = (noise_starty + noise_endy) * 0.5\n\n                self.update_strip_pattern_noise()\n\n    def clear_strip_variables(self):\n        with self.visuals_changed.hold_and_emit():\n            self._strip_startx = 0.0\n            self._strip_pattern = None\n            self.strip_start_x = 0.0\n\n    pass # end of class\n'"
pyxrd/generic/models/lines/pyxrd_line.py,3,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\nfrom scipy import stats\nfrom scipy.interpolate import interp1d\n\nfrom mvc.models.properties import (\n    StringProperty, BoolProperty, FloatProperty,\n    StringChoiceProperty, SignalMixin, ListProperty\n)\n\nfrom pyxrd.data import settings\n\nfrom pyxrd.generic.utils import not_none\nfrom pyxrd.generic.io.custom_io import storables\nfrom pyxrd.generic.models.properties import InheritableMixin\nfrom pyxrd.calculations.peak_detection import multi_peakdetect\n\nfrom .storable_xy_data import StorableXYData\n\n#from pyxrd.file_parsers.ascii_parser import ASCIIParser\n\n@storables.register()\nclass PyXRDLine(StorableXYData):\n    """"""\n        A PyXRDLine is an abstract attribute holder for a real \'Line\' object,\n        whatever the plotting library used may be. Attributes are line width and\n        color.        \n    """"""\n\n    # MODEL INTEL:\n    class Meta(StorableXYData.Meta):\n        store_id = ""PyXRDLine""\n\n    # OBSERVABLE PROPERTIES:\n\n    #: The line label\n    label = StringProperty(\n        default="""", text=""Label"", persistent=True\n    )\n\n    #: The line color\n    color = StringProperty(\n        default=""#000000"", text=""Label"",\n        visible=True, persistent=True, widget_type=""color"",\n        inherit_flag=""inherit_color"", inherit_from=""parent.parent.display_exp_color"",\n        signal_name=""visuals_changed"",\n        mix_with=(InheritableMixin, SignalMixin)\n    )\n\n    #: Flag indicating whether to use the grandparents color yes/no\n    inherit_color = BoolProperty(\n        default=True, text=""Inherit color"",\n        visible=True, persistent=True,\n        signal_name=""visuals_changed"", mix_with=(SignalMixin,)\n    )\n\n    #: The linewidth in points\n    lw = FloatProperty(\n        default=2.0, text=""Linewidth"",\n        visible=True, persistent=True, widget_type=""spin"",\n        inherit_flag=""inherit_lw"", inherit_from=""parent.parent.display_exp_lw"",\n        signal_name=""visuals_changed"",\n        mix_with=(InheritableMixin, SignalMixin),\n    )\n\n    #: Flag indicating whether to use the grandparents linewidth yes/no\n    inherit_lw = BoolProperty(\n        default=True, text=""Inherit linewidth"",\n        visible=True, persistent=True,\n        signal_name=""visuals_changed"", mix_with=(SignalMixin,),\n    )\n\n    #: A short string describing the (matplotlib) linestyle\n    ls = StringChoiceProperty(\n        default=settings.EXPERIMENTAL_LINESTYLE, text=""Linestyle"",\n        visible=True, persistent=True, choices=settings.PATTERN_LINE_STYLES,\n        mix_with=(InheritableMixin, SignalMixin,), signal_name=""visuals_changed"",\n        inherit_flag=""inherit_ls"", inherit_from=""parent.parent.display_exp_ls"",\n    )\n\n    #: Flag indicating whether to use the grandparents linestyle yes/no\n    inherit_ls = BoolProperty(\n        default=True, text=""Inherit linestyle"",\n        visible=True, persistent=True,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed""\n    )\n\n    #: A short string describing the (matplotlib) marker\n    marker = StringChoiceProperty(\n        default=settings.EXPERIMENTAL_MARKER, text=""Marker"",\n        visible=True, persistent=True, choices=settings.PATTERN_MARKERS,\n        mix_with=(InheritableMixin, SignalMixin,), signal_name=""visuals_changed"",\n        inherit_flag=""inherit_marker"", inherit_from=""parent.parent.display_exp_marker"",\n    )\n\n    #: Flag indicating whether to use the grandparents linewidth yes/no\n    inherit_marker = BoolProperty(\n        default=True, text=""Inherit marker"",\n        visible=True, persistent=True,\n        mix_with=(SignalMixin,), signal_name=""visuals_changed"",\n    )\n    \n    #: z-data (e.g. relative humidity, temperature, for multi-column \'lines\')\n    z_data = ListProperty(\n        default=None, text=""Z data"", data_type=float,\n        persistent=True, visible=False\n    ) \n\n    # REGULAR PROPERTIES:   \n    @property\n    def max_display_y(self):\n        if self.num_columns > 2:\n            # If there\'s several y-columns, check if we have z-data associated with them\n            # if so, it is a 2D pattern, otherwise this is a multi-line pattern\n            if len(self.z_data) > 2:\n                return np.max(self.z_data)\n            else:\n                return self.max_y\n        else:\n            # If there\'s a single comumn of y-data, just get the max value\n            return self.max_y\n\n    @property\n    def min_intensity(self):\n        if self.num_columns > 2:\n            return np.min(self.z_data)\n        else:        \n            return self.min_y\n\n    @property\n    def abs_max_intensity(self):\n        return self.abs_max_y\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for a PyXRDLine are:\n                data: the actual data containing x and y values\n                label: the label for this line\n                color: the color of this line\n                inherit_color: whether to use the parent-level color or its own\n                lw: the line width of this line\n                inherit_lw: whether to use the parent-level line width or its own\n                ls: the line style of this line\n                inherit_ls: whether to use the parent-level line style or its own\n                marker: the line marker of this line\n                inherit_marker: whether to use the parent-level line marker or its own\n                z_data: the z-data associated with the columns in a multi-column pattern\n        """"""\n        my_kwargs = self.pop_kwargs(kwargs,\n            *[prop.label for prop in PyXRDLine.Meta.get_local_persistent_properties()]\n        )\n        super(PyXRDLine, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.visuals_changed.hold():\n            self.label = self.get_kwarg(kwargs, self.label, ""label"")\n            self.color = self.get_kwarg(kwargs, self.color, ""color"")\n            self.inherit_color = bool(self.get_kwarg(kwargs, self.inherit_color, ""inherit_color""))\n            self.lw = float(self.get_kwarg(kwargs, self.lw, ""lw""))\n            self.inherit_lw = bool(self.get_kwarg(kwargs, self.inherit_lw, ""inherit_lw""))\n            self.ls = self.get_kwarg(kwargs, self.ls, ""ls"")\n            self.inherit_ls = bool(self.get_kwarg(kwargs, self.inherit_ls, ""inherit_ls""))\n            self.marker = self.get_kwarg(kwargs, self.marker, ""marker"")\n            self.inherit_marker = bool(self.get_kwarg(kwargs, self.inherit_marker, ""inherit_marker""))\n            self.z_data = list(self.get_kwarg(kwargs, [0], ""z_data""))\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    @classmethod\n    def from_json(cls, **kwargs): # @ReservedAssignment\n        if ""xy_store"" in kwargs:\n            if ""type"" in kwargs[""xy_store""]:\n                kwargs[""data""] = kwargs[""xy_store""][""properties""][""data""]\n        elif ""xy_data"" in kwargs:\n            if ""type"" in kwargs[""xy_data""]:\n                kwargs[""data""] = kwargs[""xy_data""][""properties""][""data""]\n            kwargs[""label""] = kwargs[""data_label""]\n            del kwargs[""data_name""]\n            del kwargs[""data_label""]\n            del kwargs[""xy_data""]\n        return cls(**kwargs)\n\n    # ------------------------------------------------------------\n    #      Convenience Methods & Functions\n    # ------------------------------------------------------------\n    def interpolate(self, *x_vals, **kwargs):\n        """"""\n            Returns a list of (x, y) tuples for the passed x values. An optional\n            column keyword argument can be passed to select a column, by default\n            the first y-column is used. Returned y-values are interpolated. \n        """"""\n        column = kwargs.get(""column"", 0)\n        f = interp1d(self.data_x, self.data_y[:, column])\n        return list(zip(x_vals, f(x_vals)))\n\n    def get_plotted_y_at_x(self, x):\n        """"""\n            Gets the (interpolated) plotted value at the given x position.\n            If this line has not been plotted (or does not have\n            access to a \'__plot_line\' attribute set by the plotting routines)\n            it will return 0.\n        """"""\n        try:\n            xdata, ydata = getattr(self, ""__plot_line"").get_data()\n        except AttributeError:\n            logging.exception(""Attribute error when trying to get plotter data at x position!"")\n        else:\n            if len(xdata) > 0 and len(ydata) > 0:\n                return np.interp(x, xdata, ydata)\n        return 0\n\n    def calculate_npeaks_for(self, max_threshold, steps):\n        """"""\n            Calculates the number of peaks for `steps` threshold values between\n            0 and `max_threshold`. Returns a tuple containing two lists with the\n            threshold values and the corresponding number of peaks. \n        """"""\n        length = self.data_x.size\n\n        resolution = length / (self.data_x[-1] - self.data_x[0])\n        delta_angle = 0.05\n        window = int(delta_angle * resolution)\n        window += (window % 2) * 2\n\n        steps = max(steps, 2) - 1\n        factor = max_threshold / steps\n\n        deltas = [i * factor for i in range(0, steps)]\n\n        numpeaks = []\n\n        maxtabs, mintabs = multi_peakdetect(self.data_y[:, 0], self.data_x, 5, deltas)\n        for maxtab, _ in zip(maxtabs, mintabs):\n            numpeak = len(maxtab)\n            numpeaks.append(numpeak)\n        numpeaks = list(map(float, numpeaks))\n\n        return deltas, numpeaks\n\n    def get_best_threshold(self, max_threshold=None, steps=None, status_dict=None):\n        """"""\n            Estimates the best threshold for peak detection using an\n            iterative algorithm. Assumes there is a linear contribution from noise.\n            Returns a 4-tuple containing the selected threshold, the maximum\n            threshold, a list of threshold values and a list with the corresponding\n            number of peaks.\n        """"""\n        length = self.data_x.size\n        steps = not_none(steps, 20)\n        threshold = 0.1\n        max_threshold = not_none(max_threshold, threshold * 3.2)\n\n        def get_new_threshold(threshold, deltas, num_peaks, ln):\n            # Left side line:\n            x = deltas[:ln]\n            y = num_peaks[:ln]\n            slope, intercept, R, _, _ = stats.linregress(x, y)\n            return R, -intercept / slope\n\n        if length > 2:\n            # Adjust the first distribution:\n            deltas, num_peaks = self.calculate_npeaks_for(max_threshold, steps)\n\n            #  Fit several lines with increasing number of points from the\n            #  generated threshold / marker count graph. Stop when the\n            #  R-coeffici\xc3\xabnt drops below 0.95 (past linear increase from noise)\n            #  Then repeat this by increasing the resolution of data points\n            #  and continue until the result does not change anymore\n\n            last_threshold = None\n            solution = False\n            max_iters = 10\n            min_iters = 3\n            itercount = 0\n            if status_dict is not None:\n                status_dict[""progress""] = 0\n\n            while not solution:\n                # Number of points to use for the lin regress:\n                ln = 4\n                # Maximum number of points to use:\n                max_ln = len(deltas)\n                # Flag indicating if we can stop searching for the linear part\n                stop = False\n                while not stop:\n                    R, threshold = get_new_threshold(threshold, deltas, num_peaks, ln)\n                    max_threshold = threshold * 3.2\n                    if abs(R) < 0.98 or ln >= max_ln:\n                        stop = True\n                    else:\n                        ln += 1\n                itercount += 1 # Increase # of iterations\n                if last_threshold:\n                    # Check if we have run at least `min_iters`, at most `max_iters`\n                    # and have not reached an equilibrium.\n                    solution = bool(\n                        itercount > min_iters and not\n                        (\n                            itercount <= max_iters and\n                            last_threshold - threshold >= 0.001\n                        )\n                    )\n                    if not solution:\n                        deltas, num_peaks = self.calculate_npeaks_for(max_threshold, steps)\n                last_threshold = threshold\n                if status_dict is not None:\n                    status_dict[""progress""] = float(itercount / max_iters)\n\n            return (deltas, num_peaks), threshold, max_threshold\n        else:\n            return ([], []), threshold, max_threshold\n\n\n    pass # end of class'"
pyxrd/generic/models/lines/storable_xy_data.py,1,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport logging\nlogger = logging.getLogger(__name__)\n\nimport numpy as np\n\nfrom mvc.models.xydata import XYData\n\nfrom pyxrd.generic.io import storables, Storable\n\nfrom pyxrd.generic.models.base import DataModel\nfrom pyxrd.generic.utils import not_none\n\n#from pyxrd.file_parsers.ascii_parser import ASCIIParser\n\n@storables.register()\nclass StorableXYData(DataModel, XYData, Storable):\n    """"""\n        A storable XYData model with additional I/O and CRUD abilities.\n    """"""\n\n    class Meta(XYData.Meta):\n        store_id = ""StorableXYData""\n\n    # ------------------------------------------------------------\n    #      Initialisation and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        """"""\n            Valid keyword arguments for a PyXRDLine are:\n                data: the actual data containing x and y values\n                label: the label for this line\n                color: the color of this line\n                inherit_color: whether to use the parent-level color or its own\n                lw: the line width of this line\n                inherit_lw: whether to use the parent-level line width or its own\n        """"""\n        if ""xy_store"" in kwargs:\n            kwargs[""data""] = kwargs.pop(""xy_store"")\n        super(StorableXYData, self).__init__(*args, **kwargs)\n\n    # ------------------------------------------------------------\n    #      Input/Output stuff\n    # ------------------------------------------------------------\n    def json_properties(self):\n        props = super(XYData, self).json_properties()\n        props[""data""] = self._serialize_data()\n        return props\n\n    def apply_correction(self, correction):\n        self.data_y = self.data_y * correction[:, np.newaxis]\n\n    def save_data(self, parser, filename, **kwargs):\n        if self.data_y.shape[1] > 1:\n            kwargs[""header""] = [""2\xce\xb8"", ] + (not_none(self.y_names, []))\n        parser.write(filename, self.data_x, self._data_y.transpose(), **kwargs)\n\n    def load_data(self, parser, filename, clear=True):\n        """"""\n            Loads data using passed filename and parser, which are passed on to\n            the load_data_from_generator method.\n            If clear=True the x-y data is cleared first.\n        """"""\n        xrdfiles = parser.parse(filename)\n        if xrdfiles:\n            self.load_data_from_generator(xrdfiles[0].data, clear=clear)\n            \n    def load_data_from_generator(self, generator, clear=True):\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).load_data_from_generator(generator, clear=clear)\n\n    def set_data(self, x, y):\n        """"""\n            Sets data using the supplied x, y1, ..., yn arrays.\n        """"""\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).set_data(x, y)\n\n    def set_value(self, i, j, value):\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).set_value(i, j, value)\n\n    def append(self, x, y):\n        """"""\n            Appends data using the supplied x, y1, ..., yn arrays.\n        """"""\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).append(x, y)\n\n    def insert(self, pos, x, y):\n        """"""\n            Inserts data using the supplied x, y1, ..., yn arrays at the given\n            position.\n        """"""\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).insert(pos, x, y)\n\n    def remove_from_indeces(self, *indeces):\n        with self.data_changed.hold_and_emit():\n            with self.visuals_changed.hold_and_emit():\n                super(StorableXYData, self).remove_from_indeces(*indeces)\n\n    pass # end of class'"
pyxrd/mixture/models/insitu_behaviours/SSSR0Behaviour.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport scipy.stats\nfrom math import sqrt\n\nfrom mvc.models.properties.float_properties import FloatProperty\n\nfrom pyxrd.generic.io.custom_io import storables\nfrom pyxrd.refinement.refinables.properties import RefinableMixin\n\nfrom .insitu_behaviour import InSituBehaviour\n\nBEHAVIOUR_CLASS = ""SSSR0Behaviour""\n\n@storables.register()\nclass SSSR0Behaviour(InSituBehaviour):\n    """"""\n    \tBehaviour class for R0 Smectite with 3 components\n    """"""\n\n    # MODEL INTEL:\n    class Meta(InSituBehaviour.Meta):\n        store_id = ""SSSR0Behaviour""\n        concrete = True # indicates this can be instantiated and added in the UI\n\n    cation_hydration_factor = FloatProperty(\n        description=""Related to the cation hydration enthalpy"",\n        default=0.54, text=""Cation hydration factor"",\n        minimum=0.0, maximum=2.0,\n        refinable=True, persistent=True, visible=True,\n        mix_with=(RefinableMixin,)\n    )\n     \n    min_swelling_layer_charge = FloatProperty(\n        description=""The minimum layer charge required for swelling"",\n        default=-0.1, text=""Minimum swelling layer charge"",\n        minimum = -2, maximum=0,\n        refinable=True, persistent=True, visible=True,\n        mix_with=(RefinableMixin,)\n    )\n      \n    layer_charge_mean = FloatProperty(\n        description=""The mean of the normal layer charge distribution"",\n        default=-0.4, text=""Mean layer charge"",\n        minimum = -2, maximum=0,\n        refinable=True, persistent=True, visible=True,\n        mix_with=(RefinableMixin,)\n    )\n\n    layer_charge_stdev = FloatProperty(\n        default=0.05, text=""The standard deviation of the layer charges"",\n        minimum = 0.0001, maximum=0.75,\n        refinable=True, persistent=True, visible=True,\n        mix_with=(RefinableMixin,)\n    )\n        \n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        my_kwargs = self.pop_kwargs(kwargs,\n            *[prop.label for prop in SSSR0Behaviour.Meta.get_local_persistent_properties()]\n        )\n        super(SSSR0Behaviour, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n            self.cation_hydration_factor = self.get_kwarg(kwargs, self.cation_hydration_factor, ""cation_hydration_factor"")\n            self.min_swelling_layer_charge = self.get_kwarg(kwargs, self.min_swelling_layer_charge, ""min_swelling_layer_charge"")\n            self.layer_charge_mean = self.get_kwarg(kwargs, self.layer_charge_mean, ""layer_charge_mean"")\n            self.layer_charge_stdev = self.get_kwarg(kwargs, self.layer_charge_stdev, ""layer_charge_stdev"")\n            \n        pass #end of constructor\n\n            \n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def get_layer_charge_distribution(self, mean = -0.4, stdev = 0.05):        \n        distr = scipy.stats.norm(mean, stdev)\n        return distr\n\n    def get_layer_type_distribution(self, distr, boundaries):\n        """"""\n            Returns a 3-tuple with the % of layers having:\n            0 layers of water\n            1 layers of water\n            2 layers of water\n        """"""\n        (B0to1, B1to2, B2to0) = boundaries\n        cdfB0to1 = distr.cdf(B0to1) # Get # layers with B0to1 or smaller layer charge \n        cdfB1to2 = distr.cdf(B1to2) # Get # layers with B1to2 or smaller layer charge\n        cdfB2to0 = distr.cdf(B2to0) # Get # layers with B2to0 or smaller layer charge\n        total = distr.cdf(0)        # Get # layers with B2 or smaller layer charge\n        # returns fraction of 0w, 1w and 2w layers:\n        return (cdfB0to1+total-cdfB2to0)/total,(cdfB1to2-cdfB0to1)/total,(cdfB2to0-cdfB1to2)/total\n        \n    def get_layer_type_boundaries(self, RH):\n        """"""\n            Gets the layer type boundaries (expressed as layer charge)\n            in function of RH (expressed as a fraction)\n        """"""\n        RH_step_size = (self.cation_hydration_factor*sqrt(RH))\n        b2to0_RH_factor = self.min_swelling_layer_charge\n        b1to2_RH_factor = b2to0_RH_factor - RH_step_size\n        b0to1_RH_factor = b1to2_RH_factor - RH_step_size\n        \n        return b0to1_RH_factor, b1to2_RH_factor, b2to0_RH_factor\n    \n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def apply(self, phase, RH):\n        super(SSSR0Behaviour, self).apply(phase)\n\n        RH = RH / 100.\n        \n        print(""Applying SSSR0Behaviour to %s"" % phase, ""For RH: %.2f"" % RH)\n\n        # Get layer charge coundaries for the given relative humidity\n        boundaries = self.get_layer_type_boundaries(RH)\n        \n        print("" boundaries:"", boundaries)\n\n        # Get the layer charge distribution for the given phase\n        lc_distr = self.get_layer_charge_distribution(self.layer_charge_mean, self.layer_charge_stdev)\n        print("" lc_distr:"", lc_distr)\n        \n        # Calculate the layer type distribution for the calculated boundaries and distribution\n        W0, W1, W2 = self.get_layer_type_distribution(lc_distr, boundaries)\n        print("" W0:"", W0)\n        print("" W1:"", W1)\n        print("" W2:"", W2)\n        \n        # Set probability model factors:\n        phase.probabilities.F0 = W2\n        phase.probabilities.F1 = W1/(W1+W0)\n        \n        # TODO update d-spacings\n                \n    def is_compatible_with(self, phase):\n        # TODO check names of components\n        try:\n            return (phase.R == 0 and phase.G == 3)\n        except:\n            return False   \n        \n    pass\n'"
pyxrd/mixture/models/insitu_behaviours/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .insitu_behaviour import InSituBehaviour\nfrom .SSSR0Behaviour import SSSR0Behaviour\n\n__all__ = [\n    ""InSituBehaviour"",\n    ""SSSR0Behaviour""\n]\n'"
pyxrd/mixture/models/insitu_behaviours/insitu_behaviour.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom mvc.models.properties import StringProperty\n\nfrom pyxrd.generic.io.custom_io import storables, Storable\nfrom pyxrd.generic.models.base import DataModel\n\nfrom pyxrd.refinement.refinables.mixins import RefinementGroup\n\n@storables.register()\nclass InSituBehaviour(DataModel, RefinementGroup, Storable):\n    """"""\n        Interface class for coding in-situ behaviour scripts.\n        Sub-classes should override or implement the methods below.\n    """"""\n\n    # MODEL INTEL:\n    class Meta(DataModel.Meta):\n        store_id = ""InSituBehaviour"" # Override this so it is a unique string\n        concrete = False # Indicates this cannot be instantiated and added in the UI\n        \n    mixture = property(DataModel.parent.fget, DataModel.parent.fset)\n\n    # REFINEMENT GROUP IMPLEMENTATION:\n    @property\n    def refine_title(self):\n        return ""In-situ behaviour""\n\n    @property\n    def refine_descriptor_data(self):\n        return dict(\n            phase_name=self.phase.refine_title,\n            component_name=""*""\n        )\n\n    #: The name of this Behaviour\n    name = StringProperty(\n        default=""New Behaviour"", text=""Name"",\n        visible=True, persistent=True, tabular=True\n    )\n    \n    # ------------------------------------------------------------\n    #      Initialization and other internals\n    # ------------------------------------------------------------\n    def __init__(self, *args, **kwargs):\n        my_kwargs = self.pop_kwargs(kwargs,\n            *[prop.label for prop in InSituBehaviour.Meta.get_local_persistent_properties()]\n        )\n        super(InSituBehaviour, self).__init__(*args, **kwargs)\n        kwargs = my_kwargs\n\n        with self.data_changed.hold():\n            self.name = self.get_kwarg(kwargs, self.name, ""name"")\n            \n        pass #end of constructor\n            \n    # ------------------------------------------------------------\n    #      Methods & Functions\n    # ------------------------------------------------------------\n    def apply(self, phase):\n        assert phase is not None, ""Cannot apply on None""\n        assert self.is_compatible_with(phase), ""`%r` is not compatible with phase `%r`"" % (self, phase)\n                \n    def is_compatible_with(self, phase):\n        return False # sub classes need to override this \n               \n    pass #end of class'"
pyxrd/refinement/refinables/properties/__init__.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nfrom .data_mixin import DataMixin\nfrom .refinable_mixin import RefinableMixin\n\n__ALL__ = [\n    ""DataMixin"",\n    ""RefinableMixin""\n]'"
pyxrd/refinement/refinables/properties/data_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass DataMixin(object):\n    """"""\n    Mixing for the ~:class:`mvc.models.properties.LabeledProperty` descriptor\n    that allows this property to be set on the `data_object` object of the\n    instance this property belongs to, instead of a private attribute.\n    \n    When this Mixin is used, the user can pass an additional keyword \n    argument to the descriptor:\n        - data_object_label: the private attribute label for the data object,\n          defaults to \'_data_object\' \n    """"""\n\n    data_object_label = ""_data_object""\n\n    def _get_private_label(self):\n        """""" Private attribute label (holds the actual value on the model) """"""\n        return ""%s.%s"" % (\n            self.data_object_label,\n            self.label\n        )\n\n    pass'"
pyxrd/refinement/refinables/properties/refinable_mixin.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nclass RefinableMixin(object):\n    """"""\n    Mixing for the ~:class:`mvc.models.properties.LabeledProperty` descriptor\n    that allows the property to be refinable.\n    When this Mixin is used, the user should pass 4 additional keyword \n    arguments to the descriptor:\n        - refinable: boolean set to True if the property is refinable\n        - refinable_info_format: the format for the refinement info attribute\n        - minimum: the minimum allowed value (or None as default)\n        - maximum: the maximum allowed value (or None as default) \n    """"""\n\n    refinable = True\n    refinable_info_format = ""%(label)s_ref_info""\n\n    minimum = None\n    maximum = None\n\n    def get_refinement_info_name(self):\n        return self.refinable_info_format % { \'label\': self.label }\n\n    pass #end of class'"
test/test_generic/test_io/test_xrd_parsers/__init__.py,0,b''
test/test_generic/test_io/test_xrd_parsers/test_brk_raw_parser.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom test.test_generic.test_io.test_file_parsers import BaseTestParsers, load_data_from_files\n\nfrom pyxrd.file_parsers.xrd_parsers import BrkRAWParser\n\n\n__all__ = [\n    \'TestRAWParser\',\n]\n\nclass TestRAWParser(BaseTestParsers.BaseTestParser):\n\n    parser_class = BrkRAWParser\n    file_data = load_data_from_files(\n        ""test/test_generic/test_io/test_xrd_parsers/brk_raw1.raw"",\n        ""test/test_generic/test_io/test_xrd_parsers/brk_raw2.raw""\n    )\n\n    pass # end of class\n'"
test/test_generic/test_io/test_xrd_parsers/test_cpi_parser.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom io import StringIO\n\nfrom test.test_generic.test_io.test_file_parsers import BaseTestParsers\nfrom pyxrd.file_parsers.xrd_parsers import CPIParser\n\n\n__all__ = [\n    \'TestCPIParser\',\n]\n\nclass TestCPIParser(BaseTestParsers.BaseTestParser):\n\n    parser_class = CPIParser\n    file_data = [\n        StringIO(r""""""SIETRONICS XRD SCAN\n3.01\n3.73\n0.02\nCu\n1,5406\n11/10/2012 14:41:24\n2,0\n08-946 Sample\nSCANDATA\n60.0000000\n50.0000000\n40.0000000\n30.0000000\n20.0000000\n10.0000000\n5.5106383\n18.1276596\n8.7446809\n-2.6382979\n4.9787234\n-9.4042553\n15.2127660\n30.8297872\n-1.5531915\n13.0638298\n-1.3191489\n-6.7021277\n-18.0851064\n-13.4680851\n-17.8510638\n6.7659574\n1.3829787\n0.0000000\n37.6960784\n27.3921569\n12.0882353\n2.7843137\n19.4803922\n-11.8235294\n4.8725490\n21.5686275\n-19.7352941\n2.9607843\n3.6568627\n-4.6470588\n-6.9509804""""""),\n    ]\n\n    pass # end of class\n'"
test/test_generic/test_io/test_xrd_parsers/test_csv_parser.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom io import StringIO\n\nfrom test.test_generic.test_io.test_file_parsers import BaseTestParsers\nfrom pyxrd.file_parsers.xrd_parsers import CSVParser\n\n\n__all__ = [\n    \'TestCSVParser\',\n]\n\nclass TestCSVParser(BaseTestParsers.BaseTestParser):\n\n    parser_class = CSVParser\n    file_data = [\n        StringIO(r""""""""2\xce\xb8"" ""Total"" ""Illite"" ""Kaolinite"" ""Kaolinite HCSDS"" ""ISS R0 GLY"" ""KSS R0 Ca-GLY"" ""KSSS R0 Ca-GLY""\n3.02755700 273.16049233 97.02814022 31.38556697 35.59578617 23.51568141 48.65379108 94.57724147\n3.04755700 270.13870087 95.62476636 31.06940638 35.22982402 23.36216182 48.62501123 93.82324607\n3.06755700 267.22786165 94.28393668 30.76061580 34.87300927 23.21212148 48.60496947 93.08892395\n3.08755700 264.42041889 93.00398290 30.45939344 34.51998503 23.06538817 48.59361044 92.37377390\n3.10755700 261.70360562 91.77676261 30.16586741 34.16672250 22.92177298 48.59088431 91.67731080\n3.12755700 259.06212412 90.58942248 29.88008630 33.81143245 22.78108632 48.59674661 90.99906497\n3.14755700 256.48113103 89.42706605 29.60201371 33.45487360 22.64315301 48.61115803 90.33858163\n3.16755700 253.94889023 88.27574451 29.33152685 33.10000476 22.50782446 48.63408424 89.69542041\n3.18755700 251.45858095 87.12514462 29.06841908 32.75109518 22.37498655 48.66549574 89.06915477\n3.20755700 249.00896711 85.97043387 28.81240611 32.41254039 22.24456254 48.70536766 88.45937154\n3.22755700 246.60389183 84.81291555 28.56313541 32.08769488 22.11651102 48.75367958 87.86567038\n3.24755700 244.25080155 83.65940329 28.32019837 31.77801661 21.99081961 48.81041538 87.28766329\n3.26755700 241.95867992 82.52049022 28.08314451 31.48272743 21.86749559 48.87556303 86.72497414\n3.28755700 239.73585293 81.40810814 27.85149708 31.19905514 21.74655494 48.94911440 86.17723824\n3.30755700 237.58810884 80.33290306 27.62476936 30.92297304 21.62801143 49.03106510 85.64410184""""""),\n        StringIO(r""""""""2\xce\xb8"",""Total"",""Illite"",""Kaolinite"",""Kaolinite,HCSDS"",""ISS,R0,GLY"",""KSS,R0,Ca-GLY"",""KSSS,R0,Ca-GLY""\n3.02755700,273.16049233,97.02814022,31.38556697,35.59578617,23.51568141,48.65379108,94.57724147\n3.04755700,270.13870087,95.62476636,31.06940638,35.22982402,23.36216182,48.62501123,93.82324607\n3.06755700,267.22786165,94.28393668,30.76061580,34.87300927,23.21212148,48.60496947,93.08892395\n3.08755700,264.42041889,93.00398290,30.45939344,34.51998503,23.06538817,48.59361044,92.37377390\n3.10755700,261.70360562,91.77676261,30.16586741,34.16672250,22.92177298,48.59088431,91.67731080\n3.12755700,259.06212412,90.58942248,29.88008630,33.81143245,22.78108632,48.59674661,90.99906497\n3.14755700,256.48113103,89.42706605,29.60201371,33.45487360,22.64315301,48.61115803,90.33858163\n3.16755700,253.94889023,88.27574451,29.33152685,33.10000476,22.50782446,48.63408424,89.69542041\n3.18755700,251.45858095,87.12514462,29.06841908,32.75109518,22.37498655,48.66549574,89.06915477\n3.20755700,249.00896711,85.97043387,28.81240611,32.41254039,22.24456254,48.70536766,88.45937154\n3.22755700,246.60389183,84.81291555,28.56313541,32.08769488,22.11651102,48.75367958,87.86567038\n3.24755700,244.25080155,83.65940329,28.32019837,31.77801661,21.99081961,48.81041538,87.28766329\n3.26755700,241.95867992,82.52049022,28.08314451,31.48272743,21.86749559,48.87556303,86.72497414\n3.28755700,239.73585293,81.40810814,27.85149708,31.19905514,21.74655494,48.94911440,86.17723824\n3.30755700,237.58810884,80.33290306,27.62476936,30.92297304,21.62801143,49.03106510,85.64410184""""""),\n    ]\n\n    pass # end of class\n'"
test/test_generic/test_io/test_xrd_parsers/test_rd_parser.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom io import BytesIO\nfrom test.test_generic.test_io.test_file_parsers import BaseTestParsers\n\nfrom pyxrd.file_parsers.xrd_parsers import RDParser\n\n__all__ = [\n    \'TestRDParser\',\n]\n\nclass TestRDParser(BaseTestParsers.BaseTestParser):\n\n    parser_class = RDParser\n    file_data = [\n        BytesIO(r""V3RDPC-APD, Diffraction software\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00PC-APD, Diffraction software\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\x03\\00\x03\\00\x0c\\00(\\00\x1e\\00J{\\83/L\\A6\\F8?\\A0O\\E4I\xd2\xb5\\F8?\\00\\00\\00\\00\\00\\00\\E0?\\00\\00\x01\x01\\B6\\E2V\x03\x01A\x04\\00X\x02\\B8\x0b\x14\\00r\\00622M001912-644 clay form\\00\\00\\00\\00\\B6\\E2V\x03\\00\x01\\9A\\99\\99\\99\\99\\99\\C9?\\00\\00\\00\\00\\00\\00\\F0?\\00\\00\\00\\00\\00\\00\\00@\\00\\00\\00\\00\\00\\00\\E8?\\00\\00\\00\\00\\00\\00\x1e\\00\\00\\00{\x14\\AEG\\E1z\\94?\\00\\00\\00\\00\\00\\00\x08@\\00\\00\\00\\00\\00\\00.@\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00`\\00n\\00j\\00r\\00d\\00b\\00b\\00i\\00c\\00j\\00g\\00n\\00e\\00f\\00e\\00e\\00p\\00n\\00Y\\00c\\00c\\00`\\00a\\00f\\00g\\00q\\00l\\00f\\00d\\00b\\00[\\00`\\00e\\00i\\00a\\00c\\00^\\00_\\00h\\00_\\00h\\00`\\00e\\00Z\\00^\\00U\\00[\\00]\\00S\\00\\\\00\\\\00e\\00]\\00_\\00\\\\00_\\00V\\00`\\00V\\00^\\00W\\00_\\00[\\00T\\00[\\00[\\00c\\00[\\00Z\\00\\\\00R\\00b\\00^\\00h\\00[\\00X\\00]\\00V\\00U\\00`\\00W\\00W\\00P\\00W\\00[\\00]\\00\\\\00T\\00W\\00\\\\00Y\\00[\\00`\\00Q\\00\\\\00T\\00T\\00Y\\00\\\\00a\\00R\\00]\\00Y\\00Q\\00T\\00[\\00T\\00W\\00\\\\00[\\00\\\\00Y\\00Y\\00W\\00\\\\00T\\00W\\00U\\00W\\00X\\00R\\00W\\00W\\00T\\00V\\00Y\\00U\\00X\\00R\\00M\\00X\\00R\\00\\\\00R\\00W\\00P\\00Q\\00S\\00W\\00N\\00J\\00Y\\00U\\00[\\00X\\00U\\00P\\00Q\\00V\\00K\\00E\\00O\\00S\\00S\\00Q\\00O\\00N\\00R\\00U\\00Q\\00T\\00Q\\00K\\00P\\00Q\\00W\\00Q\\00U\\00O\\00L\\00S\\00[\\00Q\\00U\\00\\\\00L\\00S\\00J\\00M\\00K\\00T\\00R\\00R\\00M\\00I\\00J\\00S\\00H\\00J\\00R\\00G\\00P\\00R\\00E\\00M\\00F\\00M\\00T\\00K\\00N\\00R\\00P\\00H\\00K\\00U\\00Q\\00U\\00M\\00N\\00G\\00B\\00G\\00O\\00M\\00N\\00[\\00I\\00M\\00F\\00G\\00L\\00Q\\00O\\00I\\00E\\00[\\00F\\00L\\00G\\00J\\00I\\00M\\00P\\00I\\00Q\\00N\\00O\\00H\\00J\\00Q\\00B\\00O\\00B\\00J\\00M\\00B\\00E\\00F\\00N\\00K\\00G\\00@\\00J\\00L\\00O\\00L\\00C\\00K\\00B\\00C\\00J\\00P\\00G\\00G\\00G\\00E\\00A\\00O\\00H\\00F\\00N\\00I\\00K\\00G\\00D\\00N\\00I\\00;\\00D\\00G\\00E\\00A\\00K\\00F\\00K\\00B\\00I\\00B\\00B\\00G\\00K\\00G\\00I\\00E\\00I\\00J\\00E\\00E\\00<\\00E\\00M\\00F\\00H\\00H\\00N\\00K\\00>\\007\\00A\\00I\\00B\\00<\\00J\\00G\\00D\\00J\\00E\\00E\\00E\\00L\\00B\\00F\\00F\\00E\\00B\\00D\\008\\00A\\00;\\00C\\00G\\00I\\00E\\00F\\00E\\00;\\00J\\00E\\00D\\00D\\00D\\00I\\00?\\00R\\00;\\00H\\00;\\00>\\00B\\00I\\00@\\00G\\00<\\00@\\00D\\00;\\00>\\00C\\00I\\00G\\00:\\00I\\00A\\00E\\00B\\00G\\00L\\00A\\00I\\00C\\00J\\00G\\00B\\00B\\00E\\00A\\00B\\00>\\00A\\00?\\00<\\00E\\00>\\00@\\00:\\00A\\00@\\00B\\00<\\00F\\00H\\00:\\00>\\00<\\00B\\00A\\00E\\00:\\00K\\00C\\00?\\007\\00B\\00A\\00>\\00B\\00G\\00C\\00B\\00B\\007\\00?\\00I\\00E\\00B\\00E\\00>\\00:\\00M\\00L\\00?\\00A\\00B\\00E\\003\\009\\009\\00B\\00>\\00A\\009\\00>\\00?\\00=\\00B\\00>\\00G\\006\\00D\\00?\\006\\00E\\009\\00G\\00>\\00;\\00:\\00?\\00<\\00E\\009\\00@\\00B\\00?\\00=\\00=\\00@\\009\\00@\\00D\\00E\\00A\\00;\\00=\\00;\\002\\00<\\00=\\00G\\00>\\00B\\00@\\00=\\00G\\00;\\00>\\00=\\00B\\001\\006\\008\\00<\\00D\\00=\\009\\00J\\006\\00;\\009\\009\\00;\\00>\\00E\\009\\00=\\001\\009\\00A\\00?\\00:\\00>\\00>\\00A\\009\\00E\\008\\006\\00:\\009\\00=\\00<\\00?\\009\\00?\\00B\\006\\00=\\00=\\00@\\008\\00:\\00;\\00=\\00@\\004\\00=\\004\\006\\00;\\00B\\009\\007\\00A\\009\\005\\005\\00I\\00@\\00A\\00<\\009\\00A\\007\\00:\\005\\00/\\007\\004\\005\\00C\\009\\00>\\008\\002\\00/\\009\\009\\005\\00.\\007\\00B\\00/\\009\\00?\\00/\\002\\00B\\00>\\00<\\009\\005\\00,\\009\\003\\00;\\00/\\00.\\00:\\00>\\00>\\004\\00:\\00;\\00<\\00:\\00<\\003\\009\\006\\00H\\008\\005\\008\\009\\006\\000\\005\\004\\000\\00;\\00"".encode())\n    , ]\n\n    pass # end of class\n'"
test/test_generic/test_io/test_xrd_parsers/test_udf_parser.py,0,"b'#!/usr/bin/python\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport unittest\n\nfrom io import StringIO\n\nfrom test.test_generic.test_io.test_file_parsers import BaseTestParsers\nfrom pyxrd.file_parsers.xrd_parsers import UDFParser\n\n\n__all__ = [\n    \'TestUDFParser\',\n]\n\nclass TestUDFParser(BaseTestParsers.BaseTestParser):\n\n    parser_class = UDFParser\n    file_data = [\n        StringIO(r""""""SampleIdent,Sample5 ,/\nTitle1,Dat2rit program ,/\nTitle2,Sample5 ,/\nDataAngleRange,   5.0000, 5.6400,/\nScanStepSize,     0.020,/\nRawScan\n    8000,    7000,    6000,    5000,    4000,    3000,    2000,    1000\n    800,     700,     600,     500,     400,     300,     200,     100\n    80,      70,      60,      50,      40,      30,      20,      10\n    8,       7,       6,       5,       4,       3,       2,       1\n    0/""""""),\n    ]\n\n    pass # end of class\n'"
test/test_generic/test_models/test_treemodels/__init__.py,0,b''
test/test_generic/test_models/test_treemodels/test_base.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GObject  # @UnresolvedImport\n\nimport unittest\n\nfrom mvc.adapters.gtk_support.treemodels import BaseObjectListStore\n\n__all__ = [\n    \'TestBaseObjectListStore\',\n]\n\nclass _DummyObject(object):\n    class Meta(object):\n        @classmethod\n        def get_column_properties(cls):\n            return [\n                [""name"", str],\n                [""number"", float],\n                [""test"", object]\n            ]\n\n    def __init__(self, *args, **kwargs):\n        super(_DummyObject, self).__init__()\n        for key, val in kwargs.items():\n            setattr(self, key, val)\n\n    pass # end of class\n\nclass TestBaseObjectListStore(unittest.TestCase):\n\n    def setUp(self):\n        self.store = BaseObjectListStore(_DummyObject)\n\n    def tearDown(self):\n        del self.store\n\n    def test_setup(self):\n        self.assertNotEqual(self.store, None)\n\n    def test_columns(self):\n        self.assertEqual(self.store.get_n_columns(), len(self.store._class_type.Meta.get_column_properties()))\n        self.assertEqual(self.store.get_column_type(self.store.c_name), GObject.type_from_name(""gchararray""))\n        self.assertEqual(self.store.get_column_type(self.store.c_number), GObject.type_from_name(""gdouble""))\n        self.assertEqual(self.store.get_column_type(self.store.c_test), GObject.type_from_name(""PyObject""))\n\n    def test_convert(self):\n        self.assertEqual(self.store.convert(1, ""0.5""), 0.5)\n\n    pass # end of class\n'"
test/test_generic/test_models/test_treemodels/test_objectliststore.py,0,"b'#!/usr/bin/python\n\n# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n\n# Copyright (c) 2013, Mathijs Dumon\n# All rights reserved.\n# Complete license can be found in the LICENSE file.\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')  # @UndefinedVariable\nfrom gi.repository import GObject  # @UnresolvedImport\n\nimport unittest\n\nfrom pyxrd.generic.models import DataModel\n\nfrom mvc.adapters.gtk_support.treemodels import ObjectListStore\nfrom mvc.models.properties import (\n    LabeledProperty, StringProperty, FloatProperty\n)\n\n__all__ = [\n    \'TestObjectListStore\',\n]\n\n\nclass _DummyObject(DataModel):\n\n    name = StringProperty(text=""Name"", tabular=True, default="""")\n    number = FloatProperty(text=""Number"", tabular=True, default=0)\n    test = LabeledProperty(text=""Test"", tabular=True, default=[])\n\n    pass # end of class\n\nclass _DummyParent(DataModel):\n\n    attrib = LabeledProperty(text=""Attrib"", default=[], tabular=True, data_type=_DummyObject)\n\n    pass # end of class\n\n\nclass TestObjectListStore(unittest.TestCase):\n\n    def setUp(self):\n        self.model = _DummyParent()\n        prop = type(self.model).attrib\n        self.store = ObjectListStore(self.model, prop)\n\n    def tearDown(self):\n        super(TestObjectListStore, self).tearDown()\n        del self.model\n\n    def test_columns(self):\n        self.assertEqual(self.store.get_n_columns(), len(_DummyObject.Meta.get_column_properties()))\n        self.assertEqual(self.store.get_column_type(self.store.c_name), GObject.type_from_name(""gchararray""))\n        self.assertEqual(self.store.get_column_type(self.store.c_number), GObject.type_from_name(""gdouble""))\n        self.assertEqual(self.store.get_column_type(self.store.c_test), GObject.type_from_name(""PyObject""))\n\n    def test_convert(self):\n        self.assertEqual(self.store.convert(self.store.c_number, ""0.5""), 0.5)\n\n    # TODO:\n    # - test JSON serialisation\n    # - test raw data\n\n    pass # end of class\n'"
tests_mvc/adapters/gtk_support/dialogs/__init__.py,0,b''
tests_mvc/adapters/gtk_support/dialogs/dialog_factory.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2016 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport unittest\n\nfrom mvc.adapters.gtk_support.dialogs.dialog_factory import DialogFactory\nfrom .file_chooser_dialog_args import get_file_chooser_kwags\n\n__all__ = [\n    \'DialogFactoryTest\',\n]\n\nclass DialogFactoryTest(unittest.TestCase):\n\n\n    def setUp(self):\n        pass\n\n\n    def tearDown(self):\n        pass\n\n\n    def test_get_file_dialog(self):\n        kwargs = get_file_chooser_kwags()\n        dialog = DialogFactory.get_file_dialog(**kwargs)\n\n        self.assertEqual(dialog.get_action(), kwargs[""action""], ""Action attribute is not set correctly"")\n        self.assertEqual(dialog.get_title(), kwargs[""title""], ""Title attribute is not set correctly"")\n        self.assertEqual(dialog.get_parent(), kwargs[""parent""], ""Parent window is not set correctly"")\n        self.assertEqual(dialog.get_current_name(), kwargs[""current_name""], ""Current name attribute is not set correctly"")\n        self.assertEqual(dialog.get_current_folder(), kwargs[""current_folder""], ""Current folder attribute is not set correctly"")\n        self.assertEqual(dialog.get_extra_widget(), kwargs[""extra_widget""], ""Extra widget attribute is not set correctly"")\n        self.assertEqual(dialog.filters, kwargs[""filters""], ""Filters attribute is not set correctly"")\n        self.assertEqual(dialog.get_select_multiple(), kwargs[""multiple""], ""Multiple attribute is not set correctly"")\n        self.assertEqual(dialog.get_do_overwrite_confirmation(), kwargs[""confirm_overwrite""], ""Confirm overwrite attribute is not set correctly"")\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tests_mvc/adapters/gtk_support/dialogs/file_chooser_dialog.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2016 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport unittest\n\nfrom mvc.adapters.gtk_support.dialogs.file_chooser_dialog import FileChooserDialog\n\nfrom .file_chooser_dialog_args import get_file_chooser_kwags\nfrom mock.mock import Mock\n\n__all__ = [\n    \'FileChooserDialogTest\',\n]\n\nclass FileChooserDialogTest(unittest.TestCase):\n\n    def setUp(self):\n        self.kwargs = get_file_chooser_kwags()\n        self.dialog = FileChooserDialog(**self.kwargs)\n\n\n    def tearDown(self):\n        pass\n\n\n    def test_file_dialog_selected_globs(self):\n        \n        # Set filter:\n        filter = self.dialog.list_filters()[0] #this is a *.txt filter, at least it should be... @ReservedAssignment\n        self.dialog.set_filter(filter)\n        \n        #Act        \n        sel_globs = self.dialog.selected_globs\n        \n        #Assert\n        self.assertEqual(filter.get_name(), ""Text File"")\n        self.assertEqual(sel_globs, [""*.txt""])\n        \n        \n\n    def test_file_dialog_applies_filename_filters(self):\n        \n        no_ext_name = ""test name without extension""\n        \n        # Set filter:\n        filter = self.dialog.list_filters()[0] #this is a *.txt filter, at least it should be... @ReservedAssignment\n        self.dialog.set_filter(filter)\n        # Mock current filename\n        self.dialog.get_filename = Mock(return_value=no_ext_name)\n        \n        # Assert we are working with the filter we expect\n        self.assertEqual(filter.get_name(), ""Text File"")\n        \n        # Assert name is changed correctly\n        self.assertEqual(""%s.txt"" % no_ext_name, self.dialog.filename)\n        self.dialog.get_filename.assert_called_once_with()\n\nif __name__ == ""__main__"":\n    unittest.main()'"
tests_mvc/adapters/gtk_support/dialogs/file_chooser_dialog_args.py,0,"b'# coding=UTF-8\n# ex:ts=4:sw=4:et=on\n#  -------------------------------------------------------------------------\n#  Copyright (C) 2016 by Mathijs Dumon <mathijs dot dumon at gmail dot com>\n#\n#  mvc is a framework derived from the original pygtkmvc framework\n#  hosted at: <http://sourceforge.net/projects/pygtkmvc/>\n#\n#  mvc is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU Lesser General Public\n#  License as published by the Free Software Foundation; either\n#  version 2 of the License, or (at your option) any later version.\n#\n#  mvc is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n#  Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with this library; if not, write to the Free Software\n#  Foundation, Inc., 51 Franklin Street, Fifth Floor,\n#  Boston, MA 02110, USA.\n#  -------------------------------------------------------------------------\n\nimport os\n\nimport gi\ngi.require_version(\'Gtk\', \'3.0\')\nfrom gi.repository import Gtk\n\nfrom pyxrd.generic.io.utils import get_case_insensitive_glob\n\ndef get_file_chooser_kwags():\n    return dict(\n        action=Gtk.FileChooserAction.SAVE,\n        title=""The dialog title"",\n        parent=Gtk.Window(),\n        current_name=""suggested_file_name"",\n        current_folder=os.path.expanduser(""~""),\n        extra_widget=Gtk.Label(label=""Test Label""),\n        filters=[ (""Text File"", get_case_insensitive_glob(""*.txt"")) ],\n        multiple=False,\n        confirm_overwrite=True\n    )\n'"
