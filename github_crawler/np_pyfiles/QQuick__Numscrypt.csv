file_path,api_count,code
setup.py,0,"b""import os\r\nimport sys\r\n\r\nsys.path.append ('numscrypt')\r\nimport __base__\r\n\r\nfrom setuptools import setup\r\n\r\ndef read (*paths):\r\n\twith open (os.path.join (*paths), 'r') as aFile:\r\n\t\treturn aFile.read()\r\n\r\nsetup (\r\n\tname = 'Numscrypt',\r\n\tversion = __base__.ns_version,\r\n\tdescription = 'A tiny bit of NumPy for Transcrypt using JavaScript typed arrays',\r\n\tlong_description = (\r\n\t\tread ('README.rst') + '\\n\\n' +\r\n\t\tread ('numscrypt/license_reference.txt')\r\n\t),\r\n\tkeywords = ['transcrypt', 'numscrypt', 'numpy', 'browser'],\r\n\turl = 'https://github.com/JdeH/Numscrypt',\t\r\n\tlicense = 'Apache 2.0',\r\n\tauthor = 'Jacques de Hooge',\r\n\tauthor_email = 'jacques.de.hooge@qquick.org',\r\n\tpackages = ['numscrypt'],\r\n\tinstall_requires = [\r\n\t\t'transcrypt'\r\n\t],\r\n\tinclude_package_data = True,\r\n\tclassifiers = [\r\n\t\t'Development Status :: 2 - Pre-Alpha',\r\n\t\t'Intended Audience :: Developers',\r\n\t\t'Natural Language :: English',\r\n\t\t'License :: OSI Approved :: Apache Software License',\r\n\t\t'Topic :: Software Development :: Libraries :: Python Modules',\r\n\t\t'Operating System :: OS Independent',\r\n\t\t'Programming Language :: Python :: 3.5',\r\n\t],\r\n)\r\n"""
numscrypt/__base__.py,0,"b""ns_version = '0.0.40'\r\n"""
numscrypt/__init__.py,0,"b""# For performance reasons, real arrays or scalars and complex arrays can only be mixed in a limited way\r\n# In general real arrays in natural order are fastest\r\n# Real arrays in non-natural order are slower\r\n# Complex arrays are slowest\r\n\r\nfrom org.transcrypt.stubs.browser import __pragma__\r\n    \r\n__pragma__ ('skip')\r\nInt32Array = Float32Array = Float64Array = Array = 0\r\n__pragma__ ('noskip')\r\n    \r\nimport itertools\r\n\r\nns_ctors = {\r\n    'int32': Int32Array,\r\n    'float32': Float32Array,\r\n    'float64': Float64Array,\r\n}\r\n\r\ndef ns_complex (dtype):\r\n    return dtype in ('complex64', 'complex128')\r\n\r\ndef ns_buffertype (dtype):\r\n    return (\r\n            'float32'\r\n        if dtype == 'complex64' else\r\n            'float64'\r\n        if dtype == 'complex128' else\r\n            dtype\r\n    )\r\n    \r\ndef ns_complextype (dtype):\r\n    return (\r\n            'complex64'\r\n        if dtype == 'float32' else\r\n            'complex128'\r\n        if dtype == 'float64' else\r\n            None\r\n    )\r\n    \r\ndef ns_createbuf (imag, dtype, size):\r\n    # The buffer will truly be created if it is the real part of a matrix or if that matrix is complex\r\n    # So if the matrix is real and the buffer isn't the real part, it will not be created\r\n    return (\r\n            __new__ (ns_ctors [ns_buffertype (dtype)] (size))\r\n        if not imag or ns_complex (dtype) else\r\n            None\r\n    )\r\n    \r\nclass ndarray:\r\n    def __init__ (\r\n        self,\r\n        shape,\r\n        dtype,\r\n        \r\n        # Any fully constructed real array instance will have realbuf != None, imagbuf == None\r\n        # Any fully constructed complex array instance will have realbuf != None, imagbuf != None\r\n        realbuf = None,\r\n        imagbuf = None\r\n    ):\r\n        self.dtype = dtype\r\n        self.ns_complex = ns_complex (dtype)\r\n        \r\n        self.realbuf = realbuf\r\n        if self.ns_complex:\r\n            self.imagbuf = imagbuf\r\n            \r\n        self.setshape (shape)\r\n        \r\n    def setshape (self, shape):\r\n        self.shape = shape\r\n        self.ndim = shape.length\r\n        self.ns_nrows = shape [0]\r\n        \r\n        if self.ndim == 1:\r\n            self.size = self.ns_nrows\r\n        else:\r\n            self.ns_ncols = shape [1]\r\n            self.size = self.ns_nrows * self.ns_ncols\r\n        \r\n    def astype (self, dtype):   # Do not use to convert between real and complex arrays\r\n        result = empty (self.shape, dtype)\r\n        \r\n        result.realbuf.set (self.realbuf)\r\n        if self.ns_complex:\r\n            result.imagbuf.set (self.imagbuf)\r\n            \r\n        return result\r\n                        \r\n    def tolist (self):\r\n        if self.ns_complex:\r\n            flat = [complex (real, imag) for real, imag in zip (list (self.realbuf), list (self.imagbuf))]\r\n        else:\r\n            flat = self.realbuf\r\n            \r\n        if self.ndim == 1:\r\n            return list (flat)\r\n        else:\r\n            return [[flat [self.ns_ncols * irow + icol] for icol in range (self.ns_ncols)] for irow in range (self.ns_nrows)]\r\n                    \r\n    def __repr__ (self):\r\n        return 'array({})'.format (repr (self.tolist ()))\r\n\r\n    def __str__ (self):\r\n        if self.ndim == 1:\r\n            return str (self.tolist ())\r\n        else:\r\n            return '[\\n\\t{}\\n]\\n'.format ('\\n\\t'.join ([str (row) for row in self.tolist ()]))\r\n        \r\n    def reshape (self, shape):\r\n        if self.ndim == 1:\r\n            return array (self, self.dtype),\r\n        else:\r\n            result = array (self, self.dtype)\r\n            result.setshape (self.ns_ncols, self.ns_nrows)\r\n            return result\r\n            \r\n    def transpose (self):\r\n        if self.ndim == 1:\r\n            result = array (self, dtype)\r\n        else:\r\n            result = empty ((self.ns_ncols, self.ns_nrows), self.dtype)\r\n                \r\n            itarget = 0\r\n            if self.ns_complex:\r\n                for icol in range (self.ns_ncols):\r\n                    isource = icol\r\n                    for irow in range (self.ns_nrows):\r\n                        isource = self.ns_ncols * irow + icol\r\n                        result.imagbuf [itarget] = self.imagbuf [isource]\r\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\r\n                        isource += self.ns_ncols\r\n            else:\r\n                for icol in range (self.ns_ncols):\r\n                    isource = icol\r\n                    for irow in range (self.ns_nrows):\r\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\r\n                        isource += self.ns_ncols\r\n                    \r\n        return result\r\n                \r\n    def __getitem__ (self, key):\r\n        if self.ndim == 1:          \r\n            if type (key) == tuple:\r\n                # Slice of single dim array\r\n\r\n                if key [1] == None:\r\n                    key [1] = self.size\r\n                elif key [1] < 0:\r\n                    key [1] += self.size\r\n                \r\n                result = empty ([(key [1] - key [0]) / key [2]], self.dtype)\r\n                \r\n                itarget = 0\r\n                if self.ns_complex:\r\n                    for isource in range (*self.shape):\r\n                        result.realbuf [itarget] = self.realbuf [isource]\r\n                        result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\r\n                else:\r\n                    for isource in range (*self.shape):\r\n                        result.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\r\n                \r\n                return result\r\n            else:\r\n                # Element of single dim array\r\n            \r\n                if self.ns_complex:\r\n                    return complex (self.realbuf [key], self.imagbuf [key])\r\n                else:\r\n                    return self.realbuf [key]\r\n        else:\r\n            rowkey = key [0]\r\n            colkey = key [1]\r\n            \r\n            rowistup = type (rowkey) == tuple\r\n            colistup = type (colkey) == tuple\r\n            \r\n            if rowistup:\r\n                if rowkey [1] == None:\r\n                    rowkey [1] = self.ns_nrows\r\n                elif rowkey [1] < 0:\r\n                    rowkey [1] += self.ns_nrows\r\n                    \r\n            if colistup:\r\n                if colkey [1] == None:\r\n                    colkey [1] = self.ns_ncols\r\n                elif colkey [1] < 0:\r\n                    colkey [1] += self.ns_ncols\r\n            \r\n            if rowistup or colistup:\r\n                # Slice of multidim array\r\n            \r\n                if not rowistup:\r\n                    result = empty (((colkey [1] - colkey [0]) / colkey [2], ), self.dtype)\r\n                    \r\n                    itarget = 0\r\n                    if self.ns_complex:\r\n                        for isourcecol in range (*colkey):\r\n                            isource = self.ns_ncols * rowkey + isourcecol\r\n                            result.realbuf [itarget] = self.realbuf [isource]\r\n                            result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\r\n                    else:\r\n                        for isourcecol in range (*colkey):\r\n                            result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * rowkey + isourcecol]\r\n                elif not colistup:\r\n                    result = empty (((rowkey [1] - rowkey [0]) / rowkey [2], ), self.dtype)\r\n                    \r\n                    itarget = 0\r\n                    if self.ns_complex:\r\n                        for isourcerow in range (*rowkey):\r\n                            isource = self.ns_ncols * isourcerow + colkey\r\n                            result.realbuf [itarget] = self.realbuf [isource]\r\n                            result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\r\n                    else:\r\n                        for isourcerow in range (*rowkey):\r\n                            result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + colkey]\r\n                else:\r\n                    result = empty ((\r\n                        (key[0][1] - key[0][0]) / key [0][2],\r\n                        (key[1][1] - key[1][0]) / key [1][2]\r\n                    ), self.dtype)\r\n                                \r\n                    itarget = 0\r\n                    if self.ns_complex:\r\n                        for isourcerow in range (*rowkey):\r\n                            for isourcecol in range (*colkey):\r\n                                isource = self.ns_ncols * isourcerow + isourcecol\r\n                                result.realbuf [itarget] = self.realbuf [isource]\r\n                                result.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]                         \r\n\r\n                    else:\r\n                        for isourcerow in range (*rowkey):\r\n                            for isourcecol in range (*colkey):\r\n                                result.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + isourcecol]\r\n                            \r\n                return result\r\n            else:\r\n                # Element of multi dim array\r\n            \r\n                if self.ns_complex:\r\n                    isource = self.ns_ncols * key [0] + key [1]\r\n                    return complex (self.realbuf [isource], self.imagbuf [isource])\r\n                else:\r\n                    return self.realbuf [self.ns_ncols * key [0] + key [1]]\r\n                    \r\n    def __setitem__ (self, key, value):\r\n        if self.ndim == 1:      \r\n            if type (key) == tuple:\r\n                # Slice of single dim array\r\n                \r\n                if key [1] == None:\r\n                    key [1] = self.size\r\n                elif key [1] < 0:\r\n                    key [1] += self.size\r\n                \r\n                isource = 0\r\n                if self.ns_complex:\r\n                    for itarget in range (*self.shape):\r\n                        self.realbuf [itarget] = value.realbuf [isource]\r\n                        self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\r\n                else:\r\n                    for itarget in range (*self.shape):\r\n                        self.realbuf [itarget] = value.realbuf [__postinc__ (isource)]\r\n                \r\n                return result\r\n            else:\r\n                # Element of single dim array\r\n                \r\n                if self.ns_complex:\r\n                    if __typeof__ (value) == 'number':\r\n                        self.realbuf [key] = value\r\n                        self.imagbuf [key] = 0\r\n                    else:                   \r\n                        self.realbuf [key] = value.real\r\n                        self.imagbuf [key] = value.imag\r\n                else:\r\n                    self.realbuf [key] = value\r\n        else:\r\n            rowkey = key [0]\r\n            colkey = key [1]\r\n            \r\n            rowistup = type (rowkey) == tuple\r\n            colistup = type (colkey) == tuple\r\n            \r\n            if rowistup:\r\n                if rowkey [1] == None:\r\n                    rowkey [1] = self.ns_nrows\r\n                elif rowkey [1] < 0:\r\n                    rowkey [1] += self.ns_nrows\r\n                    \r\n            if colistup:\r\n                if colkey [1] == None:\r\n                    colkey [1] = self.ns_ncols\r\n                elif colkey [1] < 0:\r\n                    colkey [1] += self.ns_ncols\r\n                    \r\n            if rowistup or colistup:\r\n                # Slice of multi dim array\r\n                \r\n                if not rowistup:            \r\n                    isource = 0\r\n                    if self.ns_complex:\r\n                        for itargetcol in range (*colkey):\r\n                            itarget = self.ns_ncols * rowkey + itargetcol\r\n                            self.realbuf [itarget] = value.realbuf [isource]\r\n                            self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\r\n                    else:\r\n                        for itargetcol in range (*colkey):\r\n                            result.realbuf [self.ns_ncols * rowkey + itargetcol] = self.realbuf [__postinc__ (isource)]\r\n                elif not colistup:\r\n                    isource = 0\r\n                    if self.ns_complex:\r\n                        for itargetrow in range (*rowkey):\r\n                            itarget = self.ns_ncols * itargetrow + colkey\r\n                            self.realbuf [itarget] = value.realbuf [isource]\r\n                            self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\r\n                    else:\r\n                        for isourcerow in range (*rowkey):\r\n                            self.realbuf [self.ns_ncols * isourcerow + colkey] = value [__postinc__ (isource)]\r\n                else:           \r\n                    isource = 0\r\n                    if self.ns_complex:\r\n                        for itargetrow in range (*rowkey):\r\n                            for itargetcol in range (*colkey):\r\n                                itarget = self.ns_ncols * itargetrow + itargetcol\r\n                                self.realbuf [itarget] = value.realbuf [isource]\r\n                                self.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]                          \r\n                    else:\r\n                        for isourcerow in range (*rowkey):\r\n                            for isourcecol in range (*colkey):\r\n                                self.realbuf [self.ns_ncols * itargetrow + itargetcol] = value.realbuf [__postinc__ (isource)]                      \r\n            else:\r\n                # Element of multi dim array\r\n                \r\n                if self.ns_complex:\r\n                    itarget = self.ns_ncols * key [0] + key [1]\r\n                    \r\n                    if __typeof__ (value) == 'number':\r\n                        self.realbuf [itarget] = value\r\n                        self.imagbuf [itarget] = 0\r\n                    else:\r\n                        self.realbuf [itarget] = value.real\r\n                        self.imagbuf [itarget] = value.imag\r\n                    \r\n                else:\r\n                    self.realbuf [self.ns_ncols * key [0] + key [1]] = value\r\n              \r\n    def real (self):    # Returns a view, so you can assign to self via it\r\n        return ndarray (self.shape, ns_buffertype (self.dtype), self.realbuf)\r\n    \r\n    def imag (self):    # Returns a view, so you can assign self via it\r\n        return ndarray (self.shape, ns_buffertype (self.dtype), self.imagbuf)\r\n        \r\n    def __conj__ (self):\r\n        if self.ns_complex:\r\n            result = empty (self.shape, self.dtype)\r\n            result.realbuf.set (self.realbuf)\r\n            result.imagbuf = ns_createbuf (True, self.dtype, self.size)\r\n            for i in range (self.size):\r\n                result.imagbuf [i] = -self.imagbuf [i]\r\n            return result\r\n        else:\r\n            return copy (self)\r\n        \r\n    def conjugate (self):\r\n        return self.__conj__ ()\r\n        \r\n    def __neg__ (self):\r\n        result = empty (self.shape, self.dtype)\r\n        if self.ns_complex:\r\n            for i in range (self.size):\r\n                result.realbuf [i] = -self.realbuf [i]\r\n                result.imagbuf [i] = -self.imagbuf [i]\r\n        else:\r\n            for i in range (self.size):\r\n                result.realbuf [i] = -self.realbuf [i]\r\n            \r\n        return result   \r\n            \r\n    def __ns_inv__ (self):\r\n        result = empty (self.shape, self.dtype)\r\n            \r\n        if self.ns_complex:\r\n            for i in range (self.size):\r\n                real = self.realbuf [i]\r\n                imag = self.imagbuf [i]\r\n                denom = real * real + imag * imag\r\n                \r\n                result.realbuf [i] = real / denom\r\n                result.imagbuf [i] = -imag / denom\r\n        else:\r\n            for i in range (self.size):\r\n                result.realbuf [i] = 1 / self.realbuf [i]\r\n            \r\n        return result   \r\n            \r\n    def __add__ (self, other):\r\n        result = empty (self.shape, self.dtype)\r\n        \r\n        if type (other) == ndarray:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] + other.realbuf [i]\r\n                    result.imagbuf [i] = self.imagbuf [i] + other.imagbuf [i]\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] + other.realbuf [i]\r\n        else:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] + other.real\r\n                    result.imagbuf [i] = self.imagbuf [i] + other.imag\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] + other\r\n                    \r\n        return result\r\n        \r\n    def __radd__ (self, scalar):    # scalar + array -> array.__radd__ (scalar)\r\n        return self.__add__ (scalar)\r\n        \r\n    def __sub__ (self, other):\r\n        result = empty (self.shape, self.dtype)\r\n        \r\n        if type (other) == ndarray:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] - other.realbuf [i]\r\n                    result.imagbuf [i] = self.imagbuf [i] - other.imagbuf [i]\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] - other.realbuf [i]\r\n        else:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] - other.real\r\n                    result.imagbuf [i] = self.imagbuf [i] - other.imag\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] - other\r\n                    \r\n        return result\r\n        \r\n    def __rsub__ (self, scalar):    # scalar - array -> array.__rsub__ (scalar)\r\n        return self.__neg__ () .__add__ (scalar)\r\n        \r\n    def __mul__ (self, other):\r\n        result = empty (self.shape, self.dtype)\r\n        \r\n        if type (other) == ndarray:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] * other.realbuf [i] - self.imagbuf [i] * other.imagbuf [i]\r\n                    result.imagbuf [i] = self.realbuf [i] * other.imagbuf [i] + self.imagbuf [i] * other.realbuf [i]\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] * other.realbuf [i]\r\n        else:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] * other.real - self.imagbuf [i] * other.imag\r\n                    result.imagbuf [i] = self.realbuf [i] * other.imag + self.imagbuf [i] * other.real\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] * other\r\n                    \r\n        return result\r\n        \r\n    def __rmul__ (self, scalar):    # scalar * array -> array.__rmul__ (scalar)\r\n        return self.__mul__ (scalar)\r\n        \r\n    def __truediv__ (self, other):\r\n        result = empty (self.shape, self.dtype)\r\n        \r\n        if type (other) == ndarray:\r\n            if self.ns_complex:\r\n                for i in range (self.size):\r\n                    real = other.realbuf [i]\r\n                    imag = other.imagbuf [i]\r\n                    denom = real * real + imag * imag\r\n                \r\n                    result.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\r\n                    result.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] / other.realbuf [i]\r\n        else:\r\n            if self.ns_complex:\r\n                real = other.real\r\n                imag = other.imag\r\n                denom = real * real + imag * imag\r\n                \r\n                for i in range (self.size):\r\n                    result.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\r\n                    result.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\r\n            else:\r\n                for i in range (self.size):\r\n                    result.realbuf [i] = self.realbuf [i] / other\r\n                    \r\n        return result\r\n        \r\n    def __rtruediv__ (self, scalar):    # scalar / array -> array.__rdiv__ (scalar)\r\n        return self.__ns_inv__ () .__mul__ (scalar)\r\n\r\n    # prefer the python 3 __truediv__, but retain __div__ for compatibility\r\n    def __div__(self, other):\r\n        return self.__truediv__(other)\r\n\r\n    def __rdiv__(self, other):\r\n        return self.__rtruediv__(other)\r\n        \r\n    def __matmul__ (self, other):\r\n        result = empty ((self.ns_nrows, other.ns_ncols), self.dtype)\r\n        \r\n        if self.ns_complex:\r\n            iresult = 0\r\n            for irow in range (self.ns_nrows):\r\n                for icol in range (other.ns_ncols):\r\n                    result.realbuf [iresult] = 0\r\n                    result.imagbuf [iresult] = 0\r\n                    iself = self.ns_ncols * irow\r\n                    iother = icol\r\n                    for iterm in range (self.ns_ncols):\r\n                        result.realbuf [iresult] += self.realbuf [iself] * other.realbuf [iother] - self.imagbuf [iself] * other.imagbuf [iother]\r\n                        result.imagbuf [iresult] += self.realbuf [iself] * other.imagbuf [iother] + self.imagbuf [__postinc__ (iself)] * other.realbuf [iother]\r\n                        iother += other.ns_ncols\r\n                    iresult += 1\r\n        else:\r\n            iresult = 0\r\n            for irow in range (self.ns_nrows):\r\n                for icol in range (other.ns_ncols):\r\n                    result.realbuf [iresult] = 0\r\n                    iself = self.ns_ncols * irow\r\n                    iother = icol\r\n                    for iterm in range (self.ns_ncols):\r\n                        result.realbuf [iresult] += self.realbuf [__postinc__ (iself)] * other.realbuf [iother]\r\n                        iother += other.ns_ncols\r\n                    iresult += 1\r\n            \r\n        return result\r\n        \r\ndef empty (shape, dtype = 'float64'):\r\n    result = ndarray (\r\n        shape,\r\n        dtype\r\n    )\r\n    result.realbuf = ns_createbuf (False, dtype, result.size)\r\n    result.imagbuf = ns_createbuf (True, dtype, result.size)\r\n    return result\r\n    \r\ndef array (obj, dtype = 'float64'): \r\n    if Array.isArray (obj):\r\n        if len (obj):\r\n            if Array.isArray (obj [0]):\r\n                result = empty ((obj.length, obj [0] .length), dtype)\r\n                iresult = 0\r\n                if result.ns_complex:\r\n                    for irow in range (result.ns_nrows):\r\n                        for icol in range (result.ns_ncols):\r\n                            element = complex (obj [irow][icol])\r\n                            result.realbuf [iresult] = element.real\r\n                            result.imagbuf [__postinc__ (iresult)] = element.imag\r\n                else:\r\n                    for irow in range (result.ns_nrows):\r\n                        for icol in range (result.ns_ncols):\r\n                            result.realbuf [__postinc__ (iresult)] = obj [irow][icol]\r\n            else:\r\n                result = empty ((obj.length, ), dtype)\r\n                if result.ns_complex:\r\n                    for i in range (result.size):\r\n                        element = complex (obj [i])\r\n                        result.realbuf [i] = element.real \r\n                        result.imagbuf [i] = element.imag\r\n                else:\r\n                    for i in range (result.size):\r\n                        result.realbuf [i] = obj [i]\r\n        else:\r\n            result = empty ((0, ), dtype)\r\n    else:   # Assume obj is an ndarray        \r\n        result = empty (obj.shape, obj.dtype)\r\n        result.realbuf.set (obj.realbuf)        \r\n        if obj.ns_complex:\r\n            result.imagbuf.set (obj.imagbuf)       \r\n    return result\r\n        \r\ndef copy (obj):\r\n    return array (obj, obj.dtype)\r\n    \r\ndef hsplit (ary, nparts):\r\n    result = [empty ((ary.ns_nrows, ary.ns_ncols / nparts), ary.dtype) for ipart in range (nparts)]\r\n    \r\n    isource = 0\r\n    if ary.ns_complex:\r\n        for irow in range (ary.ns_nrows):\r\n            for part in result:\r\n                itarget = part.ns_ncols * irow\r\n                for icol in range (part.ns_ncols):\r\n                    part.realbuf [itarget] = ary.realbuf [isource]\r\n                    part.imagbuf [__postinc__ (itarget)] = ary.imagbuf [__postinc__ (isource)]\r\n    else:\r\n        for irow in range (ary.ns_nrows):\r\n            for part in result:\r\n                itarget = part.ns_ncols * irow\r\n                for icol in range (part.ns_ncols):\r\n                    part.realbuf [__postinc__ (itarget)] = ary.realbuf [__postinc__ (isource)]\r\n                    \r\n    return result\r\n    \r\ndef vsplit (ary, nparts):\r\n    result = [empty ((ary.ns_nrows / nparts, ary.ns_ncols), array.dtype) for ipart in range (nparts)]\r\n\r\n    isource = 0\r\n    if ary.ns_complex:\r\n        for part in result:\r\n            for itarget in range (part.size):\r\n                part.realbuf [itarget] = ary.realbuf [isource]\r\n                part.imagbuf [itarget] = ary.imagbuf [__postinc__ (isource)]\r\n    else:\r\n        for part in result:\r\n            for itarget in range (part.size):\r\n                part.realbuf [itarget] = ary.realbuf [__postinc__ (isource)]\r\n                    \r\n    return result\r\n    \r\ndef hstack (tup):\r\n    ncols = 0\r\n    for part in tup:\r\n        ncols += part.ns_ncols\r\n                \r\n    result = empty ((tup [0] .ns_nrows, ncols), tup [0] .dtype)\r\n    \r\n    itarget = 0\r\n    if result.ns_complex:\r\n        for irow in range (result.ns_nrows):\r\n            for part in tup:\r\n                isource = part.ns_ncols * irow\r\n                for icol in range (part.ns_ncols):\r\n                    result.realbuf [itarget] = part.realbuf [isource]\r\n                    result.imagbuf [__postinc__ (itarget)] = part.imagbuf [__postinc__ (isource)]\r\n    else:\r\n        for irow in range (result.ns_nrows):\r\n            for part in tup:\r\n                isource = part.ns_ncols * irow\r\n                for icol in range (part.ns_ncols):\r\n                    result.realbuf [__postinc__ (itarget)] = part.realbuf [__postinc__ (isource)]\r\n                \r\n    return result\r\n    \r\ndef vstack (tup):\r\n    nrows = 0\r\n    for part in tup:\r\n        nrows += part.ns_nrows\r\n        \r\n    result = empty ((nrows, tup [0].ns_ncols), tup [0] .dtype)\r\n    \r\n    itarget = 0\r\n    if result.ns_complex:\r\n        for part in tup:\r\n            for isource in range (part.size):\r\n                result.realbuf [itarget] = part.realbuf [isource]\r\n                result.imagbuf [__postinc__ (itarget)] = part.imagbuf [isource]\r\n    else:\r\n        for part in tup:\r\n            for isource in range (part.size):\r\n                result.realbuf [__postinc__ (itarget)] = part.realbuf [isource]\r\n                \r\n    return result\r\n            \r\ndef round (a, decimals = 0):    # Truncation rather than bankers rounding, for speed\r\n    result = empty (a.shape, a.dtype)\r\n\r\n    if a.ns_complex:\r\n        for i in range (a.size):\r\n            result.realbuf [i] = a.realbuf [i] .toFixed (decimals)\r\n            result.imagbuf [i] = a.imagbuf [i] .toFixed (decimals)\r\n    else:\r\n        for i in range (a.size):\r\n            result.realbuf [i] = a.realbuf [i] .toFixed (decimals)\r\n        \r\n    return result\r\n        \r\ndef zeros (shape, dtype = 'float64'):\r\n    result = empty (shape, dtype)\r\n\r\n    if result.ns_complex:\r\n        for i in range (result.size):\r\n            result.realbuf [i] = 0\r\n            result.imagbuf [i] = 0\r\n    else:\r\n        for i in range (result.size):\r\n            result.realbuf [i] = 0\r\n            \r\n    return result\r\n    \r\ndef ones (shape, dtype = 'float64'):\r\n    result = empty (shape, dtype)\r\n    \r\n    if result.ns_complex:\r\n        for i in range (result.size):\r\n            result.realbuf [i] = 1\r\n            result.imagbuf [i] = 0\r\n    else:\r\n        for i in range (result.size):\r\n            result.realbuf [i] = 1\r\n            \r\n    return result\r\n    \r\ndef identity (n, dtype = 'float64'):\r\n    result = zeros ((n, n), dtype)\r\n    \r\n    i = 0\r\n    shift = n + 1\r\n    for j in range (n):\r\n        result.realbuf [i] = 1\r\n        i += shift\r\n    \r\n    return result\r\n    \r\ndef conjugate (x):\r\n    return x.__conj__ ()\r\n        \r\n"""
numscrypt/random.py,0,"b""import numscrypt as ns\r\n\r\ndef rand (*dims):\r\n\tresult = ns.empty (dims, 'float64')\r\n\tfor i in range (result.size):\r\n\t\tresult.realbuf [i] = Math.random ()\r\n\treturn result\r\n\t"""
numscrypt/fft/__init__.py,0,"b'__pragma__ (\'noanno\')\r\n\r\nimport numscrypt as ns\r\n\r\n__pragma__ (\'js\', \'{}\', __include__ (\'numscrypt/fft/__javascript__/fft_nayuki_precalc_fixed.js\') .replace (\'// ""use strict"";\', \'\'))\r\n\r\ndef fft (a, ns_fftn = None):\r\n\tfftn = ns_fftn if ns_fftn else __new__ (FFTNayuki (a.size))\r\n\tresult = ns.copy (a)\r\n\tfftn.forward (result.real () .realbuf, result.imag () .realbuf)\r\n\treturn result\r\n\r\ndef ifft (a, ns_fftn = None):\r\n\tfftn = ns_fftn if ns_fftn else __new__ (FFTNayuki (a.size))\r\n\treal = a.real () .__div__ (a.size)\t# Avoid complex division for efficiency\r\n\timag = a.imag () .__div__ (a.size)\r\n\tfftn.inverse (real.realbuf, imag.realbuf)\r\n\treturn ns.ndarray (real.shape, a.dtype, real.realbuf, imag.realbuf) \r\n\t\r\ndef fft2 (a, ns_fftn = None):\r\n\tif a.ns_nrows != a.ns_ncols:\r\n\t\traise \'Matrix isn\\\'t square\'\r\n\tfftn = ns_fftn if ns_fftn else __new__ (FFTNayuki (a.ns_nrows))\r\n\tresult = ns.empty (a.shape, a.dtype)\r\n\tfor irow in range (a.ns_nrows):\r\n\t\t__pragma__ (\'opov\')\r\n\t\tresult [irow, : ] = fft (a [irow, : ], fftn)\r\n\t\t__pragma__ (\'noopov\')\r\n\t\t\r\n\tfor icol in range (a.ns_ncols):\r\n\t\t__pragma__ (\'opov\')\r\n\t\tresult [ : , icol] = fft (result [ : , icol], fftn)\r\n\t\t__pragma__ (\'noopov\')\r\n\treturn result\r\n\t\r\ndef ifft2 (a, ns_fftn = None):\r\n\tif a.ns_nrows != a.ns_ncols:\r\n\t\traise \'Matrix isn\\\'t square\'\r\n\tfftn = ns_fftn if ns_fftn else __new__ (FFTNayuki (a.ns_nrows))\r\n\tresult = ns.empty (a.shape, a.dtype)\r\n\r\n\tfor irow in range (a.ns_nrows):\r\n\t\t__pragma__ (\'opov\')\r\n\t\tresult [irow, : ] = ifft (a [irow, : ], fftn)\r\n\t\t__pragma__ (\'noopov\')\r\n\t\t\r\n\tfor icol in range (a.ns_ncols):\r\n\t\t__pragma__ (\'opov\')\r\n\t\tresult [ : , icol] = ifft (result [ : , icol], fftn)\r\n\t\t__pragma__ (\'noopov\')\r\n\treturn result\r\n'"
numscrypt/linalg/__init__.py,0,"b""import numscrypt as ns\nimport numscrypt.linalg.eigen_mpmath as eigen\n\ndef inv (a):\n\t# Work directly with flat data atoms in natural order speeds up by factor 70 (!)\n\tif a.ns_complex:\n\t\treturn cinv (a)\n\telse:\n\t\treturn rinv (a)\n\ndef rinv (a):\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\treal = b.realbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not real [ipiv * ncols + ipiv]:\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tif real [irow * ncols + ipiv]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\ttemp = real [irow * ncols + icol]\n\t\t\t\t\t\treal [irow * ncols + icol] = b [ipiv * ncols + icol]\n\t\t\t\t\t\treal [ipiv * ncols + icol] = temp\n\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\n\t\t# Make pivot element 1\n\t\tpiv = real [ipiv * ncols + ipiv]\n\t\tfor icol in range (ipiv, ncols):\n\t\t\treal [ipiv * ncols + icol] /= piv\n\t\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv:\n\t\t\t\tfactor = real [irow * ncols + ipiv]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\treal [irow * ncols + icol] -= factor * real [ipiv * ncols + icol]\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n\t\ndef cinv (a):\t# for speed, don't use 'complex' or operator overloading\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\t\n\treal = b.realbuf\n\timag = b.imagbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\t\tipiv_flat = ipiv * ncols + ipiv\n\t\t\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not (real [ipiv_flat] or imag [ipiv_flat]):\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tiswap = irow * ncols + ipiv\n\t\t\t\tif real [iswap] or imag [iswap]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\tisource = irow * ncols + icol\n\t\t\t\t\t\titarget = ipiv * ncols + icol\n\t\t\t\t\t\t\n\t\t\t\t\t\ttemp = real [isource]\n\t\t\t\t\t\treal [isource] = real [itarget]\n\t\t\t\t\t\treal [itarget] = temp\n\t\t\t\t\t\t\n\t\t\t\t\t\ttemp = imag [isource_flat]\n\t\t\t\t\t\timag [isource] = imag [itarget]\n\t\t\t\t\t\timag [itarget] = temp\n\t\t\t\t\tbreak\n\t\t\n\t\t# Make pivot element 1\n\t\tpivre = real [ipiv_flat]\n\t\tpivim = imag [ipiv_flat]\n\t\t\n\t\tdenom = pivre * pivre + pivim * pivim\n\t\t\n\t\tfor icol in range (ipiv, ncols):\n\t\t\ticur = ipiv * ncols + icol\n\t\t\t\n\t\t\toldre = real [icur]\n\t\t\toldim = imag [icur]\n\n\t\t\treal [icur] = (oldre * pivre + oldim * pivim) / denom\t\t\t\n\t\t\timag [icur] = (oldim * pivre - oldre * pivim) / denom\n\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv: \n\t\t\t\tifac = irow * ncols + ipiv\n\t\t\t\tfacre = real [ifac]\n\t\t\t\tfacim = imag [ifac]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\titarget = irow * ncols + icol\n\t\t\t\t\tisource = ipiv * ncols + icol\n\t\t\t\t\t\n\t\t\t\t\toldre = real [isource]\n\t\t\t\t\toldim = imag [isource]\n\t\t\t\t\t\n\t\t\t\t\treal [itarget] -= (facre * oldre - facim * oldim)\n\t\t\t\t\timag [itarget] -= (facre * oldim + facim * oldre)\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n                    \ndef norm (a):\n    result = 0\n    \n    if a.ns_complex:\n        for i in range (a.size):\n            result += a.realbuf [i] * a.realbuf [i] + a.imagbuf [i] * a.imagbuf [i]\n    else:\n        for i in range (a.size):\n            result += a.realbuf [i] * a.realbuf [i]\n            \n    return Math.sqrt (result)\n    \ndef eig (a):    # Everything presumed complex for now\n    evals, evecs = eigen.eig (a)\n    \n    nrows, ncols = evecs.shape\n    real = evecs.realbuf\n    imag = evecs.imagbuf\n    \n    for icol in range (ncols):\n        sum = 0\n        \n        for irow in range (nrows):\n            iterm = irow * ncols + icol\n            sum += (real [iterm] * real [iterm] + imag [iterm] * imag [iterm])\n            \n        norm = Math.sqrt (sum)\n            \n        for irow in range (nrows):\n            iterm = irow * ncols + icol\n            real [iterm] /= norm\n            imag [iterm] /= norm\n            \n    return ns.array (evals, 'complex64'), evecs\n    """
numscrypt/linalg/eigen_mpmath - Copy.py,0,"b'##################################################################################################\n#\n# This module is an almost literal transcription of mpmath.matrix.eigen.py\n#\n# Copyright (C) 2005-2017 Fredrik Johansson and mpmath contributors\n# (w.r.t. the mpmath library as a whole)\n#\n# Copyright (C) 2013 Timo Hartmann, mpmath contributor\n# (w.r.t this specific module for the eigenvalue problem)\n#\n# All rights reserved.\n#\n# The whole of mpmath is distributed under the New or Revised BSD 3-clause License:\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#   a. Redistributions of source code must retain the above copyright notice,\n#      this list of conditions and the following disclaimer.\n#   b. Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#   c. Neither the name of mpmath nor the names of its contributors\n#      may be used to endorse or promote products derived from this software\n#      without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n# DAMAGE.\n#\n##################################################################################################\n\n""""""\nThe eigenvalue problem\n----------------------\n\nThis file contains routines for the eigenvalue problem.\n\nhigh level routines:\n\n  hessenberg : reduction of a real or complex square matrix to upper Hessenberg form\n  schur : reduction of a real or complex square matrix to upper Schur form\n  eig : eigenvalues and eigenvectors of a real or complex square matrix\n\nlow level routines:\n\n  hessenberg_reduce_0 : reduction of a real or complex square matrix to upper Hessenberg form\n  hessenberg_reduce_1 : auxiliary routine to hessenberg_reduce_0\n  qr_step : a single implicitly shifted QR step for an upper Hessenberg matrix\n  hessenberg_qr : Schur decomposition of an upper Hessenberg matrix\n  eig_tr_r : right eigenvectors of an upper triangular matrix\n  eig_tr_l : left  eigenvectors of an upper triangular matrix\n""""""\n\nclass Eigen(object):\n    pass\n\ndef defun(f):\n    setattr(Eigen, f.__name__, f)\n\ndef hessenberg_reduce_0(ctx, A, T):\n    """"""\n    This routine computes the (upper) Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is calculated such that\n\n               Q\' A Q = H              and             Q\' Q = Q Q\' = 1\n\n    where H is an upper Hessenberg matrix, meaning that it only contains zeros\n    below the first subdiagonal. Here \' denotes the hermitian transpose (i.e.\n    transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains the square matrix A of\n                dimension (n,n). On output, A contains a compressed representation\n                of Q and H.\n      T         (output) An array of length n containing the first elements of\n                the Householder reflectors.\n    """"""\n\n    # internally we work with householder reflections from the right.\n    # let u be a row vector (i.e. u[i]=A[i,:i]). then\n    # Q is build up by reflectors of the type (1-v\'v) where v is a suitable\n    # modification of u. these reflectors are applyed to A from the right.\n    # because we work with reflectors from the right we have to start with\n    # the bottom row of A and work then upwards (this corresponds to\n    # some kind of RQ decomposition).\n    # the first part of the vectors v (i.e. A[i,:(i-1)]) are stored as row vectors\n    # in the lower left part of A (excluding the diagonal and subdiagonal).\n    # the last entry of v is stored in T.\n    # the upper right part of A (including diagonal and subdiagonal) becomes H.\n\n\n    n = A.rows\n    if n <= 2: return\n\n    for i in range(n-1, 1, -1):\n\n        # scale the vector\n\n        scale = 0\n        for k in range(0, i):\n            scale += abs(ctx.re(A[i,k])) + abs(ctx.im(A[i,k]))\n\n        scale_inv = 0\n        if scale != 0:\n            scale_inv = 1 / scale\n\n        if scale == 0 or ctx.isinf(scale_inv):\n            # sadly there are floating point numbers not equal to zero whose reciprocal is infinity\n            T[i] = 0\n            A[i,i-1] = 0\n            continue\n\n        # calculate parameters for housholder transformation\n\n        H = 0\n        for k in range(0, i):\n            A[i,k] *= scale_inv\n            rr = ctx.re(A[i,k])\n            ii = ctx.im(A[i,k])\n            H += rr * rr + ii * ii\n\n        F = A[i,i-1]\n        f = abs(F)\n        G = ctx.sqrt(H)\n        A[i,i-1] = - G * scale\n\n        if f == 0:\n            T[i] = G\n        else:\n            ff = F / f\n            T[i] = F + G * ff\n            A[i,i-1] *= ff\n\n        H += G * f\n        H = 1 / ctx.sqrt(H)\n\n        T[i] *= H\n        for k in range(0, i - 1):\n            A[i,k] *= H\n\n        for j in range(0, i):\n            # apply housholder transformation (from right)\n\n            G = ctx.conj(T[i]) * A[j,i-1]\n            for k in range(0, i-1):\n                G += ctx.conj(A[i,k]) * A[j,k]\n\n            A[j,i-1] -= G * T[i]\n            for k in range(0, i-1):\n                A[j,k] -= G * A[i,k]\n\n        for j in range(0, n):\n            # apply housholder transformation (from left)\n\n            G = T[i] * A[i-1,j]\n            for k in range(0, i-1):\n                G += A[i,k] * A[k,j]\n\n            A[i-1,j] -= G * ctx.conj(T[i])\n            for k in range(0, i-1):\n                A[k,j] -= G * ctx.conj(A[i,k])\n\n\n\ndef hessenberg_reduce_1(ctx, A, T):\n    """"""\n    This routine forms the unitary matrix Q described in hessenberg_reduce_0.\n\n    parameters:\n      A    (input/output) On input, A is the same matrix as delivered by\n           hessenberg_reduce_0. On output, A is set to Q.\n\n      T    (input) On input, T is the same array as delivered by hessenberg_reduce_0.\n    """"""\n\n    n = A.rows\n\n    if n == 1:\n        A[0,0] = 1\n        return\n\n    A[0,0] = A[1,1] = 1\n    A[0,1] = A[1,0] = 0\n\n    for i in range(2, n):\n        if T[i] != 0:\n\n            for j in range(0, i):\n                G = T[i] * A[i-1,j]\n                for k in range(0, i-1):\n                    G += A[i,k] * A[k,j]\n\n                A[i-1,j] -= G * ctx.conj(T[i])\n                for k in range(0, i-1):\n                    A[k,j] -= G * ctx.conj(A[i,k])\n\n        A[i,i] = 1\n        for j in range(0, i):\n            A[j,i] = A[i,j] = 0\n\n\n\n@defun\ndef hessenberg(ctx, A, overwrite_a = False):\n    """"""\n    This routine computes the Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = H                and               Q\' Q = Q Q\' = 1\n\n    where H is an upper right Hessenberg matrix. Here \' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      H : an upper right Hessenberg matrix\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, H = mp.hessenberg(A)\n      >>> mp.nprint(H, 3) # doctest:+SKIP\n      [  3.15  2.23  4.44]\n      [-0.769  4.85  3.05]\n      [   0.0  3.61   7.0]\n      >>> print(mp.chop(A - Q * H * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    return value:   (Q, H)\n    """"""\n\n    n = A.rows\n\n    if n == 1:\n        return (ctx.matrix([[1]]), A)\n\n    if not overwrite_a:\n        A = A.copy()\n\n    T = ctx.matrix(n, 1)\n\n    hessenberg_reduce_0(ctx, A, T)\n    Q = A.copy()\n    hessenberg_reduce_1(ctx, Q, T)\n\n    for x in range(n):\n        for y in range(x+2, n):\n            A[y,x] = 0\n\n    return Q, A\n\n\n###########################################################################\n\n\ndef qr_step(ctx, n0, n1, A, Q, shift):\n    """"""\n    This subroutine executes a single implicitly shifted QR step applied to an\n    upper Hessenberg matrix A. Given A and shift as input, first an QR\n    decomposition is calculated:\n\n      Q R = A - shift * 1 .\n\n    The output is then following matrix:\n\n      R Q + shift * 1\n\n    parameters:\n      n0, n1    (input) Two integers which specify the submatrix A[n0:n1,n0:n1]\n                on which this subroutine operators. The subdiagonal elements\n                to the left and below this submatrix must be deflated (i.e. zero).\n                following restriction is imposed: n1>=n0+2\n      A         (input/output) On input, A is an upper Hessenberg matrix.\n                On output, A is replaced by ""R Q + shift * 1""\n      Q         (input/output) The parameter Q is multiplied by the unitary matrix\n                Q arising from the QR decomposition. Q can also be false, in which\n                case the unitary matrix Q is not computated.\n      shift     (input) a complex number specifying the shift. idealy close to an\n                eigenvalue of the bottemmost part of the submatrix A[n0:n1,n0:n1].\n\n    references:\n      Stoer, Bulirsch - Introduction to Numerical Analysis.\n      Kresser : Numerical Methods for General and Structured Eigenvalue Problems\n    """"""\n\n    # implicitly shifted and bulge chasing is explained at p.398/399 in ""Stoer, Bulirsch - Introduction to Numerical Analysis""\n    # for bulge chasing see also ""Watkins - The Matrix Eigenvalue Problem"" sec.4.5,p.173\n\n    # the Givens rotation we used is determined as follows: let c,s be two complex\n    # numbers. then we have following relation:\n    #\n    #     v = sqrt(|c|^2 + |s|^2)\n    #\n    #     1/v [ c~  s~]  [c] = [v]\n    #         [-s   c ]  [s]   [0]\n    #\n    # the matrix on the left is our Givens rotation.\n\n    n = A.rows\n\n    # first step\n\n    # calculate givens rotation\n    c = A[n0  ,n0] - shift\n    s = A[n0+1,n0]\n\n    v = ctx.hypot(ctx.hypot(ctx.re(c), ctx.im(c)), ctx.hypot(ctx.re(s), ctx.im(s)))\n\n    if v == 0:\n        v = 1\n        c = 1\n        s = 0\n    else:\n        c /= v\n        s /= v\n\n    for k in range(n0, n):\n        # apply givens rotation from the left\n        x = A[n0  ,k]\n        y = A[n0+1,k]\n        A[n0  ,k] = ctx.conj(c) * x + ctx.conj(s) * y\n        A[n0+1,k] =         -s  * x +          c  * y\n\n    for k in range(min(n1, n0+3)):\n        # apply givens rotation from the right\n        x = A[k,n0  ]\n        y = A[k,n0+1]\n        A[k,n0  ] =           c  * x +          s  * y\n        A[k,n0+1] = -ctx.conj(s) * x + ctx.conj(c) * y\n\n    if not isinstance(Q, bool):\n        for k in range(n):\n            # eigenvectors\n            x = Q[k,n0  ]\n            y = Q[k,n0+1]\n            Q[k,n0  ] =           c  * x +          s  * y\n            Q[k,n0+1] = -ctx.conj(s) * x + ctx.conj(c) * y\n\n    # chase the bulge\n\n    for j in range(n0, n1 - 2):\n        # calculate givens rotation\n\n        c = A[j+1,j]\n        s = A[j+2,j]\n\n        v = ctx.hypot(ctx.hypot(ctx.re(c), ctx.im(c)), ctx.hypot(ctx.re(s), ctx.im(s)))\n\n        if v == 0:\n            A[j+1,j] = 0\n            v = 1\n            c = 1\n            s = 0\n        else:\n            A[j+1,j] = v\n            c /= v\n            s /= v\n\n        A[j+2,j] = 0\n\n        for k in range(j+1, n):\n            # apply givens rotation from the left\n            x = A[j+1,k]\n            y = A[j+2,k]\n            A[j+1,k] = ctx.conj(c) * x + ctx.conj(s) * y\n            A[j+2,k] =         -s  * x +          c  * y\n\n        for k in range(0, min(n1, j+4)):\n            # apply givens rotation from the right\n            x = A[k,j+1]\n            y = A[k,j+2]\n            A[k,j+1] =           c  * x +          s  * y\n            A[k,j+2] = -ctx.conj(s) * x + ctx.conj(c) * y\n\n        if not isinstance(Q, bool):\n            for k in range(0, n):\n                # eigenvectors\n                x = Q[k,j+1]\n                y = Q[k,j+2]\n                Q[k,j+1] =           c  * x +          s  * y\n                Q[k,j+2] = -ctx.conj(s) * x + ctx.conj(c) * y\n\n\n\ndef hessenberg_qr(ctx, A, Q):\n    """"""\n    This routine computes the Schur decomposition of an upper Hessenberg matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = R                   and                  Q\' Q = Q Q\' = 1\n\n    where R is an upper right triangular matrix. Here \' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains an upper Hessenberg matrix.\n                On output, A is replace by the upper right triangluar matrix R.\n\n      Q         (input/output) The parameter Q is multiplied by the unitary\n                matrix Q arising from the Schur decomposition. Q can also be\n                false, in which case the unitary matrix Q is not computated.\n    """"""\n\n    n = A.rows\n\n    norm = 0\n    for x in range(n):\n        for y in range(min(x+2, n)):\n            norm += ctx.re(A[y,x]) ** 2 + ctx.im(A[y,x]) ** 2\n    norm = ctx.sqrt(norm) / n\n\n    if norm == 0:\n        return\n\n    n0 = 0\n    n1 = n\n\n    eps = ctx.eps / (100 * n)\n    maxits = ctx.dps * 4\n\n    its = totalits = 0\n\n    while 1:\n        # kressner p.32 algo 3\n        # the active submatrix is A[n0:n1,n0:n1]\n\n        k = n0\n\n        while k + 1 < n1:\n            s = abs(ctx.re(A[k,k])) + abs(ctx.im(A[k,k])) + abs(ctx.re(A[k+1,k+1])) + abs(ctx.im(A[k+1,k+1]))\n            if s < eps * norm:\n                s = norm\n            if abs(A[k+1,k]) < eps * s:\n                break\n            k += 1\n\n        if k + 1 < n1:\n            # deflation found at position (k+1, k)\n\n            A[k+1,k] = 0\n            n0 = k + 1\n\n            its = 0\n\n            if n0 + 1 >= n1:\n                # block of size at most two has converged\n                n0 = 0\n                n1 = k + 1\n                if n1 < 2:\n                    # QR algorithm has converged\n                    return\n        else:\n            if (its % 30) == 10:\n                # exceptional shift\n                shift = A[n1-1,n1-2]\n            elif (its % 30) == 20:\n                # exceptional shift\n                shift = abs(A[n1-1,n1-2])\n            elif (its % 30) == 29:\n                # exceptional shift\n                shift = norm\n            else:\n                #    A = [ a b ]       det(x-A)=x*x-x*tr(A)+det(A)\n                #        [ c d ]\n                #\n                # eigenvalues bad:   (tr(A)+sqrt((tr(A))**2-4*det(A)))/2\n                #     bad because of cancellation if |c| is small and |a-d| is small, too.\n                #\n                # eigenvalues good:     (a+d+sqrt((a-d)**2+4*b*c))/2\n\n                t =  A[n1-2,n1-2] + A[n1-1,n1-1]\n                s = (A[n1-1,n1-1] - A[n1-2,n1-2]) ** 2 + 4 * A[n1-1,n1-2] * A[n1-2,n1-1]\n                if ctx.re(s) > 0:\n                    s = ctx.sqrt(s)\n                else:\n                    s = ctx.sqrt(-s) * 1j\n                a = (t + s) / 2\n                b = (t - s) / 2\n                if abs(A[n1-1,n1-1] - a) > abs(A[n1-1,n1-1] - b):\n                    shift = b\n                else:\n                    shift = a\n\n            its += 1\n            totalits += 1\n\n            qr_step(ctx, n0, n1, A, Q, shift)\n\n            if its > maxits:\n                raise RuntimeError(""qr: failed to converge after %d steps"" % its)\n\n\n@defun\ndef schur(ctx, A, overwrite_a = False):\n    """"""\n    This routine computes the Schur decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = R                and               Q\' Q = Q Q\' = 1\n\n    where R is an upper right triangular matrix. Here \' denotes the\n    hermitian transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      R : an upper right triangular matrix\n\n    return value:   (Q, R)\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, R = mp.schur(A)\n      >>> mp.nprint(R, 3) # doctest:+SKIP\n      [2.0  0.417  -2.53]\n      [0.0    4.0  -4.74]\n      [0.0    0.0    9.0]\n      >>> print(mp.chop(A - Q * R * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    warning: The Schur decomposition is not unique.\n    """"""\n\n    n = A.rows\n\n    if n == 1:\n        return (ctx.matrix([[1]]), A)\n\n    if not overwrite_a:\n        A = A.copy()\n\n    T = ctx.matrix(n, 1)\n\n    hessenberg_reduce_0(ctx, A, T)\n    Q = A.copy()\n    hessenberg_reduce_1(ctx, Q, T)\n\n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(ctx, A, Q)\n\n    return Q, A\n\n\ndef eig_tr_r(ctx, A):\n    """"""\n    This routine calculates the right eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      ER     a matrix whose columns form the right eigenvectors of A\n\n    return value: ER\n    """"""\n\n    # this subroutine is inspired by the lapack routines ctrevc.f,clatrs.f\n\n    n = A.rows\n\n    ER = ctx.eye(n)\n\n    eps = ctx.eps\n\n    unfl = ctx.ldexp(ctx.one, -ctx.prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / ctx.sqrt(eps)\n\n    rmax = 1\n\n    for i in range(1, n):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i - 1, -1, -1):\n\n            r = 0\n            for k in range(j + 1, i + 1):\n                r += A[j,k] * ER[k,i]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            ER[j,i] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(j, i+1):\n                    ER[k,i] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(0, i + 1):\n                ER[k,i] /= rmax\n\n    return ER\n\ndef eig_tr_l(ctx, A):\n    """"""\n    This routine calculates the left eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      EL     a matrix whose rows form the left eigenvectors of A\n\n    return value:  EL\n    """"""\n\n    n = A.rows\n\n    EL = ctx.eye(n)\n\n    eps = ctx.eps\n\n    unfl = ctx.ldexp(ctx.one, -ctx.prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / ctx.sqrt(eps)\n\n    rmax = 1\n\n    for i in range(0, n - 1):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i + 1, n):\n\n            r = 0\n            for k in range(i, j):\n                r += EL[i,k] * A[k,j]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            EL[i,j] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(i, j + 1):\n                    EL[i,k] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(i, n):\n                EL[i,k] /= rmax\n\n    return EL\n\n@defun\ndef eig(ctx, A, left = False, right = True, overwrite_a = False):\n    """"""\n    This routine computes the eigenvalues and optionally the left and right\n    eigenvectors of a square matrix A. Given A, a vector E and matrices ER\n    and EL are calculated such that\n\n                        A ER[:,i] =         E[i] ER[:,i]\n                EL[i,:] A         = EL[i,:] E[i]\n\n    E contains the eigenvalues of A. The columns of ER contain the right eigenvectors\n    of A whereas the rows of EL contain the left eigenvectors.\n\n\n    input:\n      A           : a real or complex square matrix of shape (n, n)\n      left        : if true, the left eigenvectors are calulated.\n      right       : if true, the right eigenvectors are calculated.\n      overwrite_a : if true, allows modification of A which may improve\n                    performance. if false, A is not modified.\n\n    output:\n      E    : a list of length n containing the eigenvalues of A.\n      ER   : a matrix whose columns contain the right eigenvectors of A.\n      EL   : a matrix whose rows contain the left eigenvectors of A.\n\n    return values:\n       E            if left and right are both false.\n      (E, ER)       if right is true and left is false.\n      (E, EL)       if left is true and right is false.\n      (E, EL, ER)   if left and right are true.\n\n\n    examples:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, ER = mp.eig(A)\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n\n    warning:\n     - If there are multiple eigenvalues, the eigenvectors do not necessarily\n       span the whole vectorspace, i.e. ER and EL may have not full rank.\n       Furthermore in that case the eigenvectors are numerical ill-conditioned.\n     - In the general case the eigenvalues have no natural order.\n\n    see also:\n      - eigh (or eigsy, eighe) for the symmetric eigenvalue problem.\n      - eig_sort for sorting of eigenvalues and eigenvectors\n    """"""\n\n    n = A.rows\n\n    if n == 1:\n        if left and (not right):\n            return ([A[0]], ctx.matrix([[1]]))\n\n        if right and (not left):\n            return ([A[0]], ctx.matrix([[1]]))\n\n        return ([A[0]], ctx.matrix([[1]]), ctx.matrix([[1]]))\n\n    if not overwrite_a:\n        A = A.copy()\n\n    T = ctx.zeros(n, 1)\n\n    hessenberg_reduce_0(ctx, A, T)\n\n    if left or right:\n        Q = A.copy()\n        hessenberg_reduce_1(ctx, Q, T)\n    else:\n        Q = False\n\n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(ctx, A, Q)\n\n    E = [0 for i in range(n)]\n    for i in range(n):\n        E[i] = A[i,i]\n\n    if not (left or right):\n        return E\n\n    if left:\n        EL = eig_tr_l(ctx, A)\n        EL = EL * Q.transpose_conj()\n\n    if right:\n        ER = eig_tr_r(ctx, A)\n        ER = Q * ER\n\n    if left and (not right):\n        return (E, EL)\n\n    if right and (not left):\n        return (E, ER)\n\n    return (E, EL, ER)\n\n@defun\ndef eig_sort(ctx, E, EL = False, ER = False, f = ""real""):\n    """"""\n    This routine sorts the eigenvalues and eigenvectors delivered by ``eig``.\n\n    parameters:\n      E  : the eigenvalues as delivered by eig\n      EL : the left  eigenvectors as delivered by eig, or false\n      ER : the right eigenvectors as delivered by eig, or false\n      f  : either a string (""real"" sort by increasing real part, ""imag"" sort by\n           increasing imag part, ""abs"" sort by absolute value) or a function\n           mapping complexs to the reals, i.e. ``f = lambda x: -mp.re(x) ``\n           would sort the eigenvalues by decreasing real part.\n\n    return values:\n       E            if EL and ER are both false.\n      (E, ER)       if ER is not false and left is false.\n      (E, EL)       if EL is not false and right is false.\n      (E, EL, ER)   if EL and ER are not false.\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER,f = lambda x: -mp.re(x))\n      >>> mp.nprint(E)\n      [9.0, 4.0, 2.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n    """"""\n\n    if isinstance(f, str):\n        if f == ""real"":\n            f = ctx.re\n        elif f == ""imag"":\n            f = ctx.im\n        elif cmp == ""abs"":\n            f = abs\n        else:\n            raise RuntimeError(""unknown function %s"" % f)\n\n    n = len(E)\n\n    # Sort eigenvalues (bubble-sort)\n\n    for i in range(n):\n        imax = i\n        s = f(E[i])         # s is the current maximal element\n\n        for j in range(i + 1, n):\n            c = f(E[j])\n            if c < s:\n                s = c\n                imax = j\n\n        if imax != i:\n            # swap eigenvalues\n\n            z = E[i]\n            E[i] = E[imax]\n            E[imax] = z\n\n            if not isinstance(EL, bool):\n                for j in range(n):\n                    z = EL[i,j]\n                    EL[i,j] = EL[imax,j]\n                    EL[imax,j] = z\n\n            if not isinstance(ER, bool):\n                for j in range(n):\n                    z = ER[j,i]\n                    ER[j,i] = ER[j,imax]\n                    ER[j,imax] = z\n\n    if isinstance(EL, bool) and isinstance(ER, bool):\n        return E\n\n    if isinstance(EL, bool) and not(isinstance(ER, bool)):\n        return (E, ER)\n\n    if isinstance(ER, bool) and not(isinstance(EL, bool)):\n        return (E, EL)\n\n    return (E, EL, ER)\n'"
numscrypt/linalg/eigen_mpmath.py,0,"b'##################################################################################################\n#\n# This module is an adaptation for Numscrypt and Transcrypt of mpmath.matrix.eigen.py\n#\n# The whole of mpmath is distributed under the New or Revised BSD 3-clause License:\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#   a. Redistributions of source code must retain the above copyright notice,\n#      this list of conditions and the following disclaimer.\n#   b. Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#   c. Neither the name of mpmath nor the names of its contributors\n#      may be used to endorse or promote products derived from this software\n#      without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n# DAMAGE.\n#\n# The following copyrights are relevant:\n#\n# Copyright (C) 2005-2017 Fredrik Johansson and mpmath contributors\n# (w.r.t. the mpmath library as a whole)\n#\n# Copyright (C) 2013 Timo Hartmann, mpmath contributor (thartmann15 at gmail.com)\n# (w.r.t the original module for the eigenvalue problem)\n#\n# Copyright (C) 2017 Jacques de Hooge (jdeh@transcrypt.org)\n# (w.r.t. the adaptation for Numscrypt and Transcrypt)\n#\n##################################################################################################\n\n# __pragma__ (\'opov\')\n\n# BEGIN compatibility stuff\n\nfrom math import *\nimport cmath\nfrom numscrypt import *\n\ndef isinf (x):  # !!! Todo\n    return False\n    \ndef hypot (x, y):\n    return sqrt (x * x + y * y)\n    \nctx_eps = 1e-15\nctx_dps = 15\n    \nctx_one = 1\nctx_prec = 53\n\ndef ctx_ldexp (x, n):\n    return x * 2**n\n\n# END compatibility stuff\n    \n""""""\nThe eigenvalue problem\n----------------------\n\nThis file contains routines for the eigenvalue problem.\n\nhigh level routines:\n\n  hessenberg : reduction of a real or complex square matrix to upper Hessenberg form\n  schur : reduction of a real or complex square matrix to upper Schur form\n  eig : eigenvalues and eigenvectors of a real or complex square matrix\n\nlow level routines:\n\n  hessenberg_reduce_0 : reduction of a real or complex square matrix to upper Hessenberg form\n  hessenberg_reduce_1 : auxiliary routine to hessenberg_reduce_0\n  qr_step : a single implicitly shifted QR step for an upper Hessenberg matrix\n  hessenberg_qr : Schur decomposition of an upper Hessenberg matrix\n  eig_tr_r : right eigenvectors of an upper triangular matrix\n  eig_tr_l : left  eigenvectors of an upper triangular matrix\n""""""\n\ndef hessenberg_reduce_0(A, T):\n    """"""\n    This routine computes the (upper) Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is calculated such that\n\n               Q\' A Q = H              and             Q\' Q = Q Q\' = 1\n\n    where H is an upper Hessenberg matrix, meaning that it only contains zeros\n    below the first subdiagonal. Here \' denotes the hermitian transpose (i.e.\n    transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains the square matrix A of\n                dimension (n,n). On output, A contains a compressed representation\n                of Q and H.\n      T         (output) An array of length n containing the first elements of\n                the Householder reflectors.\n    """"""\n\n    # internally we work with householder reflections from the right.\n    # let u be a row vector (i.e. u[i]=A[i,:i]). then\n    # Q is build up by reflectors of the type (1-v\'v) where v is a suitable\n    # modification of u. these reflectors are applyed to A from the right.\n    # because we work with reflectors from the right we have to start with\n    # the bottom row of A and work then upwards (this corresponds to\n    # some kind of RQ decomposition).\n    # the first part of the vectors v (i.e. A[i,:(i-1)]) are stored as row vectors\n    # in the lower left part of A (excluding the diagonal and subdiagonal).\n    # the last entry of v is stored in T.\n    # the upper right part of A (including diagonal and subdiagonal) becomes H.\n    \n    n = A.shape[0]\n    if n <= 2: return\n\n    for i in range(n-1, 1, -1):\n        \n        # scale the vector\n\n        scale = 0\n        for k in range(i):\n            scale += abs(A[i,k].real) + abs(A[i,k].imag)\n\n        scale_inv = 0\n        if scale != 0:\n            scale_inv = 1 / scale\n            \n        if scale == 0 or isinf(scale_inv):\n            # sadly there are floating point numbers not equal to zero whose reciprocal is infinity\n            T[i] = 0\n            A[i,i-1] = 0\n            continue\n\n        # calculate parameters for housholder transformation\n\n        H = 0\n        for k in range(i):\n            A[i,k] *= scale_inv\n            rr = A[i,k].real\n            ii = A[i,k].imag\n            H += rr * rr + ii * ii\n\n        F = A[i,i-1]\n        f = abs(F)\n        G = cmath.sqrt(H)\n        A[i,i-1] = - G * scale\n        \n        if f == 0:\n            T[i] = G\n        else:\n            ff = F / f\n            T[i] = F + G * ff\n            A[i,i-1] *= ff\n\n        H += G * f\n        H = 1 / cmath.sqrt(H)\n        \n        T[i] *= H\n        for k in range(i - 1):\n            A[i,k] *= H\n        \n        for j in range(i):\n            # apply housholder transformation (from right)\n\n            G = T[i].conjugate() * A[j,i-1]\n\n            \n            for k in range(i-1):\n                G += A[i,k].conjugate() * A[j,k]\n\n                \n            A[j,i-1] -= G * T[i]\n            for k in range(i-1):\n                A[j,k] -= G * A[i,k]\n\n        \n        for j in range(n):\n            # apply housholder transformation (from left)\n\n            G = T[i] * A[i-1,j]\n            for k in range(i-1):\n                G += A[i,k] * A[k,j]\n\n            A[i-1,j] -= G * T[i].conjugate()\n            for k in range(i-1):\n                A[k,j] -= G * A[i,k].conjugate()\n\ndef hessenberg_reduce_1(A, T):\n    """"""\n    This routine forms the unitary matrix Q described in hessenberg_reduce_0.\n\n    parameters:\n      A    (input/output) On input, A is the same matrix as delivered by\n           hessenberg_reduce_0. On output, A is set to Q.\n\n      T    (input) On input, T is the same array as delivered by hessenberg_reduce_0.\n    """"""\n\n    n = A.shape[0]\n\n    if n == 1:\n        A[0,0] = 1\n        return\n\n    A[0,0] = A[1,1] = 1\n    A[0,1] = A[1,0] = 0\n\n    for i in range(2, n):\n        if T[i] != 0:     # !!! Conversion shouldn\'t be needed\n\n            for j in range(i):\n                G = T[i] * A[i-1,j]\n                for k in range(i-1):\n                    G += A[i,k] * A[k,j]\n\n                A[i-1,j] -= G * T[i].conjugate()\n                for k in range(i-1):\n                    A[k,j] -= G * A[i,k].conjugate()\n\n        A[i,i] = 1\n        for j in range(i):\n            A[j,i] = A[i,j] = 0\n\n            \ndef hessenberg(A, overwrite_a = False):\n    """"""\n    This routine computes the Hessenberg decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = H                and               Q\' Q = Q Q\' = 1\n\n    where H is an upper right Hessenberg matrix. Here \' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      H : an upper right Hessenberg matrix\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, H = mp.hessenberg(A)\n      >>> mp.nprint(H, 3) # doctest:+SKIP\n      [  3.15  2.23  4.44]\n      [-0.769  4.85  3.05]\n      [   0.0  3.61   7.0]\n      >>> print(mp.chop(A - Q * H * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    return value:   (Q, H)\n    """"""\n\n    n = A.shape[0]\n\n    if n == 1:\n        return (array([[1]], A.dtype), A)\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = empty((n,), A.dtype) # !!! n, 1 -> n\n\n    hessenberg_reduce_0(A, T)\n    Q = copy (A.copy)\n    hessenberg_reduce_1(Q, T)\n\n    for x in range(n):\n        for y in range(x+2, n):\n            A[y,x] = 0\n\n    return Q, A\n\n\n###########################################################################\n\n\ndef qr_step(n0, n1, A, Q, shift):\n    """"""\n    This subroutine executes a single implicitly shifted QR step applied to an\n    upper Hessenberg matrix A. Given A and shift as input, first an QR\n    decomposition is calculated:\n\n      Q R = A - shift * 1 .\n\n    The output is then following matrix:\n\n      R Q + shift * 1\n\n    parameters:\n      n0, n1    (input) Two integers which specify the submatrix A[n0:n1,n0:n1]\n                on which this subroutine operators. The subdiagonal elements\n                to the left and below this submatrix must be deflated (i.e. zero).\n                following restriction is imposed: n1>=n0+2\n      A         (input/output) On input, A is an upper Hessenberg matrix.\n                On output, A is replaced by ""R Q + shift * 1""\n      Q         (input/output) The parameter Q is multiplied by the unitary matrix\n                Q arising from the QR decomposition. Q can also be false, in which\n                case the unitary matrix Q is not computed.\n      shift     (input) a complex number specifying the shift. idealy close to an\n                eigenvalue of the bottemmost part of the submatrix A[n0:n1,n0:n1].\n\n    references:\n      Stoer, Bulirsch - Introduction to Numerical Analysis.\n      Kresser : Numerical Methods for General and Structured Eigenvalue Problems\n    """"""\n\n    # implicitly shifted and bulge chasing is explained at p.398/399 in ""Stoer, Bulirsch - Introduction to Numerical Analysis""\n    # for bulge chasing see also ""Watkins - The Matrix Eigenvalue Problem"" sec.4.5,p.173\n\n    # the Givens rotation we used is determined as follows: let c,s be two complex\n    # numbers. then we have following relation:\n    #\n    #     v = sqrt(|c|^2 + |s|^2)\n    #\n    #     1/v [ c~  s~]  [c] = [v]\n    #         [-s   c ]  [s]   [0]\n    #\n    # the matrix on the left is our Givens rotation.\n    \n    n = A.shape[0]\n\n    # first step\n\n    # calculate givens rotation\n    c = A[n0  ,n0] - shift\n    s = A[n0+1,n0]\n\n    v = hypot(hypot(c.real, c.imag), hypot(s.real, s.imag))\n\n    if v == 0:\n        v = 1\n        c = 1\n        s = 0\n    else:\n        c /= v\n        s /= v\n\n    for k in range(n0, n):\n        # apply givens rotation from the left\n        x = A[n0  ,k]\n        y = A[n0+1,k]\n\n        A[n0  ,k] = c.conjugate() * x + s.conjugate() * y\n        A[n0+1,k] =           -s  * x +            c  * y\n    \n    for k in range(min(n1, n0+3)):\n        # apply givens rotation from the right\n        x = A[k,n0  ]\n        y = A[k,n0+1]\n        A[k,n0  ] =             c  * x +            s  * y\n        A[k,n0+1] = -s.conjugate() * x + c.conjugate() * y\n\n    if not isinstance(Q, bool):\n        for k in range(n):\n            # eigenvectors\n            x = Q[k,n0  ]\n            y = Q[k,n0+1]\n            Q[k,n0  ] =             c  * x +            s  * y\n            Q[k,n0+1] = -s.conjugate() * x + c.conjugate() * y\n\n    # chase the bulge\n    \n    for j in range(n0, n1 - 2):\n        # calculate givens rotation\n\n        c = A[j+1,j]\n        s = A[j+2,j]\n\n        v = hypot(hypot(c.real, c.imag), hypot(s.real, s.imag))\n\n        if v == 0:\n            A[j+1,j] = 0\n            v = 1\n            c = 1\n            s = 0\n        else:\n            A[j+1,j] = v\n            c /= v\n            s /= v\n\n        A[j+2,j] = 0\n    \n        for k in range(j+1, n):\n            # apply givens rotation from the left\n            x = A[j+1,k]\n            y = A[j+2,k]\n            A[j+1,k] = c.conjugate() * x + s.conjugate() * y\n            A[j+2,k] =           -s  * x +            c  * y\n    \n        for k in range(min(n1, j+4)):\n            # apply givens rotation from the right\n            x = A[k,j+1]\n            y = A[k,j+2]\n            A[k,j+1] =             c  * x +            s  * y\n            A[k,j+2] = -s.conjugate() * x + c.conjugate() * y\n    \n        if not isinstance(Q, bool):\n            for k in range(n):\n                # eigenvectors\n                x = Q[k,j+1]\n                y = Q[k,j+2]\n                Q[k,j+1] =             c  * x +            s  * y\n                Q[k,j+2] = -s.conjugate() * x + c.conjugate() * y\n\n\n\ndef hessenberg_qr(A, Q):\n    """"""\n    This routine computes the Schur decomposition of an upper Hessenberg matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = R                   and                  Q\' Q = Q Q\' = 1\n\n    where R is an upper right triangular matrix. Here \' denotes the hermitian\n    transpose (i.e. transposition and conjugation).\n\n    parameters:\n      A         (input/output) On input, A contains an upper Hessenberg matrix.\n                On output, A is replace by the upper right triangluar matrix R.\n\n      Q         (input/output) The parameter Q is multiplied by the unitary\n                matrix Q arising from the Schur decomposition. Q can also be\n                false, in which case the unitary matrix Q is not computated.\n    """"""\n\n    n = A.shape[0]\n\n    norm = 0\n    for x in range(n):\n        for y in range(min(x+2, n)):\n            norm += A[y,x].real * A[y,x].real + A[y,x].imag * A[y,x].imag\n    norm = sqrt(norm) / n\n    \n    if norm == 0:\n        return\n\n    n0 = 0\n    n1 = n\n\n    eps = ctx_eps / (100 * n)\n    \n    maxits = ctx_dps * 4\n\n    its = totalits = 0                           \n\n    while True:\n        # kressner p.32 algo 3\n        # the active submatrix is A[n0:n1,n0:n1]\n\n        k = n0\n        \n        while k + 1 < n1:\n            s = abs(A[k,k].real) + abs(A[k,k].imag) + abs(A[k+1,k+1].real) + abs (A[k+1,k+1].imag)\n\n            if s < eps * norm:\n                s = norm              \n                \n            if abs(A[k+1,k]) < eps * s:\n                break\n            k += 1\n     \n        if k + 1 < n1:\n            # deflation found at position (k+1, k)\n\n            A[k+1,k] = 0  # !!! Make this unneeded, the complex, that is\n            n0 = k + 1\n\n            its = 0\n\n            if n0 + 1 >= n1:\n                # block of size at most two has converged\n                n0 = 0\n                n1 = k + 1\n                if n1 < 2:\n                    # QR algorithm has converged\n                    return\n        else:\n            if (its % 30) == 10:\n                # exceptional shift\n                shift = A[n1-1,n1-2]\n            elif (its % 30) == 20:\n                # exceptional shift\n                shift = abs(A[n1-1,n1-2])\n            elif (its % 30) == 29:\n                # exceptional shift\n                shift = norm\n            else:\n                \n                #    A = [ a b ]       det(x-A)=x*x-x*tr(A)+det(A)\n                #        [ c d ]\n                #\n                # eigenvalues bad:   (tr(A)+sqrt((tr(A))**2-4*det(A)))/2\n                #     bad because of cancellation if |c| is small and |a-d| is small, too.\n                #\n                # eigenvalues good:     (a+d+sqrt((a-d)**2+4*b*c))/2\n\n                t =  A[n1-2,n1-2] + A[n1-1,n1-1]\n                s = (A[n1-1,n1-1] - A[n1-2,n1-2]) ** 2 + 4 * A[n1-1,n1-2] * A[n1-2,n1-1]\n                if s.real > 0:\n                    s = cmath.sqrt(s)\n                else:\n                    s = cmath.sqrt(-s) * 1j\n                a = (t + s) / 2\n                b = (t - s) / 2\n                if abs(A[n1-1,n1-1] - a) > abs(A[n1-1,n1-1] - b):\n                    shift = b\n                else:\n                    shift = a\n\n            its += 1\n            totalits += 1\n\n            qr_step(n0, n1, A, Q, shift)\n            \n            if its > maxits:\n                raise RuntimeError(""qr: failed to converge after %d steps"" % its)\n\ndef schur(A, overwrite_a = False):\n    """"""\n    This routine computes the Schur decomposition of a square matrix A.\n    Given A, an unitary matrix Q is determined such that\n\n          Q\' A Q = R                and               Q\' Q = Q Q\' = 1\n\n    where R is an upper right triangular matrix. Here \' denotes the\n    hermitian transpose (i.e. transposition and conjugation).\n\n    input:\n      A            : a real or complex square matrix\n      overwrite_a  : if true, allows modification of A which may improve\n                     performance. if false, A is not modified.\n\n    output:\n      Q : an unitary matrix\n      R : an upper right triangular matrix\n\n    return value:   (Q, R)\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> Q, R = mp.schur(A)\n      >>> mp.nprint(R, 3) # doctest:+SKIP\n      [2.0  0.417  -2.53]\n      [0.0    4.0  -4.74]\n      [0.0    0.0    9.0]\n      >>> print(mp.chop(A - Q * R * Q.transpose_conj()))\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n      [0.0  0.0  0.0]\n\n    warning: The Schur decomposition is not unique.\n    """"""\n\n    n = A.shape[0]\n\n    if n == 1:\n        return (array([[1]], A.dtype), A)\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = empty((n,), A.dtype) # !!! n, 1 -> n\n\n    hessenberg_reduce_0(A, T)\n    Q = copy (A)\n    hessenberg_reduce_1(Q, T)\n\n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(A, Q)\n\n    return Q, A\n\n\ndef eig_tr_r(A):\n    """"""\n    This routine calculates the right eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      ER     a matrix whose columns form the right eigenvectors of A\n\n    return value: ER\n    """"""\n\n    # this subroutine is inspired by the lapack routines ctrevc.f,clatrs.f\n\n    n = A.shape[0] \n    \n    ER = identity(n, A.dtype)\n\n    eps = ctx_eps\n\n    unfl = ctx_ldexp(ctx_one, -ctx_prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / sqrt(eps)\n\n    rmax = 1\n\n    for i in range(1, n):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i - 1, -1, -1):\n\n            r = 0\n            for k in range(j + 1, i + 1):\n                r += A[j,k] * ER[k,i]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            \n            ER[j,i] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(j, i+1):\n                    ER[k,i] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(i + 1):\n                ER[k,i] /= rmax\n\n    return ER\n\ndef eig_tr_l(A):\n    """"""\n    This routine calculates the left eigenvectors of an upper right triangular matrix.\n\n    input:\n      A      an upper right triangular matrix\n\n    output:\n      EL     a matrix whose rows form the left eigenvectors of A\n\n    return value:  EL\n    """"""\n\n    n = A.shape[0]\n\n    EL = identity(n, A.dtype)\n\n    eps = ctx_eps\n\n    unfl = ctx_ldexp(ctx_one, -ctx_prec * 30)\n    # since mpmath effectively has no limits on the exponent, we simply scale doubles up\n    # original double has prec*20\n\n    smlnum = unfl * (n / eps)\n    simin = 1 / cmath.sqrt(eps)\n\n    rmax = 1\n\n    for i in range(n - 1):\n        s = A[i,i]\n\n        smin = max(eps * abs(s), smlnum)\n\n        for j in range(i + 1, n):\n\n            r = 0\n            for k in range(i, j):\n                r += EL[i,k] * A[k,j]\n\n            t = A[j,j] - s\n            if abs(t) < smin:\n                t = smin\n\n            r = -r / t\n            EL[i,j] = r\n\n            rmax = max(rmax, abs(r))\n            if rmax > simin:\n                for k in range(i, j + 1):\n                    EL[i,k] /= rmax\n                rmax = 1\n\n        if rmax != 1:\n            for k in range(i, n):\n                EL[i,k] /= rmax\n\n    return EL\n\ndef eig(A, left = False, right = True, overwrite_a = False):\n    """"""\n    This routine computes the eigenvalues and optionally the left and right\n    eigenvectors of a square matrix A. Given A, a vector E and matrices ER\n    and EL are calculated such that\n\n                        A ER[:,i] =         E[i] ER[:,i]\n                EL[i,:] A         = EL[i,:] E[i]\n\n    E contains the eigenvalues of A. The columns of ER contain the right eigenvectors\n    of A whereas the rows of EL contain the left eigenvectors.\n\n\n    input:\n      A           : a real or complex square matrix of shape (n, n)\n      left        : if true, the left eigenvectors are calulated.\n      right       : if true, the right eigenvectors are calculated.\n      overwrite_a : if true, allows modification of A which may improve\n                    performance. if false, A is not modified.\n\n    output:\n      E    : a list of length n containing the eigenvalues of A.\n      ER   : a matrix whose columns contain the right eigenvectors of A.\n      EL   : a matrix whose rows contain the left eigenvectors of A.\n\n    return values:\n       E            if left and right are both false.\n      (E, ER)       if right is true and left is false.\n      (E, EL)       if left is true and right is false.\n      (E, EL, ER)   if left and right are true.\n\n\n    examples:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, ER = mp.eig(A)\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n\n    warning:\n     - If there are multiple eigenvalues, the eigenvectors do not necessarily\n       span the whole vectorspace, i.e. ER and EL may have not full rank.\n       Furthermore in that case the eigenvectors are numerical ill-conditioned.\n     - In the general case the eigenvalues have no natural order.\n\n    see also:\n      - eigh (or eigsy, eighe) for the symmetric eigenvalue problem.\n      - eig_sort for sorting of eigenvalues and eigenvectors\n    """"""\n\n    n = A.shape[0]\n\n    if n == 1:\n        if left and (not right):\n            return ([A[0]], array([[1]], A.dtype))\n\n        if right and (not left):\n            return ([A[0]], array([[1]], A.dtype))\n\n        return ([A[0]], array([[1]], A.dtype), array([[1]], A.dtype))\n\n    if not overwrite_a:\n        A = copy (A)\n\n    T = zeros((n,), \'complex64\')\n\n    hessenberg_reduce_0(A, T)\n\n    if left or right:\n        Q = copy (A)\n        hessenberg_reduce_1(Q, T) \n    else:\n        Q = False\n        \n            \n    for x in range(n):\n        for y in range(x + 2, n):\n            A[y,x] = 0\n\n    hessenberg_qr(A, Q)\n    \n    E = [A[i,i] for i in range(n)]\n\n    if not (left or right):\n        return E\n\n    if left:\n        EL = eig_tr_l(A)\n        EL = EL @ Q.conjugate().transpose()\n\n    if right:\n        ER = eig_tr_r(A)\n        ER = Q @ ER\n\n    if left and (not right):\n        return (E, EL)\n\n    if right and (not left):\n        return (E, ER)\n\n    return (E, EL, ER)\n\n\'\'\'\ndef eig_sort(ctx, E, EL = False, ER = False, f = ""real""):\n    """"""\n    This routine sorts the eigenvalues and eigenvectors delivered by ``eig``.\n\n    parameters:\n      E  : the eigenvalues as delivered by eig\n      EL : the left  eigenvectors as delivered by eig, or false\n      ER : the right eigenvectors as delivered by eig, or false\n      f  : either a string (""real"" sort by increasing real part, ""imag"" sort by\n           increasing imag part, ""abs"" sort by absolute value) or a function\n           mapping complexes to the reals, i.e. ``f = lambda x: -mp.re(x) ``\n           would sort the eigenvalues by decreasing real part.\n\n    return values:\n       E            if EL and ER are both false.\n      (E, ER)       if ER is not false and left is false.\n      (E, EL)       if EL is not false and right is false.\n      (E, EL, ER)   if EL and ER are not false.\n\n    example:\n      >>> from mpmath import mp\n      >>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])\n      >>> E, EL, ER = mp.eig(A,left = True, right = True)\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER)\n      >>> mp.nprint(E)\n      [2.0, 4.0, 9.0]\n      >>> E, EL, ER = mp.eig_sort(E, EL, ER,f = lambda x: -mp.re(x))\n      >>> mp.nprint(E)\n      [9.0, 4.0, 2.0]\n      >>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))\n      [0.0]\n      [0.0]\n      [0.0]\n      >>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))\n      [0.0  0.0  0.0]\n    """"""\n\n    if isinstance(f, str):  #!!! No idea...\n        if f == ""real"":\n            f = ctx.re\n        elif f == ""imag"":\n            f = ctx.im\n        elif cmp == ""abs"":\n            f = abs\n        else:\n            raise RuntimeError(""unknown function %s"" % f)\n\n    n = len(E)\n\n    # Sort eigenvalues (bubble-sort)\n\n    for i in range(n):\n        imax = i\n        s = f(E[i])         # s is the current maximal element\n\n        for j in range(i + 1, n):\n            c = f(E[j])\n            if c < s:\n                s = c\n                imax = j\n\n        if imax != i:\n            # swap eigenvalues\n\n            z = E[i]\n            E[i] = E[imax]\n            E[imax] = z\n\n            if not isinstance(EL, bool):\n                for j in range(n):\n                    z = EL[i,j]\n                    EL[i,j] = EL[imax,j]\n                    EL[imax,j] = z\n\n            if not isinstance(ER, bool):\n                for j in range(n):\n                    z = ER[j,i]\n                    ER[j,i] = ER[j,imax]\n                    ER[j,imax] = z\n\n    if isinstance(EL, bool) and isinstance(ER, bool):\n        return E\n\n    if isinstance(EL, bool) and not(isinstance(ER, bool)):\n        return (E, ER)\n\n    if isinstance(ER, bool) and not(isinstance(EL, bool)):\n        return (E, EL)\n\n    return (E, EL, ER)\n\'\'\'\n\n'"
numscrypt/development/shipment/shipment_test.py,0,"b""import os\r\nimport webbrowser\r\n\r\nshipDir = os.path.dirname (os.path.abspath (__file__)) .replace ('\\\\', '/')\r\nrootDir = '/'.join  (shipDir.split ('/')[ : -2])\r\n\r\ndef getAbsPath (relPath):\r\n\treturn '{}/{}'.format (rootDir, relPath)\r\n\r\ndef test (relPath, fileNamePrefix, run = False):\r\n\tos.chdir (getAbsPath (relPath))\r\n\tos.system ('transcrypt -b -c -e6 {}{}.py'.format (fcallSwitch, fileNamePrefix))\t\r\n\r\n\tif run:\r\n\t\tos.chdir (getAbsPath (relPath))\r\n\t\tos.system ('transcrypt -r {}.py'.format (fileNamePrefix))\t\t\r\n\t\t\r\n\twebbrowser.open ('file://{}/{}.html'.format (getAbsPath (relPath), fileNamePrefix), new = 2)\r\n\twebbrowser.open ('file://{}/{}.min.html'.format (getAbsPath (relPath), fileNamePrefix), new = 2)\r\n\r\ndef autoTest (*args):\r\n\ttest (*args, True)\r\n\t\r\nos.system ('python test_install.py')\r\n\t\r\nfor fcallSwitch in (' ', '-f '):\r\n\tautoTest ('development/automated_tests/ndarray', 'autotest')\r\n\ttest ('development/manual_tests/slicing_optimization', 'test')\r\n\r\n\tif fcallSwitch:\r\n\t\tprint ('Shipment test completed')\r\n\telse:\r\n\t\tinput ('Close browser tabs opened by shipment test and press [enter] for fcall test')\r\n"""
numscrypt/development/shipment/test_install.py,0,"b""import os\r\nimport site\r\n\r\nsitepackagesDir = os.path.dirname (site.__file__) + '/site-packages'\r\n\t\r\nshipDir = os.path.dirname (os.path.abspath (__file__)) .replace ('\\\\', '/')\r\nappRootDir = '/'.join  (shipDir.split ('/')[ : -2])\r\ndistributionDir = '/'.join  (appRootDir.split ('/')[ : -1])\r\n\r\ndef getAbsPath (rootDir, relPath):\r\n\treturn '{}/{}'.format (rootDir, relPath)\r\n\r\ndef copyCode (relPath):\r\n\trelPath = relPath.replace ('\\\\', '/')\r\n\t\r\n\tif '/' in relPath:\r\n\t\trelDir = '{}/'.format (relPath .rsplit ('/', 1) [0])\r\n\telse:\r\n\t\trelDir = ''\r\n\r\n\tos.system ('xcopy /Y {} {}'.format (\r\n\t\tgetAbsPath (appRootDir, relPath) .replace ('/', '\\\\'),\r\n\t\tgetAbsPath (sitepackagesDir, 'numscrypt/{}'.format (relDir)) .replace ('/', '\\\\')\r\n\t))\r\n\r\ncopyCode ('__init__.py')\r\ncopyCode ('__base__.py')\r\ncopyCode ('random.py')\r\ncopyCode ('linalg/__init__.py')\r\ncopyCode ('linalg/eigen_mpmath.py')\r\ncopyCode ('fft/__init__.py')\r\ncopyCode ('fft/__javascript__/fft_nayuki_precalc_fixed.js')\r\n"""
numscrypt/development/shipment/upload_all.py,0,"b'import os\r\n\r\nshipDir = os.path.dirname (os.path.abspath (__file__)) .replace (\'\\\\\', \'/\')\r\nappRootDir = \'/\'.join  (shipDir.split (\'/\')[ : -2])\r\ndistributionDir = \'/\'.join  (appRootDir.split (\'/\')[ : -1])\r\ndynWebRootDir, statWebRootDir = eval (open (\'upload_all.nogit\') .read ())\r\nsphinxDir = \'/\'.join ([appRootDir, \'docs/sphinx\'])\r\n\r\ndef getAbsPath (rootDir, relPath):\r\n\treturn \'{}/{}\'.format (rootDir, relPath)\r\n\r\ndef copyWebsite (projRelPath, webRelPath, static = False, subdirs = False):\r\n\t os.system (\'xcopy /Y {} {} {}\'.format (\'/E\' if subdirs else \'\', getAbsPath (appRootDir, projRelPath) .replace (\'/\', \'\\\\\'), getAbsPath (statWebRootDir if static else dynWebRootDir, webRelPath) .replace (\'/\', \'\\\\\')))\r\n\r\nos.chdir (sphinxDir)\r\nos.system (\'make html\')\r\ncopyWebsite (\'docs/sphinx/_build/html\', \'numscrypt/docs/html/\', True, True)\r\n\r\nos.chdir (distributionDir)\r\n\r\nos.system (\'uploadPython\')\r\n\r\nos.system (\'git add .\')\r\nos.system (\'git commit -m""{}""\'.format (input (\'Description of commit: \')))\r\nos.system (\'git push origin master\')\r\n\r\nos.chdir (shipDir)\r\n'"
numscrypt/docs/sphinx/conf.py,0,"b'import sys\n\nsys.path.append (\'../..\')\n\nimport __base__\n\n# -*- coding: utf-8 -*-\n#\n# Transcrypt documentation build configuration file, created by\n# sphinx-quickstart on Sat Jan 09 20:57:48 2016.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = []\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Numscrypt\'\ncopyright = u\'2016, Jacques de Hooge\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = __base__.ns_version\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = \'../images/numscrypt_logo_sphinx.png\'\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'Numscryptdoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\'index\', \'Numscrypt.tex\', u\'Numscrypt Documentation\',\n   u\'Jacques de Hooge\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'numscrypt\', u\'Numscrypt Documentation\',\n     [u\'Jacques de Hooge\'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'Numscrypt\', u\'Numscrypt Documentation\',\n   u\'Jacques de Hooge\', \'Numscrypt\', \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n'"
numscrypt/development/automated_tests/ndarray/autotest.py,0,"b""import org.transcrypt.autotester\r\n\r\nimport basics\r\nimport module_linalg\r\nimport module_fft\r\n\r\nautoTester = org.transcrypt.autotester.AutoTester ()\r\n\r\nautoTester.run (basics, 'basics')\r\nautoTester.run (module_linalg, 'module_linalg')\r\nautoTester.run (module_fft, 'module_fft')\r\n\r\nautoTester.done ()\r\n"""
numscrypt/development/manual_tests/numpy_eig/test.py,0,"b""from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\timport numscrypt.linalg as linalg\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.linalg as linalg\nnum.set_printoptions (linewidth = 240)\n__pragma__ ('noskip')\n\n__pragma__ ('opov')\n\ndef show (*args):\n    print (*args)\n\nfor a in (   \n    num.array ([\n        [0, 1j],\n        [-1j, 1]\n    ], 'complex128'),\n    num.array ([\n        [1, -2, 3, 1],\n        [5, 8, -1, -5],\n        [2, 1, 1, 100],\n        [2, 1, -1, 0]\n    ], 'complex128'),\n    num.array ([\n        [1, 1, 0, 0],\n        [0, 2, 2, 0],\n        [0, 0, 3, 3],\n        [0, 0, 0, 4]\n    ], 'complex128'),\n) [1:2]:\n    eVals, eVecs = linalg.eig (a)\n    \n    enumSorted = sorted (\n        enumerate (eVals.tolist ()),\n        key = lambda elem: -(elem [1].real + elem [1].imag / 1000)  # Order on primarily on real, secundarily on imag, note conjugate vals\n    )\n    \n    indicesSorted = [elem [0] for elem in enumSorted]\n    eValsSorted = [elem [1] for elem in enumSorted]\n    \n    eValsMat = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eValsMat [iRow, iCol] = eVals [iCol]\n     \n    eVecsNorms = num.empty ((eVecs.shape [1], ), a.dtype)\n    for iNorm in range (eVecsNorms.shape [0]):\n        eVecsNorms [iNorm] = complex (linalg.norm (eVecs [:, iNorm]))\n        \n    eVecsCanon = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsCanon [iRow, iCol] = eVecs [iRow, iCol] / eVecs [0, iCol] \n        \n    eVecsSorted = num.empty (a.shape, a.dtype)\n    for iRow in range (a.shape [0]):\n        for iCol in range (a.shape [1]):\n            eVecsSorted [iRow, iCol] = eVecsCanon [iRow, indicesSorted [iCol]]\n        \n    show (  '=========================================')\n    '''\n    show ('\\n---------------- a ----------------------')\n    show (a)\n    show ('\\n---------------- eigVals ----------------')\n    show (eVals)\n    show ('\\n---------------- eigValsMat--------------')\n    show (eValsMat)\n    show ('\\n---------------- eigVecs ----------------')\n    show (eVecs)\n    show ('\\n---------------- eigValsMat @ eigVecs ---')\n    show (eValsMat * eVecs)\n    show ('\\n---------------- a @ eigVecs-------------')\n    show (a @ eVecs)\n    show ('\\n---------------- eigVecsNorms -----------')\n    show (eVecsNorms)\n    show ('\\n---------------- eigVecsCanon -----------')\n    show (eVecsCanon)\n    '''\n    show ('\\n---------------- eigVecsSorted ----------')\n    show ([[(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in row] for row in eVecsSorted.tolist ()])\n    show ('\\n---------------- eigValsSorted ----------')\n    show ([(round (value.real + 1e-10, 3), round (value.imag + 1e-10, 3)) for value in eValsSorted], '\\n')\n    show (  '=========================================')\n    \n"""
numscrypt/development/manual_tests/numpy_eig/testmp.py,0,"b""from mpmath import *\n\na = matrix ([\n    [1, 1j],\n    [-1j, 1]\n], 'complex128')\n\nw, v = eig (a)\n\n\nprint (w)\nprint ('111----')\nprint (v)\nprint ()\nprint ()\n\n\n'''\na = matrix ([\n    [1, -2, 3, 1],\n    [5, 8, -1, -5],\n    [2, 1, 1, 100],\n    [2, 1, -1, 0]\n], 'complex128')\n\nw, v = eig (a)\n\nprint (w)\nprint ('222----')\nprint (v)\nprint ()\n'''"""
numscrypt/development/manual_tests/slicing_optimization/test.py,0,"b""from org.transcrypt.stubs.browser import *\r\nfrom org.transcrypt.stubs.browser import __pragma__\r\n\r\nimport numscrypt as num\r\nimport numscrypt.random as num_rand\r\nimport numscrypt.linalg as linalg\r\nimport random\r\n\r\nresult = ''\r\n\r\nfor useComplex in (False, True):\r\n    for transpose in (False, True):\r\n        if useComplex:\r\n            a = num.array ([\r\n                [complex (random.random (), random.random ()) for iCol in range (30)]\r\n                for iRow in range (30)\r\n            ], 'complex128')\r\n        else:\r\n            a = num_rand.rand (30, 30)\r\n        \r\n        timeStartTranspose = __new__ (Date ())\r\n        if transpose:\r\n            a = a.transpose ()\r\n\r\n        timeStartInv = __new__ (Date ())\r\n        ai = linalg.inv (a)\r\n        \r\n        timeStartMul = __new__ (Date ()) \r\n        __pragma__ ('opov')\r\n        id = a @ ai\r\n        __pragma__ ('noopov')\r\n        \r\n        timeStartScalp = __new__ (Date ()) \r\n        __pragma__ ('opov')\r\n        sp = a * a\r\n        __pragma__ ('noopov')\r\n        \r\n        timeStartDiv = __new__ (Date ()) \r\n        __pragma__ ('opov')\r\n        sp = a / a\r\n        __pragma__ ('noopov')\r\n        \r\n        timeStartAdd = __new__ (Date ()) \r\n        __pragma__ ('opov')\r\n        sp = a + a\r\n        __pragma__ ('noopov')\r\n        \r\n        timeStartSub = __new__ (Date ()) \r\n        __pragma__ ('opov')\r\n        sp = a - a\r\n        __pragma__ ('noopov')\r\n        \r\n        timeStartEig = __new__ (Date ())\r\n        if useComplex:\r\n            evals, evecs = linalg.eig (a [:10, :10])            \r\n        \r\n        timeEnd = __new__ (Date ())\r\n        \r\n        result += (\r\n'''\r\n<pre>\r\na @ ai [0:5, 0:5] =\r\n\r\n{}\r\n''' \r\n        ) .format (\r\n            str (num.round (id [0:5, 0:5], 2)) .replace (' ', '\\t'),\r\n        )\r\n\r\n        if transpose:\r\n            result += (\r\n'''\r\nTranspose took: {} ms'''\r\n            ).format (\r\n                timeStartInv - timeStartTranspose\r\n            )\r\n            \r\n        result += (\r\n'''\r\nInverse took: {} ms\r\nMatrix product (@) took: {} ms\r\nElementwise product (*) took: {} ms\r\nDivision took: {} ms\r\nAddition took: {} ms\r\nSubtraction took: {} ms\r\nEigenvals/vecs took: {} ms\r\n</pre>\r\n'''\r\n        ) .format (\r\n            timeStartMul - timeStartInv,\r\n            timeStartScalp - timeStartMul,\r\n            timeStartDiv - timeStartScalp,\r\n            timeStartAdd - timeStartDiv,\r\n            timeStartSub - timeStartAdd,\r\n            timeStartEig - timeStartSub,\r\n            timeEnd - timeStartEig if useComplex else 'N.A.'\r\n        )\r\n            \r\ndocument.getElementById ('result') .innerHTML = result\r\n"""
numscrypt/development/automated_tests/ndarray/basics/__init__.py,0,"b""from org.transcrypt.stubs.browser import *\r\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\r\n\r\n# Imports for Transcrypt, skipped runtime by CPython\r\nif __envir__.executor_name == __envir__.transpiler_name:\r\n\timport numscrypt as num\r\n\r\n# Imports for CPython, skipped compile time by Transcrypt\r\n__pragma__ ('skip')\r\nimport numpy as num\r\n__pragma__ ('noskip')\r\n\r\ndef run (autoTester):\r\n\tz = num.zeros ((4, 3), 'int32')\r\n\tautoTester.check ('Zeros', z.tolist (), '<br>')\r\n\t\r\n\to = num.ones ((4, 5))\r\n\tautoTester.check ('Ones', o.astype ('int32') .tolist ())\r\n\t\r\n\ti = num.identity (3, 'int32')\r\n\tautoTester.check ('Identity', i.tolist (), '<br>')\r\n\t\r\n\ta = num.array ([\r\n\t\t[1, 1, 2, 3],\r\n\t\t[4, 5, 6, 7],\r\n\t\t[8, 9, 10, 12]\r\n\t])\r\n\t\r\n\tautoTester.check ('Matrix a', a.tolist (), '<br>')\r\n\t\r\n\tautoTester.check ('Transpose of a', a.transpose () .tolist (), '<br>')\r\n\t\r\n\tb = num.array ([\r\n\t\t[2, 2, 4, 6],\r\n\t\t[8, 10, 12, 14],\r\n\t\t[16, 18, 20, 24]\r\n\t])\r\n\t\r\n\tbp =  b.transpose ()\r\n\t\r\n\tautoTester.check ('Matrix b', b.tolist (), '<br>')\r\n\tautoTester.check ('Permutation of b', bp.tolist (), '<br>')\r\n\t\t\r\n\tc = num.array ([\r\n\t\t[1, 2, 3, 4],\r\n\t\t[5, 6, 7, 8],\r\n\t\t[9, 10, 11, 12],\r\n\t], 'int32')\r\n\t\r\n\tautoTester.check ('Shape c', tuple (c.shape), '<br>')\r\n\tautoTester.check ('Matrix c', c.tolist (), '<br>')\r\n\t\r\n\tct = c.transpose ()\r\n\tautoTester.check ('Shape ct', tuple (ct.shape), '<br>')\r\n\tautoTester.check ('Transpose of c', ct .tolist (), '<br>')\r\n\r\n\tcs0, cs1 = num.hsplit (c, 2)\r\n\tautoTester.check ('Matrix cs0', cs0.tolist (), '<br>')\r\n\tautoTester.check ('Matrix cs1', cs1.tolist (), '<br>')\r\n\r\n\tci = num.hstack ((cs1, cs0))\r\n\tautoTester.check ('Matrix ci', ci.tolist (), '<br>')\r\n\t\r\n\tcts0, cts1, cts2 = num.hsplit (ct, 3)\r\n\tautoTester.check ('Matrix cts0', cts0.tolist (), '<br>')\r\n\tautoTester.check ('Matrix cts1', cts1.tolist (), '<br>')\r\n\tautoTester.check ('Matrix cts2', cts2.tolist (), '<br>')\r\n\r\n\tcti = num.hstack ((cts2, cts1, cts0))\r\n\tautoTester.check ('Matrix ci', cti.tolist (), '<br>')\r\n\t\r\n\td = num.array ([\r\n\t\t[13, 14],\r\n\t\t[15, 16],\r\n\t\t[17, 18],\r\n\t\t[19, 20]\r\n\t], 'int32')\r\n\t\r\n\tautoTester.check ('Matrix d', d.tolist (), '<br>')\r\n\tdt = d.transpose ()\r\n\tautoTester.check ('Permutation of d', dt.tolist (), '<br>')\r\n\t\r\n\tds0, ds1, ds2, ds3 = num.vsplit (d, 4)\r\n\tautoTester.check ('Matrix ds0', ds0.tolist (), '<br>')\r\n\tautoTester.check ('Matrix ds1', ds1.tolist (), '<br>')\r\n\tautoTester.check ('Matrix ds2', ds2.tolist (), '<br>')\r\n\tautoTester.check ('Matrix ds3', ds3.tolist (), '<br>')\r\n\r\n\tdi = num.vstack ((ds3, ds2, ds1, ds0))\r\n\tautoTester.check ('Matrix di', di.tolist (), '<br>')\r\n\t\r\n\tdts0, dts1 = num.vsplit (dt, 2)\r\n\tautoTester.check ('Matrix dts0', dts0.tolist (), '<br>')\r\n\tautoTester.check ('Matrix dts1', dts1.tolist (), '<br>')\r\n\r\n\tdti = num.vstack ((dts1, dts0))\r\n\tautoTester.check ('Matrix dti', dti.tolist (), '<br>')\r\n\t\r\n\tv0 = num.array (range (10))\t\r\n\tv1 = num.array ((1, 2, 3, 1, 2, 3, 1, 2, 3, 1))\r\n\r\n\t__pragma__ ('opov')\r\n\t\r\n\ta [1, 0] = 177\r\n\tel = b [1, 2]\r\n\t\r\n\tbsl0 = b [1, 1 : 3]\r\n\tbsl1 = b [1 : 2, 1 : 3]\r\n\tbsl2 = b [1 : 2, 1]\r\n\tbsl3 = b [1, 1 : 3]\r\n\tbsl4 = b [ : , 1]\r\n\tbsl5 = b [1, 1 : 3]\r\n\tbsl6 = b [1, 1 : 3]\r\n\tbsl7 = b [1, 2 : 3]\r\n\r\n\tbpsl0 = bp [1, 1 : 3]\r\n\tbpsl1 = bp [1 : 2, 1 : 3]\r\n\tbpsl2 = bp [1, 0 : ]\r\n\tbpsl3 = bp [1, 1 : 3]\r\n\tbpsl4 = bp [ : , 1]\r\n\tbpsl5 = bp [3, 1 : 3]\r\n\tbpsl6 = bp [2 : 4, 1 : 3]\r\n\tbpsl7 = bp [2 : 4, 2 : 3]\r\n\t\r\n\tsum = a + b\r\n\tdif = a - b\r\n\tprod = a * b\r\n\tquot = a / b\r\n\tdot = c @ d\r\n\tvsum = v0 + v1\r\n\tvel = vsum [6]\r\n\tvsum [6] = 70\r\n\t\r\n\tmul_a3 = a * 3\r\n\tmul_3a = 3 * a\r\n\tdiv_a3 = a / 3.1234567\r\n\tdiv_3a = 3.1234567 / a\r\n\tadd_a3 = a + 3\r\n\tadd_3a = 3 + a\r\n\tsub_a3 = a - 3\r\n\tsub_3a = 3 - a\r\n\tneg_a = -a\r\n\t\r\n\t__pragma__ ('noopov')\r\n\t\t\r\n\tautoTester.check ('El a [1, 2, 3] alt', a.tolist (), '<br>')\r\n\tautoTester.check ('El b [1, 2, 3]', el, '<br>')\r\n\t\r\n\tautoTester.check ('Sl b0', bsl0.tolist (), '<br>')\r\n\tautoTester.check ('Sl b1', bsl1.tolist (), '<br>')\r\n\tautoTester.check ('Sl b2', bsl2.tolist (), '<br>')\r\n\tautoTester.check ('Sl b3', bsl3.tolist (), '<br>')\r\n\tautoTester.check ('Sl b4', bsl4.tolist (), '<br>')\r\n\tautoTester.check ('Sl b5', bsl5.tolist (), '<br>')\r\n\tautoTester.check ('Sl b6', bsl6.tolist (), '<br>')\r\n\tautoTester.check ('Sl b7', bsl7.tolist (), '<br>')\r\n\t\r\n\tautoTester.check ('Sl bp0', bpsl0.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp1', bpsl1.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp2', bpsl2.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp3', bpsl3.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp4', bpsl4.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp5', bpsl5.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp6', bpsl6.tolist (), '<br>')\r\n\tautoTester.check ('Sl bp7', bpsl7.tolist (), '<br>')\r\n\t\r\n\tautoTester.check ('Matrix sum', sum.tolist (), '<br>')\r\n\tautoTester.check ('Matrix difference', dif.tolist (), '<br>')\r\n\tautoTester.check ('Matrix product', prod.tolist (), '<br>')\r\n\tautoTester.check ('Matrix quotient', quot.tolist (), '<br>')\r\n\tautoTester.check ('Matrix dotproduct', dot.tolist (), '<br>')\r\n\t\r\n\tautoTester.check ('Vector', v0.tolist (), '<br>')\r\n\tautoTester.check ('Vector', v1.tolist (), '<br>')\r\n\tautoTester.check ('El sum old', vel, '<br>')\r\n\tautoTester.check ('Vector sum new', vsum.tolist (), '<br>')\r\n\t\r\n\tautoTester.check ('mul_a3', mul_a3.tolist (), '<br>')\r\n\tautoTester.check ('mul_3a', mul_3a.tolist (), '<br>')\r\n\tautoTester.check ('div_a3', num.round (div_a3, 2).tolist (), '<br>')\r\n\tautoTester.check ('div_3a', num.round (div_3a, 2).tolist (), '<br>')\r\n\tautoTester.check ('add_a3', add_a3.tolist (), '<br>')\r\n\tautoTester.check ('add_3a', add_3a.tolist (), '<br>')\r\n\tautoTester.check ('sub_a3', sub_a3.tolist (), '<br>')\r\n\tautoTester.check ('sub_3a', sub_3a.tolist (), '<br>')\r\n\tautoTester.check ('neg_a', neg_a.tolist (), '<br>')\r\n\t\r\n\t__pragma__ ('opov')\r\n\tcomp_a = num.array ([\r\n\t\t[1 + 2j, 2 - 1j, 3],\r\n\t\t[4, 5 + 3j, 7]\r\n\t], 'complex128')\t\r\n\tcomp_b = num.array ([\r\n\t\t[6, 8 - 1j],\r\n\t\t[9 + 3j, 10],\r\n\t\t[11, 12 - 6j]\r\n\t], 'complex128')\r\n\tcomp_c = comp_a @ comp_b\r\n\t__pragma__ ('noopov')\r\n\t\r\n\tautoTester.check ('comp_a', comp_a.tolist (), '<br>')\r\n\tautoTester.check ('comp_b', comp_b.tolist (), '<br>')\r\n\tautoTester.check ('comp_c', comp_c.tolist (), '<br>')\r\n\t\r\n\t__pragma__ ('opov')\r\n\t\r\n\tcomp_a_square = comp_a [ : , : 2]\r\n\tcomp_b_square = comp_b [1 : , : ]\r\n\t\r\n\tcomp_c_square = comp_a_square * comp_b_square\r\n\tcomp_d_square = comp_a_square / comp_b_square\r\n\tcomp_e_square = comp_a_square + comp_b_square\r\n\tcomp_f_square = comp_a_square - comp_b_square\r\n\t\r\n\t__pragma__ ('noopov')\r\n\t\r\n\tautoTester.check ('comp_a_square', comp_a_square.tolist (), '<br>')\r\n\tautoTester.check ('comp_b_square', comp_b_square.tolist (), '<br>')\r\n\tautoTester.check ('comp_c_square', comp_c_square.tolist (), '<br>')\r\n\tautoTester.check ('comp_d_square', num.round (comp_d_square, 2).tolist (), '<br>')\r\n\tautoTester.check ('comp_e_square', comp_e_square.tolist (), '<br>')\r\n\tautoTester.check ('comp_f_square', comp_f_square.tolist (), '<br>')\r\n\t\r\n\t__pragma__ ('opov')\r\n\tsliceable_a = num.array ([\r\n\t\t[1, 2, 3, 4],\r\n\t\t[5, 6, 7, 8],\r\n\t\t[9, 10, 11, 12],\r\n\t\t[13, 14, 15, 16]\r\n\t])\r\n\tautoTester.check ('sliceable_a', sliceable_a.tolist ())\r\n\r\n\tslice_a = sliceable_a [1 : , 1 : ]\r\n\tautoTester.check ('slice_a')\r\n\t\r\n\tsliceable_at = sliceable_a.transpose ()\r\n\tslice_at = sliceable_at [1 : ]\r\n\t\r\n\t__pragma__ ('noopov')\r\n\t"""
numscrypt/development/automated_tests/ndarray/module_fft/__init__.py,0,"b""from org.transcrypt.stubs.browser import *\r\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\r\n\r\nfrom math import sin, cos, pi\r\n\r\ntranspiled = __envir__.executor_name == __envir__.transpiler_name\r\n\r\n# Imports for Transcrypt, skipped run time by CPython\r\nif __envir__.executor_name == __envir__.transpiler_name:\r\n\timport numscrypt as num\r\n\timport numscrypt.fft as fft\r\n\r\n# Imports for CPython, skipped compile time by Transcrypt\r\n__pragma__ ('skip')\r\nimport numpy as num\r\nimport numpy.fft as fft\r\n__pragma__ ('noskip')\r\n\r\nfSample = 4096\r\ntTotal = 2\r\nfSin = 30\r\nfCos = 50\r\n\r\ndef getNow ():\t# Avoid operator overloading, which would result in the dysfunctional: __new__ __call__ (Date)\r\n\treturn __new__ (Date ())\r\n\r\ndef tCurrent (iCurrent):\r\n\treturn iCurrent / fSample\r\n\r\ndef run (autoTester):\r\n\t__pragma__ ('opov')\r\n\tdelta = 0.001 + 0.001j\r\n\t__pragma__ ('noopov')\r\n\t\r\n\tautoTester.check ('<br>------ 1D ------<br>')\r\n\t\r\n\tcut = 102\r\n\r\n\tautoTester.check ('Samples computed: {}<br>'.format (tTotal  * fSample))\r\n\tautoTester.check ('Samples shown: {}<br>'.format (cut))\r\n\r\n\torig = num.array ([\r\n\t\tcomplex (0.3 + sin (2 * pi * fSin * t) + 0.5 * cos (2 * pi * fCos * t), 0)\r\n\t\tfor t in [\r\n\t\t\tiSample / fSample\r\n\t\t\tfor iSample in range (tTotal * fSample)\r\n\t\t]\r\n\t], 'complex128')\r\n\t\r\n\t__pragma__ ('opov')\r\n\r\n\tautoTester.check ('Original samples', num.round (orig + delta, 3) .tolist ()[ : cut], '<br>')\r\n\r\n\tif transpiled:\r\n\t\ttimeStartFft = getNow ()\r\n\tfreqs = fft.fft (orig)\r\n\tif transpiled:\r\n\t\ttimeStopFft = getNow ()\t\r\n\t\t\r\n\tautoTester.check ('Frequencies', num.round (freqs + delta, 3) .tolist ()[ : cut], '<br>')\r\n\t\r\n\tif transpiled:\r\n\t\ttimeStartIfft = getNow ()\t\r\n\treconstr = fft.ifft (freqs)\r\n\tif transpiled:\r\n\t\ttimeStopIfft = getNow ()\t\r\n\t\r\n\tautoTester.check ('Reconstructed samples', num.round (reconstr + delta, 3) .tolist ()[ : cut], '<br>')\r\n\t\r\n\t__pragma__ ('noopov')\r\n\t\t\r\n\tif transpiled:\r\n\t\tprint ('FFT for {} samples took {} ms'.format (tTotal * fSample, timeStopFft - timeStartFft))\r\n\t\tprint ('IFFT for {} samples took {} ms'.format (tTotal * fSample, timeStopIfft - timeStartIfft))\r\n\t\t\r\n\tautoTester.check ('<br>------ 2D ------<br>')\r\n\t\r\n\t__pragma__ ('opov')\r\n\r\n\torig2 = num.zeros ((128, 128), 'complex128')\r\n\torig2 [32 : 96, 32 : 96] = num.ones ((64, 64), 'complex128')\r\n\t\r\n\tautoTester.check ('Original samples', num.round (orig2 + delta, 3) [64 : 68, 16 : 112] .tolist (), '<br>')\r\n\t\r\n\tif transpiled:\r\n\t\ttimeStartFft = getNow ()\r\n\t\t\r\n\tfreqs2 = fft.fft2 (orig2)\r\n\tif transpiled:\r\n\t\ttimeStopFft = getNow () \r\n\t\t\r\n\tautoTester.check ('Frequencies', num.round (freqs2 + delta, 3)  [64 : 68, 16 : 112] .tolist (), '<br>')\r\n\t\r\n\tif transpiled:\r\n\t\ttimeStartIfft = getNow ()\r\n\treconstr2 = fft.ifft2 (freqs2)\r\n\tif transpiled:\r\n\t\ttimeStopIfft = getNow ()\t\r\n\t\r\n\tif transpiled:\r\n\t\tprint ('FFT2 for {} samples took {} ms'.format (orig2.size, timeStopFft - timeStartFft))\r\n\t\tprint ('IFFT2 for {} samples took {} ms'.format (orig2.size, timeStopIfft - timeStartIfft))\r\n\t\t\r\n\tautoTester.check ('Reconstructed samples', num.round (reconstr2 + delta, 3)  [64 : 68, 16 : 112] .tolist (), '<br>')\r\n\t\r\n\t__pragma__ ('noopov')\r\n\t\r\n"""
numscrypt/development/automated_tests/ndarray/module_linalg/__init__.py,0,"b""from org.transcrypt.stubs.browser import *\r\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\r\n\r\n# Imports for Transcrypt, skipped run time by CPython\r\nif __envir__.executor_name == __envir__.transpiler_name:\r\n    import numscrypt as num\r\n    import numscrypt.linalg as linalg\r\n\r\n# Imports for CPython, skipped compile time by Transcrypt\r\n__pragma__ ('skip')\r\nimport numpy as num\r\nimport numpy.linalg as linalg\r\nnum.set_printoptions (linewidth = 240)\r\n__pragma__ ('noskip')\r\n\r\ndef run (autoTester):\r\n    autoTester.check ('====== inverse ======')\r\n\r\n    # Real\r\n\r\n    r = num.array ([\r\n        [2.12, -2.11, -1.23], \r\n        [2.31, 1.14, 3.15], \r\n        [1.13, 1.98, 2.81]\r\n    ])\r\n    \r\n    autoTester.check ('Matrix r', num.round (r, 2) .tolist (), '<br>')\r\n    \r\n    ri = linalg.inv (r)\r\n    \r\n    autoTester.check ('Matrix ri', num.round (ri, 2) .tolist (), '<br>')\r\n    \r\n    __pragma__ ('opov')\r\n    rid = r @ ri\r\n    __pragma__ ('noopov')\r\n    \r\n    autoTester.check ('r @ ri', [[int (round (elem)) for elem in row] for row in rid.tolist ()], '<br>')\r\n    \r\n    __pragma__ ('opov')\r\n    delta = 0.001\r\n    autoTester.check ('r * r', num.round (r * r + delta, 3) .tolist (), '<br>')\r\n    autoTester.check ('r / r', num.round (r / r + delta, 3) .tolist (), '<br>')\r\n    autoTester.check ('r + r', num.round (r + r + delta, 3) .tolist (), '<br>')\r\n    autoTester.check ('r - r', num.round (r - r + delta, 3) .tolist (), '<br>')\r\n    __pragma__ ('noopov')\r\n\r\n    # Complex\r\n    \r\n    __pragma__ ('opov')\r\n    c = num.array ([\r\n        [2.12 - 3.15j, -2.11, -1.23], \r\n        [2.31, 1.14, 3.15 + 2.75j], \r\n        [1.13, 1.98 - 4.33j, 2.81]\r\n    ], 'complex128')\r\n    __pragma__ ('noopov')\r\n    \r\n    autoTester.check ('Matrix c',  num.round (c, 2) .tolist (), '<br>')\r\n    \r\n    ci = linalg.inv (c)\r\n    \r\n    autoTester.check ('Matrix ci', num.round (ci, 2) .tolist (), '<br>')\r\n    \r\n    __pragma__ ('opov')\r\n    cid = c @ ci\r\n    __pragma__ ('noopov')\r\n    \r\n    # autoTester.check ('c @ ci', [['{} + j{}'.format (int (round (elem.real)), int (round (elem.imag))) for elem in row] for row in cid.tolist ()], '<br>')\r\n    \r\n    __pragma__ ('opov')\r\n    delta = 0.001 + 0.001j\r\n    autoTester.check ('c * c', num.round (c * c + delta , 3) .tolist (), '<br>')\r\n    autoTester.check ('c / c', num.round (c / c + delta, 3) .tolist (), '<br>')\r\n    autoTester.check ('c + c', num.round (c + c + delta, 3) .tolist (), '<br>')\r\n    autoTester.check ('c - c', num.round (c - c + delta, 3) .tolist (), '<br>')\r\n    __pragma__ ('noopov')\r\n    \r\n    autoTester.check ('====== eigen ======')\r\n    \r\n    __pragma__ ('opov')\r\n\r\n    for a in (   \r\n        num.array ([\r\n            [0, 1j],\r\n            [-1j, 1]\r\n        ], 'complex128'),\r\n        num.array ([\r\n            [1, -2, 3, 1],\r\n            [5, 8, -1, -5],\r\n            [2, 1, 1, 100],\r\n            [2, 1, -1, 0]\r\n        ], 'complex128'),\r\n    ):\r\n        eVals, eVecs = linalg.eig (a)\r\n        \r\n        enumSorted = sorted (\r\n            enumerate (eVals.tolist ()),\r\n            key = lambda elem: -(elem [1].real + elem [1].imag / 1000)  # Order on primarily on real, secundarily on imag, note conjugate vals\r\n        )\r\n        \r\n        indicesSorted = [elem [0] for elem in enumSorted]\r\n        eValsSorted = [elem [1] for elem in enumSorted]\r\n        \r\n        eValsMat = num.empty (a.shape, a.dtype)\r\n        for iRow in range (a.shape [0]):\r\n            for iCol in range (a.shape [1]):\r\n                eValsMat [iRow, iCol] = eVals [iCol]\r\n         \r\n        eVecsNorms = num.empty ((eVecs.shape [1], ), a.dtype)\r\n        for iNorm in range (eVecsNorms.shape [0]):\r\n            eVecsNorms [iNorm] = complex (linalg.norm (eVecs [:, iNorm]))\r\n            \r\n        eVecsCanon = num.empty (a.shape, a.dtype)\r\n        for iRow in range (a.shape [0]):\r\n            for iCol in range (a.shape [1]):\r\n                eVecsCanon [iRow, iCol] = eVecs [iRow, iCol] / eVecs [0, iCol] \r\n            \r\n        eVecsSorted = num.empty (a.shape, a.dtype)\r\n        for iRow in range (a.shape [0]):\r\n            for iCol in range (a.shape [1]):\r\n                eVecsSorted [iRow, iCol] = eVecsCanon [iRow, indicesSorted [iCol]]\r\n            \r\n        '''\r\n        autoTester.check ('\\n---------------- a ----------------------')\r\n        autoTester.check (a)\r\n        autoTester.check ('\\n---------------- eigVals ----------------')\r\n        autoTester.check (eVals)\r\n        autoTester.check ('\\n---------------- eigValsMat--------------')\r\n        autoTester.check (eValsMat)\r\n        autoTester.check ('\\n---------------- eigVecs ----------------')\r\n        autoTester.check (eVecs)\r\n        autoTester.check ('\\n---------------- eigValsMat @ eigVecs ---')\r\n        autoTester.check (eValsMat * eVecs)\r\n        autoTester.check ('\\n---------------- a @ eigVecs-------------')\r\n        autoTester.check (a @ eVecs)\r\n        autoTester.check ('\\n---------------- eigVecsNorms -----------')\r\n        autoTester.check (eVecsNorms)\r\n        autoTester.check ('\\n---------------- eigVecsCanon -----------')\r\n        autoTester.check (eVecsCanon)\r\n        '''\r\n        autoTester.check ('\\n---------------- eigVecsSorted ----------')\r\n        autoTester.check ([[(round (value.real + 1e-3, 3), round (value.imag + 1e-3, 3)) for value in row] for row in eVecsSorted.tolist ()])\r\n        autoTester.check ('\\n---------------- eigValsSorted ----------')\r\n        autoTester.check ([(round (value.real + 1e-3, 3), round (value.imag + 1e-3, 3)) for value in eValsSorted], '\\n')\r\n        """
