file_path,api_count,code
LinearRegressionModel.py,3,"b'from sklearn import linear_model\nimport numpy as np\nimport stock_data as sd\n\n\ndef build_model(X, y):\n    """"""\n    build a linear regression model using sklearn.linear_model\n    :param X: Feature dataset\n    :param y: label dataset\n    :return: a linear regression model\n    """"""\n    linear_mod = linear_model.LinearRegression()  # defining the linear regression model\n    X = np.reshape(X, (X.shape[0], 1))\n    y = np.reshape(y, (y.shape[0], 1))\n    linear_mod.fit(X, y)  # fitting the data points in the model\n\n    return linear_mod\n\n\ndef predict_prices(model, x, label_range):\n    """"""\n    Predict the label for given test sets\n    :param model: a linear regression model\n    :param x: testing features\n    :param label_range: normalised range of label data\n    :return: predicted labels for given features\n    """"""\n    x = np.reshape(x, (x.shape[0], 1))\n    predicted_price = model.predict(x)\n    predictions_rescaled, re_range = sd.scale_range(predicted_price, input_range=[-1.0, 1.0], target_range=label_range)\n\n    return predictions_rescaled.flatten()\n\n\n'"
lstm.py,0,"b'from keras.layers.core import Dense, Activation, Dropout\nfrom keras.layers.recurrent import LSTM\nfrom keras.models import Sequential\n\n\ndef build_improved_model(input_dim, output_dim, return_sequences):\n    """"""\n    Builds an improved Long Short term memory model using keras.layers.recurrent.lstm\n    :param input_dim: input dimension of model\n    :param output_dim: ouput dimension of model\n    :param return_sequences: return sequence for the model\n    :return: a 3 layered LSTM model\n    """"""\n    model = Sequential()\n    model.add(LSTM(\n        input_shape=(None, input_dim),\n        units=output_dim,\n        return_sequences=return_sequences))\n\n    model.add(Dropout(0.2))\n\n    model.add(LSTM(\n        128,\n        return_sequences=False))\n\n    model.add(Dropout(0.2))\n\n    model.add(Dense(\n        units=1))\n    model.add(Activation(\'linear\'))\n\n    return model\n\n\ndef build_basic_model(input_dim, output_dim, return_sequences):\n    """"""\n    Builds a basic lstm model \n    :param input_dim: input dimension of the model\n    :param output_dim: output dimension of the model\n    :param return_sequences: return sequence of the model\n    :return: a basic lstm model with 3 layers.\n    """"""\n    model = Sequential()\n    model.add(LSTM(\n        input_shape=(None, input_dim),\n        units=output_dim,\n        return_sequences=return_sequences))\n\n    model.add(LSTM(\n        100,\n        return_sequences=False))\n\n    model.add(Dense(\n        units=1))\n    model.add(Activation(\'linear\'))\n\n    return model\n\n\n'"
preprocess_data.py,0,"b'import pandas as pd\n\n# Import sklearn.preprocessing.StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\n\n\ndef get_normalised_data(data):\n    """"""\n    Normalises the data values using MinMaxScaler from sklearn\n    :param data: a DataFrame with columns as  [\'index\',\'Open\',\'Close\',\'Volume\']\n    :return: a DataFrame with normalised value for all the columns except index\n    """"""\n    # Initialize a scaler, then apply it to the features\n    scaler = MinMaxScaler()\n    numerical = [\'Open\', \'Close\', \'Volume\']\n    data[numerical] = scaler.fit_transform(data[numerical])\n\n    return data\n\n\ndef remove_data(data):\n    """"""\n    Remove columns from the data\n    :param data: a record of all the stock prices with columns as  [\'Date\',\'Open\',\'High\',\'Low\',\'Close\',\'Volume\']\n    :return: a DataFrame with columns as  [\'index\',\'Open\',\'Close\',\'Volume\']\n    """"""\n    # Define columns of data to keep from historical stock data\n    item = []\n    open = []\n    close = []\n    volume = []\n\n    # Loop through the stock data objects backwards and store factors we want to keep\n    i_counter = 0\n    for i in range(len(data) - 1, -1, -1):\n        item.append(i_counter)\n        open.append(data[\'Open\'][i])\n        close.append(data[\'Close\'][i])\n        volume.append(data[\'Volume\'][i])\n        i_counter += 1\n\n    # Create a data frame for stock data\n    stocks = pd.DataFrame()\n\n    # Add factors to data frame\n    stocks[\'Item\'] = item\n    stocks[\'Open\'] = open\n    stocks[\'Close\'] = pd.to_numeric(close)\n    stocks[\'Volume\'] = pd.to_numeric(volume)\n\n    # return new formatted data\n    return stocks\n\n'"
stock_data.py,5,"b'import numpy as np\nimport math\n\n\ndef scale_range(x, input_range, target_range):\n    """"""\n\n    Rescale a numpy array from input to target range\n    :param x: data to scale\n    :param input_range: optional input range for data: default 0.0:1.0\n    :param target_range: optional target range for data: default 0.0:1.0\n    :return: rescaled array, incoming range [min,max]\n    """"""\n\n    range = [np.amin(x), np.amax(x)]\n    x_std = (x - input_range[0]) / (1.0*(input_range[1] - input_range[0]))\n    x_scaled = x_std * (1.0*(target_range[1] - target_range[0])) + target_range[0]\n    return x_scaled, range\n\n\ndef train_test_split_linear_regression(stocks):\n    """"""\n        Split the data set into training and testing feature for Linear Regression Model\n        :param stocks: whole data set containing [\'Open\',\'Close\',\'Volume\'] features\n        :return: X_train : training sets of feature\n        :return: X_test : test sets of feature\n        :return: y_train: training sets of label\n        :return: y_test: test sets of label\n        :return: label_range: scaled range of label used in predicting price,\n    """"""\n    # Create numpy arrays for features and targets\n    feature = []\n    label = []\n\n    # Convert dataframe columns to numpy arrays for scikit learn\n    for index, row in stocks.iterrows():\n        # print([np.array(row[\'Item\'])])\n        feature.append([(row[\'Item\'])])\n        label.append([(row[\'Close\'])])\n\n    # Regularize the feature and target arrays and store min/max of input data for rescaling later\n    feature_bounds = [min(feature), max(feature)]\n    feature_bounds = [feature_bounds[0][0], feature_bounds[1][0]]\n    label_bounds = [min(label), max(label)]\n    label_bounds = [label_bounds[0][0], label_bounds[1][0]]\n\n    feature_scaled, feature_range = scale_range(np.array(feature), input_range=feature_bounds, target_range=[-1.0, 1.0])\n    label_scaled, label_range = scale_range(np.array(label), input_range=label_bounds, target_range=[-1.0, 1.0])\n\n    # Define Test/Train Split 80/20\n    split = .315\n    split = int(math.floor(len(stocks[\'Item\']) * split))\n\n    # Set up training and test sets\n    X_train = feature_scaled[:-split]\n    X_test = feature_scaled[-split:]\n\n    y_train = label_scaled[:-split]\n    y_test = label_scaled[-split:]\n\n    return X_train, X_test, y_train, y_test, label_range\n\n\ndef train_test_split_lstm(stocks, prediction_time=1, test_data_size=450, unroll_length=50):\n    """"""\n        Split the data set into training and testing feature for Long Short Term Memory Model\n        :param stocks: whole data set containing [\'Open\',\'Close\',\'Volume\'] features\n        :param prediction_time: no of days\n        :param test_data_size: size of test data to be used\n        :param unroll_length: how long a window should be used for train test split\n        :return: X_train : training sets of feature\n        :return: X_test : test sets of feature\n        :return: y_train: training sets of label\n        :return: y_test: test sets of label\n    """"""\n    # training data\n    test_data_cut = test_data_size + unroll_length + 1\n\n    x_train = stocks[0:-prediction_time - test_data_cut].as_matrix()\n    y_train = stocks[prediction_time:-test_data_cut][\'Close\'].as_matrix()\n\n    # test data\n    x_test = stocks[0 - test_data_cut:-prediction_time].as_matrix()\n    y_test = stocks[prediction_time - test_data_cut:][\'Close\'].as_matrix()\n\n    return x_train, x_test, y_train, y_test\n\n\ndef unroll(data, sequence_length=24):\n    """"""\n    use different windows for testing and training to stop from leak of information in the data\n    :param data: data set to be used for unrolling\n    :param sequence_length: window length\n    :return: data sets with different window.\n    """"""\n    result = []\n    for index in range(len(data) - sequence_length):\n        result.append(data[index: index + sequence_length])\n    return np.asarray(result)\n\n\n'"
visualize.py,0,"b'#%matplotlib notebook\n#%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.rcParams[\'figure.figsize\'] = (18, 12)\n\n\ndef price(x):\n    """"""\n    format the coords message box\n    :param x: data to be formatted\n    :return: formatted data\n    """"""\n    return \'$%1.2f\' % x\n\n\ndef plot_basic(stocks, title=\'Google Trading\', y_label=\'Price USD\', x_label=\'Trading Days\'):\n    """"""\n    Plots basic pyplot\n    :param stocks: DataFrame having all the necessary data\n    :param title:  Title of the plot \n    :param y_label: yLabel of the plot\n    :param x_label: xLabel of the plot\n    :return: prints a Pyplot againts items and their closing value\n    """"""\n    fig, ax = plt.subplots()\n    ax.plot(stocks[\'Item\'], stocks[\'Close\'], \'#0A7388\')\n\n    ax.format_ydata = price\n    ax.set_title(title)\n\n    # Add labels\n    plt.ylabel(y_label)\n    plt.xlabel(x_label)\n\n    plt.show()\n\n\ndef plot_prediction(actual, prediction, title=\'Google Trading vs Prediction\', y_label=\'Price USD\', x_label=\'Trading Days\'):\n    """"""\n    Plots train, test and prediction\n    :param actual: DataFrame containing actual data\n    :param prediction: DataFrame containing predicted values\n    :param title:  Title of the plot\n    :param y_label: yLabel of the plot\n    :param x_label: xLabel of the plot\n    :return: prints a Pyplot againts items and their closing value\n    """"""\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # Add labels\n    plt.ylabel(y_label)\n    plt.xlabel(x_label)\n\n    # Plot actual and predicted close values\n\n    plt.plot(actual, \'#00FF00\', label=\'Adjusted Close\')\n    plt.plot(prediction, \'#0000FF\', label=\'Predicted Close\')\n\n    # Set title\n    ax.set_title(title)\n    ax.legend(loc=\'upper left\')\n\n    plt.show()\n\n\ndef plot_lstm_prediction(actual, prediction, title=\'Google Trading vs Prediction\', y_label=\'Price USD\', x_label=\'Trading Days\'):\n    """"""\n    Plots train, test and prediction\n    :param actual: DataFrame containing actual data\n    :param prediction: DataFrame containing predicted values\n    :param title:  Title of the plot\n    :param y_label: yLabel of the plot\n    :param x_label: xLabel of the plot\n    :return: prints a Pyplot againts items and their closing value\n    """"""\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # Add labels\n    plt.ylabel(y_label)\n    plt.xlabel(x_label)\n\n    # Plot actual and predicted close values\n\n    plt.plot(actual, \'#00FF00\', label=\'Adjusted Close\')\n    plt.plot(prediction, \'#0000FF\', label=\'Predicted Close\')\n\n    # Set title\n    ax.set_title(title)\n    ax.legend(loc=\'upper left\')\n\n\n    plt.show()\n\n'"
