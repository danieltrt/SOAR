file_path,api_count,code
demo.py,1,"b'import shaded as sd\nfrom sounddevice import play\nimport soundfile as sf\nimport numpy as np\nsong = sd.space(13)\noverall_env = sd.smoothstep(0,1,song) - sd.smoothstep(12,14.8,song)\n\nbass_line = sd.arp(song, [110, 130.81, 146.83, 110]*5) #this time, the ""*"" means we\'re repeating\nbass_line_wave = sd.smooth_normalize(sd.sin(song, bass_line) * sd.pulse(song, 3, 0.333, normalize=False))\n\ndrums = sd.noise(song) * sd.sigmoid(song, 10) * sd.sigmoid(song, 12, 0.25*2*np.pi) * 0.2\n\nmelody_a = sd.arp(song, [440, 880, 440, 220])\nmelody_b = sd.arp(song, [523.25, 392.00, 659.25]*6)\nstring = sd.saw(song, melody_a) * 0.25 + sd.saw(song, melody_b) * 0.25\n\nfull_song = bass_line_wave * sd.smoothstep(2, 3, song) + drums * 0.25 + string * 0.5 * (sd.smoothstep(4, 6, song) - sd.smoothstep(8, 10, song))\n\nsf.write(\'working/demo.wav\',full_song, int(44100), \'FLOAT\')'"
example.py,6,"b'import time\nimport sys\nimport numpy as np\nimport shaded as sp\nimport sounddevice as sd\nimport soundfile as sf\n\ndef play(sound, sample_rate=sp.SAMPLE_RATE):\n  """"""Helper to play serially""""""\n  sd.play(sound)\n  time.sleep(len(sound) / sample_rate)\n\nspace = sp.space(3)\n\none_hz = (sp.sin(space, 1.) / 2. + 0.5) #beating\nconcertA = sp.sin(space, 440) #concert A sin wave for three seconds\nmodulatedA = concertA * one_hz #beating w/ a sin wave\nbuzz = sp.sigmoid(sp.sin(space,60), sp.sin(space,60)+220)*0.5 #buzzing by modulating frequency\ndiv = (sp.sin(space, 17) / sp.sin(space, 3)) * 0.2 * concertA #dividing signals to generate complex waveforms\ncomplex_beat = sp.noise(space)*(sp.sigmoid(space, 2) - sp.sin(space,0.4) - sp.sin(space,0.25,1)) + sp.sin(space, 440)*(sp.sin(space,3)-sp.sin(space,4.25)) + sp.sin(space,310)*(sp.sin(space,3,1.254)) #complex beat\nfmod = sp.sin(space, sp.sin(space, 2) * 220) #because of broadcasting, you can use waves to control the frequency of other waves\nderiv = sp.sin(sp.sin(space, 2) * 2 * np.pi, sp.sin(space, 20) * 3) #the sin of a sin\nsquare = sp.square(space,440) #square wave\nmodulated_square = sp.square(space,440)*sp.sin(space,440)-sp.square(space,443,0.5) #combining waves\nbeating = (sp.sin(space,440) + sp.sin(space,110)) * sp.square(space,90000) * sp.square(space,1.50) * sp.sin(space,3) * sp.square(space,11) * sp.sin(space,0.5)\nwamp = np.clip((sp.sin(space,200) - sp.square(space,101)*0.25) * (sp.sin(space,1.74) + sp.sin(space,sp.sin(space,200)*3+220-sp.sin(space,30)) + sp.sin(space,12)*0.25), -1., 1.)\narp = sp.saw(space,sp.arp(space,[60,70,80,90,120,90,80,70,60])) * sp.sin(space,1.7) * sp.sin(space,3)\nripple = np.fmod(sp.saw(space, sp.arp(space, [220, 240, 275,220,170]*5)), sp.saw(space, 0.3333)) * sp.saw(space, 0.7, shift=np.pi/2.)\npurr = sp.reverb(np.fmod(sp.saw(space, 1), sp.sin(space, 12)*2.), 0.125, 5, 0.75)\nsnare = sp.noise(space)*(sp.gated_pulse(space,3,0.15) + sp.gated_pulse(space,4,0.15,-np.pi))*sp.sin(space,220)*sp.sin(space,2) #use pulses to create rhythmic patterns\nfull_demo = np.concatenate((concertA, modulatedA, buzz, div, complex_beat, fmod, deriv, square, modulated_square, beating, wamp, arp, ripple, purr, snare))\n\nif len(sys.argv) == 1 or sys.argv[1] == \'play\':\n  play(concertA) \n  play(modulatedA)\n  play(square)\n  play(modulated_square)\n  play(buzz) \n  play(buzz*one_hz) \n  play(div)\n  play(complex_beat) \n  play(fmod) \n  play(deriv) #this is just nutty\n  play(complex_beat[::-1])\n  play(beating)\n  play(wamp)\n  play(arp)\n  play(ripple)\n  play(purr)\n  play(snare)\n\ndef save(name, data):\n  sf.write(name, data, int(sp.SAMPLE_RATE), \'FLOAT\')\n\nif len(sys.argv) > 1 and sys.argv[1] == \'save\':\n  save(\'samples/concertA.wav\', concertA)\n  save(\'samples/modulatedA.wav\', modulatedA)\n  save(\'samples/square.wav\', square)\n  save(\'samples/modulated_square.wav\', modulated_square)\n  save(\'samples/buzz.wav\', buzz)\n  save(\'samples/modulatedBuzz.wav\', buzz*one_hz)\n  save(\'samples/div.wav\', div)\n  save(\'samples/complex.wav\', complex_beat)\n  save(\'samples/fmod.wav\', fmod)\n  save(\'samples/deriv.wav\', deriv)\n  save(\'samples/beating.wav\', beating)\n  save(\'samples/wamp.wav\', wamp)\n  save(\'samples/arp.wav\', arp)\n  save(\'samples/ripple.wav\', ripple)\n  save(\'samples/purr.wav\', purr)\n  save(\'samples/snare.wav\', snare)\n  save(\'samples/full_demo.wav\', full_demo)\n'"
compositions/barron.py,10,"b'import time\nimport numpy as np\nimport sounddevice as sd\nimport soundfile as sf\nimport shaded as sp\nfrom shaded.const import SAMPLE_RATE\n\ndef play(sound, sample_rate=SAMPLE_RATE):\n  """"""Helper to play serially""""""\n  sd.play(sound)\n  time.sleep(len(sound) / sample_rate)\n\ndef save(path, sound, sample_rate=SAMPLE_RATE):\n  sf.write(path, sound, int(sample_rate), \'FLOAT\')\n\ndef bass_prog(space, reps=3):\n  prog = sp.arp(space, [60, 65, 80, 85, 60, 65, 80, 83, 70, 72]*reps)\n  return sp.pulse(space, prog, 0.45)\n\ndef bass_beat(space):\n  return sp.gated_pulse(space, 2, 0.8) + sp.gated_pulse(space, 5, 0.25)\n\ndef bass_enter_exit(space, reps=3):\n  return sp.arp(space, [1, 1, 1, 1.25, 0.75, 0.25, 0.25, 0.125, 0.125, 0, 0, 0, 0.5, 0.5, 0.5, 0.25, 0.25, 1, 1, 1]*reps)\n\ndef drum_line(space):\n  return (sp.saw(space+sp.noise(space)*0.004+sp.saw(space,12)*5., 40) *\n     sp.gated_pulse(space, 4, 0.25) * sp.sin(space, 4) + sp.gated_pulse(space, 4, 0.125, np.pi*0.1))\n\ndef melody_gate(space, start, stop):\n  return np.fmin(sp.gate(space, start), np.logical_not(sp.gate(space, stop))) * sp.gated_pulse(space, 1./5., 0.8)\n\ndef melody_pattern(space, base=220, low=0.2, high=4., steps=5, reps=3):\n  mults = np.linspace(low, high, steps) * base\n  np.random.shuffle(mults)\n  return sp.arp(space, np.repeat(mults, reps))\n\ndef melody_rhthym(space):\n  return sp.sigmoid(space, 0.25) * sp.gated_pulse(space, 1, 0.3333) + sp.sin(space, 1, np.pi)\n\ndef melody(space):\n  return sp.scale_normalize(\n    sp.reverb(sp.saw(song, melody_pattern(song, steps=7, reps=25)), 1./60., 5) -\n    sp.reverb(sp.saw(song, melody_pattern(song, 0.5, 2, 15, 7)), 1./55., 5)\n  ) * sp.square(space+sp.sin(space, 1./40.)*40, 40)\n\ndef whispers(space):\n  return sp.scale_normalize(\n    sp.noise(space) * 0.03 - sp.sin(space + sp.noise(space)*0.0001, sp.arp(space, np.array([98,99,98,99,97,98,99,97,96,99]*10)) * 5.) * 0.45\n    * sp.pulse(sp.sin(space, 0.01) * 50, 120, 0.25) * 0.02\n  )\n\ndef whisper_slide(space):\n  return (\n    sp.sin(space, 0.01) * sp.sin(space,0.02) * sp.sin(space, sp.arp(space, [0.125, 0.5, 0.9, 3., 3.2, 0.125, 0.52, 0.4, 3., 9, 0.125]))\n  )\n\ndef closing_scream(space):\n  return sp.saw(space, 990-sp.sin(space, 3)) - sp.saw(space/5.*sp.sin(space, 0.1), 890) - sp.saw(space, 650)\n\ndef rpeak(space):\n  dur = len(space) / sp.SAMPLE_RATE\n  return sp.saw(space, dur / 20., np.pi/4.) * sp.gate(space, dur / 20. * 19.)\n\nsong = sp.space(120)\nbass_line = sp.reverb(bass_prog(song, 20) * bass_beat(song) * bass_enter_exit(song, 7), 1./15., 10)\ndrums = sp.reverb(drum_line(song), -1./30., 7)\nmel = melody(song) * melody_rhthym(song) * melody_gate(song, 3., 100)\nwhispered = sp.reverb(whispers(song) * whisper_slide(song), 1./50., 12, 0.7)\nclosing = sp.reverb(closing_scream(song), -1., 10) * rpeak(song)\n\ncomposition = (bass_line + drums * 0.5 + mel - whispered * 0.25 + closing + np.roll(closing, int(-30*sp.SAMPLE_RATE)) +\n  np.roll(closing, int(-60*sp.SAMPLE_RATE)) - np.fmod(np.roll(closing, int(17*sp.SAMPLE_RATE)), 0.75)\n) * sp.sin(song, 1./60.)\n\nsf.write(\'working/the_barron.wav\', composition, int(sp.SAMPLE_RATE), \'FLOAT\')\nplay(\n  composition\n)\n'"
shaded/__init__.py,25,"b'import numpy as np\nfrom .const import SAMPLE_RATE\n\ndef smoothstep(edge0, edge1, x):\n  """"""\n  Hermite Interpolation, lifted from OpenGL shaders.\n\n  Converts a data stream into a sigmoid from edge0 to edge1 (outputting in the range [0.,1.])\n  """"""\n  t = np.clip((x - edge0) / (edge1 - edge0), 0.0, 1.0)\n  return t * t * (3.0 - 2.0 * t)\n\ndef step(space):\n  """"""A shelf function: all entries in space <= 0 become 0, all greater than 0 become 1.""""""\n  return np.heaviside(space, 0)\n\ndef gate(space, point):\n  """"""Open (or with a `np.not`, close) a gate based on the absolute magnitude of values in space""""""\n  return step(np.abs(space) - point)\n\ndef smooth_normalize(space):\n  """"""\n  Take an arbitrary range and compact it into the range -1,1,\n  by applying a `smoothstep`\n  \n  input sets smaller than -1,1 are left unchanged\n  """"""\n  mi = np.min(space)\n  mx = np.max(space)\n  if mi >= -1. and mx < 1.:\n    return space\n  return smoothstep(np.min(space), np.max(space), space) * 2. - 1.\n\ndef scale_normalize(space):\n  """"""\n  Take an arbitrary range and compact it into the range -1,1\n  by scaling it relative to its peaks.\n\n  input sets smaller than the input range will be scaled UP\n  """"""\n  mx = np.max(np.abs(space))\n  return space / mx\n\ndef average(space, window, sample_rate=SAMPLE_RATE):\n  """"""\n  Average across a duration, ""smoothing out"" the signal.\n  """"""\n  return np.convolve(space, np.ones(int(window*sample_rate)), mode=\'same\') / (window * sample_rate)\n\ndef convolve(space, kernel):\n  """"""Convolve the signal using a 1D kernel""""""\n  return np.convolve(space, kernel, mode=\'same\')\n\ndef space(duration, sample_rate=SAMPLE_RATE):\n  """"""Generate a temporal space of `duration` seconds at `sample_rate` sampling frequency""""""\n  return np.linspace(0, duration, duration*sample_rate)\n\ndef noise(space):\n  """"""Output random noise in the same range as our temporal space""""""\n  return (np.random.random(len(space)) - 0.5) * 2.\n\ndef sin(space, freq,shift=0):\n  """"""Convert an input space to a sinusoidal wave with `freq` frequency. `shift` moves the phase.""""""\n  return np.sin(2*np.pi*space*freq+shift)\n\ndef sigmoid(space, freq, shift=0):\n  """"""Convert an input space to a sigmoidal wave with `freq` frequency. `shift` moves the phase.""""""\n  return smoothstep(0, 1., sin(space, freq, shift)) + smoothstep(-1., 0., sin(space, freq, shift))\n\ndef square(space, freq, shift=0):\n  """"""Generate a square wave by gating a sin""""""\n  return np.sign(sin(space, freq, shift))\n\ndef pulse(space, freq, duty_cycle=0.5, shift=0, normalize=True):\n  """"""\n  Generate a rectangular wave with a given duty cycle \n\n  This wave may either be in the range [0,1] (if normalize==False)\n  or may be in the range [-1,1] (if normalize==True, the default)\n  """"""\n  s = square(space, freq, shift)\n  t = square(space, freq, shift+duty_cycle*2*np.pi)\n  wav = np.heaviside(s-t,0)\n  if normalize:\n    return wav * 2. - 1\n  return wav\n\ndef gated_pulse(space, freq, duty_cycle, shift=0):\n  """"""A convenience wrapper around pulse which returns a non-normalized pulse. Good for gates""""""\n  return pulse(space, freq, duty_cycle, shift, False)\n\ndef saw(space, freq, shift=0):\n  """"""Sawtooth wave""""""\n  return np.arctan(\n    1. / np.tan(\n      space * np.pi * freq + shift\n    )\n  )\n  \ndef delay(space, distance, wet=0.5, dry=0.5, sample_rate=SAMPLE_RATE):\n  """"""Delay and mix""""""\n  d = int(distance * sample_rate)\n  return np.roll(space, d) * wet + space * dry\n\ndef reverb(space, delay_time, iterations, falloff=0.5, sample_rate=SAMPLE_RATE):\n  """"""\n  Simple reverb with a gradual decay over time. `delay_time` is the echo time, `iterations` is how many echos to \n  generate, `falloff` is how much quieter each echo is\n  """"""\n  res = np.zeros(space.shape)\n  d = np.copy(space)\n  for i in range(iterations):\n    d = delay(d, delay_time, wet=falloff, dry=0., sample_rate=SAMPLE_RATE)\n    res += d\n  return res\n\ndef arp(space, sequence):\n  """"""\n  Breaks an arbitrary space up into equal sized units of sequence.\n  """"""\n  res = np.zeros(space.shape)\n  split = np.array_split(res, len(sequence)) #\n  for v,s in zip(sequence,split):\n    s[::] = v\n  return res\n\ndef repeat(space, data_space):\n  """"""Repeat a dataset to fill our entire space via tiling""""""\n  return np.tile(data_space, int(len(space)/len(data_space)))\n'"
shaded/const.py,0,b'SAMPLE_RATE=44100.'
tests/arp.py,1,"b'import unittest\nimport numpy as np\nimport shaded as sp\n\nclass ArpTest(unittest.TestCase):\n  def setUp(self):\n    self.steps = [0,1,2,3]\n\n  def test_arp(self):\n    space = np.linspace(0,10)\n    arped = sp.arp(space, [1,2,3])\n    self.assertEqual(arped[0], 1.)\n    self.assertEqual(arped[17], 2.)\n\nif __name__ == ""__main__"":\n  unittest.main()'"
tests/waves.py,4,"b'import unittest\nimport numpy as np\nimport shaded as sp\n\nclass SquareTest(unittest.TestCase):\n  def test_square_range(self):\n    """"""Confirm that square waves fall in the correct range- -1,1.""""""\n    sq = sp.square(sp.space(3), 100)\n    self.assertEqual(np.max(sq), 1.)\n    self.assertEqual(np.min(sq), -1.)\n\n  def test_pulse(self):\n    """"""Confirm that duty cycles work""""""\n    space = sp.space(3)\n    fif = sp.pulse(space, 100)\n    tw5 = sp.pulse(space, 100, 0.25)\n    fif_high = len(np.where(fif==1.)[0])\n    tw5_high = len(np.where(tw5==1.)[0])\n    self.assertAlmostEqual(fif_high / len(space), 0.5, 2)\n    self.assertAlmostEqual(tw5_high / len(space), 0.25, 2)\n\nif __name__ == ""__main__"":\n  unittest.main()'"
