file_path,api_count,code
Decision_boundary.py,5,"b'import os\nimport numpy as np\nnp.random.seed(0)\nfrom sklearn import datasets\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\nfrom keras.callbacks import Callback\n\nepoch_count=0\ncount=0\n\ndef plot_decision_boundary(X, y, model,epoch_count,count,steps=1000, cmap=\'Paired\'):\n    """"""\n    Function to plot the decision boundary and data points of a model.\n    Data points are colored based on their actual label.\n    """"""\n    cmap = plt.get_cmap(cmap)\n\n    # Define region of interest by data limits\n    xmin, xmax = X[:,0].min() - 1, X[:,0].max() + 1\n    ymin, ymax = X[:,1].min() - 1, X[:,1].max() + 1\n    steps = 1000\n    x_span = np.linspace(xmin, xmax, steps)\n    y_span = np.linspace(ymin, ymax, steps)\n    xx, yy = np.meshgrid(x_span, y_span)\n\n    # Make predictions across region of interest\n    labels = model.predict(np.c_[xx.ravel(), yy.ravel()])\n\n    # Plot decision boundary in region of interest\n    z = labels.reshape(xx.shape)\n\n    fig, ax = plt.subplots()\n    ax.contourf(xx, yy, z, cmap=cmap, alpha=0.5)\n    fig.suptitle(""Epoch: ""+str(epoch_count), fontsize=10)\n    # Get predicted labels on training data and plot\n    train_labels = model.predict(X)\n    ax.scatter(X[:,0], X[:,1], c=y, cmap=cmap, lw=0)\n    fig.savefig(""images_new/""+str(count)+""_nn.png"")\n    return epoch_count\n\n# Keras callback to save decision boundary after each epoch\nclass prediction_history(Callback):\n    def __init__(self):\n        self.epoch_count=epoch_count\n        self.count=count\n    def on_epoch_end(self,epoch,logs={}):\n        if self.epoch_count%20==0:\n            plot_decision_boundary(X, y, model,self.epoch_count,self.count,cmap=\'RdBu\')\n            self.count=self.count+1\n        self.epoch_count=self.epoch_count+1\n        return self.epoch_count\n\n\n\nif __name__ == ""__main__"":\n    X, y = datasets.make_moons(n_samples=1000, noise=0.1, random_state=0)\n\n    # Create a directory where image will be saved\n    os.makedirs(""images_new"", exist_ok=True)\n\n    # Define our model object\n    model = Sequential()\n    # kwarg dict for convenience\n    layer_kw = dict(activation=\'sigmoid\', init=\'glorot_uniform\')\n    # Add layers to our model\n    model.add(Dense(output_dim=5, input_shape=(2, ), **layer_kw))\n    model.add(Dense(output_dim=5, **layer_kw))\n    model.add(Dense(output_dim=1, **layer_kw))\n    sgd = SGD(lr=0.1)\n    # Compile model\n    model.compile(optimizer=sgd, loss=\'binary_crossentropy\')\n    predictions=prediction_history()\n    model.fit(X[:500], y[:500],verbose=0,epochs=4000, shuffle=True,callbacks=[predictions])\n'"
