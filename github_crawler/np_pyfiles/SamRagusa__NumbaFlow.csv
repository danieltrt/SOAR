file_path,api_count,code
simple_use.py,2,"b'import numbaflow as nf\nimport numpy as np\n\n\n""""""\nBefore running you must build the cffi library, which can be done by running the builder.py file (which is within\nthe numbaflow package). \n""""""\n\n\nif __name__ == ""__main__"":\n    eval_fn, closer_fn = nf.create_eval_fn()\n\n    dummy_pieces = np.array([96], dtype=np.uint8)\n    dummy_occupied = np.ones(1, np.uint64)\n\n    results = eval_fn(dummy_pieces, dummy_occupied)\n\n    print(""Results:"", results)\n\n    closer_fn()\n'"
numbaflow/__init__.py,1,"b'import cffi\n\nffi = cffi.FFI()\n\nimport numpy as np\n\nfrom numba import cffi_support\n\nimport numbaflow._tensorflow_ffi as _tensorflow_ffi\n\n\n\ncffi_support.register_module(_tensorflow_ffi)\n\nget_info_struct = _tensorflow_ffi.lib.create_run_info\nclose_info_struct = _tensorflow_ffi.lib.close_run_info\nsess_run = _tensorflow_ffi.lib.sess_run\n\n\ndef create_eval_fn():\n    info_struct = get_info_struct()\n\n    def evaluator(pieces, masks):\n        returned_pointer = sess_run(\n            info_struct,\n            ffi.cast(""uint8_t *"", ffi.from_buffer(pieces)),\n            ffi.cast(""uint64_t *"", ffi.from_buffer(masks)),\n            len(masks),\n            len(pieces))\n\n        result_buff = ffi.buffer(returned_pointer)\n        return np.frombuffer(result_buff, dtype=np.float32)\n\n    closer = lambda : close_info_struct(info_struct)\n\n    return evaluator, closer\n'"
numbaflow/builder.py,0,"b'from cffi import FFI\n\n\nffi = FFI()\n\nffi.set_source(\n    module_name=\'_tensorflow_ffi\',\n    source=\'#include ""tensorflow_interface.h""\',\n    sources=[""tensorflow_interface.c""],\n    libraries=[""tensorflow""])\n\nffi.cdef(\'\'\'\\\ntypedef ... run_info;\n\nrun_info *create_run_info(void);\nvoid close_run_info(run_info*);\nfloat *sess_run(run_info*, uint8_t*, uint64_t*, int, int);\n\'\'\')\n\n\n\nif __name__ == \'__main__\':\n    ffi.compile(verbose=True)'"
