file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n\nfrom setuptools import setup\n\n\nif __name__ == ""__main__"":\n    setup()\n'"
tephi/__init__.py,14,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nThe tephi module provides tephigram plotting of pressure, temperature and wind\nbarb data.\n\n.. warning::\n    This is a beta release module and is liable to change.\n\n""""""\nfrom collections import namedtuple\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom matplotlib.font_manager import FontProperties\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import (\n    GridHelperCurveLinear,\n)\nfrom mpl_toolkits.axisartist import Subplot\nimport numbers\nimport numpy as np\nimport os.path\n\nfrom . import isopleths\nfrom . import transforms\nfrom .utils.report import Report  # noqa\n\n\n__version__ = ""0.3.0.dev0""\n\n\n#\n# Miscellaneous constants.\n#\nDEFAULT_WIDTH = 700  # in pixels\n\nISOBAR_SPEC = [(25, 0.03), (50, 0.10), (100, 0.25), (200, 1.5)]\nISOBAR_LINE = {""color"": ""blue"", ""linewidth"": 0.5, ""clip_on"": True}\nISOBAR_TEXT = {\n    ""size"": 8,\n    ""color"": ""blue"",\n    ""clip_on"": True,\n    ""va"": ""bottom"",\n    ""ha"": ""right"",\n}\nISOBAR_FIXED = [50, 1000]\n\nWET_ADIABAT_SPEC = [(1, 0.05), (2, 0.15), (4, 1.5)]\nWET_ADIABAT_LINE = {""color"": ""orange"", ""linewidth"": 0.5, ""clip_on"": True}\nWET_ADIABAT_TEXT = {\n    ""size"": 8,\n    ""color"": ""orange"",\n    ""clip_on"": True,\n    ""va"": ""bottom"",\n    ""ha"": ""left"",\n}\nWET_ADIABAT_FIXED = None\n\nMIXING_RATIO_SPEC = [(1, 0.05), (2, 0.18), (4, 0.3), (8, 1.5)]\nMIXING_RATIO_LINE = {""color"": ""green"", ""linewidth"": 0.5, ""clip_on"": True}\nMIXING_RATIO_TEXT = {\n    ""size"": 8,\n    ""color"": ""green"",\n    ""clip_on"": True,\n    ""va"": ""bottom"",\n    ""ha"": ""right"",\n}\nMIXING_RATIOS = [\n    0.001,\n    0.002,\n    0.005,\n    0.01,\n    0.02,\n    0.03,\n    0.05,\n    0.1,\n    0.15,\n    0.2,\n    0.3,\n    0.4,\n    0.5,\n    0.6,\n    0.8,\n    1.0,\n    1.5,\n    2.0,\n    2.5,\n    3.0,\n    4.0,\n    5.0,\n    6.0,\n    7.0,\n    8.0,\n    9.0,\n    10.0,\n    12.0,\n    14.0,\n    16.0,\n    18.0,\n    20.0,\n    24.0,\n    28.0,\n    32.0,\n    36.0,\n    40.0,\n    44.0,\n    48.0,\n    52.0,\n    56.0,\n    60.0,\n    68.0,\n    80.0,\n]\nMIXING_RATIO_FIXED = None\n\nMIN_PRESSURE = 50  # mb = hPa\nMAX_PRESSURE = 1000  # mb = hPa\nMIN_THETA = 0  # degC\nMAX_THETA = 250  # degC\nMIN_WET_ADIABAT = 1  # degC\nMAX_WET_ADIABAT = 60  # degC\nMIN_TEMPERATURE = -50  # degC\n\n\nRESOURCES_DIR = os.path.join(os.path.abspath(os.path.dirname(__file__)), ""etc"")\nDATA_DIR = os.path.join(RESOURCES_DIR, ""test_data"")\n\n\ndef loadtxt(*filenames, **kwargs):\n    """"""\n    Load one or more text files of pressure, temperature, wind speed and wind\n    direction value sets.\n\n    Each line should contain, at minimum, a single pressure value (mb or hPa),\n    and a single temperature value (degC), but may also contain a dewpoint\n    value (degC), wind speed (knots) and wind direction value (degrees from\n    north).\n\n    Note that blank lines and comment lines beginning with a \'#\' are ignored.\n\n    For example:\n\n    >>> import os.path\n    >>> import tephi\n\n    >>> winds = os.path.join(tephi.DATA_DIR, \'barbs.txt\')\n    >>> columns = (\'pressure\', \'dewpoint\', \'wind_speed\', \'wind_direction\')\n    >>> data = tephi.loadtxt(winds, column_titles=columns)\n    >>> pressure = data.pressure\n    >>> dews = data.dewpoint\n    >>> wind_speed = data.wind_speed\n    >>> wind_direction = data.wind_direction\n\n    .. seealso:: :func:`numpy.loadtxt`.\n\n    Args:\n\n    * filenames: one or more filenames.\n\n    Kwargs:\n\n    * column_titles:\n        List of iterables, or None. If specified, should contain one title\n        string for each column of data per specified file. If all of multiple\n        files loaded have the same column titles, then only one tuple of column\n        titles need be specified.\n\n    * delimiter:\n        The string used to separate values. This is passed directly to\n        :func:`np.loadtxt`, which defaults to using any whitespace as delimiter\n        if this keyword is not specified.\n\n    * dtype:\n        The datatype to cast the data in the text file to. Passed directly to\n        :func:`np.loadtxt`.\n\n    Returns:\n        A :func:`collections.namedtuple` instance containing one tuple, named\n        with the relevant column title if specified, for each column of data\n        in the text file loaded. If more than one file is loaded, a sequence\n        of namedtuples is returned.\n\n    """"""\n\n    def _repr(nt):\n        """"""An improved representation of namedtuples over the default.""""""\n\n        typename = nt.__class__.__name__\n        fields = nt._fields\n        n_fields = len(fields)\n        return_str = ""{}(\\n"".format(typename)\n        for i, t in enumerate(fields):\n            gap = "" "" * 4\n            if i == n_fields - 1:\n                ender = """"\n            else:\n                ender = ""\\n""\n            return_str += ""{}{}={!r}{}"".format(gap, t, getattr(nt, t), ender)\n        return_str += "")""\n        return return_str\n\n    column_titles = kwargs.pop(""column_titles"", None)\n    delimiter = kwargs.pop(""delimiter"", None)\n    dtype = kwargs.pop(""dtype"", ""f4"")\n\n    if column_titles is not None:\n        fields = column_titles[0]\n        if not isinstance(column_titles, str):\n            if isinstance(fields, Iterable) and not isinstance(fields, str):\n                # We\'ve an iterable of iterables - multiple titles is True.\n                multiple_titles = True\n                if len(column_titles) > len(filenames):\n                    msg = ""Received {} files but {} sets of column titles.""\n                    raise ValueError(\n                        msg.format(len(column_titles), len(filenames))\n                    )\n            elif isinstance(fields, str):\n                # We\'ve an iterable of title strings - use for namedtuple.\n                tephidata = namedtuple(""tephidata"", column_titles)\n                multiple_titles = False\n            else:\n                # Whatever we\'ve got it isn\'t iterable, so raise TypeError.\n                msg = ""Expected title to be string, got {!r}.""\n                raise TypeError(msg.format(type(column_titles)))\n        else:\n            msg = ""Expected column_titles to be iterable, got {!r}.""\n            raise TypeError(msg.format(type(column_titles)))\n\n    else:\n        tephidata = namedtuple(""tephidata"", (""pressure"", ""temperature""))\n        multiple_titles = False\n\n    data = []\n    for ct, arg in enumerate(filenames):\n        if isinstance(arg, str):\n            if os.path.isfile(arg):\n                if multiple_titles:\n                    tephidata = namedtuple(""tephidata"", column_titles[ct])\n                tephidata.__repr__ = _repr\n                payload = np.loadtxt(arg, dtype=dtype, delimiter=delimiter)\n                item = tephidata(*payload.T)\n                data.append(item)\n            else:\n                msg = ""Item {} is either not a file or does not exist.""\n                raise OSError(msg.format(arg))\n\n    if len(data) == 1:\n        data = data[0]\n\n    return data\n\n\nclass _FormatterTheta:\n    """"""Dry adiabats potential temperature axis tick formatter.""""""\n\n    def __call__(self, direction, factor, values):\n        return [r""$\\theta={:.1f}$"".format(value) for value in values]\n\n\nclass _FormatterIsotherm:\n    """"""Isotherms temperature axis tick formatter.""""""\n\n    def __call__(self, direction, factor, values):\n        return [r""  $T={:.1f}$"".format(value) for value in values]\n\n\nclass Locator:\n    """"""\n    Determine the fixed step axis tick locations when called with a tick range.\n\n    """"""\n\n    def __init__(self, step):\n        """"""\n        Set the fixed step value for the axis tick locations.\n\n        Generate tick location specification when called with a tick range.\n\n        For example:\n\n            >>> from tephi import Locator\n            >>> locator = Locator(10)\n            >>> locator(-45, 23)\n            (array([-45., -35., -25., -15.,  -5.,   5.,  15.,  25.]), 8, 1)\n\n        Args:\n\n        * step: the step value for each axis tick.\n\n        """"""\n        self.step = int(step)\n\n    def __call__(self, start, stop):\n        """"""Calculate the axis ticks given the provided tick range.""""""\n\n        step = self.step\n        start = (int(start) / step) * step\n        stop = (int(stop) / step) * step\n        ticks = np.arange(start, stop + step, step)\n\n        return ticks, len(ticks), 1\n\n\ndef _refresh_isopleths(axes):\n    """"""\n    Refresh the plot isobars, wet adiabats and mixing ratios and associated\n    text labels.\n\n    Args:\n\n    * axes:\n        Tephigram plotting :class:`matplotlib.axes.AxesSubplot` instance.\n\n    Returns:\n        Boolean, whether the plot has changed.\n\n    """"""\n    changed = False\n\n    # Determine the current zoom level.\n    xlim = axes.get_xlim()\n    delta_xlim = xlim[1] - xlim[0]\n    ylim = axes.get_ylim()\n    zoom = delta_xlim / axes.tephigram_original_delta_xlim\n\n    # Determine the display mid-point.\n    x_point = xlim[0] + delta_xlim * 0.5\n    y_point = ylim[0] + (ylim[1] - ylim[0]) * 0.5\n    xy = np.array([[x_point, y_point]])\n    xy_point = axes.tephigram_inverse.transform(xy)[0]\n\n    for profile in axes.tephigram_profiles:\n        profile.refresh()\n\n    for isopleth in axes.tephigram_isopleths:\n        changed = isopleth.refresh(zoom, xy_point) or changed\n\n    return changed\n\n\ndef _handler(event):\n    """"""Matplotlib event handler.""""""\n\n    for axes in event.canvas.figure.axes:\n        if hasattr(axes, ""tephigram""):\n            if _refresh_isopleths(axes):\n                event.canvas.figure.show()\n\n\nclass _PlotGroup(dict):\n    """"""\n    Container for a related group of tephigram isopleths.\n\n    Manages the creation and plotting of all isopleths within the group.\n\n    """"""\n\n    def __init__(\n        self,\n        axes,\n        plot_func,\n        text_kwargs,\n        step,\n        zoom,\n        tags,\n        fixed=None,\n        xfocus=None,\n    ):\n        self.axes = axes\n        self.text_kwargs = text_kwargs\n        self.step = step\n        self.zoom = zoom\n\n        pairs = []\n        for tag in tags:\n            text = plt.text(0, 0, str(tag), **text_kwargs)\n            text.set_bbox(\n                dict(\n                    boxstyle=""Round,pad=0.3"",\n                    facecolor=""white"",\n                    edgecolor=""white"",\n                    alpha=0.5,\n                    clip_on=True,\n                    clip_box=self.axes.bbox,\n                )\n            )\n            pairs.append((tag, [plot_func(tag), text]))\n\n        dict.__init__(self, pairs)\n        for line, text in self.values():\n            line.set_visible(True)\n            text.set_visible(True)\n        self._visible = True\n\n        if fixed is None:\n            fixed = []\n\n        if not isinstance(fixed, Iterable):\n            fixed = [fixed]\n\n        if zoom is None:\n            self.fixed = set(tags)\n        else:\n            self.fixed = set(tags) & set(fixed)\n\n        self.xfocus = xfocus\n\n    def __setitem__(self, tag, item):\n        emsg = ""Cannot add or set an item into the plot group {!r}""\n        raise ValueError(emsg.format(self.step))\n\n    def __getitem__(self, tag):\n        if tag not in self.keys():\n            emsg = ""Tag item {!r} is not a member of the plot group {!r}""\n            raise KeyError(emsg.format(tag, self.step))\n        return dict.__getitem__(self, tag)\n\n    def refresh(self, zoom, xy_point):\n        """"""\n        Refresh all isopleths within the plot group.\n\n        Args:\n\n        * zoom:\n            Zoom level of the current plot, relative to the initial plot.\n        * xy_point:\n            The center point of the current point, transformed into\n            temperature and potential temperature.\n\n        Returns:\n            Boolean, whether the plot group has changed.\n\n        """"""\n        if self.zoom is None or zoom <= self.zoom:\n            changed = self._item_on()\n        else:\n            changed = self._item_off()\n        self._refresh_text(xy_point)\n        return changed\n\n    def _item_on(self, zoom=None):\n        changed = False\n        if zoom is None or self.zoom is None or zoom <= self.zoom:\n            if not self._visible:\n                for line, text in self.values():\n                    line.set_visible(True)\n                    text.set_visible(True)\n                changed = True\n                self._visible = True\n        return changed\n\n    def _item_off(self, zoom=None):\n        changed = False\n        if self.zoom is not None and (zoom is None or zoom > self.zoom):\n            if self._visible:\n                for tag, (line, text) in self.items():\n                    if tag not in self.fixed:\n                        line.set_visible(False)\n                        text.set_visible(False)\n                        changed = True\n                        self._visible = False\n        return changed\n\n    def _generate_text(self, tag, xy_point):\n        line, text = self[tag]\n        x_data = line.get_xdata()\n        y_data = line.get_ydata()\n\n        if self.xfocus:\n            delta = np.power(x_data - xy_point[0], 2)\n        else:\n            delta = np.power(x_data - xy_point[0], 2) + np.power(\n                y_data - xy_point[1], 2\n            )\n        index = np.argmin(delta)\n        text.set_position((x_data[index], y_data[index]))\n\n    def _refresh_text(self, xy_point):\n        if self._visible:\n            for tag in self:\n                self._generate_text(tag, xy_point)\n        elif self.fixed:\n            for tag in self.fixed:\n                self._generate_text(tag, xy_point)\n\n\nclass _PlotCollection:\n    """"""\n    Container for tephigram isopleths.\n\n    Manages the creation and plotting of all tephigram isobars, mixing ratio\n    lines and pseudo saturated wet adiabats.\n\n    """"""\n\n    def __init__(\n        self,\n        axes,\n        spec,\n        stop,\n        plot_func,\n        text_kwargs,\n        fixed=None,\n        minimum=None,\n        xfocus=None,\n    ):\n        if isinstance(stop, Iterable):\n            if minimum and minimum > max(stop):\n                emsg = ""Minimum value of {!r} exceeds all other values""\n                raise ValueError(emsg.format(minimum))\n\n            items = [\n                [step, zoom, set(stop[step - 1 :: step])]\n                for step, zoom in sorted(spec, reverse=True)\n            ]\n        else:\n            if minimum and minimum > stop:\n                emsg = ""Minimum value of {!r} exceeds maximum threshold {!r}""\n                raise ValueError(emsg.format(minimum, stop))\n\n            items = [\n                [step, zoom, set(range(step, stop + step, step))]\n                for step, zoom in sorted(spec, reverse=True)\n            ]\n\n        for index, item in enumerate(items):\n            if minimum:\n                item[2] = set([value for value in item[2] if value >= minimum])\n\n            for subitem in items[index + 1 :]:\n                subitem[2] -= item[2]\n\n        self.groups = {\n            item[0]: _PlotGroup(\n                axes, plot_func, text_kwargs, *item, fixed=fixed, xfocus=xfocus\n            )\n            for item in items\n            if item[2]\n        }\n\n        if not self.groups:\n            emsg = ""The plot collection failed to generate any plot groups""\n            raise ValueError(emsg)\n\n    def refresh(self, zoom, xy_point):\n        """"""\n        Refresh all isopleth groups within the plot collection.\n\n        Args:\n\n        * zoom:\n            Zoom level of the current plot, relative to the initial plot.\n        * xy_point:\n            The center point of the current plot, transformed into\n            temperature and potential temperature.\n\n        Returns:\n            Boolean, whether any plot group has changed.\n\n        """"""\n        changed = False\n\n        for group in self.groups.values():\n            changed = group.refresh(zoom, xy_point) or changed\n\n        return changed\n\n\nclass Tephigram:\n    """"""\n    Generate a tephigram of one or more pressure and temperature data sets.\n\n    """"""\n\n    def __init__(\n        self,\n        figure=None,\n        isotherm_locator=None,\n        dry_adiabat_locator=None,\n        anchor=None,\n    ):\n        """"""\n        Initialise the tephigram transformation and plot axes.\n\n        Kwargs:\n\n        * figure:\n            An existing :class:`matplotlib.figure.Figure` instance for the\n            tephigram plot. If a figure is not provided, a new figure will\n            be created by default.\n        * isotherm_locator:\n            A :class:`tephi.Locator` instance or a numeric step size\n            for the isotherm lines.\n        * dry_adiabat_locator:\n            A :class:`tephi.Locator` instance or a numeric step size\n            for the dry adiabat lines.\n        * anchor:\n            A sequence of two pressure, temperature pairs specifying the extent\n            of the tephigram plot in terms of the bottom left hand corner and\n            the top right hand corner. Pressure data points must be in units of\n            mb or hPa, and temperature data points must be in units of degC.\n\n        For example:\n\n        .. plot::\n            :include-source:\n\n            import matplotlib.pyplot as plt\n            from numpy import column_stack\n            import os.path\n            import tephi\n            from tephi import Tephigram\n\n            dew_point = os.path.join(tephi.DATA_DIR, \'dews.txt\')\n            dry_bulb = os.path.join(tephi.DATA_DIR, \'temps.txt\')\n            dew_data, temp_data = tephi.loadtxt(dew_point, dry_bulb)\n            dews = column_stack((dew_data.pressure, dew_data.temperature))\n            temps = column_stack((temp_data.pressure, temp_data.temperature))\n            tpg = Tephigram()\n            tpg.plot(dews, label=\'Dew-point\', color=\'blue\', linewidth=2)\n            tpg.plot(temps, label=\'Dry-bulb\', color=\'red\', linewidth=2)\n            plt.show()\n\n        """"""\n        if not figure:\n            # Create a default figure.\n            self.figure = plt.figure(0, figsize=(9, 9))\n        else:\n            self.figure = figure\n\n        # Configure the locators.\n        if isotherm_locator and not isinstance(isotherm_locator, Locator):\n            if not isinstance(isotherm_locator, numbers.Number):\n                raise ValueError(""Invalid isotherm locator"")\n            locator_isotherm = Locator(isotherm_locator)\n        else:\n            locator_isotherm = isotherm_locator\n\n        if dry_adiabat_locator and not isinstance(\n            dry_adiabat_locator, Locator\n        ):\n            if not isinstance(dry_adiabat_locator, numbers.Number):\n                raise ValueError(""Invalid dry adiabat locator"")\n            locator_theta = Locator(dry_adiabat_locator)\n        else:\n            locator_theta = dry_adiabat_locator\n\n        # Define the tephigram coordinate-system transformation.\n        self.tephi_transform = transforms.TephiTransform()\n        ghelper = GridHelperCurveLinear(\n            self.tephi_transform,\n            tick_formatter1=_FormatterIsotherm(),\n            grid_locator1=locator_isotherm,\n            tick_formatter2=_FormatterTheta(),\n            grid_locator2=locator_theta,\n        )\n        self.axes = Subplot(self.figure, 1, 1, 1, grid_helper=ghelper)\n        self.transform = self.tephi_transform + self.axes.transData\n        self.axes.axis[""isotherm""] = self.axes.new_floating_axis(1, 0)\n        self.axes.axis[""theta""] = self.axes.new_floating_axis(0, 0)\n        self.axes.axis[""left""].get_helper().nth_coord_ticks = 0\n        self.axes.axis[""left""].toggle(all=True)\n        self.axes.axis[""bottom""].get_helper().nth_coord_ticks = 1\n        self.axes.axis[""bottom""].toggle(all=True)\n        self.axes.axis[""top""].get_helper().nth_coord_ticks = 0\n        self.axes.axis[""top""].toggle(all=False)\n        self.axes.axis[""right""].get_helper().nth_coord_ticks = 1\n        self.axes.axis[""right""].toggle(all=True)\n        self.axes.gridlines.set_linestyle(""solid"")\n\n        self.figure.add_subplot(self.axes)\n\n        # Configure default axes.\n        axis = self.axes.axis[""left""]\n        axis.major_ticklabels.set_fontsize(10)\n        axis.major_ticklabels.set_va(""baseline"")\n        axis.major_ticklabels.set_rotation(135)\n        axis = self.axes.axis[""right""]\n        axis.major_ticklabels.set_fontsize(10)\n        axis.major_ticklabels.set_va(""baseline"")\n        axis.major_ticklabels.set_rotation(-135)\n        self.axes.axis[""top""].major_ticklabels.set_fontsize(10)\n        axis = self.axes.axis[""bottom""]\n        axis.major_ticklabels.set_fontsize(10)\n        axis.major_ticklabels.set_ha(""left"")\n        axis.major_ticklabels.set_va(""top"")\n        axis.major_ticklabels.set_rotation(-45)\n\n        # Isotherms: lines of constant temperature (degC).\n        axis = self.axes.axis[""isotherm""]\n        axis.set_axis_direction(""right"")\n        axis.set_axislabel_direction(""-"")\n        axis.major_ticklabels.set_rotation(90)\n        axis.major_ticklabels.set_fontsize(10)\n        axis.major_ticklabels.set_va(""bottom"")\n        axis.major_ticklabels.set_color(""grey"")\n        axis.major_ticklabels.set_visible(False)  # turned-off\n\n        # Dry adiabats: lines of constant potential temperature (degC).\n        axis = self.axes.axis[""theta""]\n        axis.set_axis_direction(""right"")\n        axis.set_axislabel_direction(""+"")\n        axis.major_ticklabels.set_fontsize(10)\n        axis.major_ticklabels.set_va(""bottom"")\n        axis.major_ticklabels.set_color(""grey"")\n        axis.major_ticklabels.set_visible(False)  # turned-off\n        axis.line.set_linewidth(3)\n        axis.line.set_linestyle(""--"")\n\n        # Lock down the aspect ratio.\n        self.axes.set_aspect(1.0)\n        self.axes.grid(True)\n\n        # Initialise the text formatter for the navigation status bar.\n        self.axes.format_coord = self._status_bar\n\n        # Factor in the tephigram transform.\n        ISOBAR_TEXT[""transform""] = self.transform\n        WET_ADIABAT_TEXT[""transform""] = self.transform\n        MIXING_RATIO_TEXT[""transform""] = self.transform\n\n        # Create plot collections for the tephigram isopleths.\n        func = partial(\n            isopleths.isobar,\n            MIN_THETA,\n            MAX_THETA,\n            self.axes,\n            self.transform,\n            ISOBAR_LINE,\n        )\n        self._isobars = _PlotCollection(\n            self.axes,\n            ISOBAR_SPEC,\n            MAX_PRESSURE,\n            func,\n            ISOBAR_TEXT,\n            fixed=ISOBAR_FIXED,\n            minimum=MIN_PRESSURE,\n        )\n\n        func = partial(\n            isopleths.wet_adiabat,\n            MAX_PRESSURE,\n            MIN_TEMPERATURE,\n            self.axes,\n            self.transform,\n            WET_ADIABAT_LINE,\n        )\n        self._wet_adiabats = _PlotCollection(\n            self.axes,\n            WET_ADIABAT_SPEC,\n            MAX_WET_ADIABAT,\n            func,\n            WET_ADIABAT_TEXT,\n            fixed=WET_ADIABAT_FIXED,\n            minimum=MIN_WET_ADIABAT,\n            xfocus=True,\n        )\n\n        func = partial(\n            isopleths.mixing_ratio,\n            MIN_PRESSURE,\n            MAX_PRESSURE,\n            self.axes,\n            self.transform,\n            MIXING_RATIO_LINE,\n        )\n        self._mixing_ratios = _PlotCollection(\n            self.axes,\n            MIXING_RATIO_SPEC,\n            MIXING_RATIOS,\n            func,\n            MIXING_RATIO_TEXT,\n            fixed=MIXING_RATIO_FIXED,\n        )\n\n        # Initialise for the tephigram plot event handler.\n        plt.connect(""motion_notify_event"", _handler)\n        self.axes.tephigram = True\n        self.axes.tephigram_original_delta_xlim = DEFAULT_WIDTH\n        self.original_delta_xlim = DEFAULT_WIDTH\n        self.axes.tephigram_transform = self.tephi_transform\n        self.axes.tephigram_inverse = self.tephi_transform.inverted()\n        self.axes.tephigram_isopleths = [\n            self._isobars,\n            self._wet_adiabats,\n            self._mixing_ratios,\n        ]\n\n        # The tephigram profiles.\n        self._profiles = []\n        self.axes.tephigram_profiles = self._profiles\n\n        # Center the plot around the anchor extent.\n        self._anchor = anchor\n        if self._anchor is not None:\n            self._anchor = np.asarray(anchor)\n            if (\n                self._anchor.ndim != 2\n                or self._anchor.shape[-1] != 2\n                or len(self._anchor) != 2\n            ):\n                msg = (\n                    ""Invalid anchor, expecting [(bottom-left-pressure, ""\n                    ""bottom-left-temperature), (top-right-pressure, ""\n                    ""top-right-temperature)]""\n                )\n                raise ValueError(msg)\n            (\n                (bottom_pressure, bottom_temp),\n                (top_pressure, top_temp),\n            ) = self._anchor\n\n            if (bottom_pressure - top_pressure) < 0:\n                raise ValueError(""Invalid anchor pressure range"")\n            if (bottom_temp - top_temp) < 0:\n                raise ValueError(""Invalid anchor temperature range"")\n\n            self._anchor = isopleths.Profile(anchor, self.axes)\n            self._anchor.plot(visible=False)\n            xlim, ylim = self._calculate_extents()\n            self.axes.set_xlim(xlim)\n            self.axes.set_ylim(ylim)\n\n    def plot(self, data, **kwargs):\n        """"""\n        Plot the environmental lapse rate profile of the pressure and\n        temperature data points.\n\n        The pressure and temperature data points are transformed into\n        potential temperature and temperature data points before plotting.\n\n        By default, the tephigram will automatically center the plot around\n        all profiles.\n\n        .. warning::\n            Pressure data points must be in units of mb or hPa, and temperature\n            data points must be in units of degC.\n\n        Args:\n\n        * data: pressure and temperature pair data points.\n\n        .. note::\n            All keyword arguments are passed through to\n            :func:`matplotlib.pyplot.plot`.\n\n        For example:\n\n        .. plot::\n            :include-source:\n\n            import matplotlib.pyplot as plt\n            from tephi import Tephigram\n\n            tpg = Tephigram()\n            data = [[1006, 26.4], [924, 20.3], [900, 19.8],\n                    [850, 14.5], [800, 12.9], [755, 8.3]]\n            profile = tpg.plot(data, color=\'red\', linestyle=\'--\',\n                               linewidth=2, marker=\'o\')\n            barbs = [(10, 45, 900), (20, 60, 850), (25, 90, 800)]\n            profile.barbs(barbs)\n            plt.show()\n\n        For associating wind barbs with an environmental lapse rate profile,\n        see :meth:`~tephi.isopleths.Profile.barbs`.\n\n        """"""\n        profile = isopleths.Profile(data, self.axes)\n        profile.plot(**kwargs)\n        self._profiles.append(profile)\n\n        # Center the tephigram plot around all the profiles.\n        if self._anchor is None:\n            xlim, ylim = self._calculate_extents(xfactor=0.25, yfactor=0.05)\n            self.axes.set_xlim(xlim)\n            self.axes.set_ylim(ylim)\n\n        # Refresh the tephigram plot isopleths.\n        _refresh_isopleths(self.axes)\n\n        # Show the plot legend.\n        if ""label"" in kwargs:\n            font_properties = FontProperties(size=""x-small"")\n            plt.legend(\n                loc=""upper left"",\n                fancybox=True,\n                shadow=True,\n                prop=font_properties,\n            )\n\n        return profile\n\n    def _status_bar(self, x_point, y_point):\n        """"""Generate text for the interactive backend navigation status bar.""""""\n\n        temperature, theta = transforms.convert_xy2Tt(x_point, y_point)\n        pressure, _ = transforms.convert_Tt2pT(temperature, theta)\n        xlim = self.axes.get_xlim()\n        zoom = (xlim[1] - xlim[0]) / self.original_delta_xlim\n        msg = ""T:{:.2f}, theta:{:.2f}, phi:{:.2f} (zoom:{:.3f})""\n        text = msg.format(\n            float(temperature), float(theta), float(pressure), zoom\n        )\n\n        return text\n\n    def _calculate_extents(self, xfactor=None, yfactor=None):\n        min_x = min_y = 1e10\n        max_x = max_y = -1e-10\n        profiles = self._profiles\n        transform = self.tephi_transform.transform\n\n        if self._anchor is not None:\n            profiles = [self._anchor]\n\n        for profile in profiles:\n            temperature = profile.temperature.reshape(-1, 1)\n            theta = profile.theta.reshape(-1, 1)\n            xy_points = transform(np.concatenate((temperature, theta), axis=1))\n            x_points = xy_points[:, 0]\n            y_points = xy_points[:, 1]\n            min_x = np.min([min_x, np.min(x_points)])\n            min_y = np.min([min_y, np.min(y_points)])\n            max_x = np.max([max_x, np.max(x_points)])\n            max_y = np.max([max_y, np.max(y_points)])\n\n        if xfactor is not None:\n            delta_x = max_x - min_x\n            min_x, max_x = min_x - xfactor * delta_x, max_x + xfactor * delta_x\n\n        if yfactor is not None:\n            delta_y = max_y - min_y\n            min_y, max_y = min_y - yfactor * delta_y, max_y + yfactor * delta_y\n\n        return ([min_x, max_x], [min_y, max_y])\n'"
tephi/_constants.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nTephigram transform and isopleth constants.\n\n""""""\n\n# TODO: Discover the meaning of the magic constant numbers.\n\nCONST_CP = 1.01e3\nCONST_K = 0.286\nCONST_KELVIN = 273.15  # celsius to kelvin offset.\nCONST_L = 2.5e6\nCONST_MA = 300.0\nCONST_RD = 287.0\nCONST_RV = 461.0\n'"
tephi/isopleths.py,16,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nTephigram isopleth support for generating and plotting tephigram lines,\nenvironment profiles and barbs.\n\n""""""\nimport math\nfrom matplotlib.collections import PathCollection\nfrom matplotlib.path import Path\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\nfrom ._constants import CONST_CP, CONST_L, CONST_KELVIN, CONST_RD, CONST_RV\nfrom . import transforms\n\n\n# Wind barb speed (knots) ranges used since 1 January 1955.\n_BARB_BINS = np.arange(20) * 5 + 3\n_BARB_GUTTER = 0.1\n_BARB_DTYPE = np.dtype(\n    dict(\n        names=(""speed"", ""angle"", ""pressure"", ""barb""),\n        formats=(""f4"", ""f4"", ""f4"", np.object),\n    )\n)\n\n#\n# Reference: http://www-nwp/~hadaa/tephigram/tephi_plot.html\n#\n\n\ndef mixing_ratio(\n    min_pressure, max_pressure, axes, transform, kwargs, mixing_ratio_value\n):\n    """"""\n    Generate and plot a humidity mixing ratio line.\n\n    A line of constant saturation mixing ratio with respect to a\n    plane water surface (g kg-1).\n\n    Args:\n\n    * min_pressure:\n        Minumum pressure, in mb or hPa, for the mixing ratio line extent.\n\n    * max_pressure:\n        Maximum pressure, in mb or hPa, for the mixing ratio line extent.\n\n    * axes:\n        Tephigram plotting :class:`matplotlib.axes.AxesSubplot` instance.\n\n    * transform:\n        Tephigram plotting transformation\n        :class:`matplotlib.transforms.CompositeGenericTransform` instance.\n\n    * kwargs:\n        Keyword arguments for the mixing ratio :class:`matplotlib.lines.Line2D`\n        instance.\n\n    * mixing_ratio_value:\n        The mixing ratio value to be plotted.\n\n    Returns:\n        The mixing ratio :class:`matplotlib.lines.Line2D` instance.\n\n    """"""\n    pressures = np.linspace(min_pressure, max_pressure, 100)\n    temps = transforms.convert_pw2T(pressures, mixing_ratio_value)\n    _, thetas = transforms.convert_pT2Tt(pressures, temps)\n    (line,) = axes.plot(temps, thetas, transform=transform, **kwargs)\n\n    return line\n\n\ndef isobar(min_theta, max_theta, axes, transform, kwargs, pressure):\n    """"""\n    Generate and plot an isobar line.\n\n    A line of constant pressure (mb).\n\n    Args:\n\n    * min_theta:\n        Minimum potential temperature, in degC, for the isobar extent.\n\n    * max_theta:\n        Maximum potential temperature, in degC, for the isobar extent.\n\n    * axes:\n        Tephigram plotting :class:`matplotlib.axes.AxesSubplot` instance.\n\n    * transform:\n        Tephigram plotting transformation\n        :class:`matplotlib.transforms.CompositeGenericTransform` instance.\n\n    * kwargs:\n        Keyword arguments for the isobar :class:`matplotlib.lines.Line2D`\n        instance.\n\n    * pressure:\n        The isobar pressure value, in mb or hPa, to be plotted.\n\n    Returns:\n       The isobar :class:`matplotlib.lines.Line2D` instance.\n\n    """"""\n    steps = 100\n    thetas = np.linspace(min_theta, max_theta, steps)\n    _, temps = transforms.convert_pt2pT([pressure] * steps, thetas)\n    (line,) = axes.plot(temps, thetas, transform=transform, **kwargs)\n\n    return line\n\n\ndef _wet_adiabat_gradient(min_temperature, pressure, temperature, dp):\n    """"""\n    Calculate the wet adiabat change in pressure and temperature.\n\n    Args:\n\n    * min_temperature:\n        Minimum potential temperature, in degC, for the wet adiabat line\n        extent.\n\n    * pressure:\n        Pressure point value, in mb or hPa, from which to calculate the\n        gradient difference.\n\n    * temperature:\n        Potential temperature point value, in degC, from which to calculate\n        the gradient difference.\n\n    * dp:\n        The wet adiabat change in pressure, in mb or hPa, from which to\n        calculate the gradient difference.\n\n    Returns:\n        The gradient change as a pressure, potential temperature value pair.\n\n    """"""\n\n    # TODO: Discover the meaning of the magic numbers.\n\n    kelvin = temperature + CONST_KELVIN\n    lsbc = (CONST_L / CONST_RV) * ((1.0 / CONST_KELVIN) - (1.0 / kelvin))\n    rw = 6.11 * np.exp(lsbc) * (0.622 / pressure)\n    lrwbt = (CONST_L * rw) / (CONST_RD * kelvin)\n    nume = ((CONST_RD * kelvin) / (CONST_CP * pressure)) * (1.0 + lrwbt)\n    deno = 1.0 + (lrwbt * ((0.622 * CONST_L) / (CONST_CP * kelvin)))\n    gradi = nume / deno\n    dt = dp * gradi\n\n    if (temperature + dt) < min_temperature:\n        dt = min_temperature - temperature\n        dp = dt / gradi\n\n    return dp, dt\n\n\ndef wet_adiabat(\n    max_pressure, min_temperature, axes, transform, kwargs, temperature\n):\n    """"""\n    Generate and plot a pseudo saturated wet adiabat line.\n\n    A line of constant equivalent potential temperature for saturated\n    air parcels (degC).\n\n    Args:\n\n    * max_pressure:\n        Maximum pressure, in mb or hPa, for the wet adiabat line extent.\n\n    * min_temperature:\n        Minimum potential temperature, in degC, for the wet adiabat line\n        extent.\n\n    * axes:\n        Tephigram plotting :class:`matplotlib.axes.AxesSubplot` instance.\n\n    * transform:\n        Tephigram plotting transformation\n        :class:`matplotlib.transforms.CompositeGenericTransform` instance.\n\n    * kwargs:\n        Keyword arguments for the mixing ratio :class:`matplotlib.lines.Line2D`\n        instance.\n\n    * temperature:\n        The wet adiabat value, in degC, to be plotted.\n\n    Returns:\n        The wet adiabat :class:`matplotlib.lines.Line2D` instance.\n\n    """"""\n    temps = [temperature]\n    pressures = [max_pressure]\n    dp = -5.0\n\n    for i in range(200):\n        dp, dt = _wet_adiabat_gradient(\n            min_temperature, pressures[i], temps[i], dp\n        )\n        temps.append(temps[i] + dt)\n        pressures.append(pressures[i] + dp)\n\n    _, thetas = transforms.convert_pT2Tt(pressures, temps)\n    (line,) = axes.plot(temps, thetas, transform=transform, **kwargs)\n\n    return line\n\n\nclass Barbs:\n    """"""Generate a wind arrow barb.""""""\n\n    def __init__(self, axes):\n        """"""\n        Create a wind arrow barb for the given axes.\n\n        Args:\n\n        * axes:\n            A :class:`matplotlib.axes.AxesSubplot` instance.\n\n        """"""\n        self.axes = axes\n        self.barbs = None\n        self._gutter = None\n        self._transform = axes.tephigram_transform + axes.transData\n        self._kwargs = None\n        self._custom_kwargs = None\n        self._custom = dict(\n            color=[""barbcolor"", ""color"", ""edgecolor"", ""facecolor""],\n            linewidth=[""lw"", ""linewidth""],\n            linestyle=[""ls"", ""linestyle""],\n        )\n\n    @staticmethod\n    def _uv(magnitude, angle):\n        """"""\n        Convert magnitude and angle measured in degrees to u and v components,\n        where u is -x and v is -y.\n\n        """"""\n        angle = angle % 360\n        u = v = 0\n        # Snap the magnitude of the barb vector to fall into one of the\n        # _BARB_BINS ensuring it\'s a multiple of five. Five is the increment\n        # step size for decorating with barb with flags.\n        magnitude = np.searchsorted(_BARB_BINS, magnitude, side=""right"") * 5\n        modulus = angle % 90\n        if modulus:\n            quadrant = int(angle / 90)\n            radians = math.radians(modulus)\n            y = math.cos(radians) * magnitude\n            x = math.sin(radians) * magnitude\n            if quadrant == 0:\n                u, v = -x, -y\n            elif quadrant == 1:\n                u, v = -y, x\n            elif quadrant == 2:\n                u, v = x, y\n            else:\n                u, v = y, -x\n        else:\n            angle = int(angle)\n            if angle == 0:\n                v = -magnitude\n            elif angle == 90:\n                u = -magnitude\n            elif angle == 180:\n                v = magnitude\n            else:\n                u = magnitude\n        return u, v\n\n    def _make_barb(self, temperature, theta, speed, angle):\n        """"""Add the barb to the plot at the specified location.""""""\n        u, v = self._uv(speed, angle)\n        if 0 < speed < _BARB_BINS[0]:\n            # Plot the missing barbless 1-2 knots line.\n            length = self._kwargs[""length""]\n            pivot_points = dict(tip=0.0, middle=-length / 2.0)\n            pivot = self._kwargs.get(""pivot"", ""tip"")\n            offset = pivot_points[pivot]\n            verts = [(0.0, offset), (0.0, length + offset)]\n            rangle = math.radians(-angle)\n            verts = mtransforms.Affine2D().rotate(rangle).transform(verts)\n            codes = [Path.MOVETO, Path.LINETO]\n            path = Path(verts, codes)\n            size = length ** 2 / 4\n            xy = np.array([[temperature, theta]])\n            barb = PathCollection(\n                [path],\n                (size,),\n                offsets=xy,\n                transOffset=self._transform,\n                **self._custom_kwargs,\n            )\n            barb.set_transform(mtransforms.IdentityTransform())\n            self.axes.add_collection(barb)\n        else:\n            barb = plt.barbs(\n                temperature,\n                theta,\n                u,\n                v,\n                transform=self._transform,\n                **self._kwargs,\n            )\n        return barb\n\n    def refresh(self):\n        """"""Refresh the plot with the barbs.""""""\n        if self.barbs is not None:\n            xlim = self.axes.get_xlim()\n            ylim = self.axes.get_ylim()\n            y = np.linspace(*ylim)[::-1]\n            xdelta = xlim[1] - xlim[0]\n            x = np.ones(y.size) * (xlim[1] - (xdelta * self._gutter))\n            xy = np.column_stack((x, y))\n            points = self.axes.tephigram_inverse.transform(xy)\n            temperature, theta = points[:, 0], points[:, 1]\n            pressure, _ = transforms.convert_Tt2pT(temperature, theta)\n            min_pressure, max_pressure = np.min(pressure), np.max(pressure)\n            func = interp1d(pressure, temperature)\n            for i, (speed, angle, pressure, barb) in enumerate(self.barbs):\n                if min_pressure < pressure < max_pressure:\n                    p2T = func(pressure)\n                    temperature, theta = transforms.convert_pT2Tt(\n                        pressure, p2T\n                    )\n                    if barb is None:\n                        self.barbs[i][""barb""] = self._make_barb(\n                            temperature, theta, speed, angle\n                        )\n                    else:\n                        barb.set_offsets(np.array([[temperature, theta]]))\n                        barb.set_visible(True)\n                else:\n                    if barb is not None:\n                        barb.set_visible(False)\n\n    def plot(self, barbs, **kwargs):\n        """"""\n        Plot the sequence of barbs.\n\n        Args:\n\n        * barbs:\n            Sequence of speed, direction and pressure value triples for\n            each barb. Where speed is measured in units of knots, direction\n            in units of degrees (clockwise from north), and pressure must\n            be in units of mb or hPa.\n\n        Kwargs:\n\n        * gutter:\n            Proportion offset from the right hand side axis to plot the\n            barbs. Defaults to 0.1\n\n            Also see :func:`matplotlib.pyplot.barbs`\n\n        """"""\n        self._gutter = kwargs.pop(""gutter"", _BARB_GUTTER)\n        self._kwargs = dict(length=7, zorder=10)\n        self._kwargs.update(kwargs)\n        self._custom_kwargs = dict(\n            color=None, linewidth=1.5, zorder=self._kwargs[""zorder""]\n        )\n        for key, values in self._custom.items():\n            common = set(values).intersection(kwargs)\n            if common:\n                self._custom_kwargs[key] = kwargs[sorted(common)[0]]\n        if hasattr(barbs, ""__next__""):\n            barbs = list(barbs)\n        barbs = np.asarray(barbs)\n        if barbs.ndim != 2 or barbs.shape[-1] != 3:\n            msg = (\n                ""The barbs require to be a sequence of wind speed, ""\n                ""wind direction and pressure value triples.""\n            )\n            raise ValueError(msg)\n        self.barbs = np.empty(barbs.shape[0], dtype=_BARB_DTYPE)\n        for i, barb in enumerate(barbs):\n            self.barbs[i] = tuple(barb) + (None,)\n        self.refresh()\n\n\nclass Profile:\n    """"""Generate an environmental lapse rate profile.""""""\n\n    def __init__(self, data, axes):\n        """"""\n        Create an environmental lapse rate profile from the sequence of\n        pressure and temperature point data.\n\n        Args:\n\n        * data:\n            Sequence of pressure and temperature points defining the\n            environmental lapse rate.\n\n        * axes:\n            The axes on which to plot the profile.\n\n        """"""\n        if hasattr(data, ""__next__""):\n            data = list(data)\n        self.data = np.asarray(data)\n        if self.data.ndim != 2 or self.data.shape[-1] != 2:\n            msg = (\n                ""The environment profile data requires to be a sequence ""\n                ""of pressure, temperature value pairs.""\n            )\n            raise ValueError(msg)\n        self.axes = axes\n        self._transform = axes.tephigram_transform + axes.transData\n        self.pressure = self.data[:, 0]\n        self.temperature = self.data[:, 1]\n        _, self.theta = transforms.convert_pT2Tt(\n            self.pressure, self.temperature\n        )\n        self.line = None\n        self._barbs = Barbs(axes)\n\n    def plot(self, **kwargs):\n        """"""\n        Plot the environmental lapse rate profile.\n\n        Kwargs:\n\n            See :func:`matplotlib.pyplot.plot`.\n\n        Returns:\n            The profile :class:`matplotlib.lines.Line2D`\n\n        """"""\n        if self.line is not None and self.line in self.axes.lines:\n            self.axes.lines.remove(self.line)\n\n        if ""zorder"" not in kwargs:\n            kwargs[""zorder""] = 10\n\n        (self.line,) = self.axes.plot(\n            self.temperature, self.theta, transform=self._transform, **kwargs\n        )\n        return self.line\n\n    def refresh(self):\n        """"""Refresh the plot with the profile and any associated barbs.""""""\n        self._barbs.refresh()\n\n    def barbs(self, barbs, **kwargs):\n        """"""\n        Plot the sequence of barbs associated with this profile.\n\n        Args:\n\n        * barbs:\n            Sequence of speed, direction and pressure value triples for\n            each barb. Where speed is measured in units of knots, direction\n            in units of degrees (clockwise from north), and pressure must\n            be in units of mb or hPa.\n\n        Kwargs:\n\n            See :func:`matplotlib.pyplot.barbs`\n\n        """"""\n        colors = [""color"", ""barbcolor"", ""edgecolor"", ""facecolor""]\n        if not set(colors).intersection(kwargs):\n            kwargs[""color""] = self.line.get_color()\n        self._barbs.plot(barbs, **kwargs)\n'"
tephi/transforms.py,13,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nTephigram transform support.\n\n""""""\nfrom matplotlib.transforms import Transform\nimport numpy as np\n\nfrom ._constants import CONST_K, CONST_KELVIN, CONST_L, CONST_MA, CONST_RV\n\n\n#\n# Reference: http://www-nwp/~hadaa/tephigram/tephi_plot.html\n#\n\n\ndef convert_Tt2pT(temperature, theta):\n    """"""\n    Transform temperature and potential temperature into\n    pressure and temperature.\n\n    Args:\n\n    * temperature:\n        Temperature in degC.\n\n    * theta:\n        Potential temperature in degC.\n\n    Returns:\n        Tuple of pressure, in mb or hPa, and temperature, in degC.\n\n    """"""\n    temperature, theta = np.asarray(temperature), np.asarray(theta)\n\n    # Convert temperature and theta from degC to kelvin.\n    kelvin = temperature + CONST_KELVIN\n    theta = theta + CONST_KELVIN\n\n    # Calculate the associated pressure given the temperature and\n    # potential temperature.\n    pressure = 1000.0 * np.power(kelvin / theta, 1 / CONST_K)\n\n    return pressure, temperature\n\n\ndef convert_pT2Tt(pressure, temperature):\n    """"""\n    Transform pressure and temperature into temperature and\n    potential temperature.\n\n    Args:\n\n    * pressure:\n        Pressure in mb or hPa.\n\n    * temperature:\n        Temperature in degC.\n\n    Returns:\n        Tuple of temperature, in degC, and potential temperature, in degC.\n\n    """"""\n    pressure, temperature = np.asarray(pressure), np.asarray(temperature)\n\n    # Convert temperature from degC to kelvin.\n    kelvin = temperature + CONST_KELVIN\n\n    # Calculate the potential temperature given the pressure and temperature.\n    theta = kelvin * ((1000.0 / pressure) ** CONST_K)\n\n    # Convert potential temperature from kelvin to degC.\n    return temperature, theta - CONST_KELVIN\n\n\ndef convert_pt2pT(pressure, theta):\n    """"""\n    Transform pressure and potential temperature into pressure and temperature.\n\n    Args:\n\n    * pressure:\n        Pressure in mb or hPa.\n\n    * theta:\n        Potential temperature in degC.\n\n    * Returns:\n        Tuple of pressure, in mb or hPa, and temperature, in degC.\n\n    """"""\n    pressure, theta = np.asarray(pressure), np.asarray(theta)\n\n    # Convert potential temperature from degC to kelvin.\n    theta = theta + CONST_KELVIN\n\n    # Calculate the temperature given the pressure and\n    # potential temperature.\n    kelvin = theta * (pressure ** CONST_K) / (1000.0 ** CONST_K)\n\n    # Convert temperature from kelvin to degC.\n    return pressure, kelvin - CONST_KELVIN\n\n\ndef convert_Tt2xy(temperature, theta):\n    """"""\n    Transform temperature and potential temperature to native display\n    coordinates.\n\n    Args:\n\n    * temperature:\n        Temperature in degC.\n\n    * theta:\n        Potential temperature in degC.\n\n    Returns:\n        Native display x and y coordinates.\n\n    """"""\n    temperature, theta = np.asarray(temperature), np.asarray(theta)\n\n    # Convert potential temperature from degC to kelvin.\n    theta = theta + CONST_KELVIN\n    theta = np.clip(theta, 1, 1e10)\n\n    phi = np.log(theta)\n\n    x_data = phi * CONST_MA + temperature\n    y_data = phi * CONST_MA - temperature\n\n    return x_data, y_data\n\n\ndef convert_xy2Tt(x_data, y_data):\n    """"""\n    Transform native display coordinates to temperature and\n    potential temperature.\n\n    Args:\n\n    * x_data:\n        Native display x-coordinate/s.\n\n    * y_data:\n        Native display y-coordinate/s.\n\n    Returns:\n        Temperature, in degC, and potential temperature, in degC.\n\n    """"""\n    x_data, y_data = np.asarray(x_data), np.asarray(y_data)\n\n    phi = (x_data + y_data) / (2 * CONST_MA)\n    temperature = (x_data - y_data) / 2.0\n\n    theta = np.exp(phi) - CONST_KELVIN\n\n    return temperature, theta\n\n\ndef convert_pw2T(pressure, mixing_ratio):\n    """"""\n    Transform pressure and mixing ratios to temperature.\n\n    Args:\n\n    * pressure:\n        Pressure in mb in hPa.\n\n    * mixing_ratio:\n        Dimensionless mixing ratios.\n\n    Returns:\n        Temperature in degC.\n\n    """"""\n    pressure = np.array(pressure)\n\n    # Calculate the dew-point.\n    vapp = pressure * (8.0 / 5.0) * (mixing_ratio / 1000.0)\n    temp = 1.0 / (\n        (1.0 / CONST_KELVIN) - ((CONST_RV / CONST_L) * np.log(vapp / 6.11))\n    )\n\n    return temp - CONST_KELVIN\n\n\nclass TephiTransform(Transform):\n    """"""\n    Tephigram transformation to convert from temperature and\n    potential temperature to native plotting device coordinates.\n\n    """"""\n\n    input_dims = 2\n    output_dims = 2\n    is_separable = False\n    has_inverse = True\n\n    def transform_non_affine(self, values):\n        """"""\n        Transform from tephigram temperature and potential temperature\n        to native plotting device coordinates.\n\n        Args:\n\n        * values:\n            Values to be transformed, with shape (N, 2).\n\n        """"""\n        return np.concatenate(\n            convert_Tt2xy(values[:, 0:1], values[:, 1:2]), axis=1\n        )\n\n    def inverted(self):\n        """"""Return the inverse transformation.""""""\n        return TephiTransformInverted()\n\n\nclass TephiTransformInverted(Transform):\n    """"""\n    Tephigram inverse transformation to convert from native\n    plotting device coordinates to tephigram temperature and\n    potential temperature.\n\n    """"""\n\n    input_dims = 2\n    output_dims = 2\n    is_separable = False\n    has_inverse = True\n\n    def transform_non_affine(self, values):\n        """"""\n        Transform from native plotting display coordinates to tephigram\n        temperature and potential temperature.\n\n        Args:\n\n        * values:\n           Values to be transformed, with shape (N, 2).\n\n        """"""\n        return np.concatenate(\n            convert_xy2Tt(values[:, 0:1], values[:, 1:2]), axis=1\n        )\n\n    def inverted(self):\n        """"""Return the inverse transformation.""""""\n        return TephiTransform()\n'"
tephi/tests/__init__.py,3,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nProvides testing capabilities and customisations specific to tephi.\n\n.. note:: This module needs to control the matplotlib backend, so it\n          **must** be imported before ``matplotlib.pyplot``.\n\nBy default, this module sets the matplotlib backend to ""agg"". But when\nthis module is imported it checks ``sys.argv`` for the flag ""-d"". If\nfound, it is removed from ``sys.argv`` and the matplotlib backend is\nswitched to ""tkagg"" to allow the interactive visual inspection of\ngraphical test results.\n\n""""""\nimport codecs\nimport collections\nimport io\nimport json\nimport os\nimport sys\n\nimport filelock\nimport matplotlib\nimport numpy as np\nimport pytest\nimport requests\n\nfrom tephi import DATA_DIR\n\n\n#: Basepath for test data.\n_DATA_PATH = DATA_DIR\n\n#: Basepath for test results.\n_RESULT_PATH = os.path.join(os.path.dirname(__file__), ""results"")\n\n#: Default perceptual hash size.\n_HASH_SIZE = 16\n\n#: Default maximum perceptual hash hamming distance.\n_HAMMING_DISTANCE = 2\n\n# Whether to display matplotlib output to the screen.\n_DISPLAY_FIGURES = False\n\n# Test images URL.\nBASE_URL = ""https://scitools.github.io/test-tephi-imagehash/images""\n\n\ntry:\n    # Added a timeout to stop the call to requests.get hanging when running\n    # on a platform which has restricted/no internet access.\n    requests.get(""https://github.com/SciTools/tephi"", timeout=5.0)\n    INET_AVAILABLE = True\nexcept requests.exceptions.ConnectionError:\n    INET_AVAILABLE = False\n\n\nrequires_inet = pytest.mark.skipif(\n    not INET_AVAILABLE,\n    reason=(\'Test requires an ""internet connection"", which is not available.\'),\n)\n\n\nif ""-d"" in sys.argv:\n    sys.argv.remove(""-d"")\n    matplotlib.use(""tkagg"")\n    _DISPLAY_FIGURES = True\nelse:\n    matplotlib.use(""agg"")\n\n# Imported now so that matplotlib.use can work\nimport matplotlib.pyplot as plt\n\n\ndef get_data_path(relative_path):\n    """"""\n    Returns the absolute path to a data file when given the relative path\n    as a string, or sequence of strings.\n\n    """"""\n    if isinstance(relative_path, (list, tuple)):\n        relative_path = os.path.join(*relative_path)\n    return os.path.abspath(os.path.join(_DATA_PATH, relative_path))\n\n\ndef get_result_path(relative_path):\n    """"""\n    Returns the absolute path to a result file when given the relative path\n    as a string, or sequence of strings.\n\n    """"""\n    if isinstance(relative_path, (list, tuple)):\n        relative_path = os.path.join(*relative_path)\n    return os.path.abspath(os.path.join(_RESULT_PATH, relative_path))\n\n\nclass TephiTest:\n    """"""\n    Utility class containing common testing framework functionality.\n\n    """"""\n\n    def assertArrayEqual(self, a, b):\n        __tracebackhide__ = True\n        return np.testing.assert_array_equal(a, b)\n\n    def assertArrayAlmostEqual(self, a, b, *args, **kwargs):\n        __tracebackhide__ = True\n        return np.testing.assert_array_almost_equal(a, b, *args, **kwargs)\n\n\nclass GraphicsTest(TephiTest):\n\n    _assertion_count = collections.defaultdict(int)\n\n    def _unique_id(self, nodeid):\n        """"""Create a hashable key to represent the unique test invocation.\n\n        Construct the hashable key from the provided nodeid and a sequential\n        counter specific to the current test, that is incremented on each call.\n\n        Parameters\n        ----------\n        nodeid : str\n            Unique identifier for the current test. See :func:`nodeid` fixture.\n\n        Returns\n        -------\n        str\n            The nodeid with sequential counter.\n\n        """"""\n        count = self._assertion_count[nodeid]\n        self._assertion_count[nodeid] += 1\n        return f""{nodeid}.{count}""\n\n    def check_graphic(self, nodeid):\n        """"""\n        Check the hash of the current matplotlib figure matches the expected\n        image hash for the current graphic test.\n\n        To create missing image test results, set the TEPHI_TEST_CREATE_MISSING\n        environment variable before running the tests. This will result in new\n        and appropriately ""<hash>.png"" image files being generated in the image\n        output directory, and the imagerepo.json file being updated.\n\n        """"""\n        __tracebackhide__ = True\n        import imagehash\n        from PIL import Image\n\n        dev_mode = os.environ.get(""TEPHI_TEST_CREATE_MISSING"")\n        unique_id = self._unique_id(nodeid)\n        repo_fname = os.path.join(_RESULT_PATH, ""imagerepo.json"")\n        repo = {}\n        if os.path.isfile(repo_fname):\n            with open(repo_fname, ""rb"") as fi:\n                repo = json.load(codecs.getreader(""utf-8"")(fi))\n\n        try:\n            #: The path where the images generated by the tests should go.\n            image_output_directory = os.path.join(\n                os.path.dirname(__file__), ""result_image_comparison""\n            )\n            if not os.access(image_output_directory, os.W_OK):\n                if not os.access(os.getcwd(), os.W_OK):\n                    raise IOError(\n                        ""Write access to a local disk is required ""\n                        ""to run image tests.  Run the tests from a ""\n                        ""current working directory you have write ""\n                        ""access to to avoid this issue.""\n                    )\n                else:\n                    image_output_directory = os.path.join(\n                        os.getcwd(), ""tephi_image_test_output""\n                    )\n            result_fname = os.path.join(\n                image_output_directory, ""result-"" + unique_id + "".png""\n            )\n\n            if not os.path.isdir(image_output_directory):\n                # Handle race-condition where the directories are\n                # created sometime between the check above and the\n                # creation attempt below.\n                try:\n                    os.makedirs(image_output_directory)\n                except OSError as err:\n                    # Don\'t care about ""File exists""\n                    if err.errno != 17:\n                        raise\n\n            def _create_missing():\n                fname = f""{phash}.png""\n                uri = os.path.join(BASE_URL, fname)\n                hash_fname = os.path.join(image_output_directory, fname)\n                uris = repo.setdefault(unique_id, [])\n                uris.append(uri)\n                print(f""Creating image file: {hash_fname}"")\n                figure.savefig(hash_fname)\n                msg = ""Creating imagerepo entry: {} -> {}""\n                print(msg.format(unique_id, uri))\n                lock = filelock.FileLock(\n                    os.path.join(_RESULT_PATH, ""imagerepo.lock"")\n                )\n                # The imagerepo.json file is a critical resource, so ensure\n                # thread safe read/write behaviour via platform independent\n                # file locking.\n                with lock.acquire(timeout=600):\n                    with open(repo_fname, ""wb"") as fo:\n                        json.dump(\n                            repo,\n                            codecs.getwriter(""utf-8"")(fo),\n                            indent=4,\n                            sort_keys=True,\n                        )\n\n            # Calculate the test result perceptual image hash.\n            buffer = io.BytesIO()\n            figure = plt.gcf()\n            figure.savefig(buffer, format=""png"")\n            buffer.seek(0)\n            phash = imagehash.phash(Image.open(buffer), hash_size=_HASH_SIZE)\n\n            if unique_id not in repo:\n                if dev_mode:\n                    _create_missing()\n                else:\n                    figure.savefig(result_fname)\n                    emsg = ""Missing image test result: {}.""\n                    raise AssertionError(emsg.format(unique_id))\n            else:\n                uris = repo[unique_id]\n                # Extract the hex basename strings from the uris.\n                hexes = [\n                    os.path.splitext(os.path.basename(uri))[0] for uri in uris\n                ]\n                # Create the expected perceptual image hashes from the uris.\n                to_hash = imagehash.hex_to_hash\n                expected = [to_hash(uri_hex) for uri_hex in hexes]\n\n                # Calculate hamming distance vector for the result hash.\n                distances = [e - phash for e in expected]\n\n                if np.all([hd > _HAMMING_DISTANCE for hd in distances]):\n                    if dev_mode:\n                        _create_missing()\n                    else:\n                        figure.savefig(result_fname)\n                        msg = (\n                            ""Bad phash {} with hamming distance {} ""\n                            ""for test {}.""\n                        )\n                        msg = msg.format(phash, distances, unique_id)\n                        if _DISPLAY_FIGURES:\n                            emsg = ""Image comparison would have failed: {}""\n                            print(emsg.format(msg))\n                        else:\n                            emsg = ""Image comparison failed: {}""\n                            raise AssertionError(emsg.format(msg))\n\n            if _DISPLAY_FIGURES:\n                plt.show()\n\n        finally:\n            plt.close()\n'"
tephi/tests/conftest.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""pytest configuration""""""\n\nimport matplotlib.pyplot as plt\nimport pytest\n\n\n@pytest.fixture\ndef close_plot():\n    """"""This fixture closes the current matplotlib plot associated with the graphical test.\n\n    """"""\n    yield\n    plt.close()\n\n\n@pytest.fixture\ndef nodeid(request):\n    """"""This fixture returns the unique test name for the method.\n\n    Constructs the nodeid, which is composed of the test module name,\n    class name, and method name.\n\n    Parameters\n    ----------\n    request : fixture\n        pytest built-in fixture providing information of the requesting\n        test function.\n\n    Returns\n    -------\n    str\n        The test nodeid consisting of the module, class and test name.\n\n    """"""\n    root = request.fspath.basename.split(""."")[0]\n    klass = request.cls.__name__\n    func = request.node.name\n    return ""."".join([root, klass, func])\n'"
tephi/tests/idiff.py,2,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n# !/usr/bin/env python\n""""""\nProvides ""diff-like"" comparison of images.\n\nCurrently relies on matplotlib for image processing so limited to PNG format.\n\n""""""\n\nimport argparse\nimport codecs\nimport contextlib\nfrom glob import glob\nimport json\nimport os.path\nimport shutil\nimport sys\nimport tempfile\nimport warnings\n\n# Force tephi.tests to use the ```tkagg``` backend by using the \'-d\'\n# command-line argument as idiff is an interactive tool that requires a\n# gui interface.\nsys.argv.append(""-d"")\nimport tephi.tests  # noqa\n\nfrom PIL import Image  # noqa\nimport filelock  # noqa\nimport imagehash  # noqa\nimport matplotlib.pyplot as plt  # noqa\nimport matplotlib.image as mimg  # noqa\nimport matplotlib.testing.compare as mcompare  # noqa\nfrom matplotlib.testing.exceptions import ImageComparisonFailure  # noqa\nimport matplotlib.widgets as mwidget  # noqa\nimport numpy as np  # noqa\nimport requests  # noqa\n\n\n_POSTFIX_DIFF = ""-failed-diff.png""\n_POSTFIX_JSON = os.path.join(""results"", ""imagerepo.json"")\n_POSTFIX_LOCK = os.path.join(""results"", ""imagerepo.lock"")\n\n\n@contextlib.contextmanager\ndef temp_png(suffix=""""):\n    if suffix:\n        suffix = f""-{suffix}""\n    suffix = f""{suffix}.png""\n\n    fd, fname = tempfile.mkstemp(suffix)\n    os.close(fd)\n\n    try:\n        yield fname\n    finally:\n        os.remove(fname)\n\n\ndef diff_viewer(\n    repo,\n    key,\n    repo_fname,\n    phash,\n    status,\n    expected_fname,\n    result_fname,\n    diff_fname,\n):\n    fig = plt.figure(figsize=(14, 12))\n    plt.suptitle(os.path.basename(expected_fname))\n    ax = plt.subplot(221)\n    ax.imshow(mimg.imread(expected_fname))\n    ax = plt.subplot(222, sharex=ax, sharey=ax)\n    ax.imshow(mimg.imread(result_fname))\n    ax = plt.subplot(223, sharex=ax, sharey=ax)\n    ax.imshow(mimg.imread(diff_fname))\n\n    result_dir = os.path.dirname(result_fname)\n    fname = f""{phash}.png""\n    uri = os.path.join(tephi.tests.BASE_URL, fname)\n    phash_fname = os.path.join(result_dir, fname)\n\n    def accept(event):\n        if uri not in repo[key]:\n            # Ensure to maintain strict time order where the first uri\n            # associated with the repo key is the oldest, and the last\n            # uri is the youngest\n            repo[key].append(uri)\n            # Update the image repo.\n            with open(repo_fname, ""wb"") as fo:\n                json.dump(\n                    repo,\n                    codecs.getwriter(""utf-8"")(fo),\n                    indent=4,\n                    sort_keys=True,\n                )\n            os.rename(result_fname, phash_fname)\n            msg = ""ACCEPTED:  {} -> {}""\n            print(\n                msg.format(\n                    os.path.basename(result_fname),\n                    os.path.basename(phash_fname),\n                )\n            )\n        else:\n            msg = ""DUPLICATE: {} -> {} (ignored)""\n            print(\n                msg.format(\n                    os.path.basename(result_fname),\n                    os.path.basename(phash_fname),\n                )\n            )\n            os.remove(result_fname)\n        os.remove(diff_fname)\n        plt.close()\n\n    def reject(event):\n        if uri not in repo[key]:\n            print(""REJECTED:  {}"".format(os.path.basename(result_fname)))\n        else:\n            msg = ""DUPLICATE: {} -> {} (ignored)""\n            print(\n                msg.format(\n                    os.path.basename(result_fname),\n                    os.path.basename(phash_fname),\n                )\n            )\n        os.remove(result_fname)\n        os.remove(diff_fname)\n        plt.close()\n\n    def skip(event):\n        # Let\'s keep both the result and the diff files.\n        print(""SKIPPED:   {}"".format(os.path.basename(result_fname)))\n        plt.close()\n\n    ax_accept = plt.axes([0.59, 0.05, 0.1, 0.075])\n    ax_reject = plt.axes([0.7, 0.05, 0.1, 0.075])\n    ax_skip = plt.axes([0.81, 0.05, 0.1, 0.075])\n    baccept = mwidget.Button(ax_accept, ""Accept"")\n    baccept.on_clicked(accept)\n    breject = mwidget.Button(ax_reject, ""Reject"")\n    breject.on_clicked(reject)\n    bskip = mwidget.Button(ax_skip, ""Skip"")\n    bskip.on_clicked(skip)\n    plt.text(0.59, 0.15, status, transform=fig.transFigure)\n    plt.show()\n\n\ndef _calculate_hit(uris, phash, action):\n    # Extract the hex basename strings from the uris.\n    hexes = [os.path.splitext(os.path.basename(uri))[0] for uri in uris]\n    # Create the expected perceptual image hashes from the uris.\n    to_hash = imagehash.hex_to_hash\n    expected = [to_hash(uri_hex) for uri_hex in hexes]\n    # Calculate the hamming distance vector for the result hash.\n    distances = [e - phash for e in expected]\n\n    if action == ""first"":\n        index = 0\n    elif action == ""last"":\n        index = -1\n    elif action == ""similar"":\n        index = np.argmin(distances)\n    elif action == ""different"":\n        index = np.argmax(distances)\n    else:\n        emsg = ""Unknown action: {!r}""\n        raise ValueError(emsg.format(action))\n\n    return index, distances[index]\n\n\ndef step_over_diffs(result_dir, action, display=True):\n    processed = False\n    dname = os.path.dirname(tephi.tests.__file__)\n    lock = filelock.FileLock(os.path.join(dname, _POSTFIX_LOCK))\n    if action in [""first"", ""last""]:\n        kind = action\n    elif action in [""similar"", ""different""]:\n        kind = ""most {}"".format(action)\n    else:\n        emsg = ""Unknown action: {!r}""\n        raise ValueError(emsg.format(action))\n    if display:\n        msg = (\n            ""\\nComparing the {!r} expected image with ""\n            ""the test result image.""\n        )\n        print(msg.format(kind))\n\n    # Remove old image diff results.\n    target = os.path.join(result_dir, f""*{_POSTFIX_DIFF}"")\n    for fname in glob(target):\n        os.remove(fname)\n\n    with lock.acquire(timeout=30):\n        # Load the imagerepo.\n        repo_fname = os.path.join(dname, _POSTFIX_JSON)\n        with open(repo_fname, ""rb"") as fi:\n            repo = json.load(codecs.getreader(""utf-8"")(fi))\n\n        # Filter out all non-test result image files.\n        target_glob = os.path.join(result_dir, ""result-*.png"")\n        results = []\n        for fname in sorted(glob(target_glob)):\n            # We only care about PNG images.\n            try:\n                im = Image.open(fname)\n                if im.format != ""PNG"":\n                    # Ignore - it\'s not a png image.\n                    continue\n            except IOError:\n                # Ignore - it\'s not an image.\n                continue\n            results.append(fname)\n\n        count = len(results)\n\n        for count_index, result_fname in enumerate(results):\n            key = os.path.splitext(""-"".join(result_fname.split(""-"")[1:]))[0]\n            try:\n                # Calculate the test result perceptual image hash.\n                phash = imagehash.phash(\n                    Image.open(result_fname), hash_size=tephi.tests._HASH_SIZE\n                )\n                uris = repo[key]\n                hash_index, distance = _calculate_hit(uris, phash, action)\n                uri = uris[hash_index]\n            except KeyError:\n                wmsg = ""Ignoring unregistered test result {!r}.""\n                warnings.warn(wmsg.format(key))\n                continue\n            with temp_png(key) as expected_fname:\n                processed = True\n                response = requests.get(uri)\n                if response.status_code == requests.codes.ok:\n                    with open(expected_fname, ""wb"") as fo:\n                        fo.write(response.content)\n                else:\n                    # Perhaps the uri has not been pushed into the repo yet,\n                    # so check if a local ""developer"" copy is available ...\n                    local_fname = os.path.join(\n                        result_dir, os.path.basename(uri)\n                    )\n                    if not os.path.isfile(local_fname):\n                        emsg = ""Bad URI {!r} for test {!r}.""\n                        raise ValueError(emsg.format(uri, key))\n                    else:\n                        # The temporary expected filename has the test name\n                        # baked into it, and is used in the diff plot title.\n                        # So copy the local file to the exected file to\n                        # maintain this helpfulness.\n                        shutil.copy(local_fname, expected_fname)\n                try:\n                    mcompare.compare_images(\n                        expected_fname, result_fname, tol=0\n                    )\n                except Exception as e:\n                    if isinstance(e, ValueError) or isinstance(\n                        e, ImageComparisonFailure\n                    ):\n                        print(\n                            ""Could not compare {}: {}"".format(result_fname, e)\n                        )\n                        continue\n                    else:\n                        # Propagate the exception, keeping the stack trace\n                        raise\n                diff_fname = os.path.splitext(result_fname)[0] + _POSTFIX_DIFF\n                args = expected_fname, result_fname, diff_fname\n                if display:\n                    msg = ""Image {} of {}: hamming distance = {} "" ""[{!r}]""\n                    status = msg.format(count_index + 1, count, distance, kind)\n                    prefix = repo, key, repo_fname, phash, status\n                    yield prefix + args\n                else:\n                    yield args\n        if display and not processed:\n            print(""\\nThere are no tephi test result images to process.\\n"")\n\n\nif __name__ == ""__main__"":\n    default = os.path.join(\n        os.path.dirname(tephi.tests.__file__), ""result_image_comparison""\n    )\n    description = ""Tephi graphic test difference tool.""\n    formatter_class = argparse.RawTextHelpFormatter\n    parser = argparse.ArgumentParser(\n        description=description, formatter_class=formatter_class\n    )\n    help = ""path to tephi tests result image directory (default: %(default)s)""\n    parser.add_argument(""--resultdir"", ""-r"", default=default, help=help)\n    help = (\n        \'force ""tephi.tests"" to use the tkagg backend (default: %(default)s)\'\n    )\n    parser.add_argument(""-d"", action=""store_true"", default=True, help=help)\n    help = """"""\nfirst     - compare result image with first (oldest) expected image\nlast      - compare result image with last (youngest) expected image\nsimilar   - compare result image with most similar expected image (default)\ndifferent - compare result image with most unsimilar expected image\n""""""\n    choices = (""first"", ""last"", ""similar"", ""different"")\n    parser.add_argument(\n        ""action"", nargs=""?"", choices=choices, default=""similar"", help=help\n    )\n    args = parser.parse_args()\n    result_dir = args.resultdir\n    if not os.path.isdir(result_dir):\n        emsg = ""Invalid results directory: {}""\n        raise ValueError(emsg.format(result_dir))\n    for args in step_over_diffs(result_dir, args.action):\n        diff_viewer(*args)\n'"
tephi/tests/test_imagerepo.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nTest that imagerepo.json reconciles with the images registered in the\ntest-tephi-imagehash repository.\n\n""""""\n# Import tephi tests first so that some things can be initialised before\n# importing anything else\nimport tephi.tests as tests\n\nimport codecs\nimport itertools\nimport json\nimport os\nimport pytest\n\nimport requests\n\n\nIMAGE_MANIFEST = (\n    ""https://raw.githubusercontent.com/SciTools/""\n    ""test-tephi-imagehash/gh-pages/image_manifest.txt""\n)\n\n\n@tests.requires_inet\nclass TestImageRepoJSON:\n    def test(self):\n        response = requests.get(IMAGE_MANIFEST)\n\n        emsg = \'Failed to download ""image_manifest.txt""\'\n        assert response.status_code == requests.codes.ok, emsg\n\n        image_manifest = response.content.decode(""utf-8"")\n        image_manifest = [line.strip() for line in image_manifest.split(""\\n"")]\n        image_manifest_uris = set(\n            os.path.join(tests.BASE_URL, fname) for fname in image_manifest\n        )\n\n        imagerepo_fname = os.path.join(\n            os.path.dirname(__file__), ""results"", ""imagerepo.json""\n        )\n        with open(imagerepo_fname, ""rb"") as fi:\n            imagerepo = json.load(codecs.getreader(""utf-8"")(fi))\n\n        # ""imagerepo"" maps key: list-of-uris. Put all the uris in one big set.\n        tests_uris = set(itertools.chain.from_iterable(imagerepo.values()))\n\n        missing = list(tests_uris - image_manifest_uris)\n        count = len(missing)\n        if count:\n            emsg = (\n                \'""imagerepo.json"" references {} image URIs that are not \'\n                \'listed in ""{}"":\\n\\t\'\n            )\n            emsg = emsg.format(count, IMAGE_MANIFEST)\n            emsg += ""\\t"".join(uri for uri in missing)\n            pytest.fail(emsg)\n'"
tephi/tests/test_tephigram.py,5,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""\nTests the tephigram plotting capability provided by tephi.\n\n""""""\n# Import tephi test package first so that some things can be initialised\n# before importing anything else.\nimport tephi.tests as tests\n\nimport numpy as np\nimport pytest\n\nimport tephi\nfrom tephi import Tephigram\n\n\ndef _load_result(filename):\n    with np.load(tephi.tests.get_result_path(filename)) as f:\n        result = f[""arr_0""]\n    return result\n\n\n_expected_dews = _load_result(""dews.npz"")\n_expected_temps = _load_result(""temps.npz"")\n_expected_barbs = _load_result(""barbs.npz"")\n\n\nclass TestTephigramLoadTxt(tests.TephiTest):\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.filename_dews = tephi.tests.get_data_path(""dews.txt"")\n        self.filename_temps = tephi.tests.get_data_path(""temps.txt"")\n        self.filename_barbs = tephi.tests.get_data_path(""barbs.txt"")\n        self.filename_comma = tephi.tests.get_data_path(""comma_sep.txt"")\n\n    def test_is_not_file(self):\n        with pytest.raises(OSError):\n            tephi.loadtxt(""wibble"")\n\n    def test_load_data_no_column_names(self):\n        dews = tephi.loadtxt(self.filename_dews)\n        assert dews._fields == (""pressure"", ""temperature"")\n        self.assertArrayEqual(dews.pressure, _expected_dews[0])\n        self.assertArrayEqual(dews, _expected_dews)\n\n    def test_load_data_with_column_names(self):\n        # Column titles test all valid namedtuple characters (alphanumeric, _).\n        columns = (""pressure"", ""dewpoint2"", ""wind_speed"", ""WindDirection"")\n        barbs = tephi.loadtxt(self.filename_barbs, column_titles=columns)\n        assert barbs._fields == columns\n        self.assertArrayEqual(barbs.wind_speed, _expected_barbs[2])\n        self.assertArrayEqual(barbs, _expected_barbs)\n\n    def test_load_multiple_files_same_column_names(self):\n        columns = (""foo"", ""bar"")\n        dews, temps = tephi.loadtxt(\n            self.filename_dews, self.filename_temps, column_titles=columns\n        )\n        assert dews._fields == columns\n        assert temps._fields == columns\n\n    def test_load_data_too_many_column_iterables(self):\n        columns = [\n            (""pressure"", ""dewpoint""),\n            (""pressure"", ""wind_speed"", ""wind_direction""),\n        ]\n        with pytest.raises(ValueError):\n            tephi.loadtxt(self.filename_dews, column_titles=columns)\n\n    def test_number_of_columns_and_titles_not_equal(self):\n        columns = (""pressure"", ""dewpoint"", ""wind_speed"")\n        with pytest.raises(TypeError):\n            tephi.loadtxt(self.filename_barbs, column_titles=columns)\n\n    def test_invalid_column_titles(self):\n        columns = (""pres-sure"", ""dew+point"", 5)\n        with pytest.raises(ValueError):\n            tephi.loadtxt(self.filename_dews, column_titles=columns)\n\n    def test_non_iterable_column_title(self):\n        # For the case of column titles, strings are considered non-iterable.\n        columns = ""pressure""\n        with pytest.raises(TypeError):\n            tephi.loadtxt(self.filename_dews, column_titles=columns)\n\n    def test_delimiter(self):\n        columns = (""pressure"", ""temperature"", ""wind_direction"", ""wind_speed"")\n        data = tephi.loadtxt(\n            self.filename_comma, column_titles=columns, delimiter="",""\n        )\n        assert data.pressure.shape == (2,)\n\n    def test_dtype(self):\n        dews = tephi.loadtxt(self.filename_dews, dtype=""i4"")\n        assert dews.pressure[0].dtype == np.int32\n        assert dews.temperature[0].dtype == np.int32\n\n\n@pytest.mark.graphical\n@pytest.mark.usefixtures(""close_plot"", ""nodeid"")\nclass TestTephigramPlot(tests.GraphicsTest):\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.dews = _expected_dews.T\n        self.temps = _expected_temps.T\n\n    def test_plot_dews(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_temps(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(self.temps)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_temps(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(self.dews)\n        tephigram.plot(self.temps)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_label(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(self.dews, label=""Dew-point temperature"")\n        self.check_graphic(nodeid)\n\n    def test_plot_temps_label(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(self.temps, label=""Dry-bulb temperature"")\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_custom(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(\n            self.dews,\n            label=""Dew-point temperature"",\n            linewidth=2,\n            color=""blue"",\n            marker=""s"",\n        )\n        self.check_graphic(nodeid)\n\n    def test_plot_temps_custom(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(\n            self.temps,\n            label=""Dry-bulb temperature"",\n            linewidth=2,\n            color=""red"",\n            marker=""o"",\n        )\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_temps_custom(self, nodeid):\n        tephigram = Tephigram()\n        tephigram.plot(\n            self.dews,\n            label=""Dew-point temperature"",\n            linewidth=2,\n            color=""blue"",\n            marker=""s"",\n        )\n        tephigram.plot(\n            self.temps,\n            label=""Dry-bulb temperature"",\n            linewidth=2,\n            color=""red"",\n            marker=""o"",\n        )\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_isotherm_numeric(self, nodeid):\n        tephigram = Tephigram(isotherm_locator=10)\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_isotherm_object(self, nodeid):\n        tephigram = Tephigram(isotherm_locator=tephi.Locator(10))\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_adiabat_numeric(self, nodeid):\n        tephigram = Tephigram(dry_adiabat_locator=10)\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_adiabat_object(self, nodeid):\n        tephigram = Tephigram(dry_adiabat_locator=tephi.Locator(10))\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_numeric(self, nodeid):\n        tephigram = Tephigram(isotherm_locator=10, dry_adiabat_locator=10)\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_dews_locator_object(self, nodeid):\n        locator = tephi.Locator(10)\n        tephigram = Tephigram(\n            isotherm_locator=locator, dry_adiabat_locator=locator\n        )\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n    def test_plot_anchor(self, nodeid):\n        tephigram = Tephigram(anchor=[(1000, 0), (300, 0)])\n        tephigram.plot(self.dews)\n        self.check_graphic(nodeid)\n\n\n@pytest.mark.graphical\n@pytest.mark.usefixtures(""close_plot"", ""nodeid"")\nclass TestTephigramBarbs(tests.GraphicsTest):\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        self.dews = _expected_dews.T\n        self.temps = _expected_temps.T\n        magnitude = np.hstack(([0], np.arange(20) * 5 + 2, [102]))\n        self.barbs = [(m, 45, 1000 - i * 35) for i, m in enumerate(magnitude)]\n\n    def test_rotate(self, nodeid):\n        tephigram = Tephigram()\n        profile = tephigram.plot(self.temps)\n        profile.barbs(\n            [\n                (0, 0, 900),\n                (1, 30, 850),\n                (5, 60, 800),\n                (10, 90, 750),\n                (15, 120, 700),\n                (20, 150, 650),\n                (25, 180, 600),\n                (30, 210, 550),\n                (35, 240, 500),\n                (40, 270, 450),\n                (45, 300, 400),\n                (50, 330, 350),\n                (55, 360, 300),\n            ],\n            zorder=10,\n        )\n        self.check_graphic(nodeid)\n\n    def test_barbs(self, nodeid):\n        tephigram = Tephigram()\n        profile = tephigram.plot(self.temps)\n        profile.barbs(self.barbs, zorder=10)\n        self.check_graphic(nodeid)\n\n    def test_barbs_from_file(self, nodeid):\n        tephigram = Tephigram()\n        dews = _expected_barbs.T[:, :2]\n        barbs = np.column_stack(\n            (_expected_barbs[2], _expected_barbs[3], _expected_barbs[0])\n        )\n        profile = tephigram.plot(dews)\n        profile.barbs(barbs, zorder=10)\n        self.check_graphic(nodeid)\n\n    def test_gutter(self, nodeid):\n        tephigram = Tephigram()\n        profile = tephigram.plot(self.temps)\n        profile.barbs(self.barbs, gutter=0.5, zorder=10)\n        self.check_graphic(nodeid)\n\n    def test_length(self, nodeid):\n        tephigram = Tephigram()\n        profile = tephigram.plot(self.temps)\n        profile.barbs(self.barbs, gutter=0.9, length=10, zorder=10)\n        self.check_graphic(nodeid)\n\n    def test_color(self, nodeid):\n        tephigram = Tephigram()\n        profile = tephigram.plot(self.temps)\n        profile.barbs(self.barbs, color=""green"", zorder=10)\n        self.check_graphic(nodeid)\n\n    def test_pivot(self, nodeid):\n        tephigram = Tephigram()\n        tprofile = tephigram.plot(self.temps)\n        tprofile.barbs(self.barbs, gutter=0.2, pivot=""tip"", length=8)\n        dprofile = tephigram.plot(self.dews)\n        dprofile.barbs(self.barbs, gutter=0.3, pivot=""middle"", length=8)\n        self.check_graphic(nodeid)\n'"
tephi/utils/__init__.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""Miscellaneous support utilities for tephi.""""""\n'"
tephi/utils/report.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n""""""Platform and package dependency reporting.""""""\n\nimport os\nfrom subprocess import check_output, CalledProcessError\nimport warnings\n\ntry:\n    import scooby\nexcept ImportError:\n    scooby = None\n\n\nclass CondaInfo:\n    """"""\n    Internal helper class to provision conda and conda environment\n    metadata.\n\n    """"""\n\n    def __init__(self):\n        self._path = None\n\n    @property\n    def version(self):\n        result = ""Unknown""\n        if self._path is not None:\n            with open(os.devnull, ""w"") as null:\n                command = [""conda"", ""--version""]\n                try:\n                    result = check_output(command, stderr=null)\n                    result = result.decode(""utf-8"").split("" "")[1].strip()\n                except CalledProcessError:\n                    pass\n        return result\n\n    @property\n    def name(self):\n        result = ""Unknown""\n        if self._path is not None:\n            result = os.environ.get(""CONDA_DEFAULT_ENV"", ""base"")\n        return result\n\n    @property\n    def packages(self):\n        result = ""Unknown""\n        if self._path is not None:\n            with open(os.devnull, ""w"") as null:\n                command = [""conda"", ""list"", ""-n"", self.name, ""--explicit""]\n                try:\n                    result = check_output(command, stderr=null)\n                    lines = result.decode(""utf-8"").split(""\\n"")\n                    lines = sorted(\n                        [\n                            line\n                            for line in lines\n                            if not (\n                                line.startswith(""#"") or line.startswith(""@"")\n                            )\n                            and line\n                        ]\n                    )\n                    result = ""\\n\\t{}"".format(""\\n\\t"".join(lines))\n                except CalledProcessError:\n                    pass\n        return result\n\n    def get_info(self):\n        self._path = os.environ.get(""CONDA_EXE"", None)\n        return (\n            (self.version, ""Conda Version""),\n            (self.name, ""Conda Environment""),\n            (self.packages, ""Conda Packages""),\n        )\n\n\nif scooby is not None:\n\n    class Report(scooby.Report):\n        """"""\n        Generate a :class:`scooby.Report` of platform and package dependencies.\n\n        Parameters\n        ----------\n        additional : list of ModuleType, list of str, optional\n            List of packages or package names to add to output information.\n        ncol : int, optional\n            Number of package-columns in HTML table. Has no effect in text-version\n            (default is 3).\n        text_width : int, optional\n            The text width for non-HTML display modes (default is 80).\n        sort : bool, optional\n            Sort the packages when the report is shown (default is False).\n        conda : bool, optional\n            Gather information about conda (default is False).\n\n        """"""\n\n        def __init__(\n            self,\n            additional=None,\n            ncol=3,\n            text_width=80,\n            sort=False,\n            conda=False,\n        ):\n            # Mandatory packages.\n            core = [""tephi"", ""matplotlib"", ""numpy"", ""scipy""]\n\n            # Gather conda information.\n            if conda:\n                extra_meta = CondaInfo().get_info()\n            else:\n                extra_meta = None\n\n            super().__init__(\n                additional=additional,\n                core=core,\n                ncol=ncol,\n                text_width=text_width,\n                sort=sort,\n                extra_meta=extra_meta,\n            )\n\n\nelse:\n\n    def Report(*args, **kwargs):\n        wmsg = (\n            \'Cannot generate a report. Please first install the ""scooby"" \'\n            ""package from either conda-forge or PyPI.""\n        )\n        warnings.warn(wmsg)\n'"
docs/tephi/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# tephi documentation build configuration file, created by\n# sphinx-quickstart on Thu Jun 26 15:24:09 2014.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nfrom datetime import datetime\nimport os\nimport pathlib\nimport sys\n\n# ensure tephi is discoverable by rtd build environment\nroot = pathlib.Path(__file__).absolute().parent.parent.parent.parent\nos.environ[""PYTHONPATH""] = str(root)\nsys.path.insert(0, str(root))\n\nimport tephi\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.append(os.path.abspath(\'sphinxext\'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\',\n              \'sphinx.ext.coverage\',\n              \'sphinx.ext.doctest\',\n              \'sphinx.ext.imgmath\',\n              \'sphinx.ext.intersphinx\',\n              \'matplotlib.sphinxext.mathmpl\',\n              \'matplotlib.sphinxext.plot_directive\',\n              \'custom_class_autodoc\',\n              \'generate_package_rst\',\n              \'sphinx_copybutton\',\n              ]\n\n# List of packages to document\nautopackage_name = [\'tephi\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n# source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'tephi\'\ncopyright = f\'2014-{datetime.now().year}, British Crown Copyright, Met Office\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = tephi.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = tephi.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'sphinxext\', \'build\']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n# default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {""logo_only"": True}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = ""_static/tephi-logo-200-137.png""\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = ""_static/favicon.ico""\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'tephidoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {}\n# The paper size (\'letterpaper\' or \'a4paper\').\n# \'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n# \'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n# \'preamble\': \'\',\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\'index\', \'tephi.tex\', u\'tephi Documentation\',\n     copyright, \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'tephi\', u\'tephi Documentation\',\n     [copyright], 1)\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\'index\', \'tephi\', u\'tephi Documentation\',\n     copyright, \'tephi\',\n     \'One line description of project.\', \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n# texinfo_show_urls = \'footnote\'\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \'python\': (\'http://docs.python.org/3.8\', None),\n    \'numpy\': (\'http://docs.scipy.org/doc/numpy/\', None),\n    \'matplotlib\': (\'http://matplotlib.sourceforge.net/\', None),\n}\n\n# Define Python input prompt to copybutton.\ncopybutton_prompt_text = "">>> ""\n'"
docs/tephi/source/plot/barbs.py,3,"b'import matplotlib.pyplot as plt\nimport numpy as np\n\n_BARB_BINS = np.arange(20) * 5 + 3\nknots = {\n    0: ""1-2 knots"",\n    1: ""3-7 knots"",\n    2: ""8-12 knots"",\n    3: ""13-17 knots"",\n    4: ""18-22 knots"",\n    5: ""23-27 knots"",\n    6: ""28-32 knots"",\n    7: ""33-37 knots"",\n    8: ""38-42 knots"",\n    9: ""43-47 knots"",\n    10: ""48-52 knots"",\n    11: ""53-57 knots"",\n    12: ""58-62 knots"",\n    13: ""63-67 knots"",\n    14: ""68-72 knots"",\n    15: ""73-77 knots"",\n    16: ""78-82 knots"",\n    17: ""83-87 knots"",\n    18: ""88-92 knots"",\n    19: ""93-97 knots"",\n    20: ""98-102 knots"",\n}\n\ncolor = ""blue""\nkwargs = dict(length=8, color=color)\nlsx = 1\nrsx = 3\nly = 23\ndelta = 0.3\n\nplt.barbs(lsx, ly, 0, 0, **kwargs)\nplt.text(lsx + delta, ly, ""Calm"")\n\nplt.plot([lsx - 0.36, lsx], [ly - 2, ly - 2], linewidth=2, color=color)\nplt.text(lsx + delta, ly - 2, knots[0])\n\nfor i, u in enumerate(range(5, 50, 5)):\n    y = ly - (i + 2) * 2\n    plt.barbs(lsx, y, u, 0, **kwargs)\n    plt.text(\n        lsx + delta, y, knots[np.searchsorted(_BARB_BINS, u, side=""right"")]\n    )\n\nfor i, u in enumerate(range(50, 105, 5)):\n    y = ly - i * 2\n    plt.barbs(rsx, y, u, 0, **kwargs)\n    plt.text(\n        rsx + delta, y, knots[np.searchsorted(_BARB_BINS, u, side=""right"")]\n    )\n\nax = plt.gca()\nax.set_xlim(0, 5)\nax.set_ylim(1, 25)\nax.get_xaxis().set_visible(False)\nax.get_yaxis().set_visible(False)\nplt.show()\n'"
docs/tephi/source/sphinxext/custom_class_autodoc.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n\n\nfrom sphinx.ext import autodoc\nfrom sphinx.ext.autodoc import *\nfrom sphinx.util import force_decode\nfrom sphinx.util.docstrings import prepare_docstring\n\nimport inspect\n\n\nclass ClassWithConstructorDocumenter(autodoc.ClassDocumenter):\n    priority = 1000000\n\n    def get_object_members(self, want_all):\n        return autodoc.ClassDocumenter.get_object_members(self, want_all)\n\n    @staticmethod\n    def can_document_member(member, mname, isattr, self):\n        return autodoc.ClassDocumenter.can_document_member(member, mname,\n                                                           isattr, self)\n\n    def get_doc(self, encoding=None):\n        content = self.env.config.autoclass_content\n\n        docstrings = []\n        docstring = self.get_attr(self.object, \'__doc__\', None)\n        if docstring:\n            docstrings.append(docstring)\n\n        # for classes, what the ""docstring"" is can be controlled via a\n        # config value; the default is only the class docstring\n        if content in (\'both\', \'init\'):\n            constructor = self.get_constructor()\n            if constructor:\n                initdocstring = self.get_attr(constructor, \'__doc__\', None)\n            else:\n                initdocstring = None\n            if initdocstring:\n                if content == \'init\':\n                    docstrings = [initdocstring]\n                else:\n                    docstrings.append(initdocstring)\n\n        return [prepare_docstring(force_decode(docstring, encoding))\n                for docstring in docstrings]\n\n    def get_constructor(self):\n        # for classes, the relevant signature is the __init__ method\'s\n        initmeth = self.get_attr(self.object, \'__new__\', None)\n\n        if initmeth is None or initmeth is object.__new__ or not \\\n                (inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):\n            initmeth = None\n\n        if initmeth is None:\n            initmeth = self.get_attr(self.object, \'__init__\', None)\n\n        if initmeth is None or initmeth is object.__init__ or \\\n                initmeth is object.__new__ or not \\\n                (inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):\n            initmeth = None\n\n        return initmeth\n\n    def format_args(self):\n        initmeth = self.get_constructor()\n        try:\n            argspec = inspect.getargspec(initmeth)\n        except TypeError:\n            # still not possible: happens e.g. for old-style classes\n            # with __init__ in C\n            return None\n        if argspec[0] and argspec[0][0] in (\'cls\', \'self\'):\n            del argspec[0][0]\n        return inspect.formatargspec(*argspec)\n\n\ndef setup(app):\n    app.add_autodocumenter(ClassWithConstructorDocumenter)\n'"
docs/tephi/source/sphinxext/generate_package_rst.py,0,"b'# Copyright Tephi contributors\n#\n# This file is part of Tephi and is released under the LGPL license.\n# See COPYING and COPYING.LESSER in the root of the repository for full\n# licensing details.\n\n\nimport os\nimport sys\nimport re\nimport inspect\n\n\ndocument_dict = {\n                     # Use autoclass for classes\n                     \'class\': \'\'\'\n%(object_docstring)s\n\n..\n\n    .. autoclass:: %(object_name)s\n        :members:\n        :undoc-members:\n\n\'\'\',\n                     \'function\': \'\'\'\n.. autofunction:: %(object_name)s\n\n\'\'\',\n                     # For everything else, let automodule do some magic...\n                     None: \'\'\'\n\n.. autodata:: %(object_name)s\n\n\'\'\'}\n\n\ndef lookup_object_type(obj):\n        if inspect.isclass(obj):\n            return \'class\'\n        elif inspect.isfunction(obj):\n            return \'function\'\n        else:\n            return None\n\n\ndef auto_doc_module(file_path, import_name, root_package, package_toc=None, title=None):\n    r = __import__(import_name)\n    r = sys.modules[import_name]\n    elems = dir(r)\n\n    if \'__all__\' in elems:\n        document_these = r.__all__\n        document_these = [[obj, r.__getattribute__(obj)] for obj in document_these]\n    else:\n        document_these = [[obj, r.__getattribute__(obj)] for obj in elems if not obj.startswith(\'_\') and not inspect.ismodule(r.__getattribute__(obj))]\n        is_from_this_module = lambda x, this_module=r.__name__: hasattr(x[1], \'__module__\') and x[1].__module__ == r.__name__\n    \n        document_these = filter(is_from_this_module, document_these)\n        sort_order = {\'class\': 2, \'function\':1, None:0}\n        # sort them according to sort_order dict\n        document_these = sorted(document_these, key=lambda x: sort_order.get(lookup_object_type(x[1]),0))\n        \n    tmp = \'\'\n    for element, obj in document_these:\n        tmp += \'----------\\n\' + document_dict[lookup_object_type(obj)] % {\'object_name\': import_name + \'.\' + element,\n                                                         \'object_name_header_line\':\'+\' * len(import_name + \'.\' + element),\n                                                         \'object_docstring\': inspect.getdoc(obj),\n                                                         }\n            \n\n    module_elements = \'\\n\'.join([\' * :py:obj:`%s`\' % (element) for element, obj in document_these])\n    \n    tmp = r\'\'\'.. _%(import_name)s:\n\n%(title_underline)s\n%(title)s\n%(title_underline)s\n\n%(sidebar)s\n   \n.. currentmodule:: %(root_package)s\n\n.. automodule:: %(import_name)s\n\nIn this module:\n\n%(module_elements)s\n\n\n\'\'\' + tmp\n    if package_toc:\n       sidebar = """"""\n.. sidebar:: Modules in this package\n\n%(package_toc_tree)s\n\n    """""" % {\'package_toc_tree\': package_toc}\n    else:\n       sidebar = \'\'\n \n    return tmp % {\'title\': title or import_name, \'title_underline\': \'=\' * len(title or import_name), \'import_name\': import_name, \'root_package\':root_package, \'sidebar\':sidebar, \'module_elements\': module_elements}\n\n\ndef auto_doc_package(file_path, import_name, root_package, sub_packages):\n    package_toc = \'\\n      \'.join(sub_packages)\n    package_toc = \'\'\'\n   .. toctree::\n      :maxdepth: 2\n      :titlesonly:\n      \n      %s\n\n   \n\'\'\' % package_toc\n    \n    if \'.\' in import_name:\n        title = None\n    else:\n        title = import_name.capitalize() + \' reference documentation\'\n\n    return auto_doc_module(file_path, import_name, root_package, package_toc=package_toc, title=title)\n\n\ndef auto_package_build(app):\n\n    root_package = app.config.autopackage_name\n    if root_package is None:\n        raise ValueError(\'set the autopackage_name variable in the conf.py file\')\n\n    if not isinstance(root_package, list):\n        raise ValueError(""autopackage was expecting a list of packages to document e.g. [\'itertools\']"")\n\n    for package in root_package:\n        do_package(package)\n\n\ndef do_package(package_name):\n\n#    out_dir = package_name + os.path.sep\n    out_dir = os.path.join(\'source\', package_name) + os.path.sep\n\n    # import the root package. If this fails then an import error will be raised.\n    module = __import__(package_name)\n    root_package = package_name\n    rootdir = os.path.dirname(module.__file__)\n\n\n    package_folder = []\n    module_folders = {}\n    for root, subFolders, files in os.walk(rootdir):\n        for fname in files:\n            name, ext = os.path.splitext(fname)\n            \n            # skip some non-relevant files\n            if ( fname.startswith(\'.\') or fname.startswith(\'#\') or re.search(""^_[^_]"", fname) or \n                 fname.find(\'.svn\')>=0 or not (ext in [\'.py\', \'.so\']) ):\n                continue\n            \n            rel_path = root_package + os.path.join(root, fname).split(rootdir)[-1]\n            mod_folder = root_package + os.path.join(root).split(rootdir)[-1].replace(\'/\',\'.\')\n\n            # only add to package folder list if it contains an __init__ script\n            if name == \'__init__\':\n                package_folder.append([mod_folder, rel_path])\n            else:\n                import_name = mod_folder + \'.\' + name\n                module_folders.setdefault(mod_folder, []).append([import_name, rel_path])\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n        \n    for package, package_path in package_folder:\n        if \'._\' in package or \'test\' in package:\n            continue\n\n        sub_packages = (spackage for spackage, spackage_path in package_folder if spackage != package and spackage.startswith(package))\n        paths = [os.path.join(*spackage.rsplit(\'.\', 2)[-2:None])+\'.rst\' for spackage in sub_packages]\n        paths.extend([os.path.join(os.path.basename(os.path.dirname(path)), os.path.splitext(os.path.basename(path))[0]) for imp_name, path in module_folders.get(package, [])])\n        paths.sort()\n        doc = auto_doc_package(package_path, package, root_package, paths)\n\n        package_dir = out_dir + package.replace(\'.\', os.path.sep)\n        if not os.path.exists(package_dir):\n            os.makedirs(out_dir + package.replace(\'.\', os.path.sep))\n           \n        out_path = package_dir + \'.rst\'\n        if not os.path.exists(out_path) or doc != \'\'.join(open(out_path, \'r\').readlines()):\n            print(f\'creating out of date/non-existant document {out_path}\')\n            with open(out_path, \'w\') as fo:\n                fo.write(doc)\n\n        for import_name, module_path in module_folders.get(package, []):\n            doc = auto_doc_module(module_path, import_name, root_package)\n            out_path = out_dir + import_name.replace(\'.\', os.path.sep) + \'.rst\'\n            if not os.path.exists(out_path) or doc != \'\'.join(open(out_path, \'r\').readlines()):\n                print(f\'creating out of date/non-existant document {out_path}\')\n                with open(out_path, \'w\') as fo:\n                    fo.write(doc)\n\n\ndef setup(app):\n    app.connect(\'builder-inited\', auto_package_build)\n    app.add_config_value(\'autopackage_name\', None, \'env\')\n'"
