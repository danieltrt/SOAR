file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\n\nsetup(\n    name=\'pybuffer\',\n    version=\'0.2.0\',\n    description=\'pybuffer utility for ctypes\',\n    url=\'https://github.com/ShigekiKarita/mir-pybuffer\',\n    author=\'Shigeki Karita\',\n    author_email=""shigekikarita@gmail.com"",\n    license=\'BSL-1.0\',\n    keywords=\'ctypes\',\n    packages=[""pybuffer""],\n    classifiers=[\n        \'Programming Language :: Python :: 3\',\n    ],\n)\n'"
test.py,0,"b'import argparse\nimport ctypes\n\nimport numpy\n\nimport pybuffer\n\nparser = argparse.ArgumentParser()\nparser.add_argument(""libpath"")\nargs = parser.parse_args()\n\nlib = pybuffer.CDLL(args.libpath)\n\nx = numpy.array([[0, 1, 2], [3, 4, 5]]).astype(numpy.float64)\ny = numpy.array([0, 1, 2]).astype(numpy.float64)\nlib.test_pybuffer(pybuffer.to_buffer(x))\nprint(x)\nassert numpy.all(x == -1)\n\nif ""mir"" in args.libpath:\n    print(""==== begin generated ===="")\n    lib.print_generated()\n    print(""===== end generated ====="")\n\n    assert lib.func1(x, y, ctypes.c_double(2.0)) == 0\n    assert numpy.all(x == numpy.array([[-1, 0, 1], [-1, -1, -1]]))\n    assert numpy.all(y == numpy.array([0, 2, 4]))\n    assert lib.pybuffer_func2(x) == 0\n'"
pybuffer/__init__.py,0,"b'""""""\nBoost Software License - Version 1.0 - August 17th, 2003\n\nPermission is hereby granted, free of charge, to any person or organization\nobtaining a copy of the software and accompanying documentation covered by\nthis license (the ""Software"") to use, reproduce, display, distribute,\nexecute, and transmit the Software, and to prepare derivative works of the\nSoftware, and to permit third-parties to whom the Software is furnished to\ndo so, all subject to the following:\n\nThe copyright notices in the Software and this entire statement, including\nthe above license grant, this restriction and the following disclaimer,\nmust be included in all copies of the Software, in whole or in part, and\nall derivative works of the Software, unless such copies or derivative\nworks are solely in the form of machine-executable object code generated by\na source language processor.\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\nSHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\nFOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n""""""\n\nimport ctypes\n\n\n# see also\n# https://docs.python.org/3/c-api/buffer.html#buffer-request-types\n# $CONDA_PREFIX/include/python3.6m/object.h\nPyBUF_SIMPLE   = 0\nPyBUF_WRITABLE = 0x0001\nPyBUF_FORMAT   = 0x0004\nPyBUF_ND       = 0x0008\nPyBUF_STRIDES  = 0x0010 | PyBUF_ND\n\nPyBUF_C_CONTIGUOUS   = 0x0020 | PyBUF_STRIDES\nPyBUF_F_CONTIGUOUS   = 0x0040 | PyBUF_STRIDES\nPyBUF_ANY_CONTIGUOUS = 0x0080 | PyBUF_STRIDES\nPyBUF_INDIRECT       = 0x0100 | PyBUF_STRIDES\n\nPyBUF_CONTIG_RO  = PyBUF_ND\nPyBUF_CONTIG     = PyBUF_ND | PyBUF_WRITABLE\n\nPyBUF_STRIDED_RO = PyBUF_STRIDES\nPyBUF_STRIDED    = PyBUF_STRIDES | PyBUF_WRITABLE\n\nPyBUF_RECORDS_RO = PyBUF_STRIDES | PyBUF_FORMAT\nPyBUF_RECORDS    = PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE\n\nPyBUF_FULL_RO = PyBUF_INDIRECT | PyBUF_FORMAT\nPyBUF_FULL    = PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE\n\nPy_ssize_t = ctypes.c_ssize_t\nPy_ssize_t_p = ctypes.POINTER(Py_ssize_t)\n\n\nclass PyBuffer(ctypes.Structure):\n    """"""Python Buffer Interface\n    See_also:\n    https://docs.python.org/3/c-api/buffer.html#buffer-protocol\n    $CONDA_PREFIX/include/python3.6m/object.h\n    """"""\n    _fields_ = ((\'buf\', ctypes.c_void_p),\n                (\'obj\', ctypes.c_void_p), # owned reference\n                (\'len\', Py_ssize_t),\n                (\'itemsize\', Py_ssize_t),\n\n                (\'readonly\', ctypes.c_int),\n                (\'ndim\', ctypes.c_int),\n                (\'format\', ctypes.c_char_p),\n                (\'shape\', Py_ssize_t_p),\n                (\'strides\', Py_ssize_t_p),\n                (\'suboffsets\', Py_ssize_t_p),\n                (\'internal\', ctypes.c_void_p))\n\n    def __init__(self, obj, flags=PyBUF_FULL):\n        pyapi.PyObject_GetBuffer(obj, ctypes.byref(self), flags)\n\n    def __del__(self):\n        pyapi.PyBuffer_Release(ctypes.byref(self))\n        ctypes.memset(ctypes.byref(self), 0, ctypes.sizeof(self))\n\n\ndef to_buffer(obj, flags=PyBUF_FULL):\n    return ctypes.byref(PyBuffer(obj, flags))\n\n\ndef check_buffer(obj):\n    try:\n        memoryview(obj)\n        return True\n    except TypeError:\n        return False\n\n\nclass CDLL(ctypes.CDLL):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # initialize D runtime\n        if hasattr(self, ""rt_init""):\n            assert self.rt_init()\n\n    def __del__(self):\n        if hasattr(self, ""rt_term""):\n            self.rt_term()\n\n    # https://github.com/python/cpython/blob/306559e6ca15b86eb230609f484f48132b7ca383/Lib/ctypes/__init__.py#L311\n    def __getattr__(self, name):\n        newname = ""pybuffer_"" + name\n        try:\n            func = super().__getattr__(newname)\n        except AttributeError:\n            func = super().__getattr__(name)\n\n        def wrapped(*args):\n            newargs = []\n            for a in args:\n                # see https://docs.python.org/3/c-api/buffer.html#c.PyObject_CheckBuffer\n                if check_buffer(a) == 1:\n                    newargs.append(to_buffer(a))\n                else:\n                    newargs.append(a)\n            return func(*newargs)\n        setattr(self, name, wrapped)\n        return wrapped\n\n\n# PyBuffer functions in PythonAPI\npyapi = ctypes.PyDLL(""PythonAPI"", handle=ctypes.pythonapi._handle)\npyapi.PyObject_GetBuffer.argtypes = (ctypes.py_object,          # obj\n                                     ctypes.POINTER(PyBuffer),  # view\n                                     ctypes.c_int)              # flags\npyapi.PyBuffer_Release.argtypes = ctypes.POINTER(PyBuffer),     # view\n'"
test/test.py,0,"b'import pybuffer\nimport numpy\n\nlib = pybuffer.CDLL(""./libmir-bp-test.so"")\nlib.print();\na = numpy.array([[1.0, 2.0, 3.0], [3.0, 4.0, 6.0]]).astype(numpy.float64)\nlib.func(a) # pybuffer.to_buffer(a))\n'"
