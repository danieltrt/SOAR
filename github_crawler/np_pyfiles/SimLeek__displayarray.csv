file_path,api_count,code
displayarray/__init__.py,0,"b'""""""\nDisplay any array, webcam, or video file.\n\ndisplay is a function that displays these in their own windows.\n""""""\n\n__version__ = ""1.1.1""\n\nfrom .window.subscriber_windows import display, breakpoint_display, read_updates\nfrom .frame.frame_publishing import publish_updates_zero_mq, publish_updates_ros\nfrom . import effects\n'"
displayarray/__main__.py,0,"b'""""""\nDisplayArray.\n\nDisplay NumPy arrays.\n\nUsage:\n  displayarray (-w <webcam-number> | -v <video-filename> | -t <topic-name>[,dtype])... [-m <msg-backend>]\n  displayarray -h\n  displayarray --version\n\n\nOptions:\n  -h, --help                                           Show this help text.\n  --version                                            Show version number.\n  -w <webcam-number>, --webcam=<webcam-number>         Display video from a webcam.\n  -v <video-filename>, --video=<video-filename>        Display frames from a video file.\n  -t <topic-name>, --topic=<topic-name>                Display frames from a topic using the chosen message broker.\n  -m <msg-backend>, --message-backend <msg-backend>    Choose message broker backend. [Default: ROS]\n                                                       Currently supported: ROS, ZeroMQ\n  --ros                                                Use ROS as the backend message broker.\n  --zeromq                                             Use ZeroMQ as the backend message broker.\n""""""\n\nfrom docopt import docopt\nimport asyncio\n\n\ndef main(argv=None):\n    """"""Process command line arguments.""""""\n    arguments = docopt(__doc__, argv=argv)\n    if arguments[""--version""]:\n        from displayarray import __version__\n\n        print(f""DisplayArray V{__version__}"")\n        return\n    from displayarray import display\n\n    vids = [int(w) for w in arguments[""--webcam""]] + arguments[""--video""]\n    v_disps = None\n    if vids:\n        v_disps = display(*vids, blocking=False)\n    from displayarray.frame.frame_updater import read_updates_ros, read_updates_zero_mq\n\n    topics = arguments[""--topic""]\n    topics_split = [t.split("","") for t in topics]\n    d = display()\n\n    async def msg_recv():\n        nonlocal d\n        while d:\n            if arguments[""--message-backend""] == ""ROS"":\n                async for v_name, frame in read_updates_ros(\n                    [t for t, d in topics_split], [d for t, d in topics_split]\n                ):\n                    d.update(arr=frame, id=v_name)\n            if arguments[""--message-backend""] == ""ZeroMQ"":\n                async for v_name, frame in read_updates_zero_mq(\n                    *[bytes(t, encoding=""ascii"") for t in topics]\n                ):\n                    d.update(arr=frame, id=v_name)\n\n    async def update_vids():\n        while v_disps:\n            if v_disps:\n                v_disps.update()\n                await asyncio.sleep(0)\n\n    async def runner():\n        await asyncio.wait([msg_recv(), update_vids()])\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(runner())\n    loop.close()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
displayarray/_uid.py,0,"b'""""""Generate unique IDs for videos.""""""\n\nfrom collections.abc import Hashable\n\n\ndef uid_for_source(video_source):\n    """"""Get a uid for any source so it can be passed through the publisher-subscriber system.""""""\n    if len(str(video_source)) <= 1000:\n        uid = str(video_source)\n    elif isinstance(video_source, Hashable):\n        try:\n            uid = str(hash(video_source))\n        except TypeError:\n            raise NotImplementedError(\n                ""Displaying immutables filled with mutables is not allowed yet. ""\n                ""No tuples of arrays.""\n            )\n    else:\n        uid = str(hash(str(video_source)))\n    return uid\n'"
displayarray/_util.py,0,"b'""""""Functions needed to deal with OpenCV.""""""\n\nimport weakref\n\n\nclass WeakMethod(weakref.WeakMethod):\n    """"""Pass any method to OpenCV without it keeping a reference forever.""""""\n\n    def __call__(self, *args, **kwargs):\n        """"""Call the actual method this object was made with.""""""\n        obj = super().__call__()\n        func = self._func_ref()\n        if obj is None or func is None:\n            return None\n        meth = self._meth_type(func, obj)\n        meth(*args, **kwargs)\n'"
displayarray/callbacks.py,4,"b'""""""Standard callbacks to use on incoming frames.""""""\n\nfrom displayarray.window import window_commands\nimport numpy as np\n\nfrom typing import Union\n\n\ndef global_cv_display_callback(frame: np.ndarray, cam_id: Union[int, str]):\n    """"""\n    Send frames to the global frame dictionary.\n\n    :param frame: The video or image frame\n    :type frame: np.ndarray\n    :param cam_id: The video or image source\n    :type cam_id: Union[int, str]\n    """"""\n    from displayarray.window import SubscriberWindows\n\n    SubscriberWindows.FRAME_DICT[str(cam_id)] = frame\n\n\nclass function_display_callback(object):  # NOSONAR\n    """"""\n    Used for running arbitrary functions on pixels.\n\n    .. code-block:: python\n\n      >>> import random\n      >>> from displayarray.frame import FrameUpdater\n      >>> img = np.zeros((300, 300, 3))\n      >>> def fun(array, coords, finished):\n      ...     r,g,b = random.random()/20.0, random.random()/20.0, random.random()/20.0\n      ...     array[coords[0:2]] = (array[coords[0:2]] + [r,g,b])%1.0\n      >>> FrameUpdater(video_source=img, callbacks=function_display_callback(fun)).display()\n\n    :param display_function: a function to run on the input image.\n    :param finish_function: a function to run on the input image when the other function finishes.\n    """"""\n\n    def __init__(self, display_function, finish_function=None):\n        """"""Run display_function on frames.""""""\n        self.looping = True\n        self.first_call = True\n\n        def _run_finisher(self, frame, finished, *args, **kwargs):\n            if not callable(finish_function):\n                window_commands.quit()\n            else:\n                finished = finish_function(frame, Ellipsis, finished, *args, **kwargs)\n                if finished:\n                    window_commands.quit()\n\n        def _display_internal(self, frame, *args, **kwargs):\n            finished = True\n            if self.first_call:\n                # return to display initial frame\n                self.first_call = False\n                return\n            if self.looping:\n                it = np.nditer(frame, flags=[""multi_index""])\n                while not it.finished:\n                    x, y, c = it.multi_index\n                    finished = display_function(\n                        frame, (x, y, c), finished, *args, **kwargs\n                    )\n                    it.iternext()\n            if finished:\n                self.looping = False\n                _run_finisher(self, frame, finished, *args, **kwargs)\n\n        self.inner_function = _display_internal\n\n    def __call__(self, *args, **kwargs):\n        """"""Call the function ""function_display_callback"" was set up with.""""""\n        return self.inner_function(self, *args, **kwargs)\n'"
displayarray/input.py,0,"b'""""""Decorators for creating input loops that OpenCV handles.""""""\n\nfrom displayarray.window import window_commands\nimport threading\nimport time\n\nfrom typing import Callable\n\n\nclass MouseEvent(object):\n    """"""Holds all the OpenCV mouse event information.""""""\n\n    def __init__(self, event, x, y, flags, param):\n        """"""Create an OpenCV mouse event.""""""\n        self.event = event\n        self.x = x\n        self.y = y\n        self.flags = flags\n        self.param = param\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return ""event:{}\\nx,y:{},{}\\nflags:{}\\nparam:{}\\n"".format(\n            self.event, self.x, self.y, self.flags, self.param\n        )\n\n\nclass _mouse_thread(object):  # NOSONAR\n    """"""Run a function on mouse information that is received by the window.""""""\n\n    def __init__(self, f):\n        self.f = f\n        self.sub_mouse = window_commands.mouse_pub.make_sub()\n\n    def __call__(self, *args, **kwargs):\n        """"""Call the function this was set up with.""""""\n        self.f(self.sub_mouse, *args, **kwargs)\n\n\nclass _mouse_loop_thread(object):  # NOSONAR\n    """"""Run a function on mouse information that is received by the window, in the main loop.""""""\n\n    def __init__(self, f, run_when_no_events=False, fps=60):\n        self.f = f\n        self.sub_mouse = window_commands.mouse_pub.make_sub()\n        self.sub_cmd = window_commands.win_cmd_pub.make_sub()\n        self.sub_cmd.return_on_no_data = """"\n        self.run_when_no_events = run_when_no_events\n        self.fps = fps\n\n    def __call__(self, *args, **kwargs):\n        """"""Run the function this was set up with in a loop.""""""\n        msg_cmd = """"\n        while msg_cmd != ""quit"":\n            mouse_xyzclick = self.sub_mouse.get(blocking=True)  # type: MouseEvent\n            if mouse_xyzclick is not self.sub_mouse.return_on_no_data:\n                self.f(mouse_xyzclick, *args, **kwargs)\n            elif self.run_when_no_events:\n                self.f(None, *args, **kwargs)\n            msg_cmd = self.sub_cmd.get()\n            time.sleep(1.0 / self.fps)\n        window_commands.quit(force_all_read=False)\n\n\nclass mouse_loop(object):  # NOSONAR\n    """"""\n    Run a function on mouse information that is received by the window, continuously in a new thread.\n\n    .. code-block:: python\n\n      >>> @mouse_loop\n      ... def fun(mouse_event):\n      ...   print(""x:{}, y:{}"".format(mouse_event.x, mouse_event.y))\n    """"""\n\n    def __init__(self, f):\n        """"""Start a new mouse thread for the decorated function.""""""\n        self.t = threading.Thread(\n            target=_mouse_loop_thread(f, run_when_no_events=False)\n        )\n        self.t.start()\n\n    def __call__(self, *args, **kwargs):\n        """"""Return the thread that was started with the function passed in.""""""\n        return self.t\n\n\nclass _key_thread(object):  # NOSONAR\n    """"""Run a function on mouse information that is received by the window.""""""\n\n    def __init__(self, f):\n        self.f = f\n        self.sub_key = window_commands.key_pub.make_sub()\n\n    def __call__(self, *args, **kwargs):\n        """"""Call the function this was set up with.""""""\n        self.f(self.sub_key, *args, **kwargs)\n\n\nclass _key_loop_thread(object):  # NOSONAR\n    """"""Run a function on mouse information that is received by the window, in the main loop.""""""\n\n    def __init__(self, f, run_when_no_events=False, fps=60):\n        self.f = f\n        self.sub_key = window_commands.key_pub.make_sub()\n        self.sub_cmd = window_commands.win_cmd_pub.make_sub()\n        self.sub_cmd.return_on_no_data = """"\n        self.run_when_no_events = run_when_no_events\n        self.fps = fps\n\n    def __call__(self, *args, **kwargs):\n        """"""Run the function this was set up with in a loop.""""""\n        msg_cmd = """"\n        while msg_cmd != ""quit"":\n            key_chr = self.sub_key.get()  # type: chr\n            if key_chr is not self.sub_key.return_on_no_data:\n                self.f(key_chr, *args, **kwargs)\n            elif self.run_when_no_events:\n                self.f(None, *args, **kwargs)\n            msg_cmd = self.sub_cmd.get()\n            time.sleep(1.0 / self.fps)\n        window_commands.quit(force_all_read=False)\n\n\nclass key_loop(object):  # NOSONAR\n    """"""\n    Run a function on mouse information that is received by the window, continuously in a new thread.\n\n    .. code-block:: python\n\n      >>> @key_loop\n      ... def fun(key):\n      ...   print(""key pressed:{}"".format(key))\n    """"""\n\n    def __init__(self, f: Callable[[str], None]):\n        """"""Start a new key thread for the decorated function.""""""\n        self.t = threading.Thread(target=_key_loop_thread(f, run_when_no_events=False))\n        self.t.start()\n\n    def __call__(self, *args, **kwargs):\n        """"""Return the thread that was started with the function passed in.""""""\n        return self.t\n'"
examples/__init__.py,0,b'# Fractal test is from: https://www.youtube.com/watch?v=WgXQ59rg0GM\nimport os\n'
tests/__init__.py,0,b''
displayarray/effects/__init__.py,0,"b'""""""Effects to run on numpy arrays to make data clearer.""""""\n\nfrom . import crop, lens, select_channels\n'"
displayarray/effects/crop.py,5,"b'""""""Crop any n-dimensional array.""""""\n\nimport numpy as np\nfrom ..input import mouse_loop\n\n\nclass Crop(object):\n    """"""A callback class that will return the input array cropped to the output size. N-dimensional.""""""\n\n    def __init__(self, output_size=(64, 64, 3), center=None):\n        """"""\n        Create the cropping callback class.\n\n        :param output_size: Specified the size the input should be cropped to. Can be redefined later.\n        :param center: Specifies the center on the input array to take the crop out of.\n        """"""\n        self._output_size = None\n        self._center = np.asarray([o // 2 for o in output_size])\n        self.odd_center = None\n        self.mouse_control = None\n        self.input_size = None\n\n        self.center = center\n        self.output_size = output_size\n\n    @property\n    def output_size(self):\n        """"""Get the output size.""""""\n        return self._output_size\n\n    @output_size.setter\n    def output_size(self, set):\n        """"""Set the output size.""""""\n        self._output_size = set\n        if self._output_size is not None:\n            self._output_size = np.asarray(set)\n\n    @property\n    def center(self):\n        """"""Get the center.""""""\n        return self._center\n\n    @center.setter\n    def center(self, set):\n        """"""Set the center. Guarded so that colors need not be set.""""""\n        if set is not None:\n            for x in range(len(set)):\n                self._center[x] = set[x]\n\n    def __call__(self, arr):\n        """"""Crop the input array to the specified output size. output is centered on self.center point on input.""""""\n        self.input_size = arr.shape\n        if self.center is None:\n            self.center = [int(arr.shape[x]) // 2 for x in range(arr.ndim)]\n        self.odd_out = np.array(\n            [self.output_size[x] % 2 for x in range(len(self.output_size))]\n        )\n        self.odd_center = np.array(\n            [self.center[x] % 2 for x in range(len(self.center))]\n        )\n\n        center = self.center.copy()  # stop opencv from thread breaking us\n        top_left_get = [\n            min(max(0, center[x] - self.output_size[x] // 2), arr.shape[x] - 1)\n            for x in range(arr.ndim)\n        ]\n        bottom_right_get = [\n            min(\n                max(0, center[x] + self.output_size[x] // 2 + self.odd_out[x]),\n                arr.shape[x],\n            )\n            for x in range(arr.ndim)\n        ]\n\n        top_left_put = [\n            min(\n                max(\n                    0,\n                    -(bottom_right_get[x] - center[x] - self.output_size[x] // 2)\n                    + self.odd_out[x],\n                ),\n                self.output_size[x],\n            )\n            for x in range(arr.ndim)\n        ]\n        bottom_right_put = [\n            min(\n                max(0, top_left_put[x] + (bottom_right_get[x] - top_left_get[x])),\n                self.output_size[x],\n            )\n            for x in range(arr.ndim)\n        ]\n        get_slices = [slice(x1, x2) for x1, x2 in zip(top_left_get, bottom_right_get)]\n        get_slices = tuple(get_slices)\n        put_slices = [slice(x1, x2) for x1, x2 in zip(top_left_put, bottom_right_put)]\n        put_slices = tuple(put_slices)\n        out_array = np.zeros(self.output_size)\n        out_array[put_slices] = arr[get_slices]\n        return out_array.astype(arr.dtype)\n\n    def enable_mouse_control(self):\n        """"""Move the mouse to move where the crop is from on the original image.""""""\n\n        @mouse_loop\n        def m_loop(me):\n            if self.center is None:\n                self.center = [0, 0, 1]\n            self.center[:] = [\n                int(me.y / self.output_size[0] * self.input_size[0]),\n                int(me.x / self.output_size[1] * self.input_size[1]),\n                1,\n            ]\n\n        self.mouse_control = m_loop\n        return self\n'"
displayarray/effects/lens.py,31,"b'""""""Create lens effects. Currently only 2D+color arrays are supported.""""""\n\nimport numpy as np\nfrom ..input import mouse_loop\nimport cv2\n\ntry:\n    import torch\nexcept ImportError:\n    torch = None  # type: ignore\n\n\nclass ControllableLens(object):\n    """"""A lens callback that can be controlled by the program or the user.""""""\n\n    def __init__(self, use_bleed=False, zoom=1, center=None):\n        """"""Create the lens callback.""""""\n        self._center = center\n        self._zoom = zoom\n        self.use_bleed = use_bleed\n        self.bleed = None\n        self.mouse_control = None\n\n    def _check_setup_bleed(self, arr):\n        if not isinstance(self.bleed, np.ndarray) and self.use_bleed:\n            self.bleed = np.zeros_like(arr)\n\n    def run_bleed(self, arr, x, y):\n        """"""Spread color outwards, like food coloring in water.""""""\n        arr[y, ...] = (arr[(y + 1) % len(y), ...] + arr[(y - 1) % len(y), ...]) / 2\n        arr[:, x, ...] = (\n            arr[:, (x + 1) % len(x), ...] + arr[:, (x - 1) % len(x), ...]\n        ) / 2\n\n\nclass Barrel(ControllableLens):\n    """"""A barrel lens distortion callback.""""""\n\n    def __init__(\n        self, use_bleed=False, barrel_power=1, pincushion_power=1, zoom=1, center=None\n    ):\n        """"""Create the barrel lens distortion callback.""""""\n        super().__init__(use_bleed, zoom, center)\n        self._center = center\n        self._zoom = zoom\n        self.use_bleed = use_bleed\n        self.bleed = None\n        self._barrel_power = barrel_power\n        self.mouse_control = None\n        self.input_size = None\n\n    @property\n    def center(self):\n        """"""Guarded get center. Limits to within input.""""""\n        if self.input_size is not None:\n            self._center[:] = [\n                min(max(0, s), self.input_size[i]) for i, s in enumerate(self._center)\n            ]\n        return self._center\n\n    @center.setter\n    def center(self, setpoint):\n        """"""Guarded set center. Limits to within input.""""""\n        if self.input_size is not None:\n            setpoint = [\n                min(max(0, s), self.input_size[i]) for i, s in enumerate(setpoint)\n            ]\n        self._center[:] = setpoint\n\n    @property\n    def zoom(self):\n        """"""Guarded zoom. Avoids divide by zero conditions.""""""\n        if self._zoom == 0:\n            return 1e-15\n        else:\n            return self._zoom\n\n    @property\n    def barrel_power(self):\n        """"""Guarded barrel power. Avoids divide by zero conditions.""""""\n        if self._barrel_power == 0:\n            return 1e-15\n        else:\n            return self._barrel_power\n\n    @barrel_power.setter\n    def barrel_power(self, setpoint):\n        """"""Set the barrel power.""""""\n        self._barrel_power = setpoint\n\n    @zoom.setter  # type: ignore\n    def zoom(self, setpoint):\n        """"""Set the zoom power.""""""\n        self._zoom = setpoint\n\n    def enable_mouse_control(self, crop_size=None):\n        """"""\n        Enable the default mouse controls.\n\n        Move the mouse to center the image\n        scroll to increase/decrease barrel\n        ctrl+scroll to increase/decrease zoom\n        """"""\n\n        @mouse_loop\n        def m_loop(me):\n            if self.input_size is not None:\n                if crop_size is not None:\n                    self.center = [\n                        me.y * self.input_size[0] / crop_size[0],\n                        me.x * self.input_size[1] / crop_size[1],\n                    ]\n                else:\n                    self.center = [me.y, me.x]\n                if me.event == cv2.EVENT_MOUSEWHEEL:\n                    if me.flags & cv2.EVENT_FLAG_CTRLKEY:\n                        if me.flags > 0:\n                            self.zoom *= 1.1\n                        else:\n                            self.zoom /= 1.1\n                    else:\n                        if me.flags > 0:\n                            self.barrel_power *= 1.1\n                        else:\n                            self.barrel_power /= 1.1\n                        print(self.barrel_power)\n\n        self.mouse_control = m_loop\n        return self\n\n    def __call__(self, arr):\n        """"""Run the lens distortion algorithm on the input.""""""\n        zoom_out = 1.0 / self.zoom\n        self._check_setup_bleed(arr)\n\n        self.input_size = arr.shape\n\n        y = np.arange(arr.shape[0])\n        x = np.arange(arr.shape[1])\n        if self._center is None:\n            self._center = [len(y) / 2.0, len(x) / 2.0]\n        y2_ = (y - (len(y) / 2.0)) * zoom_out / arr.shape[0]\n        x2_ = (x - (len(x) / 2.0)) * zoom_out / arr.shape[1]\n        p2 = np.array(np.meshgrid(x2_, y2_))\n\n        cy = self._center[0] / arr.shape[0]\n        cx = self._center[1] / arr.shape[1]\n\n        theta = np.arctan2(p2[1], p2[0])\n\n        radius = np.linalg.norm(p2, axis=0, ord=2)\n\n        radius = pow(radius, self.barrel_power)\n\n        x_new = 0.5 * (radius * np.cos(theta) + cx * 2)\n        x_new = np.clip(x_new * len(x), 0, len(x) - 1)\n\n        y_new = 0.5 * (radius * np.sin(theta) + cy * 2)\n        y_new = np.clip(y_new * len(y), 0, len(y) - 1)\n\n        p = np.array(np.meshgrid(y, x)).astype(np.uint32)\n\n        p_new = np.array((y_new, x_new))\n        p_new = p_new.astype(np.uint32)\n\n        if self.use_bleed:\n            arr2 = self.bleed.copy()\n            self.run_bleed(arr2, x, y)\n            arr2[p_new[0], p_new[1], :] = np.swapaxes(arr[p[0], p[1], :], 0, 1)\n            self.bleed = arr2\n        else:\n            arr[p[0], p[1], :] = np.swapaxes(arr[p_new[0], p_new[1], :], 0, 1)\n\n        return arr\n\n\nclass BarrelPyTorch(Barrel):\n    """"""A barrel distortion callback class accelerated by PyTorch.""""""\n\n    def __call__(self, arr):\n        """"""Run a pytorch accelerated lens distortion algorithm on the input.""""""\n        zoom_out = 1.0 / self.zoom\n        self.input_size = arr.shape\n        y = torch.arange(arr.shape[1]).type(torch.FloatTensor).cuda()\n        x = torch.arange(arr.shape[0]).type(torch.FloatTensor).cuda()\n        if self._center is None:\n            self._center = [y.shape[0] / 2.0, x.shape[0] / 2.0]\n\n        y2_ = (y - (y.shape[0] / 2.0)) * zoom_out / arr.shape[1]\n        x2_ = (x - (x.shape[0] / 2.0)) * zoom_out / arr.shape[0]\n        p2 = torch.stack(torch.meshgrid(x2_, y2_))\n\n        cy = self._center[1] / arr.shape[1]\n        cx = self._center[0] / arr.shape[0]\n\n        theta = torch.atan2(p2[1], p2[0])\n\n        radius = torch.norm(p2, dim=0)\n\n        radius = torch.pow(radius, self.barrel_power)\n\n        x_new = 0.5 * (radius * torch.cos(theta) + cx * 2)\n        x_new = torch.clamp(x_new * x.shape[0], 0, x.shape[0] - 1)\n\n        y_new = 0.5 * (radius * torch.sin(theta) + cy * 2)\n        y_new = torch.clamp(y_new * y.shape[0], 0, y.shape[0] - 1)\n\n        p = torch.stack(torch.meshgrid([x, y])).type(torch.IntTensor)\n\n        p_new = torch.stack((x_new, y_new))\n        p_new = p_new.type(torch.IntTensor)\n\n        arr[p[0], p[1], :] = arr[p_new[0], p_new[1], :]\n\n        return arr\n\n\nclass Mustache(ControllableLens):\n    """"""A mustache distortion callback.""""""\n\n    def __init__(\n        self, use_bleed=False, barrel_power=1, pincushion_power=1, zoom=1, center=None\n    ):\n        """"""Create the mustache distortion callback.""""""\n        super().__init__(use_bleed, zoom, center)\n        self.center = center\n        self.zoom = zoom\n        self.use_bleed = use_bleed\n        self.bleed = None\n        self.barrel_power = barrel_power\n        self.pincushion_power = pincushion_power\n        self.mouse_control = None\n\n    def enable_mouse_control(self):\n        """"""\n        Enable the default mouse loop to control the mustache distortion.\n\n        ctrl+scroll wheel: zoom in and out\n        shift+scroll wheel: adjust pincushion power\n        scroll wheel: adjust barrel power\n        """"""\n\n        @mouse_loop\n        def m_loop(me):\n            self.center[:] = [me.y, me.x]\n            if me.event == cv2.EVENT_MOUSEWHEEL:\n                if me.flags & cv2.EVENT_FLAG_CTRLKEY:\n                    if me.flags > 0:\n                        self.zoom *= 1.1\n                    else:\n                        self.zoom /= 1.1\n                elif me.flags & cv2.EVENT_FLAG_SHIFTKEY:\n                    if me.flags > 0:\n                        self.pincushion_power *= 1.1\n                    else:\n                        self.pincushion_power /= 1.1\n                else:\n                    if me.flags > 0:\n                        self.barrel_power *= 1.1\n                    else:\n                        self.barrel_power /= 1.1\n\n        self.mouse_control = m_loop\n\n    def __call__(self, arr):\n        """"""Run the mustache distortion algorithm on the input numpy array.""""""\n        zoom_out = 1.0 / self.zoom\n        self._check_setup_bleed(arr)\n\n        y = np.arange(arr.shape[0])\n        x = np.arange(arr.shape[1])\n        if self.center is None:\n            self.center = [len(y) / 2.0, len(x) / 2.0]\n        y2_ = (y - self.center[0]) * zoom_out / arr.shape[0]\n        x2_ = (x - self.center[1]) * zoom_out / arr.shape[1]\n        p2 = np.array(np.meshgrid(x2_, y2_))\n\n        barrel_power = self.barrel_power\n        pincushion_power = self.pincushion_power\n\n        theta = np.arctan2(p2[1], p2[0])\n\n        radius = np.linalg.norm(p2, axis=0)\n        radius2 = np.linalg.norm(p2, axis=0, ord=4)\n\n        radius = pow(radius, barrel_power)\n        radius2 = pow(radius2, pincushion_power)\n\n        x_new = 0.5 * (radius2 * radius * np.cos(theta) + 1)\n        x_new = np.clip(x_new * len(x), 0, len(x) - 1)\n\n        y_new = 0.5 * (radius2 * radius * np.sin(theta) + 1)\n        y_new = np.clip(y_new * len(y), 0, len(y) - 1)\n\n        p = np.array(np.meshgrid(y, x)).astype(np.uint32)\n\n        p_new = np.array((y_new, x_new)).astype(np.uint32)\n\n        if self.use_bleed:\n            arr2 = self.bleed.copy()\n            self.run_bleed(arr2, x, y)\n            arr2[p_new[0], p_new[1], :] = np.swapaxes(arr[p[0], p[1], :], 0, 1)\n            self.bleed = arr2\n        else:\n            arr2 = np.zeros_like(arr)\n            arr2[p_new[0], p_new[1], :] = np.swapaxes(arr[p[0], p[1], :], 0, 1)\n\n        return arr2\n'"
displayarray/effects/select_channels.py,1,"b'""""""Reduce many color images to the three colors that your eyeballs can see.""""""\n\nimport numpy as np\nfrom ..input import mouse_loop\nimport cv2\n\nfrom typing import Iterable\n\n\nclass SelectChannels(object):\n    """"""\n    Select channels to display from an array with too many colors.\n\n    :param selected_channels: the list of channels to display.\n    """"""\n\n    def __init__(self, selected_channels: Iterable[int] = None):\n        """"""Select which channels from the input array to display in the output.""""""\n        if selected_channels is None:\n            selected_channels = [0, 0, 0]\n        self.selected_channels = selected_channels\n        self.mouse_control = None\n        self.mouse_print_channels = False\n        self.num_input_channels = None\n\n    def __call__(self, arr):\n        """"""Run the channel selector.""""""\n        self.num_input_channels = arr.shape[-1]\n        out_arr = [\n            arr[..., min(max(0, x), arr.shape[-1] - 1)] for x in self.selected_channels\n        ]\n        out_arr = np.stack(out_arr, axis=-1)\n        return out_arr\n\n    def enable_mouse_control(self):\n        """"""\n        Enable mouse control.\n\n        Alt+Scroll to increase/decrease channel 2.\n        Shift+Scroll to increase/decrease channel 1.\n        Ctrl+scroll to increase/decrease channel 0.\n        """"""\n\n        @mouse_loop\n        def m_loop(me):\n            if me.event == cv2.EVENT_MOUSEWHEEL:\n                if me.flags & cv2.EVENT_FLAG_CTRLKEY:\n                    if me.flags > 0:\n                        self.selected_channels[0] += 1\n                        self.selected_channels[0] = min(\n                            self.selected_channels[0], self.num_input_channels - 1\n                        )\n                    else:\n                        self.selected_channels[0] -= 1\n                        self.selected_channels[0] = max(self.selected_channels[0], 0)\n                    if self.mouse_print_channels:\n                        print(f""Channel 0 now maps to {self.selected_channels[0]}."")\n                elif me.flags & cv2.EVENT_FLAG_SHIFTKEY:\n                    if me.flags > 0:\n                        self.selected_channels[1] += 1\n                        self.selected_channels[1] = min(\n                            self.selected_channels[1], self.num_input_channels - 1\n                        )\n                    else:\n                        self.selected_channels[1] -= 1\n                        self.selected_channels[1] = max(self.selected_channels[1], 0)\n                    if self.mouse_print_channels:\n                        print(f""Channel 1 now maps to {self.selected_channels[1]}."")\n                elif me.flags & cv2.EVENT_FLAG_ALTKEY:\n                    if me.flags > 0:\n                        self.selected_channels[2] += 1\n                        self.selected_channels[2] = min(\n                            self.selected_channels[2], self.num_input_channels - 1\n                        )\n                    else:\n                        self.selected_channels[2] -= 1\n                        self.selected_channels[2] = max(self.selected_channels[2], 0)\n                    if self.mouse_print_channels:\n                        print(f""Channel 2 now maps to {self.selected_channels[2]}."")\n\n        self.mouse_control = m_loop\n'"
displayarray/frame/__init__.py,0,"b'""""""\nHandles publishing arrays, videos, and cameras.\n\nCamCtrl handles sending and receiving commands to specific camera (or array/video) publishers\nVideoHandlerThread updates the frames for the global displayer, since OpenCV can only update on the main thread\nget_cam_ids gets the ids for all cameras that OpenCV can detect\npub_cam_thread continually publishes updates to arrays, videos, and cameras\nnp_cam simulates numpy arrays as OpenCV cameras\n""""""\n\nfrom . import subscriber_dictionary\nfrom .frame_updater import FrameUpdater\nfrom .get_frame_ids import get_cam_ids\nfrom .np_to_opencv import NpCam\nfrom .frame_publishing import pub_cam_thread\n'"
displayarray/frame/frame_publishing.py,22,"b'""""""Publish frames so any function within this program can find them.""""""\n\nimport asyncio\nimport sys\nimport threading\nimport time\nimport warnings\n\nimport cv2\n\nusing_pyv4l2cam = False\ntry:\n    if sys.platform == ""linux"":\n        from PyV4L2Cam.camera import Camera as pyv4lcamera\n        from PyV4L2Cam.controls import ControlIDs as pyv4lcontrolids\n\n        using_pyv4l2cam = True\nexcept ImportError:\n    warnings.warn(""Could not import PyV4L2Cam on linux. Camera capture will be slow."")\n    warnings.warn(\n        ""To install, run: pip install git+https://github.com/simleek/PyV4L2Cam.git""\n    )\n\nimport numpy as np\n\nfrom displayarray.frame import subscriber_dictionary\nfrom .np_to_opencv import NpCam\nfrom displayarray._uid import uid_for_source\n\nfrom typing import Union, Tuple, Optional, Dict, Any, List, Callable\n\nFrameCallable = Callable[[np.ndarray], Optional[np.ndarray]]\n\n\ndef _v4l2_convert_mjpeg(mjpeg: bytes) -> Optional[np.ndarray]:\n    # Thanks: https://stackoverflow.com/a/21844162\n    a = mjpeg.find(b""\\xff\\xd8"")\n    b = mjpeg.find(b""\\xff\\xd9"")\n\n    if a == -1 or b == -1:\n        return None\n    else:\n        jpg = mjpeg[a : b + 2]\n        frame = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_COLOR)\n        return frame\n\n\ndef _v4l2_convert_rgb24(rgb24: bytes, width: int, height: int) -> Optional[np.ndarray]:\n    nparr = np.frombuffer(rgb24, np.uint8)\n    np_frame = nparr.reshape((height, width, 3))\n    return np_frame\n\n\ndef pub_cam_loop_pyv4l2(\n    cam_id: Union[int, str, np.ndarray],\n    request_size: Tuple[int, int] = (-1, -1),\n    high_speed: bool = True,\n    fps_limit: float = float(""inf""),\n):\n    """"""\n    Publish whichever camera you select to CVCams.<cam_id>.Vid, using v4l2 instead of opencv.\n\n    You can send a quit command \'quit\' to CVCams.<cam_id>.Cmd\n    Status information, such as failure to open, will be posted to CVCams.<cam_id>.Status\n\n    :param high_speed: Selects mjpeg transferring, which most cameras seem to support, so speed isn\'t limited\n    :param fps_limit: Limits the frames per second.\n    :param cam_id: An integer representing which webcam to use, or a string representing a video file.\n    :param request_size: A tuple with width, then height, to request the video size.\n    :return: True if loop ended normally, False if it failed somehow.\n    """"""\n    name = uid_for_source(cam_id)\n\n    if isinstance(cam_id, (int, str)):\n        if isinstance(cam_id, int):\n            cam: pyv4lcamera = pyv4lcamera(  # type: ignore\n                f""/dev/video{cam_id}"", *request_size\n            )\n        else:\n            cam = pyv4lcamera(cam_id, *request_size)  # type: ignore\n    else:\n        raise TypeError(\n            ""Only strings or ints representing cameras are supported with v4l2.""\n        )\n\n    subscriber_dictionary.register_cam(name)\n\n    sub = subscriber_dictionary.cam_cmd_sub(name)\n    sub.return_on_no_data = """"\n    msg = """"\n\n    if high_speed and cam.pixel_format != ""MJPEG"":\n        warnings.warn(""Camera does not support high speed."")\n\n    now = time.time()\n    while msg != ""quit"":\n        time.sleep(1.0 / (fps_limit - (time.time() - now)))\n        now = time.time()\n        frame_bytes = cam.get_frame()  # type: bytes\n\n        if cam.pixel_format == ""MJPEG"":\n            nd_frame = _v4l2_convert_mjpeg(frame_bytes)\n        elif cam.pixel_format == ""RGB24"":\n            nd_frame = _v4l2_convert_rgb24(frame_bytes, cam.width, cam.height)\n        else:\n            raise NotImplementedError(f""{cam.pixel_format} format not supported."")\n\n        if nd_frame is not None:\n            subscriber_dictionary.CV_CAMS_DICT[name].frame_pub.publish(nd_frame)\n        else:\n            cam.close()\n            subscriber_dictionary.CV_CAMS_DICT[name].status_pub.publish(""failed"")\n            return False\n\n        msg = sub.get()\n    sub.release()\n\n    cam.close()\n    return True\n\n\ndef pub_cam_loop_opencv(\n    cam_id: Union[int, str, np.ndarray],\n    request_size: Tuple[int, int] = (-1, -1),\n    high_speed: bool = True,\n    fps_limit: float = float(""inf""),\n    extra: Optional[List[Tuple[int, int]]] = None,\n) -> bool:\n    """"""\n    Publish whichever camera you select to CVCams.<cam_id>.Vid.\n\n    You can send a quit command \'quit\' to CVCams.<cam_id>.Cmd\n    Status information, such as failure to open, will be posted to CVCams.<cam_id>.Status\n\n    :param high_speed: Selects mjpeg transferring, which most cameras seem to support, so speed isn\'t limited\n    :param fps_limit: Limits the frames per second.\n    :param cam_id: An integer representing which webcam to use, or a string representing a video file.\n    :param request_size: A tuple with width, then height, to request the video size.\n    :return: True if loop ended normally, False if it failed somehow.\n    """"""\n    name = uid_for_source(cam_id)\n\n    if isinstance(cam_id, (int, str)):\n        cam: Union[NpCam, cv2.VideoCapture] = cv2.VideoCapture(cam_id)\n    elif isinstance(cam_id, np.ndarray):\n        cam = NpCam(cam_id)\n    else:\n        raise TypeError(\n            ""Only strings or ints representing cameras, or numpy arrays representing pictures supported.""\n        )\n\n    subscriber_dictionary.register_cam(name)\n\n    frame_counter = 0\n\n    sub = subscriber_dictionary.cam_cmd_sub(name)\n    sub.return_on_no_data = """"\n    msg = """"\n\n    if high_speed:\n        cam.set(cv2.CAP_PROP_FOURCC, cv2.CAP_OPENCV_MJPEG)\n\n    cam.set(cv2.CAP_PROP_FRAME_WIDTH, request_size[0])\n    cam.set(cv2.CAP_PROP_FRAME_HEIGHT, request_size[1])\n\n    if not cam.isOpened():\n        subscriber_dictionary.CV_CAMS_DICT[name].status_pub.publish(""failed"")\n        return False\n    now = time.time()\n    while msg != ""quit"":\n        time.sleep(1.0 / (fps_limit - (time.time() - now)))\n        now = time.time()\n        (ret, frame) = cam.read()  # type: Tuple[bool, np.ndarray ]\n        if ret is False or not isinstance(frame, np.ndarray):\n            cam.release()\n            subscriber_dictionary.CV_CAMS_DICT[name].status_pub.publish(""failed"")\n            return False\n        if cam.get(cv2.CAP_PROP_FRAME_COUNT) > 0:\n            frame_counter += 1\n            if frame_counter >= cam.get(cv2.CAP_PROP_FRAME_COUNT):\n                frame_counter = 0\n                cam = cv2.VideoCapture(cam_id)\n        subscriber_dictionary.CV_CAMS_DICT[name].frame_pub.publish(frame)\n        msg = sub.get()\n    sub.release()\n\n    cam.release()\n    return True\n\n\nuid_dict: Dict[str, threading.Thread] = {}\n\n\ndef pub_cam_thread(\n    cam_id: Union[int, str],\n    request_ize: Tuple[int, int] = (-1, -1),\n    high_speed: bool = True,\n    fps_limit: float = float(""inf""),\n) -> threading.Thread:\n    """"""Run pub_cam_loop in a new thread. Starts on creation.""""""\n\n    name = uid_for_source(cam_id)\n    if name in uid_dict.keys():\n        t = uid_dict[name]\n    else:\n        if (\n            sys.platform == ""linux""\n            and using_pyv4l2cam\n            and (\n                isinstance(cam_id, int)\n                or (isinstance(cam_id, str) and ""/dev/video"" in cam_id)\n            )\n        ):\n            pub_cam_loop = pub_cam_loop_pyv4l2\n        else:\n            pub_cam_loop = pub_cam_loop_opencv\n\n        t = threading.Thread(\n            target=pub_cam_loop, args=(cam_id, request_ize, high_speed, fps_limit)\n        )\n        uid_dict[name] = t\n        t.start()\n    return t\n\n\nasync def publish_updates_zero_mq(\n    *vids,\n    callbacks: Optional[\n        Union[Dict[Any, FrameCallable], List[FrameCallable], FrameCallable]\n    ] = None,\n    fps_limit=float(""inf""),\n    size=(-1, -1),\n    end_callback: Callable[[], bool] = lambda: False,\n    blocking=False,\n    publishing_address=""tcp://127.0.0.1:5600"",\n    prepend_topic="""",\n    flags=0,\n    copy=True,\n    track=False,\n):\n    """"""Publish frames to ZeroMQ when they\'re updated.""""""\n    import zmq\n    from displayarray import read_updates\n\n    ctx = zmq.Context()\n    s = ctx.socket(zmq.PUB)\n    s.bind(publishing_address)\n\n    if not blocking:\n        flags |= zmq.NOBLOCK\n\n    try:\n        for v in read_updates(vids, callbacks, fps_limit, size, end_callback, blocking):\n            if v:\n                for vid_name, frame in v.items():\n                    md = dict(\n                        dtype=str(frame.dtype),\n                        shape=frame.shape,\n                        name=prepend_topic + vid_name,\n                    )\n                    s.send_json(md, flags | zmq.SNDMORE)\n                    s.send(frame, flags, copy=copy, track=track)\n            if fps_limit:\n                await asyncio.sleep(1.0 / fps_limit)\n            else:\n                await asyncio.sleep(0)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        vid_names = [uid_for_source(name) for name in vids]\n        for v in vid_names:\n            subscriber_dictionary.stop_cam(v)\n\n\nasync def publish_updates_ros(\n    *vids,\n    callbacks: Optional[\n        Union[Dict[Any, FrameCallable], List[FrameCallable], FrameCallable]\n    ] = None,\n    fps_limit=float(""inf""),\n    size=(-1, -1),\n    end_callback: Callable[[], bool] = lambda: False,\n    blocking=False,\n    node_name=""displayarray"",\n    publisher_name=""npy"",\n    rate_hz=None,\n    dtype=None,\n):\n    """"""Publish frames to ROS when they\'re updated.""""""\n    import rospy\n    from rospy.numpy_msg import numpy_msg\n    import std_msgs.msg\n    from displayarray import read_updates\n\n    def get_msg_type(dtype):\n        if dtype is None:\n            msg_type = {\n                np.float32: std_msgs.msg.Float32(),\n                np.float64: std_msgs.msg.Float64(),\n                np.bool: std_msgs.msg.Bool(),\n                np.char: std_msgs.msg.Char(),\n                np.int16: std_msgs.msg.Int16(),\n                np.int32: std_msgs.msg.Int32(),\n                np.int64: std_msgs.msg.Int64(),\n                np.str: std_msgs.msg.String(),\n                np.uint16: std_msgs.msg.UInt16(),\n                np.uint32: std_msgs.msg.UInt32(),\n                np.uint64: std_msgs.msg.UInt64(),\n                np.uint8: std_msgs.msg.UInt8(),\n            }[dtype]\n        else:\n            msg_type = (\n                dtype  # allow users to use their own custom messages in numpy arrays\n            )\n        return msg_type\n\n    publishers: Dict[str, rospy.Publisher] = {}\n    rospy.init_node(node_name, anonymous=True)\n    try:\n        for v in read_updates(vids, callbacks, fps_limit, size, end_callback, blocking):\n            if v:\n                if rospy.is_shutdown():\n                    break\n                for vid_name, frame in v.items():\n                    if vid_name not in publishers:\n                        dty = frame.dtype if dtype is None else dtype\n                        publishers[vid_name] = rospy.Publisher(\n                            publisher_name + vid_name,\n                            numpy_msg(get_msg_type(dty)),\n                            queue_size=10,\n                        )\n                    publishers[vid_name].publish(frame)\n            if rate_hz:\n                await asyncio.sleep(1.0 / rate_hz)\n            else:\n                await asyncio.sleep(0)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        vid_names = [uid_for_source(name) for name in vids]\n        for v in vid_names:\n            subscriber_dictionary.stop_cam(v)\n    if rospy.core.is_shutdown():\n        raise rospy.exceptions.ROSInterruptException(""rospy shutdown"")\n'"
displayarray/frame/frame_updater.py,19,"b'""""""Get and handle updated frames.""""""\n\nimport threading\nimport asyncio\nfrom typing import Union, Tuple, Any, Callable, List, Optional, Dict\n\nimport numpy as np\n\nfrom displayarray.callbacks import global_cv_display_callback\nfrom displayarray._uid import uid_for_source\nfrom displayarray.frame import subscriber_dictionary\nfrom displayarray.frame.frame_publishing import pub_cam_thread\nfrom displayarray.window import window_commands\nfrom displayarray.effects.select_channels import SelectChannels\nfrom localpubsub import NoData\n\nFrameCallable = Callable[[np.ndarray], Optional[np.ndarray]]\n\n\nclass FrameUpdater(threading.Thread):\n    """"""Thread for updating frames from a video source.""""""\n\n    def __init__(\n        self,\n        video_source: Union[int, str, np.ndarray] = 0,\n        callbacks: Optional[Union[List[FrameCallable], FrameCallable]] = None,\n        request_size: Tuple[int, int] = (-1, -1),\n        high_speed: bool = True,\n        fps_limit: float = float(""inf""),\n    ):\n        """"""Create the frame updater thread.""""""\n        super(FrameUpdater, self).__init__(target=self.loop, args=())\n        self.cam_id = uid_for_source(video_source)\n        self.video_source = video_source\n        if callbacks is None:\n            callbacks = []\n        if callable(callbacks):\n            self.callbacks = [callbacks]\n        else:\n            self.callbacks = callbacks\n        self.request_size = request_size\n        self.high_speed = high_speed\n        self.fps_limit = fps_limit\n        self.exception_raised = None\n\n    def __wait_for_cam_id(self):\n        while str(self.cam_id) not in subscriber_dictionary.CV_CAMS_DICT:\n            continue\n\n    def __apply_callbacks_to_frame(self, frame):\n        if frame is not None and not isinstance(frame, NoData):\n            try:\n                for c in self.callbacks:\n                    frame_c = c(frame)\n                    if frame_c is not None:\n                        frame = frame_c\n                if (\n                    isinstance(frame, np.ndarray)\n                    and frame.shape[-1] not in [1, 3]\n                    and len(frame.shape) != 2\n                ):\n                    print(\n                        f""Too many channels in output. (Got {frame.shape[-1]} instead of 1 or 3.) ""\n                        f""Frame selection callback added.""\n                    )\n                    print(\n                        ""Ctrl+scroll to change first channel.\\n""\n                        ""Shift+scroll to change second channel.\\n""\n                        ""Alt+scroll to change third channel.""\n                    )\n                    sel = SelectChannels()\n                    sel.enable_mouse_control()\n                    sel.mouse_print_channels = True\n                    self.callbacks.append(sel)\n                    frame = self.callbacks[-1](frame)\n            except Exception as e:\n                self.exception_raised = e\n                frame = self.exception_raised\n                subscriber_dictionary.stop_cam(self.cam_id)\n                window_commands.quit()\n                raise e\n            global_cv_display_callback(frame, self.cam_id)\n\n    def loop(self):\n        """"""Continually get frames from the video publisher, run callbacks on them, and listen to commands.""""""\n        t = pub_cam_thread(\n            self.video_source, self.request_size, self.high_speed, self.fps_limit\n        )\n        self.__wait_for_cam_id()\n\n        sub_cam = subscriber_dictionary.cam_frame_sub(str(self.cam_id))\n        sub_owner = subscriber_dictionary.handler_cmd_sub(str(self.cam_id))\n        msg_owner = sub_owner.return_on_no_data = """"\n        try:\n            while msg_owner != ""quit"":\n                frame = sub_cam.get(blocking=True, timeout=1.0)  # type: np.ndarray\n                self.__apply_callbacks_to_frame(frame)\n                msg_owner = sub_owner.get()\n        except Exception as e:\n            raise e\n        finally:\n            sub_owner.release()\n            sub_cam.release()\n            subscriber_dictionary.stop_cam(self.cam_id)\n            t.join()\n\n    def display(self, callbacks: List[Callable[[np.ndarray], Any]] = None):\n        """"""\n        Start default display operation.\n\n        For multiple video sources, please use something outside of this class.\n\n        :param callbacks: List of callbacks to be run on frames before displaying to the screen.\n        """"""\n        from displayarray.window import SubscriberWindows\n\n        if callbacks is None:\n            callbacks = []\n        self.start()\n        SubscriberWindows(video_sources=[self.cam_id], callbacks=callbacks).loop()\n        self.join()\n        if self.exception_raised is not None:\n            raise self.exception_raised\n\n\n\'\'\'async def read_updates(\n    *vids,\n    callbacks: Optional[\n        Union[\n            Dict[Any, Union[FrameCallable, List[FrameCallable]]],\n            List[FrameCallable],\n            FrameCallable,\n        ]\n    ] = None,\n    fps_limit=float(""inf""),\n    size=(-1, -1),\n    end_callback: Callable[[], bool] = lambda: False,\n    blocking=True,\n):\n    """"""\n    Read back all updates from the requested videos.\n\n    Examp#le usage:\n\n    .. co#de-block:: python\n\n      >>#> from examples.videos import test_video\n      >>#> f = 0\n      >>#> for f, r in enumerate(read_updates(test_video, end_callback=lambda :f==2)):\n      ..#.   print(f""Frame:{f}. Array:{r}"")\n\n    """"""\n    from displayarray.window import SubscriberWindows\n    from displayarray.window.subscriber_windows import _get_video_threads\n\n    vid_names = [uid_for_source(name) for name in vids]\n    vid_threads = _get_video_threads(\n        *vids, callbacks=callbacks, fps=fps_limit, size=size\n    )\n    for v in vid_threads:\n        v.start()\n\n    while not end_callback():\n        vid_update_dict = {}\n        dict_was_updated = False\n        for i in range(len(vid_names)):\n            if vid_names[i] in SubscriberWindows.FRAME_DICT and not isinstance(\n                SubscriberWindows.FRAME_DICT[vid_names[i]], NoData\n            ):\n                vid_update_dict[vid_names[i]] = SubscriberWindows.FRAME_DICT[\n                    vid_names[i]\n                ]\n                if (\n                    isinstance(vid_update_dict[vid_names[i]], np.ndarray)\n                    and len(vid_update_dict[vid_names[i]].shape) <= 3\n                ):\n                    vid_update_dict[vid_names[i]] = [vid_update_dict[vid_names[i]]]\n                dict_was_updated = True\n        if dict_was_updated or not blocking:\n            yield vid_update_dict\n        await asyncio.sleep(0)\n    for v in vid_names:\n        subscriber_dictionary.stop_cam(v)\n    for v in vid_threads:\n        v.join()\'\'\'\n\n\nasync def read_updates_zero_mq(\n    *topic_names,\n    address: str = ""tcp://127.0.0.1:5600"",\n    flags: int = 0,\n    copy: bool = True,\n    track: bool = False,\n    blocking: bool = False,\n    end_callback: Callable[[Any], bool] = lambda x: False,\n):\n    """"""Read updated frames from ZeroMQ.""""""\n    import zmq\n\n    ctx = zmq.Context()\n    s = ctx.socket(zmq.SUB)\n    s.connect(address)\n    if not blocking:\n        flags |= zmq.NOBLOCK\n\n    for topic in topic_names:\n        s.setsockopt(zmq.SUBSCRIBE, topic)\n    cb_val = False\n    while not cb_val:\n        try:\n            md = s.recv_json(flags=flags)\n            msg = s.recv(flags=flags, copy=copy, track=track)\n            buf = memoryview(msg)\n            arr = np.frombuffer(buf, dtype=md[""dtype""])\n            arr.reshape(md[""shape""])\n            name = md[""name""]\n            cb_val = end_callback(md)\n            yield name, arr\n        except zmq.ZMQError as e:\n            if isinstance(e, zmq.Again):\n                pass  # no messages to receive\n            else:\n                raise e\n        finally:\n            await asyncio.sleep(0)\n\n\nasync def read_updates_ros(\n    *topic_names,\n    dtypes=None,\n    listener_node_name=None,\n    poll_rate_hz=None,\n    end_callback: Callable[[Any], bool] = lambda x: False,\n):\n    """"""Read updated frames from ROS.""""""\n    import rospy\n    from rospy.numpy_msg import numpy_msg\n    from rospy.client import _WFM\n    import std_msgs.msg\n    import random\n    import string\n\n    if dtypes is None:\n        raise ValueError(\n            ""ROS cannot automatically determine the types of incoming numpy arrays. Please specify.\\n""\n            ""Options are: \\n""\n            ""\\tfloat32, float64, bool, char, int16, ""\n            ""\\tint32, int64, str, uint16, uint32, uint64, uint8""\n        )\n\n    if listener_node_name is None:\n        # https://stackoverflow.com/a/2257449\n        listener_node_name = """".join(\n            random.choices(string.ascii_uppercase + string.digits, k=8)\n        )\n\n    rospy.init_node(listener_node_name)\n\n    msg_types = [\n        {\n            np.float32: std_msgs.msg.Float32(),\n            np.float64: std_msgs.msg.Float64(),\n            np.bool: std_msgs.msg.Bool(),\n            np.char: std_msgs.msg.Char(),\n            np.int16: std_msgs.msg.Int16(),\n            np.int32: std_msgs.msg.Int32(),\n            np.int64: std_msgs.msg.Int64(),\n            np.str: std_msgs.msg.String(),\n            np.uint16: std_msgs.msg.UInt16(),\n            np.uint32: std_msgs.msg.UInt32(),\n            np.uint64: std_msgs.msg.UInt64(),\n            np.uint8: std_msgs.msg.UInt8(),\n            ""float32"": std_msgs.msg.Float32(),\n            ""float64"": std_msgs.msg.Float64(),\n            ""bool"": std_msgs.msg.Bool(),\n            ""char"": std_msgs.msg.Char(),\n            ""int16"": std_msgs.msg.Int16(),\n            ""int32"": std_msgs.msg.Int32(),\n            ""int64"": std_msgs.msg.Int64(),\n            ""str"": std_msgs.msg.String(),\n            ""uint16"": std_msgs.msg.UInt16(),\n            ""uint32"": std_msgs.msg.UInt32(),\n            ""uint64"": std_msgs.msg.UInt64(),\n            ""uint8"": std_msgs.msg.UInt8(),\n        }.get(\n            dtype, dtype\n        )  # allow users to use their own custom messages in numpy arrays\n        for dtype in dtypes\n    ]\n    s = None\n    cb_val = False\n    try:\n        wfms = {t: _WFM() for t in topic_names}\n        s = {\n            t: rospy.Subscriber(t, numpy_msg(msg_types[i]), wfms[t].cb)\n            for i, t in enumerate(topic_names)\n        }\n        while not cb_val:\n            while not rospy.core.is_shutdown():\n                if poll_rate_hz:\n                    await asyncio.sleep(1.0 / poll_rate_hz)\n                else:\n                    await asyncio.sleep(0)\n                for t, w in wfms.items():\n                    if w.msg is not None:\n                        yield t, w.msg\n                        cb_val = end_callback(w.msg)\n                        w.msg = None\n    except KeyboardInterrupt:\n        pass\n    finally:\n        if s is not None:\n            for _, sub in s.items():\n                sub.unregister()\n    if rospy.core.is_shutdown():\n        raise rospy.exceptions.ROSInterruptException(""rospy shutdown"")\n'"
displayarray/frame/get_frame_ids.py,0,"b'""""""Get camera IDs.""""""\n\nimport cv2\n\nfrom typing import List\n\n\ndef get_cam_ids() -> List[int]:\n    """"""Get all cameras that OpenCV can currently detect.""""""\n    cam_list: List[int] = []\n\n    while True:\n        cam = cv2.VideoCapture(len(cam_list))\n        if not cam.isOpened():\n            break\n        cam_list.append(len(cam_list))\n\n    return cam_list\n'"
displayarray/frame/np_to_opencv.py,1,"b'""""""Allow OpenCV to handle numpy arrays as input.""""""\n\nimport numpy as np\nimport cv2\n\n\nclass NpCam(object):\n    """"""Add OpenCV camera controls to a numpy array.""""""\n\n    def __init__(self, img):\n        """"""Create a fake camera for OpenCV based on the initial array.""""""\n        assert isinstance(img, np.ndarray)\n        self.__img = img\n        self.__is_opened = True\n        if len(img.shape) > 0:\n            self.__height = self.__img.shape[0]\n            if len(self.__img.shape) > 1:\n                self.__width = self.__img.shape[1]\n            else:\n                self.__width = self.__height\n        else:\n            self.__width = self.__height = 1\n        self.__ratio = float(self.__width) / self.__height\n\n        self.__wait_for_ratio = False\n\n    def __handler_ratio(self):\n        if self.__width <= 0 or not isinstance(self.__width, int):\n            self.__width = int(self.__ratio * self.__height)\n        elif self.__height <= 0 or not isinstance(self.__height, int):\n            self.__height = int(self.__width / self.__ratio)\n        if self.__width > 0 and self.__height > 0:\n            self.__img = cv2.resize(self.__img, (self.__width, self.__height))\n\n    def set(self, *args, **kwargs):\n        """"""Set CAP_PROP_FRAME_WIDTH or CAP_PROP_FRAME_HEIGHT to scale a numpy array to that size.""""""\n        if args[0] in [cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT]:\n            self.__wait_for_ratio = not self.__wait_for_ratio\n            if args[0] == cv2.CAP_PROP_FRAME_WIDTH:\n                self.__width = args[1]\n            else:\n                self.__height = args[1]\n            if not self.__wait_for_ratio:\n                self.__handler_ratio()\n\n    @staticmethod\n    def get(*args, **kwargs):\n        """"""Get OpenCV args. Currently only a fake CAP_PROP_FRAME_COUNT to fix detecting video ends.""""""\n        if args[0] == cv2.CAP_PROP_FRAME_COUNT:\n            return float(""inf"")\n\n    def read(self):\n        """"""Read back the numpy array in standard ""did it work"", ""the array"", OpenCV format.""""""\n        return True, self.__img\n\n    def isOpened(self):  # NOSONAR\n        """"""Hack to tell OpenCV we\'re opened until we call release.""""""\n        return self.__is_opened\n\n    def release(self):\n        """"""Let OpenCV know we\'re finished.""""""\n        self.__is_opened = False\n'"
displayarray/frame/subscriber_dictionary.py,0,"b'""""""Publisher-subscriber commands to and from the camera.""""""\n\nfrom localpubsub import VariablePub, VariableSub\n\nfrom typing import Union, Dict\n\n\nclass CamHandler(object):\n    """"""A camera handler instance that will send commands to and receive data from a camera.""""""\n\n    def __init__(self, name, sub):\n        """"""Create the cam handler.""""""\n        self.name = name\n        self.cmd = None\n        self.sub: VariableSub = sub\n        self.pub = VariablePub()\n        self.cmd_pub = VariablePub()\n\n\nclass Cam(object):\n    """"""A camera publisher instance that will send frames, status, and commands out.""""""\n\n    def __init__(self, name):\n        """"""Create the cam.""""""\n        self.name = name\n        self.cmd = None\n        self.frame_pub = VariablePub()\n        self.cmd_pub = VariablePub()\n        self.status_pub = VariablePub()\n\n\nCV_CAM_HANDLERS_DICT: Dict[str, CamHandler] = {}\nCV_CAMS_DICT: Dict[str, Cam] = {}\n\n\ndef register_cam(cam_id):\n    """"""Register camera ""cam_id"" to a global list so it can be picked up.""""""\n    cam = Cam(str(cam_id))\n    CV_CAMS_DICT[str(cam_id)] = cam\n    CV_CAM_HANDLERS_DICT[str(cam_id)] = CamHandler(\n        str(cam_id), cam.frame_pub.make_sub()\n    )\n\n\ndef stop_cam(cam_id: Union[int, str]):\n    """"""Tell camera ""cam_id"" to end it\'s main loop.""""""\n    if str(cam_id) in CV_CAMS_DICT:\n        CV_CAMS_DICT[str(cam_id)].cmd_pub.publish(""quit"", blocking=True)\n    if str(cam_id) in CV_CAM_HANDLERS_DICT:\n        CV_CAM_HANDLERS_DICT[str(cam_id)].cmd_pub.publish(""quit"", blocking=True)\n\n\ndef cam_cmd_sub(cam_id, blocking=True):\n    """"""Get a command subscriber for registered camera ""cam_id"".""""""\n    if blocking:\n        while cam_id not in CV_CAMS_DICT:\n            continue\n    return CV_CAMS_DICT[str(cam_id)].cmd_pub.make_sub()\n\n\ndef cam_frame_sub(cam_id, blocking=True):\n    """"""Get a frame subscriber for registered camera ""cam_id"".""""""\n    if blocking:\n        while cam_id not in CV_CAMS_DICT:\n            continue\n    return CV_CAMS_DICT[str(cam_id)].frame_pub.make_sub()\n\n\ndef cam_status_sub(cam_id, blocking=True):\n    """"""Get a status subscriber for registered camera ""cam_id"".""""""\n    if blocking:\n        while cam_id not in CV_CAMS_DICT:\n            continue\n    return CV_CAMS_DICT[str(cam_id)].status_pub.make_sub()\n\n\ndef handler_cmd_sub(cam_id, blocking=True):\n    """"""Get a command subscriber for registered camera ""cam_id"" handler.""""""\n    if blocking:\n        while cam_id not in CV_CAM_HANDLERS_DICT:\n            continue\n    return CV_CAM_HANDLERS_DICT[str(cam_id)].cmd_pub.make_sub()\n'"
displayarray/window/__init__.py,0,"b'""""""\nDisplays arrays.\n\nSubscriberWindows displays one array per window, updating it as it\'s changed.\n""""""\n\nfrom .subscriber_windows import SubscriberWindows\n'"
displayarray/window/subscriber_windows.py,6,"b'""""""OpenCV windows that will display the arrays.""""""\n\nimport warnings\nfrom threading import Thread\nfrom typing import List, Union, Callable, Any, Dict, Iterable, Optional\n\nimport cv2\nimport numpy as np\nfrom localpubsub import NoData\n\nfrom displayarray.callbacks import global_cv_display_callback\nfrom displayarray._uid import uid_for_source\nfrom displayarray.frame import subscriber_dictionary\nfrom displayarray.frame.frame_updater import FrameCallable\nfrom displayarray.frame.frame_updater import FrameUpdater\nfrom displayarray.input import MouseEvent\nfrom displayarray.window import window_commands\nfrom displayarray._util import WeakMethod\nfrom displayarray.effects.select_channels import SelectChannels\n\n\nclass SubscriberWindows(object):\n    """"""Windows that subscribe to updates to cameras, videos, and arrays.""""""\n\n    FRAME_DICT: Dict[str, np.ndarray] = {}\n    ESC_KEY_CODES = [27]  # ESC key on most keyboards\n\n    def __init__(\n        self,\n        window_names: Iterable[str] = (""displayarray"",),\n        video_sources: Iterable[Union[str, int]] = (0,),\n        callbacks: Optional[List[Callable[[np.ndarray], Any]]] = None,\n        silent: bool = False,\n    ):\n        """"""Create the array displaying window.""""""\n        self.source_names: List[Union[str, int]] = []\n        self.close_threads: Optional[List[Thread]] = []\n        self.frames: Dict[Union[str, int], np.ndarray] = {}\n        self.input_vid_global_names: List[str] = []\n        self.window_names: List[str] = []\n        self.input_cams: List[str] = []\n        self.exited = False\n        self.silent = silent\n\n        if callbacks is None:\n            callbacks = []\n        for name in video_sources:\n            self.add_source(name)\n        self.callbacks = callbacks\n        if not self.silent:\n            for name in window_names:\n                self.add_window(name)\n\n        self.update()\n\n    def __bool__(self):\n        self.update()\n        return not self.exited\n\n    def __iter__(self):\n        while not self.exited:\n            self.update()\n            yield self.frames\n\n    def block(self):\n        """"""Update the window continuously while blocking the outer program.""""""\n        self.loop()\n        for ct in self.close_threads:\n            ct.join()\n\n    def add_source(self, name):\n        """"""Add another source for this class to display.""""""\n        uid = uid_for_source(name)\n        self.source_names.append(uid)\n        self.input_vid_global_names.append(uid)\n        self.input_cams.append(name)\n        return self\n\n    def add_window(self, name):\n        """"""Add another window for this class to display sources with. The name will be the title.""""""\n        self.window_names.append(name)\n        cv2.namedWindow(name + "" (press ESC to quit)"")\n        m = WeakMethod(self.handle_mouse)\n        cv2.setMouseCallback(name + "" (press ESC to quit)"", m)\n        return self\n\n    def add_callback(self, callback):\n        """"""Add a callback for this class to apply to videos.""""""\n        self.callbacks.append(callback)\n        return self\n\n    def __stop_all_cams(self):\n        for c in self.source_names:\n            subscriber_dictionary.stop_cam(c)\n\n    def handle_keys(self, key_input: int):\n        """"""Capture key input for the escape function and passing to key control subscriber threads.""""""\n        if key_input in self.ESC_KEY_CODES:\n            for name in self.window_names:\n                cv2.destroyWindow(name + "" (press ESC to quit)"")\n            self.exited = True\n            window_commands.quit()\n            self.__stop_all_cams()\n            return ""quit""\n        elif key_input not in [-1, 0]:\n            try:\n                window_commands.key_pub.publish(chr(key_input))\n            except ValueError:\n                warnings.warn(\n                    RuntimeWarning(\n                        f""Unknown key code: [{key_input}]. Please report to the displayarray issue page.""\n                    )\n                )\n\n    def handle_mouse(self, event, x, y, flags, param):\n        """"""Capture mouse input for mouse control subscriber threads.""""""\n        mousey = MouseEvent(event, x, y, flags, param)\n        window_commands.mouse_pub.publish(mousey)\n\n    def display_frames(self, frames, win_num=0, prepend_name=""""):\n        """"""Display a list of frames on multiple windows.""""""\n        if isinstance(frames, Exception):\n            raise frames\n        if isinstance(frames, dict):\n            for f_name, f in frames.items():\n                for i in range(len(f)):\n                    # detect nested:\n                    if (\n                        isinstance(f[i], (list, tuple))\n                        or f[i].dtype.num == 17\n                        or (\n                            len(f[i].shape) != 2\n                            and (len(f[i].shape) != 3 or f[i].shape[-1] != 3)\n                        )\n                    ):\n                        win_num = self.display_frames(\n                            f[i], win_num, prepend_name=f""{f_name} - ""\n                        )\n                    else:\n                        if len(self.window_names) <= win_num:\n                            self.add_window(f""{prepend_name}{win_num}"")\n                        cv2.imshow(\n                            self.window_names[win_num] + "" (press ESC to quit)"", f[i]\n                        )\n                        win_num += 1\n        else:\n            for f in range(len(frames)):\n                # detect nested:\n                if (\n                    isinstance(frames[f], (list, tuple))\n                    or frames[f].dtype.num == 17\n                    or (\n                        len(frames[f].shape) != 2\n                        and (len(frames[f].shape) != 3 or frames[f].shape[-1] != 3)\n                    )\n                ):\n                    win_num = self.display_frames(frames[f], win_num, prepend_name)\n                else:\n                    if len(self.window_names) <= win_num:\n                        self.add_window(f""{prepend_name} {win_num}"")\n                    cv2.imshow(\n                        self.window_names[win_num] + "" (press ESC to quit)"", frames[f]\n                    )\n                    win_num += 1\n        return win_num\n\n    def __check_too_many_channels(self):\n        for f_name, f in self.frames.items():\n            for i in range(len(f)):\n                if isinstance(f[i], Exception):\n                    raise f[i]\n                if (\n                    isinstance(f[i], np.ndarray)\n                    and f[i].shape[-1] not in [1, 3]\n                    and len(f[i].shape) != 2\n                ):\n                    print(\n                        f""Too many channels in output. (Got {f[i].shape[-1]} instead of 1 or 3.) ""\n                        f""Frame selection callback added.""\n                    )\n                    print(\n                        ""Ctrl+scroll to change first channel.\\n""\n                        ""Shift+scroll to change second channel.\\n""\n                        ""Alt+scroll to change third channel.""\n                    )\n                    sel = SelectChannels()\n                    sel.enable_mouse_control()\n                    sel.mouse_print_channels = True\n                    self.callbacks.append(sel)\n                    for fr in range(len(f)):\n                        f[fr] = self.callbacks[-1](f[fr])\n                    break\n\n    def update_frames(self):\n        """"""Update the windows with the newest data for all frames.""""""\n        self.frames = {}\n\n        for i in range(len(self.input_vid_global_names)):\n            if self.input_vid_global_names[i] in self.FRAME_DICT and not isinstance(\n                self.FRAME_DICT[self.input_vid_global_names[i]], NoData\n            ):\n                if self.input_vid_global_names[i] not in self.frames.keys():\n                    self.frames[self.input_vid_global_names[i]] = []\n                self.frames[self.input_vid_global_names[i]].append(\n                    self.FRAME_DICT[self.input_vid_global_names[i]]\n                )\n                if len(self.callbacks) > 0:\n                    for c in self.callbacks:\n                        frame = c(self.frames[self.input_vid_global_names[i]][-1])\n                        if frame is not None:\n                            self.frames[self.input_vid_global_names[i]][-1] = frame\n                if not self.silent:\n                    self.__check_too_many_channels()\n        if not self.silent:\n            self.display_frames(self.frames)\n\n    def update(self, arr: np.ndarray = None, id: str = None):\n        """"""Update window frames once. Optionally add a new input and input id.""""""\n        if arr is not None and id is not None:\n            global_cv_display_callback(arr, id)\n            if id not in self.input_cams:\n                self.add_source(id)\n                if not self.silent:\n                    self.add_window(id)\n        sub_cmd = window_commands.win_cmd_sub()\n        self.update_frames()\n        msg_cmd = sub_cmd.get()\n        key = self.handle_keys(cv2.waitKey(1))\n        return msg_cmd, key\n\n    def wait_for_init(self):\n        """"""Update window frames in a loop until they\'re actually updated. Useful for waiting for cameras to init.""""""\n        msg_cmd = """"\n        key = """"\n        while msg_cmd != ""quit"" and key != ""quit"" and len(self.frames) == 0:\n            msg_cmd, key = self.update()\n        return self\n\n    def end(self):\n        """"""Close all threads. Should be used with non-blocking mode.""""""\n        window_commands.quit(force_all_read=False)\n        self.__stop_all_cams()\n        for t in self.close_threads:\n            t.join()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.end()\n\n    def __del__(self):\n        self.end()\n\n    def __delete__(self, instance):\n        self.end()\n\n    def loop(self):\n        """"""Continually update window frame. OpenCV only allows this in the main thread.""""""\n        sub_cmd = window_commands.win_cmd_sub()\n        msg_cmd = """"\n        key = """"\n        while msg_cmd != ""quit"" and key != ""quit"":\n            msg_cmd, key = self.update()\n        sub_cmd.release()\n        window_commands.quit(force_all_read=False)\n        self.__stop_all_cams()\n\n\ndef _get_video_callback_dict_threads(\n    *vids,\n    callbacks: Optional[Dict[Any, Union[FrameCallable, List[FrameCallable]]]] = None,\n    fps=float(""inf""),\n    size=(-1, -1),\n):\n    assert callbacks is not None\n    vid_threads = []\n    for v in vids:\n        v_name = uid_for_source(v)\n        v_callbacks: List[Callable[[np.ndarray], Any]] = []\n        if v_name in callbacks:\n            if isinstance(callbacks[v_name], List):\n                v_callbacks.extend(callbacks[v_name])  # type: ignore\n            elif callable(callbacks[v_name]):\n                v_callbacks.append(callbacks[v_name])  # type: ignore\n        if v in callbacks:\n            if isinstance(callbacks[v], List):\n                v_callbacks.extend(callbacks[v])  # type: ignore\n            elif callable(callbacks[v]):\n                v_callbacks.append(callbacks[v])  # type: ignore\n        vid_threads.append(\n            FrameUpdater(v, callbacks=v_callbacks, fps_limit=fps, request_size=size)\n        )\n    return vid_threads\n\n\ndef _get_video_threads(\n    *vids,\n    callbacks: Optional[\n        Union[\n            Dict[Any, Union[FrameCallable, List[FrameCallable]]],\n            List[FrameCallable],\n            FrameCallable,\n        ]\n    ] = None,\n    fps=float(""inf""),\n    size=(-1, -1),\n):\n    vid_threads: List[Thread] = []\n    if isinstance(callbacks, Dict):\n        vid_threads = _get_video_callback_dict_threads(\n            *vids, callbacks=callbacks, fps=fps, size=size\n        )\n    elif isinstance(callbacks, List):\n        for v in vids:\n            vid_threads.append(\n                FrameUpdater(v, callbacks=callbacks, fps_limit=fps, request_size=size)\n            )\n    elif callable(callbacks):\n        for v in vids:\n            vid_threads.append(\n                FrameUpdater(v, callbacks=[callbacks], fps_limit=fps, request_size=size)\n            )\n    else:\n        for v in vids:\n            if v is not None:\n                vid_threads.append(FrameUpdater(v, fps_limit=fps, request_size=size))\n    return vid_threads\n\n\ndef display(\n    *vids,\n    callbacks: Optional[\n        Union[\n            Dict[Any, Union[FrameCallable, List[FrameCallable]]],\n            List[FrameCallable],\n            FrameCallable,\n        ]\n    ] = None,\n    window_names=None,\n    blocking=False,\n    fps_limit=float(""inf""),\n    size=(-1, -1),\n    silent=False,\n):\n    """"""\n    Display all the arrays, cameras, and videos passed in.\n\n    callbacks can be a dictionary linking functions to videos, or a list of function or functions operating on the video\n     data before displaying.\n    Window names end up becoming the title of the windows\n    """"""\n    vid_threads = _get_video_threads(\n        *vids, callbacks=callbacks, fps=fps_limit, size=size\n    )\n    for v in vid_threads:\n        v.start()\n    if window_names is None:\n        window_names = [""window {}"".format(i) for i in range(len(vids))]\n    if blocking:\n        SubscriberWindows(\n            window_names=window_names, video_sources=vids, silent=silent\n        ).loop()\n        for vt in vid_threads:\n            vt.join()\n    else:\n        s = SubscriberWindows(\n            window_names=window_names, video_sources=vids, silent=silent\n        )\n        s.close_threads = vid_threads\n        return s\n\n\ndef breakpoint_display(*args, **kwargs):\n    """"""Display all the arrays, cameras, and videos passed in. Stops code execution until the window is closed.""""""\n    return display(*args, **kwargs, blocking=True)\n\n\ndef read_updates(*args, **kwargs):\n    """"""Read back all frame updates and yield a list of frames. List is empty if no frames were read.""""""\n    return display(*args, **kwargs, silent=True)\n'"
displayarray/window/window_commands.py,0,"b'""""""Commands to control the array displaying windows.""""""\n\nfrom localpubsub import VariablePub, VariableSub\n\nkey_pub = VariablePub()\nmouse_pub = VariablePub()\nwin_cmd_pub = VariablePub()\n\n\ndef quit(force_all_read=True):\n    """"""Quit the main loop displaying all the windows.""""""\n    win_cmd_pub.publish(""quit"", force_all_read=force_all_read)\n\n\ndef win_cmd_sub() -> VariableSub:\n    """"""Get a subscriber to the main window loop.""""""\n    return win_cmd_pub.make_sub()\n'"
docs/docsrc/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(f""..{os.sep}..""))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = ""DisplayArray""\ncopyright = ""2019, Simulator Leek""\nauthor = ""Simulator Leek""\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [""sphinx.ext.todo"", ""sphinx.ext.viewcode"", ""sphinx.ext.autodoc""]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\nadd_module_names = False\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = ""alabaster""\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\n'"
examples/callbacks/black_and_white.py,1,"b'from displayarray import display\nimport numpy as np\n\n\ndef black_and_white(arr):\n    return (np.sum(arr, axis=-1) / 3).astype(np.uint8)\n\n\nimport time\n\nt0 = t1 = time.time()\nfor up in display(0, size=(1, 1), callbacks=black_and_white):\n    if up:\n        t1 = time.time()\n        print(1.0 / (t1 - t0))\n        t0 = t1\n'"
examples/callbacks/psychadelic_effect.py,0,"b'from displayarray import display\nimport math as m\nfrom examples.videos import test_video\n\n\ndef forest_color(arr):\n    forest_color.i += 1\n    arr[..., 0] = (\n        m.sin(forest_color.i * (2 * m.pi) * 0.4 / 360) * 255 + arr[..., 0]\n    ) % 255\n    arr[..., 1] = (\n        m.sin((forest_color.i * (2 * m.pi) * 0.5 + 45) / 360) * 255 + arr[..., 1]\n    ) % 255\n    arr[..., 2] = (\n        m.cos(forest_color.i * (2 * m.pi) * 0.3 / 360) * 255 + arr[..., 2]\n    ) % 255\n\n\nforest_color.i = 0\n\ndisplay(test_video, callbacks=forest_color, blocking=True, fps_limit=120)\n'"
examples/callbacks/random_display.py,2,"b'from displayarray import display\nimport numpy as np\n\narr = np.random.normal(0.5, 0.1, (500, 500, 3))\n\n\ndef fix_arr_cv(arr_in):\n    arr_in[:] += np.random.normal(0.01, 0.005, (500, 500, 3))\n    arr_in %= 1.0\n\n\ndisplay(arr, callbacks=fix_arr_cv, blocking=True)\n'"
examples/debugging/breakpoint_display.py,16,"b'from displayarray import breakpoint_display\nimport numpy as np\n\ncenter = (75, 450)\nzoom = 0.5\nzoom_out = 1.0 / zoom\n\narr = np.random.uniform(0, 1, (300, 600, 3))\nbreakpoint_display(arr)\n\ny = np.arange(arr.shape[0])\nx = np.arange(arr.shape[1])\ny_ = (y - center[0]) * zoom_out / arr.shape[0]\nx_ = (x - center[1]) * zoom_out / arr.shape[1]\np = np.array(np.meshgrid(x_, y_))\nbreakpoint_display(p[0] + 0.5)\nbreakpoint_display(p[1] + 0.5)\n\nbarrel_power = 1.5\n\ntheta = np.arctan2(p[1], p[0])\nbreakpoint_display((theta + (np.pi / 2.0)) / (np.pi / 2.0))\n\nradius = np.linalg.norm(p, axis=0)\nprint(radius.shape)\nbreakpoint_display(radius)\n\nradius = pow(radius, barrel_power)\nbreakpoint_display(radius)\n\nprint(len(x))\nx_new = 0.5 * (radius * np.cos(theta) + 1)\nbreakpoint_display(x_new)\nx_new = np.clip(x_new * len(x), 0, len(x) - 1)\nbreakpoint_display(x_new / float(len(x)))\n\ny_new = 0.5 * (radius * np.sin(theta) + 1)\nbreakpoint_display(y_new)\ny_new = np.clip(y_new * len(y), 0, len(y) - 1)\n\np = np.array(np.meshgrid(y, x)).astype(np.uint32)\n\np_new = np.array((y_new, x_new)).astype(np.uint32)\n\nbrr = arr.copy()\nbrr[p[0], p[1], :] = np.swapaxes(arr[p_new[0], p_new[1], :], 0, 1)\nbreakpoint_display(brr)\n\ncrr = np.zeros_like(arr)\ncrr[p_new[0], p_new[1], :] = np.swapaxes(arr[p[0], p[1], :], 0, 1)\nbreakpoint_display(crr)\n'"
examples/debugging/random_display.py,1,"b'from displayarray import display\nimport numpy as np\n\ndisplay(np.random.normal(0.5, 0.1, (500, 500, 3))).block()\n'"
examples/documentation/fractal.py,5,"b'import numpy as np\nfrom displayarray import display\n\n\ndef mandel(\n    height=240, width=320, itermax=255, y_min=-1.8, y_max=0.6, x_min=-1.6, x_max=1.6\n):\n    """"""\n    Generate a view of the mandlebrot fractal\n\n    source: https://thesamovar.wordpress.com/2009/03/22/fast-fractals-with-python-and-numpy/\n\n    .. code-block:: python\n\n      >>> img = mandel()\n      >>> center = (0, -1.78)\n      >>> length = 3.2\n      >>> d = display(img)\n      >>> while d:\n      ...   length*=.9\n      ...   y_min = center[1]-length/2.0\n      ...   y_max = center[1]+length/2.0\n      ...   x_min = center[0]-length/2.0\n      ...   x_max = center[0]+length/2.0\n      ...   img[...] = mandel(y_min=y_min, y_max=y_max, x_min=x_min, x_max=x_max)\n    """"""\n\n    ix, iy = np.mgrid[0:height, 0:width]\n    x = np.linspace(y_min, y_max, height)[ix]\n    y = np.linspace(x_min, x_max, width)[iy]\n    c = x + complex(0, 1) * y\n    del x, y\n    img = np.zeros_like(c, dtype=int)\n    c.shape = iy.shape = ix.shape = height * width\n    z = np.copy(c)\n    for i in range(itermax):\n        if not len(z):\n            break\n        z = z * z\n        z = z + c\n        rem = abs(z) > 4.0\n        img[ix[rem], iy[rem]] = i + 1\n        rem = ~rem\n        z = z[rem]\n        ix, iy = ix[rem], iy[rem]\n        c = c[rem]\n    return img / 255.0\n\n\nif __name__ == ""__main__"":\n    img = mandel()\n    center = (0, -0.6)\n    length = 3.2\n    d = display(img)\n    while d:\n        length *= 0.9\n        y_min = center[1] - length / 2.0\n        y_max = center[1] + length / 2.0\n        x_min = center[0] - length / 2.0\n        x_max = center[0] + length / 2.0\n        img[...] = mandel(y_min=y_min, y_max=y_max, x_min=x_min, x_max=x_max)\n'"
examples/effects/crop.py,0,b'from displayarray.effects import crop\nfrom displayarray import display\nfrom examples.videos import test_video\n\n# Move the mouse to move where the crop is from on the original image\n\ndisplay(test_video).add_callback(crop.Crop().enable_mouse_control()).block()\n'
examples/effects/lens_crop.py,0,"b'from displayarray.effects import crop, lens\nfrom displayarray import display\nfrom examples.videos import test_video\n\n# Move the mouse to center the image, scroll to increase/decrease barrel, ctrl+scroll to increase/decrease zoom\n\nd = (\n    display(test_video)\n    .add_callback(lens.BarrelPyTorch().enable_mouse_control(crop_size=(256, 256)))\n    .add_callback(crop.Crop(output_size=(256, 256, 3)))\n    .wait_for_init()\n)\n\nwhile d:\n    if len(d.frames) > 0:\n        pass\n'"
examples/effects/lens_crop_blocking.py,0,"b'from displayarray.effects import crop, lens\nfrom displayarray import display\nfrom examples.videos import test_video\n\n# Move the mouse to move where the crop is from on the original image\n\ndisplay(test_video).add_callback(crop.Crop()).add_callback(\n    lens.Barrel().enable_mouse_control()\n).block()\n'"
examples/effects/manual_control.py,0,"b'from displayarray.effects import crop, lens\nfrom displayarray import display\nfrom examples.videos import test_video\nimport math as m\n\n# Move the mouse to center the image, scroll to increase/decrease barrel, ctrl+scroll to increase/decrease zoom\n\npre_crop_callback = crop.Crop(output_size=(480, 640, 3)).enable_mouse_control()\nlens_callback = lens.BarrelPyTorch()\npost_crop_callback = crop.Crop(output_size=(256, 256, 3)).enable_mouse_control()\n\nd = (\n    display(0, size=(99999, 99999))\n    .add_callback(pre_crop_callback)\n    .add_callback(lens_callback)\n    .add_callback(post_crop_callback)\n    .wait_for_init()\n)\n\ni = 0\nwhile d:\n    if len(d.frames) > 0:\n        i += 1\n        frame = d.frames[0]\n        center_sin = [(m.sin(m.pi * (i / 70.0))), (m.cos(m.pi * (i / 120.0)))]\n        pre_crop_callback.center = [\n            center_sin[0] * 720 / 2 + 720 / 2,\n            center_sin[1] * 1280 / 2 + 1280 / 2,\n        ]\n        lens_callback.center = [\n            center_sin[0] * 480 / 2 + 480 / 2,\n            center_sin[1] * 640 / 2 + 640 / 2,\n        ]\n        post_crop_callback.center = [480 / 2, 640 / 2]\n        lens_callback.zoom = m.sin(m.pi * ((i + 25) / 50.0)) + 1.01\n        lens_callback.barrel_power = m.sin((m.pi * (i + 33) / 25)) + 1.5\n'"
examples/effects/select_channels.py,1,"b'from displayarray.effects import crop\nfrom displayarray import display\nimport numpy as np\n\n# Scroll the mouse wheel and press ctrl, alt, or shift to select which channels are displayed as red, green, or blue.\narr = np.ones((250, 250, 250))\nfor x in range(250):\n    arr[..., x] = x / 250.0\ndisplay(arr).block()\n'"
examples/looping/no_display.py,0,"b'from displayarray import read_updates, display\nimport time\nimport cProfile\nfrom examples.videos import test_video\n\n\ndef profile_reading(total_seconds=5):\n    t_init = t01 = time.time()\n    times = []\n    started = False\n    for up in display(0, size=(1, 1)):\n        if up:\n            t1 = time.time()\n            if started:\n                times.append((t1 - t01) * 1000)\n            t01 = t1\n            started = True\n        if started:\n            t2 = time.time()\n            if t2 - t_init >= total_seconds:\n                if times:\n                    print(f""Average framerate: {1000 / (sum(times) / len(times))}fps"")\n                else:\n                    print(""failure"")\n                break\n        else:\n            t_init = time.time()\n\n\ncProfile.run(""profile_reading()"")\n'"
examples/looping/no_display_simple.py,0,"b'from displayarray import read_updates\n\nfor f in read_updates(0, size=(1, 1)):\n    if f:\n        print(f[0].shape)\n        break\n'"
examples/looping/one_cam_two_codes.py,0,"b'from displayarray import read_updates\n\nwith read_updates(0) as a, read_updates(0) as b:\n    for i in range(1000):\n        a.update()\n        b.update()\n        try:\n            print(a.frames == b.frames)\n        except ValueError:\n            print(f""frame comparison: {(a.frames[\'0\'][0] == b.frames[\'0\'][0]).all()}"")\n'"
examples/looping/random_display.py,2,"b'from displayarray import display\nimport numpy as np\n\narr = np.random.normal(0.5, 0.1, (100, 100, 5))\n\nwith display(arr) as displayer:\n    while displayer:\n        arr[:] += np.random.normal(0.001, 0.0005, (100, 100, 5))\n        arr %= 1.0\n'"
examples/tensorflow/denoising_autoencoder.py,6,"b'from displayarray import display\nimport numpy as np\nfrom tensorflow.keras import layers, models\nimport tensorflow as tf\nfrom examples.videos import test_video_2\n\nfor gpu in tf.config.experimental.list_physical_devices(""GPU""):\n    tf.compat.v2.config.experimental.set_memory_growth(gpu, True)\n\ndisplayer = display(test_video_2)\ndisplayer.wait_for_init()\nautoencoder = models.Sequential()\nautoencoder.add(\n    layers.Conv2D(\n        20, (3, 3), activation=""sigmoid"", input_shape=displayer.frames[0].shape\n    )\n)\nautoencoder.add(\n    layers.Conv2D(\n        20, (3, 3), activation=""sigmoid"", input_shape=displayer.frames[0].shape\n    )\n)\nautoencoder.add(layers.Conv2DTranspose(3, (3, 3), activation=""sigmoid""))\nautoencoder.add(layers.Conv2DTranspose(3, (3, 3), activation=""sigmoid""))\n\nautoencoder.compile(loss=""mse"", optimizer=""adam"")\n\nwhile displayer:\n    displayer.update()\n    grab = tf.convert_to_tensor(\n        next(iter(displayer.FRAME_DICT.values()))[np.newaxis, ...].astype(np.float32)\n        / 255.0\n    )\n    grab_noise = tf.convert_to_tensor(\n        (\n            (\n                next(iter(displayer.FRAME_DICT.values()))[np.newaxis, ...].astype(\n                    np.float32\n                )\n                + np.random.uniform(0, 255, grab.shape)\n            )\n            / 2\n        )\n        / 255.0\n    )\n    displayer.update(\n        (grab_noise.numpy()[0] * 255.0).astype(np.uint8), ""uid for grab noise""\n    )\n    autoencoder.fit(grab_noise, grab, steps_per_epoch=1, epochs=1)\n    output_image = autoencoder.predict(grab, steps=1)\n    displayer.update(\n        (output_image[0] * 255.0).astype(np.uint8), ""uid for autoencoder output""\n    )\n\n    get_3rd_layer_output = tf.keras.backend.function(\n        [autoencoder.layers[0].input], [autoencoder.layers[1].output]\n    )\n    layer_output = get_3rd_layer_output([grab_noise])[0]\n\n    displayer.update(layer_output[0], ""conv 1"")\n'"
examples/videos/__init__.py,0,"b'# Fractal test is from: https://www.youtube.com/watch?v=WgXQ59rg0GM\n\nfrom pathlib import Path\n\ntest_video = str(Path.joinpath(Path(__file__).parent, ""fractal test.mp4""))\ntest_video_2 = str(Path.joinpath(Path(__file__).parent, ""fractal test 2.mp4""))\ntest_video_3 = str(Path.joinpath(Path(__file__).parent, ""fractal test 3.mp4""))\n\nurls = {\n    ""test_video"": ""https://www.youtube.com/watch?v=LpWhaBVIrZw"",\n    ""test_video_2"": ""https://www.youtube.com/watch?v=GASynpGr-c8"",\n    ""test_video_3"": ""https://www.youtube.com/watch?v=u_P83LcI8Oc""\n}\n\n\ndef populate_videos(fps=60, res=""720p"", ext=""mp4""):\n    from pytube import YouTube  # Note: pip install pytube3, not pytube\n    from pathlib import Path\n    for n, v in globals().items():\n        if \'test_video\' in n:\n            print(f""Checking if \'{n}\' is downloaded."")\n            if Path(v).exists():\n                print(""Video already downloaded."")\n            else:\n                the_path = Path(v)\n                print(""Downloading..."")\n                YouTube(urls[n]) \\\n                    .streams \\\n                    .filter(fps=fps, res=res, file_extension=ext)[0] \\\n                    .download(output_path=the_path.parent, filename=the_path.stem)\n\n\nif __name__ == ""__main__"":\n    populate_videos()\n'"
tests/effects/__init__.py,0,b''
tests/effects/test_crop.py,25,"b'import displayarray.effects.crop as crop\nimport numpy as np\nfrom displayarray.input import mouse_loop\nimport mock\n\n\ndef test_init_defaults():\n    c = crop.Crop()\n\n    assert np.all(c.output_size == (64, 64, 3))\n    assert all(c.center == [32, 32, 1])\n    assert c.odd_center is None\n    assert c.input_size is None\n\n\ndef test_init():\n    c = crop.Crop((32, 32, 3), (16, 16, 1))\n\n    c(np.ndarray((64, 64, 3)))\n\n    assert np.all(c.output_size == (32, 32, 3))\n    assert np.all(c.center == (16, 16, 1))\n    assert np.all(c.odd_center == [0, 0, 1])\n    assert c.input_size == (64, 64, 3)\n\n\ndef test_1d_crop():\n    c = crop.Crop((4,))\n\n    cropped = c(np.ones((8,)))\n\n    assert np.all(cropped == np.ones((4,)))\n\n\ndef test_1d_edges():\n    c = crop.Crop((4,), (0,))\n\n    cropped = c(np.ones((8,)))\n\n    assert np.all(cropped == np.concatenate((np.ones((2,)), np.zeros((2,)))))\n    c.center[...] = [8]\n    cropped = c(np.ones((8,)))\n\n    assert np.all(cropped == np.concatenate((np.zeros((2,)), np.ones((2,)))))\n\n\ndef test_2d_crop():\n    c = crop.Crop((4, 5))\n\n    cropped = c(np.ones((8, 8)))\n\n    assert np.all(cropped == np.ones((4, 5)))\n\n\ndef test_2d_edges():\n    c = crop.Crop((4, 5), (0, 4))\n\n    cropped = c(np.ones((8, 8)))\n\n    assert np.all(\n        cropped\n        == np.array(\n            [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\n        )\n    )\n    c.center = [4, 0]\n    cropped = c(np.ones((8, 8)))\n\n    assert np.all(\n        cropped\n        == np.array(\n            [[1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [1, 1, 1, 0, 0], [1, 1, 1, 0, 0]]\n        )\n    )\n\n    c.center = [8, 8]\n    cropped = c(np.ones((8, 8)))\n\n    assert np.all(\n        cropped\n        == np.array(\n            [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]\n        )\n    )\n\n    c.center = [4, 8]\n    cropped = c(np.ones((8, 8)))\n\n    assert np.all(\n        cropped\n        == np.array(\n            [[0, 0, 0, 1, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]\n        )\n    )\n\n\ndef test_enable_mouse_control():\n    with mock.patch.object(crop, ""mouse_loop"") as m_loop:\n        decorate = m_loop.return_value = mock.MagicMock()\n        c = crop.Crop()\n        assert c.mouse_control == None\n\n        c.enable_mouse_control()\n        m_loop.assert_called_once()\n\n        assert c.mouse_control == decorate\n'"
tests/frame/__init__.py,0,b''
tests/frame/test_frame_publishing.py,4,"b'from displayarray.frame.frame_publishing import pub_cam_loop_opencv, pub_cam_thread\nimport displayarray\nimport mock\nimport pytest\nimport cv2\nfrom displayarray.frame.np_to_opencv import NpCam\nimport numpy as np\nimport displayarray.frame.subscriber_dictionary as subd\nimport displayarray.frame.frame_publishing as fpub\n\n\ndef test_pub_cam_loop_exit():\n    not_a_camera = mock.MagicMock()\n    with pytest.raises(TypeError):\n        pub_cam_loop_opencv(not_a_camera)\n\n\ndef test_pub_cam_int():\n    img = np.zeros((30, 40))\n    with mock.patch.object(\n        cv2, ""VideoCapture"", new_callable=mock.MagicMock\n    ) as mock_cv_capture, mock.patch.object(NpCam, ""set""), mock.patch.object(\n        NpCam, ""get""\n    ) as mock_get, mock.patch.object(\n        NpCam, ""release""\n    ), mock.patch.object(\n        displayarray.frame.frame_publishing.subscriber_dictionary, ""register_cam""\n    ) as reg_cam, mock.patch.object(\n        displayarray.frame.frame_publishing.subscriber_dictionary, ""cam_cmd_sub""\n    ) as cam_cmd_sub:\n        cap = NpCam(img)\n        mock_cv_capture.return_value = cap\n        mock_sub = cam_cmd_sub.return_value = mock.MagicMock()\n        mock_sub.get = mock.MagicMock()\n        mock_sub.get.side_effect = ["""", """", """", ""quit""]\n        mock_sub.release = mock.MagicMock()\n        mock_get.return_value = 2\n\n        cam_0 = subd.CV_CAMS_DICT[""0""] = subd.Cam(""0"")\n        with mock.patch.object(cam_0.frame_pub, ""publish"") as cam_pub:\n            pub_cam_loop_opencv(0, high_speed=False)\n\n            cam_pub.assert_has_calls([mock.call(img)] * 4)\n\n            reg_cam.assert_called_once_with(""0"")\n            cam_cmd_sub.assert_called_once_with(""0"")\n\n            cap.set.assert_has_calls(\n                [\n                    mock.call(cv2.CAP_PROP_FRAME_WIDTH, -1),\n                    mock.call(cv2.CAP_PROP_FRAME_HEIGHT, -1),\n                ]\n            )\n            cap.get.assert_has_calls([mock.call(cv2.CAP_PROP_FRAME_COUNT)] * 8)\n            mock_sub.get.assert_has_calls(\n                [mock.call(), mock.call(), mock.call(), mock.call()]\n            )\n            mock_sub.release.assert_called_once()\n            cap.release.assert_called_once()\n\n        subd.CV_CAMS_DICT = {}\n\n\ndef test_pub_cam_fail():\n    img = np.zeros((30, 40))\n    with mock.patch.object(\n        cv2, ""VideoCapture"", new_callable=mock.MagicMock\n    ) as mock_cv_capture, mock.patch.object(\n        NpCam, ""isOpened""\n    ) as mock_is_open, mock.patch.object(\n        subd, ""register_cam""\n    ) as mock_reg:\n        cap = NpCam(img)\n        mock_cv_capture.side_effect = [cap]\n\n        mock_is_open.return_value = False\n        subd.CV_CAMS_DICT[""0""] = subd.Cam(""0"")\n\n        with mock.patch.object(\n            subd.CV_CAMS_DICT[""0""].status_pub, ""publish""\n        ) as mock_fail_pub:\n            pub_cam_loop_opencv(0, high_speed=False)\n\n            mock_fail_pub.assert_called_once_with(""failed"")\n\n        subd.CV_CAMS_DICT = {}\n\n\ndef test_pub_cam_high_speed():\n    img = np.zeros((30, 40))\n    with mock.patch.object(\n        cv2, ""VideoCapture"", new_callable=mock.MagicMock\n    ) as mock_cv_capture, mock.patch.object(\n        NpCam, ""isOpened""\n    ) as mock_is_open, mock.patch.object(\n        NpCam, ""set""\n    ) as mock_cam_set:\n        cap = NpCam(img)\n        mock_cv_capture.side_effect = [cap]\n\n        mock_is_open.return_value = False\n\n        pub_cam_loop_opencv(0, request_size=(640, 480), high_speed=True)\n\n        mock_cam_set.assert_has_calls(\n            [\n                mock.call(cv2.CAP_PROP_FOURCC, cv2.CAP_OPENCV_MJPEG),\n                mock.call(cv2.CAP_PROP_FRAME_WIDTH, 640),\n                mock.call(cv2.CAP_PROP_FRAME_HEIGHT, 480),\n            ]\n        )\n\n\ndef test_pub_cam_numpy():\n    with mock.patch(\n        ""displayarray.frame.frame_publishing.uid_for_source"",\n        new_callable=mock.MagicMock,\n    ) as mock_uidfs, mock.patch.object(\n        NpCam, ""read""\n    ) as mock_np_read, mock.patch.object(\n        subd, ""register_cam""\n    ):\n        img = np.zeros((30, 40))\n        mock_np_read.side_effect = [\n            (True, img),\n            (True, img),\n            (True, img),\n            (False, None),\n        ]\n        mock_uidfs.return_value = ""0""\n        cam_0 = subd.CV_CAMS_DICT[""0""] = subd.Cam(""0"")\n        with mock.patch.object(cam_0.frame_pub, ""publish"") as cam_pub:\n            pub_cam_loop_opencv(img)\n            cam_pub.assert_has_calls([mock.call(img)] * 3)\n        subd.CV_CAMS_DICT = {}\n\n\ndef test_pub_cam_thread():\n    with mock.patch(\n        ""displayarray.frame.frame_publishing.threading.Thread"",\n        new_callable=mock.MagicMock,\n    ) as mock_thread:\n        thread_instance = mock_thread.return_value = mock.MagicMock()\n\n        pub_cam_thread(5)\n\n        mock_thread.assert_called_once_with(\n            target=fpub.pub_cam_loop_opencv, args=(5, (-1, -1), True, float(""inf""))\n        )\n        thread_instance.start.assert_called_once()\n'"
tests/frame/test_frame_updater.py,4,"b'import displayarray.frame.frame_updater as fup\nimport numpy as np\nimport mock\nimport pytest\nimport itertools\nfrom displayarray.effects.select_channels import SelectChannels\n\n\ndef test_init_defaults():\n    ud = fup.FrameUpdater()\n\n    assert ud.video_source == 0\n    assert ud.cam_id == ""0""\n    assert ud.callbacks == []\n    assert ud.request_size == (-1, -1)\n    assert ud.high_speed == True\n    assert ud.fps_limit == float(""inf"")\n\n\ndef test_init():\n    cb = lambda x: np.zeros((1, 1))\n    ud = fup.FrameUpdater(""test"", cb, (2, 2), False, 30)\n\n    assert ud.video_source == ""test""\n    assert ud.cam_id == ""test""\n    assert ud.callbacks == [cb]\n    assert ud.request_size == (2, 2)\n    assert ud.high_speed == False\n    assert ud.fps_limit == 30\n\n\ndef test_loop():\n    with mock.patch(\n        ""displayarray.frame.frame_updater.pub_cam_thread""\n    ) as mock_pubcam_thread, mock.patch(\n        ""displayarray.frame.frame_updater.subscriber_dictionary.CV_CAMS_DICT""\n    ) as mock_cam_dict, mock.patch(\n        ""displayarray.frame.frame_updater.subscriber_dictionary.cam_frame_sub""\n    ) as mock_frame_sub, mock.patch(\n        ""displayarray.frame.frame_updater.subscriber_dictionary.handler_cmd_sub""\n    ) as handler_cmd_sub, mock.patch(\n        ""displayarray.frame.frame_updater.global_cv_display_callback""\n    ) as mock_global_cb:\n        mock_cbs = [mock.MagicMock(), mock.MagicMock()]\n        ud = fup.FrameUpdater(0, callbacks=mock_cbs)\n\n        pub_t = mock_pubcam_thread.return_value = mock.MagicMock()\n        mock_cam_dict.__contains__.side_effect = itertools.cycle([False, False, True])\n        sub_cam = mock_frame_sub.return_value = mock.MagicMock()\n        frame = sub_cam.get.return_value = mock.MagicMock()\n        transformed_frame = mock.MagicMock()\n        mock_cbs[0].return_value = transformed_frame\n        mock_cbs[1].return_value = transformed_frame\n        transformed_frame.shape = [1, 2, 3]\n        mock_sub_owner = handler_cmd_sub.return_value = mock.MagicMock()\n        mock_sub_owner.get.side_effect = ["""", """", """", ""quit""]\n\n        ud.loop()\n\n        mock_pubcam_thread.assert_called_once_with(0, (-1, -1), True, float(""inf""))\n        mock_frame_sub.assert_called_once_with(""0"")\n        handler_cmd_sub.assert_called_once_with(""0"")\n        sub_cam.get.assert_has_calls([mock.call(blocking=True, timeout=1.0)] * 3)\n        mock_cbs[0].assert_has_calls([mock.call(frame)] * 4)\n        mock_cbs[1].assert_has_calls([mock.call(transformed_frame)] * 4)\n        mock_global_cb.assert_has_calls([mock.call(transformed_frame, ""0"")] * 4)\n        mock_sub_owner.release.assert_called_once()\n        sub_cam.release.assert_called_once()\n        pub_t.join.assert_called_once()\n\n\ndef test_callback_exception():\n    def redden_frame_print_spam(frame):\n        frame[:, :, 0] = 0\n        frame[:, :, 2] = 1 / 0\n\n    with pytest.raises(ZeroDivisionError) as e:\n        v = fup.FrameUpdater(np.zeros((1, 2, 3)), callbacks=redden_frame_print_spam)\n        v.loop()\n    assert e.errisinstance(ZeroDivisionError)\n\n\ndef test_display():\n    with mock.patch(\n        ""displayarray.window.SubscriberWindows"", new_callable=mock.MagicMock\n    ) as mock_sub_win:\n        f = fup.FrameUpdater()\n        with mock.patch.object(f, ""start""), mock.patch.object(f, ""join""):\n            mock_sub_win_instance = mock_sub_win.return_value = mock.MagicMock()\n\n            f.display()\n\n            mock_sub_win.assert_called_once_with(video_sources=[""0""], callbacks=[])\n            mock_sub_win_instance.loop.assert_called_once()\n\n\ndef test_display_exception():\n    with mock.patch(\n        ""displayarray.window.SubscriberWindows"", new_callable=mock.MagicMock\n    ) as mock_sub_win:\n\n        def redden_frame_print_spam(frame):\n            frame[:, :, 0] = 0\n            frame[:, :, 2] = 1 / 0\n\n        with pytest.raises(ZeroDivisionError) as e:\n            v = fup.FrameUpdater(np.zeros((1, 1, 3)), callbacks=redden_frame_print_spam)\n            v.display()\n        assert e.errisinstance(ZeroDivisionError)\n        # todo: clear the frame dict so that these don\'t hang forever\n\n\nfrom displayarray.window.window_commands import win_cmd_pub\n\n\ndef test_display_many_channels():\n    with mock.patch(\n        ""displayarray.frame.frame_updater.pub_cam_thread""\n    ), mock.patch.object(\n        fup.subscriber_dictionary, ""CV_CAMS_DICT""\n    ) as mock_cam_dict, mock.patch.object(\n        fup.subscriber_dictionary, ""cam_frame_sub""\n    ) as mock_sub_cam, mock.patch(\n        ""displayarray.frame.frame_updater.subscriber_dictionary.handler_cmd_sub""\n    ) as handler_cmd_sub:\n        mock_cam_dict.__contains__.side_effect = itertools.cycle([False, False, True])\n        mock_sub_owner = handler_cmd_sub.return_value = mock.MagicMock()\n        mock_sub_owner.get.side_effect = ["""", """", """", ""quit""]\n\n        arr = np.ones((20, 20, 20))\n        sub = mock.MagicMock()\n        sub.get.return_value = arr\n        mock_sub_cam.return_value = sub\n\n        f = fup.FrameUpdater(arr)\n\n        f.loop()\n\n        assert isinstance(f.callbacks[0], SelectChannels)\n        win_cmd_pub.publish(""quit"")\n'"
tests/frame/test_get_frame_ids.py,0,"b'import displayarray.frame.get_frame_ids as gfi\nimport mock\nimport cv2\n\n\ndef test_get_cam_ids():\n    with mock.patch.object(\n        cv2, ""VideoCapture"", new_callable=mock.MagicMock\n    ) as mock_cv_capture:\n        cap = mock.MagicMock()\n        cap.isOpened.return_value = True\n        cap_end = mock.MagicMock()\n        cap_end.isOpened.return_value = False\n        mock_cv_capture.side_effect = [cap, cap, cap, cap_end]\n        ids = gfi.get_cam_ids()\n        assert ids == [0, 1, 2]\n'"
tests/frame/test_np_to_cv.py,8,"b'import displayarray.frame.np_to_opencv as npcv\nimport numpy as np\nimport pytest\nimport cv2\n\n\ndef test_init():\n    npcv.NpCam(np.zeros((10, 10)))\n\n    with pytest.raises(AssertionError):\n        npcv.NpCam(""Not a numpy array"")\n\n\ndef test_open():\n    cam = npcv.NpCam(np.zeros((10, 10)))\n    assert cam.isOpened() is True\n    cam.release()\n    assert cam.isOpened() is False\n\n\ndef test_read():\n    cam = npcv.NpCam(np.zeros((10, 10)))\n    succeeded, img = cam.read()\n    assert succeeded is True\n    assert img.shape == np.zeros((10, 10)).shape\n\n\ndef test_set():\n    cam = npcv.NpCam(np.zeros((10, 10)))\n    cam.set(cv2.CAP_PROP_FRAME_WIDTH, 20)\n    succeeded, img = cam.read()\n    assert succeeded is True\n    assert img.shape == np.zeros((10, 10)).shape\n    cam.set(cv2.CAP_PROP_FRAME_HEIGHT, 30)\n    succeeded, img = cam.read()\n    assert succeeded is True\n    assert img.shape == np.zeros((30, 20)).shape\n\n\ndef test_get():\n    cam = npcv.NpCam(np.zeros((10, 10)))\n    assert cam.get(cv2.CAP_PROP_FRAME_COUNT) == float(""inf"")\n'"
tests/frame/test_subscriber_dictionary.py,0,"b'import displayarray.frame.subscriber_dictionary as subd\nfrom localpubsub import VariablePub, VariableSub\nimport mock\n\n\ndef test_cam_handler():\n    my_pub = VariablePub()\n    my_sub = VariableSub(my_pub)\n    camh = subd.CamHandler(""my name"", my_sub)\n\n    assert camh.name == ""my name""\n    assert camh.cmd is None\n    assert camh.sub == my_sub\n    assert isinstance(camh.pub, VariablePub)\n    assert isinstance(camh.cmd_pub, VariablePub)\n\n\ndef test_cam():\n    cam = subd.Cam(""my name"")\n\n    assert cam.name == ""my name""\n    assert cam.cmd is None\n    assert isinstance(cam.frame_pub, VariablePub)\n    assert isinstance(cam.cmd_pub, VariablePub)\n    assert isinstance(cam.status_pub, VariablePub)\n\n\ndef test_register_cam():\n    subd.register_cam(""test name"")\n    assert isinstance(subd.CV_CAMS_DICT[""test name""], subd.Cam)\n    assert subd.CV_CAMS_DICT[""test name""].name == ""test name""\n    assert isinstance(subd.CV_CAM_HANDLERS_DICT[""test name""], subd.CamHandler)\n    assert subd.CV_CAM_HANDLERS_DICT[""test name""].name == ""test name""\n\n\ndef test_stop_cam():\n    subd.register_cam(""test name 2"")\n    cam_publish = subd.CV_CAMS_DICT[""test name 2""].cmd_pub.publish = mock.MagicMock()\n    cam_handler_publish = subd.CV_CAM_HANDLERS_DICT[\n        ""test name 2""\n    ].cmd_pub.publish = mock.MagicMock()\n\n    subd.stop_cam(""test name 2"")\n\n    cam_publish.assert_called_once_with(""quit"", blocking=True)\n    cam_handler_publish.assert_called_once_with(""quit"", blocking=True)\n\n\ndef test_cam_cmd_sub():\n    subd.register_cam(""test name 2"")\n\n    sub = subd.cam_cmd_sub(""test name 2"", blocking=False)\n\n    assert isinstance(sub, VariableSub)\n    assert sub.pub == subd.CV_CAMS_DICT[""test name 2""].cmd_pub\n\n\ndef test_cam_frame_sub():\n    subd.register_cam(""test name 2"")\n\n    sub = subd.cam_frame_sub(""test name 2"", blocking=False)\n\n    assert isinstance(sub, VariableSub)\n    assert sub.pub == subd.CV_CAMS_DICT[""test name 2""].frame_pub\n\n\ndef test_handler_cmd_sub():\n    subd.register_cam(""test name 2"")\n\n    sub = subd.handler_cmd_sub(""test name 2"", blocking=False)\n\n    assert isinstance(sub, VariableSub)\n    assert sub.pub == subd.CV_CAM_HANDLERS_DICT[""test name 2""].cmd_pub\n'"
tests/window/__init__.py,0,b''
tests/window/test_subscriber_windows.py,29,"b'import displayarray.window.subscriber_windows as sub_win\nfrom threading import Thread\nimport mock\nimport cv2\nimport numpy as np\nfrom displayarray.effects.select_channels import SelectChannels\nimport pytest\n\n\ndef test_init_defaults():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow"") as window_mock:\n        sw = sub_win.SubscriberWindows()\n\n        assert sw.source_names == [""0""]\n        assert sw.input_vid_global_names == [""0""]\n        assert sw.window_names == [""displayarray""]\n        assert sw.input_cams == [0]\n        assert sw.exited == False\n\n        window_mock.assert_called_once_with(""displayarray (press ESC to quit)"")\n\n\ndef test_init():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow"") as window_mock:\n        cb = mock.MagicMock()\n        sw = sub_win.SubscriberWindows([""test name""], [1], cb)\n\n        assert sw.source_names == [""1""]\n        assert sw.input_vid_global_names == [""1""]\n        assert sw.window_names == [""test name""]\n        assert sw.input_cams == [1]\n        assert sw.exited == False\n\n        window_mock.assert_called_once_with(""test name (press ESC to quit)"")\n\n\ndef test_bool():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""update""\n    ) as mock_update:\n        sw = sub_win.SubscriberWindows()\n\n        mock_update.assert_called_once()\n        mock_update.reset_mock()\n\n        assert bool(sw) == True\n\n        mock_update.assert_called_once()\n        mock_update.reset_mock()\n\n        sw.exited = True\n\n        assert bool(sw) == False\n\n\ndef test_block():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""update""\n    ), mock.patch.object(sub_win.SubscriberWindows, ""loop"") as mock_loop:\n        sw = sub_win.SubscriberWindows()\n        sw.close_threads.append(mock.MagicMock())\n\n        sw.block()\n\n        mock_loop.assert_called_once()\n        sw.close_threads[0].join.assert_called_once()\n\n\ndef test_add_source():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""):\n        sw = sub_win.SubscriberWindows().add_source(2)\n\n        assert sw.source_names == [""0"", ""2""]\n        assert sw.input_vid_global_names == [""0"", ""2""]\n        assert sw.input_cams == [0, 2]\n\n\ndef test_add_window():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow"") as mock_named_window, mock.patch.object(\n        cv2, ""setMouseCallback""\n    ) as mock_set_mouse, mock.patch(\n        ""displayarray.window.subscriber_windows.WeakMethod"", new_callable=mock.MagicMock\n    ) as mock_weak:\n        weak_method = mock_weak.return_value = mock.MagicMock()\n\n        sw = sub_win.SubscriberWindows().add_window(""second window"")\n\n        mock_weak.assert_has_calls(\n            [mock.call(sw.handle_mouse), mock.call(sw.handle_mouse)]\n        )\n        assert sw.window_names == [""displayarray"", ""second window""]\n        mock_named_window.assert_has_calls(\n            [\n                mock.call(""displayarray (press ESC to quit)""),\n                mock.call(""second window (press ESC to quit)""),\n            ]\n        )\n        mock_set_mouse.assert_has_calls(\n            [\n                mock.call(""displayarray (press ESC to quit)"", weak_method),\n                mock.call(""second window (press ESC to quit)"", weak_method),\n            ]\n        )\n\n\ndef test_add_callback():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""):\n        mock_cb = mock.MagicMock()\n\n        sw = sub_win.SubscriberWindows().add_callback(mock_cb)\n\n        assert sw.callbacks[0] == mock_cb\n\n\ndef test_handle_keys():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch(\n        ""displayarray.window.subscriber_windows.subscriber_dictionary.stop_cam""\n    ) as mock_stop, mock.patch(\n        ""displayarray.window.subscriber_windows.warnings""\n    ) as mock_warnings, mock.patch(\n        ""displayarray.window.subscriber_windows.RuntimeWarning""\n    ) as mock_runtime, mock.patch.object(\n        cv2, ""destroyWindow""\n    ) as mock_destroy:\n        mock_runtime.return_value = mock_runtime\n\n        # test ordinary\n        sw = sub_win.SubscriberWindows()\n\n        sw.handle_keys(ord(""h""))\n\n        mock_win_cmd.key_pub.publish.assert_called_once_with(""h"")\n\n        # test bad key\n        def bad_key(k):\n            raise ValueError(""Bad Key"")\n\n        mock_win_cmd.key_pub.publish = bad_key\n\n        sw.handle_keys(ord(""b""))\n\n        mock_runtime.assert_called_once_with(\n            f""Unknown key code: [{ord(\'b\')}]. Please report to the displayarray issue page.""\n        )\n        mock_warnings.warn.assert_called_once_with(mock_runtime)\n\n        # test exit key\n        assert sw.ESC_KEY_CODES == [27]\n        ret = sw.handle_keys(27)\n\n        mock_destroy.assert_called_once_with(""displayarray (press ESC to quit)"")\n        assert sw.exited is True\n        mock_win_cmd.quit.assert_called()\n        mock_stop.assert_called_with(""0"")\n        assert ret == ""quit""\n\n\ndef test_handle_mouse():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch(\n        ""displayarray.window.subscriber_windows.MouseEvent""\n    ) as mock_mouse_event:\n        mock_mousey = mock_mouse_event.return_value = mock.MagicMock()\n\n        sw = sub_win.SubscriberWindows()\n\n        sw.handle_mouse(1, 2, 3, 4, 5)\n        mock_mouse_event.assert_called_once_with(1, 2, 3, 4, 5)\n        mock_win_cmd.mouse_pub.publish.assert_called_once_with(mock_mousey)\n\n\ndef test_update_frames():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        cv2, ""imshow""\n    ) as mock_imshow:\n        sw = sub_win.SubscriberWindows()\n\n        frame = np.ones((100, 100))\n        sw.FRAME_DICT[""0""] = frame\n\n        sw.update_frames()\n\n        assert sw.frames == {""0"": [frame]}\n        mock_imshow.assert_called_once_with(""displayarray (press ESC to quit)"", frame)\n\n\ndef test_update_frames_callback():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        cv2, ""imshow""\n    ) as mock_imshow:\n        cb = mock.MagicMock()\n        cb2 = mock.MagicMock()\n        frame = np.ones((100, 100))\n        frame2 = np.ones((102, 102))\n        frame3 = np.ones((103, 103))\n        cb.return_value = frame2\n        cb2.return_value = frame3\n\n        sw = sub_win.SubscriberWindows(\n            window_names=[""0"", ""1""], video_sources=[0, 1], callbacks=[cb, cb2]\n        )\n\n        sw.FRAME_DICT[""0""] = frame\n        sw.FRAME_DICT[""1""] = frame\n\n        sw.update_frames()\n\n        assert sw.frames == {""0"": [frame3], ""1"": [frame3]}\n        assert np.all(cb.mock_calls[0].args[0] == frame)\n        assert np.all(cb2.mock_calls[0].args[0] == frame2)\n        mock_imshow.assert_has_calls(\n            [\n                mock.call(""0 (press ESC to quit)"", frame3),\n                mock.call(""1 (press ESC to quit)"", frame3),\n            ]\n        )\n\n\ndef test_update_frames_too_many_channels():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        cv2, ""imshow""\n    ) as mock_imshow, mock.patch(\n        ""displayarray.window.subscriber_windows.print""\n    ) as mock_print:\n        sw = sub_win.SubscriberWindows()\n\n        frame = np.ones((100, 100, 100))\n        sw.FRAME_DICT[""0""] = frame\n\n        sw.update_frames()\n\n        mock_print.assert_has_calls(\n            [\n                mock.call(\n                    ""Too many channels in output. (Got 100 instead of 1 or 3.) Frame selection callback added.""\n                ),\n                mock.call(\n                    ""Ctrl+scroll to change first channel.\\n""\n                    ""Shift+scroll to change second channel.\\n""\n                    ""Alt+scroll to change third channel.""\n                ),\n            ]\n        )\n\n        assert isinstance(sw.callbacks[-1], SelectChannels)\n        assert sw.callbacks[-1].mouse_control is not None\n        assert sw.callbacks[-1].mouse_print_channels is True\n        assert sw.frames[""0""][0].shape[-1] == 3\n\n\ndef test_update_frames_nested():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        cv2, ""imshow""\n    ) as mock_imshow, mock.patch(""displayarray.window.subscriber_windows.print""):\n        sw = sub_win.SubscriberWindows()\n\n        frame = np.ones((20, 100, 100, 100))\n        sw.FRAME_DICT[""0""] = frame\n\n        sw.update_frames()\n\n        assert np.all(sw.frames[""0""][0] == np.ones((20, 100, 100, 3)))\n        assert len(sw.frames) == 1\n        assert mock_imshow.mock_calls[0].args[0] == ""displayarray (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[0].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[1].args[0] == ""0 -  1 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[1].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[2].args[0] == ""0 -  2 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[2].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[3].args[0] == ""0 -  3 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[3].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[4].args[0] == ""0 -  4 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[4].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[5].args[0] == ""0 -  5 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[5].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[6].args[0] == ""0 -  6 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[6].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[7].args[0] == ""0 -  7 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[7].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[8].args[0] == ""0 -  8 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[8].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[9].args[0] == ""0 -  9 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[9].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[10].args[0] == ""0 -  10 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[10].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[11].args[0] == ""0 -  11 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[11].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[12].args[0] == ""0 -  12 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[12].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[13].args[0] == ""0 -  13 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[13].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[14].args[0] == ""0 -  14 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[14].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[15].args[0] == ""0 -  15 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[15].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[16].args[0] == ""0 -  16 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[16].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[17].args[0] == ""0 -  17 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[17].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[18].args[0] == ""0 -  18 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[18].args[1] == np.ones((100, 100, 3)))\n        assert mock_imshow.mock_calls[19].args[0] == ""0 -  19 (press ESC to quit)""\n        assert np.all(mock_imshow.mock_calls[19].args[1] == np.ones((100, 100, 3)))\n\n\ndef test_update_frames_exception():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        cv2, ""imshow""\n    ) as mock_imshow:\n        sw = sub_win.SubscriberWindows()\n\n        frame = RuntimeError(""Sent from FrameUpdater"")\n        sw.FRAME_DICT[""0""] = frame\n\n        with pytest.raises(RuntimeError) as e:\n            sw.update_frames()\n        assert e.value == frame\n\n\ndef test_update():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""update_frames""\n    ) as mock_update_win_frames, mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch.object(\n        sub_win.SubscriberWindows, ""handle_keys""\n    ) as mock_handle_keys, mock.patch.object(\n        cv2, ""waitKey""\n    ) as key:\n        sub_cmd = mock_win_cmd.win_cmd_sub.return_value = mock.MagicMock()\n        key.return_value = 2\n        mock_cmd = sub_cmd.get.return_value = mock.MagicMock()\n        mock_key = mock_handle_keys.return_value = mock.MagicMock()\n\n        sw = sub_win.SubscriberWindows()\n\n        cmd, key = sw.update()\n\n        assert mock_win_cmd.win_cmd_sub.call_count == 2\n        assert mock_update_win_frames.call_count == 2\n        assert sub_cmd.get.call_count == 2\n        assert cmd == mock_cmd\n        assert key == mock_key\n\n\ndef test_update_with_array():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""update_frames""\n    ) as mock_update_win_frames, mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch.object(\n        sub_win.SubscriberWindows, ""handle_keys""\n    ) as mock_handle_keys, mock.patch.object(\n        sub_win.SubscriberWindows, ""add_source""\n    ) as add_source, mock.patch.object(\n        sub_win.SubscriberWindows, ""add_window""\n    ) as add_window, mock.patch(\n        ""displayarray.window.subscriber_windows.global_cv_display_callback""\n    ) as mock_cb, mock.patch.object(\n        cv2, ""waitKey""\n    ) as key:\n        sw = sub_win.SubscriberWindows()\n\n        sw.update(arr=1, id=2)\n\n        mock_cb.assert_called_once_with(1, 2)\n        add_source.assert_has_calls([mock.call(0), mock.call(2)])\n        add_window.assert_has_calls([mock.call(""displayarray""), mock.call(2)])\n\n\ndef test_wait_for_init():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""update""\n    ) as update:\n        sw = sub_win.SubscriberWindows()\n\n        def mock_update():\n            sw.frames = mock_update.frames[mock_update.i]\n            mock_update.i += 1\n            return """", """"\n\n        mock_update.frames = [[], [], [], [1]]\n        mock_update.i = 0\n\n        update.side_effect = mock_update\n\n        sw.wait_for_init()\n\n        assert mock_update.i == 4\n\n\ndef test_end():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch(\n        ""displayarray.window.subscriber_windows.subscriber_dictionary.stop_cam""\n    ) as mock_stop:\n        sw = sub_win.SubscriberWindows()\n\n        sw.close_threads = [mock.MagicMock(), mock.MagicMock()]\n\n        sw.end()\n\n        mock_win_cmd.quit.assert_called_with(force_all_read=False)\n        mock_stop.assert_called_with(""0"")\n        sw.close_threads[0].join.assert_called_once()\n        sw.close_threads[1].join.assert_called_once()\n\n\ndef test_enter_exit():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""end""\n    ) as end:\n        with sub_win.SubscriberWindows() as sw:\n            assert isinstance(sw, sub_win.SubscriberWindows)\n\n        end.assert_called()\n\n\ndef test_del():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch.object(\n        sub_win.SubscriberWindows, ""end""\n    ) as end:\n        sw = sub_win.SubscriberWindows()\n\n        del sw\n\n        end.assert_called_once()\n\n\ndef test_loop():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch.object(cv2, ""namedWindow""), mock.patch(\n        ""displayarray.window.subscriber_windows.window_commands""\n    ) as mock_win_cmd, mock.patch(\n        ""displayarray.window.subscriber_windows.subscriber_dictionary.stop_cam""\n    ) as mock_stop, mock.patch.object(\n        sub_win.SubscriberWindows, ""update""\n    ) as update:\n        sub_cmd = mock_win_cmd.win_cmd_sub.return_value = mock.MagicMock()\n\n        sw = sub_win.SubscriberWindows()\n\n        def mock_update():\n            mock_update.i += 1\n            return """", mock_update.keys[mock_update.i]\n\n        mock_update.keys = ["""", """", """", ""quit""]\n        mock_update.i = 0\n\n        update.side_effect = mock_update\n\n        sw.loop()\n\n        assert mock_update.i == 3\n        sub_cmd.release.assert_called_once()\n        mock_win_cmd.quit.assert_called_with(force_all_read=False)\n        mock_stop.assert_called_with(""0"")\n\n\ndef test_display():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch(\n        ""displayarray.window.subscriber_windows.FrameUpdater""\n    ) as fup, mock.patch(\n        ""displayarray.window.subscriber_windows.SubscriberWindows""\n    ) as sws:\n        fup_inst = fup.return_value = mock.MagicMock()\n        sws_inst = sws.return_value = mock.MagicMock()\n\n        d = sub_win.display(0, 1, size=(50, 50))\n\n        fup.assert_has_calls(\n            [\n                mock.call(0, fps_limit=float(""inf""), request_size=(50, 50)),\n                mock.call(1, fps_limit=float(""inf""), request_size=(50, 50)),\n            ]\n        )\n        assert fup_inst.start.call_count == 2\n        sws.assert_called_once_with(\n            window_names=[""window 0"", ""window 1""], video_sources=(0, 1), silent=False\n        )\n        assert sws_inst.close_threads == [fup_inst, fup_inst]\n        assert d == sws_inst\n\n\ndef test_display_blocking():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch(\n        ""displayarray.window.subscriber_windows.FrameUpdater""\n    ) as fup, mock.patch(\n        ""displayarray.window.subscriber_windows.SubscriberWindows""\n    ) as sws:\n        fup_inst = fup.return_value = mock.MagicMock()\n        sws_inst = sws.return_value = mock.MagicMock()\n\n        sub_win.display(0, 1, blocking=True)\n\n        assert fup_inst.start.call_count == 2\n        sws.assert_called_once_with(\n            window_names=[""window 0"", ""window 1""], video_sources=(0, 1), silent=False\n        )\n        sws_inst.loop.assert_called_once()\n        assert fup_inst.join.call_count == 2\n\n\ndef test_display_callbacks():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch(\n        ""displayarray.window.subscriber_windows.FrameUpdater""\n    ) as fup, mock.patch(\n        ""displayarray.window.subscriber_windows.SubscriberWindows""\n    ) as sws:\n        cb = mock.MagicMock()\n\n        sub_win.display(0, 1, callbacks=cb)\n\n        fup.assert_has_calls(\n            [\n                mock.call(\n                    0, callbacks=[cb], fps_limit=float(""inf""), request_size=(-1, -1)\n                ),\n                mock.call(\n                    1, callbacks=[cb], fps_limit=float(""inf""), request_size=(-1, -1)\n                ),\n            ]\n        )\n\n        fup.reset_mock()\n\n        cb2 = mock.MagicMock()\n\n        sub_win.display(0, 1, callbacks=[cb, cb2], fps_limit=60)\n\n        fup.assert_has_calls(\n            [\n                mock.call(0, callbacks=[cb, cb2], fps_limit=60, request_size=(-1, -1)),\n                mock.call(1, callbacks=[cb, cb2], fps_limit=60, request_size=(-1, -1)),\n            ]\n        )\n\n\ndef test_display_callbacks_dict():\n    sub_win.SubscriberWindows.FRAME_DICT = {}\n    with mock.patch(\n        ""displayarray.window.subscriber_windows.FrameUpdater""\n    ) as fup, mock.patch(\n        ""displayarray.window.subscriber_windows.SubscriberWindows""\n    ) as sws:\n        cb1 = mock.MagicMock()\n        cb2 = mock.MagicMock()\n        cb3 = mock.MagicMock()\n\n        sub_win.display(0, 1, 2, callbacks={0: cb1, 1: [cb1, cb2], ""2"": [cb3]})\n\n        fup.assert_has_calls(\n            [\n                mock.call(\n                    0, callbacks=[cb1], fps_limit=float(""inf""), request_size=(-1, -1)\n                ),\n                mock.call(\n                    1,\n                    callbacks=[cb1, cb2],\n                    fps_limit=float(""inf""),\n                    request_size=(-1, -1),\n                ),\n                mock.call(\n                    2, callbacks=[cb3], fps_limit=float(""inf""), request_size=(-1, -1)\n                ),\n            ]\n        )\n'"
tests/window/test_window_commands.py,0,"b'import displayarray.window.window_commands as win_com\nfrom localpubsub import VariablePub, VariableSub\nimport mock\n\n\ndef test_pubs():\n    assert isinstance(win_com.key_pub, VariablePub)\n    assert isinstance(win_com.mouse_pub, VariablePub)\n    assert isinstance(win_com.win_cmd_pub, VariablePub)\n\n\ndef test_quit():\n    with mock.patch.object(win_com.win_cmd_pub, ""publish"") as mock_pub:\n        win_com.quit()\n        mock_pub.assert_called_once_with(""quit"", force_all_read=True)\n        mock_pub.reset_mock()\n        win_com.quit(False)\n        mock_pub.assert_called_once_with(""quit"", force_all_read=False)\n\n\ndef test_win_cmd_sub():\n    with mock.patch.object(win_com.win_cmd_pub, ""make_sub"") as mock_make:\n        win_com.win_cmd_sub()\n        mock_make.assert_called_once()\n'"
examples/effects/lens/barrel.py,0,"b'from displayarray.effects import lens\nfrom displayarray import display\nfrom examples.videos import test_video\n\n# Move the mouse to center the image, scroll to increase/decrease barrel, ctrl+scroll to increase/decrease zoom\n\nm = lens.Barrel(use_bleed=False)\nm.enable_mouse_control()\ndisplay(test_video, callbacks=m, blocking=True)\n'"
examples/effects/lens/moustache.py,0,"b'from displayarray.effects import lens\nfrom displayarray import display\nfrom examples.videos import test_video\n\nm = lens.Mustache()\nm.enable_mouse_control()\ndisplay(test_video, callbacks=m, blocking=True)\n'"
