file_path,api_count,code
DemoExtension/setup.py,0,"b""#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n#\n#\n#\n# Simple build script for DemoExtension\n# \n# Author: Jonathan Hale\n#\n\nfrom distutils.core import setup, Extension\n\nDemoExt = Extension('DemoExtension', \n\t\tsources = ['DemoExtensionmodule.c'],\n\t\tinclude_dirs = [],\n\t\tlibraries = [],\n\t\tlibrary_dirs = []\n\t\t)\n\nsetup( name = 'DemoExtension',\n\tversion = '1.0.0',\n\tdescription = 'Demo Extension for JyNI test purposes.',\n\tauthor = 'Stefan Richthofer',\n\text_modules = [DemoExt]\n)\n\n\n"""
JyNI-Lib/config_util.py,0,"b'#\r\n#  Copyright of JyNI:\r\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\r\n#  All rights reserved.\r\n#\r\n#\r\n#  Copyright of Python and Jython:\r\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\r\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\r\n#  Python Software Foundation.\r\n#  All rights reserved.\r\n#\r\n#\r\n#  This file is part of JyNI.\r\n#\r\n#  JyNI is free software: you can redistribute it and/or modify\r\n#  it under the terms of the GNU Lesser General Public License as\r\n#  published by the Free Software Foundation, either version 3 of\r\n#  the License, or (at your option) any later version.\r\n#\r\n#  JyNI is distributed in the hope that it will be useful,\r\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n#  GNU Lesser General Public License for more details.\r\n#\r\n#  You should have received a copy of the GNU Lesser General Public\r\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport os, sys\r\n\r\ndef autoconfig_dynload_path():\r\n\t\'\'\'Automatically adds the dynamic library folder of the system\'s\r\n\tinstalled CPython to sys.path.\r\n\t\'\'\'\r\n\tif os.name == \'java\':\r\n\t\tif os._name == \'posix\':\r\n\t\t\tlib_dynload = \'/usr/lib/python2.7/lib-dynload\'\r\n\t\telif os._name in (""nt"", ""ce""):\r\n\t\t\timport python_home_winreg\r\n\t\t\tpy_home = python_home_winreg.python_home()\r\n\t\t\tif py_home is None:\r\n\t\t\t\treturn\r\n\t\t\tlib_dynload = py_home+\'DLLs\'\r\n\t\telse:\r\n\t\t\treturn\r\n\t\tif not lib_dynload in sys.path:\r\n\t\t\tsys.path.append(lib_dynload)\r\n\r\ndef autoconfig_lib_tk_path():\r\n\t\'\'\'Automatically adds the lib-tk folder of the system\'s\r\n\tinstalled CPython to sys.path.\r\n\t\'\'\'\r\n\tif os.name == \'java\':\r\n\t\tif os._name == \'posix\':\r\n\t\t\tlib_tk = \'/usr/lib/python2.7/lib-tk\'\r\n\t\telif os._name in (""nt"", ""ce""):\r\n\t\t\timport python_home_winreg\r\n\t\t\tpy_home = python_home_winreg.python_home()\r\n\t\t\tif py_home is None:\r\n\t\t\t\treturn\r\n\t\t\tlib_tk = py_home+\'Lib\\\\lib-tk\'\r\n\t\telse:\r\n\t\t\treturn\r\n\t\tif not lib_tk in sys.path:\r\n\t\t\tsys.path.append(lib_tk)\r\n\r\ndef _monkeypatch_os_path_for_Tk(py_home):\r\n\t\'\'\'For internal use only. Do not call.\'\'\'\r\n\t_os_path_join = os.path.join\r\n\tdef _join(a, *p):\r\n\t\t# This strange-looking check assumes that a PyShadowString\r\n\t\t# has been inserted into sys.prefix. We use the\r\n\t\t# PyShadowString magic here to assert that only very\r\n\t\t# specific modules (i.e. FixTk) are affected by this hack.\r\n\t\tif sys.prefix==a and sys.prefix==py_home and not py_home is None:\r\n\t\t\treturn _os_path_join(py_home, *p)\r\n\t\telse:\r\n\t\t\treturn _os_path_join(a, *p)\r\n\tos.path.join = _join\r\n\r\ndef _register_mbcs_encoding():\r\n\t\'\'\'For internal use only. Do not call.\'\'\'\r\n\timport mbcs_JyNI, codecs\r\n\tdef searchfunc_mbcs(encoding):\r\n\t\tif encoding == \'mbcs\':\r\n\t\t\treturn mbcs_JyNI.getregentry()\r\n\t\telse:\r\n\t\t\treturn None\r\n\tcodecs.register(searchfunc_mbcs)\r\n\r\ndef _patch_os_environ():\r\n\t\'\'\'For internal use only. Do not call.\'\'\'\r\n\tfrom JyNI import JyNI\r\n\r\n\tdef unsetenv(key):\r\n\t\tJyNI.putenv(key, """")\r\n\r\n# This variant fails with read-only attribute error:\r\n# \tif os._name in (\'os2\', \'nt\'):  # Where Env Var Names Must Be UPPERCASE\r\n# \t\t# But we store them as upper case\r\n# \t\tdef __setitem__(self, key, item):\r\n# \t\t\tJyNI.putenv(key, item)\r\n# \t\t\tself.data[key.upper()] = item\r\n# \t\tdef __delitem__(self, key):\r\n# \t\t\tunsetenv(key)\r\n# \t\t\tdel self.data[key.upper()]\r\n# \t\tdef clear(self):\r\n# \t\t\tfor key in self.data.keys():\r\n# \t\t\t\tunsetenv(key)\r\n# \t\t\t\tdel self.data[key]\r\n# \t\tdef pop(self, key, *args):\r\n# \t\t\tunsetenv(key)\r\n# \t\t\treturn self.data.pop(key.upper(), *args)\r\n# \r\n# \telse:  # Where Env Var Names Can Be Mixed Case\r\n# \t\tdef __setitem__(self, key, item):\r\n# \t\t\tJyNI.putenv(key, item)\r\n# \t\t\tself.data[key] = item\r\n# \t\tdef __delitem__(self, key):\r\n# \t\t\tunsetenv(key)\r\n# \t\t\tdel self.data[key]\r\n# \t\tdef clear(self):\r\n# \t\t\tfor key in self.data.keys():\r\n# \t\t\t\tunsetenv(key)\r\n# \t\t\t\tdel self.data[key]\r\n# \t\tdef pop(self, key, *args):\r\n# \t\t\tunsetenv(key)\r\n# \t\t\treturn self.data.pop(key, *args)\r\n# \r\n# \tos.environ.__setitem__ = __setitem__\r\n# \tos.environ.__delitem__ = __delitem__\r\n# \tos.environ.clear = clear\r\n# \tos.environ.pop = pop\r\n\r\n\r\n# Variant that patches entire os.environ:\r\n\timport UserDict\r\n\tif os._name in (\'os2\', \'nt\'):  # Where Env Var Names Must Be UPPERCASE\r\n\t\t# But we store them as upper case\r\n\t\tclass _Environ(UserDict.IterableUserDict):\r\n\t\t\tdef __init__(self, environ):\r\n\t\t\t\tUserDict.UserDict.__init__(self)\r\n\t\t\t\tdata = self.data\r\n\t\t\t\tfor k, v in environ.items():\r\n\t\t\t\t\tdata[k.upper()] = v\r\n\t\t\tdef __setitem__(self, key, item):\r\n\t\t\t\tJyNI.putenv(key, item)\r\n\t\t\t\tself.data[key.upper()] = item\r\n\t\t\tdef __getitem__(self, key):\r\n\t\t\t\treturn self.data[key.upper()]\r\n\t\t\ttry:\r\n\t\t\t\tunsetenv\r\n\t\t\texcept NameError:\r\n\t\t\t\tdef __delitem__(self, key):\r\n\t\t\t\t\tdel self.data[key.upper()]\r\n\t\t\telse:\r\n\t\t\t\tdef __delitem__(self, key):\r\n\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\tdel self.data[key.upper()]\r\n\t\t\t\tdef clear(self):\r\n\t\t\t\t\tfor key in self.data.keys():\r\n\t\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\t\tdel self.data[key]\r\n\t\t\t\tdef pop(self, key, *args):\r\n\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\treturn self.data.pop(key.upper(), *args)\r\n\t\t\tdef has_key(self, key):\r\n\t\t\t\treturn key.upper() in self.data\r\n\t\t\tdef __contains__(self, key):\r\n\t\t\t\treturn key.upper() in self.data\r\n\t\t\tdef get(self, key, failobj=None):\r\n\t\t\t\treturn self.data.get(key.upper(), failobj)\r\n\t\t\tdef update(self, dict=None, **kwargs):\r\n\t\t\t\tif dict:\r\n\t\t\t\t\ttry:\r\n\t\t\t\t\t\tkeys = dict.keys()\r\n\t\t\t\t\texcept AttributeError:\r\n\t\t\t\t\t\t# List of (key, value)\r\n\t\t\t\t\t\tfor k, v in dict:\r\n\t\t\t\t\t\t\tself[k] = v\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\t# got keys\r\n\t\t\t\t\t\t# cannot use items(), since mappings\r\n\t\t\t\t\t\t# may not have them.\r\n\t\t\t\t\t\tfor k in keys:\r\n\t\t\t\t\t\t\tself[k] = dict[k]\r\n\t\t\t\tif kwargs:\r\n\t\t\t\t\tself.update(kwargs)\r\n\t\t\tdef copy(self):\r\n\t\t\t\treturn dict(self)\r\n\r\n\telse:  # Where Env Var Names Can Be Mixed Case\r\n\t\tclass _Environ(UserDict.IterableUserDict):\r\n\t\t\tdef __init__(self, environ):\r\n\t\t\t\tUserDict.UserDict.__init__(self)\r\n\t\t\t\tself.data = environ\r\n\t\t\tdef __setitem__(self, key, item):\r\n\t\t\t\tJyNI.putenv(key, item)\r\n\t\t\t\tself.data[key] = item\r\n\t\t\tdef update(self,  dict=None, **kwargs):\r\n\t\t\t\tif dict:\r\n\t\t\t\t\ttry:\r\n\t\t\t\t\t\tkeys = dict.keys()\r\n\t\t\t\t\texcept AttributeError:\r\n\t\t\t\t\t\t# List of (key, value)\r\n\t\t\t\t\t\tfor k, v in dict:\r\n\t\t\t\t\t\t\tself[k] = v\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\t# got keys\r\n\t\t\t\t\t\t# cannot use items(), since mappings\r\n\t\t\t\t\t\t# may not have them.\r\n\t\t\t\t\t\tfor k in keys:\r\n\t\t\t\t\t\t\tself[k] = dict[k]\r\n\t\t\t\tif kwargs:\r\n\t\t\t\t\tself.update(kwargs)\r\n\t\t\ttry:\r\n\t\t\t\tunsetenv\r\n\t\t\texcept NameError:\r\n\t\t\t\tpass\r\n\t\t\telse:\r\n\t\t\t\tdef __delitem__(self, key):\r\n\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\tdel self.data[key]\r\n\t\t\t\tdef clear(self):\r\n\t\t\t\t\tfor key in self.data.keys():\r\n\t\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\t\tdel self.data[key]\r\n\t\t\t\tdef pop(self, key, *args):\r\n\t\t\t\t\tunsetenv(key)\r\n\t\t\t\t\treturn self.data.pop(key, *args)\r\n\t\t\tdef copy(self):\r\n\t\t\t\treturn dict(self)\r\n\r\n\tos.environ = _Environ(os.environ)\r\n'"
JyNI-Lib/mbcs_JyNI.py,0,"b'#\n#  This File is based on encodings/mbcs.py from CPython 2.7.13.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n"""""" Python \'mbcs\' Codec for Windows\n\n\nCloned by Mark Hammond (mhammond@skippinet.com.au) from ascii.py,\nwhich was written by Marc-Andre Lemburg (mal@lemburg.com).\n\n(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.\n\n""""""\n# Import them explicitly to cause an ImportError\n# on non-Windows systems\n# JyNI-note: This won\'t cause ImportError on non-Windows.\n# However An error will be printed and a crash or NPE will occur.\n# ToDo: Improve this exception.\nfrom JyNI.JyNI import mbcs_encode, mbcs_decode\n# for IncrementalDecoder, IncrementalEncoder, ...\nimport codecs\n\n### Codec APIs\n\ndef encode(input, errors=\'strict\'):\n\treturn mbcs_encode(input, errors)\n\ndef decode(input, errors=\'strict\'):\n\treturn mbcs_decode(input, errors, True)\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n\tdef encode(self, input, final=False):\n\t\treturn mbcs_encode(input, self.errors)[0]\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n\t_buffer_decode = mbcs_decode\n\nclass StreamWriter(codecs.StreamWriter):\n\tencode = mbcs_encode\n\nclass StreamReader(codecs.StreamReader):\n\tdecode = mbcs_decode\n\n### encodings module API\n\ndef getregentry():\n\treturn codecs.CodecInfo(\n\t\tname=\'mbcs\',\n\t\tencode=encode,\n\t\tdecode=decode,\n\t\tincrementalencoder=IncrementalEncoder,\n\t\tincrementaldecoder=IncrementalDecoder,\n\t\tstreamreader=StreamReader,\n\t\tstreamwriter=StreamWriter,\n\t)\n'"
JyNI-Lib/python_home_winreg.py,0,"b'#\r\n#  Copyright of JyNI:\r\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\r\n#  All rights reserved.\r\n#\r\n#\r\n#  Copyright of Python and Jython:\r\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\r\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\r\n#  Python Software Foundation.\r\n#  All rights reserved.\r\n#\r\n#\r\n#  This file is part of JyNI.\r\n#\r\n#  JyNI is free software: you can redistribute it and/or modify\r\n#  it under the terms of the GNU Lesser General Public License as\r\n#  published by the Free Software Foundation, either version 3 of\r\n#  the License, or (at your option) any later version.\r\n#\r\n#  JyNI is distributed in the hope that it will be useful,\r\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n#  GNU Lesser General Public License for more details.\r\n#\r\n#  You should have received a copy of the GNU Lesser General Public\r\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nfrom _winreg import HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, QueryValue\r\n\r\nkey = ""SOFTWARE\\\\Python\\\\PythonCore\\\\2.7\\\\InstallPath""\r\nkey32 = ""SOFTWARE\\\\Wow6432Node\\\\Python\\\\PythonCore\\\\2.7\\\\InstallPath""\r\n\r\ndef python_home():\r\n\t# Running 32 bit we prefer a Python in Wow6432Node if it exists:\r\n\timport platform, os\r\n\tif os.name == ""java"":\r\n\t\t# When running JyNI we cannot use platform.architecture(),\r\n\t\t# because it tries to load ctypes which crashes exactly due\r\n\t\t# to the 64 bit vs 32 bit issue we want to avoid here.\r\n\t\t# Note that platform.architecture() works well with plain\r\n\t\t# Jython, because if it cannot find ctypes at all it performs\r\n\t\t# some fallback.\r\n\t\tfrom java.lang import System\r\n\t\tarch = System.getProperty(""sun.arch.data.model"")+""bit""\r\n\telse:\r\n\t\tarch = platform.architecture()[0]\r\n\tif arch == ""32bit"":\r\n\t\ttry:\r\n\t\t\treturn QueryValue(HKEY_CURRENT_USER, key32)\r\n\t\texcept WindowsError:\r\n\t\t\tpass\r\n\t\ttry:\r\n\t\t\treturn QueryValue(HKEY_LOCAL_MACHINE, key32)\r\n\t\texcept WindowsError:\r\n\t\t\tpass\r\n\t\tif platform.uname()[4].endswith(\'64\'):\r\n\t\t\t# Running 32 bit on a 64 bit platform we abort here\r\n\t\t\treturn\r\n\ttry:\r\n\t\treturn QueryValue(HKEY_CURRENT_USER, key)\r\n\texcept WindowsError:\r\n\t\tpass\r\n\ttry:\r\n\t\treturn QueryValue(HKEY_LOCAL_MACHINE, key)\r\n\texcept WindowsError:\r\n\t\tpass\r\n\r\nif __name__ == \'__main__\':\r\n\tprint python_home()[:-1]\r\n'"
JyNI-Demo/src/JyNIDatetimeTest.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 21.09.2013\n\n@author: Stefan Richthofer\n\'\'\'\nimport sys\n#    exclude the following line to switch back to Jython\'s datetime:\nsys.path.insert(0, \'/usr/lib/python2.7/lib-dynload\')\n#sys.path.insert(0, \'/data/workspace/linux/Python-2.7.11/build/lib.linux-x86_64-2.7\')\n\n#    This path should be okay for linux systems and maybe some bsd-oids;\n#    if it does not work (i.e. doc below reads different than\n#    ""Fast implementation of the datetime type.""), check that the path is\n#    correct and the original datetime module is present there.\n\nimport datetime\n\nprint ""datetime successfully imported.""\nprint """"\n#    you can see that CPython\'s datetime is used, if the doc reads\n#    ""Fast implementation of the datetime type.""\nprint ""-----datetime doc-----""\nprint datetime.__doc__\nprint ""----------------------""\nprint """"\n\n#print datetime.__findattr__(""datetime"")\nprint datetime.__name__\ndt = datetime.datetime\n#print dt\nnow = datetime.datetime(2013, 11, 3, 20, 30, 45)\n\nprint now\nprint repr(now)\nprint type(now)\nprint now.year, now.month, now.day\nprint now.hour, now.minute, now.second\nprint now.microsecond\nprint ""--------------------------------------""\n'"
JyNI-Demo/src/JyNIDemo.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 30.06.2013\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys\nimport os\nimport platform\n\nif os.name == \'java\':\n\tsystm = platform.java_ver()[-1][0].lower().replace(\' \', \'\')\n\tif systm == \'macosx\':\n\t\tver = platform.java_ver()[-1][1]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((systm, ver, \'intel\'))\n\telse:\n\t\tif systm.startswith(\'win\'):\n\t\t\tsystm = \'win\'\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\nelse:\n\tsystm = os.uname()[0].lower()\n\tif systm == \'darwin\':\n\t\tver = platform.mac_ver()[0]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((\'macosx\', ver, \'intel\'))\n\telse:\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\n\n\n#Since invalid paths do no harm, we add several possible paths here, where\n#DemoExtension.so could be located in various build scenarios. If you use different\n#scenarios in parallel, select the one to be used by setting some of the paths as comments.\n\n#built with an IDE in debug mode:\nsys.path.append(\'../../DemoExtension/Debug\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Debug\') #in case you run it from base dir\n#built with an IDE in release mode:\nsys.path.append(\'../../DemoExtension/Release\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Release\') #in case you run it from base dir\n#built with setup.py:\nsys.path.append(\'../../DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from base dir\nsys.path.append(\'./DemoExtension/build\')\n\nimport DemoExtension\n\n\nprint ""--------Access Docstring----------""\nprint DemoExtension\nprint DemoExtension.__doc__\n\n# If you run this via Jython, you can uncomment the following lines to prove that Jython is running.\n# With these lines this demo becomes a program that neither Jython without JyNI,\n# nor ordinary CPython could run.\n\n#print ""To prove that Jython is running, we make a java call:""\n#from  java.lang import System\n#print ""System.currentTimeMillis: ""+str(System.currentTimeMillis())\n\n\nprint """"\nprint ""--------Hello World----------""\nprint DemoExtension.hello_world\nprint DemoExtension.hello_world.__doc__\nDemoExtension.hello_world()\n\nprint """"\nprint ""--------Argument passing----------""\nprint DemoExtension.concatFirstWithLastString.__doc__\nprint DemoExtension.concatFirstWithLastString(""begin_"", ""ignore"", ""ignore too"", ""end"")\nprint DemoExtension.argCountToString.__doc__\nprint DemoExtension.argCountToString(""a"", ""b"", ""c"", ""d"", ""e"", ""f"")\n\nprint """"\nprint ""--------Argument passing with keywords----------""\nDemoExtension.keywordTest(""first"", ""second"", right = ""Hey"", wrong = ""nothing"")\nprint ""(in JyNI-case see bottom for native outputs)""\n\nprint """"\nprint ""----------------Integer passing-----------------""\nprint DemoExtension.intSquare.__doc__\nprint DemoExtension.intSquare\nprint DemoExtension.intSquare.__class__\nprint DemoExtension.intSquare.__name__\nprint ""Native square result of 16: ""+str(DemoExtension.intSquare(16))\nprint ""Native square result of -19: ""+str(DemoExtension.intSquare(19))\n\nprint """"\nprint ""--------Native list access reading----------""\nlst = [""Hello"", ""lovely"", ""world""]\nprint lst.__class__\nDemoExtension.listReadTest(lst)\nprint ""(in JyNI-case see bottom for native outputs)""\n\nprint """"\nprint ""--------Native list access writing----------""\nl = [""Hello"", ""lovely"", ""world""]\nprint ""input: ""+str(l)\nDemoExtension.listModifyTest(l, 2)\nprint ""output: ""+str(l)\n\nprint """"\nprint ""--------Set testing----------""\nbasket = [\'apple\', \'orange\', \'apple\', \'pear\', \'orange\', \'banana\']\nfruit = set(basket)\nprint fruit\np = 2\nDemoExtension.setPopTest(fruit, p)\nprint ""after popping ""+str(p)+"" elements:""\nprint fruit\n\nprint """"\nprint ""--------Unicode testing----------""\nuc = u\'a\\xac\\u1234\\u20ac\\U00008000\'\nprint type(uc)\nprint uc\nuc2 = DemoExtension.unicodeTest(uc)\nprint uc2\n\nprint """"\nprint ""--------New-style classes---------""\n\nclass testnewstyle(str):\n\tpass\n\nnobj = testnewstyle()\nprint ""Check conversion of new-style class: ""+str(DemoExtension.newstyleCheck(nobj))\nprint ""Check new-style is string-subtype: ""+str(DemoExtension.newstyleCheckSubtype(nobj, type("""")))\n\n# Let\'s test instances of custom type that is not necessarily new-style class:\n# from JyNI import PyShadowString\n# nobj2 = PyShadowString(""a"", ""b"")\n\n# print ""Check conversion of Java-custom class: ""+str(DemoExtension.newstyleCheck(nobj2))\n# print ""Check custom class is string-subtype: ""+str(DemoExtension.newstyleCheckSubtype(nobj2, type("""")))\n# print ""Check custom class is int-subtype (shouldn\'t be): ""+str(DemoExtension.newstyleCheckSubtype(nobj2, type(6)))\n\nprint """"\nprint ""======in JyNI-case expect native output after these lines on some consoles======""\nprint ""=====(it is JNI-behavior that native output is displayed after Java output)=====""\n'"
JyNI-Demo/src/JyNIExceptionTest.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 20.09.2013\n\n@author: Stefan Richthofer\n\'\'\'\nimport sys\nimport os\nimport platform\n\nif os.name == \'java\':\n\tsystm = platform.java_ver()[-1][0].lower().replace(\' \', \'\')\n\tif systm == \'macosx\':\n\t\tver = platform.java_ver()[-1][1]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((systm, ver, \'intel\'))\n\telse:\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\nelse:\n\tsystm = os.uname()[0].lower()\n\tif systm == \'darwin\':\n\t\tver = platform.mac_ver()[0]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((\'macosx\', ver, \'intel\'))\n\telse:\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\n\n\n#Since invalid paths do no harm, we add several possible paths here, where\n#DemoExtension.so could be located in various build scenarios. If you use different\n#scenarios in parallel, select the one to be used by setting some of the paths as comments.\n\n#built with an IDE in debug mode:\nsys.path.append(\'../../DemoExtension/Debug\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Debug\') #in case you run it from base dir\n#built with an IDE in release mode:\nsys.path.append(\'../../DemoExtension/Release\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Release\') #in case you run it from base dir\n#built with setup.py:\nsys.path.append(\'../../DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from base dir\n\nimport DemoExtension\n\n#import java.lang.System as jsys\n#jsys.out.println(""Jython is running!"")\n#print ""-------------------""\n\nprint ""sys.exc_info, initial: ""+str(sys.exc_info())\ntry:\n\tprint ""We call a native method that creates an exception. However, this time we handle it...""\n\tDemoExtension.exceptionTest()\nexcept SystemError:\n\tprint ""...and entered except-area!""\n\tprint ""sys.exc_info: ""+str(sys.exc_info())\nprint ""Now lets look, what happens, if the exception is uncaught:""\nDemoExtension.exceptionTest()\nprint ""------------------- this line should never be printed""\n'"
JyNI-Demo/src/JyNIRefMonitor.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 30.06.2013\n\n@author: Stefan Richthofer\n\'\'\'\n\n# Note that this script currently has issues under 32bit systems.\n# It appears that this is a JNI-bug.\n\nimport sys\n#Since invalid paths do no harm, we add several possible paths here, where\n#DemoExtension.so could be located in various build scenarios. If you use different\n#scenarios in parallel, select the one to be used by setting some of the paths as comments.\n\n#built with an IDE in debug mode:\nsys.path.append(\'../../DemoExtension/Debug\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Debug\') #in case you run it from base dir\n#built with an IDE in release mode:\nsys.path.append(\'../../DemoExtension/Release\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Release\') #in case you run it from base dir\n#built with setup.py on 64 bit machine:\nsys.path.append(\'../../DemoExtension/build/lib.linux-x86_64-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.linux-x86_64-2.7\') #in case you run it from base dir\n#built with setup.py on 32 bit machine:\nsys.path.append(\'../../DemoExtension/build/lib.linux-i686-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.linux-i686-2.7\') #in case you run it from base dir\n#built with setup.py on macosx 10.10:\nsys.path.append(\'../../DemoExtension/build/lib.macosx-10.10-intel-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.macosx-10.10-intel-2.7\') #in case you run it from base dir\n\nimport time\nimport weakref\n\nfrom JyNI import JyNI\nfrom JyNI import JyReferenceMonitor as monitor\nfrom JyNI.gc import JyWeakReferenceGC\nfrom java.lang import System\nfrom java.lang.ref import WeakReference\nfrom org.python.modules._weakref import GlobalRef\n\n\ndef run1():\n\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n\tJyWeakReferenceGC.monitorNativeCollection = True\n\t\n\t# PyType  <- Make native ref-cycle test with heap type to test partly-stub-mode.\n\t# PySet, but no native link to other PyObject\n\t# PyFrozenSet, ""\n\t# PyCode, not GC-relevant in CPython\n\t\n\timport DemoExtension\n\t\n\t#Note:\n\t# For now we attempt to verify JyNI\'s GC-functionality independently from\n\t# Jython concepts like Jython weak references or Jython GC-module.\n\t# So we use java.lang.ref.WeakReference and java.lang.System.gc to monitor\n\t# and control Java-gc.\n\t\n\t#JyNI.JyRefMonitor_setMemDebugFlags(1)\n\t#JyWeakReferenceGC.monitorNativeCollection = True\n\n\t#l = (123,)\n\tl = ([0, ""test""],)\n\tl[0][0] = l\n\t#l = (123, {\'a\': 0, \'b\': ""test""})\n\t#l[1][\'a\'] = l\n\t#We create weak reference to l to monitor collection by Java-GC:\n\twkl = WeakReference(l)\n\tprint ""weak(l): ""+str(wkl.get())\n\t\n\t# We pass down l to some native method. We don\'t care for the method itself,\n\t# but conversion to native side causes creation of native PyObjects that\n\t# correspond to l and its elements. We will then track the life-cycle of these.\n\tprint ""make l native...""\n\t\n\tDemoExtension.argCountToString(l)\n\t\n\t#print ""argCountToString.__doc__-address: ""+str(JyNI.lookupNativeHandle(DemoExtension.argCountToString.__doc__))\n\t#print ""We access a method-doc as this used to cause problems with GC:""\n\t#print ""    ""+DemoExtension.argCountToString.__doc__\n\t#print ""Native static objects so far:""\n\t#print JyNI.nativeStaticPyObjectHeads.keySet()\n\t\n\tprint ""Delete l... (but GC not yet ran)""\n\tdel l\n\t#l = None\n\tprint ""weak(l) after del: ""+str(wkl.get())\n\tprint """"\n\t# monitor.list-methods display the following format:\n\t# [native pointer]{\'\' | \'_GC_J\' | \'_J\'} ([type]) #[native ref-count]: [repr] *[creation time]\n\t# _GC_J means that JyNI tracks the object\n\t# _J means that a JyNI-GC-head exists, but the object is not actually treated by GC\n\t# This can serve monitoring purposes or soft-keep-alive (c.f. java.lang.ref.SoftReference)\n\t# for caching.\n\tprint ""Leaks before GC:""\n\tmonitor.listLeaks()\n\tprint """"\n\n\t# By inserting this line you can confirm that native\n\t# leaks would persist if JyNI-GC is not working:\n\t#JyWeakReferenceGC.nativecollectionEnabled = False\n\n\tprint ""calling Java-GC...""\n\tSystem.gc()\n\ttime.sleep(2)\n\tprint ""weak(l) after GC: ""+str(wkl.get())\n\tprint """"\n\tmonitor.listWouldDeleteNative()\n\tprint """"\n\tprint ""leaks after GC:""\n\tmonitor.listLeaks()\n\tprint """"\n\tprint ""    ""+DemoExtension.argCountToString.__doc__\n\tmonitor.listLeaks()\n\t#print ""----""\n\t#print monitor.listAll()\n\tprint """"\n\tprint ""====""\n\tprint ""exit""\n\tprint ""====""\n\n\ndef run2():\n\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n\tJyWeakReferenceGC.monitorNativeCollection = True\n\t\n\t# PyType  <- Make native ref-cycle test with heap type to test partly-stub-mode.\n\t# PySet, but no native link to other PyObject\n\t# PyFrozenSet, ""\n\t# PyCode, not GC-relevant in CPython\n\n\timport DemoExtension\n\t\n\t#Note:\n\t# For now we attempt to verify JyNI\'s GC-functionality independently from\n\t# Jython concepts like Jython weak references or Jython GC-module.\n\t# So we use java.lang.ref.WeakReference and java.lang.System.gc to monitor\n\t# and control Java-gc.\n\t\n\t#JyNI.JyRefMonitor_setMemDebugFlags(1)\n\t#JyWeakReferenceGC.monitorNativeCollection = True\n\n\tl = [0, ""test1""]\n\td = {\'a\': 7, \'b\': ""test6""}\n\t#We create weak reference to l to monitor collection by Java-GC:\n\twkl = WeakReference(l)\n\twkd = WeakReference(d)\n\t#l[0] = d\n\tprint ""weak(l): ""+str(wkl.get())\n\tprint ""weak(d): ""+str(wkd.get())\n\n\t# We pass down l to some native method. We don\'t care for the method itself,\n\t# but conversion to native side causes creation of native PyObjects that\n\t# correspond to l and its elements. We will then track the life-cycle of these.\n\tprint ""make l native...""\n\n\t# Note that it *does* matter whether we insert d into l before oder after this\n\t# native call. Inserting it after the call tests PyList\'s capability to update\n\t# the reference graph while inserting it before yields the should-be-result.\n\t# If both variants lead to the same post-GC output, JyNI works fine.\n\t#l[0] = d\n\tDemoExtension.argCountToString(l)\n\tl[0] = d\n\t#print ""argCountToString.__doc__-address: ""+str(JyNI.lookupNativeHandle(DemoExtension.argCountToString.__doc__))\n\t#print ""We access a method-doc as this used to cause problems with GC:""\n\t#print ""    ""+DemoExtension.argCountToString.__doc__\n\t#print ""Native static objects so far:""\n\t#print JyNI.nativeStaticPyObjectHeads.keySet()\n\t\n\tprint ""Delete l... (but GC not yet ran)""\n\t#del l\n\tdel d\n\t#l = None\n\t#print ""weak(l) after del: ""+str(wkl.get())\n\tprint ""weak(d) after del: ""+str(wkd.get())\n\tprint """"\n\t# monitor.list-methods display the following format:\n\t# [native pointer]{\'\' | \'_GC_J\' | \'_J\'} ([type]) #[native ref-count]: [repr] *[creation time]\n\t# _GC_J means that JyNI tracks the object\n\t# _J means that a JyNI-GC-head exists, but the object is not actually treated by GC\n\t# This can serve monitoring purposes or soft-keep-alive (c.f. java.lang.ref.SoftReference)\n\t# for caching.\n\tprint ""Leaks before GC:""\n\tmonitor.listLeaks()\n\tprint """"\n\t\n\t# By inserting this line you can confirm that native\n\t# leaks would persist if JyNI-GC is not working:\n\t#JyWeakReferenceGC.nativecollectionEnabled = False\n\t\n\tprint ""calling Java-GC...""\n\tSystem.gc()\n\ttime.sleep(2)\n\tprint ""weak(l) after GC: ""+str(wkl.get())\n\t#print ""l after GC: ""+str(l)\n\tprint ""weak(d) after GC: ""+str(wkd.get())\n\tprint """"\n\tmonitor.listWouldDeleteNative()\n\tprint """"\n\tprint ""leaks after GC:""\n\tmonitor.listLeaks()\n\t\n\t#print ""------""\n\t#print DemoExtension.argCountToString.__doc__\n\t#monitor.listFreeStatus(""dict"")\n\t#monitor.listAll()\n\tprint """"\n\tprint ""====""\n\tprint ""exit""\n\tprint ""====""\n\ndef run3():\n\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n\tJyWeakReferenceGC.monitorNativeCollection = True\n\timport DemoExtension\n\t\n\t#JyNI.JyRefMonitor_setMemDebugFlags(1)\n\t#JyWeakReferenceGC.monitorNativeCollection = True\n\n\tl = [0, ""test1""]\n# \tprint l\n# \tDemoExtension.listSetIndex(l, 0, 100.7)\n# \tprint l\n\td = {\'a\': 7, \'b\': ""test6""}\n\t#We create weak reference to l to monitor collection by Java-GC:\n\twkl = WeakReference(l)\n\twkd = WeakReference(d)\n\twkl2 = weakref.ref(l)\n\twkd2 = weakref.ref(d)\n\n\t#Note:\n\t#=====\n\t#To make this work we\'ll have to ensure that d gets a GCHead even though\n\t#l doesn\'t recognize the insertion of d and thus would not explore it.\n\t#In fact every C-stub object must get a GCHead when going native, regardless\n\t#of whether it is inserted somewhere or not, because it might be silently\n\t#inserted and a GCHead is the only way to detect this and fix it.\n\t#Add a call (e.g. to size) to the dict in l on native side to test that\n\t#d still works (which it currently shouldn\'t).\n\t#Later use d\'s GCHead to detect the invalid graph and resurrect d\'s java-part.\n\t#Take care of the GIL here. CStubs must release the GIL when they detect a\n\t#failing backend, so the GC-thread can acquire it and resurrect the backend.\n\t#How to fix the weak reference etc?\n\n\t#l[0] = d\n\tprint ""weak(l): ""+str(wkl.get())\n\tprint ""weak(d): ""+str(wkd.get())\n\tprint ""weak2(l): ""+str(wkl2())\n\tprint ""weak2(d): ""+str(wkd2())\n\tprint ""make l native...""\n\t#l[0] = d\n\t#DemoExtension.argCountToString(l)\n\t#l[0] = d\n\tDemoExtension.listSetIndex(l, 0, d)\n\n\tprint ""Delete l... (but GC not yet ran)""\n\t#del l\n\tdel d\n\t#l = None\n\t#print ""weak(l) after del: ""+str(wkl.get())\n\tprint ""weak(d) after del: ""+str(wkd.get())\n\tprint ""weak2(d) after del: ""+str(wkd2())\n\tprint """"\n\tprint ""Leaks before GC:""\n\tmonitor.listLeaks()\n\tprint """"\n\t\n\tprint ""calling Java-GC...""\n\tSystem.gc()\n\ttime.sleep(2)\n# \tif monitor.lastClearGraphValid:\n# \t\tprint ""valid graph""\n# \telse:\n# \t\tprint ""invalid graph""\n# \tmonitor.lastClearGraphValid = False\n\tprint ""weak(l) after GC: ""+str(wkl.get())\n\t#print ""l after GC: ""+str(l)\n\tprint ""weak(d) after GC: ""+str(wkd.get())\n\tprint ""weak2(l) after GC: ""+str(wkl2())\n\tprint ""weak2(d) after GC: ""+str(wkd2())\n\twkd = WeakReference(l[0])\n\tprint """"\n\t#monitor.listWouldDeleteNative()\n\tprint """"\n\t#print ""leaks after GC:""\n\t#monitor.listLeaks()\n\tprint ""l[0], i.e. d after gc:""\n\t#print l[0]\n\t#print len(l[0])\n\t\n\tprint ""------""\n\tprint ""del l...""\n\tdel l\n\tSystem.gc()\n\ttime.sleep(2)\n# \tif monitor.lastClearGraphValid:\n# \t\tprint ""valid graph""\n# \telse:\n# \t\tprint ""invalid graph""\n# \tmonitor.lastClearGraphValid = False\n\tprint """"\n\tmonitor.listWouldDeleteNative()\n\tprint """"\n\t#print ""leaks after GC (l deleted):""\n\t#monitor.listLeaks()\n\t#print DemoExtension.argCountToString.__doc__\n\t#monitor.listFreeStatus(""dict"")\n\t#monitor.listAll()\n\t#GlobalRef.processDelayedCallbacks()\n\tprint ""weak(d) after GC2: ""+str(wkd.get())\n\tprint ""weak2(l) after GC2: ""+str(wkl2())\n\tprint ""weak2(d) after GC2: ""+str(wkd2())\n\tSystem.gc()\n\ttime.sleep(2)\n\tprint ""weak(d) after GC3: ""+str(wkd.get())\n\tmonitor.listWouldDeleteNative()\n\tprint """"\n\tprint ""leaks after GC3:""\n\tmonitor.listLeaks()\n\tprint """"\n\tprint ""====""\n\tprint ""exit""\n\tprint ""====""\n\ndef run4():\n\timport DemoExtension\n\n\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n\tl = ([0, ""test""],)\n\tl[0][0] = l\n\tDemoExtension.argCountToString(l)\n\tdel l\n\t#l[0][1] = None\n\tprint ""Leaks before GC:""\n\tmonitor.listLeaks()\n\tSystem.gc()\n\ttime.sleep(2)\n\tprint ""Leaks after GC:""\n\tmonitor.listLeaks()\n\nrun4()\n#System.getProperties().list(System.out)\n'"
JyNI-Demo/src/JyNITkinterTest.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys, os\n\n#Include native Tkinter:\nif os.name == \'java\':\n\timport config_util\n\tconfig_util.autoconfig_dynload_path()\n\tconfig_util.autoconfig_lib_tk_path()\n\nfrom Tkinter import Tk, StringVar, Label, Entry, Button\n\nroot = Tk()\ntxt = StringVar()\ntxt.set(""Hello World!"")\n\ndef printText():\n\tprint txt.get()\n\ndef printTimeStamp():\n\tfrom java.lang import System\n\tprint ""System.currentTimeMillis: ""+str(System.currentTimeMillis())\n\nLabel(root, text = ""Welcome to JyNI Tkinter-Demo!"").pack()\nEntry(root, textvariable = txt).pack()\nButton(root, text = ""print text"", command = printText).pack()\nButton(root, text = ""print timestamp"", command = printTimeStamp).pack()\nButton(root, text = ""Quit"", command = root.destroy).pack()\n\nroot.mainloop()\n\nprint """"\nprint ""====""\nprint ""exit""\nprint ""====""\n'"
JyNI-Demo/src/JyNIctypesTest.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 03.10.2015\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport os, sys\n# Use a command like this to override the potentially automatically found ctypes location:\n#sys.path.insert(0, \'/data/workspace/linux/CPython/Python-2.7.15/build/lib.linux-x86_64-2.7\')\nimport ctypes\nfrom ctypes import *\nimport platform\n\nisMac = platform.java_ver()[-1][0] == \'Mac OS X\' or platform.mac_ver()[0] != \'\'\nisWin = os.name in (""nt"", ""ce"") or os.name == \'java\' and os._name in (""nt"", ""ce"")\n\n# print ""Demo of ctypes with os.name: ""+platform.os.name\n# print """"\n\nif isMac:\n\tlibc = CDLL(\'libc.dylib\')\nelif isWin:\n\tlibc = cdll.msvcrt\nelse:\n\tlibc = CDLL(\'libc.so.6\')\n\nclass Bottles:\n\tdef __init__(self, number):\n\t\tself._as_parameter_ = number\n\nprint libc\nprint type(libc.strlen)\nprint libc.strlen\nprint libc.strlen(""abcdef"")\nprint ""--------------------""\nprintf = libc.printf\nprintf(""%d bottles of beer\\n"", 42)\nprintf(""%d bottles of beer\\n"", Bottles(73))\n\nprintf.argtypes = [c_char_p, c_char_p, c_int, c_double]\nprintf(""String \'%s\'; Int %d; Double %f\\n"", ""Hi"", 10, 2.2)\n\nprintf.argtypes = [c_char_p, c_int]\nprintf(""Int %d\\n"", False)\n\nbuffer = c_buffer(""\\000"", 10)\nlibc.sprintf(buffer, ""Spam%d"", 776)\n\nprint repr(buffer.value)\n# Currently fails:\n# print repr(buffer.raw),\n# print ""(should be \'Spam776\\\\x00\\\\x00\\\\x00\')""\n\nclass cell(Structure):\n\tpass\n\nprint ""Testing ctypes-pointers:""\n\ncell._fields_ = [(""name"", c_char_p), (""next"", POINTER(cell))]\nc1 = cell()\nc1.name = ""foo""\nc2 = cell()\nc2.name = ""bar""\nc1.next = pointer(c2)\nc2.next = pointer(c1)\np = c1\nprint p.next[0]\nfor i in range(8):\n\tprint p.name,\n\tp = p.next[0]\n\nprint """"\nprint ""--------------------""\n\nIntArray6 = c_int * 6\n\n#print type(IntArray6)\n#print IntArray6.mro()\n\nia = IntArray6(5, 1, 7, 33, 99, -7)\nprint ia\nqsort = libc.qsort\n\ndef py_cmp_func(a, b):\n\tprint ""py_cmp_func"", a[0], b[0]\n\treturn a[0] - b[0]\n\nCMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\ncmp_func = CMPFUNC(py_cmp_func)\nqsort(ia, len(ia), sizeof(c_int), cmp_func)\nfor i in range(len(ia)):\n\tprint ia[i],\n\n# Iterator-related builtins not yet supported:\n# for i in ia: print i,\n\nprint """"\nprint ""====================""\nprint ""exited normally""\nprint ""i.e. demo successful""\nprint """"\nprint ""======in JyNI-case expect native output after these lines on some consoles=====""\nprint ""=====(it is a JNI issue that native output is displayed after java output)=====""\n'"
JyNI-Demo/src/test_JyNI.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 02.09.2014\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys\nimport os\nfrom os import name\nimport sys\nimport platform\n\nif os.name == \'java\':\n\tsystm = platform.java_ver()[-1][0].lower().replace(\' \', \'\')\n\tif systm == \'macosx\':\n\t\tver = platform.java_ver()[-1][1]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((systm, ver, \'intel\'))\n\telse:\n\t\tif systm.startswith(\'win\'):\n\t\t\tsystm = \'win\'\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\nelse:\n\tsystm = os.uname()[0].lower()\n\tif systm == \'darwin\':\n\t\tver = platform.mac_ver()[0]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((\'macosx\', ver, \'intel\'))\n\telse:\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\n\n#Since invalid paths do no harm, we add several possible paths here, where\n#DemoExtension.so could be located in various build scenarios. If you use different\n#scenarios in parallel, select the one to be used by setting some of the paths as comments.\n\n#built with an IDE in debug mode:\nsys.path.append(\'../../DemoExtension/Debug\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Debug\') #in case you run it from base dir\n#built with an IDE in release mode:\nsys.path.append(\'../../DemoExtension/Release\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Release\') #in case you run it from base dir\n#built with setup.py:\nsys.path.append(\'../../DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from base dir\n\n\n# datetime_path is expected to be folder containing datetime.so\n\n# This is the usual system path for datetime.so. On some distributions it actually\n# does not contain datetime.so; i.e. then datetime.so is part of libpython2.7.so.\n# (However JyNI cannot load libpython2.7.so for that purpose due to other symbol\n#  conflicts; you need to provide datetime.so in some other way then, e.g. by\n#  compiling CPython yourself)\ndatetime_path = \'/usr/lib/python2.7/lib-dynload\'\n\n# This is an example-path for a self-compiled python:\n#datetime_path = \'/data/workspace/linux/Python-2.7.11/build/lib.linux-x86_64-2.7\'\n\nsys.path.insert(0, datetime_path)\n\n# def hasNativeDatetime():\n# \tif os.name == \'java\':\n# \t\tfrom JyNI import JyNI\n# \t\treturn JyNI.isLibraryFileAvailable(\'datetime\')\n# \telse:\n# \t\t# Let\'s assume native datetime is trivially available for non-Java case:\n# \t\treturn True\n\nimport DemoExtension\nimport datetime\nimport unittest\n\nclass TestJyNI(unittest.TestCase):\n\n\tdef test_DemoExtension_doc(self):\n\t\tself.assertEqual(DemoExtension.__doc__, ""This is a pure demo extension."")\n\n\tdef test_hello_world_info(self):\n\t\tself.assertEqual(str(DemoExtension.hello_world), ""<built-in function hello_world>"")\n\t\tself.assertEqual(DemoExtension.hello_world.__doc__, ""Hello World method."")\n\n\tdef test_argument_passing(self):\n\t\tself.assertEqual(DemoExtension.concatFirstWithLastString.__doc__, ""Concatenates first with last element. Returns empty string, if less than two args are available."")\n\t\tself.assertEqual(DemoExtension.concatFirstWithLastString(""begin_"", ""ignore"", ""ignore too"", ""end""), ""begin_end"")\n\t\tself.assertEqual(DemoExtension.argCountToString.__doc__, ""Returns number of arguments as string."")\n\t\tself.assertEqual(DemoExtension.argCountToString(""a"", ""b"", ""c"", ""d"", ""e"", ""f""), ""(6)"")\n\n\tdef test_integer_passing(self):\n\t\tself.assertEqual(DemoExtension.intSquare.__doc__, ""Returns the square of the given int."")\n\t\tself.assertEqual(str(DemoExtension.intSquare), ""<built-in function intSquare>"")\n\t\tself.assertEqual(str(DemoExtension.intSquare.__class__), ""<type \'builtin_function_or_method\'>"")\n\t\tself.assertEqual(DemoExtension.intSquare.__name__, ""intSquare"")\n\t\tself.assertEqual(DemoExtension.intSquare(16), 256)\n\t\tself.assertEqual(DemoExtension.intSquare(19), 361)\n\t\tself.assertEqual(DemoExtension.intSquare1(-19), 361)\n\n\tdef test_boolean_passing(self):\n\t\tself.assertEqual(DemoExtension.booleanToInt(False), 0)\n\t\tself.assertEqual(DemoExtension.booleanToInt(True), 1)\n\t\tself.assertIsNone(DemoExtension.booleanToInt(99))\n\t\tself.assertTrue(DemoExtension.intToBoolean(1))\n\t\tself.assertFalse(DemoExtension.intToBoolean(0))\n\t\tself.assertIsNone(DemoExtension.intToBoolean(2))\n\n\tdef test_native_list_access_writing(self):\n\t\tl = [""Hello"", ""lovely"", ""world""]\n\t\tDemoExtension.listModifyTest(l, 2)\n\t\tself.assertEqual(l[2], ""natively modified"")\n\t\tself.assertEqual(len(l), 3)\n\n\t#Passing self-containing objects to native code used to crash JyNI.\n\t#This test proves that this is fixed.\n\tdef test_native_list_selfcontaining(self):\n\t\tl = [""Hello"", ""lovely"", ""world""]\n\t\tl[1] = l\n\t\tDemoExtension.listModifyTest(l, 0)\n\t\tself.assertEqual(l[0], ""natively modified"")\n\t\tself.assertEqual(len(l), 3)\n\t\tself.assertEqual(str(l), ""[\'natively modified\', [...], \'world\']"")\n\n\tdef test_native_sequence_selfcontaining(self):\n\t\t# In early JyNI-days self-containing sequences used\n\t\t# to trigger infinite conversion loops\n\t\tl = [""Hello"", ""lovely"", ""world""]\n\t\tl[1] = (11, 12, l)\n\t\tDemoExtension.listModifyTest(l, 2)\n\t\tself.assertEqual(l[2], ""natively modified"")\n\t\tself.assertEqual(len(l), 3)\n\t\tself.assertEqual(str(l), ""[\'Hello\', (11, 12, [...]), \'natively modified\']"")\n\n\tdef test_native_create_list_selfcontaining(self):\n\t\tl = DemoExtension.createListSelfContaining()\n\t\tself.assertEqual(str(l), ""[\'element1\', \'element2\', [...]]"")\n\n\tdef test_native_create_tuple_selfcontaining(self):\n\t\tl = DemoExtension.createTupleSelfContaining()\n\t\tself.assertEqual(str(l[:2]), ""(\'tp1\', \'tp2\')"")\n\t\tself.assertEqual(str(l[2]), ""[\'lst1\', (\'tp1\', \'tp2\', [...])]"")\n\t\t#This output differs between Jython and CPython: (Why?)\n\t\t#(slightly different output-recursion depth)\n# \t\tself.assertEqual(str(l), ""(\'tp1\', \'tp2\', [\'lst1\', (\'tp1\', \'tp2\', [...])])"")\n\n\tdef test_native_set(self):\n\t\tbasket = [\'apple\', \'orange\', \'apple\', \'pear\', \'orange\', \'banana\']\n\t\tfruit = set(basket)\n\t\tp = 2\n\t\tDemoExtension.setPopTest(fruit, p)\n\t\tself.assertEqual(len(fruit), 2)\n\t\tcount = 0\n\t\tif ""pear"" in fruit:\n\t\t\tcount += 1\n\t\tif ""apple"" in fruit:\n\t\t\tcount += 1\n\t\tif ""orange"" in fruit:\n\t\t\tcount += 1\n\t\tif ""banana"" in fruit:\n\t\t\tcount += 1\n\t\tself.assertEqual(count, 2)\n\n\tdef test_unicode(self):\n\t\tuc = u\'a\\xac\\u1234\\u20ac\\U00008000\'\n\t\tuc2 = DemoExtension.unicodeTest(uc)\n\t\tself.assertEqual(uc, uc2)\n\n\tdef test_exception(self):\n\t\tself.assertRaisesRegexp(SystemError, ""This is a test exception message for JyNI."", DemoExtension.exceptionTest)\n\t\ttry:\n\t\t\tDemoExtension.exceptionTest()\n\t\t\tself.assertEqual(1, 2) #would always fail, but is not reached if everything works as expected\n\t\texcept SystemError:\n\t\t\texc = sys.exc_info()\n\t\t\tself.assertEqual(exc[0], SystemError)\n\t\t\tself.assertEqual(str(exc[1]), ""This is a test exception message for JyNI."")\n\n\tdef test_new_style_classes(self):\n\n\t\tclass testnewstyle(object):\n\t\t\tpass\n\n\t\tclass testnewstyleString(str):\n\t\t\tpass\n\n\t\tclass testnewstyleInt(int):\n\t\t\tpass\n\n\t\tstrType = type("""")\n\t\tintType = type(6)\n\n\t\tnobj = testnewstyle()\n\t\tself.assertTrue(DemoExtension.newstyleCheck(nobj))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, strType))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, intType))\n\n\t\tnobj = testnewstyleString()\n\t\tself.assertTrue(DemoExtension.newstyleCheck(nobj))\n\t\tself.assertTrue(DemoExtension.newstyleCheckSubtype(nobj, strType))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, intType))\n\n\t\tnobj = testnewstyleInt()\n\t\tself.assertTrue(DemoExtension.newstyleCheck(nobj))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, strType))\n\t\tself.assertTrue(DemoExtension.newstyleCheckSubtype(nobj, intType))\n\n\t@unittest.skipUnless(os.name == \'java\',\n\t\t\'Not runnable with CPython, because it uses JyNI-classes for testing.\')\n\tdef test_custom_classes(self):\n\t\tfrom JyNI import JyNIImporter #, PyShadowString\n\n\t\tstrType = type("""")\n\t\tintType = type(6)\n\n\t\tnobj = JyNIImporter()\n\t\tself.assertTrue(DemoExtension.newstyleCheck(nobj))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, strType))\n\t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, intType))\n\n# \t\tnobj = PyShadowString(""a"", ""b"")\n# \t\tself.assertTrue(DemoExtension.newstyleCheck(nobj))\n# \t\tself.assertTrue(DemoExtension.newstyleCheckSubtype(nobj, strType))\n# \t\tself.assertFalse(DemoExtension.newstyleCheckSubtype(nobj, intType))\n\n# \t@unittest.skipUnless(hasNativeDatetime(),\n# \t\t\'datetime.so not found (probably part of libpython2.7.so)\')\n\tdef test_datetime(self):\n\t\tself.assertEqual(datetime.__doc__, ""Fast implementation of the datetime type."")\n\t\tself.assertEqual(datetime.__name__, ""datetime"")\n\t\tnow = datetime.datetime(2013, 11, 3, 20, 30, 45)\n\t\tself.assertEqual(str(now), ""2013-11-03 20:30:45"")\n\t\tself.assertEqual(repr(now), ""datetime.datetime(2013, 11, 3, 20, 30, 45)"")\n\t\tself.assertEqual(str(type(now)), ""<type \'datetime.datetime\'>"")\n\n\t@unittest.skipUnless(os.name == \'java\',\n\t\t\'Shuts down CPython silently for unknown reason; \\\n\t\tthe tested API is used by Cython, so should actually work.\')\n\tdef test_native_import_API_and_methoddescr(self):\n\t\tself.assertEqual(DemoExtension.importAPIandMethodDescrTest(), 0)\n\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
JyNI-Demo/src/test_JyNI_ctypes.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 09.02.2016\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport os, sys\n\nimport unittest\nimport platform\nfrom ctypes import *\n\nisMac = platform.java_ver()[-1][0] == \'Mac OS X\' or platform.mac_ver()[0] != \'\'\nisWin = os.name in (""nt"", ""ce"") or os.name == \'java\' and os._name in (""nt"", ""ce"")\nif isMac:\n\tlibc = CDLL(\'libc.dylib\')\nelif isWin:\n\tlibc = cdll.msvcrt\nelse:\n\tlibc = CDLL(\'libc.so.6\')\n\nbuffer = c_buffer(""\\000"", 50)\n\nclass TestJyNI_ctypes(unittest.TestCase):\n\n\tdef test_libc_sprintf(self):\n\t\tself.assertEqual(str(type(libc.strlen)), ""<class \'ctypes._FuncPtr\'>"")\n\t\tself.assertTrue(str(libc.strlen).startswith(""<_FuncPtr object at 0x""))\n\t\tself.assertEqual(libc.strlen(""abcdef""), 6)\n\t\tlibc.sprintf(buffer, ""%d bottles of beer"", 42)\n\t\tself.assertEqual(buffer.value, ""42 bottles of beer"")\n\n\t\tclass Bottles:\n\t\t\tdef __init__(self, number):\n\t\t\t\tself._as_parameter_ = number\n\n\t\tlibc.sprintf(buffer, ""%d bottles of beer"", Bottles(73))\n\t\tself.assertEqual(buffer.value, ""73 bottles of beer"")\n\n\n\tdef test_argtypes(self):\n\t\t# We must later restore old argtypes (i.e. probably None) to assure\n\t\t# that all tests are applied under same conditions.\n\t\tsaved_argtypes = libc.sprintf.argtypes\n\t\tlibc.sprintf.argtypes = [c_char_p, c_char_p, c_char_p, c_int, c_double]\n\t\tlibc.sprintf(buffer, ""String \'%s\'; Int %d; Double %f\\n"", ""Hi"", 10, 2.2)\n\t\tself.assertTrue(buffer.value.startswith(""String \'Hi\'; Int 10; Double 2""))\n\t\tlibc.sprintf.argtypes = saved_argtypes\n\n\n\tdef test_pointers(self):\n\n\t\tclass cell(Structure):\n\t\t\tpass\n\n\t\tcell._fields_ = [(""name"", c_char_p), (""next"", POINTER(cell))]\n\t\tc1 = cell()\n\t\tc1.name = ""foo""\n\t\tc2 = cell()\n\t\tc2.name = ""bar""\n\t\tc1.next = pointer(c2)\n\t\tc2.next = pointer(c1)\n\t\tp = c1\n\t\tsbuf = []\n\t\tfor i in range(8):\n\t\t\tsbuf.append(p.name)\n\t\t\tp = p.next[0]\n\t\tself.assertEqual(""_"".join(sbuf), ""foo_bar_foo_bar_foo_bar_foo_bar"")\n\n\n\tdef test_callback(self):\n\t\tIntArray6 = c_int * 6\n\t\tself.assertEqual(str(type(IntArray6)), ""<type \'_ctypes.PyCArrayType\'>"")\n\t\tia = IntArray6(5, 1, 7, 33, 99, -8)\n\t\t\n\t\tdef py_abs_cmp_func(a, b):\n\t\t\treturn abs(a[0]) - abs(b[0])\n\t\t\n\t\tCMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n\t\tcmp_func = CMPFUNC(py_abs_cmp_func)\n\t\tlibc.qsort(ia, len(ia), sizeof(c_int), cmp_func)\n\t\tia_buf = []\n\t\tfor i in range(len(ia)):\n\t\t\tia_buf.append(ia[i])\n\t\tself.assertEqual(ia_buf, [1, 5, 7, -8, 33, 99])\n\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
JyNI-Demo/src/test_JyNI_ctypes_gc.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 01.05.2016\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys\n\nimport ctypes\nimport unittest\nimport time\n#import weakref\n\nfrom JyNI import JyNI\nfrom JyNI import JyReferenceMonitor as monitor\nfrom java.lang import System\n#from java.lang.ref import WeakReference\n\ndef runGC():\n\tSystem.gc()\n\ttime.sleep(2)\n\ndef clearCurrentLeaks():\n\tleaks = monitor.getCurrentNativeLeaks()\n\tif len(leaks) > 0:\n\t\tmonitor.declareLeaksPermanent(leaks)\n\nclass TestJyNI_gc(unittest.TestCase):\n# \t@classmethod\n# \tdef setUpClass(cls):\n# \t\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n# \t\t#JyWeakReferenceGC.monitorNativeCollection = True\n# \n# \t@classmethod\n# \tdef tearDownClass(cls):\n# \t\tJyNI.JyRefMonitor_setMemDebugFlags(0)\n# \t\t#JyWeakReferenceGC.monitorNativeCollection = False\n\n\tdef test_ctypes_newstyle_dict(self):\n\t\t#print ""test_ctypes_newstyle_dict""\n\t\tfrom ctypes import CFUNCTYPE, c_int\n\n\t\ttest = CFUNCTYPE(c_int, c_int)()\n\t\tdct = test.__dict__\n\t\ttest.__name__ = ""testName""\n\t\tdct = None\n\t\tself.assertTrue(hasattr(test, ""__name__""))\n\t\tself.assertEqual(test.__name__, ""testName"")\n\t\trunGC()\n\t\trunGC()\n\t\tself.assertTrue(hasattr(test, ""__name__""))\n\t\tself.assertEqual(test.__name__, ""testName"")\n\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
JyNI-Demo/src/test_JyNI_gc.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 10.07.2015\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys\nimport os\nimport platform\n\nif os.name == \'java\':\n\tsystm = platform.java_ver()[-1][0].lower().replace(\' \', \'\')\n\tif systm == \'macosx\':\n\t\tver = platform.java_ver()[-1][1]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((systm, ver, \'intel\'))\n\telse:\n\t\tif systm.startswith(\'win\'):\n\t\t\tsystm = \'win\'\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\nelse:\n\tsystm = os.uname()[0].lower()\n\tif systm == \'darwin\':\n\t\tver = platform.mac_ver()[0]\n\t\tver = ver[:5] # e.g.""10.12.4"" => ""10.12""\n\t\tbuildf = \'-\'.join((\'macosx\', ver, \'intel\'))\n\telse:\n\t\tbuildf = \'-\'.join((systm, os.uname()[-1]))\n\n#Since invalid paths do no harm, we add several possible paths here, where\n#DemoExtension.so could be located in various build scenarios. If you use different\n#scenarios in parallel, select the one to be used by setting some of the paths as comments.\n\n#built with an IDE in debug mode:\nsys.path.append(\'../../DemoExtension/Debug\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Debug\') #in case you run it from base dir\n#built with an IDE in release mode:\nsys.path.append(\'../../DemoExtension/Release\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/Release\') #in case you run it from base dir\n#built with setup.py:\nsys.path.append(\'../../DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from src dir\nsys.path.append(\'./DemoExtension/build/lib.\'+buildf+\'-2.7\') #in case you run it from base dir\n\nimport DemoExtension\nimport unittest\nimport time\nimport weakref\n# ToDo: If _winreg was imported before this point, one test will fail. Why...?\n\nfrom JyNI import JyNI\nfrom JyNI import JyReferenceMonitor as monitor\n#from JyNI.gc import JyWeakReferenceGC\nfrom java.lang import System\nfrom java.lang.ref import WeakReference\n\ndef runGC():\n\tSystem.gc()\n\ttime.sleep(1)\n\ndef clearCurrentLeaks():\n\tleaks = monitor.getCurrentNativeLeaks()\n\tif len(leaks) > 0:\n\t\tmonitor.declareLeaksPermanent(leaks)\n\nclass TestJyNI_gc(unittest.TestCase):\n\t@classmethod\n\tdef setUpClass(cls):\n\t\tJyNI.JyRefMonitor_setMemDebugFlags(1)\n\t\t#JyWeakReferenceGC.monitorNativeCollection = True\n\n\t@classmethod\n\tdef tearDownClass(cls):\n\t\tJyNI.JyRefMonitor_setMemDebugFlags(0)\n\t\t#JyWeakReferenceGC.monitorNativeCollection = False\n\n\tdef test_gc_doc(self):\n\t\t#print ""test_gc_doc""\n\t\tclearCurrentLeaks()\n\t\tdoc = DemoExtension.argCountToString.__doc__\n\t\t#monitor.listLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\n\tdef test_gc_list_cycle(self):\n\t\t#print ""test_gc_list_cycle""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl = (123, [0, ""test1""])\n\t\tl[1][0] = l\n\t\t#We create weak reference to l to monitor collection by Java-GC:\n\t\twkl = WeakReference(l)\n\t\tDemoExtension.argCountToString(l)\n\t\tdel l\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 4)\n\t\trunGC()\n\t\tself.assertIsNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tdel wkl\n\n\tdef test_gc_list_cycle2(self):\n\t\t#print ""test_gc_list_cycle2""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl2 = (127, [0, ""test2""])\n\t\tl2[1][0] = l2\n\t\t#We create weak reference to l to monitor collection by Java-GC:\n\t\twkl = WeakReference(l2)\n\t\tDemoExtension.argCountToString(l2)\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 4)\n\t\trunGC()\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 3)\n\t\tdel l2\n\t\trunGC()\n\t\tself.assertIsNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tdel wkl\n\n\tdef test_gc_dict_cycle(self):\n\t\t#print ""test_gc_dict_cycle""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl = (123, {\'a\': 0, \'b\': ""test3""})\n\t\tl[1][\'a\'] = l\n\t\t#We create weak reference to l to monitor collection by Java-GC:\n\t\twkl = WeakReference(l)\n\t\tDemoExtension.argCountToString(l)\n\t\tdel l\n\t\tself.assertIsNotNone(wkl.get())\n\t\t#monitor.listLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 3)\n\t\trunGC()\n\t\tself.assertIsNone(wkl.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\t#monitor.listLeaks()\n\t\tdel wkl\n\n\tdef test_gc_list_modify_pre(self):\n\t\t#print ""test_gc_list_modify_pre""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl = [0, ""test1""]\n\t\td = {\'a\': 7, \'b\': ""test6""}\n\t\t#We create weak reference to l to monitor collection by Java-GC:\n\t\twkl = WeakReference(l)\n\t\twkd = WeakReference(d)\n\t\tl[0] = d\n\t\tDemoExtension.argCountToString(l)\n\t\t#l[0] = d\n\t\tdel d\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 4)\n\t\trunGC()\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertIsNotNone(wkd.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 3)\n\t\tdel l\n\t\trunGC()\n\t\tself.assertIsNone(wkl.get())\n\t\tself.assertIsNone(wkd.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\n\tdef test_gc_list_modify_update(self):\n\t\t#print ""test_gc_list_modify_update""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl = [0, ""test1""]\n\t\td = {\'a\': 7, \'b\': ""test6""}\n\t\t#We create weak reference to l to monitor collection by Java-GC:\n\t\twkl = WeakReference(l)\n\t\twkd = WeakReference(d)\n\t\t#l[0] = d\n\t\tDemoExtension.argCountToString(l)\n\t\tl[0] = d\n\t\tdel d\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 4)\n\t\trunGC()\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertIsNotNone(wkd.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 3)\n\t\tdel l\n\t\trunGC()\n\t\tself.assertIsNone(wkl.get())\n\t\tself.assertIsNone(wkd.get())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\n\tdef test_gc_list_modify_silent(self):\n\t\t#print ""test_gc_list_modify_silent""\n\t\tclearCurrentLeaks()\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tl = [0, ""test1""]\n\t\td = {\'a\': 7, \'b\': ""test6""}\n\t\twkl = WeakReference(l)\n\t\twkd = WeakReference(d)\n\t\twkl2 = weakref.ref(l)\n\t\twkd2 = weakref.ref(d)\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertIsNotNone(wkd.get())\n\t\tself.assertIsNotNone(wkl2())\n\t\tself.assertIsNotNone(wkd2())\n\t\tDemoExtension.listSetIndex(l, 0, d)\n\t\tdel d\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 4)\n\t\trunGC()\n\t\tself.assertFalse(monitor.lastClearGraphValid)\n\t\tself.assertIsNotNone(wkl.get())\n\t\tself.assertIsNone(wkd.get())\n\t\tself.assertIsNotNone(wkl2())\n\t\tself.assertIsNotNone(wkd2())\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 3)\n\t\tself.assertIsNotNone(l[0])\n\t\tself.assertEqual(len(l[0]), 2)\n\t\tdel l\n\t\trunGC()\n\t\tself.assertTrue(monitor.lastClearGraphValid)\n\n\t\t# For some reason resurrected objects persist one more\n\t\t# gc-cycle in principle. So we have to run gc again before\n\t\t# we can observe wkd2 to die. It is currently unclear whether\n\t\t# this behavior is a JyNI-bug or natural Java-gc behavior,\n\t\t# but for now (with some evidence) we assume the latter.\n\t\t# Note: Since WeakRef-support wkd2 actually keeps the native\n\t\t# referent alive for one more cycle. So also the monitor-refcount\n\t\t# test only passes after another gc-run now.\n\t\trunGC()\n\t\tself.assertTrue(monitor.lastClearGraphValid)\n\t\tself.assertEqual(len(monitor.getCurrentNativeLeaks()), 0)\n\t\tself.assertIsNone(wkl2())\n\t\tself.assertIsNone(wkd2())\n\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
JyNI-Demo/src/test_JyNI_sqlite3.py,0,"b'\'\'\'\n * Copyright of JyNI:\n * Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n * All rights reserved.\n *\n *\n * Copyright of Python and Jython:\n * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n * 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n * Python Software Foundation.\n * All rights reserved.\n *\n *\n * This file is part of JyNI.\n *\n * JyNI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * JyNI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\nCreated on 29.07.2016\n\n@author: Stefan Richthofer\n\'\'\'\n\nimport sys\nimport os\nimport unittest\n# class TestJyNI(unittest.TestCase):\n# for line in sys.path:\n# \tprint line\nimport sqlite3\n\nclass Test_sqlite3(unittest.TestCase):\n\n\tdef test_connection_basic(self):\n\t\ttry:\n\t\t\tos.remove(\'test.db\')\n\t\texcept:\n\t\t\tpass\n\t\tconn = sqlite3.connect(\'test.db\')\n# \t\tprint ""Opened database successfully"";\n\n\t\tconn.execute(\'\'\'CREATE TABLE GALAXY\n\t\t\t\t(ID INT PRIMARY KEY      NOT NULL,\n\t\t\t\tNAME             TEXT    NOT NULL,\n\t\t\t\tDIAMETER_LY      INT     NOT NULL,\n\t\t\t\tTYPE             CHAR(50),\n\t\t\t\tDIST_EARTH_MLY   REAL);\'\'\')\n# \t\tprint ""Table created successfully"";\n\n\n\t\tconn.execute(""INSERT INTO GALAXY (ID,NAME,DIAMETER_LY,TYPE,DIST_EARTH_MLY) \\\n\t\t\t\tVALUES (1, \'Milky Way\', 100000, \'SBbc\', 0.027 )"");\n\n\t\tconn.execute(""INSERT INTO GALAXY (ID,NAME,DIAMETER_LY,TYPE,DIST_EARTH_MLY) \\\n\t\t\t\tVALUES (2, \'Andromeda Galaxy\', 220000, \'SA(s)b\', 2.56 )"");\n\n\t\tconn.execute(""INSERT INTO GALAXY (ID,NAME,DIAMETER_LY,TYPE,DIST_EARTH_MLY) \\\n\t\t\t\tVALUES (3, \'Triangulum Galaxy\', 60000, \'SAc\', 2.64 )"");\n\n\t\tconn.execute(""INSERT INTO GALAXY (ID,NAME,DIAMETER_LY,TYPE,DIST_EARTH_MLY) \\\n\t\t\t\tVALUES (4, \'Barnards Galaxy\', 7000, \'IB(s)m IV-V\', 1.630 )"");\n\n\t\tconn.commit()\n# \t\tprint ""Records created successfully"";\n\n\n\t\tcursor = conn.execute(""SELECT id, name, diameter_ly, type  from GALAXY"")\n\t\trowstr = []\n\t\tfor row in cursor:\n\t\t\trowstr.append(str(row))\n\n# \t\tfor line in rowstr:\n# \t\t\tprint line\n\n\t\tself.assertEqual(rowstr[0], ""(1, u\'Milky Way\', 100000, u\'SBbc\')"")\n\t\tself.assertEqual(rowstr[1], ""(2, u\'Andromeda Galaxy\', 220000, u\'SA(s)b\')"")\n\t\tself.assertEqual(rowstr[2], ""(3, u\'Triangulum Galaxy\', 60000, u\'SAc\')"")\n\t\tself.assertEqual(rowstr[3], ""(4, u\'Barnards Galaxy\', 7000, u\'IB(s)m IV-V\')"")\n\n\t\tconn.execute(""UPDATE GALAXY set DIAMETER_LY = 180000 where ID=1"")\n\t\tconn.commit\n# \t\tprint ""Total number of rows updated :"", conn.total_changes\n\n\t\tcursor = conn.execute(""SELECT id, name, diameter_ly, type  from GALAXY"")\n\n\t\trowstr = []\n\t\tfor row in cursor:\n\t\t\trowstr.append(str(row))\n\n\t\tself.assertEqual(rowstr[0], ""(1, u\'Milky Way\', 180000, u\'SBbc\')"")\n\t\tself.assertEqual(rowstr[1], ""(2, u\'Andromeda Galaxy\', 220000, u\'SA(s)b\')"")\n\t\tself.assertEqual(rowstr[2], ""(3, u\'Triangulum Galaxy\', 60000, u\'SAc\')"")\n\t\tself.assertEqual(rowstr[3], ""(4, u\'Barnards Galaxy\', 7000, u\'IB(s)m IV-V\')"")\n\n\t\tconn.execute(""DELETE from GALAXY where ID=2;"")\n\t\tconn.commit\n# \t\tprint ""Total number of rows deleted :"", conn.total_changes\n\n\t\tcursor = conn.execute(""SELECT id, name, diameter_ly, type  from GALAXY"")\n\t\trowstr = []\n\t\tfor row in cursor:\n\t\t\trowstr.append(str(row))\n\n\t\tself.assertEqual(rowstr[0], ""(1, u\'Milky Way\', 180000, u\'SBbc\')"")\n\t\tself.assertEqual(rowstr[1], ""(3, u\'Triangulum Galaxy\', 60000, u\'SAc\')"")\n\t\tself.assertEqual(rowstr[2], ""(4, u\'Barnards Galaxy\', 7000, u\'IB(s)m IV-V\')"")\n\t\t\n# \t\tfor line in rowstr:\n# \t\t\tprint line\n\n\t\tconn.close()\n\t\tos.remove(\'test.db\')\n\n\nif __name__ == \'__main__\':\n\tunittest.main()\n'"
JyNI-Lib/ctypes/__init__.py,0,"b'#\n#  This File is based on ctypes/__init__.py from CPython 2.7.8.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\n""""""create and manipulate C data types in Python""""""\n\nimport os as _os, sys as _sys\n\n# JyNI-adjustment:\n# Usually Jython does not have lib-dynload on its path, so ensure it here\nimport config_util\nconfig_util.autoconfig_dynload_path()\n\n\n__version__ = ""1.1.0""\n\nfrom _ctypes import Union, Structure, Array\nfrom _ctypes import _Pointer\nfrom _ctypes import CFuncPtr as _CFuncPtr\nfrom _ctypes import __version__ as _ctypes_version\nfrom _ctypes import RTLD_LOCAL, RTLD_GLOBAL\nfrom _ctypes import ArgumentError\nfrom struct import calcsize as _calcsize\nif __version__ != _ctypes_version:\n    raise Exception(""Version number mismatch"", __version__, _ctypes_version)\n\nif _os.name in (""nt"", ""ce""):\n    from _ctypes import FormatError\n\n#isPosix = _os.name == ""posix""\n#if _os.name == ""java"":\n#    from JyNI import JyNI\n#    isPosix = JyNI._os.name == ""posix""()\n\nDEFAULT_MODE = RTLD_LOCAL\n#todo: Work out Jython-compliant replacement for _sys.platform == ""darwin""\n#if _os.name == ""posix"" and _sys.platform == ""darwin"":\n    # On OS X 10.3, we use RTLD_GLOBAL as default mode\n    # because RTLD_LOCAL does not work at least on some\n    # libraries.  OS X 10.3 is Darwin 7, so we check for\n    # that.\n\n# JyNI-Note: So far we ignore OS-versions before 8.\n#            (at least until uname is added to Jython 2.7.2.)\n#    if int(_os.uname()[2].split(\'.\')[0]) < 8:\n#        DEFAULT_MODE = RTLD_GLOBAL\n\nfrom _ctypes import FUNCFLAG_CDECL as _FUNCFLAG_CDECL, \\\n     FUNCFLAG_PYTHONAPI as _FUNCFLAG_PYTHONAPI, \\\n     FUNCFLAG_USE_ERRNO as _FUNCFLAG_USE_ERRNO, \\\n     FUNCFLAG_USE_LASTERROR as _FUNCFLAG_USE_LASTERROR\n\n""""""\nWINOLEAPI -> HRESULT\nWINOLEAPI_(type)\n\nSTDMETHODCALLTYPE\n\nSTDMETHOD(name)\nSTDMETHOD_(type, name)\n\nSTDAPICALLTYPE\n""""""\n\ndef create_string_buffer(init, size=None):\n    """"""create_string_buffer(aString) -> character array\n    create_string_buffer(anInteger) -> character array\n    create_string_buffer(aString, anInteger) -> character array\n    """"""\n    if isinstance(init, (str, unicode)):\n        if size is None:\n            size = len(init)+1\n        buftype = c_char * size\n        buf = buftype()\n        buf.value = init\n        return buf\n    elif isinstance(init, (int, long)):\n        buftype = c_char * init\n        buf = buftype()\n        return buf\n    raise TypeError(init)\n\ndef c_buffer(init, size=None):\n##    ""deprecated, use create_string_buffer instead""\n##    import warnings\n##    warnings.warn(""c_buffer is deprecated, use create_string_buffer instead"",\n##                  DeprecationWarning, stacklevel=2)\n    return create_string_buffer(init, size)\n\n_c_functype_cache = {}\ndef CFUNCTYPE(restype, *argtypes, **kw):\n    """"""CFUNCTYPE(restype, *argtypes,\n                 use_errno=False, use_last_error=False) -> function prototype.\n\n    restype: the result type\n    argtypes: a sequence specifying the argument types\n\n    The function prototype can be called in different ways to create a\n    callable object:\n\n    prototype(integer address) -> foreign function\n    prototype(callable) -> create and return a C callable function from callable\n    prototype(integer index, method name[, paramflags]) -> foreign function calling a COM method\n    prototype((ordinal number, dll object)[, paramflags]) -> foreign function exported by ordinal\n    prototype((function name, dll object)[, paramflags]) -> foreign function exported by name\n    """"""\n    flags = _FUNCFLAG_CDECL\n    if kw.pop(""use_errno"", False):\n        flags |= _FUNCFLAG_USE_ERRNO\n    if kw.pop(""use_last_error"", False):\n        flags |= _FUNCFLAG_USE_LASTERROR\n    if kw:\n        raise ValueError(""unexpected keyword argument(s) %s"" % kw.keys())\n    try:\n        return _c_functype_cache[(restype, argtypes, flags)]\n    except KeyError:\n        class CFunctionType(_CFuncPtr):\n            _argtypes_ = argtypes\n            _restype_ = restype\n            _flags_ = flags\n        _c_functype_cache[(restype, argtypes, flags)] = CFunctionType\n        return CFunctionType\n\nif _os.name in (""nt"", ""ce""):\n    from _ctypes import LoadLibrary as _dlopen\n    from _ctypes import FUNCFLAG_STDCALL as _FUNCFLAG_STDCALL\n    if _os.name == ""ce"":\n        # \'ce\' doesn\'t have the stdcall calling convention\n        _FUNCFLAG_STDCALL = _FUNCFLAG_CDECL\n\n    _win_functype_cache = {}\n    def WINFUNCTYPE(restype, *argtypes, **kw):\n        # docstring set later (very similar to CFUNCTYPE.__doc__)\n        flags = _FUNCFLAG_STDCALL\n        if kw.pop(""use_errno"", False):\n            flags |= _FUNCFLAG_USE_ERRNO\n        if kw.pop(""use_last_error"", False):\n            flags |= _FUNCFLAG_USE_LASTERROR\n        if kw:\n            raise ValueError(""unexpected keyword argument(s) %s"" % kw.keys())\n        try:\n            return _win_functype_cache[(restype, argtypes, flags)]\n        except KeyError:\n            class WinFunctionType(_CFuncPtr):\n                _argtypes_ = argtypes\n                _restype_ = restype\n                _flags_ = flags\n            _win_functype_cache[(restype, argtypes, flags)] = WinFunctionType\n            return WinFunctionType\n    if WINFUNCTYPE.__doc__:\n        WINFUNCTYPE.__doc__ = CFUNCTYPE.__doc__.replace(""CFUNCTYPE"", ""WINFUNCTYPE"")\n\nelif _os.name == ""posix"":\n    from _ctypes import dlopen as _dlopen\n\nfrom _ctypes import sizeof, byref, addressof, alignment, resize\nfrom _ctypes import get_errno, set_errno\nfrom _ctypes import _SimpleCData\n\ndef _check_size(typ, typecode=None):\n    # Check if sizeof(ctypes_type) against struct.calcsize.  This\n    # should protect somewhat against a misconfigured libffi.\n    from struct import calcsize\n    if typecode is None:\n        # Most _type_ codes are the same as used in struct\n        typecode = typ._type_\n    actual, required = sizeof(typ), calcsize(typecode)\n    if actual != required:\n        raise SystemError(""sizeof(%s) wrong: %d instead of %d"" % \\\n                          (typ, actual, required))\n\nclass py_object(_SimpleCData):\n    _type_ = ""O""\n    def __repr__(self):\n        try:\n            return super(py_object, self).__repr__()\n        except ValueError:\n            return ""%s(<NULL>)"" % type(self).__name__\n_check_size(py_object, ""P"")\n\nclass c_short(_SimpleCData):\n    _type_ = ""h""\n_check_size(c_short)\n\nclass c_ushort(_SimpleCData):\n    _type_ = ""H""\n_check_size(c_ushort)\n\nclass c_long(_SimpleCData):\n    _type_ = ""l""\n_check_size(c_long)\n\nclass c_ulong(_SimpleCData):\n    _type_ = ""L""\n_check_size(c_ulong)\n\nif _calcsize(""i"") == _calcsize(""l""):\n    # if int and long have the same size, make c_int an alias for c_long\n    c_int = c_long\n    c_uint = c_ulong\nelse:\n    class c_int(_SimpleCData):\n        _type_ = ""i""\n    _check_size(c_int)\n\n    class c_uint(_SimpleCData):\n        _type_ = ""I""\n    _check_size(c_uint)\n\nclass c_float(_SimpleCData):\n    _type_ = ""f""\n_check_size(c_float)\n\nclass c_double(_SimpleCData):\n    _type_ = ""d""\n_check_size(c_double)\n\nclass c_longdouble(_SimpleCData):\n    _type_ = ""g""\nif sizeof(c_longdouble) == sizeof(c_double):\n    c_longdouble = c_double\n\nif _calcsize(""l"") == _calcsize(""q""):\n    # if long and long long have the same size, make c_longlong an alias for c_long\n    c_longlong = c_long\n    c_ulonglong = c_ulong\nelse:\n    class c_longlong(_SimpleCData):\n        _type_ = ""q""\n    _check_size(c_longlong)\n\n    class c_ulonglong(_SimpleCData):\n        _type_ = ""Q""\n    ##    def from_param(cls, val):\n    ##        return (\'d\', float(val), val)\n    ##    from_param = classmethod(from_param)\n    _check_size(c_ulonglong)\n\nclass c_ubyte(_SimpleCData):\n    _type_ = ""B""\nc_ubyte.__ctype_le__ = c_ubyte.__ctype_be__ = c_ubyte\n# backward compatibility:\n##c_uchar = c_ubyte\n_check_size(c_ubyte)\n\nclass c_byte(_SimpleCData):\n    _type_ = ""b""\nc_byte.__ctype_le__ = c_byte.__ctype_be__ = c_byte\n_check_size(c_byte)\n\nclass c_char(_SimpleCData):\n    _type_ = ""c""\nc_char.__ctype_le__ = c_char.__ctype_be__ = c_char\n_check_size(c_char)\n\nclass c_char_p(_SimpleCData):\n    _type_ = ""z""\n    if _os.name == ""nt"":\n        def __repr__(self):\n            if not windll.kernel32.IsBadStringPtrA(self, -1):\n                return ""%s(%r)"" % (self.__class__.__name__, self.value)\n            return ""%s(%s)"" % (self.__class__.__name__, cast(self, c_void_p).value)\n    else:\n        def __repr__(self):\n            return ""%s(%s)"" % (self.__class__.__name__, cast(self, c_void_p).value)\n_check_size(c_char_p, ""P"")\n\nclass c_void_p(_SimpleCData):\n    _type_ = ""P""\nc_voidp = c_void_p # backwards compatibility (to a bug)\n_check_size(c_void_p)\n\nclass c_bool(_SimpleCData):\n    _type_ = ""?""\n\nfrom _ctypes import POINTER, pointer, _pointer_type_cache\n\ndef _reset_cache():\n    _pointer_type_cache.clear()\n    _c_functype_cache.clear()\n    if _os.name in (""nt"", ""ce""):\n        _win_functype_cache.clear()\n    # _SimpleCData.c_wchar_p_from_param\n    POINTER(c_wchar).from_param = c_wchar_p.from_param\n    # _SimpleCData.c_char_p_from_param\n    POINTER(c_char).from_param = c_char_p.from_param\n    _pointer_type_cache[None] = c_void_p\n\n    # XXX for whatever reasons, creating the first instance of a callback\n    # function is needed for the unittests on Win64 to succeed.  This MAY\n    # be a compiler bug, since the problem occurs only when _ctypes is\n    # compiled with the MS SDK compiler.  Or an uninitialized variable?\n    CFUNCTYPE(c_int)(lambda: None)\n\ntry:\n    from _ctypes import set_conversion_mode\nexcept ImportError:\n    pass\nelse:\n    if _os.name in (""nt"", ""ce""):\n        set_conversion_mode(""mbcs"", ""ignore"")\n    else:\n        set_conversion_mode(""ascii"", ""strict"")\n\n    class c_wchar_p(_SimpleCData):\n        _type_ = ""Z""\n\n    class c_wchar(_SimpleCData):\n        _type_ = ""u""\n\n    def create_unicode_buffer(init, size=None):\n        """"""create_unicode_buffer(aString) -> character array\n        create_unicode_buffer(anInteger) -> character array\n        create_unicode_buffer(aString, anInteger) -> character array\n        """"""\n        if isinstance(init, (str, unicode)):\n            if size is None:\n                size = len(init)+1\n            buftype = c_wchar * size\n            buf = buftype()\n            buf.value = init\n            return buf\n        elif isinstance(init, (int, long)):\n            buftype = c_wchar * init\n            buf = buftype()\n            return buf\n        raise TypeError(init)\n\n# XXX Deprecated\ndef SetPointerType(pointer, cls):\n    if _pointer_type_cache.get(cls, None) is not None:\n        raise RuntimeError(""This type already exists in the cache"")\n    if id(pointer) not in _pointer_type_cache:\n        raise RuntimeError(""What\'s this???"")\n    pointer.set_type(cls)\n    _pointer_type_cache[cls] = pointer\n    del _pointer_type_cache[id(pointer)]\n\n# XXX Deprecated\ndef ARRAY(typ, len):\n    return typ * len\n\n################################################################\n\nclass CDLL(object):\n    """"""An instance of this class represents a loaded dll/shared\n    library, exporting functions using the standard C calling\n    convention (named \'cdecl\' on Windows).\n\n    The exported functions can be accessed as attributes, or by\n    indexing with the function name.  Examples:\n\n    <obj>.qsort -> callable object\n    <obj>[\'qsort\'] -> callable object\n\n    Calling the functions releases the Python GIL during the call and\n    reacquires it afterwards.\n    """"""\n    _func_flags_ = _FUNCFLAG_CDECL\n    _func_restype_ = c_int\n\n    def __init__(self, name, mode=DEFAULT_MODE, handle=None,\n                 use_errno=False,\n                 use_last_error=False):\n        self._name = name\n        flags = self._func_flags_\n        if use_errno:\n            flags |= _FUNCFLAG_USE_ERRNO\n        if use_last_error:\n            flags |= _FUNCFLAG_USE_LASTERROR\n        class _FuncPtr(_CFuncPtr):\n            _flags_ = flags\n            _restype_ = self._func_restype_\n        self._FuncPtr = _FuncPtr\n        if handle is None:\n            self._handle = _dlopen(self._name, mode)\n        else:\n            self._handle = handle\n\n    def __repr__(self):\n        return ""<%s \'%s\', handle %x at %x>"" % \\\n               (self.__class__.__name__, self._name,\n                (self._handle & (_sys.maxint*2 + 1)),\n                id(self) & (_sys.maxint*2 + 1))\n\n    def __getattr__(self, name):\n        #print ""CDLL getattr: ""+str(name)\n        if name.startswith(\'__\') and name.endswith(\'__\'):\n            raise AttributeError(name)\n        func = self.__getitem__(name)\n        setattr(self, name, func)\n        return func\n\n    def __getitem__(self, name_or_ordinal):\n#         print self._FuncPtr\n#         print name_or_ordinal\n#         print self\n        tpl = (name_or_ordinal, self)\n#         print tpl\n        func = self._FuncPtr(tpl)\n        #if not isinstance(name_or_ordinal, (int, long)):\n        #    func.__name__ = name_or_ordinal\n        return func\n\nclass PyDLL(CDLL):\n    """"""This class represents the Python library itself.  It allows to\n    access Python API functions.  The GIL is not released, and\n    Python exceptions are handled correctly.\n    """"""\n    _func_flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI\n\nif _os.name in (""nt"", ""ce""):\n\n    class WinDLL(CDLL):\n        """"""This class represents a dll exporting functions using the\n        Windows stdcall calling convention.\n        """"""\n        _func_flags_ = _FUNCFLAG_STDCALL\n\n    # XXX Hm, what about HRESULT as normal parameter?\n    # Mustn\'t it derive from c_long then?\n    from _ctypes import _check_HRESULT, _SimpleCData\n    class HRESULT(_SimpleCData):\n        _type_ = ""l""\n        # _check_retval_ is called with the function\'s result when it\n        # is used as restype.  It checks for the FAILED bit, and\n        # raises a WindowsError if it is set.\n        #\n        # The _check_retval_ method is implemented in C, so that the\n        # method definition itself is not included in the traceback\n        # when it raises an error - that is what we want (and Python\n        # doesn\'t have a way to raise an exception in the caller\'s\n        # frame).\n        _check_retval_ = _check_HRESULT\n\n    class OleDLL(CDLL):\n        """"""This class represents a dll exporting functions using the\n        Windows stdcall calling convention, and returning HRESULT.\n        HRESULT error values are automatically raised as WindowsError\n        exceptions.\n        """"""\n        _func_flags_ = _FUNCFLAG_STDCALL\n        _func_restype_ = HRESULT\n\nclass LibraryLoader(object):\n    def __init__(self, dlltype):\n        self._dlltype = dlltype\n\n    def __getattr__(self, name):\n        #print ""LibraryLoader getattr: ""+str(name)\n        if name[0] == \'_\':\n            raise AttributeError(name)\n        dll = self._dlltype(name)\n        setattr(self, name, dll)\n        return dll\n\n    def __getitem__(self, name):\n        return getattr(self, name)\n\n    def LoadLibrary(self, name):\n        return self._dlltype(name)\n\ncdll = LibraryLoader(CDLL)\npydll = LibraryLoader(PyDLL)\n\nif _os.name in (""nt"", ""ce""):\n    pythonapi = PyDLL(""python dll"", None, _sys.dllhandle)\n# elif _sys.platform == ""cygwin"":\n#     pythonapi = PyDLL(""libpython%d.%d.dll"" % _sys.version_info[:2])\nelse:\n    # JyNI-Note:\n    # From dlopen man-page:\n    # If filename is NULL, then the returned handle is for the main program.\n    # Given that in JyNI-case the main-program is the Java-loader (or LiJy)\n    # this might need an adjustment, i.e. explicitly libJyNI.so as filename.\n    pythonapi = PyDLL(None)\n\n\nif _os.name in (""nt"", ""ce""):\n    windll = LibraryLoader(WinDLL)\n    oledll = LibraryLoader(OleDLL)\n\n    if _os.name == ""nt"":\n        GetLastError = windll.kernel32.GetLastError\n    else:\n        GetLastError = windll.coredll.GetLastError\n    from _ctypes import get_last_error, set_last_error\n\n    def WinError(code=None, descr=None):\n        if code is None:\n            code = GetLastError()\n        if descr is None:\n            descr = FormatError(code).strip()\n        return WindowsError(code, descr)\n\nif sizeof(c_uint) == sizeof(c_void_p):\n    c_size_t = c_uint\n    c_ssize_t = c_int\nelif sizeof(c_ulong) == sizeof(c_void_p):\n    c_size_t = c_ulong\n    c_ssize_t = c_long\nelif sizeof(c_ulonglong) == sizeof(c_void_p):\n    c_size_t = c_ulonglong\n    c_ssize_t = c_longlong\n\n# functions\n\nfrom _ctypes import _memmove_addr, _memset_addr, _string_at_addr, _cast_addr\n\n## void *memmove(void *, const void *, size_t);\nmemmove = CFUNCTYPE(c_void_p, c_void_p, c_void_p, c_size_t)(_memmove_addr)\n#JyNI-note: This line onwards appears to cut-down c-output\n#maybe it somehow crashes c-console\n\n## void *memset(void *, int, size_t)\nmemset = CFUNCTYPE(c_void_p, c_void_p, c_int, c_size_t)(_memset_addr)\n\ndef PYFUNCTYPE(restype, *argtypes):\n    class CFunctionType(_CFuncPtr):\n        _argtypes_ = argtypes\n        _restype_ = restype\n        _flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI\n    return CFunctionType\n\n_cast = PYFUNCTYPE(py_object, c_void_p, py_object, py_object)(_cast_addr)\ndef cast(obj, typ):\n    return _cast(obj, obj, typ)\n\n_string_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)\ndef string_at(ptr, size=-1):\n    """"""string_at(addr[, size]) -> string\n\n    Return the string at addr.""""""\n    return _string_at(ptr, size)\n\ntry:\n    from _ctypes import _wstring_at_addr\nexcept ImportError:\n    pass\nelse:\n    _wstring_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)\n    def wstring_at(ptr, size=-1):\n        """"""wstring_at(addr[, size]) -> string\n\n        Return the string at addr.""""""\n        return _wstring_at(ptr, size)\n\n\nif _os.name in (""nt"", ""ce""): # COM stuff\n    def DllGetClassObject(rclsid, riid, ppv):\n        try:\n            ccom = __import__(""comtypes.server.inprocserver"", globals(), locals(), [\'*\'])\n        except ImportError:\n            return -2147221231 # CLASS_E_CLASSNOTAVAILABLE\n        else:\n            return ccom.DllGetClassObject(rclsid, riid, ppv)\n\n    def DllCanUnloadNow():\n        try:\n            ccom = __import__(""comtypes.server.inprocserver"", globals(), locals(), [\'*\'])\n        except ImportError:\n            return 0 # S_OK\n        return ccom.DllCanUnloadNow()\n\nfrom ctypes._endian import BigEndianStructure, LittleEndianStructure\n\n# Fill in specifically-sized types\nc_int8 = c_byte\nc_uint8 = c_ubyte\n\nfor kind in [c_short, c_int, c_long, c_longlong]:\n    if sizeof(kind) == 2: c_int16 = kind\n    elif sizeof(kind) == 4: c_int32 = kind\n    elif sizeof(kind) == 8: c_int64 = kind\nfor kind in [c_ushort, c_uint, c_ulong, c_ulonglong]:\n    if sizeof(kind) == 2: c_uint16 = kind\n    elif sizeof(kind) == 4: c_uint32 = kind\n    elif sizeof(kind) == 8: c_uint64 = kind\ndel(kind)\n\n_reset_cache()\n#print ""ctypes __init__ done""\n'"
JyNI-Lib/ctypes/_endian.py,0,"b'#\n#  This File is based on ctypes/_endian.py from CPython 2.7.8.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n#  JyNI-Note: So far this file was actually not modified apart from adding\n#  this header. It is bundled with JyNI for convenience, such that ctypes\n#  can work out of the box.\n\n\n######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\nimport sys\nfrom ctypes import *\n\n_array_type = type(Array)\n\ndef _other_endian(typ):\n    """"""Return the type with the \'other\' byte order.  Simple types like\n    c_int and so on already have __ctype_be__ and __ctype_le__\n    attributes which contain the types, for more complicated types\n    arrays and structures are supported.\n    """"""\n    # check _OTHER_ENDIAN attribute (present if typ is primitive type)\n    if hasattr(typ, _OTHER_ENDIAN):\n        return getattr(typ, _OTHER_ENDIAN)\n    # if typ is array\n    if isinstance(typ, _array_type):\n        return _other_endian(typ._type_) * typ._length_\n    # if typ is structure\n    if issubclass(typ, Structure):\n        return typ\n    raise TypeError(""This type does not support other endian: %s"" % typ)\n\nclass _swapped_meta(type(Structure)):\n    def __setattr__(self, attrname, value):\n        if attrname == ""_fields_"":\n            fields = []\n            for desc in value:\n                name = desc[0]\n                typ = desc[1]\n                rest = desc[2:]\n                fields.append((name, _other_endian(typ)) + rest)\n            value = fields\n        super(_swapped_meta, self).__setattr__(attrname, value)\n\n################################################################\n\n# Note: The Structure metaclass checks for the *presence* (not the\n# value!) of a _swapped_bytes_ attribute to determine the bit order in\n# structures containing bit fields.\n\nif sys.byteorder == ""little"":\n    _OTHER_ENDIAN = ""__ctype_be__""\n\n    LittleEndianStructure = Structure\n\n    class BigEndianStructure(Structure):\n        """"""Structure with big endian byte order""""""\n        __metaclass__ = _swapped_meta\n        _swappedbytes_ = None\n\nelif sys.byteorder == ""big"":\n    _OTHER_ENDIAN = ""__ctype_le__""\n\n    BigEndianStructure = Structure\n\n    class LittleEndianStructure(Structure):\n        """"""Structure with little endian byte order""""""\n        __metaclass__ = _swapped_meta\n        _swappedbytes_ = None\n\nelse:\n    raise RuntimeError(""Invalid byteorder"")\n\n'"
JyNI-Lib/ctypes/util.py,0,"b'#\n#  This File is based on ctypes/util.py from CPython 2.7.8.\n#  It is bundled with JyNI for convenience.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n#  JyNI-Note: So far this file was actually not modified apart from adding\n#  this header. It is bundled with JyNI for convenience, such that ctypes\n#  can work out of the box.\n\n\n######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\nimport sys, os\n\nisPosix = os.name == ""posix""\nif os.name == ""java"":\n    from JyNI import JyNI\n    isPosix = JyNI.isPosix()\n\n# find_library(name) returns the pathname of a library, or None.\nif os.name == ""nt"":\n\n    def _get_build_version():\n        """"""Return the version of MSVC that was used to build Python.\n\n        For Python 2.3 and up, the version number is included in\n        sys.version.  For earlier versions, assume the compiler is MSVC 6.\n        """"""\n        # This function was copied from Lib/distutils/msvccompiler.py\n        prefix = ""MSC v.""\n        i = sys.version.find(prefix)\n        if i == -1:\n            return 6\n        i = i + len(prefix)\n        s, rest = sys.version[i:].split("" "", 1)\n        majorVersion = int(s[:-2]) - 6\n        minorVersion = int(s[2:3]) / 10.0\n        # I don\'t think paths are affected by minor version in version 6\n        if majorVersion == 6:\n            minorVersion = 0\n        if majorVersion >= 6:\n            return majorVersion + minorVersion\n        # else we don\'t know what version of the compiler this is\n        return None\n\n    def find_msvcrt():\n        """"""Return the name of the VC runtime dll""""""\n        version = _get_build_version()\n        if version is None:\n            # better be safe than sorry\n            return None\n        if version <= 6:\n            clibname = \'msvcrt\'\n        else:\n            clibname = \'msvcr%d\' % (version * 10)\n\n        # If python was built with in debug mode\n        import imp\n        if imp.get_suffixes()[0][0] == \'_d.pyd\':\n            clibname += \'d\'\n        return clibname+\'.dll\'\n\n    def find_library(name):\n        if name in (\'c\', \'m\'):\n            return find_msvcrt()\n        # See MSDN for the REAL search order.\n        for directory in os.environ[\'PATH\'].split(os.pathsep):\n            fname = os.path.join(directory, name)\n            if os.path.isfile(fname):\n                return fname\n            if fname.lower().endswith("".dll""):\n                continue\n            fname = fname + "".dll""\n            if os.path.isfile(fname):\n                return fname\n        return None\n\nif os.name == ""ce"":\n    # search path according to MSDN:\n    # - absolute path specified by filename\n    # - The .exe launch directory\n    # - the Windows directory\n    # - ROM dll files (where are they?)\n    # - OEM specified search path: HKLM\\Loader\\SystemPath\n    def find_library(name):\n        return name\n\nif isPosix and sys.platform == ""darwin"":\n    from ctypes.macholib.dyld import dyld_find as _dyld_find\n    def find_library(name):\n        possible = [\'lib%s.dylib\' % name,\n                    \'%s.dylib\' % name,\n                    \'%s.framework/%s\' % (name, name)]\n        for name in possible:\n            try:\n                return _dyld_find(name)\n            except ValueError:\n                continue\n        return None\n\nelif isPosix:\n    # Andreas Degert\'s find functions, using gcc, /sbin/ldconfig, objdump\n    import re, tempfile, errno\n\n    def _findLib_gcc(name):\n        expr = r\'[^\\(\\)\\s]*lib%s\\.[^\\(\\)\\s]*\' % re.escape(name)\n        fdout, ccout = tempfile.mkstemp()\n        os.close(fdout)\n        cmd = \'if type gcc >/dev/null 2>&1; then CC=gcc; elif type cc >/dev/null 2>&1; then CC=cc;else exit 10; fi;\' \\\n              \'$CC -Wl,-t -o \' + ccout + \' 2>&1 -l\' + name\n        try:\n            f = os.popen(cmd)\n            try:\n                trace = f.read()\n            finally:\n                rv = f.close()\n        finally:\n            try:\n                os.unlink(ccout)\n            except OSError, e:\n                if e.errno != errno.ENOENT:\n                    raise\n        if rv == 10:\n            raise OSError, \'gcc or cc command not found\'\n        res = re.search(expr, trace)\n        if not res:\n            return None\n        return res.group(0)\n\n\n    if sys.platform == ""sunos5"":\n        # use /usr/ccs/bin/dump on solaris\n        def _get_soname(f):\n            if not f:\n                return None\n            cmd = ""/usr/ccs/bin/dump -Lpv 2>/dev/null "" + f\n            f = os.popen(cmd)\n            try:\n                data = f.read()\n            finally:\n                f.close()\n            res = re.search(r\'\\[.*\\]\\sSONAME\\s+([^\\s]+)\', data)\n            if not res:\n                return None\n            return res.group(1)\n    else:\n        def _get_soname(f):\n            # assuming GNU binutils / ELF\n            if not f:\n                return None\n            cmd = \'if ! type objdump >/dev/null 2>&1; then exit 10; fi;\' \\\n                  ""objdump -p -j .dynamic 2>/dev/null "" + f\n            f = os.popen(cmd)\n            dump = f.read()\n            rv = f.close()\n            if rv == 10:\n                raise OSError, \'objdump command not found\'\n            f = os.popen(cmd)\n            try:\n                data = f.read()\n            finally:\n                f.close()\n            res = re.search(r\'\\sSONAME\\s+([^\\s]+)\', data)\n            if not res:\n                return None\n            return res.group(1)\n\n    if (sys.platform.startswith(""freebsd"")\n        or sys.platform.startswith(""openbsd"")\n        or sys.platform.startswith(""dragonfly"")):\n\n        def _num_version(libname):\n            # ""libxyz.so.MAJOR.MINOR"" => [ MAJOR, MINOR ]\n            parts = libname.split(""."")\n            nums = []\n            try:\n                while parts:\n                    nums.insert(0, int(parts.pop()))\n            except ValueError:\n                pass\n            return nums or [ sys.maxint ]\n\n        def find_library(name):\n            ename = re.escape(name)\n            expr = r\':-l%s\\.\\S+ => \\S*/(lib%s\\.\\S+)\' % (ename, ename)\n            f = os.popen(\'/sbin/ldconfig -r 2>/dev/null\')\n            try:\n                data = f.read()\n            finally:\n                f.close()\n            res = re.findall(expr, data)\n            if not res:\n                return _get_soname(_findLib_gcc(name))\n            res.sort(cmp= lambda x,y: cmp(_num_version(x), _num_version(y)))\n            return res[-1]\n\n    elif sys.platform == ""sunos5"":\n\n        def _findLib_crle(name, is64):\n            if not os.path.exists(\'/usr/bin/crle\'):\n                return None\n\n            if is64:\n                cmd = \'env LC_ALL=C /usr/bin/crle -64 2>/dev/null\'\n            else:\n                cmd = \'env LC_ALL=C /usr/bin/crle 2>/dev/null\'\n\n            for line in os.popen(cmd).readlines():\n                line = line.strip()\n                if line.startswith(\'Default Library Path (ELF):\'):\n                    paths = line.split()[4]\n\n            if not paths:\n                return None\n\n            for dir in paths.split("":""):\n                libfile = os.path.join(dir, ""lib%s.so"" % name)\n                if os.path.exists(libfile):\n                    return libfile\n\n            return None\n\n        def find_library(name, is64 = False):\n            return _get_soname(_findLib_crle(name, is64) or _findLib_gcc(name))\n\n    else:\n\n        def _findSoname_ldconfig(name):\n            import struct\n            if struct.calcsize(\'l\') == 4:\n                machine = os.uname()[4] + \'-32\'\n            else:\n                machine = os.uname()[4] + \'-64\'\n            mach_map = {\n                \'x86_64-64\': \'libc6,x86-64\',\n                \'ppc64-64\': \'libc6,64bit\',\n                \'sparc64-64\': \'libc6,64bit\',\n                \'s390x-64\': \'libc6,64bit\',\n                \'ia64-64\': \'libc6,IA-64\',\n                }\n            abi_type = mach_map.get(machine, \'libc6\')\n\n            # XXX assuming GLIBC\'s ldconfig (with option -p)\n            expr = r\'\\s+(lib%s\\.[^\\s]+)\\s+\\(%s\' % (re.escape(name), abi_type)\n            f = os.popen(\'/sbin/ldconfig -p 2>/dev/null\')\n            try:\n                data = f.read()\n            finally:\n                f.close()\n            res = re.search(expr, data)\n            if not res:\n                return None\n            return res.group(1)\n\n        def find_library(name):\n            return _findSoname_ldconfig(name) or _get_soname(_findLib_gcc(name))\n\n################################################################\n# test code\n\ndef test():\n    from ctypes import cdll\n    if os.name == ""nt"":\n        print cdll.msvcrt\n        print cdll.load(""msvcrt"")\n        print find_library(""msvcrt"")\n\n    if isPosix:\n        # find and load_version\n        print find_library(""m"")\n        print find_library(""c"")\n        print find_library(""bz2"")\n\n        # getattr\n##        print cdll.m\n##        print cdll.bz2\n\n        # load\n        if sys.platform == ""darwin"":\n            print cdll.LoadLibrary(""libm.dylib"")\n            print cdll.LoadLibrary(""libcrypto.dylib"")\n            print cdll.LoadLibrary(""libSystem.dylib"")\n            print cdll.LoadLibrary(""System.framework/System"")\n        else:\n            print cdll.LoadLibrary(""libm.so"")\n            print cdll.LoadLibrary(""libcrypt.so"")\n            print find_library(""crypt"")\n\nif __name__ == ""__main__"":\n    test()\n'"
JyNI-Lib/sqlite3/__init__.py,0,"b""#-*- coding: ISO-8859-1 -*-\n#\n#  This File is based on sqlite3/__init__.py from CPython 2.7.9.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n# pysqlite2/__init__.py: the pysqlite2 package.\n#\n# Copyright (C) 2005 Gerhard H\xc3\xa4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided 'as-is', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\n\n# JyNI-adjustment:\n# Usually Jython does not have lib-dynload on its path, so ensure it here\nimport config_util\nconfig_util.autoconfig_dynload_path()\n# lib_dynload = '/usr/lib/python2.7/lib-dynload'\n# #lib_dynload = '/data/workspace/linux/Python-2.7.11/build/lib.linux-x86_64-2.7'\n# import sys\n# if not lib_dynload in sys.path:\n#     sys.path.append(lib_dynload)\n\nfrom dbapi2 import *\n"""
JyNI-Lib/sqlite3/dbapi2.py,0,"b'# -*- coding: iso-8859-1 -*-\n#\n#  This File is based on sqlite3/dbapi2.py from CPython 2.7.9.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n# pysqlite2/dbapi2.py: the DB-API 2.0 interface\n#\n# Copyright (C) 2004-2005 Gerhard H\xc3\xa4ring <gh@ghaering.de>\n#\n# This file is part of pysqlite.\n#\n# This software is provided \'as-is\', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\nimport collections\nimport datetime\nimport time\n\nfrom _sqlite3 import *\n\nparamstyle = ""qmark""\n\nthreadsafety = 1\n\napilevel = ""2.0""\n\nDate = datetime.date\n\nTime = datetime.time\n\nTimestamp = datetime.datetime\n\ndef DateFromTicks(ticks):\n    return Date(*time.localtime(ticks)[:3])\n\ndef TimeFromTicks(ticks):\n    return Time(*time.localtime(ticks)[3:6])\n\ndef TimestampFromTicks(ticks):\n    return Timestamp(*time.localtime(ticks)[:6])\n\nversion_info = tuple([int(x) for x in version.split(""."")])\nsqlite_version_info = tuple([int(x) for x in sqlite_version.split(""."")])\n\nBinary = buffer\ncollections.Sequence.register(Row)\n\ndef register_adapters_and_converters():\n    def adapt_date(val):\n        return val.isoformat()\n\n    def adapt_datetime(val):\n        return val.isoformat("" "")\n\n    def convert_date(val):\n        return datetime.date(*map(int, val.split(""-"")))\n\n    def convert_timestamp(val):\n        datepart, timepart = val.split("" "")\n        year, month, day = map(int, datepart.split(""-""))\n        timepart_full = timepart.split(""."")\n        hours, minutes, seconds = map(int, timepart_full[0].split("":""))\n        if len(timepart_full) == 2:\n            microseconds = int(\'{:0<6.6}\'.format(timepart_full[1].decode()))\n        else:\n            microseconds = 0\n\n        val = datetime.datetime(year, month, day, hours, minutes, seconds, microseconds)\n        return val\n\n\n    register_adapter(datetime.date, adapt_date)\n    register_adapter(datetime.datetime, adapt_datetime)\n    register_converter(""date"", convert_date)\n    register_converter(""timestamp"", convert_timestamp)\n\nregister_adapters_and_converters()\n\n# Clean up namespace\n\ndel(register_adapters_and_converters)\n'"
JyNI-Lib/sqlite3/dump.py,0,"b'#\n#  This File is based on sqlite3/dump.py from CPython 2.7.9.\n#  It has been modified to suit JyNI needs.\n#\n#  Copyright of JyNI:\n#  Copyright (c) 2013, 2014, 2015, 2016, 2017 Stefan Richthofer.\n#  All rights reserved.\n#\n#\n#  Copyright of Python and Jython:\n#  Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n#  2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017\n#  Python Software Foundation.\n#  All rights reserved.\n#\n#\n#  This file is part of JyNI.\n#\n#  JyNI is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of\n#  the License, or (at your option) any later version.\n#\n#  JyNI is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with JyNI.  If not, see <http://www.gnu.org/licenses/>.\n\n\n# Mimic the sqlite3 console shell\'s .dump command\n# Author: Paul Kippes <kippesp@gmail.com>\n\n# Every identifier in sql is quoted based on a comment in sqlite\n# documentation ""SQLite adds new keywords from time to time when it\n# takes on new features. So to prevent your code from being broken by\n# future enhancements, you should normally quote any identifier that\n# is an English language word, even if you do not have to.""\n\ndef _iterdump(connection):\n    """"""\n    Returns an iterator to the dump of the database in an SQL text format.\n\n    Used to produce an SQL dump of the database.  Useful to save an in-memory\n    database for later restoration.  This function should not be called\n    directly but instead called from the Connection method, iterdump().\n    """"""\n\n    cu = connection.cursor()\n    yield(\'BEGIN TRANSACTION;\')\n\n    # sqlite_master table contains the SQL CREATE statements for the database.\n    q = """"""\n        SELECT ""name"", ""type"", ""sql""\n        FROM ""sqlite_master""\n            WHERE ""sql"" NOT NULL AND\n            ""type"" == \'table\'\n            ORDER BY ""name""\n        """"""\n    schema_res = cu.execute(q)\n    for table_name, type, sql in schema_res.fetchall():\n        if table_name == \'sqlite_sequence\':\n            yield(\'DELETE FROM ""sqlite_sequence"";\')\n        elif table_name == \'sqlite_stat1\':\n            yield(\'ANALYZE ""sqlite_master"";\')\n        elif table_name.startswith(\'sqlite_\'):\n            continue\n        # NOTE: Virtual table support not implemented\n        #elif sql.startswith(\'CREATE VIRTUAL TABLE\'):\n        #    qtable = table_name.replace(""\'"", ""\'\'"")\n        #    yield(""INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)""\\\n        #        ""VALUES(\'table\',\'{0}\',\'{0}\',0,\'{1}\');"".format(\n        #        qtable,\n        #        sql.replace(""\'\'"")))\n        else:\n            yield(\'%s;\' % sql)\n\n        # Build the insert statement for each row of the current table\n        table_name_ident = table_name.replace(\'""\', \'""""\')\n        res = cu.execute(\'PRAGMA table_info(""{0}"")\'.format(table_name_ident))\n        column_names = [str(table_info[1]) for table_info in res.fetchall()]\n        q = """"""SELECT \'INSERT INTO ""{0}"" VALUES({1})\' FROM ""{0}"";"""""".format(\n            table_name_ident,\n            "","".join(""""""\'||quote(""{0}"")||\'"""""".format(col.replace(\'""\', \'""""\')) for col in column_names))\n        query_res = cu.execute(q)\n        for row in query_res:\n            yield(""%s;"" % row[0])\n\n    # Now when the type is \'index\', \'trigger\', or \'view\'\n    q = """"""\n        SELECT ""name"", ""type"", ""sql""\n        FROM ""sqlite_master""\n            WHERE ""sql"" NOT NULL AND\n            ""type"" IN (\'index\', \'trigger\', \'view\')\n        """"""\n    schema_res = cu.execute(q)\n    for name, type, sql in schema_res.fetchall():\n        yield(\'%s;\' % sql)\n\n    yield(\'COMMIT;\')\n'"
JyNI-Lib/ctypes/macholib/__init__.py,0,"b'######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\n""""""\nEnough Mach-O to make your head spin.\n\nSee the relevant header files in /usr/include/mach-o\n\nAnd also Apple\'s documentation.\n""""""\n\n__version__ = \'1.0\'\n'"
JyNI-Lib/ctypes/macholib/dyld.py,0,"b'######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\n""""""\ndyld emulation\n""""""\n\nimport os\nfrom framework import framework_info\nfrom dylib import dylib_info\nfrom itertools import *\n\n__all__ = [\n    \'dyld_find\', \'framework_find\',\n    \'framework_info\', \'dylib_info\',\n]\n\n# These are the defaults as per man dyld(1)\n#\nDEFAULT_FRAMEWORK_FALLBACK = [\n    os.path.expanduser(""~/Library/Frameworks""),\n    ""/Library/Frameworks"",\n    ""/Network/Library/Frameworks"",\n    ""/System/Library/Frameworks"",\n]\n\nDEFAULT_LIBRARY_FALLBACK = [\n    os.path.expanduser(""~/lib""),\n    ""/usr/local/lib"",\n    ""/lib"",\n    ""/usr/lib"",\n]\n\ndef ensure_utf8(s):\n    """"""Not all of PyObjC and Python understand unicode paths very well yet""""""\n    if isinstance(s, unicode):\n        return s.encode(\'utf8\')\n    return s\n\ndef dyld_env(env, var):\n    if env is None:\n        env = os.environ\n    rval = env.get(var)\n    if rval is None:\n        return []\n    return rval.split(\':\')\n\ndef dyld_image_suffix(env=None):\n    if env is None:\n        env = os.environ\n    return env.get(\'DYLD_IMAGE_SUFFIX\')\n\ndef dyld_framework_path(env=None):\n    return dyld_env(env, \'DYLD_FRAMEWORK_PATH\')\n\ndef dyld_library_path(env=None):\n    return dyld_env(env, \'DYLD_LIBRARY_PATH\')\n\ndef dyld_fallback_framework_path(env=None):\n    return dyld_env(env, \'DYLD_FALLBACK_FRAMEWORK_PATH\')\n\ndef dyld_fallback_library_path(env=None):\n    return dyld_env(env, \'DYLD_FALLBACK_LIBRARY_PATH\')\n\ndef dyld_image_suffix_search(iterator, env=None):\n    """"""For a potential path iterator, add DYLD_IMAGE_SUFFIX semantics""""""\n    suffix = dyld_image_suffix(env)\n    if suffix is None:\n        return iterator\n    def _inject(iterator=iterator, suffix=suffix):\n        for path in iterator:\n            if path.endswith(\'.dylib\'):\n                yield path[:-len(\'.dylib\')] + suffix + \'.dylib\'\n            else:\n                yield path + suffix\n            yield path\n    return _inject()\n\ndef dyld_override_search(name, env=None):\n    # If DYLD_FRAMEWORK_PATH is set and this dylib_name is a\n    # framework name, use the first file that exists in the framework\n    # path if any.  If there is none go on to search the DYLD_LIBRARY_PATH\n    # if any.\n\n    framework = framework_info(name)\n\n    if framework is not None:\n        for path in dyld_framework_path(env):\n            yield os.path.join(path, framework[\'name\'])\n\n    # If DYLD_LIBRARY_PATH is set then use the first file that exists\n    # in the path.  If none use the original name.\n    for path in dyld_library_path(env):\n        yield os.path.join(path, os.path.basename(name))\n\ndef dyld_executable_path_search(name, executable_path=None):\n    # If we haven\'t done any searching and found a library and the\n    # dylib_name starts with ""@executable_path/"" then construct the\n    # library name.\n    if name.startswith(\'@executable_path/\') and executable_path is not None:\n        yield os.path.join(executable_path, name[len(\'@executable_path/\'):])\n\ndef dyld_default_search(name, env=None):\n    yield name\n\n    framework = framework_info(name)\n\n    if framework is not None:\n        fallback_framework_path = dyld_fallback_framework_path(env)\n        for path in fallback_framework_path:\n            yield os.path.join(path, framework[\'name\'])\n\n    fallback_library_path = dyld_fallback_library_path(env)\n    for path in fallback_library_path:\n        yield os.path.join(path, os.path.basename(name))\n\n    if framework is not None and not fallback_framework_path:\n        for path in DEFAULT_FRAMEWORK_FALLBACK:\n            yield os.path.join(path, framework[\'name\'])\n\n    if not fallback_library_path:\n        for path in DEFAULT_LIBRARY_FALLBACK:\n            yield os.path.join(path, os.path.basename(name))\n\ndef dyld_find(name, executable_path=None, env=None):\n    """"""\n    Find a library or framework using dyld semantics\n    """"""\n    name = ensure_utf8(name)\n    executable_path = ensure_utf8(executable_path)\n    for path in dyld_image_suffix_search(chain(\n                dyld_override_search(name, env),\n                dyld_executable_path_search(name, executable_path),\n                dyld_default_search(name, env),\n            ), env):\n        if os.path.isfile(path):\n            return path\n    raise ValueError(""dylib %s could not be found"" % (name,))\n\ndef framework_find(fn, executable_path=None, env=None):\n    """"""\n    Find a framework using dyld semantics in a very loose manner.\n\n    Will take input such as:\n        Python\n        Python.framework\n        Python.framework/Versions/Current\n    """"""\n    try:\n        return dyld_find(fn, executable_path=executable_path, env=env)\n    except ValueError, e:\n        pass\n    fmwk_index = fn.rfind(\'.framework\')\n    if fmwk_index == -1:\n        fmwk_index = len(fn)\n        fn += \'.framework\'\n    fn = os.path.join(fn, os.path.basename(fn[:fmwk_index]))\n    try:\n        return dyld_find(fn, executable_path=executable_path, env=env)\n    except ValueError:\n        raise e\n\ndef test_dyld_find():\n    env = {}\n    assert dyld_find(\'libSystem.dylib\') == \'/usr/lib/libSystem.dylib\'\n    assert dyld_find(\'System.framework/System\') == \'/System/Library/Frameworks/System.framework/System\'\n\nif __name__ == \'__main__\':\n    test_dyld_find()\n'"
JyNI-Lib/ctypes/macholib/dylib.py,0,"b'######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\n""""""\nGeneric dylib path manipulation\n""""""\n\nimport re\n\n__all__ = [\'dylib_info\']\n\nDYLIB_RE = re.compile(r""""""(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+?)\n    (?:\\.(?P<version>[^._]+))?\n    (?:_(?P<suffix>[^._]+))?\n    \\.dylib$\n)\n"""""")\n\ndef dylib_info(filename):\n    """"""\n    A dylib name can take one of the following four forms:\n        Location/Name.SomeVersion_Suffix.dylib\n        Location/Name.SomeVersion.dylib\n        Location/Name_Suffix.dylib\n        Location/Name.dylib\n\n    returns None if not found or a mapping equivalent to:\n        dict(\n            location=\'Location\',\n            name=\'Name.SomeVersion_Suffix.dylib\',\n            shortname=\'Name\',\n            version=\'SomeVersion\',\n            suffix=\'Suffix\',\n        )\n\n    Note that SomeVersion and Suffix are optional and may be None\n    if not present.\n    """"""\n    is_dylib = DYLIB_RE.match(filename)\n    if not is_dylib:\n        return None\n    return is_dylib.groupdict()\n\n\ndef test_dylib_info():\n    def d(location=None, name=None, shortname=None, version=None, suffix=None):\n        return dict(\n            location=location,\n            name=name,\n            shortname=shortname,\n            version=version,\n            suffix=suffix\n        )\n    assert dylib_info(\'completely/invalid\') is None\n    assert dylib_info(\'completely/invalide_debug\') is None\n    assert dylib_info(\'P/Foo.dylib\') == d(\'P\', \'Foo.dylib\', \'Foo\')\n    assert dylib_info(\'P/Foo_debug.dylib\') == d(\'P\', \'Foo_debug.dylib\', \'Foo\', suffix=\'debug\')\n    assert dylib_info(\'P/Foo.A.dylib\') == d(\'P\', \'Foo.A.dylib\', \'Foo\', \'A\')\n    assert dylib_info(\'P/Foo_debug.A.dylib\') == d(\'P\', \'Foo_debug.A.dylib\', \'Foo_debug\', \'A\')\n    assert dylib_info(\'P/Foo.A_debug.dylib\') == d(\'P\', \'Foo.A_debug.dylib\', \'Foo\', \'A\', \'debug\')\n\nif __name__ == \'__main__\':\n    test_dylib_info()\n'"
JyNI-Lib/ctypes/macholib/framework.py,0,"b'######################################################################\n#  This file should be kept compatible with Python 2.3, see PEP 291. #\n######################################################################\n""""""\nGeneric framework path manipulation\n""""""\n\nimport re\n\n__all__ = [\'framework_info\']\n\nSTRICT_FRAMEWORK_RE = re.compile(r""""""(?x)\n(?P<location>^.*)(?:^|/)\n(?P<name>\n    (?P<shortname>\\w+).framework/\n    (?:Versions/(?P<version>[^/]+)/)?\n    (?P=shortname)\n    (?:_(?P<suffix>[^_]+))?\n)$\n"""""")\n\ndef framework_info(filename):\n    """"""\n    A framework name can take one of the following four forms:\n        Location/Name.framework/Versions/SomeVersion/Name_Suffix\n        Location/Name.framework/Versions/SomeVersion/Name\n        Location/Name.framework/Name_Suffix\n        Location/Name.framework/Name\n\n    returns None if not found, or a mapping equivalent to:\n        dict(\n            location=\'Location\',\n            name=\'Name.framework/Versions/SomeVersion/Name_Suffix\',\n            shortname=\'Name\',\n            version=\'SomeVersion\',\n            suffix=\'Suffix\',\n        )\n\n    Note that SomeVersion and Suffix are optional and may be None\n    if not present\n    """"""\n    is_framework = STRICT_FRAMEWORK_RE.match(filename)\n    if not is_framework:\n        return None\n    return is_framework.groupdict()\n\ndef test_framework_info():\n    def d(location=None, name=None, shortname=None, version=None, suffix=None):\n        return dict(\n            location=location,\n            name=name,\n            shortname=shortname,\n            version=version,\n            suffix=suffix\n        )\n    assert framework_info(\'completely/invalid\') is None\n    assert framework_info(\'completely/invalid/_debug\') is None\n    assert framework_info(\'P/F.framework\') is None\n    assert framework_info(\'P/F.framework/_debug\') is None\n    assert framework_info(\'P/F.framework/F\') == d(\'P\', \'F.framework/F\', \'F\')\n    assert framework_info(\'P/F.framework/F_debug\') == d(\'P\', \'F.framework/F_debug\', \'F\', suffix=\'debug\')\n    assert framework_info(\'P/F.framework/Versions\') is None\n    assert framework_info(\'P/F.framework/Versions/A\') is None\n    assert framework_info(\'P/F.framework/Versions/A/F\') == d(\'P\', \'F.framework/Versions/A/F\', \'F\', \'A\')\n    assert framework_info(\'P/F.framework/Versions/A/F_debug\') == d(\'P\', \'F.framework/Versions/A/F_debug\', \'F\', \'A\', \'debug\')\n\nif __name__ == \'__main__\':\n    test_framework_info()\n'"
