file_path,api_count,code
pv_tk.py,0,"b'#! python\n# -*- coding: utf-8 -*-\n\n""""""\nCreated on Jul 29, 2012\n\n@author: marko\n""""""\nfrom pvmismatch.pvmismatch_tk.pvapplication_tk import PVapplicaton\nfrom Tkinter import Tk\nimport sys\nimport re\n\n\ndef showHelpError(argvs_):\n    help(Tk.geometry)\n    errMsg = \'Invalid geometry format.\\n\'\n    errMsg = errMsg + \'""{}""\\n\'.format(argvs_)\n    errMsg = errMsg + \'is not valid. See ""wm_geometry help"" above.\'\n    raise Exception(errMsg)\n\nif __name__ == ""__main__"":\n    nargv = len(sys.argv)  # number of user arguments\n    argvs = sys.argv[1:]  # will be empty if only sys.argv[0]\n    if argvs:\n        argv1 = sys.argv[1]\n        # test if input is \'home\',\'reset\',\'WxH+/-X+/-Y\' or \'WxH\'\n        if nargv == 2:  # and type(argv1) is str:\n            # try any custom geometry e.g. (\'home\', \'reset\')\n            if argv1 == \'home\':\n                dims = \'835x655\'  # custom setting for my home laptop\n            elif argv1 in ["""", \'reset\']:\n                dims = """"  # reset the geometry\n            else:\n                # try regular expressions for \'WxH+/-X+/-Y\' or \'WxH\'\n                dims = re.findall(\'\\d+x\\d+[+-]\\d+[+-]\\d+\', argv1)\n                # dims will be empty if nothing found\n                if not dims:\n                    dims = re.findall(\'\\d+x\\d+\', argv1)\n                # still nothing, or too much, or extra crap\n                if not dims or len(dims) > 1 or len(dims[0]) != len(argv1):\n                    showHelpError(argvs)\n                # found it, get string from list, should be only one\n                else:\n                    dims = dims[0]\n        # test if input is (W, H)\n        elif nargv in [3, 5]:\n            try:\n                argvs = [int(argv) for argv in argvs]\n            except ValueError:\n                showHelpError(argvs)\n            if nargv == 3:\n                dims = ""{}x{}"".format(*argvs)  # IGNORE:W0142\n            if nargv == 5:\n                dims = ""{}x{}{:+d}{:+d}"".format(*argvs)  # IGNORE:W0142\n        else:\n            showHelpError(argvs)\n    else:\n        dims = None\n    if dims is not None:\n        dim_reset_or_dims = lambda dims: (not dims) * \'reset\' + dims\n        print ""dimensions: {}"".format(dim_reset_or_dims(dims))\n    root = Tk()\n    app = PVapplicaton(root)\n    root.geometry(dims)\n    app.mainloop()\n    # matplotlib must implement destroy in mainloop\n'"
setup.py,0,"b""__author__ = 'mmikofski'\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\nfrom pvmismatch import __version__, __name__, __email__, __url__\nimport os\n\nREADME = 'README.rst'\ntry:\n    with open(os.path.join(os.path.dirname(__file__), README), 'r') as readme:\n        README = readme.read()\nexcept IOError:\n    pass\n\nINSTALL_REQUIRES = [\n    'numpy>=1.13.3', 'matplotlib>=2.1.0', 'scipy>=1.0.0', 'future>=0.16.0',\n    'six>=1.11.0'\n]\n\nTESTS_REQUIRES = [\n    'nose>=1.3.7', 'pytest>=3.2.1', 'sympy>=1.1.1', 'pvlib>=0.5.1'\n]\n\nCLASSIFIERS = [\n    'Development Status :: 4 - Beta',\n    'License :: OSI Approved :: BSD License',\n    'Operating System :: OS Independent',\n    'Intended Audience :: Science/Research',\n    'Programming Language :: Python',\n    'Programming Language :: Python :: 2',\n    'Programming Language :: Python :: 2.7',\n    'Programming Language :: Python :: 3',\n    'Programming Language :: Python :: 3.3',\n    'Programming Language :: Python :: 3.4',\n    'Programming Language :: Python :: 3.5',\n    'Programming Language :: Python :: 3.6',\n    'Topic :: Scientific/Engineering',\n]\n\nsetup(\n    name=__name__,\n    version=__version__,\n    description='PV Mismatch Calculator',\n    long_description=README,\n    author=__author__,\n    author_email=__email__,\n    url=__url__,\n    license='BSD 3-clause',\n    packages=[\n        'pvmismatch', 'pvmismatch.pvmismatch_lib',\n        'pvmismatch.pvmismatch_tk', 'pvmismatch.contrib',\n        'pvmismatch.contrib.gen_coeffs'\n    ],\n    install_requires=INSTALL_REQUIRES,\n    tests_require=TESTS_REQUIRES,\n    scripts=['pv_tk.py'],\n    package_data={\n        'pvmismatch': [\n            'pvmismatch_json/messagetext.English.json',\n            'pvmismatch_json/validationConstants.json',\n            'res/logo.png', 'res/logo_invert.png',\n            'res/logo_bg.png', 'docs/conf.py', 'docs/*.rst',\n            'docs/Makefile', 'docs/make.bat'\n        ]\n    },\n    classifiers=CLASSIFIERS\n)\n"""
pvmismatch/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nThis is the PVMismatch Package. It contains :mod:`~pvmismatch.pvmismatch_lib`\nand :mod:`~pvmismatch.pvmismatch_tk`.\n\n:mod:`~pvmismatch.pvmismatch_lib`\n=================================\nThis package contains the basic library modules, methods, classes and\nattributes to model PV system mismatch.\n\n.. note::\n   The main library classes and modules are exposed through this package for\n   convenience.\n\n   For example::\n\n       >>> from pvmismatch import PVcell  # imports the PVcell class\n       >>> # import pvconstants, pvcell, pvmodule, pvstring and pvsystem\n       >>> from pvmismatch import *\n\n:mod:`~pvmismatch.pvmismatch_tk`\n================================\nThis package contains an application that can be run using\n:mod:`pvmismatch.pv_tk`.\n""""""\n\nimport os\nimport importlib\n\n# try to import Dulwich or create dummies\ntry:\n    from dulwich.contrib.release_robot import get_current_version\n    from dulwich.repo import NotGitRepository\nexcept ImportError:\n    NotGitRepository = NotImplementedError\n\n    def get_current_version(*args, **kwargs):\n        raise NotGitRepository\n\n# import pvmismatch_lib modules so to match old API\nimport pvmismatch.pvmismatch_lib.pvconstants as pvconstants\nimport pvmismatch.pvmismatch_lib.pvcell as pvcell\nimport pvmismatch.pvmismatch_lib.pvmodule as pvmodule\nimport pvmismatch.pvmismatch_lib.pvstring as pvstring\nimport pvmismatch.pvmismatch_lib.pvsystem as pvsystem\nimport pvmismatch.pvmismatch_lib.pvexceptions as pvexceptions\n\n# expose constructors to package\'s top level\nPVconstants = pvconstants.PVconstants\nPVcell = pvcell.PVcell\nPVmodule = pvmodule.PVmodule\nPVstring = pvstring.PVstring\nPVsystem = pvsystem.PVsystem\n\n# Dulwich Release Robot\nBASEDIR = os.path.dirname(__file__)  # this directory\nPROJDIR = os.path.dirname(BASEDIR)\nVER_FILE = \'version\'  # name of file to store version\n# use release robot to try to get current Git tag\ntry:\n    GIT_TAG = get_current_version(PROJDIR)\nexcept NotGitRepository:\n    GIT_TAG = None\n# check version file\ntry:\n    version = importlib.import_module(\'%s.%s\' % (__name__, VER_FILE))\nexcept ImportError:\n    VERSION = None\nelse:\n    VERSION = version.VERSION\n# update version file if it differs from Git tag\nif GIT_TAG is not None and VERSION != GIT_TAG:\n    with open(os.path.join(BASEDIR, VER_FILE + \'.py\'), \'w\') as vf:\n        vf.write(\'VERSION = ""%s""\\n\' % GIT_TAG)\nelse:\n    GIT_TAG = VERSION  # if Git tag is none use version file\nVERSION = GIT_TAG  # version\n\n__author__ = \'Mark Mikofski\'\n__email__ = u\'mark.mikofski@sunpowercorp.com\'\n__url__ = u\'https://github.com/SunPower/PVMismatch\'\n__version__ = VERSION\n__release__ = \'Nepal Negroni\'\n__all__ = [\'pvconstants\', \'pvcell\', \'pvmodule\', \'pvstring\', \'pvsystem\']\n'"
pvmismatch/contrib/__init__.py,0,"b'""""""\nContributions to pvmismatch that are considered useful enough to be distributed\nbut are not necessarily considered part of pvmismatch core.\n""""""\n'"
pvmismatch/contrib/module_mismatch_simulator.py,25,"b'#!/usr/bin/env python\n\n\'\'\'\nCreated on Mar 29, 2013\n\nThis script allows the user to dynamically investigate the IV and PV\ncharacteristics of a single module. The user chooses the modules size--72 or 96\ncells. A GUI is then generated that allows the user to change the size, location,\nand irradiance level of a single ""shade rectangle"". Outputs include cell,\nsubstring, and module level IV and PV curves as well as a module diagram showing\nthe shade location, any reverse biased cells, and any active diodes.\n\n@author: bmeyers\n\'\'\'\n# ==============================================================================\n# Importing standard libraries\n# ==============================================================================\n\nfrom __future__ import (\n    absolute_import, division, unicode_literals, print_function)\nimport json\nfrom functools import partial\nfrom copy import deepcopy\nimport os\nimport numpy as np\nfrom scipy.interpolate import interp1d\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.widgets import Slider\nfrom matplotlib.widgets import Button\nfrom past.builtins import raw_input, xrange\n\n# ==============================================================================\n# Import PVmismatch items\n# ==============================================================================\n\ntry:\n    from pvmismatch import PVsystem, PVmodule, PVcell, PVconstants\n    from pvmismatch.pvmismatch_lib.pvmodule import STD72, STD96, STD128\nexcept ImportError:\n    print(""PVMismatch not found on path! Please use \'pip install -e path/to/pvmismatch\'"")\n    print(""or \'export PYTHONPATH=path/to/pvmismatch:$PYTHONPATH\' first."")\n    import sys\n    sys.exit(-1)\n\n# ==============================================================================\n# Define Classes and Functions\n# ==============================================================================\n\ndef modheight(numberCells):\n    if numberCells % 12 == 0:\n        modHeight = 12\n    else:\n        modHeight = 16\n    return modHeight\n\n\nclass ShadeObj(object):\n    """"""\n    A Class for creating a rectangular shade object. Accounts for the fact that\n    the cells are ordered sequentially in PVMismatch according to their\n    electrical connections, but a user often wants to think about the layout of\n    shade on a real module.\n    The cell stringing layout of an example 96-cell module is as follows:\n    11    12    35    36    59    60    83    84\n    10    13    34    37    58    61    82    85\n    9     14    33    38    57    62    81    86\n    8     15    32    39    56    63    80    87\n    7     16    31    40    55    64    79    88\n    6     17    30    41    54    65    78    89\n    5     18    29    42    53    66    77    90\n    4     19    28    43    52    67    76    91\n    3     20    27    44    51    68    75    92\n    2     21    26    45    50    69    74    93\n    1     22    25    46    49    70    73    94\n    0     23    24    47    48    71    72    95\n    So, shd_x=4 and shd_y=6 corresponds to cell 42\n    """"""\n\n    def __init__(self, pershade=90, shd_width=1, shd_height=1, shd_x=4,\n                 shd_y=6, numberCells=96):\n        modHeight = modheight(numberCells)\n        module = np.empty([numberCells // modHeight, modHeight], dtype=int)\n        for n in range(numberCells // modHeight):\n            if n % 2 == 0:\n                module[n] = np.arange(n * modHeight, (n + 1) * modHeight, 1)\n            else:\n                module[n] = np.arange((n + 1) * modHeight - 1,\n                                      n * modHeight - 1, -1)\n        module = module.T\n\n        self.numberCells = numberCells\n        self.modHeight = modHeight\n        self.pershade = pershade\n        self.sw = shd_width\n        self.sh = shd_height\n        self.sx = shd_x\n        self.sy = shd_y\n        self.nx = np.arange(shd_x, shd_x + shd_width, 1)\n        self.ny = np.arange(shd_y, shd_y + shd_height, 1)\n        self.nx, self.ny = np.meshgrid(self.nx, self.ny)\n        self.shadecells = []\n        for i in self.nx[0]:\n            for j in self.ny.T[0]:\n                self.shadecells.append(module[int(j - 1), int(i - 1)])\n\n    def plot(self):\n        x1 = self.numberCells / self.modHeight + 1\n        y1 = self.modHeight + 1\n        x = np.arange(1, x1, 1)\n        y = np.arange(1, y1, 1)\n        x, y = np.meshgrid(x, y)\n        plt.Figure()\n        plt.scatter(x, y, s=.5*1000, c=\'w\', marker=\'s\')\n        plt.scatter(self.nx, self.ny, s=.5*1000, c=\'k\', marker=\'s\', alpha=self.pershade / 100.)\n        plt.show()\n\n\ndef plotting_calcs(pvmod, ivp=None):\n    if ivp is None:\n        ivp = IVP()\n    numberCells = pvmod.numberCells\n    pvcells = pvmod.pvcells\n    ivp.pvcells = pvcells\n    calcmod1 = pvmod.calcMod()\n    ivp.Imod = calcmod1[0].squeeze()\n    ivp.Vmod = calcmod1[1].squeeze()\n    ivp.Pmod = calcmod1[2].squeeze()\n    ivp.Isubstr = calcmod1[3].squeeze()\n    ivp.Vsubstr = calcmod1[4].squeeze()\n    ind = ivp.Pmod.argmax()\n    ivp.Imp = ivp.Imod[ind]\n    ivp.Vmp = ivp.Vmod[ind]\n    ivp.Pmp = ivp.Pmod[ind]\n    ivp.Icell = pvmod.Icell.T\n    ivp.Vcell = pvmod.Vcell.T\n    ivp.Pcell = pvmod.Pcell.T\n    ivp.Voc = pvmod.Voc\n    ivp.VRBD = pvcells[0].VRBD\n    # Create coordinates of cells that have active diodes\n    ivp.activediode = []\n    if numberCells == 72:   # a 72 cell module\n        ad_x = [1, 3, 5]\n    else:                               # a 96 or 128 cell module\n        ad_x = [1, 3, 7]\n    if numberCells % 12 == 0:\n        ivp.modHeight = 12\n    else:\n        ivp.modHeight = 16\n    interp_funcs = [interp1d(ivp.Isubstr[i], ivp.Vsubstr[i]) for i in xrange(3)]\n    substring_Vmps = [f(ivp.Imp) for f in interp_funcs]\n    for n, ss_Vmp in enumerate(substring_Vmps):\n        if ss_Vmp < 0:\n            diodobj = ShadeObj(pershade=100,\n                               shd_width=pvmod.subStrCells[n],\n                               shd_height=ivp.modHeight,\n                               shd_x=ad_x[n], shd_y=1,\n                               numberCells=numberCells)\n            ivp.activediode.append(diodobj)\n    # Create coordinates of cells that are reverse biased\n    reversebias = [n for n in range(len(ivp.Icell.T))\n                   if -np.interp(-ivp.Imp, -ivp.Icell.T[n], -ivp.Vcell.T[n]) < 0]\n    boolindx = np.array(reversebias)\n    module = np.empty([pvmod.numberCells // ivp.modHeight, ivp.modHeight], dtype=int)\n    for n in range(pvmod.numberCells // ivp.modHeight):\n        if n % 2 == 0:\n            module[n] = np.arange(n * ivp.modHeight, (n + 1) * ivp.modHeight, 1)\n        else:\n            module[n] = np.arange((n + 1) * ivp.modHeight - 1,\n                                  n * ivp.modHeight - 1, -1)\n    ivp.rb_y, ivp.rb_x = [], []\n    for i in boolindx:\n        y1, x1 = np.where(module == i)\n        ivp.rb_x.append(y1.flatten()[0] + 1)\n        ivp.rb_y.append(x1.flatten()[0] + 1)\n    return ivp\n\n\nclass IVP(object):\n    """"""A class for holding module, cell, and substring data""""""\n    def __init__(self, Imod=None, Vmod=None, Pmod=None, Vsubstr=None, Isubstr=None, Imp=None,\n                 Vmp=None, Pmp=None, Icell=None, Vcell=None, Pcell=None, pvcells=None,\n                 Voc=None, VRBD=None, shade=None, activediode=None, rb_x=None, rb_y=None,\n                 shade_index=None, modHeight=None):\n        self.Imod = Imod\n        self.Vmod = Vmod\n        self.Pmod = Pmod\n        self.Vsubstr = Vsubstr\n        self.Isubstr = Isubstr\n        self.Imp = Imp\n        self.Vmp = Vmp\n        self.Pmp = Pmp\n        self.Icell = Icell\n        self.Vcell = Vcell\n        self.Pcell = Pcell\n        self.pvcells = pvcells\n        self.Voc = Voc\n        self.VRBD = VRBD\n        self.shade = shade\n        self.activediode = activediode\n        self.rb_x = rb_x\n        self.rb_y = rb_y\n        self.shade_index = shade_index\n        self.modHeight = modHeight\n\n\nclass PlotObjs(object):\n    """"""A class for holding line and scatter objects for plotting""""""\n    def __init__(self, lcellIVR=None, lcellIVF=None, lcellPVR=None,\n                 lcellPVF=None, lmodIV=None, lmodPV=None, lsubsIV=None,\n                 scatter=list(range(4)),\n                 text1=None, lines=list(range(6))):\n        self.lcellIVR = lcellIVR\n        self.lcellIVF = lcellIVF\n        self.lcellPVR = lcellPVR\n        self.lcellPVF = lcellPVF\n        self.lmodIV = lmodIV\n        self.lmodPV = lmodPV\n        self.lsubsIV = lsubsIV\n        self.scatter = scatter\n        self.text1 = text1\n        self.lines = lines\n\n\ndef construct_plot_area(numcells, modHeight):\n    cellPlot = plt.figure(figsize=(22, 6))\n    gs = gridspec.GridSpec(2, 5)\n    gs.update(left=0.06, right=0.96, wspace=0.25)\n    ax00 = cellPlot.add_subplot(gs[0, 0])\n    ax00.set_title(\'Cell Reverse I-V Characteristics\')\n    ax00.set_ylabel(\'Cell Current, I [A]\')\n    ax00.grid()\n    ax01 = cellPlot.add_subplot(gs[0, 1])\n    ax01.set_title(\'Cell Forward I-V Characteristics\')\n    ax01.set_ylabel(\'Cell Current, I [A]\')\n    ax01.grid()\n    ax10 = cellPlot.add_subplot(gs[1, 0])\n    ax10.set_title(\'Cell Reverse P-V Characteristics\')\n    ax10.set_xlabel(\'Cell Voltage, V [V]\')\n    ax10.set_ylabel(\'Cell Power, P [W]\')\n    ax10.grid()\n    ax11 = cellPlot.add_subplot(gs[1, 1])\n    ax11.set_title(\'Cell Forward P-V Characteristics\')\n    ax11.set_xlabel(\'Cell Voltage, V [V]\')\n    ax11.set_ylabel(\'Cell Power, P [W]\')\n    ax11.grid()\n    ax02 = cellPlot.add_subplot(gs[0, 2])\n    ax02.set_title(\'Module I-V Characteristics\')\n    ax02.set_ylabel(\'Module Current, I [A]\')\n    ax02.grid()\n    ax12 = cellPlot.add_subplot(gs[1, 2])\n    ax12.set_title(\'Module P-V Characteristics\')\n    ax12.set_xlabel(\'Module Voltage, V [V]\')\n    ax12.set_ylabel(\'Module Power, P [W]\')\n    ax12.grid()\n    ax03 = cellPlot.add_subplot(gs[0, 3])\n    ax03.set_title(\'Cell String I-V Characteristics\')\n    ax03.set_xlabel(\'Cell String Voltage, V [V]\')\n    ax03.set_ylabel(\'String Current, I [A]\')\n    ax03.grid()\n    ax_4 = cellPlot.add_subplot(gs[:, 4])\n    ax_4.set_title(\'Shade Diagram\')\n    ax_4.set_xlim(0.5, 8.5)\n    ax_4.set_ylim(0.5, modHeight + 0.5)\n    ax_4.set_aspect(\'equal\')\n    x = np.arange(1, numcells / modHeight + 1, 1)\n    y = np.arange(1, modHeight + 1, 1)\n    x, y = np.meshgrid(x, y)\n    output = {\'cellPlot\': cellPlot, \'gs\': gs, \'ax00\': ax00, \'ax01\': ax01, \'ax10\': ax10, \'ax11\': ax11, \'ax02\': ax02,\n              \'ax12\': ax12, \'ax03\': ax03, \'ax_4\': ax_4, \'x\': x, \'y\': y}\n    return output\n\n\ndef pvsys_defs_user_input(npts=101, user_set_temp=False, tcell=298.15):\n    """"""\n    Prompt a user to input array definitions from the command line. Returns all\n    info necessary to create a PVsystem instance\n    """"""\n    modsizeinput = int(raw_input(""Module Size? (1=72c, 2=96c, 3=128c): ""))\n    while modsizeinput != 1 and modsizeinput != 2 and modsizeinput != 3:\n        modsizeinput = input(""Please input 1, 2, or 3, please. "")\n    if modsizeinput == 1:\n        cellpos = STD72\n        modHeight = 12\n        numCells = 72\n    elif modsizeinput == 2:\n        cellpos = STD96\n        modHeight = 12\n        numCells = 96\n    elif modsizeinput == 3:\n        cellpos = STD128\n        modHeight = 16\n        numCells = 128\n    tcell = int(raw_input(""Cell temperature (deg C)? ""))\n    tcell = tcell + 273.15\n    pvcelldict = {\'Tcell\': tcell, \'pvconst\': PVconstants(npts=npts)}\n    pvmoddict = {\'cell_pos\': cellpos, \'Vbypass\': -0.5, \'pvconst\': PVconstants(npts=npts)}\n    pvcell = PVcell(**pvcelldict)\n    pvmod = PVmodule(pvcells=pvcell, **pvmoddict)\n    pvsys = PVsystem(pvmods=pvmod, numberStrs=1, numberMods=1, pvconst=pvmod.pvconst)\n    return pvsys, modHeight, numCells\n\n\n\ndef all_calc(ivp, i_ps, i_sw, i_sh, i_sx, i_sy):\n    """"""Calculate cell and module parameters""""""\n    if i_sx + i_sw > (numcells / 12 + 1):\n        i_sw = (numcells / modHeight + 1) - i_sx\n    if i_sy + i_sh > modHeight + 1:\n        i_sh = (modHeight + 1) - i_sy\n    if len(ivp.shade) != 0:\n        ivp.shade.pop()\n    ivp.shade.append(ShadeObj(pershade=i_ps, shd_width=i_sw, shd_height=i_sh,\n                              shd_x=i_sx, shd_y=i_sy,\n                              numberCells=pvmod1.numberCells))\n    pvmod1.setSuns(1.0)\n    for shd in ivp.shade:\n        pvmod1.setSuns(1 - (shd.pershade / 100.), shd.shadecells)\n    _ = plotting_calcs(pvmod1, ivp=ivp)\n\n\ndef plot_init(ivp, plotobjs, ax00, ax01, ax10, ax11, ax02, ax12, ax03, ax_4, x, y):\n    # Create plot objects\n    plotobjs.lcellIVR = list(ax00.plot(ivp.Vcell, ivp.Icell))\n    plotobjs.lcellIVF = list(ax01.plot(ivp.Vcell, ivp.Icell))\n    plotobjs.lcellPVR = list(ax10.plot(ivp.Vcell, ivp.Pcell))\n    plotobjs.lcellPVF = list(ax11.plot(ivp.Vcell, ivp.Pcell))\n    plotobjs.lmodIV, = ax02.plot(ivp.Vmod, ivp.Imod)\n    plotobjs.lmodPV, = ax12.plot(ivp.Vmod, ivp.Pmod)\n    plotobjs.lsubsIV = list(ax03.plot(ivp.Vsubstr[0], ivp.Isubstr[0], ivp.Vsubstr[1],\n                                      ivp.Isubstr[1], ivp.Vsubstr[2], ivp.Isubstr[2]))\n    # Create line objects\n    plotobjs.lines[0] = ax00.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[1] = ax01.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[2] = ax02.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[3] = ax02.axvline(x=ivp.Vmp, color=\'r\')\n    plotobjs.lines[4] = ax12.axvline(x=ivp.Vmp, color=\'r\')\n    plotobjs.lines[5] = ax03.axhline(y=ivp.Imp, color=\'r\')\n    # Create objects for diagram\n    if ivp.rb_x:\n        plotobjs.scatter[0] = ax_4.scatter(ivp.rb_x, ivp.rb_y, s=.5*800, c=\'r\',\n                                           marker=\'s\')\n    plotobjs.scatter[1] = []\n    for ad in ivp.activediode:\n        plotobjs.scatter[1].append(ax_4.scatter(ad.nx, ad.ny, s=.5*850, c=\'b\',\n                                                marker=\'s\'))\n    plotobjs.scatter[2] = ax_4.scatter(x, y, s=.5*500, c=\'w\', marker=\'s\', edgecolor=\'black\')\n    plotobjs.text1 = []\n    for shd in ivp.shade:\n        plotobjs.scatter[3] = ax_4.scatter(shd.nx, shd.ny, s=.5*500, c=\'k\',\n                                           marker=\'s\',\n                                           alpha=shd.pershade / 100.)\n        for a in shd.nx[0]:\n            for b in shd.ny.T[0]:\n                plotobjs.text1.append(ax_4.text(a - 0.25, b - 0.25,\n                                                int(shd.pershade), color=\'r\'))\n#   Set limits\n    ax00.set_xlim(ivp.VRBD - 1, 0)\n    ax00.set_ylim(0, ivp.pvcells[0].Isc0_T0 + 10)\n    ax01.set_xlim(0, np.max(ivp.Voc))\n    ax01.set_ylim(0, ivp.pvcells[0].Isc0_T0 + 1)\n    ax10.set_xlim(ivp.VRBD - 1, 0)\n    ax10.set_ylim((ivp.pvcells[0].Isc0_T0 + 10) * (ivp.VRBD - 1), -1)\n    ax11.set_xlim(0, np.max(ivp.Voc))\n    ax11.set_ylim(0, (ivp.pvcells[0].Isc0_T0 + 1) * np.max(ivp.Voc))\n    ax02.set_ylim(0, ivp.pvcells[0].Isc0_T0 + 1)\n    ax02.set_xlim(0, np.max(ivp.Vmod) * 1.25)\n    ax12.set_ylim(0, np.max(ivp.Pmod) * 1.25)\n    ax12.set_xlim(0, np.max(ivp.Vmod) * 1.25)\n    ax03.set_ylim(0, ivp.pvcells[0].Isc0_T0 + 1)\n    ax03.set_xlim(0, np.max(ivp.Vsubstr) * 1.0)\n\n\ndef plot_update(ivp, plotobjs, ax00, ax01, ax10, ax11, ax02, ax12, ax03, ax_4, x, y):\n    # Update plot objects\n    for i in range(len(plotobjs.lcellIVR)):\n        plotobjs.lcellIVR[i].set_data(ivp.Vcell.T[i], ivp.Icell.T[i])\n        plotobjs.lcellIVF[i].set_data(ivp.Vcell.T[i], ivp.Icell.T[i])\n        plotobjs.lcellPVR[i].set_data(ivp.Vcell.T[i], ivp.Pcell.T[i])\n        plotobjs.lcellPVF[i].set_data(ivp.Vcell.T[i], ivp.Pcell.T[i])\n    plotobjs.lmodIV.set_data(ivp.Vmod, ivp.Imod)\n    plotobjs.lmodPV.set_data(ivp.Vmod, ivp.Pmod)\n    for i in range(len(plotobjs.lsubsIV)):\n        plotobjs.lsubsIV[i].set_data(ivp.Vsubstr[i], ivp.Isubstr[i])\n    # Update line objects\n    for i in range(6):\n        plotobjs.lines[i].remove()\n    plotobjs.lines[0] = ax00.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[1] = ax01.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[2] = ax02.axhline(y=ivp.Imp, color=\'r\')\n    plotobjs.lines[3] = ax02.axvline(x=ivp.Vmp, color=\'r\')\n    plotobjs.lines[4] = ax12.axvline(x=ivp.Vmp, color=\'r\')\n    plotobjs.lines[5] = ax03.axhline(y=ivp.Imp, color=\'r\')\n#     Update scatter objects\n    for i in range(4):\n        if plotobjs.scatter[i]:\n            if i == 1:\n                for scatt in plotobjs.scatter[i]:\n                    scatt.remove()\n            else:\n                plotobjs.scatter[i].remove()\n    for text in plotobjs.text1:\n        text.remove()\n    if ivp.rb_x:\n        plotobjs.scatter[0] = ax_4.scatter(ivp.rb_x, ivp.rb_y, s=.5*800, c=\'r\',\n                                           marker=\'s\')\n    else:\n        plotobjs.scatter[0] = None\n    plotobjs.scatter[1] = []\n    for ad in ivp.activediode:\n        plotobjs.scatter[1].append(ax_4.scatter(ad.nx, ad.ny, s=.5*850, c=\'b\',\n                                                marker=\'s\'))\n    plotobjs.scatter[2] = ax_4.scatter(x, y, s=.5*500, c=\'w\', marker=\'s\', edgecolor=\'black\')\n    plotobjs.text1 = []\n    for shd in ivp.shade:\n        plotobjs.scatter[3] = ax_4.scatter(shd.nx, shd.ny, s=.5*500, c=\'k\',\n                                           marker=\'s\',\n                                           alpha=shd.pershade / 100.)\n        for a in shd.nx[0]:\n            for b in shd.ny.T[0]:\n                plotobjs.text1.append(ax_4.text(a - 0.25, b - 0.25,\n                                                int(shd.pershade), color=\'r\'))\n\n\ndef full_update(val, output=None, ivp0=None, plotobjs=None):\n    ps = s_ps.val\n    sw = round(s_sw.val)\n    sh = round(s_sh.val)\n    sy = round(s_sy.val)\n    sx = round(s_sx.val)\n    all_calc(ivp0, ps, sw, sh, sx, sy)\n    plot_update(ivp0, plotobjs, output[\'ax00\'], output[\'ax01\'], output[\'ax10\'], output[\'ax11\'], output[\'ax02\'],\n                output[\'ax12\'], output[\'ax03\'], output[\'ax_4\'], output[\'x\'], output[\'y\'])\n    plt.draw()\n    t1 = (sw * sh, s_ps.val, ivp0.Pmp, 100 * ivp0.Pmp / Pmp0)\n    print(\'{0:^6} {1:^6,.2f} {2:^6,.2f} {3:^7,.2f}\'.format(*t1))\n\n\ndef set_the_shade(val):\n    ivp0.shade.insert(0, ivp0.shade[-1])\n\n\ndef save_the_shade(val):\n    this_dir = os.getcwd()\n    save_dir = os.path.join(this_dir, \'JSONshade\')\n    os.makedirs(save_dir, exist_ok=True)\n    dicts = []\n    for shd in ivp0.shade:\n        dicts.append({\'ps\': shd.pershade, \'sw\': shd.sw, \'sh\': shd.sh,\n                      \'sy\': shd.sy, \'sx\': shd.sx,\n                      \'numberCells\': pvmod1.numberCells})\n    filename = raw_input(""File name? "")\n    filename = os.path.join(save_dir, filename + \'.json\')\n    with open(filename, \'w\') as fo:\n        json.dump(dicts, fo, sort_keys=True, indent=2)\n\n\ndef clear_last_full(val, update=None):\n    if len(ivp0.shade) != 1:\n        ivp0.shade.pop(-2)\n    update(val)\n\n\nif __name__ == ""__main__"":\n    pvsys, modHeight, numcells = pvsys_defs_user_input(npts=201)\n    output = construct_plot_area(numcells, modHeight)\n    pvmod1 = pvsys.pvstrs[0].pvmods[0]\n    pvmod_noshade = deepcopy(pvmod1)\n    calcmod_noshade = pvmod_noshade.calcMod()\n    Pmod_noshade = calcmod_noshade[2].squeeze()\n    Pmp0 = Pmod_noshade.max()\n    ivp0 = IVP()\n    plotobjs = PlotObjs()\n    update = partial(full_update, output=output, ivp0=ivp0, plotobjs=plotobjs)\n    ClearLast = partial(clear_last_full, update=update)\n    print(""Pmp0: {}"".format(Pmp0))\n    print("""")\n    print(\'{0:6} {1:^6} {2:^6} {3:^7}\'.format(\'#Cells\', \'%Shade\', \'Pmp\', \'%ofPmp0\'))\n    print(\'----------------------------\')\n    ps0 = 90\n    sw0 = 1\n    sh0 = 1\n    sy0 = 1\n    sx0 = 1\n    ivp0.shade = []\n    all_calc(ivp0, ps0, sw0, sh0, sx0, sy0)\n    plot_init(ivp0, plotobjs, output[\'ax00\'], output[\'ax01\'], output[\'ax10\'], output[\'ax11\'], output[\'ax02\'],\n              output[\'ax12\'], output[\'ax03\'], output[\'ax_4\'], output[\'x\'], output[\'y\'])\n    plt.draw()\n\n    cellPlot = output[\'cellPlot\']\n    ax_ps = cellPlot.add_axes([0.64, 0.38, 0.12, .04])\n    ax_sw = cellPlot.add_axes([0.64, 0.33, 0.12, .04])\n    ax_sh = cellPlot.add_axes([0.64, 0.28, 0.12, .04])\n    ax_sy = cellPlot.add_axes([0.64, 0.23, 0.12, .04])\n    ax_sx = cellPlot.add_axes([0.64, 0.18, 0.12, .04])\n    ax_button_setshade = cellPlot.add_axes([0.63, 0.10, 0.06, 0.06])\n    ax_button_saveshade = cellPlot.add_axes([0.71, 0.10, 0.06, 0.06])\n    ax_button_clearlast = cellPlot.add_axes([0.67, 0.03, 0.06, 0.06])\n    s_ps = Slider(ax_ps, \'Shade%\', 0, 100, valinit=ps0)\n    s_sw = Slider(ax_sw, \'Width\', 1, numcells / modHeight, valinit=sw0,\n                  valfmt=\'%0.0f\')\n    s_sh = Slider(ax_sh, \'Height\', 1, modHeight, valinit=sh0, valfmt=\'%0.0f\')\n    s_sy = Slider(ax_sy, \'Row Start\', 1, modHeight, valinit=sw0,\n                  valfmt=\'%0.0f\')\n    s_sx = Slider(ax_sx, \'Col Start\', 1, numcells / modHeight, valinit=sh0,\n                  valfmt=\'%0.0f\')\n    b_setshade = Button(ax_button_setshade, ""Set Shade"")\n    b_saveshade = Button(ax_button_saveshade, ""Save Shade"")\n    b_clearlast = Button(ax_button_clearlast, ""Clear Last"")\n    s_ps.on_changed(update)\n    s_sw.on_changed(update)\n    s_sh.on_changed(update)\n    s_sy.on_changed(update)\n    s_sx.on_changed(update)\n    b_setshade.on_clicked(set_the_shade)\n    b_saveshade.on_clicked(save_the_shade)\n    b_clearlast.on_clicked(ClearLast)\n\nplt.show()\n'"
pvmismatch/contrib/tiled_reference_module.py,2,"b'""""""\nThis script uses default Tiled module configuration and cell parameters to\ncalculate performance and generate IV and PV curves.\n""""""\n\nfrom pvmismatch import *\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nif __name__ == ""__main__"":\n    \n    # Model parameters\n    NPTS=5000  # Because of the high cell breakdown voltage, NPTS must be >1000\n    \n    # Cell parameters\n    RS = 0.0181123  # [ohm] series resistance\n    RSH = 58.082  # [ohm] shunt resistance\n    ISAT1_T0 = 2.9885E-11  # [A] diode one saturation current\n    ISAT2_T0 = 1.6622E-07  # [A] diode two saturation current\n    ISC0_T0 = 1.437  # [A] reference short circuit current\n    ARBD = 9.0E-4  # reverse breakdown coefficient 1\n    BRBD = -0.056  # reverse breakdown coefficient 2\n    VRBD_ = -25.1  # [V] reverse breakdown voltage\n    NRBD = 4.0  # reverse breakdown exponent\n    EG = 1.166  # [eV] band gap of cSi\n    ALPHA_ISC = 0.0003551  # [1/K] short circuit current temperature coefficient\n    TCELL = 298.15  # [K] cell temperature\n    CELLAREA = np.float64(38.064)  # [cm^2] cell area used for efficiency calculation\n    \n    # Module parameters\n    VBYPASS = np.float64(-0.885)  # [V] trigger voltage of bypass diode\n    NUMBERCOLS = 6  # number of hypercells per module\n    \n    # System parameters\n    NUMBERMODS = 1  # number of modules per string\n    NUMBERSTRS = 1  # number of strings in parallel\n    \n    # System definition\n    tiledCell = pvcell.PVcell(Rs=RS, Rsh=RSH, Isat1_T0=ISAT1_T0, Isat2_T0=ISAT2_T0,\n                    Isc0_T0=ISC0_T0, aRBD=ARBD, VRBD=VRBD_, bRBD=BRBD, \n                    nRBD=NRBD, Eg=EG, alpha_Isc=ALPHA_ISC,\n                    Tcell=TCELL)\n    tiledModule = pvmodule.PVmodule(cell_pos=pvmodule.PCT492, pvcells=tiledCell,\n                    Vbypass=VBYPASS, cellArea=CELLAREA)  # Tiled module with partial cross-ties\n    tiledSystem = pvsystem.PVsystem(pvconst=pvconstants.PVconstants(npts=NPTS),\n                    pvmods=tiledModule, numberStrs=NUMBERSTRS, numberMods=NUMBERMODS)\n    \n    print(\'Imp = \' + str(tiledSystem.Imp) + \' A\')\n    print(\'Vmp = \' + str(tiledSystem.Vmp) + \' V\')\n    print(\'Pmp = \' + str(tiledSystem.Pmp) + \' W\')\n    print(\'Isc = \' + str(tiledSystem.Isc) + \' A\')\n    print(\'Voc = \' + str(tiledSystem.Voc) + \' V\')\n    print(\'FF = \' + str(100*tiledSystem.FF) + \' %\')\n    print(\'Efficiency = \' + str(100*tiledSystem.eff) + \' %\')\n    figure = tiledSystem.plotSys()\n    plt.show()\n'"
pvmismatch/docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# PVMismatch documentation build configuration file, created by\n# sphinx-quickstart on Thu Dec 05 12:49:34 2013.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(os.path.join(\'..\', \'..\')))\nfrom pvmismatch import __version__, __author__, __name__, __release__\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\', \'sphinx.ext.intersphinx\',\n              \'sphinx.ext.mathjax\', \'sphinx.ext.napoleon\',\n              \'sphinx.ext.graphviz\', \'sphinx.ext.imgconverter\']\n\nimage_converter = \'c://Program Files//ImageMagick-7.0.7-Q16//convert.exe\'\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'PVMismatch\'\ncopyright = u\'2017, SunPower\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = __version__\n# The full version, including alpha/beta/rc tags.\nrelease = __release__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'alabaster\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \'logo\': \'sp_2014_logo_black_orange_rgb.png\',\n    \'logo_name\': True,\n    \'description\': \'PV Mismatch Estimation Tool\',\n    \'github_user\': \'SunPower\',\n    \'github_repo\': \'PVMismatch\',\n    \'github_banner\': True,\n    \'travis_button\': True,\n    \'show_related\': True\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = os.path.join(\'..\', \'res\', \'logo_invert.png\')\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = \'favicon.ico\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \'**\': [\n        \'about.html\',\n        \'navigation.html\',\n        \'searchbox.html\',\n        \'relations.html\'\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'PVMismatchdoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\'index\', \'%s.tex\' % __name__, u\'%s Documentation\' % __name__,\n   u\'%s\' % __author__, \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'%s\' % __name__, u\'%s Documentation\' % __name__,\n     [u\'%s\' % __author__], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'%s\' % __name__, u\'%s Documentation\' % __name__,\n   u\'%s\' % __author__, \'%s\' % __name__, \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \'numpy\': (\'https://docs.scipy.org/doc/numpy\', None),\n    \'scipy\': (\'https://docs.scipy.org/doc/scipy/reference\', None),\n    \'python\': (\'https://docs.python.org/3\', None)}\n\n'"
pvmismatch/pvmismatch_lib/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nThis is the PVMismatch Library. Configuration constants and classes like\n:class:`~pvmismatch.pvmismatch_lib.pvconstants.PVconstants`,\n:class:`~pvmismatch.pvmismatch_lib.pvcell.PVcell`,\n:class:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule`,\n:class:`~pvmismatch.pvmismatch_lib.pvstring.PVstring` and\n:class:`~pvmismatch.pvmismatch_lib.pvsystem.PVsystem`, objects are all defined\nhere.\n""""""\n\n# imports, version and other info moved to package top level\n\n# TODO: move pvconstants here\n'"
pvmismatch/pvmismatch_lib/pvcell.py,20,"b'# -*- coding: utf-8 -*-\n\n""""""\nThis module contains the :class:`~pvmismatch.pvmismatch_lib.pvcell.PVcell`\nobject which is used by modules, strings and systems.\n""""""\n\nfrom __future__ import absolute_import\nfrom future.utils import iteritems\nfrom pvmismatch.pvmismatch_lib.pvconstants import PVconstants\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy.optimize import newton\n\n# Defaults\nRS = 0.004267236774264931  # [ohm] series resistance\nRSH = 10.01226369025448  # [ohm] shunt resistance\nISAT1_T0 = 2.286188161253440E-11  # [A] diode one saturation current\nISAT2_T0 = 1.117455042372326E-6  # [A] diode two saturation current\nISC0_T0 = 6.3056  # [A] reference short circuit current\nTCELL = 298.15  # [K] cell temperature\nARBD = 1.036748445065697E-4  # reverse breakdown coefficient 1\nBRBD = 0.  # reverse breakdown coefficient 2\nVRBD_ = -5.527260068445654  # [V] reverse breakdown voltage\nNRBD = 3.284628553041425  # reverse breakdown exponent\nEG = 1.1  # [eV] band gap of cSi\nALPHA_ISC = 0.0003551  # [1/K] short circuit current temperature coefficient\nEPS = np.finfo(np.float64).eps\n\nclass PVcell(object):\n    """"""\n    Class for PV cells.\n\n    :param Rs: series resistance [ohms]\n    :param Rsh: shunt resistance [ohms]\n    :param Isat1_T0: first saturation diode current at ref temp [A]\n    :param Isat2_T0: second saturation diode current [A]\n    :param Isc0_T0: short circuit current at ref temp [A]\n    :param aRBD: reverse breakdown coefficient 1\n    :param bRBD: reverse breakdown coefficient 2\n    :param VRBD: reverse breakdown voltage [V]\n    :param nRBD: reverse breakdown exponent\n    :param Eg: band gap [eV]\n    :param alpha_Isc: short circuit current temp coeff [1/K]\n    :param Tcell: cell temperature [K]\n    :param Ee: incident effective irradiance [suns]\n    :param pvconst: configuration constants object\n    :type pvconst: :class:`~pvmismatch.pvmismatch_lib.pvconstants.PVconstants`\n    """"""\n\n    _calc_now = False  #: if True ``calcCells()`` is called in ``__setattr__``\n\n    def __init__(self, Rs=RS, Rsh=RSH, Isat1_T0=ISAT1_T0, Isat2_T0=ISAT2_T0,\n                 Isc0_T0=ISC0_T0, aRBD=ARBD, bRBD=BRBD, VRBD=VRBD_,\n                 nRBD=NRBD, Eg=EG, alpha_Isc=ALPHA_ISC,\n                 Tcell=TCELL, Ee=1., pvconst=PVconstants()):\n        # user inputs\n        self.Rs = Rs  #: [ohm] series resistance\n        self.Rsh = Rsh  #: [ohm] shunt resistance\n        self.Isat1_T0 = Isat1_T0  #: [A] diode one sat. current at T0\n        self.Isat2_T0 = Isat2_T0  #: [A] diode two saturation current\n        self.Isc0_T0 = Isc0_T0  #: [A] short circuit current at T0\n        self.aRBD = aRBD  #: reverse breakdown coefficient 1\n        self.bRBD = bRBD  #: reverse breakdown coefficient 2\n        self.VRBD = VRBD  #: [V] reverse breakdown voltage\n        self.nRBD = nRBD  #: reverse breakdown exponent\n        self.Eg = Eg  #: [eV] band gap of cSi\n        self.alpha_Isc = alpha_Isc  #: [1/K] short circuit temp. coeff.\n        self.Tcell = Tcell  #: [K] cell temperature\n        self.Ee = Ee  #: [suns] incident effective irradiance on cell\n        self.pvconst = pvconst  #: configuration constants\n        self.Icell = None  #: cell currents on IV curve [A]\n        self.Vcell = None  #: cell voltages on IV curve [V]\n        self.Pcell = None  #: cell power on IV curve [W]\n        self.VocSTC = self._VocSTC()  #: estimated Voc at STC [V]\n        # set calculation flag\n        self._calc_now = True  # overwrites the class attribute\n\n    def __str__(self):\n        fmt = \'<PVcell(Ee=%g[suns], Tcell=%g[K], Isc=%g[A], Voc=%g[V])>\'\n        return fmt % (self.Ee, self.Tcell, self.Isc, self.Voc)\n\n    def __repr__(self):\n        return str(self)\n\n    def __setattr__(self, key, value):\n        # check for floats\n        try:\n            value = np.float64(value)\n        except (TypeError, ValueError):\n            pass  # fail silently if not float, eg: pvconst or _calc_now\n        super(PVcell, self).__setattr__(key, value)\n        # recalculate IV curve\n        if self._calc_now:\n            Icell, Vcell, Pcell = self.calcCell()\n            self.__dict__.update(Icell=Icell, Vcell=Vcell, Pcell=Pcell)\n\n    def update(self, **kwargs):\n        """"""\n        Update user-defined constants.\n        """"""\n        # turn off calculation flag until all attributes are updated\n        self._calc_now = False\n        # don\'t use __dict__.update() instead use setattr() to go through\n        # custom __setattr__() so that numbers are cast to floats\n        for k, v in iteritems(kwargs):\n            setattr(self, k, v)\n        self._calc_now = True  # recalculate\n\n    @property\n    def Vt(self):\n        """"""\n        Thermal voltage in volts.\n        """"""\n        return self.pvconst.k * self.Tcell / self.pvconst.q\n\n    @property\n    def Isc(self):\n        return self.Ee * self.Isc0\n\n    @property\n    def Aph(self):\n        """"""\n        Photogenerated current coefficient, non-dimensional.\n        """"""\n        # Aph is undefined (0/0) if there is no irradiance\n        if self.Isc == 0: return np.nan\n        # short current (SC) conditions (Vcell = 0)\n        Vdiode_sc = self.Isc * self.Rs  # diode voltage at SC\n        Idiode1_sc = self.Isat1 * (np.exp(Vdiode_sc / self.Vt) - 1.)\n        Idiode2_sc = self.Isat2 * (np.exp(Vdiode_sc / 2. / self.Vt) - 1.)\n        Ishunt_sc = Vdiode_sc / self.Rsh  # diode voltage at SC\n        # photogenerated current coefficient\n        return 1. + (Idiode1_sc + Idiode2_sc + Ishunt_sc) / self.Isc\n\n    @property\n    def Isat1(self):\n        """"""\n        Diode one saturation current at Tcell in amps.\n        """"""\n        _Tstar = self.Tcell ** 3. / self.pvconst.T0 ** 3.  # scaled temperature\n        _inv_delta_T = 1. / self.pvconst.T0 - 1. / self.Tcell  # [1/K]\n        _expTstar = np.exp(\n            self.Eg * self.pvconst.q / self.pvconst.k * _inv_delta_T\n        )\n        return self.Isat1_T0 * _Tstar * _expTstar  # [A] Isat1(Tcell)\n\n    @property\n    def Isat2(self):\n        """"""\n        Diode two saturation current at Tcell in amps.\n        """"""\n        _Tstar = self.Tcell ** 3. / self.pvconst.T0 ** 3.  # scaled temperature\n        _inv_delta_T = 1. / self.pvconst.T0 - 1. / self.Tcell  # [1/K]\n        _expTstar = np.exp(\n            self.Eg * self.pvconst.q / (2.0 * self.pvconst.k) * _inv_delta_T\n        )\n        return self.Isat2_T0 * _Tstar * _expTstar  # [A] Isat2(Tcell)\n    \n    @property\n    def Isc0(self):\n        """"""\n        Short circuit current at Tcell in amps.\n        """"""\n        _delta_T = self.Tcell - self.pvconst.T0  # [K] temperature difference\n        return self.Isc0_T0 * (1. + self.alpha_Isc * _delta_T)  # [A] Isc0\n\n    @property\n    def Voc(self):\n        """"""\n        Estimate open circuit voltage of cells.\n        Returns Voc : numpy.ndarray of float, estimated open circuit voltage\n        """"""\n        C = self.Aph * self.Isc + self.Isat1 + self.Isat2\n        delta = self.Isat2 ** 2. + 4. * self.Isat1 * C\n        return self.Vt * np.log(\n            ((-self.Isat2 + np.sqrt(delta)) / 2. / self.Isat1) ** 2.\n        )\n\n    def _VocSTC(self):\n        """"""\n        Estimate open circuit voltage of cells.\n        Returns Voc : numpy.ndarray of float, estimated open circuit voltage\n        """"""\n        Vdiode_sc = self.Isc0_T0 * self.Rs  # diode voltage at SC\n        Idiode1_sc = self.Isat1_T0 * (np.exp(Vdiode_sc / self.Vt) - 1.)\n        Idiode2_sc = self.Isat2_T0 * (np.exp(Vdiode_sc / 2. / self.Vt) - 1.)\n        Ishunt_sc = Vdiode_sc / self.Rsh  # diode voltage at SC\n        # photogenerated current coefficient\n        Aph = 1. + (Idiode1_sc + Idiode2_sc + Ishunt_sc) / self.Isc0_T0\n        # estimated Voc at STC\n        C = Aph * self.Isc0_T0 + self.Isat1_T0 + self.Isat2_T0\n        delta = self.Isat2_T0 ** 2. + 4. * self.Isat1_T0 * C\n        return self.Vt * np.log(\n            ((-self.Isat2_T0 + np.sqrt(delta)) / 2. / self.Isat1_T0) ** 2.\n        )\n\n    @property\n    def Igen(self):\n        """"""\n        Photovoltaic generated light current (AKA IL or Iph)\n        Returns Igen : numpy.ndarray of float, PV generated light current [A]\n\n        Photovoltaic generated light current is zero if irradiance is zero.\n        """"""\n        if self.Ee == 0: return 0\n        return self.Aph * self.Isc\n\n    def calcCell(self):\n        """"""\n        Calculate cell I-V curves.\n        Returns (Icell, Vcell, Pcell) : tuple of numpy.ndarray of float\n        """"""\n        Vreverse = self.VRBD * self.pvconst.negpts\n        Vff = self.Voc\n        delta_Voc = self.VocSTC - self.Voc\n        # to make sure that the max voltage is always in the 4th quadrant, add\n        # a third set of points log spaced with decreasing density, from Voc to\n        # Voc @ STC unless Voc *is* Voc @ STC, then use an arbitrary voltage at\n        # 80% of Voc as an estimate of Vmp assuming a fill factor of 80% and\n        # Isc close to Imp, or if Voc > Voc @ STC, then use Voc as the max\n        if delta_Voc == 0:\n            Vff = 0.8 * self.Voc\n            delta_Voc = 0.2 * self.Voc\n        elif delta_Voc < 0:\n            Vff = self.VocSTC\n            delta_Voc = -delta_Voc\n        Vquad4 = Vff + delta_Voc * self.pvconst.Vmod_q4pts\n        Vforward = Vff * self.pvconst.pts\n        Vdiode = np.concatenate((Vreverse, Vforward, Vquad4), axis=0)\n        Idiode1 = self.Isat1 * (np.exp(Vdiode / self.Vt) - 1.)\n        Idiode2 = self.Isat2 * (np.exp(Vdiode / 2. / self.Vt) - 1.)\n        Ishunt = Vdiode / self.Rsh\n        fRBD = 1. - Vdiode / self.VRBD\n        # use epsilon = 2.2204460492503131e-16 to avoid ""divide by zero""\n        fRBD[fRBD == 0] = EPS\n        Vdiode_norm = Vdiode / self.Rsh / self.Isc0_T0\n        fRBD = self.Isc0_T0 * fRBD ** (-self.nRBD)\n        IRBD = (self.aRBD * Vdiode_norm + self.bRBD * Vdiode_norm ** 2) * fRBD \n        Icell = self.Igen - Idiode1 - Idiode2 - Ishunt - IRBD\n        Vcell = Vdiode - Icell * self.Rs\n        Pcell = Icell * Vcell\n        return Icell, Vcell, Pcell\n\n    # diode model\n    #  *-->--*--->---*--Rs->-Icell--+\n    #  ^     |       |              ^\n    #  |     |       |              |\n    # Igen  Idiode  Ishunt         Vcell\n    #  |     |       |              |\n    #  |     v       v              v\n    #  *--<--*---<---*--<-----------=\n    # http://en.wikipedia.org/wiki/Diode_modelling#Shockley_diode_model\n    # http://en.wikipedia.org/wiki/Diode#Shockley_diode_equation\n    # http://en.wikipedia.org/wiki/William_Shockley\n\n    @staticmethod\n    def f_Icell(Icell, Vcell, Igen, Rs, Vt, Isat1, Isat2, Rsh):\n        """"""\n        Objective function for Icell.\n        :param Icell: cell current [A]\n        :param Vcell: cell voltage [V]\n        :param Igen: photogenerated current at Tcell and Ee [A]\n        :param Rs: series resistance [ohms]\n        :param Vt: thermal voltage [V]\n        :param Isat1: first diode saturation current at Tcell [A]\n        :param Isat2: second diode saturation current [A]\n        :param Rsh: shunt resistance [ohms]\n        :return: residual = (Icell - Icell0) [A]\n        """"""\n        # arbitrary current condition\n        Vdiode = Vcell + Icell * Rs  # diode voltage\n        Idiode1 = Isat1 * (np.exp(Vdiode / Vt) - 1.)  # diode current\n        Idiode2 = Isat2 * (np.exp(Vdiode / 2. / Vt) - 1.)  # diode current\n        Ishunt = Vdiode / Rsh  # shunt current\n        return Igen - Idiode1 - Idiode2 - Ishunt - Icell\n\n    def calcIcell(self, Vcell):\n        """"""\n        Calculate Icell as a function of Vcell.\n        :param Vcell: cell voltage [V]\n        :return: Icell\n        """"""\n        args = (np.float64(Vcell), self.Igen, self.Rs, self.Vt,\n                self.Isat1, self.Isat2, self.Rsh)\n        return newton(self.f_Icell, x0=self.Isc, args=args)\n\n    @staticmethod\n    def f_Vcell(Vcell, Icell, Igen, Rs, Vt, Isat1, Isat2, Rsh):\n        return PVcell.f_Icell(Icell, Vcell, Igen, Rs, Vt, Isat1, Isat2, Rsh)\n\n    def calcVcell(self, Icell):\n        """"""\n        Calculate Vcell as a function of Icell.\n        :param Icell: cell current [A]\n        :return: Vcell\n        """"""\n        args = (np.float64(Icell), self.Igen, self.Rs, self.Vt,\n                self.Isat1, self.Isat2, self.Rsh)\n        return newton(self.f_Vcell, x0=self.Voc, args=args)\n\n    def plot(self):\n        """"""\n        Plot cell I-V curve.\n        Returns cellPlot : matplotlib.pyplot figure\n        """"""\n        cell_plot = plt.figure()\n        plt.subplot(2, 2, 1)\n        plt.plot(self.Vcell, self.Icell)\n        plt.title(\'Cell Reverse I-V Characteristics\')\n        plt.ylabel(\'Cell Current, I [A]\')\n        plt.xlim(self.VRBD - 1, 0)\n        plt.ylim(0, self.Isc + 10)\n        plt.grid()\n        plt.subplot(2, 2, 2)\n        plt.plot(self.Vcell, self.Icell)\n        plt.title(\'Cell Forward I-V Characteristics\')\n        plt.ylabel(\'Cell Current, I [A]\')\n        plt.xlim(0, self.Voc)\n        plt.ylim(0, self.Isc + 1)\n        plt.grid()\n        plt.subplot(2, 2, 3)\n        plt.plot(self.Vcell, self.Pcell)\n        plt.title(\'Cell Reverse P-V Characteristics\')\n        plt.xlabel(\'Cell Voltage, V [V]\')\n        plt.ylabel(\'Cell Power, P [W]\')\n        plt.xlim(self.VRBD - 1, 0)\n        plt.ylim((self.Isc + 10) * (self.VRBD - 1), -1)\n        plt.grid()\n        plt.subplot(2, 2, 4)\n        plt.plot(self.Vcell, self.Pcell)\n        plt.title(\'Cell Forward P-V Characteristics\')\n        plt.xlabel(\'Cell Voltage, V [V]\')\n        plt.ylabel(\'Cell Power, P [W]\')\n        plt.xlim(0, self.Voc)\n        plt.ylim(0, (self.Isc + 1) * self.Voc)\n        plt.grid()\n        plt.tight_layout()\n        return cell_plot\n'"
pvmismatch/pvmismatch_lib/pvconstants.py,24,"b'# -*- coding: utf-8 -*-\n""""""\nThis module contains configuration constants for PVMismatch, such as number of\npoints in IV curve to calculate, flag to use parallel processing and parallel\nprocessing parameters. This module also contains some utility functions like\n:func:`~pvmismatch.pvmismatch_lib.pvconstants.npinterpx()` and\n:func:`~pvmismatch.pvmismatch_lib.pvconstants.get_series_cells()` are defined\nhere too.\n""""""\n\n# TODO: move this to pvmismatch_lib/__init__.py\n\nimport numpy as np\nimport scipy.constants\n\n# Constants\nNPTS = 101  # number of I-V points to calculate\nMODSIZES = [24, 72, 96, 128]  # list of possible number of cells per module\nNUMBERCELLS = MODSIZES[2]  # default is 96-cell module\nNUMBERMODS = 10  # default number of modules\nNUMBERSTRS = 10  # default number of strings\nEPS = np.finfo(np.float64).eps\n\n\ndef npinterpx(x, xp, fp):\n    """"""\n    Numpy interpolation function with linear extrapolation.\n\n    Parameters\n    ----------\n    x : array_like\n        The x-coordinates of the interpolated values.\n\n    xp : 1-D sequence of floats\n        The x-coordinates of the data points, must be increasing.\n\n    fp : 1-D sequence of floats\n        The y-coordinates of the data points, same length as `xp`.\n\n    Returns\n    -------\n    y : {float, ndarray}\n        The interpolated values, same shape as `x`.\n\n    Raises\n    ------\n    ValueError\n        If `xp` and `fp` have different length\n    """"""\n    y = np.interp(x, xp, fp)\n    # extrapolate left\n    left = x < xp[0]\n    xleft = x[left]\n    yleft = fp[0] + (xleft - xp[0]) / (xp[1] - xp[0]) * (fp[1] - fp[0])\n    y[left] = yleft\n    # extrapolate right\n    right = x > xp[-1]\n    xright = x[right]\n    yright = fp[-1] + (xright - xp[-1]) / (xp[-2] - xp[-1]) * (fp[-2] - fp[-1])\n    y[right] = yright\n    return y\n\n\nclass PVconstants(object):\n    """"""\n    Class for configuration constants\n\n    :param npts: number of points in IV curve\n    :type npts: int\n    """"""\n    # hard constants\n    k = scipy.constants.k  #: [J/K] Boltzmann constant\n    q = scipy.constants.e  #: [Coloumbs] elementary charge\n    E0 = 1000.  #: [W/m^2] irradiance of 1 sun\n    T0 = 298.15  #: [K] reference temperature\n\n    def __init__(self, npts=NPTS):\n        self._npts = None\n        self.pts = None\n        """"""array of points with decreasing spacing from exactly zero to one""""""\n        self.negpts = None\n        """"""array of points with increasing spacing from one to ``0.1/npts``""""""\n        self.Imod_pts = None\n        """"""array of points with increasing spacing from exactly zero to one""""""\n        self.Imod_pts_sq = None\n        """"""array of points from EPS to 1 with very close spacing near EPS""""""\n        self.Imod_negpts = None\n        """"""array of points with decreasing spacing from one to  ``0.1/npts``""""""\n        self.Vmod_q4pts = None\n        """"""array of points with decreasing spacing from ``0.1/npts`` to one""""""\n        # call property setter\n        self.npts = npts  #: number of points in IV curves\n\n    @property\n    def npts(self):\n        """"""number of points in IV curves""""""\n        return self._npts\n\n    @npts.setter\n    def npts(self, npts):\n        # set number of points in IV curve(s)\n        self._npts = npts  # number of points in IV curves\n        # point spacing from 0 to 1, used for Vcell, Vmod, Vsys and Istring\n        # decrease point spacing as voltage approaches Voc by using logspace\n        pts = (11. - np.logspace(np.log10(11.), 0., self._npts)) / 10.\n        pts[0] = 0.  # first point must be exactly zero\n        self.pts = pts.reshape((self._npts, 1))\n        negpts = (11. - np.logspace(np.log10(11. - 1. / float(self._npts)),\n                                    0., self._npts)) / 10.\n        negpts = negpts.reshape((self._npts, 1))\n        self.Imod_negpts = 1 + 1. / float(self._npts) / 10. - negpts\n        self.negpts = np.flipud(negpts)  # reverse the order\n        # shift and concatenate pvconst.negpts and pvconst.pts\n        # so that tight spacing is around MPP and RBD\n        self.Imod_pts = 1 - np.flipud(self.pts)\n        self.Imod_pts_sq = self.Imod_pts**2 + EPS\n        self.Vmod_q4pts = np.flipud(self.Imod_negpts)\n\n    def __str__(self):\n        return \'<PVconstants(npts=%d)>\' % self.npts\n\n    def __repr__(self):\n        return str(self)\n\n    def calcSeries(self, I, V, meanIsc, Imax):\n        """"""\n        Calculate IV curve for cells and substrings in series given current and\n        voltage in increasing order by voltage, the average short circuit\n        current and the max current at the breakdown voltage.\n\n        :param I: cell or substring currents [A]\n        :param V: cell or substring voltages [V]\n        :param meanIsc: average short circuit current [A]\n        :param Imax: maximum current [A]\n        :return: current [A] and voltage [V] of series\n        """"""\n        # make sure all inputs are numpy arrays, but don\'t make extra copies\n        I = np.asarray(I)  # currents [A]\n        V = np.asarray(V)  # voltages [V]\n        meanIsc = np.asarray(meanIsc)  # mean Isc [A]\n        Imax = np.asarray(Imax)  # max current [A]\n        # create array of currents optimally spaced from mean Isc to  max VRBD\n        Ireverse = (Imax - meanIsc) * self.Imod_pts_sq + meanIsc\n        # range of currents in forward bias from 0 to mean Isc\n        Iforward = meanIsc * self.pts\n        Imin = np.minimum(I.min(), 0.)  # minimum cell current, at most zero\n        # range of negative currents in the 4th quadrant from min current to 0\n        Iquad4 = Imin * self.Imod_negpts\n        # create range for interpolation from forward to reverse bias\n        Itot = np.concatenate((Iquad4, Iforward, Ireverse), axis=0).flatten()\n        Vtot = np.zeros((3 * self.npts,))\n        # add up all series cell voltages\n        for i, v in zip(I, V):\n            # interp requires x, y to be sorted by x in increasing order\n            Vtot += npinterpx(Itot, np.flipud(i), np.flipud(v))\n        return np.flipud(Itot), np.flipud(Vtot)\n\n    def calcParallel(self, I, V, Vmax, Vmin, Voc=None):\n        """"""\n        Calculate IV curve for cells and substrings in parallel.\n\n        :param I: currents [A]\n        :type: I: list, :class:`numpy.ndarray`\n        :param V: voltages [V]\n        :type: V: list, :class:`numpy.ndarray`\n        :param Vmax: max voltage limit, should be max Voc [V]\n        :param Vmin: min voltage limit, could be zero or Vrbd [V]\n        :param Voc: (``None``) open circuit voltage [V]\n        """"""\n        if Voc is None:\n            Voc = Vmax\n        I, V = np.asarray(I), np.asarray(V)\n        Vmax = np.asarray(Vmax)\n        Vmin = np.asarray(Vmin)\n        Voc = np.asarray(Voc)\n        Vff = Voc\n        delta_Voc = Vmax - Voc\n        if np.isclose(delta_Voc, 0):\n            Vff = 0.8 * Voc\n            delta_Voc = 0.2 * Voc\n        elif delta_Voc < 0:\n            Vff = Vmax\n            delta_Voc = -delta_Voc\n        Vquad4 = Vff + delta_Voc * self.Vmod_q4pts\n        Vreverse = Vmin * self.negpts\n        Vforward = Vff * self.pts\n        Vtot = np.concatenate((Vreverse, Vforward, Vquad4), axis=0).flatten()\n        Itot = np.zeros((3 * self.npts,))\n        for i, v in zip(I, V):\n            Itot += npinterpx(Vtot, v, i)\n        return Itot, Vtot\n\n\ndef Vdiode(Icell, Vcell, Rs):\n    """"""\n    Calculate Vdiode from current, voltage and series resistance.\n\n    :param Icell: cell current [A]\n    :param Vcell: cell voltage [V]\n    :param Rs: cell series resistance [:math:`\\Omega`]\n    :return: diode voltage [V]\n    """"""\n    return Vcell + Icell * Rs\n\n\ndef Idiode(Isat, Vdiode, Vt, n):\n    """"""\n    Calculate diode current using `Shockley diode model`_.\n\n    :param Isat: diode saturation current [A]\n    :param Vdiode: diode voltage [V]\n    :param Vt: thermal voltage [V]\n    :param n: diode ideality factor\n    :return: diode current\n\n    .. LaTeX math directives need double backslashes in comments\n\n    .. note::\n       Thermal voltage is defined as ...\n\n       .. math::\n           V_t = \\\\frac {k_B * T} {q_e}\n\n    .. _Shockley diode model: https://en.wikipedia.org/wiki/Diode_modelling#Shockley_diode_model\n    """"""\n    return Isat * (np.exp(Vdiode / n / Vt) - 1.)\n\n\ndef Ishunt(Vdiode, Rsh):\n    return Vdiode / Rsh\n\n\ndef Igen(Aph, Ee, Isc0):\n    return Aph * Ee * Isc0\n\n\ndef get_series_cells(cell_pos_column, prev_col=None):\n    """"""\n    Get the sequence of series cells between parallel crossties.\n\n    :param cell_pos_column: column in cell position pattern\n    :param prev_col: previous column in cell position pattern\n    :return: indices of series cells\n    """"""\n    series_cells = []  # empty list of indices of cells in series\n    # if the previous column is specified, find the indices of cells in the\n    # current column that correspond to cells between parallel crossties in the\n    # previous column\n    if prev_col:\n        cell_pos_column = zip(prev_col, cell_pos_column)\n    for cell in cell_pos_column:\n        if prev_col:\n            cell, next_col = cell\n        else:\n            next_col = None\n        # noinspection PyTypeChecker\n        if cell[\'crosstie\'] == True:\n            yield series_cells\n            series_cells = []\n        # if the next column is specified, return the cell indices that\n        # correspond to the previous column since they must be the same\n        if next_col:\n            cell_idx = next_col[\'idx\']\n        else:\n            # noinspection PyTypeChecker\n            cell_idx = cell[\'idx\']\n        series_cells.append(cell_idx)\n    yield series_cells\n'"
pvmismatch/pvmismatch_lib/pvexceptions.py,0,"b'""""""\nCreated on Mar 26, 2013\n\n@author: mmikofski\n""""""\n\n\nclass PVexception(Exception):\n    """"""\n    Base exception class for pvmismatch.\n    """"""\n    pass\n\n\nclass PVparallel_calcError(PVexception):\n    def __init__(self, name):  # IGNORE:W0231\n        self.name = name\n\n    def __str__(self):\n        errmsg = (\'Parallel function from module, %s, must be on the main\' +\n                  \' thread.\')\n        return errmsg % self.name\n'"
pvmismatch/pvmismatch_lib/pvmodule.py,49,"b'# -*- coding: utf-8 -*-\n""""""\nThis module defines the :class:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule`.\n""""""\n\nfrom __future__ import absolute_import\nfrom past.builtins import xrange, range\nfrom builtins import zip\nfrom six import itervalues\nimport numpy as np\nfrom copy import copy\nfrom matplotlib import pyplot as plt\n# use absolute imports instead of relative, so modules are portable\nfrom pvmismatch.pvmismatch_lib.pvconstants import PVconstants, get_series_cells\nfrom pvmismatch.pvmismatch_lib.pvcell import PVcell\nfrom pvmismatch.pvmismatch_lib.pvexceptions import PVexception\n\nVBYPASS = np.float64(-0.5)  # [V] trigger voltage of bypass diode\nCELLAREA = np.float64(153.33)  # [cm^2] cell area\nDEFAULT_BYPASS = 0\nMODULE_BYPASS = 1\nCUSTOM_SUBSTR_BYPASS = 2\n\ndef standard_cellpos_pat(nrows, ncols_per_substr):\n    """"""\n    Standard module object builder.\n\n    Parameters\n    ----------\n    nrows : integer\n        Number of rows of cells in module.\n\n    ncols_per_substr : list of integers\n        Number of columns of cells in each substring (in parallel with a diode).\n\n    Returns\n    -------\n    cellpos : list of lists\n         Outermost list is a list of substrings in parallel with a bypass diode\n         and in series with each other.\n         The substring is a list of columns in that substring.\n         Inside the column are the actual cells in each row.\n         Each cell has a \'crosstie\' key and an index.\n    """"""\n    cellpos = []\n    ncols = [0, 0]\n    for substr_cols in ncols_per_substr:\n        ncols[0], ncols[1] = ncols[1], ncols[1] + substr_cols\n        newsubstr = []\n        for col in xrange(*ncols):\n            newrow = []\n            for row in xrange(nrows):\n                idx = col * nrows\n                if col % 2 == 0:\n                    idx += row\n                else:\n                    idx += (nrows - row - 1)\n                newrow.append({\'crosstie\': False, \'idx\': idx})\n            newsubstr.append(newrow)\n        cellpos.append(newsubstr)\n    return cellpos\n\n# standard cell positions presets\nSTD24 = standard_cellpos_pat(1, [1] * 24)\nSTD72 = standard_cellpos_pat(12, [2, 2, 2])\nSTD96 = standard_cellpos_pat(12, [2, 4, 2])\n""""""\nStandard module: 12x8 cells\nSubstrings have 2, 4 and 2 columns of cells per diode\n""""""\nSTD128 = standard_cellpos_pat(16, [2, 4, 2])\n\n\ndef crosstied_cellpos_pat(nrows_per_substrs, ncols, partial=False):\n    """"""\n    Cross-tied module object builder.\n\n    Parameters\n    ----------\n    nrows_per_substr : list of integers\n        Number of rows of cells in each substring (in parallel with a diode).\n\n    ncols : integer\n        Number of columns of cells.\n        \n    partial : boolean\n        False (default) means TCT (all cells are cross-tied).\n        True means no cross-tiling.\n\n    Returns\n    -------\n    cellpos : list of lists\n         Outermost list is a list of substrings in parallel with a bypass diode\n         and in series with each other.\n         The substring is a list of columns in that substring.\n         Inside the column are the actual cells in each row.\n         Each cell has a \'crosstie\' key and an index.\n    """"""\n    trows = sum(nrows_per_substrs)\n    cellpos = []\n    nrows = [0, 0]\n    for substr_row in nrows_per_substrs:\n        nrows[0], nrows[1] = nrows[1], nrows[1] + substr_row\n        newsubstr = []\n        for col in xrange(ncols):\n            newrow = []\n            for row in xrange(*nrows):\n                crosstie = True\n                if partial and newrow:\n                    crosstie = False\n                newrow.append({\'crosstie\': crosstie, \'idx\': col * trows + row})\n            newsubstr.append(newrow)\n        cellpos.append(newsubstr)\n    return cellpos\n\n# crosstied cell positions presets\nTCT492 = crosstied_cellpos_pat([27, 28, 27], 6)\n""""""\nStandard Tiled module with total cross-ties: 82x6 cells\nSubstrings have 27, 28 and 27 rows of cells per diode\n""""""\nPCT492 = crosstied_cellpos_pat([27, 28, 27], 6, partial=True)\n""""""\nStandard Tiled module with partial cross-ties: 82x6 cells\nSubstrings have 27, 28 and 27 rows of cells per diode\n""""""\n\n\ndef combine_parallel_circuits(IVprev_cols, pvconst):\n    """"""\n    Combine crosstied circuits in a substring\n\n    :param IVprev_cols: lists of IV curves of crosstied and series circuits\n    :param pvconst: an instance of :class:`~pvmismatch.pvconstants.PVconstants`\n    :return: current [A] and voltage [V] of the combined parallel circuites\n    """"""\n    # combine crosstied circuits\n    Irows, Vrows = [], []\n    Isc_rows, Imax_rows = [], []\n    for IVcols in zip(*IVprev_cols):\n        Iparallel, Vparallel, Voc_parallel = zip(*IVcols)\n        Iparallel = np.asarray(Iparallel)\n        Vparallel = np.asarray(Vparallel)\n        Voc_parallel = np.mean(Voc_parallel)\n        Irow, Vrow = pvconst.calcParallel(\n            Iparallel, Vparallel, Vparallel.max(),\n            Vparallel.min(), Voc=Voc_parallel\n        )\n        Irows.append(Irow)\n        Vrows.append(Vrow)\n        Isc_rows.append(np.interp(np.float64(0), Vrow, Irow))\n        Imax_rows.append(Irow.max())\n    Irows, Vrows = np.asarray(Irows), np.asarray(Vrows)\n    Isc_rows = np.asarray(Isc_rows)\n    Imax_rows = np.asarray(Imax_rows)\n    return pvconst.calcSeries(\n        Irows, Vrows, Isc_rows.mean(), Imax_rows.max()\n    )\n\ndef parse_diode_config(Vbypass, cell_pos):\n    """"""\n    Parse diode configuration from the Vbypass argument\n    :param Vbypass: Vbypass config\n    :type Vbypass: float|list|tuple\n    :param cell_pos:\n    :type cell_pos:\n    :return: bypass config\n    :rtype: str\n    """"""\n    try:\n        # check if float or list/tuple\n        num_bypass = len(Vbypass)\n    except TypeError:\n        # float passed - default case - Vbypass across every cell string\n        return DEFAULT_BYPASS\n    else:\n        # if only one value is passed in the list- assume only one\n        # bypass diode  across the PV module\n        if len(Vbypass) == 1:\n            return MODULE_BYPASS\n        # if more than 1 values are passed, apply them across\n        # the cell strings in ascending order\n        elif len(cell_pos) == num_bypass:\n            return CUSTOM_SUBSTR_BYPASS\n        else:\n            raise PVexception(""wrong number of bypass diode values passed : %d""%(len(Vbypass)))\n\nclass PVmodule(object):\n    """"""\n    A Class for PV modules.\n\n    :param cell_pos: cell position pattern\n    :type cell_pos: dict\n    :param pvcells: list of :class:`~pvmismatch.pvmismatch_lib.pvcell.PVcell`\n    :type pvcells: list, :class:`~pvmismatch.pvmismatch_lib.pvcell.PVcell`\n    :param pvconst: An object with common parameters and constants.\n    :type pvconst: :class:`~pvmismatch.pvmismatch_lib.pvconstants.PVconstants`\n    :param Vbypass: float|list of :float\n        bypass diode trigger voltage [V]\n        default case - one bypass diode per cell string (VBYPASS = -0.5V(V)) \\n\n        float - one bypass diode per cell string with Vf = Vbypass (V) \\n\n        len(list) == 1 - one bypass diode per module (bypasses entire module ) \\n\n        len(list) == len(cell_pos) - bypass diode value across cell string as defined in the list \\n\n    :param cellArea: cell area [cm^2]\n    """"""\n    def __init__(self, cell_pos=STD96, pvcells=None, pvconst=None,\n                 Vbypass=None, cellArea=CELLAREA):\n        # TODO: check cell position pattern\n        self.cell_pos = cell_pos  #: cell position pattern dictionary\n        self.numberCells = sum([len(c) for s in self.cell_pos for c in s])\n        """"""number of cells in the module""""""\n        # is pvcells a list?\n        try:\n            pvc0 = pvcells[0]\n        except TypeError:\n            # is pvcells an object?\n            try:\n                pvconst = pvcells.pvconst\n            except AttributeError:\n                #  try to use the pvconst arg or create one if none\n                if not pvconst:\n                    pvconst = PVconstants()\n                # create pvcell\n                pvcells = PVcell(pvconst=pvconst)\n            # expand pvcells to list\n            pvcells = [pvcells] * self.numberCells\n        else:\n            pvconst = pvc0.pvconst\n            for p in pvcells:\n                if p.pvconst is not pvconst:\n                    raise Exception(\'PVconstant must be the same for all cells\')\n        self.pvconst = pvconst  #: configuration constants\n        \n        # set default value of Vbypass if None\n        if Vbypass is None:\n            self.Vbypass = VBYPASS  #: [V] trigger voltage of bypass diode\n        else:\n            # if an object is passed, use that to determine the config of bypass diodes\n            self.Vbypass = Vbypass\n        self.Vbypass_config = parse_diode_config(self.Vbypass, self.cell_pos)\n\n        self.cellArea = cellArea  #: [cm^2] cell area\n        # check cell position pattern matches list of cells\n        if len(pvcells) != self.numberCells:\n            raise ValueError(\n                ""Number of cells doesn\'t match cell position pattern.""\n            )\n        self.pvcells = pvcells  #: list of `PVcell` objects in this `PVmodule`\n        self.numSubStr = len(self.cell_pos)  #: number of substrings\n        self.subStrCells = [len(_) for _ in self.cell_pos]  #: cells per substr\n        # initialize members so PyLint doesn\'t get upset\n        self.Imod, self.Vmod, self.Pmod, self.Isubstr, self.Vsubstr = self.calcMod()\n\n    # TODO: use __getattr__ to check for updates to pvcells\n\n    # copy some values from cells to modules\n    @property\n    def Ee(self):\n        return np.array([pvc.Ee.flatten() for pvc in self.pvcells])\n\n    @property\n    def Tcell(self):\n        return np.array([pvc.Tcell.flatten() for pvc in self.pvcells])\n\n    @property\n    def Icell(self):\n        return np.array([pvc.Icell.flatten() for pvc in self.pvcells])\n\n    @property\n    def Vcell(self):\n        return np.array([pvc.Vcell.flatten() for pvc in self.pvcells])\n\n    @property\n    def Pcell(self):\n        return np.array([pvc.Pcell.flatten() for pvc in self.pvcells])\n\n    @property\n    def Isc(self):\n        return np.array([pvc.Isc.flatten() for pvc in self.pvcells])\n\n    @property\n    def Voc(self):\n        return np.array([pvc.Voc.flatten() for pvc in self.pvcells])\n\n    @property\n    def VRBD(self):\n        return np.array([pvc.VRBD.flatten() for pvc in self.pvcells])\n\n    def setSuns(self, Ee, cells=None):\n        """"""\n        Set the irradiance in suns, Ee, on the solar cells in the module.\n        Recalculates cell current (Icell [A]), voltage (Vcell [V]) and power\n        (Pcell [W]) as well as module current (Imod [A]), voltage (Vmod [V])\n        and power (Pmod [W]).\n\n        Args:\n            Ee (:class:`numpy.ndarray`): Effective Irradiance [suns]\n            cells (list): Cells to change [Optional]\n        """"""\n        if cells is None:\n            if np.isscalar(Ee):\n                new_pvcells = range(self.numberCells)  # new list of cells\n                old_pvcells = dict.fromkeys(self.pvcells)  # same as set(pvcells)\n                for cell_id, pvcell in enumerate(self.pvcells):\n                    if old_pvcells[pvcell] is None:\n                        new_pvcells[cell_id] = copy(pvcell)\n                        old_pvcells[pvcell] = new_pvcells[cell_id]\n                    else:\n                        new_pvcells[cell_id] = old_pvcells[pvcell]\n                self.pvcells = new_pvcells\n                pvcell_set = itervalues(old_pvcells)\n                for pvc in pvcell_set:\n                    pvc.Ee = Ee\n            elif np.size(Ee) == self.numberCells:\n                self.pvcells = copy(self.pvcells)  # copy list first\n                for cell_idx, Ee_idx in enumerate(Ee):\n                    self.pvcells[cell_idx] = copy(self.pvcells[cell_idx])\n                    self.pvcells[cell_idx].Ee = Ee_idx\n            else:\n                raise Exception(""Input irradiance value (Ee) for each cell!"")\n        else:\n            Ncells = np.size(cells)\n            self.pvcells = copy(self.pvcells)  # copy list first\n            if np.isscalar(Ee):\n                cells_to_update = [self.pvcells[i] for i in cells]\n                old_pvcells = dict.fromkeys(cells_to_update)\n                for cell_id, pvcell in zip(cells, cells_to_update):\n                    if old_pvcells[pvcell] is None:\n                        self.pvcells[cell_id] = copy(pvcell)\n                        self.pvcells[cell_id].Ee = Ee\n                        old_pvcells[pvcell] = self.pvcells[cell_id]\n                    else:\n                        self.pvcells[cell_id] = old_pvcells[pvcell]\n            elif np.size(Ee) == Ncells:\n                # Find unique irradiance values\n                # TODO possible ""cleaner"" alternative by grouping cells into tuples that match the set irradiance\n                # E.g: pvsys.setSuns({X: {Y: {\'Ee\': (0.33, 0.99), \'cells\': [(2, 3), 17]}}})\n                cells = np.array(cells)\n                Ee = np.array(Ee)\n                unique_ee = np.unique(Ee)\n                for a_Ee in unique_ee:\n                    cells_subset = cells[Ee == a_Ee]\n                    cells_to_update = [self.pvcells[i] for i in cells_subset]\n                    old_pvcells = dict.fromkeys(cells_to_update)\n                    for cell_id, pvcell in zip(cells_subset, cells_to_update):\n                        if old_pvcells[pvcell] is None:\n                            self.pvcells[cell_id] = copy(pvcell)\n                            self.pvcells[cell_id].Ee = a_Ee\n                            old_pvcells[pvcell] = self.pvcells[cell_id]\n                        else:\n                            self.pvcells[cell_id] = old_pvcells[pvcell]\n            else:\n                raise Exception(""Input irradiance value (Ee) for each cell!"")\n        self.Imod, self.Vmod, self.Pmod, self.Isubstr, self.Vsubstr = self.calcMod()\n\n    # TODO setTemps is a nearly identical copy of setSuns. The DRY principle\n    # says that we should not be copying code.\n    # TODO Replace both setSuns() and setTemps() with a single method for\n    # updating cell parameters that works for all params\n\n    def setTemps(self, Tc, cells=None):\n        """"""\n        Set the temperature in Kelvin, Tc, on the solar cells in the module.\n        Recalculates cell current (Icell [A]), voltage (Vcell [V]) and power\n        (Pcell [W]) as well as module current (Imod [A]), voltage (Vmod [V])\n        and power (Pmod [W]).\n\n        Args:\n            Tc (:class:`numpy.ndarray`): Cell Temperature [K]\n            cells (list): Cells to change [Optional]\n        """"""\n        if cells is None:\n            if np.isscalar(Tc):\n                new_pvcells = range(self.numberCells)  # new list of cells\n                old_pvcells = dict.fromkeys(self.pvcells)  # same as set(pvcells)\n                for cell_id, pvcell in enumerate(self.pvcells):\n                    if old_pvcells[pvcell] is None:\n                        new_pvcells[cell_id] = copy(pvcell)\n                        old_pvcells[pvcell] = new_pvcells[cell_id]\n                    else:\n                        new_pvcells[cell_id] = old_pvcells[pvcell]\n                self.pvcells = new_pvcells\n                pvcell_set = itervalues(old_pvcells)\n                for pvc in pvcell_set:\n                    pvc.Tcell = Tc\n            elif np.size(Tc) == self.numberCells:\n                self.pvcells = copy(self.pvcells)  # copy list first\n                for cell_idx, Tc_idx in enumerate(Tc):\n                    self.pvcells[cell_idx] = copy(self.pvcells[cell_idx])\n                    self.pvcells[cell_idx].Tcell = Tc_idx\n            else:\n                raise Exception(""Input temperature value (Tc) for each cell!"")\n        else:\n            Ncells = np.size(cells)\n            self.pvcells = copy(self.pvcells)  # copy list first\n            if np.isscalar(Tc):\n                cells_to_update = [self.pvcells[i] for i in cells]\n                old_pvcells = dict.fromkeys(cells_to_update)\n                for cell_id, pvcell in zip(cells, cells_to_update):\n                    if old_pvcells[pvcell] is None:\n                        self.pvcells[cell_id] = copy(pvcell)\n                        self.pvcells[cell_id].Tcell = Tc\n                        old_pvcells[pvcell] = self.pvcells[cell_id]\n                    else:\n                        self.pvcells[cell_id] = old_pvcells[pvcell]\n            elif np.size(Tc) == Ncells:\n                # Find unique irradiance values\n                # TODO possible ""cleaner"" alternative by grouping cells into tuples that match the set temp\n                # E.g: pvsys.setTemps({X: {Y: {\'Tc\': (280, 290), \'cells\': [(2, 3), 17]}}})\n                cells = np.array(cells)\n                Tc = np.array(Tc)\n                unique_tc = np.unique(Tc)\n                for a_Tc in unique_tc:\n                    cells_subset = cells[Tc == a_Tc]\n                    cells_to_update = [self.pvcells[i] for i in cells_subset]\n                    old_pvcells = dict.fromkeys(cells_to_update)\n                    for cell_id, pvcell in zip(cells_subset, cells_to_update):\n                        if old_pvcells[pvcell] is None:\n                            self.pvcells[cell_id] = copy(pvcell)\n                            self.pvcells[cell_id].Tcell = a_Tc\n                            old_pvcells[pvcell] = self.pvcells[cell_id]\n                        else:\n                            self.pvcells[cell_id] = old_pvcells[pvcell]\n            else:\n                raise Exception(""Input temperature value (Tc) for each cell!"")\n        self.Imod, self.Vmod, self.Pmod, self.Isubstr, self.Vsubstr = self.calcMod()\n\n    def calcMod(self):\n        """"""\n        Calculate module I-V curves.\n\n        Returns module currents [A], voltages [V] and powers [W]\n        """"""\n        # iterate over substrings\n        # TODO: benchmark speed difference append() vs preallocate space\n        Isubstr, Vsubstr, Isc_substr, Imax_substr = [], [], [], []\n        for substr_idx, substr in enumerate(self.cell_pos):\n            # check if cells are in series or any crosstied circuits\n            if all(r[\'crosstie\'] == False for c in substr for r in c):\n                idxs = [r[\'idx\'] for c in substr for r in c]\n                IatVrbd = np.asarray(\n                    [np.interp(vrbd, v, i) for vrbd, v, i in\n                     zip(self.VRBD[idxs], self.Vcell[idxs], self.Icell[idxs])]\n                )\n                Isub, Vsub = self.pvconst.calcSeries(\n                    self.Icell[idxs], self.Vcell[idxs], self.Isc[idxs].mean(),\n                    IatVrbd.max()\n                )\n            elif all(r[\'crosstie\'] == True for c in substr for r in c):\n                Irows, Vrows = [], []\n                Isc_rows, Imax_rows = [], []\n                for row in zip(*substr):\n                    idxs = [c[\'idx\'] for c in row]\n                    Irow, Vrow = self.pvconst.calcParallel(\n                        self.Icell[idxs], self.Vcell[idxs],\n                        self.Voc[idxs].max(), self.VRBD.min(),\n                        Voc=self.Voc[idxs].mean()\n                    )\n                    Irows.append(Irow)\n                    Vrows.append(Vrow)\n                    Isc_rows.append(np.interp(np.float64(0), Vrow, Irow))\n                    Imax_rows.append(Irow.max())\n                Irows, Vrows = np.asarray(Irows), np.asarray(Vrows)\n                Isc_rows = np.asarray(Isc_rows)\n                Imax_rows = np.asarray(Imax_rows)\n                Isub, Vsub = self.pvconst.calcSeries(\n                    Irows, Vrows, Isc_rows.mean(), Imax_rows.max()\n                )\n            else:\n                IVall_cols = []\n                prev_col = None\n                IVprev_cols = []\n                for col in substr:\n                    IVcols = []\n                    is_first = True\n                    # combine series between crossties\n                    for idxs in get_series_cells(col, prev_col):\n                        if not idxs:\n                            # first row should always be empty since it must be\n                            # crosstied\n                            is_first = False\n                            continue\n                        elif is_first:\n                            # TODO: use pvmismatch exceptions\n                            raise Exception(\n                                ""First row and last rows must be crosstied.""\n                            )\n                        elif len(idxs) > 1:\n                            IatVrbd = np.asarray(\n                                [np.interp(vrbd, v, i) for vrbd, v, i in\n                                 zip(self.VRBD[idxs], self.Vcell[idxs],\n                                     self.Icell[idxs])]\n                            )\n                            Icol, Vcol = self.pvconst.calcSeries(\n                                self.Icell[idxs], self.Vcell[idxs],\n                                self.Isc[idxs].mean(), IatVrbd.max()\n                            )\n                        else:\n                            Icol, Vcol = self.Icell[idxs], self.Vcell[idxs]\n                        IVcols.append([Icol, Vcol, self.Voc[idxs].sum()])\n                    # append IVcols and continue\n                    IVprev_cols.append(IVcols)\n                    if prev_col:\n                        # if circuits are same in both columns then continue\n                        if not all(icol[\'crosstie\'] == jcol[\'crosstie\']\n                                   for icol, jcol in zip(prev_col, col)):\n                            # combine crosstied circuits\n                            Iparallel, Vparallel = combine_parallel_circuits(\n                                IVprev_cols, self.pvconst\n                            )\n                            IVall_cols.append([Iparallel, Vparallel])\n                            # reset prev_col\n                            prev_col = None\n                            IVprev_cols = []\n                            continue\n                    # set prev_col and continue\n                    prev_col = col\n                # combine any remaining crosstied circuits in substring\n                if not IVall_cols:\n                    # combine crosstied circuits\n                    Isub, Vsub = combine_parallel_circuits(\n                        IVprev_cols, self.pvconst\n                    )\n                else:\n                    Iparallel, Vparallel = zip(*IVall_cols)\n                    Iparallel = np.asarray(Iparallel)\n                    Vparallel = np.asarray(Vparallel)\n                    Voc_parallel = np.asarray([\n                        np.interp(np.float64(0), np.flipud(i_par), np.flipud(v_par))\n                        for i_par, v_par in zip(Iparallel, Vparallel)])\n                    Isub, Vsub = self.pvconst.calcParallel(\n                        Iparallel, Vparallel, Vparallel.max(), Vparallel.min(),\n                        Voc=Voc_parallel.mean()\n                    )\n\n\n            if self.Vbypass_config == DEFAULT_BYPASS:\n                bypassed = Vsub < self.Vbypass\n                Vsub[bypassed] = self.Vbypass\n            elif self.Vbypass_config == CUSTOM_SUBSTR_BYPASS:\n                if self.Vbypass[substr_idx] is None:\n                    # no bypass for this substring\n                    pass\n                else:\n                    # bypass the substring\n                    bypassed = Vsub < self.Vbypass[substr_idx]\n                    Vsub[bypassed] = self.Vbypass[substr_idx]\n            elif self.Vbypass_config == MODULE_BYPASS:\n                # module bypass value will be assigned after the for loop for substrings is over\n                pass\n\n            Isubstr.append(Isub)\n            Vsubstr.append(Vsub)\n            Isc_substr.append(np.interp(np.float64(0), Vsub, Isub))\n            Imax_substr.append(Isub.max())\n            \n        Isubstr, Vsubstr = np.asarray(Isubstr), np.asarray(Vsubstr)\n        Isc_substr = np.asarray(Isc_substr)\n        Imax_substr = np.asarray(Imax_substr)\n        Imod, Vmod = self.pvconst.calcSeries(\n            Isubstr, Vsubstr, Isc_substr.mean(), Imax_substr.max()\n        )\n        \n        # if entire module has only one bypass diode\n        if self.Vbypass_config == MODULE_BYPASS:\n            bypassed = Vmod < self.Vbypass[0]\n            Vmod[bypassed] = self.Vbypass[0]\n        else:\n            pass\n\n        Pmod = Imod * Vmod\n        return Imod, Vmod, Pmod, Isubstr, Vsubstr\n\n    def plotCell(self):\n        """"""\n        Plot cell I-V curves.\n        Returns cellPlot : matplotlib.pyplot figure\n        """"""\n        cellPlot = plt.figure()\n        plt.subplot(2, 2, 1)\n        plt.plot(self.Vcell.T, self.Icell.T)\n        plt.title(\'Cell Reverse I-V Characteristics\')\n        plt.ylabel(\'Cell Current, I [A]\')\n        plt.xlim(self.VRBD.min() - 1, 0)\n        plt.ylim(0, self.Isc.mean() + 10)\n        plt.grid()\n        plt.subplot(2, 2, 2)\n        plt.plot(self.Vcell.T, self.Icell.T)\n        plt.title(\'Cell Forward I-V Characteristics\')\n        plt.ylabel(\'Cell Current, I [A]\')\n        plt.xlim(0, self.Voc.max())\n        plt.ylim(0, self.Isc.mean() + 1)\n        plt.grid()\n        plt.subplot(2, 2, 3)\n        plt.plot(self.Vcell.T, self.Pcell.T)\n        plt.title(\'Cell Reverse P-V Characteristics\')\n        plt.xlabel(\'Cell Voltage, V [V]\')\n        plt.ylabel(\'Cell Power, P [W]\')\n        plt.xlim(self.VRBD.min() - 1, 0)\n        plt.ylim((self.Isc.mean() + 10) * (self.VRBD.min() - 1), -1)\n        plt.grid()\n        plt.subplot(2, 2, 4)\n        plt.plot(self.Vcell.T, self.Pcell.T)\n        plt.title(\'Cell Forward P-V Characteristics\')\n        plt.xlabel(\'Cell Voltage, V [V]\')\n        plt.ylabel(\'Cell Power, P [W]\')\n        plt.xlim(0, self.Voc.max())\n        plt.ylim(0, (self.Isc.mean() + 1) * self.Voc.max())\n        plt.grid()\n        plt.tight_layout()\n        return cellPlot\n\n    def plotMod(self):\n        """"""\n        Plot module I-V curves.\n        Returns modPlot : matplotlib.pyplot figure\n        """"""\n        modPlot = plt.figure()\n        ax = plt.subplot(2, 1, 1)\n        plt.plot(self.Vmod, self.Imod)\n        plt.title(\'Module I-V Characteristics\')\n        plt.ylabel(\'Module Current, I [A]\')\n        plt.ylim(ymin=0)\n        plt.xlim(self.Vmod.min() - 1, self.Vmod.max() + 1)\n        plt.grid()\n        plt.subplot(2, 1, 2, sharex=ax)\n        plt.plot(self.Vmod, self.Pmod)\n        plt.title(\'Module P-V Characteristics\')\n        plt.xlabel(\'Module Voltage, V [V]\')\n        plt.ylabel(\'Module Power, P [W]\')\n        plt.ylim(ymin=0)\n        plt.xlim(self.Vmod.min() - 1, self.Vmod.max() + 1)\n        plt.grid()\n        plt.tight_layout()\n        return modPlot\n'"
pvmismatch/pvmismatch_lib/pvstring.py,6,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nThis module contains the :class:`~pvmismatch.pvmismatch_lib.pvstring.PVstring`\r\nclass.\r\n""""""\r\n\r\nfrom __future__ import absolute_import\r\nfrom past.builtins import range\r\nfrom future.utils import iteritems\r\nimport numpy as np\r\nfrom copy import copy\r\nfrom matplotlib import pyplot as plt\r\n# use absolute imports instead of relative, so modules are portable\r\nfrom pvmismatch.pvmismatch_lib.pvconstants import PVconstants, NUMBERMODS\r\nfrom pvmismatch.pvmismatch_lib.pvmodule import PVmodule\r\n\r\n\r\nclass PVstring(object):\r\n    """"""\r\n    A class for PV strings.\r\n\r\n    :param numberMods: number of modules in string\r\n    :param pvmods: either a list of modules, an instance of\r\n        :class:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule` [Optional]\r\n    :type pvmods: list, :class:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule`\r\n    :param pvconst: a configuration constants object\r\n    """"""\r\n    def __init__(self, numberMods=NUMBERMODS, pvmods=None,\r\n                 pvconst=None):\r\n        # is pvmods a list?\r\n        try:\r\n            pvmod0 = pvmods[0]\r\n        except TypeError:\r\n            # is pvmods an object?\r\n            try:\r\n                pvconst = pvmods.pvconst\r\n            except AttributeError:\r\n                #  try to use the pvconst arg or create one if none\r\n                if not pvconst:\r\n                    pvconst = PVconstants()\r\n                # create pvmod\r\n                pvmods = PVmodule(pvconst=pvconst)\r\n            # expand pvmods to list\r\n            pvmods = [pvmods] * numberMods\r\n        else:\r\n            pvconst = pvmod0.pvconst\r\n            numberMods = len(pvmods)\r\n            for p in pvmods:\r\n                if p.pvconst is not pvconst:\r\n                    raise Exception(\'pvconst must be the same for all modules\')\r\n        self.pvconst = pvconst  #: ``PVconstants`` used in  ``PVstring``\r\n        self.numberMods = numberMods  #: number of module in string\r\n        self.pvmods = pvmods  #: list of ``PVModule`` in ``PVstring``\r\n        # calculate string\r\n        self.Istring, self.Vstring, self.Pstring = self.calcString()\r\n\r\n    # TODO: use __getattr__ to check for updates to pvcells\r\n\r\n    @property\r\n    def Imod(self):\r\n        return np.array([mod.Imod.flatten() for mod in self.pvmods])\r\n\r\n    @property\r\n    def Vmod(self):\r\n        return np.array([mod.Vmod.flatten() for mod in self.pvmods])\r\n\r\n    @property\r\n    def Voc_mod(self):\r\n        return np.array([mod.Voc.sum() for mod in self.pvmods])\r\n\r\n    def calcString(self):\r\n        """"""\r\n        Calculate string I-V curves.\r\n        Returns (Istring, Vstring, Pstring) : tuple of numpy.ndarray of float\r\n        """"""\r\n        # Imod is already set to the range from Vrbd to the minimum current\r\n        meanIsc = np.mean([pvmod.Isc.mean() for pvmod in self.pvmods])\r\n        Istring, Vstring = self.pvconst.calcSeries(self.Imod, self.Vmod,\r\n                                                   meanIsc, self.Imod.max())\r\n        Pstring = Istring * Vstring\r\n        return Istring, Vstring, Pstring\r\n\r\n    def setSuns(self, Ee):\r\n        """"""\r\n        Set irradiance on cells in modules of string in system.\r\n        If Ee is ...\r\n        ... scalar, then sets the entire string to that irradiance.\r\n        ... a dictionary, then each key refers to a module in the string,\r\n        and the corresponding value are passed to\r\n        :meth:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule.setSuns()`\r\n\r\n        :param Ee: irradiance [suns]\r\n        :type Ee: dict or float\r\n\r\n        For Example::\r\n\r\n            Ee={0: {\'cells\': (1,2,3), \'Ee\': (0.9, 0.3, 0.5)}}  # set module 0\r\n            Ee=0.91  # set all modules to 0.91 suns\r\n            Ee={12: 0.77}  # set module with index 12 to 0.77 suns\r\n            Ee={8: [0.23, (0, 1, 2)], 7: [(0.45, 0.35), (71, 72)]}\r\n            # set module 8, cells 0, 1 and 2 to 0.23 suns, then set module 7, cell\r\n            #   71 to 0.45 suns and module 72 to 0.35 suns.\r\n\r\n        """"""\r\n        if np.isscalar(Ee):\r\n            new_pvmods = range(self.numberMods)  # new list of modules\r\n            old_pvmods = dict.fromkeys(self.pvmods)  # same as set(pvmods)\r\n            for mod_id, pvmod in enumerate(self.pvmods):\r\n                if old_pvmods[pvmod] is None:\r\n                    new_pvmods[mod_id] = copy(pvmod)\r\n                    old_pvmods[pvmod] = new_pvmods[mod_id]\r\n                else:\r\n                    new_pvmods[mod_id] = old_pvmods[pvmod]\r\n            self.pvmods = new_pvmods\r\n            for pvmod in iter(self.pvmods):\r\n                pvmod.setSuns(Ee)\r\n        else:\r\n            self.pvmods = copy(self.pvmods)  # copy list first\r\n            try:\r\n                for pvmod, cell_Ee in iteritems(Ee):\r\n                    pvmod = int(pvmod)\r\n                    self.pvmods[pvmod] = copy(self.pvmods[pvmod])\r\n                    if hasattr(cell_Ee, \'keys\'):\r\n                        self.pvmods[pvmod].setSuns(**cell_Ee)\r\n                    else:\r\n                        try:\r\n                            self.pvmods[pvmod].setSuns(*cell_Ee)\r\n                        except TypeError:\r\n                            self.pvmods[pvmod].setSuns(cell_Ee)\r\n            except AttributeError:\r\n                # Ee was a list? just take first item in list\r\n                if len(Ee) > 1:\r\n                    raise TypeError(\'Irradiance, Ee, should be scalar or dict\')\r\n                Ee = Ee[0]\r\n                new_pvmods = range(self.numberMods)  # new list of modules\r\n                old_pvmods = dict.fromkeys(self.pvmods)  # same as set(pvmods)\r\n                for mod_id, pvmod in enumerate(self.pvmods):\r\n                    if old_pvmods[pvmod] is None:\r\n                        new_pvmods[mod_id] = copy(pvmod)\r\n                        old_pvmods[pvmod] = new_pvmods[mod_id]\r\n                    else:\r\n                        new_pvmods[mod_id] = old_pvmods[pvmod]\r\n                self.pvmods = new_pvmods\r\n                for pvmod in iter(self.pvmods):\r\n                    pvmod.setSuns(Ee)\r\n        # update modules\r\n        self.Istring, self.Vstring, self.Pstring = self.calcString()\r\n\r\n    def setTemps(self, Tc):\r\n        """"""\r\n        Set temperature on cells in modules of string in system.\r\n        If Tc is ...\r\n        ... scalar, then sets the entire string to that temperature.\r\n        ... a dictionary, then each key refers to a module in the string,\r\n        and the corresponding value are passed to\r\n        :meth:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule.setTemps()`\r\n\r\n        :param Tc: temperature [K]\r\n        :type Tc: dict or float\r\n\r\n        For Example::\r\n\r\n            Tc={0: {\'cells\': (1,2,3), \'Tc\': (323.15, 348.15, 373.15)}}  # set module 0\r\n            Tc=323.15  # set all modules to 323.15K (50\xc2\xb0C)\r\n            Tc={12: 348.15}  # set module with index 12 to 348.15K (75\xc2\xb0C)\r\n\r\n        """"""\r\n        if np.isscalar(Tc):\r\n            new_pvmods = range(self.numberMods)  # new list of modules\r\n            old_pvmods = dict.fromkeys(self.pvmods)  # same as set(pvmods)\r\n            for mod_id, pvmod in enumerate(self.pvmods):\r\n                if old_pvmods[pvmod] is None:\r\n                    new_pvmods[mod_id] = copy(pvmod)\r\n                    old_pvmods[pvmod] = new_pvmods[mod_id]\r\n                else:\r\n                    new_pvmods[mod_id] = old_pvmods[pvmod]\r\n            self.pvmods = new_pvmods\r\n            for pvmod in iter(self.pvmods):\r\n                pvmod.setTemps(Tc)\r\n        else:\r\n            self.pvmods = copy(self.pvmods)  # copy list first\r\n            try:\r\n                for pvmod, cell_Tc in iteritems(Tc):\r\n                    pvmod = int(pvmod)\r\n                    self.pvmods[pvmod] = copy(self.pvmods[pvmod])\r\n                    if hasattr(cell_Tc, \'keys\'):\r\n                        self.pvmods[pvmod].setTemps(**cell_Tc)\r\n                    else:\r\n                        try:\r\n                            self.pvmods[pvmod].setTemps(*cell_Tc)\r\n                        except TypeError:\r\n                            self.pvmods[pvmod].setTemps(cell_Tc)\r\n            except AttributeError:\r\n                # Tc was a list? just take first item in list\r\n                if len(Tc) > 1:\r\n                    raise TypeError(\'Irradiance, Ee, should be scalar or dict\')\r\n                Tc = Tc[0]\r\n                new_pvmods = range(self.numberMods)  # new list of modules\r\n                old_pvmods = dict.fromkeys(self.pvmods)  # same as set(pvmods)\r\n                for mod_id, pvmod in enumerate(self.pvmods):\r\n                    if old_pvmods[pvmod] is None:\r\n                        new_pvmods[mod_id] = copy(pvmod)\r\n                        old_pvmods[pvmod] = new_pvmods[mod_id]\r\n                    else:\r\n                        new_pvmods[mod_id] = old_pvmods[pvmod]\r\n                self.pvmods = new_pvmods\r\n                for pvmod in iter(self.pvmods):\r\n                    pvmod.setTemps(Tc)\r\n        # update modules\r\n        self.Istring, self.Vstring, self.Pstring = self.calcString()\r\n\r\n    def plotStr(self):\r\n        """"""\r\n        Plot string I-V curves.\r\n        Returns strPlot : matplotlib.pyplot figure\r\n        """"""\r\n        strPlot = plt.figure()\r\n        ax = plt.subplot(2, 1, 1)\r\n        plt.plot(self.Vstring, self.Istring)\r\n        plt.title(\'String I-V Characteristics\')\r\n        plt.ylabel(\'String Current, I [A]\')\r\n        plt.ylim(ymin=0)\r\n        plt.grid()\r\n        plt.subplot(2, 1, 2, sharex=ax)\r\n        plt.plot(self.Vstring, self.Pstring)\r\n        plt.title(\'String P-V Characteristics\')\r\n        plt.xlabel(\'String Voltage, V [V]\')\r\n        plt.ylabel(\'String Power, P [W]\')\r\n        plt.grid()\r\n        plt.tight_layout()\r\n        return strPlot\r\n'"
pvmismatch/pvmismatch_lib/pvsystem.py,13,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nThis module contains the :class:`~pvmismatch.pvmismatch_lib.pvsystem.PVsystem`\r\nclass.\r\n""""""\r\n\r\nfrom __future__ import absolute_import\r\nfrom past.builtins import basestring\r\nfrom future.utils import iteritems\r\nimport numpy as np\r\nfrom copy import copy\r\nfrom matplotlib import pyplot as plt\r\n# use absolute imports instead of relative, so modules are portable\r\nfrom pvmismatch.pvmismatch_lib.pvconstants import PVconstants, NUMBERMODS, \\\r\n    NUMBERSTRS\r\nfrom pvmismatch.pvmismatch_lib.pvstring import PVstring\r\n\r\n\r\nclass PVsystem(object):\r\n    """"""\r\n    A class for PV systems.\r\n\r\n    :param pvconst: configuration constants object\r\n    :type pvconst: :class:`~pvmismatch.pvmismatch_lib.pvconstants.PVconstants`\r\n    :param numberStrs: number of strings\r\n    :param pvstrs: list of parallel strings, a ``PVstring`` object or None\r\n    :param numberMods: number of modules per string\r\n    :param pvmods: list of modules, a ``PVmodule`` object or None\r\n    """"""\r\n    def __init__(self, pvconst=None, numberStrs=NUMBERSTRS,\r\n                 pvstrs=None, numberMods=NUMBERMODS, pvmods=None):\r\n        # is pvstrs a list?\r\n        try:\r\n            pvstr0 = pvstrs[0]\r\n        except TypeError:\r\n            # is pvstrs a PVstring object?\r\n            try:\r\n                pvconst = pvstrs.pvconst\r\n            except AttributeError:\r\n                # try to use the pvconst arg or create one if none\r\n                if not pvconst:\r\n                    pvconst = PVconstants()\r\n                # create a pvstring\r\n                pvstrs = PVstring(numberMods=numberMods, pvmods=pvmods,\r\n                                  pvconst=pvconst)\r\n            # expand pvstrs to list\r\n            pvstrs = [pvstrs] * numberStrs\r\n            numberMods = [numberMods] * numberStrs\r\n        else:\r\n            pvconst = pvstr0.pvconst\r\n            numberStrs = len(pvstrs)\r\n            numberMods = []\r\n            for p in pvstrs:\r\n                if p.pvconst is not pvconst:\r\n                    raise Exception(\'pvconst must be the same for all strings\')\r\n                numberMods.append(len(p.pvmods))\r\n        self.pvconst = pvconst  #: ``PVconstants`` used in ``PVsystem``\r\n        self.numberStrs = numberStrs  #: number strings in the system\r\n        self.numberMods = numberMods  #: list of number of modules per string\r\n        self.pvstrs = pvstrs  #: list of ``PVstring`` in system\r\n        # calculate pvsystem\r\n        self.update()\r\n\r\n    def update(self):\r\n        """"""Update system calculations.""""""\r\n        self.Isys, self.Vsys, self.Psys = self.calcSystem()\r\n        (self.Imp, self.Vmp, self.Pmp,\r\n         self.Isc, self.Voc, self.FF, self.eff) = self.calcMPP_IscVocFFeff()\r\n\r\n    # TODO: use __getattr__ to check for updates to pvcells\r\n\r\n    @property\r\n    def pvmods(self):\r\n        return [pvstr.pvmods for pvstr in self.pvstrs]\r\n\r\n    @property\r\n    def Istring(self):\r\n        return np.asarray([pvstr.Istring.flatten() for pvstr in self.pvstrs])\r\n\r\n    @property\r\n    def Vstring(self):\r\n        return np.asarray([pvstr.Vstring.flatten() for pvstr in self.pvstrs])\r\n\r\n    @property\r\n    def Voc_str(self):\r\n        return np.asarray([pvstr.Voc_mod.sum() for pvstr in self.pvstrs])\r\n\r\n    def calcSystem(self):\r\n        """"""\r\n        Calculate system I-V curves.\r\n        Returns (Isys, Vsys, Psys) : tuple of numpy.ndarray of float\r\n        """"""\r\n        Isys, Vsys = self.pvconst.calcParallel(\r\n            self.Istring, self.Vstring, self.Voc_str.max(), self.Vstring.min()\r\n        )\r\n        Psys = Isys * Vsys\r\n        return Isys, Vsys, Psys\r\n\r\n    def calcMPP_IscVocFFeff(self):\r\n        mpp = np.argmax(self.Psys)\r\n        P = self.Psys[mpp - 1:mpp + 2]\r\n        V = self.Vsys[mpp - 1:mpp + 2]\r\n        I = self.Isys[mpp - 1:mpp + 2]\r\n        # calculate derivative dP/dV using central difference\r\n        dP = np.diff(P, axis=0)  # size is (2, 1)\r\n        dV = np.diff(V, axis=0)  # size is (2, 1)\r\n        Pv = dP / dV  # size is (2, 1)\r\n        # dP/dV is central difference at midpoints,\r\n        Vmid = (V[1:] + V[:-1]) / 2.0  # size is (2, 1)\r\n        Imid = (I[1:] + I[:-1]) / 2.0  # size is (2, 1)\r\n        # interpolate to find Vmp\r\n        Vmp = (-Pv[0] * np.diff(Vmid, axis=0) / np.diff(Pv, axis=0) + Vmid[0]).item()\r\n        Imp = (-Pv[0] * np.diff(Imid, axis=0) / np.diff(Pv, axis=0) + Imid[0]).item()\r\n        # calculate max power at Pv = 0\r\n        Pmp = Imp * Vmp\r\n        # calculate Voc, current must be increasing so flipup()\r\n        Voc = np.interp(np.float64(0), np.flipud(self.Isys),\r\n                        np.flipud(self.Vsys))\r\n        Isc = np.interp(np.float64(0), self.Vsys, self.Isys)  # calculate Isc\r\n        FF = Pmp / Isc / Voc\r\n        totalSuns = sum(\r\n            [pvmod.Ee.sum() * pvmod.cellArea for pvstr in self.pvmods\r\n             for pvmod in pvstr]\r\n        )\r\n        # convert cellArea from cm^2 to m^2\r\n        Psun = self.pvconst.E0 * totalSuns / 100 / 100\r\n        eff = Pmp / Psun\r\n        return Imp, Vmp, Pmp, Isc, Voc, FF, eff\r\n\r\n    def setSuns(self, Ee):\r\n        """"""\r\n        Set irradiance on cells in modules of string in system.\r\n        If Ee is ...\r\n        ... scalar, then sets the entire system to that irradiance.\r\n        ... a dictionary, then each key refers to a pv-string in the system,\r\n        and the corresponding value is either a dictionary or a scalar.\r\n        If the dictionary\'s value is another dictionary, then its keys are pv-\r\n        modules and its values are either cells and corresponding Ee, cells and\r\n        a scalar Ee, a scalar Ee value for all cells or an array of Ee values\r\n        for all cells in the module. The values of pv-modules are passed to\r\n        :meth:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule.setSuns()`\r\n\r\n        :param Ee: irradiance [suns]\r\n        :type Ee: dict, float\r\n\r\n        For Example::\r\n\r\n            Ee={0: {0: {\'cells\': (0, 1, 2), \'Ee\': (0.9, 0.3, 0.5)}}}\r\n            Ee=0.91  # set all modules in all strings to 0.91 suns\r\n            Ee={12: 0.77}  # set all modules in string with index 12 to 0.77 suns\r\n            Ee={3: {8: 0.23, 7: 0.45}}\r\n            # set module with index 8 to 0.23 suns and module with index 7 to\r\n            # 0.45 suns in string with index 3\r\n\r\n        """"""\r\n        if np.isscalar(Ee):\r\n            for pvstr in self.pvstrs:\r\n                pvstr.setSuns(Ee)\r\n        else:\r\n            for pvstr, pvmod_Ee in iteritems(Ee):\r\n                pvstr = int(pvstr)\r\n                self.pvstrs[pvstr] = copy(self.pvstrs[pvstr])\r\n                self.pvstrs[pvstr].setSuns(pvmod_Ee)\r\n        # calculate pvsystem\r\n        self.update()\r\n\r\n    def setTemps(self, Tc):\r\n        """"""\r\n        Set temperature on cells in modules of string in system.\r\n        If Tc is ...\r\n        ... scalar, then sets the entire system to that cell temperature.\r\n        ... a dictionary, then each key refers to a pv-string in the system,\r\n        and the corresponding value is either a dictionary or a scalar.\r\n        If the dictionary\'s value is another dictionary, then its keys are pv-\r\n        modules and its values are either cells and corresponding Tc, cells and\r\n        a scalar Tc, a scalar Tc value for all cells or an array of Tc values\r\n        for all cells in the module. The values of pv-modules are passed to\r\n        :meth:`~pvmismatch.pvmismatch_lib.pvmodule.PVmodule.setTemps()`\r\n\r\n        :param Tc: temperature [K]\r\n        :type Tc: dict, float\r\n\r\n        For Example::\r\n\r\n            Tc={0: {0: {\'cells\': (1,2,3), \'Tc\': (323.15, 348.15, 373.15)}}}\r\n            Tc=323.15  # set all modules in all strings to 323.15K (50\xc2\xb0C)\r\n            Tc={12: 348.15}  # set all modules in string with index 12 to 348.15K (75\xc2\xb0C)\r\n            Tc={3: {8: 333.15, 7: 373.15}}\r\n            # set module with index 8 to 333.15K (60\xc2\xb0C) and module with index 7 to\r\n            # 373.15K (100\xc2\xb0C) in string with index 3\r\n\r\n        """"""\r\n        if np.isscalar(Tc):\r\n            for pvstr in self.pvstrs:\r\n                pvstr.setTemps(Tc)\r\n        else:\r\n            for pvstr, pvmod_Tc in iteritems(Tc):\r\n                pvstr = int(pvstr)\r\n                self.pvstrs[pvstr] = copy(self.pvstrs[pvstr])\r\n                self.pvstrs[pvstr].setTemps(pvmod_Tc)\r\n        # calculate pvsystem\r\n        self.update()\r\n\r\n    def plotSys(self, sysPlot=None, fmt=\'\'):\r\n        """"""\r\n        Plot system I-V curves.\r\n\r\n        :param sysPlot: integer, string, or existing figure\r\n        :returns: new figure\r\n        """"""\r\n        # create new figure if sysPlot or make the specified sysPlot current\r\n        # and clear it\r\n        try:\r\n            sysPlot.clear()\r\n        except (AttributeError, SyntaxError):\r\n            sysPlot = plt.figure(sysPlot)\r\n        ax = plt.subplot(2, 1, 1)\r\n        plt.plot(self.Vsys, self.Isys, fmt)\r\n        plt.xlim(0, self.Voc * 1.1)\r\n        plt.ylim(0, self.Isc * 1.1)\r\n        plt.axvline(self.Vmp, color=\'r\', linestyle=\':\')\r\n        plt.axhline(self.Imp, color=\'r\', linestyle=\':\')\r\n        plt.title(\'System I-V Characteristics\')\r\n        plt.ylabel(\'System Current, I [A]\')\r\n        plt.grid()\r\n        plt.subplot(2, 1, 2, sharex=ax)\r\n        plt.plot(self.Vsys, self.Psys / 1000, fmt)\r\n        plt.xlim(0, self.Voc * 1.1)\r\n        plt.ylim(0, self.Pmp * 1.1 / 1000)\r\n        plt.axvline(self.Vmp, color=\'r\', linestyle=\':\')\r\n        plt.axhline(self.Pmp / 1000, color=\'r\', linestyle=\':\')\r\n        plt.title(\'System P-V Characteristics\')\r\n        plt.xlabel(\'System Voltage, V [V]\')\r\n        plt.ylabel(\'System Power, P [kW]\')\r\n        plt.grid()\r\n        plt.tight_layout()\r\n        return sysPlot\r\n'"
pvmismatch/pvmismatch_tk/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed May 30 11:53:52 2012\n\n@author: mmikofski\n""""""\n\n__all__ = [\'pvapplication_tk\', \'pvmodule_tk\', \'pvstring_tk\', \'pvsystem_tk\',\n           \'advCnf_tk\']\n'"
pvmismatch/pvmismatch_tk/advCnf_tk.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Aug 18, 2012\n\n@author: mmikofski\n""""""\n\nfrom Tkconstants import W, E, RIGHT\nfrom Tkinter import Frame, Label, Button, DoubleVar, Entry, IntVar\nimport tkFont\n\nPVAPP_TXT = \'PVmismatch\'\nINTEGERS = \'0123456789\'\nFLOATS = \'.\' + INTEGERS\n\n\nclass AdvCnf_tk(Frame):\n    """"""\n    classdocs\n    """"""\n\n    def __init__(self, pvapp, top):\n        """"""\n        Constructor\n        """"""\n        self.pvapp = pvapp\n        Frame.__init__(self, top, name=\'advCnf\')\n        self.pack()\n        self.focus_set()  # get the focus\n        self.grab_set()  # make this window modal\n        top.resizable(False, False)  # not resizable in x or y\n        top.title(PVAPP_TXT)  # set title bar\n        top.protocol(""WM_DELETE_WINDOW"", self.quit)  # close window to quit\n        CAPTION_FONT = tkFont.nametofont(\'TkCaptionFont\')  # font for titles\n\n        # variables\n        cellnum = self.cellnum = IntVar(self, name=\'cellnum\')\n        Rs = self.Rs = DoubleVar(self, name=\'Rs\')\n        Rsh = self.Rsh = DoubleVar(self, name=\'Rsh\')\n        Isat1_T0 = self.Isat1_T0 = DoubleVar(self, name=\'Isat1_T0\')\n        Isat2 = self.Isat2 = DoubleVar(self, name=\'Isat2\')\n        Rs.set(""{:10.4e}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Rs))\n        Rsh.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Rsh))\n        Isat1_T0.set(""{:10.4e}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Isat1_T0))\n        Isat2.set(""{:10.4e}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Isat2))\n        Aph = self.Aph = DoubleVar(self, name=\'Aph\')\n        Isc0_T0 = self.Isc0_T0 = DoubleVar(self, name=\'Isc0_T0\')\n        Tcell = self.Tcell = DoubleVar(self, name=\'Tcell\')\n        Vbypass = self.Vbypass = DoubleVar(self, name=\'Vbypasss\')\n        Aph.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Aph))\n        Isc0_T0.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Isc0_T0))\n        Tcell.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].Tcell))\n        Vbypass.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].Vbypass))\n        aRBD = self.aRBD = DoubleVar(self, name=\'aRBD\')\n        VRBD = self.VRBD = DoubleVar(self, name=\'VRBD\')\n        nRBD = self.nRBD = DoubleVar(self, name=\'nRBD\')\n        cellArea = self.cellArea = DoubleVar(self, name=\'cellArea\')\n        aRBD.set(""{:10.4e}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].aRBD))\n        VRBD.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].VRBD))\n        nRBD.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[cellnum.get() % pvapp.numCells.get()].nRBD))\n        cellArea.set(""{:10.4f}"".format(pvapp.pvSys.pvmods[cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].cellArea))\n\n        # must register vcmd and invcmd as Tcl functions\n        vcmd = (self.register(self.validateWidget),\n                \'%d\', \'%i\', \'%P\', \'%s\', \'%S\', \'%v\', \'%V\', \'%W\')\n        invcmd = (self.register(self.invalidWidget),\n                \'%d\', \'%i\', \'%P\', \'%s\', \'%S\', \'%v\', \'%V\', \'%W\')\n\n        # layout\n        _row = 0\n        Label(self,\n              text=\'Advanced Configuration\',\n              font=CAPTION_FONT).grid(row=_row, columnspan=3, sticky=W)\n        _row += 1\n        # cellnum, Rs, Rsh, Isat1_T0\n        Label(self, text=\'cell #\').grid(row=_row, sticky=W)\n        Label(self, text=\'Rs [Ohms]\').grid(row=_row + 1, sticky=W)\n        Label(self, text=\'Rsh [Ohms]\').grid(row=(_row + 2), sticky=W)\n        Label(self, text=\'Isat1_T0 [A]\').grid(row=(_row + 3), sticky=W)\n        cellnumEntry = Entry(self, textvariable=cellnum, width=12, justify=RIGHT,\n                             name=\'cellnumEntry\', validatecommand=vcmd,\n                             invalidcommand=invcmd, validate=\'all\')\n        cellnumEntry.grid(row=_row, column=1)\n        RsEntry = Entry(self, textvariable=Rs, width=12, justify=RIGHT,\n                        name=\'rsEntry\', validatecommand=vcmd,\n                        invalidcommand=invcmd, validate=\'all\')\n        RsEntry.grid(row=_row + 1, column=1)\n        RshEntry = Entry(self, textvariable=Rsh, width=12, justify=RIGHT,\n                         name=\'rshEntry\', validatecommand=vcmd,\n                         invalidcommand=invcmd, validate=\'all\')\n        RshEntry.grid(row=(_row + 2), column=1)\n        Isat1_T0Entry = Entry(self, textvariable=Isat1_T0, width=12,\n                              justify=RIGHT, name=\'isat1_T0Entry\',\n                              validatecommand=vcmd, invalidcommand=invcmd,\n                              validate=\'all\')\n        Isat1_T0Entry.grid(row=(_row + 3), column=1)\n        _row += 4  # row 2, 3, 4, 5\n        # Isat2, Isc0_T0, Tcell, Vbypasss\n        Label(self, text=\'Isat2 [A]\').grid(row=(_row), sticky=W)\n        Label(self, text=\'Isc0_T0 [A]\').grid(row=(_row + 1), sticky=W)\n        Label(self, text=\'Tcell [K]\').grid(row=(_row + 2), sticky=W)\n        Label(self, text=\'Vbypass [V]\').grid(row=(_row + 3), sticky=W)\n        Isat2Entry = Entry(self, textvariable=Isat2, width=12, justify=RIGHT,\n                           name=\'isat2Entry\', validatecommand=vcmd,\n                           invalidcommand=invcmd, validate=\'all\')\n        Isat2Entry.grid(row=(_row), column=1)\n        Isc01_T0Entry = Entry(self, textvariable=Isc0_T0, width=12,\n                             justify=RIGHT, name=\'isc01_T0Entry\',\n                             validatecommand=vcmd, invalidcommand=invcmd,\n                             validate=\'all\')\n        Isc01_T0Entry.grid(row=(_row + 1), column=1)\n        TcellEntry = Entry(self, textvariable=Tcell, width=12, justify=RIGHT,\n                           name=\'tcellEntry\', validatecommand=vcmd,\n                           invalidcommand=invcmd, validate=\'all\')\n        TcellEntry.grid(row=(_row + 2), column=1)\n        VbypassEntry = Entry(self, textvariable=Vbypass, width=12,\n                             justify=RIGHT, name=\'vbypassEntry\',\n                             validatecommand=vcmd, invalidcommand=invcmd,\n                             validate=\'all\')\n        VbypassEntry.grid(row=(_row + 3), column=1)\n        _row += 4\n        # aRBD, VRBD, nRBD, cellArea\n        Label(self, text=\'aRBD\').grid(row=_row, sticky=W)\n        Label(self, text=\'VRBD [V]\').grid(row=(_row + 1), sticky=W)\n        Label(self, text=\'nRBD\').grid(row=(_row + 2), sticky=W)\n        Label(self, text=\'cell area [cm^2]\').grid(row=(_row + 3), sticky=W)\n        aRBDEntry = Entry(self, textvariable=aRBD, width=12, justify=RIGHT,\n                          name=\'aRBDEntry\', validatecommand=vcmd,\n                          invalidcommand=invcmd, validate=\'all\')\n        aRBDEntry.grid(row=_row, column=1)\n        VRBDEntry = Entry(self, textvariable=VRBD, width=12, justify=RIGHT,\n                          name=\'vRBDEntry\', validatecommand=vcmd,\n                          invalidcommand=invcmd, validate=\'all\')\n        VRBDEntry.grid(row=(_row + 1), column=1)\n        nRBDEntry = Entry(self, textvariable=nRBD, width=12, justify=RIGHT,\n                          name=\'nRBDEntry\', validatecommand=vcmd,\n                          invalidcommand=invcmd, validate=\'all\')\n        nRBDEntry.grid(row=(_row + 2), column=1)\n        cellAreaEntry = Entry(self, textvariable=cellArea, width=12,\n                              justify=RIGHT, name=\'cellAreaEntry\',\n                              validatecommand=vcmd, invalidcommand=invcmd,\n                              validate=\'all\')\n        cellAreaEntry.grid(row=(_row + 3), column=1)\n        _row += 4\n        Button(self, text=\'OK\',\n               command=self.okay).grid(row=_row, sticky=(E + W))\n        Button(self, text=\'Cancel\',\n               command=self.quit).grid(row=_row, column=1, sticky=(E + W))\n\n    def okay(self):\n        # get the new values\n        validationConstants = self.pvapp.validationConstants\n        messagetext = self.pvapp.messagetext\n        Rs = self.Rs.get()\n        if not (0 < Rs <= validationConstants[""advCnf""][""Rs""]):\n            self.pvapp.msgtext.set(\'Invalid series resistance!\')\n            self.bell()\n            return\n        Rsh = self.Rsh.get()\n        if not (0 < Rsh <= validationConstants[""advCnf""][""Rsh""]):\n            self.pvapp.msgtext.set(\'Invalid shunt resistance!\')\n            self.bell()\n            return\n        Isat1_T0 = self.Isat1_T0.get()\n        if not 0 < Isat1_T0 <= validationConstants[""advCnf""][""Isat1_T0""]:\n            self.pvapp.msgtext.set(\'Invalid diode-1 saturation current!\')\n            self.bell()\n            return\n        Isat2 = self.Isat2.get()\n        if not 0 < Isat2 <= validationConstants[""advCnf""][""Isat2""]:\n            self.pvapp.msgtext.set(\'Invalid diode-2 saturation current!\')\n            self.bell()\n            return\n        Aph = self.Aph.get()\n        if not 0 < Aph <= validationConstants[""advCnf""][""Aph""]:\n            errtext = \'Invalid photo-generated current coefficient!\'\n            self.pvapp.msgtext.set(errtext)\n            self.bell()\n            return\n        Isc0_T0 = self.Isc0_T0.get()\n        if not 1 < Isc0_T0 <= validationConstants[""advCnf""][""Isc0_T0""]:\n            self.pvapp.msgtext.set(\'Invalid short circuit current!\')\n            self.bell()\n            return\n        Tcell = self.Tcell.get()\n        if not 0 < Tcell <= validationConstants[""advCnf""][""Tcell""]:\n            self.pvapp.msgtext.set(\'Invalid cell temperature!\')\n            self.bell()\n            return\n        cellArea = self.cellArea.get()\n        if not 0 < cellArea <= validationConstants[""advCnf""][""cellArea""]:\n            self.pvapp.msgtext.set(\'Invalid cell area!\')\n            self.bell()\n            return\n        Vbypass = self.Vbypass.get()\n        if not 0 > Vbypass >= validationConstants[""advCnf""][""Vbypass""]:\n            errtext = \'Invalid bypass diode trigger voltage!\'\n            self.pvapp.msgtext.set(errtext)\n            self.bell()\n            return\n        aRBD = self.aRBD.get()\n        if not 0 < aRBD <= validationConstants[""advCnf""][""aRBD""]:\n            errtext = \'Invalid reverse bias breakdown coefficient (aRBD)!\'\n            self.pvapp.msgtext.set(errtext)\n            self.bell()\n            return\n        VRBD = self.VRBD.get()\n        if not 0 > VRBD >= validationConstants[""advCnf""][""VRBD""]:\n            errtext = \'Invalid reverse bias breakdown voltage!\'\n            self.pvapp.msgtext.set(errtext)\n            self.bell()\n            return\n        nRBD = self.nRBD.get()\n        if not 0 < nRBD <= validationConstants[""advCnf""][""nRBD""]:\n            errtext = \'Invalid reverse bias breakdown exponent (nRBD)!\'\n            self.pvapp.msgtext.set(errtext)\n            self.bell()\n            return\n        # update PVconstants\n        self.pvapp.msgtext.set(messagetext[""pvapplication""][""Ready""])\n        pvapp = self.pvapp\n        kwargs = {\'Rs\': Rs, \'Rsh\': Rsh, \'Isat1_T0\': Isat1_T0, \'Isat2\': Isat2, \'Isc0_T0\': Isc0_T0, \'Tcell\': Tcell, \'aRBD\': aRBD, \'VRBD\': VRBD, \'nRBD\': nRBD}\n        pvapp.pvSys.pvmods[self.cellnum.get() / (pvapp.numCells.get() * pvapp.numMods.get())][(self.cellnum.get() / pvapp.numCells.get()) % pvapp.numMods.get()].pvcells[self.cellnum.get() % pvapp.numCells.get()].update(\n            **kwargs\n        )  # cellArea, Vbypass updated by module\n        # update PVapplication_tk\n        self.pvapp.updatePVsys(pvapp.pvSys)\n        self.pvapp.updateIVstats()\n        self.quit()\n\n#    Validation substitutions\n#    %d  Type of action: 1 for insert, 0 for delete, or -1 for focus, forced or\n#        textvariable validation.\n#    %i  Index of char string to be inserted/deleted, if any, otherwise -1.\n#    %P  The value of the spinbox should edition occur. If you are configuring\n#        the spinbox widget to have a new textvariable, this will be the value\n#        of that textvariable.\n#    %s  The current value of spinbox before edition.\n#    %S  The text string being inserted/deleted, if any. Otherwise it is an\n#        empty string.\n#    %v  The type of validation currently set.\n#    %V  The type of validation that triggered the callback (key, focusin,\n#        focusout, forced).\n#    %W  The name of the spinbox widget.\n\n# TODO: Fix these functions so that delete and overwrite work\n\n    def validateWidget(self, *args):\n        # W = Tkinter.W = \'w\' is already used, so use W_ instead\n        (d, i, P, s, S, v, V, W_) = args  # @UnusedVariable # IGNORE:W0612\n        print ""OnValidate:"",\n        print(""d={}, i={}, P={}, s={}, S={}, v={}, V={}, W={}"".format(*args))\n        if W_ == \'.advCnfTop.advCnf.rsEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.rshEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.isat1_T0Entry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.isat2Entry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.aphEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val) - 1  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.isc01_T0Entry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.tcellEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.vbypassEntry\':\n            valType = FLOATS\n            valTest = lambda val: -float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.aRBDEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.vRBDEntry\':\n            valType = FLOATS\n            valTest = lambda val: -float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.nRBDEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.cellAreaEntry\':\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        elif W_ == \'.advCnfTop.advCnf.cellnumEntry\':\n            valType = INTEGERS\n            valTest = lambda val: int(val)  # IGNORE:W0108\n        else:\n            return False\n        w = self.nametowidget(W_)\n        w.config(validate=v)\n        if S in valType:\n            try:\n                valTest(P)\n            except ValueError:\n                return False\n            return True\n        else:\n            return False\n\n    def invalidWidget(self, *args):\n        (d, i, P, s, S, v, V, W_) = args  # @UnusedVariable # IGNORE:W0612\n        print ""OnInvalid: "",\n        print(""d={}, i={}, P={}, s={}, S={}, v={}, V={}, W={}"".format(*args))\n        if W_ == "".advCnfTop.advCnf.rsEntry"":\n            errText = \'Invalid series resistance!\'\n        elif W_ == "".advCnfTop.advCnf.rshEntry"":\n            errText = \'Invalid shunt resistance!\'\n        elif W_ == "".advCnfTop.advCnf.isat1_T0Entry"":\n            errText = \'Invalid diode-1 saturation current!\'\n        elif W_ == "".advCnfTop.advCnf.isat2Entry"":\n            errText = \'Invalid diode-2 saturation current!\'\n        elif W_ == "".advCnfTop.advCnf.aphEntry"":\n            errText = \'Invalid photo-generated current coefficient!\'\n        elif W_ == "".advCnfTop.advCnf.isc01_T0Entry"":\n            errText = \'Invalid short circuit current!\'\n        elif W_ == "".advCnfTop.advCnf.tcellEntry"":\n            errText = \'Invalid cell temperature!\'\n        elif W_ == "".advCnfTop.advCnf.vbypassEntry"":\n            errText = \'Invalid bypass diode trigger voltage!\'\n        elif W_ == "".advCnfTop.advCnf.aRBDEntry"":\n            errText = \'Invalid reverse bias breakdown coefficient (aRBD)!\'\n        elif W_ == "".advCnfTop.advCnf.vRBDEntry"":\n            errText = \'Invalid reverse bias breakdown voltage!\'\n        elif W_ == "".advCnfTop.advCnf.nRBDEntry"":\n            errText = \'Invalid reverse bias breakdown exponent (nRBD)!\'\n        elif W_ == "".advCnfTop.advCnf.cellAreaEntry"":\n            errText = \'Invalid cell area!\'\n        elif W_ == "".advCnfTop.advCnf.cellnumEntry"":\n            errText = \'Invalid cell number!\'\n        else:\n            errText = \'Unknown widget!\'\n        w = self.nametowidget(W_)\n        w.config(validate=v)\n        self.pvapp.msgtext.set(errText)\n        self.bell()\n'"
pvmismatch/pvmismatch_tk/pvapplication_tk.py,4,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Jul 29, 2012\n\n@author: marko\n""""""\nfrom PIL import Image, ImageTk\nfrom Tkconstants import RIGHT, LEFT, BOTH, E, W, HORIZONTAL\nfrom Tkinter import Frame, Label, Button, Toplevel, OptionMenu, Scale, Entry, \\\n    Message, Spinbox, IntVar, StringVar, DoubleVar\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, \\\n    NavigationToolbar2TkAgg\nfrom threading import Thread\nfrom tkFont import nametofont\nimport Queue\nimport json\nimport logging\nimport numpy as np\nimport os\nfrom pvmismatch.pvmismatch_lib.pvconstants import MODSIZES, NUMBERCELLS, \\\n    NUMBERMODS, NUMBERSTRS\nfrom pvmismatch.pvmismatch_lib.pvmodule import STD128, STD72, STD96, STD24\nfrom pvmismatch import PVsystem as PVsystem_cls, PVmodule, PVcell\n# use absolute imports instead of relative, so modules are portable\nfrom pvmismatch import __name__ as __pkg_name__, __file__ as __pkg_file__\nfrom pvmismatch.pvmismatch_tk.advCnf_tk import AdvCnf_tk\nfrom pvmismatch.pvmismatch_tk.pvexceptions import PVValidationError\nfrom pvmismatch.pvmismatch_tk.pvstring_tk import PVstring_tk\nimport webbrowser\n\nINTEGERS = \'0123456789\'\nFLOATS = \'.\' + INTEGERS\nPVAPP_TXT = __pkg_name__\nREADY_MSG = \'Ready\'\nLANGUAGE = \'English\'\nPKG_BASEDIR = os.path.dirname(__pkg_file__)\nJSONDIR = os.path.join(PKG_BASEDIR, \'pvmismatch_json\')\nSPLOGO = os.path.join(PKG_BASEDIR, \'res\', \'logo_bg.png\')\nDOCS = os.path.join(PKG_BASEDIR, \'docs\', \'_build\', \'html\', \'index.html\')\n\nlogging.basicConfig(level=logging.DEBUG,\n                    format=\'[%(levelname)s] (%(threadName)-10s) %(message)s\')\n\n\nclass waitWidget(Frame):  # pylint: disable=R0924,R0904\n    """"""\n    A wait widget that shows something is happening.\n    """"""\n    def __init__(self, queue, master):\n        self.queue = queue\n        Frame.__init__(self, master)\n        self.pack(fill=""both"")\n        self.focus_set()  # get the focus\n        self.grab_set()  # make this window modal\n        master.resizable(False, False)  # not resizable\n        master.title("""")  # no title\n        # don\'t let user close window using X - instead call timer\n        master.protocol(""WM_DELETE_WINDOW"", self.timer)\n        self.wait = IntVar(master, 0, ""wait"")\n        Label(master, bitmap=""hourglass"").pack(fill=""both"")\n        Label(master, text=""Please wait ..."").pack(fill=""both"")\n        Label(master, textvariable=self.wait).pack(fill=""both"")\n        self.timer()\n\n    def timer(self):\n        """"""\n        A callback that counts milliseconds until SELF.QUEUE has somthing in it\n        """"""\n        wait = self.wait.get() + 1\n        if not self.queue.empty():\n            # when queue is filled, quit loop and print elapsed time\n            logging.debug(\'elapsed time = %2.1f [s]\', wait * 0.10)\n            self.quit()\n        self.wait.set(wait)\n        # loop over this callback every 100[ms] until queue is filled\n        self.after(100, self.timer)\n\n\ndef setqueue(original_function, queue):\n    """"""\n    Create a new function QUEUEFUN that calculates the results from the\n    ORIGINAL_FUNCTION and puts them in a queue.\n    :param original_function: The function the results of which are added to \\\n        the queue.\n    :param queue: The queue to which the results of the original_function are \\\n        added.\n    :return queuefun: The new function.\n    """"""\n    def queuefun(*args, **kwargs):\n        """"""\n        Call ORIGINAL_FUNCTION with ARGS & KWARGS and put the results in QUEUE.\n        NOTE: this is function *call*, not a function object!\n        This is equivalent to:\n        >>> results = original_function(*args, **kwargs)  # calc results\n        >>> queue.put(results)  # put results in queue\n        >>> results = queue.get()  # get results from queue\n        \n        """"""\n        logging.debug(\'Starting\')\n        queue.put(original_function(*args, **kwargs))\n        logging.debug(\'Exiting\')\n\n    return queuefun\n\n\ndef waitbox(original_function):\n    """"""\n    Create a new function that adds a waitbox widget to original_function.\n    :param original_function: A funciton to wrap with a waitbox waitWidget\n    """"""\n    def new_function(*args, **kwargs):\n        """"""\n        Create a queue, create a queuefun from original_function and make the\n        new queuefun the target of a thread, passing the thread target\n        original_function\'s args and kwargs. Then instantiate a new Tk Toplevel\n        Frame called master and a new waitWidget with the queue and master.\n        Start master\'s mainloop which exits when the original_function\'s\n        results are fed to the queue. Destroy master and return the\n        original_function\'s results.\n        """"""\n        queue = Queue.Queue()\n        queuefun = setqueue(original_function, queue)\n        thread = Thread(target=queuefun, args=args, kwargs=kwargs)\n        thread.start()\n        master = Toplevel()\n        waitBox = waitWidget(queue, master)\n        waitBox.mainloop()\n        master.destroy()\n        return queue.get()\n\n    return new_function\n\nPVsystem = waitbox(PVsystem_cls)  # wrap PVsystem with a waitbox waitWidget\n\n\nclass PVapplicaton(Frame):\n    """"""\n    classdocs\n    """"""\n\n    def __init__(self, master=None):\n        """"""\n        Constructor\n        """"""\n        Frame.__init__(self, master, name=\'pvApplication\',\n                       bg=\'black\', padx=5, pady=5)\n        # set black background, pad sides with 15 points, top/bottom 5 points\n        # fill=BOTH fills in padding with background color\n        # w/o fill=BOTH padding is default color\n        # side=TOP is the default\n        self.pack(fill=BOTH)\n        master.resizable(False, False)  # not resizable in x or y\n        master.title(PVAPP_TXT)  # set title bar of master (a.k.a. root)\n        master.protocol(""WM_DELETE_WINDOW"", self._quit)  # close window to quit\n\n        self.validationConstants = self.readJSON(\'validationConstants\')\n        self.messagetext = self.readJSON(\'messagetext\' + \'.\' + LANGUAGE)\n        MAX_STRINGS = self.validationConstants[""pvapplication""][""numStrs""]\n        MAX_MODULES = self.validationConstants[""pvapplication""][""numMods""]\n        MAX_SUNS = self.validationConstants[""pvapplication""][""sysEe""]\n        CAPTION_FONT = nametofont(\'TkCaptionFont\')  # font for titles\n\n        # PVsystem\n        pvSys = self.pvSys = PVsystem()\n\n        # variables\n        numStrs = self.numStrs = IntVar(self, NUMBERSTRS, \'numStrs\')\n        numMods = self.numMods = IntVar(self, NUMBERMODS, \'numMods\')\n        numCells = self.numCells = IntVar(self, NUMBERCELLS, \'numCells\')\n        txtIsys = self.txtIsys = DoubleVar(self, name=\'txtIsys\')\n        txtVsys = self.txtVsys = DoubleVar(self, name=\'txtVsys\')\n        txtPsys = self.txtPsys = DoubleVar(self, name=\'txtPsys\')\n        txtImp = self.txtImp = StringVar(self, name=\'txtImp\')\n        txtVmp = self.txtVmp = StringVar(self, name=\'txtVmp\')\n        txtPmp = self.txtPmp = StringVar(self, name=\'txtPmp\')\n        txtIsc = self.txtIsc = StringVar(self, name=\'txtIsc\')\n        txtVoc = self.txtVoc = StringVar(self, name=\'txtVoc\')\n        txtFF = self.txtFF = StringVar(self, name=\'txtFF\')\n        txtEff = self.txtEff = StringVar(self, name=\'txtEff\')\n        sysEe = self.sysEe = DoubleVar(self, 1, name=\'sysEe\')\n        txtImp.set(""{:7.3f}"".format(self.pvSys.Imp))  # [A]\n        txtVmp.set(""{:7.3f}"".format(self.pvSys.Vmp))  # [V]\n        txtPmp.set(""{:7.3f}"".format(self.pvSys.Pmp / 1000))  # [kW]\n        txtIsc.set(""{:7.3f}"".format(self.pvSys.Isc))  # [A]\n        txtVoc.set(""{:7.3f}"".format(self.pvSys.Voc))  # [V]\n        txtFF.set(""{:7.3f}"".format(self.pvSys.FF * 100))  # [%]\n        txtEff.set(""{:7.3f}"".format(self.pvSys.eff * 100))  # [%]\n        self.msgtext = StringVar(self, READY_MSG, \'msgtext\')\n\n        # must register vcmd and invcmd as Tcl functions\n        vcmd = (self.register(self.validateWidget),\n                \'%d\', \'%i\', \'%P\', \'%s\', \'%S\', \'%v\', \'%V\', \'%W\')\n        invcmd = (self.register(self.invalidWidget),\n                \'%d\', \'%i\', \'%P\', \'%s\', \'%S\', \'%v\', \'%V\', \'%W\')\n\n        # SP logo\n        # convert image to tk-compatible format (.gif, .pgm, or .ppm)\n        self.SPlogo = ImageTk.PhotoImage(Image.open(SPLOGO))\n        # bg=\'black\' fills extra space with black\n        # anchor=W aligns photoimage on left side, NW is no different\n        # padding is ignored by images, use borderwidth\n        Label(self, image=self.SPlogo, borderwidth=5, bg=\'black\',\n              anchor=W).pack(fill=BOTH)\n        # fill=BOTH expands the photoimage to fill parent frame\n        # w/o fill=BOTH photoimage is centered in frame even with anchor=W\n        # Intro text\n        introText = \'PVmismatch calculates I-V and P-V curves as well as the\'\n        introText += \' max power point (MPP) for any sized system.\\nSet the\'\n        introText += \' number of strings in the system, the number of modules\'\n        introText += \' per string and the number cells per module.\'\n        # anchor=W aligns message on left side, NW is no different\n        # fg=\'white\' sets text color to white, default is black, so it doesn\'t\n        #   show on black background\n        # default aspect is 150%, about as wide as high, or set width>0\n        Message(self, text=introText, width=750, bg=\'black\', fg=\'white\',\n                anchor=W).pack(fill=BOTH)\n        # fill=BOTH expands the message to fill parent frame\n        # w/o fill=BOTH message is centered in frame even with anchor=W\n\n        # PVsystem frame\n        pvSysFrame = self.pvSysFrame = Frame(master, name=\'pvSysFrame\')\n        # fill=BOTH keeps widgets in frame on left when window is resized\n        pvSysFrame.pack(fill=BOTH)\n\n        # PVsystem matplotlib figure canvas\n        self.pvSysPlotFrame = Frame(pvSysFrame, name=\'pvSysPlotFrame\')\n        pvSysPlotFrame = self.pvSysPlotFrame\n        pvSysPlotFrame.pack(side=RIGHT)\n        pvSysPlot = self.pvSysPlot = pvSys.plotSys()\n        self.pvSysFigCanvas = FigureCanvasTkAgg(pvSysPlot,\n                                                master=pvSysPlotFrame,\n                                                resize_callback=None)\n        pvSysFigCanvas = self.pvSysFigCanvas\n        pvSysFigCanvas.get_tk_widget()._name = \'pvSysFigCanvas\'  # IGNORE:W0212\n        pvSysFigCanvas.show()\n        # NB: FigureCanvasTkAgg._tkcanvas is FigureCanvasTkAgg.get_tk_widget()\n        pvSysFigCanvas.get_tk_widget().pack(fill=BOTH)\n        pvSysToolbar = NavigationToolbar2TkAgg(pvSysFigCanvas, pvSysPlotFrame)\n        pvSysToolbar.update()\n        pvSysToolbar.pack(fill=BOTH)\n\n        # PVsystem data frame\n        pvSysDataFrame = self.pvSysDataFrame = Frame(pvSysFrame,\n                                                     name=\'pvSysDataFrame\')\n        pvSysDataFrame.pack(side=LEFT)\n        _row = 0\n        Label(pvSysDataFrame,\n              text=\'PVsystem\', font=CAPTION_FONT).grid(row=_row, columnspan=3,\n                                                     sticky=W)\n\n        # number of strings\n        _row += 1  # row 1\n        Label(pvSysDataFrame,\n              text=\'Number of Strings\').grid(row=_row, columnspan=2, sticky=W)\n        # use textVar to set number of strings from LOAD, RESET or default\n        spinboxCnf = {\'name\': \'numStrSpinbox\', \'from_\': 1, \'to\': MAX_STRINGS,\n                      \'textvariable\': numStrs, \'width\': 5, \'validate\': \'all\',\n                      \'validatecommand\': vcmd, \'invalidcommand\': invcmd,\n                      \'command\': self.updatePVsys}\n        self.numStrSpinbox = Spinbox(pvSysDataFrame, cnf=spinboxCnf)\n        self.numStrSpinbox.bind(""<Return>"", self.keyBinding)\n        self.numStrSpinbox.grid(row=_row, column=2)\n\n        # number of modules\n        _row += 1  # row 2\n        Label(pvSysDataFrame,\n              text=\'Number of Modules\').grid(row=_row, columnspan=2, sticky=W)\n        # number of modules spinbox\n        spinboxCnf = {\'name\': \'numModSpinbox\', \'from_\': 1, \'to\': MAX_MODULES,\n                      \'textvariable\': numMods, \'width\': 5, \'validate\': \'all\',\n                      \'validatecommand\': vcmd, \'invalidcommand\': invcmd,\n                      \'command\': self.updatePVsys}\n        self.numModSpinbox = Spinbox(pvSysDataFrame, cnf=spinboxCnf)\n        self.numModSpinbox.bind(""<Return>"", self.keyBinding)\n        self.numModSpinbox.grid(row=_row, column=2)\n\n        # number of cells\n        _row += 1  # row 3\n        Label(pvSysDataFrame,\n              text=\'Number of Cells\').grid(row=_row, columnspan=2, sticky=W)\n        # http://www.logilab.org/card/pylintfeatures#basic-checker\n        # pylint: disable = W0142\n        self.numCellOption = OptionMenu(pvSysDataFrame, numCells, *MODSIZES,\n                                        command=self.updatePVsys)\n        # pylint: enable = W0142\n        self.numCellOption._name = \'numCellOption\'  # IGNORE:W0212\n        self.numCellOption.grid(row=_row, column=2)\n\n        # Advanced Configuration button\n        _row += 1  # row 14\n        buttonCnf = {\'name\': \'advCnfButton\', \'text\': \'Advanced Configuration\',\n                     \'command\': self.startAdvCnf_tk}\n        pvStrButton = self.pvStrButton = Button(pvSysDataFrame, buttonCnf)\n        pvStrButton.grid(row=_row, columnspan=3, sticky=(E + W))\n\n        # slider to explore IV curves\n        _row += 1  # row 4, 5 & 6\n        self.pvSysScale = Scale(pvSysDataFrame, orient=HORIZONTAL,\n                                label=\'I-V Curve\', font=CAPTION_FONT,\n                                command=self.getIV, showvalue=False,\n                                from_=0, to=(pvSys.pvconst.npts - 1))\n        self.pvSysScale.grid(row=_row, columnspan=3, sticky=(E + W))\n        # Isys\n        Label(pvSysDataFrame, text=\'Isys [A]\').grid(row=(_row + 1))\n        self.pvIsys = Entry(pvSysDataFrame, textvariable=txtIsys,\n                            width=7)\n        self.pvIsys.grid(row=(_row + 2))\n        # Vsys\n        Label(pvSysDataFrame, text=\'Vsys [V]\').grid(row=(_row + 1), column=1)\n        self.pvVsys = Entry(pvSysDataFrame, textvariable=txtVsys,\n                            width=7)\n        self.pvVsys.grid(row=(_row + 2), column=1)\n        # Psys\n        Label(pvSysDataFrame, text=\'Psys [kW]\').grid(row=(_row + 1), column=2)\n        self.pvPsys = Entry(pvSysDataFrame, textvariable=txtPsys,\n                            width=7)\n        self.pvPsys.grid(row=(_row + 2), column=2)\n\n        # Imp, Vmp & Pmp\n        _row += 3  # row 7, 8, 9, 10, 11 & 12\n        Label(pvSysDataFrame,\n              text=\'I-V Characteristics\',\n              font=CAPTION_FONT).grid(row=_row, columnspan=3, sticky=W)\n        Label(pvSysDataFrame, text=\'Imp [A]\').grid(row=(_row + 1))\n        Label(pvSysDataFrame, text=\'Vmp [V]\').grid(row=(_row + 1), column=1)\n        Label(pvSysDataFrame, text=\'Pmp [kW]\').grid(row=(_row + 1), column=2)\n        self.pvImp = Entry(pvSysDataFrame, textvariable=txtImp,\n                            width=7, state=\'readonly\')\n        self.pvImp.grid(row=(_row + 2))\n        self.pvVmp = Entry(pvSysDataFrame, textvariable=txtVmp,\n                            width=7, state=\'readonly\')\n        self.pvVmp.grid(row=(_row + 2), column=1)\n        self.pvPmp = Entry(pvSysDataFrame, textvariable=txtPmp,\n                            width=7, state=\'readonly\')\n        self.pvPmp.grid(row=(_row + 2), column=2)\n        # Isc, Voc & FF\n        Label(pvSysDataFrame, text=\'Isc [A]\').grid(row=(_row + 3))\n        Label(pvSysDataFrame, text=\'Voc [V]\').grid(row=(_row + 3), column=1)\n        Label(pvSysDataFrame, text=\'FF [%]\').grid(row=(_row + 3), column=2)\n        self.pvIsc = Entry(pvSysDataFrame, textvariable=txtIsc,\n                            width=7, state=\'readonly\')\n        self.pvIsc.grid(row=(_row + 4))\n        self.pvVoc = Entry(pvSysDataFrame, textvariable=txtVoc,\n                            width=7, state=\'readonly\')\n        self.pvVoc.grid(row=(_row + 4), column=1)\n        self.pvFF = Entry(pvSysDataFrame, textvariable=txtFF,\n                            width=7, state=\'readonly\')\n        self.pvFF.grid(row=(_row + 4), column=2)\n        Label(pvSysDataFrame, text=\'Efficiency [%]\').grid(row=(_row + 5),\n                                                          columnspan=2)\n        self.pvEff = Entry(pvSysDataFrame, textvariable=txtEff,\n                            width=7, state=\'readonly\')\n        self.pvEff.grid(row=(_row + 5), column=2)\n\n        # set suns\n        _row += 6  # row 13\n        Label(pvSysDataFrame, text=\'Irradiance [suns]\',\n              font=CAPTION_FONT).grid(row=_row, columnspan=2, sticky=W)\n        # number of modules spinbox\n        spinboxCnf = {\'name\': \'sunSpinbox\', \'from_\': 0.2, \'to\': MAX_SUNS,\n                      \'increment\': 0.1, \'textvariable\': sysEe, \'width\': 5,\n                      \'validate\': \'all\', \'validatecommand\': vcmd,\n                      \'invalidcommand\': invcmd, \'command\': self.updatePVsys}\n        self.sunSpinbox = Spinbox(pvSysDataFrame, cnf=spinboxCnf)\n        self.sunSpinbox.bind(""<Return>"", self.keyBinding)\n        self.sunSpinbox.grid(row=_row, column=2)\n\n        # PVstring button\n        _row += 1  # row 14\n        buttonCnf = {\'name\': \'pvStrButton\', \'text\': \'PVstring\',\n                     \'command\': self.startPVstring_tk}\n        pvStrButton = self.pvStrButton = Button(pvSysDataFrame, buttonCnf)\n        pvStrButton.grid(row=_row, columnspan=3, sticky=(E + W))\n\n        # toolbar\n        toolbar = self.toolbarframe = Frame(master, name=\'toolbar\')\n        toolbar.pack(fill=BOTH)\n        self.QUIT = Button(toolbar, text=\'Quit\', command=self._quit)\n        self.QUIT.pack(side=RIGHT)\n        self.SAVE = Button(toolbar, text=\'Save\', command=self._save)\n        self.SAVE.pack(side=RIGHT)\n        self.LOAD = Button(toolbar, text=\'Load\', command=self._load)\n        self.LOAD.pack(side=RIGHT)\n        self.RESET = Button(toolbar, text=\'Reset\', command=self._reset)\n        self.RESET.pack(side=RIGHT)\n        self.UPDATE = Button(toolbar, text=\'Update\', command=self._update)\n        self.UPDATE.pack(side=RIGHT)\n        self.HELP = Button(toolbar, text=\'Help\', command=self._help)\n        self.HELP.pack(side=RIGHT)\n        self.MESSAGE = Message(toolbar, textvariable=self.msgtext,\n                               width=500, fg=\'red\')\n        self.MESSAGE.pack(side=LEFT)\n\n#    Validation substitutions\n#    %d  Type of action: 1 for insert, 0 for delete, or -1 for focus, forced or\n#        textvariable validation.\n#    %i  Index of char string to be inserted/deleted, if any, otherwise -1.\n#    %P  The value of the spinbox should edition occur. If you are configuring\n#        the spinbox widget to have a new textvariable, this will be the value\n#        of that textvariable.\n#    %s  The current value of spinbox before edition.\n#    %S  The text string being inserted/deleted, if any. Otherwise it is an\n#        empty string.\n#    %v  The type of validation currently set.\n#    %V  The type of validation that triggered the callback (key, focusin,\n#        focusout, forced).\n#    %W  The name of the spinbox widget.\n\n# TODO: Fix these functions so that delete and overwrite work\n\n    def validateWidget(self, *args):\n        # W = Tkinter.W = \'w\' is already used, so use W_ instead\n        (d, i, P, s, S, v, V, W_) = args  # @UnusedVariable # IGNORE:W0612\n        logging.debug(""OnValidate: d={}, i={}, P={}, s={}, S={}, v={}, V={}, W={}"".format(*args))\n        if W_ == "".pvSysFrame.pvSysDataFrame.numStrSpinbox"":\n            valType = INTEGERS\n            valTest = lambda val: int(val)  # IGNORE:W0108\n        elif W_ == "".pvSysFrame.pvSysDataFrame.numModSpinbox"":\n            valType = INTEGERS\n            valTest = lambda val: int(val)  # IGNORE:W0108\n        elif W_ == "".pvSysFrame.pvSysDataFrame.sunSpinbox"":\n            valType = FLOATS\n            valTest = lambda val: float(val)  # IGNORE:W0108\n        else:\n            return False\n        w = self.nametowidget(W_)\n        w.config(validate=v)\n        if S in valType:\n            try:\n                valTest(P)\n            except ValueError:\n                return False\n            return True\n        else:\n            return False\n\n    def invalidWidget(self, *args):\n        (d, i, P, s, S, v, V, W_) = args  # @UnusedVariable # IGNORE:W0612\n        logging.debug(""OnInvalid: d={}, i={}, P={}, s={}, S={}, v={}, V={}, W={}"".format(*args))\n        if W_ == "".pvSysFrame.pvSysDataFrame.numStrSpinbox"":\n            errText = \'Invalid number of strings!\'\n        elif W_ == "".pvSysFrame.pvSysDataFrame.numModSpinbox"":\n            errText = \'Invalid number of modules!\'\n        elif W_ == "".pvSysFrame.pvSysDataFrame.sunSpinbox"":\n            errText = \'Invalid irradiance!\'\n        else:\n            errText = \'Unknown widget!\'\n        w = self.nametowidget(W_)\n        w.config(validate=v)\n        self.msgtext.set(errText)\n        self.bell()\n\n    def getIV(self, *args):\n        logging.debug(\'args:\\n\\t%r\', args)\n        x = np.float64(float(args[0]) / self.pvSys.pvconst.npts / 2.)\n        xp = np.concatenate((self.pvSys.pvconst.negpts, self.pvSys.pvconst.pts),\n                            axis=0).flatten()\n        Vsys = np.interp(x, xp, self.pvSys.Vsys)\n        Isys = np.interp(x, xp, self.pvSys.Isys)\n        Psys = Vsys * Isys / 1000\n        self.txtVsys.set(""{:7.3f}"".format(Vsys))\n        self.txtIsys.set(""{:7.3f}"".format(Isys))\n        self.txtPsys.set(""{:7.3f}"".format(Psys))\n\n    def startPVstring_tk(self):\n        top = Toplevel()\n        app = PVstring_tk(self, top)\n        app.mainloop()\n        # please destroy me or I\'ll continue to run in background\n        top.destroy()\n\n    def startAdvCnf_tk(self):\n        """"""\n        open advnaced config window\n        """"""\n        top = Toplevel(name=\'advCnfTop\')\n        app = AdvCnf_tk(self, top)\n        app.mainloop()\n        # please destroy me or I\'ll continue to run in background\n        top.destroy()\n\n    def keyBinding(self, event):\n        logging.debug(\'event widget:\\n\\t%r\', event.widget)\n        logging.debug(\'event widget get:\\n\\t%r\', event.widget.get())\n        self.updatePVsys()\n\n    def updatePVsys(self, *args, **kwargs):\n        logging.debug(\'args:\\n\\t%r\', args)\n        logging.debug(\'kwargs:\\n\\t%r\', kwargs)\n        if args and isinstance(args[0], PVsystem_cls):\n            pvsys = args[0]\n            for n, pvstr in enumerate(pvsys.pvstrs):\n                for pvmod in pvstr.pvmods:\n                    pvmod.calcMod()\n                pvstr.calcString()\n                logging.debug(\'updating pvstring #%d: Pmp = %g[W]\', n, pvstr.Pstring.max())\n            return\n        PVAPP = ""pvapplication""\n        try:\n            numStrs = self.numStrs.get()\n            if not (0 < numStrs <= self.validationConstants[PVAPP][""numStrs""]):\n                raise PVValidationError(\'numStrs\', numStrs)\n            numMods = self.numMods.get()\n            if not (0 < numMods <= self.validationConstants[PVAPP][""numMods""]):\n                raise PVValidationError(\'numMods\', numMods)\n            sysEe = self.sysEe.get()\n            if not (0 < sysEe <= self.validationConstants[PVAPP][""sysEe""]):\n                raise PVValidationError(\'sysEe\', sysEe)\n        except PVValidationError as err:\n            logging.debug(\'err:\\n\\t%r\', err)\n            errtext = self.messagetext[PVAPP][err.argname]\n            self.msgtext.set(errtext)\n            self.bell()\n            return\n        numCells = self.numCells.get()\n        self.msgtext.set(self.messagetext[PVAPP][""Ready""])\n        pvconst = self.pvSys.pvconst\n        pvcell = PVcell(Ee=sysEe)\n        if numCells == 24:\n            numCells = STD24\n        elif numCells == 72:\n            numCells = STD72\n        elif numCells == 96:\n            numCells = STD96\n        elif numCells == 128:\n            numCells = STD128\n        pvmods = PVmodule(cell_pos=numCells, pvcells=pvcell)\n        self.pvSys = PVsystem(pvconst, numStrs, numberMods=numMods,\n                              pvmods=pvmods)\n        self.updateIVstats()\n\n\n    def updateIVstats(self):\n        # reuse sysPlot figure and update pvSysFigCanvas\n        self.pvSysPlot = self.pvSys.plotSys(self.pvSysPlot)\n        self.pvSysFigCanvas.show()\n        self.txtImp.set(""{:7.3f}"".format(self.pvSys.Imp))  # [A]\n        self.txtVmp.set(""{:7.3f}"".format(self.pvSys.Vmp))  # [V]\n        self.txtPmp.set(""{:7.3f}"".format(self.pvSys.Pmp / 1000))  # [kW]\n        self.txtIsc.set(""{:7.3f}"".format(self.pvSys.Isc))  # [A]\n        self.txtVoc.set(""{:7.3f}"".format(self.pvSys.Voc))  # [V]\n        self.txtFF.set(""{:7.3f}"".format(self.pvSys.FF * 100))  # [%]\n        self.txtEff.set(""{:7.3f}"".format(self.pvSys.eff * 100))  # [%]\n\n    def _help(self):\n        logging.debug(\'show docs in browser\')\n        webbrowser.open(DOCS)\n\n    def _update(self):\n        self.msgtext.set(READY_MSG)\n        self.updatePVsys()\n\n    def _reset(self):\n        # number of strings integer variable\n        self.numStrs.set(NUMBERSTRS)  # default\n        # number of modules integer variable\n        self.numMods.set(NUMBERMODS)  # default\n        # number of cells integer variable\n        self.numCells.set(NUMBERCELLS)  # default value is 96\n        self.msgtext.set(READY_MSG)\n        # TODO: need to reset advCnf too\n        logging.debug(\'reset\')\n\n    def _load(self):\n        logging.debug(\'load *.pv file\')\n\n    def _save(self):\n        logging.debug(\'save *.pv file\')\n\n    def _quit(self):\n        # this is necessary on Windows to prevent\n        # Fatal Python Error: PyEval_RestoreThread: NULL tstate\n        self.master.quit()  # stops mainloop\n        self.master.destroy()\n\n    def readJSON(self, JSONfilename):\n        if not JSONfilename.endswith(\'json\'):\n            JSONfilename += \'.json\'\n        JSONfullpath = os.path.join(JSONDIR, JSONfilename)\n        with open(JSONfullpath, \'r\') as JSONfile:\n            JSONObjects = json.load(JSONfile)\n            logging.debug(\'JSON objects loaded from %s.\', JSONfullpath)\n        return JSONObjects\n'"
pvmismatch/pvmismatch_tk/pvexceptions.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sep 3, 2012\n\n@author: marko\n""""""\n\n\nclass PVexception(Exception):\n    """"""\n    Base exception class for PVmismatch_tk.\n    """"""\n    pass\n\n\nclass PVValidationError(PVexception):\n    def __init__(self, argname, argvalue):  # IGNORE:W0231\n        self.argname = argname\n        self.argvalue = argvalue\n\n    def __str__(self):\n        return (\'Invalid value, %s, for argument ""%s"".\' % (self.argvalue,\n                                                          self.argname))\n'"
pvmismatch/pvmismatch_tk/pvmodule_tk.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Jul 29, 2012\n\n@author: marko\n""""""\n\nfrom Tkinter import Frame, Label, Button, OptionMenu, IntVar\n#from Tkinter import Menu, Entry\nMODULE_SIZES = [72, 96, 128]\n\n\nclass PVmodule_tk(Frame):\n    """"""\n    classdocs\n    """"""\n\n    def __init__(self, pvapp, top):\n        """"""\n        Constructor\n        """"""\n        self.pvapp = pvapp\n        Frame.__init__(self, top)\n        self.pack(expand=True)  # if user resizes, expand Frame\n        self.pack(fill=\'both\')\n        self.focus_set()  # get the focus\n        self.grab_set()  # make this window modal\n\n        self[\'bg\'] = \'black\'  # set black background\n        self[\'padx\'] = \'15\'  # pad sides with 15 points\n        self[\'pady\'] = \'5\'  # pad top/bottom 5 points\n        self.master.title(\'PVmodule\')  # set title bar\n        self.SPlogoLabel = Label(self, image=self.pvapp.SPlogo,\n                                 cnf={\'borderwidth\': \'0\'})\n        self.SPlogoLabel.pack({\'side\': \'top\'})\n\n        self.numberCells = IntVar(self)  # bind numberCells\n        self.numberCells.set(MODULE_SIZES[0])  # default value\n        # pylint: disable = W0142\n        self.numberCellsOption = OptionMenu(self, self.numberCells,\n                                            *MODULE_SIZES)\n        # pylint: enable = W0142\n        self.numberCellsOption.pack({\'side\': \'top\', \'fill\': \'both\'})\n\n        self.QUIT = Button(self, cnf={\'text\': \'Quit\', \'command\': self.quit})\n        self.QUIT.pack({\'side\': \'top\', \'fill\': \'both\'})\n\n#        # cell ID # spinbox\n#        cellID = self.cellID = IntVar(self)  # bind moduleID\n#        cellID.set(1)\n\n#        # cell ID # label\n#        self.cellIDlabel = Label(pvModFrame, text=\'Cell ID #\')\n#        self.cellIDlabel.pack(side=LEFT)\n#        spacer(pvModFrame, 16, LEFT)\n#        # cell ID spinbox\n#        maxModSize = max(MOD_SIZES)\n#        spinboxCnf = {\'name\': \'cellIDspinbox\', \'from_\': 1, \'to\': maxModSize,\n#                      \'textvariable\': cellID, \'width\': 5, \'validate\': \'all\',\n#                      \'validatecommand\': vcmd, \'invalidcommand\': invcmd}\n#        self.cellIDspinbox = Spinbox(pvModFrame, cnf=spinboxCnf)\n#        self.cellIDspinbox.pack(side=LEFT)\n#        self.pvModButton = Button(pvModFrame,\n#                                     cnf={\'text\': PVMODULE_TEXT})\n#        self.pvModButton.pack(side=RIGHT)\n#        self.pvModButton[\'command\'] = self.startPVmodule_tk\n#        self.separatorLine()  # separator\n\n#        # module ID # label\n#        labelCnf = {\'name\': \'modIDlabel\', \'text\': \'Module ID #\'}\n#        self.modIDlabel = Label(pvStrFrame, cnf=labelCnf)\n#        self.modIDlabel.pack(side=LEFT)\n#        # module ID # spinbox\n#        spinboxCnf = {\'name\': \'modIDspinbox\', \'from_\': 1, \'to\': MAX_MODULES,\n#                      \'textvariable\': modID, \'width\': 5, \'validate\': \'all\',\n#                      \'validatecommand\': vcmd, \'invalidcommand\': invcmd}\n#        self.modIDspinbox = Spinbox(pvStrFrame, cnf=spinboxCnf)\n#        self.modIDspinbox.pack(side=LEFT)\n#        # PVmodule button\n#        self.pvStrButton = Button(pvStrFrame, cnf={\'text\': PVSTRING_TEXT})\n#        self.pvStrButton.pack(side=RIGHT)\n#        self.pvStrButton[\'command\'] = self.startPVstring_tk\n#        self.separatorLine()  # separator\n#\n#        ## PVmodule frame\n#        pvModFrame = self.pvModFrame = Frame(master, name=\'pvModFrame\')\n#        pvModFrame.pack(fill=BOTH)\n'"
pvmismatch/pvmismatch_tk/pvstring_tk.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Jul 30, 2012\n\n@author: mmikofski\n""""""\n\nfrom Tkinter import Frame, Label, Button, Toplevel\n#from Tkinter import IntVar\n#import tkFont\n# use absolute imports instead of relative, so modules are portable\nfrom pvmismatch.pvmismatch_tk.pvmodule_tk import PVmodule_tk\n\n\nclass PVstring_tk(Frame):\n    """"""\n    classdocs\n    """"""\n\n    def __init__(self, pvapp, top):\n        """"""\n        Constructor\n        """"""\n        self.pvapp = pvapp\n        Frame.__init__(self, top)\n        self.pack(expand=True)  # if user resizes, expand Frame\n        self.pack(fill=\'both\')\n        self.focus_set()  # get the focus\n        self.grab_set()  # make this window modal\n        top.resizable(False, False)  # not resizable in x or y\n        top.title(\'PVstring\')  # set title bar\n        top.protocol(""WM_DELETE_WINDOW"", self.quit)  # close window to quit\n#        CAPTION_FONT = tkFont.nametofont(\'TkCaptionFont\')  # font for titles\n        # number of strings integer variable\n#        strID = self.strID = IntVar(self, 1, \'strID\')\n        # number of strings integer variable\n#        self.strID.set(1)  # default\n\n        self[\'bg\'] = \'black\'  # set black background\n        self[\'padx\'] = \'15\'  # pad sides with 15 points\n        self[\'pady\'] = \'5\'  # pad top/bottom 5 points\n        self.SPlogoLabel = Label(self, image=self.pvapp.SPlogo,\n                                 cnf={\'borderwidth\': \'0\'})\n        self.SPlogoLabel.pack({\'side\': \'top\'})\n        self.QUIT = Button(self, cnf={\'text\': \'Quit\', \'command\': self.quit})\n        self.QUIT.pack({\'side\': \'top\', \'fill\': \'both\'})\n\n    def startPVmodule_tk(self):\n        top = Toplevel()\n        app = PVmodule_tk(self, top)\n        app.mainloop()\n        # please destroy me or I\'ll continue to run in background\n        top.destroy()\n\n\n#        # module ID # integer variable\n#        modID = self.moduleID = IntVar(self)\n#        modID.set(1)\n\n#        # string ID label\n#        labelCnf = {\'name\': \'strIDlabel\', \'text\': \'String ID #\'}\n#        self.strIDlabel = Label(pvSysFrame, cnf=labelCnf)\n#        self.strIDlabel.pack(side=LEFT)\n#        spacer(pvSysFrame, 6, LEFT)\n#        # string ID # spinbox\n#        spinboxCnf = {\'name\': \'strIDspinbox\', \'from_\': 1, \'to\': MAX_STRINGS,\n#                      \'textvariable\': strID, \'width\': 5, \'validate\': \'all\',\n#                      \'validatecommand\': vcmd, \'invalidcommand\': invcmd}\n#        self.strIDspinbox = Spinbox(pvSysFrame, cnf=spinboxCnf)\n#        self.strIDspinbox.pack(side=LEFT)\n#        # PVsystem button\n#        self.pvSysButton = Button(pvSysFrame, name=\'pvsysButton\',\n#                                     text=PVSYSTEM_TEXT,\n#                                     command=self.startPVsystem_tk)\n#        self.pvSysButton.pack(side=RIGHT)\n#        self.separatorLine()  # separator\n\n#        # PVstring frame\n#        pvStrFrame = self.pvStrFrame = Frame(master, name=\'pvStrFrame\')\n#        pvStrFrame.pack(fill=BOTH)\n'"
pvmismatch/pvmismatch_tk/pvsystem_tk.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Jul 28, 2012\n\n@author: marko\n""""""\n\nfrom Tkinter import Frame, Label, Button\n\n\nclass PVsystem_tk(Frame):\n    """"""\n    classdocs\n    """"""\n\n    def __init__(self, pvapp, top):\n        """"""\n        Constructor\n        """"""\n        self.pvapp = pvapp\n        Frame.__init__(self, top)\n        self.pack(expand=True)  # if user resizes, expand Frame\n        self.pack(fill=\'both\')\n        self.focus_set()  # get the focus\n        self.grab_set()  # make this window modal\n\n        self[\'bg\'] = \'black\'  # set black background\n        self[\'padx\'] = \'15\'  # pad sides with 15 points\n        self[\'pady\'] = \'5\'  # pad top/bottom 5 points\n        self.master.title(\'PVsystem\')  # set title bar\n        self.SPlogoLabel = Label(self, image=self.pvapp.SPlogo,\n                                 cnf={\'borderwidth\': \'0\'})\n        self.SPlogoLabel.pack({\'side\': \'top\'})\n        self.QUIT = Button(self, cnf={\'text\': \'Quit\', \'command\': self.quit})\n        self.QUIT.pack({\'side\': \'top\', \'fill\': \'both\'})\n'"
pvmismatch/tests/__init__.py,0,"b'""""""\ntests for pvmismatch\n""""""\n\nfrom nose.tools import ok_\n\ndef test_parallel_cals_is_gone():\n    from pvmismatch import pvconstants, pvcell, pvmodule, pvstring, pvsystem\n'"
pvmismatch/tests/test_pvcell.py,27,"b'""""""\nTest pvcells.\n""""""\n\nfrom nose.tools import ok_\nfrom pvmismatch.pvmismatch_lib.pvcell import PVcell\nfrom pvmismatch.pvmismatch_lib.pvconstants import PVconstants\nimport numpy as np\nimport os\n\nBASE_DIR = os.path.dirname(__file__)\n\n\ndef test_pvcell_basic():\n    """"""\n    test that pvcell returns a :class:`~pvmismatch.pvmismatch_lib.pvcell.PVcell`\n    object.\n    """"""\n    pvc = PVcell()\n    ok_(isinstance(pvc, PVcell))\n\n\ndef test_pvcell_setattr_recalc():\n    pvc = PVcell()\n    i183 = pvc.Icell[183]\n    pvc.Tcell = 323\n    pvc.Ee = 0.65\n    ok_(pvc.Icell[183] != i183)\n\n\ndef test_pvcell_calc_icell():\n    pvc = PVcell()\n    ok_(np.isclose(pvc.Icell[123], pvc.calcIcell(pvc.Vcell[123])))\n    ok_(np.isclose(pvc.Icell[153], pvc.calcIcell(pvc.Vcell[153])))\n    ok_(np.isclose(pvc.Icell[183], pvc.calcIcell(pvc.Vcell[183])))\n\n\ndef test_pvcell_calc_vcell():\n    pvc = PVcell()\n    ok_(np.isclose(pvc.Vcell[123], pvc.calcVcell(pvc.Icell[123]), 1e-4))\n    ok_(np.isclose(pvc.Vcell[153], pvc.calcVcell(pvc.Icell[153]), 1e-4))\n    ok_(np.isclose(pvc.Vcell[183], pvc.calcVcell(pvc.Icell[183])))\n\n\ndef test_calc_series():\n    pvconst = PVconstants()\n    pvcells = [\n        PVcell(pvconst=pvconst, Tcell=323),\n        PVcell(pvconst=pvconst, Ee=0.75, Tcell=313),\n        PVcell(pvconst=pvconst, Ee=0.55, Tcell=303)\n    ]\n    i_at_vrbd = np.asarray([np.interp(pvc.VRBD, pvc.Vcell.flat, pvc.Icell.flat)\n                            for pvc in pvcells])\n    icells = np.asarray([pvc.Icell.flatten() for pvc in pvcells])\n    vcells = np.asarray([pvc.Vcell.flatten() for pvc in pvcells])\n    isc = np.asarray([pvc.Isc for pvc in pvcells])\n    i, v = pvconst.calcSeries(icells, vcells, isc.mean(), i_at_vrbd.max())\n    iv_old = np.loadtxt(os.path.join(BASE_DIR, \'calc_series_test_iv_old.dat\'))\n    iv_expected = np.loadtxt(\n        os.path.join(BASE_DIR, \'calc_series_test_iv.dat\'))\n    # noinspection PyTypeChecker\n    iv_calc = np.concatenate([[i], [v]], axis=0).T\n    # noinspection PyTypeChecker\n    ok_(np.allclose(iv_calc, iv_expected))\n    assert np.allclose(iv_old[0,:], np.interp(iv_old[1,:], v, i), 0.01, 0.01)\n    assert np.allclose(\n        iv_old[1,:],\n        np.interp(iv_old[0,:], np.flipud(i), np.flipud(v)), 0.1, 0.1)\n    return i, v\n\n\ndef test_pvcell_calc_rbd():\n    pvc1 = PVcell(bRBD=0.)\n    ok_(isinstance(pvc1, PVcell))\n    pvc2 = PVcell(bRBD=-0.056)\n    ok_(isinstance(pvc2, PVcell))\n\n\ndef test_pvcell_calc_now_flag():\n    """"""\n    Test ``_calc_now`` turns off recalc in ``__setattr__``.\n    """"""\n    pvc = PVcell()\n    itest, vtest, ptest = pvc.Icell, pvc.Vcell, pvc.Pcell\n    pvc._calc_now = False\n    pvc.Rs = 0.001\n    assert np.allclose(itest, pvc.Icell)\n    assert np.allclose(vtest, pvc.Vcell)\n    assert np.allclose(ptest, pvc.Pcell)\n    icell, vcell, pcell = pvc.calcCell()\n    pvc._calc_now = True\n    assert np.allclose(icell, pvc.Icell)\n    assert np.allclose(vcell, pvc.Vcell)\n    assert np.allclose(pcell, pvc.Pcell)\n\n\ndef test_update():\n    pvc = PVcell()\n    Rs = pvc.Rs\n    itest = pvc.Icell[170]\n    pvc.update(Rs=0.001)\n    assert np.isclose(pvc.Icell[170], 5.79691674)\n    pvc._calc_now = False\n    pvc.Rs = Rs\n    pvc.update()  # resets _calc_now to True\n    assert np.isclose(pvc.Icell[170], itest)\n    assert pvc._calc_now\n\n\nif __name__ == ""__main__"":\n    i, v = test_calc_series()\n    iv_calc = np.concatenate([[i], [v]], axis=0).T\n    np.savetxt(os.path.join(BASE_DIR, \'calc_series_test_iv.dat\'), iv_calc)\n'"
pvmismatch/tests/test_pvconstants.py,4,"b'from pvmismatch import *\nimport os\nimport numpy as np\n\n\nBASEDIR = os.path.dirname(__file__)\n\n\ndef test_pvconst_npts_setter():\n    """"""Test pvconst property and setter methods""""""\n    pvconst = pvconstants.PVconstants()\n    assert pvconst.npts == pvconstants.NPTS\n    assert len(pvconst.pts) == pvconst.npts\n    assert pvconst.pts[0] == 0\n    assert pvconst.pts[-1] == 1\n    assert len(pvconst.negpts) == pvconst.npts\n    assert pvconst.negpts[0] == 1\n    assert pvconst.negpts[-1] > 0\n    pvconst.npts = 1001\n    assert pvconst.npts == 1001\n    assert len(pvconst.pts) == pvconst.npts\n    assert pvconst.pts[0] == 0\n    assert pvconst.pts[-1] == 1\n    assert len(pvconst.negpts) == pvconst.npts\n    assert pvconst.negpts[0] == 1\n    assert pvconst.negpts[-1] > 0\n\n\ndef test_minimum_current_close_to_max_voc_gh110():\n    """"""\n    Tests that minimum current in ``calcSeries`` is reasonably close to the\n    maximum open circuit current of all cells in module. This came up in GitHub\n    issue 110 that the resolution of the plots, and hence the underlying data,\n    at high cell temperature was too coarse.\n    """"""\n    pvsys = pvsystem.PVsystem()\n    pvsys.setTemps(388)\n    expected = np.loadtxt(os.path.join(BASEDIR, \'gh110.dat\'))\n    calculated = np.concatenate(\n        [[pvsys.Isys], [pvsys.Vsys], [pvsys.Psys]], axis=0).T\n    assert np.allclose(expected, calculated)\n    return calculated\n\n\nif __name__ == \'__main__\':\n    calculated = test_minimum_current_close_to_max_voc_gh110()\n    np.savetxt(os.path.join(BASEDIR, \'gh110.dat\'), calculated)'"
pvmismatch/tests/test_pvmodule.py,14,"b'""""""\nTests for pvmodules.\n""""""\nimport pytest\nfrom pvmismatch.pvmismatch_lib.pvmodule import PVmodule, TCT492, PCT492\nfrom pvmismatch.pvmismatch_lib.pvcell import PVcell\nimport numpy as np\nfrom copy import copy\n\ndef test_calc_mod():\n    pvmod = PVmodule()\n    assert (isinstance(pvmod, PVmodule))\n    return pvmod\n\ndef test_calc_tct_mod():\n    pvmod = PVmodule(cell_pos=TCT492)\n    isc = np.interp(np.float64(0), pvmod.Vmod, pvmod.Imod)\n    voc = np.interp(np.float64(0), np.flipud(pvmod.Imod), np.flipud(pvmod.Vmod))\n    assert (np.isclose(isc, 37.833598333277074))\n    assert (np.isclose(voc, 55.278957845604886))\n    return pvmod\n\ndef test_calc_pct_mod():\n    pvmod = PVmodule(cell_pos=PCT492)\n    isc = np.interp(np.float64(0), pvmod.Vmod, pvmod.Imod)\n    voc = np.interp(np.float64(0), np.flipud(pvmod.Imod), np.flipud(pvmod.Vmod))\n    assert (np.isclose(isc, 37.83359833000976))\n    assert (np.isclose(voc, 55.278957845604886))\n    return pvmod\n\ndef test_calc_pct_bridges():\n    pct492_bridges = copy(PCT492)\n    pct492_bridges[0][0][2][\'crosstie\'] = True\n    pct492_bridges[0][2][2][\'crosstie\'] = True\n    pct492_bridges[0][4][2][\'crosstie\'] = True\n    pvmod = PVmodule(cell_pos=pct492_bridges)\n    return pvmod\n\ndef check_same_pvconst_and_lengths(pvmod):\n    assert len(pvmod.pvcells) == 96\n    for p in pvmod.pvcells:\n        assert p.pvconst is pvmod.pvconst\n\ndef test_pvmodule_with_pvcells_list():\n    pvcells = [PVcell()] * 96\n    pvmod = PVmodule(pvcells=pvcells)\n    check_same_pvconst_and_lengths(pvmod)\n\ndef test_pvmodule_with_pvcells_obj():\n    pvcells = PVcell()\n    pvmod = PVmodule(pvcells=pvcells)\n    check_same_pvconst_and_lengths(pvmod)\n\ndef test_pvmodule_with_no_pvcells():\n    pvmod = PVmodule()\n    check_same_pvconst_and_lengths(pvmod)\n\ndef test_bypass_diode_configurations():\n    # No bypass diodes\n    pvm = PVmodule(Vbypass = [None, None, None])\n    assert (np.isclose(pvm.Vmod.min(), -530.6169665707829))\n        \n    # only one cell string has a bypass diode\n    pvm = PVmodule(Vbypass = [None, None,-0.5])\n    assert (np.isclose(pvm.Vmod.min(), -398.46272492808714))\n    \n    # two bypass diodes (middle removed)\n    pvm = PVmodule(Vbypass = [-0.5, None,-0.5])\n    assert (np.isclose(pvm.Vmod.min(), -266.30848328539145))\n\n    # all bypass diodes - same values\n    pvm = PVmodule(Vbypass = -0.2)\n    assert (np.isclose(pvm.Vmod.min(), -0.6))\n\n    # one bypass diode across the module\n    pvm = PVmodule(Vbypass = [-0.7])\n    assert (np.isclose(pvm.Vmod.min(), -0.7))\n\n    # default case    \n    pvm = PVmodule()\n    assert (np.isclose(pvm.Vmod.min(), pvm.Vbypass * 3))\n\nif __name__ == ""__main__"":\n    test_calc_mod()\n    test_calc_tct_mod()\n    test_calc_pct_mod()\n    test_calc_pct_bridges()\n'"
pvmismatch/tests/test_pvstring.py,0,b'from pvmismatch import *\n\n\ndef check_same_pvconst_and_lengths(pvstr):\n    assert len(pvstr.pvmods) == pvstring.NUMBERMODS\n    for p in pvstr.pvmods:\n        assert p.pvconst is pvstr.pvconst\n\n\ndef test_pvstring_with_pvmods_list():\n    pvmods = [pvmodule.PVmodule()] * pvstring.NUMBERMODS\n    pvstr = pvstring.PVstring(pvmods=pvmods)\n    check_same_pvconst_and_lengths(pvstr)\n\n\ndef test_pvstring_with_pvmods_obj():\n    pvmods = pvmodule.PVmodule()\n    pvstr = pvstring.PVstring(pvmods=pvmods)\n    check_same_pvconst_and_lengths(pvstr)\n\n\ndef test_pvstring_with_no_pvmods():\n    pvstr = pvstring.PVstring()\n    check_same_pvconst_and_lengths(pvstr)\n'
pvmismatch/tests/test_pvsystem.py,0,"b'from pvmismatch import *\n\n\ndef check_same_pvconst_and_lengths(pvsys):\n    assert len(pvsys.pvstrs) == pvsystem.NUMBERSTRS\n    for n, p in enumerate(pvsys.pvstrs):\n        assert p.pvconst is pvsys.pvconst\n        assert len(p.pvmods) == pvsys.numberMods[n]\n\n\ndef test_pvsystem_with_pvstrs_list():\n    pvstrs = [pvstring.PVstring()] * pvsystem.NUMBERSTRS\n    pvsys = pvsystem.PVsystem(pvstrs=pvstrs)\n    check_same_pvconst_and_lengths(pvsys)\n\n\ndef test_pvsystem_with_pvstrs_obj():\n    pvstrs = pvstring.PVstring()\n    pvsys = pvsystem.PVsystem(pvstrs=pvstrs)\n    check_same_pvconst_and_lengths(pvsys)\n\n\ndef test_pvsystem_with_no_pvstrs():\n    pvsys = pvsystem.PVsystem()\n    check_same_pvconst_and_lengths(pvsys)\n'"
pvmismatch/tests/test_setsuns.py,7,"b'""""""\nTest for setSuns method.\n\nBennet Meyers 10/10/16\n""""""\n\nimport numpy as np\nfrom nose.tools import ok_\nfrom pvmismatch.pvmismatch_lib.pvsystem import PVsystem\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nLOGGER = logging.getLogger(__name__)\n\n\ndef test_basic():\n    pvsys = PVsystem()\n    pvsys.setSuns(.75)\n    ok_(np.isclose(pvsys.Pmp, 23908.773330127806))\n\n\ndef test_dictionary():\n    pvsys = PVsystem()\n    Ee = {1: {3: {\'cells\': np.arange(30), \'Ee\': [.25] * 30}}}\n    pvsys.setSuns(Ee)\n    ok_(np.isclose(pvsys.Pmp, 31619.56808987828))\n\n\ndef test_set_mod_1():\n    pvsys = PVsystem()\n    Ee = {1: {3: [.2], 0: [.1]}}\n    pvsys.setSuns(Ee)\n    ok_(np.isclose(pvsys.Pmp, 29570.33263114967))\n\n\ndef test_set_mod_2():\n    pvsys = PVsystem()\n    Ee = {1: {3: .2, 0: .1}}\n    pvsys.setSuns(Ee)\n    ok_(np.isclose(pvsys.Pmp, 29570.33263114967))\n    # 1001 points linear: [ 29579.12191565]\n\n\ndef test_set_str_1():\n    pvsys = PVsystem()\n    Ee = {1: [.1]}\n    pvsys.setSuns(Ee)\n    ok_(np.isclose(pvsys.Pmp, 29140.183832416682))\n    # 1001 points linear: [ 29141.73034719]\n\n\ndef test_set_str_2():\n    pvsys = PVsystem()\n    Ee = {1: .1}\n    pvsys.setSuns(Ee)\n    ok_(np.isclose(pvsys.Pmp, 29140.183832416682))\n    # 1001 points linear: [ 29141.73034719]\n\n\ndef test_gh34_35():\n    pvsys = PVsystem()\n    # display unique id numbers\n    LOGGER.debug(\'\\n*** unique id numbers ***\')\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    # test strings references same object\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    # modules references same object\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    # cells reference same object\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n\n    # test set suns on just string #2\n    pvsys.setSuns({2: 0.88})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    # test other string not changed\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 1.0).all()\n    # test all modules in string #2 changed\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    # test strings references same object\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    # modules references same object\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    # cells reference same object\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvmods[2][0].pvcells[0] == pvsys.pvmods[2][2].pvcells[2]\n\n    # test set suns on just module #4 in string #2\n    pvsys.setSuns({2: {4: 0.75}})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Ee == 1.0).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[4].Ee == 0.75).all()\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n\n    # set just cells #0 and #2 in module #4 in string #2\n    pvsys.setSuns({2: {4: {\'Ee\': 0.66, \'cells\': [0, 2]}}})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Ee == 1.0).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Ee == 0.66\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Ee == 0.75\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Ee == 0.66\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n\n    # set cells 3 and 4 to one irradiance and 5 to another. should only make two new cell objects\n    pvsys.setSuns({2: {4: {\'Ee\': (0.33, 0.99, 0.33), \'cells\': (3, 4, 5)}}})\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Ee == 1.0).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Ee == 0.66\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Ee == 0.75\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Ee == 0.66\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Ee == 0.99\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n\n    # set all of a string with a single value, two ways. make sure no unnecessary modules are created\n    pvsys.setSuns({1: 0.5})\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 0.5).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Ee == 0.5).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Ee == 0.66\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Ee == 0.75\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Ee == 0.66\n    assert pvsys.pvstrs[0] != pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] != pvsys.pvmods[1][1]\n    assert pvsys.pvmods[1][2].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Ee == 0.99\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n    assert pvsys.pvstrs[1].pvmods[0] == pvsys.pvstrs[1].pvmods[2]\n\n    pvsys.setSuns({1: [0.6]})\n    assert (pvsys.pvstrs[0].pvmods[0].Ee == 1.0).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Ee == 0.6).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Ee == 0.6).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Ee == 0.88).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Ee == 0.88).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Ee == 0.66\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Ee == 0.75\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Ee == 0.66\n    assert pvsys.pvstrs[0] != pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] != pvsys.pvmods[1][1]\n    assert pvsys.pvmods[1][2].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Ee == 0.99\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Ee == 0.33\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n    assert pvsys.pvstrs[1].pvmods[0] == pvsys.pvstrs[1].pvmods[2]\n'"
pvmismatch/tests/test_settemps.py,3,"b'""""""\nTest for setTemps method.\n\nBennet Meyers 2/2/17\n""""""\n\nimport numpy as np\nfrom nose.tools import ok_\nfrom pvmismatch.pvmismatch_lib.pvsystem import PVsystem\nfrom pvmismatch.pvmismatch_lib.pvcell import PVcell\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nLOGGER = logging.getLogger(__name__)\n\ndef test_settemp():\n    pvsys = PVsystem()\n    # display unique id numbers\n    LOGGER.debug(\'\\n*** unique id numbers ***\')\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    # test strings references same object\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    # modules references same object\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    # cells reference same object\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n\n    # test set suns on just string #2\n    pvsys.setTemps({2: 373})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    # test other string not changed\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 298.15).all()\n    # test all modules in string #2 changed\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    # test strings references same object\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    # modules references same object\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    # cells reference same object\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvmods[2][0].pvcells[0] == pvsys.pvmods[2][2].pvcells[2]\n\n    # test set suns on just module #4 in string #2\n    pvsys.setTemps({2: {4: 300}})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[4].Tcell == 300).all()\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n\n    # set just cells #0 and #2 in module #4 in string #2\n    pvsys.setTemps({2: {4: {\'Tc\': 290, \'cells\': [0, 2]}}})\n    # display unique id numbers\n    LOGGER.debug(\'pvstrs:\\n%r\', set(pvsys.pvstrs))\n    LOGGER.debug(\'pvmods:\\n%r\', set([x for y in pvsys.pvmods for x in y]))\n    LOGGER.debug(\n        \'pvcells:\\n%r\',\n        {hex(int(id(z))): z for y in pvsys.pvmods for x in y for z in x.pvcells}\n    )\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Tcell == 290\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Tcell == 300\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Tcell == 290\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n\n    # set cells 3 and 4 to one irradiance and 5 to another. should only make two new cell objects\n    pvsys.setTemps({2: {4: {\'Tc\': (310, 320, 310), \'cells\': (3, 4, 5)}}})\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Tcell == 290\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Tcell == 300\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Tcell == 290\n    assert pvsys.pvstrs[0] == pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] == pvsys.pvmods[1][1]\n    assert pvsys.pvmods[0][0].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Tcell == 320\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n\n    # set all of a string with a single value, two ways. make sure no unnecessary modules are created\n    pvsys.setTemps({1: 350})\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 350).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Tcell == 350).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Tcell == 290\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Tcell == 300\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Tcell == 290\n    assert pvsys.pvstrs[0] != pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] != pvsys.pvmods[1][1]\n    assert pvsys.pvmods[1][2].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Tcell == 320\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n    assert pvsys.pvstrs[1].pvmods[0] == pvsys.pvstrs[1].pvmods[2]\n\n    pvsys.setTemps({1: [360]})\n    assert (pvsys.pvstrs[0].pvmods[0].Tcell == 298.15).all()\n    assert (pvsys.pvstrs[1].pvmods[1].Tcell == 360).all()\n    assert (pvsys.pvstrs[1].pvmods[4].Tcell == 360).all()\n    assert (pvsys.pvstrs[2].pvmods[0].Tcell == 373).all()\n    assert (pvsys.pvstrs[2].pvmods[2].Tcell == 373).all()\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0].Tcell == 290\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[1].Tcell == 300\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[2].Tcell == 290\n    assert pvsys.pvstrs[0] != pvsys.pvstrs[1]\n    assert pvsys.pvmods[0][0] != pvsys.pvmods[1][1]\n    assert pvsys.pvmods[1][2].pvcells[0] == pvsys.pvmods[1][1].pvcells[1]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[0] == pvsys.pvstrs[2].pvmods[4].pvcells[2]\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[4].Tcell == 320\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[5].Tcell == 310\n    assert pvsys.pvstrs[2].pvmods[4].pvcells[3] == pvsys.pvstrs[2].pvmods[4].pvcells[5]\n    assert pvsys.pvstrs[1].pvmods[0] == pvsys.pvstrs[1].pvmods[2]\n\ndef test_settemp_cell():\n    """"""\n    Test setTemp method for a wide range of temperatures. \n    Test added after implementing Isat2 as Isat2(Tcell)\n    """"""\n    pvc = PVcell()\n    Pmp_arr = []\n    Vmp_arr = []\n    Voc_arr = []\n    Isc_arr = []\n    \n    temps = [-85, -60, -40, -25, 0, 25, 40, 60, 85]\n    for t in temps:\n        pvc.Tcell = float(t) + 273.15\n        Pmp_arr.append(pvc.Pcell.max())\n        Vmp_arr.append(pvc.Vcell[pvc.Pcell.argmax()])\n        Voc_arr.append(pvc.calcVcell(0))\n        Isc_arr.append(pvc.Isc)\n        \n    assert(np.all(np.gradient(np.squeeze(Vmp_arr)) < 0))\n    assert(np.all(np.gradient(np.squeeze(Voc_arr)) < 0))\n    assert(np.all(np.gradient(Isc_arr) > 0))\n        \n'"
pvmismatch/contrib/gen_coeffs/__init__.py,13,"b'""""""\nMethods to generate diode coefficients.\n""""""\n\nfrom pvlib.pvsystem import sapm\nimport numpy as np\nfrom scipy import optimize\nfrom pvmismatch.contrib.gen_coeffs import diode, two_diode\nfrom pvmismatch.pvmismatch_lib.pvcell import ISAT1_T0, ISAT2_T0, RS, RSH\n\n# IEC 61853 test matrix\nTC_C = [15.0, 25.0, 50.0, 75.0]\nIRR_W_M2 = [100.0, 200.0, 400.0, 600.0, 800.0, 1000.0, 1100.0]\nTEST_MAT = np.meshgrid(TC_C, IRR_W_M2)  #: IEC61853 test matrix\n\ndef gen_iec_61853_from_sapm(pvmodule):\n    """"""\n    Generate an IEC 61853 test from Sandia Array Performance Model (sapm).\n\n    :param dict pvmodule: PV module to be tested\n    :returns: a pandas dataframe with columns ``i_mp``, ``v_mp``, ``i_sc``, and\n        ``v_oc`` and rows corresponding to the IEC61853 test conditions\n\n    Module is a dictionary according to ``pvlib.pvsystem.sapm``.\n    """"""\n    tc, irr = TEST_MAT\n    return sapm(irr / 1000.0, tc, pvmodule)\n\n\ndef gen_two_diode(isc, voc, imp, vmp, nseries, nparallel,\n                  tc, x0=None, *args, **kwargs):\n    """"""\n    Generate two-diode model parameters for ``pvcell`` given.\n\n    :param numeric isc: short circuit current [A]\n    :param numeric voc: open circuit voltage [V]\n    :param numeric imp: max power current [A]\n    :param numeric vmp: max power voltage [V]\n    :param int nseries: number of cells in series\n    :param int nparallel: number of parallel substrings in PV module\n    :param numeric tc: cell temperature [C]\n    :param x0: optional list of initial guesses, default is ``None``\n    :returns: tuple ``(isat1, isat2, rs, rsh)`` of generated coefficients and\n        the solver output\n    """"""\n    isc_cell = isc / nparallel\n    voc_cell = voc / nseries\n    imp_cell = imp / nparallel\n    vmp_cell = vmp / nseries\n    if x0 is None:\n        isat1 = ISAT1_T0  # [A]\n        isat2 = ISAT2_T0\n        rs = RS  # [ohms]\n        rsh = RSH  # [ohms]\n    else:\n        isat1 = x0[0]\n        isat2 = x0[1]\n        rs = x0[2]\n        rsh = x0[3]\n    x = np.array([np.log(isat1), np.log(isat2), np.sqrt(rs), np.sqrt(rsh)])\n    sol = optimize.root(\n        fun=residual_two_diode, x0=x,\n        args=(isc_cell, voc_cell, imp_cell, vmp_cell, tc),\n        jac=True,\n        *args, **kwargs\n    )\n    if sol.success:\n        isat1 = np.exp(sol.x[0])\n        isat2 = np.exp(sol.x[1])\n        rs = sol.x[2] ** 2.0\n        rsh = sol.x[3] ** 2.0\n    return (isat1, isat2, rs, rsh), sol\n\n\ndef gen_sapm(iec_61853):\n    i_sc = iec_61853[\'i_sc\']\n    # calculate Isc0 and alpha_Isc\n    # given Isc = Ee * Isc0 * (1 + alpha_Isc * (Tc - T0))\n    # as Ee * Isc0 + Ee * Isc0 * alpha_Isc * (Tc - T0) = Isc\n    # so Ax = B\n    # where x0 = Isc0 and x1 = Isc0 * alpha_Isc\n    # and A = [Ee, Ee * (Tc - T0)] and B = Isc\n    tc, irr = TEST_MAT\n    ee = (irr / 1000.0).flatten()\n    delta_t = (tc - 25.0).flatten()\n    a = np.array([ee, ee * delta_t])\n    b = i_sc.flatten()\n    x, res, rank, s = np.linalg.lstsq(a.T, b.T)\n    isc0, alpha_isc = x[0], x[1] / x[0]\n    return isc0, alpha_isc\n\n\ndef residual_two_diode(x, isc, voc, imp, vmp, tc):\n    """"""\n    Objective function to solve 2-diode model.\n\n    :param x: parameters ``isat1``, ``isat2``, ``rs``, and ``rsh``\n    :param isc: short circuit current [A] at ``tc`` [C]\n    :param voc: open circuit voltage [V] at ``tc`` [C]\n    :param imp: max power current [A] at ``tc`` [C]\n    :param vmp: max power voltage [V] at ``tc`` [C]\n    :param tc: cell temperature [C]\n    :returns: norm of the residuals and the Jacobian matrix\n    """"""\n    # Constants\n    q = diode.QE  # [C/electron] elementary electric charge\n    # (n.b. 1 Coulomb = 1 A * s)\n    kb = diode.KB  # [J/K/molecule] Boltzmann\'s constant\n    tck = tc + 273.15  # [K] reference temperature\n    # Governing Equation\n    vt = kb * tck / q  # [V] thermal voltage\n    # Rescale Variables\n    isat1_t0 = np.exp(x[0])\n    isat2_t0 = np.exp(x[1])\n    rs = x[2] ** 2.0\n    rsh = x[3] ** 2.0\n    # first diode saturation current\n    isat1 = diode.isat_t(tc, isat1_t0)\n    isat2 = diode.isat_t(tc, isat2_t0)\n    # Short Circuit\n    vd_isc, _ = diode.fvd(vc=0.0, ic=isc, rs=rs)\n    id1_isc, _ = diode.fid(isat=isat1, vd=vd_isc, m=1.0, vt=vt)\n    id2_isc, _ = diode.fid(isat=isat2, vd=vd_isc, m=2.0, vt=vt)\n    ish_isc, _ = diode.fish(vd=vd_isc, rsh=rsh)\n    # Photo-generated Current\n    iph = isc + id1_isc + id2_isc + ish_isc  # [A]\n    # Open Circuit\n    vd_voc, jvd_voc = diode.fvd(vc=voc, ic=0.0, rs=rs)\n    id1_voc, jid1_voc = diode.fid(isat=isat1, vd=vd_voc, m=1.0, vt=vt)\n    id2_voc, jid2_voc = diode.fid(isat=isat2, vd=vd_voc, m=2.0, vt=vt)\n    ish_voc, jish_voc = diode.fish(vd=vd_voc, rsh=rsh)\n    # Max Power Point\n    vd_mpp, jvd_mpp = diode.fvd(vc=vmp, ic=imp, rs=rs)\n    id1_mpp, jid1_mpp = diode.fid(isat=isat1, vd=vd_mpp, m=1.0, vt=vt)\n    id2_mpp, jid2_mpp = diode.fid(isat=isat2, vd=vd_mpp, m=2.0, vt=vt)\n    ish_mpp, jish_mpp = diode.fish(vd=vd_mpp, rsh=rsh)\n    # Slope at Max Power Point\n    dpdv, jdpdv = two_diode.fdpdv(\n        isat1=isat1, isat2=isat2, rs=rs, rsh=rsh, ic=imp, vc=vmp, vt=vt\n    )\n    # Shunt Resistance\n    frsh, jrsh = two_diode.fjrsh(\n        isat1=isat1, isat2=isat2, rs=rs, rsh=rsh, vt=vt, isc=isc\n    )\n    # Residual\n    # should be (M, ) array with M residual equations (constraints)\n    f2 = np.stack([\n        (iph - id1_voc - id2_voc - ish_voc).T,  # Open Circuit\n        (iph - id1_mpp - id2_mpp - ish_mpp - imp).T,  # Max Power Point\n        dpdv.T,  # Slope at Max Power Point\n        frsh.T  # Shunt Resistance\n    ], axis=0).flatten()\n    # Jacobian\n    # should be (M, N) array with M residuals and N variables\n    # [[df1/dx1, df1/dx2, ...], [df2/dx1, df2/dx2, ...]]\n    jvoc = np.stack((\n        -jid1_voc[0],  # d/disat1\n        -jid2_voc[0],  # d/disat2\n        -jvd_voc[2] * (jid1_voc[1] + jid2_voc[1] + jish_voc[0]),  # d/drs\n        -jish_voc[1]  # d/drsh\n    ), axis=0).T.reshape(-1, 4)\n    jmpp = np.stack((\n        -jid1_mpp[0],  # d/disat1\n        -jid2_mpp[0],  # d/disat2\n        -jvd_mpp[2] * (jid1_mpp[1] + jid2_mpp[1] + jish_mpp[0]),  # d/drs\n        -jish_mpp[1]  # d.drsh\n    ), axis=0).T.reshape(-1, 4) \n    # Scaling Factors\n    scale_fx = np.array([np.exp(x[0]), np.exp(x[1]), 2 * x[2], 2 * x[3]])\n    # scales each column by the corresponding element\n    j2 = np.concatenate(\n        (jvoc, jmpp, jdpdv[:4].T.reshape(-1, 4), jrsh[:4].T.reshape(-1, 4)),\n        axis=0\n    ) * scale_fx\n    return f2, j2\n\n\nPVMODULES = {\n    ""SunPower_SPR_E20_435"": {\n        ""Vintage"": ""2013-01-01"",\n        ""Area"": 2.16,\n        ""Material"": ""c-Si"",\n        ""Cells_in_Series"": 128,\n        ""Parallel_Strings"": 1,\n        ""Isco"": 6.4293,\n        ""Voco"": 86.626,\n        ""Impo"": 6.0102,\n        ""Vmpo"": 72.3771,\n        ""Aisc"": 0.00037,\n        ""Aimp"": 7.02e-05,\n        ""C0"": 1.0115,\n        ""C1"": -0.0115,\n        ""C2"": 0.218474,\n        ""C3"": -7.224183,\n        ""Bvoco"": -0.248,\n        ""Mbvoc"": 0.0,\n        ""Bvmpo"": -0.2584,\n        ""Mbvmp"": 0.0,\n        ""N"": 1.011,\n        ""A0"": 0.957,\n        ""A1"": 0.0402,\n        ""A2"": -0.008515,\n        ""A3"": 0.0007141,\n        ""A4"": -2.132e-05,\n        ""B0"": 1.0002,\n        ""B1"": -0.000213,\n        ""B2"": 3.63416e-05,\n        ""B3"": -2.175e-06,\n        ""B4"": 5.2796e-08,\n        ""B5"": -4.4351e-10,\n        ""DTC"": 3.0,\n        ""FD"": 1.0,\n        ""A"": -3.46,\n        ""B"": -0.07599,\n        ""IXO"": 6.1717,\n        ""IXXO"": 4.3997,\n        ""C4"": 0.9891,\n        ""C5"": 0.0109,\n        ""C6"": 1.0869,\n        ""C7"": -0.0869,\n        ""Notes"": ""Source: Estimated""\n    }\n}\n'"
pvmismatch/contrib/gen_coeffs/diode.py,18,"b'""""""\nCommon diode model equations.\n""""""\n\nimport numpy as np\nfrom scipy.constants import elementary_charge as QE, Boltzmann as KB\n\nT0 = 25.0  # [C]\nE0 = 1000.0  # [W/m^2]\nEG = 1.1  # [eV]]\n\n\ndef fid(isat, vd, m, vt):\n    """"""\n    Diode current, I_d, and its derivatives w.r.t. I_sat, V_d, m and V_t.\n\n    :param isat: diode saturation current [A]\n    :type isat: float\n    :param vd: diode voltage [V]\n    :type vd: float\n    :param m: diode ideality factor\n    :type m: float\n    :param vt: thermal voltage [V]\n    :type vt: float\n    :return: diode current [A] and its derivatives\n    :rtype: float\n\n    Diode current is given by Shockley\'s equation ...\n\n    .. math::\n        I_d = I_{sat} \\\\left(\\\\exp\\\\left(\\\\frac{V_d}{m V_t} \\\\right) - 1\\\\right)\n\n    ... where I_d is the diode current in amps, I_sat is the saturation current\n    in amps, V_d is the diode voltage in volts, m is the diode ideality factor\n    and V_t is the thermal voltage in volts ...\n\n    .. math::\n        V_t = \\\\frac{k_B T}{q_e}\n\n    ... in which k_B is the Boltzmann constant, T is the ambient temperature in\n    Kelvin and q_e is teh elementary charge in coulombs per electron.\n\n    https://en.wikipedia.org/wiki/Shockley_diode_equation\n\n    """"""\n    vact = m * vt  # activation voltage [V]\n    growth = np.exp(vd / vact)  # growth term\n    expfact = (growth - 1.0)  # exponential factor\n    isat_growth = isat * growth  # combination parameter\n    vd_isat_growth = -vd * isat_growth  # combination parameter\n    # diode current\n    id_ = np.atleast_1d(isat * expfact)\n    # derivatives\n    d_isat = np.atleast_1d(expfact)  # df w.r.t. isat\n    d_vd = np.atleast_1d(isat_growth / vact)  # df w.r.t. vd\n    d_m = np.atleast_1d(vd_isat_growth / (m ** 2.0 * vt))  # df w.r.t. m\n    d_vt = np.atleast_1d(vd_isat_growth / (m * vt ** 2.0))  # df w.r.t. vt\n    jac = np.array([d_isat, d_vd, d_m, d_vt])  # jacobian\n    return id_, jac\n\n\ndef fish(vd, rsh):\n    """"""\n    Shunt current, I_sh, and its derivatives w.r.t. V_d and R_sh.\n\n    :param vd: diode voltage [V]\n    :param rsh: shunt resistance [Ohms]\n    :return: shunt current [A]\n    """"""\n    ish = np.atleast_1d(vd / rsh)\n    shaper = np.ones(ish.shape)  # make sure scalars are the right shape\n    d_vd = np.atleast_1d(1.0 / rsh) * shaper\n    d_rsh = np.atleast_1d(-ish * d_vd)\n    jac = np.array([d_vd, d_rsh])\n    return ish, jac\n\n\ndef fvd(vc, ic, rs):\n    """"""\n    Diode voltage, V_d, and its derivatives w.r.t. V_c, I_c, R_s.\n\n    :param vc: cell voltage [V]\n    :param ic: cell current [A]\n    :param rs: series resistance [Ohms]\n    :return: diode voltage [V]\n    """"""\n    vd = np.atleast_1d(vc + rs * ic)\n    shaper = np.ones(vd.shape)  # make sure scalars are the right shape\n    jac = np.array([np.ones(vd.shape),\n                    np.atleast_1d(rs) * shaper,  # d/dIc\n                    np.atleast_1d(ic) * shaper])  # d/dRs\n    return vd, jac\n\n\ndef isat_t(tc, isat0):\n    tck = tc + 273.15\n    t0k = T0 + 273.15\n    tstar = tck ** 3.0 / t0k ** 3.0\n    inv_delta_t = 1.0 / t0k - 1.0 / tck  # [1/K]\n    exp_tstar = np.exp(EG * QE / KB * inv_delta_t)\n    isat_t = isat0 * tstar * exp_tstar\n    return isat_t\n\n\ndef isc_t(tc, isc0, alpha_isc):\n    delta_t = tc - T0\n    isc_t = isc0 * (1.0 + alpha_isc * delta_t)\n    return isc_t\n\n\ndef aph(tc, isc0, alpha_isc, isat1, isat2, vt, rs, rsh):\n    isc = isc_t(tc, isc0, alpha_isc)\n    vd_sc, _ = fvd(0, isc, rs)\n    isat1_t = isat_t(tc, isat0=isat1)\n    id1_sc, _ = fid(isat1_t, vd_sc, 1.0, vt)\n    id2_sc, _ = fid(isat2, vd_sc, 2.0, vt)\n    ish_sc, _ = fish(vd_sc, rsh)\n    aph = 1.0 + (id1_sc + id2_sc + ish_sc) / isc\n    return aph\n'"
pvmismatch/contrib/gen_coeffs/example.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nGenerate coefficients example.\n""""""\n\nfrom __future__ import (\n    absolute_import, division, print_function, unicode_literals)\nimport os\nimport sys\nfrom pvmismatch.contrib import gen_coeffs\nfrom pvmismatch import *\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n# read module from PVLIB dictionary of SAPM modules\nPROD_NAME = \'SunPower_SPR_E20_435\'\nNS = gen_coeffs.PVMODULES[PROD_NAME][\'Cells_in_Series\']  # number of series cells\nNP = gen_coeffs.PVMODULES[PROD_NAME][\'Parallel_Strings\']  # number of parallel substrings\nISC0 = gen_coeffs.PVMODULES[PROD_NAME][\'Isco\']  # short circuit current [A]\nVOC0 = gen_coeffs.PVMODULES[PROD_NAME][\'Voco\']  # open circuit voltage [A]\nIMP0 = gen_coeffs.PVMODULES[PROD_NAME][\'Impo\']  # max power current [A]\nVMP0 = gen_coeffs.PVMODULES[PROD_NAME][\'Vmpo\']  # max power voltage [V]\nAISC = gen_coeffs.PVMODULES[PROD_NAME][\'Aisc\']  # short circuit current tempco [1/K]\nPMP0 = IMP0 * VMP0\nTC, IRR = gen_coeffs.TEST_MAT\nT0, E0 = 25.0, 1000.0\n\niec61853 = gen_coeffs.gen_iec_61853_from_sapm(gen_coeffs.PVMODULES[PROD_NAME])\niec61853[\'i_mp\'] = iec61853[\'p_mp\'] / iec61853[\'v_mp\']\nisc0, alpha_isc = gen_coeffs.gen_sapm(iec61853)\nassert np.isclose(isc0, ISC0)\nassert np.isclose(alpha_isc, AISC)\n\nif __name__ == \'__main__\':\n    test_cond = \'STC\'\n    if len(sys.argv) > 1:\n        test_cond = sys.argv[1]\n    if test_cond.upper() == \'STC\':\n        x, sol = gen_coeffs.gen_two_diode(ISC0, VOC0, IMP0, VMP0, NS, NP, T0)\n    else:\n        x, sol = gen_coeffs.gen_two_diode(\n            iec61853[\'i_sc\'], iec61853[\'v_oc\'], iec61853[\'i_mp\'],\n            iec61853[\'v_mp\'], NS, NP, tc=TC, method=\'lm\',\n            x0=(2.25e-11, 1.5e-6, 0.004, 10.0)\n        )\n    isat1, isat2, rs, rsh = x\n\n    pvc = pvcell.PVcell(\n        Rs=rs, Rsh=rsh, Isat1_T0=isat1, Isat2_T0=isat2,\n        Isc0_T0=ISC0/NP, alpha_Isc=AISC,\n        pvconst=pvconstants.PVconstants(npts=1001)\n    )\n    f1 = plt.figure(figsize=(16, 10))\n\n    for m, _tc in enumerate(gen_coeffs.TC_C):\n        pvc.Tcell = _tc + 273.15\n        plt.subplot(2, 2, m+1)\n        plt.xlim([0, 0.8])\n        plt.ylim([0, 8])\n        res_norm = 0\n        for n, _irr in enumerate(gen_coeffs.IRR_W_M2):\n            pvc.Ee = _irr / 1000.0\n            plt.plot(pvc.Vcell, pvc.Icell, \'-\', pvc.Vcell, pvc.Pcell, \':\')\n            plt.plot(\n                iec61853[\'v_mp\'][n][m]/NS, iec61853[\'i_mp\'][n][m]/NP, \'x\',\n                iec61853[\'v_oc\'][n][m]/NS, 0.0, \'x\',\n                0.0, iec61853[\'i_sc\'][n][m]/NP, \'x\',\n                iec61853[\'v_mp\'][n][m]/NS, iec61853[\'p_mp\'][n][m]/NS/NP, \'o\',\n            )\n            mpp = np.argmax(pvc.Pcell)\n            res_norm += (\n                pvc.Icell[mpp] - iec61853[\'i_mp\'][n][m]/NP\n            )**2 / (IMP0/NP)**2\n            res_norm += (\n                pvc.Vcell[mpp] - iec61853[\'v_mp\'][n][m]/NS\n            )**2 / (VMP0/NS)**2\n            voc = pvc.calcVcell(0.0)\n            res_norm += (\n                voc - iec61853[\'v_oc\'][n][m]/NS\n            )**2 / (VOC0/NS)**2\n            isc = pvc.calcIcell(0.0)\n            res_norm += (\n                isc - iec61853[\'i_sc\'][n][m]/NP\n            )**2 / (ISC0/NP)**2\n            rel_diff = (pvc.Pcell[mpp]*NS*NP - iec61853[\'p_mp\'][n][m]) / PMP0\n            plt.annotate(\'$\\Delta_{STC}$ = %.2g%%\' % (rel_diff*100),\n                         (0.65, iec61853[\'p_mp\'][n][m]/NS/NP))\n            plt.annotate(\n                \'$E_e$ = %.2g[suns], $V_{oc}$ = %.2g[V}, $I_{sc}$ = %.g[A]\' % (_irr/1000, voc, isc),\n                (0.05, 0.05+iec61853[\'i_sc\'][n][m]/NP))\n        plt.annotate(\'STC RMSE = %.2g%%\' % (np.sqrt(res_norm / (7*4))*100),\n                     (0.65, 7.5))\n        plt.annotate(\'$I_{sat,1}$ = %.4g\' % isat1,\n                     (0.65, 7.2))\n        plt.annotate(\'$I_{sat,2}$ = %.4g\' % isat2,\n                     (0.65, 6.9))\n        plt.annotate(\'$R_s$ = %.4g\' % rs,\n                     (0.65, 6.6))\n        plt.annotate(\'$R_{sh}$ = %.4g\' % rsh,\n                     (0.65, 6.3))\n\n        plt.grid(True)\n        plt.title(\n            \'PVMismatch Generated Coefficients for %s at Tc = %g\' % (PROD_NAME, _tc)\n        )\n        plt.xlabel(\'voltage\')\n        plt.ylabel(\'current [A], power [W]\')\n        plt.xlabel(\'voltage [V]\')\n        plt.tight_layout()\n        if len(sys.argv) > 2:\n            test_save_dir = sys.argv[2]\n            os.makedirs(test_save_dir, exist_ok=True)\n            f1.savefig(os.path.join(test_save_dir, sys.argv[1]))\n        else:\n            f1.show()\n'"
pvmismatch/contrib/gen_coeffs/two_diode.py,98,"b'""""""\nTwo diode model equations.\n""""""\n\nimport numpy as np\nfrom pvmismatch.contrib.gen_coeffs import diode\n\n\ndef fdidv(isat1, isat2, rs, rsh, ic, vc, vt):\n    """"""\n    Derivative of IV curve and its derivatives w.r.t. Isat1, Isat2, Rs, Rsh, Ic,\n    Vc and Vt.\n\n    :param isat1: diode 1 saturation current [A]\n    :param isat2: diode 2 saturation current [A]\n    :param rs: series resistance [ohms]\n    :param rsh: shunt resistance [ohms]\n    :param ic: cell current [A]\n    :param vc: cell voltage [V]\n    :param vt: thermal voltage (kB * Tc / qe = 26[mV] at Tc=298K) [V]\n    :return: derivative of IV curve and its derivatives\n    """"""\n    vd, _ = diode.fvd(vc, ic, rs)  # vd = vc + ic * rs\n    vstar = vd / vt\n    rstar = rsh / rs\n    exp_vstar, exp_vstar_2 = np.exp(vstar), np.exp(0.5 * vstar)\n    v_sat1_sh, v_sat2_sh = isat1 * rsh, isat2 * rsh\n    v_sat1_sh_exp_vstar = v_sat1_sh * exp_vstar\n    v_sat2_sh_exp_vstar_2 = 0.5 * v_sat2_sh * exp_vstar_2\n    vsum = v_sat1_sh_exp_vstar + v_sat2_sh_exp_vstar_2 + vt\n    vsum_rstar = vsum + vt * rstar\n    combiterm1 = v_sat1_sh_exp_vstar + 0.5*v_sat2_sh_exp_vstar_2\n    combiterm2 = isat1*exp_vstar + 0.5*isat2*exp_vstar_2\n    combiterm3 = vsum / vsum_rstar - 1.0\n    combiterm4 = vsum_rstar * rs\n    combiterm5 = rstar * combiterm3 / vsum_rstar\n    combiterm6 = combiterm1 * combiterm3 / vt\n    combiterm7 = 1.0 / combiterm4\n    # dI/dV = derivative of IV curve\n    didv = -vsum / combiterm4\n    # jacobian\n    didv_isat1 = exp_vstar * combiterm5\n    didv_isat2 = 0.5 * exp_vstar_2 * combiterm5\n    didv__r_s = combiterm7 * (combiterm6 * ic + vsum**2.0 / combiterm4)\n    didv_rsh = combiterm7 * (combiterm2 * combiterm3 + vt * vsum / combiterm4)\n    didv_ic = combiterm6 / vsum_rstar\n    didv_vc = (didv + 1.0 / rs) * didv_ic\n    jac = np.array([\n        didv_isat1, didv_isat2, didv__r_s, didv_rsh, didv_ic, didv_vc\n    ])\n    return didv, jac\n\n\ndef fdpdv(isat1, isat2, rs, rsh, ic, vc, vt):\n    """"""\n    Derivative of PV curve and its derivatives w.r.t. Isat1, Isat2, Rs, Rsh, Ic,\n    Vc and Vt.\n\n    :param isat1: diode 1 saturation current [A]\n    :param isat2: diode 2 saturation current [A]\n    :param rs: series resistance [ohms]\n    :param rsh: shunt resistance [ohms]\n    :param ic: cell current [A]\n    :param vc: cell voltage [V]\n    :param vt: thermal voltage (kB * Tc / qe = 26[mV] at Tc=298K) [V]\n    :return: derivative of PV curve and its derivatives\n    """"""\n    didv, _ = fdidv(isat1, isat2, rs, rsh, ic, vc, vt)\n    vd, _ = diode.fvd(vc, ic, rs)  # vd = vc + ic * rs\n    dpdv = didv * vc + ic\n    dpdv_isat1 = 2.0*rs*rsh*vc*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )*np.exp(vd/vt)/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2 - 2.0*rsh*vc*np.exp(vd/vt)/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )\n    dpdv_isat2 = rs*rsh*vc*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )*np.exp(0.5*vd/vt)/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2 - rsh*vc*np.exp(0.5*vd/vt)/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )\n    dpdv_rs = -vc*(\n        2.0*isat1*rsh*ic*np.exp(vd/vt)/vt\n        + 0.5*isat2*rsh*ic*np.exp(0.5*vd/vt)/vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    ) - vc*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )*(\n        -2.0*isat1*rs*rsh*ic*np.exp(vd/vt)/vt\n        - 2.0*isat1*rsh*np.exp(vd/vt)\n        - 0.5*isat2*rs*rsh*ic*np.exp(0.5*vd/vt)/vt\n        - isat2*rsh*np.exp(0.5*vd/vt) - 2.0*vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2\n    dpdv_rsh = -vc*(\n        2.0*isat1*np.exp(vd/vt) + isat2*np.exp(0.5*vd/vt)\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    ) - vc*(\n        -2.0*isat1*rs*np.exp(vd/vt) - isat2*rs*np.exp(0.5*vd/vt) - 2.0*vt\n    )*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2\n    dpdv_ic = -vc*(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)/vt\n        + 0.5*isat2*rs*rsh*np.exp(0.5*vd/vt)/vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    ) - vc*(\n        -2.0*isat1*rs**2*rsh*np.exp(vd/vt)/vt\n        - 0.5*isat2*rs**2*rsh*np.exp(0.5*vd/vt)/vt\n    )*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2 + 1.0\n    dpdv_vc = -vc*(\n        2.0*isat1*rsh*(rs*didv + 1)*np.exp(vd/vt)/vt\n        + 0.5*isat2*rsh*(rs*didv + 1)*np.exp(0.5*vd/vt)/vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    ) - vc*(\n        -2.0*isat1*rs*rsh*(rs*didv + 1)*np.exp(vd/vt)/vt\n        - 0.5*isat2*rs*rsh*(rs*didv + 1)*np.exp(0.5*vd/vt)/vt\n    )*(\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    )**2 - (\n        2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n    )/(\n        2.0*isat1*rs*rsh*np.exp(vd/vt)\n        + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n    ) + didv\n    jac = np.array([\n        dpdv_isat1, dpdv_isat2, dpdv_rs, dpdv_rsh, dpdv_ic, dpdv_vc\n        ])\n    return dpdv, jac\n\n\ndef fjrsh(isat1, isat2, rs, rsh, vt, isc):\n    """"""\n    Shunt resistance residual and its derivatives w.r.t. Isat1, Isat2, Rs and\n    Rsh.\n\n    :param isat1: diode 1 saturation current [A]\n    :param isat2: diode 2 saturation current [A]\n    :param rs: series resistance [ohms]\n    :param rsh: shunt resistance [ohms]\n    :param vt: thermal voltage (kB * Tc / qe = 26[mV] at Tc=298K) [V]\n    :param isc: short circuit current [A]\n    :return: Rsh residual and its derivatives\n\n    Shunt resistance is assumed to be equal to the inverse of the slope of the\n    IV curve at short circuit.\n\n    .. math::\n        Rsh = \\\\frac{ -1 }{ \\\\left. \\\\frac{dI}{dV} \\\\right|_{V=0} }\n\n    This assumption is valid when [put condition here].\n    """"""\n    didv, _ = fdidv(isat1, isat2, rs, rsh, ic=isc, vc=0, vt=vt)\n    vd, _ = diode.fvd(0.0, isc, rs)  # vd = vc + ic * rs = 0.0 + isc * rs\n    # frsh = rsh + 1/didv\n    frsh = vd * (1.0/rsh + didv)\n    dfrsh_isat1 = vd*(\n        2.0*rs*rsh*(\n            2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n        )*np.exp(vd/vt)/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt)\n            + 2.0*rs*vt + 2.0*rsh*vt\n        )**2 - 2.0*rsh*np.exp(vd/vt)/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt)\n            + 2.0*rs*vt + 2.0*rsh*vt\n        )\n    )\n    dfrsh_isat2 = vd*(\n        rs*rsh*(\n            2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n        )*np.exp(0.5*vd/vt)/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt)\n            + 2.0*rs*vt + 2.0*rsh*vt\n        )**2 - rsh*np.exp(0.5*vd/vt)/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt)\n            + 2.0*rs*vt + 2.0*rsh*vt\n        )\n    )\n    dfrsh_rs = (\n        vd*(\n            -(\n                2.0*isat1*rsh*isc*np.exp(vd/vt)/vt + 0.5*isat2*rsh*isc*np.exp(0.5*vd/vt)/vt\n            )/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) - (\n                2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n            )*(\n                -2.0*isat1*rs*rsh*isc*np.exp(vd/vt)/vt\n                - 2.0*isat1*rsh*np.exp(vd/vt)\n                - 0.5*isat2*rs*rsh*isc*np.exp(0.5*vd/vt)/vt\n                - isat2*rsh*np.exp(0.5*vd/vt) - 2.0*vt\n            )/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            )**2\n        ) + (\n            -(2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt)/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) + 1.0/rsh\n        )*isc\n    )\n    dfrsh_rsh = (\n        vd*(\n            -(2.0*isat1*np.exp(vd/vt) + isat2*np.exp(0.5*vd/vt))/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) - (\n                -2.0*isat1*rs*np.exp(vd/vt) - isat2*rs*np.exp(0.5*vd/vt) - 2.0*vt\n            )*(2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt)/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            )**2 - 1.0/rsh**2\n        )\n    )\n    dfrsh_ic = (\n        rs*(\n            -(2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt)/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) + 1.0/rsh\n        ) + vd*(\n            -(\n                2.0*isat1*rs*rsh*np.exp(vd/vt)/vt + 0.5*isat2*rs*rsh*np.exp(0.5*vd/vt)/vt\n            )/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) - (\n                -2.0*isat1*rs**2*rsh*np.exp(vd/vt)/vt - 0.5*isat2*rs**2*rsh*np.exp(0.5*vd/vt)/vt\n            )*(\n                2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt\n            )/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            )**2\n        )\n    )\n    dfrsh_vc = (\n        vd*(-(\n            2.0*isat1*rsh*(rs*didv + 1)*np.exp(vd/vt)/vt\n            + 0.5*isat2*rsh*(rs*didv + 1)*np.exp(0.5*vd/vt)/vt\n        )/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n        ) - (\n            -2.0*isat1*rs*rsh*(rs*didv + 1)*np.exp(vd/vt)/vt\n            - 0.5*isat2*rs*rsh*(rs*didv + 1)*np.exp(0.5*vd/vt)/vt\n        )*(2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt)/(\n            2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n        )**2) + (rs*didv + 1)*(\n            -(2.0*isat1*rsh*np.exp(vd/vt) + isat2*rsh*np.exp(0.5*vd/vt) + 2.0*vt)/(\n                2.0*isat1*rs*rsh*np.exp(vd/vt) + isat2*rs*rsh*np.exp(0.5*vd/vt) + 2.0*rs*vt + 2.0*rsh*vt\n            ) + 1.0/rsh\n        )\n    )\n    jac = np.array([\n        dfrsh_isat1, dfrsh_isat2, dfrsh_rs, dfrsh_rsh, dfrsh_ic, dfrsh_vc\n    ])\n    return frsh, jac\n'"
pvmismatch/contrib/xlsio/__init__.py,0,b'# API for xlsio\nfrom pvmismatch.contrib.xlsio.xlsio import *\n'
pvmismatch/contrib/xlsio/xlsio.py,0,"b'import numpy as np\nfrom scipy.interpolate import interp1d\n# Pandas is an optional dependency only used by xlsio, therefore\n# not installed with PVMismatch:\ntry:\n    import pandas as pd\nexcept ImportError:\n    print(""Pandas module not found. You need to install it before proceeding:"")\n    print(""https://pandas.pydata.org/pandas-docs/stable/install.html"")\n    raise\n\ndef _create_cell_pos_df(pv_mod, nr_string, nr_mod):\n    """"""Create cell position dataframe of a module in the PV system""""""\n    cell_pos = pv_mod.cell_pos\n    nrows = int(pv_mod.numberCells / sum(pv_mod.subStrCells))\n    cell_pos_df = pd.DataFrame(index=[\'{}_{}\'.format(nr_mod, nr)\n                                      for nr\n                                      in range(nrows)])\n    for b, bypass in enumerate(cell_pos):\n        for c, col in enumerate(bypass):\n            cell_pos_df[\'{}_{}_{}\'.format(nr_string, b, c)] = [i[\'idx\']\n                                                               for i\n                                                               in col]\n    return cell_pos_df\n\ndef _create_nan_df(pv_mod, nr_string, nr_mod):\n    """"""Create an ""nan"" dataframe of a module in the PV system for the case\n    when the bypass diode activation is not calculated yet""""""\n    cell_pos = pv_mod.cell_pos\n    nrows = int(pv_mod.numberCells / sum(pv_mod.subStrCells))\n    nan_df = pd.DataFrame(index=[\'{}_{}\'.format(nr_mod, nr)\n                                 for nr\n                                 in range(nrows)])\n    for b, bypass in enumerate(cell_pos):\n        for c, col in enumerate(bypass):\n            nan_df[\'{}_{}_{}\'.format(nr_string, b, c)] = [\'nan\'] * len(col)\n    return nan_df\n\ndef _create_irrad_df(pv_mod, cell_pos_df):\n    """"""Create irradiance dataframe of a module in the PV system""""""\n    irrad = pd.Series(pv_mod.Ee.flatten())\n    irrad_df = pd.DataFrame(index=cell_pos_df.index,\n                            columns=cell_pos_df.columns)\n    for column in cell_pos_df.columns:\n        for row in cell_pos_df.index:\n            cell_index = cell_pos_df.loc[row, column]\n            irrad_df.loc[row, column] = irrad[cell_index]\n    return irrad_df\n\ndef _create_temp_df(pv_mod, cell_pos_df):\n    """"""Create temperature dataframe of a module in the PV system""""""\n    temp = pd.Series(pv_mod.Tcell.flatten())\n    temp_df = pd.DataFrame(index=cell_pos_df.index,\n                           columns=cell_pos_df.columns)\n    for column in cell_pos_df.columns:\n        for row in cell_pos_df.index:\n            cell_index = cell_pos_df.loc[row, column]\n            temp_df.loc[row, column] = temp[cell_index]\n    return temp_df\n\ndef system_layout_to_xls(output_xls_name, pv_sys, write_bpd_act):\n    """"""Write an xls with worksheets of irradiance, cell temperature\n    and cell index. If ""write_bpd_act"" is True, bypass diode activation is\n    checked and on the ActiveBpd tab bypassed cells are represented with 1 and\n    non-bypassed cells with 0.""""""\n    writer = pd.ExcelWriter(output_xls_name, engine=\'xlsxwriter\')\n    workbook = writer.book\n    writer.sheets[\'CellIndexes\'] = workbook.add_worksheet(\'CellIndexes\')\n    writer.sheets[\'Irradiance\'] = workbook.add_worksheet(\'Irradiance\')\n    writer.sheets[\'CellTemp\'] = workbook.add_worksheet(\'CellTemp\')\n    writer.sheets[\'BpdAndRbc\'] = workbook.add_worksheet(\'BpdAndRbc\')\n    if write_bpd_act:\n        pv_sys_vmp = pv_sys.Vmp\n        print(pv_sys.Pmp)\n    for s, string in enumerate(pv_sys.pvstrs):\n        if write_bpd_act:\n            interp_string_iv = interp1d(string.Vstring, string.Istring)\n            string_imp = interp_string_iv(pv_sys_vmp)\n        for m, module in enumerate(string.pvmods):\n            cell_pos_df = _create_cell_pos_df(pv_mod=module, nr_string=s,\n                                              nr_mod=m)\n            ncols = sum(module.subStrCells)\n            nrows = int(module.numberCells / ncols)\n            v_bpd_trig = module.Vbypass\n            if write_bpd_act:\n                cols_per_substr = module.subStrCells\n                bpd = []\n                cis = []\n                rbc = []\n                # checking for bypass diode activation and reverse bised cells\n                for ss in range(module.numSubStr):\n                    interp_substring_vi = interp1d(module.Isubstr[ss],\n                                                   module.Vsubstr[ss])\n                    substring_vmp = interp_substring_vi(string_imp)\n                    if substring_vmp < 0: # doublecheck if we should compare to 0 here\n                        [bpd.append(2) for nss in range(cols_per_substr[ss])]\n                    else:\n                        [bpd.append(0) for nss in range(cols_per_substr[ss])]\n                    cis_inss = []\n                    for col in range(cols_per_substr[ss]):\n                        cis_inss += [i[\'idx\'] for i in module.cell_pos[ss][col]]\n                    cells_inss = [module.pvcells[ci] for ci in cis_inss]\n                    for cell in cells_inss:\n                        interp_cell_vi = interp1d(cell.Icell.flatten(),\n                                                  cell.Vcell.flatten())\n                        cell_vmp = interp_cell_vi(string_imp)\n                        if cell_vmp < 0:\n                            rbc.append(1)\n                        else:\n                            rbc.append(0)\n                    cis += cis_inss\n\n                cis_series = pd.Series(index=cis, data=rbc)\n                bpd_df = pd.DataFrame(index=cell_pos_df.index,\n                                      columns=cell_pos_df.columns)\n                bpdcols = [[c] * len(bpd_df) for c in bpd]\n                rbc_df = pd.DataFrame(index=cell_pos_df.index,\n                                      columns=cell_pos_df.columns)\n                for c, column in enumerate(cell_pos_df.columns):\n                    bpd_df[column] = bpdcols[c]\n                    for row in cell_pos_df.index:\n                        ci = cell_pos_df.loc[row, column]\n                        rbc_df.loc[row, column] = cis_series[ci]\n                # merging bpd and rbc dataframes into one dataframe, where\n                # 2 = bypassed cells and 1 = reverse biased cells\n                bpdrbc_df = (bpd_df * 2 + rbc_df).clip(upper=2)\n            # writing xls files\n            if not write_bpd_act:\n                bpdrbc_df = _create_nan_df(pv_mod=module, nr_string=s, nr_mod=m)\n            startcol = 0 if s == 0 else s*(ncols+1)\n            startrow = 0 if m == 0 else m*(nrows+1)\n\n            cell_pos_df.to_excel(writer, sheet_name=\'CellIndexes\',\n                                 startrow=startrow , startcol=startcol)\n            irrad_df = _create_irrad_df(pv_mod=module, cell_pos_df=cell_pos_df)\n            irrad_df.to_excel(writer, sheet_name=\'Irradiance\',\n                              startrow=startrow, startcol=startcol)\n            temp_df = _create_temp_df(pv_mod=module, cell_pos_df=cell_pos_df)\n            temp_df.to_excel(writer, sheet_name=\'CellTemp\', startrow=startrow,\n                             startcol=startcol)\n            bpdrbc_df.to_excel(writer, sheet_name=\'BpdAndRbc\',\n                               startrow=startrow, startcol=startcol)\n    # formatting the Irradiance worksheet\n    writer.sheets[\'Irradiance\'].conditional_format(0, 0,\n                                        writer.sheets[\'Irradiance\'].dim_rowmax,\n                                        writer.sheets[\'Irradiance\'].dim_colmax,\n                                        {\'type\': \'2_color_scale\',\n                                         \'min_type\': \'num\',\n                                         \'max_type\': \'num\',\n                                         \'min_value\':0,\n                                         \'max_value\':1,\n                                         \'min_color\':\'#808080\',\n                                         \'max_color\':\'#FFD700\'})\n    # formatting the CellTemp worksheet\n    writer.sheets[\'CellTemp\'].conditional_format(0, 0,\n                                    writer.sheets[\'CellTemp\'].dim_rowmax,\n                                    writer.sheets[\'CellTemp\'].dim_colmax,\n                                    {\'type\': \'3_color_scale\',\n                                     \'min_type\': \'num\',\n                                     \'mid_type\': \'num\',\n                                     \'max_type\': \'num\',\n                                     \'min_value\':273.15,\n                                     \'mid_value\':273.15 + 25,\n                                     \'max_value\':273.15 + 85,\n                                     \'min_color\':\'#85C1E9\',\n                                     \'mid_color\':\'#E5E7E9\',\n                                     \'max_color\':\'#E74C3C\'})\n    # formatting BpdAndRbc worksheet\n    writer.sheets[\'BpdAndRbc\'].conditional_format(0, 0,\n                                    writer.sheets[\'BpdAndRbc\'].dim_rowmax,\n                                    writer.sheets[\'BpdAndRbc\'].dim_colmax,\n                                    {\'type\': \'3_color_scale\',\n                                     \'min_type\': \'num\',\n                                     \'mid_type\': \'num\',\n                                     \'max_type\': \'num\',\n                                     \'min_value\':0,\n                                     \'mid_value\':1,\n                                     \'max_value\':2,\n                                     \'min_color\':\'#FFFFFF\',\n                                     \'mid_color\':\'#FF6347\',\n                                     \'max_color\':\'#36C1FF\'})\n    writer.save()\n    writer.close()\n\ndef set_input_from_xls(input_xls_name, pv_sys, str_num, str_len):\n    """"""Set cell temperatures of a PVMM PV system from an xls""""""\n    for string in list(range(str_num)):\n        for module in list(range(str_len)):\n            ncols = sum(pv_sys.pvstrs[string].pvmods[module].subStrCells)\n            nrows = int(pv_sys.pvstrs[string].pvmods[module].numberCells/ncols)\n            irrad = pd.read_excel(input_xls_name, sheet_name=\'Irradiance\',\n                                  skiprows=module*(nrows+1),nrows=nrows,\n                                  usecols=range(string*(ncols+1),\n                                  (string+1)*(ncols+1)),\n                                  index_col=0, header=0)\n            cell_temp = pd.read_excel(input_xls_name, sheet_name=\'CellTemp\',\n                                      skiprows=module*(nrows+1), nrows=nrows,\n                                      usecols=range(string*(ncols+1),\n                                      (string+1)*(ncols+1)),\n                                      index_col=0, header=0)\n            cell_pos = pd.read_excel(input_xls_name, sheet_name=\'CellIndexes\',\n                                     skiprows=module*(nrows+1), nrows=nrows,\n                                     usecols=range(string*(ncols+1),\n                                     (string+1)*(ncols+1)),\n                                     index_col=0, header=0)\n            Ee = []\n            Tc = []\n            mod_cell_idxs = []\n            for column in cell_pos.columns:\n                for row in cell_pos.index:\n                    Ee.append(irrad.loc[row, column])\n                    Tc.append(cell_temp.loc[row, column])\n                    mod_cell_idxs.append(cell_pos.loc[row, column])\n            pv_sys.setTemps({string:{module:[Tc, mod_cell_idxs]}})\n            pv_sys.setSuns({string:{module:[Ee, mod_cell_idxs]}})\n'"
pvmismatch/contrib/gen_coeffs/tests/__init__.py,0,"b'""""""\nTests of diode equations.\n""""""\n\nimport logging\n\nlogging.basicConfig()\nLOGGER = logging.getLogger(__name__)\nLOGGER.setLevel(logging.DEBUG)\n'"
pvmismatch/contrib/gen_coeffs/tests/test_diode.py,21,"b'""""""\nTest common diode model equations.\n""""""\n\nfrom pvmismatch.pvmismatch_lib.pvcell import (\n    RS as RS_2, RSH as RSH_2, ISAT1_T0 as ISAT1_2, ISAT2_T0 as ISAT2_2\n)\nfrom pvmismatch.contrib.gen_coeffs import diode\nfrom pvmismatch.contrib.gen_coeffs import PVMODULES\nfrom pvmismatch.contrib.gen_coeffs.tests import logging\nimport sympy\nimport numpy as np\n\nLOGGER = logging.getLogger(__name__)\nLOGGER.setLevel(logging.DEBUG)\n\nRS_1 = 0.0017692138011355  # [OHMS]\nRSH_1 = 22.58334768734093  # [OHMS]\nISAT_1 = 1.964978757168584e-008  # [A]\nM_1 = 1.339986040349784\nVT = 0.026  # [V]\nISC0 = PVMODULES[\'SunPower_SPR_E20_435\'][\'Isco\']  # 6.4293 [A]\nIC = PVMODULES[\'SunPower_SPR_E20_435\'][\'Impo\']  # 6.0102 [A]\nVC = (\n    PVMODULES[\'SunPower_SPR_E20_435\'][\'Vmpo\']\n    / PVMODULES[\'SunPower_SPR_E20_435\'][\'Cells_in_Series\']\n)  # 0.56545 = 72.3771/128 [V]\nVD_1 = VC + IC * RS_1  # [V]\n\nLOGGER.debug(\'I_sc0 = %g\', ISC0)\nLOGGER.debug(\'I_mp0 = %g\', IC)\nLOGGER.debug(\'V_mp0 = %g\', VC)\nLOGGER.debug(\'V_diode_1 = %g\', VD_1)\n\n\ndef test_fid():\n    """"""\n    Test diode current.\n    """"""\n    # make sympy symbols\n    isat, vd, m, vt = sympy.symbols([\'isat\', \'vd\', \'m\', \'vt\'])\n    # diode current\n    id_ = isat * (sympy.exp(vd / m / vt) - 1.0)\n    # derivatives\n    d_isat = sympy.diff(id_, isat)\n    d_vd = sympy.diff(id_, vd)\n    d_m = sympy.diff(id_, m)\n    d_vt = sympy.diff(id_, vt)\n    # evaluate scalars\n    test_data1 = {\'isat\': ISAT_1, \'vd\': VD_1, \'m\': M_1, \'vt\': VT}\n    fid_test1, jid_test1 = diode.fid(**test_data1)\n    fid_expected1 = np.float(id_.evalf(subs=test_data1))\n    jid_expected1 = np.array([\n        d_isat.evalf(subs=test_data1), d_vd.evalf(subs=test_data1),\n        d_m.evalf(subs=test_data1), d_vt.evalf(subs=test_data1)\n    ], dtype=np.float)\n    LOGGER.debug(\'test: %g = expected: %g\', fid_test1, fid_expected1)\n    assert np.isclose(fid_test1, fid_expected1)\n    assert np.allclose(jid_test1, jid_expected1.reshape(-1, 1))\n    # evaluate arrays\n    test_data2 = (np.array([ISAT1_2, ISAT2_2]), np.array([VD_1, VD_1]),\n                  np.array([1.0, 2.0]), np.array([VT, VT]))\n    fid_test2, jid_test2 = diode.fid(*test_data2)\n    # lambda functions\n    args, math_mod = (isat, vd, m, vt), (""numpy"",)\n    g_id = sympy.lambdify(args, id_, modules=math_mod)\n    g_d_isat = sympy.lambdify(args, d_isat, modules=math_mod)\n    g_d_vd = sympy.lambdify(args, d_vd, modules=math_mod)\n    g_d_m = sympy.lambdify(args, d_m, modules=math_mod)\n    g_d_vt = sympy.lambdify(args, d_vt, modules=math_mod)\n    fid_expected2 = g_id(*test_data2)\n    jid_expected2 = np.array([\n        g_d_isat(*test_data2), g_d_vd(*test_data2),\n        g_d_m(*test_data2), g_d_vt(*test_data2)\n    ], dtype=np.float)\n    assert np.allclose(fid_test2, fid_expected2)\n    assert np.allclose(jid_test2, jid_expected2)\n\n\ndef test_fish():\n    """"""\n    test shunt current.\n    """"""\n    # make sympy symbols\n    ish, vd, rsh = sympy.symbols([\'ish\', \'vd\', \'rsh\'])\n    # shunt current\n    ish = vd / rsh\n    d_vd = sympy.diff(ish, vd)\n    d_rsh = sympy.diff(ish, rsh)\n    # evaluate\n    test_data = {\'vd\': VD_1, \'rsh\': RSH_1}\n    fish_test, jish_test = diode.fish(**test_data)\n    fish_expected = np.float(ish.evalf(subs=test_data))\n    jish_expected = np.array([\n        d_vd.evalf(subs=test_data), d_rsh.evalf(subs=test_data)\n    ], dtype=np.float)\n    LOGGER.debug(\'test: %g = expected: %g\', fish_test, fish_expected)\n    assert np.isclose(fish_test, fish_expected)\n    assert np.allclose(jish_test, jish_expected.reshape(-1, 1))\n    # evaluate arrays\n\n\ndef test_fvd():\n    """"""\n    Test diode voltage.\n    """"""\n    # make sympy symbols\n    vd, vc, ic, rs = sympy.symbols([\'vd\', \'vc\', \'ic\', \'rs\'])\n    # diode voltage\n    vd = vc + ic * rs\n    d_vc = sympy.diff(vd, vc)\n    d_ic = sympy.diff(vd, ic)\n    d_rs = sympy.diff(vd, rs)\n    # evaluate\n    test_data = {\'vc\': VC, \'ic\': IC, \'rs\': RS_1}\n    fvd_test, jvd_test = diode.fvd(**test_data)\n    fvd_expected = np.float(vd.evalf(subs=test_data))\n    jvd_expected = np.array([\n        d_vc.evalf(subs=test_data), d_ic.evalf(subs=test_data),\n        d_rs.evalf(subs=test_data)\n    ], dtype=np.float)\n    LOGGER.debug(\'test: %g = expected: %g\', fvd_test, fvd_expected)\n    assert np.isclose(fvd_test, fvd_expected)\n    assert np.allclose(jvd_test, jvd_expected.reshape(-1, 1))\n    # evaluate arrays\n'"
pvmismatch/contrib/gen_coeffs/tests/test_two_diode.py,16,"b'""""""\nTest two diode model equations.\n""""""\n\nimport sympy\nimport numpy as np\nfrom pvmismatch.contrib.gen_coeffs.two_diode import fdidv, fdpdv, fjrsh\nfrom pvmismatch.contrib.gen_coeffs.tests.test_diode import (\n    ISAT1_2, ISAT2_2, RS_2, RSH_2, VT, ISC0, IC, VC\n)\nfrom pvmismatch.contrib.gen_coeffs.tests import logging\n\nLOGGER = logging.getLogger(__name__)\nLOGGER.setLevel(logging.DEBUG)\n\nVD_2 = VC + IC * RS_2\nLOGGER.debug(\'V_diode_2 = %g\', VD_2)\n\ndef test_didv_dpdv_frsh():\n    """"""\n    Test derivative of IV curve.\n    """"""\n    isat1, isat2, rs, rsh, vt, vc = sympy.symbols([\n        \'isat1\', \'isat2\', \'rs\', \'rsh\', \'vt\', \'vc\'\n    ])\n    ic = sympy.Function(\'ic\')(\'vc\')\n    isc0, alpha_isc, tc, t0, ee = sympy.symbols([\n        \'isc\', \'alpha_isc\', \'tc\', \'t0\', \'ee\'\n    ])\n    # short circuit\n    isc = isc0 * (1 + alpha_isc * (tc - t0))\n    vd_sc = isc * rs\n    id1_sc = isat1 * (sympy.exp(vd_sc / vt) - 1.0)\n    id2_sc = isat2 * (sympy.exp(vd_sc / 2.0 / vt) - 1.0)\n    ish_sc = vd_sc / rsh\n    aph = 1.0 + (id1_sc + id2_sc + ish_sc) / isc\n    # any current\n    iph = aph * ee * isc\n    vd = vc + ic * rs\n    id1 = isat1 * (sympy.exp(vd / vt) - 1.0)\n    id2 = isat2 * (sympy.exp(vd / 2.0 / vt) - 1.0)\n    ish = vd / rsh\n    # derivatives\n    diph_dv = sympy.diff(iph, vc)\n    did1_dv = sympy.diff(id1, vc)\n    did2_dv = sympy.diff(id2, vc)\n    dish_dv = sympy.diff(ish, vc)\n    di_dv = sympy.Derivative(ic, vc)\n    # 0 = ic - (iph - id1 - id2 - ish)\n    # 0 = dI/dV - d(Iph - Id1 - Id2 - Ish)/dV\n    f = di_dv - diph_dv + did1_dv + did2_dv + dish_dv\n    solution_set = sympy.solve(f, di_dv)\n    didv = solution_set[0]\n    # test fdidv\n    test_data = {\'isat1\': ISAT1_2, \'isat2\': ISAT2_2, \'rs\': RS_2,\n                 \'rsh\': RSH_2, \'ic\': IC, \'vc\': VC, \'vt\': VT}\n    fdidv_test, jdidv_test = fdidv(**test_data)\n    expected_data = {\n        isat1: ISAT1_2, isat2: ISAT2_2, rs: RS_2, rsh: RSH_2,\n        ic: IC, vc: VC, \'vd\': VD_2, vt: VT\n    }\n    didv_simple = didv.subs(vc + ic * rs, \'vd\')\n    fdidv_expected = np.float(didv_simple.evalf(subs=expected_data))\n    LOGGER.debug(\'fdidv test: %g, expected: %g\', fdidv_test, fdidv_expected)\n    assert np.isclose(fdidv_test, fdidv_expected)\n    # jacobian\n    d_didv_isat1 = didv.diff(isat1).subs(vc + ic * rs, \'vd\')\n    d_didv_isat2 = didv.diff(isat2).subs(vc + ic * rs, \'vd\')\n    d_didv_rs = didv.diff(rs).subs(vc + ic * rs, \'vd\')\n    d_didv_rsh = didv.diff(rsh).subs(vc + ic * rs, \'vd\')\n    d_didv_ic = didv.diff(ic).subs(vc + ic * rs, \'vd\')\n    d_didv_vc = didv.diff(vc).subs(vc + ic * rs, \'vd\')\n    # update expected test data with calculated derivative\n    expected_data[di_dv] = fdidv_expected\n    jdidv_expected = np.array([\n        d_didv_isat1.evalf(subs=expected_data),\n        d_didv_isat2.evalf(subs=expected_data),\n        d_didv_rs.evalf(subs=expected_data),\n        d_didv_rsh.evalf(subs=expected_data),\n        d_didv_ic.evalf(subs=expected_data),\n        d_didv_vc.evalf(subs=expected_data)\n    ], dtype=np.float)\n    LOGGER.debug(\n        \'\\njdidv test:\\n%r\\nexpected:\\n%r\\n\', jdidv_test,\n        jdidv_expected.reshape(-1, 1))\n    assert np.allclose(jdidv_test.flatten(), jdidv_expected)\n    # power\n    dpdv = didv * vc + ic\n    # test fdpdv\n    fdpdv_test, jdpdv_test = fdpdv(**test_data)\n    dpdv_simple = dpdv.subs(vc + ic * rs, \'vd\')\n    fdpdv_expected = np.float(dpdv_simple.evalf(subs=expected_data))\n    LOGGER.debug(\'fdpdv test: %g, expected: %g\', fdpdv_test, fdpdv_expected)\n    assert np.isclose(fdpdv_test, fdpdv_expected)\n    # jacobian\n    d_dpdv_isat1 = dpdv.diff(isat1).subs(vc + ic * rs, \'vd\')\n    d_dpdv_isat2 = dpdv.diff(isat2).subs(vc + ic * rs, \'vd\')\n    d_dpdv_rs = dpdv.diff(rs).subs(vc + ic * rs, \'vd\')\n    d_dpdv_rsh = dpdv.diff(rsh).subs(vc + ic * rs, \'vd\')\n    d_dpdv_ic = dpdv.diff(ic).subs(vc + ic * rs, \'vd\')\n    d_dpdv_vc = dpdv.diff(vc).subs(vc + ic * rs, \'vd\')\n    jdpdv_expected = np.array([\n        d_dpdv_isat1.evalf(subs=expected_data),\n        d_dpdv_isat2.evalf(subs=expected_data),\n        d_dpdv_rs.evalf(subs=expected_data),\n        d_dpdv_rsh.evalf(subs=expected_data),\n        d_dpdv_ic.evalf(subs=expected_data),\n        d_dpdv_vc.evalf(subs=expected_data)\n    ], dtype=np.float)\n    LOGGER.debug(\n        \'\\njdidv test:\\n%r\\nexpected:\\n%r\\n\', jdpdv_test,\n        jdpdv_expected.reshape(-1, 1))\n    assert np.allclose(jdpdv_test.flatten(), jdpdv_expected)\n    # shunt resistance\n    frsh = vd * (1.0 / rsh + didv)\n    # update test data\n    del test_data[\'ic\'], test_data[\'vc\']  # remove Ic, Vc\n    test_data[\'isc\'] = ISC0  # add Isc\n    frsh_test, jfrsh_test = fjrsh(**test_data)\n    frsh_simple = frsh.subs(vc + ic * rs, \'vd\')\n    # update expected test data with calculated derivative\n    expected_data[ic] = ISC0\n    expected_data[vc] = 0\n    expected_data[\'vd\'] = ISC0 * RS_2\n    didv_isc = np.float(didv_simple.evalf(subs=expected_data))\n    expected_data[di_dv] = didv_isc\n    frsh_expected = np.float(frsh_simple.evalf(subs=expected_data))\n    LOGGER.debug(\'frsh test: %r, expected: %r\', frsh_test, frsh_expected)\n    assert np.isclose(frsh_test, frsh_expected)\n    # jacobian\n    dfrsh_isat1 = frsh.diff(isat1).subs(vc + ic * rs, \'vd\')\n    dfrsh_isat2 = frsh.diff(isat2).subs(vc + ic * rs, \'vd\')\n    dfrsh_rs = frsh.diff(rs).subs(vc + ic * rs, \'vd\')\n    dfrsh_rsh = frsh.diff(rsh).subs(vc + ic * rs, \'vd\')\n    dfrsh_ic = frsh.diff(ic).subs(vc + ic * rs, \'vd\')\n    dfrsh_vc = frsh.diff(vc).subs(vc + ic * rs, \'vd\')\n    jfrsh_expected = np.array([\n        dfrsh_isat1.evalf(subs=expected_data),\n        dfrsh_isat2.evalf(subs=expected_data),\n        dfrsh_rs.evalf(subs=expected_data),\n        dfrsh_rsh.evalf(subs=expected_data),\n        dfrsh_ic.evalf(subs=expected_data),\n        dfrsh_vc.evalf(subs=expected_data),\n    ], dtype=np.float)\n    LOGGER.debug(\n        \'\\njdidv test:\\n%r\\nexpected:\\n%r\\n\', jfrsh_test,\n        jfrsh_expected.reshape(-1, 1))\n    assert np.allclose(jfrsh_test.flatten(), jfrsh_expected)\n    return dfrsh_isat1, dfrsh_isat2, dfrsh_rs, dfrsh_rsh, dfrsh_ic, dfrsh_vc\n'"
pvmismatch/contrib/xlsio/example_workflow/example_workflow.py,2,"b""import pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom pvmismatch.pvmismatch_lib import (pvcell, pvconstants, pvmodule,\n                                       pvstring, pvsystem)\n\nfrom pvmismatch.contrib import xlsio\n\n# Setting PV system layout cell and module parameters\nstr_len = 6 # number of modules in a string\nstr_num = 3 # number of (parallel connected) strings in the array\nv_bypass = np.float64(-0.5)  # [V] trigger voltage of bypass diode\ncell_area = np.float64(246.49)  # [cm^2] cell area\nIsc0_T0 = 9.68 # [A] reference short circuit current\nncols_per_substr=[2]*3 # 3 bypass diodes with 2 series connected cell-columns\nnrows=10 # number of cell rows in the module\n# Building PV modules and system\npv_mod_pattern = pvmodule.standard_cellpos_pat(nrows=nrows,\n                                            ncols_per_substr=ncols_per_substr)\npv_mod = pvmodule.PVmodule(cell_pos=pv_mod_pattern, pvcells=None,\n                           pvconst=None, Vbypass=v_bypass, cellArea=cell_area)\npv_cells = pv_mod.pvcells\nfor c in pv_cells:\n    c.update(Isc0_T0 = Isc0_T0) # updating short circuit currents\npv_mod.setSuns(cells=list(range(0, len(pv_cells))), Ee=[1]*len(pv_cells))\npv_str = pvstring.PVstring(numberMods=str_len, pvmods=[pv_mod]*str_len)\npv_sys = pvsystem.PVsystem(numberStrs=str_num, pvstrs=[pv_str]*str_num,\n                           numberMods=[str_len]*str_num,\n                           pvmods=[pv_mod]*str_len)\n\n# Create a human-readable xls of the pv system layout with the PV cell indexes\n# irradiances and temperatures\noutput_xls_name=r'ExcelLayoutFromPVMM.xlsx' # the mod. & sys. layout in xls\nxlsio.system_layout_to_xls(output_xls_name, pv_sys, write_bpd_act=False)\nprint('PV power with 1 suns: ', pv_sys.calcSystem()[2].max(), ' [W]')\nplot = pv_sys.plotSys()\nplt.show(block=False)\n\n# Set now the desired irradiance input in the xls files with some xls editor\n\n# After a human has changed the irradiance values for the system in the xls\n# and saved it with a different name, we can read the new irradiance back to\n# python anc calculate PV power again. Then we update the xls files with the\n# bypass diode activation patterns, as this can only be done after the system\n# is calculated.\n\nfor i in list(range(1,7)):\n    input_xls_name=r'ExcelLayoutFromPVMM_input{}.xlsx'.format(i)\n    xlsio.set_input_from_xls(input_xls_name, pv_sys, str_num, str_len)\n    print('PV power with irradiances read in from {}: '.format(input_xls_name),\n          pv_sys.calcSystem()[2].max(), ' [W]')\n    # updating the input excel with the bypass diode activation\n    xlsio.system_layout_to_xls(output_xls_name=input_xls_name, pv_sys=pv_sys,\n                               write_bpd_act=True)\n    pv_sys.plotSys()\n    plt.show(block=False)\n"""
