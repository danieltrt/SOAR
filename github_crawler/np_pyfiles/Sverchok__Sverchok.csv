file_path,api_count,code
__init__.py,0,"b'#  ***** BEGIN GPL LICENSE BLOCK *****\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, see <http://www.gnu.org/licenses/>\n#  and write to the Free Software Foundation, Inc., 51 Franklin Street,\n#  Fifth Floor, Boston, MA  02110-1301, USA..\n#\n#  The Original Code is Copyright (C) 2015 by Gorodetskiy Nikita  ###\n#  All rights reserved.\n#\n#  Contact:      linusyng@live.com    ###\n#\n#  The Original Code is: all of this file.\n#\n#  Contributor(s):\n#     Linus Yng (aka Ly29)\n#\n#  ***** END GPL LICENSE BLOCK *****\n#\n# -*- coding: utf-8 -*-\n\n\nimport sys\nimport importlib\nimport pkgutil\n\n\nbl_info = {\n    ""name"": ""SverchokRedux"",\n    ""author"":\n        ""ly29"",\n    ""version"": (0, 6, 2, 0),\n    ""blender"": (2, 7, 8),\n    ""location"": ""Nodes > Ghost > Add user nodes"",\n    ""description"": ""Parametric node-based geometry programming"",\n    ""warning"": """",\n    ""wiki_url"": """",\n    ""tracker_url"": """",\n    ""category"": ""Node""}\n\n\nif __name__ != ""svrx"":\n    sys.modules[""svrx""] = sys.modules[__name__]\n\n# Recursive auto import,\n# http://stackoverflow.com/a/25562415\n\ndef import_submodules(package, recursive=True):\n    """""" Import all submodules of a module, recursively, including subpackages\n    :param package: package (name or actual module)\n    :type package: str | module\n    :rtype: dict[str, types.ModuleType]\n    """"""\n    if isinstance(package, str):\n        package = importlib.import_module(package)\n    results = {}\n    for loader, name, is_pkg in pkgutil.walk_packages(package.__path__):\n        full_name = package.__name__ + \'.\' + name\n        results[full_name] = importlib.import_module(full_name)\n        if recursive and is_pkg:\n            results.update(import_submodules(full_name))\n    return results\n\n\nimported_modules = import_submodules(\'svrx\')\n\nreload_event = bool(""bpy"" in locals())\n\nif reload_event:\n    print(""SvRx reloading"")\n    # modules that needs to be loaded in order\n    # for changes in these modules restart\n\n    prio_list = [\'svrx.nodes.classes\', \'svrx.nodes.node_base\', \'svrx.typing\']\n    #prio_list.extend([key for key in imported_modules.keys() if key.startswith(""svrx.core"")])\n\n    for key, im in imported_modules.items():\n        if key in prio_list:\n            continue\n        importlib.reload(im)\n\n# this is used as a marker for reload\nimport bpy\n\n\ndef register():\n\n    for m in imported_modules.values():\n        if hasattr(m, ""register""):\n            m.register()\n    bpy.utils.register_module(__name__)\n    if reload_event:\n        print(""SvRx is reloaded, press update"")\n\n\ndef unregister():\n    bpy.utils.unregister_module(__name__)\n\n    for m in reversed(list(imported_modules.values())):\n        if hasattr(m, ""unregister""):\n            m.unregister()\n'"
typing.py,1,"b'import numpy as np\n\nfrom bpy.props import (BoolProperty, EnumProperty,\n                       FloatProperty, IntProperty,\n                       StringProperty, FloatVectorProperty,\n                       IntVectorProperty, BoolVectorProperty)\n\n\nclass SvRxBaseType:\n    iterable = False\n\n    def __init__(self, name=None, iterable=None):\n        if name is None:\n            self.default_name = type(self).__name__\n            self.name = None\n        else:\n            self.name = name\n\n        if iterable is not None:\n            # basiclly only allow chaning to False for types\n            # than can be resonable iterated\n            self.iterable = iterable\n\n    def get_settings(self):\n        return {}\n\n\n# Everytype must have a corresponding socket\n# Types aren\'t actually concrete types, they are just for\n# auto generating nodes based on introspection\n\n# specal value kept\n\nclass Required:\n    pass\n\n\nclass Anytype(SvRxBaseType):\n    bl_idname = ""SvRxSocketAny""\n\n\nclass Number(SvRxBaseType):\n    bl_idname = ""SvRxSocketFloat""\n    iterable = True\n\n    def __init__(self, name=None, iterable=None, min=None, max=None):\n        super().__init__(name, iterable)\n        self.min = min\n        self.max = max\n\n    def get_settings(self):\n        settings = {}\n        if self.max is not None:\n            settings[\'default_value_high\'] = self.max\n        if self.min is not None:\n            settings[\'default_value_low\'] = self.min\n        return settings\n\n\nclass Int(Number):\n    @property\n    def bl_idname(self):\n        if self.max is not None or self.min is not None:\n            return ""SvRxSocketIntLimit""\n        else:\n            return ""SvRxSocketInt""\n\n\nclass Bool(Int):\n    pass\n\n\nclass Float(Number):\n    @property\n    def bl_idname(self):\n        if self.max is not None or self.min is not None:\n            return ""SvRxSocketFloatLimit""\n        else:\n            return ""SvRxSocketFloat""\n\n\nclass Number4f(SvRxBaseType):\n    iterable = True\n\n\nclass Color(Number4f):\n    bl_idname = ""SvRxSocketColor""\n\n\nclass Vertices(Number4f):\n    bl_idname = ""SvRxSocketVertex""\n\n\nclass Vector(Number4f):\n    bl_idname = ""SvRxSocketVector""\n\n\nclass Point(Number4f):\n    bl_idname = ""SvRxSocketPoint""\n\n\nclass Edges(SvRxBaseType):\n    bl_idname = ""SvRxSocketTopo""\n\n\nclass Faces(SvRxBaseType):\n    bl_idname = ""SvRxSocketTopo""\n\n\nclass TopoData(Edges, Faces):\n    bl_idname = ""SvRxSocketTopo""\n\n\nclass String(SvRxBaseType):\n    bl_idname = ""SvRxSocketString""\n\n\nclass Object(SvRxBaseType):\n    bl_idname = ""SvRxSocketObject""\n    iterable = False\n\n\nclass Matrix(SvRxBaseType):\n    bl_idname = ""SvRxSocketMatrix""\n    identity = np.identity(4)\n    iterable = False\n\n\nclass Mesh(SvRxBaseType):\n    bl_idname = ""SvRxSocketMesh""\n    iterable = False\n\n\nclass BMesh(Mesh):\n    bl_idname = ""SvRxSocketMesh""\n    iterable = False\n\n\nclass SMesh(Mesh):\n    bl_idname = ""SvRxSocketMesh""\n    iterable = False\n\n\n# Property types\n\n\ndef exec_node(self, context):\n    self.id_data.update()\n\n\nclass SvRxBaseTypeP:\n    def __init__(self, **kwargs):\n        self.kwargs = {}\n        self.kwargs[\'update\'] = exec_node\n        self.kwargs.update(kwargs)\n\n    def add(self, key, value):\n        self.kwargs[key] = value\n\n    def get_prop(self):\n        return self.prop_func(**self.kwargs)\n\n\nclass FloatP(SvRxBaseTypeP):\n    prop_func = FloatProperty\n\n\nclass IntP(SvRxBaseTypeP):\n    prop_func = IntProperty\n\n\nclass BVectorP(SvRxBaseTypeP):\n    prop_func = BoolVectorProperty\n\n\nclass IVectorP(SvRxBaseTypeP):\n    prop_func = IntVectorProperty\n\n\nclass FVectorP(SvRxBaseTypeP):\n    prop_func = FloatVectorProperty\n\n\nclass ColorP(FVectorP):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.kwargs[\'size\'] = 3\n        self.kwargs[\'min\'] = 0.0\n        self.kwargs[\'max\'] = 1.0\n        self.kwargs[\'subtype\'] = \'COLOR\'\n\n\nclass ColorAP(ColorP):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.kwargs[\'size\'] = 4\n\n\nclass StringP(SvRxBaseTypeP):\n    prop_func = StringProperty\n\n\nclass EnumP(SvRxBaseTypeP):\n    prop_func = EnumProperty\n\n\nclass BoolP(SvRxBaseTypeP):\n    prop_func = BoolProperty\n\n\n# Value Types, used for outputs\n\nclass ValueBase:\n    bl_idname = ""SvRxSocketValueInt""\n\n\nclass IntValue(Int):\n    bl_idname = ""SvRxSocketValueInt""\n\n\nclass FloatValue(Float):\n    bl_idname = ""SvRxSocketValueFloat""\n\n\nclass PointValue(Number4f):\n    bl_idname = ""SvRxSocketValuePoint""\n\n\nclass ColorValue(Number4f):\n    bl_idname = ""SvRxSocketValueColor""\n\n\nclass ObjectValue(Object):\n    bl_idname = ""SvRxSocketValueObject""\n\n\nbases = [Number, Number4f, Mesh, Object, String, Matrix, Anytype, Faces, Edges]\n_lookup = {}\n\n\ndef get_classes(cls):\n    for sub_cls in cls.__subclasses__():\n        yield sub_cls\n        yield from get_classes(sub_cls)\n\n\nfor base in bases:\n    _lookup[base] = base\n    for class_ in get_classes(base):\n        _lookup[class_] = base\n'"
core/__init__.py,0,b''
core/data_tree.py,1,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\nimport bpy\nimport collections\nfrom itertools import  chain\n\nimport numpy as np\n\n\nclass SvDataTree:\n    __slots__ =  (\'children\', \'data\', \'name\', \'level\', \'obj_count\')\n    def __init__(self, socket=None, node=None, prop=None):\n        self.data = None\n        self.children = []\n        self.name = """"\n        self.level = None\n        self.obj_count = None\n        if socket:\n            self.name = socket.node.name + "": "" + socket.name\n            self.level = 0\n            if not socket.is_linked:\n                if socket.default_value is not None:\n                    if isinstance(socket.default_value, str):\n                        if socket.bl_idname == ""SvRxSocketString"":\n                            self.data = socket.default_value\n                        elif socket.bl_idname == ""SvRxSocketObject"":\n                            self.data = bpy.data.objects.get(socket.default_value)\n                    else:\n                        self.data = np.array([socket.default_value])\n        elif node and prop is not None:\n            self.name = node.name + ""."" + prop\n            self.data = getattr(node, prop)\n            self.level = 0\n        else:\n            pass\n\n    def add_child(self, data=None):\n        self.children.append(SvDataTree())\n        self.children[-1].data = data\n        return self.children[-1]\n\n    @property\n    def is_leaf(self):\n        return self.data is not None\n\n    def __repr__(self):\n        if self.is_leaf:\n            return ""SvDataTree<data={}, level={}>"".format(self.data, self.level)\n        else:\n            return ""SvDataTree<children={}, level={},d={}>"".format(len(self.children), self.level, self.data)\n\n    def print(self, level=0):\n        if self.name:\n            print(self.name, self.level)\n        else:\n            print(self.level)\n        if self.is_leaf:\n            print(level * ""    "", self.data)\n        else:\n            for child in self.children:\n                child.print(level + 1)\n\n    def __iter__(self):\n        if self.is_leaf:\n            yield self.data\n        else:\n            for v in chain(map(iter, self.children)):\n                yield from v\n\n    def set_level(self):\n        if self.is_leaf:\n            self.level = 0\n        else:\n            level = 0\n            for child in self.children:\n                level = max(child.set_level() + 1, level)\n            self.level = level\n        return self.level\n\n    def get_level(self):\n        return self.level\n\n    def assign(self, level, data):\n        if level == 0:\n            self.data = data\n            self.level = 0\n        elif level == 1:\n            for d in data:\n                self.add_child(data=d).level = 0\n            self.level = 1\n\n    def count(self):\n        if self.obj_count is None:\n            if self.is_leaf:\n                return 1\n            else:\n                self.obj_count = sum(t.count() for t in self.children)\n                return self.obj_count\n        else:\n            return -1 if self.obj_count is None else self.obj_count\n'"
core/execution.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport collections\nfrom itertools import chain\n\nimport svrx\nfrom svrx.core.data_tree import SvDataTree\nfrom svrx.core.type_conversion import needs_conversion, get_conversion\nfrom svrx.nodes.node_base import Stateful\n\nimport svrx.core.timings as timings\nfrom svrx.core.timings import add_time, time_func, start_timing, show_timings\nimport svrx.ui.error as error\n\n\nclass SvTreeDB:\n    """"""\n    Data storage loookup for sockets\n    """"""\n    def __init__(self):\n        self.data_trees = {}\n        self.links = {}\n\n    def set_links(self, ng, links):\n        self.links[ng.name] = links\n\n    def print(self, ng):\n        for link in ng.links:\n            self.get(link.from_socket).print()\n\n    def get(self, socket):\n        ng_id = socket.id_data.name\n        if not socket.is_output:\n            if ng_id in self.links:\n                return self.get(self.links[ng_id][socket])\n            else:\n                return self.get(socket.other)\n\n        if ng_id not in self.data_trees:\n            self.data_trees[ng_id] = {}\n        ng_trees = self.data_trees[ng_id]\n        if socket not in ng_trees:\n            ng_trees[socket] = SvDataTree(socket=socket)\n        return ng_trees[socket]\n\n    def clean(self, ng):\n        ng_id = ng.name\n        self.data_trees[ng_id] = {}\n\n\ndata_trees = SvTreeDB()\n\n\nclass VirtualNode:\n    """"""\n    Used to represent node that don\'t have real conterpart in the layout\n    """"""\n    bl_idname = ""SvRxVirtualNode""\n\n    def __init__(self, func, ng):\n        self.func = func\n        self.id_data = ng\n        self.inputs = []\n        for _, name, default in func.inputs_template:\n            self.inputs.append(VirtualSocket(self,\n                                             name=name,\n                                             default=default[\'default_value\'],\n                                             output=False))\n        self.outputs = [VirtualSocket(self) for _ in func.returns]\n        self.name = ""VNode<{}>"".format(func.label)\n\n    def compile(self):\n        return self.func\n\n\nclass VirtualLink:\n    bl_idname = ""SvRxVirtualLink""\n\n    def __init__(self, from_socket, to_socket):\n        self.from_socket = from_socket\n        self.from_node = from_socket.node\n        self.to_node = to_socket.node\n        self.to_socket = to_socket\n        self.id_data = self.from_node.id_data\n\n        if isinstance(from_socket, VirtualSocket):\n            from_socket.is_linked = True\n\n        if isinstance(to_socket, VirtualSocket):\n            to_socket.is_linked = True\n            to_socket.other = from_socket\n\n\nclass VirtualSocket:\n    def __init__(self, node, name=None, default=None, output=True):\n        self.name = name or ""VirtualSocket""\n        self.node = node\n        self.id_data = node.id_data\n        self.default_value = default\n        self.is_linked = False\n        self.required = False\n        self.is_output = output\n\n\ndef topo_sort(links, starts):\n    """"""\n    links = {node: [node0, node1, ..., nodeN]}\n    starts, nodes to start from\n    return a topologiclly sorted list\n    """"""\n    weights = collections.defaultdict(lambda: -1)\n\n    def visit(node, weight):\n        weights[node] = max(weight, weights[node])\n        for from_node in links[node]:\n            visit(from_node, weight + 1)\n\n    for start in starts:\n        visit(start, 0)\n    return sorted(weights.keys(), key=lambda n: -weights[n])\n\n\ndef filter_reroute(ng):\n    links = []\n    for l in ng.links:\n        if not l.is_valid:\n            return []\n        if l.to_node.bl_idname == \'NodeReroute\':\n            continue\n        if l.from_node.bl_idname == \'NodeReroute\':\n            links.append(VirtualLink(l.to_socket.other, l.to_socket))\n        else:\n            links.append(l)\n\n    return links\n\n\ndef compile_nodes(links, nodes):\n    for link in links:\n        if link.from_node not in nodes:\n            nodes[link.from_node] = link.from_node.compile()\n        if link.to_node not in nodes:\n            nodes[link.to_node] = link.to_node.compile()\n\n\ndef verify_links(links, nodes, socket_links, real_nodes=False):\n    skip = set()\n\n    for i in range(len(links)):\n        link = links[i]\n\n        to_func = nodes[link.to_node]\n        from_func = nodes[link.from_node]\n        from_type = from_func.returns[link.from_socket.index][0]\n\n        to_type = None\n        socket_index = link.to_socket.index\n        for index, _, s_type in to_func.parameters:\n            if index == socket_index:\n                to_type = s_type\n        if needs_conversion(from_type, to_type):\n            skip.add(i)\n            func, to_index, from_index = get_conversion(from_type, to_type)\n            ng = link.id_data\n            if real_nodes:\n                node = ng.nodes.new(func.bl_idname)\n                node.hide = True\n                node.select = False\n                nodes[node] = node.compile()\n                node.location = (link.from_node.location + link.to_node.location) * .5\n                for idx in to_index:\n                    links.append(ng.links.new(link.from_socket, node.inputs[idx]))\n                links.append(ng.links.new(node.outputs[from_index], link.to_socket))\n            else:\n                node = VirtualNode(func, ng)\n                nodes[node] = func\n                for idx in to_index:\n                    links.append(VirtualLink(link.from_socket, node.inputs[idx]))\n                links.append(VirtualLink(node.outputs[from_index], link.to_socket))\n\n    real_links = collections.defaultdict(list)\n\n    for idx, link in enumerate(links):\n        if idx in skip:\n            continue\n        real_links[link.to_node].append(link.from_node)\n        socket_links[link.to_socket] = link.from_socket\n\n    return real_links\n\n\ndef DAG(ng, nodes, socket_links):\n    """"""\n    preprocess the node layout in suitable way\n    for topo_sort, removing reroutes and verifying\n    type info\n    """"""\n\n    # needs to preprocess certain things\n    # 1. reroutes, done\n    # 2. type inf, done\n    # 3. wifi node replacement\n\n    links = filter_reroute(ng)\n    compile_nodes(links, nodes)\n    real_links = verify_links(links, nodes, socket_links, real_nodes=ng.rx_real_nodes)\n\n    from_nodes = set(node for node in chain(*real_links.values()))\n    starts = {node for node in real_links.keys() if node not in from_nodes}\n\n    node_list = topo_sort(real_links, starts)\n    return node_list\n\n\ndef recurse_levels(f, in_levels, out_levels, in_trees, out_trees):\n    """"""\n    does the exec for each node by recursively matching input trees\n    and building output tree\n    """"""\n\n    if all(t.level == l for t, l in zip(in_trees, in_levels)):\n        """"""\n        All tree levels a correct, build arguments for node func\n        call it and store results\n        """"""\n        args = []\n        for tree in in_trees:\n            if tree.level == 0:\n                args.append(tree.data)\n            else:\n                args.append(list(tree))\n        results = f(*args)\n        if len(out_trees) > 1:\n            if any(l > 0 for l in out_levels):\n                results = zip(*results)\n            for out_tree, l, result in zip(out_trees, out_levels, results):\n                if out_tree:\n                    out_tree.assign(l, result)\n        elif len(out_trees) == 1 and out_trees[0]:  # results is a single socket\n            out_trees[0].assign(out_levels[0], results)\n        else:  # no output\n            pass\n    else:\n        inner_trees = []\n        max_length = 1\n        for tree, l in zip(in_trees, in_levels):\n            if tree.level != l:\n                inner_trees.append(tree.children)\n                max_length = max(len(tree.children), max_length)\n            else:\n                inner_trees.append(None)\n\n        for i in range(max_length):\n            args = []\n            for tree, inner_tree in zip(in_trees, inner_trees):\n                if inner_tree is None:\n                    args.append(tree)\n                else:\n                    if i < len(inner_tree):\n                        args.append(inner_tree[i])\n                    else:\n                        args.append(inner_tree[-1])\n\n            outs = []\n            for ot in out_trees:\n                if ot:\n                    outs.append(ot.add_child())\n                else:\n                    outs.append(None)\n\n            recurse_levels(f, in_levels, out_levels, args, outs)\n\n\ndef collect_inputs(func, node):\n    in_trees = []\n    in_levels = []\n    for param, level, data_type in func.parameters:\n        in_levels.append(level)\n        #  int refers to socket index, str to a property name on the node\n        if isinstance(param, int):\n            socket = node.inputs[param]\n            if socket.is_linked:\n                tree = data_trees.get(socket)\n            elif socket.required:\n                print(""Warning Required socket not connected"", node.name)\n                msg = ""Required socket not connected {}: {}"".format(node.name, socket.name)\n                raise SyntaxError(msg)\n            else:\n                tree = SvDataTree(socket)\n        else:  # prop parameter\n            tree = SvDataTree(node=node, prop=param)\n        in_trees.append(tree)\n    return in_trees, in_levels\n\n\ndef exec_node_group(node_group):\n    data_trees.clean(node_group)\n    error.clear(node_group)\n    nodes = {}\n    socket_links = {}\n    do_timings = node_group.do_timings_text or node_group.do_timings_graphics\n    if do_timings:\n        timings.start_timing()\n\n    add_time(node_group.name)\n    add_time(""DAG"")\n    dag_list = DAG(node_group, nodes, socket_links)\n    data_trees.set_links(node_group, socket_links)\n    add_time(""DAG"")\n    try:\n        for node in dag_list:\n\n            func = nodes[node]\n            add_time(node.bl_idname + "": "" + node.name)\n\n            if isinstance(func, Stateful):\n                add_time(func.label)\n                func.start()\n                add_time(func.label)\n\n            in_trees, in_levels = collect_inputs(func, node)\n\n            out_trees = []\n            for socket in node.outputs:\n                if socket.is_linked:\n                    out_trees.append(data_trees.get(socket))\n                else:\n                    out_trees.append(None)\n\n            out_levels = [l for _, l in func.returns]\n\n            if do_timings:\n                recurse_levels(time_func(func), in_levels, out_levels, in_trees, out_trees)\n            else:\n                recurse_levels(func, in_levels, out_levels, in_trees, out_trees)\n\n            for ot in out_trees:\n                if ot:\n                    ot.set_level()\n\n            if isinstance(func, Stateful):\n                add_time(func.label)\n                func.stop()\n                add_time(func.label)\n\n            add_time(node.bl_idname + "": "" + node.name)\n        add_time(node_group.name)\n\n        if do_timings:\n            show_timings(node_group)\n    except Exception as err:\n        error.show(node, err)\n'"
core/handler.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport bpy\nfrom bpy.app.handlers import persistent\n\nfrom svrx.core.tree import svrx_trees\nfrom svrx.util import bgl_callback, bgl_callback_3dview\nimport svrx\n\n@persistent\ndef sv_main_handler(scene):\n    """"""\n    Main Sverchok handler for updating node tree upon editor changes\n    """"""\n    reload_event = svrx.reload_event\n    svrx.reload_event = False\n    for ng in svrx_trees():\n        if ng.has_changed or reload_event:\n            ng.execute()\n\n\n@persistent\ndef sv_file_load(scene):\n    """"""\n    To make sure nodes follow signature on node changes on startup\n    clean up callbacks\n    """"""\n\n    for callback in (bgl_callback, bgl_callback_3dview):\n        callback.callback_disable_all()\n\n    for ng in svrx_trees():\n        for node in ng.nodes:\n            if node.bl_idname == ""SvRxNodeScript"":\n                node.load_text()\n            if hasattr(node, ""adjust_sockets""):\n                node.adjust_sockets()\n\n\n@persistent\ndef frame_change(scene):\n    for ng in svrx_trees():\n        try:\n            ng.execute_animate()\n        except:\n            pass\n    scene.update()\n\n\ndef register():\n    bpy.app.handlers.scene_update_pre.append(sv_main_handler)\n    bpy.app.handlers.load_post.append(sv_file_load)\n    bpy.app.handlers.frame_change_pre.append(frame_change)\n\n\ndef unregister():\n    bpy.app.handlers.scene_update_pre.remove(sv_main_handler)\n    bpy.app.handlers.load_post.remove(sv_file_load)\n    bpy.app.handlers.frame_change_pre.remove(frame_change)\n'"
core/script.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nimport importlib\nimport importlib.abc\nimport importlib.util\nimport sys\n\nimport bpy\n\n\nfrom svrx.util.importers import text_remap\n\nclass SvRxFinder(importlib.abc.MetaPathFinder):\n\n    def find_spec(self, fullname, path, target=None):\n        if fullname.startswith(""svrx.nodes.script.""):\n            name = fullname.split(""."")[-1]\n            text_name = text_remap(name, reverse=True)\n            if text_name in bpy.data.texts:\n                return importlib.util.spec_from_loader(fullname, SvRxLoader(text_name))\n            else:\n                print(""couldn\'t find file"")\n\n        elif fullname == ""svrx.nodes.script"":\n            # load Module, right now uses real but empty module, will perhaps change\n            pass\n        return None\n\n\nSTANDAD_HEADER = ""from svrx.nodes.node_base import node_script; from svrx.typing import *;""\n\nclass SvRxLoader(importlib.abc.SourceLoader):\n\n    def __init__(self, text):\n        self._text = text\n\n    def get_data(self, path):\n        text = bpy.data.texts[self._text]\n        lines = [l.body for l in text.lines[1:]]\n        lines.insert(0, STANDAD_HEADER + text.lines[0].body)\n        source = ""\\n"".join(lines)\n        return source\n\n    def get_filename(self, fullname):\n        return ""<bpy.data.texts[{}]>"".format(self._text)\n\n\ndef register():\n    sys.meta_path.append(SvRxFinder())\n\ndef unregister():\n    for finder in sys.meta_path[:]:\n        if isinstance(finder, SvRxFinder):\n            sys.meta_path.remove(finder)\n'"
core/socket.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport bpy\n\nfrom bpy.props import (FloatProperty,\n                       IntProperty,\n                       FloatVectorProperty,\n                       BoolProperty,\n                       StringProperty)\n\nfrom .execution import data_trees\n\n\n\ndef exec_socket(self, context):\n    self.id_data.update()\n\n\ndef get_other_socket(socket):\n    """"""\n    Get next real upstream socket.\n    This should be expanded to support wifi nodes also.\n    Will return None if there isn\'t a another socket connect\n    so no need to check socket.links\n    """"""\n\n    if not socket.is_linked:\n        return None\n\n    if not socket.is_output:\n        other = socket.links[0].from_socket\n    else:\n        other = socket.links[0].to_socket\n\n    if other.node.bl_idname == \'NodeReroute\':\n        if not socket.is_output:\n            return get_other_socket(other.node.inputs[0])\n        else:\n            return get_other_socket(other.node.outputs[0])\n    else:\n        return other\n\n\nclass SocketBase:\n    default_value = None\n    color = (1, 0, 0, 1)  # red to show unset colors\n    error_color = (1, 0, 0, 1)\n    required = BoolProperty(default=False)\n\n    def draw(self, context, layout, node, text):\n\n        if self.is_output and self.is_linked:\n            layout.label(text + "" : "" + self.count)\n        elif self.is_linked:\n            layout.label(text)\n        elif not self.is_output and self.default_value is not None:\n            layout.prop(self, ""default_value"", text=text)\n        else:\n            layout.label(text)\n\n    def draw_color(self, context, node):\n        if self.required and not self.is_linked:\n            return self.error_color\n        return self.color\n\n    def replace_socket(self, bl_idname=None, name=None, settings=None):\n        replace_socket(self, new_type=bl_idname, new_name=name, settings=settings)\n\n    @property\n    def depth(self):\n        level = data_trees.get(self).level\n        if level is not None:\n            return str(level)\n        else:\n            return """"\n\n    @property\n    def data_tree(self):\n        if self.is_output:\n            return data_trees.get(self)\n        else:\n            return self.other.data_tree\n\n    @property\n    def count(self):\n        tree = data_trees.get(self)\n        return str(tree.count())\n\n    @property\n    def socket_id(self):\n        return hash(self)\n\n    @property\n    def other(self):\n        return get_other_socket(self)\n\n    @property\n    def index(self):\n        """"""Index of socket""""""\n        node = self.node\n        sockets = node.outputs if self.is_output else node.inputs\n        for i, s in enumerate(sockets):\n            if s == self:\n                return i\n\n    def setup(self, settings):\n        if settings:\n            for key, value in settings.items():\n                if getattr(self, key) is not None:\n                    setattr(self, key, value)\n\n\ndef replace_socket(socket, new_type=None, new_name=None, settings=None):\n    \'\'\'\n    Replace a socket with a socket of new_type and keep links\n    \'\'\'\n\n    socket_type = new_type or socket.bl_idname\n    socket_name = new_name or socket.name\n    socket_pos = socket.index\n    settings = settings or {}\n    ng = socket.id_data\n\n    if socket.bl_idname == socket_type:\n        if socket.name == new_name:\n            return socket\n        socket.name = new_name\n        socket.setup(settings)\n        return socket\n\n    if socket.is_output:\n        outputs = socket.node.outputs\n        to_sockets = [l.to_socket for l in socket.links]\n\n        outputs.remove(socket)\n        new_socket = outputs.new(socket_type, socket_name)\n        outputs.move(len(outputs)-1, socket_pos)\n\n        for to_socket in to_sockets:\n            ng.links.new(new_socket, to_socket)\n\n    else:\n        inputs = socket.node.inputs\n        from_socket = socket.links[0].from_socket if socket.is_linked else None\n\n        inputs.remove(socket)\n        new_socket = inputs.new(socket_type, socket_name)\n        inputs.move(len(inputs)-1, socket_pos)\n        new_socket.setup(settings)\n\n        if from_socket:\n            ng.links.new(from_socket, new_socket)\n\n    return new_socket\n\n\nclass SocketNumber(SocketBase):\n    color = (0.0, 0.8, 0.0, 1.0)\n\n\nclass IntSocket(bpy.types.NodeSocket, SocketNumber):\n    bl_idname = ""SvRxSocketInt""\n    bl_label = ""Int Socket""\n\n    default_value = IntProperty(update=exec_socket)\n\n\n#  property functions for limited value sockets\n\ndef get_value(self):\n    value = self.get(\'default_value\', 0)\n    return max(min(value, self.default_value_high), self.default_value_low)\n\n\ndef set_value(self, value):\n    self[\'default_value\'] = max(min(value, self.default_value_high), self.default_value_low)\n\n\nclass IntLimitSocket(bpy.types.NodeSocket, SocketNumber):\n    bl_idname = ""SvRxSocketIntLimit""\n    bl_label = ""Int Socket""\n\n    default_value_low = IntProperty(default=-100)\n    default_value_high = IntProperty(default=100)\n    default_value = IntProperty(update=exec_socket, set=set_value, get=get_value)\n\n\nclass FloatSocket(bpy.types.NodeSocket, SocketNumber):\n    bl_idname = ""SvRxSocketFloat""\n    bl_label = ""Float Socket""\n\n    default_value = FloatProperty(update=exec_socket)\n\n\nclass FloatLimitSocket(bpy.types.NodeSocket, SocketNumber):\n    bl_idname = ""SvRxSocketFloatLimit""\n    bl_label = ""Float Socket""\n\n    default_value_low = FloatProperty(default=-100)\n    default_value_high = FloatProperty(default=100)\n\n    default_value = FloatProperty(update=exec_socket, set=set_value, get=get_value)\n\n\nclass SocketVector(SocketBase):\n    color = (0.9, 0.6, 0.2, 1.0)\n\n\nclass VertexSocket(bpy.types.NodeSocket, SocketVector):\n    bl_idname = ""SvRxSocketVertex""\n    bl_label = ""Vertex Socket""\n\n\nclass MatrixSocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = ""SvRxSocketMatrix""\n    bl_label = ""Matrix Socket""\n\n    color = (.2, .8, .8, 1.0)\n\n\nclass VectorSocket(bpy.types.NodeSocket, SocketVector):\n    bl_idname = ""SvRxSocketVector""\n    bl_label = ""Vector Socket""\n\n    default_value = FloatVectorProperty(size=4, update=exec_socket, default=(0, 0, 0, 1))\n\n    def draw(self, context, layout, node, text):\n        if not self.is_linked:\n            layout.template_component_menu(self, ""default_value"", name=text)\n        else:\n            super().draw(context, layout, node, text)\n\n\nclass PointSocket(bpy.types.NodeSocket, SocketVector):\n    bl_idname = ""SvRxSocketPoint""\n    bl_label = ""Point Socket""\n\n    default_value = FloatVectorProperty(size=4, update=exec_socket, default=(0, 0, 0, 1))\n\n    def draw(self, context, layout, node, text):\n        if not self.is_linked:\n            layout.template_component_menu(self, ""default_value"", name=text)\n        else:\n            super().draw(context, layout, node, text)\n\n\nclass ColorSocket(bpy.types.NodeSocket, SocketVector):\n    bl_idname = \'SvRxSocketColor\'\n    bl_label = \'Color Socket\'\n\n    default_value = FloatVectorProperty(size=4,\n                                        subtype=\'COLOR\',\n                                        update=exec_socket,\n                                        soft_min=0.0,\n                                        soft_max=1.0)\n\n    def draw(self, context, layout, node, text):\n        if not self.is_linked and not self.is_output:\n            layout.prop(self, \'default_value\')\n        else:\n            super().draw(context, layout, node, text)\n\n\nclass StringSocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = \'SvRxSocketString\'\n    bl_label = \'String Socket\'\n\n    default_value = StringProperty(update=exec_socket)\n    color = (.3, .3, .3, 1.0)\n\n\nclass TopoSocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = ""SvRxSocketTopo""\n    bl_label = ""Topo Socket""\n\n    color = (.1, .1, .1, 1)\n\n\nclass AnySocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = ""SvRxSocketAny""\n    bl_label = ""Any Socket""\n\n    color = (.9, .9, .9, 1.0)\n\n\nclass MeshSocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = ""SvRxSocketMesh""\n    bl_label = ""Any Socket""\n\n    color = (.1, .1, .1, 1.0)\n\n\nclass ObjectSocket(bpy.types.NodeSocket, SocketBase):\n    bl_idname = \'SvRxSocketObject\'\n    bl_label = \'Blender Objects\'\n\n    color = (.2, .2, .2, 1.0)\n\n    default_value = StringProperty(update=exec_socket)\n\n    def draw(self, context, layout, node, text):\n        if not self.is_linked:\n            layout.prop_search(self, \'default_value\', bpy.data, \'objects\')\n        else:\n            super().draw(context, layout, node, text)\n\n\nclass ValueSocket:\n    def draw(self, context, layout, node, text):\n        if self.is_output:\n            layout.prop(self, ""default_value"", text=text)\n        else:\n            pass\n\n\nclass ValueIntSocket(bpy.types.NodeSocket, ValueSocket, SocketNumber):\n    bl_idname = ""SvRxSocketValueInt""\n    bl_label = ""Value Int Socket""\n\n    default_value = IntProperty(update=exec_socket)\n\n\nclass ValueFloatSocket(bpy.types.NodeSocket, ValueSocket, SocketNumber):\n    bl_idname = ""SvRxSocketValueFloat""\n    bl_label = ""Value Float Socket""\n\n    default_value = FloatProperty(update=exec_socket)\n\n\nclass ValuePointSocket(bpy.types.NodeSocket, ValueSocket, SocketVector):\n    bl_idname = ""SvRxSocketValuePoint""\n    bl_label = ""Value Point Socket""\n\n    default_value = FloatVectorProperty(size=4, update=exec_socket)\n\n    def draw(self, context, layout, node, text):\n        if self.is_output:\n            column = layout.column(align=True)\n            for i in range(4):\n                row = column.row(align=True)\n                row.prop(self, ""default_value"", index=i, text=\'XYZW\'[i])\n\n\nclass ValueColorSocket(bpy.types.NodeSocket, ValueSocket, SocketVector):\n    bl_idname = ""SvRxSocketValueColor""\n    bl_label = ""Value Color Socket""\n\n    default_value = FloatVectorProperty(size=4,\n                                        subtype=\'COLOR\',\n                                        update=exec_socket,\n                                        soft_min=0.0,\n                                        soft_max=1.0)\n\n\nclass ValueObjectSocket(bpy.types.NodeSocket, ValueSocket, SocketBase):\n    bl_idname = ""SvRxSocketValueObject""\n    bl_label = ""Value Object Socket""\n\n    default_value = StringProperty(update=exec_socket)\n    color = (.2, .2, .2, 1.0)\n\n    def draw(self, context, layout, node, text):\n        if self.is_output:\n            layout.prop_search(self, \'default_value\', bpy.data, \'objects\', text=text)\n        else:\n            pass\n'"
core/timings.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport collections\nfrom itertools import chain\nimport time\n\nimport io\n\nimport bpy\nimport bgl\n\nfrom svrx.util import bgl_callback\n\n\ntimings = []\n\ndef get_time():\n    return time.perf_counter()\n\ndef add_time(name):\n    if timings is not None:\n        timings.append((name, get_time()))\n\ndef start_timing():\n    if timings is not None:\n        timings.clear()\n\ndef time_func(func):\n    def inner(*args):\n        add_time(func.label)\n        res = func(*args)\n        add_time(func.label)\n        return res\n    return inner\n\ndef show_timings(ng):\n    if ng.do_timings_text:\n        show_timings_text(ng)\n\n    if ng.do_timings_graphics:\n        show_timings_graphics(ng)\n\n\ndef show_timings_graphics(ng):\n    bgl_callback.callback_disable(""timings:"" + ng.name)\n    t_iter = iter(timings)\n    ng_name, base_time = next(t_iter)\n    _, dag_start = next(t_iter)\n    _, dag_stop = next(t_iter)\n    name, t = next(t_iter)\n    nodes = []\n    res = collections.defaultdict(list)\n    current_node = \'\'\n    while name != ng_name:\n        if name.startswith(""SvRx"") and current_node != name:\n            current_node = name\n            node_start = t\n        elif name == current_node:\n            current_node = \'\'\n            nodes.append((name, node_start, t))\n        else:\n            res[current_node].append((name, t))\n        name, t = next(t_iter)\n    stop_time = t\n\n    node_boxes = []\n    func_boxes = []\n    for node, start, stop in nodes:\n        y = len(res[node]) * 5\n        x = (stop - start) * 10000\n        node_boxes.append((node, x, y, (start - base_time) * 10000))\n        func_data = res[node]\n        for i in range(0, len(func_data), 2):\n            func, start = func_data[i]\n            _, stop = func_data[i + 1]\n            y_f = 6\n            x_f = (stop - start) * 10000\n            func_boxes.append((func, x_f, y_f, (start - base_time) * 10000))\n\n    base_point = (max(n.location.x for n in ng.nodes) + 200, max(n.location.y for n in ng.nodes))\n    draw_data = {\n        \'tree_name\': ng.name,\n        \'custom_function\': water_fall,\n        \'loc\': base_point,\n        \'args\': (node_boxes, func_boxes)\n\n    }\n    bgl_callback.callback_enable(""timings:"" + ng.name, draw_data)\n\n\ndef water_fall(x, y, args):\n\n    if len(args) == 2:\n        node_boxes, func_boxes = args\n    else:\n        return\n\n    def draw_rect(x=0, y=0, w=30, h=10):\n\n        bgl.glBegin(bgl.GL_TRIANGLE_STRIP)\n\n        bgl.glVertex2f(x, y)\n        bgl.glVertex2f(x + w, y)\n        bgl.glVertex2f(x, y-h)\n        bgl.glVertex2f(w+x, y-h)\n        bgl.glEnd()\n\n    node, n_x, n_y, x_offset = node_boxes[-1]\n    x_max = n_x + x_offset\n    y_offset = 0\n    for node, n_x, n_y, x_offset in node_boxes:\n        y_offset -= n_y\n    y_max = -y_offset\n    bgl.glColor4f(0.7, .7, .7, 1.0)\n\n    draw_rect(x, y, x_max , y_max)\n\n    y_offset = 0\n    bgl.glColor4f(0.1, .7, .3, 1.0)\n\n    for node, n_x, n_y, x_offset in node_boxes:\n        draw_rect(x + x_offset, y + y_offset,  max(n_x, 1.0), n_y)\n        y_offset -= n_y\n    y_offset = 0\n    bgl.glColor4f(0.9, .1, .1, 1.0)\n    for node, n_x, n_y, x_offset in func_boxes:\n        draw_rect(x + x_offset, y + y_offset - 2, max(n_x, 1.0), n_y)\n        y_offset -= (n_y + 4)\n\n\ndef show_timings_text(ng):\n    text = bpy.data.texts.get(""SVRX_Timings_{}"".format(ng.name))\n    if not text:\n        text = bpy.data.texts.new(""SVRX_Timings_{}"".format(ng.name))\n\n    t_iter = iter(timings)\n    output = io.StringIO()\n    ng_name, ng_start = next(t_iter)\n    _, start = next(t_iter)\n    _, stop = next(t_iter)\n\n    res = collections.defaultdict(list)\n    nodes = []\n    while t_iter:\n        name, t = next(t_iter)\n        if name.startswith(""SvRx""):\n            nodes.append(name)\n        if name == ng_name:\n            ng_stop = t\n            break\n        res[name].append(t)\n\n    total = ng_stop - ng_start\n    print(""Total exec time: "", ng_name, ""{0:.6f}"".format(ng_stop-ng_start), file=output)\n    print(""DAG build time: "",  ""{0:.6f}"".format(stop - start), \'{:.1%}\'.format((stop-start)/total), file=output)\n    sum_node_calls = 0.0\n    print(""Nodes:"", file=output)\n    for key in nodes[::2]:\n        ts = res[key]\n        if key.startswith(""SvRx""):\n            t = sum(ts[1::2]) - sum(ts[0::2])\n            sum_node_calls +=  t\n            names = [(key, 40), (""{0:.6f}"".format(t),12), (\'{:.1%}\'.format(t/total), 12 )]\n            for n, c in names:\n                f = ""{0: <{1}}""\n                output.write(f.format(n, c))\n            print(\'\',file=output)\n    print(""Node call time total: "", ""{0:.6f}"".format(sum_node_calls), \'{:.1%}\'.format(sum_node_calls/total), file=output)\n    sum_func_calls = 0.0\n    print(""Functions:"", file=output)\n    for key, ts in sorted(res.items(), key=lambda x: x[0]):\n        if not key.startswith(""SvRx""):\n            t = sum(ts[1::2]) - sum(ts[0::2])\n            sum_func_calls += t\n            names = [(key, 30), (len(ts)//2, 10), ( ""{0:.6f}"".format(t), 12), (\'{:.1%}\'.format(t/total), 12 )]\n            for n, c in names:\n                f = ""{0: <{1}}""\n                output.write(f.format(n, c))\n            print(\'\',file=output)\n\n    print(""Functon call total time"",  ""{0:.6f}"".format(sum_func_calls), \'{:.1%}\'.format(sum_func_calls/total), file=output)\n    text.from_string(output.getvalue())\n'"
core/tree.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport time\nimport cProfile\nimport pstats\nimport io\n\nimport bpy\nfrom bpy.props import BoolProperty\n\nfrom svrx.core.execution import exec_node_group, DAG\nfrom svrx.util import bgl_callback\n\n\ndef svrx_trees():\n    for ng in bpy.data.node_groups:\n        if ng.bl_idname == \'SvRxTree\':\n            yield ng\n\nclass SverchokReduxTree(bpy.types.NodeTree):\n    """"""\n    Sverchok Redux visual programming language\n    """"""\n    bl_idname = \'SvRxTree\'\n    bl_label = \'SverchokRedux Node Tree\'\n    bl_icon = \'NODE\'\n\n    def turn_graphics_off(self, context):\n        bgl_callback.callback_disable(""timings:"" + self.name)\n\n    has_changed = BoolProperty(default=False)\n    do_timings_text = BoolProperty(default=False)\n    do_timings_graphics = BoolProperty(default=False, update=turn_graphics_off)\n\n    rx_animate = BoolProperty(default=True,\n                              name=""Animate"",\n                              description=""Execute layout upon frame change"")\n\n    rx_real_nodes = BoolProperty(default=False,\n                                 name=""Explict conversion"",\n                                 description=""Create type conversion nodes"")\n\n    def update(self):\n        self.has_changed = True\n\n    def execute(self):\n        self.has_changed = False\n        exec_node_group(self)\n        self.has_changed = False\n\n    def execute_animate(self):\n        exec_node_group(self)\n\n    def update_list(self):\n        return DAG(self)\n\n    def profile_execute(self, pstat_file=None):\n        pr = cProfile.Profile()\n        pr.enable()\n        exec_node_group(self)\n        pr.disable()\n\n        if pstat_file is not None:\n            pr.dump_stats(pstat_file)\n\n        s = io.StringIO()\n        sortby = \'cumulative\'\n\n        ps = pstats.Stats(pr, stream=s)\n        ps.strip_dirs()\n        ps.sort_stats(sortby)\n        ps.print_stats()\n\n        text_name = self.name + "" Profile""\n        if text_name in bpy.data.texts:\n            text = bpy.data.texts[text_name]\n        else:\n            text = bpy.data.texts.new(text_name)\n        text.from_string(s.getvalue())\n'"
core/type_conversion.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nfrom svrx.typing import Matrix, Number, Number4f, _lookup\n\nconverion_table = {}\n\ndef needs_conversion(from_type, to_type):\n    if from_type == to_type:\n        return False\n    return (_lookup[from_type], _lookup[to_type]) in converion_table\n\ndef get_conversion(from_type, to_type):\n    return converion_table[(_lookup[from_type], _lookup[to_type])]\n\n\n\ndef register():\n    """"""\n    done at register time to be able to use loaded nodes\n\n    also this should be more clever and use the type hierarchy which\n    should also be reworked\n    """"""\n    from svrx.nodes.matrix.create import create_matrix\n    from svrx.nodes.vertex.vector_in import vector_in\n    converion_table[(Number4f, Matrix)] = (create_matrix, (0,), 0)\n    converion_table[(Number, Number4f)] = (vector_in, (0, 1, 2), 0)\n'"
nodes/__init__.py,0,b''
nodes/classes.py,0,"b'import os\nimport time\nimport bpy\nfrom bpy.props import EnumProperty, StringProperty, BoolProperty\n\n\nimport importlib\nfrom svrx.util.importers import get_sn_template_path, text_remap\nfrom svrx.ui import error\n\n_node_funcs = {}\n\n\nclass NodeBase:\n\n    @staticmethod\n    def add_func(func):\n        _node_funcs[func.bl_idname] = func\n\n    @staticmethod\n    def get_func(bl_idname):\n        return _node_funcs.get(bl_idname)\n\n    @classmethod\n    def poll(cls, ntree):\n        return ntree.bl_idname in {\'SvRxTree\'}\n\n    def init(self, context):\n        self.adjust_sockets()\n\n    def compile(self):\n        return _node_funcs[self.bl_idname]\n\n    def draw_buttons(self, context, layout):\n        props = self.compile().properties\n\n        for name in props.keys():\n            layout.prop(self, name)\n\n    def adjust_sockets(self):\n        func = self.compile()\n        if func is None:\n            return\n        self.adjust_inputs(func.inputs_template)\n        self.adjust_outputs(func.outputs_template)\n\n    def adjust_inputs(self, template):\n        inputs_template = template\n        for socket, socket_data in zip(self.inputs, inputs_template):\n            socket.replace_socket(*socket_data)\n\n        diff = len(self.inputs) - len(inputs_template)\n\n        if diff > 0:\n            for i in range(diff):\n                self.inputs.remove(self.inputs[-1])\n        elif diff < 0:\n            for bl_id, name, settings in inputs_template[diff:]:\n                s = self.inputs.new(bl_id, name)\n                s.setup(settings)\n\n    def adjust_outputs(self, template):\n        outputs_template = template\n\n        for socket, socket_data in zip(self.outputs[:], outputs_template):\n            socket.replace_socket(*socket_data)\n\n        diff = len(self.outputs) - len(outputs_template)\n\n        if diff > 0:\n            for i in range(diff):\n                self.outputs.remove(self.outputs[-1])\n        elif diff < 0:\n            for bl_id, name in outputs_template[diff:]:\n                self.outputs.new(bl_id, name)\n\n    def as_json(self):\n        pass\n\n    def from_json(self, json):\n        pass\n\n\nclass MultiInputNode(NodeBase):\n\n    def compile(self):\n        count = max(len(self.inputs), 2)\n        func = super.compile()\n        func.copy()\n\n    def adjust_sockets(self):\n        func = self.compile()\n        if func is None:\n            return\n\n        print(""adjust_sockets"", self.name, count)\n        self.adjust_inputs(func.inputs_template * count)\n        self.adjust_outputs(func.outputs_template)\n\n    def update(self):\n\n        min_count = max(1, self.min_count)\n\n        if not self.inputs:\n            return\n        if self.inputs[-1].is_linked:\n            length = start + len(self.inputs)\n            name = self.base_name.format(length)\n            node.inputs.new(node.socket_type, name)\n        else:\n            while len(self.inputs) > min_count and not self.inputs[-2].is_linked:\n                self.inputs.remove(self.inputs[-1])\n\nclass NodeID:\n    n_id = StringProperty()\n\n    @property\n    def node_id(self):\n        if not self.n_id:\n            self.n_id = str(hash(self) ^ hash(time.monotonic()))\n        return self.n_id\n\n    def copy(self, node):\n        self.n_id = \'\'\n\n\n_node_classes = {}\n\n\nclass NodeStateful(NodeBase):\n\n    @staticmethod\n    def add_cls(bl_idname, func_cls):\n        _node_classes[bl_idname] = func_cls\n\n    @staticmethod\n    def get_cls(bl_idname):\n        return _node_classes[bl_idname]\n\n    def draw_buttons(self, context, layout):\n        props = self.get_cls(self.bl_idname).properties\n\n        for name in props.keys():\n            layout.prop(self, name)\n\n    def adjust_sockets(self):\n        func = self.get_cls(self.bl_idname)\n        if func is None:\n            return\n        self.adjust_inputs(func.inputs_template)\n        self.adjust_outputs(func.outputs_template)\n\n    def compile(self):\n        return NodeStateful.get_cls(self.bl_idname)(self)\n\n\n_multi_storage = {}\n\n\nclass NodeDynSignature(NodeBase):\n\n    expand_modes = BoolProperty()\n\n    def init(self, context):\n        func_dict, func_list = _multi_storage[self.bl_idname]\n        self.expand_modes = 4 > len(func_list)\n        super().init(context)\n\n    @staticmethod\n    def add_multi(func):\n        if not func.bl_idname in _multi_storage:\n            _multi_storage[func.bl_idname] = ({}, [])\n        func_dict, func_list = _multi_storage[func.bl_idname]\n        func_list.append((func.label, func.label, func.label, func.id))\n        func_dict[func.label] = func\n        NodeDynSignature.last_bl_idname = func.bl_idname\n\n    @staticmethod\n    def get_last():\n        return NodeDynSignature.last_bl_idname\n\n    @staticmethod\n    def get_multi(func):\n        return _multi_storage[func.bl_idname]\n\n    def compile(self):\n        func_dict, _ = _multi_storage[self.bl_idname]\n        return func_dict[self.mode]\n\n    def update_mode(self, context):\n        self.adjust_sockets()\n        self.id_data.update()\n\n    def draw_buttons(self, context, layout):\n        layout.prop(self, \'mode\', expand=self.expand_modes)\n        super().draw_buttons(context, layout)\n\n\n\nsocket_types = [\n    (\'default\', \'default\', \'default\', 0),\n    (\'SvRxFloatSocket\', \'Float\', \'Float\', 1),\n    (\'SvRxIntSocket\', \'Int\', \'Int\', 2),\n\n]\n\n\nclass NodeMathBase(NodeDynSignature):\n\n    first_input = EnumProperty(items=socket_types,\n                               default=""default"",\n                               update=NodeDynSignature.update_mode)\n\n    second_input = EnumProperty(items=socket_types,\n                                default=""default"",\n                                update=NodeDynSignature.update_mode)\n\n    def draw_label(self):\n        """"""\n        draws label for mutli mode nodes like math, logic and trigonometey\n        """"""\n        if not self.hide:\n            return self.label or self.name\n\n        name_or_value = [self.mode.title()]\n        for socket in self.inputs:\n            if socket.is_linked:\n                name_or_value.append(socket.name.title())\n            else:\n                name_or_value.append(str(socket.default_value))\n        return \' \'.join(name_or_value)\n\n    def draw_buttons_ext(self, context, layout):\n        super().draw_buttons(context, layout)\n        if self.inputs:\n            layout.prop(self, ""first_input"", text=""First input"")\n        if len(self.inputs) > 1:\n            layout.prop(self, ""second_input"", text=""Second input"")\n\n\n\n    def adjust_sockets(self):\n        """"""Allow overrideing input types\n        """"""\n        func = self.compile()\n        inputs_template = func.inputs_template.copy()\n\n        if self.first_input != \'default\' and inputs_template:\n            inputs_template[0] = (self.first_input,) + inputs_template[0][1:]\n        if self.second_input != \'default\' and len(inputs_template) > 1:\n            inputs_template[1] = (self.second_input,) + inputs_template[1][1:]\n\n        self.adjust_inputs(inputs_template)\n        self.adjust_outputs(func.outputs_template)\n\n\n_node_scripts = {}\n\n# This should be more generic and custom\n\nFAIL_COLOR = (0.8, 0.1, 0.1)\nREADY_COLOR = (0, 0.8, 0.95)\nsnrx_template_path = get_sn_template_path()\n\nclass SvRxScriptNodePyMenu(bpy.types.Menu):\n    bl_label = ""svrx sn templates""\n    bl_idname = ""SvRxScriptNodePyMenu""\n\n    def draw(self, context):\n        if context.active_node:\n            node = context.active_node\n            if node.selected_mode == \'To TextBlok\':\n                self.path_menu([snrx_template_path], ""text.open"", {""internal"": True})\n            else:\n                self.path_menu([snrx_template_path], ""node.svrxscript_import"")\n\nclass SvRxScriptNodeTextImport(bpy.types.Operator):\n    bl_idname = ""node.svrxscript_import""\n    bl_label = ""SNRX load""\n    filepath = bpy.props.StringProperty()\n\n    def execute(self, context):\n        txt = bpy.data.texts.load(self.filepath)\n        context.node.text_file = os.path.basename(txt.name)  # strip .py ?\n        # context.node.text_load()\n        return {\'FINISHED\'}\n\n\nclass NodeScript(NodeBase):\n    bl_idname = ""SvRxNodeScript""\n    bl_label = ""Script""\n\n    mode_options = [(m, m, \'\', idx) for idx, m in enumerate([""To TextBlok"", ""To Node""])]\n\n    selected_mode = bpy.props.EnumProperty(\n        items=mode_options,\n        description=""load the template directly to the node or add to textblocks"",\n        default=""To Node"")\n\n    def init(self, context):\n        super().init(context)\n\n\n    def load_text(self, context=None):\n        if self.text_file in bpy.data.texts:\n            if self.text_file == \'Text\':\n                self.text_file = \'\'\n                return\n            text = text_remap(self.text_file)\n            try:\n                mod = importlib.import_module(""svrx.nodes.script.{}"".format(text))\n                importlib.reload(mod)\n            except Exception as err:\n                error.show(self, err, script=True)\n            else:\n                self.adjust_sockets()\n                self.color = READY_COLOR\n                self.use_custom_color = True\n        else:\n            pass #  fail\n\n    text_file = StringProperty(update=load_text)\n\n\n    def draw_label(self):\n        if self.text_file:\n            return ""Script: {}"".format(self.text_file)\n        else:\n            return ""Script""\n\n    def compile(self):\n        module = text_remap(self.text_file)\n        return _node_scripts.get(module)\n\n    @staticmethod\n    def add(func):\n        _node_scripts[func.module] = func\n\n\n    def reset(self):\n        self.text_file = \'\'\n        self.inputs.clear()\n        self.outputs.clear()\n\n    def draw_buttons(self, context, layout):\n        if not self.text_file:\n            layout.prop_search(self, \'text_file\', bpy.data, \'texts\')\n        else:\n            row = layout.row()\n            row.operator(""node.svrxscript_ui_callback"", text=\'Reset\').fn_name = \'reset\'\n            row.operator(""node.svrxscript_ui_callback"", text=\'Reload\').fn_name = \'load_text\'\n\n    def draw_buttons_ext(self, context, layout):\n        row = layout.row()\n        row.prop(self, \'selected_mode\', expand=True)\n        col = layout.column()\n        col.menu(SvRxScriptNodePyMenu.bl_idname)\n        self.draw_buttons(context, layout)\n\n\nclass SvRxScriptNodeCallBack(bpy.types.Operator):\n\n    bl_idname = ""node.svrxscript_ui_callback""\n    bl_label = ""SvRx Script callback""\n    fn_name = bpy.props.StringProperty(default=\'\')\n\n    def execute(self, context):\n        getattr(context.node, self.fn_name)()\n        return {\'FINISHED\'}\n\n\nclass RealNodeScript(NodeScript, bpy.types.Node):\n    pass\n\ndef register():\n\n    for func in _node_funcs.values():\n        bpy.utils.register_class(func.cls)\n    for cls in _node_classes.values():\n        bpy.utils.register_class(cls.node_cls)\n\n\ndef unregister():\n\n    for func in _node_funcs.values():\n        bpy.utils.unregister_class(func.cls)\n\n    for cls in _node_classes.values():\n        bpy.utils.unregister_class(cls.node_cls)\n\n    _multi_storage.clear()\n    _node_funcs.clear()\n    _node_classes.clear()\n    _node_scripts.clear()\n'"
nodes/node_base.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\nimport bpy\nfrom bpy.props import EnumProperty, StringProperty\n\nimport inspect\n\nimport svrx\n\nfrom svrx.typing import SvRxBaseType, SvRxBaseTypeP, Required\nfrom svrx.nodes.classes import (NodeBase,\n                                NodeDynSignature,\n                                NodeStateful,\n                                NodeScript)\n\n\n\n\ndef make_valid_identifier(name):\n    """"""Create a valid python identifier from name for use a a part of class name""""""\n    if not name[0].isalpha():\n        name = ""Sv"" + name\n    return """".join(ch for ch in name if ch.isalnum() or ch == ""_"")\n\n\ndef class_factory(func):\n    """"""create a node class based on a function that has been preprocessed\n    with get signature or from @stateful""""""\n\n    if hasattr(func, ""cls_bases""):\n        bases = func.cls_bases + (bpy.types.Node,)\n    else:\n        bases = (NodeBase, bpy.types.Node)\n\n    cls_dict = {}\n    cls_name = func.bl_idname\n    cls_dict[\'bl_idname\'] = func.bl_idname\n    cls_dict[\'bl_label\'] = func.label\n\n    for name, prop in func.properties.items():\n        #print(name, prop)\n        cls_dict[name] = prop\n\n    if hasattr(func, \'id\'):\n        func_dict, func_list = NodeDynSignature.get_multi(func)\n        default = func_list[0][0]\n        cls_dict[\'mode\'] = EnumProperty(items=func_list,\n                                        default=default,\n                                        update=NodeDynSignature.update_mode)\n        cls_dict[\'bl_label\'] = func.multi_label\n\n    for name in {""draw_buttons"", ""draw_buttons_ext"", ""update"", ""draw_label""}:\n        attr = getattr(func, name, None)\n        if callable(attr):\n            cls_dict[name] = attr\n\n    cls = type(cls_name, bases, cls_dict)\n    func.cls = cls\n\n\ndef get_signature(func):\n    """"""\n    annotate the function with meta data from the signature\n    """"""\n    sig = inspect.signature(func)\n\n    # for input socket creation (bl_idname: str, name: str, settings: dict)\n    func.inputs_template = []\n    # for output socket creation (bl_idname: str, name: str)\n    func.outputs_template = []\n    # needed properties from function signature dict name: BlenderProperty\n    func.properties = {}\n    # how to access parameters of the function (int|str, level, type)\n    # int means it is a socket accesed by index, str means name of property in node\n    func.parameters = []\n    # (type, level) of return parameters of node\n    func.returns = []\n\n\n    if not hasattr(func, ""label""):\n        func.label = func.__name__.replace(""_"",\' \').strip().title()\n\n    for name, parameter in sig.parameters.items():\n        annotation = parameter.annotation\n\n        level = 0\n\n        if isinstance(annotation, list):\n            annotation, level = parse_type(annotation)\n        if isinstance(annotation, type):\n            annotation = annotation()\n\n        if isinstance(annotation, SvRxBaseType):  # Socket type parameter\n            if parameter.default is None:\n                socket_settings = None\n            elif isinstance(parameter.default, type) and issubclass(parameter.default, Required):\n                socket_settings = {\'required\': True}\n            else:\n                socket_settings = {\'default_value\': parameter.default}\n                socket_settings.update(annotation.get_settings())\n\n\n            if annotation.name is not None:\n                socket_name = annotation.name\n            else:\n                socket_name = name\n\n            socket_name = name.replace(\'_\', \' \').title()\n            func.inputs_template.append((annotation.bl_idname, socket_name, socket_settings))\n            func.parameters.append((len(func.inputs_template) - 1, level, type(annotation)))\n\n        elif isinstance(annotation, SvRxBaseTypeP):\n            if not (parameter.default == inspect.Signature.empty or parameter.default is None):\n                annotation.add(""default"", parameter.default)\n            func.properties[name] = annotation.get_prop()\n            func.parameters.append((name, 0, None))\n        else:\n            raise SyntaxError\n\n    if sig.return_annotation is inspect.Signature.empty:\n        return\n    elif isinstance(sig.return_annotation, tuple):\n        return_annotation = sig.return_annotation\n    else:\n        return_annotation = (sig.return_annotation, )\n\n    for s_type in return_annotation:\n        s_type, level = parse_type(s_type)\n        if isinstance(s_type, type):\n            s_type = s_type()\n        socket_type = s_type.bl_idname\n        if s_type.name:\n            name = s_type.name\n        else:\n            name = s_type.default_name\n\n        func.outputs_template.append((socket_type, name))\n        func.returns.append((type(s_type), level))\n\n\ndef parse_type(s_type, level=0):\n    """"""parse type into level\n    retrun type, level\n    """"""\n    if isinstance(s_type, list):\n        s_type, level = parse_type(s_type[0], level)\n        return s_type, level + 1\n    else:\n        return s_type, 0\n\n\nclass Stateful:\n    cls_bases = (NodeStateful,)\n\n    def start(self):\n        pass\n\n    def stop(self):\n        pass\n\n\ndef stateful(cls):\n    """"""\n    class decorator for creating stateful class\n    """"""\n    func = cls()\n    get_signature(func)\n    module_name = func.__module__.split(""."")[-2]\n    props = {}\n    for name, prop in getattr(cls, \'properties\', {}).items():\n        if isinstance(prop, SvRxBaseTypeP):\n            props[name] = prop.get_prop()\n        else:\n            props[name] = prop\n\n    props.update(func.properties)\n\n    class InnerStateful(cls, Stateful):\n        category = module_name\n        inputs_template = func.inputs_template.copy()\n        outputs_template = func.outputs_template.copy()\n        properties = props.copy()\n        parameters = func.parameters.copy()\n        returns = func.returns.copy()\n\n    func_new = InnerStateful()\n    class_factory(func_new)\n    InnerStateful.node_cls = func_new.cls\n\n    NodeStateful.add_cls(cls.bl_idname, InnerStateful)\n    return InnerStateful\n\n\n\ndef node_func(**values):\n    """"""\n    annotates and registers a node function, also creates classes\n    if needed\n    """"""\n    def real_node_func(func):\n        def annotate(func):\n            for key, value in values.items():\n                setattr(func, key, value)\n        annotate(func)\n        get_signature(func)\n\n        if hasattr(func, \'id\'):\n            # has Dynamic Signature\n            if not hasattr(func, \'bl_idname\'):\n                func.bl_idname = NodeDynSignature.get_last()\n            NodeDynSignature.add_multi(func)\n            func_ref = NodeBase.get_func(func.bl_idname)\n            if func_ref:\n                func.categoy = \'SKIP\'\n                return func\n            elif not hasattr(func, ""cls_bases""):\n                func.cls_bases = (NodeDynSignature,)\n\n        class_factory(func)\n        NodeBase.add_func(func)\n        module_name = func.__module__.split(""."")[-2]\n        if module_name == \'script\':\n            func.category = \'User\'\n            try:\n                bpy.utils.unregister_class(func.cls)\n            except:\n                print(""unregister failed"")\n            try:\n                bpy.utils.register_class(func.cls)\n            except:\n                print(""register failed"", func.label)\n            import svrx.ui.menu\n            svrx.ui.menu.reload_menu()\n        else:\n            func.category = module_name\n        return func\n    return real_node_func\n\n\ndef node_script(func):\n    """"""\n    limited in scope allowing quick scripts with custom properties/class\n    """"""\n    module = func.__module__.split(""."")[-1]\n    func.bl_idname = ""SvRxNodeScript""\n    func.category = ""Script""\n    func.module = module\n    get_signature(func)\n    NodeScript.add(func)\n    return func\n'"
ui/__init__.py,0,b''
ui/error.py,0,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK\n\nimport svrx.util.bgl_callback as bgl_callback\nimport bgl\nimport blf\nimport traceback\nimport bpy\nimport sys\n\n\ndef draw_rect(x=0, y=0, w=30, h=10):\n\n    bgl.glBegin(bgl.GL_TRIANGLE_STRIP)\n\n    bgl.glVertex2f(x, y)\n    bgl.glVertex2f(x + w, y)\n    bgl.glVertex2f(x, y-h)\n    bgl.glVertex2f(w+x, y-h)\n    bgl.glEnd()\n\n\ndef draw_frame(x, y, w, h, t):\n    coord = [(x, y), (x - t, y + t), (x + w, y), (x + w + t, y + t),\n             (x + w, y - h), (x + w + t, y - t - h), (x, y - h), (x - t, y - h - t)]\n    bgl.glColor3f(1, 0, 0)\n\n    bgl.glBegin(bgl.GL_TRIANGLE_STRIP)\n    for i in range(10):\n        bgl.glVertex2f(*coord[i % 8])\n    bgl.glEnd()\n\n\ndef draw_text(x, y, args):\n    lines = args[0]\n    w, h = args[1]\n    max_len = args[2]\n    #  disable reed frame for now\n    #  draw_frame(x - 5, y + 5, w + 10, h + 40, 10)\n    x, y = int(x), int(y)\n    color = (0.9, 0.9, 0.9)\n    font_id = 0\n\n    text_height = 15\n    line_height = 14\n\n    # why does the text look so jagged?  <-- still valid question\n    # dpi = bpy.context.user_preferences.system.dpi\n    blf.size(font_id, int(text_height), 72)\n    bgl.glColor3f(*color)\n    ypos = y\n    xpos = x + w + 30\n    h = 1.3 * line_height * (len(lines) + 1)\n    bgl.glColor3f(0.2,  0.2, 0.2)\n    draw_rect(xpos, ypos + 1.5 * line_height, max_len * 8, h)\n    bgl.glColor3f(*color)\n    for line in lines:\n        blf.position(0, xpos, ypos, 0)\n        blf.draw(font_id, line)\n        ypos -= int(line_height * 1.3)\n\n\ndef show(node, err, script=False):\n    if node.bl_idname == ""SvRxVirtualNode"":\n        return  # for now\n    ng_name = node.id_data.name\n    bgl_callback.callback_disable(""error:"" + ng_name)\n\n    text = bpy.data.texts.get(ng_name + ""_Error"")\n    if not text:\n        text = bpy.data.texts.new(ng_name + ""_Error"")\n    text.clear()\n    msg = traceback.format_exc()\n    print(msg, file=sys.stderr)\n    text.from_string(msg)\n\n    frames = traceback.extract_tb(err.__traceback__)\n    if isinstance(err, SyntaxError):\n        lines = [""SyntaxError""]\n        lines.append(""@ -> {}"".format(err.text))\n        lines.append(""{}:{}"".format(err.filename, err.lineno))\n    else:\n        lines = [str(type(err).__name__) + "" "" + str(err)]\n\n        for info in reversed(frames):\n            print(info)\n            file = info[0].lower()\n\n            if not script:\n                loc = file.find(""svrx"")\n                if loc == -1:\n                    loc = file.find(""bpy.data"")\n            else:\n                loc = file.find(""bpy.data"")\n                print(loc, file, *info)\n\n            if loc > -1:\n                lines.append(""@ -> {}"".format(info[3]))\n                lines.append(""{}:{} in {}"".format(file[loc:], *info[1:3]))\n                break\n\n    x = node.location.x\n    y = node.location.y\n    max_len = max(map(len, lines))\n    draw_data = {\n        \'tree_name\': ng_name,\n        \'custom_function\': draw_text,\n        \'loc\': (x, y),\n        \'args\': (lines, (node.width, node.height), max_len)\n    }\n\n    bgl_callback.callback_enable(""error:"" + node.id_data.name, draw_data)\n\n\ndef clear(ng):\n    bgl_callback.callback_disable(""error:"" + ng.name)\n'"
ui/menu.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport bpy\nimport svrx.nodes.classes\n\nfrom collections import OrderedDict, defaultdict\n\nfrom nodeitems_utils import NodeCategory, NodeItem\nimport nodeitems_utils\n\n\nclass SvRxNodeCategory(NodeCategory):\n\n    @classmethod\n    def poll(cls, context):\n        return context.space_data.tree_type == \'SvRxTree\'\n\n\ndef make_node_cats():\n\n    node_cats = OrderedDict()\n    node_funcs = svrx.nodes.classes._node_funcs\n    node_classes = svrx.nodes.classes._node_classes\n    cats = set(func.category for func in node_funcs.values())\n    cats = cats.union(cls.category for cls in node_classes.values())\n\n    for cat in sorted(cats):\n        nodes = [func.cls for func in node_funcs.values() if func.category == cat]\n        nodes += [cls.node_cls for cls in node_classes.values() if cls.category == cat]\n        node_cat = sorted([(node.bl_idname, node.bl_label) for node in nodes],\n                          key=lambda x: x[1])\n\n        node_cats[cat.title()] = node_cat\n\n    return node_cats\n\n\ndef make_categories():\n    node_cats = make_node_cats()\n\n    node_categories = []\n    node_count = 0\n    for category, nodes in node_cats.items():\n        name_big = ""SVRX_"" + category\n        node_categories.append(SvRxNodeCategory(\n            name_big, category,\n            # bl_idname, name\n            items=[NodeItem(*data) for data in nodes]))\n        node_count += len(nodes)\n\n    node_categories.append(SvRxNodeCategory(\'SVRX_Script\',\'Scripts\', items=script_nodes))\n    return node_categories, node_count\n\n\ndef script_nodes(context):\n    """"""\n    Based on the built in node_group_items in the blender distrubution\n    somewhat edited to fit.\n    """"""\n    if context is None:\n        return\n    space = context.space_data\n    if not space:\n        return\n    ntree = space.edit_tree\n    if not ntree:\n        return\n\n    yield NodeItem(""SvRxNodeScript"", ""Script Node"")\n\n    """"""\n    rough sketch\n    for script in scrip_node_source:\n        yeild NodeItem(\'SvRxNodeScript\', script.name, {\'text_file\': script.text_file})\n    """"""\n\n\ndef draw_script(self, layout, context):\n    pass\n\n\ndef reload_menu():\n    menu, node_count = make_categories()\n    if \'SVRX\' in nodeitems_utils._node_categories:\n        nodeitems_utils.unregister_node_categories(""SVRX"")\n    nodeitems_utils.register_node_categories(""SVRX"", menu)\n\n\ndef register():\n    reload_menu()\n\n\ndef unregister():\n    if \'SVRX\' in nodeitems_utils._node_categories:\n        nodeitems_utils.unregister_node_categories(""SVRX"")\n'"
ui/panel.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nimport bpy\nfrom svrx.core.tree import svrx_trees\n\n\nclass SvRxPanelDebug(bpy.types.Panel):\n    bl_idname = ""SvRxPanelDebug""\n    bl_label = ""SvRx Debug""\n    bl_space_type = \'NODE_EDITOR\'\n    bl_region_type = \'UI\'\n    bl_category = \'Sverchok Redux\'\n    use_pin = True\n\n    @classmethod\n    def poll(cls, context):\n        try:\n            return context.space_data.edit_tree.bl_idname == \'SvRxTree\'\n        except:\n            return False\n\n    def draw(self, context):\n        layout = self.layout\n        ng = context.space_data.edit_tree\n        layout.label(""Timings"")\n        layout.prop(ng, ""do_timings_text"")\n        layout.prop(ng, ""do_timings_graphics"")\n        layout.label(""Options"")\n        layout.prop(ng, ""rx_real_nodes"")\n\n\nclass SvRxPanelControl(bpy.types.Panel):\n    bl_idname = ""SvRxPanelControl""\n    bl_label = ""SvRx Control""\n    bl_space_type = \'NODE_EDITOR\'\n    bl_region_type = \'UI\'\n    bl_category = \'Sverchok Redux\'\n    use_pin = True\n\n    @classmethod\n    def poll(cls, context):\n        try:\n            return context.space_data.edit_tree.bl_idname == \'SvRxTree\'\n        except:\n            return False\n\n    def draw(self, context):\n        layout = self.layout\n        current_ng = context.space_data.edit_tree\n        for ng in svrx_trees():\n            row = layout.row()\n            row.label(ng.name)\n            row.prop(ng, ""rx_animate"")\n'"
ui/translations.py,0,"b'# -*- coding: utf-8 -*-\n# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n'"
util/__init__.py,0,b'    \n'
util/bgl_callback.py,0,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport bpy\nimport blf\nimport bgl\n\nfrom bpy.types import SpaceNodeEditor\n\n\ncallback_dict = {}\npoint_dict = {}\n\n\ndef adjust_list(in_list, x, y):\n    return [[old_x + x, old_y + y] for (old_x, old_y) in in_list]\n\n\n## end of util functions\n\n\ndef tag_redraw_all_nodeviews():\n\n    for window in bpy.context.window_manager.windows:\n        for area in window.screen.areas:\n            if area.type == \'NODE_EDITOR\':\n                for region in area.regions:\n                    if region.type == \'WINDOW\':\n                        region.tag_redraw()\n\n\ndef callback_enable(*args):\n    n_id = args[0]\n    global callback_dict\n    if n_id in callback_dict:\n        return\n\n    handle_pixel = SpaceNodeEditor.draw_handler_add(draw_callback_px, args, \'WINDOW\', \'POST_VIEW\')\n    callback_dict[n_id] = handle_pixel\n    tag_redraw_all_nodeviews()\n\n\ndef callback_disable(n_id):\n    global callback_dict\n    handle_pixel = callback_dict.get(n_id, None)\n    if not handle_pixel:\n        return\n    SpaceNodeEditor.draw_handler_remove(handle_pixel, \'WINDOW\')\n    del callback_dict[n_id]\n    tag_redraw_all_nodeviews()\n\n\ndef callback_disable_all():\n    global callback_dict\n    temp_list = list(callback_dict.keys())\n    for n_id in temp_list:\n        if n_id:\n            callback_disable(n_id)\n\n\ndef restore_opengl_defaults():\n    bgl.glLineWidth(1)\n    bgl.glDisable(bgl.GL_BLEND)\n    bgl.glColor4f(0.0, 0.0, 0.0, 1.0)\n\n\ndef draw_callback_px(n_id, data):\n    space = bpy.context.space_data\n\n    ng_view = space.edit_tree\n    if not ng_view:\n        return\n\n    ng_name = space.edit_tree.name\n    if not (data[\'tree_name\'] == ng_name):\n        return\n    if not ng_view.bl_idname == ""SvRxTree"":\n        return\n\n    drawing_func = data.get(\'custom_function\')\n    x, y = data.get(\'loc\', (20, 20))\n    args = data.get(\'args\', (None,))\n    drawing_func(x, y, args)\n    restore_opengl_defaults()\n\n\ndef unregister():\n    callback_disable_all()\n'"
util/bgl_callback_3dview.py,0,"b""# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\nimport bpy\nimport bgl\n\n\nSpaceView3D = bpy.types.SpaceView3D\n\ncallback_dict = {}\n\n\ndef tag_redraw_all_3dviews():\n\n    for window in bpy.context.window_manager.windows:\n        for area in window.screen.areas:\n            if area.type == 'VIEW_3D':\n                for region in area.regions:\n                    if region.type == 'WINDOW':\n                        region.tag_redraw()\n\n\ndef callback_enable(*args, overlay='POST_VIEW'):\n    n_id = args[0]\n    if n_id in callback_dict:\n        return\n\n    handle_pixel = SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', overlay)\n    callback_dict[n_id] = handle_pixel\n    tag_redraw_all_3dviews()\n\n\ndef callback_disable(n_id):\n    handle_pixel = callback_dict.get(n_id, None)\n    if not handle_pixel:\n        return\n    SpaceView3D.draw_handler_remove(handle_pixel, 'WINDOW')\n    del callback_dict[n_id]\n    tag_redraw_all_3dviews()\n\n\ndef callback_disable_all():\n    temp_list = list(callback_dict.keys())\n    for n_id in temp_list:\n        if n_id:\n            callback_disable(n_id)\n\n\ndef restore_opengl_defaults():\n    bgl.glLineWidth(1)\n    bgl.glDisable(bgl.GL_BLEND)\n    bgl.glColor4f(0.0, 0.0, 0.0, 1.0)\n\n\ndef draw_callback_px(n_id, data):\n    context = bpy.context\n    drawing_func = data.get('custom_function')   # must accept 'context' first\n    args = data.get('args', (None,))             # args does not need to be a tuple.\n    drawing_func(context, args)\n    restore_opengl_defaults()\n\n    ###\n    #    in your drawing function you can use the first parameter to get a reference to region/3d\n    #\n    #    region = context.region\n    #    region3d = context.space_data.region_3d\n    ###\n\n\ndef unregister():\n    callback_disable_all()\n"""
util/function.py,6,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n#\n# This file contains helper functions for @node_func functions\n# Mostly dealing with np array shapes and function behaviour\n#\n# The most important one is @geenrator\n\n\nfrom functools import wraps\nimport inspect\nimport itertools\n\nimport numpy as np\n\n\ndef generator(func=None, match=None, limit=None):\n    \'\'\'\n    Will create a yeilding vectorized generator of the\n    function it is applied to.\n    \'\'\'\n    def wrapper(func):\n        sig = inspect.signature(func)\n        func.mask = []\n        for name, parameter in sig.parameters.items():\n            m = getattr(parameter.annotation, ""iterable"", False)\n            func.mask.append(not m)\n\n        @wraps(func)\n        def inner(*args, match=match):\n            if match is None:\n                match = match_long_repeat\n            mask = func.mask\n            if mask is None:\n                parameters = [np.atleast_1d(arg) for arg in args]\n            else:\n                parameters = [arg if m else np.atleast_1d(arg) for arg, m in zip(args, mask)]\n            out = []\n            for param in match(*parameters, limit=limit, mask=mask):\n                out.append(func(*param))\n            return out\n        return inner\n    if func:\n        return wrapper(func)\n    else:\n        return wrapper\n\n\ndef match_long_repeat(*parameters, limit=None, mask=None):\n    if mask is None:\n        counts = [len(p) for p in parameters]\n    else:\n        counts = [1 if m else len(p) for m, p in zip(mask, parameters)]\n    if limit is not None:\n        max_len = counts[limit]\n    else:\n        max_len = max(counts)\n    if mask is None:\n        for i in range(max_len):\n            args = []\n            for c, parameter in zip(counts, parameters):\n                args.append(parameter[min(c - 1, i)])\n            yield args\n    else:\n        for i in range(max_len):\n            args = []\n            for c, m, parameter in zip(counts, mask, parameters):\n                if m:\n                    args.append(parameter)\n                else:\n                    args.append(parameter[min(c - 1, i)])\n            yield args\n\n\ndef match_long_cycle(*parameters, limit=None, mask=None):\n    counts = [len(p) for p in parameters]\n    if limit is not None:\n        max_len = counts[limit]\n    else:\n        max_len = max(counts)\n    args = []\n    for c, p in zip(counts, parameters):\n        if c < max_len:\n            args.append(itertools.cycle(p))\n        else:\n            args.append(p)\n    yield from zip(*args)\n\n\ndef match_short(*parameters, limit=None, mask=None):\n    yield from zip(*parameters)\n\n\ndef constant(func):\n    """"""wrap a function func so it can return a single number/value\n    that is wrapped into an array.\n    """"""\n    @wraps(func)\n    def inner(*args):\n        return np.atleast_1d(func(*args))\n    return inner\n\n\ndef std_wrap(func):\n    """"""wrap a function func so it can return a single number/value\n    that is wrapped into an array.\n    """"""\n    @wraps(func)\n    def inner(*args):\n        return np.atleast_1d(func(*args))\n    return inner\n\n\ndef compat(func):\n    @wraps(func)\n    def inner(a, b):\n        return func(*make_compatible(a, b))\n    return inner\n\n\ndef make_compatible(a, b, broadcast=True):\n    if broadcast and is_broadcastable(a, b):\n        return a, b\n    shape = tuple(max(x, y) for x, y in zip(a.shape, b.shape))\n    return array_as(a, shape), array_as(b, shape)\n\n\ndef array_as(a, shape):\n    if a.shape == shape:\n        return a\n    new_a = np.empty(shape, dtype=a.dtype)\n    new_a[:len(a)] = a\n    new_a[len(a):] = a[-1]\n    return new_a\n\n\ndef array_as_cycle(a, shape):\n    if a.shape == shape:\n        return a\n    new_a = np.empty(shape, dtype=a.dtype)\n    for i in range(shape[0]):\n        new_a[i] = a[i % len(a)]\n    return new_a\n\n\ndef is_broadcastable(a, b):\n    return all((x == 1 or y == 1 or x == y) for x, y in zip(a.shape[::-1], b.shape[::-1]))\n'"
util/geom.py,34,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nimport numpy as np\nfrom functools import wraps\n\nfrom svrx.util.smesh import SvPolygon\nfrom svrx.util.function import match_long_repeat\n\n\ndef vectorize(func):\n    \'\'\'\n    Will create a yeilding vectorized generator of the\n    function it is applied to.\n    all arguments most be of list type\n    \'\'\'\n    @wraps(func)\n    def inner(*args, **kwargs):\n        split = len(args)\n        keys = kwargs.keys()\n        parameters = [p for p in args + tuple(kwargs.values())]\n        for param in match_long_repeat(*parameters):\n            kw_args = {k: v for k, v in zip(keys, param[split:])}\n            yield func(*param[:split], **kw_args)\n    return inner\n\n\ndef circle(radius=1.0, phase=0, nverts=20):\n    t = np.linspace(0, np.pi * 2, nverts, endpoint=False)\n    circ = np.array([np.cos(t + phase) * radius,\n                    np.sin(t + phase) * radius,\n                    np.zeros(nverts),\n                    np.ones(nverts)])\n    verts = np.transpose(circ)\n    edges = np.array([(i, i + 1) for i in range(nverts - 1)] + [(nverts - 1, 0)])\n    faces = SvPolygon(np.array([0], dtype=np.uint32),\n                      np.array([nverts], dtype=np.uint32),\n                      np.arange(0, nverts, dtype=np.uint32))\n    return verts, edges, faces\n\n\ncircles = vectorize(circle)\n\n# ---------- Spline\n\n# spline function modifed from\n# from looptools 4.5.2 done by Bart Crouch\n\n\n# calculates natural cubic splines through all given knots\n\n\nclass CubicSpline:\n    def __init__(self, locs, tknots=None, metric=\'DISTANCE\'):\n        """"""    locs is and np.array with shape (n,3) and tknots has shape (n-1,)\n        creates a cubic spline thorugh the locations given in locs\n\n        """"""\n        n = len(locs)\n        if n < 2:\n            return False\n\n        if tknots is None:\n            tknots = create_knots(locs, metric)\n\n        self.tknots = tknots\n\n        h = tknots[1:] - tknots[:-1]\n        h[h == 0] = 1e-8\n        q = np.zeros((n - 1, 3))\n        q[1:] = 3 / h[1:, np.newaxis] * (locs[2:] - locs[1:-1]) - 3 / \\\n            h[:-1, np.newaxis] * (locs[1:-1] - locs[:-2])\n\n        l = np.zeros((n, 3))\n        l[0, :] = 1.0\n        u = np.zeros((n - 1, 3))\n        z = np.zeros((n, 3))\n\n        for i in range(1, n - 1):\n            l[i] = 2 * (tknots[i + 1] - tknots[i - 1]) - h[i - 1] * u[i - 1]\n            l[i, l[i] == 0] = 1e-8\n            u[i] = h[i] / l[i]\n            z[i] = (q[i] - h[i - 1] * z[i - 1]) / l[i]\n        l[-1, :] = 1.0\n        z[-1] = 0.0\n\n        b = np.zeros((n - 1, 3))\n        c = np.zeros((n, 3))\n\n        for i in range(n - 2, -1, -1):\n            c[i] = z[i] - u[i] * c[i + 1]\n        b = (locs[1:] - locs[:-1]) / h[:, np.newaxis] - h[:, np.newaxis] * (c[1:] + 2 * c[:-1]) / 3\n        d = (c[1:] - c[:-1]) / (3 * h[:, np.newaxis])\n\n        splines = np.zeros((n - 1, 5, 3))\n        splines[:, 0] = locs[:-1]\n        splines[:, 1] = b\n        splines[:, 2] = c[:-1]\n        splines[:, 3] = d\n        splines[:, 4] = tknots[:-1, np.newaxis]\n\n        self.splines = splines\n\n    def eval(self, t_in):\n        """"""\n        Evaluate the spline at the points in t_in, which must be an array\n        with values in [0,1]\n        returns and np array with the corresponding points\n        """"""\n        t_in = t_in.clip(0.0, 1.0)\n        splines = self.splines\n        tknots = self.tknots\n        index = tknots.searchsorted(t_in, side=\'left\') - 1\n        index = index.clip(0, len(splines) - 1)\n        to_calc = splines[index]\n        ax, bx, cx, dx, tx = np.swapaxes(to_calc, 0, 1)\n        t_r = t_in[:, np.newaxis] - tx\n        out = ax + t_r * (bx + t_r * (cx + t_r * dx))\n        return out\n\n\n    def tangent(self, t_in, h=0.001):\n        """"""\n        Calc numerical tangents for spline at t_in\n        """"""\n        t_ph = t_in + h\n        t_mh = t_in - h\n        t_less_than_0 = t_mh < 0.0\n        t_great_than_1 = t_ph > 1.0\n        t_mh[t_less_than_0] += h\n        t_ph[t_great_than_1] -= h\n        tanget_ph = self.eval(t_ph)\n        tanget_mh = self.eval(t_mh)\n        tanget = tanget_ph - tanget_mh\n        tanget[t_less_than_0 | t_great_than_1] *= 2\n        return tanget\n\n\ndef create_knots(pts, metric=""DISTANCE""):\n    if metric == ""DISTANCE"":\n        tmp = np.linalg.norm(pts[:-1] - pts[1:], axis=1)\n        tknots = np.insert(tmp, 0, 0).cumsum()\n        tknots = tknots / tknots[-1]\n    elif metric == ""MANHATTAN"":\n        tmp = np.sum(np.absolute(pts[:-1] - pts[1:]), 1)\n        tknots = np.insert(tmp, 0, 0).cumsum()\n        tknots = tknots / tknots[-1]\n    elif metric == ""POINTS"":\n        tknots = np.linspace(0, 1, len(pts))\n    elif metric == ""CHEBYSHEV"":\n        tknots = np.max(np.absolute(pts[1:] - pts[:-1]), 1)\n        tmp = np.insert(tmp, 0, 0).cumsum()\n        tknots = tknots / tknots[-1]\n\n    return tknots\n\n\nclass LinearSpline:\n    def __init__(self, locs, tknots=None, metric=\'DISTANCE\'):\n        self.pts = locs.T\n        if tknots is None:\n            tknots = create_knots(locs, metric)\n\n        self.tknots = tknots\n\n    def eval(self, t_in):\n        """"""\n        Eval the liner spline f(t) = x,y,z through the points\n        in pts given the knots in tknots at the point in t_in\n        """"""\n        ptsT = self.pts\n        tknots = self.tknots\n        out = np.empty((3, len(t_in)))\n        for i in range(3):\n            out[i] = np.interp(t_in, tknots, ptsT[i])\n        return out.T\n'"
util/importers.py,0,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nimport os\nimport functools\n\ndef mesh_objects_path():\n    return os.path.join(os.path.dirname(__file__), \'mesh_objects\')\n\ndef named_mesh_path(name):\n    return os.path.join(mesh_objects_path(), name)\n\ndef get_sn_template_path():\n    return os.path.join(os.path.dirname(__file__), \'snrx_templates\')\n\n\n\n@functools.lru_cache(maxsize=16)\ndef obj_to_pydata_lite(path):\n    """"""Loads external .obj files in a very simple format. Cached\n    """"""\n    verts, edges, faces = [], [], []\n    add_vert = verts.append\n    add_face = faces.append\n    with open(path) as ofile:\n        for line in ofile:\n            if line.startswith(\'v\'):\n                add_vert([float(i) for i in line[2:].strip().split(\' \')])\n            if line.startswith(\'f\'):\n                add_face([int(i)-1 for i in line[2:].strip().split(\' \')])\n\n    return verts, edges, faces\n\ndef uncached_obj_to_pydata_lite(path):\n    """"""\n    Bypasses the data cache for when are working with and changing the file.\n    """"""\n    return obj_to_pydata_lite.__wrapped__(path)\n\n_text_file_lookup = {}\n\ndef text_remap(text_file, reverse=False):\n    if not reverse:\n        remap_name = make_valid_identifier(text_file)\n        _text_file_lookup[remap_name] = text_file\n        return  remap_name\n    return _text_file_lookup.get(text_file)\n\ndef make_valid_identifier(name):\n    """"""Create a valid python identifier from name for use a a part of class name""""""\n    if not name[0].isalpha():\n        name = ""SvRx"" + name\n    return """".join(ch for ch in name if ch.isalnum() or ch == ""_"")\n'"
util/mesh.py,2,"b""# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n# pylint: disable=W0141\n\nfrom itertools import chain, islice, accumulate\n\nimport numpy as np\n\nimport bmesh\n\nfrom svrx.util.smesh import SvPolygon, SMesh, SvVertices, SvEdges\n\n\ndef bmesh_from_pydata(verts, edges=None, faces=None, normal_update=False):\n    ''' verts is necessary, edges/faces are optional\n        normal_update, will update verts/edges/faces normals at the end\n    '''\n\n    bm = bmesh.new()\n    add_vert = bm.verts.new\n\n    for co in verts:\n        add_vert(co)\n\n    bm.verts.index_update()\n    bm.verts.ensure_lookup_table()\n\n    if not faces is None:\n        add_face = bm.faces.new\n        for face in faces:\n            add_face(tuple(bm.verts[i] for i in face))\n\n        bm.faces.index_update()\n\n    if not edges is None:\n        add_edge = bm.edges.new\n        for edge in edges:\n            edge_seq = tuple(bm.verts[i] for i in edge)\n            try:\n                add_edge(edge_seq)\n            except ValueError:\n                # edge exists!\n                pass\n\n        bm.edges.index_update()\n\n    if normal_update:\n        bm.normal_update()\n    return bm\n\n\ndef rxdata_from_bm(bm):\n    vert_count = len(bm.verts)\n    vertices = np.ones((vert_count, 4), dtype=np.float64)\n    for idx, v in enumerate(bm.verts):\n        vertices[idx,:3] = v.co\n    edges = np.array([(e.verts[0].index, e.verts[1].index) for e in bm.edges], dtype=np.uint32)\n    faces = SvPolygon.from_pydata([[i.index for i in p.verts] for p in bm.faces])\n    return vertices, edges, faces\n\ndef rxdata_from_pydata(verts, edges=None, faces=None):\n    # v = SvVertices.from_pydata(verts)\n    # e = SvEdges.from_pydata(edges)\n    # f = SvPolygon.from_pydata(faces)\n    # return v, e, f\n    return SMesh.from_pydata(verts, edges, faces).as_rxdata\n"""
util/smesh.py,21,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\nfrom itertools import chain, islice, accumulate\n\nimport numpy as np\nfrom mathutils.geometry import normal\n\nclass SMesh:\n    @classmethod\n    def from_mesh(cls, mesh):\n        return cls(SvVertices.from_mesh(mesh),\n                   SvEdges.from_mesh(mesh),\n                   SvPolygon.from_mesh(mesh))\n\n    @classmethod\n    def from_pydata(cls, verts, edges=None, faces=None):\n        empty_edges = []\n        empty_faces = []\n        return cls(SvVertices.from_pydata(verts),\n                   SvEdges.from_pydata(edges or empty_edges),\n                   SvPolygon.from_pydata(faces or empty_faces))\n\n    def __init__(self, vertices, edges, faces):\n        self.vertices = vertices\n        self.edges = edges\n        self.faces = faces\n\n    def calc_normals(self):\n        """"""\n        Face normals\n        """"""\n        normals = np.empty((len(self.faces), 3))\n        for idx, face in enumerate(self.faces):\n            normals[idx] = normal(self.vertices[face])\n        self.faces.normals = normals\n\n    def as_pydata(self):\n        return self.vertices.as_pydata(), self.edges.as_pydata(), self.faces\n\n\n    @property\n    def as_rxdata(self):\n        #  this is sign of broken abstraction, this needs to be given another pass\n        return self.vertices.vertices, self.edges, self.faces\n\n\nclass SvVertices:\n    @classmethod\n    def from_mesh(cls, mesh):\n        vertices = np.empty(len(mesh.vertices) * 3, dtype=np.float32)\n        mesh.vertices.foreach_get(""co"", vertices)\n        vertices.shape = (len(mesh.vertices), 3)\n        real_vertices = np.ones((len(mesh.vertices), 4))\n        real_vertices[:,:3] = vertices\n        return cls(real_vertices)\n\n    @classmethod\n    def from_pydata(cls, vertices):\n        real_vertices = np.ones((len(vertices), 4))\n        real_vertices[:,:3] = vertices\n        return cls(real_vertices)\n\n    def __getitem__(self, key):\n        return self.vertices[key]\n\n    def __init__(self, vertices):\n        self.vertices = vertices\n\n    def as_pydata(self):\n        return self.vertices\n\n\nclass SvEdges:\n    @classmethod\n    def from_mesh(cls, mesh):\n        # should use foreach_get\n        #\n        #   :: like this?\n        #   edges = mesh.edges\n        #   k = np.empty(len(edges) * 2, dtype=np.uint32)\n        #   edges.foreach_get(\'vertices\', k)\n        #   f = k.reshape(-1, 2)             # -1 infers whatever is sane for x in (x, 2)\n        #\n        return cls(np.array(mesh.edge_keys, dtype=np.uint32))\n\n    @classmethod\n    def from_pydata(cls, edges):\n        return cls(np.array(edges, dtype=np.uint32))\n\n    def __init__(self, edges=None):\n        self.edges = edges\n\n    def __getitem__(self, key):\n        return self.edges[key]\n\n    def as_pydata(self):\n        return self.edges\n\nclass SvPolygon:\n    """"""\n    Represent face-data using data structur compatible with blender\n    vertex_indices list of vertex index for all loops\n    loop_start offset of each face in vertex_indices\n    loop_total length of each face in vertex_indices\n\n    Example:\n    - 1 Triangle face:\n    vertex_indices = [0 1 2]\n    loop_start = [0]\n    loop_total = [3]\n\n    - 2 Triangle faces and polygon face\n    [[0, 1, 2], [0, 1, 4 ,3]]\n\n    [0 1 2 0 1 4 3]\n    [0 3]\n    [3 4]\n    """"""\n\n    @classmethod\n    def from_pydata(cls, faces):\n\n        loop_total = np.empty(len(faces), dtype=np.uint32)\n        loop_start = np.zeros(len(faces), dtype=np.uint32)\n        loop_total[:] = tuple(map(len, faces))\n        loop_start[1:] = loop_total[:-1].cumsum()\n        vertex_indices = np.fromiter(chain.from_iterable(faces),\n                                     dtype=np.uint32,)\n                                     #count=loop_start.sum())\n        return cls(loop_start, loop_total, vertex_indices)\n\n\n    def __init__(self, loop_start=None, loop_total=None, vertex_indices=None):\n       self.loop_start = loop_start\n       self.loop_total = loop_total\n       self.vertex_indices = vertex_indices\n\n    @classmethod\n    def from_mesh(cls, mesh):\n        loop_total = np.empty(len(mesh.polygons), dtype=np.uint32)\n        loop_start = np.empty(len(mesh.polygons), dtype=np.uint32)\n        mesh.polygons.foreach_get(""loop_total"", loop_total)\n        mesh.polygons.foreach_get(""loop_start"", loop_start)\n        vertex_indices = np.empty(len(mesh.loops), dtype=np.uint32)\n        mesh.loops.foreach_get(""vertex_index"", vertex_indices)\n        return cls(loop_start, loop_total, vertex_indices)\n\n\n    def __getitem__(self, key):\n        loop_start = self.loop_start[key]\n        loop_stop = loop_start + self.loop_total[key]\n        return self.vertex_indices[loop_start: loop_stop]\n\n    def __len__(self):\n        return len(self.loop_start)\n\n    def as_pydata(self):\n        return [tuple(face) for face in self]\n\n    def __iadd__(self, other):\n        if isinstance(other, SvPolygon):\n            face_count = len(self)\n            offset = len(self.vertex_indices)\n            self.loop_start = np.concatenate((self.loop_start, other.loop_start + face_count))\n            self.loop_total = np.concatenate((self.loop_total, other.loop_total))\n            self.vertex_indices = np.concatenate((self.vertex_indices, other.vertex_indices + offset))\n        else:\n            if isinstance(other, np.ndarray):\n                if len(other.shape) == 1:\n                    self += SvPolygon(np.array([0], dtype=np.uint32),np.array(other.shape, dtype=np.uint32), other)\n                elif len(other.shape) == 2:\n                    #self += SvPolygon\n                    pass\n\n    """"""\n    def join(self, poly):\n        offset = len(poly.vertex_indices)\n        face_count = len(self)\n        self.loop_info = np.concatenate((self.loop_info, poly.loop_info))\n        self.vertex_indices = np.concatenate((self.vertex_indices, poly.vertex_indices + offset))\n        self.loop_info[face_count:,1] += offset\n    """"""\n'"
util/topology.py,36,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\nimport numpy as np\nfrom svrx.util.smesh import SvPolygon\n\n\ndef plane_edges(x, y):\n    edges = np.empty((x * (y - 1) + (x - 1) * y, 2 ), dtype=np.uint32)\n    u_dir = np.arange(0, x - 1) + np.arange(0, x * y, x)[:,np.newaxis]\n    v_dir = np.arange(0, x * (y - 1), x) + np.arange(0, x)[:,np.newaxis]\n    u_dir.shape = -1\n    v_dir.shape = -1\n    split = v_dir.shape[0]\n    edges[split:, 0] = u_dir\n    edges[:split, 0] = v_dir\n    edges[split:, 1] = u_dir + 1\n    edges[:split, 1] = v_dir + x\n    return edges\n\ndef plane_faces(x, y):\n    faces = np.empty(((x - 1) * (y - 1), 4), dtype=np.uint32)\n    faces[:, 3] = (np.arange(y, x * y, y) + np.arange(0 , y - 1)[:,np.newaxis]).flatten()\n    faces[:, 2] = faces[:, 3] + 1\n    faces[:, 0] = (np.arange(0, x * y -y, y) + np.arange(0, y - 1)[:,np.newaxis]).flatten()\n    faces[:, 1] = faces[:, 0] + 1\n    faces.shape = -1\n    l_total = np.empty((x - 1) * (y - 1), dtype=np.uint32)\n    l_total[:] = 4\n    l_start = np.arange(0, (x - 1) * (y - 1) * 4, 4, dtype=np.uint32)\n    return SvPolygon(l_start, l_total, faces)\n\n\ndef cylinder_edges(x, y):\n    edges = np.empty((2*x*y-y, 2), dtype=np.uint32)\n    edges[:x*y, 0] = np.arange(x * y)\n    edges[:x*y, 1] = np.arange(1, x * y + 1)\n    edges[range(y - 1, x * y, y), 1] -= y\n    edges[x * y:, 0] = np.arange(0, x * y - y)\n    edges[x * y:, 1] = np.arange(y, x * y)\n    return edges\n\n\ndef cylinder_faces(x, y, caps=False):\n    if caps:\n        out = np.empty((x * y - y) * 4 + 2 * y, dtype=np.uint32)\n        out[:y] = np.arange(0, y)[::-1]\n        out[y: 2*y] = np.arange(y * (x - 1), y * x)\n        p = out[2 * y:]\n        p.shape = (-1, 4)\n    else:\n        p = np.empty((x*y-y, 4), dtype=np.uint32)\n    skips = range(y - 1, x*y -y, y)\n    p[:, 0] = np.arange(0, x * y - y)\n    p[:, 1] = np.arange(1, x * y - y + 1)\n    p[skips, 1] -= y\n    p[:, 2] = np.arange(y + 1, x * y + 1)\n    p[skips, 2] -= y\n    p[:, 3] = np.arange(y, x * y)\n    if caps:\n        l_total = np.empty(x * y - y + 2, dtype=np.uint32)\n        l_start = np.empty(x * y - y + 2, dtype=np.uint32)\n        l_total[:2] = y\n        l_total[2:] = 4\n        l_start[:1] = 0\n        l_start[1:] = l_total[:-1].cumsum()\n        out.shape = -1\n        return SvPolygon(l_start, l_total, out)\n    else:\n        l_total = np.empty(x * y - y, dtype=np.uint32)\n        l_total[:] = 4\n        l_start = np.arange(0, (x * y - y) * 4, 4, dtype=np.uint32)\n        p.shape = (x * y -y ) * 4\n        return SvPolygon(l_start, l_total, p)\n\n\n\n\n\ndef torus_edges(x, y):\n    edges = np.empty((2*x*y, 2), dtype=np.uint32)\n    edges[:x*y, 0] = np.arange(x * y)\n    edges[:x*y, 1] = np.arange(1, x * y + 1)\n    edges[range(y - 1, x * y, y), 1] -= y\n    edges[x * y:, 0] = np.arange(0, x * y)\n    edges[x * y:, 1] = np.roll(np.arange(0, x * y), -y)\n    return edges\n\ndef torus_faces(x, y):\n    faces = np.empty((x * y, 4), dtype=np.uint32)\n    tmp = np.arange(0, x * y)\n    faces[:, 0] = tmp\n    faces[:, 1] = np.roll(tmp, -y)\n    tmp += 1\n    tmp.shape = (x, y)\n    tmp[:, y - 1] -= y\n    tmp.shape = -1\n    faces[:, 3] = tmp\n    faces[:, 2] = np.roll(tmp, -y)\n    faces.shape = -1\n    l_total = np.empty(x * y, dtype=np.uint32)\n    l_total[:] = 4\n    l_start = np.arange(0, (x * y) * 4, 4, dtype=np.uint32)\n    return SvPolygon(l_start, l_total, faces)\n'"
util/transforms.py,0,"b'# -*- coding: utf-8 -*-\n# transformations.py\n\n# Copyright (c) 2006-2015, Christoph Gohlke\n# Copyright (c) 2006-2015, The Regents of the University of California\n# Produced at the Laboratory for Fluorescence Dynamics\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright\n#   notice, this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright\n#   notice, this list of conditions and the following disclaimer in the\n#   documentation and/or other materials provided with the distribution.\n# * Neither the name of the copyright holders nor the names of any\n#   contributors may be used to endorse or promote products derived\n#   from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n""""""Homogeneous Transformation Matrices and Quaternions.\n\nA library for calculating 4x4 matrices for translating, rotating, reflecting,\nscaling, shearing, projecting, orthogonalizing, and superimposing arrays of\n3D homogeneous coordinates as well as for converting between rotation matrices,\nEuler angles, and quaternions. Also includes an Arcball control object and\nfunctions to decompose transformation matrices.\n\n:Author:\n  `Christoph Gohlke <http://www.lfd.uci.edu/~gohlke/>`_\n\n:Organization:\n  Laboratory for Fluorescence Dynamics, University of California, Irvine\n\n:Version: 2015.07.18\n\nRequirements\n------------\n* `CPython 2.7 or 3.4 <http://www.python.org>`_\n* `Numpy 1.9 <http://www.numpy.org>`_\n* `Transformations.c 2015.07.18 <http://www.lfd.uci.edu/~gohlke/>`_\n  (recommended for speedup of some functions)\n\nNotes\n-----\nThe API is not stable yet and is expected to change between revisions.\n\nThis Python code is not optimized for speed. Refer to the transformations.c\nmodule for a faster implementation of some functions.\n\nDocumentation in HTML format can be generated with epydoc.\n\nMatrices (M) can be inverted using numpy.linalg.inv(M), be concatenated using\nnumpy.dot(M0, M1), or transform homogeneous coordinate arrays (v) using\nnumpy.dot(M, v) for shape (4, \\*) column vectors, respectively\nnumpy.dot(v, M.T) for shape (\\*, 4) row vectors (""array of points"").\n\nThis module follows the ""column vectors on the right"" and ""row major storage""\n(C contiguous) conventions. The translation components are in the right column\nof the transformation matrix, i.e. M[:3, 3].\nThe transpose of the transformation matrices may have to be used to interface\nwith other graphics systems, e.g. with OpenGL\'s glMultMatrixd(). See also [16].\n\nCalculations are carried out with numpy.float64 precision.\n\nVector, point, quaternion, and matrix function arguments are expected to be\n""array like"", i.e. tuple, list, or numpy arrays.\n\nReturn types are numpy arrays unless specified otherwise.\n\nAngles are in radians unless specified otherwise.\n\nQuaternions w+ix+jy+kz are represented as [w, x, y, z].\n\nA triple of Euler angles can be applied/interpreted in 24 ways, which can\nbe specified using a 4 character string or encoded 4-tuple:\n\n  *Axes 4-string*: e.g. \'sxyz\' or \'ryxy\'\n\n  - first character : rotations are applied to \'s\'tatic or \'r\'otating frame\n  - remaining characters : successive rotation axis \'x\', \'y\', or \'z\'\n\n  *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)\n\n  - inner axis: code of axis (\'x\':0, \'y\':1, \'z\':2) of rightmost matrix.\n  - parity : even (0) if inner axis \'x\' is followed by \'y\', \'y\' is followed\n    by \'z\', or \'z\' is followed by \'x\'. Otherwise odd (1).\n  - repetition : first and last axis are same (1) or different (0).\n  - frame : rotations are applied to static (0) or rotating (1) frame.\n\nOther Python packages and modules for 3D transformations and quaternions:\n\n* `Transforms3d <https://pypi.python.org/pypi/transforms3d>`_\n   includes most code of this module.\n* `Blender.mathutils <http://www.blender.org/api/blender_python_api>`_\n* `numpy-dtypes <https://github.com/numpy/numpy-dtypes>`_\n\nReferences\n----------\n(1)  Matrices and transformations. Ronald Goldman.\n     In ""Graphics Gems I"", pp 472-475. Morgan Kaufmann, 1990.\n(2)  More matrices and transformations: shear and pseudo-perspective.\n     Ronald Goldman. In ""Graphics Gems II"", pp 320-323. Morgan Kaufmann, 1991.\n(3)  Decomposing a matrix into simple transformations. Spencer Thomas.\n     In ""Graphics Gems II"", pp 320-323. Morgan Kaufmann, 1991.\n(4)  Recovering the data from the transformation matrix. Ronald Goldman.\n     In ""Graphics Gems II"", pp 324-331. Morgan Kaufmann, 1991.\n(5)  Euler angle conversion. Ken Shoemake.\n     In ""Graphics Gems IV"", pp 222-229. Morgan Kaufmann, 1994.\n(6)  Arcball rotation control. Ken Shoemake.\n     In ""Graphics Gems IV"", pp 175-192. Morgan Kaufmann, 1994.\n(7)  Representing attitude: Euler angles, unit quaternions, and rotation\n     vectors. James Diebel. 2006.\n(8)  A discussion of the solution for the best rotation to relate two sets\n     of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.\n(9)  Closed-form solution of absolute orientation using unit quaternions.\n     BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.\n(10) Quaternions. Ken Shoemake.\n     http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf\n(11) From quaternion to matrix and back. JMP van Waveren. 2005.\n     http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm\n(12) Uniform random rotations. Ken Shoemake.\n     In ""Graphics Gems III"", pp 124-132. Morgan Kaufmann, 1992.\n(13) Quaternion in molecular modeling. CFF Karney.\n     J Mol Graph Mod, 25(5):595-604\n(14) New method for extracting the quaternion from a rotation matrix.\n     Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.\n(15) Multiple View Geometry in Computer Vision. Hartley and Zissermann.\n     Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.\n(16) Column Vectors vs. Row Vectors.\n     http://steve.hollasch.net/cgindex/math/matrix/column-vec.html\n\nExamples\n--------\n>>> alpha, beta, gamma = 0.123, -1.234, 2.345\n>>> origin, xaxis, yaxis, zaxis = [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]\n>>> I = identity_matrix()\n>>> Rx = rotation_matrix(alpha, xaxis)\n>>> Ry = rotation_matrix(beta, yaxis)\n>>> Rz = rotation_matrix(gamma, zaxis)\n>>> R = concatenate_matrices(Rx, Ry, Rz)\n>>> euler = euler_from_matrix(R, \'rxyz\')\n>>> numpy.allclose([alpha, beta, gamma], euler)\nTrue\n>>> Re = euler_matrix(alpha, beta, gamma, \'rxyz\')\n>>> is_same_transform(R, Re)\nTrue\n>>> al, be, ga = euler_from_matrix(Re, \'rxyz\')\n>>> is_same_transform(Re, euler_matrix(al, be, ga, \'rxyz\'))\nTrue\n>>> qx = quaternion_about_axis(alpha, xaxis)\n>>> qy = quaternion_about_axis(beta, yaxis)\n>>> qz = quaternion_about_axis(gamma, zaxis)\n>>> q = quaternion_multiply(qx, qy)\n>>> q = quaternion_multiply(q, qz)\n>>> Rq = quaternion_matrix(q)\n>>> is_same_transform(R, Rq)\nTrue\n>>> S = scale_matrix(1.23, origin)\n>>> T = translation_matrix([1, 2, 3])\n>>> Z = shear_matrix(beta, xaxis, origin, zaxis)\n>>> R = random_rotation_matrix(numpy.random.rand(3))\n>>> M = concatenate_matrices(T, R, Z, S)\n>>> scale, shear, angles, trans, persp = decompose_matrix(M)\n>>> numpy.allclose(scale, 1.23)\nTrue\n>>> numpy.allclose(trans, [1, 2, 3])\nTrue\n>>> numpy.allclose(shear, [0, math.tan(beta), 0])\nTrue\n>>> is_same_transform(R, euler_matrix(axes=\'sxyz\', *angles))\nTrue\n>>> M1 = compose_matrix(scale, shear, angles, trans, persp)\n>>> is_same_transform(M, M1)\nTrue\n>>> v0, v1 = random_vector(3), random_vector(3)\n>>> M = rotation_matrix(angle_between_vectors(v0, v1), vector_product(v0, v1))\n>>> v2 = numpy.dot(v0, M[:3,:3].T)\n>>> numpy.allclose(unit_vector(v1), unit_vector(v2))\nTrue\n\n""""""\n\nfrom __future__ import division, print_function\n\nimport math\n\nimport numpy\n\n__version__ = \'2015.07.18\'\n__docformat__ = \'restructuredtext en\'\n__all__ = ()\n\n\ndef identity_matrix():\n    """"""Return 4x4 identity/unit matrix.\n\n    >>> I = identity_matrix()\n    >>> numpy.allclose(I, numpy.dot(I, I))\n    True\n    >>> numpy.sum(I), numpy.trace(I)\n    (4.0, 4.0)\n    >>> numpy.allclose(I, numpy.identity(4))\n    True\n\n    """"""\n    return numpy.identity(4)\n\n\ndef translation_matrix(direction):\n    """"""Return matrix to translate by direction vector.\n\n    >>> v = numpy.random.random(3) - 0.5\n    >>> numpy.allclose(v, translation_matrix(v)[:3, 3])\n    True\n\n    """"""\n    M = numpy.identity(4)\n    M[:3, 3] = direction[:3]\n    return M\n\n\ndef translation_from_matrix(matrix):\n    """"""Return translation vector from translation matrix.\n\n    >>> v0 = numpy.random.random(3) - 0.5\n    >>> v1 = translation_from_matrix(translation_matrix(v0))\n    >>> numpy.allclose(v0, v1)\n    True\n\n    """"""\n    return numpy.array(matrix, copy=False)[:3, 3].copy()\n\n\ndef reflection_matrix(point, normal):\n    """"""Return matrix to mirror at plane defined by point and normal vector.\n\n    >>> v0 = numpy.random.random(4) - 0.5\n    >>> v0[3] = 1.\n    >>> v1 = numpy.random.random(3) - 0.5\n    >>> R = reflection_matrix(v0, v1)\n    >>> numpy.allclose(2, numpy.trace(R))\n    True\n    >>> numpy.allclose(v0, numpy.dot(R, v0))\n    True\n    >>> v2 = v0.copy()\n    >>> v2[:3] += v1\n    >>> v3 = v0.copy()\n    >>> v2[:3] -= v1\n    >>> numpy.allclose(v2, numpy.dot(R, v3))\n    True\n\n    """"""\n    normal = unit_vector(normal[:3])\n    M = numpy.identity(4)\n    M[:3, :3] -= 2.0 * numpy.outer(normal, normal)\n    M[:3, 3] = (2.0 * numpy.dot(point[:3], normal)) * normal\n    return M\n\n\ndef reflection_from_matrix(matrix):\n    """"""Return mirror plane point and normal vector from reflection matrix.\n\n    >>> v0 = numpy.random.random(3) - 0.5\n    >>> v1 = numpy.random.random(3) - 0.5\n    >>> M0 = reflection_matrix(v0, v1)\n    >>> point, normal = reflection_from_matrix(M0)\n    >>> M1 = reflection_matrix(point, normal)\n    >>> is_same_transform(M0, M1)\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)\n    # normal: unit eigenvector corresponding to eigenvalue -1\n    w, V = numpy.linalg.eig(M[:3, :3])\n    i = numpy.where(abs(numpy.real(w) + 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no unit eigenvector corresponding to eigenvalue -1"")\n    normal = numpy.real(V[:, i[0]]).squeeze()\n    # point: any unit eigenvector corresponding to eigenvalue 1\n    w, V = numpy.linalg.eig(M)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no unit eigenvector corresponding to eigenvalue 1"")\n    point = numpy.real(V[:, i[-1]]).squeeze()\n    point /= point[3]\n    return point, normal\n\n\ndef rotation_matrix(angle, direction, point=None):\n    """"""Return matrix to rotate about axis defined by point and direction.\n\n    >>> R = rotation_matrix(math.pi/2, [0, 0, 1], [1, 0, 0])\n    >>> numpy.allclose(numpy.dot(R, [0, 0, 0, 1]), [1, -1, 0, 1])\n    True\n    >>> angle = (random.random() - 0.5) * (2*math.pi)\n    >>> direc = numpy.random.random(3) - 0.5\n    >>> point = numpy.random.random(3) - 0.5\n    >>> R0 = rotation_matrix(angle, direc, point)\n    >>> R1 = rotation_matrix(angle-2*math.pi, direc, point)\n    >>> is_same_transform(R0, R1)\n    True\n    >>> R0 = rotation_matrix(angle, direc, point)\n    >>> R1 = rotation_matrix(-angle, -direc, point)\n    >>> is_same_transform(R0, R1)\n    True\n    >>> I = numpy.identity(4, numpy.float64)\n    >>> numpy.allclose(I, rotation_matrix(math.pi*2, direc))\n    True\n    >>> numpy.allclose(2, numpy.trace(rotation_matrix(math.pi/2,\n    ...                                               direc, point)))\n    True\n\n    """"""\n    sina = math.sin(angle)\n    cosa = math.cos(angle)\n    direction = unit_vector(direction[:3])\n    # rotation matrix around unit vector\n    R = numpy.diag([cosa, cosa, cosa])\n    R += numpy.outer(direction, direction) * (1.0 - cosa)\n    direction *= sina\n    R += numpy.array([[ 0.0,         -direction[2],  direction[1]],\n                      [ direction[2], 0.0,          -direction[0]],\n                      [-direction[1], direction[0],  0.0]])\n    M = numpy.identity(4)\n    M[:3, :3] = R\n    if point is not None:\n        # rotation not around origin\n        point = numpy.array(point[:3], dtype=numpy.float64, copy=False)\n        M[:3, 3] = point - numpy.dot(R, point)\n    return M\n\n\ndef rotation_from_matrix(matrix):\n    """"""Return rotation angle and axis from rotation matrix.\n\n    >>> angle = (random.random() - 0.5) * (2*math.pi)\n    >>> direc = numpy.random.random(3) - 0.5\n    >>> point = numpy.random.random(3) - 0.5\n    >>> R0 = rotation_matrix(angle, direc, point)\n    >>> angle, direc, point = rotation_from_matrix(R0)\n    >>> R1 = rotation_matrix(angle, direc, point)\n    >>> is_same_transform(R0, R1)\n    True\n\n    """"""\n    R = numpy.array(matrix, dtype=numpy.float64, copy=False)\n    R33 = R[:3, :3]\n    # direction: unit eigenvector of R33 corresponding to eigenvalue of 1\n    w, W = numpy.linalg.eig(R33.T)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no unit eigenvector corresponding to eigenvalue 1"")\n    direction = numpy.real(W[:, i[-1]]).squeeze()\n    # point: unit eigenvector of R33 corresponding to eigenvalue of 1\n    w, Q = numpy.linalg.eig(R)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no unit eigenvector corresponding to eigenvalue 1"")\n    point = numpy.real(Q[:, i[-1]]).squeeze()\n    point /= point[3]\n    # rotation angle depending on direction\n    cosa = (numpy.trace(R33) - 1.0) / 2.0\n    if abs(direction[2]) > 1e-8:\n        sina = (R[1, 0] + (cosa-1.0)*direction[0]*direction[1]) / direction[2]\n    elif abs(direction[1]) > 1e-8:\n        sina = (R[0, 2] + (cosa-1.0)*direction[0]*direction[2]) / direction[1]\n    else:\n        sina = (R[2, 1] + (cosa-1.0)*direction[1]*direction[2]) / direction[0]\n    angle = math.atan2(sina, cosa)\n    return angle, direction, point\n\n\ndef scale_matrix(factor, origin=None, direction=None):\n    """"""Return matrix to scale by factor around origin in direction.\n\n    Use factor -1 for point symmetry.\n\n    >>> v = (numpy.random.rand(4, 5) - 0.5) * 20\n    >>> v[3] = 1\n    >>> S = scale_matrix(-1.234)\n    >>> numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3])\n    True\n    >>> factor = random.random() * 10 - 5\n    >>> origin = numpy.random.random(3) - 0.5\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> S = scale_matrix(factor, origin)\n    >>> S = scale_matrix(factor, origin, direct)\n\n    """"""\n    if direction is None:\n        # uniform scaling\n        M = numpy.diag([factor, factor, factor, 1.0])\n        if origin is not None:\n            M[:3, 3] = origin[:3]\n            M[:3, 3] *= 1.0 - factor\n    else:\n        # nonuniform scaling\n        direction = unit_vector(direction[:3])\n        factor = 1.0 - factor\n        M = numpy.identity(4)\n        M[:3, :3] -= factor * numpy.outer(direction, direction)\n        if origin is not None:\n            M[:3, 3] = (factor * numpy.dot(origin[:3], direction)) * direction\n    return M\n\n\ndef scale_from_matrix(matrix):\n    """"""Return scaling factor, origin and direction from scaling matrix.\n\n    >>> factor = random.random() * 10 - 5\n    >>> origin = numpy.random.random(3) - 0.5\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> S0 = scale_matrix(factor, origin)\n    >>> factor, origin, direction = scale_from_matrix(S0)\n    >>> S1 = scale_matrix(factor, origin, direction)\n    >>> is_same_transform(S0, S1)\n    True\n    >>> S0 = scale_matrix(factor, origin, direct)\n    >>> factor, origin, direction = scale_from_matrix(S0)\n    >>> S1 = scale_matrix(factor, origin, direction)\n    >>> is_same_transform(S0, S1)\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)\n    M33 = M[:3, :3]\n    factor = numpy.trace(M33) - 2.0\n    try:\n        # direction: unit eigenvector corresponding to eigenvalue factor\n        w, V = numpy.linalg.eig(M33)\n        i = numpy.where(abs(numpy.real(w) - factor) < 1e-8)[0][0]\n        direction = numpy.real(V[:, i]).squeeze()\n        direction /= vector_norm(direction)\n    except IndexError:\n        # uniform scaling\n        factor = (factor + 2.0) / 3.0\n        direction = None\n    # origin: any eigenvector corresponding to eigenvalue 1\n    w, V = numpy.linalg.eig(M)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no eigenvector corresponding to eigenvalue 1"")\n    origin = numpy.real(V[:, i[-1]]).squeeze()\n    origin /= origin[3]\n    return factor, origin, direction\n\n\ndef projection_matrix(point, normal, direction=None,\n                      perspective=None, pseudo=False):\n    """"""Return matrix to project onto plane defined by point and normal.\n\n    Using either perspective point, projection direction, or none of both.\n\n    If pseudo is True, perspective projections will preserve relative depth\n    such that Perspective = dot(Orthogonal, PseudoPerspective).\n\n    >>> P = projection_matrix([0, 0, 0], [1, 0, 0])\n    >>> numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:])\n    True\n    >>> point = numpy.random.random(3) - 0.5\n    >>> normal = numpy.random.random(3) - 0.5\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> persp = numpy.random.random(3) - 0.5\n    >>> P0 = projection_matrix(point, normal)\n    >>> P1 = projection_matrix(point, normal, direction=direct)\n    >>> P2 = projection_matrix(point, normal, perspective=persp)\n    >>> P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)\n    >>> is_same_transform(P2, numpy.dot(P0, P3))\n    True\n    >>> P = projection_matrix([3, 0, 0], [1, 1, 0], [1, 0, 0])\n    >>> v0 = (numpy.random.rand(4, 5) - 0.5) * 20\n    >>> v0[3] = 1\n    >>> v1 = numpy.dot(P, v0)\n    >>> numpy.allclose(v1[1], v0[1])\n    True\n    >>> numpy.allclose(v1[0], 3-v1[1])\n    True\n\n    """"""\n    M = numpy.identity(4)\n    point = numpy.array(point[:3], dtype=numpy.float64, copy=False)\n    normal = unit_vector(normal[:3])\n    if perspective is not None:\n        # perspective projection\n        perspective = numpy.array(perspective[:3], dtype=numpy.float64,\n                                  copy=False)\n        M[0, 0] = M[1, 1] = M[2, 2] = numpy.dot(perspective-point, normal)\n        M[:3, :3] -= numpy.outer(perspective, normal)\n        if pseudo:\n            # preserve relative depth\n            M[:3, :3] -= numpy.outer(normal, normal)\n            M[:3, 3] = numpy.dot(point, normal) * (perspective+normal)\n        else:\n            M[:3, 3] = numpy.dot(point, normal) * perspective\n        M[3, :3] = -normal\n        M[3, 3] = numpy.dot(perspective, normal)\n    elif direction is not None:\n        # parallel projection\n        direction = numpy.array(direction[:3], dtype=numpy.float64, copy=False)\n        scale = numpy.dot(direction, normal)\n        M[:3, :3] -= numpy.outer(direction, normal) / scale\n        M[:3, 3] = direction * (numpy.dot(point, normal) / scale)\n    else:\n        # orthogonal projection\n        M[:3, :3] -= numpy.outer(normal, normal)\n        M[:3, 3] = numpy.dot(point, normal) * normal\n    return M\n\n\ndef projection_from_matrix(matrix, pseudo=False):\n    """"""Return projection plane and perspective point from projection matrix.\n\n    Return values are same as arguments for projection_matrix function:\n    point, normal, direction, perspective, and pseudo.\n\n    >>> point = numpy.random.random(3) - 0.5\n    >>> normal = numpy.random.random(3) - 0.5\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> persp = numpy.random.random(3) - 0.5\n    >>> P0 = projection_matrix(point, normal)\n    >>> result = projection_from_matrix(P0)\n    >>> P1 = projection_matrix(*result)\n    >>> is_same_transform(P0, P1)\n    True\n    >>> P0 = projection_matrix(point, normal, direct)\n    >>> result = projection_from_matrix(P0)\n    >>> P1 = projection_matrix(*result)\n    >>> is_same_transform(P0, P1)\n    True\n    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)\n    >>> result = projection_from_matrix(P0, pseudo=False)\n    >>> P1 = projection_matrix(*result)\n    >>> is_same_transform(P0, P1)\n    True\n    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)\n    >>> result = projection_from_matrix(P0, pseudo=True)\n    >>> P1 = projection_matrix(*result)\n    >>> is_same_transform(P0, P1)\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)\n    M33 = M[:3, :3]\n    w, V = numpy.linalg.eig(M)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not pseudo and len(i):\n        # point: any eigenvector corresponding to eigenvalue 1\n        point = numpy.real(V[:, i[-1]]).squeeze()\n        point /= point[3]\n        # direction: unit eigenvector corresponding to eigenvalue 0\n        w, V = numpy.linalg.eig(M33)\n        i = numpy.where(abs(numpy.real(w)) < 1e-8)[0]\n        if not len(i):\n            raise ValueError(""no eigenvector corresponding to eigenvalue 0"")\n        direction = numpy.real(V[:, i[0]]).squeeze()\n        direction /= vector_norm(direction)\n        # normal: unit eigenvector of M33.T corresponding to eigenvalue 0\n        w, V = numpy.linalg.eig(M33.T)\n        i = numpy.where(abs(numpy.real(w)) < 1e-8)[0]\n        if len(i):\n            # parallel projection\n            normal = numpy.real(V[:, i[0]]).squeeze()\n            normal /= vector_norm(normal)\n            return point, normal, direction, None, False\n        else:\n            # orthogonal projection, where normal equals direction vector\n            return point, direction, None, None, False\n    else:\n        # perspective projection\n        i = numpy.where(abs(numpy.real(w)) > 1e-8)[0]\n        if not len(i):\n            raise ValueError(\n                ""no eigenvector not corresponding to eigenvalue 0"")\n        point = numpy.real(V[:, i[-1]]).squeeze()\n        point /= point[3]\n        normal = - M[3, :3]\n        perspective = M[:3, 3] / numpy.dot(point[:3], normal)\n        if pseudo:\n            perspective -= normal\n        return point, normal, None, perspective, pseudo\n\n\ndef clip_matrix(left, right, bottom, top, near, far, perspective=False):\n    """"""Return matrix to obtain normalized device coordinates from frustum.\n\n    The frustum bounds are axis-aligned along x (left, right),\n    y (bottom, top) and z (near, far).\n\n    Normalized device coordinates are in range [-1, 1] if coordinates are\n    inside the frustum.\n\n    If perspective is True the frustum is a truncated pyramid with the\n    perspective point at origin and direction along z axis, otherwise an\n    orthographic canonical view volume (a box).\n\n    Homogeneous coordinates transformed by the perspective clip matrix\n    need to be dehomogenized (divided by w coordinate).\n\n    >>> frustum = numpy.random.rand(6)\n    >>> frustum[1] += frustum[0]\n    >>> frustum[3] += frustum[2]\n    >>> frustum[5] += frustum[4]\n    >>> M = clip_matrix(perspective=False, *frustum)\n    >>> numpy.dot(M, [frustum[0], frustum[2], frustum[4], 1])\n    array([-1., -1., -1.,  1.])\n    >>> numpy.dot(M, [frustum[1], frustum[3], frustum[5], 1])\n    array([ 1.,  1.,  1.,  1.])\n    >>> M = clip_matrix(perspective=True, *frustum)\n    >>> v = numpy.dot(M, [frustum[0], frustum[2], frustum[4], 1])\n    >>> v / v[3]\n    array([-1., -1., -1.,  1.])\n    >>> v = numpy.dot(M, [frustum[1], frustum[3], frustum[4], 1])\n    >>> v / v[3]\n    array([ 1.,  1., -1.,  1.])\n\n    """"""\n    if left >= right or bottom >= top or near >= far:\n        raise ValueError(""invalid frustum"")\n    if perspective:\n        if near <= _EPS:\n            raise ValueError(""invalid frustum: near <= 0"")\n        t = 2.0 * near\n        M = [[t/(left-right), 0.0, (right+left)/(right-left), 0.0],\n             [0.0, t/(bottom-top), (top+bottom)/(top-bottom), 0.0],\n             [0.0, 0.0, (far+near)/(near-far), t*far/(far-near)],\n             [0.0, 0.0, -1.0, 0.0]]\n    else:\n        M = [[2.0/(right-left), 0.0, 0.0, (right+left)/(left-right)],\n             [0.0, 2.0/(top-bottom), 0.0, (top+bottom)/(bottom-top)],\n             [0.0, 0.0, 2.0/(far-near), (far+near)/(near-far)],\n             [0.0, 0.0, 0.0, 1.0]]\n    return numpy.array(M)\n\n\ndef shear_matrix(angle, direction, point, normal):\n    """"""Return matrix to shear by angle along direction vector on shear plane.\n\n    The shear plane is defined by a point and normal vector. The direction\n    vector must be orthogonal to the plane\'s normal vector.\n\n    A point P is transformed by the shear matrix into P"" such that\n    the vector P-P"" is parallel to the direction vector and its extent is\n    given by the angle of P-P\'-P"", where P\' is the orthogonal projection\n    of P onto the shear plane.\n\n    >>> angle = (random.random() - 0.5) * 4*math.pi\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> point = numpy.random.random(3) - 0.5\n    >>> normal = numpy.cross(direct, numpy.random.random(3))\n    >>> S = shear_matrix(angle, direct, point, normal)\n    >>> numpy.allclose(1, numpy.linalg.det(S))\n    True\n\n    """"""\n    normal = unit_vector(normal[:3])\n    direction = unit_vector(direction[:3])\n    if abs(numpy.dot(normal, direction)) > 1e-6:\n        raise ValueError(""direction and normal vectors are not orthogonal"")\n    angle = math.tan(angle)\n    M = numpy.identity(4)\n    M[:3, :3] += angle * numpy.outer(direction, normal)\n    M[:3, 3] = -angle * numpy.dot(point[:3], normal) * direction\n    return M\n\n\ndef shear_from_matrix(matrix):\n    """"""Return shear angle, direction and plane from shear matrix.\n\n    >>> angle = (random.random() - 0.5) * 4*math.pi\n    >>> direct = numpy.random.random(3) - 0.5\n    >>> point = numpy.random.random(3) - 0.5\n    >>> normal = numpy.cross(direct, numpy.random.random(3))\n    >>> S0 = shear_matrix(angle, direct, point, normal)\n    >>> angle, direct, point, normal = shear_from_matrix(S0)\n    >>> S1 = shear_matrix(angle, direct, point, normal)\n    >>> is_same_transform(S0, S1)\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)\n    M33 = M[:3, :3]\n    # normal: cross independent eigenvectors corresponding to the eigenvalue 1\n    w, V = numpy.linalg.eig(M33)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-4)[0]\n    if len(i) < 2:\n        raise ValueError(""no two linear independent eigenvectors found %s"" % w)\n    V = numpy.real(V[:, i]).squeeze().T\n    lenorm = -1.0\n    for i0, i1 in ((0, 1), (0, 2), (1, 2)):\n        n = numpy.cross(V[i0], V[i1])\n        w = vector_norm(n)\n        if w > lenorm:\n            lenorm = w\n            normal = n\n    normal /= lenorm\n    # direction and angle\n    direction = numpy.dot(M33 - numpy.identity(3), normal)\n    angle = vector_norm(direction)\n    direction /= angle\n    angle = math.atan(angle)\n    # point: eigenvector corresponding to eigenvalue 1\n    w, V = numpy.linalg.eig(M)\n    i = numpy.where(abs(numpy.real(w) - 1.0) < 1e-8)[0]\n    if not len(i):\n        raise ValueError(""no eigenvector corresponding to eigenvalue 1"")\n    point = numpy.real(V[:, i[-1]]).squeeze()\n    point /= point[3]\n    return angle, direction, point, normal\n\n\ndef decompose_matrix(matrix):\n    """"""Return sequence of transformations from transformation matrix.\n\n    matrix : array_like\n        Non-degenerative homogeneous transformation matrix\n\n    Return tuple of:\n        scale : vector of 3 scaling factors\n        shear : list of shear factors for x-y, x-z, y-z axes\n        angles : list of Euler angles about static x, y, z axes\n        translate : translation vector along x, y, z axes\n        perspective : perspective partition of matrix\n\n    Raise ValueError if matrix is of wrong type or degenerative.\n\n    >>> T0 = translation_matrix([1, 2, 3])\n    >>> scale, shear, angles, trans, persp = decompose_matrix(T0)\n    >>> T1 = translation_matrix(trans)\n    >>> numpy.allclose(T0, T1)\n    True\n    >>> S = scale_matrix(0.123)\n    >>> scale, shear, angles, trans, persp = decompose_matrix(S)\n    >>> scale[0]\n    0.123\n    >>> R0 = euler_matrix(1, 2, 3)\n    >>> scale, shear, angles, trans, persp = decompose_matrix(R0)\n    >>> R1 = euler_matrix(*angles)\n    >>> numpy.allclose(R0, R1)\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=True).T\n    if abs(M[3, 3]) < _EPS:\n        raise ValueError(""M[3, 3] is zero"")\n    M /= M[3, 3]\n    P = M.copy()\n    P[:, 3] = 0.0, 0.0, 0.0, 1.0\n    if not numpy.linalg.det(P):\n        raise ValueError(""matrix is singular"")\n\n    scale = numpy.zeros((3, ))\n    shear = [0.0, 0.0, 0.0]\n    angles = [0.0, 0.0, 0.0]\n\n    if any(abs(M[:3, 3]) > _EPS):\n        perspective = numpy.dot(M[:, 3], numpy.linalg.inv(P.T))\n        M[:, 3] = 0.0, 0.0, 0.0, 1.0\n    else:\n        perspective = numpy.array([0.0, 0.0, 0.0, 1.0])\n\n    translate = M[3, :3].copy()\n    M[3, :3] = 0.0\n\n    row = M[:3, :3].copy()\n    scale[0] = vector_norm(row[0])\n    row[0] /= scale[0]\n    shear[0] = numpy.dot(row[0], row[1])\n    row[1] -= row[0] * shear[0]\n    scale[1] = vector_norm(row[1])\n    row[1] /= scale[1]\n    shear[0] /= scale[1]\n    shear[1] = numpy.dot(row[0], row[2])\n    row[2] -= row[0] * shear[1]\n    shear[2] = numpy.dot(row[1], row[2])\n    row[2] -= row[1] * shear[2]\n    scale[2] = vector_norm(row[2])\n    row[2] /= scale[2]\n    shear[1:] /= scale[2]\n\n    if numpy.dot(row[0], numpy.cross(row[1], row[2])) < 0:\n        numpy.negative(scale, scale)\n        numpy.negative(row, row)\n\n    angles[1] = math.asin(-row[0, 2])\n    if math.cos(angles[1]):\n        angles[0] = math.atan2(row[1, 2], row[2, 2])\n        angles[2] = math.atan2(row[0, 1], row[0, 0])\n    else:\n        #angles[0] = math.atan2(row[1, 0], row[1, 1])\n        angles[0] = math.atan2(-row[2, 1], row[1, 1])\n        angles[2] = 0.0\n\n    return scale, shear, angles, translate, perspective\n\n\ndef compose_matrix(scale=None, shear=None, angles=None, translate=None,\n                   perspective=None):\n    """"""Return transformation matrix from sequence of transformations.\n\n    This is the inverse of the decompose_matrix function.\n\n    Sequence of transformations:\n        scale : vector of 3 scaling factors\n        shear : list of shear factors for x-y, x-z, y-z axes\n        angles : list of Euler angles about static x, y, z axes\n        translate : translation vector along x, y, z axes\n        perspective : perspective partition of matrix\n\n    >>> scale = numpy.random.random(3) - 0.5\n    >>> shear = numpy.random.random(3) - 0.5\n    >>> angles = (numpy.random.random(3) - 0.5) * (2*math.pi)\n    >>> trans = numpy.random.random(3) - 0.5\n    >>> persp = numpy.random.random(4) - 0.5\n    >>> M0 = compose_matrix(scale, shear, angles, trans, persp)\n    >>> result = decompose_matrix(M0)\n    >>> M1 = compose_matrix(*result)\n    >>> is_same_transform(M0, M1)\n    True\n\n    """"""\n    M = numpy.identity(4)\n    if perspective is not None:\n        P = numpy.identity(4)\n        P[3, :] = perspective[:4]\n        M = numpy.dot(M, P)\n    if translate is not None:\n        T = numpy.identity(4)\n        T[:3, 3] = translate[:3]\n        M = numpy.dot(M, T)\n    if angles is not None:\n        R = euler_matrix(angles[0], angles[1], angles[2], \'sxyz\')\n        M = numpy.dot(M, R)\n    if shear is not None:\n        Z = numpy.identity(4)\n        Z[1, 2] = shear[2]\n        Z[0, 2] = shear[1]\n        Z[0, 1] = shear[0]\n        M = numpy.dot(M, Z)\n    if scale is not None:\n        S = numpy.identity(4)\n        S[0, 0] = scale[0]\n        S[1, 1] = scale[1]\n        S[2, 2] = scale[2]\n        M = numpy.dot(M, S)\n    M /= M[3, 3]\n    return M\n\n\ndef orthogonalization_matrix(lengths, angles):\n    """"""Return orthogonalization matrix for crystallographic cell coordinates.\n\n    Angles are expected in degrees.\n\n    The de-orthogonalization matrix is the inverse.\n\n    >>> O = orthogonalization_matrix([10, 10, 10], [90, 90, 90])\n    >>> numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10)\n    True\n    >>> O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])\n    >>> numpy.allclose(numpy.sum(O), 43.063229)\n    True\n\n    """"""\n    a, b, c = lengths\n    angles = numpy.radians(angles)\n    sina, sinb, _ = numpy.sin(angles)\n    cosa, cosb, cosg = numpy.cos(angles)\n    co = (cosa * cosb - cosg) / (sina * sinb)\n    return numpy.array([\n        [ a*sinb*math.sqrt(1.0-co*co),  0.0,    0.0, 0.0],\n        [-a*sinb*co,                    b*sina, 0.0, 0.0],\n        [ a*cosb,                       b*cosa, c,   0.0],\n        [ 0.0,                          0.0,    0.0, 1.0]])\n\n\ndef affine_matrix_from_points(v0, v1, shear=True, scale=True, usesvd=True):\n    """"""Return affine transform matrix to register two point sets.\n\n    v0 and v1 are shape (ndims, \\*) arrays of at least ndims non-homogeneous\n    coordinates, where ndims is the dimensionality of the coordinate space.\n\n    If shear is False, a similarity transformation matrix is returned.\n    If also scale is False, a rigid/Euclidean transformation matrix\n    is returned.\n\n    By default the algorithm by Hartley and Zissermann [15] is used.\n    If usesvd is True, similarity and Euclidean transformation matrices\n    are calculated by minimizing the weighted sum of squared deviations\n    (RMSD) according to the algorithm by Kabsch [8].\n    Otherwise, and if ndims is 3, the quaternion based algorithm by Horn [9]\n    is used, which is slower when using this Python implementation.\n\n    The returned matrix performs rotation, translation and uniform scaling\n    (if specified).\n\n    >>> v0 = [[0, 1031, 1031, 0], [0, 0, 1600, 1600]]\n    >>> v1 = [[675, 826, 826, 677], [55, 52, 281, 277]]\n    >>> affine_matrix_from_points(v0, v1)\n    array([[   0.14549,    0.00062,  675.50008],\n           [   0.00048,    0.14094,   53.24971],\n           [   0.     ,    0.     ,    1.     ]])\n    >>> T = translation_matrix(numpy.random.random(3)-0.5)\n    >>> R = random_rotation_matrix(numpy.random.random(3))\n    >>> S = scale_matrix(random.random())\n    >>> M = concatenate_matrices(T, R, S)\n    >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20\n    >>> v0[3] = 1\n    >>> v1 = numpy.dot(M, v0)\n    >>> v0[:3] += numpy.random.normal(0, 1e-8, 300).reshape(3, -1)\n    >>> M = affine_matrix_from_points(v0[:3], v1[:3])\n    >>> numpy.allclose(v1, numpy.dot(M, v0))\n    True\n\n    More examples in superimposition_matrix()\n\n    """"""\n    v0 = numpy.array(v0, dtype=numpy.float64, copy=True)\n    v1 = numpy.array(v1, dtype=numpy.float64, copy=True)\n\n    ndims = v0.shape[0]\n    if ndims < 2 or v0.shape[1] < ndims or v0.shape != v1.shape:\n        raise ValueError(""input arrays are of wrong shape or type"")\n\n    # move centroids to origin\n    t0 = -numpy.mean(v0, axis=1)\n    M0 = numpy.identity(ndims+1)\n    M0[:ndims, ndims] = t0\n    v0 += t0.reshape(ndims, 1)\n    t1 = -numpy.mean(v1, axis=1)\n    M1 = numpy.identity(ndims+1)\n    M1[:ndims, ndims] = t1\n    v1 += t1.reshape(ndims, 1)\n\n    if shear:\n        # Affine transformation\n        A = numpy.concatenate((v0, v1), axis=0)\n        u, s, vh = numpy.linalg.svd(A.T)\n        vh = vh[:ndims].T\n        B = vh[:ndims]\n        C = vh[ndims:2*ndims]\n        t = numpy.dot(C, numpy.linalg.pinv(B))\n        t = numpy.concatenate((t, numpy.zeros((ndims, 1))), axis=1)\n        M = numpy.vstack((t, ((0.0,)*ndims) + (1.0,)))\n    elif usesvd or ndims != 3:\n        # Rigid transformation via SVD of covariance matrix\n        u, s, vh = numpy.linalg.svd(numpy.dot(v1, v0.T))\n        # rotation matrix from SVD orthonormal bases\n        R = numpy.dot(u, vh)\n        if numpy.linalg.det(R) < 0.0:\n            # R does not constitute right handed system\n            R -= numpy.outer(u[:, ndims-1], vh[ndims-1, :]*2.0)\n            s[-1] *= -1.0\n        # homogeneous transformation matrix\n        M = numpy.identity(ndims+1)\n        M[:ndims, :ndims] = R\n    else:\n        # Rigid transformation matrix via quaternion\n        # compute symmetric matrix N\n        xx, yy, zz = numpy.sum(v0 * v1, axis=1)\n        xy, yz, zx = numpy.sum(v0 * numpy.roll(v1, -1, axis=0), axis=1)\n        xz, yx, zy = numpy.sum(v0 * numpy.roll(v1, -2, axis=0), axis=1)\n        N = [[xx+yy+zz, 0.0,      0.0,      0.0],\n             [yz-zy,    xx-yy-zz, 0.0,      0.0],\n             [zx-xz,    xy+yx,    yy-xx-zz, 0.0],\n             [xy-yx,    zx+xz,    yz+zy,    zz-xx-yy]]\n        # quaternion: eigenvector corresponding to most positive eigenvalue\n        w, V = numpy.linalg.eigh(N)\n        q = V[:, numpy.argmax(w)]\n        q /= vector_norm(q)  # unit quaternion\n        # homogeneous transformation matrix\n        M = quaternion_matrix(q)\n\n    if scale and not shear:\n        # Affine transformation; scale is ratio of RMS deviations from centroid\n        v0 *= v0\n        v1 *= v1\n        M[:ndims, :ndims] *= math.sqrt(numpy.sum(v1) / numpy.sum(v0))\n\n    # move centroids back\n    M = numpy.dot(numpy.linalg.inv(M1), numpy.dot(M, M0))\n    M /= M[ndims, ndims]\n    return M\n\n\ndef superimposition_matrix(v0, v1, scale=False, usesvd=True):\n    """"""Return matrix to transform given 3D point set into second point set.\n\n    v0 and v1 are shape (3, \\*) or (4, \\*) arrays of at least 3 points.\n\n    The parameters scale and usesvd are explained in the more general\n    affine_matrix_from_points function.\n\n    The returned matrix is a similarity or Euclidean transformation matrix.\n    This function has a fast C implementation in transformations.c.\n\n    >>> v0 = numpy.random.rand(3, 10)\n    >>> M = superimposition_matrix(v0, v0)\n    >>> numpy.allclose(M, numpy.identity(4))\n    True\n    >>> R = random_rotation_matrix(numpy.random.random(3))\n    >>> v0 = [[1,0,0], [0,1,0], [0,0,1], [1,1,1]]\n    >>> v1 = numpy.dot(R, v0)\n    >>> M = superimposition_matrix(v0, v1)\n    >>> numpy.allclose(v1, numpy.dot(M, v0))\n    True\n    >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20\n    >>> v0[3] = 1\n    >>> v1 = numpy.dot(R, v0)\n    >>> M = superimposition_matrix(v0, v1)\n    >>> numpy.allclose(v1, numpy.dot(M, v0))\n    True\n    >>> S = scale_matrix(random.random())\n    >>> T = translation_matrix(numpy.random.random(3)-0.5)\n    >>> M = concatenate_matrices(T, R, S)\n    >>> v1 = numpy.dot(M, v0)\n    >>> v0[:3] += numpy.random.normal(0, 1e-9, 300).reshape(3, -1)\n    >>> M = superimposition_matrix(v0, v1, scale=True)\n    >>> numpy.allclose(v1, numpy.dot(M, v0))\n    True\n    >>> M = superimposition_matrix(v0, v1, scale=True, usesvd=False)\n    >>> numpy.allclose(v1, numpy.dot(M, v0))\n    True\n    >>> v = numpy.empty((4, 100, 3))\n    >>> v[:, :, 0] = v0\n    >>> M = superimposition_matrix(v0, v1, scale=True, usesvd=False)\n    >>> numpy.allclose(v1, numpy.dot(M, v[:, :, 0]))\n    True\n\n    """"""\n    v0 = numpy.array(v0, dtype=numpy.float64, copy=False)[:3]\n    v1 = numpy.array(v1, dtype=numpy.float64, copy=False)[:3]\n    return affine_matrix_from_points(v0, v1, shear=False,\n                                     scale=scale, usesvd=usesvd)\n\n\ndef euler_matrix(ai, aj, ak, axes=\'sxyz\'):\n    """"""Return homogeneous rotation matrix from Euler angles and axis sequence.\n\n    ai, aj, ak : Euler\'s roll, pitch and yaw angles\n    axes : One of 24 axis sequences as string or encoded tuple\n\n    >>> R = euler_matrix(1, 2, 3, \'syxz\')\n    >>> numpy.allclose(numpy.sum(R[0]), -1.34786452)\n    True\n    >>> R = euler_matrix(1, 2, 3, (0, 1, 0, 1))\n    >>> numpy.allclose(numpy.sum(R[0]), -0.383436184)\n    True\n    >>> ai, aj, ak = (4*math.pi) * (numpy.random.random(3) - 0.5)\n    >>> for axes in _AXES2TUPLE.keys():\n    ...    R = euler_matrix(ai, aj, ak, axes)\n    >>> for axes in _TUPLE2AXES.keys():\n    ...    R = euler_matrix(ai, aj, ak, axes)\n\n    """"""\n    try:\n        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes]\n    except (AttributeError, KeyError):\n        _TUPLE2AXES[axes]  # validation\n        firstaxis, parity, repetition, frame = axes\n\n    i = firstaxis\n    j = _NEXT_AXIS[i+parity]\n    k = _NEXT_AXIS[i-parity+1]\n\n    if frame:\n        ai, ak = ak, ai\n    if parity:\n        ai, aj, ak = -ai, -aj, -ak\n\n    si, sj, sk = math.sin(ai), math.sin(aj), math.sin(ak)\n    ci, cj, ck = math.cos(ai), math.cos(aj), math.cos(ak)\n    cc, cs = ci*ck, ci*sk\n    sc, ss = si*ck, si*sk\n\n    M = numpy.identity(4)\n    if repetition:\n        M[i, i] = cj\n        M[i, j] = sj*si\n        M[i, k] = sj*ci\n        M[j, i] = sj*sk\n        M[j, j] = -cj*ss+cc\n        M[j, k] = -cj*cs-sc\n        M[k, i] = -sj*ck\n        M[k, j] = cj*sc+cs\n        M[k, k] = cj*cc-ss\n    else:\n        M[i, i] = cj*ck\n        M[i, j] = sj*sc-cs\n        M[i, k] = sj*cc+ss\n        M[j, i] = cj*sk\n        M[j, j] = sj*ss+cc\n        M[j, k] = sj*cs-sc\n        M[k, i] = -sj\n        M[k, j] = cj*si\n        M[k, k] = cj*ci\n    return M\n\n\ndef euler_from_matrix(matrix, axes=\'sxyz\'):\n    """"""Return Euler angles from rotation matrix for specified axis sequence.\n\n    axes : One of 24 axis sequences as string or encoded tuple\n\n    Note that many Euler angle triplets can describe one matrix.\n\n    >>> R0 = euler_matrix(1, 2, 3, \'syxz\')\n    >>> al, be, ga = euler_from_matrix(R0, \'syxz\')\n    >>> R1 = euler_matrix(al, be, ga, \'syxz\')\n    >>> numpy.allclose(R0, R1)\n    True\n    >>> angles = (4*math.pi) * (numpy.random.random(3) - 0.5)\n    >>> for axes in _AXES2TUPLE.keys():\n    ...    R0 = euler_matrix(axes=axes, *angles)\n    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))\n    ...    if not numpy.allclose(R0, R1): print(axes, ""failed"")\n\n    """"""\n    try:\n        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]\n    except (AttributeError, KeyError):\n        _TUPLE2AXES[axes]  # validation\n        firstaxis, parity, repetition, frame = axes\n\n    i = firstaxis\n    j = _NEXT_AXIS[i+parity]\n    k = _NEXT_AXIS[i-parity+1]\n\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)[:3, :3]\n    if repetition:\n        sy = math.sqrt(M[i, j]*M[i, j] + M[i, k]*M[i, k])\n        if sy > _EPS:\n            ax = math.atan2( M[i, j],  M[i, k])\n            ay = math.atan2( sy,       M[i, i])\n            az = math.atan2( M[j, i], -M[k, i])\n        else:\n            ax = math.atan2(-M[j, k],  M[j, j])\n            ay = math.atan2( sy,       M[i, i])\n            az = 0.0\n    else:\n        cy = math.sqrt(M[i, i]*M[i, i] + M[j, i]*M[j, i])\n        if cy > _EPS:\n            ax = math.atan2( M[k, j],  M[k, k])\n            ay = math.atan2(-M[k, i],  cy)\n            az = math.atan2( M[j, i],  M[i, i])\n        else:\n            ax = math.atan2(-M[j, k],  M[j, j])\n            ay = math.atan2(-M[k, i],  cy)\n            az = 0.0\n\n    if parity:\n        ax, ay, az = -ax, -ay, -az\n    if frame:\n        ax, az = az, ax\n    return ax, ay, az\n\n\ndef euler_from_quaternion(quaternion, axes=\'sxyz\'):\n    """"""Return Euler angles from quaternion for specified axis sequence.\n\n    >>> angles = euler_from_quaternion([0.99810947, 0.06146124, 0, 0])\n    >>> numpy.allclose(angles, [0.123, 0, 0])\n    True\n\n    """"""\n    return euler_from_matrix(quaternion_matrix(quaternion), axes)\n\n\ndef quaternion_from_euler(ai, aj, ak, axes=\'sxyz\'):\n    """"""Return quaternion from Euler angles and axis sequence.\n\n    ai, aj, ak : Euler\'s roll, pitch and yaw angles\n    axes : One of 24 axis sequences as string or encoded tuple\n\n    >>> q = quaternion_from_euler(1, 2, 3, \'ryxz\')\n    >>> numpy.allclose(q, [0.435953, 0.310622, -0.718287, 0.444435])\n    True\n\n    """"""\n    try:\n        firstaxis, parity, repetition, frame = _AXES2TUPLE[axes.lower()]\n    except (AttributeError, KeyError):\n        _TUPLE2AXES[axes]  # validation\n        firstaxis, parity, repetition, frame = axes\n\n    i = firstaxis + 1\n    j = _NEXT_AXIS[i+parity-1] + 1\n    k = _NEXT_AXIS[i-parity] + 1\n\n    if frame:\n        ai, ak = ak, ai\n    if parity:\n        aj = -aj\n\n    ai /= 2.0\n    aj /= 2.0\n    ak /= 2.0\n    ci = math.cos(ai)\n    si = math.sin(ai)\n    cj = math.cos(aj)\n    sj = math.sin(aj)\n    ck = math.cos(ak)\n    sk = math.sin(ak)\n    cc = ci*ck\n    cs = ci*sk\n    sc = si*ck\n    ss = si*sk\n\n    q = numpy.empty((4, ))\n    if repetition:\n        q[0] = cj*(cc - ss)\n        q[i] = cj*(cs + sc)\n        q[j] = sj*(cc + ss)\n        q[k] = sj*(cs - sc)\n    else:\n        q[0] = cj*cc + sj*ss\n        q[i] = cj*sc - sj*cs\n        q[j] = cj*ss + sj*cc\n        q[k] = cj*cs - sj*sc\n    if parity:\n        q[j] *= -1.0\n\n    return q\n\n\ndef quaternion_about_axis(angle, axis):\n    """"""Return quaternion for rotation about axis.\n\n    >>> q = quaternion_about_axis(0.123, [1, 0, 0])\n    >>> numpy.allclose(q, [0.99810947, 0.06146124, 0, 0])\n    True\n\n    """"""\n    q = numpy.array([0.0, axis[0], axis[1], axis[2]])\n    qlen = vector_norm(q)\n    if qlen > _EPS:\n        q *= math.sin(angle/2.0) / qlen\n    q[0] = math.cos(angle/2.0)\n    return q\n\n\ndef quaternion_matrix(quaternion):\n    """"""Return homogeneous rotation matrix from quaternion.\n\n    >>> M = quaternion_matrix([0.99810947, 0.06146124, 0, 0])\n    >>> numpy.allclose(M, rotation_matrix(0.123, [1, 0, 0]))\n    True\n    >>> M = quaternion_matrix([1, 0, 0, 0])\n    >>> numpy.allclose(M, numpy.identity(4))\n    True\n    >>> M = quaternion_matrix([0, 1, 0, 0])\n    >>> numpy.allclose(M, numpy.diag([1, -1, -1, 1]))\n    True\n\n    """"""\n    q = numpy.array(quaternion, dtype=numpy.float64, copy=True)\n    n = numpy.dot(q, q)\n    if n < _EPS:\n        return numpy.identity(4)\n    q *= math.sqrt(2.0 / n)\n    q = numpy.outer(q, q)\n    return numpy.array([\n        [1.0-q[2, 2]-q[3, 3],     q[1, 2]-q[3, 0],     q[1, 3]+q[2, 0], 0.0],\n        [    q[1, 2]+q[3, 0], 1.0-q[1, 1]-q[3, 3],     q[2, 3]-q[1, 0], 0.0],\n        [    q[1, 3]-q[2, 0],     q[2, 3]+q[1, 0], 1.0-q[1, 1]-q[2, 2], 0.0],\n        [                0.0,                 0.0,                 0.0, 1.0]])\n\n\ndef quaternion_from_matrix(matrix, isprecise=False):\n    """"""Return quaternion from rotation matrix.\n\n    If isprecise is True, the input matrix is assumed to be a precise rotation\n    matrix and a faster algorithm is used.\n\n    >>> q = quaternion_from_matrix(numpy.identity(4), True)\n    >>> numpy.allclose(q, [1, 0, 0, 0])\n    True\n    >>> q = quaternion_from_matrix(numpy.diag([1, -1, -1, 1]))\n    >>> numpy.allclose(q, [0, 1, 0, 0]) or numpy.allclose(q, [0, -1, 0, 0])\n    True\n    >>> R = rotation_matrix(0.123, (1, 2, 3))\n    >>> q = quaternion_from_matrix(R, True)\n    >>> numpy.allclose(q, [0.9981095, 0.0164262, 0.0328524, 0.0492786])\n    True\n    >>> R = [[-0.545, 0.797, 0.260, 0], [0.733, 0.603, -0.313, 0],\n    ...      [-0.407, 0.021, -0.913, 0], [0, 0, 0, 1]]\n    >>> q = quaternion_from_matrix(R)\n    >>> numpy.allclose(q, [0.19069, 0.43736, 0.87485, -0.083611])\n    True\n    >>> R = [[0.395, 0.362, 0.843, 0], [-0.626, 0.796, -0.056, 0],\n    ...      [-0.677, -0.498, 0.529, 0], [0, 0, 0, 1]]\n    >>> q = quaternion_from_matrix(R)\n    >>> numpy.allclose(q, [0.82336615, -0.13610694, 0.46344705, -0.29792603])\n    True\n    >>> R = random_rotation_matrix()\n    >>> q = quaternion_from_matrix(R)\n    >>> is_same_transform(R, quaternion_matrix(q))\n    True\n    >>> R = euler_matrix(0.0, 0.0, numpy.pi/2.0)\n    >>> numpy.allclose(quaternion_from_matrix(R, isprecise=False),\n    ...                quaternion_from_matrix(R, isprecise=True))\n    True\n\n    """"""\n    M = numpy.array(matrix, dtype=numpy.float64, copy=False)[:4, :4]\n    if isprecise:\n        q = numpy.empty((4, ))\n        t = numpy.trace(M)\n        if t > M[3, 3]:\n            q[0] = t\n            q[3] = M[1, 0] - M[0, 1]\n            q[2] = M[0, 2] - M[2, 0]\n            q[1] = M[2, 1] - M[1, 2]\n        else:\n            i, j, k = 1, 2, 3\n            if M[1, 1] > M[0, 0]:\n                i, j, k = 2, 3, 1\n            if M[2, 2] > M[i, i]:\n                i, j, k = 3, 1, 2\n            t = M[i, i] - (M[j, j] + M[k, k]) + M[3, 3]\n            q[i] = t\n            q[j] = M[i, j] + M[j, i]\n            q[k] = M[k, i] + M[i, k]\n            q[3] = M[k, j] - M[j, k]\n        q *= 0.5 / math.sqrt(t * M[3, 3])\n    else:\n        m00 = M[0, 0]\n        m01 = M[0, 1]\n        m02 = M[0, 2]\n        m10 = M[1, 0]\n        m11 = M[1, 1]\n        m12 = M[1, 2]\n        m20 = M[2, 0]\n        m21 = M[2, 1]\n        m22 = M[2, 2]\n        # symmetric matrix K\n        K = numpy.array([[m00-m11-m22, 0.0,         0.0,         0.0],\n                         [m01+m10,     m11-m00-m22, 0.0,         0.0],\n                         [m02+m20,     m12+m21,     m22-m00-m11, 0.0],\n                         [m21-m12,     m02-m20,     m10-m01,     m00+m11+m22]])\n        K /= 3.0\n        # quaternion is eigenvector of K that corresponds to largest eigenvalue\n        w, V = numpy.linalg.eigh(K)\n        q = V[[3, 0, 1, 2], numpy.argmax(w)]\n    if q[0] < 0.0:\n        numpy.negative(q, q)\n    return q\n\n\ndef quaternion_multiply(quaternion1, quaternion0):\n    """"""Return multiplication of two quaternions.\n\n    >>> q = quaternion_multiply([4, 1, -2, 3], [8, -5, 6, 7])\n    >>> numpy.allclose(q, [28, -44, -14, 48])\n    True\n\n    """"""\n    w0, x0, y0, z0 = quaternion0\n    w1, x1, y1, z1 = quaternion1\n    return numpy.array([-x1*x0 - y1*y0 - z1*z0 + w1*w0,\n                         x1*w0 + y1*z0 - z1*y0 + w1*x0,\n                        -x1*z0 + y1*w0 + z1*x0 + w1*y0,\n                         x1*y0 - y1*x0 + z1*w0 + w1*z0], dtype=numpy.float64)\n\n\ndef quaternion_conjugate(quaternion):\n    """"""Return conjugate of quaternion.\n\n    >>> q0 = random_quaternion()\n    >>> q1 = quaternion_conjugate(q0)\n    >>> q1[0] == q0[0] and all(q1[1:] == -q0[1:])\n    True\n\n    """"""\n    q = numpy.array(quaternion, dtype=numpy.float64, copy=True)\n    numpy.negative(q[1:], q[1:])\n    return q\n\n\ndef quaternion_inverse(quaternion):\n    """"""Return inverse of quaternion.\n\n    >>> q0 = random_quaternion()\n    >>> q1 = quaternion_inverse(q0)\n    >>> numpy.allclose(quaternion_multiply(q0, q1), [1, 0, 0, 0])\n    True\n\n    """"""\n    q = numpy.array(quaternion, dtype=numpy.float64, copy=True)\n    numpy.negative(q[1:], q[1:])\n    return q / numpy.dot(q, q)\n\n\ndef quaternion_real(quaternion):\n    """"""Return real part of quaternion.\n\n    >>> quaternion_real([3, 0, 1, 2])\n    3.0\n\n    """"""\n    return float(quaternion[0])\n\n\ndef quaternion_imag(quaternion):\n    """"""Return imaginary part of quaternion.\n\n    >>> quaternion_imag([3, 0, 1, 2])\n    array([ 0.,  1.,  2.])\n\n    """"""\n    return numpy.array(quaternion[1:4], dtype=numpy.float64, copy=True)\n\n\ndef quaternion_slerp(quat0, quat1, fraction, spin=0, shortestpath=True):\n    """"""Return spherical linear interpolation between two quaternions.\n\n    >>> q0 = random_quaternion()\n    >>> q1 = random_quaternion()\n    >>> q = quaternion_slerp(q0, q1, 0)\n    >>> numpy.allclose(q, q0)\n    True\n    >>> q = quaternion_slerp(q0, q1, 1, 1)\n    >>> numpy.allclose(q, q1)\n    True\n    >>> q = quaternion_slerp(q0, q1, 0.5)\n    >>> angle = math.acos(numpy.dot(q0, q))\n    >>> numpy.allclose(2, math.acos(numpy.dot(q0, q1)) / angle) or \\\n        numpy.allclose(2, math.acos(-numpy.dot(q0, q1)) / angle)\n    True\n\n    """"""\n    q0 = unit_vector(quat0[:4])\n    q1 = unit_vector(quat1[:4])\n    if fraction == 0.0:\n        return q0\n    elif fraction == 1.0:\n        return q1\n    d = numpy.dot(q0, q1)\n    if abs(abs(d) - 1.0) < _EPS:\n        return q0\n    if shortestpath and d < 0.0:\n        # invert rotation\n        d = -d\n        numpy.negative(q1, q1)\n    angle = math.acos(d) + spin * math.pi\n    if abs(angle) < _EPS:\n        return q0\n    isin = 1.0 / math.sin(angle)\n    q0 *= math.sin((1.0 - fraction) * angle) * isin\n    q1 *= math.sin(fraction * angle) * isin\n    q0 += q1\n    return q0\n\n\ndef random_quaternion(rand=None):\n    """"""Return uniform random unit quaternion.\n\n    rand: array like or None\n        Three independent random variables that are uniformly distributed\n        between 0 and 1.\n\n    >>> q = random_quaternion()\n    >>> numpy.allclose(1, vector_norm(q))\n    True\n    >>> q = random_quaternion(numpy.random.random(3))\n    >>> len(q.shape), q.shape[0]==4\n    (1, True)\n\n    """"""\n    if rand is None:\n        rand = numpy.random.rand(3)\n    else:\n        assert len(rand) == 3\n    r1 = numpy.sqrt(1.0 - rand[0])\n    r2 = numpy.sqrt(rand[0])\n    pi2 = math.pi * 2.0\n    t1 = pi2 * rand[1]\n    t2 = pi2 * rand[2]\n    return numpy.array([numpy.cos(t2)*r2, numpy.sin(t1)*r1,\n                        numpy.cos(t1)*r1, numpy.sin(t2)*r2])\n\n\ndef random_rotation_matrix(rand=None):\n    """"""Return uniform random rotation matrix.\n\n    rand: array like\n        Three independent random variables that are uniformly distributed\n        between 0 and 1 for each returned quaternion.\n\n    >>> R = random_rotation_matrix()\n    >>> numpy.allclose(numpy.dot(R.T, R), numpy.identity(4))\n    True\n\n    """"""\n    return quaternion_matrix(random_quaternion(rand))\n\n\nclass Arcball(object):\n    """"""Virtual Trackball Control.\n\n    >>> ball = Arcball()\n    >>> ball = Arcball(initial=numpy.identity(4))\n    >>> ball.place([320, 320], 320)\n    >>> ball.down([500, 250])\n    >>> ball.drag([475, 275])\n    >>> R = ball.matrix()\n    >>> numpy.allclose(numpy.sum(R), 3.90583455)\n    True\n    >>> ball = Arcball(initial=[1, 0, 0, 0])\n    >>> ball.place([320, 320], 320)\n    >>> ball.setaxes([1, 1, 0], [-1, 1, 0])\n    >>> ball.constrain = True\n    >>> ball.down([400, 200])\n    >>> ball.drag([200, 400])\n    >>> R = ball.matrix()\n    >>> numpy.allclose(numpy.sum(R), 0.2055924)\n    True\n    >>> ball.next()\n\n    """"""\n    def __init__(self, initial=None):\n        """"""Initialize virtual trackball control.\n\n        initial : quaternion or rotation matrix\n\n        """"""\n        self._axis = None\n        self._axes = None\n        self._radius = 1.0\n        self._center = [0.0, 0.0]\n        self._vdown = numpy.array([0.0, 0.0, 1.0])\n        self._constrain = False\n        if initial is None:\n            self._qdown = numpy.array([1.0, 0.0, 0.0, 0.0])\n        else:\n            initial = numpy.array(initial, dtype=numpy.float64)\n            if initial.shape == (4, 4):\n                self._qdown = quaternion_from_matrix(initial)\n            elif initial.shape == (4, ):\n                initial /= vector_norm(initial)\n                self._qdown = initial\n            else:\n                raise ValueError(""initial not a quaternion or matrix"")\n        self._qnow = self._qpre = self._qdown\n\n    def place(self, center, radius):\n        """"""Place Arcball, e.g. when window size changes.\n\n        center : sequence[2]\n            Window coordinates of trackball center.\n        radius : float\n            Radius of trackball in window coordinates.\n\n        """"""\n        self._radius = float(radius)\n        self._center[0] = center[0]\n        self._center[1] = center[1]\n\n    def setaxes(self, *axes):\n        """"""Set axes to constrain rotations.""""""\n        if axes is None:\n            self._axes = None\n        else:\n            self._axes = [unit_vector(axis) for axis in axes]\n\n    @property\n    def constrain(self):\n        """"""Return state of constrain to axis mode.""""""\n        return self._constrain\n\n    @constrain.setter\n    def constrain(self, value):\n        """"""Set state of constrain to axis mode.""""""\n        self._constrain = bool(value)\n\n    def down(self, point):\n        """"""Set initial cursor window coordinates and pick constrain-axis.""""""\n        self._vdown = arcball_map_to_sphere(point, self._center, self._radius)\n        self._qdown = self._qpre = self._qnow\n        if self._constrain and self._axes is not None:\n            self._axis = arcball_nearest_axis(self._vdown, self._axes)\n            self._vdown = arcball_constrain_to_axis(self._vdown, self._axis)\n        else:\n            self._axis = None\n\n    def drag(self, point):\n        """"""Update current cursor window coordinates.""""""\n        vnow = arcball_map_to_sphere(point, self._center, self._radius)\n        if self._axis is not None:\n            vnow = arcball_constrain_to_axis(vnow, self._axis)\n        self._qpre = self._qnow\n        t = numpy.cross(self._vdown, vnow)\n        if numpy.dot(t, t) < _EPS:\n            self._qnow = self._qdown\n        else:\n            q = [numpy.dot(self._vdown, vnow), t[0], t[1], t[2]]\n            self._qnow = quaternion_multiply(q, self._qdown)\n\n    def next(self, acceleration=0.0):\n        """"""Continue rotation in direction of last drag.""""""\n        q = quaternion_slerp(self._qpre, self._qnow, 2.0+acceleration, False)\n        self._qpre, self._qnow = self._qnow, q\n\n    def matrix(self):\n        """"""Return homogeneous rotation matrix.""""""\n        return quaternion_matrix(self._qnow)\n\n\ndef arcball_map_to_sphere(point, center, radius):\n    """"""Return unit sphere coordinates from window coordinates.""""""\n    v0 = (point[0] - center[0]) / radius\n    v1 = (center[1] - point[1]) / radius\n    n = v0*v0 + v1*v1\n    if n > 1.0:\n        # position outside of sphere\n        n = math.sqrt(n)\n        return numpy.array([v0/n, v1/n, 0.0])\n    else:\n        return numpy.array([v0, v1, math.sqrt(1.0 - n)])\n\n\ndef arcball_constrain_to_axis(point, axis):\n    """"""Return sphere point perpendicular to axis.""""""\n    v = numpy.array(point, dtype=numpy.float64, copy=True)\n    a = numpy.array(axis, dtype=numpy.float64, copy=True)\n    v -= a * numpy.dot(a, v)  # on plane\n    n = vector_norm(v)\n    if n > _EPS:\n        if v[2] < 0.0:\n            numpy.negative(v, v)\n        v /= n\n        return v\n    if a[2] == 1.0:\n        return numpy.array([1.0, 0.0, 0.0])\n    return unit_vector([-a[1], a[0], 0.0])\n\n\ndef arcball_nearest_axis(point, axes):\n    """"""Return axis, which arc is nearest to point.""""""\n    point = numpy.array(point, dtype=numpy.float64, copy=False)\n    nearest = None\n    mx = -1.0\n    for axis in axes:\n        t = numpy.dot(arcball_constrain_to_axis(point, axis), point)\n        if t > mx:\n            nearest = axis\n            mx = t\n    return nearest\n\n\n# epsilon for testing whether a number is close to zero\n_EPS = numpy.finfo(float).eps * 4.0\n\n# axis sequences for Euler angles\n_NEXT_AXIS = [1, 2, 0, 1]\n\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \'sxyz\': (0, 0, 0, 0), \'sxyx\': (0, 0, 1, 0), \'sxzy\': (0, 1, 0, 0),\n    \'sxzx\': (0, 1, 1, 0), \'syzx\': (1, 0, 0, 0), \'syzy\': (1, 0, 1, 0),\n    \'syxz\': (1, 1, 0, 0), \'syxy\': (1, 1, 1, 0), \'szxy\': (2, 0, 0, 0),\n    \'szxz\': (2, 0, 1, 0), \'szyx\': (2, 1, 0, 0), \'szyz\': (2, 1, 1, 0),\n    \'rzyx\': (0, 0, 0, 1), \'rxyx\': (0, 0, 1, 1), \'ryzx\': (0, 1, 0, 1),\n    \'rxzx\': (0, 1, 1, 1), \'rxzy\': (1, 0, 0, 1), \'ryzy\': (1, 0, 1, 1),\n    \'rzxy\': (1, 1, 0, 1), \'ryxy\': (1, 1, 1, 1), \'ryxz\': (2, 0, 0, 1),\n    \'rzxz\': (2, 0, 1, 1), \'rxyz\': (2, 1, 0, 1), \'rzyz\': (2, 1, 1, 1)}\n\n_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())\n\n\ndef vector_norm(data, axis=None, out=None):\n    """"""Return length, i.e. Euclidean norm, of ndarray along axis.\n\n    >>> v = numpy.random.random(3)\n    >>> n = vector_norm(v)\n    >>> numpy.allclose(n, numpy.linalg.norm(v))\n    True\n    >>> v = numpy.random.rand(6, 5, 3)\n    >>> n = vector_norm(v, axis=-1)\n    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2)))\n    True\n    >>> n = vector_norm(v, axis=1)\n    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))\n    True\n    >>> v = numpy.random.rand(5, 4, 3)\n    >>> n = numpy.empty((5, 3))\n    >>> vector_norm(v, axis=1, out=n)\n    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))\n    True\n    >>> vector_norm([])\n    0.0\n    >>> vector_norm([1])\n    1.0\n\n    """"""\n    data = numpy.array(data, dtype=numpy.float64, copy=True)\n    if out is None:\n        if data.ndim == 1:\n            return math.sqrt(numpy.dot(data, data))\n        data *= data\n        out = numpy.atleast_1d(numpy.sum(data, axis=axis))\n        numpy.sqrt(out, out)\n        return out\n    else:\n        data *= data\n        numpy.sum(data, axis=axis, out=out)\n        numpy.sqrt(out, out)\n\n\ndef unit_vector(data, axis=None, out=None):\n    """"""Return ndarray normalized by length, i.e. Euclidean norm, along axis.\n\n    >>> v0 = numpy.random.random(3)\n    >>> v1 = unit_vector(v0)\n    >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0))\n    True\n    >>> v0 = numpy.random.rand(5, 4, 3)\n    >>> v1 = unit_vector(v0, axis=-1)\n    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2)\n    >>> numpy.allclose(v1, v2)\n    True\n    >>> v1 = unit_vector(v0, axis=1)\n    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1)\n    >>> numpy.allclose(v1, v2)\n    True\n    >>> v1 = numpy.empty((5, 4, 3))\n    >>> unit_vector(v0, axis=1, out=v1)\n    >>> numpy.allclose(v1, v2)\n    True\n    >>> list(unit_vector([]))\n    []\n    >>> list(unit_vector([1]))\n    [1.0]\n\n    """"""\n    if out is None:\n        data = numpy.array(data, dtype=numpy.float64, copy=True)\n        if data.ndim == 1:\n            data /= math.sqrt(numpy.dot(data, data))\n            return data\n    else:\n        if out is not data:\n            out[:] = numpy.array(data, copy=False)\n        data = out\n    length = numpy.atleast_1d(numpy.sum(data*data, axis))\n    numpy.sqrt(length, length)\n    if axis is not None:\n        length = numpy.expand_dims(length, axis)\n    data /= length\n    if out is None:\n        return data\n\n\ndef random_vector(size):\n    """"""Return array of random doubles in the half-open interval [0.0, 1.0).\n\n    >>> v = random_vector(10000)\n    >>> numpy.all(v >= 0) and numpy.all(v < 1)\n    True\n    >>> v0 = random_vector(10)\n    >>> v1 = random_vector(10)\n    >>> numpy.any(v0 == v1)\n    False\n\n    """"""\n    return numpy.random.random(size)\n\n\ndef vector_product(v0, v1, axis=0):\n    """"""Return vector perpendicular to vectors.\n\n    >>> v = vector_product([2, 0, 0], [0, 3, 0])\n    >>> numpy.allclose(v, [0, 0, 6])\n    True\n    >>> v0 = [[2, 0, 0, 2], [0, 2, 0, 2], [0, 0, 2, 2]]\n    >>> v1 = [[3], [0], [0]]\n    >>> v = vector_product(v0, v1)\n    >>> numpy.allclose(v, [[0, 0, 0, 0], [0, 0, 6, 6], [0, -6, 0, -6]])\n    True\n    >>> v0 = [[2, 0, 0], [2, 0, 0], [0, 2, 0], [2, 0, 0]]\n    >>> v1 = [[0, 3, 0], [0, 0, 3], [0, 0, 3], [3, 3, 3]]\n    >>> v = vector_product(v0, v1, axis=1)\n    >>> numpy.allclose(v, [[0, 0, 6], [0, -6, 0], [6, 0, 0], [0, -6, 6]])\n    True\n\n    """"""\n    return numpy.cross(v0, v1, axis=axis)\n\n\ndef angle_between_vectors(v0, v1, directed=True, axis=0):\n    """"""Return angle between vectors.\n\n    If directed is False, the input vectors are interpreted as undirected axes,\n    i.e. the maximum angle is pi/2.\n\n    >>> a = angle_between_vectors([1, -2, 3], [-1, 2, -3])\n    >>> numpy.allclose(a, math.pi)\n    True\n    >>> a = angle_between_vectors([1, -2, 3], [-1, 2, -3], directed=False)\n    >>> numpy.allclose(a, 0)\n    True\n    >>> v0 = [[2, 0, 0, 2], [0, 2, 0, 2], [0, 0, 2, 2]]\n    >>> v1 = [[3], [0], [0]]\n    >>> a = angle_between_vectors(v0, v1)\n    >>> numpy.allclose(a, [0, 1.5708, 1.5708, 0.95532])\n    True\n    >>> v0 = [[2, 0, 0], [2, 0, 0], [0, 2, 0], [2, 0, 0]]\n    >>> v1 = [[0, 3, 0], [0, 0, 3], [0, 0, 3], [3, 3, 3]]\n    >>> a = angle_between_vectors(v0, v1, axis=1)\n    >>> numpy.allclose(a, [1.5708, 1.5708, 1.5708, 0.95532])\n    True\n\n    """"""\n    v0 = numpy.array(v0, dtype=numpy.float64, copy=False)\n    v1 = numpy.array(v1, dtype=numpy.float64, copy=False)\n    dot = numpy.sum(v0 * v1, axis=axis)\n    dot /= vector_norm(v0, axis=axis) * vector_norm(v1, axis=axis)\n    return numpy.arccos(dot if directed else numpy.fabs(dot))\n\n\ndef inverse_matrix(matrix):\n    """"""Return inverse of square transformation matrix.\n\n    >>> M0 = random_rotation_matrix()\n    >>> M1 = inverse_matrix(M0.T)\n    >>> numpy.allclose(M1, numpy.linalg.inv(M0.T))\n    True\n    >>> for size in range(1, 7):\n    ...     M0 = numpy.random.rand(size, size)\n    ...     M1 = inverse_matrix(M0)\n    ...     if not numpy.allclose(M1, numpy.linalg.inv(M0)): print(size)\n\n    """"""\n    return numpy.linalg.inv(matrix)\n\n\ndef concatenate_matrices(*matrices):\n    """"""Return concatenation of series of transformation matrices.\n\n    >>> M = numpy.random.rand(16).reshape((4, 4)) - 0.5\n    >>> numpy.allclose(M, concatenate_matrices(M))\n    True\n    >>> numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T))\n    True\n\n    """"""\n    M = numpy.identity(4)\n    for i in matrices:\n        M = numpy.dot(M, i)\n    return M\n\n\ndef is_same_transform(matrix0, matrix1):\n    """"""Return True if two matrices perform same transformation.\n\n    >>> is_same_transform(numpy.identity(4), numpy.identity(4))\n    True\n    >>> is_same_transform(numpy.identity(4), random_rotation_matrix())\n    False\n\n    """"""\n    matrix0 = numpy.array(matrix0, dtype=numpy.float64, copy=True)\n    matrix0 /= matrix0[3, 3]\n    matrix1 = numpy.array(matrix1, dtype=numpy.float64, copy=True)\n    matrix1 /= matrix1[3, 3]\n    return numpy.allclose(matrix0, matrix1)\n\n\ndef _import_module(name, package=None, warn=True, prefix=\'_py_\', ignore=\'_\'):\n    """"""Try import all public attributes from module into global namespace.\n\n    Existing attributes with name clashes are renamed with prefix.\n    Attributes starting with underscore are ignored by default.\n\n    Return True on successful import.\n\n    """"""\n    import warnings\n    from importlib import import_module\n    try:\n        if not package:\n            module = import_module(name)\n        else:\n            module = import_module(\'.\' + name, package=package)\n    except ImportError:\n        if warn:\n            warnings.warn(""failed to import module %s"" % name)\n    else:\n        for attr in dir(module):\n            if ignore and attr.startswith(ignore):\n                continue\n            if prefix:\n                if attr in globals():\n                    globals()[prefix + attr] = globals()[attr]\n                elif warn:\n                    warnings.warn(""no Python implementation of "" + attr)\n            globals()[attr] = getattr(module, attr)\n        return True\n\n\n_import_module(\'_transformations\')\n\nif __name__ == ""__main__"":\n    import doctest\n    import random  # used in doctests\n    numpy.set_printoptions(suppress=True, precision=5)\n    doctest.testmod()\n'"
nodes/bmesh/__init__.py,0,b''
nodes/bmesh/bm_info.py,3,"b'import numpy as np\n\nfrom svrx.typing import Float, Int, Vector, BMesh, Required, Vertices\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.function import std_wrap\n\n\n@node_func(bl_idname=\'SvRxNodeBMeshInfo\', multi_label=\'Bm info\', id=0)\ndef face_info(\n        bm: BMesh = Required\n             ) -> (\n        Float(""Area""),\n        Vertices(""Center median"")):\n    faces = np.array([f.calc_area() for f in bm.faces])\n    center = np.zeros((len(bm.faces), 4))\n    center[:, :3] = np.array([f.calc_center_median() for f in bm.faces])\n    return faces, center\n\n\n@node_func(id=1)\n@std_wrap\ndef volum(bm: BMesh = Required) -> Float(""Volume""):\n    return bm.calc_volume()\n'"
nodes/bmesh/generators.py,0,"b'import bmesh\n\nfrom svrx.typing import Float, Int, Vector, BMesh\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.function import generator\n\n@node_func(bl_idname=\'SvRxNodeBmeshGenerate\', multi_label=""Bmesh Gen"", id=0)\ndef create_monkey() -> BMesh:\n    bm = bmesh.new()\n    bmesh.ops.create_monkey(bm)\n    return bm\n\n\ndef make_icosphere(subdiv, diam):\n    bm = bmesh.new()\n    bmesh.ops.create_icosphere(bm, subdivisions=subdiv, diameter=diam, calc_uvs=False)\n    return bm\n\n@node_func(id=1)\n@generator\ndef create_icosphere(subdiv: Int(min=0, max=8) = 2, diam: Float = 1.0) -> [BMesh]:\n    return make_icosphere(min(subdiv, 8), diam)\n\n\n@node_func(id=2)\n@generator\ndef create_cube(size: Float = 1.0) -> [BMesh]:\n    bm = bmesh.new()\n    bmesh.ops.create_cube(bm, size=size)\n    return bm\n\n@node_func(id=3)\n@generator\ndef create_uvsphere(u: Int = 10, v: Int = 10, diameter: Float = 1.0) -> [BMesh]:\n    bm = bmesh.new()\n    bmesh.ops.create_uvsphere(bm, u_segments=u, v_segments=v, diameter=diameter)\n    return bm\n'"
nodes/bmesh/in_out.py,0,"b'import bmesh\n\nfrom svrx.typing import Float, Int, Vector, BMesh, Required, Vertices, Edges, Faces\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.mesh import bmesh_from_pydata, rxdata_from_bm\n\n\n@node_func(bl_idname=""SvRxNodeBMeshIn"")\ndef bmesh_in(verts: Vertices = Required,\n             edges: Edges = None,\n             faces: Faces = None) -> BMesh:\n    return bmesh_from_pydata(verts[:,:3].tolist(), edges, faces)\n\n@node_func(bl_idname=""SvRxNodeBMeshOut"")\ndef bmesh_out(bm: BMesh = Required) -> (Vertices, Edges, Faces):\n    return rxdata_from_bm(bm)\n'"
nodes/bmesh/modifiers.py,0,"b""import bmesh\n\nfrom svrx.typing import Float, Int, Vector, BMesh, Required\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.function import generator\n\n\n@node_func(bl_idname='SvRxNodeBmeshModifiers', multi_label='Bmesh modifiers', id=0)\n@generator\ndef wireframe(bm: BMesh = Required, t: Float = 0.01) -> [BMesh]:\n    bm = bm.copy()\n    bmesh.ops.wireframe(\n        bm, faces=bm.faces[:],\n        thickness=t,\n        offset=True,\n        use_replace=True,\n        use_boundary=True,\n        use_even_offset=True,\n        use_relative_offset=True)\n    return bm\n\n\n@node_func(id=1)\n@generator\ndef solidify(bm: BMesh = Required, thickness: Float = 1.0) -> [BMesh]:\n    bm = bm.copy()\n    geom_in = bm.verts[:] + bm.edges[:] + bm.faces[:]\n    bmesh.ops.solidify(bm, geom=geom_in, thickness=thickness)\n    return bm\n\n\n@node_func(id=2)\ndef recalc_normals(bm: BMesh = Required) -> BMesh:\n    bm = bm.copy()\n    bmesh.ops.recalc_face_normals(bm, faces=bm.faces[:])\n\n\n@node_func(id=3)\ndef update_normals(bm: BMesh = Required) -> BMesh:\n    bm = bm.copy()\n    bm.normal_update()\n    return bm\n"""
nodes/debug/__init__.py,0,b''
nodes/debug/debugprint.py,0,"b'from svrx.nodes.node_base import node_func\n\nfrom svrx.typing import Anytype\n\n\n@node_func(bl_idname=""SvRxNodeDebugPrint"")\ndef debug_print(data: Anytype = None):\n    print(""start debug_print"")\n    print(data)\n    print(""finish debug_print"")\n'"
nodes/generator/__init__.py,0,b''
nodes/generator/circle.py,0,"b'\nfrom svrx.nodes.node_base import node_func\nfrom svrx.typing import Int, Float, Vertices, Edges, Faces\n\nfrom svrx.util.geom import circle\nfrom svrx.util.function import generator\n\n\n@node_func(bl_idname=""SvRxNodeCircle"", label=""Circle"")\n@generator\ndef circle_(nr_verts: Int = 24,\n            radius: Float = 1.0\n            ) -> ([Vertices],\n                  [Edges],\n                  [Faces]):\n    return circle(radius, 0, nr_verts)\n'"
nodes/generator/cylinder.py,15,"b'from svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Int, Vertices, Edges, Faces, BoolP\n\nimport numpy as np\nfrom svrx.util.function import generator\nfrom svrx.util.smesh import SvPolygon\nfrom svrx.util.topology import cylinder_edges, cylinder_faces\nfrom svrx.util.function import array_as\n\n\n@node_func(bl_idname=""SvRxNodeGenCylinder"", multi_label=""Cylinder"", id=0)\n@generator\ndef cylinder(r_top: Float = 1.0,\n             r_bot: Float = 1.0,\n             h: Float = 10,\n             verts: Int =20,\n             rings: Int = 10,\n             caps: BoolP = False) -> ([Vertices], [Edges], [Faces]):\n    z = np.zeros((rings, 4))\n    z[:, 2] = np.linspace(0, h, rings)\n    scale = np.linspace(r_bot, r_top, rings)\n    t = np.linspace(0, np.pi * 2 * (verts - 1 / verts), verts)\n    circle = np.array([np.cos(t), np.sin(t), np.zeros(verts), np.ones(verts)]).T\n    cylinder = np.empty((rings, verts, 4))\n    cylinder[:] = z[:, np.newaxis, :] + circle\n    cylinder[:, :, :2] *= scale[:, np.newaxis, np.newaxis]\n    cylinder.shape = (-1, 4)\n    return cylinder, cylinder_edges(rings, verts), cylinder_faces(rings, verts, caps)\n\n\n@node_func(id=1, label=""Scale control"")\n@generator\ndef cylinder(xy_scale: Float(iterable=False) = 1.0,\n             z_scale: Float(iterable=False) = 1.0,\n             verts: Int = 20,\n             rings: Int = 10,\n             caps: BoolP = False) -> ([Vertices], [Edges], [Faces]):\n    z = np.zeros((rings, 4))\n    if len(z_scale) == 1:\n        z[:, 2] = np.linspace(0, z_scale[0] * rings, rings)\n    else:\n        z[:, 2] = array_as(z_scale, (rings,))\n    xy_scale = array_as(xy_scale, (rings,))\n    t = np.linspace(0, np.pi * 2 * (verts - 1 / verts), verts)\n    circle = np.array([np.cos(t), np.sin(t), np.zeros(verts), np.ones(verts)]).T\n    cylinder = np.empty((rings, verts, 4))\n    cylinder[:] = z[:, np.newaxis, :] + circle\n    cylinder[:, :, :2] *= xy_scale[:, np.newaxis, np.newaxis]\n    cylinder.shape = (-1, 4)\n    return cylinder, cylinder_edges(rings, verts), cylinder_faces(rings, verts, caps)\n'"
nodes/generator/plane.py,6,"b'from svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Int, Vertices, Edges, Faces\n\nimport numpy as np\nfrom svrx.util.function import generator\nfrom svrx.util.topology import plane_edges, plane_faces\n\ndef plane_verts(t_x, t_y):\n    """"""\n    make plane from grid in x coord and y coord\n    """"""\n    verts = np.empty((t_y.size, t_x.size, 4))\n    x_l, y_l = np.meshgrid(t_x, t_y)\n    verts[:,:,0] = x_l\n    verts[:,:,1] = y_l\n    verts[:,:,2] = 0\n    verts[:,:,3] = 1\n    verts.shape = (-1, 4)\n    return verts\n\n@node_func(bl_idname=""SvRxNodeGenPlane"", multi_label=""Plane"", id=0)\n@generator\ndef grid(x: Int = 10,\n         y: Int = 10,\n         size: Float = 10) -> ([Vertices], [Edges], [Faces]):\n    t_x = np.linspace(-size, size, x)\n    t_y = np.linspace(-size, size, y)\n    return plane_verts(t_x, t_y), plane_edges(x, y), plane_faces(y, x)\n\n\n@node_func(bl_idname=""SvRxNodeGenPlane"", multi_label=""Plane"", id=1)\n@generator\ndef plane(x: Int = 10,\n          y: Int = 10,\n          step_x: Float = 1.0,\n          step_y: Float = 1.0) -> ([Vertices], [Edges], [Faces]):\n    t_x = np.linspace(0, (x - 1) * step_x, x)\n    t_y = np.linspace(0, (y - 1) * step_y, y)\n    return plane_verts(t_x, t_y), plane_edges(x, y), plane_faces(y, x)\n'"
nodes/generator/topology.py,12,"b'import numpy as np\n\nfrom svrx.typing import Vertices, Edges, Faces, Required\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.smesh import SvPolygon\nfrom svrx.util.topology import (plane_edges, plane_faces,\n                                cylinder_edges, cylinder_faces,\n                                torus_edges, torus_faces)\n\n\n@node_func(bl_idname=""SvRxNodeGeneratorTopology"", multi_label=""Topology"", id=0)\ndef line(verts: Vertices = Required) -> (Vertices, Edges, Faces):\n    count = len(verts)\n    edges = np.array([np.arange(0, count - 1), np.arange(1, count)]).T\n    return verts, edges, None\n\n\n@node_func(id=1)\ndef cirle(verts: Vertices = Required) -> (Vertices, Edges, Faces):\n    count = len(verts)\n    edges = np.array([np.arange(0, count), np.arange(1, count + 1) % count], dtype=np.uint32).T\n    faces = SvPolygon(np.array([0], dtype=np.uint32),\n                      np.array([verts], dtype=np.uint32),\n                      np.arange(0, verts, dtype=np.uint32))\n    return verts, edges, faces\n\n\n@node_func(id=2)\ndef plane(verts: [Vertices] = Required) -> (Vertices, Edges, Faces):\n    vertices = np.concatenate(verts)\n    y = len(verts)\n    x = len(verts[0])\n    edges = plane_edges(x, y)\n    faces = plane_faces(x, y)\n    return vertices, edges, faces\n\n\n@node_func(id=3)\ndef cylinder(verts: [Vertices] = Required) -> (Vertices, Edges, Faces):\n    vertices = np.concatenate(verts)\n    height = len(verts)\n    vert_count = len(verts[0])\n    edges = cylinder_edges(height, vert_count)\n    faces = cylinder_faces(height, vert_count, False)\n    return vertices, edges, faces\n\n\n@node_func(id=4)\ndef line_connect(verts: [Vertices] = Required) -> (Vertices, Edges, Faces):\n    vertices = np.concatenate(verts)\n    count = len(verts[0])\n    obj_count = len(verts)\n    e_start = np.arange(0, obj_count * count - count)\n    e_stop = np.arange(count, obj_count * count)\n    edges = np.array((e_start, e_stop)).T\n    return vertices, edges, None\n\n\n@node_func(id=5)\ndef torus(verts: [Vertices] = Required) -> (Vertices, Edges, Faces):\n    vertices = np.concatenate(verts)\n    height = len(verts)\n    vert_count = len(verts[0])\n    edges = torus_edges(height, vert_count)\n    faces = torus_faces(height, vert_count)\n    return vertices, edges, faces\n'"
nodes/generator/torus.py,9,"b'from svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Int, Vertices, Edges, Faces\n\nimport numpy as np\nfrom svrx.util.function import generator\nfrom svrx.util.smesh import SvPolygon\nfrom svrx.util.topology import torus_edges, torus_faces\n\n\ndef make_torus(R, r, N1, N2):\n    z = np.zeros((N2, 4))\n    t_r = np.linspace(0, np.pi *2 * (N2-1/N2), N2)\n    z[:,2] = np.cos(t_r) *r\n    scale = np.sin(t_r) *r + R\n    t_R = np.linspace(0, np.pi * 2 * (N1 - 1 / N1), N1)\n    circle = np.array([np.cos(t_R), np.sin(t_R), np.zeros(N1), np.ones(N1)]).T\n    torus = np.empty((N2, N1, 4))\n    torus[:] = z[:, np.newaxis, :] + circle\n    torus[:,:,:2] *= scale[:,np.newaxis,np.newaxis]\n    torus.shape = (-1, 4)\n    return torus\n\n@node_func(bl_idname=""SvRxNodeGenTorus"", multi_label=""Torus"", id=0)\n@generator\ndef torus(\n    R: Float = 2.0, r: Float = 0.6,\n    N1: Int = 22, N2: Int = 15) -> ([Vertices], [Edges], [Faces]):\n    return make_torus(R, r, N1, N2), torus_edges(N2, N1), torus_faces(N2, N1)\n'"
nodes/input/__init__.py,0,b''
nodes/input/object.py,0,"b'\nfrom svrx.typing import Vertices, Edges, Object, Faces\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.smesh import SMesh\n\n\n@node_func(bl_idname=""SvRxNodeInObject"")\ndef object_in(obj: Object = None) -> (Vertices, Edges, Faces):\n    if obj and obj.type == \'MESH\':\n        sm = SMesh.from_mesh(obj.data)\n        return sm.as_pydata()\n    else:\n        return None, None, None\n'"
nodes/input/value.py,5,"b'import numpy as np\n\nimport bpy\n\nfrom svrx.typing import IntValue, FloatValue, PointValue, ColorValue, ObjectValue, Int\nfrom svrx.nodes.node_base import stateful, node_func\nfrom svrx.nodes.classes import NodeBase\n\n\nclass NodeFrameInfo(NodeBase):\n\n    def draw_buttons(self, context, layout):\n        row = layout.row()\n        scene = context.scene\n        screen = context.screen\n        """"""\n        box = row.box()\n        box.prop(scene, ""frame_start"")\n        box.prop(scene, ""frame_end"")\n        """"""\n        row.prop(scene, ""frame_current"", text="""")\n        if not screen.is_animation_playing:\n            row.operator(""screen.animation_play"", text="""", icon=\'PLAY\')\n        else:\n            row.operator(""screen.animation_play"", text="""", icon=\'PAUSE\')\n\n\nclass ValueNodeCommon:\n    def __init__(self, node=None):\n        if node and node.outputs:\n            self.value = node.outputs[0].default_value\n        else:\n            self.value = None\n\n\n@node_func(bl_idname=""SvRxNodeFrameChange"", cls_bases=(NodeFrameInfo,))\ndef frame_change() -> (Int(""Current""), Int(""Frame Start""), Int(""Frame End"")):\n    scene = bpy.context.scene\n    current = scene.frame_current\n    start = scene.frame_start\n    end = scene.frame_end\n    return np.atleast_1d(current), np.atleast_1d(start), np.atleast_1d(end)\n\n\n@stateful\nclass IntNode(ValueNodeCommon):\n    bl_idname = ""SvRxNodeIntValue""\n    label = ""Int input""\n\n    def __call__(self) -> IntValue(""i""):\n        return np.array([self.value])\n\n\n@stateful\nclass FloatNode(ValueNodeCommon):\n    bl_idname = ""SvRxNodeFloatValue""\n    label = ""Float input""\n\n    def __call__(self) -> FloatValue(""f""):\n        return np.array([self.value])\n\n\n@stateful\nclass PointValue(ValueNodeCommon):\n    bl_idname = ""SvRxNodePointValue""\n    label = ""Point input""\n\n    def __call__(self) -> PointValue(""p""):\n        return np.array(self.value)\n\n\n@stateful\nclass ColorValue(ValueNodeCommon):\n    bl_idname = ""SvRxNodeColorValue""\n    label = ""Color input""\n\n    def __call__(self) -> ColorValue(""c""):\n        return np.array(self.value)\n\n\n@stateful\nclass ObjectValue(ValueNodeCommon):\n    bl_idname = ""SvRxNodeObjectValue""\n    label = ""Object input""\n\n    def __call__(self) -> ObjectValue(""o""):\n        return bpy.data.objects.get(self.value)\n'"
nodes/list/__init__.py,0,b''
nodes/list/info.py,0,"b'from svrx.typing import Anytype, Int, Float\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.function import std_wrap\n\nimport numpy as np\n\n\n\n@node_func(bl_idname=""SvRxNodeListInfo"", multi_label=""List info"", id=0)\n@std_wrap\ndef length(data: Anytype = None) -> Int(""Length""):\n    if data.size > 1:\n        return data.shape[0]\n    else:\n        return data.size\n\n@node_func(bl_idname=""SvRxNodeListInfo"", id=1)\n@std_wrap\ndef min_(data: Anytype = None) -> Float(""Min""):\n    return data.min()\n\n\n@node_func(bl_idname=""SvRxNodeListInfo"", id=2)\n@std_wrap\ndef max_(data: Anytype = None) -> Float(""Max""):\n    return data.max()\n\n@node_func(bl_idname=""SvRxNodeListInfo"", id=3)\n@std_wrap\ndef sum_(data: Anytype = None) -> Float(""Sum""):\n    return data.sum()\n\n@node_func(bl_idname=""SvRxNodeListInfo"", id=4)\n@std_wrap\ndef mean_(data: Anytype = None) -> Float(""Mean""):\n    return data.mean()\n'"
nodes/list/join.py,4,"b'\nimport numpy as np\nimport bpy\n\n\nfrom svrx.typing import Anytype, Int, Vertices, BoolP\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.nodes.classes import MultiInputNode\n\nfrom svrx.util.function import make_compatible\n\n\n@node_func(bl_idname=""SvRxNodeListJoin"")\ndef join(data: [Anytype] = None) -> Anytype(""Data""):\n    return np.concatenate(data)\n\n\n""""""\nclass MergeNode(MultiInputNode):\n    socket_type = bpy.props.StringProperty(default=Vertices.bl_idname)\n    socket_base_name = bpy.props.StringProperty(default=""Vert data {}"")\n@node_func(bl_idname=""SvRxNodeListMerge"", cls_bases = (MergeNode,))\ndef merge(*vert_data: Vertices) -> Vertices:\n#    return np.concatenate(vert_data)\n""""""\n\n\n@node_func(bl_idname=""SvRxNodeListMerge"")\ndef merge(a: Vertices = None,\n          b: Vertices = None,\n          mix: BoolP(description=""interleave"") = False) -> Vertices:\n    if a is None:\n        return b\n    if b is None:\n        return a\n    if mix:\n        a, b = make_compatible(a, b, broadcast=False)\n        new_l = len(a) + len(b)\n        out = np.empty((new_l, 4))\n        out[::2] = a\n        out[1::2] = b\n        return out\n    else:\n        return np.concatenate((a, b))\n'"
nodes/list/repeat.py,2,"b'import numpy as np\nfrom svrx.nodes.classes import NodeMathBase\nfrom svrx.nodes.node_base import node_func\nfrom svrx.typing import Number, Int\nfrom svrx.util.function import generator\n\n\n@node_func(bl_idname=\'SvRxNodeListRepeat\', multi_label=""Repeat"", id=0, cls_bases=(NodeMathBase,))\n@generator\ndef np_repeat(Values: Number(iterable=False) = 0.0, Repeat: Int = 2) -> [Number]:\n    return np.repeat(Values, Repeat)\n\n\n@node_func(id=1)\n@generator\ndef np_tile(Values: Number(iterable=False) = 0.0, Repeat: Int = 2) -> [Number]:\n    return np.tile(Values, Repeat)\n'"
nodes/list/split.py,1,"b'from svrx.typing import Anytype, Int, Required\n\nfrom svrx.nodes.node_base import node_func\n\nimport numpy as np\n\n\n\n@node_func(bl_idname=""SvRxNodeListSplit"")\ndef split(size: Int = 1, data: Anytype = Required) -> [Anytype(""Data"")]:\n    if size.size == 1:\n        s = range(size[0], data.shape[0], size[0])\n    else:\n        s = size\n    return np.split(data, s)\n'"
nodes/matrix/__init__.py,0,b''
nodes/matrix/create.py,3,"b'import math\nimport numpy as np\nimport mathutils\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.transforms import translation_matrix, concatenate_matrices, scale_matrix\nfrom svrx.util.function import generator\n\n\nfrom svrx.typing import Vector, Float, Matrix\n\n\n@node_func(bl_idname=""SvRxNodeCreateMatrix"")\n@generator\ndef create_matrix(location: Vector = (0.0, 0.0, 0.0, 1.0),\n                  scale: Vector = (1.0, 1.0, 1.0, 0.0),\n                  rotation: Vector = (0.0, 0.0, 1.0, 0.0),\n                  angle: Float = 0.0\n                  ) -> [Matrix]:\n\n    #t = translation_matrix(location)\n    s = np.identity(4)\n    for i in range(3):\n        s[i,i] = scale[i]\n        s[i, 3] = location[i]\n    r = rotation_matrix(math.radians(angle), rotation)\n    return s.dot(r)\n\n\ndef rotation_matrix(theta, axis):\n    """"""\n    Return the rotation matrix associated with counterclockwise rotation about\n    the given axis by theta radians.\n    Adapted from\n    http://stackoverflow.com/questions/6802577/python-rotation-of-3d-vector\n    """"""\n    axis = axis[:3]\n    axis = axis/math.sqrt(np.dot(axis, axis))\n    a = math.cos(theta/2.0)\n    b, c, d = -axis*math.sin(theta/2.0)\n    aa, bb, cc, dd = a*a, b*b, c*c, d*d\n    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d\n    return np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac), 0],\n                     [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab), 0],\n                     [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc, 0],\n                     [0,         0,         0,           1]])\n'"
nodes/matrix/transform.py,0,"b'from svrx.typing import Matrix, Vertices, Required\nfrom svrx.nodes.node_base import node_func\n\nimport numpy as np\n\n\n@node_func(bl_idname=""SvRxNodeMatrixTransform"")\ndef transform(vertices: Vertices = Required,\n              matrix: Matrix = Matrix.identity\n              ) -> Vertices:\n    if matrix is None:\n        return vertices\n    else:\n        return vertices.dot(matrix.T)\n'"
nodes/number/__init__.py,0,b''
nodes/number/logic.py,5,"b'import numpy as np\n\nfrom svrx.util.function import constant\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.nodes.classes import NodeMathBase\n\nfrom svrx.typing import Number, Bool\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', multi_label=\'Logic\', id=0,  cls_bases=(NodeMathBase,))\ndef equal(x: Number = 0, y: Number= 0) -> Bool:\n    return x == y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=2)\ndef is_close(x: Number = 0, y: Number= 0) -> Bool:\n    return np.isclose(x, y)\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=3)\ndef not_equal(x: Number = 0, y: Number = 0) -> Bool:\n    return x != y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=4)\ndef less_than(x: Number = 0, y: Number = 0) -> Bool:\n    return x < y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=5)\ndef bigger_than(x: Number = 0, y: Number = 0) -> Bool:\n    return x > y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=6)\ndef less_eq(x: Number = 0, y: Number = 0) -> Bool:\n    return x <= y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=7)\ndef bigger_eq(x: Number = 0, y: Number = 0) -> Bool:\n    return x >= y\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=10)\n@constant\ndef true() -> Bool:\n    return False\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=11)\n@constant\ndef false() -> Bool:\n    return False\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=20)\ndef and_(a: Bool = True, b: Bool = False) -> Bool:\n    return np.logical_and(a, b)\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=21)\ndef or_(a: Bool = True, b: Bool = False) -> Bool:\n    return np.logical_or(a, b)\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=22)\ndef not_(a: Bool = True) -> Bool:\n    return np.logical_not(a)\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=23)\ndef xor_(a: Bool = True, b: Bool = False) -> Bool:\n    return np.logical_xor(a, b)\n\n\n@node_func(bl_idname=\'SvRxNodeLogic\', id=24)\ndef bool_(a: Bool = True) -> Bool:\n    return a.astype(dtype=bool)\n\n\n""""""\nTODO\n    mode_items = [\n\n        (""NAND"",            ""Nand"",         """", 5),\n        (""NOR"",             ""Nor"",          """", 6),\n        (""XNOR"",            ""Xnor"",         """", 8),\n""""""\n'"
nodes/number/mask.py,4,"b'\nimport numpy as np\n\nfrom svrx.typing import Bool, Number, Required\nfrom svrx.nodes.node_base import node_func\n\n\ndef array_as_cycle(a, shape):\n    if a.shape == shape:\n        return a\n    new_a = np.empty(shape, dtype=a.dtype)\n    for i in range(shape[0]):\n        new_a[i] = a[i % len(a)]\n    return new_a\n\n@node_func(bl_idname=""SvRxNodeMask"")\ndef mask(mask: Bool = True, data: Number = Required\n         ) -> (\n         Bool(""Mask""),\n         Number(""Data True""),\n         Number(""Data False"")):\n    real_mask = array_as_cycle(mask, data.shape)\n    return real_mask, data[real_mask], data[np.logical_not(real_mask)]\n\n\n@node_func(bl_idname=\'SvRxNodeMaskJoin\')\ndef mask_join(mask: Bool = True,\n              data_true: Number = Required,\n              data_false: Number = Required\n              ) -> Number(""data""):\n    data = np.empty(mask.shape, dtype=data_true.dtype)\n    data[mask] = data_true\n    data[np.logical_not(mask)] = data_false\n    return data\n'"
nodes/number/math.py,16,"b'import numpy as np\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.nodes.classes import NodeMathBase\n\nfrom svrx.typing import Number, Float, Int\nfrom svrx.util.function import constant\n\n# pylint: disable=C0326\n# pylint: disable=W0622\n\n@node_func(bl_idname=\'SvRxNodeMath\', multi_label=""Math"", id=0, cls_bases=(NodeMathBase,))\ndef add(x: Number = 0.0, y: Number = 1.0) -> Number:\n    return x + y\n\n@node_func(id=1)\ndef sub(x: Number = 0.0, y: Number = 1.0) -> Number:\n    return x - y\n\n@node_func(id=2)\ndef mul(x: Number = 0.0, y: Number = 2.0) -> Number:\n    return x * y\n\n@node_func(id=3)\ndef div(x: Number = 1.0, y: Number = 2.0) -> Number:\n    return x / y\n\n@node_func(id=4)\ndef sqrt(x: Number = 1.0) -> Number:\n    return np.sqrt(x)\n\n@node_func(id=5)\ndef copy_sign(x: Number = 1.0, y: Number = -1.0) -> Number:\n    return np.copysign(x, y)\n\n@node_func(id=6)\ndef absolute(x: Number = -1.0) -> Number:\n    return np.absolute(x)\n\n@node_func(id=9)\ndef reciprocal(x: Number = 1.0) -> Number:\n    # numpy.reciprocal  is not designed to work with integers.\n    return 1 / x\n\n@node_func(id=10)\ndef negate(x: Number = 0.0) -> Number:\n    return -x\n\n@node_func(id=15)\ndef as_int(x: Number = 0.0) -> Int:\n    return x.astype(int)\n\n@node_func(id=16)\ndef int_div(x1: Number = 1.0, x2: Number = 2.0) -> Int:\n    return np.floor_divide(x1, x2)\n\n@node_func(id=17)\ndef round_n(x: Number = 0.0, y: Int = 0) -> Float:\n    return x.round(y)\n\n@node_func(id=18)\ndef modulo(x1: Number = 1.0, x2: Number = 1.0) -> Float:\n    return np.mod(x1, x2)\n\n@node_func(id=19)\ndef fmodulo(x1: Number = 1.0, x2: Number = 1.0) -> Float:\n    return np.fmod(x1, x2)\n\n@node_func(id=20)\ndef ceil(x: Number = 1.0) -> Float:\n    return np.ceil(x)\n\n@node_func(id=21)\ndef floor(x: Number = 1.5) -> Float:\n    return np.floor(x)\n\n@node_func(id=22)\ndef pow(x: Number = 1.0, y: Number = 2.0) -> Number:\n    return np.power(x, y)\n\n@node_func(id=24)\ndef exp(x: Number = 1.0) -> Number:\n    return np.exp(x)\n\n@node_func(id=25)\ndef ln(x: Number = 1.0) -> Number:\n    return np.log(x)\n\n@node_func(id=26)\ndef log10(x: Number = 1.0) -> Number:\n    return np.log10(x)\n\n@node_func(id=27)\ndef logn(x1: Number = 1.0, x2: Number = 2.0) -> Number:\n    return np.logn(x1, x2)\n\n\n# each element individually compared returns smallest\n@node_func(id=30)\ndef minimum(x1: Number = 1.0, x2: Number = -1.0) -> Number:\n    return np.minimum(x1, x2)\n\n# each element individually compared returns largest\n@node_func(id=31)\ndef maximum(x1: Number = 1.0, x2: Number = -1.0) -> Number:\n    return np.maximum(x1, x2)\n\n\n\n\n@node_func(id=61)\n@constant\ndef e() -> Float:\n    return np.e\n'"
nodes/number/random.py,6,"b'import numpy as np\n\nfrom svrx.typing import Float, Int\nfrom svrx.nodes.node_base import node_func\n\nfrom svrx.util.function import generator\n\n\n@node_func(bl_idname=""SvRxNodeNumberRandom"", multi_label=""Random"", id=0)\n@generator\ndef random_int(size: Int = 1, low: Int = 0, high: Int = 10, seed: Int = 1) -> [Int]:\n    """"""Return random integers from low (inclusive) to high (inclusive)\n    """"""\n    np.random.seed(seed)\n    return np.random.random_integers(low, high, size)\n\n\n@node_func(id=1)\n@generator\ndef randint(size: Int = 1, low: Int = 0, high: Int = 10, seed: Int = 1) -> [Int]:\n    """"""Return random integers from low (inclusive) to high (exclusive)\n    """"""\n    np.random.seed(seed)\n    return np.random.randint(low, high, size)\n\n\n@node_func(id=2)\n@generator\ndef random_float(size: Int = 1, low: Float = 0.0, high: Float = 1.0, seed: Int = 1) -> [Float]:\n    np.random.seed(seed)\n    #  here we could be clever and only scale if needed.\n    return (high - low) * np.random.random_sample(size) + low\n'"
nodes/number/range_float.py,3,"b'import numpy as np\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Int, BoolP\nfrom svrx.util.function import generator\n\n\n@node_func(bl_idname=""SvRxNodeNumberFloat"", multi_label=\'Range Float\', id=0)\n@generator\ndef space(start: Float = 0.0,\n          stop: Float = 1.0,\n          count: Int(min=1) = 10,\n          endpoint: BoolP(name=\'End point\',\n                          description=\'Last point is stop\') = True\n          ) -> [Float]:\n    return np.linspace(start, stop, count, endpoint=endpoint)\n\n\n@node_func(id=1)\n@generator\ndef range_(start: Float = 0.0,\n           stop: Float = 1.0,\n           step: Float = 0.1,\n           ) -> [Float]:\n    if stop < start:\n        step = np.copysign(step, -1)\n    return np.arange(start, stop, step)\n\n\n@node_func(id=2)\n@generator\ndef step(start: Float = 0.0,\n         step: Float = 1.0,\n         count: Int(min=1) = 10,\n         ) -> [Float]:\n    return range_(start, step * count + start, step)\n'"
nodes/number/range_int.py,2,"b'import numpy as np\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.util.function import generator\nfrom svrx.typing import Int\n\n# pylint: disable=C0326\n# pylint: disable=W0622\n# pylint: disable=W0621\n\n\n@node_func(bl_idname=\'SvRxNodeNumberRangeInt\', multi_label=""Range Int"", id=0)\n@generator\ndef range(start: Int = 0, step: Int = 1, stop: Int = 10) -> [Int]:\n    if start == stop:\n        return []\n    step = max(step, 1)\n    if stop < start:\n        step *= -1\n    return np.arange(start, stop, step)\n\n\n@node_func(id=1)\n@generator\ndef count(start: Int = 0, step: Int = 1, count: Int(min=0) = 10) -> [Int]:\n    count = max(count, 0)\n    if count == 0:\n        return []\n    stop = (count*step) + start\n    return np.arange(start, stop, step)\n'"
nodes/number/trig.py,17,"b'import numpy as np\n\nfrom svrx.nodes.node_base import node_func\nfrom svrx.nodes.classes import NodeMathBase\nfrom svrx.typing import Number, Float\n\n\n# pylint: disable=C0326\n\'\'\'\n-  SINE     / COSINE     / SIN(x), COS(x)\n-  DEGREES  / RADIANS    / TANGENT\n-  ARCSINE  / ARCCOSINE  / ARCTANGENT\n-  ACOSH    / ASINH      / ATANH\n-  COSH     / SINH       / TANH\n  ----- divider ----\n-  PI * N, where N defaults to 1.0 or 2.0\n-  PHI * N\n-  TAU * N\n\'\'\'\n\n\n@node_func(bl_idname=""SvRxNodeTrig"",\n           multi_label=""Trigonometey"",\n           id=0, cls_bases=(NodeMathBase,))\ndef sine(x: Number = 0.0) -> Number:\n    return np.sin(x)\n\n\n@node_func(id=1)\ndef cosine(x: Number = 0.0) -> Number:\n    return np.cos(x)\n\n\n@node_func(id=2)\ndef sincos(x: Number = 0.0) -> (Number(""sin""), Number(""cos"")):\n    return np.sin(x), np.cos(x)\n\n\n@node_func(id=3)\ndef degrees(x: Number = 0.0) -> Number:\n    return np.degrees(x)\n\n\n@node_func(id=4)\ndef radians(x: Number = 0.0) -> Number:\n    return np.radians(x)\n\n\n@node_func(id=20)\ndef tangent(x: Number = 0.0) -> Number:\n    return np.tan(x)\n\n\n@node_func(id=30)\ndef arcsine(x: Number = 0.0) -> Number:\n    return np.asin(x)\n\n\n@node_func(id=31)\ndef arcosine(x: Number = 0.0) -> Number:\n    return np.acos(x)\n\n\n@node_func(id=32)\ndef arctangent(x: Number = 0.0) -> Number:\n    return np.atan(x)\n\n\n@node_func(id=40)\ndef asinh(x: Number = 0.0) -> Number:\n    return np.asinh(x)\n\n\n@node_func(id=41)\ndef acosh(x: Number = 0.0) -> Number:\n    return np.acosh(x)\n\n\n@node_func(id=42)\ndef atanh(x: Number = 0.0) -> Number:\n    return np.atanh(x)\n\n\n@node_func(id=50)\ndef sinh(x: Number = 0.0) -> Number:\n    return np.sinh(x)\n\n\n@node_func(id=51)\ndef cosh(x: Number = 0.0) -> Number:\n    return np.cosh(x)\n\n\n@node_func(id=52)\ndef tanh(x: Number = 0.0) -> Number:\n    return np.tanh(x)\n\n\n#  Constants times input n\n\n\n@node_func(id=60)\ndef pi(n: Number = 2.0) -> Number:\n    return np.pi * n\n\n\n@node_func(id=61)\ndef tau(n: Number = 1.0) -> Number:\n    return np.pi * n * 2\n\n\nPHI = ((1 + 5 ** 0.5) / 2)\n\n\n@node_func(id=62)\ndef phi(n: Number = 1.0) -> Number:\n    return PHI * n\n'"
nodes/output/__init__.py,0,b''
nodes/output/index_view.py,0,"b'import math\nfrom collections import namedtuple\n\nimport bgl\nimport blf\n\nimport bpy\nimport bmesh\nimport time\n\nfrom mathutils import Matrix as bMatrix\nfrom mathutils import Vector as bVector\n\nfrom svrx.nodes.node_base import stateful\nfrom svrx.nodes.classes import NodeID, NodeStateful\nfrom svrx.util import bgl_callback_3dview as bgl_callback\nfrom svrx.typing import Required, BoolP, ColorAP, BMesh, Matrix\n\n\n# pylint: disable=C0326\n# pylint: disable=C0330\n\npoint_dict = {}\n\n\ndef NOT_IMPLEMENTED_YET_identity_epsilon(matrix):\n    #  reduces all values below threshold (+ or -) to 0.0, to avoid meaningless\n    #  wandering floats.\n    # coord_strip = lambda c: 0.0 if (-1.6e-5 <= c <= 1.6e-5) else c\n    # san = lambda v: Vector((coord_strip(c) for c in v[:]))\n    # return Matrix([san(v) for v in matrix]) == Matrix()\n    return False\n\n\ndef adjust_list(in_list, x, y):\n    return [[old_x + x, old_y + y] for (old_x, old_y) in in_list]\n\n\ndef generate_points(width, height):\n    amp = 5  # radius fillet\n\n    width += 2\n    height += 4\n    width = ((width/2) - amp) + 2\n    height -= (2*amp)\n\n    pos_list, final_list = [], []\n\n    n_points = 12\n    seg_angle = 2 * math.pi / n_points\n    for i in range(n_points + 1):\n        angle = i * seg_angle\n        x = math.cos(angle) * amp\n        y = math.sin(angle) * amp\n        pos_list.append([x, -y])\n\n    w_list, h_list = [1, -1, -1, 1], [-1, -1, 1, 1]\n    slice_list = [[i, i+4] for i in range(0, n_points, 3)]\n\n    for idx, (start, end) in enumerate(slice_list):\n        point_array = pos_list[start:end]\n        w = width * w_list[idx]\n        h = height * h_list[idx]\n        final_list += adjust_list(point_array, w, h)\n\n    return final_list\n\n\ndef get_points(index):\n    \'\'\'\n    index:   string representation of the index number\n    returns: rounded rect point_list used for background.\n    the neat thing about this is if a width has been calculated once, it\n    is stored in a dict and used if another polygon is saught with that width.\n    \'\'\'\n    width, height = blf.dimensions(0, index)\n    if not (width in point_dict):\n        point_dict[width] = generate_points(width, height)\n\n    return point_dict[width]\n\n\ndef draw_index_viz(context, args):\n\n    fx = args.fx\n    region = context.region\n    region3d = context.space_data.region_3d\n\n    # vars for projection\n    perspective_matrix = region3d.perspective_matrix.copy()\n\n    font_id = 0\n    text_height = 13\n    blf.size(font_id, text_height, 72)  # should check prefs.dpi\n\n    region_mid_width = region.width / 2.0\n    region_mid_height = region.height / 2.0\n\n    def draw_index(rgb, rgb2, index, vec):\n\n        vec_4d = perspective_matrix * vec.to_4d()\n        if vec_4d.w <= 0.0:\n            return\n\n        x = region_mid_width + region_mid_width * (vec_4d.x / vec_4d.w)\n        y = region_mid_height + region_mid_height * (vec_4d.y / vec_4d.w)\n        index = str(index)\n\n        \'\'\' draw polygon if requested\'\'\'\n        if fx.draw_bg:\n            polyline = get_points(index)\n\n            bgl.glColor4f(*rgb2)\n            bgl.glBegin(bgl.GL_POLYGON)\n            for pointx, pointy in polyline:\n                bgl.glVertex2f(pointx+x, pointy+y)\n            bgl.glEnd()\n\n        \'\'\' draw text \'\'\'\n        txt_width, txt_height = blf.dimensions(0, index)\n        bgl.glColor4f(*rgb)\n        blf.position(0, x - (txt_width / 2), y - (txt_height / 2), 0)\n        blf.draw(0, index)\n\n    for instructions in args.data.vert_indices:\n        for instruct in instructions:\n            draw_index(fx.vert_idx_color, fx.vert_bg_color, *instruct)\n\n    for instructions in args.data.edge_indices:\n        for instruct in instructions:\n            draw_index(fx.edge_idx_color, fx.edge_bg_color, *instruct)\n\n    for instructions in args.data.face_indices:\n        for instruct in instructions:\n            draw_index(fx.face_idx_color, fx.face_bg_color, *instruct)\n\n\n\nclass NodeIndexView(NodeID, NodeStateful):\n\n    def draw_buttons(self, context, layout):\n        view_icon = \'RESTRICT_VIEW_\' + (\'OFF\' if self.activate else \'ON\')\n\n        column_all = layout.column()\n\n        row = column_all.row(align=True)\n        split = row.split()\n        r = split.column()\n        r.prop(self, ""activate"", text=""Show"", toggle=True, icon=view_icon)\n        row.prop(self, ""draw_bg"", text=""Background"", toggle=True)\n\n        col = column_all.column(align=True)\n        row = col.row(align=True)\n        row.prop(self, ""display_vert_index"", toggle=True, icon=\'VERTEXSEL\', text=\'\')\n        row.prop(self, ""vert_idx_color"", text="""")\n        if self.draw_bg:\n            row.prop(self, ""vert_bg_color"", text="""")\n\n        row = col.row(align=True)\n        row.prop(self, ""display_edge_index"", toggle=True, icon=\'EDGESEL\', text=\'\')\n        row.prop(self, ""edge_idx_color"", text="""")\n        if self.draw_bg:\n            row.prop(self, ""edge_bg_color"", text="""")\n\n        row = col.row(align=True)\n        row.prop(self, ""display_face_index"", toggle=True, icon=\'FACESEL\', text=\'\')\n        row.prop(self, ""face_idx_color"", text="""")\n        if self.draw_bg:\n            row.prop(self, ""face_bg_color"", text="""")\n\n\n    def free(self):\n        bgl_callback.callback_disable(self.node_id)\n\n\n\n@stateful\nclass SvRxIndexView():\n\n    bl_idname = ""SvRxNodeIndexView""\n    label = ""Index View""\n    cls_bases = (NodeIndexView,)\n\n    properties = {\n        \'activate\': BoolP(name=\'activate\', default=True),\n        \'draw_bg\': BoolP(name=\'draw bg\', default=False),\n        ""vert_idx_color"": ColorAP(default=(1., 1., 1., 1.)),\n        ""edge_idx_color"": ColorAP(default=(1., 1., .1, 1.)),\n        ""face_idx_color"": ColorAP(default=(1., .8, .8, 1.)),\n        ""vert_bg_color"": ColorAP(default=(.2, .2, .2, 1.)),\n        ""edge_bg_color"": ColorAP(default=(.2, .2, .2, 1.)),\n        ""face_bg_color"": ColorAP(default=(.2, .2, .2, 1.)),\n        ""display_vert_index"": BoolP(name=\'show_verts\', default=True),\n        ""display_edge_index"": BoolP(name=\'show_edges\', default=True),\n        ""display_face_index"": BoolP(name=\'show_faces\', default=True)\n    }\n\n    def __init__(self, node=None):\n        if node is not None:\n            self.node = node\n            self.activate = node.activate\n            self.n_id = node.node_id\n\n    def start(self):\n        self.bms = []\n        self.mats = []\n\n\n    @property\n    def get_fx(self):\n        params = self.properties.keys()\n\n        fx = namedtuple(\'fx\', params)\n        for param_name in params:\n            param_value = getattr(self.node, param_name)\n            if not isinstance(param_value, (bool, )):\n                param_value = getattr(self.node, param_name)[:]\n            setattr(fx, param_name, param_value)\n        return fx\n\n\n    @property\n    def get_data(self):\n        vert_indices = []\n        face_indices = []\n        edge_indices = []\n        vert_indices_add = vert_indices.append\n        face_indices_add = face_indices.append\n        edge_indices_add = edge_indices.append\n\n        for obj_index, (bm, matrix) in enumerate(zip(self.bms, self.mats)):\n\n            # yes ultra lazy, but think of it like this.. we never use idx viewer to see tonnes of indices\n            # we should offer an index mask\n\n            if not matrix is None and not NOT_IMPLEMENTED_YET_identity_epsilon(matrix):\n                bmat = bMatrix(matrix)\n                bm2 = bm.copy()\n                bmesh.ops.transform(bm2, verts=bm2.verts, matrix=bmat)\n                final_verts = bm2.verts\n                final_edges = bm2.edges\n                final_faces = bm2.faces\n                final_verts.ensure_lookup_table()\n            else:\n                final_verts = bm.verts\n                final_edges = bm.edges\n                final_faces = bm.faces\n\n            VI = []\n            add_vert_instruct = VI.append\n            if self.node.display_vert_index:\n                for idx, v in enumerate(final_verts):\n                    add_vert_instruct([idx, v.co])\n                vert_indices_add(VI)\n\n            EI = []\n            add_edge_instruct = EI.append\n            if bm.edges and self.node.display_edge_index:\n                for edge_index, (idx1, idx2) in enumerate([e.verts[0].index, e.verts[1].index] for e in final_edges):\n                    v1 = final_verts[idx1].co\n                    v2 = final_verts[idx2].co\n                    loc = v1 + ((v2 - v1) / 2)\n                    add_edge_instruct([edge_index, loc])\n                edge_indices_add(EI)\n\n            FI = []\n            add_face_instruct = FI.append\n            if bm.faces and self.node.display_face_index:\n                for face_index, f in enumerate(final_faces):\n                    median = f.calc_center_median()\n                    add_face_instruct([face_index, median])\n                face_indices_add(FI)\n\n        return type(\'\', (), {\'vert_indices\': vert_indices, \'edge_indices\': edge_indices, \'face_indices\': face_indices})\n\n    @property\n    def current_draw_data(self):\n        return {\n            \'tree_name\': self.node.id_data.name[:],\n            \'custom_function\': draw_index_viz,\n            \'args\': type(\'\', (), {\'fx\': self.get_fx, \'data\': self.get_data})\n        }\n\n\n    def stop(self):\n        bgl_callback.callback_disable(self.n_id)\n        if self.activate:\n            bgl_callback.callback_enable(self.n_id, self.current_draw_data, overlay=\'POST_PIXEL\')\n\n\n    def __call__(self, bm: BMesh = Required, matrix: Matrix = None):\n        self.bms.append(bm)\n        self.mats.append(matrix)\n'"
nodes/output/mesh_out.py,0,"b'import numpy as np\n\nimport bpy\nimport bmesh\n\nfrom svrx.nodes.node_base import stateful\nfrom svrx.typing import Vertices, Required, Faces, Edges, StringP, IntP, Matrix, BMesh\nfrom svrx.util.mesh import bmesh_from_pydata\n\n\n# pylint: disable=C0326\n\nclass Mesh_out_common:\n    def __init__(self, node=None):\n        if node:\n            self.base_name = node.mesh_name\n            self.max_mesh_count = node.max_mesh_count\n\n    def get_children(self, basename, kind=\'MESH\'):\n        """"""\n        This finds those objects that are associated with the basename provided by\n        the node\'s interface. kind can be MESH / CURVE\n        """"""\n        objects = bpy.data.objects\n        objs = [obj for obj in objects if obj.type == kind]\n        return [o for o in objs if o.get(\'basename\') == basename]\n\n\n    def remove_non_updated_objects(self, obj_index, kind=\'MESH\'):\n        """"""\n        This function removes those objects that the node no longer is asked to\n        update. This is necessary because a node can be asked to generate any\n        number of objects, and that number can fluctuate on consecutive updates.\n\n        """"""\n        objs = self.get_children(self.base_name, kind)\n        objs = [obj.name for obj in objs if obj[\'idx\'] > obj_index]\n        if not objs:\n            return\n\n        if kind == \'MESH\':\n            data_kind = bpy.data.meshes\n        elif kind == \'CURVE\':\n            data_kind = bpy.data.curves\n\n        objects = bpy.data.objects\n        scene = bpy.context.scene\n\n        # remove excess objects\n        for object_name in objs:\n            obj = objects[object_name]\n            obj.hide_select = False\n            scene.objects.unlink(obj)\n            objects.remove(obj, do_unlink=True)\n\n        # delete associated meshes\n        for object_name in objs:\n            data_kind.remove(data_kind[object_name])\n\n@stateful\nclass MeshOut(Mesh_out_common):\n\n    bl_idname = ""SvRxNodeMeshOut""\n    label = ""Mesh out""\n\n    properties = {\'mesh_name\': StringP(name=\'Mesh name\', default=""svrx_mesh""),\n                  \'max_mesh_count\': IntP(name=""Max count"", default=100)}\n\n    def start(self):\n        self.verts = []\n        self.edges = []\n        self.faces = []\n        self.mats = []\n\n    def stop(self):\n        obj_index = 0\n        #  using range to limit object number for now during testing\n        param = zip(range(self.max_mesh_count), self.verts, self.edges, self.faces, self.mats)\n        for idx, verts, edges, faces, mat in param:\n            obj_index = idx\n            bm = bmesh_from_pydata(verts[:, :3].tolist(), edges, faces, normal_update=False)\n            obj = make_bmesh_geometry(bm,\n                                      name=self.base_name,\n                                      idx=idx,)\n            if mat is not None:\n                obj.matrix_world = mat.T\n\n        # cleanup\n        self.remove_non_updated_objects(obj_index)\n\n\n    def __call__(self,\n                 verts: Vertices = Required,\n                 edges: Edges = None,\n                 faces: Faces = None,\n                 matrix: Matrix = None):\n        self.verts.append(verts)\n        self.edges.append(edges)\n        self.faces.append(faces)\n        self.mats.append(matrix)\n\n\n\n@stateful\nclass BMesh_out(Mesh_out_common):\n    bl_idname = ""SvRxNodeBmeshOut""\n    label = ""BMesh out""\n\n    properties = {\'mesh_name\': StringP(name=\'Mesh name\', default=""svrx_bm""),\n                  \'max_mesh_count\': IntP(name=""Max count"", default=100)}\n    def start(self):\n        self.meshes = []\n        self.mats = []\n\n    def __call__(self, bm: BMesh = Required, mat: Matrix = None):\n        self.meshes.append(bm.copy())\n        self.mats.append(mat)\n\n    def stop(self):\n        obj_index = 0\n        for idx, bm, mat in zip(range(self.max_mesh_count), self.meshes, self.mats):\n            obj_index = idx\n            obj = make_bmesh_geometry(bm, name=self.base_name, idx=idx, free=False)\n            if mat is not None:\n                obj.matrix_world = mat.T\n\n        self.remove_non_updated_objects(obj_index)\n\n\n@stateful\nclass RxMeshOut(Mesh_out_common):\n\n    bl_idname = ""SvRxNodeRxMeshOut""\n    label = ""RxMesh out""\n\n    properties = {\n        \'mesh_name\': StringP(name=\'Mesh name\', default=""svrx_mesh""),\n        \'max_mesh_count\': IntP(name=""Max count"", default=100)\n    }\n\n    def start(self):\n        self.verts = []\n        self.edges = []\n        self.faces = []\n        self.mats = []\n\n    def stop(self):\n        obj_index = 0\n\n        #  using range to limit object number for now during testing\n        param = zip(range(self.max_mesh_count), self.verts, self.edges, self.faces, self.mats)\n        for idx, verts, edges, faces, mat in param:\n\n            obj_index = idx\n\n            obj = get_obj_for(self.base_name, obj_index)\n            res = write_to_mesh(obj, verts, edges, faces)\n            obj.update_tag(refresh={\'OBJECT\', \'DATA\'})\n            obj.hide_select = False\n\n            if mat is not None:\n                obj.matrix_world = mat.T\n\n        # cleanup\n        self.remove_non_updated_objects(obj_index)\n\n\n    def __call__(self,\n                 verts: Vertices = Required,\n                 edges: Edges = None,\n                 faces: Faces = None,\n                 matrix: Matrix = None):\n        self.verts.append(verts)\n        self.edges.append(edges)\n        self.faces.append(faces)\n        self.mats.append(matrix)\n\n\ndef make_bmesh_geometry(bm, name=""svrx_mesh"", idx=0, free=True):\n    obj = get_obj_for(name, idx)\n\n    \'\'\' get bmesh, write bmesh to obj, free bmesh\'\'\'\n    bm.to_mesh(obj.data)\n    if free:\n        bm.free()\n\n    obj.update_tag(refresh={\'OBJECT\', \'DATA\'})\n    obj.hide_select = False\n    return obj\n\n\ndef get_obj_for(name=""svrx"", idx=0):\n    scene = bpy.context.scene\n    meshes = bpy.data.meshes\n    objects = bpy.data.objects\n\n    rx_name = name + ""."" + str(idx).zfill(4)\n\n    if rx_name in objects:\n        obj = objects[rx_name]\n    else:\n        # this is only executed once, upon the first run.\n        mesh = meshes.new(rx_name)\n        obj = objects.new(rx_name, mesh)\n        scene.objects.link(obj)\n\n        obj[\'idx\'] = idx\n        obj[\'basename\'] = name\n\n    # at this point the mesh is always fresh and empty\n\n    return obj\n\ndef write_to_mesh(obj, vertices, edges=None, faces=None):\n    mesh = obj.data\n    vert_diff = len(vertices) - len(mesh.vertices)\n    if edges is not None and faces is None:\n        edge_diff = len(edges) - len(mesh.edges)\n    elif faces is not None:\n        #   we have faces, edges will be updated using calc_edges\n        edge_diff = 0\n    else: #  no incoming faces or edges\n        edge_diff = - len(mesh.edges)\n\n    if faces is not None:\n        face_diff = len(faces) - len(mesh.polygons)\n        loop_diff = len(faces.vertex_indices) - len(mesh.loops)\n    else:\n        face_diff = -len(mesh.polygons)\n        loop_diff = -len(mesh.loops)\n    diffs = (vert_diff, edge_diff, face_diff, loop_diff)\n\n    if any(n < 0 for n in diffs):\n        print(""giving up fast path, bmesh it is"", diffs)\n        bm = bmesh_from_pydata(vertices[:, :3].tolist(), edges, faces, normal_update=False)\n        bm.to_mesh(mesh)\n        return True\n    elif any(n > 0 for n in diffs):\n        print(""adding vertices"")\n        mesh.vertices.add(vert_diff)\n        mesh.edges.add(edge_diff)\n        mesh.loops.add(loop_diff)\n        mesh.polygons.add(face_diff)\n\n    vert_out = vertices[:,:3].flatten()\n    #vert_out.shape = (3 * len(vert_out))\n    mesh.vertices.foreach_set(\'co\', vert_out)\n\n    if edges is not None:\n        edges.shape = -1\n        mesh.edges.foreach_set(\'vertices\', edges)\n        # temporary falten\n        edges.shape = (-1, 2)\n\n    if faces is not None:\n        mesh.polygons.foreach_set(""loop_total"", faces.loop_total)\n        mesh.polygons.foreach_set(""loop_start"", faces.loop_start)\n        mesh.loops.foreach_set(""vertex_index"", faces.vertex_indices)\n\n    if faces is not None and edges is None:\n        print(""updating edges"")\n        mesh.update(calc_edges=True)\n\n    fail = mesh.validate(verbose=False)\n    if not fail:\n        print(""managed to update mesh for: "", obj.name)\n    else:\n        print(""horrible failue for mesh for: "", obj.name)\n\n    return fail\n'"
nodes/output/stethoscope.py,0,"b'import textwrap\nimport pprint\n\nimport bgl\nimport blf\n\nimport bpy\nimport bmesh\n\nfrom svrx.nodes.node_base import stateful\nfrom svrx.nodes.classes import NodeID, NodeStateful\nfrom svrx.typing import Required, StringP, Anytype, BoolP\nfrom svrx.util import bgl_callback\n# pylint: disable=C0326\n\n\nclass NodeStethoscope(NodeID, NodeStateful):\n    def free(self):\n        bgl_callback.callback_disable(self.node_id)\n\n    def draw_buttons(self, context, layout):\n        row = layout.row()\n        row.prop(self, ""activate"")\n        row.prop(self, ""shape"")\n\ndef simple_grid_xy(x, y, args):\n    # func = args[0]\n    # back_color, grid_color, line_color = args[1]\n\n    def draw_rect(x=0, y=0, w=30, h=10, color=(0.0, 0.0, 0.0, 1.0)):\n\n        bgl.glColor4f(*color)\n        bgl.glBegin(bgl.GL_POLYGON)\n\n        for coord in [(x, y), (x+w, y), (w+x, y-h), (x, y-h)]:\n            bgl.glVertex2f(*coord)\n        bgl.glEnd()\n\n    # draw bg fill\n    draw_rect(x=x, y=y, w=140, h=140, color=(0.2, 0.7, 0.4, 1.0))\n\n\n@stateful\nclass SvRxStethoscope():\n\n    bl_idname = ""SvRxNodeStethoscope""\n    label = ""Stethoscope""\n    cls_bases = (NodeStethoscope,)\n\n    properties = {\n        \'activate\': BoolP(name=\'Activate\', default=True),\n        \'shape\': BoolP(name=""Shape"", default=True)\n    }\n\n    def __init__(self, node=None):\n        if node is not None:\n            self.node = node\n            self.activate = node.activate\n            self.shape = node.shape\n            self.n_id = node.node_id\n\n    @property\n    def xy_offset(self):\n        a = self.node.location[:]\n        b = int(self.node.width) + 20\n        return int(a[0] + b), int(a[1])\n\n    def stop(self):\n        bgl_callback.callback_disable(self.n_id)\n        if self.activate:\n            dt = self.node.inputs[0].data_tree\n            lines = [""total depth: {} object count: {}"".format(dt.level, dt.count()), """"]\n            structure = parse_tree(dt, self.shape)\n            lines.extend(pprint.pformat(structure).splitlines())\n            draw_data = {\n                \'tree_name\': self.node.id_data.name[:],\n                \'custom_function\': draw_text,\n                \'loc\': self.xy_offset,\n                \'args\': (lines,)\n            }\n            bgl_callback.callback_enable(self.n_id, draw_data)\n\n    def __call__(self, data: Anytype = Required):\n        pass\n\n\ndef draw_text(x, y, args):\n    lines = args[0]\n\n    x, y = int(x), int(y)\n    color = (0.9, 0.9, 0.9)\n    font_id = 0\n\n    text_height = 15\n    line_height = 14\n\n    # why does the text look so jagged?  <-- still valid question\n    # dpi = bpy.context.user_preferences.system.dpi\n    blf.size(font_id, int(text_height), 72)\n    ypos = y\n    xpos = x\n    h = 1.3 * line_height * (len(lines) + 1)\n    bgl.glColor3f(0.2,  0.2, 0.2)\n    bgl.glColor3f(*color)\n    for line in lines:\n        blf.position(0, xpos, ypos, 0)\n        blf.draw(font_id, line)\n        ypos -= int(line_height * 1.3)\n\n\ndef parse_tree(dt, shape=False):\n    if dt.level == 0:\n        if shape:\n            return dt.data.shape\n        else:\n            return dt.data\n    else:\n        out = []\n        for child in dt.children:\n            out.append(parse_tree(child, shape))\n        return out\n'"
nodes/output/viewer.py,1,"b'\nimport bgl\n\nfrom svrx.nodes.node_base import stateful\nfrom svrx.nodes.classes import NodeID, NodeStateful\nfrom svrx.typing import (Required, BoolP, ColorP,\n                         BMesh, Matrix, Vertices, Faces, Edges)\nfrom svrx.util import bgl_callback_3dview as bgl_callback\nimport itertools\nimport mathutils as mu\nimport bmesh\nimport numpy as np\n\nfrom svrx.util.mesh import bmesh_from_pydata\n\n\n_callback_cache = {}\n\n\nclass NodeView(NodeID, NodeStateful):\n\n    def draw_buttons(self, context, layout):\n        layout.prop(self, ""use_ops_trans"")\n        view_icon = \'RESTRICT_VIEW_\' + (\'OFF\' if self.activate else \'ON\')\n        layout.prop(self, ""activate"", text=""Show"", toggle=True, icon=view_icon)\n        col = layout.column()\n        row = col.row(align=True)\n        row.prop(self, ""display_vert"", toggle=True, icon=\'VERTEXSEL\', text=\'\')\n        row.prop(self, ""vert_color"", text="""")\n\n        row = col.row(align=True)\n        row.prop(self, ""display_edge"", toggle=True, icon=\'EDGESEL\', text=\'\')\n        row.prop(self, ""edge_color"", text="""")\n\n        row = col.row(align=True)\n        row.prop(self, ""display_face"", toggle=True, icon=\'FACESEL\', text=\'\')\n        row.prop(self, ""face_color"", text="""")\n\n\n\n    def free(self):\n        bgl_callback.callback_disable(self.node_id)\n\n\ndef draw_bmesh(context, args):\n    """"""Draw mesh from formatted data\n\n    Better passing of arguments\n    Display list/vertex buffer\n    """"""\n    obj_list = args[0]\n    face_list = args[1]\n    col_list = args[2]\n    edg_list = args[3]\n    edge_col, vert_col = args[4]\n\n    for verts, vert_index, colors, edges in zip(obj_list, face_list, col_list, edg_list):\n        if vert_index:\n            bgl.glBegin(bgl.GL_TRIANGLES)\n            for idx in range(0, len(vert_index), 3):\n                p0 = verts[vert_index[idx]]\n                p1 = verts[vert_index[idx + 1]]\n                p2 = verts[vert_index[idx + 2]]\n                bgl.glColor3f(*colors[idx//3])\n                bgl.glVertex3f(*p0)\n                bgl.glVertex3f(*p1)\n                bgl.glVertex3f(*p2)\n            bgl.glEnd()\n        if vert_col:\n            bgl.glBegin(bgl.GL_POINTS)\n            bgl.glColor3f(*vert_col)\n            for vert in verts:\n                bgl.glVertex3f(*vert)\n            bgl.glEnd()\n        if edge_col:\n            bgl.glBegin(bgl.GL_LINES)\n            bgl.glColor3f(*edge_col)\n            for x, y in edges:\n                bgl.glVertex3f(*verts[x])\n                bgl.glVertex3f(*verts[y])\n            bgl.glEnd()\n\n\n@stateful\nclass BMViewNode():\n\n    bl_idname = ""SvRxNodeBMViewGL""\n    label = ""View bm GL""\n    cls_bases = (NodeView,)\n\n    properties = {\n        \'activate\': BoolP(name=\'activate\', default=True),\n        ""vert_color"": ColorP(default=(1., 1., 1.)),\n        ""edge_color"": ColorP(default=(1., 1., .1)),\n        ""face_color"": ColorP(default=(1., .8, .8)),\n        ""display_vert"": BoolP(name=\'show_verts\', default=True),\n        ""display_edge"": BoolP(name=\'show_edges\', default=True),\n        ""display_face"": BoolP(name=\'show_faces\', default=True),\n        ""use_ops_trans"": BoolP(default=False)\n    }\n\n    def __init__(self, node=None):\n        if node is not None:\n            self.node = node\n            self.activate = node.activate\n            self.n_id = node.node_id\n\n    def start(self):\n        self.vertices = []\n        self.faces = []\n        self.colors = []\n        self.edges = []\n\n    @property\n    def current_draw_data(self):\n        args = (self.vertices, self.faces, self.colors, self.edges,\n                (self.node.edge_color[:] if self.node.display_edge else None,\n                 self.node.vert_color[:] if self.node.display_vert else None))\n        return {\n            \'tree_name\': self.node.id_data.name[:],\n            \'custom_function\': draw_bmesh,\n            \'args\': args\n        }\n\n    def stop(self):\n        bgl_callback.callback_disable(self.n_id)\n        _callback_cache.pop(self.n_id, None)\n        if self.activate:\n            draw_data = self.current_draw_data\n            _callback_cache[self.n_id] = draw_data\n            bgl_callback.callback_enable(self.n_id, draw_data, overlay=""POST_VIEW"")\n\n    def __call__(self, bm: BMesh = Required,\n                 mat: Matrix = None):\n        color = self.node.face_color[:]\n        if mat is not None:\n            if self.node.use_ops_trans:\n                bm = bm.copy()\n                matrix = mu.Matrix(mat)\n                bmesh.ops.transform(bm, matrix=matrix, verts=bm.verts)\n                verts = [v.co[:] for v in bm.verts]\n                bm.normal_update()\n                normals = [f.normal[:] for f in bm.faces]\n            else:\n                matrix = mu.Matrix(mat)\n                verts = [matrix * v.co for v in bm.verts]\n                bm.normal_update()\n                mat33 = matrix.to_3x3()\n                normals = [(mat33 * f.normal)[:] for f in bm.faces]\n        else:\n            verts = [v.co[:] for v in bm.verts]\n            bm.normal_update()\n            normals = [f.normal[:] for f in bm.faces]\n\n        tess_faces = bm.calc_tessface()\n        vert_index = [l.vert.index for l in itertools.chain(*bm.calc_tessface())]\n\n        face_index = [t_f[0].face.index for t_f in tess_faces]\n        edges_index = [(e.verts[0].index, e.verts[1].index) for e in bm.edges]\n        colors = []\n        for idx in face_index:\n            normal = mu.Vector(normals[idx])\n            normal_nu = normal.angle((0, 0, 1), 0) / np.pi\n            r = (normal_nu * color[0]) + 0.1\n            g = (normal_nu * color[1]) + 0.1\n            b = (normal_nu * color[2]) + 0.1\n            colors.append((r, g, b))\n\n        self.vertices.append(verts)\n        self.faces.append(vert_index if self.node.display_face else [])\n        self.colors.append(colors)\n        self.edges.append(edges_index)\n\n\n@stateful\nclass ViewNode(BMViewNode):\n    bl_idname = ""SvRxNodeRxViewGL""\n    label = \'Viewer Rx GL\'\n\n    def __call__(self,\n                 verts: Vertices = Required,\n                 edges: Edges = None,\n                 faces: Faces = None,\n                 mat: Matrix = None):\n        bm = bmesh_from_pydata(verts[:, :3].tolist(), edges, faces)\n        super().__call__(bm, mat)\n'"
nodes/script/__init__.py,0,b''
nodes/vertex/__init__.py,0,b''
nodes/vertex/interpol.py,7,"b'import numpy as np\n\nfrom svrx.typing import Vertices, Float, Int, Required, FloatP\n\nfrom svrx.util.geom import CubicSpline, LinearSpline\nfrom svrx.util.function import generator\nfrom svrx.nodes.node_base import node_func\n\n\n@node_func(bl_idname=""SvRxNodeVertexInterpol"", multi_label=""Interpolation"", id=0)\ndef cubic_spline(verts: Vertices = Required,\n                 t: Float = 0.5,\n                 h: FloatP = 0.001,\n                 ) -> (Vertices, Vertices(""Tanget"")):\n    spl = CubicSpline(verts[:, :3])\n    points_out = np.ones((len(t), 4), dtype=np.float64)\n    tangents_out = np.zeros((len(t), 4), dtype=np.float64)\n    points_out[:, :3] = spl.eval(t)\n    tangents_out[:, :3] = spl.tangent(t, h)\n    return points_out, tangents_out\n\n\n@node_func(id=2)\n@generator\ndef cubic_spline_count(verts: Vertices(iterable=False) = Required,\n                       count: Int = 10,\n                       h: FloatP = 0.0001\n                       ) -> ([Vertices], [Vertices(""Tanget"")]):\n    return cubic_spline(verts, np.linspace(0.0, 1.0, count), h)\n\n\n@node_func(id=10)\ndef linear_spline(verts: Vertices = Required,\n                  t: Float = 0.5,\n                  ) -> Vertices:\n    spl = LinearSpline(verts[:, :3])\n    points_out = np.ones((len(t), 4), dtype=np.float64)\n    points_out[:, :3] = spl.eval(t)\n    return points_out\n\n\n""""""\n# sketches below\n\n@node_func(bl_idname=\'SvRxVertexInterpol\', id=2)\ndef surface_patch(verts : [Vertices] = Required,\n                  u: Int = 10,\n                  v: Int = 10\n                  ) -> (\n                  Vertices,\n                  Vertices(""Normal""),\n                  Vertices(""U tanget""),\n                  Vertices(""V tangent"")):\n    u_splines = []\n    v_splines = []\n    u_t = np.linspace(0, 1, u[0])\n    v_t = np.linspace(0, 1, v[0])\n\n    for vert in verts:\n        u_splines.append(CubicSpline(verts))\n\n    np.empty((u[0], 3))\n    for u_spl in u_splines:\n        u_spl.eval(u_t)\n""""""\n'"
nodes/vertex/random_vector.py,6,"b'# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\nimport numpy as np\n\nfrom svrx.typing import Float, Int, Vertices, BoolP\nfrom svrx.nodes.node_base import node_func\n\nfrom svrx.util.function import generator\n\n\ndef gen_rand_vecs(dims, number):\n    vecs = np.random.normal(size=(number, dims))\n    mags = np.linalg.norm(vecs, axis=-1)\n    return vecs / mags[..., np.newaxis]\n\n\n@node_func(bl_idname=""SvRxNodeVectorRandom"")\n@generator\ndef random_unit_vector(size: Int =1,\n                       seed: Int = 1,\n                       scale: Float = 1.0,\n                       point: BoolP = False\n                       ) -> [Vertices]:\n    np.random.seed(seed)\n    if point:\n        res = np.ones((size, 4))\n    else:\n        res = np.zeros((size, 4))\n    res[:, :3] = scale * gen_rand_vecs(3, size)\n    return res\n'"
nodes/vertex/vector_in.py,1,"b'from svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Vertices\n\nimport numpy as np\n\n@node_func(bl_idname=""SvRxNodeVectorIn"")\ndef vector_in(x: Float = 0.0,\n              y: Float = 0.0,\n              z: Float = 0.0,\n              w: Float = 1.0\n              ) -> Vertices:\n    """"""create vertices from inputs""""""\n    data = (x, y, z, w)\n    counts = [len(x) for x in data]\n    verts = np.empty((max(counts), 4))\n    for i, count in zip(range(4), counts):\n        verts[:count, i] = data[i]\n        verts[count:, i] = data[i][-1]\n    return verts\n'"
nodes/vertex/vector_math.py,10,"b'import numpy as np\n\nfrom svrx.typing import Vector, Float, Int, Vertices\nfrom svrx.nodes.node_base import node_func\n\nfrom svrx.util.function import make_compatible\n\nX_AXIS = (1, 0, 0, 1)\nY_AXIS = (0, 1, 0, 1)\nZ_AXIS = (0, 0, 1, 1)\nZEROS = (0, 0, 0, 1)\nONES = (1, 1, 1, 1)\n"""""" missing\n- Angle Rad,\n- Angle Deg,\n- Project,\n- Reflect,\n- Componentwise-multiplication,\n""""""\n# pylint: disable=C0326\n# pylint: disable=W0622\n\n\n@node_func(bl_idname=""SvRxNodeVectorMath"", multi_label=""Vector Math"", id=0)\ndef add(u: Vector = ZEROS, v: Vector = ZEROS) -> Vertices:\n    u, v = make_compatible(u, v)\n    max_len = max(u.shape[0], v.shape[0])\n    out = np.zeros((max_len, 4))\n    out[:, :3] = u[:, :3] + v[:, :3]\n    out[:, 3] = max(u[0, 3], v[0, 3])\n    return out\n\n\n@node_func(id=6)\ndef sub(u: Vector = ZEROS, v: Vector = ZEROS) -> Vertices:\n    # return add(u, opposite(v))\n    u, v = make_compatible(u, v)\n    max_len = max(u.shape[0], v.shape[0])\n    out = np.zeros((max_len, 4))\n    out[:, :3] = u[:, :3] - v[:, :3]\n    out[:, 3] = max(u[0, 3], v[0, 3])\n    return out\n\n@node_func(id=12)\ndef cross(u: Vector = X_AXIS, v: Vector = Y_AXIS) -> Vertices:\n    u, v = make_compatible(u, v)\n    max_len = max(u.shape[0], v.shape[0])\n    out = np.zeros((max_len, 4))\n    out[:, :3] = np.cross(u[:, :3], v[:, :3])\n    return out\n\n\n@node_func(id=18)\ndef scale(u: Vector = ZEROS, s: Float = 1.0) -> Vertices:\n    u, s = make_compatible(u, s[:, np.newaxis])\n    out = u.copy()\n    out[:, :3] = u[:, :3] * s[:, :3]\n    return out\n\n\n@node_func(id=22)\ndef scale_reciprocal(u: Vector = ZEROS, s: Float = 1.0) -> Vertices:\n    return scale(u, 1 / s)\n\n\n@node_func(id=26)\ndef length(u: Vector = ZEROS) -> Float:\n    tmp = u[:, :3]\n    return np.sqrt((tmp * tmp).sum(axis=1))\n\n\n@node_func(id=32)\ndef dot(u: Vector = ZEROS, v: Vector = ZEROS) -> Float:\n    u, v = make_compatible(u, v)\n    return np.sum(u[:, :3] * v[:, :3], axis=1)  # .. not sure\n\n\n@node_func(id=38)\ndef opposite(u: Vector = ZEROS) -> Vertices:\n    out = u.copy()\n    out[:, :3] = -u[:, :3]\n    return out\n\n\n@node_func(id=44)\ndef distance(u: Vector = ZEROS, v: Vector = ZEROS) -> Float:\n    # speed!?  http://stackoverflow.com/a/9184560/1243487\n    # return length(sub(u, v))\n\n    u, v = make_compatible(u, v)\n    x = u[:, :3] - v[:, :3]\n    return np.sqrt((x * x).sum(axis=1))\n\n\n@node_func(id=48)\ndef round(u: Vector = ZEROS, n: Int = 7) -> Vertices:\n    out = u.copy()\n    out[:, :3] = np.round(u[:, :3], n)\n    return out\n\n\n@node_func(id=50)\ndef normalize(u: Vector = ZEROS) -> Vertices:\n    out = u.copy()\n    mag = length(u)\n    out[:, :3] /= mag[:, np.newaxis]\n    return out\n\n\n@node_func(id=60)\ndef component_mul(u: Vector = ONES, v: Vector = ONES) -> Vertices:\n    u, v = make_compatible(u, v)\n    return u * v\n'"
nodes/vertex/vector_out.py,0,"b'from svrx.nodes.node_base import node_func\nfrom svrx.typing import Float, Point\n\nimport numpy as np\n\n@node_func(bl_idname=""SvRxNodeVectorOut"")\ndef vector_out(verts: Point = (0.0, 0.0, 0.0, 1.0)\n              ) -> (Float(""x""), Float(""y""), Float(""z""), Float(""w"")):\n    return verts[:, 0], verts[:, 1], verts[:, 2], verts[:, 3]\n'"
util/scripts/parse_types.py,0,b''
util/snrx_templates/bm_icosphere.py,0,"b'import bmesh\nfrom svrx.util.function import generator\nfrom svrx.util.mesh import rxdata_from_bm\n\ndef make_icosphere(subdiv, diam):\n    bm = bmesh.new()\n    bmesh.ops.create_icosphere(bm, subdivisions=subdiv, diameter=diam, calc_uvs=False)\n    return rxdata_from_bm(bm)\n\n@node_script\n@generator\ndef sn_icosphere(subdiv: Int(min=0, max=5) = 2, diam: Float = 1.0) -> ([Vertices], [Edges], [Faces]):\n    return make_icosphere(min(subdiv, 5), diam)\n'"
util/snrx_templates/n1_torus.py,0,"b'from sverchok.nodes.generator.torus import torus_verts, torus_edges, torus_polygons\n\nfrom svrx.util.function import generator\nfrom svrx.util.smesh import SMesh\n\ndef make_torus(R, r, N1, N2, rPhase, sPhase):\n    v = torus_verts(R, r, N1, N2, rPhase, sPhase, False)[0]\n    e = torus_edges(N1, N2)\n    f = torus_polygons(N1, N2)\n    return SMesh.from_pydata(v, e, f).as_rxdata\n\n@node_script\n@generator\ndef sn_torus(\n    R: Float = 2.0, r: Float = 0.6, \n    N1: Int = 22, N2: Int = 15, \n    rPhase: Float = 0.0,\n    sPhase: Float = 0.0) -> ([Vertices], [Edges], [Faces]):\n    return make_torus(R, r, N1, N2, rPhase, sPhase)\n'"
util/snrx_templates/rxdata_cricket.py,0,"b'from svrx.util.mesh import rxdata_from_pydata\nfrom svrx.util.importers import named_mesh_path, obj_to_pydata_lite\n\n@node_script\ndef sn_make_cricket() -> (Vertices, Edges, Faces):\n    obj_path = named_mesh_path(""cricket.obj"")       #  returns the library path +  object name\n    verts, _, faces = obj_to_pydata_lite(obj_path)  #  accepts full valid path\n    return rxdata_from_pydata(verts, faces=faces)\n'"
