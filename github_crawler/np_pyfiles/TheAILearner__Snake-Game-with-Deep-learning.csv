file_path,api_count,code
game.py,11,"b'import pygame\r\nimport random\r\nimport time\r\nimport math\r\nfrom tqdm import tqdm\r\nimport numpy as np\r\n\r\n\r\ndef display_snake(snake_position, display):\r\n    for position in snake_position:\r\n        pygame.draw.rect(display, (255, 0, 0), pygame.Rect(position[0], position[1], 10, 10))\r\n\r\n\r\ndef display_apple(apple_position, display):\r\n    pygame.draw.rect(display, (0, 255, 0), pygame.Rect(apple_position[0], apple_position[1], 10, 10))\r\n\r\n\r\ndef starting_positions():\r\n    snake_start = [100, 100]\r\n    snake_position = [[100, 100], [90, 100], [80, 100]]\r\n    apple_position = [random.randrange(1, 50) * 10, random.randrange(1, 50) * 10]\r\n    score = 3\r\n\r\n    return snake_start, snake_position, apple_position, score\r\n\r\n\r\ndef apple_distance_from_snake(apple_position, snake_position):\r\n    return np.linalg.norm(np.array(apple_position) - np.array(snake_position[0]))\r\n\r\n\r\ndef generate_snake(snake_start, snake_position, apple_position, button_direction, score):\r\n    if button_direction == 1:\r\n        snake_start[0] += 10\r\n    elif button_direction == 0:\r\n        snake_start[0] -= 10\r\n    elif button_direction == 2:\r\n        snake_start[1] += 10\r\n    else:\r\n        snake_start[1] -= 10\r\n\r\n    if snake_start == apple_position:\r\n        apple_position, score = collision_with_apple(apple_position, score)\r\n        snake_position.insert(0, list(snake_start))\r\n\r\n    else:\r\n        snake_position.insert(0, list(snake_start))\r\n        snake_position.pop()\r\n\r\n    return snake_position, apple_position, score\r\n\r\n\r\ndef collision_with_apple(apple_position, score):\r\n    apple_position = [random.randrange(1, 50) * 10, random.randrange(1, 50) * 10]\r\n    score += 1\r\n    return apple_position, score\r\n\r\n\r\ndef collision_with_boundaries(snake_start):\r\n    if snake_start[0] >= 500 or snake_start[0] < 0 or snake_start[1] >= 500 or snake_start[1] < 0:\r\n        return 1\r\n    else:\r\n        return 0\r\n\r\n\r\ndef collision_with_self(snake_start, snake_position):\r\n    # snake_start = snake_position[0]\r\n    if snake_start in snake_position[1:]:\r\n        return 1\r\n    else:\r\n        return 0\r\n\r\n\r\ndef blocked_directions(snake_position):\r\n    current_direction_vector = np.array(snake_position[0]) - np.array(snake_position[1])\r\n\r\n    left_direction_vector = np.array([current_direction_vector[1], -current_direction_vector[0]])\r\n    right_direction_vector = np.array([-current_direction_vector[1], current_direction_vector[0]])\r\n\r\n    is_front_blocked = is_direction_blocked(snake_position, current_direction_vector)\r\n    is_left_blocked = is_direction_blocked(snake_position, left_direction_vector)\r\n    is_right_blocked = is_direction_blocked(snake_position, right_direction_vector)\r\n\r\n    return current_direction_vector, is_front_blocked, is_left_blocked, is_right_blocked\r\n\r\n\r\ndef is_direction_blocked(snake_position, current_direction_vector):\r\n    next_step = snake_position[0] + current_direction_vector\r\n    snake_start = snake_position[0]\r\n    if collision_with_boundaries(next_step) == 1 or collision_with_self(next_step.tolist(), snake_position) == 1:\r\n        return 1\r\n    else:\r\n        return 0\r\n\r\n\r\ndef generate_random_direction(snake_position, angle_with_apple):\r\n    direction = 0\r\n    if angle_with_apple > 0:\r\n        direction = 1\r\n    elif angle_with_apple < 0:\r\n        direction = -1\r\n    else:\r\n        direction = 0\r\n\r\n    return direction_vector(snake_position, angle_with_apple, direction)\r\n\r\n\r\ndef direction_vector(snake_position, angle_with_apple, direction):\r\n    current_direction_vector = np.array(snake_position[0]) - np.array(snake_position[1])\r\n    left_direction_vector = np.array([current_direction_vector[1], -current_direction_vector[0]])\r\n    right_direction_vector = np.array([-current_direction_vector[1], current_direction_vector[0]])\r\n\r\n    new_direction = current_direction_vector\r\n\r\n    if direction == -1:\r\n        new_direction = left_direction_vector\r\n    if direction == 1:\r\n        new_direction = right_direction_vector\r\n\r\n    button_direction = generate_button_direction(new_direction)\r\n\r\n    return direction, button_direction\r\n\r\n\r\ndef generate_button_direction(new_direction):\r\n    button_direction = 0\r\n    if new_direction.tolist() == [10, 0]:\r\n        button_direction = 1\r\n    elif new_direction.tolist() == [-10, 0]:\r\n        button_direction = 0\r\n    elif new_direction.tolist() == [0, 10]:\r\n        button_direction = 2\r\n    else:\r\n        button_direction = 3\r\n\r\n    return button_direction\r\n\r\n\r\ndef angle_with_apple(snake_position, apple_position):\r\n    apple_direction_vector = np.array(apple_position) - np.array(snake_position[0])\r\n    snake_direction_vector = np.array(snake_position[0]) - np.array(snake_position[1])\r\n\r\n    norm_of_apple_direction_vector = np.linalg.norm(apple_direction_vector)\r\n    norm_of_snake_direction_vector = np.linalg.norm(snake_direction_vector)\r\n    if norm_of_apple_direction_vector == 0:\r\n        norm_of_apple_direction_vector = 10\r\n    if norm_of_snake_direction_vector == 0:\r\n        norm_of_snake_direction_vector = 10\r\n\r\n    apple_direction_vector_normalized = apple_direction_vector / norm_of_apple_direction_vector\r\n    snake_direction_vector_normalized = snake_direction_vector / norm_of_snake_direction_vector\r\n    angle = math.atan2(\r\n        apple_direction_vector_normalized[1] * snake_direction_vector_normalized[0] - apple_direction_vector_normalized[\r\n            0] * snake_direction_vector_normalized[1],\r\n        apple_direction_vector_normalized[1] * snake_direction_vector_normalized[1] + apple_direction_vector_normalized[\r\n            0] * snake_direction_vector_normalized[0]) / math.pi\r\n    return angle, snake_direction_vector, apple_direction_vector_normalized, snake_direction_vector_normalized\r\n\r\n\r\ndef play_game(snake_start, snake_position, apple_position, button_direction, score, display, clock):\r\n    crashed = False\r\n    while crashed is not True:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                crashed = True\r\n        display.fill((255, 255, 255))\r\n\r\n        display_apple(apple_position, display)\r\n        display_snake(snake_position, display)\r\n\r\n        snake_position, apple_position, score = generate_snake(snake_start, snake_position, apple_position,\r\n                                                               button_direction, score)\r\n        pygame.display.set_caption(""SCORE: "" + str(score))\r\n        pygame.display.update()\r\n        clock.tick(50000)\r\n\r\n        return snake_position, apple_position, score'"
main.py,1,"b""from game import *\r\nfrom training_data import generate_training_data\r\n\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense\r\n\r\ndisplay_width = 500\r\ndisplay_height = 500\r\ngreen = (0,255,0)\r\nred = (255,0,0)\r\nblack = (0,0,0)\r\nwhite = (255,255,255)\r\n\r\npygame.init()\r\ndisplay=pygame.display.set_mode((display_width,display_height))\r\nclock=pygame.time.Clock()\r\n\r\n'''\r\nLEFT -> button_direction = 0\r\nRIGHT -> button_direction = 1\r\nDOWN ->button_direction = 2\r\nUP -> button_direction = 3\r\n'''\r\ntraining_data_x, training_data_y = generate_training_data(display,clock)\r\n\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(units=9,input_dim=7))\r\n\r\nmodel.add(Dense(units=15, activation='relu'))\r\nmodel.add(Dense(output_dim=3,  activation = 'softmax'))\r\n\r\nmodel.compile(loss='mean_squared_error', optimizer='adam', metrics=['accuracy'])\r\nmodel.fit((np.array(training_data_x).reshape(-1,7)),( np.array(training_data_y).reshape(-1,3)), batch_size = 256,epochs= 3)\r\n\r\nmodel.save_weights('model.h5')\r\nmodel_json = model.to_json()\r\nwith open('model.json', 'w') as json_file:\r\n    json_file.write(model_json)"""
test.py,4,"b'import tensorflow as tf\r\nfrom keras.backend.tensorflow_backend import set_session\r\nconfig = tf.ConfigProto()\r\nconfig.gpu_options.allow_growth = True  # dynamically grow the memory used on the GPU\r\nconfig.log_device_placement = True  # to log device placement (on which device the operation ran)\r\n                                    # (nothing gets printed in Jupyter, only if you run it standalone)\r\nsess = tf.Session(config=config)\r\nset_session(sess)  # set this TensorFlow session as the default session for Keras\r\n\r\n\r\n\r\nfrom game import *\r\nfrom keras.models import model_from_json\r\n\r\ndef run_game_with_ML(model, display, clock):\r\n    max_score = 3\r\n    avg_score = 0\r\n    test_games = 1000\r\n    steps_per_game = 2000\r\n\r\n    for _ in range(test_games):\r\n        snake_start, snake_position, apple_position, score = starting_positions()\r\n\r\n        count_same_direction = 0\r\n        prev_direction = 0\r\n\r\n        for _ in range(steps_per_game):\r\n            current_direction_vector, is_front_blocked, is_left_blocked, is_right_blocked = blocked_directions(\r\n                snake_position)\r\n            angle, snake_direction_vector, apple_direction_vector_normalized, snake_direction_vector_normalized = angle_with_apple(\r\n                snake_position, apple_position)\r\n            predictions = []\r\n\r\n            predicted_direction = np.argmax(np.array(model.predict(np.array([is_left_blocked, is_front_blocked, \\\r\n                                                                             is_right_blocked,\r\n                                                                             apple_direction_vector_normalized[0], \\\r\n                                                                             snake_direction_vector_normalized[0],\r\n                                                                             apple_direction_vector_normalized[1], \\\r\n                                                                             snake_direction_vector_normalized[\r\n                                                                                 1]]).reshape(-1, 7)))) - 1\r\n\r\n            if predicted_direction == prev_direction:\r\n                count_same_direction += 1\r\n            else:\r\n                count_same_direction = 0\r\n                prev_direction = predicted_direction\r\n\r\n            new_direction = np.array(snake_position[0]) - np.array(snake_position[1])\r\n            if predicted_direction == -1:\r\n                new_direction = np.array([new_direction[1], -new_direction[0]])\r\n            if predicted_direction == 1:\r\n                new_direction = np.array([-new_direction[1], new_direction[0]])\r\n\r\n            button_direction = generate_button_direction(new_direction)\r\n\r\n            next_step = snake_position[0] + current_direction_vector\r\n            if collision_with_boundaries(snake_position[0]) == 1 or collision_with_self(next_step.tolist(),\r\n                                                                                        snake_position) == 1:\r\n                break\r\n            snake_position, apple_position, score = play_game(snake_start, snake_position, apple_position,\r\n                                                              button_direction, score, display, clock)\r\n\r\n            if score > max_score:\r\n                max_score = score\r\n\r\n        avg_score += score\r\n\r\n    return max_score, avg_score / 1000\r\n\r\n\r\njson_file = open(\'model.json\', \'r\')\r\nloaded_json_model = json_file.read()\r\nmodel = model_from_json(loaded_json_model)\r\nmodel.load_weights(\'model.h5\')\r\n\r\n\r\ndisplay_width = 500\r\ndisplay_height = 500\r\npygame.init()\r\ndisplay=pygame.display.set_mode((display_width,display_height))\r\nclock=pygame.time.Clock()\r\nmax_score, avg_score = run_game_with_ML(model,display,clock)\r\nprint(""Maximum score achieved is:  "", max_score)\r\nprint(""Average score achieved is:  "", avg_score)'"
training_data.py,0,"b'from game import *\r\n\r\ndef generate_training_data(display, clock):\r\n    training_data_x = []\r\n    training_data_y = []\r\n    training_games = 1000\r\n    steps_per_game = 2000\r\n\r\n    for _ in tqdm(range(training_games)):\r\n        snake_start, snake_position, apple_position, score = starting_positions()\r\n        prev_apple_distance = apple_distance_from_snake(apple_position, snake_position)\r\n\r\n        for _ in range(steps_per_game):\r\n            angle, snake_direction_vector, apple_direction_vector_normalized, snake_direction_vector_normalized = angle_with_apple(\r\n                snake_position, apple_position)\r\n            direction, button_direction = generate_random_direction(snake_position, angle)\r\n            current_direction_vector, is_front_blocked, is_left_blocked, is_right_blocked = blocked_directions(\r\n                snake_position)\r\n\r\n            direction, button_direction, training_data_y = generate_training_data_y(snake_position, angle_with_apple,\r\n                                                                                    button_direction, direction,\r\n                                                                                    training_data_y, is_front_blocked,\r\n                                                                                    is_left_blocked, is_right_blocked)\r\n\r\n            if is_front_blocked == 1 and is_left_blocked == 1 and is_right_blocked == 1:\r\n                break\r\n\r\n            training_data_x.append(\r\n                [is_left_blocked, is_front_blocked, is_right_blocked, apple_direction_vector_normalized[0], \\\r\n                 snake_direction_vector_normalized[0], apple_direction_vector_normalized[1], \\\r\n                 snake_direction_vector_normalized[1]])\r\n\r\n            snake_position, apple_position, score = play_game(snake_start, snake_position, apple_position,\r\n                                                              button_direction, score, display, clock)\r\n\r\n    return training_data_x, training_data_y\r\n\r\n\r\ndef generate_training_data_y(snake_position, angle_with_apple, button_direction, direction, training_data_y,\r\n                             is_front_blocked, is_left_blocked, is_right_blocked):\r\n    if direction == -1:\r\n        if is_left_blocked == 1:\r\n            if is_front_blocked == 1 and is_right_blocked == 0:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 1)\r\n                training_data_y.append([0, 0, 1])\r\n            elif is_front_blocked == 0 and is_right_blocked == 1:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 0)\r\n                training_data_y.append([0, 1, 0])\r\n            elif is_front_blocked == 0 and is_right_blocked == 0:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 1)\r\n                training_data_y.append([0, 0, 1])\r\n\r\n        else:\r\n            training_data_y.append([1, 0, 0])\r\n\r\n    elif direction == 0:\r\n        if is_front_blocked == 1:\r\n            if is_left_blocked == 1 and is_right_blocked == 0:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 1)\r\n                training_data_y.append([0, 0, 1])\r\n            elif is_left_blocked == 0 and is_right_blocked == 1:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, -1)\r\n                training_data_y.append([1, 0, 0])\r\n            elif is_left_blocked == 0 and is_right_blocked == 0:\r\n                training_data_y.append([0, 0, 1])\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 1)\r\n        else:\r\n            training_data_y.append([0, 1, 0])\r\n    else:\r\n        if is_right_blocked == 1:\r\n            if is_left_blocked == 1 and is_front_blocked == 0:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, 0)\r\n                training_data_y.append([0, 1, 0])\r\n            elif is_left_blocked == 0 and is_front_blocked == 1:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, -1)\r\n                training_data_y.append([1, 0, 0])\r\n            elif is_left_blocked == 0 and is_front_blocked == 0:\r\n                direction, button_direction = direction_vector(snake_position, angle_with_apple, -1)\r\n                training_data_y.append([1, 0, 0])\r\n        else:\r\n            training_data_y.append([0, 0, 1])\r\n\r\n    return direction, button_direction, training_data_y'"
