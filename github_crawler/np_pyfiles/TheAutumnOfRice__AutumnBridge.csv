file_path,api_count,code
AutumnBridge.py,6,"b'from matlab.engine import start_matlab, connect_matlab\nfrom typing import Optional\nfrom scipy.io import savemat, loadmat\nimport numpy as np\nfrom os import remove\nfrom os.path import exists\nfrom os import getcwd\n\n\ndef RandomBridge():\n    return \'B\' + str(np.random.randint(1000000, 9999999))\n\n\ndef _MakeArgs(num: int, sym: str, br: str = \'\'):\n    """"""\n    Input Num, Return Args Name list like [a1,a2,...,an]\n    """"""\n    return [\'%s%s%d\' % (sym, br, i) for i in range(num)]\n\n\ndef _Del(fname: str):\n    if exists(fname):\n        remove(fname)\n\n\nclass MatlabError(Exception):\n    def __init__(self, err=\'Matlab Error\'):\n        Exception.__init__(self, err)\n\n\nclass AutumnBridge:\n    def __init__(self, connect=False, desktop=False, background=False, MoreOpt=None, ID=None):\n        """"""\n        Initialize the bridge between python and matlab.\n        :param connect: bool\n            If True, AutumnBridge will connect to an opened Matlab.\n            Otherwise, AutumnBridge will start a new Matlab.\n        :param desktop: bool\n            Avaliable only when connect==False\n            If True, Matlab will be start in desktop mode.\n        :param background: bool\n            Avaliable only when connect==False\n            If True, Matlab will start in async mode.\n        :param MoreOpt: str = None\n            Avaliable only when connect==False\n            More parameters avaliable in Matlab Options.\n        :param ID: int\n            The ID of the bridge.\n            If None, the ID will be id(self).\n        """"""\n        opt = \'-desktop\' if desktop else \'-nodesktop\'\n        self._floatformat = np.float64\n        self._connect = connect\n        self._ID = ID if ID is not None else id(self)\n        if MoreOpt is not None:\n            opt = opt + \' \' + MoreOpt\n        self.eng = connect_matlab() if connect \\\n            else start_matlab(opt, background=background)\n        self.eng.cd(getcwd())\n\n    def __del__(self):\n        """"""\n        Quit Matlab.\n        """"""\n        if self._connect is False:\n            self.eng.quit()\n\n    """""" Dispatched\n    def __getattr__(self, item):\n        \'\'\'\n        The same function as eng.__getattr__\n        \'\'\'\n        return self.eng.__getattr__(item)\n    """"""\n\n    def E(self, command: str, nargout=0, raise_error=False):\n        """"""\n        A fast eval method.\n        :param command: str\n            matlab command.\n        :param nargout: int\n            Number of output arguments.\n        :param raise_error: bool\n            If False, the function will not raise an error, and give plain text warning.\n            If True, the function will raise an error, without more text warning.\n        :return:\n            Output arguments\n        """"""\n        try:\n            return self.eng.eval(command, nargout=nargout)\n        except Exception as e:\n            if raise_error:\n                raise MatlabError(str(e))\n\n    def R(self, command: str, nargout=1, raise_error=False):\n        """"""\n        A fast eval method, but return with scipy.io.\n        It can return big matrix.\n        :param command: str\n            matlab command.\n        :param nargout: int\n            Number of output arguments.\n        :param raise_error: bool\n            If False, the function will not raise an error, and give plain text warning.\n            If True, the function will raise an error, without more text warning.\n        :return:\n            Output arguments\n        """"""\n        BR = RandomBridge()\n        ArgOuts = _MakeArgs(nargout, \'Out\', BR)\n        fname = self._BridgeName(BR, \'_out.mat\')\n        try:\n            self.E(\'[%s]=%s;\' % (\',\'.join(ArgOuts), command), raise_error=True)\n            if nargout > 0:\n                self.E(\'save %s %s\' % (fname, \' \'.join(ArgOuts)), raise_error=True)\n                self.E(\'clear %s\' % \' \'.join(ArgOuts), raise_error=True)\n\n        except MatlabError as e:\n            if raise_error:\n                raise e\n            else:\n                return tuple([None for _ in range(nargout)]) if nargout >= 2 else None\n        except Exception as e:\n            raise e\n        else:\n            P = self._FromMat(BR, nargout)\n            if len(P) == 1:\n                return P[0]\n            else:\n                return P\n        finally:\n            self._DelInOut(BR)\n\n\n    def __getitem__(self, item: str):\n        """"""\n        Get an item from workspace\n        :param item: str\n            Variable.\n        """"""\n        if self.__contains__(item):\n            # item exist.\n            RB = RandomBridge()\n            fname = self._BridgeName(RB, \'_out.mat\')\n            try:\n                self.E(\'save %s %s\' % (fname, item), raise_error=True)\n            except MatlabError as e:\n                raise MatlabError(\'Error occured when saving \' + item + \': \' + str(e))\n            else:\n                P = self._FromMat(RB, 1, [item])\n                if len(P) == 1:\n                    return P[0]\n                else:\n                    return P\n            finally:\n                self._DelInOut(RB)\n\n        else:\n            raise KeyError(item)\n\n    def __setitem__(self, item: str, value):\n        """"""\n        Set an item into workspace\n        :param item: str\n            Variable\n        :param value:\n            any value to set to variable.\n        """"""\n        RB = RandomBridge()\n        try:\n            self._ToMat(RB, value, argname=[item])\n            fname = self._BridgeName(RB, \'_in.mat\')\n            self.E(\'load %s\' % fname, raise_error=True)\n        except MatlabError as e:\n            raise e\n        finally:\n            self._DelInOut(RB)\n\n    def __contains__(self, item):\n        """"""\n        Check if item in workspace\n        :param item: str\n            Variable\n        :return: bool\n            True if workspace contains item\n        """"""\n        P = self.E(""exist(\'%s\')"" % item, 1, raise_error=True) == 1\n        return P\n\n    def __iter__(self):\n        A = self.A()\n        for i in A:\n            yield i\n\n    def S(self, item, raise_error=False):\n        """"""\n        Show the shape / size of an item\n        :param item: str\n            Variable\n        :param raise_error: bool\n            If False, the function will not raise an error, and give plain text warning.\n            If True, the function will raise an error, without more text warning.\n        :return: tuple\n            shape or size\n        """"""\n        if not self.__contains__(item):\n            if raise_error:\n                raise KeyError(item)\n            else:\n                print(\'ERROR: \', item, \' not exist.\')\n        T = tuple(self.R(\'size(%s)\' % item, raise_error=raise_error))\n        return T\n\n    def A(self, raise_error=False):\n        """"""\n        Get all the variables\' names.\n        :param raise_error: bool\n            If False, the function will not raise an error, and give plain text warning.\n            If True, the function will raise an error, without more text warning.\n        :return:\n        names of the variables\n        """"""\n        try:\n            P = self.R(\'whos()\', raise_error=True)\n            return self.R(\'whos()\', raise_error=True)[\'name\']\n        except IndexError:\n            return np.array([])\n        except MatlabError as e:\n            if raise_error:\n                raise e\n            else:\n                return np.array([])\n\n    def show(self):\n        """"""\n        Equals to E(\'whos\')\n        """"""\n        self.E(\'whos\')\n\n    def _BridgeName(self, bridge: str, suf: str):\n        """"""\n        Return The Name Of the Bridge File\n        """"""\n        return ""AutumnBridge_%s_%s%s"" % (str(self._ID), str(bridge), suf)\n\n    def BuildBridge(self, func: str, bridge: str, nargin: int, nargout: int):\n        """"""\n        Build .m Bridge.\n        :param func: str\n            Name of the function that will be wrapped.\n        :param bridge: str\n            Name of the bridge\n        :param nargin: int\n            Number of input arguments\n        :param nargout: int\n            Number of output arguments\n        """"""\n        fname = self._BridgeName(bridge, \'.m\')\n        funname = self._BridgeName(bridge, \'\')\n        inmatname = self._BridgeName(bridge, \'_in.mat\')\n        outmatname = self._BridgeName(bridge, \'_out.mat\')\n        OutArgs = _MakeArgs(nargout, \'Out\', bridge)\n        InArgs = _MakeArgs(nargin, \'In\', bridge)\n        with open(fname, \'w\') as f:\n            P = []\n            P += [\'function []=%s()\\n\' % funname]\n            P += [\'\\tload %s\\n\' % inmatname]\n            P += [\'\\t[%s]=%s(%s);\\n\' % (\',\'.join(OutArgs), func, \',\'.join(InArgs))]\n            P += [\'\\tsave %s %s\\n\' % (outmatname, \' \'.join(OutArgs))]\n            P += [\'end\\n\']\n            f.writelines(P)\n\n    def DelBridge(self, bridge: str):\n        """"""\n        Delete Bridge file.\n        :param bridge: str\n            The name of bridge\n        :return:\n        """"""\n        fname = self._BridgeName(bridge, \'.m\')\n        _Del(fname)\n\n    def _DelInOut(self, bridge: str):\n        inmatname = self._BridgeName(bridge, \'_in.mat\')\n        outmatname = self._BridgeName(bridge, \'_out.mat\')\n        _Del(inmatname)\n        _Del(outmatname)\n\n    def _ToMat(self, bridge: str, *argin, argname=None):\n        inmatname = self._BridgeName(bridge, \'_in.mat\')\n        if argname is None:\n            InArgs = _MakeArgs(len(argin), \'In\', bridge)\n        else:\n            InArgs = argname\n        argin = list(argin)\n        for i, j in enumerate(argin):\n            if type(argin[i]) is int:\n                argin[i] = float(argin[i])\n            if type(j) in [list, tuple]:\n                argin[i] = np.array(j)\n            if type(argin[i]) is np.ndarray and \'int\' in argin[i].dtype.name:\n                argin[i] = argin[i].astype(self._floatformat)\n        savemat(inmatname, dict(zip(InArgs, argin)))\n\n    def _FromMat(self, bridge: str, nargout: int, argname=None):\n        outmatname = self._BridgeName(bridge, \'_out.mat\')\n        if argname is None:\n            OutArgs = _MakeArgs(nargout, \'Out\', bridge)\n        else:\n            OutArgs = argname\n        D = loadmat(outmatname, squeeze_me=True, struct_as_record=True, chars_as_strings=True)\n        L = []\n        for i in OutArgs:\n            L = L + [D[i]]\n        return tuple(L)\n\n    def __call__(self, func: str, *argin, nargout=1, bridge: Optional[str] = None, NewBridge=\'auto\', delete=\'auto\'):\n        """"""\n        Wrap a matlab function with Bridge, and transfer data/parameters much more faster\n        using scipy.io.\n        :param func: str\n            the function to be wrapped\n        :param argin: Any type that can be recognized by scipy.io.savemat\n            arguments or data that will be transfered to the matlab function\n        :param nargout: int\n            The number of output arguments\n        :param bridge: str\n            The name of bridge.\n            If None: the name will be random int.\n        :param NewBridge: bool or \'auto\'\n            If True, the bridge .m file will be create anyhow.\n            If False, the bridge .m file will not be created, and make sure\n                you have ever created one with certain ID and Bridge name.\n            If \'auto\', the bridge .m file will be create if there doesn\'t\n                exist one.\n        :param delete: bool or \'auto\'\n            If True, the bridge .m file will be delete after function calling.\n            If False, the bridge .m file will not be delete.\n            If \'auto\', delete=True if bridge is not None.\n        :return:\n            Tuple(arg0,arg1,...,argn), n=nargout\n        """"""\n        if delete == \'auto\':\n            delete = bridge is not None\n        else:\n            assert type(delete) is bool\n        if bridge is None:\n            bridge = RandomBridge()\n        fname = self._BridgeName(bridge, \'.m\')\n        funname = self._BridgeName(bridge, \'\')\n        if NewBridge == \'auto\':\n            NewBridge = not exists(fname)\n        else:\n            assert type(NewBridge) is bool\n        if NewBridge:\n            self.BuildBridge(func, bridge, len(argin), nargout)\n        try:\n            self._ToMat(bridge, *argin)\n            self.eng.__getattr__(funname)(nargout=0)\n            T = self._FromMat(bridge, nargout)\n        except Exception as e:\n            raise e\n        else:\n            if len(T) == 1:\n                return T[0]\n            else:\n                return T\n        finally:\n            if delete:\n                self.DelBridge(bridge)\n            self._DelInOut(bridge)\n'"
setup.py,0,"b""from setuptools import setup\n\nsetup(\n    name='AutumnBridge',\n    version='1.0.1',\n    packages=[''],\n    url='https://github.com/TheAutumnOfRice/AutumnBridge',\n    license='GPL-3.0',\n    author='TheRiceOfAutumn',\n    author_email='nuaazhouyi@nuaa.edu.cn',\n    description='A fast, convenient bridge between python and matlab which support numpy.', install_requires=['scipy',\n                                                                                                              'numpy']\n)\n"""
