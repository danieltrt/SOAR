file_path,api_count,code
setup.py,0,"b'# Copyright (c) 2017 UCAR Unidata Program Center.\n# Distributed under the terms of the BSD 3-Clause License.\n# SPDX-License-Identifier: BSD-3-Clause\nfrom __future__ import print_function\nimport sys\nfrom distutils.core import setup\nfrom setuptools import find_packages\n\ndependencies = [\'numpy\', \'six\']\nif sys.version_info < (3, 4):\n    dependencies.append(\'enum34\')\n\nver = ""18.1.7""\n\nsetup(\n    name=\'python-awips\',\n    version=ver,\n    description=\'A framework for requesting AWIPS meteorological datasets from an EDEX server\',\n    packages=find_packages(exclude=\'data\'),\n    license=\'BSD\',\n    url=\'http://python-awips.readthedocs.io\',\n    download_url=\'https://github.com/Unidata/python-awips/archive/{}.tar.gz\'.format(ver),\n    author=\'Unidata\',\n    author_email=\'mjames@ucar.edu\',\n    install_requires=dependencies,\n    extras_require={\n        \'cdm\': [\'pyproj>=1.9.4\'],\n        \'dev\': [\'ipython[all]>=3.1\'],\n        \'doc\': [\'sphinx>=1.4\', \'sphinx-gallery\', \'doc8\'],\n        \'examples\': [\'cartopy>=0.13.1\', \'metpy>=0.4.0\']\n    }\n)\n\n'"
awips/DateTimeConverter.py,0,"b'#\n# Functions for converting between the various ""Java"" dynamic serialize types\n# used by EDEX to the native python time datetime.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/24/15         #4480        dgilling       Initial Creation.\n#\n\nimport datetime\nimport time\n\nfrom dynamicserialize.dstypes.java.util import Date\nfrom dynamicserialize.dstypes.java.sql import Timestamp\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import TimeRange\n\nMAX_TIME = pow(2, 31) - 1\nMICROS_IN_SECOND = 1000000\n\n\ndef convertToDateTime(timeArg):\n    """"""\n    Converts the given object to a python datetime object. Supports native\n    python representations like datetime and struct_time, but also\n    the dynamicserialize types like Date and Timestamp. Raises TypeError\n    if no conversion can be performed.\n\n    Args:\n            timeArg: a python object representing a date and time. Supported\n            types include datetime, struct_time, float, int, long and the\n            dynamicserialize types Date and Timestamp.\n\n    Returns:\n        A datetime that represents the same date/time as the passed in object.\n    """"""\n    if isinstance(timeArg, datetime.datetime):\n        return timeArg\n    elif isinstance(timeArg, time.struct_time):\n        return datetime.datetime(*timeArg[:6])\n    elif isinstance(timeArg, float):\n        # seconds as float, should be avoided due to floating point errors\n        totalSecs = int(timeArg)\n        micros = int((timeArg - totalSecs) * MICROS_IN_SECOND)\n        return _convertSecsAndMicros(totalSecs, micros)\n    elif isinstance(timeArg, int):\n        # seconds as integer\n        totalSecs = timeArg\n        return _convertSecsAndMicros(totalSecs, 0)\n    elif isinstance(timeArg, (Date, Timestamp)):\n        totalSecs = timeArg.getTime()\n        return _convertSecsAndMicros(totalSecs, 0)\n    else:\n        objType = str(type(timeArg))\n        raise TypeError(""Cannot convert object of type "" + objType + "" to datetime."")\n\n\ndef _convertSecsAndMicros(seconds, micros):\n    if seconds < MAX_TIME:\n        rval = datetime.datetime.utcfromtimestamp(seconds)\n    else:\n        extraTime = datetime.timedelta(seconds=(seconds - MAX_TIME))\n        rval = datetime.datetime.utcfromtimestamp(MAX_TIME) + extraTime\n    return rval.replace(microsecond=micros)\n\n\ndef constructTimeRange(*args):\n    """"""\n    Builds a python dynamicserialize TimeRange object from the given\n    arguments.\n\n    Args:\n            args*: must be a TimeRange or a pair of objects that can be\n                   converted to a datetime via convertToDateTime().\n\n    Returns:\n        A TimeRange.\n    """"""\n\n    if len(args) == 1 and isinstance(args[0], TimeRange):\n        return args[0]\n    if len(args) != 2:\n        raise TypeError(""constructTimeRange takes exactly 2 arguments, "" + str(len(args)) + "" provided."")\n    startTime = convertToDateTime(args[0])\n    endTime = convertToDateTime(args[1])\n    return TimeRange(startTime, endTime)\n'"
awips/QpidSubscriber.py,0,"b'#\n# Provides a Python-based interface for subscribing to qpid queues and topics.\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    11/17/10                      njensen       Initial Creation.\n#    08/15/13        2169          bkowal        Optionally gzip decompress any data that is read.\n#    08/04/16        2416          tgurney       Add queueStarted property\n#    02/16/17        6084          bsteffen      Support ssl connections\n#    09/07/17        6175          tgurney       Remove ""decompressing"" log message\n#\n#\n\nimport os\nimport os.path\nimport qpid\nimport zlib\n\nfrom Queue import Empty\nfrom qpid.exceptions import Closed\n\n\nclass QpidSubscriber:\n\n    def __init__(self, host=\'127.0.0.1\', port=5672, decompress=False, ssl=None):\n        self.host = host\n        self.port = port\n        self.decompress = decompress\n        socket = qpid.util.connect(host, port)\n        if ""QPID_SSL_CERT_DB"" in os.environ:\n            certdb = os.environ[""QPID_SSL_CERT_DB""]\n        else:\n            certdb = os.path.expanduser(""~/.qpid/"")\n        if ""QPID_SSL_CERT_NAME"" in os.environ:\n            certname = os.environ[""QPID_SSL_CERT_NAME""]\n        else:\n            certname = ""guest""\n        certfile = os.path.join(certdb, certname + "".crt"")\n        if ssl or (ssl is None and os.path.exists(certfile)):\n            keyfile = os.path.join(certdb, certname + "".key"")\n            trustfile = os.path.join(certdb, ""root.crt"")\n            socket = qpid.util.ssl(socket, keyfile=keyfile, certfile=certfile, ca_certs=trustfile)\n        self.__connection = qpid.connection.Connection(sock=socket, username=\'guest\', password=\'guest\')\n        self.__connection.start()\n        self.__session = self.__connection.session(str(qpid.datatypes.uuid4()))\n        self.subscribed = True\n        self.__queueStarted = False\n\n    def topicSubscribe(self, topicName, callback):\n        # if the queue is edex.alerts, set decompress to true always for now to\n        # maintain compatibility with existing python scripts.\n        if topicName == \'edex.alerts\':\n            self.decompress = True\n\n        print(""Establishing connection to broker on"", self.host)\n        queueName = topicName + self.__session.name\n        self.__session.queue_declare(queue=queueName, exclusive=True, auto_delete=True,\n                                     arguments={\'qpid.max_count\': 100, \'qpid.policy_type\': \'ring\'})\n        self.__session.exchange_bind(exchange=\'amq.topic\', queue=queueName, binding_key=topicName)\n        self.__innerSubscribe(queueName, callback)\n\n    def __innerSubscribe(self, serverQueueName, callback):\n        local_queue_name = \'local_queue_\' + serverQueueName\n        queue = self.__session.incoming(local_queue_name)\n        self.__session.message_subscribe(serverQueueName, destination=local_queue_name)\n        queue.start()\n        print(""Connection complete to broker on"", self.host)\n        self.__queueStarted = True\n\n        while self.subscribed:\n            try:\n                message = queue.get(timeout=10)\n                content = message.body\n                self.__session.message_accept(qpid.datatypes.RangedSet(message.id))\n                if self.decompress:\n                    try:\n                        # http://stackoverflow.com/questions/2423866/python-decompressing-gzip-chunk-by-chunk\n                        d = zlib.decompressobj(16+zlib.MAX_WBITS)\n                        content = d.decompress(content)\n                    except ValueError:\n                        # decompression failed, return the original content\n                        pass\n                callback(content)\n            except Empty:\n                pass\n            except Closed:\n                self.close()\n\n    def close(self):\n        self.__queueStarted = False\n        self.subscribed = False\n        try:\n            self.__session.close(timeout=10)\n        except ValueError:\n            pass\n\n    @property\n    def queueStarted(self):\n        return self.__queueStarted\n'"
awips/RadarCommon.py,0,"b'#\n# Common methods for the a2gtrad and a2advrad scripts.\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/13/2014      3393          nabowle        Initial creation to contain common\n#                                                 code for a2*radStub scripts.\n#    03/15/2015                    mjames@ucar    Edited/added to awips package as RadarCommon\n#\n#\n\n\ndef get_datetime_str(record):\n    """"""\n    Get the datetime string for a record.\n\n    Args:\n            record: the record to get data for.\n\n    Returns:\n            datetime string.\n    """"""\n    return str(record.getDataTime())[0:19].replace("" "", ""_"") + "".0""\n\n\ndef get_data_type(azdat):\n    """"""\n    Get the radar file type (radial or raster).\n\n    Args:\n            azdat: Boolean.\n\n    Returns:\n            Radial or raster.\n    """"""\n    if azdat:\n        return ""radial""\n    return ""raster""\n\n\ndef get_hdf5_data(idra):\n    rdat = []\n    azdat = []\n    depVals = []\n    threshVals = []\n    if idra:\n        for item in idra:\n            if item.getName() == ""Data"":\n                rdat = item\n            elif item.getName() == ""Angles"":\n                azdat = item\n                # dattyp = ""radial""\n            elif item.getName() == ""DependentValues"":\n                depVals = item.getShortData()\n            elif item.getName() == ""Thresholds"":\n                threshVals = item.getShortData()\n\n    return rdat, azdat, depVals, threshVals\n\n\ndef get_header(record, headerFormat, xLen, yLen, azdat, description):\n    # Encode dimensions, time, mapping, description, tilt, and VCP\n    mytime = get_datetime_str(record)\n    dattyp = get_data_type(azdat)\n\n    if headerFormat:\n        msg = str(xLen) + "" "" + str(yLen) + "" "" + mytime + "" "" + \\\n            dattyp + "" "" + str(record.getLatitude()) + "" "" +  \\\n            str(record.getLongitude()) + "" "" +  \\\n            str(record.getElevation()) + "" "" +  \\\n            str(record.getElevationNumber()) + "" "" +  \\\n            description + "" "" + str(record.getTrueElevationAngle()) + "" "" + \\\n            str(record.getVolumeCoveragePattern()) + ""\\n""\n    else:\n        msg = str(xLen) + "" "" + str(yLen) + "" "" + mytime + "" "" + \\\n            dattyp + "" "" + description + "" "" + \\\n            str(record.getTrueElevationAngle()) + "" "" + \\\n            str(record.getVolumeCoveragePattern()) + ""\\n""\n\n    return msg\n\n\ndef encode_thresh_vals(threshVals):\n    spec = [""."", ""TH"", ""ND"", ""RF"", ""BI"", ""GC"", ""IC"", ""GR"", ""WS"", ""DS"",\n            ""RA"", ""HR"", ""BD"", ""HA"", ""UK""]\n    nnn = len(threshVals)\n    j = 0\n    msg = """"\n    while j < nnn:\n        lo = threshVals[j] % 256\n        hi = threshVals[j] / 256\n        msg += "" ""\n        j += 1\n        if hi < 0:\n            if lo > 14:\n                msg += "".""\n            else:\n                msg += spec[lo]\n            continue\n        if hi % 16 >= 8:\n            msg += "">""\n        elif hi % 8 >= 4:\n            msg += ""<""\n        if hi % 4 >= 2:\n            msg += ""+""\n        elif hi % 2 >= 1:\n            msg += ""-""\n        if hi >= 64:\n            msg += ""%.2f"" % (lo*0.01)\n        elif hi % 64 >= 32:\n            msg += ""%.2f"" % (lo*0.05)\n        elif hi % 32 >= 16:\n            msg += ""%.1f"" % (lo*0.1)\n        else:\n            msg += str(lo)\n    msg += ""\\n""\n    return msg\n\n\ndef encode_dep_vals(depVals):\n    nnn = len(depVals)\n    j = 0\n    msg = []\n    while j < nnn:\n        msg.append(str(depVals[j]))\n        j += 1\n    return msg\n\n\ndef encode_radial(azVals):\n    azValsLen = len(azVals)\n    j = 0\n    msg = []\n    while j < azValsLen:\n        msg.append(azVals[j])\n        j += 1\n    return msg\n'"
awips/ThriftClient.py,0,"b'#\n# Provides a Python-based interface for executing Thrift requests.\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/20/10                      dgilling       Initial Creation.\n#\n#\n\ntry:\n    import http.client as httpcl\nexcept ImportError:\n    import httplib as httpcl\nfrom dynamicserialize import DynamicSerializationManager\n\n\nclass ThriftClient:\n\n    # How to call this constructor:\n    #   1. Pass in all arguments separately (e.g.,\n    #      ThriftClient.ThriftClient(""localhost"", 9581, ""/services""))\n    #      will return a Thrift client pointed at http://localhost:9581/services.\n    #   2. Pass in all arguments through the host string (e.g.,\n    #      ThriftClient.ThriftClient(""localhost:9581/services""))\n    #      will return a Thrift client pointed at http://localhost:9581/services.\n    #   3. Pass in host/port arguments through the host string (e.g.,\n    #      ThriftClient.ThriftClient(""localhost:9581"", ""/services""))\n    #      will return a Thrift client pointed at http://localhost:9581/services.\n    def __init__(self, host, port=9581, uri=""/services""):\n        hostParts = host.split(""/"", 1)\n        if len(hostParts) > 1:\n            hostString = hostParts[0]\n            self.__uri = ""/"" + hostParts[1]\n            self.__httpConn = httpcl.HTTPConnection(hostString)\n        else:\n            if port is None:\n                self.__httpConn = httpcl.HTTPConnection(host)\n            else:\n                self.__httpConn = httpcl.HTTPConnection(host, port)\n\n            self.__uri = uri\n\n        self.__dsm = DynamicSerializationManager.DynamicSerializationManager()\n\n    def sendRequest(self, request, uri=""/thrift""):\n        message = self.__dsm.serializeObject(request)\n\n        self.__httpConn.connect()\n        self.__httpConn.request(""POST"", self.__uri + uri, message)\n\n        response = self.__httpConn.getresponse()\n        if response.status != 200:\n            raise ThriftRequestException(""Unable to post request to server"")\n\n        rval = self.__dsm.deserializeBytes(response.read())\n        self.__httpConn.close()\n\n        # let\'s verify we have an instance of ServerErrorResponse\n        # IF we do, through an exception up to the caller along\n        # with the original Java stack trace\n        # ELSE: we have a valid response and pass it back\n        try:\n            forceError = rval.getException()\n            raise ThriftRequestException(forceError)\n        except AttributeError:\n            pass\n\n        return rval\n\n\nclass ThriftRequestException(Exception):\n    def __init__(self, value):\n        self.parameter = value\n\n    def __str__(self):\n        return repr(self.parameter)\n'"
awips/TimeUtil.py,0,"b'# ----------------------------------------------------------------------------\n# This software is in the public domain, furnished ""as is"", without technical\n# support, and with no warranty, express or implied, as to its usefulness for\n# any purpose.\n#\n# offsetTime.py\n# Handles Displaced Real Time for various applications\n#\n# Author: hansen/romberg\n# ----------------------------------------------------------------------------\n\nimport string\nimport time\n\n# Given the timeStr, return the offset (in seconds)\n# from the current time.\n# Also return the launchStr i.e. Programs launched from this\n# offset application will use the launchStr as the -z argument.\n# The offset will be positive for time in the future,\n# negative for time in the past.\n#\n# May still want it to be normalized to the most recent midnight.\n#\n# NOTES about synchronizing:\n# --With synchronizing on, the ""current time"" for all processes started\n#   within a given hour will be the same.\n#   This guarantees that GFE\'s have the same current time and ISC grid\n#   time stamps are syncrhonized and can be exchanged.\n#   Formatters launched from the GFE in this mode will be synchronized as\n#   well by setting the launchStr to use the time difference format\n#   (YYYYMMDD_HHMM,YYYYMMDD_HHMM).\n#   --This does not solve the problem in the general case.\n#     For example, if someone starts the GFE at 12:59 and someone\n#     else starts it at 1:01, they will have different offsets and\n#     current times.\n# --With synchronizing off, when the process starts, the current time\n#   matches the drtTime in the command line.  However, with synchronizing\n#   on, the current time will be offset by the fraction of the hour at\n#   which the process was started. Examples:\n#     Actual Starting time:             20040617_1230\n#     drtTime                           20040616_0000\n#     Synchronizing off:\n#        GFE Spatial Editor at StartUp: 20040616_0000\n#     Synchronizing on:\n#        GFE Spatial Editor at StartUp: 20040616_0030\n#\n\n\ndef determineDrtOffset(timeStr):\n    launchStr = timeStr\n    # Check for time difference\n    if timeStr.find("","") >= 0:\n        times = timeStr.split("","")\n        t1 = makeTime(times[0])\n        t2 = makeTime(times[1])\n        return t1-t2, launchStr\n    # Check for synchronized mode\n    synch = 0\n    if timeStr[0] == ""S"":\n        timeStr = timeStr[1:]\n        synch = 1\n    drt_t = makeTime(timeStr)\n    gm = time.gmtime()\n    cur_t = time.mktime(gm)\n\n    # Synchronize to most recent hour\n    # i.e. ""truncate"" cur_t to most recent hour.\n    if synch:\n        cur_t = time.mktime((gm[0], gm[1], gm[2], gm[3], 0, 0, 0, 0, 0))\n        curStr = \'%4s%2s%2s_%2s00\\n\' % (repr(gm[0]), repr(gm[1]),\n                                        repr(gm[2]), repr(gm[3]))\n        curStr = curStr.replace(\' \', \'0\')\n        launchStr = timeStr + "","" + curStr\n\n    offset = drt_t - cur_t\n    return int(offset), launchStr\n\n\ndef makeTime(timeStr):\n    year = string.atoi(timeStr[0:4])\n    month = string.atoi(timeStr[4:6])\n    day = string.atoi(timeStr[6:8])\n    hour = string.atoi(timeStr[9:11])\n    minute = string.atoi(timeStr[11:13])\n    # Do not use daylight savings because gmtime is not in daylight\n    # savings time.\n    return time.mktime((year, month, day, hour, minute, 0, 0, 0, 0))\n'"
awips/UsageArgumentParser.py,0,"b'#\n# SOFTWARE HISTORY\n#\n# Date          Ticket#  Engineer  Description\n# ------------- -------- --------- ---------------------------------------------\n# Feb 13, 2017  6092     randerso  Added StoreTimeAction\n#\n\nimport argparse\nimport sys\nimport time\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import DatabaseID\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import ParmID\n\nTIME_FORMAT = ""%Y%m%d_%H%M""\n\n\nclass UsageArgumentParser(argparse.ArgumentParser):\n    """"""\n    A subclass of ArgumentParser that overrides error() to print the\n    whole help text, rather than just the usage string.\n    """"""\n    def error(self, message):\n        sys.stderr.write(\'%s: error: %s\\n\' % (self.prog, message))\n        self.print_help()\n        sys.exit(2)\n\n\n# Custom actions for ArgumentParser objects\nclass StoreDatabaseIDAction(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n        did = DatabaseID(values)\n        if did.isValid():\n            setattr(namespace, self.dest, did)\n        else:\n            parser.error(""DatabaseID ["" + values + ""] not a valid identifier"")\n\n\nclass AppendParmNameAndLevelAction(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n        tx = ParmID.parmNameAndLevel(values)\n        comp = tx[0] + \'_\' + tx[1]\n        if (hasattr(namespace, self.dest)) and (getattr(namespace, self.dest) is not None):\n                currentValues = getattr(namespace, self.dest)\n                currentValues.append(comp)\n                setattr(namespace, self.dest, currentValues)\n        else:\n            setattr(namespace, self.dest, [comp])\n\n\nclass StoreTimeAction(argparse.Action):\n    """"""\n    argparse.Action subclass to validate GFE formatted time strings\n    and parse them to time.struct_time\n    """"""\n    def __call__(self, parser, namespace, values, option_string=None):\n        try:\n            timeStruct = time.strptime(values, TIME_FORMAT)\n            setattr(namespace, self.dest, timeStruct)\n        except ValueError:\n            parser.error(str(values) + "" is not a valid time string of the format YYYYMMDD_hhmm"")\n'"
awips/UsageOptionParser.py,0,"b'import sys\nfrom optparse import OptionParser\n\n\nclass UsageOptionParser(OptionParser):\n    """"""\n    A subclass of OptionParser that prints that overrides error() to print the\n    whole help text, rather than just the usage string.\n    """"""\n    def error(self, msg):\n        """"""\n        Print the help text and exit.\n        """"""\n        self.print_help(sys.stderr)\n        sys.stderr.write(""\\n"")\n        sys.stderr.write(msg)\n        sys.stderr.write(""\\n"")\n        sys.exit(2)\n'"
awips/__init__.py,0,b'\n__all__ = [\n           ]\n'
awips/qpidingest.py,0,"b'# ===============================================================================\n# qpidingest.py\n#\n# @author: Aaron Anderson\n# @organization: NOAA/WDTB OU/CIMMS\n# @version: 1.0 02/19/2010\n# @requires: QPID Python Client available from http://qpid.apache.org/download.html\n#            The Python Client is located under Single Component Package/Client\n#\n#            From the README.txt Installation Instructions\n#                = INSTALLATION =\n#                Extract the release archive into a directory of your choice and set\n#                your PYTHONPATH accordingly:\n#\n#                tar -xzf qpid-python-<version>.tar.gz -C <install-prefix>\n#                export PYTHONPATH=<install-prefix>/qpid-<version>/python\n#\n#       ***EDEX and QPID must be running for this module to work***\n#\n# DESCRIPTION:\n# This module is used to connect to QPID and send messages to the external.dropbox queue\n# which tells EDEX to ingest a data file from a specified path. This avoids having to copy\n# a data file into an endpoint. Each message also contains a header which is used to determine\n# which plugin should be used to decode the file. Each plugin has an xml file located in\n# $EDEX_HOME/data/utility/edex_static/base/distribution that contains regular expressions\n# that the header is compared to. When the header matches one of these regular expressions\n# the file is decoded with that plugin. If you make changes to one of these xml files you\n# must restart EDEX for the changes to take effect.\n#\n# NOTE: If the message is being sent but you do not see it being ingested in the EDEX log\n# check the xml files to make sure the header you are passing matches one of the regular\n# expressions. Beware of spaces, some regular expressions require spaces while others use\n# a wildcard character so a space is optional. It seems you are better off having the space\n# as this will be matched to both patterns. For the file in the example below,\n# 20100218_185755_SAUS46KLOX.metar, I use SAUS46 KLOX as the header to make sure it matches.\n#\n#\n# EXAMPLE:\n# Simple example program:\n#\n# ------------------------------------------------------------------------------\n# import qpidingest\n# #Tell EDEX to ingest a metar file from data_store. The filepath is\n# #/data_store/20100218/metar/00/standard/20100218_005920_SAUS46KSEW.metar\n#\n# conn=qpidingest.IngestViaQPID() #defaults to localhost port 5672\n#\n# #If EDEX is not on the local machine you can make the connection as follows\n# #conn=qpidingest.IngestViaQPID(host=\'<MACHINE NAME>\',port=<PORT NUMBER>)\n#\n# conn.sendmessage(\'/data_store/20100218/metar/18/standard/20100218_185755_SAUS46KLOX.metar\',\'SAUS46 KLOX\')\n# conn.close()\n# -------------------------------------------------------------------------------\n#\n#    SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ....\n#    06/13/2013      DR 16242      D. Friedman    Add Qpid authentication info\n#    03/06/2014      DR 17907      D. Friedman    Workaround for issue QPID-5569\n#    02/16/2017      DR 6084       bsteffen       Support ssl connections\n#\n# ===============================================================================\n\nimport os\nimport os.path\n\nimport qpid\nfrom qpid.util import connect\nfrom qpid.connection import Connection\nfrom qpid.datatypes import Message, uuid4\n\nQPID_USERNAME = \'guest\'\nQPID_PASSWORD = \'guest\'\n\n\nclass IngestViaQPID:\n    def __init__(self, host=\'localhost\', port=5672, ssl=None):\n        """"""\n        Connect to QPID and make bindings to route message to external.dropbox queue\n        @param host: string hostname of computer running EDEX and QPID (default localhost)\n        @param port: integer port used to connect to QPID (default 5672)\n        @param ssl: boolean to determine whether ssl is used, default value of None will use\n            ssl only if a client certificate is found.\n        """"""\n\n        try:\n            #\n            socket = connect(host, port)\n            if ""QPID_SSL_CERT_DB"" in os.environ:\n                certdb = os.environ[""QPID_SSL_CERT_DB""]\n            else:\n                certdb = os.path.expanduser(""~/.qpid/"")\n            if ""QPID_SSL_CERT_NAME"" in os.environ:\n                certname = os.environ[""QPID_SSL_CERT_NAME""]\n            else:\n                certname = QPID_USERNAME\n            certfile = os.path.join(certdb, certname + "".crt"")\n            if ssl or (ssl is None and os.path.exists(certfile)):\n                keyfile = os.path.join(certdb, certname + "".key"")\n                trustfile = os.path.join(certdb, ""root.crt"")\n                socket = qpid.util.ssl(socket, keyfile=keyfile, certfile=certfile, ca_certs=trustfile)\n            self.connection = Connection(sock=socket, username=QPID_USERNAME, password=QPID_PASSWORD)\n            self.connection.start()\n            self.session = self.connection.session(str(uuid4()))\n            self.session.exchange_bind(exchange=\'amq.direct\', queue=\'external.dropbox\', binding_key=\'external.dropbox\')\n            print(\'Connected to Qpid\')\n        except ValueError:\n            print(\'Unable to connect to Qpid\')\n\n    def sendmessage(self, filepath, header):\n        """"""\n        This function sends a message to the external.dropbox queue providing the path\n        to the file to be ingested and a header to determine the plugin to be used to\n        decode the file.\n        @param filepath: string full path to file to be ingested\n        @param header: string header used to determine plugin decoder to use\n        """"""\n        props = self.session.delivery_properties(routing_key=\'external.dropbox\')\n        head = self.session.message_properties(application_headers={\'header\': header},\n                                               user_id=QPID_USERNAME)\n        self.session.message_transfer(destination=\'amq.direct\', message=Message(props, head, filepath))\n\n    def close(self):\n        """"""\n        After all messages are sent call this function to close connection and make sure\n        there are no threads left open\n        """"""\n        self.session.close(timeout=10)\n        print(\'Connection to Qpid closed\')\n'"
awips/tables.py,1,"b'\nclass Item(object):\n    def __init__(self, *initial_data, **kwargs):\n        for dictionary in initial_data:\n            for key in dictionary:\n                setattr(self, key, dictionary[key])\n        for key in kwargs:\n            setattr(self, key, kwargs[key])\n\n\n#class GenerateNexradTable(object):\n#\timport numpy as np\n#\timport json\n#\t# find this file locally and confirm location\n#\tfilename = \'~/awips2-builds/edexOsgi/com.raytheon.edex.plugin.radar/utility/common_static/base/radarInfoSimple.txt\'\n#\tdata = np.genfromtxt(\n#\t\tfilename,\n#\t\tdelimiter="","",\n#\t\tautostrip=True,\n#\t\tskip_header=0,\n#\t\tnames=True,\n#\t\tdtype=None)\n#\n#\tfor x in data:\n#\t\tdefn = Item(dict(zip(data.dtype.names, x)))\n#\t\tprod = dict(zip(data.dtype.names, x))\n#\t\tnexrad[defn.id] = prod\n#\n#\treturn json.dumps(nexrad, indent=1)\n\n\nprofiler = {\n\t""74997"" : {\n\t\t""profilerId"": ""ASTC1"",\n\t\t""latitude"": 46.16,\n\t\t""longitude"": -123.88,\n\t\t""elevation"": 3,\n\t\t""profilerName"": ""Astoria OR""},\n\t""74996"" : {\n\t\t""profilerId"": ""BGDC1"",\n\t\t""latitude"": 38.32,\n\t\t""longitude"": -123.07,\n\t\t""elevation"": 13,\n\t\t""profilerName"": ""Bodega Bay CA""},\n\t""74995"" : {\n\t\t""profilerId"": ""FKSC1"",\n\t\t""latitude"": 47.97,\n\t\t""longitude"": -124.40,\n\t\t""elevation"": 92,\n\t\t""profilerName"": ""Forks WA""},\n\t""74998"" : {\n\t\t""profilerId"": ""ACVC1"",\n\t\t""latitude"": 40.97,\n\t\t""longitude"": -124.11,\n\t\t""elevation"": 56,\n\t\t""profilerName"": ""McKinleyville CA""},\n\t""74994"" : {\n\t\t""profilerId"": ""OTHC1"",\n\t\t""latitude"": 43.42,\n\t\t""longitude"": -124.24,\n\t\t""elevation"": 5,\n\t\t""profilerName"": ""North Bend OR""},\n\t""74993"" : {\n\t\t""profilerId"": ""PTSC1"",\n\t\t""latitude"": 36.30,\n\t\t""longitude"": -121.89,\n\t\t""elevation"": 11,\n\t\t""profilerName"": ""Point Sur CA""},\n\t""74992"" : {\n\t\t""profilerId"": ""SBAC1"",\n\t\t""latitude"": 34.43,\n\t\t""longitude"": -119.85,\n\t\t""elevation"": 4,\n\t\t""profilerName"": ""Santa Barbara CA""},\n\t""74991"" : {\n\t\t""profilerId"": ""PVLC1"",\n\t\t""latitude"": 40.18,\n\t\t""longitude"": -104.73,\n\t\t""elevation"": 1503,\n\t\t""profilerName"": ""Platteville CO""},\n\t""74990"" : {\n\t\t""profilerId"": ""TDEC1"",\n\t\t""latitude"": 45.55,\n\t\t""longitude"": -122.39,\n\t\t""elevation"": 12,\n\t\t""profilerName"": ""Troutdale OR""},\n\t""74989"" : {\n\t\t""profilerId"": ""CCOC1"",\n\t\t""latitude"": 39.70,\n\t\t""longitude"": -121.91,\n\t\t""elevation"": 42,\n\t\t""profilerName"": ""Chico CA""}\n}\n\nnexrad = {\n\t""2"": {\n\t\t""layer"": 0,\n\t\t""name"": ""NEXRAD Unit Status Msg"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""GSM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 2,\n\t\t""unit"": """"\n\t},\n\t""3"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Product Request Resp"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""PRR"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 3,\n\t\t""unit"": """"\n\t},\n\t""8"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Product List"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""PTL"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 8,\n\t\t""unit"": """"\n\t},\n\t""12"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Command Parameter Msg"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""CPM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 12,\n\t\t""unit"": """"\n\t},\n\t""14"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Command Control Msg"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""CCM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 14,\n\t\t""unit"": """"\n\t},\n\t""16"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 16,\n\t\t""unit"": ""dBZ""\n\t},\n\t""17"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 17,\n\t\t""unit"": ""dBZ""\n\t},\n\t""18"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 18,\n\t\t""unit"": ""dBZ""\n\t},\n\t""19"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 19,\n\t\t""unit"": ""dBZ""\n\t},\n\t""20"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 20,\n\t\t""unit"": ""dBZ""\n\t},\n\t""21"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 21,\n\t\t""unit"": ""dBZ""\n\t},\n\t""22"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""V"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""range"": 60,\n\t\t""lvls"": 8,\n\t\t""id"": 22,\n\t\t""unit"": ""kts""\n\t},\n\t""23"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 115,\n\t\t""lvls"": 8,\n\t\t""id"": 23,\n\t\t""unit"": ""kts""\n\t},\n\t""24"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 24,\n\t\t""unit"": ""kts""\n\t},\n\t""25"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 60,\n\t\t""lvls"": 16,\n\t\t""id"": 25,\n\t\t""unit"": ""kts""\n\t},\n\t""26"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 115,\n\t\t""lvls"": 16,\n\t\t""id"": 26,\n\t\t""unit"": ""kts""\n\t},\n\t""27"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 27,\n\t\t""unit"": ""kts""\n\t},\n\t""28"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spectrum Width"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""SW"",\n\t\t""range"": 60,\n\t\t""lvls"": 8,\n\t\t""id"": 28,\n\t\t""unit"": ""kts""\n\t},\n\t""29"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spectrum Width"",\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""SW"",\n\t\t""range"": 115,\n\t\t""lvls"": 8,\n\t\t""id"": 29,\n\t\t""unit"": ""kts""\n\t},\n\t""30"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spectrum Width"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""SW"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 30,\n\t\t""unit"": ""kts""\n\t},\n\t""31"": {\n\t\t""layer"": 0,\n\t\t""name"": ""User Select Precip"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""USP"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 31,\n\t\t""unit"": ""in""\n\t},\n\t""32"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Digital Hybrid Scan Refl"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""DHR"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -20., 0.5],\n\t\t""scale"": [-32.0, 94.5],\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 32,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""33"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hybrid Scan Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""HSR"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 33,\n\t\t""unit"": ""dBZ""\n\t},\n\t""34"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Clutter Filter Control"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CFC"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 34,\n\t\t""unit"": """"\n\t},\n\t""35"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Composite Refl"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CZ"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 35,\n\t\t""unit"": ""dBZ""\n\t},\n\t""36"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Composite Refl"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""CZ"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 36,\n\t\t""unit"": ""dBZ""\n\t},\n\t""37"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Composite Refl"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CZ"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 37,\n\t\t""unit"": ""dBZ""\n\t},\n\t""38"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Composite Refl"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""CZ"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 38,\n\t\t""unit"": ""dBZ""\n\t},\n\t""41"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Echo Tops"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""ET"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 41,\n\t\t""unit"": ""ft*1000""\n\t},\n\t""43"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Svr Wx Analysis - Ref"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""SWR"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 43,\n\t\t""unit"": """"\n\t},\n\t""44"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Svr Wx Analysis - Vel"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""SWV"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 44,\n\t\t""unit"": """"\n\t},\n\t""45"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Svr Wx Analysis - SW"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""SWW"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 45,\n\t\t""unit"": """"\n\t},\n\t""46"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Svr Wx Analysis - Shear"",\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""SWS"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 46,\n\t\t""unit"": """"\n\t},\n\t""47"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Severe Wx Prob"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""SWP"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 47,\n\t\t""unit"": """"\n\t},\n\t""48"": {\n\t\t""layer"": 0,\n\t\t""name"": ""VAD Wind Profile"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""VWP"",\n\t\t""range"": 0,\n\t\t""lvls"": 8,\n\t\t""id"": 48,\n\t\t""unit"": ""kts""\n\t},\n\t""50"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Ref X-Sect"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""RCS"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 50,\n\t\t""unit"": ""dBZ""\n\t},\n\t""51"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Vel X-Sect"",\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""VCS"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 51,\n\t\t""unit"": ""kts""\n\t},\n\t""55"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Rel Vel Region"",\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""SRR"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 55,\n\t\t""unit"": ""kts""\n\t},\n\t""56"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Rel Velocity"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [-100, 100],\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""SRM"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 56,\n\t\t""unit"": ""kts""\n\t},\n\t""57"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Vert Integ Liq"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""VIL"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 57,\n\t\t""unit"": ""kg/m\\u00b2""\n\t},\n\t""58"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Track"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""STI"",\n\t\t""range"": 345,\n\t\t""lvls"": 0,\n\t\t""id"": 58,\n\t\t""unit"": """"\n\t},\n\t""59"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hail Index"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""HI"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 59,\n\t\t""unit"": """"\n\t},\n\t""60"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Legacy Meso"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""M"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 60,\n\t\t""unit"": """"\n\t},\n\t""61"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Tornadic Vortex Sig"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""TVS"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 61,\n\t\t""unit"": """"\n\t},\n\t""62"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Structure"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""SS"",\n\t\t""range"": 460,\n\t\t""lvls"": 0,\n\t\t""id"": 62,\n\t\t""unit"": """"\n\t},\n\t""65"": {\n\t\t""layer"": 1,\n\t\t""name"": ""Layer 1 Max Refl"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""LRM"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 65,\n\t\t""unit"": ""dBZ""\n\t},\n\t""66"": {\n\t\t""layer"": 2,\n\t\t""name"": ""Lyr 2 Comp Ref Max"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""LRM"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 66,\n\t\t""unit"": ""dBZ""\n\t},\n\t""67"": {\n\t\t""layer"": 1,\n\t\t""name"": ""Lyr 1 Comp Ref Max"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""APR"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 67,\n\t\t""unit"": ""dBZ""\n\t},\n\t""74"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Radar Coded Message"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""RCM"",\n\t\t""range"": 460,\n\t\t""lvls"": 0,\n\t\t""id"": 74,\n\t\t""unit"": """"\n\t},\n\t""75"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Free Text Message"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""FTM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 75,\n\t\t""unit"": """"\n\t},\n\t""77"": {\n\t\t""layer"": 0,\n\t\t""name"": ""PUP Text Message"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""PTM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 77,\n\t\t""unit"": """"\n\t},\n\t""78"": {\n\t\t""layer"": 0,\n\t\t""name"": ""One Hour Precip"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""OHP"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 78,\n\t\t""unit"": ""in""\n\t},\n\t""79"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Three Hour Precip"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""THP"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 79,\n\t\t""unit"": ""in""\n\t},\n\t""80"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Precip"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""STP"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 80,\n\t\t""unit"": ""in""\n\t},\n\t""81"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Digital Precip Array"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""DPA"",\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 81,\n\t\t""unit"": """"\n\t},\n\t""82"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Supplemental Precip Data"",\n\t\t""res"": 40.0,\n\t\t""mnemo"": ""SPD"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 82,\n\t\t""unit"": """"\n\t},\n\t""83"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Intermediate Radar Message"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""IRM"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 83,\n\t\t""unit"": """"\n\t},\n\t""84"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity Azimuth Disp"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""VAD"",\n\t\t""range"": 0,\n\t\t""lvls"": 8,\n\t\t""id"": 84,\n\t\t""unit"": ""dBZ""\n\t},\n\t""85"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Ref X-Sect"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""RCS"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 85,\n\t\t""unit"": ""dBZ""\n\t},\n\t""86"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Vel X-Sect"",\n\t\t""res"": 0.5,\n\t\t""mnemo"": ""VCS"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 86,\n\t\t""unit"": ""kts""\n\t},\n\t""87"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Combined Shear"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""CS"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 87,\n\t\t""unit"": """"\n\t},\n\t""90"": {\n\t\t""layer"": 3,\n\t\t""name"": ""Lyr 3 Comp Ref Max"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""LRM"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 90,\n\t\t""unit"": ""dBZ""\n\t},\n\t""93"": {\n\t\t""layer"": 0,\n\t\t""name"": ""ITWS Digital Velocity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""DBV"",\n\t\t""range"": 115,\n\t\t""lvls"": 256,\n\t\t""id"": 93,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""94"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -20., 0.5],\n\t\t""scale"": [-32.0, 94.5],\n\t\t""lvls"": 256,\n\t\t""id"": 94,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""95"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Comp Refl Edited for AP"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CZE"",\n\t\t""range"": 230,\n\t\t""lvls"": 8,\n\t\t""id"": 95,\n\t\t""unit"": ""dBZ""\n\t},\n\t""96"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Comp Refl Edited for AP"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""CZE"",\n\t\t""range"": 460,\n\t\t""lvls"": 8,\n\t\t""id"": 96,\n\t\t""unit"": ""dBZ""\n\t},\n\t""97"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Comp Refl Edited for AP"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CZE"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 97,\n\t\t""unit"": ""dBZ""\n\t},\n\t""98"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Comp Refl Edited for AP"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""CZE"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 98,\n\t\t""unit"": ""dBZ""\n\t},\n\t""99"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 300,\n        \t""ctable"": [\'NWS8bitVel\', -100., 1.],\n        \t""scale"": [-100, 100],\n\t\t""lvls"": 256,\n\t\t""id"": 99,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""100"": {\n\t\t""layer"": 0,\n\t\t""name"": ""VAD Site Adapt Params"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""VSDT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 100,\n\t\t""unit"": """"\n\t},\n\t""101"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Track Alpha block"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""STIT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 101,\n\t\t""unit"": """"\n\t},\n\t""102"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hail Index Alpha block"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""HIT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 102,\n\t\t""unit"": """"\n\t},\n\t""103"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Mesocyclone Alpha block"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""MT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 103,\n\t\t""unit"": """"\n\t},\n\t""104"": {\n\t\t""layer"": 0,\n\t\t""name"": ""TVS Alpha block"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""TVST"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 104,\n\t\t""unit"": """"\n\t},\n\t""105"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Combined Shear Params"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""CST"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 105,\n\t\t""unit"": """"\n\t},\n\t""107"": {\n\t\t""layer"": 0,\n\t\t""name"": ""1hr Rainfall Params"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""OHPT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 107,\n\t\t""unit"": """"\n\t},\n\t""108"": {\n\t\t""layer"": 0,\n\t\t""name"": ""3hr Rainfall Params"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""THPT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 108,\n\t\t""unit"": """"\n\t},\n\t""109"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Params"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""STPT"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 109,\n\t\t""unit"": """"\n\t},\n\t""132"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Clutter Likelihood Refl"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CLR"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 132,\n\t\t""unit"": ""%""\n\t},\n\t""133"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Clutter Likelihood Dopp"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CLD"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 133,\n\t\t""unit"": ""%""\n\t},\n\t""134"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Digital Vert Integ Liq"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""DVL"",\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 134,\n\t\t""unit"": ""kg/m\\u00b2""\n\t},\n\t""135"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Enhanced Echo Tops"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""EET"",\n\t\t""ctable"": [\'NWSEnhancedEchoTops\', 2, 1],\n\t\t""scale"": [0, 255],\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 135,\n\t\t""unit"": ""ft*1000""\n\t},\n\t""136"": {\n\t\t""layer"": 0,\n\t\t""name"": ""SuperOb"",\n\t\t""res"": 4.0,\n\t\t""mnemo"": ""SO"",\n\t\t""range"": 0,\n\t\t""lvls"": 256,\n\t\t""id"": 136,\n\t\t""unit"": """"\n\t},\n\t""137"": {\n\t\t""layer"": 9,\n\t\t""name"": ""User Selectable Lyr Refl"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""ULR"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 137,\n\t\t""unit"": ""dBZ""\n\t},\n\t""138"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Precip"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""STP"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 10],\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 138,\n\t\t""unit"": ""in/100""\n\t},\n\t""139"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Rapid Update Mesocyclone"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""MRU"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 139,\n\t\t""unit"": """"\n\t},\n\t""140"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Gust Front MIGFA"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""GFM"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 140,\n\t\t""unit"": """"\n\t},\n\t""141"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Mesocyclone"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""MD"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 141,\n\t\t""unit"": """"\n\t},\n\t""143"": {\n\t\t""layer"": 0,\n\t\t""name"": ""TVS Rapid Update"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""TRU"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 143,\n\t\t""unit"": """"\n\t},\n\t""144"": {\n\t\t""layer"": 0,\n\t\t""name"": ""1-Hour Snow-Water Equiv"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""OSW"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 144,\n\t\t""unit"": ""in""\n\t},\n\t""145"": {\n\t\t""layer"": 0,\n\t\t""name"": ""1-Hour Snow Depth"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""OSD"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 145,\n\t\t""unit"": ""in""\n\t},\n\t""146"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Tot Snow-Water Equiv"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""SSW"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 146,\n\t\t""unit"": ""in""\n\t},\n\t""147"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Tot Snow Depth"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""SSD"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 147,\n\t\t""unit"": ""in""\n\t},\n\t""149"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Digital Mesocyclone Data"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""DMD"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 149,\n\t\t""unit"": """"\n\t},\n\t""150"": {\n\t\t""layer"": 0,\n\t\t""name"": ""User Sel Snow-Water Equiv"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""USW"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 150,\n\t\t""unit"": ""in""\n\t},\n\t""151"": {\n\t\t""layer"": 0,\n\t\t""name"": ""User Sel Snow Depth"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""USD"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 151,\n\t\t""unit"": ""in""\n\t},\n\t""152"": {\n\t\t""layer"": 0,\n\t\t""name"": ""RPG System Status"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""RSS"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 152,\n\t\t""unit"": """"\n\t},\n\t""153"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""HZ"",\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 153,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""154"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""HV"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 154,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""155"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spec Width"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""HSW"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 155,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""158"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Diff Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""ZDR"",\n\t\t""range"": 230,\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -4.0, 5.0],\n\t\t""lvls"": 16,\n\t\t""id"": 158,\n\t\t""unit"": ""dB""\n\t},\n\t""159"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Diff Reflectivity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""ZDR"",\n\t\t""range"": 300,\n    \t""ctable"": [\'NWSStormClearReflectivity\', -4.0, 5.0],\n\t\t""lvls"": 256,\n\t\t""id"": 159,\n\t\t""unit"": ""dB""\n\t},\n\t""160"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Correlation Coeff"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""CC"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 160,\n\t\t""unit"": """"\n\t},\n\t""161"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Correlation Coeff"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""CC"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 161,\n\t\t""unit"": """"\n\t},\n\t""162"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Specific Diff Phase"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""KDP"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 162,\n\t\t""unit"": ""deg/km""\n\t},\n\t""163"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Specific Diff Phase"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""KDP"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 163,\n\t\t""unit"": ""deg/km""\n\t},\n\t""164"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hydrometeor Class"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""HC"",\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 164,\n\t\t""unit"": """"\n\t},\n\t""165"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hydrometeor Class"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""HC"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 165,\n\t\t""unit"": ""/10""\n\t},\n\t""166"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Melting Layer"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""ML"",\n\t\t""range"": 230,\n\t\t""lvls"": 0,\n\t\t""id"": 166,\n\t\t""unit"": """"\n\t},\n\t""167"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Raw CC"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""SDC"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 167,\n\t\t""unit"": """"\n\t},\n\t""168"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Raw PHIDP"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""SDP"",\n\t\t""range"": 300,\n\t\t""lvls"": 256,\n\t\t""id"": 168,\n\t\t""unit"": ""deg""\n\t},\n\t""169"": {\n\t\t""layer"": 0,\n\t\t""name"": ""One Hour Accum"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""OHA"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 10],\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 169,\n\t\t""unit"": ""in""\n\t},\n\t""170"": {\n\t\t""layer"": 0,\n\t\t""name"": ""One Hour Unbiased Accum"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""DAA"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 10],\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 170,\n\t\t""unit"": ""in/100""\n\t},\n\t""171"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Accum"",\n\t\t""res"": 2.0,\n\t\t""mnemo"": ""STA"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 30],\n\t\t""range"": 230,\n\t\t""lvls"": 16,\n\t\t""id"": 171,\n\t\t""unit"": ""in""\n\t},\n\t""172"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Accum"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""STA"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 30],\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 172,\n\t\t""unit"": ""in/100""\n\t},\n\t""173"": {\n\t\t""layer"": 0,\n\t\t""name"": ""User Select Accum"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""DUA"",\n\t\t""ctable"": [\'NWSStormClearReflectivity\', -100., 1.],\n\t\t""scale"": [0, 30],\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 173,\n\t\t""unit"": ""in/100""\n\t},\n\t""174"": {\n\t\t""layer"": 0,\n\t\t""name"": ""One Hour Diff"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""DOD"",\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 174,\n\t\t""unit"": ""in/100""\n\t},\n\t""175"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Storm Total Diff"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""DSD"",\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 175,\n\t\t""unit"": ""in/100""\n\t},\n\t""176"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Digital Inst Precip Rate"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""DPR"",\n\t\t""ctable"": [\'NWS8bitVel\', -100., 1.],\n\t\t""scale"": [0, 16],\n\t\t""range"": 230,\n\t\t""lvls"": 65536,\n\t\t""id"": 176,\n\t\t""unit"": ""in/h""\n\t},\n\t""177"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Hybrid Hydrometeor Class"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""HHC"",\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 177,\n\t\t""unit"": ""/10""\n\t},\n\t""180"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 90,\n\t\t""lvls"": 256,\n\t\t""id"": 180,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""181"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 90,\n\t\t""lvls"": 16,\n\t\t""id"": 181,\n\t\t""unit"": ""dBZ""\n\t},\n\t""182"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 90,\n\t\t""lvls"": 256,\n\t\t""id"": 182,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""183"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Velocity"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 90,\n\t\t""lvls"": 16,\n\t\t""id"": 183,\n\t\t""unit"": ""kts""\n\t},\n\t""184"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spec Width"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""SW"",\n\t\t""range"": 90,\n\t\t""lvls"": 256,\n\t\t""id"": 184,\n\t\t""unit"": ""(m/s)/10""\n\t},\n\t""185"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Spectrum Width"",\n\t\t""res"": 0.15,\n\t\t""mnemo"": ""SW"",\n\t\t""range"": 90,\n\t\t""lvls"": 8,\n\t\t""id"": 185,\n\t\t""unit"": ""kts""\n\t},\n\t""186"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Long Range Refl"",\n\t\t""res"": 0.3,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 186,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""187"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Long Range Refl"",\n\t\t""res"": 0.3,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 16,\n\t\t""id"": 187,\n\t\t""unit"": ""dBZ""\n\t},\n\t""196"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Microburst AMDA"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""MBA"",\n\t\t""range"": 50,\n\t\t""lvls"": 0,\n\t\t""id"": 196,\n\t\t""unit"": """"\n\t},\n\t""202"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Shift Change Checklist"",\n\t\t""res"": 0.0,\n\t\t""mnemo"": ""SCC"",\n\t\t""range"": 0,\n\t\t""lvls"": 0,\n\t\t""id"": 202,\n\t\t""unit"": """"\n\t},\n\t""550"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 0.926,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 111,\n\t\t""lvls"": 8,\n\t\t""id"": 550,\n\t\t""unit"": ""dBZ""\n\t},\n\t""300"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Level II Reflectivity"",\n\t\t""res"": 1.0,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 460,\n\t\t""lvls"": 256,\n\t\t""id"": 300,\n\t\t""unit"": ""dBZ/10""\n\t},\n\t""301"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Level II Velocity"",\n\t\t""res"": 0.25,\n\t\t""mnemo"": ""V"",\n\t\t""range"": 230,\n\t\t""lvls"": 256,\n\t\t""id"": 301,\n\t\t""unit"": ""kts""\n\t},\n\t""500"": {\n\t\t""layer"": 0,\n\t\t""name"": ""Reflectivity"",\n\t\t""res"": 0.463,\n\t\t""mnemo"": ""Z"",\n\t\t""range"": 463,\n\t\t""lvls"": 8,\n\t\t""id"": 500,\n\t\t""unit"": ""dBZ""\n\t}\n}\n\n#\n# Dictionary that maps VTEC codes to headlines\n# Modified from com.raytheon.uf.edex.activetable/utility/common_static/base/vtec/VTECTable.py\n# Colornames from:\n# 1) https://www.weather.gov/bro/mapcolors\n# 2) https://digital.weather.gov/staticpages/definitions.php\n# 3) https://www.w3schools.com/colors/colors_names.asp\n#\nvtec = {\n    \'AF.W\' : {\'phen\': \'AF\',\n              \'sig\': \'W\',\n              \'color\': \'gray\',\n              \'hdln\': \'Ashfall Warning\'},\n    \'AF.Y\' : {\'phen\': \'AF\',\n              \'sig\': \'Y\',\n              \'color\': \'gray\',\n              \'hdln\': \'Ashfall Advisory\'},\n    \'AQ.Y\' : {\'phen\': \'AQ\',\n              \'sig\': \'Y\',\n              \'color\': \'gray\',\n              \'hdln\': \'Air Quality Alert\'},\n    \'AS.O\' : {\'phen\': \'AS\',\n              \'sig\': \'O\',\n              \'color\': \'gray\',\n              \'hdln\': \'Air Stagnation Outlook\'},\n    \'AS.Y\' : {\'phen\': \'AS\',\n              \'sig\': \'Y\',\n              \'color\': \'gray\',\n              \'hdln\': \'Air Stagnation Advisory\'},\n    \'BH.S\' : {\'phen\': \'BH\',\n              \'sig\': \'S\',\n              \'color\': \'turquoise\',\n              \'hdln\': \'Beach Hazards Statement\'},\n    \'BW.Y\' : {\'phen\': \'BW\',\n              \'sig\': \'Y\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Brisk Wind Advisory\'},\n    \'BZ.A\' : {\'phen\' : \'BZ\',\n              \'sig\' : \'A\',\n              \'color\': \'greenyellow\',\n              \'hdln\' : \'Blizzard Watch\'},\n    \'BZ.W\' : {\'phen\' : \'BZ\',\n              \'sig\' : \'W\',\n              \'color\': \'orangered\',\n              \'hdln\' : \'Blizzard Warning\'},\n    \'CF.A\' : {\'phen\': \'CF\',\n              \'sig\': \'A\',\n              \'color\': \'mediumaquamarine\',\n              \'hdln\': \'Coastal Flood Watch\'},\n    \'CF.W\' : {\'phen\': \'CF\',\n              \'sig\': \'W\',\n              \'color\': \'forestgreen\',\n              \'hdln\': \'Coastal Flood Warning\'},\n    \'CF.Y\' : {\'phen\': \'CF\',\n              \'sig\': \'Y\',\n              \'color\': \'lawngreen\',\n              \'hdln\': \'Coastal Flood Advisory\'},\n    \'CF.S\' : {\'phen\': \'CF\',\n              \'sig\': \'S\',\n              \'color\': \'olivedrab\',\n              \'hdln\': \'Coastal Flood Statement\'},\n    \'DS.W\' : {\'phen\': \'DS\',\n              \'sig\': \'W\',\n              \'color\': \'bisque\',\n              \'hdln\': \'Dust Storm Warning\'},\n    \'DU.Y\' : {\'phen\': \'DU\',\n              \'sig\': \'Y\',\n              \'color\': \'darkkhaki\',\n              \'hdln\': \'Blowing Dust Advisory\'},\n    \'EC.A\' : {\'phen\': \'EC\',\n              \'sig\': \'A\',\n              \'color\': \'blue\',\n              \'hdln\': \'Extreme Cold Watch\'},\n    \'EC.W\' : {\'phen\': \'EC\',\n              \'sig\': \'W\',\n              \'color\': \'blue\',\n              \'hdln\': \'Extreme Cold Warning\'},\n    \'EH.A\' : {\'phen\': \'EH\',\n              \'sig\': \'A\',\n              \'color\': \'maroon\',\n              \'hdln\': \'Excessive Heat Watch\'},\n    \'EH.W\' : {\'phen\': \'EH\',\n              \'sig\': \'W\',\n              \'color\': \'mediumvioletred\',\n              \'hdln\': \'Excessive Heat Warning\'},\n    \'EW.W\' : {\'phen\': \'EW\',\n              \'sig\': \'W\',\n              \'color\': \'deeppink\',\n              \'hdln\': \'Excessive Wind Warning\'},\n    \'FA.A\' : {\'phen\': \'FA\',\n              \'sig\': \'A\',\n              \'color\': \'seagreen\',\n              \'hdln\': \'Flood Watch\'},\n    \'FA.W\' : {\'phen\': \'FA\',\n              \'sig\': \'W\',\n              \'color\': \'seagreen\',\n              \'hdln\': \'Areal Flood Warning\'},\n    \'FA.Y\' : {\'phen\': \'FA\',\n              \'sig\': \'Y\',\n              \'color\': \'seagreen\',\n              \'hdln\': \'Areal Flood Advisory\'},\n    \'FF.A\' : {\'phen\': \'FF\',\n              \'sig\': \'A\',\n              \'color\': \'limegreen\',\n              \'hdln\': \'Flash Flood Watch\'},\n    \'FF.S\' : {\'phen\': \'FF\',\n              \'sig\': \'S\',\n              \'color\': \'yellowgreen\',\n              \'hdln\': \'Flash Flood Statement\'},\n    \'FF.W\' : {\'phen\': \'FF\',\n              \'sig\': \'W\',\n              \'color\': \'darkred\',\n              \'hdln\': \'Flash Flood Warning\'},\n    \'FG.Y\' : {\'phen\': \'FG\',\n              \'sig\': \'Y\',\n              \'color\': \'slategray\',\n              \'hdln\': \'Dense Fog Advisory\'},\n    \'FL.A\' : {\'phen\': \'FL\',\n              \'sig\': \'A\',\n              \'color\': \'seagreen\',\n              \'hdln\': \'Flood Watch\'},\n    \'FL.W\' : {\'phen\': \'FL\',\n              \'sig\': \'W\',\n              \'color\': \'green\',\n              \'hdln\': \'Flood Warning\'},\n    \'HY.S\' : {\'phen\': \'FL\',\n              \'sig\': \'S\',\n              \'color\': \'#00ff7f\',\n              \'hdln\': \'Hydrological Statement\'},\n    \'FL.S\' : {\'phen\': \'FL\',\n              \'sig\': \'S\',\n              \'color\': \'#00ff7f\',\n              \'hdln\': \'Flood Statement\'},\n    \'FL.Y\' : {\'phen\': \'FL\',\n              \'sig\': \'Y\',\n              \'color\': \'#00ff7f\',\n              \'hdln\': \'Flood Advisory\'},\n    \'FR.Y\' : {\'phen\': \'FR\',\n              \'sig\': \'Y\',\n              \'color\': \'cornflowerblue\',\n              \'hdln\': \'Frost Advisory\'},\n    \'FW.A\' : {\'phen\': \'FW\',\n              \'sig\': \'A\',\n              \'color\': \'navajowhite\',\n              \'hdln\': \'Fire Weather Watch\'},\n    \'FW.W\' : {\'phen\': \'FW\',\n              \'sig\': \'W\',\n              \'color\': \'deeppink\',\n              \'hdln\': \'Red Flag Warning\'},\n    \'FZ.A\' : {\'phen\': \'FZ\',\n              \'sig\': \'A\',\n              \'color\': \'royalblue\',\n              \'hdln\': \'Freeze Watch\'},\n    \'FZ.W\' : {\'phen\': \'FZ\',\n              \'sig\': \'W\',\n              \'color\': \'cyan\',\n              \'hdln\': \'Freeze Warning\'},\n    \'GL.A\' : {\'phen\': \'GL\',\n              \'sig\': \'A\',\n              \'color\': \'pink\',\n              \'hdln\': \'Gale Watch\'},\n    \'GL.W\' : {\'phen\': \'GL\',\n              \'sig\': \'W\',\n              \'color\': \'#dda0dd\',\n              \'hdln\': \'Gale Warning\'},\n    \'HF.A\' : {\'phen\': \'HF\',\n              \'sig\': \'A\',\n              \'color\': \'darkorchid\',\n              \'hdln\': \'Hurricane Force Wind Watch\'},\n    \'HF.W\' : {\'phen\': \'HF\',\n              \'sig\': \'W\',\n              \'color\': \'#cd5c5c\',\n              \'hdln\': \'Hurricane Force Wind Warning\'},\n    \'HT.Y\' : {\'phen\': \'HT\',\n              \'sig\': \'Y\',\n              \'color\': \'#ff7f4e\',\n              \'hdln\': \'Heat Advisory\'},\n    \'HU.A\' : {\'phen\': \'HU\',\n              \'sig\': \'A\',\n              \'color\': \'#ff00ff\',\n              \'hdln\': \'Hurricane Watch\'},\n    \'HU.S\' : {\'phen\': \'HU\',\n              \'sig\': \'S\',\n              \'color\': \'yellow\',\n              \'hdln\': \'Hurricane Statement\'},\n    \'HU.W\' : {\'phen\': \'HU\',\n              \'sig\': \'W\',\n              \'color\': \'#dc143c\',\n              \'hdln\': \'Hurricane Warning\'},\n    \'HW.A\' : {\'phen\': \'HW\',\n              \'sig\': \'A\',\n              \'color\': \'darkgoldenrod\',\n              \'hdln\': \'High Wind Watch\'},\n    \'HW.W\' : {\'phen\': \'HW\',\n              \'sig\': \'W\',\n              \'color\': \'goldenrod\',\n              \'hdln\': \'High Wind Warning\'},\n    \'HZ.A\' : {\'phen\': \'HZ\',\n              \'sig\': \'A\',\n              \'color\': \'royalblue\',\n              \'hdln\': \'Hard Freeze Watch\'},\n    \'HZ.W\' : {\'phen\': \'HZ\',\n              \'sig\': \'W\',\n              \'color\': \'blue\',\n              \'hdln\': \'Hard Freeze Warning\'},\n    \'IS.W\' : {\'phen\': \'IS\',\n              \'sig\': \'W\',\n              \'color\': \'darkmagenta\',\n              \'hdln\': \'Ice Storm Warning\'},\n    \'LE.A\' : {\'phen\': \'LE\',\n              \'sig\': \'A\',\n              \'color\': \'LightSkyBlue\',\n              \'hdln\': \'Lake Effect Snow Watch\'},\n    \'LE.W\' : {\'phen\': \'LE\',\n              \'sig\': \'W\',\n              \'color\': \'DarkCyan\',\n              \'hdln\': \'Lake Effect Snow Warning\'},\n    \'LE.Y\' : {\'phen\': \'LE\',\n              \'sig\': \'Y\',\n              \'color\': \'MediumTurquoise\',\n              \'hdln\': \'Lake Effect Snow Advisory\'},\n    \'LO.Y\' : {\'phen\': \'LO\',\n              \'sig\': \'Y\',\n              \'color\': \'maroon\',\n              \'hdln\': \'Low Water Advisory\'},\n    \'LS.A\' : {\'phen\': \'LS\',\n              \'sig\': \'A\',\n              \'color\': \'MediumAquaMarine\',\n              \'hdln\': \'Lakeshore Flood Watch\'},\n    \'LS.S\' : {\'phen\': \'LS\',\n              \'sig\': \'S\',\n              \'color\': \'lawngreen\',\n              \'hdln\': \'Lakeshore Flood Statement\'},\n    \'LS.W\' : {\'phen\': \'LS\',\n              \'sig\': \'W\',\n              \'color\': \'forestgreen\',\n              \'hdln\': \'Lakeshore Flood Warning\'},\n    \'LS.Y\' : {\'phen\': \'LS\',\n              \'sig\': \'Y\',\n              \'color\': \'lawngreen\',\n              \'hdln\': \'Lakeshore Flood Advisory\'},\n    \'LW.Y\' : {\'phen\': \'LW\',\n              \'sig\': \'Y\',\n              \'color\': \'tan\',\n              \'hdln\': \'Lake Wind Advisory\'},\n    \'MA.A\' : {\'phen\': \'MA\',\n              \'sig\': \'A\',\n              \'color\': \'peachpuff\',\n              \'hdln\': \'Special Marine Advisory\'},\n    \'MA.S\' : {\'phen\': \'MA\',\n              \'sig\': \'S\',\n              \'color\': \'peachpuff\',\n              \'hdln\': \'Special Marine Statement\'},\n    \'MA.W\' : {\'phen\': \'MA\',\n              \'sig\': \'W\',\n              \'color\': \'palevioletred\',\n              \'hdln\': \'Special Marine Warning\'},\n    \'MF.Y\' : {\'phen\': \'MF\',\n              \'sig\': \'Y\',\n              \'color\': \'slategray\',\n              \'hdln\': \'Dense Fog Advisory\'}, # Marine Fog\n    \'MH.W\' : {\'phen\': \'MH\',\n              \'sig\': \'W\',\n              \'color\': \'darkgray\',\n              \'hdln\': \'Ashfall Warning\'}, # Marine Ashfall\n    \'MH.Y\' : {\'phen\': \'MH\',\n              \'sig\': \'Y\',\n              \'color\': \'dimgray\',\n              \'hdln\': \'Ashfall Advisory\'}, # Marine Ashfall\n    \'MS.Y\' : {\'phen\': \'MS\',\n              \'sig\': \'Y\',\n              \'color\': \'khaki\',\n              \'hdln\': \'Dense Smoke Advisory\'}, # Marine Smoke\n    \'RB.Y\' : {\'phen\': \'RB\',\n              \'sig\': \'Y\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Small Craft Advisory for rough bar\'},\n    \'RP.S\' : {\'phen\': \'RP\',\n              \'sig\' : \'S\',\n              \'color\': \'turquoise\',\n              \'hdln\': \'High Rip Current Risk\'},\n    \'SC.Y\' : {\'phen\': \'SC\',\n              \'sig\': \'Y\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Small Craft Advisory\'},\n    \'SE.A\' : {\'phen\': \'SE\',\n              \'sig\': \'A\',\n              \'color\': \'darkslateblue\',\n              \'hdln\': \'Hazardous Seas Watch\'},\n    \'SE.W\' : {\'phen\': \'SE\',\n              \'sig\': \'W\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Hazardous Seas Warning\'},\n    \'SI.Y\' : {\'phen\': \'SI\',\n              \'sig\': \'Y\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Small Craft Advisory for winds\'},\n    \'SM.Y\' : {\'phen\': \'SM\',\n              \'sig\': \'Y\',\n              \'color\': \'khaki\',\n              \'hdln\': \'Dense Smoke Advisory\'},\n    \'SR.A\' : {\'phen\': \'SR\',\n              \'sig\': \'A\',\n              \'color\': \'violet\',\n              \'hdln\': \'Storm Watch\'},\n    \'SR.W\' : {\'phen\': \'SR\',\n              \'sig\': \'W\',\n              \'color\': \'darkorchid\',\n              \'hdln\': \'Storm Warning\'},\n    \'SS.A\' : {\'phen\': \'SS\',\n              \'sig\': \'A\',\n              \'color\': \'#DB7FF7\',\n              \'hdln\': \'Storm Surge Watch\'},\n    \'SS.W\' : {\'phen\': \'SS\',\n              \'sig\': \'W\',\n              \'color\': \'#B524F7\',\n              \'hdln\': \'Storm Surge Warning\'},\n    \'SU.W\' : {\'phen\': \'SU\',\n              \'sig\': \'W\',\n              \'color\': \'forestgreen\',\n              \'hdln\': \'High Surf Warning\'},\n    \'SU.Y\' : {\'phen\': \'SU\',\n              \'sig\': \'Y\',\n              \'color\': \'mediumorchid\',\n              \'hdln\': \'High Surf Advisory\'},\n    \'SV.A\' : {\'phen\': \'SV\',\n              \'sig\': \'A\',\n              \'color\': \'palevioletred\',\n              \'hdln\': \'Severe Thunderstorm Watch\'},\n    \'SV.S\' : {\'phen\': \'SV\',\n              \'sig\': \'S\',\n              \'color\': \'aqua\',\n              \'hdln\': \'Severe Weather Statement\'},\n    \'SV.W\' : {\'phen\': \'SV\',\n              \'sig\': \'W\',\n              \'color\': \'orange\',\n              \'hdln\': \'Severe Thunderstorm Warning\'},\n    \'SW.Y\' : {\'phen\': \'SW\',\n              \'sig\': \'Y\',\n              \'color\': \'thistle\',\n              \'hdln\': \'Small Craft Advisory for hazardous seas\'},\n    \'TO.A\' : {\'phen\': \'TO\',\n              \'sig\': \'A\',\n              \'color\': \'yellow\',\n              \'hdln\': \'Tornado Watch\'},\n    \'TO.W\' : {\'phen\': \'TO\',\n              \'sig\': \'W\',\n              \'color\': \'red\',\n              \'hdln\': \'Tornado Warning\'},\n    \'TR.A\' : {\'phen\': \'TR\',\n              \'sig\': \'A\',\n              \'color\': \'#f08080\',\n              \'hdln\': \'Tropical Storm Watch\'},\n    \'TR.W\' : {\'phen\': \'TR\',\n              \'sig\': \'W\',\n              \'color\': \'#b22222\',\n              \'hdln\': \'Tropical Storm Warning\'},\n    \'TS.A\' : {\'phen\': \'TS\',\n              \'sig\': \'A\',\n              \'color\': \'fuchsia\',\n              \'hdln\': \'Tsunami Watch\'},\n    \'TS.W\' : {\'phen\': \'TS\',\n              \'sig\': \'W\',\n              \'color\': \'#FD6347\',\n              \'hdln\': \'Tsunami Warning\'},\n    \'TS.Y\' : {\'phen\': \'TS\',\n              \'sig\': \'Y\',\n              \'color\': \'chocolate\',\n              \'hdln\': \'Tsunami Advisory\'},\n    \'TY.A\' : {\'phen\': \'TY\',\n              \'sig\': \'A\',\n              \'color\': \'fuchsia\',\n              \'hdln\': \'Typhoon Watch\'},\n    \'TY.W\' : {\'phen\': \'TY\',\n              \'sig\': \'W\',\n              \'color\': \'#FD6347\',\n              \'hdln\': \'Typhoon Warning\'},\n    \'UP.A\' : {\'phen\': \'UP\',\n              \'sig\': \'A\',\n              \'color\': \'RosyBrown\',\n              \'hdln\': \'Heavy Freezing Spray Watch\'},\n    \'UP.W\' : {\'phen\': \'UP\',\n              \'sig\': \'W\',\n              \'color\': \'#00C0FF\',\n              \'hdln\': \'Heavy Freezing Spray Warning\'},\n    \'UP.Y\' : {\'phen\': \'UP\',\n              \'sig\': \'Y\',\n              \'color\': \'#00C0FF\',\n              \'hdln\': \'Freezing Spray Advisory\'},\n    \'WC.A\' : {\'phen\': \'WC\',\n              \'sig\': \'A\',\n              \'color\': \'cadetblue\',\n              \'hdln\': \'Wind Chill Watch\'},\n    \'WC.W\' : {\'phen\': \'WC\',\n              \'sig\': \'W\',\n              \'color\': \'lightsteelblue\',\n              \'hdln\': \'Wind Chill Warning\'},\n    \'WC.Y\' : {\'phen\': \'WC\',\n              \'sig\': \'Y\',\n              \'color\': \'paleturquoise\',\n              \'hdln\': \'Wind Chill Advisory\'},\n    \'WI.Y\' : {\'phen\': \'WI\',\n              \'sig\': \'Y\',\n              \'color\': \'tan\',\n              \'hdln\': \'Wind Advisory\'},\n    \'WS.A\' : {\'phen\': \'WS\',\n              \'sig\': \'A\',\n              \'color\': \'#4682b4\',\n              \'hdln\': \'Winter Storm Watch\'},\n    \'WS.W\' : {\'phen\': \'WS\',\n              \'sig\': \'W\',\n              \'color\': \'hotpink\',\n              \'hdln\': \'Winter Storm Warning\'},\n    \'WW.Y\' : {\'phen\': \'WW\',\n              \'sig\': \'Y\',\n              \'color\': \'#7b68ee\',\n              \'hdln\': \'Winter Weather Advisory\'},\n    \'ZF.Y\' : {\'phen\': \'ZF\',\n              \'sig\': \'Y\',\n              \'color\': \'teal\',\n              \'hdln\': \'Freezing Fog Advisory\'},\n    \'ZR.Y\' : {\'phen\': \'ZR\',\n              \'sig\': \'Y\',\n              \'color\': \'orchid\',\n              \'hdln\': \'Freezing Rain Advisory\'},\n    }\n\n#\n# Upgrade Hazards Dictionary - upgradeHazardsDict is a dictionary of\n# phen/sig combinations defining upgrades. Each key is the proposed hazard.\n# The associated list are the hazards which are upgraded by the\n# proposed hazard.\n#\n\nupgradeHazardsDict = {\n\'WC.W\': [\'WC.A\', \'WC.Y\'],\n\'WC.Y\': [\'WC.A\'],\n\'BZ.W\': [\'WS.W\', \'LE.W\', \'ZR.Y\', \'LE.Y\', \'WW.Y\',\n         \'BZ.A\', \'WS.A\', \'LE.A\'],\n\'IS.W\': [\'WS.W\', \'LE.W\', \'ZR.Y\', \'LE.Y\', \'WW.Y\',\n         \'BZ.A\', \'WS.A\', \'LE.A\'],\n\'LE.W\': [\'ZR.Y\', \'LE.Y\', \'WW.Y\',\n         \'BZ.A\', \'WS.A\', \'LE.A\'],\n\'WS.W\': [\'ZR.Y\', \'LE.Y\', \'WW.Y\',\n         \'BZ.A\', \'WS.A\', \'LE.A\'],\n\'ZR.Y\': [\'BZ.A\', \'WS.A\', \'LE.A\'],\n\'LE.Y\': [\'BZ.A\', \'WS.A\', \'LE.A\'],\n\'WW.Y\': [\'BZ.A\', \'WS.A\', \'LE.A\'],\n\'EH.W\': [\'EH.A\', \'HT.Y\'],\n\'HT.Y\': [\'EH.A\'],\n\'FZ.W\': [\'FZ.A\', \'FR.Y\', \'HZ.A\'],\n\'HZ.W\': [\'FZ.A\', \'FR.Y\', \'HZ.A\'],\n\'FR.Y\': [\'FZ.A\', \'HZ.A\'],\n\'HW.W\': [\'DU.Y\', \'LW.Y\', \'WI.Y\', \'HW.A\'],\n\'DS.W\': [\'DU.Y\', \'LW.Y\', \'WI.Y\', \'HW.A\'],\n\'WI.Y\': [\'HW.A\'],\n\'EC.W\': [\'EC.A\'],\n\'FW.W\': [\'FW.A\'],\n\'CF.W\': [\'CF.A\', \'CF.Y\'],\n\'CF.Y\': [\'CF.A\'],\n\'LS.W\': [\'LS.A\', \'LS.Y\'],\n\'LS.Y\': [\'LS.A\'],\n\'BW.Y\': [\'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'RB.Y\': [\'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'SC.Y\': [\'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'SI.Y\': [\'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'SW.Y\': [\'SE.A\'],\n\'UP.Y\': [\'UP.A\'],\n\'HF.W\': [\'SR.W\', \'GL.W\', \'SC.Y\', \'SW.Y\', \'BW.Y\', \'SI.Y\', \'RB.Y\', \'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'SR.W\': [\'GL.W\', \'SC.Y\', \'SW.Y\', \'BW.Y\', \'SI.Y\', \'RB.Y\', \'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'GL.W\': [\'SC.Y\', \'SW.Y\', \'BW.Y\', \'SI.Y\', \'RB.Y\', \'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'SE.W\': [\'SC.Y\', \'RB.Y\', \'GL.A\', \'SR.A\', \'HF.A\', \'SE.A\'],\n\'UP.W\': [\'UP.Y\', \'UP.A\'],\n\'SU.W\': [\'SU.Y\'],\n\'SS.W\': [\'SS.A\'],\n\'HU.W\': [\'HU.A\', \'TR.W\', \'TR.A\'],\n\'HU.A\': [\'TR.A\'],\n\'TR.W\': [\'TR.A\', \'HU.A\', \'TY.A\'],\n\'TY.W\': [\'TY.A\', \'TR.W\', \'TR.A\'],\n\'TY.A\': [\'TR.A\'],\n\'AF.W\': [\'AF.Y\'],\n\'MH.W\': [\'MH.Y\'],\n }\n\n#\n# When passed a phen/sig for both the current hazard and the proposed hazard,\n# checkForUpgrade returns a 1 if the proposed hazard is an upgrade, otherwise 0\n#\n\ndef checkForUpgrade(pPhen, pSig, cPhen, cSig):\n    proposed = pPhen + ""."" + pSig\n    current = cPhen + ""."" + cSig\n    if proposed in upgradeHazardsDict:\n        if current in upgradeHazardsDict[proposed]:\n            return 1\n        else:\n            return 0\n    else:\n        return 0\n\n#\n# Downgrade Hazards Dictionary - downgradeHazardsDict is a dictionary of\n# phen/sig combinations defining downgrades. Each key is the proposed hazard.\n# The associated list are the hazards which are downgraded by the\n# proposed hazard.\n#\n\ndowngradeHazardsDict = {\n\'ZR.Y\': [\'BZ.W\', \'LE.W\', \'IS.W\', \'WS.W\'],\n\'LE.Y\': [\'BZ.W\', \'LE.W\', \'IS.W\', \'WS.W\'],\n\'WW.Y\': [\'BZ.W\', \'LE.W\', \'IS.W\', \'WS.W\'],\n\'WC.Y\': [\'WC.W\'],\n\'WS.W\': [\'BZ.W\', \'IS.W\'],\n\'LE.W\': [\'BZ.W\', \'IS.W\'],\n\'DU.Y\': [\'DS.W\', \'HW.W\'],\n\'LW.Y\': [\'DS.W\', \'HW.W\', \'WI.Y\'],\n\'WI.Y\': [\'DS.W\', \'HW.W\'],\n\'HT.Y\': [\'EH.W\'],\n\'FR.Y\': [\'FZ.W\', \'HZ.W\'],\n\'TR.W\': [\'HU.W\', \'TY.W\'],\n\'UP.Y\': [\'UP.W\'],\n\'SR.W\': [\'HF.W\'],\n\'GL.W\': [\'HF.W\', \'SR.W\'],\n\'SC.Y\': [\'HF.W\', \'SR.W\', \'GL.W\', \'SE.W\'],\n\'SW.Y\': [\'SE.W\'],\n\'RB.Y\': [\'HF.W\', \'SR.W\', \'GL.W\', \'SE.W\'],\n\'SU.Y\': [\'SU.W\'],\n\'BW.Y\': [\'HF.W\', \'SR.W\', \'GL.W\'],\n\'SI.Y\': [\'HF.W\', \'SR.W\', \'GL.W\'],\n\'LS.Y\': [\'LS.W\'],\n\'CF.Y\': [\'CF.W\'],\n\'AF.Y\': [\'AF.W\'],\n\'MH.Y\': [\'MH.W\'],\n}\n\n#\n# When passed a phen/sig for both the current hazard and the proposed hazard,\n# checkForDowngrade returns a 1 if the proposed hazard is an downgrade, otherwise 0\n#\n\ndef checkForDowngrade(pPhen, pSig, cPhen, cSig):\n    proposed = pPhen + ""."" + pSig\n    current = cPhen + ""."" + cSig\n    if proposed in downgradeHazardsDict:\n        if current in downgradeHazardsDict[proposed]:\n            return 1\n        else:\n            return 0\n    else:\n        return 0\n'"
dynamicserialize/DynamicSerializationManager.py,0,"b'#\n# A port of the Java DynamicSerializeManager.  Should be used to read/write\n# DynamicSerialize binary data.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/09/10                      njensen       Initial Creation.\n#\n\nfrom thrift.transport import TTransport\nfrom . import SelfDescribingBinaryProtocol, ThriftSerializationContext\n\n\nclass DynamicSerializationManager:\n\n    def __init__(self):\n        self.transport = None\n\n    def _deserialize(self, ctx):\n        return ctx.deserializeMessage()\n\n    def deserializeBytes(self, sbytes):\n        ctx = self._buildSerializationContext(sbytes)\n        ctx.readMessageStart()\n        obj = self._deserialize(ctx)\n        ctx.readMessageEnd()\n        return obj\n\n    def _buildSerializationContext(self, sbytes=None):\n        self.transport = TTransport.TMemoryBuffer(sbytes)\n        protocol = SelfDescribingBinaryProtocol.SelfDescribingBinaryProtocol(self.transport)\n        return ThriftSerializationContext.ThriftSerializationContext(self, protocol)\n\n    def serializeObject(self, obj):\n        ctx = self._buildSerializationContext()\n        ctx.writeMessageStart(""dynamicSerialize"")\n        self._serialize(ctx, obj)\n        ctx.writeMessageEnd()\n        return self.transport.getvalue()\n\n    def _serialize(self, ctx, obj):\n        ctx.serializeMessage(obj)\n'"
dynamicserialize/SelfDescribingBinaryProtocol.py,0,"b""#\n# Partially compatible AWIPS-II Thrift Binary Protocol\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    11/11/09                      chammack        Initial Creation.\n#    06/09/10                      njensen            Added float, list methods\n#    Apr 24, 2015    4425          nabowle         Add F64List support.\n#\n#\n\nimport struct\nimport numpy\nfrom thrift.protocol.TProtocol import *\nfrom thrift.protocol.TBinaryProtocol import *\n\nFLOAT = 64\n\nintList = numpy.dtype(numpy.int32).newbyteorder('>')\nfloatList = numpy.dtype(numpy.float32).newbyteorder('>')\nlongList = numpy.dtype(numpy.int64).newbyteorder('>')\nshortList = numpy.dtype(numpy.int16).newbyteorder('>')\nbyteList = numpy.dtype(numpy.int8).newbyteorder('>')\ndoubleList = numpy.dtype(numpy.float64).newbyteorder('>')\n\n\nclass SelfDescribingBinaryProtocol(TBinaryProtocol):\n\n    def readFieldBegin(self):\n        ftype = self.readByte()\n        if ftype == TType.STOP:\n            return None, ftype, 0\n        name = self.readString()\n        fid = self.readI16()\n        return name, ftype, fid\n\n    def readStructBegin(self):\n        return self.readString()\n\n    def writeStructBegin(self, name):\n        self.writeString(name)\n\n    def writeFieldBegin(self, name, ftype, fid):\n        self.writeByte(ftype)\n        self.writeString(name)\n        self.writeI16(fid)\n\n    def readFloat(self):\n        d = self.readI32()\n        dAsBytes = struct.pack('i', d)\n        f = struct.unpack('f', dAsBytes)\n        return f[0]\n\n    def writeFloat(self, f):\n        dAsBytes = struct.pack('f', f)\n        i = struct.unpack('i', dAsBytes)\n        self.writeI32(i[0])\n\n    def readI32List(self, sz):\n        buff = self.trans.readAll(4*sz)\n        val = numpy.frombuffer(buff, dtype=intList, count=sz)\n        return val\n\n    def readF32List(self, sz):\n        buff = self.trans.readAll(4*sz)\n        val = numpy.frombuffer(buff, dtype=floatList, count=sz)\n        return val\n\n    def readF64List(self, sz):\n        buff = self.trans.readAll(8*sz)\n        val = numpy.frombuffer(buff, dtype=doubleList, count=sz)\n        return val\n\n    def readI64List(self, sz):\n        buff = self.trans.readAll(8*sz)\n        val = numpy.frombuffer(buff, dtype=longList, count=sz)\n        return val\n\n    def readI16List(self, sz):\n        buff = self.trans.readAll(2*sz)\n        val = numpy.frombuffer(buff, dtype=shortList, count=sz)\n        return val\n\n    def readI8List(self, sz):\n        buff = self.trans.readAll(sz)\n        val = numpy.frombuffer(buff, dtype=byteList, count=sz)\n        return val\n\n    def writeI32List(self, buff):\n        b = numpy.asarray(buff, intList)\n        self.trans.write(numpy.getbuffer(b))\n\n    def writeF32List(self, buff):\n        b = numpy.asarray(buff, floatList)\n        self.trans.write(numpy.getbuffer(b))\n\n    def writeF64List(self, buff):\n        b = numpy.asarray(buff, doubleList)\n        self.trans.write(numpy.getbuffer(b))\n\n    def writeI64List(self, buff):\n        b = numpy.asarray(buff, longList)\n        self.trans.write(numpy.getbuffer(b))\n\n    def writeI16List(self, buff):\n        b = numpy.asarray(buff, shortList)\n        self.trans.write(numpy.getbuffer(b))\n\n    def writeI8List(self, buff):\n        b = numpy.asarray(buff, byteList)\n        self.trans.write(numpy.getbuffer(b))\n"""
dynamicserialize/ThriftSerializationContext.py,0,"b'#\n# A port of the Java ThriftSerializationContext, used for reading/writing\n# DynamicSerialize objects to/from thrift.\n#\n# For serialization, it has no knowledge of the expected types in other\n# languages, it is instead all based on inspecting the types of the objects\n# passed to it.  Therefore, ensure the types of python objects and primitives\n# match what they should be in the destination language.\n#\n#\n#    SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/09/10                      njensen       Initial Creation.\n#    06/12/13         #2099        dgilling      Implement readObject() and\n#                                                writeObject().\n#    Apr 24, 2015    4425          nabowle       Add Double support\n#    Oct 17, 2016    5919          njensen       Optimized for speed\n#    Sep 06, 2018                  mjames@ucar   Python3 compliance\n#\n#\n\nimport inspect\nimport sys\nimport types\nimport six\nimport numpy\nfrom thrift.Thrift import TType\nimport dynamicserialize\nfrom dynamicserialize import dstypes, adapters\nfrom dynamicserialize import SelfDescribingBinaryProtocol\n\nDS_LEN = len(\'dynamicserialize.dstypes.\')\n\ndsObjTypes = {}\n\n\ndef buildObjMap(module):\n    if \'__all__\' in module.__dict__:\n        for i in module.__all__:\n            name = module.__name__ + \'.\' + i\n            __import__(name)\n            buildObjMap(sys.modules[name])\n    else:\n        clzName = module.__name__[module.__name__.rfind(\'.\') + 1:]\n        clz = module.__dict__[clzName]\n        tname = module.__name__\n        tname = tname[DS_LEN:]\n        dsObjTypes[tname] = clz\n\n\nbuildObjMap(dstypes)\n\nif six.PY2:\n    pythonToThriftMap = {\n        types.StringType: TType.STRING,\n        types.IntType: TType.I32,\n        types.LongType: TType.I64,\n        types.ListType: TType.LIST,\n        unicode: TType.STRING,\n        types.DictionaryType: TType.MAP,\n        type(set([])): TType.SET,\n        types.FloatType: SelfDescribingBinaryProtocol.FLOAT,\n        # types.FloatType: TType.DOUBLE,\n        types.BooleanType: TType.BOOL,\n        types.InstanceType: TType.STRUCT,\n        types.NoneType: TType.VOID,\n        numpy.float32: SelfDescribingBinaryProtocol.FLOAT,\n        numpy.int32: TType.I32,\n        numpy.ndarray: TType.LIST,\n        numpy.object_: TType.STRING,  # making an assumption here\n        numpy.string_: TType.STRING,\n        numpy.float64: TType.DOUBLE,\n        numpy.int16: TType.I16,\n        numpy.int8: TType.BYTE,\n        numpy.int64: TType.I64\n    }\nelse:\n    pythonToThriftMap = {\n        bytes: TType.STRING,\n        int: TType.I32,\n        int: TType.I64,\n        list: TType.LIST,\n        dict: TType.MAP,\n        type(set([])): TType.SET,\n        float: SelfDescribingBinaryProtocol.FLOAT,\n        # types.FloatType: TType.DOUBLE,\n        bool: TType.BOOL,\n        object: TType.STRUCT,\n        str: TType.STRING,\n        type(None): TType.VOID,\n        numpy.float32: SelfDescribingBinaryProtocol.FLOAT,\n        numpy.int32: TType.I32,\n        numpy.ndarray: TType.LIST,\n        numpy.object_: TType.STRING,  # making an assumption here\n        numpy.string_: TType.STRING,\n        numpy.float64: TType.DOUBLE,\n        numpy.int16: TType.I16,\n        numpy.int8: TType.BYTE,\n        numpy.int64: TType.I64\n    }\n\nprimitiveSupport = (TType.BYTE, TType.I16, TType.I32, TType.I64,\n                    SelfDescribingBinaryProtocol.FLOAT, TType.DOUBLE)\n\n\nclass ThriftSerializationContext(object):\n\n    def __init__(self, serializationManager, selfDescribingBinaryProtocol):\n        self.serializationManager = serializationManager\n        self.protocol = selfDescribingBinaryProtocol\n        self.typeDeserializationMethod = {\n            TType.STRING: self.protocol.readString,\n            TType.I16: self.protocol.readI16,\n            TType.I32: self.protocol.readI32,\n            TType.LIST: self._deserializeArray,\n            TType.MAP: self._deserializeMap,\n            TType.SET: self._deserializeSet,\n            SelfDescribingBinaryProtocol.FLOAT: self.protocol.readFloat,\n            TType.BYTE: self.protocol.readByte,\n            TType.I64: self.protocol.readI64,\n            TType.DOUBLE: self.protocol.readDouble,\n            TType.BOOL: self.protocol.readBool,\n            TType.STRUCT: self.deserializeMessage,\n            TType.VOID: lambda: None\n        }\n        self.typeSerializationMethod = {\n            TType.STRING: self.protocol.writeString,\n            TType.I16: self.protocol.writeI16,\n            TType.I32: self.protocol.writeI32,\n            TType.LIST: self._serializeArray,\n            TType.MAP: self._serializeMap,\n            TType.SET: self._serializeSet,\n            SelfDescribingBinaryProtocol.FLOAT: self.protocol.writeFloat,\n            TType.BYTE: self.protocol.writeByte,\n            TType.I64: self.protocol.writeI64,\n            TType.DOUBLE: self.protocol.writeDouble,\n            TType.BOOL: self.protocol.writeBool,\n            TType.STRUCT: self.serializeMessage,\n            TType.VOID: lambda x: None\n        }\n        self.listDeserializationMethod = {\n            TType.BYTE: self.protocol.readI8List,\n            TType.I16: self.protocol.readI16List,\n            TType.I32: self.protocol.readI32List,\n            TType.I64: self.protocol.readI64List,\n            SelfDescribingBinaryProtocol.FLOAT: self.protocol.readF32List,\n            TType.DOUBLE: self.protocol.readF64List\n        }\n        self.listSerializationMethod = {\n            TType.BYTE: self.protocol.writeI8List,\n            TType.I16: self.protocol.writeI16List,\n            TType.I32: self.protocol.writeI32List,\n            TType.I64: self.protocol.writeI64List,\n            SelfDescribingBinaryProtocol.FLOAT: self.protocol.writeF32List,\n            TType.DOUBLE: self.protocol.writeF64List\n        }\n\n    def readMessageStart(self):\n        msg = self.protocol.readMessageBegin()\n        return msg[0]\n\n    def readMessageEnd(self):\n        self.protocol.readMessageEnd()\n\n    def deserializeMessage(self):\n        name = self.protocol.readStructBegin()\n        name = name.decode(\'cp437\')\n        name = name.replace(\'_\', \'.\')\n        if name.isdigit():\n            obj = self._deserializeType(int(name))\n            return obj\n        if name in adapters.classAdapterRegistry:\n            return adapters.classAdapterRegistry[name].deserialize(self)\n        elif \'$\' in name:\n            # it\'s an inner class, we\'re going to hope it\'s an enum, treat it\n            # special\n            fieldName, fieldType, fieldId = self.protocol.readFieldBegin()\n            if fieldName.decode(\'utf8\') != \'__enumValue__\':\n                raise dynamicserialize.SerializationException(\n                    ""Expected to find enum payload.  Found: "" + fieldName)\n            obj = self.protocol.readString()\n            self.protocol.readFieldEnd()\n            return obj\n        else:\n            clz = dsObjTypes[name]\n            obj = clz()\n\n        while self._deserializeField(obj):\n            pass\n\n        self.protocol.readStructEnd()\n        return obj\n\n    def _deserializeType(self, b):\n        try:\n            return self.typeDeserializationMethod[b]()\n        except KeyError:\n            raise dynamicserialize.SerializationException(\n                ""Unsupported type value "" + str(b))\n\n    def _deserializeField(self, obj):\n        fieldName, fieldType, fieldId = self.protocol.readFieldBegin()\n        if fieldType == TType.STOP:\n            return False\n        elif fieldType != TType.VOID:\n            result = self._deserializeType(fieldType)\n            fn_str = bytes.decode(fieldName)\n            lookingFor = ""set"" + fn_str[0].upper() + fn_str[1:]\n\n            try:\n                setMethod = getattr(obj, lookingFor)\n                setMethod(result)\n            except ValueError:\n                raise dynamicserialize.SerializationException(\n                    ""Couldn\'t find setter method "" + lookingFor)\n\n        self.protocol.readFieldEnd()\n        return True\n\n    def _deserializeArray(self):\n        listType, size = self.protocol.readListBegin()\n        result = []\n        if size:\n            if listType not in primitiveSupport:\n                m = self.typeDeserializationMethod[listType]\n                result = [m() for __ in range(size)]\n            else:\n                result = self.listDeserializationMethod[listType](size)\n        self.protocol.readListEnd()\n        return result\n\n    def _deserializeMap(self):\n        keyType, valueType, size = self.protocol.readMapBegin()\n        result = {}\n        for __ in range(size):\n            # can\'t go off the type, due to java generics limitations dynamic serialize is\n            # serializing keys and values as void\n            key = self.typeDeserializationMethod[TType.STRUCT]()\n            value = self.typeDeserializationMethod[TType.STRUCT]()\n            result[key] = value\n        self.protocol.readMapEnd()\n        return result\n\n    def _deserializeSet(self):\n        setType, setSize = self.protocol.readSetBegin()\n        result = set([])\n        for __ in range(setSize):\n            result.add(self.typeDeserializationMethod[TType.STRUCT]())\n        self.protocol.readSetEnd()\n        return result\n\n    def _lookupType(self, obj):\n        pyt = type(obj)\n        if pyt in pythonToThriftMap:\n            return pythonToThriftMap[pyt]\n        elif pyt.__module__[:DS_LEN - 1] == (\'dynamicserialize.dstypes\'):\n            if six.PY2:\n                return pythonToThriftMap[types.InstanceType]\n            return pythonToThriftMap[object]\n        raise dynamicserialize.SerializationException(\n            ""Don\'t know how to serialize object of type: "" + str(pyt))\n\n    def serializeMessage(self, obj):\n        tt = self._lookupType(obj)\n\n        if tt == TType.STRUCT:\n            fqn = obj.__module__[DS_LEN:]\n            if fqn in adapters.classAdapterRegistry:\n                # get proper class name when writing class name to serialization stream\n                # in case we have a special inner-class case\n                m = sys.modules[adapters.classAdapterRegistry[fqn].__name__]\n                if isinstance(m.ClassAdapter, list):\n                    fqn = m.ClassAdapter[0]\n                self.protocol.writeStructBegin(fqn)\n                adapters.classAdapterRegistry[fqn].serialize(self, obj)\n                return\n            else:\n                self.protocol.writeStructBegin(fqn)\n                methods = inspect.getmembers(obj, inspect.ismethod)\n                fid = 1\n                for m in methods:\n                    methodName = m[0]\n                    if methodName.startswith(\'get\'):\n                        fieldname = methodName[3].lower() + methodName[4:]\n                        val = m[1]()\n                        ft = self._lookupType(val)\n                        if ft == TType.STRUCT:\n                            self._serializeField(fieldname, ft, fid, val)\n                        else:\n                            self._serializeField(fieldname, ft, fid, val)\n                        fid += 1\n                self.protocol.writeFieldStop()\n\n                self.protocol.writeStructEnd()\n        else:\n            # basic types\n            self.protocol.writeStructBegin(str(tt))\n            self._serializeType(obj, tt)\n            self.protocol.writeStructEnd()\n\n    def _serializeField(self, fieldName, fieldType, fieldId, fieldValue):\n        self.protocol.writeFieldBegin(fieldName, fieldType, fieldId)\n        self._serializeType(fieldValue, fieldType)\n        self.protocol.writeFieldEnd()\n\n    def _serializeType(self, fieldValue, fieldType):\n        if fieldType in self.typeSerializationMethod:\n            return self.typeSerializationMethod[fieldType](fieldValue)\n        else:\n            raise dynamicserialize.SerializationException(\n                ""Unsupported type value "" + str(fieldType))\n\n    def _serializeArray(self, obj):\n        size = len(obj)\n        if size:\n            if isinstance(obj, numpy.ndarray):\n                t = pythonToThriftMap[obj.dtype.type]\n                size = obj.size\n            else:\n                t = self._lookupType(obj[0])\n        else:\n            t = TType.STRUCT\n        self.protocol.writeListBegin(t, size)\n        if t == TType.STRING:\n            if isinstance(obj, numpy.ndarray):\n                if len(obj.shape) == 1:\n                    for x in obj:\n                        s = str(x).strip()\n                        self.typeSerializationMethod[t](s)\n                else:\n                    for x in obj:\n                        for y in x:\n                            s = str(y).strip()\n                            self.typeSerializationMethod[t](s)\n            else:\n                for x in obj:\n                    s = str(x)\n                    self.typeSerializationMethod[t](s)\n        elif t not in primitiveSupport:\n            for x in obj:\n                self.typeSerializationMethod[t](x)\n        else:\n            self.listSerializationMethod[t](obj)\n        self.protocol.writeListEnd()\n\n    def _serializeMap(self, obj):\n        size = len(obj)\n        self.protocol.writeMapBegin(TType.VOID, TType.VOID, size)\n        for k in list(obj.keys()):\n            self.typeSerializationMethod[TType.STRUCT](k)\n            self.typeSerializationMethod[TType.STRUCT](obj[k])\n        self.protocol.writeMapEnd()\n\n    def _serializeSet(self, obj):\n        size = len(obj)\n        self.protocol.writeSetBegin(TType.VOID, size)\n        for x in obj:\n            self.typeSerializationMethod[TType.STRUCT](x)\n        self.protocol.writeSetEnd()\n\n    def writeMessageStart(self, name):\n        self.protocol.writeMessageBegin(name, TType.VOID, 0)\n\n    def writeMessageEnd(self):\n        self.protocol.writeMessageEnd()\n\n    def readBool(self):\n        return self.protocol.readBool()\n\n    def writeBool(self, b):\n        self.protocol.writeBool(b)\n\n    def readByte(self):\n        return self.protocol.readByte()\n\n    def writeByte(self, b):\n        self.protocol.writeByte(b)\n\n    def readDouble(self):\n        return self.protocol.readDouble()\n\n    def writeDouble(self, d):\n        self.protocol.writeDouble(d)\n\n    def readFloat(self):\n        return self.protocol.readFloat()\n\n    def writeFloat(self, f):\n        self.protocol.writeFloat(f)\n\n    def readI16(self):\n        return self.protocol.readI16()\n\n    def writeI16(self, i):\n        self.protocol.writeI16(i)\n\n    def readI32(self):\n        return self.protocol.readI32()\n\n    def writeI32(self, i):\n        self.protocol.writeI32(i)\n\n    def readI64(self):\n        return self.protocol.readI64()\n\n    def writeI64(self, i):\n        self.protocol.writeI64(i)\n\n    def readString(self):\n        return self.protocol.readString()\n\n    def writeString(self, s):\n        self.protocol.writeString(s)\n\n    def readBinary(self):\n        numBytes = self.protocol.readI32()\n        return self.protocol.readI8List(numBytes)\n\n    def readFloatArray(self):\n        size = self.protocol.readI32()\n        return self.protocol.readF32List(size)\n\n    def writeFloatArray(self, floats):\n        self.protocol.writeI32(len(floats))\n        self.protocol.writeF32List(floats)\n\n    def readObject(self):\n        return self.deserializeMessage()\n\n    def writeObject(self, obj):\n        self.serializeMessage(obj)\n'"
dynamicserialize/__init__.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/20/10                      njensen       Initial Creation.\n#\n#\n\n__all__ = [\'SerializationException\']\n\nfrom . import dstypes, adapters\nfrom . import DynamicSerializationManager\n\n\nclass SerializationException(Exception):\n\n    def __init__(self, message=None):\n        self.message = message\n\n    def __str__(self):\n        if self.message:\n            return self.message\n        else:\n            return """"\n\n\ndef serialize(obj):\n    dsm = DynamicSerializationManager.DynamicSerializationManager()\n    return dsm.serializeObject(obj)\n\n\ndef deserialize(objbytes):\n    dsm = DynamicSerializationManager.DynamicSerializationManager()\n    return dsm.deserializeBytes(objbytes)\n'"
thrift/TSCons.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom os import path\nfrom SCons.Builder import Builder\n\n\ndef scons_env(env, add=\'\'):\n  opath = path.dirname(path.abspath(\'$TARGET\'))\n  lstr = \'thrift --gen cpp -o \' + opath + \' \' + add + \' $SOURCE\'\n  cppbuild = Builder(action=lstr)\n  env.Append(BUILDERS={\'ThriftCpp\': cppbuild})\n\n\ndef gen_cpp(env, dir, file):\n  scons_env(env)\n  suffixes = [\'_types.h\', \'_types.cpp\']\n  targets = [\'gen-cpp/\' + file + s for s in suffixes]\n  return env.ThriftCpp(targets, dir + file + \'.thrift\')\n'"
thrift/TSerialization.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom .protocol import TBinaryProtocol\nfrom .transport import TTransport\n\n\ndef serialize(thrift_object,\n              protocol_factory=TBinaryProtocol.TBinaryProtocolFactory()):\n    transport = TTransport.TMemoryBuffer()\n    protocol = protocol_factory.getProtocol(transport)\n    thrift_object.write(protocol)\n    return transport.getvalue()\n\n\ndef deserialize(base,\n                buf,\n                protocol_factory=TBinaryProtocol.TBinaryProtocolFactory()):\n    transport = TTransport.TMemoryBuffer(buf)\n    protocol = protocol_factory.getProtocol(transport)\n    base.read(protocol)\n    return base\n'"
thrift/Thrift.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport sys\n\n\nclass TType:\n  STOP   = 0\n  VOID   = 1\n  BOOL   = 2\n  BYTE   = 3\n  I08    = 3\n  DOUBLE = 4\n  I16    = 6\n  I32    = 8\n  I64    = 10\n  STRING = 11\n  UTF7   = 11\n  STRUCT = 12\n  MAP    = 13\n  SET    = 14\n  LIST   = 15\n  UTF8   = 16\n  UTF16  = 17\n\n  _VALUES_TO_NAMES = (\'STOP\',\n                      \'VOID\',\n                      \'BOOL\',\n                      \'BYTE\',\n                      \'DOUBLE\',\n                      None,\n                      \'I16\',\n                      None,\n                      \'I32\',\n                      None,\n                     \'I64\',\n                     \'STRING\',\n                     \'STRUCT\',\n                     \'MAP\',\n                     \'SET\',\n                     \'LIST\',\n                     \'UTF8\',\n                     \'UTF16\')\n\n\nclass TMessageType:\n  CALL = 1\n  REPLY = 2\n  EXCEPTION = 3\n  ONEWAY = 4\n\n\nclass TProcessor:\n  """"""Base class for procsessor, which works on two streams.""""""\n\n  def process(iprot, oprot):\n    pass\n\n\nclass TException(Exception):\n  """"""Base class for all thrift exceptions.""""""\n\n  # BaseException.message is deprecated in Python v[2.6,3.0)\n  if (2, 6, 0) <= sys.version_info < (3, 0):\n    def _get_message(self):\n      return self._message\n\n    def _set_message(self, message):\n      self._message = message\n    message = property(_get_message, _set_message)\n\n  def __init__(self, message=None):\n    Exception.__init__(self, message)\n    self.message = message\n\n\nclass TApplicationException(TException):\n  """"""Application level thrift exceptions.""""""\n\n  UNKNOWN = 0\n  UNKNOWN_METHOD = 1\n  INVALID_MESSAGE_TYPE = 2\n  WRONG_METHOD_NAME = 3\n  BAD_SEQUENCE_ID = 4\n  MISSING_RESULT = 5\n  INTERNAL_ERROR = 6\n  PROTOCOL_ERROR = 7\n\n  def __init__(self, type=UNKNOWN, message=None):\n    TException.__init__(self, message)\n    self.type = type\n\n  def __str__(self):\n    if self.message:\n      return self.message\n    elif self.type == self.UNKNOWN_METHOD:\n      return \'Unknown method\'\n    elif self.type == self.INVALID_MESSAGE_TYPE:\n      return \'Invalid message type\'\n    elif self.type == self.WRONG_METHOD_NAME:\n      return \'Wrong method name\'\n    elif self.type == self.BAD_SEQUENCE_ID:\n      return \'Bad sequence ID\'\n    elif self.type == self.MISSING_RESULT:\n      return \'Missing result\'\n    else:\n      return \'Default (unknown) TApplicationException\'\n\n  def read(self, iprot):\n    iprot.readStructBegin()\n    while True:\n      (fname, ftype, fid) = iprot.readFieldBegin()\n      if ftype == TType.STOP:\n        break\n      if fid == 1:\n        if ftype == TType.STRING:\n          self.message = iprot.readString()\n        else:\n          iprot.skip(ftype)\n      elif fid == 2:\n        if ftype == TType.I32:\n          self.type = iprot.readI32()\n        else:\n          iprot.skip(ftype)\n      else:\n        iprot.skip(ftype)\n      iprot.readFieldEnd()\n    iprot.readStructEnd()\n\n  def write(self, oprot):\n    oprot.writeStructBegin(\'TApplicationException\')\n    if self.message is not None:\n      oprot.writeFieldBegin(\'message\', TType.STRING, 1)\n      oprot.writeString(self.message)\n      oprot.writeFieldEnd()\n    if self.type is not None:\n      oprot.writeFieldBegin(\'type\', TType.I32, 2)\n      oprot.writeI32(self.type)\n      oprot.writeFieldEnd()\n    oprot.writeFieldStop()\n    oprot.writeStructEnd()\n'"
thrift/__init__.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n__all__ = [\'Thrift\', \'TSCons\']\n'"
awips/dataaccess/CombinedTimeQuery.py,0,"b'#\n# Method for performing a DAF time query where all parameter/level/location\n# combinations must be available at the same time.\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/22/16         #5591        bsteffen       Initial Creation.\n#\n\nfrom awips.dataaccess import DataAccessLayer\n\n\ndef getAvailableTimes(request, refTimeOnly=False):\n    return __getAvailableTimesForEachParameter(request, refTimeOnly)\n\n\ndef __getAvailableTimesForEachParameter(request, refTimeOnly=False):\n    parameters = request.getParameters()\n    if parameters:\n        times = None\n        for parameter in parameters:\n            specificRequest = __cloneRequest(request)\n            specificRequest.setParameters(parameter)\n            specificTimes = __getAvailableTimesForEachLevel(specificRequest, refTimeOnly)\n            if times is None:\n                times = specificTimes\n            else:\n                times.intersection_update(specificTimes)\n            if not times:\n                break\n        return times\n    else:\n        return __getAvailableTimesForEachLevel(request, refTimeOnly)\n\n\ndef __getAvailableTimesForEachLevel(request, refTimeOnly=False):\n    levels = request.getLevels()\n    if levels:\n        times = None\n        for level in levels:\n            specificRequest = __cloneRequest(request)\n            specificRequest.setLevels(level)\n            specificTimes = __getAvailableTimesForEachLocation(specificRequest, refTimeOnly)\n            if times is None:\n                times = specificTimes\n            else:\n                times.intersection_update(specificTimes)\n            if not times:\n                break\n        return times\n    else:\n        return __getAvailableTimesForEachLocation(request, refTimeOnly)\n\n\ndef __getAvailableTimesForEachLocation(request, refTimeOnly=False):\n    locations = request.getLocationNames()\n    if locations:\n        times = None\n        for location in locations:\n            specificRequest = __cloneRequest(request)\n            specificRequest.setLocationNames(location)\n            specificTimes = DataAccessLayer.getAvailableTimes(specificRequest, refTimeOnly)\n            if times is None:\n                times = set(specificTimes)\n            else:\n                times.intersection_update(specificTimes)\n            if not times:\n                break\n        return times\n    else:\n        return DataAccessLayer.getAvailableTimes(request, refTimeOnly)\n\n\ndef __cloneRequest(request):\n    return DataAccessLayer.newDataRequest(datatype=request.getDatatype(),\n                                          parameters=request.getParameters(),\n                                          levels=request.getLevels(),\n                                          locationNames=request.getLocationNames(),\n                                          envelope=request.getEnvelope(),\n                                          **request.getIdentifiers())\n'"
awips/dataaccess/DataAccessLayer.py,0,"b'#\n# Published interface for awips.dataaccess package\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date           Ticket#  Engineer    Description\n#    ------------   -------  ----------  -------------------------\n#    12/10/12                njensen     Initial Creation.\n#    Feb 14, 2013   1614     bsteffen    refactor data access framework to use single request.\n#    04/10/13       1871     mnash       move getLatLonCoords to JGridData and add default args\n#    05/29/13       2023     dgilling    Hook up ThriftClientRouter.\n#    03/03/14       2673     bsteffen    Add ability to query only ref times.\n#    07/22/14       3185     njensen     Added optional/default args to newDataRequest\n#    07/30/14       3185     njensen     Renamed valid identifiers to optional\n#    Apr 26, 2015   4259     njensen     Updated for new JEP API\n#    Apr 13, 2016   5379     tgurney     Add getIdentifierValues(), getRequiredIdentifiers(),\n#                                        and getOptionalIdentifiers()\n#    Oct 07, 2016   ----     mjames@ucar Added getForecastRun\n#    Oct 18, 2016   5916     bsteffen    Add setLazyLoadGridLatLon\n#    Oct 11, 2018   ----     mjames@ucar Added getMetarObs() getSynopticObs()\n#\n\nimport sys\nimport warnings\n\nTHRIFT_HOST = ""edex""\n\nUSING_NATIVE_THRIFT = False\n\nif \'jep\' in sys.modules:\n    # intentionally do not catch if this fails to import, we want it to\n    # be obvious that something is configured wrong when running from within\n    # Java instead of allowing false confidence and fallback behavior\n    import JepRouter\n    router = JepRouter\nelse:\n    from awips.dataaccess import ThriftClientRouter\n    router = ThriftClientRouter.ThriftClientRouter(THRIFT_HOST)\n    USING_NATIVE_THRIFT = True\n\n\ndef getRadarProductIDs(availableParms):\n    """"""\n    Get only the numeric idetifiers for NEXRAD3 products.\n\n    Args:\n            availableParms: Full list of radar parameters\n\n    Returns:\n            List of filtered parameters\n    """"""\n    productIDs = []\n    for p in list(availableParms):\n        try:\n            if isinstance(int(p), int):\n                productIDs.append(str(p))\n        except ValueError:\n            pass\n\n    return productIDs\n\n\ndef getRadarProductNames(availableParms):\n    """"""\n     Get only the named idetifiers for NEXRAD3 products.\n\n    Args:\n            availableParms: Full list of radar parameters\n\n    Returns:\n            List of filtered parameters\n    """"""\n    productNames = []\n    for p in list(availableParms):\n        if len(p) > 3:\n            productNames.append(p)\n\n    return productNames\n\n\ndef getMetarObs(response):\n    """"""\n    Processes a DataAccessLayer ""obs"" response into a dictionary,\n    with special consideration for multi-value parameters\n    ""presWeather"", ""skyCover"", and ""skyLayerBase"".\n\n    Args:\n            response: DAL getGeometry() list\n\n    Returns:\n            A dictionary of METAR obs\n    """"""\n    from datetime import datetime\n    single_val_params = [""timeObs"", ""stationName"", ""longitude"", ""latitude"",\n                         ""temperature"", ""dewpoint"", ""windDir"",\n                         ""windSpeed"", ""seaLevelPress""]\n    multi_val_params = [""presWeather"", ""skyCover"", ""skyLayerBase""]\n    params = single_val_params + multi_val_params\n    station_names, pres_weather, sky_cov, sky_layer_base = [], [], [], []\n    obs = dict({params: [] for params in params})\n    for ob in response:\n        avail_params = ob.getParameters()\n        if ""presWeather"" in avail_params:\n            pres_weather.append(ob.getString(""presWeather""))\n        elif ""skyCover"" in avail_params and ""skyLayerBase"" in avail_params:\n            sky_cov.append(ob.getString(""skyCover""))\n            sky_layer_base.append(ob.getNumber(""skyLayerBase""))\n        else:\n            # If we already have a record for this stationName, skip\n            if ob.getString(\'stationName\') not in station_names:\n                station_names.append(ob.getString(\'stationName\'))\n                for param in single_val_params:\n                    if param in avail_params:\n                        if param == \'timeObs\':\n                            obs[param].append(datetime.fromtimestamp(ob.getNumber(param) / 1000.0))\n                        else:\n                            try:\n                                obs[param].append(ob.getNumber(param))\n                            except TypeError:\n                                obs[param].append(ob.getString(param))\n                    else:\n                        obs[param].append(None)\n\n                obs[\'presWeather\'].append(pres_weather)\n                obs[\'skyCover\'].append(sky_cov)\n                obs[\'skyLayerBase\'].append(sky_layer_base)\n                pres_weather = []\n                sky_cov = []\n                sky_layer_base = []\n    return obs\n\n\ndef getSynopticObs(response):\n    """"""\n    Processes a DataAccessLayer ""sfcobs"" response into a dictionary\n    of available parameters.\n\n    Args:\n            response: DAL getGeometry() list\n\n    Returns:\n            A dictionary of synop obs\n    """"""\n    from datetime import datetime\n    station_names = []\n    params = response[0].getParameters()\n    sfcobs = dict({params: [] for params in params})\n    for sfcob in response:\n        # If we already have a record for this stationId, skip\n        if sfcob.getString(\'stationId\') not in station_names:\n            station_names.append(sfcob.getString(\'stationId\'))\n            for param in params:\n                if param == \'timeObs\':\n                    sfcobs[param].append(datetime.fromtimestamp(sfcob.getNumber(param) / 1000.0))\n                else:\n                    try:\n                        sfcobs[param].append(sfcob.getNumber(param))\n                    except TypeError:\n                        sfcobs[param].append(sfcob.getString(param))\n\n    return sfcobs\n\n\ndef getForecastRun(cycle, times):\n    """"""\n    Get the latest forecast run (list of objects) from all\n    all cycles and times returned from DataAccessLayer ""grid""\n    response.\n\n    Args:\n            cycle: Forecast cycle reference time\n            times: All available times/cycles\n\n    Returns:\n            DataTime array for a single forecast run\n    """"""\n    fcstRun = []\n    for t in times:\n        if str(t)[:19] == str(cycle):\n            fcstRun.append(t)\n    return fcstRun\n\n\ndef getAvailableTimes(request, refTimeOnly=False):\n    """"""\n    Get the times of available data to the request.\n\n    Args:\n            request: the IDataRequest to get data for\n            refTimeOnly: optional, use True if only unique refTimes should be\n                returned (without a forecastHr)\n\n    Returns:\n            a list of DataTimes\n    """"""\n    return router.getAvailableTimes(request, refTimeOnly)\n\n\ndef getGridData(request, times=[]):\n    """"""\n    Gets the grid data that matches the request at the specified times.  Each\n    combination of parameter, level, and dataTime will be returned as a\n    separate IGridData.\n\n    Args:\n            request: the IDataRequest to get data for\n            times: a list of DataTimes, a TimeRange, or None if the data is time\n                agnostic\n\n    Returns:\n            a list of IGridData\n    """"""\n    return router.getGridData(request, times)\n\n\ndef getGeometryData(request, times=[]):\n    """"""\n    Gets the geometry data that matches the request at the specified times.\n    Each combination of geometry, level, and dataTime will be returned as a\n    separate IGeometryData.\n\n    Args:\n            request: the IDataRequest to get data for\n            times: a list of DataTimes, a TimeRange, or None if the data is time\n                agnostic\n\n    Returns:\n       a list of IGeometryData\n    """"""\n    return router.getGeometryData(request, times)\n\n\ndef getAvailableLocationNames(request):\n    """"""\n    Gets the available location names that match the request without actually\n    requesting the data.\n\n    Args:\n            request: the request to find matching location names for\n\n    Returns:\n            a list of strings of available location names.\n    """"""\n    return router.getAvailableLocationNames(request)\n\n\ndef getAvailableParameters(request):\n    """"""\n    Gets the available parameters names that match the request without actually\n    requesting the data.\n\n    Args:\n            request: the request to find matching parameter names for\n\n    Returns:\n            a list of strings of available parameter names.\n    """"""\n    return router.getAvailableParameters(request)\n\n\ndef getAvailableLevels(request):\n    """"""\n    Gets the available levels that match the request without actually\n    requesting the data.\n\n    Args:\n            request: the request to find matching levels for\n\n    Returns:\n            a list of strings of available levels.\n    """"""\n    return router.getAvailableLevels(request)\n\n\ndef getRequiredIdentifiers(request):\n    """"""\n    Gets the required identifiers for this request.  These identifiers\n    must be set on a request for the request of this datatype to succeed.\n\n    Args:\n            request: the request to find required identifiers for\n\n    Returns:\n            a list of strings of required identifiers\n    """"""\n    if str(request) == request:\n        warnings.warn(""Use getRequiredIdentifiers(IDataRequest) instead"",\n                      DeprecationWarning)\n    return router.getRequiredIdentifiers(request)\n\n\ndef getOptionalIdentifiers(request):\n    """"""\n    Gets the optional identifiers for this request.\n\n    Args:\n            request: the request to find optional identifiers for\n\n    Returns:\n            a list of strings of optional identifiers\n    """"""\n    if str(request) == request:\n        warnings.warn(""Use getOptionalIdentifiers(IDataRequest) instead"",\n                      DeprecationWarning)\n    return router.getOptionalIdentifiers(request)\n\n\ndef getIdentifierValues(request, identifierKey):\n    """"""\n    Gets the allowed values for a particular identifier on this datatype.\n\n    Args:\n            request: the request to find identifier values for\n            identifierKey: the identifier to find values for\n\n    Returns:\n            a list of strings of allowed values for the specified identifier\n    """"""\n    return router.getIdentifierValues(request, identifierKey)\n\n\ndef newDataRequest(datatype=None, **kwargs):\n    """"""\n    Creates a new instance of IDataRequest suitable for the runtime environment.\n    All args are optional and exist solely for convenience.\n\n    Args:\n            datatype: the datatype to create a request for\n            parameters: a list of parameters to set on the request\n            levels: a list of levels to set on the request\n            locationNames: a list of locationNames to set on the request\n            envelope: an envelope to limit the request\n            kwargs: any leftover kwargs will be set as identifiers\n\n    Returns:\n            a new IDataRequest\n    """"""\n    return router.newDataRequest(datatype, **kwargs)\n\n\ndef getSupportedDatatypes():\n    """"""\n    Gets the datatypes that are supported by the framework\n\n    Returns:\n            a list of strings of supported datatypes\n    """"""\n    return router.getSupportedDatatypes()\n\n\ndef changeEDEXHost(newHostName):\n    """"""\n    Changes the EDEX host the Data Access Framework is communicating with. Only\n    works if using the native Python client implementation, otherwise, this\n    method will throw a TypeError.\n\n    Args:\n            newHostName: the EDEX host to connect to\n    """"""\n    if USING_NATIVE_THRIFT:\n        global THRIFT_HOST\n        THRIFT_HOST = newHostName\n        global router\n        router = ThriftClientRouter.ThriftClientRouter(THRIFT_HOST)\n    else:\n        raise TypeError(""Cannot call changeEDEXHost when using JepRouter."")\n\n\ndef setLazyLoadGridLatLon(lazyLoadGridLatLon):\n    """"""\n    Provide a hint to the Data Access Framework indicating whether to load the\n    lat/lon data for a grid immediately or wait until it is needed. This is\n    provided as a performance tuning hint and should not affect the way the\n    Data Access Framework is used. Depending on the internal implementation of\n    the Data Access Framework this hint might be ignored. Examples of when this\n    should be set to True are when the lat/lon information is not used or when\n    it is used only if certain conditions within the data are met. It could be\n    set to False if it is guaranteed that all lat/lon information is needed and\n    it would be better to get any performance overhead for generating the\n    lat/lon data out of the way during the initial request.\n\n\n    Args:\n            lazyLoadGridLatLon: Boolean value indicating whether to lazy load.\n    """"""\n    try:\n        router.setLazyLoadGridLatLon(lazyLoadGridLatLon)\n    except AttributeError:\n        # The router is not required to support this capability.\n        pass\n'"
awips/dataaccess/DataNotificationLayer.py,0,"b'#\n# Published interface for retrieving data updates via awips.dataaccess package\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    May 26, 2016    2416          rjpeter        Initial Creation.\n#    Aug  1, 2016    2416          tgurney        Finish implementation\n#\n#\n\n""""""\nInterface for the DAF\'s data notification feature, which allows continuous\nretrieval of new data as it is coming into the system.\n\nThere are two ways to access this feature:\n\n1. The DataQueue module (awips.dataaccess.DataQueue) offers a collection that\nautomatically fills up with new data as it receives notifications. See that\nmodule for more information.\n\n2. Depending on the type of data you want, use either getGridDataUpdates() or\ngetGeometryDataUpdates() in this module. Either one will give you back an\nobject that will retrieve new data for you and will call a function you specify\neach time new data is received.\n\nExample code follows. This example prints temperature as observed from KOMA\neach time a METAR is received from there.\n\n  from awips.dataaccess import DataAccessLayer as DAL\n  from awips.dataaccess import DataNotificationLayer as DNL\n\n  def process_obs(list_of_data):\n      for item in list_of_data:\n          print(item.getNumber(\'temperature\'))\n\n  request = DAL.newDataRequest(\'obs\')\n  request.setParameters(\'temperature\')\n  request.setLocationNames(\'KOMA\')\n\n  notifier = DNL.getGeometryDataUpdates(request)\n  notifier.subscribe(process_obs)\n  # process_obs will called with a list of data each time new data comes in\n\n""""""\n\nimport re\nimport sys\nfrom awips.dataaccess.PyGeometryNotification import PyGeometryNotification\nfrom awips.dataaccess.PyGridNotification import PyGridNotification\n\n\nTHRIFT_HOST = ""edex""\n\nUSING_NATIVE_THRIFT = False\n\nJMS_HOST_PATTERN = re.compile(\'tcp://([^:]+):([0-9]+)\')\n\nif \'jep\' in sys.modules:\n    # intentionally do not catch if this fails to import, we want it to\n    # be obvious that something is configured wrong when running from within\n    # Java instead of allowing false confidence and fallback behavior\n    import JepRouter\n    router = JepRouter\nelse:\n    from awips.dataaccess import ThriftClientRouter\n    router = ThriftClientRouter.ThriftClientRouter(THRIFT_HOST)\n    USING_NATIVE_THRIFT = True\n\n\ndef _getJmsConnectionInfo(notifFilterResponse):\n    serverString = notifFilterResponse.getJmsConnectionInfo()\n    try:\n        host, port = JMS_HOST_PATTERN.match(serverString).groups()\n    except AttributeError:\n        raise RuntimeError(\'Got bad JMS connection info from server: \' + serverString)\n    return {\'host\': host, \'port\': port}\n\n\ndef getGridDataUpdates(request):\n    """"""\n    Get a notification object that receives updates to grid data.\n\n    Args:\n            request: the IDataRequest specifying the data you want to receive\n\n    Returns:\n            an update request object that you can listen for updates to by\n            calling its subscribe() method\n    """"""\n    response = router.getNotificationFilter(request)\n    notificationFilter = response.getNotificationFilter()\n    jmsInfo = _getJmsConnectionInfo(response)\n    notifier = PyGridNotification(request, notificationFilter,\n                                  requestHost=THRIFT_HOST, **jmsInfo)\n    return notifier\n\n\ndef getGeometryDataUpdates(request):\n    """"""\n    Get a notification object that receives updates to geometry data.\n\n    Args:\n            request: the IDataRequest specifying the data you want to receive\n\n    Returns:\n            an update request object that you can listen for updates to by\n            calling its subscribe() method\n    """"""\n    response = router.getNotificationFilter(request)\n    notificationFilter = response.getNotificationFilter()\n    jmsInfo = _getJmsConnectionInfo(response)\n    notifier = PyGeometryNotification(request, notificationFilter,\n                                      requestHost=THRIFT_HOST, **jmsInfo)\n    return notifier\n\n\ndef changeEDEXHost(newHostName):\n    """"""\n    Changes the EDEX host the Data Access Framework is communicating with. Only\n    works if using the native Python client implementation, otherwise, this\n    method will throw a TypeError.\n\n    Args:\n            newHostName: the EDEX host to connect to\n    """"""\n    if USING_NATIVE_THRIFT:\n        global THRIFT_HOST\n        THRIFT_HOST = newHostName\n        global router\n        router = ThriftClientRouter.ThriftClientRouter(THRIFT_HOST)\n    else:\n        raise TypeError(""Cannot call changeEDEXHost when using JepRouter."")\n'"
awips/dataaccess/DataQueue.py,0,"b'#\n#   Convenience class for using the DAF\'s notifications feature. This is a\n#   collection that, once connected to EDEX by calling start(), fills with\n#   data as notifications come in. Runs on a separate thread to allow\n#   non-blocking data retrieval.\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/29/16        2416          tgurney        Initial creation\n#\n\nfrom awips.dataaccess import DataNotificationLayer as DNL\n\nimport time\nfrom threading import Thread\nimport sys\n\n\nif sys.version_info.major == 2:\n    from Queue import Queue, Empty\nelse:  # Python 3 module renamed to \'queue\'\n    from queue import Queue, Empty\n\n# Used to indicate a DataQueue that will produce geometry data.\nGEOMETRY = object()\n\n# Used to indicate a DataQueue that will produce grid data.\nGRID = object()\n\n# Default maximum queue size.\n_DEFAULT_MAXSIZE = 100\n\n\nclass Closed(Exception):\n    """"""Raised when attempting to get data from a closed queue.""""""\n    pass\n\n\nclass DataQueue(object):\n\n    """"""\n    Convenience class for using the DAF\'s notifications feature. This is a\n    collection that, once connected to EDEX by calling start(), fills with\n    data as notifications come in.\n\n    Example for getting obs data:\n\n      from DataQueue import DataQueue, GEOMETRY\n      request = DataAccessLayer.newDataRequest(\'obs\')\n      request.setParameters(\'temperature\')\n      request.setLocationNames(\'KOMA\')\n      q = DataQueue(GEOMETRY, request)\n      q.start()\n      for item in q:\n          print(item.getNumber(\'temperature\'))\n    """"""\n\n    def __init__(self, dtype, request, maxsize=_DEFAULT_MAXSIZE):\n        """"""\n        Create a new DataQueue.\n\n        Args:\n            dtype: Either GRID or GEOMETRY; must match the type of data\n              requested.\n            request: IDataRequest describing the data you want. It must at\n              least have datatype set. All data produced will satisfy the\n              constraints you specify.\n            maxsize: Maximum number of data objects the queue can hold at\n              one time. If the limit is reached, any data coming in after\n              that will not appear until one or more items are removed using\n              DataQueue.get().\n        """"""\n        assert maxsize > 0\n        assert dtype in (GEOMETRY, GRID)\n        self._maxsize = maxsize\n        self._queue = Queue(maxsize=maxsize)\n        self._thread = None\n        if dtype is GEOMETRY:\n            self._notifier = DNL.getGeometryDataUpdates(request)\n        elif dtype is GRID:\n            self._notifier = DNL.getGridDataUpdates(request)\n\n    def start(self):\n        """"""Start listening for notifications and requesting data.""""""\n        if self._thread is not None:\n            # Already started\n            return\n        kwargs = {\'callback\': self._data_received}\n        self._thread = Thread(target=self._notifier.subscribe, kwargs=kwargs)\n        self._thread.daemon = True\n        self._thread.start()\n        timer = 0\n        while not self._notifier.subscribed:\n            time.sleep(0.1)\n            timer += 1\n            if timer >= 100:  # ten seconds\n                raise RuntimeError(\'timed out when attempting to subscribe\')\n\n    def _data_received(self, data):\n        for d in data:\n            if not isinstance(d, list):\n                d = [d]\n            for item in d:\n                self._queue.put(item)\n\n    def get(self, block=True, timeout=None):\n        """"""\n        Get and return the next available data object. By default, if there is\n        no data yet available, this method will not return until data becomes\n        available.\n\n        Args:\n            block: Specifies behavior when the queue is empty. If True, wait\n              until an item is available before returning (the default). If\n              False, return None immediately if the queue is empty.\n            timeout: If block is True, wait this many seconds, and return None\n              if data is not received in that time.\n        Returns:\n            IData\n        """"""\n        if self.closed:\n            raise Closed\n        try:\n            return self._queue.get(block, timeout)\n        except Empty:\n            return None\n\n    def get_all(self):\n        """"""\n        Get all data waiting for processing, in a single list. Always returns\n        immediately. Returns an empty list if no data has arrived yet.\n\n        Returns:\n            List of IData\n        """"""\n        data = []\n        for _ in range(self._maxsize):\n            next_item = self.get(False)\n            if next_item is None:\n                break\n            data.append(next_item)\n        return data\n\n    def close(self):\n        """"""Close the queue. May not be re-opened after closing.""""""\n        if not self.closed:\n            self._notifier.close()\n        self._thread.join()\n\n    def qsize(self):\n        """"""Return number of items in the queue.""""""\n        return self._queue.qsize()\n\n    def empty(self):\n        """"""Return True if the queue is empty.""""""\n        return self._queue.empty()\n\n    def full(self):\n        """"""Return True if the queue is full.""""""\n        return self._queue.full()\n\n    @property\n    def closed(self):\n        """"""True if the queue has been closed.""""""\n        return not self._notifier.subscribed\n\n    @property\n    def maxsize(self):\n        """"""\n        Maximum number of data objects the queue can hold at one time.\n        If this limit is reached, any data coming in after that will not appear\n        until one or more items are removed using get().\n        """"""\n        return self._maxsize\n\n    def __iter__(self):\n        if self._thread is not None:\n            while not self.closed:\n                yield self.get()\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, *unused):\n        self.close()\n'"
awips/dataaccess/ModelSounding.py,0,"b'#\n# Classes for retrieving soundings based on gridded data from the Data Access\n# Framework\n#\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/24/15         #4480        dgilling       Initial Creation.\n#\n\nfrom awips.dataaccess import DataAccessLayer\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.level import Level\nfrom shapely.geometry import Point\n\n\ndef getSounding(modelName, weatherElements, levels, samplePoint, timeRange=None):\n    """"""\n    Performs a series of Data Access Framework requests to retrieve a sounding object\n    based on the specified request parameters.\n\n    Args:\n        modelName: the grid model datasetid to use as the basis of the sounding.\n        weatherElements: a list of parameters to return in the sounding.\n        levels: a list of levels to sample the given weather elements at\n        samplePoint: a lat/lon pair to perform the sampling of data at.\n        timeRange: (optional) a list of times, or a TimeRange to specify\n        which forecast hours to use. If not specified, will default to all forecast hours.\n\n    Returns:\n        A _SoundingCube instance, which acts a 3-tiered dictionary, keyed\n        by DataTime, then by level and finally by weather element. If no\n        data is available for the given request parameters, None is returned.\n\n    """"""\n\n    (locationNames, parameters, levels, envelope, timeRange) = \\\n        __sanitizeInputs(modelName, weatherElements, levels, samplePoint, timeRange)\n\n    requestArgs = {\'datatype\': \'grid\', \'locationNames\': locationNames,\n                   \'parameters\': parameters, \'levels\': levels, \'envelope\': envelope}\n\n    req = DataAccessLayer.newDataRequest(**requestArgs)\n    response = DataAccessLayer.getGeometryData(req, timeRange)\n    soundingObject = _SoundingCube(response)\n\n    return soundingObject\n\n\ndef changeEDEXHost(host):\n    """"""\n    Changes the EDEX host the Data Access Framework is communicating with.\n\n    Args:\n            host: the EDEX host to connect to\n    """"""\n\n    if host:\n        DataAccessLayer.changeEDEXHost(str(host))\n\n\ndef __sanitizeInputs(modelName, weatherElements, levels, samplePoint, timeRange):\n    locationNames = [str(modelName)]\n    parameters = __buildStringList(weatherElements)\n    levels = __buildStringList(levels)\n    envelope = Point(samplePoint)\n    return locationNames, parameters, levels, envelope, timeRange\n\n\ndef __buildStringList(param):\n    if __notStringIter(param):\n        return [str(item) for item in param]\n    else:\n        return [str(param)]\n\n\ndef __notStringIter(iterable):\n    if not isinstance(iterable, str):\n        try:\n            iter(iterable)\n            return True\n        except TypeError:\n            return False\n\n\nclass _SoundingCube(object):\n    """"""\n    The top-level sounding object returned when calling ModelSounding.getSounding.\n\n    This object acts as a 3-tiered dict which is keyed by time then level\n    then parameter name. Calling times() will return all valid keys into this\n    object.\n    """"""\n\n    def __init__(self, geometryDataObjects):\n        self._dataDict = {}\n        self._sortedTimes = []\n        if geometryDataObjects:\n            for geometryData in geometryDataObjects:\n                dataTime = geometryData.getDataTime()\n                level = geometryData.getLevel()\n                for parameter in geometryData.getParameters():\n                    self.__addItem(parameter, dataTime, level, geometryData.getNumber(parameter))\n\n    def __addItem(self, parameter, dataTime, level, value):\n        timeLayer = self._dataDict.get(dataTime, _SoundingTimeLayer(dataTime))\n        self._dataDict[dataTime] = timeLayer\n        timeLayer._addItem(parameter, level, value)\n        if dataTime not in self._sortedTimes:\n            self._sortedTimes.append(dataTime)\n            self._sortedTimes.sort()\n\n    def __getitem__(self, key):\n        return self._dataDict[key]\n\n    def __len__(self):\n        return len(self._dataDict)\n\n    def times(self):\n        """"""\n        Returns the valid times for this sounding.\n\n        Returns:\n            A list containing the valid DataTimes for this sounding in order.\n        """"""\n        return self._sortedTimes\n\n\nclass _SoundingTimeLayer(object):\n    """"""\n    The second-level sounding object returned when calling ModelSounding.getSounding.\n\n    This object acts as a 2-tiered dict which is keyed by level then parameter\n    name. Calling levels() will return all valid keys into this\n    object. Calling time() will return the DataTime for this particular layer.\n    """"""\n\n    def __init__(self, dataTime):\n        self._dataTime = dataTime\n        self._dataDict = {}\n\n    def _addItem(self, parameter, level, value):\n        asString = str(level)\n        levelLayer = self._dataDict.get(asString, _SoundingTimeAndLevelLayer(self._dataTime, asString))\n        levelLayer._addItem(parameter, value)\n        self._dataDict[asString] = levelLayer\n\n    def __getitem__(self, key):\n        asString = str(key)\n        if asString in self._dataDict:\n            return self._dataDict[asString]\n        else:\n            raise KeyError(""Level "" + str(key) + "" is not a valid level for this sounding."")\n\n    def __len__(self):\n        return len(self._dataDict)\n\n    def time(self):\n        """"""\n        Returns the DataTime for this sounding cube layer.\n\n        Returns:\n            The DataTime for this sounding layer.\n        """"""\n        return self._dataTime\n\n    def levels(self):\n        """"""\n        Returns the valid levels for this sounding.\n\n        Returns:\n            A list containing the valid levels for this sounding in order of\n            closest to surface to highest from surface.\n        """"""\n        sortedLevels = [Level(level) for level in list(self._dataDict.keys())]\n        sortedLevels.sort()\n        return [str(level) for level in sortedLevels]\n\n\nclass _SoundingTimeAndLevelLayer(object):\n    """"""\n    The bottom-level sounding object returned when calling ModelSounding.getSounding.\n\n    This object acts as a dict which is keyed by parameter name. Calling\n    parameters() will return all valid keys into this object. Calling time()\n    will return the DataTime for this particular layer. Calling level() will\n    return the level for this layer.\n    """"""\n\n    def __init__(self, time, level):\n        self._time = time\n        self._level = level\n        self._parameters = {}\n\n    def _addItem(self, parameter, value):\n        self._parameters[parameter] = value\n\n    def __getitem__(self, key):\n        return self._parameters[key]\n\n    def __len__(self):\n        return len(self._parameters)\n\n    def level(self):\n        """"""\n        Returns the level for this sounding cube layer.\n\n        Returns:\n            The level for this sounding layer.\n        """"""\n        return self._level\n\n    def parameters(self):\n        """"""\n        Returns the valid parameters for this sounding.\n\n        Returns:\n            A list containing the valid parameter names.\n        """"""\n        return list(self._parameters.keys())\n\n    def time(self):\n        """"""\n        Returns the DataTime for this sounding cube layer.\n\n        Returns:\n            The DataTime for this sounding layer.\n        """"""\n        return self._time\n'"
awips/dataaccess/PyData.py,0,"b""#\n# Implements IData for use by native Python clients to the Data Access\n# Framework.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/03/13                      dgilling      Initial Creation.\n#    10/05/18                      mjames@ucar   Encode/decode attribute names.\n#\n#\n\nfrom awips.dataaccess import IData\nimport six\n\n\nclass PyData(IData):\n\n    def __init__(self, dataRecord):\n        self.__time = dataRecord.getTime()\n        self.__level = dataRecord.getLevel()\n        self.__locationName = dataRecord.getLocationName()\n        self.__attributes = dataRecord.getAttributes()\n\n    def getAttribute(self, key):\n        return self.__attributes[key]\n\n    def getAttributes(self):\n        return self.__attributes.keys()\n\n    def getDataTime(self):\n        return self.__time\n\n    def getLevel(self):\n        if six.PY2:\n            return self.__level\n        if not isinstance(self.__level, str):\n            return self.__level.decode('utf-8')\n        return self.__level\n\n    def getLocationName(self):\n        return self.__locationName\n"""
awips/dataaccess/PyGeometryData.py,0,"b'#\n# Implements IGeometryData for use by native Python clients to the Data Access\n# Framework.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/03/13                      dgilling       Initial Creation.\n#    01/06/14        2537          bsteffen       Share geometry WKT.\n#    03/19/14        2882          dgilling       Raise an exception when getNumber()\n#                                                 is called for data that is not a\n#                                                 numeric Type.\n#    06/09/16        5574          mapeters       Handle \'SHORT\' type in getNumber().\n#    10/05/18                      mjames@ucar    Encode/decode string, number val, and type\n#\n#\n\nfrom awips.dataaccess import IGeometryData\nfrom awips.dataaccess import PyData\nimport six\n\n\nclass PyGeometryData(IGeometryData, PyData.PyData):\n\n    def __init__(self, geoDataRecord, geometry):\n        PyData.PyData.__init__(self, geoDataRecord)\n        self.__geometry = geometry\n        self.__dataMap = {}\n        tempDataMap = geoDataRecord.getDataMap()\n        for key, value in list(tempDataMap.items()):\n            self.__dataMap[key] = (value[0], value[1], value[2])\n\n    def getGeometry(self):\n        return self.__geometry\n\n    def getParameters(self):\n        if six.PY2:\n            return list(self.__dataMap.keys())\n        else:\n            return [x.decode(\'utf-8\') for x in list(self.__dataMap.keys())]\n\n    def getString(self, param):\n        if six.PY2:\n            return self.__dataMap[param][0]\n        value = self.__dataMap[param.encode(\'utf-8\')][0]\n        if isinstance(value, bytes):\n            return str(value.decode(\'utf-8\'))\n        return str(value)\n\n    def getNumber(self, param):\n        t = self.getType(param)\n        if six.PY2:\n            value = self.__dataMap[param][0]\n        else:\n            value = self.__dataMap[param.encode(\'utf-8\')][0]\n        if t == \'INT\' or t == \'SHORT\' or t == \'LONG\':\n            return int(value)\n        elif t == \'FLOAT\':\n            return float(value)\n        elif t == \'DOUBLE\':\n            return float(value)\n        else:\n            raise TypeError(""Data for parameter "" + param + "" is not a numeric type."")\n\n    def getUnit(self, param):\n        if six.PY2:\n            return self.__dataMap[param][2]\n        unit = self.__dataMap[param.encode(\'utf-8\')][2]\n        if unit is not None:\n            return unit.decode(\'utf-8\')\n        return unit\n\n    def getType(self, param):\n        if six.PY2:\n            return self.__dataMap[param][1]\n        datatype = self.__dataMap[param.encode(\'utf-8\')][1]\n        if datatype is not None:\n            return datatype.decode(\'utf-8\')\n        return datatype\n'"
awips/dataaccess/PyGeometryNotification.py,0,"b'#\n# Notification object that produces geometry data\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/22/16        2416          tgurney        Initial creation\n#    09/07/17        6175          tgurney        Override messageReceived\n#\n\nimport traceback\nimport dynamicserialize\nfrom awips.dataaccess.PyNotification import PyNotification\n\n\nclass PyGeometryNotification(PyNotification):\n\n    def messageReceived(self, msg):\n        dataUriMsg = dynamicserialize.deserialize(msg)\n        dataUris = dataUriMsg.getDataURIs()\n        dataTimes = set()\n        for dataUri in dataUris:\n            if self.notificationFilter.accept(dataUri):\n                dataTimes.add(self.getDataTime(dataUri))\n        if dataTimes:\n            try:\n                data = self.getData(self.request, list(dataTimes))\n                self.callback(data)\n            except ValueError:\n                traceback.print_exc()\n\n    def getData(self, request, dataTimes):\n        return self.DAL.getGeometryData(request, dataTimes)\n'"
awips/dataaccess/PyGridData.py,0,"b'#\n# Implements IGridData for use by native Python clients to the Data Access\n# Framework.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/03/13         #2023        dgilling      Initial Creation.\n#    10/13/16         #5916        bsteffen      Correct grid shape, allow lat/lon\n#    11/10/16         #5900        bsteffen      Correct grid shape\n#                                                to be requested by a delegate\n#\n#\n\nimport numpy\nimport warnings\nimport six\n\nfrom awips.dataaccess import IGridData\nfrom awips.dataaccess import PyData\n\nNO_UNIT_CONVERT_WARNING = """"""\nThe ability to unit convert grid data is not currently available in this version of the Data Access Framework.\n""""""\n\n\nclass PyGridData(IGridData, PyData.PyData):\n\n    def __init__(self, gridDataRecord, nx, ny, latLonGrid=None, latLonDelegate=None):\n        PyData.PyData.__init__(self, gridDataRecord)\n        nx = nx\n        ny = ny\n        self.__parameter = gridDataRecord.getParameter()\n        self.__unit = gridDataRecord.getUnit()\n        self.__gridData = numpy.reshape(numpy.array(gridDataRecord.getGridData()), (ny, nx))\n        self.__latLonGrid = latLonGrid\n        self.__latLonDelegate = latLonDelegate\n\n    def getParameter(self):\n        return self.__parameter\n\n    def getUnit(self):\n        if six.PY2:\n            return self.__unit\n        if self.__unit is not None and not isinstance(self.__unit, str):\n            return self.__unit.decode(\'utf-8\')\n        return self.__unit\n\n    def getRawData(self, unit=None):\n        # TODO: Find a proper python library that deals will with numpy and\n        # javax.measure style unit strings and hook it in to this method to\n        # allow end-users to perform unit conversion for grid data.\n        if unit is not None:\n            warnings.warn(NO_UNIT_CONVERT_WARNING, stacklevel=2)\n        return self.__gridData\n\n    def getLatLonCoords(self):\n        if self.__latLonGrid is not None:\n            return self.__latLonGrid\n        elif self.__latLonDelegate is not None:\n            return self.__latLonDelegate()\n        return self.__latLonGrid\n'"
awips/dataaccess/PyGridNotification.py,0,"b'#\n# Notification object that produces grid data\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/03/16        2416          rjpeter        Initial Creation.\n#    09/06/17        6175          tgurney        Override messageReceived\n#\n\nimport dynamicserialize\nimport traceback\nfrom awips.dataaccess.PyNotification import PyNotification\n\n\nclass PyGridNotification(PyNotification):\n\n    def messageReceived(self, msg):\n        dataUriMsg = dynamicserialize.deserialize(msg)\n        dataUris = dataUriMsg.getDataURIs()\n        for dataUri in dataUris:\n            if not self.notificationFilter.accept(dataUri):\n                continue\n            try:\n                # This improves performance over requesting by datatime since it requests only the\n                # parameter that the notification was received for (instead of this and all previous\n                # parameters for the same forecast hour)\n                # TODO: This utterly fails for derived requests\n                newReq = self.DAL.newDataRequest(self.request.getDatatype())\n                newReq.addIdentifier(""dataURI"", dataUri)\n                newReq.setParameters(self.request.getParameters())\n                data = self.getData(newReq, [])\n                self.callback(data)\n            except ValueError:\n                traceback.print_exc()\n\n    def getData(self, request, dataTimes):\n        return self.DAL.getGridData(request, dataTimes)\n'"
awips/dataaccess/PyNotification.py,0,"b'#\n# Implements IData for use by native Python clients to the Data Access\n# Framework.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer      Description\n#    ------------    ----------    -----------   --------------------------\n#    Jun 22, 2016    2416          rjpeter       Initial creation\n#    Jul 22, 2016    2416          tgurney       Finish implementation\n#    Sep 07, 2017    6175          tgurney       Override messageReceived in subclasses\n#\n\nfrom six import with_metaclass\nimport abc\n\nfrom awips.dataaccess import DataAccessLayer\nfrom awips.dataaccess import INotificationSubscriber\nfrom awips.QpidSubscriber import QpidSubscriber\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import DataTime\n\n\nclass PyNotification(with_metaclass(abc.ABCMeta, INotificationSubscriber)):\n    """"""\n    Receives notifications for new data and retrieves the data that meets\n    specified filtering criteria.\n    """"""\n\n    def __init__(self, request, notificationFilter, host=\'localhost\',\n                 port=5672, requestHost=\'localhost\'):\n        self.DAL = DataAccessLayer\n        self.DAL.changeEDEXHost(requestHost)\n        self.request = request\n        self.notificationFilter = notificationFilter\n        self.__topicSubscriber = QpidSubscriber(host, port, decompress=True)\n        self.__topicName = ""edex.alerts""\n        self.callback = None\n\n    def subscribe(self, callback):\n        """"""\n        Start listening for notifications.\n\n        Args:\n            callback: Function to call with a list of received data objects.\n              Will be called once for each request made for data.\n        """"""\n        assert hasattr(callback, \'__call__\'), \'callback arg must be callable\'\n        self.callback = callback\n        self.__topicSubscriber.topicSubscribe(self.__topicName, self.messageReceived)\n        # Blocks here\n\n    def close(self):\n        if self.__topicSubscriber.subscribed:\n            self.__topicSubscriber.close()\n\n    def getDataTime(self, dataURI):\n        dataTimeStr = dataURI.split(\'/\')[2]\n        return DataTime(dataTimeStr)\n\n    @abc.abstractmethod\n    def messageReceived(self, msg):\n        """"""Called when a message is received from QpidSubscriber.\n\n        This method must call self.callback once for each request made for data\n        """"""\n        pass\n\n    @abc.abstractmethod\n    def getData(self, request, dataTimes):\n        """"""\n        Retrieve and return data\n\n        Args:\n            request: IDataRequest to send to the server\n            dataTimes: list of data times\n        Returns:\n            list of IData\n        """"""\n        pass\n\n    @property\n    def subscribed(self):\n        """"""True if currently subscribed to notifications.""""""\n        return self.__topicSubscriber.queueStarted\n'"
awips/dataaccess/ThriftClientRouter.py,0,"b""#\n# Routes requests to the Data Access Framework through Python Thrift.\n#\n#\n#    SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/21/13        2023          dgilling       Initial Creation.\n#    01/06/14        2537          bsteffen       Share geometry WKT.\n#    03/03/14        2673          bsteffen       Add ability to query only ref times.\n#    07/22/14        3185          njensen        Added optional/default args to newDataRequest\n#    07/23/14        3185          njensen        Added new methods\n#    07/30/14        3185          njensen        Renamed valid identifiers to optional\n#    06/30/15        4569          nabowle        Use hex WKB for geometries.\n#    04/13/15        5379          tgurney        Add getIdentifierValues()\n#    06/01/16        5587          tgurney        Add new signatures for\n#                                                 getRequiredIdentifiers() and\n#                                                 getOptionalIdentifiers()\n#    08/01/16        2416          tgurney        Add getNotificationFilter()\n#    10/13/16        5916          bsteffen       Correct grid shape, allow lazy grid lat/lon\n#    10/26/16        5919          njensen        Speed up geometry creation in getGeometryData()\n#\n\nimport numpy\nimport six\nimport shapely.wkb\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.impl import DefaultDataRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetAvailableLocationNamesRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetAvailableTimesRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetGeometryDataRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetGridDataRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetGridLatLonRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetAvailableParametersRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetAvailableLevelsRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetRequiredIdentifiersRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetOptionalIdentifiersRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetIdentifierValuesRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetSupportedDatatypesRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import GetNotificationFilterRequest\n\nfrom awips import ThriftClient\nfrom awips.dataaccess import PyGeometryData\nfrom awips.dataaccess import PyGridData\n\n\nclass LazyGridLatLon(object):\n\n    def __init__(self, client, nx, ny, envelope, crsWkt):\n        self._latLonGrid = None\n        self._client = client\n        self._request = GetGridLatLonRequest()\n        self._request.setNx(nx)\n        self._request.setNy(ny)\n        self._request.setEnvelope(envelope)\n        self._request.setCrsWkt(crsWkt)\n\n    def __call__(self):\n        # Its important that the data is cached internally so that if multiple\n        # GridData are sharing the same delegate then they can also share a\n        # single request for the LatLon information.\n        if self._latLonGrid is None:\n            response = self._client.sendRequest(self._request)\n            nx = response.getNx()\n            ny = response.getNy()\n            latData = numpy.reshape(numpy.array(response.getLats()), (ny, nx))\n            lonData = numpy.reshape(numpy.array(response.getLons()), (ny, nx))\n            self._latLonGrid = (lonData, latData)\n        return self._latLonGrid\n\n\nclass ThriftClientRouter(object):\n\n    def __init__(self, host='localhost'):\n        self._client = ThriftClient.ThriftClient(host)\n        self._lazyLoadGridLatLon = False\n\n    def setLazyLoadGridLatLon(self, lazyLoadGridLatLon):\n        self._lazyLoadGridLatLon = lazyLoadGridLatLon\n\n    def getAvailableTimes(self, request, refTimeOnly):\n        timesRequest = GetAvailableTimesRequest()\n        timesRequest.setRequestParameters(request)\n        timesRequest.setRefTimeOnly(refTimeOnly)\n        response = self._client.sendRequest(timesRequest)\n        return response\n\n    def getGridData(self, request, times):\n        gridDataRequest = GetGridDataRequest()\n        gridDataRequest.setIncludeLatLonData(not self._lazyLoadGridLatLon)\n        gridDataRequest.setRequestParameters(request)\n        # if we have an iterable times instance, then the user must have asked\n        # for grid data with the List of DataTime objects\n        # else, we assume it was a single TimeRange that was meant for the\n        # request\n        try:\n            iter(times)\n            gridDataRequest.setRequestedTimes(times)\n        except TypeError:\n            gridDataRequest.setRequestedPeriod(times)\n        response = self._client.sendRequest(gridDataRequest)\n\n        locSpecificData = {}\n        locNames = list(response.getSiteNxValues().keys())\n        for location in locNames:\n            nx = response.getSiteNxValues()[location]\n            ny = response.getSiteNyValues()[location]\n            if self._lazyLoadGridLatLon:\n                envelope = response.getSiteEnvelopes()[location]\n                crsWkt = response.getSiteCrsWkt()[location]\n                delegate = LazyGridLatLon(\n                    self._client, nx, ny, envelope, crsWkt)\n                locSpecificData[location] = (nx, ny, delegate)\n            else:\n                latData = numpy.reshape(numpy.array(\n                    response.getSiteLatGrids()[location]), (ny, nx))\n                lonData = numpy.reshape(numpy.array(\n                    response.getSiteLonGrids()[location]), (ny, nx))\n                locSpecificData[location] = (nx, ny, (lonData, latData))\n        retVal = []\n        for gridDataRecord in response.getGridData():\n            locationName = gridDataRecord.getLocationName()\n            if locationName is not None:\n                if six.PY2:\n                    locData = locSpecificData[locationName]\n                else:\n                    locData = locSpecificData[locationName.encode('utf-8')]\n            else:\n                locData = locSpecificData[locationName]\n            if self._lazyLoadGridLatLon:\n                retVal.append(PyGridData.PyGridData(gridDataRecord, locData[\n                              0], locData[1], latLonDelegate=locData[2]))\n            else:\n                retVal.append(PyGridData.PyGridData(\n                    gridDataRecord, locData[0], locData[1], locData[2]))\n        return retVal\n\n    def getGeometryData(self, request, times):\n        geoDataRequest = GetGeometryDataRequest()\n        geoDataRequest.setRequestParameters(request)\n        # if we have an iterable times instance, then the user must have asked\n        # for geometry data with the List of DataTime objects\n        # else, we assume it was a single TimeRange that was meant for the\n        # request\n        try:\n            iter(times)\n            geoDataRequest.setRequestedTimes(times)\n        except TypeError:\n            geoDataRequest.setRequestedPeriod(times)\n        response = self._client.sendRequest(geoDataRequest)\n        geometries = []\n        for wkb in response.getGeometryWKBs():\n            # the wkb is a numpy.ndarray of dtype int8\n            # convert the bytearray to a byte string and load it\n            geometries.append(shapely.wkb.loads(wkb.tostring()))\n\n        retVal = []\n        for geoDataRecord in response.getGeoData():\n            geom = geometries[geoDataRecord.getGeometryWKBindex()]\n            retVal.append(PyGeometryData.PyGeometryData(geoDataRecord, geom))\n        return retVal\n\n    def getAvailableLocationNames(self, request):\n        locNamesRequest = GetAvailableLocationNamesRequest()\n        locNamesRequest.setRequestParameters(request)\n        response = self._client.sendRequest(locNamesRequest)\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def getAvailableParameters(self, request):\n        paramReq = GetAvailableParametersRequest()\n        paramReq.setRequestParameters(request)\n        response = self._client.sendRequest(paramReq)\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def getAvailableLevels(self, request):\n        levelReq = GetAvailableLevelsRequest()\n        levelReq.setRequestParameters(request)\n        response = self._client.sendRequest(levelReq)\n        return response\n\n    def getRequiredIdentifiers(self, request):\n        if str(request) == request:\n            # Handle old version getRequiredIdentifiers(str)\n            request = self.newDataRequest(request)\n        idReq = GetRequiredIdentifiersRequest()\n        idReq.setRequest(request)\n        response = self._client.sendRequest(idReq)\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def getOptionalIdentifiers(self, request):\n        if str(request) == request:\n            # Handle old version getOptionalIdentifiers(str)\n            request = self.newDataRequest(request)\n        idReq = GetOptionalIdentifiersRequest()\n        idReq.setRequest(request)\n        response = self._client.sendRequest(idReq)\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def getIdentifierValues(self, request, identifierKey):\n        idValReq = GetIdentifierValuesRequest()\n        idValReq.setIdentifierKey(identifierKey)\n        idValReq.setRequestParameters(request)\n        response = self._client.sendRequest(idValReq)\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def newDataRequest(self, datatype, parameters=[], levels=[], locationNames=[],\n                       envelope=None, **kwargs):\n        req = DefaultDataRequest()\n        if datatype:\n            req.setDatatype(datatype)\n        if parameters:\n            req.setParameters(*parameters)\n        if levels:\n            req.setLevels(*levels)\n        if locationNames:\n            req.setLocationNames(*locationNames)\n        if envelope:\n            req.setEnvelope(envelope)\n        if kwargs:\n            # any args leftover are assumed to be identifiers\n            req.identifiers = kwargs\n        return req\n\n    def getSupportedDatatypes(self):\n        response = self._client.sendRequest(GetSupportedDatatypesRequest())\n        if six.PY2:\n            return response\n        if response is not None:\n            return [x.decode('utf-8') for x in response]\n        return response\n\n    def getNotificationFilter(self, request):\n        notifReq = GetNotificationFilterRequest()\n        notifReq.setRequestParameters(request)\n        response = self._client.sendRequest(notifReq)\n        return response\n"""
awips/dataaccess/__init__.py,0,"b'#\n# __init__.py for awips.dataaccess package\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    12/10/12                      njensen       Initial Creation.\n#    Feb 14, 2013    1614          bsteffen       refactor data access framework\n#                                                 to use single request.\n#    Apr 09, 2013    1871          njensen      Add doc strings\n#    Jun 03, 2013    2023          dgilling     Add getAttributes to IData, add\n#                                               getLatLonGrids() to IGridData.\n#    Aug 01, 2016    2416          tgurney      Add INotificationSubscriber\n#                                                 and INotificationFilter\n#\n#\n\n__all__ = [\n    \'IData\',\n    \'IDataRequest\',\n    \'IGeometryData\',\n    \'IGridData\',\n    \'IGeometryData\',\n    \'INotificationFilter\',\n    \'INotificationSubscriber\'\n]\n\nimport abc\nfrom six import with_metaclass\n\n\nclass IDataRequest(with_metaclass(abc.ABCMeta, object)):\n    """"""\n    An IDataRequest to be submitted to the DataAccessLayer to retrieve data.\n    """"""\n\n    @abc.abstractmethod\n    def setDatatype(self, datatype):\n        """"""\n        Sets the datatype of the request.\n\n        Args:\n                datatype: A string of the datatype, such as ""grid"", ""radar"", ""gfe"", ""obs""\n        """"""\n        return\n\n    @abc.abstractmethod\n    def addIdentifier(self, key, value):\n        """"""\n        Adds an identifier to the request.  Identifiers are specific to the\n        datatype being requested.\n\n        Args:\n                key: the string key of the identifier\n                value: the value of the identifier\n        """"""\n        return\n\n    @abc.abstractmethod\n    def setParameters(self, params):\n        """"""\n        Sets the parameters of data to request.\n\n        Args:\n                params: a list of strings of parameters to request\n        """"""\n        return\n\n    @abc.abstractmethod\n    def setLevels(self, levels):\n        """"""\n        Sets the levels of data to request.  Not all datatypes support levels.\n\n        Args:\n                levels: a list of strings of level abbreviations to request\n        """"""\n        return\n\n    @abc.abstractmethod\n    def setEnvelope(self, env):\n        """"""\n        Sets the envelope of the request.  If supported by the datatype factory,\n        the data returned for the request will be constrained to only the data\n        within the envelope.\n\n        Args:\n                env: a shapely geometry\n        """"""\n        return\n\n    @abc.abstractmethod\n    def setLocationNames(self, locationNames):\n        """"""\n        Sets the location names of the request.\n\n        Args:\n                locationNames: a list of strings of location names to request\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getDatatype(self):\n        """"""\n        Gets the datatype of the request\n\n        Returns:\n                the datatype set on the request\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getIdentifiers(self):\n        """"""\n        Gets the identifiers on the request\n\n        Returns:\n                a dictionary of the identifiers\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getLevels(self):\n        """"""\n        Gets the levels on the request\n\n        Returns:\n                a list of strings of the levels\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getLocationNames(self):\n        """"""\n        Gets the location names on the request\n\n        Returns:\n                a list of strings of the location names\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getEnvelope(self):\n        """"""\n        Gets the envelope on the request\n\n        Returns:\n                a rectangular shapely geometry\n        """"""\n        return\n\n\nclass IData(with_metaclass(abc.ABCMeta, object)):\n    """"""\n    An IData representing data returned from the DataAccessLayer.\n    """"""\n\n    @abc.abstractmethod\n    def getAttribute(self, key):\n        """"""\n        Gets an attribute of the data.\n\n        Args:\n                key: the key of the attribute\n\n        Returns:\n                the value of the attribute\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getAttributes(self):\n        """"""\n        Gets the valid attributes for the data.\n\n        Returns:\n                a list of strings of the attribute names\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getDataTime(self):\n        """"""\n        Gets the data time of the data.\n\n        Returns:\n                the data time of the data, or None if no time is associated\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getLevel(self):\n        """"""\n        Gets the level of the data.\n\n        Returns:\n                the level of the data, or None if no level is associated\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getLocationName(self, param):\n        """"""\n        Gets the location name of the data.\n\n        Returns:\n                the location name of the data, or None if no location name is\n                associated\n        """"""\n        return\n\n\nclass IGridData(IData):\n    """"""\n    An IData representing grid data that is returned by the DataAccessLayer.\n    """"""\n\n    @abc.abstractmethod\n    def getParameter(self):\n        """"""\n        Gets the parameter of the data.\n\n        Returns:\n                the parameter of the data\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getUnit(self):\n        """"""\n        Gets the unit of the data.\n\n        Returns:\n                the string abbreviation of the unit, or None if no unit is associated\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getRawData(self):\n        """"""\n        Gets the grid data as a numpy array.\n\n        Returns:\n                a numpy array of the data\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getLatLonCoords(self):\n        """"""\n        Gets the lat/lon coordinates of the grid data.\n\n        Returns:\n            a tuple where the first element is a numpy array of lons, and the\n            second element is a numpy array of lats\n        """"""\n        return\n\n\nclass IGeometryData(IData):\n    """"""\n    An IData representing geometry data that is returned by the DataAccessLayer.\n    """"""\n\n    @abc.abstractmethod\n    def getGeometry(self):\n        """"""\n        Gets the geometry of the data.\n\n        Returns:\n                a shapely geometry\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getParameters(self):\n        """"""Gets the parameters of the data.\n\n        Returns:\n                a list of strings of the parameter names\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getString(self, param):\n        """"""\n        Gets the string value of the specified param.\n\n        Args:\n                param: the string name of the param\n\n        Returns:\n                the string value of the param\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getNumber(self, param):\n        """"""\n        Gets the number value of the specified param.\n\n        Args:\n                param: the string name of the param\n\n        Returns:\n                the number value of the param\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getUnit(self, param):\n        """"""\n        Gets the unit of the specified param.\n\n        Args:\n                param: the string name of the param\n\n        Returns:\n                the string abbreviation of the unit of the param\n        """"""\n        return\n\n    @abc.abstractmethod\n    def getType(self, param):\n        """"""\n        Gets the type of the param.\n\n        Args:\n                param: the string name of the param\n\n        Returns:\n                a string of the type of the parameter, such as\n                ""STRING"", ""INT"", ""LONG"", ""FLOAT"", or ""DOUBLE""\n        """"""\n        return\n\n\nclass INotificationSubscriber(with_metaclass(abc.ABCMeta, object)):\n    """"""\n    An INotificationSubscriber representing a notification filter returned from\n    the DataNotificationLayer.\n    """"""\n\n    @abc.abstractmethod\n    def subscribe(self, callback):\n        """"""\n        Subscribes to the requested data. Method will not return until close is\n        called in a separate thread.\n\n        Args:\n                callback: the method to call with the IGridData/IGeometryData\n\n        """"""\n        pass\n\n    @abc.abstractmethod\n    def close(self):\n        """"""Closes the notification subscriber""""""\n        pass\n\n\nclass INotificationFilter(with_metaclass(abc.ABCMeta, object)):\n    """"""\n    Represents data required to filter a set of URIs and\n    return a corresponding list of IDataRequest to retrieve data for.\n    """"""\n    @abc.abstractmethod\n    def accept(dataUri):\n        pass\n'"
awips/gempak/GridDataRetriever.py,0,"b'import os\nimport numpy\nfrom datetime import datetime\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import GetGridDataRequest\n\n\nclass GridDataRetriever:\n\n    def __init__(self, server, pluginName, modelId, cycle, forecast, level1, level2, vcoord, param, nnx, nny):\n        self.pluginName = pluginName\n        self.modelId = modelId\n        self.cycle = cycle\n        self.forecast = forecast\n        self.level1 = level1\n        self.level2 = level2\n        self.vcoord = vcoord\n        self.param = param\n        self.nx = nnx\n        self.ny = nny\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getData(self):\n        """""" Sends ThriftClient request and writes out received files.""""""\n        req = GetGridDataRequest()\n\n        req.setPluginName(self.pluginName)\n        req.setModelId(self.modelId)\n\n        dt = datetime.strptime(self.cycle, \'%y%m%d/%H%M\')\n        ct = datetime.strftime(dt, \'%Y-%m-%d %H:%M:%S\')\n        req.setReftime(ct)\n        req.setFcstsec(self.forecast)\n\n        if self.level1 == \'-1\':\n            f1 = -999999.0\n        else:\n            f1 = float(self.level1)\n\n        if self.level2 == \'-1\':\n            f2 = -999999.0\n        else:\n            f2 = float(self.level2)\n\n        vcoord = self.vcoord\n        if vcoord == \'SGMA\':\n            if f1 >= 0.0:\n                f1 = f1 / 10000\n            if f2 >= 0.0:\n                f2 = f2 / 10000\n        elif vcoord == \'DPTH\':\n            if f1 >= 0.0:\n                f1 = f1 / 100.0\n            if f2 >= 0.0:\n                f2 = f2 / 100.0\n        elif vcoord == \'POTV\':\n            if f1 >= 0.0:\n                f1 = f1 / 1000.0\n            if f2 >= 0.0:\n                f2 = f2 / 1000.0\n\n        req.setLevel1(str(f1))\n        req.setLevel2(str(f2))\n        req.setVcoord(vcoord)\n\n        req.setParm(self.param)\n\n        resp = self.client.sendRequest(req)\n\n        # Get the dimensions of the grid\n        kx = int(self.nx)\n        ky = int(self.ny)\n        kxky = kx * ky\n\n        # Put the data into a NUMPY array\n        grid = numpy.asarray(resp.getFloatData())\n\n        # All grids need to be flipped from a GEMPAK point of view\n        # Reshape the array into 2D\n        grid = numpy.reshape(grid, (ky, kx))\n        # Flip the array in the up-down direction\n        grid = numpy.flipud(grid)\n        # Reshape the array back into 1D\n        grid = numpy.reshape(grid, kxky)\n\n        return [replacemissing(x) for x in grid]\n\n\ndef getgriddata(server, table, model, cycle, forecast, level1,\n                level2, vcoord, param, nnx, nny):\n    gir = GridDataRetriever(server, table, model, cycle, forecast,\n                            level1, level2, vcoord, param, nnx, nny)\n    return gir.getData()\n\n\ndef getheader(server, table, model, cycle, forecast, level1,\n              level2, vcoord, param, nnx, nny):\n    idata = []\n    idata.append(0)\n    idata.append(0)\n    return idata\n\n\ndef replacemissing(x):\n    if x == -999999.0:\n        return -9999.0\n    return x\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    # Run Test\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    tbl = \'grid\'\n    mdl = \'GFS20\'\n    cyc = \'131227/0000\'\n    fcs = \'43200\'\n    lv1 = \'500\'\n    lv2 = \'-1\'\n    vcd = \'PRES\'\n    prm = \'HGHT\'\n    nx = \'720\'\n    ny = \'361\'\n\n    print(getheader(srv, tbl, mdl, cyc, fcs, lv1, lv2, vcd, prm, nx, ny))\n    print(getgriddata(srv, tbl, mdl, cyc, fcs, lv1, lv2, vcd, prm, nx, ny))\n'"
awips/gempak/GridInfoRetriever.py,0,"b'import os\nimport sys\nfrom datetime import datetime\nfrom operator import itemgetter\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import GetGridInfoRequest\n\n\nclass GridInfoRetriever:\n\n    def __init__(self, server, pluginName, modelId, cycle=None, forecast=None):\n        self.pluginName = pluginName\n        self.modelId = modelId\n        self.cycle = cycle\n        self.forecast = forecast\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getInfo(self):\n        import sys\n        """""" Sends ThriftClient request and writes out received files.""""""\n        req = GetGridInfoRequest()\n        req.setPluginName(self.pluginName)\n        req.setModelId(self.modelId)\n\n        req.setReftime(self.cycle)\n        if len(self.cycle) > 2:\n            dt = datetime.strptime(self.cycle, \'%y%m%d/%H%M\')\n            ct = datetime.strftime(dt, \'%Y-%m-%d %H:%M:%S\')\n            req.setReftime(ct)\n\n        req.setFcstsec(self.forecast)\n        resp = self.client.sendRequest(req)\n\n        # Take care of bytestring encodings in python3\n        for i, rec in enumerate(resp):\n            resp[i] = {\n                key.decode() if isinstance(key, bytes) else key:\n                    val.decode() if isinstance(val, bytes) else val\n                for key, val in rec.items()\n            }\n\n        sortresp = sorted(sorted(resp, key=itemgetter(""reftime""), reverse=True), key=itemgetter(""fcstsec""))\n\n        grids = []\n\n        count = 0\n        for record in sortresp:\n            s = \'{:<12}\'.format(record[\'param\'])\n\n            if sys.byteorder == \'little\':\n                parm1 = (ord(s[3]) << 24) + (ord(s[2]) << 16) + (ord(s[1]) << 8) + ord(s[0])\n                parm2 = (ord(s[7]) << 24) + (ord(s[6]) << 16) + (ord(s[5]) << 8) + ord(s[4])\n                parm3 = (ord(s[11]) << 24) + (ord(s[10]) << 16) + (ord(s[9]) << 8) + ord(s[8])\n            else:\n                parm1 = (ord(s[0]) << 24) + (ord(s[1]) << 16) + (ord(s[2]) << 8) + ord(s[3])\n                parm2 = (ord(s[4]) << 24) + (ord(s[5]) << 16) + (ord(s[6]) << 8) + ord(s[7])\n                parm3 = (ord(s[8]) << 24) + (ord(s[9]) << 16) + (ord(s[10]) << 8) + ord(s[11])\n\n            dt = datetime.strptime(record[\'reftime\'], \'%Y-%m-%d %H:%M:%S.%f\')\n            dattim = dt.month * 100000000 + dt.day * 1000000 + (dt.year%100) * 10000 + dt.hour * 100 + dt.minute\n            fcsth = (int(record[\'fcstsec\']) / 60) / 60\n            fcstm = (int(record[\'fcstsec\']) / 60) % 60\n            fcst = 100000 + fcsth * 100 + fcstm\n\n            lv1 = float(record[\'level1\'])\n            if lv1 == -999999.0:\n                lv1 = -1.0\n            lv2 = float(record[\'level2\'])\n            if lv2 == -999999.0:\n                lv2 = -1.0\n\n            vcd = record[\'vcoord\']\n            if vcd == \'NONE\':\n                ivcd = 0\n            elif vcd == \'PRES\':\n                ivcd = 1\n            elif vcd == \'THTA\':\n                ivcd = 2\n            elif vcd == \'HGHT\':\n                ivcd = 3\n            elif vcd == \'SGMA\':\n                ivcd = 4\n                if lv1 >= 0.0:\n                    lv1 = lv1 * 10000.0\n                if lv2 >= 0.0:\n                    lv2 = lv2 * 10000.0\n            elif vcd == \'DPTH\':\n                ivcd = 5\n                if lv1 >= 0.0:\n                    lv1 = lv1 * 100.0\n                if lv2 >= 0.0:\n                    lv2 = lv2 * 100.0\n            elif vcd == \'HYBL\':\n                ivcd = 6\n            else:\n                v = \'{:<4}\'.format(vcd)\n                if sys.byteorder == \'little\':\n                    ivcd = (ord(v[3]) << 24) + (ord(v[2]) << 16) + (ord(v[1]) << 8) + ord(v[0])\n                else:\n                    ivcd = (ord(v[0]) << 24) + (ord(v[1]) << 16) + (ord(v[2]) << 8) + ord(v[3])\n                if vcd == \'POTV\':\n                    if lv1 >= 0.0:\n                        lv1 = lv1 * 1000.0\n                    if lv2 >= 0.0:\n                        lv2 = lv2 * 1000.0\n            grids.append(9999)\n            grids.append(dattim)\n            grids.append(fcst)\n            grids.append(0)\n            grids.append(0)\n            grids.append(int(lv1))\n            grids.append(int(lv2))\n            grids.append(ivcd)\n            grids.append(parm1)\n            grids.append(parm2)\n            grids.append(parm3)\n            count += 1\n            if count > 29998:\n                break\n\n        return grids\n             \n\ndef getinfo(server, table, model, cycle, forecast):\n    gir = GridInfoRetriever(server, table, model, cycle, forecast)\n    return gir.getInfo()\n\n\ndef getrow(server, table, model, cycle, forecast):\n    idata = []\n    idata.append(9999)\n    idata.append(1)\n    return idata\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    # Run Test\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    tbl = \'grid\'\n    mdl = \'NAM40\'\n    print(getrow(srv, tbl, mdl))\n    print(getinfo(srv, tbl, mdl))\n'"
awips/gempak/GridNavRetriever.py,0,"b'import os\nimport math\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import GetGridNavRequest\nfrom ctypes import *\n\nEARTH_RADIUS = 6371200.0\nDEG_TO_RAD = math.pi / 180.0\nRAD_TO_DEG = 180.0 / math.pi\nTWOPI = math.pi * 2.0\nHALFPI = math.pi / 2.0\nPI4TH = math.pi / 4.0\nPI3RD = math.pi / 3.0\n\n\ndef createPolar(nsflag, clon, lat1, lon1, dx, dy, unit, nx, ny):\n    clonr = clon * DEG_TO_RAD\n    latr = lat1 * DEG_TO_RAD\n    lonr = lon1 * DEG_TO_RAD\n    if nsflag == \'N\':\n        x1 = EARTH_RADIUS * math.tan(PI4TH - latr/2.0) * math.sin(lonr-clonr)\n        y1 = -1 * EARTH_RADIUS * math.tan(PI4TH - latr/2.0) * math.cos(lonr-clonr)\n    else:\n        x1 = EARTH_RADIUS * math.tan(PI4TH + latr/2.0) * math.sin(lonr-clonr)\n        y1 = EARTH_RADIUS * math.tan(PI4TH + latr/2.0) * math.cos(lonr-clonr)\n\n    if unit == \'m\':\n        tdx = dx / (1 + math.sin(PI3RD))\n        tdy = dy / (1 + math.sin(PI3RD))\n    else:\n        tdx = (dx*1000.0) / (1 + math.sin(PI3RD))\n        tdy = (dy*1000.0) / (1 + math.sin(PI3RD))\n\n    x2 = x1 + tdx * (nx-1)\n    y2 = y1 + tdy * (ny-1)\n    xll = min(x1, x2)\n    yll = min(y1, y2)\n    xur = max(x1, x2)\n    yur = max(y1, y2)\n\n    if nsflag == \'N\':\n        latll = (HALFPI - 2*math.atan2(math.hypot(xll, yll), EARTH_RADIUS)) * RAD_TO_DEG\n        rtemp = clonr + math.atan2(xll, -yll)\n    else:\n        latll = -1 * (HALFPI - 2*math.atan2(math.hypot(xll, yll), EARTH_RADIUS)) * RAD_TO_DEG\n        rtemp = clonr + math.atan2(xll, yll)\n\n    if rtemp > math.pi:\n        lonll = (rtemp-TWOPI) * RAD_TO_DEG\n    elif rtemp < -math.pi:\n        lonll = (rtemp+TWOPI) * RAD_TO_DEG\n    else:\n        lonll = rtemp * RAD_TO_DEG\n\n    if nsflag == \'N\':\n        latur = (HALFPI - 2*math.atan2(math.hypot(xur, yur), EARTH_RADIUS)) * RAD_TO_DEG\n        rtemp = clonr + math.atan2(xur, -yur)\n    else:\n        latur = -1 * (HALFPI - 2*math.atan2(math.hypot(xur, yur), EARTH_RADIUS)) * RAD_TO_DEG\n        rtemp = clonr + math.atan2(xur, yur)\n\n    if rtemp > math.pi:\n        lonur = (rtemp-TWOPI) * RAD_TO_DEG\n    elif rtemp < -math.pi:\n        lonur = (rtemp+TWOPI) * RAD_TO_DEG\n    else:\n        lonur = rtemp * RAD_TO_DEG\n\n    return [latll, lonll, latur, lonur]\n\n\ndef createConic(nsflag, clon, lat1, lon1, dx, dy, unit, nx, ny, ang1, ang3):\n    clonr = clon * DEG_TO_RAD\n    latr = lat1 * DEG_TO_RAD\n    lonr = lon1 * DEG_TO_RAD\n\n    angle1 = HALFPI - (math.fabs(ang1) * DEG_TO_RAD)\n    angle2 = HALFPI - (math.fabs(ang3) * DEG_TO_RAD)\n\n    if ang1 == ang3:\n        cc = math.cos(angle1)\n    else:\n        cc = (math.log(math.sin(angle2)) - math.log(math.sin(angle1))) \\\n             / (math.log(math.tan(angle2/2.0)) - math.log(math.tan(angle1/2.0)))\n\n    er = EARTH_RADIUS / cc\n\n    if nsflag == \'N\':\n        x1 = er * math.pow(math.tan((HALFPI-latr)/2.0), cc) * math.sin(cc*(lonr-clonr))\n        y1 = -1.0 * er * math.pow(math.tan((HALFPI-latr)/2.0), cc) * math.cos(cc*(lonr-clonr))\n    else:\n        x1 = er * math.pow(math.tan((HALFPI+latr)/2.0), cc) * math.sin(cc*(lonr-clonr))\n        y1 = er * math.pow(math.tan((HALFPI+latr)/2.0), cc) * math.cos(cc*(lonr-clonr))\n\n    alpha = math.pow(math.tan(angle1/2.0), cc) / math.sin(angle1)\n\n    if unit == \'m\':\n        x2 = x1 + (nx-1) * alpha * dx\n        y2 = y1 + (ny-1) * alpha * dy\n    else:\n        x2 = x1 + (nx-1) * alpha * (dx*1000.0)\n        y2 = y1 + (ny-1) * alpha * (dy*1000.0)\n\n    xll = min(x1, x2)\n    yll = min(y1, y2)\n    xur = max(x1, x2)\n    yur = max(y1, y2)\n\n    if nsflag == \'N\':\n        latll = (HALFPI - 2.0 * math.atan(math.pow(math.hypot(xll, yll)/er, (1/cc)))) * RAD_TO_DEG\n        rtemp = math.atan2(xll, -yll) * (1/cc) + clonr\n    else:\n        latll = (-1.0 * (HALFPI - 2.0 * math.atan(math.pow(math.hypot(xll, yll)/er, (1/cc))))) * RAD_TO_DEG\n        rtemp = math.atan2(xll, yll) * (1/cc) + clonr\n\n    if rtemp > math.pi:\n        lonll = (rtemp-TWOPI) * RAD_TO_DEG\n    elif rtemp < -math.pi:\n        lonll = (rtemp+TWOPI) * RAD_TO_DEG\n    else:\n        lonll = rtemp * RAD_TO_DEG\n\n    if nsflag == \'N\':\n        latur = (HALFPI - 2.0 * math.atan(math.pow(math.hypot(xur, yur)/er, (1/cc)))) * RAD_TO_DEG\n        rtemp = math.atan2(xur, -yur) * (1/cc) + clonr\n    else:\n        latur = (-1.0 * (HALFPI - 2.0 * math.atan(math.pow(math.hypot(xur, yur)/er, (1/cc))))) * RAD_TO_DEG\n        rtemp = math.atan2(xur, yur) * (1/cc) + clonr\n\n    if rtemp > math.pi:\n        lonur = (rtemp-TWOPI) * RAD_TO_DEG\n    elif rtemp < -math.pi:\n        lonur = (rtemp+TWOPI) * RAD_TO_DEG\n    else:\n        lonur = rtemp * RAD_TO_DEG\n\n    return [latll, lonll, latur, lonur]\n\n\nclass StringConverter(Union):\n    _fields_ = [(""char"", c_char*4), (""int"", c_int), (""float"", c_float)]\n\n\nclass GridNavRetriever:\n\n    def __init__(self, server, pluginName, modelId, arrayLen):\n        self.pluginName = pluginName\n        self.modelId = modelId\n        self.arrayLen = arrayLen\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getNavBlk(self):\n        """""" Sends ThriftClient request and writes out received files.""""""\n        req = GetGridNavRequest()\n        req.setPluginName(self.pluginName)\n        req.setModelId(self.modelId)\n        resp = self.client.sendRequest(req)\n\n        for i, rec in enumerate(resp):\n            resp[i] = {\n                key.decode() if isinstance(key, bytes) else key:\n                    val.decode() if isinstance(val, bytes) else val\n                for key, val in rec.items()\n            }\n\n        nav = []\n\n        for record in resp:\n            unit = record[\'spacingunit\']\n            sk = record[\'spatialkey\']\n            skarr = sk.split(\'/\')\n\n            nx = float(skarr[1])\n            ny = float(skarr[2])\n            dx = float(skarr[3])\n            dy = float(skarr[4])\n\n            sc = StringConverter()\n            if record[\'projtype\'] == \'LatLon\':\n                sc.char = \'CED \'\n                gemproj = 2.0\n                ang1 = 0.0\n                ang2 = 0.0\n                ang3 = 0.0\n\n                lllat = float(record[\'lowerleftlat\'])\n                lllon = float(record[\'lowerleftlon\'])\n                urlat = lllat + (dy * (ny-1))\n                urlon = lllon + (dx * (nx-1))\n                if lllon > 180:\n                    lllon -= 360.0\n                if urlon > 180:\n                    urlon -= 360.0\n\n            if record[\'projtype\'] == \'Polar Stereographic\':\n                sc.char = \'STR \'\n                gemproj = 2.0\n                if float(record[\'standard_parallel_1\']) < 0.0:\n                    ang1 = -90.0\n                    nsflag = \'S\'\n                else:\n                    ang1 = 90.0\n                    nsflag = \'N\'\n                ang2 = float(record[\'central_meridian\'])\n                ang3 = 0.0\n\n                lat1 = float(record[\'lowerleftlat\'])\n                lon1 = float(record[\'lowerleftlon\'])\n                coords = createPolar(nsflag, ang2, lat1, lon1, dx, dy, unit, nx, ny)\n                lllat = coords[0]\n                lllon = coords[1]\n                urlat = coords[2]\n                urlon = coords[3]\n\n            if record[\'projtype\'] == \'Lambert Conformal\':\n                sc.char = \'LCC \'\n                gemproj = 2.0\n\n                ang1 = float(skarr[7])\n                ang2 = float(record[\'central_meridian\'])\n                ang3 = float(skarr[8])\n                if ang1 < 0.0:\n                    nsflag = \'S\'\n                else:\n                    nsflag = \'N\'\n\n                lat1 = float(record[\'lowerleftlat\'])\n                lon1 = float(record[\'lowerleftlon\'])\n                coords = createConic(nsflag, ang2, lat1, lon1, dx, dy, unit, nx, ny, ang1, ang3)\n                lllat = coords[0]\n                lllon = coords[1]\n                urlat = coords[2]\n                urlon = coords[3]\n\n            # Fill up the output array of floats\n            nav.append(gemproj)\n            nav.append(sc.float)\n            nav.append(1.0)\n            nav.append(1.0)\n            nav.append(nx)\n            nav.append(ny)\n            nav.append(lllat)\n            nav.append(lllon)\n            nav.append(urlat)\n            nav.append(urlon)\n            nav.append(ang1)\n            nav.append(ang2)\n            nav.append(ang3)\n\n        for i in range(13, int(self.arrayLen)):\n            nav.append(0.0)\n        return nav\n\n    def getAnlBlk(self):\n        anl = []\n        # Type\n        anl.append(2.0)\n        # Delta\n        anl.append(1.0)\n        # Extend area\n        anl.append(0.0)\n        anl.append(0.0)\n        anl.append(0.0)\n        anl.append(0.0)\n        # Grid area\n        anl.append(-90.0)\n        anl.append(-180.0)\n        anl.append(90.0)\n        anl.append(180.0)\n        # Data area\n        anl.append(-90.0)\n        anl.append(-180.0)\n        anl.append(90.0)\n        anl.append(180.0)\n        for i in range(18, int(self.arrayLen)):\n            anl.append(0.0)\n        return anl\n\n\ndef getnavb(server, table, model, arrlen):\n    gnr = GridNavRetriever(server, table, model, arrlen)\n    return gnr.getNavBlk()\n\n\ndef getanlb(server, table, model, arrlen):\n    gnr = GridNavRetriever(server, table, model, arrlen)\n    return gnr.getAnlBlk()\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    # Run Test\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    tbl = \'grid_info\'\n    mdl = \'NAM40\'\n    navlen = \'256\'\n    print(getnavb(srv, tbl, mdl, navlen))\n    anllen = \'128\'\n    print(getanlb(srv, tbl, mdl, anllen))\n'"
awips/gempak/StationDataRetriever.py,0,"b'import os\nfrom datetime import datetime\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import DataTime\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import TimeRange\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import StationDataRequest\n\n\nclass StationDataRetriever:\n    """""" Retrieves all data for a requested station and time """"""\n\n    def __init__(self, server, pluginName, stationId, refTime, parmList, partNumber):\n        self.pluginName = pluginName\n        self.stationId = stationId\n        self.refTime = refTime\n        self.parmList = parmList\n        self.partNumber = partNumber\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getStationData(self):\n        """""" Sends ThriftClient request and writes out received files.""""""\n        dtime = datetime.strptime(self.refTime, ""%y%m%d/%H%M"")\n        trange = TimeRange()\n        trange.setStart(dtime)\n        trange.setEnd(dtime)\n        dataTime = DataTime(refTime=dtime, validPeriod=trange)\n        req = StationDataRequest()\n        req.setPluginName(self.pluginName)\n        req.setStationId(self.stationId)\n        req.setRefTime(dataTime)\n        req.setParmList(self.parmList)\n        req.setPartNumber(self.partNumber)\n        resp = self.client.sendRequest(req)\n\n        for i, rec in enumerate(resp):\n            resp[i] = {\n                key.decode() if isinstance(key, bytes) else key:\n                val.decode() if isinstance(val, bytes) else val\n                for key, val in rec.items()\n            }\n\n        return resp\n\n\ndef getstationdata(server, table, stationId, refTime, parmList, partNumber):\n    sr = StationDataRetriever(server, table, stationId, refTime, parmList, partNumber)\n    lcldict = sr.getStationData()\n\n    rdata = []\n    \n    for substr in parmList.split(\',\'):\n        if substr in lcldict:\n            rdata.append(lcldict[substr])\n        else:\n            rdata.append(-9999.00)\n\n    return rdata\n\n\ndef getleveldata(server, table, stationId, refTime, parmList, partNumber):\n    sr = StationDataRetriever(server, table, stationId, refTime, parmList, partNumber)\n    lcldict = sr.getStationData()\n\n    numset = [1]\n    for substr in parmList.split(\',\'):\n        if substr in lcldict:\n            pnum = len(lcldict[substr]) - 1\n            while pnum >= 0:\n                if lcldict[substr][pnum] != -9999.00:\n                    break\n                pnum = pnum - 1\n            numset.append(pnum)\n\n    rdata = []\n\n    for jj in range(max(numset)):\n        for substr in parmList.split(\',\'):\n            if substr in lcldict:\n                if lcldict[substr][jj] == -9999998.0:\n                    rdata.append(-9999.0)\n                else:\n                    rdata.append(lcldict[substr][jj])\n            else:\n                rdata.append(-9999.0)\n\n    return rdata\n\n\ndef getstationtext(server, table, stationId, refTime, parmList, partNumber):\n    sr = StationDataRetriever(server, table, stationId, refTime, parmList, partNumber)\n    lcldict = sr.getStationData()\n\n    if parmList in lcldict:\n        return lcldict[parmList]\n    else:\n        return \' \'\n\n\ndef getheader(server, table, stationId, refTime, parmList, partNumber):\n    idata = []\n    idata.append(0)\n    return idata\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    # Run Test\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    key = \'-\'\n    print(\'OBS - METAR\')\n    tbl = \'obs\'\n    stn = \'KLGA\'\n    time = \'130823/1700\'\n    parm = \'seaLevelPress,temperature,dewpoint,windSpeed,windDir\'\n    part = \'0\'\n    print(getheader(srv, tbl, stn, time, parm, part))\n    print(getstationdata(srv, tbl, stn, time, parm, part))\n    parm = \'rawMETAR\'\n    print(getstationtext(srv, tbl, stn, time, parm, part))\n    print(\'SFCOBS - SYNOP\')\n    tbl = \'sfcobs\'\n    stn = \'72403\'\n    time = \'130823/1800\'\n    parm = \'seaLevelPress,temperature,dewpoint,windSpeed,windDir\'\n    part = \'0\'\n    print(getheader(srv, tbl, stn, time, parm, part))\n    print(getstationdata(srv, tbl, stn, time, parm, part))\n    parm = \'rawReport\'\n    print(getstationtext(srv, tbl, stn, time, parm, part))\n    print(\'UAIR\')\n    tbl = \'bufrua\'\n    stn = \'72469\'\n    time = \'130823/1200\'\n    parm = \'prMan,htMan,tpMan,tdMan,wdMan,wsMan\'\n    part = \'2020\'\n    print(getleveldata(srv, tbl, stn, time, parm, part))\n    parm = \'prSigT,tpSigT,tdSigT\'\n    part = \'2022\'\n    print(getleveldata(srv, tbl, stn, time, parm, part))\n    parm = \'htSigW,wsSigW,wdSigW\'\n    part = \'2021\'\n    print(getleveldata(srv, tbl, stn, time, parm, part))\n'"
awips/gempak/StationRetriever.py,0,"b'import os\nimport sys\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import GetStationsRequest\n\n\nclass StationRetriever:\n    """""" Retrieves all requested stations """"""\n\n    def __init__(self, server, pluginName):\n        self.pluginName = pluginName\n        self.outdir = os.getcwd()\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getStations(self):\n        """""" Sends ThriftClient request and writes out received files.""""""\n        req = GetStationsRequest()\n        req.setPluginName(self.pluginName)\n        resp = self.client.sendRequest(req)\n\n        for i, rec in enumerate(resp):\n            resp[i] = {\n                key.decode() if isinstance(key, bytes) else key:\n                    val.decode() if isinstance(val, bytes) else val\n                for key, val in rec.items()\n            }\n\n        stns = []\n        for item in resp:\n            stationstr = \'{:<8}\'.format(item.getStationId())\n\n            if sys.byteorder == \'little\':\n                stnid = (ord(stationstr[3]) << 24) + (ord(stationstr[2]) << 16) + \\\n                        (ord(stationstr[1]) << 8) + ord(stationstr[0])\n                stnid2 = (ord(stationstr[7]) << 24) + (ord(stationstr[6]) << 16) + \\\n                         (ord(stationstr[5]) << 8) + ord(stationstr[4])\n            else:\n                stnid = (ord(stationstr[0]) << 24) + (ord(stationstr[1]) << 16) + \\\n                        (ord(stationstr[2]) << 8) + ord(stationstr[3])\n                stnid2 = (ord(stationstr[4]) << 24) + (ord(stationstr[5]) << 16) + \\\n                         (ord(stationstr[6]) << 8) + ord(stationstr[7])\n\n            if item.getState() is None:\n                stationstr = \'    \'\n            else:\n                stationstr = \'{:<4}\'.format(item.getState())\n\n            if sys.byteorder == \'little\':\n                state = (ord(stationstr[3]) << 24) + (ord(stationstr[2]) << 16) \\\n                        + (ord(stationstr[1]) << 8) + ord(stationstr[0])\n            else:\n                state = (ord(stationstr[0]) << 24) + (ord(stationstr[1]) << 16) \\\n                        + (ord(stationstr[2]) << 8) + ord(stationstr[3])\n\n            stationstr = \'{:<4}\'.format(item.getCountry())\n            if sys.byteorder == \'little\':\n                cntry = (ord(stationstr[3]) << 24) + (ord(stationstr[2]) << 16) \\\n                        + (ord(stationstr[1]) << 8) + ord(stationstr[0])\n            else:\n                cntry = (ord(stationstr[0]) << 24) + (ord(stationstr[1]) << 16) \\\n                        + (ord(stationstr[2]) << 8) + ord(stationstr[3])\n\n            stns.append(9999)\n            stns.append(stnid)\n            stns.append(item.getWmoIndex())\n            stns.append(int(item.getLatitude()*100))\n            stns.append(int(item.getLongitude()*100))\n            stns.append(int(item.getElevation()))\n            stns.append(state)\n            stns.append(cntry)\n            stns.append(stnid2)\n            stns.append(0)\n        return stns\n\n\ndef getstations(server, table, key, dummy, dummy2):\n    sr = StationRetriever(server, table)\n    return sr.getStations()\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    # Run Test\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    key = \'-\'\n    print(\'OBS - METAR\')\n    tbl = \'obs\'\n    print(getstations(srv, tbl, key))\n    print(\'SFCOBS - SYNOP\')\n    tbl = \'sfcobs\'\n    print(getstations(srv, tbl, key))\n'"
awips/gempak/TimeRetriever.py,0,"b'import os\nfrom datetime import datetime\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.java.util import GregorianCalendar\nfrom dynamicserialize.dstypes.gov.noaa.nws.ncep.common.dataplugin.gempak.request import GetTimesRequest\n\n\nclass TimeRetriever:\n    """""" Retrieves all requested times""""""\n\n    def __init__(self, server, pluginName, timeField):\n        self.pluginName = pluginName\n        self.timeField = timeField\n        self.outdir = os.getcwd()\n        self.host = os.getenv(""DEFAULT_HOST"", server)\n        self.port = os.getenv(""DEFAULT_PORT"", ""9581"")\n        self.client = ThriftClient.ThriftClient(self.host, self.port)\n\n    def getTimes(self):\n        """""" Sends ThriftClient request and writes out received files.""""""\n        req = GetTimesRequest()\n        req.setPluginName(self.pluginName)\n        req.setTimeField(self.timeField)\n        resp = self.client.sendRequest(req)\n\n        for i, rec in enumerate(resp):\n            resp[i] = {\n                key.decode() if isinstance(key, bytes) else key:\n                    val.decode() if isinstance(val, bytes) else val\n                for key, val in rec.items()\n            }\n\n        timelist = []\n        for item in resp.getTimes():\n            if isinstance(item, GregorianCalendar):\n                tstamp = item.getTimeInMillis()\n            else:\n                tstamp = item.getTime()\n            time = datetime.utcfromtimestamp(tstamp/1000)\n            timelist.append(time)\n\n        timelist.sort(reverse=True)\n\n        times = []\n        for time in timelist:\n            times.append(9999)\n            times.append((time.year % 100) * 10000 + (time.month * 100) + time.day)\n            times.append((time.hour * 100) + time.minute)\n\n        # GEMPAK can only handle up to 200 times, which is 600 elements\n        # in this array -- [9999, DATE, TIME] -- repeated\n        return times[0:600]\n\n\ndef gettimes(server, table, key, dummy, dummy2):\n    tr = TimeRetriever(server, table, key)\n    return tr.getTimes()\n\n\n# This is the standard boilerplate that runs this script as a main\nif __name__ == \'__main__\':\n    srv = \'edex-cloud.unidata.ucar.edu\'\n    print(\'OBS - METAR\')\n    tbl = \'obs\'\n    key = \'refHour\'\n    print(gettimes(srv, tbl, key))\n\n    print(\'SFCOBS - SYNOP\')\n    tbl = \'sfcobs\'\n    key = \'refHour\'\n    print(gettimes(srv, tbl, key))\n\n    print(\'BUFRUA\')\n    tbl = \'bufrua\'\n    key = \'dataTime.refTime\'\n    print(gettimes(srv, tbl, key))\n'"
awips/gempak/ncepGribTables.py,0,"b'#!/usr/bin/env python\n# Parse html tables from a given URL and output CSV.\n# Note: To install a missing python module foo do ""easy_install foo""\n#   (or the new way is ""pip install foo"" but you might have to do \n#    ""easy_install pip"" first)\n\nfrom BeautifulSoup import BeautifulSoup\nimport scrape\nimport urllib.request, urllib.error, urllib.parse\nimport html.entities\nimport re\nimport sys\nimport unicodedata\n\n\n# from http://stackoverflow.com/questions/1197981/convert-html-entities\ndef asciify2(s):\n    matches = re.findall(""&#\\d+;"", s)\n    if len(matches) > 0:\n        hits = set(matches)\n        for hit in hits:\n            name = hit[2:-1]\n            try:\n                entnum = int(name)\n                s = s.replace(hit, chr(entnum))\n            except ValueError:\n                pass\n\n    matches = re.findall(""&\\w+;"", s)\n    hits = set(matches)\n    amp = ""&amp;""\n    if amp in hits:\n        hits.remove(amp)\n    for hit in hits:\n        name = hit[1:-1]\n        if name in html.entities.name2codepoint:\n            s = s.replace(hit, """")\n    s = s.replace(amp, ""&"")\n    return s\n\n\ndef opensoup(url):\n    request = urllib.request.Request(url)\n    request.add_header(""User-Agent"", ""Mozilla/5.0"")\n    # To mimic a real browser\'s user-agent string more exactly, if necessary:\n    #   Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.14)\n    #   Gecko/20080418 Ubuntu/7.10 (gutsy) Firefox/2.0.0.14\n    pagefile = urllib.request.urlopen(request)\n    soup = BeautifulSoup(pagefile)\n    pagefile.close()\n    return soup\n\n\ndef asciify(s):\n    return unicodedata.normalize(\'NFKD\', s).encode(\'ascii\', \'ignore\')\n\n\n# remove extra whitespace, including stripping leading and trailing whitespace.\ndef condense(s):\n    s = re.sub(r""\\s+"", "" "", s, re.DOTALL)\n    return s.strip()\n\n\ndef stripurl(s):\n    s = re.sub(r""\\<span\\s+style\\s*\\=\\s*\\""display\\:none[^\\""]*\\""[^\\>]*\\>[^\\<]*\\<\\/span\\>"", """", s)\n    s = re.sub(r""\\&\\#160\\;"", "" "", s)\n    return condense(re.sub(r""\\<[^\\>]*\\>"", "" "", s))\n\n\n# this gets rid of tags and condenses whitespace\ndef striptags(s):\n    s = re.sub(r""\\<span\\s+style\\s*\\=\\s*\\""display\\:none[^\\""]*\\""[^\\>]*\\>[^\\<]*\\<\\/span\\>"", """", s)\n    s = re.sub(r""\\&\\#160\\;"", "" "", s)\n    return condense(s)\n\n\ndef getUrlArgs(parseUrl):\n    return re.search(\'grib2_table4-2-(\\d+)-(\\d+).shtml\', parseUrl).groups()\n\n\nif len(sys.argv) == 1:\n    print(""Usage: "", sys.argv[0], "" url [n]"")\n    print(""  (where n indicates which html table to parse)"")\n    exit(1)\n\nurl = sys.argv[1]\nsoup = opensoup(url)\ntables = soup.findAll(""table"")\n\nfor table in tables:\n    for r in table.findAll(\'tr\'):\n        rl = []\n        for c in r.findAll(re.compile(\'td|th\')):\n            rl.append(striptags(c.renderContents()))\n        if len(rl) > 1 and ""href"" in rl[1]:\n            print(\'! \' + stripurl(rl[1]))\n            scrapeUrl = \'http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_table4-2-\' + \\\n                        getUrlArgs(rl[1])[0] + ""-"" + getUrlArgs(rl[1])[1] + \'.shtml\'\n            scrape.run(scrapeUrl)\n'"
awips/gempak/scrape.py,0,"b'#!/usr/bin/env python\n# Parse html tables from a given URL and output CSV.\n# Note: To install a missing python module foo do ""easy_install foo""\n#   (or the new way is ""pip install foo"" but you might have to do \n#    ""easy_install pip"" first)\n\nfrom BeautifulSoup import BeautifulSoup\nimport urllib.request, urllib.error, urllib.parse\nimport html.entities\nimport re\nimport sys\nimport unicodedata\n\n\n# from http://stackoverflow.com/questions/1197981/convert-html-entities\ndef asciify2(s):\n    matches = re.findall(""&#\\d+;"", s)\n    if len(matches) > 0:\n        hits = set(matches)\n        for hit in hits:\n            name = hit[2:-1]\n            try:\n                entnum = int(name)\n                s = s.replace(hit, chr(entnum))\n            except ValueError:\n                pass\n\n    matches = re.findall(""&\\w+;"", s)\n    hits = set(matches)\n    amp = ""&amp;""\n    if amp in hits:\n        hits.remove(amp)\n    for hit in hits:\n        name = hit[1:-1]\n        if name in html.entities.name2codepoint:\n            s = s.replace(hit, """")\n    s = s.replace(amp, ""&"")\n    return s\n\n\ndef opensoup(url):\n    request = urllib.request.Request(url)\n    request.add_header(""User-Agent"", ""Mozilla/5.0"")\n    # To mimic a real browser\'s user-agent string more exactly, if necessary:\n    #   Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.14)\n    #   Gecko/20080418 Ubuntu/7.10 (gutsy) Firefox/2.0.0.14\n    pagefile = urllib.request.urlopen(request)\n    soup = BeautifulSoup(pagefile)\n    pagefile.close()\n    return soup\n\n\ndef asciify(s):\n    return unicodedata.normalize(\'NFKD\', s).encode(\'ascii\', \'ignore\')\n\n\n# remove extra whitespace, including stripping leading and trailing whitespace.\ndef condense(s):\n    s = re.sub(r""\\s+"", "" "", s, re.DOTALL)\n    return s.strip()\n\n\n# this gets rid of tags and condenses whitespace\ndef striptags(s):\n    s = re.sub(r""\\<span\\s+style\\s*\\=\\s*\\""display\\:none[^\\""]*\\""[^\\>]*\\>[^\\<]*\\<\\/span\\>"", """", s)\n    s = re.sub(r""\\&\\#160\\;"", "" "", s)\n    return condense(re.sub(r""\\<[^\\>]*\\>"", "" "", s))\n\n\nif len(sys.argv) == 1:  # called with no arguments\n    print(""Usage: "", sys.argv[0], "" url [n]"")\n    print(""  (where n indicates which html table to parse)"")\n    exit(1)\n\n\ndef getUrlArgs(parseUrl):\n    return re.search(\'grib2_table4-2-(\\d+)-(\\d+).shtml\', parseUrl).groups()\n\n\ndef run(url):\n    soup = opensoup(url)\n    tables = soup.findAll(""table"")\n    for table in tables:\n        ct = 0\n        for r in table.findAll(\'tr\'):\n            rl = []\n            for c in r.findAll(re.compile(\'td|th\')):\n                rl.append(striptags(c.renderContents()))\n        if ct > 0:\n            rl[0] = getUrlArgs(url)[0].zfill(3) + "" "" + \\\n                    getUrlArgs(url)[1].zfill(3) + "" "" + rl[0].zfill(3) + "" 000""\n        if len(rl) > 1:\n            if ""Reserved"" in rl[1]:\n                rl[0] = \'!\' + rl[0]\n            if ""See Table"" in rl[2] or ""Code table"" in rl[2]:\n                rl[2] = ""cat""\n            rl[1] = rl[1][:32].ljust(32)\n            rl[2] = rl[2].ljust(20)\n            rl[3] = rl[3].ljust(12) + ""     0  -9999.00""\n            if ct:\n                print("" "".join(rl))\n        ct += 1\n\n\nif __name__ == \'__main__\':\n    run(sys.argv[1])\n'"
awips/gfe/IFPClient.py,0,"b'#\n# Provides a Python-based interface for executing GFE requests.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/26/12                      dgilling       Initial Creation.\n#\n#\n\nfrom awips import ThriftClient\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import DatabaseID\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import ParmID\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import CommitGridsRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import GetGridInventoryRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import GetParmListRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import GetSelectTimeRangeRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.server.request import CommitGridRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.message import WsId\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.site.requests import GetActiveSitesRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.server.message import ServerResponse\n\n\nclass IFPClient(object):\n    def __init__(self, host, port, user, site=None, progName=None):\n        self.__thrift = ThriftClient.ThriftClient(host, port)\n        self.__wsId = WsId(userName=user, progName=progName)\n        # retrieve default site\n        if site is None:\n            sr = self.getSiteID()\n            if len(sr.getPayload()) > 0:\n                site = sr.getPayload()[0]\n        self.__siteId = site\n\n    def commitGrid(self, request):\n        if isinstance(request, CommitGridRequest):\n            return self.__commitGrid([request])\n        elif self.__isHomogenousIterable(request, CommitGridRequest):\n            return self.__commitGrid([cgr for cgr in request])\n        raise TypeError(""Invalid type: "" + str(type(request)) +\n                        "" for commitGrid(). Only accepts CommitGridRequest or lists of CommitGridRequest."")\n\n    def __commitGrid(self, requests):\n        ssr = ServerResponse()\n        request = CommitGridsRequest()\n        request.setCommits(requests)\n        sr = self.__makeRequest(request)\n        ssr.setMessages(sr.getMessages())\n        return ssr\n\n    def getParmList(self, pid):\n        argType = type(pid)\n        if argType is DatabaseID:\n            return self.__getParmList([pid])\n        elif self.__isHomogenousIterable(pid, DatabaseID):\n            return self.__getParmList([dbid for dbid in pid])\n        raise TypeError(""Invalid type: "" + str(argType) +\n                        "" for getParmList(). Only accepts DatabaseID or lists of DatabaseID."")\n\n    def __getParmList(self, ids):\n        ssr = ServerResponse()\n        request = GetParmListRequest()\n        request.setDbIds(ids)\n        sr = self.__makeRequest(request)\n        ssr.setMessages(sr.getMessages())\n        parmlist = sr.getPayload() if sr.getPayload() is not None else []\n        ssr.setPayload(parmlist)\n        return ssr\n\n    def __isHomogenousIterable(self, iterable, classType):\n        try:\n            iterator = iter(iterable)\n            for item in iterator:\n                if not isinstance(item, classType):\n                    return False\n        except TypeError:\n            return False\n        return True\n\n    def getGridInventory(self, parmID):\n        if isinstance(parmID, ParmID):\n            sr = self.__getGridInventory([parmID])\n            inventoryList = []\n            try:\n                inventoryList = sr.getPayload()[parmID]\n            except KeyError:\n                # no-op, we\'ve already default the TimeRange list to empty\n                pass\n            sr.setPayload(inventoryList)\n            return sr\n        elif self.__isHomogenousIterable(parmID, ParmID):\n            return self.__getGridInventory([pid for pid in parmID])\n        raise TypeError(""Invalid type: "" + str(type(parmID)) +\n                        "" specified to getGridInventory(). Accepts ParmID or lists of ParmID."")\n\n    def __getGridInventory(self, parmIDs):\n        ssr = ServerResponse()\n        request = GetGridInventoryRequest()\n        request.setParmIds(parmIDs)\n        sr = self.__makeRequest(request)\n        ssr.setMessages(sr.getMessages())\n        trs = sr.getPayload() if sr.getPayload() is not None else {}\n        ssr.setPayload(trs)\n        return ssr\n\n    def getSelectTR(self, name):\n        request = GetSelectTimeRangeRequest()\n        request.setName(name)\n        sr = self.__makeRequest(request)\n        ssr = ServerResponse()\n        ssr.setMessages(sr.getMessages())\n        ssr.setPayload(sr.getPayload())\n        return ssr\n\n    def getSiteID(self):\n        ssr = ServerResponse()\n        request = GetActiveSitesRequest()\n        sr = self.__makeRequest(request)\n        ssr.setMessages(sr.getMessages())\n        ids = sr.getPayload() if sr.getPayload() is not None else []\n        sr.setPayload(ids)\n        return sr\n\n    def __makeRequest(self, request):\n        try:\n            request.setSiteID(self.__siteId)\n        except AttributeError:\n            pass\n        try:\n            request.setWorkstationID(self.__wsId)\n        except AttributeError:\n            pass\n\n        sr = ServerResponse()\n        response = None\n        try:\n            response = self.__thrift.sendRequest(request)\n        except ThriftClient.ThriftRequestException as e:\n            sr.setMessages([str(e)])\n        try:\n            sr.setPayload(response.getPayload())\n        except AttributeError:\n            sr.setPayload(response)\n        try:\n            sr.setMessages(response.getMessages())\n        except AttributeError:\n            # not a server response, nothing else to do\n            pass\n\n        return sr\n'"
awips/gfe/__init__.py,0,b'\n__all__ = [\n           ]\n'
awips/test/Record.py,0,"b'import sys\n\n\nclass Record():\n    def __init__(self, level=0, msg=\'Test Message\'):\n        self.levelno = level\n        self.message = msg\n        self.exc_info = sys.exc_info()\n        self.exc_text = ""TEST""\n\n    def getMessage(self):\n        return self.message\n'"
awips/test/__init__.py,0,b'\n__all__ = []\n'
docs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# python-awips documentation build configuration file, created by\n# sphinx-quickstart on Tue Mar 15 15:59:23 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration ------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'.\'))\nsys.path.insert(0, os.path.abspath(\'../..\'))\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.autosectionlabel\',\n    \'notebook_gen_sphinxext\'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'python-awips\'\ncopyright = \'2018, Unidata\'\nauthor = \'Unidata\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'18.1.7\'\n# The full version, including alpha/beta/rc tags.\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#html_theme = \'alabaster\'\nhtml_theme = \'sphinx_rtd_theme\'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only \'ja\' uses this config value\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'python-awipsdoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n\n# Latex figure (float) alignment\n#\'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'python-awips.tex\', \'python-awips Documentation\',\n     \'Unidata\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'python-awips\', \'python-awips Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'python-awips\', \'python-awips Documentation\',\n     author, \'python-awips\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n\n# Set up mapping for other projects\' docs\nintersphinx_mapping = {\n                       \'matplotlib\': (\'http://matplotlib.org/\', None),\n                       \'numpy\': (\'http://docs.scipy.org/doc/numpy/\', None),\n                       \'scipy\': (\'http://docs.scipy.org/doc/scipy/reference/\', None),\n                       \'pint\': (\'http://pint.readthedocs.org/en/stable/\', None),\n                       \'python\': (\'http://docs.python.org\', None)\n                       }\n'"
docs/source/notebook_gen_sphinxext.py,0,"b'#\n# Generation of RST from notebooks\n#\nimport glob\nimport os\nimport os.path\nimport warnings\n\nwarnings.simplefilter(\'ignore\')\n\nfrom nbconvert.exporters import rst\n\ndef setup(app):\n    setup.app = app\n    setup.config = app.config\n    setup.confdir = app.confdir\n\n    app.connect(\'builder-inited\', generate_rst)\n\n    return dict(\n        version=\'0.1\',\n        parallel_read_safe=True,\n        parallel_write_safe=True\n    )\n\nnotebook_source_dir = \'../../examples/notebooks\'\ngenerated_source_dir = \'examples/generated\'\n\n\ndef nb_to_rst(nb_path):\n    """"""convert notebook to restructured text""""""\n    exporter = rst.RSTExporter()\n    out, resources = exporter.from_file(open(nb_path))\n    basename = os.path.splitext(os.path.basename(nb_path))[0]\n    imgdir = basename + \'_files\'\n    img_prefix = os.path.join(imgdir, basename + \'_\')\n    resources[\'metadata\'][\'basename\'] = basename\n    resources[\'metadata\'][\'name\'] = basename.replace(\'_\', \' \')\n    resources[\'metadata\'][\'imgdir\'] = imgdir\n    base_url = (\'http://nbviewer.ipython.org/github/Unidata/python-awips/blob/master/\'\n                \'examples/notebooks/\')\n    out_lines = [\'`Notebook <%s>`_\' % (base_url + os.path.basename(nb_path))]\n    for line in out.split(\'\\n\'):\n        if line.startswith(\'.. image:: \'):\n            line = line.replace(\'output_\', img_prefix)\n        out_lines.append(line)\n    out = \'\\n\'.join(out_lines)\n\n    return out, resources\n\n\ndef write_nb(dest, output, resources):\n    if not os.path.exists(dest):\n        os.makedirs(dest)\n    rst_file = os.path.join(dest,\n                            resources[\'metadata\'][\'basename\'] + resources[\'output_extension\'])\n    name = resources[\'metadata\'][\'name\']\n    with open(rst_file, \'w\') as rst:\n        header = \'=\' * len(name)\n        rst.write(header + \'\\n\')\n        rst.write(name + \'\\n\')\n        rst.write(header + \'\\n\')\n        rst.write(output)\n\n    imgdir = os.path.join(dest, resources[\'metadata\'][\'imgdir\'])\n    if not os.path.exists(imgdir):\n        os.makedirs(imgdir)\n    basename = resources[\'metadata\'][\'basename\']\n    for filename in resources[\'outputs\']:\n        img_file =  os.path.join(imgdir, filename.replace(\'output_\', basename + \'_\'))\n        with open(img_file, \'wb\') as img:\n            img.write(resources[\'outputs\'][filename])\n\n\ndef generate_rst(app):\n    for fname in glob.glob(os.path.join(app.srcdir, notebook_source_dir, \'*.ipynb\')):\n        write_nb(os.path.join(app.srcdir, generated_source_dir), *nb_to_rst(fname))\n'"
dynamicserialize/adapters/ByteBufferAdapter.py,0,"b'#\n# Adapter for java.nio.ByteBuffer\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/03/11                      dgilling       Initial Creation.\n#\n\nClassAdapter = [\'java.nio.ByteBuffer\', \'java.nio.HeapByteBuffer\']\n\n\ndef serialize(context, bufferset):\n    raise NotImplementedError(""Serialization of ByteBuffers is not supported."")\n\n\ndef deserialize(context):\n    byteBuf = context.readBinary()\n    return byteBuf\n'"
dynamicserialize/adapters/CalendarAdapter.py,0,"b""#\n# Adapter for java.util.Calendar\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/29/10                      wldougher     Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.java.util import Calendar\n\nClassAdapter = 'java.util.Calendar'\n\n\ndef serialize(context, calendar):\n    calTiM = calendar.getTimeInMillis()\n    context.writeI64(calTiM)\n\n\ndef deserialize(context):\n    result = Calendar()\n    result.setTimeInMillis(context.readI64())\n    return result\n"""
dynamicserialize/adapters/CommutativeTimestampAdapter.py,0,"b""#\n# Adapter for CommutativeTimestamp\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    9/21/2015       4486          rjpeter        Initial creation.\n#    Jun 23, 2016    5696          rjpeter        Handle CommutativeTimestamp.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import CommutativeTimestamp\n\nClassAdapter = 'com.raytheon.uf.common.time.CommutativeTimestamp'\n\n\ndef serialize(context, date):\n    context.writeI64(date.getTime())\n\n\ndef deserialize(context):\n    result = CommutativeTimestamp()\n    result.setTime(context.readI64())\n    return result\n"""
dynamicserialize/adapters/CoordAdapter.py,0,"b""#\n# Adapter for com.vividsolutions.jts.geom.Coordinate\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/20/11                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.vividsolutions.jts.geom import Coordinate\n\nClassAdapter = 'com.vividsolutions.jts.geom.Coordinate'\n\n\ndef serialize(context, coordinate):\n    context.writeDouble(coordinate.getX())\n    context.writeDouble(coordinate.getY())\n\n\ndef deserialize(context):\n    x = context.readDouble()\n    y = context.readDouble()\n    coord = Coordinate()\n    coord.setX(x)\n    coord.setY(y)\n    return coord\n"""
dynamicserialize/adapters/DatabaseIDAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.dataplugin.gfe.db.objects.DatabaseID\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    03/29/11                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import DatabaseID\n\nClassAdapter = 'com.raytheon.uf.common.dataplugin.gfe.db.objects.DatabaseID'\n\n\ndef serialize(context, dbId):\n    context.writeString(str(dbId))\n\n\ndef deserialize(context):\n    result = DatabaseID(context.readString())\n    return result\n"""
dynamicserialize/adapters/DateAdapter.py,0,"b""#\n# Adapter for java.util.Date\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    12/06/10                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.java.util import Date\n\nClassAdapter = 'java.util.Date'\n\n\ndef serialize(context, date):\n    context.writeI64(date.getTime())\n\n\ndef deserialize(context):\n    result = Date()\n    result.setTime(context.readI64())\n    return result\n"""
dynamicserialize/adapters/EnumSetAdapter.py,0,"b""#\n# Adapter for java.util.EnumSet\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/28/11                      dgilling       Initial Creation.\n#    12/02/13        2537          bsteffen       Serialize empty enum sets.\n#\n\nfrom dynamicserialize.dstypes.java.util import EnumSet\n\nClassAdapter = ['java.util.EnumSet', 'java.util.RegularEnumSet']\n\n\ndef serialize(context, bufferset):\n    setSize = len(bufferset)\n    context.writeI32(setSize)\n    context.writeString(bufferset.getEnumClass())\n    for val in bufferset:\n        context.writeString(val)\n\n\ndef deserialize(context):\n    setSize = context.readI32()\n    enumClassName = context.readString()\n    valList = []\n    for __ in range(setSize):\n        valList.append(context.readString())\n    return EnumSet(enumClassName, valList)\n"""
dynamicserialize/adapters/FloatBufferAdapter.py,0,"b'#\n# Adapter for java.nio.FloatBuffer\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/01/11                      dgilling       Initial Creation.\n#\n\nClassAdapter = [\'java.nio.FloatBuffer\', \'java.nio.HeapFloatBuffer\']\n\n\ndef serialize(context, bufferset):\n    raise NotImplementedError(""Serialization of FloatBuffers is not supported."")\n\n\ndef deserialize(context):\n    floatBuf = context.readFloatArray()\n    return floatBuf\n'"
dynamicserialize/adapters/FormattedDateAdapter.py,0,"b""#\n# Adapter for FormattedDate\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    9/21/2015       4486          rjpeter        Initial creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import FormattedDate\n\nClassAdapter = 'com.raytheon.uf.common.time.FormattedDate'\n\n\ndef serialize(context, date):\n    context.writeI64(date.getTime())\n\n\ndef deserialize(context):\n    result = FormattedDate()\n    result.setTime(context.readI64())\n    return result\n"""
dynamicserialize/adapters/GeomDataRespAdapter.py,0,"b""#\n#    Efficient adapter for GetGeometryDataResponse\n#\n#\n#    SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    Oct 17, 2016     5919         njensen        Initial creation\n#\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.response import GeometryResponseData\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.response import GetGeometryDataResponse\n\nClassAdapter = 'com.raytheon.uf.common.dataaccess.response.GetGeometryDataResponse'\n\n\ndef serialize(context, resp):\n    wkbs = resp.getGeometryWKBs()\n    # write list size\n    context.writeI32(len(wkbs))\n    # write byte arrays\n    for b in wkbs:\n        context.writeBinary(b)\n\n    geoData = resp.getGeoData()\n    # write list size\n    context.writeI32(len(geoData))\n    # write objects\n    for geo in geoData:\n        context.writeI32(geo.getGeometryWKBindex())\n        context.writeObject(geo.getTime())\n        context.writeObject(geo.getLevel())\n        context.writeObject(geo.getLocationName())\n        context.writeObject(geo.getAttributes())\n\n        # write data map\n        params = geo.getDataMap()\n        context.writeI32(len(params))\n        for p in params:\n            context.writeString(p)\n            value = params[p]\n            # actual value\n            context.writeObject(value[0])\n            # value type as string\n            context.writeString(str(value[1]))\n            # unit\n            context.writeObject(value[2])\n\n\ndef deserialize(context):\n    size = context.readI32()\n    wkbs = []\n    for __ in range(size):\n        wkb = context.readBinary()\n        wkbs.append(wkb)\n\n    geoData = []\n    size = context.readI32()\n    for _ in range(size):\n        data = GeometryResponseData()\n        # wkb index\n        wkbIndex = context.readI32()\n        data.setGeometryWKBindex(wkbIndex)\n\n        time = context.readObject()\n        data.setTime(time)\n        level = context.readObject()\n        data.setLevel(level)\n        locName = context.readObject()\n        data.setLocationName(locName)\n        attrs = context.readObject()\n        data.setAttributes(attrs)\n\n        # parameters\n        paramSize = context.readI32()\n        paramMap = {}\n        for __ in range(paramSize):\n            paramName = context.readString()\n            value = context.readObject()\n            tName = context.readString()\n            unit = context.readObject()\n            paramMap[paramName] = [value, tName, unit]\n        data.setDataMap(paramMap)\n        geoData.append(data)\n\n    # make the response object\n    resp = GetGeometryDataResponse()\n    resp.setGeometryWKBs(wkbs)\n    resp.setGeoData(geoData)\n\n    return resp\n"""
dynamicserialize/adapters/GeometryTypeAdapter.py,0,"b""#\n# Adapter for com.vividsolutions.jts.geom.Polygon\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/20/11                      dgilling      Initial Creation.\n#\n\nimport dynamicserialize\n\n# TODO: Implement serialization/make deserialization useful.\n# Deserialization was simply implemented to allow GridLocation objects to be\n# passed through thrift, but the resulting Geometry object will not be transformed into\n# useful data; the base byte array is passed to a worthless Geometry class.\n\nfrom dynamicserialize.dstypes.com.vividsolutions.jts.geom import Geometry\n\n# NOTE: At the moment, EDEX serializes Polygon, MultiPolygons, Points, and\n# Geometrys with the tag of the base class Geometry. Java's serialization\n# adapter is smarter and can determine the exact object by reading the binary\n# data. This adapter doesn't need this _yet_, so it has not been implemented.\nClassAdapter = 'com.vividsolutions.jts.geom.Geometry'\n\n\ndef serialize(context, coordinate):\n    raise dynamicserialize.SerializationException('Not implemented yet')\n\n\ndef deserialize(context):\n    data = context.readBinary()\n    geom = Geometry()\n    geom.setBinaryData(data)\n    return geom\n"""
dynamicserialize/adapters/GregorianCalendarAdapter.py,0,"b""#\n# Adapter for java.util.Calendar\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/29/10                      wldougher     Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.java.util import GregorianCalendar\n\nClassAdapter = 'java.util.GregorianCalendar'\n\n\ndef serialize(context, calendar):\n    calTiM = calendar.getTimeInMillis()\n    context.writeI64(calTiM)\n\n\ndef deserialize(context):\n    result = GregorianCalendar()\n    result.setTimeInMillis(context.readI64())\n    return result\n"""
dynamicserialize/adapters/GridDataHistoryAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.dataplugin.gfe.GridDataHistory\n#\n# TODO: REWRITE THIS ADAPTER when serialization/deserialization of this\n# class has been finalized.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    03/29/11                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe import GridDataHistory\n\nClassAdapter = 'com.raytheon.uf.common.dataplugin.gfe.GridDataHistory'\n\n\ndef serialize(context, history):\n    context.writeString(history.getCodedString())\n\n\ndef deserialize(context):\n    result = GridDataHistory(context.readString())\n    return result\n"""
dynamicserialize/adapters/JTSEnvelopeAdapter.py,0,"b""#\n# Adapter for com.vividsolutions.jts.geom.Envelope\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/29/13         2023         dgilling       Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.vividsolutions.jts.geom import Envelope\n\nClassAdapter = 'com.vividsolutions.jts.geom.Envelope'\n\n\ndef serialize(context, envelope):\n    context.writeDouble(envelope.getMinX())\n    context.writeDouble(envelope.getMaxX())\n    context.writeDouble(envelope.getMinY())\n    context.writeDouble(envelope.getMaxY())\n\n\ndef deserialize(context):\n    env = Envelope()\n    env.setMinX(context.readDouble())\n    env.setMaxX(context.readDouble())\n    env.setMinY(context.readDouble())\n    env.setMaxY(context.readDouble())\n    return env\n"""
dynamicserialize/adapters/LocalizationLevelSerializationAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.localization.LocalizationContext$LocalizationLevel\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/11/11                      dgilling       Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.localization import LocalizationLevel\n\nClassAdapter = [\n                 'com.raytheon.uf.common.localization.LocalizationContext$LocalizationLevel',\n                 'com.raytheon.uf.common.localization.LocalizationLevel'\n                ]\n\n\ndef serialize(context, level):\n    context.writeString(level.getText())\n    context.writeI32(level.getOrder())\n    context.writeBool(level.isSystemLevel())\n\n\ndef deserialize(context):\n    text = context.readString()\n    order = context.readI32()\n    systemLevel = context.readBool()\n    level = LocalizationLevel(text, order, systemLevel=systemLevel)\n    return level\n"""
dynamicserialize/adapters/LocalizationTypeSerializationAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.localization.LocalizationContext$LocalizationType\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/11/11                      dgilling       Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.localization import LocalizationType\n\nClassAdapter = [\n                'com.raytheon.uf.common.localization.LocalizationContext$LocalizationType',\n                'com.raytheon.uf.common.localization.LocalizationType'\n                ]\n\n\ndef serialize(context, ltype):\n    context.writeString(ltype.getText())\n\n\ndef deserialize(context):\n    typeString = context.readString()\n    return LocalizationType(typeString)\n"""
dynamicserialize/adapters/ParmIDAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.dataplugin.gfe.db.objects.ParmID\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    03/29/11                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import ParmID\n\nClassAdapter = 'com.raytheon.uf.common.dataplugin.gfe.db.objects.ParmID'\n\n\ndef serialize(context, parmId):\n    context.writeString(str(parmId))\n\n\ndef deserialize(context):\n    result = ParmID(context.readString())\n    return result\n"""
dynamicserialize/adapters/PointAdapter.py,0,"b""#\n# Adapter for java.awt.Point\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen       Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.java.awt import Point\n\nClassAdapter = 'java.awt.Point'\n\n\ndef serialize(context, point):\n    context.writeI32(point.getX())\n    context.writeI32(point.getY())\n\n\ndef deserialize(context):\n    x = context.readI32()\n    y = context.readI32()\n    point = Point()\n    point.setX(x)\n    point.setY(y)\n    return point\n"""
dynamicserialize/adapters/StackTraceElementAdapter.py,0,"b""#\n# Adapter for java.lang.StackTraceElement[]\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/21/10                      njensen       Initial Creation.\n#\n\nimport dynamicserialize\nfrom dynamicserialize.dstypes.java.lang import StackTraceElement\n\nClassAdapter = 'java.lang.StackTraceElement'\n\n\ndef serialize(context, obj):\n    raise dynamicserialize.SerializationException('Not implemented yet')\n\n\ndef deserialize(context):\n    result = StackTraceElement()\n    result.setDeclaringClass(context.readString())\n    result.setMethodName(context.readString())\n    result.setFileName(context.readString())\n    result.setLineNumber(context.readI32())\n    return result\n"""
dynamicserialize/adapters/TimeConstraintsAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.dataplugin.gfe.db.objects.ParmID\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    03/20/13           #1774      randerso       Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import TimeConstraints\n\nClassAdapter = 'com.raytheon.uf.common.dataplugin.gfe.db.objects.TimeConstraints'\n\n\ndef serialize(context, timeConstraints):\n    context.writeI32(timeConstraints.getDuration())\n    context.writeI32(timeConstraints.getRepeatInterval())\n    context.writeI32(timeConstraints.getStartTime())\n\n\ndef deserialize(context):\n    result = TimeConstraints(context.readI32(), context.readI32(), context.readI32())\n    return result\n"""
dynamicserialize/adapters/TimeRangeTypeAdapter.py,0,"b""#\n# Adapter for com.raytheon.uf.common.message.WsId\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/16/10                      dgilling       Initial Creation.\n#    01/22/14        2667          bclement       use method to get millis from time range\n#    02/28/14        2667          bclement       deserialize now converts millis to micros\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import TimeRange\n\nClassAdapter = 'com.raytheon.uf.common.time.TimeRange'\n\nMICROS_IN_MILLISECOND = 1000\nMILLIS_IN_SECOND = 1000\n\n\ndef serialize(context, timeRange):\n    context.writeI64(timeRange.getStartInMillis())\n    context.writeI64(timeRange.getEndInMillis())\n\n\ndef deserialize(context):\n    startTime = context.readI64()\n    endTime = context.readI64()\n\n    timeRange = TimeRange()\n    # java uses milliseconds, python uses microseconds\n    startSeconds = startTime // MILLIS_IN_SECOND\n    endSeconds = endTime // MILLIS_IN_SECOND\n    startExtraMicros = (startTime % MILLIS_IN_SECOND) * MICROS_IN_MILLISECOND\n    endExtraMicros = (endTime % MILLIS_IN_SECOND) * MICROS_IN_MILLISECOND\n    timeRange.setStart(startSeconds, startExtraMicros)\n    timeRange.setEnd(endSeconds, endExtraMicros)\n\n    return timeRange\n"""
dynamicserialize/adapters/TimestampAdapter.py,0,"b""#\n# Adapter for java.sql.Timestamp\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/30/11                      dgilling      Initial Creation.\n#\n\nfrom dynamicserialize.dstypes.java.sql import Timestamp\n\nClassAdapter = 'java.sql.Timestamp'\n\n\ndef serialize(context, timestamp):\n    context.writeI64(timestamp.getTime())\n\n\ndef deserialize(context):\n    result = Timestamp(context.readI64())\n    return result\n"""
dynamicserialize/adapters/WsIdAdapter.py,0,"b'#\n# Adapter for com.raytheon.uf.common.message.WsId\n#\n#\n# SOFTWARE HISTORY\n#\n# Date          Ticket#  Engineer  Description\n# ------------- -------- --------- ---------------------------------------------\n# Sep 16, 2010           dgilling  Initial Creation.\n# Apr 25, 2012  545      randerso  Repurposed the lockKey field as threadId\n# Feb 06, 2017  5959     randerso  Removed Java .toString() calls\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.message import WsId\n\nClassAdapter = \'com.raytheon.uf.common.message.WsId\'\n\n\ndef serialize(context, wsId):\n    context.writeString(str(wsId))\n\n\ndef deserialize(context):\n    wsIdString = context.readString()\n    wsIdParts = wsIdString.split("":"", 5)\n    wsId = WsId()\n    wsId.setNetworkId(wsIdParts[0])\n    wsId.setUserName(wsIdParts[1])\n    wsId.setProgName(wsIdParts[2])\n    wsId.setPid(wsIdParts[3])\n    wsId.setThreadId(int(wsIdParts[4]))\n    return wsId\n'"
dynamicserialize/adapters/__init__.py,0,"b""#\n# __init__.py for Dynamic Serialize adapters.\n#\n# Plugins can contribute to dynamicserialize.adapters by either including their\n# classes directly in pythonPackages/dynamicserialize/adapters/ within their\n# plugin. The plugin's adapter will automatically be added to __all__ at runtime\n# and registered.\n# Plugins should not include a custom __init__.py in\n# pythonPackages/dynamicserialize/adapters/ because it will overwrite this file.\n# If custom package initialization is needed, a subpackage should be created\n# with an __init__.py that includes the following:\n#\n# __all__ = ['CustomAdapter1', 'CustomAdapter2']\n# from dynamicserialize.adapters import registerAdapters\n# registerAdapters(__name__, __all__)\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen        Initial Creation.\n#    03/20/13           #1774      randerso       Added TimeConstraintsAdapter\n#    04/22/13           #1949      rjpeter        Added LockTableAdapter\n#    02/06/14           #2672      bsteffen       Added JTSEnvelopeAdapter\n#    09/21/2015         #4486      rjpeter        Added FormattedDateAdapter\n#    06/23/2016         #5696      rjpeter        Added CommutativeTimestampAdapter\n#    10/17/2016         #5919      njensen        Added GeomDataRespAdapter\n#    01/09/2017         #5997      nabowle        Allow contribution from plugins.\n#\n\n__all__ = [\n    'PointAdapter',\n    'StackTraceElementAdapter',\n    'WsIdAdapter',\n    'CalendarAdapter',\n    'GregorianCalendarAdapter',\n    'DateAdapter',\n    'FormattedDateAdapter',\n    'LocalizationLevelSerializationAdapter',\n    'LocalizationTypeSerializationAdapter',\n    'GeometryTypeAdapter',\n    'CoordAdapter',\n    'TimeRangeTypeAdapter',\n    'ParmIDAdapter',\n    'DatabaseIDAdapter',\n    'TimestampAdapter',\n    'CommutativeTimestampAdapter',\n    'EnumSetAdapter',\n    'FloatBufferAdapter',\n    'ByteBufferAdapter',\n    'TimeConstraintsAdapter',\n    'JTSEnvelopeAdapter'\n]\n\nclassAdapterRegistry = {}\n\n\ndef getAdapterRegistry():\n    import pkgutil\n\n    discoveredPackages = []\n    # allow other plugins to contribute to adapters by dropping their adapter or\n    # package into the dynamicserialize.adapters package\n    for _, modname, ispkg in pkgutil.iter_modules(__path__):\n        if ispkg:\n            discoveredPackages.append(modname)\n        else:\n            if modname not in __all__:\n                __all__.append(modname)\n\n    registerAdapters(__name__, __all__)\n\n    for pkg in discoveredPackages:\n        __import__(__name__ + '.' + pkg)\n\n\ndef registerAdapters(package, modules):\n    import sys\n    if not package.endswith('.'):\n        package += '.'\n    for x in modules:\n        # TODO: use importlib\n        exec('import ' + package + x)\n        m = sys.modules[package + x]\n        d = m.__dict__\n        if 'ClassAdapter' in d:\n            if isinstance(m.ClassAdapter, list):\n                for clz in m.ClassAdapter:\n                    classAdapterRegistry[clz] = m\n            else:\n                clzName = m.ClassAdapter\n                classAdapterRegistry[clzName] = m\n        else:\n            raise LookupError('Adapter class ' + x + ' has no ClassAdapter field ' +\n                              'and cannot be registered.')\n\n\ngetAdapterRegistry()\n"""
dynamicserialize/dstypes/__init__.py,0,"b""\n__all__ = [\n            'com',\n            'gov',\n            'java'\n          ]\n"""
thrift/protocol/TBase.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom thrift.Thrift import *\nfrom thrift.protocol import TBinaryProtocol\nfrom thrift.transport import TTransport\n\ntry:\n  from thrift.protocol import fastbinary\nexcept:\n  fastbinary = None\n\n\nclass TBase(object):\n  __slots__ = []\n\n  def __repr__(self):\n    L = [\'%s=%r\' % (key, getattr(self, key))\n              for key in self.__slots__]\n    return \'%s(%s)\' % (self.__class__.__name__, \', \'.join(L))\n\n  def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n      return False\n    for attr in self.__slots__:\n      my_val = getattr(self, attr)\n      other_val = getattr(other, attr)\n      if my_val != other_val:\n        return False\n    return True\n\n  def __ne__(self, other):\n    return not (self == other)\n\n  def read(self, iprot):\n    if (iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and\n        isinstance(iprot.trans, TTransport.CReadableTransport) and\n        self.thrift_spec is not None and\n        fastbinary is not None):\n      fastbinary.decode_binary(self,\n                               iprot.trans,\n                               (self.__class__, self.thrift_spec))\n      return\n    iprot.readStruct(self, self.thrift_spec)\n\n  def write(self, oprot):\n    if (oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and\n        self.thrift_spec is not None and\n        fastbinary is not None):\n      oprot.trans.write(\n        fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))\n      return\n    oprot.writeStruct(self, self.thrift_spec)\n\n\nclass TExceptionBase(Exception):\n  # old style class so python2.4 can raise exceptions derived from this\n  #  This can\'t inherit from TBase because of that limitation.\n  __slots__ = []\n\n  __repr__ = TBase.__repr__.__func__\n  __eq__ = TBase.__eq__.__func__\n  __ne__ = TBase.__ne__.__func__\n  read = TBase.read.__func__\n  write = TBase.write.__func__\n'"
thrift/protocol/TBinaryProtocol.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom .TProtocol import *\nfrom struct import pack, unpack\n\n\nclass TBinaryProtocol(TProtocolBase):\n  """"""Binary implementation of the Thrift protocol driver.""""""\n\n  # NastyHaxx. Python 2.4+ on 32-bit machines forces hex constants to be\n  # positive, converting this into a long. If we hardcode the int value\n  # instead it\'ll stay in 32 bit-land.\n\n  # VERSION_MASK = 0xffff0000\n  VERSION_MASK = -65536\n\n  # VERSION_1 = 0x80010000\n  VERSION_1 = -2147418112\n\n  TYPE_MASK = 0x000000ff\n\n  def __init__(self, trans, strictRead=False, strictWrite=True):\n    TProtocolBase.__init__(self, trans)\n    self.strictRead = strictRead\n    self.strictWrite = strictWrite\n\n  def writeMessageBegin(self, name, type, seqid):\n    if self.strictWrite:\n      self.writeI32(TBinaryProtocol.VERSION_1 | type)\n      self.writeString(name)\n      self.writeI32(seqid)\n    else:\n      self.writeString(name)\n      self.writeByte(type)\n      self.writeI32(seqid)\n\n  def writeMessageEnd(self):\n    pass\n\n  def writeStructBegin(self, name):\n    pass\n\n  def writeStructEnd(self):\n    pass\n\n  def writeFieldBegin(self, name, type, id):\n    self.writeByte(type)\n    self.writeI16(id)\n\n  def writeFieldEnd(self):\n    pass\n\n  def writeFieldStop(self):\n    self.writeByte(TType.STOP)\n\n  def writeMapBegin(self, ktype, vtype, size):\n    self.writeByte(ktype)\n    self.writeByte(vtype)\n    self.writeI32(size)\n\n  def writeMapEnd(self):\n    pass\n\n  def writeListBegin(self, etype, size):\n    self.writeByte(etype)\n    self.writeI32(size)\n\n  def writeListEnd(self):\n    pass\n\n  def writeSetBegin(self, etype, size):\n    self.writeByte(etype)\n    self.writeI32(size)\n\n  def writeSetEnd(self):\n    pass\n\n  def writeBool(self, bool):\n    if bool:\n      self.writeByte(1)\n    else:\n      self.writeByte(0)\n\n  def writeByte(self, byte):\n    buff = pack(""!b"", byte)\n    self.trans.write(buff)\n\n  def writeI16(self, i16):\n    buff = pack(""!h"", i16)\n    self.trans.write(buff)\n\n  def writeI32(self, i32):\n    buff = pack(""!i"", i32)\n    self.trans.write(buff)\n\n  def writeI64(self, i64):\n    buff = pack(""!q"", i64)\n    self.trans.write(buff)\n\n  def writeDouble(self, dub):\n    buff = pack(""!d"", dub)\n    self.trans.write(buff)\n\n  def writeString(self, str):\n    self.writeI32(len(str))\n    self.trans.write(str)\n\n  def readMessageBegin(self):\n    sz = self.readI32()\n    if sz < 0:\n      version = sz & TBinaryProtocol.VERSION_MASK\n      if version != TBinaryProtocol.VERSION_1:\n        raise TProtocolException(\n          type=TProtocolException.BAD_VERSION,\n          message=\'Bad version in readMessageBegin: %d\' % (sz))\n      type = sz & TBinaryProtocol.TYPE_MASK\n      name = self.readString()\n      seqid = self.readI32()\n    else:\n      if self.strictRead:\n        raise TProtocolException(type=TProtocolException.BAD_VERSION,\n                                 message=\'No protocol version header\')\n      name = self.trans.readAll(sz)\n      type = self.readByte()\n      seqid = self.readI32()\n    return (name, type, seqid)\n\n  def readMessageEnd(self):\n    pass\n\n  def readStructBegin(self):\n    pass\n\n  def readStructEnd(self):\n    pass\n\n  def readFieldBegin(self):\n    type = self.readByte()\n    if type == TType.STOP:\n      return (None, type, 0)\n    id = self.readI16()\n    return (None, type, id)\n\n  def readFieldEnd(self):\n    pass\n\n  def readMapBegin(self):\n    ktype = self.readByte()\n    vtype = self.readByte()\n    size = self.readI32()\n    return (ktype, vtype, size)\n\n  def readMapEnd(self):\n    pass\n\n  def readListBegin(self):\n    etype = self.readByte()\n    size = self.readI32()\n    return (etype, size)\n\n  def readListEnd(self):\n    pass\n\n  def readSetBegin(self):\n    etype = self.readByte()\n    size = self.readI32()\n    return (etype, size)\n\n  def readSetEnd(self):\n    pass\n\n  def readBool(self):\n    byte = self.readByte()\n    if byte == 0:\n      return False\n    return True\n\n  def readByte(self):\n    buff = self.trans.readAll(1)\n    val, = unpack(\'!b\', buff)\n    return val\n\n  def readI16(self):\n    buff = self.trans.readAll(2)\n    val, = unpack(\'!h\', buff)\n    return val\n\n  def readI32(self):\n    buff = self.trans.readAll(4)\n    try:\n      val, = unpack(\'!i\', buff)\n    except TypeError:\n      #str does not support the buffer interface\n      val, = unpack(\'!i\', buff)\n    return val\n\n  def readI64(self):\n    buff = self.trans.readAll(8)\n    val, = unpack(\'!q\', buff)\n    return val\n\n  def readDouble(self):\n    buff = self.trans.readAll(8)\n    val, = unpack(\'!d\', buff)\n    return val\n\n  def readString(self):\n    len = self.readI32()\n    str = self.trans.readAll(len)\n    return str\n\n\nclass TBinaryProtocolFactory:\n  def __init__(self, strictRead=False, strictWrite=True):\n    self.strictRead = strictRead\n    self.strictWrite = strictWrite\n\n  def getProtocol(self, trans):\n    prot = TBinaryProtocol(trans, self.strictRead, self.strictWrite)\n    return prot\n\n\nclass TBinaryProtocolAccelerated(TBinaryProtocol):\n  """"""C-Accelerated version of TBinaryProtocol.\n\n  This class does not override any of TBinaryProtocol\'s methods,\n  but the generated code recognizes it directly and will call into\n  our C module to do the encoding, bypassing this object entirely.\n  We inherit from TBinaryProtocol so that the normal TBinaryProtocol\n  encoding can happen if the fastbinary module doesn\'t work for some\n  reason.  (TODO(dreiss): Make this happen sanely in more cases.)\n\n  In order to take advantage of the C module, just use\n  TBinaryProtocolAccelerated instead of TBinaryProtocol.\n\n  NOTE:  This code was contributed by an external developer.\n         The internal Thrift team has reviewed and tested it,\n         but we cannot guarantee that it is production-ready.\n         Please feel free to report bugs and/or success stories\n         to the public mailing list.\n  """"""\n  pass\n\n\nclass TBinaryProtocolAcceleratedFactory:\n  def getProtocol(self, trans):\n    return TBinaryProtocolAccelerated(trans)\n'"
thrift/protocol/TCompactProtocol.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom .TProtocol import *\nfrom struct import pack, unpack\n\n__all__ = [\'TCompactProtocol\', \'TCompactProtocolFactory\']\n\nCLEAR = 0\nFIELD_WRITE = 1\nVALUE_WRITE = 2\nCONTAINER_WRITE = 3\nBOOL_WRITE = 4\nFIELD_READ = 5\nCONTAINER_READ = 6\nVALUE_READ = 7\nBOOL_READ = 8\n\n\ndef make_helper(v_from, container):\n  def helper(func):\n    def nested(self, *args, **kwargs):\n      assert self.state in (v_from, container), (self.state, v_from, container)\n      return func(self, *args, **kwargs)\n    return nested\n  return helper\nwriter = make_helper(VALUE_WRITE, CONTAINER_WRITE)\nreader = make_helper(VALUE_READ, CONTAINER_READ)\n\n\ndef makeZigZag(n, bits):\n  return (n << 1) ^ (n >> (bits - 1))\n\n\ndef fromZigZag(n):\n  return (n >> 1) ^ -(n & 1)\n\n\ndef writeVarint(trans, n):\n  out = []\n  while True:\n    if n & ~0x7f == 0:\n      out.append(n)\n      break\n    else:\n      out.append((n & 0xff) | 0x80)\n      n = n >> 7\n  trans.write(\'\'.join(map(chr, out)))\n\n\ndef readVarint(trans):\n  result = 0\n  shift = 0\n  while True:\n    x = trans.readAll(1)\n    byte = ord(x)\n    result |= (byte & 0x7f) << shift\n    if byte >> 7 == 0:\n      return result\n    shift += 7\n\n\nclass CompactType:\n  STOP = 0x00\n  TRUE = 0x01\n  FALSE = 0x02\n  BYTE = 0x03\n  I16 = 0x04\n  I32 = 0x05\n  I64 = 0x06\n  DOUBLE = 0x07\n  BINARY = 0x08\n  LIST = 0x09\n  SET = 0x0A\n  MAP = 0x0B\n  STRUCT = 0x0C\n\nCTYPES = {TType.STOP: CompactType.STOP,\n          TType.BOOL: CompactType.TRUE,  # used for collection\n          TType.BYTE: CompactType.BYTE,\n          TType.I16: CompactType.I16,\n          TType.I32: CompactType.I32,\n          TType.I64: CompactType.I64,\n          TType.DOUBLE: CompactType.DOUBLE,\n          TType.STRING: CompactType.BINARY,\n          TType.STRUCT: CompactType.STRUCT,\n          TType.LIST: CompactType.LIST,\n          TType.SET: CompactType.SET,\n          TType.MAP: CompactType.MAP\n          }\n\nTTYPES = {}\nfor k, v in list(CTYPES.items()):\n  TTYPES[v] = k\nTTYPES[CompactType.FALSE] = TType.BOOL\ndel k\ndel v\n\n\nclass TCompactProtocol(TProtocolBase):\n  """"""Compact implementation of the Thrift protocol driver.""""""\n\n  PROTOCOL_ID = 0x82\n  VERSION = 1\n  VERSION_MASK = 0x1f\n  TYPE_MASK = 0xe0\n  TYPE_SHIFT_AMOUNT = 5\n\n  def __init__(self, trans):\n    TProtocolBase.__init__(self, trans)\n    self.state = CLEAR\n    self.__last_fid = 0\n    self.__bool_fid = None\n    self.__bool_value = None\n    self.__structs = []\n    self.__containers = []\n\n  def __writeVarint(self, n):\n    writeVarint(self.trans, n)\n\n  def writeMessageBegin(self, name, type, seqid):\n    assert self.state == CLEAR\n    self.__writeUByte(self.PROTOCOL_ID)\n    self.__writeUByte(self.VERSION | (type << self.TYPE_SHIFT_AMOUNT))\n    self.__writeVarint(seqid)\n    self.__writeString(name)\n    self.state = VALUE_WRITE\n\n  def writeMessageEnd(self):\n    assert self.state == VALUE_WRITE\n    self.state = CLEAR\n\n  def writeStructBegin(self, name):\n    assert self.state in (CLEAR, CONTAINER_WRITE, VALUE_WRITE), self.state\n    self.__structs.append((self.state, self.__last_fid))\n    self.state = FIELD_WRITE\n    self.__last_fid = 0\n\n  def writeStructEnd(self):\n    assert self.state == FIELD_WRITE\n    self.state, self.__last_fid = self.__structs.pop()\n\n  def writeFieldStop(self):\n    self.__writeByte(0)\n\n  def __writeFieldHeader(self, type, fid):\n    delta = fid - self.__last_fid\n    if 0 < delta <= 15:\n      self.__writeUByte(delta << 4 | type)\n    else:\n      self.__writeByte(type)\n      self.__writeI16(fid)\n    self.__last_fid = fid\n\n  def writeFieldBegin(self, name, type, fid):\n    assert self.state == FIELD_WRITE, self.state\n    if type == TType.BOOL:\n      self.state = BOOL_WRITE\n      self.__bool_fid = fid\n    else:\n      self.state = VALUE_WRITE\n      self.__writeFieldHeader(CTYPES[type], fid)\n\n  def writeFieldEnd(self):\n    assert self.state in (VALUE_WRITE, BOOL_WRITE), self.state\n    self.state = FIELD_WRITE\n\n  def __writeUByte(self, byte):\n    self.trans.write(pack(\'!B\', byte))\n\n  def __writeByte(self, byte):\n    self.trans.write(pack(\'!b\', byte))\n\n  def __writeI16(self, i16):\n    self.__writeVarint(makeZigZag(i16, 16))\n\n  def __writeSize(self, i32):\n    self.__writeVarint(i32)\n\n  def writeCollectionBegin(self, etype, size):\n    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state\n    if size <= 14:\n      self.__writeUByte(size << 4 | CTYPES[etype])\n    else:\n      self.__writeUByte(0xf0 | CTYPES[etype])\n      self.__writeSize(size)\n    self.__containers.append(self.state)\n    self.state = CONTAINER_WRITE\n  writeSetBegin = writeCollectionBegin\n  writeListBegin = writeCollectionBegin\n\n  def writeMapBegin(self, ktype, vtype, size):\n    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state\n    if size == 0:\n      self.__writeByte(0)\n    else:\n      self.__writeSize(size)\n      self.__writeUByte(CTYPES[ktype] << 4 | CTYPES[vtype])\n    self.__containers.append(self.state)\n    self.state = CONTAINER_WRITE\n\n  def writeCollectionEnd(self):\n    assert self.state == CONTAINER_WRITE, self.state\n    self.state = self.__containers.pop()\n  writeMapEnd = writeCollectionEnd\n  writeSetEnd = writeCollectionEnd\n  writeListEnd = writeCollectionEnd\n\n  def writeBool(self, bool):\n    if self.state == BOOL_WRITE:\n      if bool:\n        ctype = CompactType.TRUE\n      else:\n        ctype = CompactType.FALSE\n      self.__writeFieldHeader(ctype, self.__bool_fid)\n    elif self.state == CONTAINER_WRITE:\n      if bool:\n        self.__writeByte(CompactType.TRUE)\n      else:\n        self.__writeByte(CompactType.FALSE)\n    else:\n      raise AssertionError(""Invalid state in compact protocol"")\n\n  writeByte = writer(__writeByte)\n  writeI16 = writer(__writeI16)\n\n  @writer\n  def writeI32(self, i32):\n    self.__writeVarint(makeZigZag(i32, 32))\n\n  @writer\n  def writeI64(self, i64):\n    self.__writeVarint(makeZigZag(i64, 64))\n\n  @writer\n  def writeDouble(self, dub):\n    self.trans.write(pack(\'!d\', dub))\n\n  def __writeString(self, s):\n    self.__writeSize(len(s))\n    self.trans.write(s)\n  writeString = writer(__writeString)\n\n  def readFieldBegin(self):\n    assert self.state == FIELD_READ, self.state\n    type = self.__readUByte()\n    if type & 0x0f == TType.STOP:\n      return (None, 0, 0)\n    delta = type >> 4\n    if delta == 0:\n      fid = self.__readI16()\n    else:\n      fid = self.__last_fid + delta\n    self.__last_fid = fid\n    type = type & 0x0f\n    if type == CompactType.TRUE:\n      self.state = BOOL_READ\n      self.__bool_value = True\n    elif type == CompactType.FALSE:\n      self.state = BOOL_READ\n      self.__bool_value = False\n    else:\n      self.state = VALUE_READ\n    return (None, self.__getTType(type), fid)\n\n  def readFieldEnd(self):\n    assert self.state in (VALUE_READ, BOOL_READ), self.state\n    self.state = FIELD_READ\n\n  def __readUByte(self):\n    result, = unpack(\'!B\', self.trans.readAll(1))\n    return result\n\n  def __readByte(self):\n    result, = unpack(\'!b\', self.trans.readAll(1))\n    return result\n\n  def __readVarint(self):\n    return readVarint(self.trans)\n\n  def __readZigZag(self):\n    return fromZigZag(self.__readVarint())\n\n  def __readSize(self):\n    result = self.__readVarint()\n    if result < 0:\n      raise TException(""Length < 0"")\n    return result\n\n  def readMessageBegin(self):\n    assert self.state == CLEAR\n    proto_id = self.__readUByte()\n    if proto_id != self.PROTOCOL_ID:\n      raise TProtocolException(TProtocolException.BAD_VERSION,\n          \'Bad protocol id in the message: %d\' % proto_id)\n    ver_type = self.__readUByte()\n    type = (ver_type & self.TYPE_MASK) >> self.TYPE_SHIFT_AMOUNT\n    version = ver_type & self.VERSION_MASK\n    if version != self.VERSION:\n      raise TProtocolException(TProtocolException.BAD_VERSION,\n          \'Bad version: %d (expect %d)\' % (version, self.VERSION))\n    seqid = self.__readVarint()\n    name = self.__readString()\n    return (name, type, seqid)\n\n  def readMessageEnd(self):\n    assert self.state == CLEAR\n    assert len(self.__structs) == 0\n\n  def readStructBegin(self):\n    assert self.state in (CLEAR, CONTAINER_READ, VALUE_READ), self.state\n    self.__structs.append((self.state, self.__last_fid))\n    self.state = FIELD_READ\n    self.__last_fid = 0\n\n  def readStructEnd(self):\n    assert self.state == FIELD_READ\n    self.state, self.__last_fid = self.__structs.pop()\n\n  def readCollectionBegin(self):\n    assert self.state in (VALUE_READ, CONTAINER_READ), self.state\n    size_type = self.__readUByte()\n    size = size_type >> 4\n    type = self.__getTType(size_type)\n    if size == 15:\n      size = self.__readSize()\n    self.__containers.append(self.state)\n    self.state = CONTAINER_READ\n    return type, size\n  readSetBegin = readCollectionBegin\n  readListBegin = readCollectionBegin\n\n  def readMapBegin(self):\n    assert self.state in (VALUE_READ, CONTAINER_READ), self.state\n    size = self.__readSize()\n    types = 0\n    if size > 0:\n      types = self.__readUByte()\n    vtype = self.__getTType(types)\n    ktype = self.__getTType(types >> 4)\n    self.__containers.append(self.state)\n    self.state = CONTAINER_READ\n    return (ktype, vtype, size)\n\n  def readCollectionEnd(self):\n    assert self.state == CONTAINER_READ, self.state\n    self.state = self.__containers.pop()\n  readSetEnd = readCollectionEnd\n  readListEnd = readCollectionEnd\n  readMapEnd = readCollectionEnd\n\n  def readBool(self):\n    if self.state == BOOL_READ:\n      return self.__bool_value == CompactType.TRUE\n    elif self.state == CONTAINER_READ:\n      return self.__readByte() == CompactType.TRUE\n    else:\n      raise AssertionError(""Invalid state in compact protocol: %d"" %\n                           self.state)\n\n  readByte = reader(__readByte)\n  __readI16 = __readZigZag\n  readI16 = reader(__readZigZag)\n  readI32 = reader(__readZigZag)\n  readI64 = reader(__readZigZag)\n\n  @reader\n  def readDouble(self):\n    buff = self.trans.readAll(8)\n    val, = unpack(\'!d\', buff)\n    return val\n\n  def __readString(self):\n    len = self.__readSize()\n    return self.trans.readAll(len)\n  readString = reader(__readString)\n\n  def __getTType(self, byte):\n    return TTYPES[byte & 0x0f]\n\n\nclass TCompactProtocolFactory:\n  def __init__(self):\n    pass\n\n  def getProtocol(self, trans):\n    return TCompactProtocol(trans)\n'"
thrift/protocol/TProtocol.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom thrift.Thrift import *\n\n\nclass TProtocolException(TException):\n  """"""Custom Protocol Exception class""""""\n\n  UNKNOWN = 0\n  INVALID_DATA = 1\n  NEGATIVE_SIZE = 2\n  SIZE_LIMIT = 3\n  BAD_VERSION = 4\n\n  def __init__(self, type=UNKNOWN, message=None):\n    TException.__init__(self, message)\n    self.type = type\n\n\nclass TProtocolBase:\n  """"""Base class for Thrift protocol driver.""""""\n\n  def __init__(self, trans):\n    self.trans = trans\n\n  def writeMessageBegin(self, name, type, seqid):\n    pass\n\n  def writeMessageEnd(self):\n    pass\n\n  def writeStructBegin(self, name):\n    pass\n\n  def writeStructEnd(self):\n    pass\n\n  def writeFieldBegin(self, name, type, id):\n    pass\n\n  def writeFieldEnd(self):\n    pass\n\n  def writeFieldStop(self):\n    pass\n\n  def writeMapBegin(self, ktype, vtype, size):\n    pass\n\n  def writeMapEnd(self):\n    pass\n\n  def writeListBegin(self, etype, size):\n    pass\n\n  def writeListEnd(self):\n    pass\n\n  def writeSetBegin(self, etype, size):\n    pass\n\n  def writeSetEnd(self):\n    pass\n\n  def writeBool(self, bool):\n    pass\n\n  def writeByte(self, byte):\n    pass\n\n  def writeI16(self, i16):\n    pass\n\n  def writeI32(self, i32):\n    pass\n\n  def writeI64(self, i64):\n    pass\n\n  def writeDouble(self, dub):\n    pass\n\n  def writeString(self, str):\n    pass\n\n  def readMessageBegin(self):\n    pass\n\n  def readMessageEnd(self):\n    pass\n\n  def readStructBegin(self):\n    pass\n\n  def readStructEnd(self):\n    pass\n\n  def readFieldBegin(self):\n    pass\n\n  def readFieldEnd(self):\n    pass\n\n  def readMapBegin(self):\n    pass\n\n  def readMapEnd(self):\n    pass\n\n  def readListBegin(self):\n    pass\n\n  def readListEnd(self):\n    pass\n\n  def readSetBegin(self):\n    pass\n\n  def readSetEnd(self):\n    pass\n\n  def readBool(self):\n    pass\n\n  def readByte(self):\n    pass\n\n  def readI16(self):\n    pass\n\n  def readI32(self):\n    pass\n\n  def readI64(self):\n    pass\n\n  def readDouble(self):\n    pass\n\n  def readString(self):\n    pass\n\n  def skip(self, type):\n    if type == TType.STOP:\n      return\n    elif type == TType.BOOL:\n      self.readBool()\n    elif type == TType.BYTE:\n      self.readByte()\n    elif type == TType.I16:\n      self.readI16()\n    elif type == TType.I32:\n      self.readI32()\n    elif type == TType.I64:\n      self.readI64()\n    elif type == TType.DOUBLE:\n      self.readDouble()\n    elif type == TType.STRING:\n      self.readString()\n    elif type == TType.STRUCT:\n      name = self.readStructBegin()\n      while True:\n        (name, type, id) = self.readFieldBegin()\n        if type == TType.STOP:\n          break\n        self.skip(type)\n        self.readFieldEnd()\n      self.readStructEnd()\n    elif type == TType.MAP:\n      (ktype, vtype, size) = self.readMapBegin()\n      for i in range(size):\n        self.skip(ktype)\n        self.skip(vtype)\n      self.readMapEnd()\n    elif type == TType.SET:\n      (etype, size) = self.readSetBegin()\n      for i in range(size):\n        self.skip(etype)\n      self.readSetEnd()\n    elif type == TType.LIST:\n      (etype, size) = self.readListBegin()\n      for i in range(size):\n        self.skip(etype)\n      self.readListEnd()\n\n  # tuple of: ( \'reader method\' name, is_container bool, \'writer_method\' name )\n  _TTYPE_HANDLERS = (\n       (None, None, False),  # 0 TType.STOP\n       (None, None, False),  # 1 TType.VOID # TODO: handle void?\n       (\'readBool\', \'writeBool\', False),  # 2 TType.BOOL\n       (\'readByte\',  \'writeByte\', False),  # 3 TType.BYTE and I08\n       (\'readDouble\', \'writeDouble\', False),  # 4 TType.DOUBLE\n       (None, None, False),  # 5 undefined\n       (\'readI16\', \'writeI16\', False),  # 6 TType.I16\n       (None, None, False),  # 7 undefined\n       (\'readI32\', \'writeI32\', False),  # 8 TType.I32\n       (None, None, False),  # 9 undefined\n       (\'readI64\', \'writeI64\', False),  # 10 TType.I64\n       (\'readString\', \'writeString\', False),  # 11 TType.STRING and UTF7\n       (\'readContainerStruct\', \'writeContainerStruct\', True),  # 12 *.STRUCT\n       (\'readContainerMap\', \'writeContainerMap\', True),  # 13 TType.MAP\n       (\'readContainerSet\', \'writeContainerSet\', True),  # 14 TType.SET\n       (\'readContainerList\', \'writeContainerList\', True),  # 15 TType.LIST\n       (None, None, False),  # 16 TType.UTF8 # TODO: handle utf8 types?\n       (None, None, False)  # 17 TType.UTF16 # TODO: handle utf16 types?\n      )\n\n  def readFieldByTType(self, ttype, spec):\n    try:\n      (r_handler, w_handler, is_container) = self._TTYPE_HANDLERS[ttype]\n    except IndexError:\n      raise TProtocolException(type=TProtocolException.INVALID_DATA,\n                               message=\'Invalid field type %d\' % (ttype))\n    if r_handler is None:\n      raise TProtocolException(type=TProtocolException.INVALID_DATA,\n                               message=\'Invalid field type %d\' % (ttype))\n    reader = getattr(self, r_handler)\n    if not is_container:\n      return reader()\n    return reader(spec)\n\n  def readContainerList(self, spec):\n    results = []\n    ttype, tspec = spec[0], spec[1]\n    r_handler = self._TTYPE_HANDLERS[ttype][0]\n    reader = getattr(self, r_handler)\n    (list_type, list_len) = self.readListBegin()\n    if tspec is None:\n      # list values are simple types\n      for idx in range(list_len):\n        results.append(reader())\n    else:\n      # this is like an inlined readFieldByTType\n      container_reader = self._TTYPE_HANDLERS[list_type][0]\n      val_reader = getattr(self, container_reader)\n      for idx in range(list_len):\n        val = val_reader(tspec)\n        results.append(val)\n    self.readListEnd()\n    return results\n\n  def readContainerSet(self, spec):\n    results = set()\n    ttype, tspec = spec[0], spec[1]\n    r_handler = self._TTYPE_HANDLERS[ttype][0]\n    reader = getattr(self, r_handler)\n    (set_type, set_len) = self.readSetBegin()\n    if tspec is None:\n      # set members are simple types\n      for idx in range(set_len):\n        results.add(reader())\n    else:\n      container_reader = self._TTYPE_HANDLERS[set_type][0]\n      val_reader = getattr(self, container_reader)\n      for idx in range(set_len):\n        results.add(val_reader(tspec))\n    self.readSetEnd()\n    return results\n\n  def readContainerStruct(self, spec):\n    (obj_class, obj_spec) = spec\n    obj = obj_class()\n    obj.read(self)\n    return obj\n\n  def readContainerMap(self, spec):\n    results = dict()\n    key_ttype, key_spec = spec[0], spec[1]\n    val_ttype, val_spec = spec[2], spec[3]\n    (map_ktype, map_vtype, map_len) = self.readMapBegin()\n    # TODO: compare types we just decoded with thrift_spec and\n    # abort/skip if types disagree\n    key_reader = getattr(self, self._TTYPE_HANDLERS[key_ttype][0])\n    val_reader = getattr(self, self._TTYPE_HANDLERS[val_ttype][0])\n    # list values are simple types\n    for idx in range(map_len):\n      if key_spec is None:\n        k_val = key_reader()\n      else:\n        k_val = self.readFieldByTType(key_ttype, key_spec)\n      if val_spec is None:\n        v_val = val_reader()\n      else:\n        v_val = self.readFieldByTType(val_ttype, val_spec)\n      # this raises a TypeError with unhashable keys types\n      # i.e. this fails: d=dict(); d[[0,1]] = 2\n      results[k_val] = v_val\n    self.readMapEnd()\n    return results\n\n  def readStruct(self, obj, thrift_spec):\n    self.readStructBegin()\n    while True:\n      (fname, ftype, fid) = self.readFieldBegin()\n      if ftype == TType.STOP:\n        break\n      try:\n        field = thrift_spec[fid]\n      except IndexError:\n        self.skip(ftype)\n      else:\n        if field is not None and ftype == field[1]:\n          fname = field[2]\n          fspec = field[3]\n          val = self.readFieldByTType(ftype, fspec)\n          setattr(obj, fname, val)\n        else:\n          self.skip(ftype)\n      self.readFieldEnd()\n    self.readStructEnd()\n\n  def writeContainerStruct(self, val, spec):\n    val.write(self)\n\n  def writeContainerList(self, val, spec):\n    self.writeListBegin(spec[0], len(val))\n    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[spec[0]]\n    e_writer = getattr(self, w_handler)\n    if not is_container:\n      for elem in val:\n        e_writer(elem)\n    else:\n      for elem in val:\n        e_writer(elem, spec[1])\n    self.writeListEnd()\n\n  def writeContainerSet(self, val, spec):\n    self.writeSetBegin(spec[0], len(val))\n    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[spec[0]]\n    e_writer = getattr(self, w_handler)\n    if not is_container:\n      for elem in val:\n        e_writer(elem)\n    else:\n      for elem in val:\n        e_writer(elem, spec[1])\n    self.writeSetEnd()\n\n  def writeContainerMap(self, val, spec):\n    k_type = spec[0]\n    v_type = spec[2]\n    ignore, ktype_name, k_is_container = self._TTYPE_HANDLERS[k_type]\n    ignore, vtype_name, v_is_container = self._TTYPE_HANDLERS[v_type]\n    k_writer = getattr(self, ktype_name)\n    v_writer = getattr(self, vtype_name)\n    self.writeMapBegin(k_type, v_type, len(val))\n    for m_key, m_val in val.items():\n      if not k_is_container:\n        k_writer(m_key)\n      else:\n        k_writer(m_key, spec[1])\n      if not v_is_container:\n        v_writer(m_val)\n      else:\n        v_writer(m_val, spec[3])\n    self.writeMapEnd()\n\n  def writeStruct(self, obj, thrift_spec):\n    self.writeStructBegin(obj.__class__.__name__)\n    for field in thrift_spec:\n      if field is None:\n        continue\n      fname = field[2]\n      val = getattr(obj, fname)\n      if val is None:\n        # skip writing out unset fields\n        continue\n      fid = field[0]\n      ftype = field[1]\n      fspec = field[3]\n      # get the writer method for this value\n      self.writeFieldBegin(fname, ftype, fid)\n      self.writeFieldByTType(ftype, val, fspec)\n      self.writeFieldEnd()\n    self.writeFieldStop()\n    self.writeStructEnd()\n\n  def writeFieldByTType(self, ttype, val, spec):\n    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[ttype]\n    writer = getattr(self, w_handler)\n    if is_container:\n      writer(val, spec)\n    else:\n      writer(val)\n\n\nclass TProtocolFactory:\n  def getProtocol(self, trans):\n    pass\n'"
thrift/protocol/__init__.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n__all__ = [\'TProtocol\', \'TBinaryProtocol\', \'fastbinary\', \'TBase\']\n'"
thrift/server/THttpServer.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport http.server\n\nfrom thrift.server import TServer\nfrom thrift.transport import TTransport\n\n\nclass ResponseException(Exception):\n  """"""Allows handlers to override the HTTP response\n\n  Normally, THttpServer always sends a 200 response.  If a handler wants\n  to override this behavior (e.g., to simulate a misconfigured or\n  overloaded web server during testing), it can raise a ResponseException.\n  The function passed to the constructor will be called with the\n  RequestHandler as its only argument.\n  """"""\n  def __init__(self, handler):\n    self.handler = handler\n\n\nclass THttpServer(TServer.TServer):\n  """"""A simple HTTP-based Thrift server\n\n  This class is not very performant, but it is useful (for example) for\n  acting as a mock version of an Apache-based PHP Thrift endpoint.\n  """"""\n  def __init__(self,\n               processor,\n               server_address,\n               inputProtocolFactory,\n               outputProtocolFactory=None,\n               server_class=http.server.HTTPServer):\n    """"""Set up protocol factories and HTTP server.\n\n    See BaseHTTPServer for server_address.\n    See TServer for protocol factories.\n    """"""\n    if outputProtocolFactory is None:\n      outputProtocolFactory = inputProtocolFactory\n\n    TServer.TServer.__init__(self, processor, None, None, None,\n        inputProtocolFactory, outputProtocolFactory)\n\n    thttpserver = self\n\n    class RequestHander(http.server.BaseHTTPRequestHandler):\n      def do_POST(self):\n        # Don\'t care about the request path.\n        itrans = TTransport.TFileObjectTransport(self.rfile)\n        otrans = TTransport.TFileObjectTransport(self.wfile)\n        itrans = TTransport.TBufferedTransport(\n          itrans, int(self.headers[\'Content-Length\']))\n        otrans = TTransport.TMemoryBuffer()\n        iprot = thttpserver.inputProtocolFactory.getProtocol(itrans)\n        oprot = thttpserver.outputProtocolFactory.getProtocol(otrans)\n        try:\n          thttpserver.processor.process(iprot, oprot)\n        except ResponseException as exn:\n          exn.handler(self)\n        else:\n          self.send_response(200)\n          self.send_header(""content-type"", ""application/x-thrift"")\n          self.end_headers()\n          self.wfile.write(otrans.getvalue())\n\n    self.httpd = server_class(server_address, RequestHander)\n\n  def serve(self):\n    self.httpd.serve_forever()\n'"
thrift/server/TNonblockingServer.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n""""""Implementation of non-blocking server.\n\nThe main idea of the server is to receive and send requests\nonly from the main thread.\n\nThe thread poool should be sized for concurrent tasks, not\nmaximum connections\n""""""\nimport threading\nimport socket\nimport queue\nimport select\nimport struct\nimport logging\n\nfrom thrift.transport import TTransport\nfrom thrift.protocol.TBinaryProtocol import TBinaryProtocolFactory\n\n__all__ = [\'TNonblockingServer\']\n\n\nclass Worker(threading.Thread):\n    """"""Worker is a small helper to process incoming connection.""""""\n\n    def __init__(self, queue):\n        threading.Thread.__init__(self)\n        self.queue = queue\n\n    def run(self):\n        """"""Process queries from task queue, stop if processor is None.""""""\n        while True:\n            try:\n                processor, iprot, oprot, otrans, callback = self.queue.get()\n                if processor is None:\n                    break\n                processor.process(iprot, oprot)\n                callback(True, otrans.getvalue())\n            except Exception:\n                logging.exception(""Exception while processing request"")\n                callback(False, \'\')\n\nWAIT_LEN = 0\nWAIT_MESSAGE = 1\nWAIT_PROCESS = 2\nSEND_ANSWER = 3\nCLOSED = 4\n\n\ndef locked(func):\n    """"""Decorator which locks self.lock.""""""\n    def nested(self, *args, **kwargs):\n        self.lock.acquire()\n        try:\n            return func(self, *args, **kwargs)\n        finally:\n            self.lock.release()\n    return nested\n\n\ndef socket_exception(func):\n    """"""Decorator close object on socket.error.""""""\n    def read(self, *args, **kwargs):\n        try:\n            return func(self, *args, **kwargs)\n        except socket.error:\n            self.close()\n    return read\n\n\nclass Connection:\n    """"""Basic class is represented connection.\n\n    It can be in state:\n        WAIT_LEN --- connection is reading request len.\n        WAIT_MESSAGE --- connection is reading request.\n        WAIT_PROCESS --- connection has just read whole request and\n                         waits for call ready routine.\n        SEND_ANSWER --- connection is sending answer string (including length\n                        of answer).\n        CLOSED --- socket was closed and connection should be deleted.\n    """"""\n    def __init__(self, new_socket, wake_up):\n        self.socket = new_socket\n        self.socket.setblocking(False)\n        self.status = WAIT_LEN\n        self.len = 0\n        self.message = \'\'\n        self.lock = threading.Lock()\n        self.wake_up = wake_up\n\n    def _read_len(self):\n        """"""Reads length of request.\n\n        It\'s a safer alternative to self.socket.recv(4)\n        """"""\n        read = self.socket.recv(4 - len(self.message))\n        if len(read) == 0:\n            # if we read 0 bytes and self.message is empty, then\n            # the client closed the connection\n            if len(self.message) != 0:\n                logging.error(""can\'t read frame size from socket"")\n            self.close()\n            return\n        self.message += read\n        if len(self.message) == 4:\n            self.len, = struct.unpack(\'!i\', self.message)\n            if self.len < 0:\n                logging.error(""negative frame size, it seems client ""\n                              ""doesn\'t use FramedTransport"")\n                self.close()\n            elif self.len == 0:\n                logging.error(""empty frame, it\'s really strange"")\n                self.close()\n            else:\n                self.message = \'\'\n                self.status = WAIT_MESSAGE\n\n    @socket_exception\n    def read(self):\n        """"""Reads data from stream and switch state.""""""\n        assert self.status in (WAIT_LEN, WAIT_MESSAGE)\n        if self.status == WAIT_LEN:\n            self._read_len()\n            # go back to the main loop here for simplicity instead of\n            # falling through, even though there is a good chance that\n            # the message is already available\n        elif self.status == WAIT_MESSAGE:\n            read = self.socket.recv(self.len - len(self.message))\n            if len(read) == 0:\n                logging.error(""can\'t read frame from socket (get %d of ""\n                              ""%d bytes)"" % (len(self.message), self.len))\n                self.close()\n                return\n            self.message += read\n            if len(self.message) == self.len:\n                self.status = WAIT_PROCESS\n\n    @socket_exception\n    def write(self):\n        """"""Writes data from socket and switch state.""""""\n        assert self.status == SEND_ANSWER\n        sent = self.socket.send(self.message)\n        if sent == len(self.message):\n            self.status = WAIT_LEN\n            self.message = \'\'\n            self.len = 0\n        else:\n            self.message = self.message[sent:]\n\n    @locked\n    def ready(self, all_ok, message):\n        """"""Callback function for switching state and waking up main thread.\n\n        This function is the only function witch can be called asynchronous.\n\n        The ready can switch Connection to three states:\n            WAIT_LEN if request was oneway.\n            SEND_ANSWER if request was processed in normal way.\n            CLOSED if request throws unexpected exception.\n\n        The one wakes up main thread.\n        """"""\n        assert self.status == WAIT_PROCESS\n        if not all_ok:\n            self.close()\n            self.wake_up()\n            return\n        self.len = \'\'\n        if len(message) == 0:\n            # it was a oneway request, do not write answer\n            self.message = \'\'\n            self.status = WAIT_LEN\n        else:\n            self.message = struct.pack(\'!i\', len(message)) + message\n            self.status = SEND_ANSWER\n        self.wake_up()\n\n    @locked\n    def is_writeable(self):\n        """"""Return True if connection should be added to write list of select""""""\n        return self.status == SEND_ANSWER\n\n    # it\'s not necessary, but...\n    @locked\n    def is_readable(self):\n        """"""Return True if connection should be added to read list of select""""""\n        return self.status in (WAIT_LEN, WAIT_MESSAGE)\n\n    @locked\n    def is_closed(self):\n        """"""Returns True if connection is closed.""""""\n        return self.status == CLOSED\n\n    def fileno(self):\n        """"""Returns the file descriptor of the associated socket.""""""\n        return self.socket.fileno()\n\n    def close(self):\n        """"""Closes connection""""""\n        self.status = CLOSED\n        self.socket.close()\n\n\nclass TNonblockingServer:\n    """"""Non-blocking server.""""""\n\n    def __init__(self,\n                 processor,\n                 lsocket,\n                 inputProtocolFactory=None,\n                 outputProtocolFactory=None,\n                 threads=10):\n        self.processor = processor\n        self.socket = lsocket\n        self.in_protocol = inputProtocolFactory or TBinaryProtocolFactory()\n        self.out_protocol = outputProtocolFactory or self.in_protocol\n        self.threads = int(threads)\n        self.clients = {}\n        self.tasks = queue.Queue()\n        self._read, self._write = socket.socketpair()\n        self.prepared = False\n        self._stop = False\n\n    def setNumThreads(self, num):\n        """"""Set the number of worker threads that should be created.""""""\n        # implement ThreadPool interface\n        assert not self.prepared, ""Can\'t change number of threads after start""\n        self.threads = num\n\n    def prepare(self):\n        """"""Prepares server for serve requests.""""""\n        if self.prepared:\n            return\n        self.socket.listen()\n        for _ in range(self.threads):\n            thread = Worker(self.tasks)\n            thread.setDaemon(True)\n            thread.start()\n        self.prepared = True\n\n    def wake_up(self):\n        """"""Wake up main thread.\n\n        The server usualy waits in select call in we should terminate one.\n        The simplest way is using socketpair.\n\n        Select always wait to read from the first socket of socketpair.\n\n        In this case, we can just write anything to the second socket from\n        socketpair.\n        """"""\n        self._write.send(\'1\')\n\n    def stop(self):\n        """"""Stop the server.\n\n        This method causes the serve() method to return.  stop() may be invoked\n        from within your handler, or from another thread.\n\n        After stop() is called, serve() will return but the server will still\n        be listening on the socket.  serve() may then be called again to resume\n        processing requests.  Alternatively, close() may be called after\n        serve() returns to close the server socket and shutdown all worker\n        threads.\n        """"""\n        self._stop = True\n        self.wake_up()\n\n    def _select(self):\n        """"""Does select on open connections.""""""\n        readable = [self.socket.handle.fileno(), self._read.fileno()]\n        writable = []\n        for i, connection in list(self.clients.items()):\n            if connection.is_readable():\n                readable.append(connection.fileno())\n            if connection.is_writeable():\n                writable.append(connection.fileno())\n            if connection.is_closed():\n                del self.clients[i]\n        return select.select(readable, writable, readable)\n\n    def handle(self):\n        """"""Handle requests.\n\n        WARNING! You must call prepare() BEFORE calling handle()\n        """"""\n        assert self.prepared, ""You have to call prepare before handle""\n        rset, wset, xset = self._select()\n        for readable in rset:\n            if readable == self._read.fileno():\n                # don\'t care i just need to clean readable flag\n                self._read.recv(1024)\n            elif readable == self.socket.handle.fileno():\n                client = self.socket.accept().handle\n                self.clients[client.fileno()] = Connection(client,\n                                                           self.wake_up)\n            else:\n                connection = self.clients[readable]\n                connection.read()\n                if connection.status == WAIT_PROCESS:\n                    itransport = TTransport.TMemoryBuffer(connection.message)\n                    otransport = TTransport.TMemoryBuffer()\n                    iprot = self.in_protocol.getProtocol(itransport)\n                    oprot = self.out_protocol.getProtocol(otransport)\n                    self.tasks.put([self.processor, iprot, oprot,\n                                    otransport, connection.ready])\n        for writeable in wset:\n            self.clients[writeable].write()\n        for oob in xset:\n            self.clients[oob].close()\n            del self.clients[oob]\n\n    def close(self):\n        """"""Closes the server.""""""\n        for _ in range(self.threads):\n            self.tasks.put([None, None, None, None, None])\n        self.socket.close()\n        self.prepared = False\n\n    def serve(self):\n        """"""Serve requests.\n\n        Serve requests forever, or until stop() is called.\n        """"""\n        self._stop = False\n        self.prepare()\n        while not self._stop:\n            self.handle()\n'"
thrift/server/TProcessPoolServer.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n\nimport logging\nfrom multiprocessing import  Process, Value, Condition, reduction\n\nfrom .TServer import TServer\nfrom thrift.transport.TTransport import TTransportException\nimport collections\n\n\nclass TProcessPoolServer(TServer):\n    """"""Server with a fixed size pool of worker subprocesses to service requests\n\n    Note that if you need shared state between the handlers - it\'s up to you!\n    Written by Dvir Volk, doat.com\n    """"""\n    def __init__(self, *args):\n        TServer.__init__(self, *args)\n        self.numWorkers = 10\n        self.workers = []\n        self.isRunning = Value(\'b\', False)\n        self.stopCondition = Condition()\n        self.postForkCallback = None\n\n    def setPostForkCallback(self, callback):\n        if not isinstance(callback, collections.Callable):\n            raise TypeError(""This is not a callback!"")\n        self.postForkCallback = callback\n\n    def setNumWorkers(self, num):\n        """"""Set the number of worker threads that should be created""""""\n        self.numWorkers = num\n\n    def workerProcess(self):\n        """"""Loop getting clients from the shared queue and process them""""""\n        if self.postForkCallback:\n            self.postForkCallback()\n\n        while self.isRunning.value:\n            try:\n                client = self.serverTransport.accept()\n                self.serveClient(client)\n            except (KeyboardInterrupt, SystemExit):\n                return 0\n            except Exception as x:\n                logging.exception(x)\n\n    def serveClient(self, client):\n        """"""Process input/output from a client for as long as possible""""""\n        itrans = self.inputTransportFactory.getTransport(client)\n        otrans = self.outputTransportFactory.getTransport(client)\n        iprot = self.inputProtocolFactory.getProtocol(itrans)\n        oprot = self.outputProtocolFactory.getProtocol(otrans)\n\n        try:\n            while True:\n                self.processor.process(iprot, oprot)\n        except TTransportException as tx:\n            pass\n        except Exception as x:\n            logging.exception(x)\n\n        itrans.close()\n        otrans.close()\n\n    def serve(self):\n        """"""Start workers and put into queue""""""\n        # this is a shared state that can tell the workers to exit when False\n        self.isRunning.value = True\n\n        # first bind and listen to the port\n        self.serverTransport.listen()\n\n        # fork the children\n        for i in range(self.numWorkers):\n            try:\n                w = Process(target=self.workerProcess)\n                w.daemon = True\n                w.start()\n                self.workers.append(w)\n            except Exception as x:\n                logging.exception(x)\n\n        # wait until the condition is set by stop()\n        while True:\n            self.stopCondition.acquire()\n            try:\n                self.stopCondition.wait()\n                break\n            except (SystemExit, KeyboardInterrupt):\n                break\n            except Exception as x:\n                logging.exception(x)\n\n        self.isRunning.value = False\n\n    def stop(self):\n        self.isRunning.value = False\n        self.stopCondition.acquire()\n        self.stopCondition.notify()\n        self.stopCondition.release()\n'"
thrift/server/TServer.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport queue\nimport logging\nimport os\nimport sys\nimport threading\nimport traceback\n\nfrom thrift.Thrift import TProcessor\nfrom thrift.protocol import TBinaryProtocol\nfrom thrift.transport import TTransport\n\n\nclass TServer:\n  """"""Base interface for a server, which must have a serve() method.\n\n  Three constructors for all servers:\n  1) (processor, serverTransport)\n  2) (processor, serverTransport, transportFactory, protocolFactory)\n  3) (processor, serverTransport,\n      inputTransportFactory, outputTransportFactory,\n      inputProtocolFactory, outputProtocolFactory)\n  """"""\n  def __init__(self, *args):\n    if (len(args) == 2):\n      self.__initArgs__(args[0], args[1],\n                        TTransport.TTransportFactoryBase(),\n                        TTransport.TTransportFactoryBase(),\n                        TBinaryProtocol.TBinaryProtocolFactory(),\n                        TBinaryProtocol.TBinaryProtocolFactory())\n    elif (len(args) == 4):\n      self.__initArgs__(args[0], args[1], args[2], args[2], args[3], args[3])\n    elif (len(args) == 6):\n      self.__initArgs__(args[0], args[1], args[2], args[3], args[4], args[5])\n\n  def __initArgs__(self, processor, serverTransport,\n                   inputTransportFactory, outputTransportFactory,\n                   inputProtocolFactory, outputProtocolFactory):\n    self.processor = processor\n    self.serverTransport = serverTransport\n    self.inputTransportFactory = inputTransportFactory\n    self.outputTransportFactory = outputTransportFactory\n    self.inputProtocolFactory = inputProtocolFactory\n    self.outputProtocolFactory = outputProtocolFactory\n\n  def serve(self):\n    pass\n\n\nclass TSimpleServer(TServer):\n  """"""Simple single-threaded server that just pumps around one transport.""""""\n\n  def __init__(self, *args):\n    TServer.__init__(self, *args)\n\n  def serve(self):\n    self.serverTransport.listen()\n    while True:\n      client = self.serverTransport.accept()\n      itrans = self.inputTransportFactory.getTransport(client)\n      otrans = self.outputTransportFactory.getTransport(client)\n      iprot = self.inputProtocolFactory.getProtocol(itrans)\n      oprot = self.outputProtocolFactory.getProtocol(otrans)\n      try:\n        while True:\n          self.processor.process(iprot, oprot)\n      except TTransport.TTransportException as tx:\n        pass\n      except Exception as x:\n        logging.exception(x)\n\n      itrans.close()\n      otrans.close()\n\n\nclass TThreadedServer(TServer):\n  """"""Threaded server that spawns a new thread per each connection.""""""\n\n  def __init__(self, *args, **kwargs):\n    TServer.__init__(self, *args)\n    self.daemon = kwargs.get(""daemon"", False)\n\n  def serve(self):\n    self.serverTransport.listen()\n    while True:\n      try:\n        client = self.serverTransport.accept()\n        t = threading.Thread(target=self.handle, args=(client,))\n        t.setDaemon(self.daemon)\n        t.start()\n      except KeyboardInterrupt:\n        raise\n      except Exception as x:\n        logging.exception(x)\n\n  def handle(self, client):\n    itrans = self.inputTransportFactory.getTransport(client)\n    otrans = self.outputTransportFactory.getTransport(client)\n    iprot = self.inputProtocolFactory.getProtocol(itrans)\n    oprot = self.outputProtocolFactory.getProtocol(otrans)\n    try:\n      while True:\n        self.processor.process(iprot, oprot)\n    except TTransport.TTransportException as tx:\n      pass\n    except Exception as x:\n      logging.exception(x)\n\n    itrans.close()\n    otrans.close()\n\n\nclass TThreadPoolServer(TServer):\n  """"""Server with a fixed size pool of threads which service requests.""""""\n\n  def __init__(self, *args, **kwargs):\n    TServer.__init__(self, *args)\n    self.clients = queue.Queue()\n    self.threads = 10\n    self.daemon = kwargs.get(""daemon"", False)\n\n  def setNumThreads(self, num):\n    """"""Set the number of worker threads that should be created""""""\n    self.threads = num\n\n  def serveThread(self):\n    """"""Loop around getting clients from the shared queue and process them.""""""\n    while True:\n      try:\n        client = self.clients.get()\n        self.serveClient(client)\n      except Exception as x:\n        logging.exception(x)\n\n  def serveClient(self, client):\n    """"""Process input/output from a client for as long as possible""""""\n    itrans = self.inputTransportFactory.getTransport(client)\n    otrans = self.outputTransportFactory.getTransport(client)\n    iprot = self.inputProtocolFactory.getProtocol(itrans)\n    oprot = self.outputProtocolFactory.getProtocol(otrans)\n    try:\n      while True:\n        self.processor.process(iprot, oprot)\n    except TTransport.TTransportException as tx:\n      pass\n    except Exception as x:\n      logging.exception(x)\n\n    itrans.close()\n    otrans.close()\n\n  def serve(self):\n    """"""Start a fixed number of worker threads and put client into a queue""""""\n    for i in range(self.threads):\n      try:\n        t = threading.Thread(target=self.serveThread)\n        t.setDaemon(self.daemon)\n        t.start()\n      except Exception as x:\n        logging.exception(x)\n\n    # Pump the socket for clients\n    self.serverTransport.listen()\n    while True:\n      try:\n        client = self.serverTransport.accept()\n        self.clients.put(client)\n      except Exception as x:\n        logging.exception(x)\n\n\nclass TForkingServer(TServer):\n  """"""A Thrift server that forks a new process for each request\n\n  This is more scalable than the threaded server as it does not cause\n  GIL contention.\n\n  Note that this has different semantics from the threading server.\n  Specifically, updates to shared variables will no longer be shared.\n  It will also not work on windows.\n\n  This code is heavily inspired by SocketServer.ForkingMixIn in the\n  Python stdlib.\n  """"""\n  def __init__(self, *args):\n    TServer.__init__(self, *args)\n    self.children = []\n\n  def serve(self):\n    def try_close(file):\n      try:\n        file.close()\n      except IOError as e:\n        logging.warning(e, exc_info=True)\n\n    self.serverTransport.listen()\n    while True:\n      client = self.serverTransport.accept()\n      try:\n        pid = os.fork()\n\n        if pid:  # parent\n          # add before collect, otherwise you race w/ waitpid\n          self.children.append(pid)\n          self.collect_children()\n\n          # Parent must close socket or the connection may not get\n          # closed promptly\n          itrans = self.inputTransportFactory.getTransport(client)\n          otrans = self.outputTransportFactory.getTransport(client)\n          try_close(itrans)\n          try_close(otrans)\n        else:\n          itrans = self.inputTransportFactory.getTransport(client)\n          otrans = self.outputTransportFactory.getTransport(client)\n\n          iprot = self.inputProtocolFactory.getProtocol(itrans)\n          oprot = self.outputProtocolFactory.getProtocol(otrans)\n\n          ecode = 0\n          try:\n            try:\n              while True:\n                self.processor.process(iprot, oprot)\n            except TTransport.TTransportException as tx:\n              pass\n            except Exception as e:\n              logging.exception(e)\n              ecode = 1\n          finally:\n            try_close(itrans)\n            try_close(otrans)\n\n          os._exit(ecode)\n\n      except TTransport.TTransportException as tx:\n        pass\n      except Exception as x:\n        logging.exception(x)\n\n  def collect_children(self):\n    while self.children:\n      try:\n        pid, status = os.waitpid(0, os.WNOHANG)\n      except os.error:\n        pid = None\n\n      if pid:\n        self.children.remove(pid)\n      else:\n        break\n'"
thrift/server/__init__.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n__all__ = [\'TServer\', \'TNonblockingServer\']\n'"
thrift/transport/THttpClient.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport http.client\nimport os\nimport socket\nimport sys\nimport urllib.request, urllib.parse, urllib.error\nimport urllib.parse\nimport warnings\n\nfrom io import StringIO\n\nfrom .TTransport import *\n\n\nclass THttpClient(TTransportBase):\n  """"""Http implementation of TTransport base.""""""\n\n  def __init__(self, uri_or_host, port=None, path=None):\n    """"""THttpClient supports two different types constructor parameters.\n\n    THttpClient(host, port, path) - deprecated\n    THttpClient(uri)\n\n    Only the second supports https.\n    """"""\n    if port is not None:\n      warnings.warn(\n        ""Please use the THttpClient(\'http://host:port/path\') syntax"",\n        DeprecationWarning,\n        stacklevel=2)\n      self.host = uri_or_host\n      self.port = port\n      assert path\n      self.path = path\n      self.scheme = \'http\'\n    else:\n      parsed = urllib.parse.urlparse(uri_or_host)\n      self.scheme = parsed.scheme\n      assert self.scheme in (\'http\', \'https\')\n      if self.scheme == \'http\':\n        self.port = parsed.port or http.client.HTTP_PORT\n      elif self.scheme == \'https\':\n        self.port = parsed.port or http.client.HTTPS_PORT\n      self.host = parsed.hostname\n      self.path = parsed.path\n      if parsed.query:\n        self.path += \'?%s\' % parsed.query\n    self.__wbuf = StringIO()\n    self.__http = None\n    self.__timeout = None\n    self.__custom_headers = None\n\n  def open(self):\n    if self.scheme == \'http\':\n      self.__http = http.client.HTTP(self.host, self.port)\n    else:\n      self.__http = http.client.HTTPS(self.host, self.port)\n\n  def close(self):\n    self.__http.close()\n    self.__http = None\n\n  def isOpen(self):\n    return self.__http is not None\n\n  def setTimeout(self, ms):\n    if not hasattr(socket, \'getdefaulttimeout\'):\n      raise NotImplementedError\n\n    if ms is None:\n      self.__timeout = None\n    else:\n      self.__timeout = ms / 1000.0\n\n  def setCustomHeaders(self, headers):\n    self.__custom_headers = headers\n\n  def read(self, sz):\n    return self.__http.file.read(sz)\n\n  def write(self, buf):\n    self.__wbuf.write(buf)\n\n  def __withTimeout(f):\n    def _f(*args, **kwargs):\n      orig_timeout = socket.getdefaulttimeout()\n      socket.setdefaulttimeout(args[0].__timeout)\n      result = f(*args, **kwargs)\n      socket.setdefaulttimeout(orig_timeout)\n      return result\n    return _f\n\n  def flush(self):\n    if self.isOpen():\n      self.close()\n    self.open()\n\n    # Pull data out of buffer\n    data = self.__wbuf.getvalue()\n    self.__wbuf = StringIO()\n\n    # HTTP request\n    self.__http.putrequest(\'POST\', self.path)\n\n    # Write headers\n    self.__http.putheader(\'Host\', self.host)\n    self.__http.putheader(\'Content-Type\', \'application/x-thrift\')\n    self.__http.putheader(\'Content-Length\', str(len(data)))\n\n    if not self.__custom_headers or \'User-Agent\' not in self.__custom_headers:\n      user_agent = \'Python/THttpClient\'\n      script = os.path.basename(sys.argv[0])\n      if script:\n        user_agent = \'%s (%s)\' % (user_agent, urllib.parse.quote(script))\n      self.__http.putheader(\'User-Agent\', user_agent)\n\n    if self.__custom_headers:\n        for key, val in self.__custom_headers.items():\n            self.__http.putheader(key, val)\n\n    self.__http.endheaders()\n\n    # Write payload\n    self.__http.send(data)\n\n    # Get reply to flush the request\n    self.code, self.message, self.headers = self.__http.getreply()\n\n  # Decorate if we know how to timeout\n  if hasattr(socket, \'getdefaulttimeout\'):\n    flush = __withTimeout(flush)\n'"
thrift/transport/TSSLSocket.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport os\nimport socket\nimport ssl\n\nfrom thrift.transport import TSocket\nfrom thrift.transport.TTransport import TTransportException\n\n\nclass TSSLSocket(TSocket.TSocket):\n  """"""\n  SSL implementation of client-side TSocket\n\n  This class creates outbound sockets wrapped using the\n  python standard ssl module for encrypted connections.\n\n  The protocol used is set using the class variable\n  SSL_VERSION, which must be one of ssl.PROTOCOL_* and\n  defaults to  ssl.PROTOCOL_TLSv1 for greatest security.\n  """"""\n  SSL_VERSION = ssl.PROTOCOL_TLSv1\n\n  def __init__(self,\n               host=\'localhost\',\n               port=9090,\n               validate=True,\n               ca_certs=None,\n               unix_socket=None):\n    """"""Create SSL TSocket\n\n    @param validate: Set to False to disable SSL certificate validation\n    @type validate: bool\n    @param ca_certs: Filename to the Certificate Authority pem file, possibly a\n    file downloaded from: http://curl.haxx.se/ca/cacert.pem  This is passed to\n    the ssl_wrap function as the \'ca_certs\' parameter.\n    @type ca_certs: str\n\n    Raises an IOError exception if validate is True and the ca_certs file is\n    None, not present or unreadable.\n    """"""\n    self.validate = validate\n    self.is_valid = False\n    self.peercert = None\n    if not validate:\n      self.cert_reqs = ssl.CERT_NONE\n    else:\n      self.cert_reqs = ssl.CERT_REQUIRED\n    self.ca_certs = ca_certs\n    if validate:\n      if ca_certs is None or not os.access(ca_certs, os.R_OK):\n        raise IOError(\'Certificate Authority ca_certs file ""%s"" \'\n                      \'is not readable, cannot validate SSL \'\n                      \'certificates.\' % (ca_certs))\n    TSocket.TSocket.__init__(self, host, port, unix_socket)\n\n  def open(self):\n    try:\n      res0 = self._resolveAddr()\n      for res in res0:\n        sock_family, sock_type = res[0:2]\n        ip_port = res[4]\n        plain_sock = socket.socket(sock_family, sock_type)\n        self.handle = ssl.wrap_socket(plain_sock,\n                                      ssl_version=self.SSL_VERSION,\n                                      do_handshake_on_connect=True,\n                                      ca_certs=self.ca_certs,\n                                      cert_reqs=self.cert_reqs)\n        self.handle.settimeout(self._timeout)\n        try:\n          self.handle.connect(ip_port)\n        except socket.error as e:\n          if res is not res0[-1]:\n            continue\n          else:\n            raise e\n        break\n    except socket.error as e:\n      if self._unix_socket:\n        message = \'Could not connect to secure socket %s\' % self._unix_socket\n      else:\n        message = \'Could not connect to %s:%d\' % (self.host, self.port)\n      raise TTransportException(type=TTransportException.NOT_OPEN,\n                                message=message)\n    if self.validate:\n      self._validate_cert()\n\n  def _validate_cert(self):\n    """"""internal method to validate the peer\'s SSL certificate, and to check the\n    commonName of the certificate to ensure it matches the hostname we\n    used to make this connection.  Does not support subjectAltName records\n    in certificates.\n\n    raises TTransportException if the certificate fails validation.\n    """"""\n    cert = self.handle.getpeercert()\n    self.peercert = cert\n    if \'subject\' not in cert:\n      raise TTransportException(\n        type=TTransportException.NOT_OPEN,\n        message=\'No SSL certificate found from %s:%s\' % (self.host, self.port))\n    fields = cert[\'subject\']\n    for field in fields:\n      # ensure structure we get back is what we expect\n      if not isinstance(field, tuple):\n        continue\n      cert_pair = field[0]\n      if len(cert_pair) < 2:\n        continue\n      cert_key, cert_value = cert_pair[0:2]\n      if cert_key != \'commonName\':\n        continue\n      certhost = cert_value\n      if certhost == self.host:\n        # success, cert commonName matches desired hostname\n        self.is_valid = True\n        return\n      else:\n        raise TTransportException(\n          type=TTransportException.UNKNOWN,\n          message=\'Hostname we connected to ""%s"" doesn\\\'t match certificate \'\n                  \'provided commonName ""%s""\' % (self.host, certhost))\n    raise TTransportException(\n      type=TTransportException.UNKNOWN,\n      message=\'Could not validate SSL certificate from \'\n              \'host ""%s"".  Cert=%s\' % (self.host, cert))\n\n\nclass TSSLServerSocket(TSocket.TServerSocket):\n  """"""SSL implementation of TServerSocket\n\n  This uses the ssl module\'s wrap_socket() method to provide SSL\n  negotiated encryption.\n  """"""\n  SSL_VERSION = ssl.PROTOCOL_TLSv1\n\n  def __init__(self,\n               host=None,\n               port=9090,\n               certfile=\'cert.pem\',\n               unix_socket=None):\n    """"""Initialize a TSSLServerSocket\n\n    @param certfile: filename of the server certificate, defaults to cert.pem\n    @type certfile: str\n    @param host: The hostname or IP to bind the listen socket to,\n                 i.e. \'localhost\' for only allowing local network connections.\n                 Pass None to bind to all interfaces.\n    @type host: str\n    @param port: The port to listen on for inbound connections.\n    @type port: int\n    """"""\n    self.setCertfile(certfile)\n    TSocket.TServerSocket.__init__(self, host, port)\n\n  def setCertfile(self, certfile):\n    """"""Set or change the server certificate file used to wrap new connections.\n\n    @param certfile: The filename of the server certificate,\n                     i.e. \'/etc/certs/server.pem\'\n    @type certfile: str\n\n    Raises an IOError exception if the certfile is not present or unreadable.\n    """"""\n    if not os.access(certfile, os.R_OK):\n      raise IOError(\'No such certfile found: %s\' % (certfile))\n    self.certfile = certfile\n\n  def accept(self):\n    plain_client, addr = self.handle.accept()\n    try:\n      client = ssl.wrap_socket(plain_client, certfile=self.certfile,\n                      server_side=True, ssl_version=self.SSL_VERSION)\n    except ssl.SSLError as ssl_exc:\n      # failed handshake/ssl wrap, close socket to client\n      plain_client.close()\n      # raise ssl_exc\n      # We can\'t raise the exception, because it kills most TServer derived\n      # serve() methods.\n      # Instead, return None, and let the TServer instance deal with it in\n      # other exception handling.  (but TSimpleServer dies anyway)\n      return None\n    result = TSocket.TSocket()\n    result.setHandle(client)\n    return result\n'"
thrift/transport/TSocket.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nimport errno\nimport os\nimport socket\nimport sys\n\nfrom .TTransport import *\n\n\nclass TSocketBase(TTransportBase):\n  def _resolveAddr(self):\n    if self._unix_socket is not None:\n      return [(socket.AF_UNIX, socket.SOCK_STREAM, None, None,\n               self._unix_socket)]\n    else:\n      return socket.getaddrinfo(self.host,\n                                self.port,\n                                socket.AF_UNSPEC,\n                                socket.SOCK_STREAM,\n                                0,\n                                socket.AI_PASSIVE | socket.AI_ADDRCONFIG)\n\n  def close(self):\n    if self.handle:\n      self.handle.close()\n      self.handle = None\n\n\nclass TSocket(TSocketBase):\n  """"""Socket implementation of TTransport base.""""""\n\n  def __init__(self, host=\'localhost\', port=9090, unix_socket=None):\n    """"""Initialize a TSocket\n\n    @param host(str)  The host to connect to.\n    @param port(int)  The (TCP) port to connect to.\n    @param unix_socket(str)  The filename of a unix socket to connect to.\n                             (host and port will be ignored.)\n    """"""\n    self.host = host\n    self.port = port\n    self.handle = None\n    self._unix_socket = unix_socket\n    self._timeout = None\n\n  def setHandle(self, h):\n    self.handle = h\n\n  def isOpen(self):\n    return self.handle is not None\n\n  def setTimeout(self, ms):\n    if ms is None:\n      self._timeout = None\n    else:\n      self._timeout = ms / 1000.0\n\n    if self.handle is not None:\n      self.handle.settimeout(self._timeout)\n\n  def open(self):\n    try:\n      res0 = self._resolveAddr()\n      for res in res0:\n        self.handle = socket.socket(res[0], res[1])\n        self.handle.settimeout(self._timeout)\n        try:\n          self.handle.connect(res[4])\n        except socket.error as e:\n          if res is not res0[-1]:\n            continue\n          else:\n            raise e\n        break\n    except socket.error as e:\n      if self._unix_socket:\n        message = \'Could not connect to socket %s\' % self._unix_socket\n      else:\n        message = \'Could not connect to %s:%d\' % (self.host, self.port)\n      raise TTransportException(type=TTransportException.NOT_OPEN,\n                                message=message)\n\n  def read(self, sz):\n    try:\n      buff = self.handle.recv(sz)\n    except socket.error as e:\n      if (e.args[0] == errno.ECONNRESET and\n          (sys.platform == \'darwin\' or sys.platform.startswith(\'freebsd\'))):\n        # freebsd and Mach don\'t follow POSIX semantic of recv\n        # and fail with ECONNRESET if peer performed shutdown.\n        # See corresponding comment and code in TSocket::read()\n        # in lib/cpp/src/transport/TSocket.cpp.\n        self.close()\n        # Trigger the check to raise the END_OF_FILE exception below.\n        buff = \'\'\n      else:\n        raise\n    if len(buff) == 0:\n      raise TTransportException(type=TTransportException.END_OF_FILE,\n                                message=\'TSocket read 0 bytes\')\n    return buff\n\n  def write(self, buff):\n    if not self.handle:\n      raise TTransportException(type=TTransportException.NOT_OPEN,\n                                message=\'Transport not open\')\n    sent = 0\n    have = len(buff)\n    while sent < have:\n      plus = self.handle.send(buff)\n      if plus == 0:\n        raise TTransportException(type=TTransportException.END_OF_FILE,\n                                  message=\'TSocket sent 0 bytes\')\n      sent += plus\n      buff = buff[plus:]\n\n  def flush(self):\n    pass\n\n\nclass TServerSocket(TSocketBase, TServerTransportBase):\n  """"""Socket implementation of TServerTransport base.""""""\n\n  def __init__(self, host=None, port=9090, unix_socket=None):\n    self.host = host\n    self.port = port\n    self._unix_socket = unix_socket\n    self.handle = None\n\n  def listen(self):\n    res0 = self._resolveAddr()\n    for res in res0:\n      if res[0] is socket.AF_INET6 or res is res0[-1]:\n        break\n\n    # We need remove the old unix socket if the file exists and\n    # nobody is listening on it.\n    if self._unix_socket:\n      tmp = socket.socket(res[0], res[1])\n      try:\n        tmp.connect(res[4])\n      except socket.error as err:\n        eno, message = err.args\n        if eno == errno.ECONNREFUSED:\n          os.unlink(res[4])\n\n    self.handle = socket.socket(res[0], res[1])\n    self.handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    if hasattr(self.handle, \'settimeout\'):\n      self.handle.settimeout(None)\n    self.handle.bind(res[4])\n    self.handle.listen(128)\n\n  def accept(self):\n    client, addr = self.handle.accept()\n    result = TSocket()\n    result.setHandle(client)\n    return result\n'"
thrift/transport/TTransport.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom six import BytesIO\nfrom struct import pack, unpack\nfrom thrift.Thrift import TException\n\n\nclass TTransportException(TException):\n  """"""Custom Transport Exception class""""""\n\n  UNKNOWN = 0\n  NOT_OPEN = 1\n  ALREADY_OPEN = 2\n  TIMED_OUT = 3\n  END_OF_FILE = 4\n\n  def __init__(self, type=UNKNOWN, message=None):\n    TException.__init__(self, message)\n    self.type = type\n\n\nclass TTransportBase:\n  """"""Base class for Thrift transport layer.""""""\n\n  def isOpen(self):\n    pass\n\n  def open(self):\n    pass\n\n  def close(self):\n    pass\n\n  def read(self, sz):\n    pass\n\n  def readAll(self, sz):\n    buff = b\'\'\n    have = 0\n    while (have < sz):\n      chunk = self.read(sz - have)\n      have += len(chunk)\n      buff += chunk\n\n      if len(chunk) == 0:\n        raise EOFError()\n\n    return buff\n\n  def write(self, buf):\n    pass\n\n  def flush(self):\n    pass\n\n\n# This class should be thought of as an interface.\nclass CReadableTransport:\n  """"""base class for transports that are readable from C""""""\n\n  # TODO(dreiss): Think about changing this interface to allow us to use\n  #               a (Python, not c) StringIO instead, because it allows\n  #               you to write after reading.\n\n  # NOTE: This is a classic class, so properties will NOT work\n  #       correctly for setting.\n  @property\n  def cstringio_buf(self):\n    """"""A cStringIO buffer that contains the current chunk we are reading.""""""\n    pass\n\n  def cstringio_refill(self, partialread, reqlen):\n    """"""Refills cstringio_buf.\n\n    Returns the currently used buffer (which can but need not be the same as\n    the old cstringio_buf). partialread is what the C code has read from the\n    buffer, and should be inserted into the buffer before any more reads.  The\n    return value must be a new, not borrowed reference.  Something along the\n    lines of self._buf should be fine.\n\n    If reqlen bytes can\'t be read, throw EOFError.\n    """"""\n    pass\n\n\nclass TServerTransportBase:\n  """"""Base class for Thrift server transports.""""""\n\n  def listen(self):\n    pass\n\n  def accept(self):\n    pass\n\n  def close(self):\n    pass\n\n\nclass TTransportFactoryBase:\n  """"""Base class for a Transport Factory""""""\n\n  def getTransport(self, trans):\n    return trans\n\n\nclass TBufferedTransportFactory:\n  """"""Factory transport that builds buffered transports""""""\n\n  def getTransport(self, trans):\n    buffered = TBufferedTransport(trans)\n    return buffered\n\n\nclass TBufferedTransport(TTransportBase, CReadableTransport):\n  """"""Class that wraps another transport and buffers its I/O.\n\n  The implementation uses a (configurable) fixed-size read buffer\n  but buffers all writes until a flush is performed.\n  """"""\n  DEFAULT_BUFFER = 4096\n\n  def __init__(self, trans, rbuf_size=DEFAULT_BUFFER):\n    self.__trans = trans\n    self.__wbuf = BytesIO()\n    self.__rbuf = BytesIO("""")\n    self.__rbuf_size = rbuf_size\n\n  def isOpen(self):\n    return self.__trans.isOpen()\n\n  def open(self):\n    return self.__trans.open()\n\n  def close(self):\n    return self.__trans.close()\n\n  def read(self, sz):\n    ret = self.__rbuf.read(sz)\n    if len(ret) != 0:\n      return ret\n\n    self.__rbuf = BytesIO(self.__trans.read(max(sz, self.__rbuf_size)))\n    return self.__rbuf.read(sz)\n\n  def write(self, buf):\n    self.__wbuf.write(buf)\n\n  def flush(self):\n    out = self.__wbuf.getvalue()\n    # reset wbuf before write/flush to preserve state on underlying failure\n    self.__wbuf = BytesIO()\n    self.__trans.write(out)\n    self.__trans.flush()\n\n  # Implement the CReadableTransport interface.\n  @property\n  def cstringio_buf(self):\n    return self.__rbuf\n\n  def cstringio_refill(self, partialread, reqlen):\n    retstring = partialread\n    if reqlen < self.__rbuf_size:\n      # try to make a read of as much as we can.\n      retstring += self.__trans.read(self.__rbuf_size)\n\n    # but make sure we do read reqlen bytes.\n    if len(retstring) < reqlen:\n      retstring += self.__trans.readAll(reqlen - len(retstring))\n\n    self.__rbuf = BytesIO(retstring)\n    return self.__rbuf\n\n\nclass TMemoryBuffer(TTransportBase, CReadableTransport):\n  """"""Wraps a cStringIO object as a TTransport.\n\n  NOTE: Unlike the C++ version of this class, you cannot write to it\n        then immediately read from it.  If you want to read from a\n        TMemoryBuffer, you must either pass a string to the constructor.\n  TODO(dreiss): Make this work like the C++ version.\n  """"""\n\n  def __init__(self, value=None):\n    """"""value -- a value to read from for stringio\n\n    If value is set, this will be a transport for reading,\n    otherwise, it is for writing""""""\n    if value is not None:\n      self._buffer = BytesIO(value)\n    else:\n      self._buffer = BytesIO()\n\n  def isOpen(self):\n    return not self._buffer.closed\n\n  def open(self):\n    pass\n\n  def close(self):\n    self._buffer.close()\n\n  def read(self, sz):\n    return self._buffer.read(sz)\n\n  def write(self, buf):\n    try:\n      self._buffer.write(buf)\n    except TypeError:\n      self._buffer.write(buf.encode(\'cp437\'))\n\n  def flush(self):\n    pass\n\n  def getvalue(self):\n    return self._buffer.getvalue()\n\n  # Implement the CReadableTransport interface.\n  @property\n  def cstringio_buf(self):\n    return self._buffer\n\n  def cstringio_refill(self, partialread, reqlen):\n    # only one shot at reading...\n    raise EOFError()\n\n\nclass TFramedTransportFactory:\n  """"""Factory transport that builds framed transports""""""\n\n  def getTransport(self, trans):\n    framed = TFramedTransport(trans)\n    return framed\n\n\nclass TFramedTransport(TTransportBase, CReadableTransport):\n  """"""Class that wraps another transport and frames its I/O when writing.""""""\n\n  def __init__(self, trans,):\n    self.__trans = trans\n    self.__rbuf = BytesIO()\n    self.__wbuf = BytesIO()\n\n  def isOpen(self):\n    return self.__trans.isOpen()\n\n  def open(self):\n    return self.__trans.open()\n\n  def close(self):\n    return self.__trans.close()\n\n  def read(self, sz):\n    ret = self.__rbuf.read(sz)\n    if len(ret) != 0:\n      return ret\n\n    self.readFrame()\n    return self.__rbuf.read(sz)\n\n  def readFrame(self):\n    buff = self.__trans.readAll(4)\n    sz, = unpack(\'!i\', buff)\n    self.__rbuf = BytesIO(self.__trans.readAll(sz))\n\n  def write(self, buf):\n    self.__wbuf.write(buf)\n\n  def flush(self):\n    wout = self.__wbuf.getvalue()\n    wsz = len(wout)\n    # reset wbuf before write/flush to preserve state on underlying failure\n    self.__wbuf = BytesIO()\n    # N.B.: Doing this string concatenation is WAY cheaper than making\n    # two separate calls to the underlying socket object. Socket writes in\n    # Python turn out to be REALLY expensive, but it seems to do a pretty\n    # good job of managing string buffer operations without excessive copies\n    buf = pack(""!i"", wsz) + wout\n    self.__trans.write(buf)\n    self.__trans.flush()\n\n  # Implement the CReadableTransport interface.\n  @property\n  def cstringio_buf(self):\n    return self.__rbuf\n\n  def cstringio_refill(self, prefix, reqlen):\n    # self.__rbuf will already be empty here because fastbinary doesn\'t\n    # ask for a refill until the previous buffer is empty.  Therefore,\n    # we can start reading new frames immediately.\n    while len(prefix) < reqlen:\n      self.readFrame()\n      prefix += self.__rbuf.getvalue()\n    self.__rbuf = BytesIO(prefix)\n    return self.__rbuf\n\n\nclass TFileObjectTransport(TTransportBase):\n  """"""Wraps a file-like object to make it work as a Thrift transport.""""""\n\n  def __init__(self, fileobj):\n    self.fileobj = fileobj\n\n  def isOpen(self):\n    return True\n\n  def close(self):\n    self.fileobj.close()\n\n  def read(self, sz):\n    return self.fileobj.read(sz)\n\n  def write(self, buf):\n    self.fileobj.write(buf)\n\n  def flush(self):\n    self.fileobj.flush()\n'"
thrift/transport/TTwisted.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\nfrom io import StringIO\n\nfrom zope.interface import implements, Interface, Attribute\nfrom twisted.internet.protocol import Protocol, ServerFactory, ClientFactory, \\\n    connectionDone\nfrom twisted.internet import defer\nfrom twisted.protocols import basic\nfrom twisted.python import log\nfrom twisted.web import server, resource, http\n\nfrom thrift.transport import TTransport\n\n\nclass TMessageSenderTransport(TTransport.TTransportBase):\n\n    def __init__(self):\n        self.__wbuf = StringIO()\n\n    def write(self, buf):\n        self.__wbuf.write(buf)\n\n    def flush(self):\n        msg = self.__wbuf.getvalue()\n        self.__wbuf = StringIO()\n        self.sendMessage(msg)\n\n    def sendMessage(self, message):\n        raise NotImplementedError\n\n\nclass TCallbackTransport(TMessageSenderTransport):\n\n    def __init__(self, func):\n        TMessageSenderTransport.__init__(self)\n        self.func = func\n\n    def sendMessage(self, message):\n        self.func(message)\n\n\nclass ThriftClientProtocol(basic.Int32StringReceiver):\n\n    MAX_LENGTH = 2 ** 31 - 1\n\n    def __init__(self, client_class, iprot_factory, oprot_factory=None):\n        self._client_class = client_class\n        self._iprot_factory = iprot_factory\n        if oprot_factory is None:\n            self._oprot_factory = iprot_factory\n        else:\n            self._oprot_factory = oprot_factory\n\n        self.recv_map = {}\n        self.started = defer.Deferred()\n\n    def dispatch(self, msg):\n        self.sendString(msg)\n\n    def connectionMade(self):\n        tmo = TCallbackTransport(self.dispatch)\n        self.client = self._client_class(tmo, self._oprot_factory)\n        self.started.callback(self.client)\n\n    def connectionLost(self, reason=connectionDone):\n        for k, v in self.client._reqs.items():\n            tex = TTransport.TTransportException(\n                type=TTransport.TTransportException.END_OF_FILE,\n                message=\'Connection closed\')\n            v.errback(tex)\n\n    def stringReceived(self, frame):\n        tr = TTransport.TMemoryBuffer(frame)\n        iprot = self._iprot_factory.getProtocol(tr)\n        (fname, mtype, rseqid) = iprot.readMessageBegin()\n\n        try:\n            method = self.recv_map[fname]\n        except KeyError:\n            method = getattr(self.client, \'recv_\' + fname)\n            self.recv_map[fname] = method\n\n        method(iprot, mtype, rseqid)\n\n\nclass ThriftServerProtocol(basic.Int32StringReceiver):\n\n    MAX_LENGTH = 2 ** 31 - 1\n\n    def dispatch(self, msg):\n        self.sendString(msg)\n\n    def processError(self, error):\n        self.transport.loseConnection()\n\n    def processOk(self, _, tmo):\n        msg = tmo.getvalue()\n\n        if len(msg) > 0:\n            self.dispatch(msg)\n\n    def stringReceived(self, frame):\n        tmi = TTransport.TMemoryBuffer(frame)\n        tmo = TTransport.TMemoryBuffer()\n\n        iprot = self.factory.iprot_factory.getProtocol(tmi)\n        oprot = self.factory.oprot_factory.getProtocol(tmo)\n\n        d = self.factory.processor.process(iprot, oprot)\n        d.addCallbacks(self.processOk, self.processError,\n            callbackArgs=(tmo,))\n\n\nclass IThriftServerFactory(Interface):\n\n    processor = Attribute(""Thrift processor"")\n\n    iprot_factory = Attribute(""Input protocol factory"")\n\n    oprot_factory = Attribute(""Output protocol factory"")\n\n\nclass IThriftClientFactory(Interface):\n\n    client_class = Attribute(""Thrift client class"")\n\n    iprot_factory = Attribute(""Input protocol factory"")\n\n    oprot_factory = Attribute(""Output protocol factory"")\n\n\nclass ThriftServerFactory(ServerFactory):\n\n    implements(IThriftServerFactory)\n\n    protocol = ThriftServerProtocol\n\n    def __init__(self, processor, iprot_factory, oprot_factory=None):\n        self.processor = processor\n        self.iprot_factory = iprot_factory\n        if oprot_factory is None:\n            self.oprot_factory = iprot_factory\n        else:\n            self.oprot_factory = oprot_factory\n\n\nclass ThriftClientFactory(ClientFactory):\n\n    implements(IThriftClientFactory)\n\n    protocol = ThriftClientProtocol\n\n    def __init__(self, client_class, iprot_factory, oprot_factory=None):\n        self.client_class = client_class\n        self.iprot_factory = iprot_factory\n        if oprot_factory is None:\n            self.oprot_factory = iprot_factory\n        else:\n            self.oprot_factory = oprot_factory\n\n    def buildProtocol(self, addr):\n        p = self.protocol(self.client_class, self.iprot_factory,\n            self.oprot_factory)\n        p.factory = self\n        return p\n\n\nclass ThriftResource(resource.Resource):\n\n    allowedMethods = (\'POST\',)\n\n    def __init__(self, processor, inputProtocolFactory,\n        outputProtocolFactory=None):\n        resource.Resource.__init__(self)\n        self.inputProtocolFactory = inputProtocolFactory\n        if outputProtocolFactory is None:\n            self.outputProtocolFactory = inputProtocolFactory\n        else:\n            self.outputProtocolFactory = outputProtocolFactory\n        self.processor = processor\n\n    def getChild(self, path, request):\n        return self\n\n    def _cbProcess(self, _, request, tmo):\n        msg = tmo.getvalue()\n        request.setResponseCode(http.OK)\n        request.setHeader(""content-type"", ""application/x-thrift"")\n        request.write(msg)\n        request.finish()\n\n    def render_POST(self, request):\n        request.content.seek(0, 0)\n        data = request.content.read()\n        tmi = TTransport.TMemoryBuffer(data)\n        tmo = TTransport.TMemoryBuffer()\n\n        iprot = self.inputProtocolFactory.getProtocol(tmi)\n        oprot = self.outputProtocolFactory.getProtocol(tmo)\n\n        d = self.processor.process(iprot, oprot)\n        d.addCallback(self._cbProcess, request, tmo)\n        return server.NOT_DONE_YET\n'"
thrift/transport/TZlibTransport.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n""""""TZlibTransport provides a compressed transport and transport factory\nclass, using the python standard library zlib module to implement\ndata compression.\n""""""\n\n\nimport zlib\nfrom io import StringIO\nfrom .TTransport import TTransportBase, CReadableTransport\n\n\nclass TZlibTransportFactory(object):\n  """"""Factory transport that builds zlib compressed transports.\n\n  This factory caches the last single client/transport that it was passed\n  and returns the same TZlibTransport object that was created.\n\n  This caching means the TServer class will get the _same_ transport\n  object for both input and output transports from this factory.\n  (For non-threaded scenarios only, since the cache only holds one object)\n\n  The purpose of this caching is to allocate only one TZlibTransport where\n  only one is really needed (since it must have separate read/write buffers),\n  and makes the statistics from getCompSavings() and getCompRatio()\n  easier to understand.\n  """"""\n  # class scoped cache of last transport given and zlibtransport returned\n  _last_trans = None\n  _last_z = None\n\n  def getTransport(self, trans, compresslevel=9):\n    """"""Wrap a transport, trans, with the TZlibTransport\n    compressed transport class, returning a new\n    transport to the caller.\n\n    @param compresslevel: The zlib compression level, ranging\n    from 0 (no compression) to 9 (best compression).  Defaults to 9.\n    @type compresslevel: int\n\n    This method returns a TZlibTransport which wraps the\n    passed C{trans} TTransport derived instance.\n    """"""\n    if trans == self._last_trans:\n      return self._last_z\n    ztrans = TZlibTransport(trans, compresslevel)\n    self._last_trans = trans\n    self._last_z = ztrans\n    return ztrans\n\n\nclass TZlibTransport(TTransportBase, CReadableTransport):\n  """"""Class that wraps a transport with zlib, compressing writes\n  and decompresses reads, using the python standard\n  library zlib module.\n  """"""\n  # Read buffer size for the python fastbinary C extension,\n  # the TBinaryProtocolAccelerated class.\n  DEFAULT_BUFFSIZE = 4096\n\n  def __init__(self, trans, compresslevel=9):\n    """"""Create a new TZlibTransport, wrapping C{trans}, another\n    TTransport derived object.\n\n    @param trans: A thrift transport object, i.e. a TSocket() object.\n    @type trans: TTransport\n    @param compresslevel: The zlib compression level, ranging\n    from 0 (no compression) to 9 (best compression).  Default is 9.\n    @type compresslevel: int\n    """"""\n    self.__trans = trans\n    self.compresslevel = compresslevel\n    self.__rbuf = StringIO()\n    self.__wbuf = StringIO()\n    self._init_zlib()\n    self._init_stats()\n\n  def _reinit_buffers(self):\n    """"""Internal method to initialize/reset the internal StringIO objects\n    for read and write buffers.\n    """"""\n    self.__rbuf = StringIO()\n    self.__wbuf = StringIO()\n\n  def _init_stats(self):\n    """"""Internal method to reset the internal statistics counters\n    for compression ratios and bandwidth savings.\n    """"""\n    self.bytes_in = 0\n    self.bytes_out = 0\n    self.bytes_in_comp = 0\n    self.bytes_out_comp = 0\n\n  def _init_zlib(self):\n    """"""Internal method for setting up the zlib compression and\n    decompression objects.\n    """"""\n    self._zcomp_read = zlib.decompressobj()\n    self._zcomp_write = zlib.compressobj(self.compresslevel)\n\n  def getCompRatio(self):\n    """"""Get the current measured compression ratios (in,out) from\n    this transport.\n\n    Returns a tuple of:\n    (inbound_compression_ratio, outbound_compression_ratio)\n\n    The compression ratios are computed as:\n        compressed / uncompressed\n\n    E.g., data that compresses by 10x will have a ratio of: 0.10\n    and data that compresses to half of ts original size will\n    have a ratio of 0.5\n\n    None is returned if no bytes have yet been processed in\n    a particular direction.\n    """"""\n    r_percent, w_percent = (None, None)\n    if self.bytes_in > 0:\n      r_percent = self.bytes_in_comp / self.bytes_in\n    if self.bytes_out > 0:\n      w_percent = self.bytes_out_comp / self.bytes_out\n    return (r_percent, w_percent)\n\n  def getCompSavings(self):\n    """"""Get the current count of saved bytes due to data\n    compression.\n\n    Returns a tuple of:\n    (inbound_saved_bytes, outbound_saved_bytes)\n\n    Note: if compression is actually expanding your\n    data (only likely with very tiny thrift objects), then\n    the values returned will be negative.\n    """"""\n    r_saved = self.bytes_in - self.bytes_in_comp\n    w_saved = self.bytes_out - self.bytes_out_comp\n    return (r_saved, w_saved)\n\n  def isOpen(self):\n    """"""Return the underlying transport\'s open status""""""\n    return self.__trans.isOpen()\n\n  def open(self):\n    """"""Open the underlying transport""""""\n    self._init_stats()\n    return self.__trans.open()\n\n  def listen(self):\n    """"""Invoke the underlying transport\'s listen() method""""""\n    self.__trans.listen()\n\n  def accept(self):\n    """"""Accept connections on the underlying transport""""""\n    return self.__trans.accept()\n\n  def close(self):\n    """"""Close the underlying transport,""""""\n    self._reinit_buffers()\n    self._init_zlib()\n    return self.__trans.close()\n\n  def read(self, sz):\n    """"""Read up to sz bytes from the decompressed bytes buffer, and\n    read from the underlying transport if the decompression\n    buffer is empty.\n    """"""\n    ret = self.__rbuf.read(sz)\n    if len(ret) > 0:\n      return ret\n    # keep reading from transport until something comes back\n    while True:\n      if self.readComp(sz):\n        break\n    ret = self.__rbuf.read(sz)\n    return ret\n\n  def readComp(self, sz):\n    """"""Read compressed data from the underlying transport, then\n    decompress it and append it to the internal StringIO read buffer\n    """"""\n    zbuf = self.__trans.read(sz)\n    zbuf = self._zcomp_read.unconsumed_tail + zbuf\n    buf = self._zcomp_read.decompress(zbuf)\n    self.bytes_in += len(zbuf)\n    self.bytes_in_comp += len(buf)\n    old = self.__rbuf.read()\n    self.__rbuf = StringIO(old + buf)\n    if len(old) + len(buf) == 0:\n      return False\n    return True\n\n  def write(self, buf):\n    """"""Write some bytes, putting them into the internal write\n    buffer for eventual compression.\n    """"""\n    self.__wbuf.write(buf)\n\n  def flush(self):\n    """"""Flush any queued up data in the write buffer and ensure the\n    compression buffer is flushed out to the underlying transport\n    """"""\n    wout = self.__wbuf.getvalue()\n    if len(wout) > 0:\n      zbuf = self._zcomp_write.compress(wout)\n      self.bytes_out += len(wout)\n      self.bytes_out_comp += len(zbuf)\n    else:\n      zbuf = \'\'\n    ztail = self._zcomp_write.flush(zlib.Z_SYNC_FLUSH)\n    self.bytes_out_comp += len(ztail)\n    if (len(zbuf) + len(ztail)) > 0:\n      self.__wbuf = StringIO()\n      self.__trans.write(zbuf + ztail)\n    self.__trans.flush()\n\n  @property\n  def cstringio_buf(self):\n    """"""Implement the CReadableTransport interface""""""\n    return self.__rbuf\n\n  def cstringio_refill(self, partialread, reqlen):\n    """"""Implement the CReadableTransport interface for refill""""""\n    retstring = partialread\n    if reqlen < self.DEFAULT_BUFFSIZE:\n      retstring += self.read(self.DEFAULT_BUFFSIZE)\n    while len(retstring) < reqlen:\n      retstring += self.read(reqlen - len(retstring))\n    self.__rbuf = StringIO(retstring)\n    return self.__rbuf\n'"
thrift/transport/__init__.py,0,"b'#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements. See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership. The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# ""License""); you may not use this file except in compliance\n# with the License. You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied. See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n\n__all__ = [\'TTransport\', \'TSocket\', \'THttpClient\', \'TZlibTransport\']\n'"
awips/test/dafTests/__init__.py,0,b'\n__all__ = []\n'
awips/test/dafTests/baseBufrMosTestCase.py,0,"b'#\n# Base TestCase for BufrMos* tests.\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    12/07/16        5981          tgurney        Parameterize\n#    12/15/16        5981          tgurney        Add envelope test\n#\n#\n\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass BufrMosTestCase(baseDafTestCase.DafTestCase):\n    """"""Base class for testing DAF support of bufrmos data""""""\n\n    data_params = ""temperature"", ""dewpoint""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(params.OBS_STATION)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(params.OBS_STATION)\n        req.setParameters(*self.data_params)\n        self.runGeometryDataTest(req)\n\n    def testGetGeometryDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(*self.data_params)\n        req.setEnvelope(params.ENVELOPE)\n        data = self.runGeometryDataTest(req)\n        for item in data:\n            self.assertTrue(params.ENVELOPE.contains(item.getGeometry()))\n'"
awips/test/dafTests/baseDafTestCase.py,0,"b'#\n# Base TestCase for DAF tests. This class provides helper methods and\n# tests common to all DAF test cases.\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/13/16        5379          tgurney        Add identifier values tests\n#    04/18/16        5548          tgurney        More cleanup, plus new tests\n#    04/26/16        5587          tgurney        Move identifier values tests\n#                                                 to subclasses\n#    06/01/16        5587          tgurney        Add testGet*Identifiers\n#    06/07/16        5574          tgurney        Make geometry/grid data tests\n#                                                 return the retrieved data\n#    06/10/16        5548          tgurney        Make testDatatypeIsSupported\n#                                                 case-insensitive\n#    08/10/16        2416          tgurney        Don\'t test identifier values\n#                                                 for dataURI\n#    10/05/16        5926          dgilling       Better checks in runGeometryDataTest.\n#    11/08/16        5985          tgurney        Do not check data times on\n#                                                 time-agnostic data\n#    03/13/17        5981          tgurney        Do not check valid period on\n#                                                 data time\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\n\nimport os\nimport unittest\n\n\nclass DafTestCase(unittest.TestCase):\n\n    sampleDataLimit = 5\n    """"""\n    Maximum number of levels, locations, times, and geometry/grid data to\n    display\n    """"""\n\n    numTimesToLimit = 3\n    """"""\n    When limiting geometry/grid data requests with times, only retrieve data\n    for this many times\n    """"""\n\n    datatype = None\n    """"""Name of the datatype""""""\n\n    @classmethod\n    def setUpClass(cls):\n        host = os.environ.get(\'DAF_TEST_HOST\')\n        if host is None:\n            host = \'edex-cloud.unidata.ucar.edu\'\n        DAL.changeEDEXHost(host)\n\n    @staticmethod\n    def getTimesIfSupported(req):\n        """"""Return available times for req. If req refers to a time-agnostic\n        datatype, return an empty list instead.\n        """"""\n        times = []\n        try:\n            times = DAL.getAvailableTimes(req)\n        except ThriftRequestException as e:\n            if \'TimeAgnosticDataException\' not in str(e):\n                raise\n        return times\n\n    def testDatatypeIsSupported(self):\n        allSupported = DAL.getSupportedDatatypes()\n        self.assertIn(self.datatype, allSupported)\n\n    def testGetRequiredIdentifiers(self):\n        req = DAL.newDataRequest(self.datatype)\n        required = DAL.getRequiredIdentifiers(req)\n        self.assertIsNotNone(required)\n        print(""Required identifiers:"", required)\n\n    def testGetOptionalIdentifiers(self):\n        req = DAL.newDataRequest(self.datatype)\n        optional = DAL.getOptionalIdentifiers(req)\n        self.assertIsNotNone(optional)\n        print(""Optional identifiers:"", optional)\n\n    def runGetIdValuesTest(self, identifiers):\n        for identifier in identifiers:\n            if identifier.lower() == \'datauri\':\n                continue\n            req = DAL.newDataRequest(self.datatype)\n            idValues = DAL.getIdentifierValues(req, identifier)\n            self.assertTrue(hasattr(idValues, \'__iter__\'))\n\n    def runInvalidIdValuesTest(self):\n        badString = \'id from \' + self.datatype + \'; select 1;\'\n        with self.assertRaises(ThriftRequestException):\n            req = DAL.newDataRequest(self.datatype)\n            DAL.getIdentifierValues(req, badString)\n\n    def runNonexistentIdValuesTest(self):\n        with self.assertRaises(ThriftRequestException):\n            req = DAL.newDataRequest(self.datatype)\n            DAL.getIdentifierValues(req, \'idthatdoesnotexist\')\n\n    def runParametersTest(self, req):\n        params = DAL.getAvailableParameters(req)\n        self.assertIsNotNone(params)\n        print(params)\n\n    def runLevelsTest(self, req):\n        levels = DAL.getAvailableLevels(req)\n        self.assertIsNotNone(levels)\n        print(""Number of levels: "" + str(len(levels)))\n        strLevels = [str(t) for t in levels[:self.sampleDataLimit]]\n        print(""Sample levels:\\n"" + str(strLevels))\n\n    def runLocationsTest(self, req):\n        locs = DAL.getAvailableLocationNames(req)\n        self.assertIsNotNone(locs)\n        print(""Number of location names: "" + str(len(locs)))\n        print(""Sample location names:\\n"" + str(locs[:self.sampleDataLimit]))\n\n    def runTimesTest(self, req):\n        times = DAL.getAvailableTimes(req)\n        self.assertIsNotNone(times)\n        print(""Number of times: "" + str(len(times)))\n        strTimes = [str(t) for t in times[:self.sampleDataLimit]]\n        print(""Sample times:\\n"" + str(strTimes))\n\n    def runTimeAgnosticTest(self, req):\n        with self.assertRaises(ThriftRequestException) as cm:\n            DAL.getAvailableTimes(req)\n        self.assertIn(\'TimeAgnosticDataException\', str(cm.exception))\n\n    def runGeometryDataTest(self, req, checkDataTimes=True):\n        """"""\n        Test that we are able to successfully retrieve geometry data for the\n        given request.\n        """"""\n        times = DafTestCase.getTimesIfSupported(req)\n        geomData = DAL.getGeometryData(req, times[:self.numTimesToLimit])\n        self.assertIsNotNone(geomData)\n        if not geomData:\n            raise unittest.SkipTest(""No data available"")\n        print(""Number of geometry records: "" + str(len(geomData)))\n        return geomData\n\n    def runGeometryDataTestWithTimeRange(self, req, timeRange):\n        """"""\n        Test that we are able to successfully retrieve geometry data for the\n        given request.\n        """"""\n        geomData = DAL.getGeometryData(req, timeRange)\n        self.assertIsNotNone(geomData)\n        if not geomData:\n            raise unittest.SkipTest(""No data available"")\n        print(""Number of geometry records: "" + str(len(geomData)))\n        return geomData\n\n    def runGridDataTest(self, req, testSameShape=True):\n        """"""\n        Test that we are able to successfully retrieve grid data for the given\n        request.\n\n        Args:\n            req: the grid request\n            testSameShape: whether or not to verify that all the retrieved data\n                           have the same shape (most data don\'t change shape)\n        """"""\n        times = DafTestCase.getTimesIfSupported(req)\n        gridData = DAL.getGridData(req, times[:self.numTimesToLimit])\n        self.assertIsNotNone(gridData)\n        if not gridData:\n            raise unittest.SkipTest(""No data available"")\n        print(""Number of grid records: "" + str(len(gridData)))\n        if len(gridData) > 0:\n            print(""Sample grid data shape:\\n"" + str(gridData[0].getRawData().shape) + ""\\n"")\n            print(""Sample grid data:\\n"" + str(gridData[0].getRawData()) + ""\\n"")\n            print(""Sample lat-lon data:\\n"" + str(gridData[0].getLatLonCoords()) + ""\\n"")\n\n            if testSameShape:\n                correctGridShape = gridData[0].getLatLonCoords()[0].shape\n                for record in gridData:\n                    rawData = record.getRawData()\n                    self.assertIsNotNone(rawData)\n                    self.assertEqual(rawData.shape, correctGridShape)\n        return gridData\n'"
awips/test/dafTests/baseRadarTestCase.py,0,"b'#\n# Tests common to all radar factories\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    04/26/16        5587          tgurney        Move identifier values tests\n#                                                 out of base class\n#    06/01/16        5587          tgurney        Update testGetIdentifierValues\n#    06/08/16        5574          mapeters       Add advanced query tests\n#    06/13/16        5574          tgurney        Fix checks for None\n#    06/14/16        5548          tgurney        Undo previous change (broke\n#                                                 test)\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    08/25/16        2671          tgurney        Rename to baseRadarTestCase\n#                                                 and move factory-specific\n#                                                 tests\n#    12/07/16        5981          tgurney        Parameterize\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass BaseRadarTestCase(baseDafTestCase.DafTestCase):\n    """"""Tests common to all radar factories""""""\n\n    # datatype is specified by subclass\n    datatype = None\n\n    radarLoc = params.RADAR.lower()\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableLevels(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLevelsTest(req)\n\n    def testGetAvailableLevelsWithInvalidLevelIdentifierThrowsException(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'level.one.field\', \'invalidLevelField\')\n        with self.assertRaises(ThriftRequestException) as cm:\n            self.runLevelsTest(req)\n        self.assertIn(\'IncompatibleRequestException\', str(cm.exception))\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        self.runTimesTest(req)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        requiredIds = set(DAL.getRequiredIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds | requiredIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def runConstraintTest(self, key, operator, value):\n        raise NotImplementedError\n\n    def testGetDataWithEqualsString(self):\n        gridData = self.runConstraintTest(\'icao\', \'=\', self.radarLoc)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithEqualsInt(self):\n        gridData = self.runConstraintTest(\'icao\', \'=\', 1000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'icao\'), 1000)\n\n    def testGetDataWithEqualsLong(self):\n        gridData = self.runConstraintTest(\'icao\', \'=\', 1000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'icao\'), 1000)\n\n    def testGetDataWithEqualsFloat(self):\n        gridData = self.runConstraintTest(\'icao\', \'=\', 1.0)\n        for record in gridData:\n            self.assertEqual(round(record.getAttribute(\'icao\'), 1), 1.0)\n\n    def testGetDataWithEqualsNone(self):\n        gridData = self.runConstraintTest(\'icao\', \'=\', None)\n        for record in gridData:\n            self.assertIsNone(record.getAttribute(\'icao\'))\n\n    def testGetDataWithNotEquals(self):\n        gridData = self.runConstraintTest(\'icao\', \'!=\', self.radarLoc)\n        for record in gridData:\n            self.assertNotEqual(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithNotEqualsNone(self):\n        gridData = self.runConstraintTest(\'icao\', \'!=\', None)\n        for record in gridData:\n            self.assertIsNotNone(record.getAttribute(\'icao\'))\n\n    def testGetDataWithGreaterThan(self):\n        gridData = self.runConstraintTest(\'icao\', \'>\', self.radarLoc)\n        for record in gridData:\n            self.assertGreater(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithLessThan(self):\n        gridData = self.runConstraintTest(\'icao\', \'<\', self.radarLoc)\n        for record in gridData:\n            self.assertLess(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithGreaterThanEquals(self):\n        gridData = self.runConstraintTest(\'icao\', \'>=\', self.radarLoc)\n        for record in gridData:\n            self.assertGreaterEqual(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithLessThanEquals(self):\n        gridData = self.runConstraintTest(\'icao\', \'<=\', self.radarLoc)\n        for record in gridData:\n            self.assertLessEqual(record.getAttribute(\'icao\'), self.radarLoc)\n\n    def testGetDataWithInTuple(self):\n        gridData = self.runConstraintTest(\'icao\', \'in\', (self.radarLoc, \'tpbi\'))\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'icao\'), (self.radarLoc, \'tpbi\'))\n\n    def testGetDataWithInList(self):\n        gridData = self.runConstraintTest(\'icao\', \'in\', [self.radarLoc, \'tpbi\'])\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'icao\'), (self.radarLoc, \'tpbi\'))\n\n    def testGetDataWithInGenerator(self):\n        generator = (item for item in (self.radarLoc, \'tpbi\'))\n        gridData = self.runConstraintTest(\'icao\', \'in\', generator)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'icao\'), (self.radarLoc, \'tpbi\'))\n\n    def testGetDataWithNotInList(self):\n        gridData = self.runConstraintTest(\'icao\', \'not in\', [\'zzzz\', self.radarLoc])\n        for record in gridData:\n            self.assertNotIn(record.getAttribute(\'icao\'), (\'zzzz\', self.radarLoc))\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self.runConstraintTest(\'icao\', \'junk\', self.radarLoc)\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self.runConstraintTest(\'icao\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self.runConstraintTest(\'icao\', \'in\', [])\n'"
awips/test/dafTests/params.py,0,"b""#\n# Site-specific parameters for DAF tests\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    12/07/16        5981          tgurney        Initial creation\n#    12/15/16        5981          tgurney        Add ENVELOPE\n#\n#\n\nfrom shapely.geometry import box\n\n\nAIRPORT = 'OMA'\nOBS_STATION = 'KOMA'\nSITE_ID = 'OAX'\nSTATION_ID = '72558'\nRADAR = 'KOAX'\nSAMPLE_AREA = (-97.0, 41.0, -96.0, 42.0)\n\nENVELOPE = box(*SAMPLE_AREA)\n"""
awips/test/dafTests/testAcars.py,0,"b'#\n# Test DAF support for ACARS data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass AcarsTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for ACARS data""""""\n\n    datatype = ""acars""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""flightLevel"", ""tailNumber"")\n        self.runGeometryDataTest(req)\n'"
awips/test/dafTests/testAirep.py,0,"b'#\n# Test DAF support for airep data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          bsteffen       Add getIdentifierValues tests\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass AirepTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for airep data""""""\n\n    datatype = ""airep""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""flightLevel"", ""reportType"")\n        self.runGeometryDataTest(req)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.setParameters(""flightLevel"", ""reportType"")\n        req.addIdentifier(key, constraint)\n        return self.runGeometryDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', \'AIREP\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'reportType\'), \'AIREP\')\n\n    # No numeric tests since no numeric identifiers are available.\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', \'AIREP\')\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'reportType\'), \'AIREP\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>\', \'AIREP\')\n        for record in geometryData:\n            self.assertGreater(record.getString(\'reportType\'), \'AIREP\')\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<\', \'AIREP\')\n        for record in geometryData:\n            self.assertLess(record.getString(\'reportType\'), \'AIREP\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>=\', \'AIREP\')\n        for record in geometryData:\n            self.assertGreaterEqual(record.getString(\'reportType\'), \'AIREP\')\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<=\', \'AIREP\')\n        for record in geometryData:\n            self.assertLessEqual(record.getString(\'reportType\'), \'AIREP\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'AIREP\', \'AMDAR\')\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'AIREP\', \'AMDAR\']\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'AIREP\', \'AMDAR\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'AMDAR\']\n        geometryData = self._runConstraintTest(\'reportType\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'junk\', \'AIREP\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'AIREP\', \'AMDAR\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'in\', collection)\n'"
awips/test/dafTests/testBinLightning.py,0,"b'#\n# Test DAF support for binlightning data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    04/21/16        5551          tgurney        Add tests to verify #5551\n#    04/25/16        5587          tgurney        Enable skipped test added in\n#                                                 #5551\n#    04/26/16        5587          tgurney        Move identifier values tests\n#                                                 out of base class\n#    06/01/16        5587          tgurney        Update testGetIdentifierValues\n#    06/03/16        5574          tgurney        Add advanced query tests\n#    06/13/16        5574          tgurney        Typo\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    11/08/16        5985          tgurney        Do not check data times\n#\n#\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass BinLightningTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for binlightning data""""""\n\n    datatype = ""binlightning""\n    source = ""GLMfl""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'source\', self.source)\n        self.runTimesTest(req)\n\n    def testGetGeometryDataSingleSourceSingleParameter(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'source\', self.source)\n        req.setParameters(\'intensity\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataInvalidParamRaisesIncompatibleRequestException(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'source\', self.source)\n        req.setParameters(\'blahblahblah\')\n        with self.assertRaises(ThriftRequestException) as cm:\n            self.runGeometryDataTest(req)\n        self.assertIn(\'IncompatibleRequestException\', str(cm.exception))\n\n    def testGetGeometryDataSingleSourceAllParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'source\', self.source)\n        req.setParameters(*DAL.getAvailableParameters(req))\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        requiredIds = set(DAL.getRequiredIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds | requiredIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(\'intensity\')\n        return self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetDataWithEqualsString(self):\n        geomData = self._runConstraintTest(\'source\', \'=\', self.source)\n        for record in geomData:\n            self.assertEqual(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithEqualsInt(self):\n        geomData = self._runConstraintTest(\'source\', \'=\', 1000)\n        for record in geomData:\n            self.assertEqual(record.getAttribute(\'source\'), 1000)\n\n    def testGetDataWithEqualsLong(self):\n        geomData = self._runConstraintTest(\'source\', \'=\', 1000)\n        for record in geomData:\n            self.assertEqual(record.getAttribute(\'source\'), 1000)\n\n    def testGetDataWithEqualsFloat(self):\n        geomData = self._runConstraintTest(\'source\', \'=\', 1.0)\n        for record in geomData:\n            self.assertEqual(round(record.getAttribute(\'source\'), 1), 1.0)\n\n    def testGetDataWithEqualsNone(self):\n        geomData = self._runConstraintTest(\'source\', \'=\', None)\n        for record in geomData:\n            self.assertIsNone(record.getAttribute(\'source\'))\n\n    def testGetDataWithNotEquals(self):\n        geomData = self._runConstraintTest(\'source\', \'!=\', self.source)\n        for record in geomData:\n            self.assertNotEqual(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithNotEqualsNone(self):\n        geomData = self._runConstraintTest(\'source\', \'!=\', None)\n        for record in geomData:\n            self.assertIsNotNone(record.getAttribute(\'source\'))\n\n    def testGetDataWithGreaterThan(self):\n        geomData = self._runConstraintTest(\'source\', \'>\', self.source)\n        for record in geomData:\n            self.assertGreater(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithLessThan(self):\n        geomData = self._runConstraintTest(\'source\', \'<\', self.source)\n        for record in geomData:\n            self.assertLess(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithGreaterThanEquals(self):\n        geomData = self._runConstraintTest(\'source\', \'>=\', self.source)\n        for record in geomData:\n            self.assertGreaterEqual(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithLessThanEquals(self):\n        geomData = self._runConstraintTest(\'source\', \'<=\', self.source)\n        for record in geomData:\n            self.assertLessEqual(record.getAttribute(\'source\'), self.source)\n\n    def testGetDataWithInTuple(self):\n        geomData = self._runConstraintTest(\'source\', \'in\', (self.source, \'GLMev\'))\n        for record in geomData:\n            self.assertIn(record.getAttribute(\'source\'), (self.source, \'GLMev\'))\n\n    def testGetDataWithInList(self):\n        geomData = self._runConstraintTest(\'source\', \'in\', [self.source, \'GLMev\'])\n        for record in geomData:\n            self.assertIn(record.getAttribute(\'source\'), (self.source, \'GLMev\'))\n\n    def testGetDataWithInGenerator(self):\n        generator = (item for item in (self.source, \'GLMev\'))\n        geomData = self._runConstraintTest(\'source\', \'in\', generator)\n        for record in geomData:\n            self.assertIn(record.getAttribute(\'source\'), (self.source, \'GLMev\'))\n\n    def testGetDataWithNotInList(self):\n        geomData = self._runConstraintTest(\'source\', \'not in\', [self.source, \'blah\'])\n        for record in geomData:\n            self.assertNotIn(record.getAttribute(\'source\'), (self.source, \'blah\'))\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'source\', \'junk\', self.source)\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'source\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'source\', \'in\', [])\n'"
awips/test/dafTests/testBufrMosGfs.py,0,"b'#\n# Test DAF support for bufrmosGFS data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#\n#\n\nfrom awips.test.dafTests import baseBufrMosTestCase\n\n\nclass BufrMosGfsTestCase(baseBufrMosTestCase.BufrMosTestCase):\n    """"""Test DAF support for bufrmosGFS data""""""\n\n    datatype = ""bufrmosGFS""\n\n    # All tests inherited from superclass\n'"
awips/test/dafTests/testBufrUa.py,0,"b'from __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n#\n# Test DAF support for bufrua data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          bsteffen       Add getIdentifierValues tests\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    12/07/16        5981          tgurney        Parameterize\n#    12/15/16        5981          tgurney        Add envelope test\n#\n#\n\n\nclass BufrUaTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for bufrua data""""""\n\n    datatype = ""bufrua""\n\n    location = params.STATION_ID\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""reportType"", ""2020"")\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(self.location)\n        req.addIdentifier(""reportType"", ""2020"")\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(self.location)\n        req.addIdentifier(""reportType"", ""2020"")\n        req.setParameters(""sfcPressure"", ""staName"", ""rptType"", ""tdMan"")\n\n        print(""Testing getGeometryData()"")\n\n        geomData = DAL.getGeometryData(req)\n        self.assertIsNotNone(geomData)\n        print(""Number of geometry records: "" + str(len(geomData)))\n        print(""Sample geometry data:"")\n        for record in geomData[:self.sampleDataLimit]:\n            print(""level="", record.getLevel(), end="""")\n            # One dimensional parameters are reported on the 0.0UNKNOWN level.\n            # 2D parameters are reported on MB levels from pressure.\n            if record.getLevel() == ""0.0UNKNOWN"":\n                print("" sfcPressure="" + record.getString(""sfcPressure"") + record.getUnit(""sfcPressure""), end="""")\n                print("" staName="" + record.getString(""staName""), end="""")\n                print("" rptType="" + record.getString(""rptType"") + record.getUnit(""rptType""), end="""")\n            else:\n                print("" tdMan="" + str(record.getNumber(""tdMan"")) + record.getUnit(""tdMan""), end="""")\n            print("" geometry="", record.getGeometry())\n\n        print(""getGeometryData() complete\\n\\n"")\n\n    def testGetGeometryDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""staName"", ""rptType"")\n        req.setEnvelope(params.ENVELOPE)\n        data = self.runGeometryDataTest(req)\n        for item in data:\n            self.assertTrue(params.ENVELOPE.contains(item.getGeometry()))\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        # As an identifier it is ""reportType"" but as a parameter it is\n        # ""rptType""... this is weird...\n        req.setParameters(""staName"", ""rptType"")\n        return self.runGeometryDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', \'2022\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', 2022)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', 2022)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'rptType\'), \'2022\')\n\n    # No float test because no float identifiers are available\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'rptType\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', 2022)\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'rptType\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>\', 2022)\n        for record in geometryData:\n            self.assertGreater(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<\', 2022)\n        for record in geometryData:\n            self.assertLess(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>=\', 2022)\n        for record in geometryData:\n            self.assertGreaterEqual(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<=\', 2022)\n        for record in geometryData:\n            self.assertLessEqual(record.getString(\'rptType\'), \'2022\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'2022\', \'2032\')\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'rptType\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'2022\', \'2032\']\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'rptType\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'2022\', \'2032\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'rptType\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = (\'2022\', \'2032\')\n        geometryData = self._runConstraintTest(\'reportType\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'rptType\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'junk\', \'2022\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'rptType\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'2022\', \'2032\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'rptType\', \'in\', collection)\n'"
awips/test/dafTests/testCombinedTimeQuery.py,0,"b'#\n# Test the CombinedTimedQuery module\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/24/16        5591          bsteffen       Initial Creation.\n#    11/08/16        5895          tgurney        Change grid model\n#\n#\n#\n\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.dataaccess import CombinedTimeQuery as CTQ\n\nimport unittest\nimport os\n\n\nclass CombinedTimeQueryTestCase(unittest.TestCase):\n\n    modelName = ""RAP13""\n\n    @classmethod\n    def setUp(cls):\n        host = os.environ.get(\'DAF_TEST_HOST\')\n        if host is None:\n            host = \'edex-cloud.unidata.ucar.edu\'\n        DAL.changeEDEXHost(host)\n\n    def testSuccessfulQuery(self):\n        req = DAL.newDataRequest(\'grid\')\n        req.setLocationNames(self.modelName)\n        req.setParameters(\'T\', \'GH\')\n        req.setLevels(\'300MB\', \'500MB\', \'700MB\')\n        times = CTQ.getAvailableTimes(req)\n        self.assertNotEqual(len(times), 0)\n\n    def testNonIntersectingQuery(self):\n        """"""\n        Test that when a parameter is only available on one of the levels that no times are returned.\n        """"""\n        req = DAL.newDataRequest(\'grid\')\n        req.setLocationNames(self.modelName)\n        req.setParameters(\'T\', \'GH\', \'LgSP1hr\')\n        req.setLevels(\'300MB\', \'500MB\', \'700MB\', \'0.0SFC\')\n        times = CTQ.getAvailableTimes(req)\n        self.assertEqual(len(times), 0)\n'"
awips/test/dafTests/testCommonObsSpatial.py,0,"b'#\n# Test DAF support for common_obs_spatial data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    05/26/16        5587          njensen        Added testGetIdentifierValues()\n#    06/01/16        5587          tgurney        Move testIdentifiers() to\n#                                                 superclass\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/21/16        5548          tgurney        Skip tests that cause errors\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    12/07/16        5981          tgurney        Parameterize\n#    01/06/17        5981          tgurney        Do not check data times\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass CommonObsSpatialTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for common_obs_spatial data""""""\n\n    datatype = ""common_obs_spatial""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""country"", [""US"", ""CN""])\n        self.runLocationsTest(req)\n\n    def testGetIdentifierValues(self):\n        self.runGetIdValuesTest([\'country\'])\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setParameters(""name"", ""stationid"")\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testRequestingTimesThrowsTimeAgnosticDataException(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimeAgnosticTest(req)\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(\'catalogtype\', \'elevation\', \'state\')\n        return self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'state\', \'=\', \'NE\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'state\'), \'NE\')\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'catalogtype\', \'=\', 32)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'catalogtype\'), 32)\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'elevation\', \'=\', 0)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'elevation\'), 0)\n\n    # No float test since there are no float identifiers available. Attempting\n    # to filter a non-float identifier on a float value raises an exception.\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'state\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'state\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'state\', \'!=\', \'NE\')\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'state\'), \'NE\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'state\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'state\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'elevation\', \'>\', 500)\n        for record in geometryData:\n            self.assertGreater(record.getNumber(\'elevation\'), 500)\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'elevation\', \'<\', 100)\n        for record in geometryData:\n            self.assertLess(record.getNumber(\'elevation\'), 100)\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'elevation\', \'>=\', 500)\n        for record in geometryData:\n            self.assertGreaterEqual(record.getNumber(\'elevation\'), 500)\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'elevation\', \'<=\', 100)\n        for record in geometryData:\n            self.assertLessEqual(record.getNumber(\'elevation\'), 100)\n\n    def testGetDataWithInTuple(self):\n        collection = (\'NE\', \'TX\')\n        geometryData = self._runConstraintTest(\'state\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'NE\', \'TX\']\n        geometryData = self._runConstraintTest(\'state\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'NE\', \'TX\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'state\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = (\'NE\', \'TX\')\n        geometryData = self._runConstraintTest(\'state\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'state\', \'junk\', \'NE\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'state\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'state\', \'in\', [])\n'"
awips/test/dafTests/testDataTime.py,0,"b""#\n# Unit tests for Python implementation of RequestConstraint\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/02/16        2416          tgurney        Initial creation\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import DataTime\n\nimport unittest\n\n\nclass DataTimeTestCase(unittest.TestCase):\n\n    def testFromStrRefTimeOnly(self):\n        s = '2016-08-02 01:23:45'\n        expected = s\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrRefTimeOnlyZeroMillis(self):\n        s = '2016-08-02 01:23:45.0'\n        # result of str() will always drop trailing .0 milliseconds\n        expected = '2016-08-02 01:23:45'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrRefTimeOnlyWithMillis(self):\n        s = '2016-08-02 01:23:45.1'\n        expected = '2016-08-02 01:23:45.001000'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithFcstTimeHr(self):\n        s = '2016-08-02 01:23:45 (17)'\n        expected = s\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithFcstTimeHrZeroMillis(self):\n        s = '2016-08-02 01:23:45.0 (17)'\n        expected = '2016-08-02 01:23:45 (17)'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithFcstTimeHrAndMillis(self):\n        s = '2016-08-02 01:23:45.1 (17)'\n        expected = '2016-08-02 01:23:45.001000 (17)'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithFcstTimeHrMin(self):\n        s = '2016-08-02 01:23:45 (17:34)'\n        expected = s\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithFcstTimeHrMinZeroMillis(self):\n        s = '2016-08-02 01:23:45.0 (17:34)'\n        expected = '2016-08-02 01:23:45 (17:34)'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithPeriod(self):\n        s = '2016-08-02 01:23:45[2016-08-02 02:34:45--2016-08-02 03:45:56]'\n        expected = s\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithPeriodZeroMillis(self):\n        s = '2016-08-02 01:23:45.0[2016-08-02 02:34:45.0--2016-08-02 03:45:56.0]'\n        expected = '2016-08-02 01:23:45[2016-08-02 02:34:45--2016-08-02 03:45:56]'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testFromStrWithEverything(self):\n        s = '2016-08-02 01:23:45.0_(17:34)[2016-08-02 02:34:45.0--2016-08-02 03:45:56.0]'\n        expected = '2016-08-02 01:23:45 (17:34)[2016-08-02 02:34:45--2016-08-02 03:45:56]'\n        self.assertEqual(expected, str(DataTime(s)))\n        s = s.replace(' ', '_')\n        self.assertEqual(expected, str(DataTime(s)))\n\n    def testDataTimeReconstructItselfFromString(self):\n        times = [\n             '2016-08-02 01:23:45',\n             '2016-08-02 01:23:45.0',\n             '2016-08-02 01:23:45.1',\n             '2016-08-02 01:23:45.123000',\n             '2016-08-02 01:23:45 (17)',\n             '2016-08-02 01:23:45.0 (17)',\n             '2016-08-02 01:23:45.1 (17)',\n             '2016-08-02 01:23:45 (17:34)',\n             '2016-08-02 01:23:45.0 (17:34)',\n             '2016-08-02 01:23:45.1 (17:34)',\n             '2016-08-02 01:23:45.0[2016-08-02_02:34:45.0--2016-08-02_03:45:56.0]',\n             '2016-08-02 01:23:45.0[2016-08-02_02:34:45.123--2016-08-02_03:45:56.456]',\n             '2016-08-02 01:23:45.456_(17:34)[2016-08-02_02:34:45.0--2016-08-02_03:45:56.0]'\n             ]\n        for time in times:\n            self.assertEqual(DataTime(time), DataTime(str(DataTime(time))), time)\n"""
awips/test/dafTests/testGfe.py,0,"b'#\n# Test DAF support for GFE data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    05/23/16        5637          bsteffen       Test vectors\n#    05/31/16        5587          tgurney        Add getIdentifierValues tests\n#    06/01/16        5587          tgurney        Update testGetIdentifierValues\n#    06/17/16        5574          mapeters       Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    11/07/16        5991          bsteffen       Improve vector tests\n#    12/07/16        5981          tgurney        Parameterize\n#    12/15/16        6040          tgurney        Add testGetGridDataWithDbType\n#    12/20/16        5981          tgurney        Add envelope test\n#    10/19/17        6491          tgurney        Add test for dbtype identifier\n#    11/10/17        6491          tgurney        Replace modelName with\n#                                                 parmId.dbId.modelName\n#\n#\n\nfrom __future__ import print_function\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom shapely.geometry import box, Point\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\nimport unittest\n\n\nclass GfeTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for GFE data""""""\n\n    datatype = \'gfe\'\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'parmId.dbId.modelName\', \'Fcst\')\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'parmId.dbId.modelName\', \'Fcst\')\n        req.addIdentifier(\'parmId.dbId.siteId\', params.SITE_ID)\n        self.runTimesTest(req)\n\n    def testGetGridData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'parmId.dbId.modelName\', \'Fcst\')\n        req.addIdentifier(\'parmId.dbId.siteId\', params.SITE_ID)\n        req.setParameters(\'T\')\n        gridDatas = self.runGridDataTest(req)\n        for gridData in gridDatas:\n            self.assertEqual(gridData.getAttribute(\'parmId.dbId.dbType\'), \'\')\n\n    def testGetGridDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'parmId.dbId.modelName\', \'Fcst\')\n        req.addIdentifier(\'parmId.dbId.siteId\', params.SITE_ID)\n        req.setParameters(\'T\')\n        req.setEnvelope(params.ENVELOPE)\n        gridData = self.runGridDataTest(req)\n        if not gridData:\n            raise unittest.SkipTest(\'no data available\')\n        lons, lats = gridData[0].getLatLonCoords()\n        lons = lons.reshape(-1)\n        lats = lats.reshape(-1)\n\n        # Ensure all points are within one degree of the original box\n        # to allow slight margin of error for reprojection distortion.\n        testEnv = box(params.ENVELOPE.bounds[0] - 1, params.ENVELOPE.bounds[1] - 1,\n                      params.ENVELOPE.bounds[2] + 1, params.ENVELOPE.bounds[3] + 1)\n\n        for i in range(len(lons)):\n            self.assertTrue(testEnv.contains(Point(lons[i], lats[i])))\n\n    def testGetVectorGridData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'parmId.dbId.modelName\', \'Fcst\')\n        req.addIdentifier(\'parmId.dbId.siteId\', params.SITE_ID)\n        req.setParameters(\'Wind\')\n        times = DAL.getAvailableTimes(req)\n        if not times:\n            raise unittest.SkipTest(\'No Wind Data available for testing\')\n        gridData = DAL.getGridData(req, [times[0]])\n        rawWind = None\n        rawDir = None\n        for grid in gridData:\n            if grid.getParameter() == \'Wind\':\n                self.assertEqual(grid.getUnit(), \'kts\')\n                rawWind = grid.getRawData()\n            elif grid.getParameter() == \'WindDirection\':\n                self.assertEqual(grid.getUnit(), \'deg\')\n                rawDir = grid.getRawData()\n        self.assertIsNotNone(rawWind, \'Wind Magnitude grid is not present\')\n        self.assertIsNotNone(rawDir, \'Wind Direction grid is not present\')\n        # rawWind and rawDir are numpy.ndarrays so comparison will result in boolean ndarrays.\n        self.assertTrue((rawWind >= 0).all(), \'Wind Speed should not contain negative values\')\n        self.assertTrue((rawDir >= 0).all(), \'Wind Direction should not contain negative values\')\n        self.assertTrue((rawDir <= 360).all(), \'Wind Direction should be less than or equal to 360\')\n        self.assertFalse((rawDir == rawWind).all(), \'Wind Direction should be different from Wind Speed\')\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        requiredIds = set(DAL.getRequiredIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds | requiredIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setLocationNames(params.SITE_ID)\n        req.setParameters(\'T\')\n        return self.runGridDataTest(req)\n\n    def testGetDataWithModelNameEqualsString(self):\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'=\', \'Fcst\')\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'parmId.dbId.modelName\'), \'Fcst\')\n\n    def testGetDataWithDbTypeEqualsString(self):\n        gridData = self._runConstraintTest(\'parmId.dbId.dbType\', \'=\', \'Prac\')\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'parmId.dbId.dbType\'), \'Prac\')\n\n    # No numeric tests since no numeric identifiers are available.\n\n    def testGetDataWithEqualsNone(self):\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'=\', None)\n        for record in gridData:\n            self.assertIsNone(record.getAttribute(\'parmId.dbId.modelName\'))\n\n    def testGetDataWithNotEquals(self):\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'!=\', \'Fcst\')\n        for record in gridData:\n            self.assertNotEqual(record.getAttribute(\'parmId.dbId.modelName\'), \'Fcst\')\n\n    def testGetDataWithNotEqualsNone(self):\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'!=\', None)\n        for record in gridData:\n            self.assertIsNotNone(record.getAttribute(\'parmId.dbId.modelName\'))\n\n    def testGetDataWithInTuple(self):\n        collection = (\'Fcst\', \'SAT\')\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'in\', collection)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'parmId.dbId.modelName\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'Fcst\', \'SAT\']\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'in\', collection)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'parmId.dbId.modelName\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'Fcst\', \'SAT\')\n        generator = (item for item in collection)\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'in\', generator)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'parmId.dbId.modelName\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = (\'Fcst\', \'SAT\')\n        gridData = self._runConstraintTest(\'parmId.dbId.modelName\', \'not in\', collection)\n        for record in gridData:\n            self.assertNotIn(record.getAttribute(\'parmId.dbId.modelName\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'parmId.dbId.modelName\', \'junk\', \'Fcst\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'parmId.dbId.modelName\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'parmId.dbId.modelName\', \'in\', [])\n'"
awips/test/dafTests/testGrid.py,0,"b'#\n# Test DAF support for grid data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          tgurney        Typo in id values test\n#    07/06/16        5728          mapeters       Add advanced query tests\n#    08/03/16        5728          mapeters       Add additional identifiers to testGetDataWith*\n#                                                 tests to shorten run time and prevent EOFError\n#    10/13/16        5942          bsteffen       Test envelopes\n#    11/08/16        5985          tgurney        Skip certain tests when no\n#                                                 data is available\n#    12/07/16        5981          tgurney        Parameterize\n#    01/06/17        5981          tgurney        Skip envelope test when no\n#                                                 data is available\n#\n\nfrom __future__ import print_function\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\nfrom shapely.geometry import box, Point\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\nimport unittest\n\n\nclass GridTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for grid data""""""\n\n    datatype = \'grid\'\n\n    model = \'GFS160\'\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        self.runLocationsTest(req)\n\n    def testGetAvailableLevels(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        self.runLevelsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        req.setLevels(\'2FHAG\')\n        self.runTimesTest(req)\n\n    def testGetGridData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        req.setLevels(\'2FHAG\')\n        req.setParameters(\'T\')\n        self.runGridDataTest(req)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', \'ENSEMBLE\')\n        req.setLevels(\'2FHAG\')\n        req.setParameters(\'T\')\n        idValues = DAL.getIdentifierValues(req, \'info.ensembleId\')\n        self.assertTrue(hasattr(idValues, \'__iter__\'))\n        if idValues:\n            self.assertIn(\'ctl1\', idValues)\n            self.assertIn(\'p1\', idValues)\n            self.assertIn(\'n1\', idValues)\n        else:\n            raise unittest.SkipTest(""no data available"")\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def testGetDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        req.setLevels(\'2FHAG\')\n        req.setParameters(\'T\')\n        req.setEnvelope(params.ENVELOPE)\n        gridData = self.runGridDataTest(req)\n        if len(gridData) == 0:\n            raise unittest.SkipTest(""No data available"")\n        lons, lats = gridData[0].getLatLonCoords()\n        lons = lons.reshape(-1)\n        lats = lats.reshape(-1)\n\n        # Ensure all points are within one degree of the original box\n        # to allow slight margin of error for reprojection distortion.\n        testEnv = box(params.ENVELOPE.bounds[0] - 1, params.ENVELOPE.bounds[1] - 1,\n                      params.ENVELOPE.bounds[2] + 1, params.ENVELOPE.bounds[3] + 1)\n\n        for i in range(len(lons)):\n            self.assertTrue(testEnv.contains(Point(lons[i], lats[i])))\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        req.addIdentifier(\'info.level.masterLevel.name\', \'FHAG\')\n        req.addIdentifier(\'info.level.leveltwovalue\', 3000.0)\n        req.setParameters(\'T\')\n        return self.runGridDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'=\', \'2000.0\')\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithEqualsInt(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'=\', 2000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000)\n\n    def testGetDataWithEqualsLong(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'=\', 2000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000)\n\n    def testGetDataWithEqualsFloat(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'=\', 2000.0)\n        for record in gridData:\n            self.assertEqual(round(record.getAttribute(\'info.level.levelonevalue\'), 1), 2000.0)\n\n    def testGetDataWithEqualsNone(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'=\', None)\n        for record in gridData:\n            self.assertIsNone(record.getAttribute(\'info.level.levelonevalue\'))\n\n    def testGetDataWithNotEquals(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'!=\', 2000.0)\n        for record in gridData:\n            self.assertNotEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithNotEqualsNone(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'!=\', None)\n        for record in gridData:\n            self.assertIsNotNone(record.getAttribute(\'info.level.levelonevalue\'))\n\n    def testGetDataWithGreaterThan(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'>\', 2000.0)\n        for record in gridData:\n            self.assertGreater(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithLessThan(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'<\', 2000.0)\n        for record in gridData:\n            self.assertLess(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithGreaterThanEquals(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'>=\', 2000.0)\n        for record in gridData:\n            self.assertGreaterEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithLessThanEquals(self):\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'<=\', 2000.0)\n        for record in gridData:\n            self.assertLessEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n\n    def testGetDataWithInList(self):\n        collection = [2000.0, 1000.0]\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'in\', collection)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'info.level.levelonevalue\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [2000.0, 1000.0]\n        gridData = self._runConstraintTest(\'info.level.levelonevalue\', \'not in\', collection)\n        for record in gridData:\n            self.assertNotIn(record.getAttribute(\'info.level.levelonevalue\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'info.level.levelonevalue\', \'junk\', \'2000.0\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'info.level.levelonevalue\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'info.level.levelonevalue\', \'in\', [])\n\n    def testGetDataWithLevelOneAndLevelTwoConstraints(self):\n        req = DAL.newDataRequest(self.datatype)\n        levelOneConstraint = RequestConstraint.new(\'>=\', 2000.0)\n        req.addIdentifier(\'info.level.levelonevalue\', levelOneConstraint)\n        levelTwoConstraint = RequestConstraint.new(\'in\', (4000.0, 5000.0))\n        req.addIdentifier(\'info.level.leveltwovalue\', levelTwoConstraint)\n        req.addIdentifier(\'info.datasetId\', self.model)\n        req.addIdentifier(\'info.level.masterLevel.name\', \'FHAG\')\n        req.setParameters(\'T\')\n        gridData = self.runGridDataTest(req)\n        for record in gridData:\n            self.assertGreaterEqual(record.getAttribute(\'info.level.levelonevalue\'), 2000.0)\n            self.assertIn(record.getAttribute(\'info.level.leveltwovalue\'), (4000.0, 5000.0))\n\n    def testGetDataWithMasterLevelNameInConstraint(self):\n        req = DAL.newDataRequest(self.datatype)\n        masterLevelConstraint = RequestConstraint.new(\'in\', (\'FHAG\', \'K\'))\n        req.addIdentifier(\'info.level.masterLevel.name\', masterLevelConstraint)\n        req.addIdentifier(\'info.level.levelonevalue\', 2000.0)\n        req.addIdentifier(\'info.level.leveltwovalue\', 3000.0)\n        req.addIdentifier(\'info.datasetId\', \'GFS160\')\n        req.setParameters(\'T\')\n        gridData = self.runGridDataTest(req)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'info.level.masterLevel.name\'), (\'FHAG\', \'K\'))\n\n    def testGetDataWithDatasetIdInConstraint(self):\n        req = DAL.newDataRequest(self.datatype)\n        # gfs160 is alias for GFS160 in this namespace\n        req.addIdentifier(\'namespace\', \'gfeParamInfo\')\n        datasetIdConstraint = RequestConstraint.new(\'in\', (\'gfs160\', \'HRRR\'))\n        req.addIdentifier(\'info.datasetId\', datasetIdConstraint)\n        req.addIdentifier(\'info.level.masterLevel.name\', \'FHAG\')\n        req.addIdentifier(\'info.level.levelonevalue\', 2000.0)\n        req.addIdentifier(\'info.level.leveltwovalue\', 3000.0)\n        req.setParameters(\'T\')\n        gridData = self.runGridDataTest(req, testSameShape=False)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'info.datasetId\'), (\'gfs160\', \'HRRR\'))\n\n    def testGetDataWithMasterLevelNameLessThanEqualsConstraint(self):\n        req = DAL.newDataRequest(self.datatype)\n        masterLevelConstraint = RequestConstraint.new(\'<=\', \'K\')\n        req.addIdentifier(\'info.level.masterLevel.name\', masterLevelConstraint)\n        req.addIdentifier(\'info.level.levelonevalue\', 2000.0)\n        req.addIdentifier(\'info.level.leveltwovalue\', 3000.0)\n        req.addIdentifier(\'info.datasetId\', \'GFS160\')\n        req.setParameters(\'T\')\n        gridData = self.runGridDataTest(req)\n        for record in gridData:\n            self.assertLessEqual(record.getAttribute(\'info.level.masterLevel.name\'), \'K\')\n\n    def testGetDataWithComplexConstraintAndNamespaceThrowsException(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'namespace\', \'grib\')\n        masterLevelConstraint = RequestConstraint.new(\'<=\', \'K\')\n        req.addIdentifier(\'info.level.masterLevel.name\', masterLevelConstraint)\n        req.addIdentifier(\'info.datasetId\', \'GFS160\')\n        req.setParameters(\'T\')\n        with self.assertRaises(ThriftRequestException) as cm:\n            self.runGridDataTest(req)\n        self.assertIn(\'IncompatibleRequestException\', str(cm.exception))\n        self.assertIn(\'info.level.masterLevel.name\', str(cm.exception))\n'"
awips/test/dafTests/testMaps.py,0,"b'#\n# Test DAF support for maps data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    04/26/16        5587          tgurney        Add identifier values tests\n#    06/13/16        5574          mapeters       Add advanced query tests\n#    06/21/16        5548          tgurney        Skip tests that cause errors\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    01/06/17        5981          tgurney        Do not check data times\n#\n#\n\nfrom __future__ import print_function\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\n\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass MapsTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for maps data""""""\n\n    datatype = \'maps\'\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.county\')\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.county\')\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        req.addIdentifier(\'locationField\', \'cwa\')\n        self.runLocationsTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.county\')\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        req.addIdentifier(\'inLocation\', \'true\')\n        req.addIdentifier(\'locationField\', \'cwa\')\n        req.setLocationNames(\'OAX\')\n        req.addIdentifier(\'cwa\', \'OAX\')\n        req.setParameters(\'countyname\', \'state\', \'fips\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testRequestingTimesThrowsTimeAgnosticDataException(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimeAgnosticTest(req)\n\n    def testGetTableIdentifierValues(self):\n        self.runGetIdValuesTest([\'table\'])\n\n    def testGetGeomFieldIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.county\')\n        idValues = DAL.getIdentifierValues(req, \'geomField\')\n        for idValue in idValues:\n            self.assertTrue(idValue.startswith(\'the_geom\'))\n\n    def testGetGeomFieldIdValuesWithoutTableThrowsException(self):\n        with self.assertRaises(ThriftRequestException):\n            self.runGetIdValuesTest([\'geomField\'])\n\n    def testGetColumnIdValuesWithTable(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.county\')\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        idValues = DAL.getIdentifierValues(req, \'state\')\n        self.assertIn(\'NE\', idValues)\n\n    def testGetColumnIdValuesWithoutTableThrowsException(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        with self.assertRaises(ThriftRequestException):\n            DAL.getIdentifierValues(req, \'state\')\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(\'table\', \'mapdata.ffmp_basins\')\n        req.addIdentifier(\'geomField\', \'the_geom\')\n        req.addIdentifier(\'cwa\', \'OAX\')\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(\'state\', \'reservoir\', \'area_sq_mi\')\n        return self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'state\', \'=\', \'NE\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'state\'), \'NE\')\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'reservoir\', \'=\', 1)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'reservoir\'), 1)\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'reservoir\', \'=\', 1)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'reservoir\'), 1)\n\n    def testGetDataWithEqualsFloat(self):\n        geometryData = self._runConstraintTest(\'area_sq_mi\', \'=\', 5.00)\n        for record in geometryData:\n            self.assertEqual(round(record.getNumber(\'area_sq_mi\'), 2), 5.00)\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'state\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'state\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'state\', \'!=\', \'NE\')\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'state\'), \'NE\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'state\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'state\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'area_sq_mi\', \'>\', 5)\n        for record in geometryData:\n            self.assertGreater(record.getNumber(\'area_sq_mi\'), 5)\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'area_sq_mi\', \'<\', 5)\n        for record in geometryData:\n            self.assertLess(record.getNumber(\'area_sq_mi\'), 5)\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'area_sq_mi\', \'>=\', 5)\n        for record in geometryData:\n            self.assertGreaterEqual(record.getNumber(\'area_sq_mi\'), 5)\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'area_sq_mi\', \'<=\', 5)\n        for record in geometryData:\n            self.assertLessEqual(record.getNumber(\'area_sq_mi\'), 5)\n\n    def testGetDataWithInTuple(self):\n        collection = (\'NE\', \'TX\')\n        geometryData = self._runConstraintTest(\'state\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'NE\', \'TX\']\n        geometryData = self._runConstraintTest(\'state\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'NE\', \'TX\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'state\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'IA\', \'TX\']\n        geometryData = self._runConstraintTest(\'state\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'state\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'state\', \'junk\', \'NE\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'state\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'state\', \'in\', [])\n'"
awips/test/dafTests/testModelSounding.py,0,"b'#\n# Test DAF support for modelsounding data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          bsteffen       Add getIdentifierValues tests\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    11/10/16        5985          tgurney        Mark expected failures prior\n#                                                 to 17.3.1\n#    12/07/16        5981          tgurney        Parameterize\n#    12/19/16        5981          tgurney        Remove pre-17.3 expected fails\n#    12/20/16        5981          tgurney        Add envelope test\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass ModelSoundingTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for modelsounding data""""""\n\n    datatype = ""modelsounding""\n\n    reporttype = ""ETA""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""reportType"", self.reporttype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""reportType"", self.reporttype)\n        req.setLocationNames(params.OBS_STATION)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""reportType"", self.reporttype)\n        req.setLocationNames(params.OBS_STATION)\n        req.setParameters(""temperature"", ""pressure"", ""specHum"", ""sfcPress"", ""temp2"", ""q2"")\n        print(""Testing getGeometryData()"")\n        geomData = DAL.getGeometryData(req)\n        print(""Number of geometry records: "" + str(len(geomData)))\n        print(""Sample geometry data:"")\n        for record in geomData[:self.sampleDataLimit]:\n            print(""level="" + record.getLevel(), end="""")\n            # One dimensional parameters are reported on the 0.0UNKNOWN level.\n            # 2D parameters are reported on MB levels from pressure.\n            if record.getLevel() == ""0.0UNKNOWN"":\n                print("" sfcPress="" + record.getString(""sfcPress"") +\n                      record.getUnit(""sfcPress""), end="""")\n                print("" temp2="" + record.getString(""temp2"") +\n                      record.getUnit(""temp2""), end="""")\n                print("" q2="" + record.getString(""q2"") +\n                      record.getUnit(""q2""), end="""")\n            else:\n                print("" pressure="" + record.getString(""pressure"") +\n                      record.getUnit(""pressure""), end="""")\n                print("" temperature="" + record.getString(""temperature"") +\n                      record.getUnit(""temperature""), end="""")\n                print("" specHum="" + record.getString(""specHum"") +\n                      record.getUnit(""specHum""), end="""")\n            print("" geometry="" + str(record.getGeometry()))\n        print(""getGeometryData() complete\\n\\n"")\n\n    def testGetGeometryDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""reportType"", self.reporttype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setParameters(""temperature"", ""pressure"", ""specHum"", ""sfcPress"", ""temp2"", ""q2"")\n        print(""Testing getGeometryData()"")\n        data = DAL.getGeometryData(req)\n        for item in data:\n            self.assertTrue(params.ENVELOPE.contains(item.getGeometry()))\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.setParameters(\'dataURI\')\n        req.setLocationNames(params.OBS_STATION, \'KORD\', \'KOFK\', \'KLNK\')\n        req.addIdentifier(key, constraint)\n        return self.runGeometryDataTest(req)\n\n    # We can filter on reportType but it is not possible to retrieve the value\n    # of reportType directly. We can look inside the dataURI instead.\n    #\n    # For cases like \'<=\' and \'>\' the best we can do is send the request and\n    # see if it throws back an exception.\n    #\n    # Can also eyeball the number of returned records.\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', \'ETA\')\n        for record in geometryData:\n            self.assertIn(\'/ETA/\', record.getString(\'dataURI\'))\n\n    # No numeric tests since no numeric identifiers are available.\n\n    def testGetDataWithEqualsNone(self):\n        self._runConstraintTest(\'reportType\', \'=\', None)\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', \'ETA\')\n        for record in geometryData:\n            self.assertNotIn(\'/ETA/\', record.getString(\'dataURI\'))\n\n    def testGetDataWithNotEqualsNone(self):\n        self._runConstraintTest(\'reportType\', \'!=\', None)\n\n    def testGetDataWithGreaterThan(self):\n        self._runConstraintTest(\'reportType\', \'>\', \'ETA\')\n\n    def testGetDataWithLessThan(self):\n        self._runConstraintTest(\'reportType\', \'<\', \'ETA\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        self._runConstraintTest(\'reportType\', \'>=\', \'ETA\')\n\n    def testGetDataWithLessThanEquals(self):\n        self._runConstraintTest(\'reportType\', \'<=\', \'ETA\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'ETA\', \'GFS\')\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            dataURI = record.getString(\'dataURI\')\n            self.assertTrue(\'/ETA/\' in dataURI or \'/GFS/\' in dataURI)\n\n    def testGetDataWithInList(self):\n        collection = [\'ETA\', \'GFS\']\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            dataURI = record.getString(\'dataURI\')\n            self.assertTrue(\'/ETA/\' in dataURI or \'/GFS/\' in dataURI)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'ETA\', \'GFS\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', generator)\n        for record in geometryData:\n            dataURI = record.getString(\'dataURI\')\n            self.assertTrue(\'/ETA/\' in dataURI or \'/GFS/\' in dataURI)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'ETA\', \'GFS\']\n        geometryData = self._runConstraintTest(\'reportType\', \'not in\', collection)\n        for record in geometryData:\n            dataURI = record.getString(\'dataURI\')\n            self.assertTrue(\'/ETA/\' not in dataURI and \'/GFS/\' not in dataURI)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'junk\', \'ETA\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'ETA\', \'GFS\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'in\', collection)\n'"
awips/test/dafTests/testObs.py,0,"b'#\n# Test DAF support for obs data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          bsteffen       Add getIdentifierValues tests\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    12/07/16        5981          tgurney        Parameterize\n#    12/20/16        5981          tgurney        Add envelope test\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass ObsTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for obs data""""""\n\n    datatype = ""obs""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(params.OBS_STATION)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(params.OBS_STATION)\n        req.setParameters(""temperature"", ""seaLevelPress"", ""dewpoint"")\n        self.runGeometryDataTest(req)\n\n    def testGetGeometryDataWithEnvelope(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setParameters(""temperature"", ""seaLevelPress"", ""dewpoint"")\n        data = self.runGeometryDataTest(req)\n        for item in data:\n            self.assertTrue(params.ENVELOPE.contains(item.getGeometry()))\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.setParameters(""temperature"", ""reportType"")\n        req.setLocationNames(params.OBS_STATION)\n        req.addIdentifier(key, constraint)\n        return self.runGeometryDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', \'METAR\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'reportType\'), \'METAR\')\n\n    # No numeric tests since no numeric identifiers are available.\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', \'METAR\')\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'reportType\'), \'METAR\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>\', \'METAR\')\n        for record in geometryData:\n            self.assertGreater(record.getString(\'reportType\'), \'METAR\')\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<\', \'METAR\')\n        for record in geometryData:\n            self.assertLess(record.getString(\'reportType\'), \'METAR\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>=\', \'METAR\')\n        for record in geometryData:\n            self.assertGreaterEqual(record.getString(\'reportType\'), \'METAR\')\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<=\', \'METAR\')\n        for record in geometryData:\n            self.assertLessEqual(record.getString(\'reportType\'), \'METAR\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'METAR\', \'SPECI\')\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'METAR\', \'SPECI\']\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'METAR\', \'SPECI\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'METAR\', \'SPECI\']\n        geometryData = self._runConstraintTest(\'reportType\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'junk\', \'METAR\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'METAR\', \'SPECI\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'in\', collection)\n'"
awips/test/dafTests/testProfiler.py,0,"b'#\n# Test DAF support for profiler data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass ProfilerTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for profiler data""""""\n\n    datatype = ""profiler""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""temperature"", ""pressure"", ""uComponent"", ""vComponent"")\n\n        print(""Testing getGeometryData()"")\n\n        geomData = DAL.getGeometryData(req)\n        self.assertIsNotNone(geomData)\n        print(""Number of geometry records: "" + str(len(geomData)))\n        print(""Sample geometry data:"")\n        for record in geomData[:self.sampleDataLimit]:\n            print(""level:"", record.getLevel(), end="""")\n            # One dimensional parameters are reported on the 0.0UNKNOWN level.\n            # 2D parameters are reported on MB levels from pressure.\n            if record.getLevel() == ""0.0UNKNOWN"":\n                print("" temperature="" + record.getString(""temperature"") + record.getUnit(""temperature""), end="""")\n                print("" pressure="" + record.getString(""pressure"") + record.getUnit(""pressure""), end="""")\n            else:\n                print("" uComponent="" + record.getString(""uComponent"") + record.getUnit(""uComponent""), end="""")\n                print("" vComponent="" + record.getString(""vComponent"") + record.getUnit(""vComponent""), end="""")\n            print("" geometry:"", record.getGeometry())\n\n        print(""getGeometryData() complete\\n\\n"")\n'"
awips/test/dafTests/testRadarGraphics.py,0,"b'#\n# Test DAF support for radar graphics data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/25/16        2671          tgurney        Initial creation.\n#    08/31/16        2671          tgurney        Add mesocyclone\n#    09/08/16        2671          tgurney        Add storm track\n#    09/27/16        2671          tgurney        Add hail index\n#    09/30/16        2671          tgurney        Add TVS\n#    12/07/16        5981          tgurney        Parameterize\n#    12/19/16        5981          tgurney        Do not check data times on\n#                                                 returned data\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom awips.test.dafTests import baseRadarTestCase\nfrom awips.test.dafTests import params\n\n\nclass RadarGraphicsTestCase(baseRadarTestCase.BaseRadarTestCase):\n    """"""Test DAF support for radar data""""""\n\n    datatype = \'radar\'\n\n    def runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(\'166\')\n        # TODO: Cannot check datatimes on the result because the times returned\n        # by getAvailableTimes have level = -1.0, while the time on the actual\n        # data has the correct level set (>= 0.0).\n        return self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataMeltingLayer(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(\'166\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataMesocyclone(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(\'141\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataStormTrack(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(\'58\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataHailIndex(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(\'59\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetGeometryDataTVS(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(\'61\')\n        self.runGeometryDataTest(req, checkDataTimes=False)\n'"
awips/test/dafTests/testRadarGrid.py,0,"b'#\n# Test DAF support for radar grid data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/25/16        2671          tgurney        Initial creation\n#\n#\n\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseRadarTestCase\nfrom awips.test.dafTests import params\n\n\nclass RadarTestCase(baseRadarTestCase.BaseRadarTestCase):\n    """"""Test DAF support for radar data""""""\n\n    datatype = \'radar\'\n\n    parameterList = [\'94\']\n\n    def runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(*self.parameterList)\n        # Don\'t test shapes since they may differ.\n        return self.runGridDataTest(req, testSameShape=False)\n\n    def testGetGridData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        req.setLocationNames(self.radarLoc)\n        req.setParameters(*self.parameterList)\n        # Don\'t test shapes since they may differ.\n        self.runGridDataTest(req, testSameShape=False)\n'"
awips/test/dafTests/testRadarSpatial.py,0,"b'#\n# Test DAF support for radar_spatial data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    05/26/16        5587          njensen        Added testGetIdentifierValues()\n#    06/01/16        5587          tgurney        Move testIdentifiers() to\n#                                                 superclass\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    12/07/16        5981          tgurney        Parameterize\n#    01/06/17        5981          tgurney        Do not check data times\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\nfrom awips.test.dafTests import baseDafTestCase\nfrom awips.test.dafTests import params\n\n\nclass RadarSpatialTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for radar_spatial data""""""\n\n    datatype = ""radar_spatial""\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setEnvelope(params.ENVELOPE)\n        self.runLocationsTest(req)\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetIdentifierValues(self):\n        self.runGetIdValuesTest([\'wfo_id\'])\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(""TORD"", ""TMDW"")\n        req.setParameters(""wfo_id"", ""name"", ""elevmeter"")\n        self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testRequestingTimesThrowsTimeAgnosticDataException(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runTimeAgnosticTest(req)\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(\'elevmeter\', \'eqp_elv\', \'wfo_id\', \'immutablex\')\n        return self.runGeometryDataTest(req, checkDataTimes=False)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'wfo_id\', \'=\', params.SITE_ID)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'wfo_id\'), params.SITE_ID)\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'immutablex\', \'=\', 57)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'immutablex\'), 57)\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'immutablex\', \'=\', 57)\n        for record in geometryData:\n            self.assertEqual(record.getNumber(\'immutablex\'), 57)\n\n    def testGetDataWithEqualsFloat(self):\n        geometryData = self._runConstraintTest(\'immutablex\', \'=\', 57.0)\n        for record in geometryData:\n            self.assertEqual(round(record.getNumber(\'immutablex\'), 1), 57.0)\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'wfo_id\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'wfo_id\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'wfo_id\', \'!=\', params.SITE_ID)\n        for record in geometryData:\n            self.assertNotEquals(record.getString(\'wfo_id\'), params.SITE_ID)\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'wfo_id\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'wfo_id\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'elevmeter\', \'>\', 1000)\n        for record in geometryData:\n            self.assertGreater(record.getNumber(\'elevmeter\'), 1000)\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'elevmeter\', \'<\', 1000)\n        for record in geometryData:\n            self.assertLess(record.getNumber(\'elevmeter\'), 1000)\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'eqp_elv\', \'>=\', 1295)\n        for record in geometryData:\n            self.assertGreaterEqual(record.getNumber(\'eqp_elv\'), 1295)\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'eqp_elv\', \'<=\', 138)\n        for record in geometryData:\n            self.assertLessEqual(record.getNumber(\'eqp_elv\'), 138)\n\n    def testGetDataWithInTuple(self):\n        collection = (params.SITE_ID, \'GID\')\n        geometryData = self._runConstraintTest(\'wfo_id\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'wfo_id\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [params.SITE_ID, \'GID\']\n        geometryData = self._runConstraintTest(\'wfo_id\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'wfo_id\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (params.SITE_ID, \'GID\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'wfo_id\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'wfo_id\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [params.SITE_ID, \'GID\']\n        geometryData = self._runConstraintTest(\'wfo_id\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'wfo_id\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'wfo_id\', \'junk\', params.SITE_ID)\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'wfo_id\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'wfo_id\', \'in\', [])\n'"
awips/test/dafTests/testRequestConstraint.py,0,"b'#\n# Unit tests for Python implementation of RequestConstraint\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/22/16        2416          tgurney        Initial creation\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nimport unittest\n\n\nclass RequestConstraintTestCase(unittest.TestCase):\n\n    def _newRequestConstraint(self, constraintType, constraintValue):\n        constraint = RequestConstraint()\n        constraint.constraintType = constraintType\n        constraint.constraintValue = constraintValue\n        return constraint\n\n    def testEvaluateEquals(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'=\', 3).evaluate(3))\n        self.assertTrue(new(\'=\', 3).evaluate(\'3\'))\n        self.assertTrue(new(\'=\', \'3\').evaluate(3))\n        self.assertTrue(new(\'=\', 12345).evaluate(12345))\n        self.assertTrue(new(\'=\', \'a\').evaluate(\'a\'))\n        self.assertTrue(new(\'=\', \'a\').evaluate(u\'a\'))\n        self.assertTrue(new(\'=\', 1.0001).evaluate(2.0 - 0.999999))\n        self.assertTrue(new(\'=\', 1.00001).evaluate(1))\n        self.assertFalse(new(\'=\', \'a\').evaluate([\'a\']))\n        self.assertFalse(new(\'=\', \'a\').evaluate([\'b\']))\n        self.assertFalse(new(\'=\', 3).evaluate(4))\n        self.assertFalse(new(\'=\', 4).evaluate(3))\n        self.assertFalse(new(\'=\', \'a\').evaluate(\'z\'))\n\n    def testEvaluateNotEquals(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'!=\', \'a\').evaluate([\'a\']))\n        self.assertTrue(new(\'!=\', \'a\').evaluate([\'b\']))\n        self.assertTrue(new(\'!=\', 3).evaluate(4))\n        self.assertTrue(new(\'!=\', 4).evaluate(3))\n        self.assertTrue(new(\'!=\', \'a\').evaluate(\'z\'))\n        self.assertFalse(new(\'!=\', 3).evaluate(\'3\'))\n        self.assertFalse(new(\'!=\', \'3\').evaluate(3))\n        self.assertFalse(new(\'!=\', 3).evaluate(3))\n        self.assertFalse(new(\'!=\', 12345).evaluate(12345))\n        self.assertFalse(new(\'!=\', \'a\').evaluate(\'a\'))\n        self.assertFalse(new(\'!=\', \'a\').evaluate(u\'a\'))\n        self.assertFalse(new(\'!=\', 1.0001).evaluate(2.0 - 0.9999))\n\n    def testEvaluateGreaterThan(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'>\', 1.0001).evaluate(1.0002))\n        self.assertTrue(new(\'>\', \'a\').evaluate(\'b\'))\n        self.assertTrue(new(\'>\', 3).evaluate(4))\n        self.assertFalse(new(\'>\', 20).evaluate(3))\n        self.assertFalse(new(\'>\', 12345).evaluate(12345))\n        self.assertFalse(new(\'>\', \'a\').evaluate(\'a\'))\n        self.assertFalse(new(\'>\', \'z\').evaluate(\'a\'))\n        self.assertFalse(new(\'>\', 4).evaluate(3))\n\n    def testEvaluateGreaterThanEquals(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'>=\', 3).evaluate(3))\n        self.assertTrue(new(\'>=\', 12345).evaluate(12345))\n        self.assertTrue(new(\'>=\', \'a\').evaluate(\'a\'))\n        self.assertTrue(new(\'>=\', 1.0001).evaluate(1.0002))\n        self.assertTrue(new(\'>=\', \'a\').evaluate(\'b\'))\n        self.assertTrue(new(\'>=\', 3).evaluate(20))\n        self.assertFalse(new(\'>=\', 1.0001).evaluate(1.0))\n        self.assertFalse(new(\'>=\', \'z\').evaluate(\'a\'))\n        self.assertFalse(new(\'>=\', 40).evaluate(3))\n\n    def testEvaluateLessThan(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'<\', \'z\').evaluate(\'a\'))\n        self.assertTrue(new(\'<\', 30).evaluate(4))\n        self.assertFalse(new(\'<\', 3).evaluate(3))\n        self.assertFalse(new(\'<\', 12345).evaluate(12345))\n        self.assertFalse(new(\'<\', \'a\').evaluate(\'a\'))\n        self.assertFalse(new(\'<\', 1.0001).evaluate(1.0002))\n        self.assertFalse(new(\'<\', \'a\').evaluate(\'b\'))\n        self.assertFalse(new(\'<\', 3).evaluate(40))\n\n    def testEvaluateLessThanEquals(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'<=\', \'z\').evaluate(\'a\'))\n        self.assertTrue(new(\'<=\', 20).evaluate(3))\n        self.assertTrue(new(\'<=\', 3).evaluate(3))\n        self.assertTrue(new(\'<=\', 12345).evaluate(12345))\n        self.assertTrue(new(\'<=\', \'a\').evaluate(\'a\'))\n        self.assertFalse(new(\'<=\', 1.0001).evaluate(1.0002))\n        self.assertFalse(new(\'<=\', \'a\').evaluate(\'b\'))\n        self.assertFalse(new(\'<=\', 4).evaluate(30))\n\n    def testEvaluateIsNull(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'=\', None).evaluate(None))\n        self.assertTrue(new(\'=\', None).evaluate(\'null\'))\n        self.assertFalse(new(\'=\', None).evaluate(()))\n        self.assertFalse(new(\'=\', None).evaluate(0))\n        self.assertFalse(new(\'=\', None).evaluate(False))\n\n    def testEvaluateIsNotNull(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'!=\', None).evaluate(()))\n        self.assertTrue(new(\'!=\', None).evaluate(0))\n        self.assertTrue(new(\'!=\', None).evaluate(False))\n        self.assertFalse(new(\'!=\', None).evaluate(None))\n        self.assertFalse(new(\'!=\', None).evaluate(\'null\'))\n\n    def testEvaluateIn(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'in\', [3]).evaluate(3))\n        self.assertTrue(new(\'in\', [\'a\', \'b\', 3]).evaluate(3))\n        self.assertTrue(new(\'in\', \'a\').evaluate(\'a\'))\n        self.assertTrue(new(\'in\', [3, 4, 5]).evaluate(\'5\'))\n        self.assertTrue(new(\'in\', [1.0001, 2, 3]).evaluate(2.0 - 0.9999))\n        self.assertFalse(new(\'in\', [\'a\', \'b\', \'c\']).evaluate(\'d\'))\n        self.assertFalse(new(\'in\', \'a\').evaluate(\'b\'))\n\n    def testEvaluateNotIn(self):\n        new = RequestConstraint.new\n        self.assertTrue(new(\'not in\', [\'a\', \'b\', \'c\']).evaluate(\'d\'))\n        self.assertTrue(new(\'not in\', [3, 4, 5]).evaluate(6))\n        self.assertTrue(new(\'not in\', \'a\').evaluate(\'b\'))\n        self.assertFalse(new(\'not in\', [3]).evaluate(3))\n        self.assertFalse(new(\'not in\', [\'a\', \'b\', 3]).evaluate(3))\n        self.assertFalse(new(\'not in\', \'a\').evaluate(\'a\'))\n        self.assertFalse(new(\'not in\', [1.0001, 2, 3]).evaluate(2.0 - 0.9999))\n\n    def testEvaluateBetween(self):\n        # cannot make ""between"" with RequestConstraint.new()\n        new = self._newRequestConstraint\n        self.assertTrue(new(\'BETWEEN\', \'1--1\').evaluate(1))\n        self.assertTrue(new(\'BETWEEN\', \'1--10\').evaluate(1))\n        self.assertTrue(new(\'BETWEEN\', \'1--10\').evaluate(5))\n        self.assertTrue(new(\'BETWEEN\', \'1--10\').evaluate(10))\n        self.assertTrue(new(\'BETWEEN\', \'1.0--1.1\').evaluate(1.0))\n        self.assertTrue(new(\'BETWEEN\', \'1.0--1.1\').evaluate(1.05))\n        self.assertTrue(new(\'BETWEEN\', \'1.0--1.1\').evaluate(1.1))\n        self.assertTrue(new(\'BETWEEN\', \'a--x\').evaluate(\'a\'))\n        self.assertTrue(new(\'BETWEEN\', \'a--x\').evaluate(\'j\'))\n        self.assertTrue(new(\'BETWEEN\', \'a--x\').evaluate(\'x\'))\n        self.assertFalse(new(\'BETWEEN\', \'1--1\').evaluate(2))\n        self.assertFalse(new(\'BETWEEN\', \'1--2\').evaluate(10))\n        self.assertFalse(new(\'BETWEEN\', \'1--10\').evaluate(0))\n        self.assertFalse(new(\'BETWEEN\', \'1--10\').evaluate(11))\n        self.assertFalse(new(\'BETWEEN\', \'1.0--1.1\').evaluate(0.99))\n        self.assertFalse(new(\'BETWEEN\', \'1.0--1.1\').evaluate(1.11))\n        self.assertFalse(new(\'BETWEEN\', \'a--x\').evaluate(\' \'))\n        self.assertFalse(new(\'BETWEEN\', \'a--x\').evaluate(\'z\'))\n\n'"
awips/test/dafTests/testSatellite.py,0,"b'#\n# Test DAF support for satellite data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    04/26/16        5587          tgurney        Move identifier values tests\n#                                                 out of base class\n#    06/01/16        5587          tgurney        Update testGetIdentifierValues\n#    06/07/16        5574          tgurney        Add advanced query tests\n#    06/13/16        5574          tgurney        Typo\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass SatelliteTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for satellite data""""""\n\n    datatype = ""satellite""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(""West CONUS"")\n        self.runTimesTest(req)\n\n    def testGetGridData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""Imager 11 micron IR"")\n        req.setLocationNames(""West CONUS"")\n        self.runGridDataTest(req)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        requiredIds = set(DAL.getRequiredIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds | requiredIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(""Imager 11 micron IR"")\n        req.setLocationNames(""West CONUS"")\n        return self.runGridDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'=\', \'Composite\')\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithEqualsInt(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'=\', 1000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'creatingEntity\'), 1000)\n\n    def testGetDataWithEqualsLong(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'=\', 1000)\n        for record in gridData:\n            self.assertEqual(record.getAttribute(\'creatingEntity\'), 1000)\n\n    def testGetDataWithEqualsFloat(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'=\', 1.0)\n        for record in gridData:\n            self.assertEqual(round(record.getAttribute(\'creatingEntity\'), 1), 1.0)\n\n    def testGetDataWithEqualsNone(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'=\', None)\n        for record in gridData:\n            self.assertIsNone(record.getAttribute(\'creatingEntity\'))\n\n    def testGetDataWithNotEquals(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'!=\', \'Composite\')\n        for record in gridData:\n            self.assertNotEqual(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithNotEqualsNone(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'!=\', None)\n        for record in gridData:\n            self.assertIsNotNone(record.getAttribute(\'creatingEntity\'))\n\n    def testGetDataWithGreaterThan(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'>\', \'Composite\')\n        for record in gridData:\n            self.assertGreater(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithLessThan(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'<\', \'Composite\')\n        for record in gridData:\n            self.assertLess(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'>=\', \'Composite\')\n        for record in gridData:\n            self.assertGreaterEqual(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithLessThanEquals(self):\n        gridData = self._runConstraintTest(\'creatingEntity\', \'<=\', \'Composite\')\n        for record in gridData:\n            self.assertLessEqual(record.getAttribute(\'creatingEntity\'), \'Composite\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'Composite\', \'Miscellaneous\')\n        gridData = self._runConstraintTest(\'creatingEntity\', \'in\', collection)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'creatingEntity\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = (\'Composite\', \'Miscellaneous\')\n        gridData = self._runConstraintTest(\'creatingEntity\', \'in\', collection)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'creatingEntity\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'Composite\', \'Miscellaneous\')\n        generator = (item for item in collection)\n        gridData = self._runConstraintTest(\'creatingEntity\', \'in\', generator)\n        for record in gridData:\n            self.assertIn(record.getAttribute(\'creatingEntity\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = (\'Composite\', \'Miscellaneous\')\n        gridData = self._runConstraintTest(\'creatingEntity\', \'not in\', collection)\n        for record in gridData:\n            self.assertNotIn(record.getAttribute(\'creatingEntity\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'creatingEntity\', \'junk\', \'Composite\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'creatingEntity\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'creatingEntity\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'Composite\', \'Miscellaneous\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'creatingEntity\', \'in\', collection)\n'"
awips/test/dafTests/testSfcObs.py,0,"b'#\n# Test DAF support for sfcobs data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    06/09/16        5587          bsteffen       Add getIdentifierValues tests\n#    06/13/16        5574          tgurney        Add advanced query tests\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    01/20/17        6095          tgurney        Add null identifiers test\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass SfcObsTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for sfcobs data""""""\n\n    datatype = ""sfcobs""\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(""14547"")\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(""14547"")\n        req.setParameters(""temperature"", ""seaLevelPress"", ""dewpoint"")\n        self.runGeometryDataTest(req)\n\n    def testGetGeometryDataNullIdentifiers(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setLocationNames(""14547"")\n        req.setParameters(""temperature"", ""seaLevelPress"", ""dewpoint"")\n        req.identifiers = None\n        self.runGeometryDataTest(req)\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(""temperature"", ""reportType"")\n        return self.runGeometryDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', \'1004\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', 1004)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', 1004)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'reportType\'), \'1004\')\n\n    # No float test because no float identifiers are available\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', 1004)\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'reportType\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>\', 1004)\n        for record in geometryData:\n            self.assertGreater(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<\', 1004)\n        for record in geometryData:\n            self.assertLess(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'>=\', 1004)\n        for record in geometryData:\n            self.assertGreaterEqual(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'reportType\', \'<=\', 1004)\n        for record in geometryData:\n            self.assertLessEqual(record.getString(\'reportType\'), \'1004\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'1004\', \'1005\')\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'1004\', \'1005\']\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'1004\', \'1005\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'reportType\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'1004\', \'1005\']\n        geometryData = self._runConstraintTest(\'reportType\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'reportType\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'junk\', \'1004\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'reportType\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'1004\', \'1005\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'reportType\', \'in\', collection)\n'"
awips/test/dafTests/testTopo.py,0,"b'#\n# Test DAF support for topo data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    05/26/16        5587          tgurney        Add test for\n#                                                 getIdentifierValues()\n#    06/01/16        5587          tgurney        Update testGetIdentifierValues\n#    07/18/17        6253          randerso       Removed referenced to GMTED\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom awips.ThriftClient import ThriftRequestException\nimport shapely.geometry\n\nfrom awips.test.dafTests import baseDafTestCase\n\n\nclass TopoTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for topo data""""""\n\n    datatype = ""topo""\n\n    def testGetGridData(self):\n        print(""defaultTopo"")\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""group"", ""/"")\n        req.addIdentifier(""dataset"", ""full"")\n        poly = shapely.geometry.LinearRing(((-70, 40), (-71, 40), (-71, 42), (-70, 42)))\n        req.setEnvelope(poly)\n        gridData = DAL.getGridData(req)\n        self.assertIsNotNone(gridData)\n        print(""Number of grid records: "" + str(len(gridData)))\n        print(""Sample grid data shape:\\n"" + str(gridData[0].getRawData().shape) + ""\\n"")\n        print(""Sample grid data:\\n"" + str(gridData[0].getRawData()) + ""\\n"")\n\n        for topoFile in [""gtopo30""]:\n            print(""\\n"" + topoFile)\n            req.addIdentifier(""topoFile"", topoFile)\n            gridData = DAL.getGridData(req)\n            self.assertIsNotNone(gridData)\n            print(""Number of grid records: "" + str(len(gridData)))\n            print(""Sample grid data shape:\\n"" + str(gridData[0].getRawData().shape) + ""\\n"")\n            print(""Sample grid data:\\n"" + str(gridData[0].getRawData()) + ""\\n"")\n\n    def testRequestingTooMuchDataThrowsResponseTooLargeException(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.addIdentifier(""group"", ""/"")\n        req.addIdentifier(""dataset"", ""full"")\n        points = ((-180, 90), (180, 90), (180, -90), (-180, -90))\n        poly = shapely.geometry.LinearRing(points)\n        req.setEnvelope(poly)\n\n        with self.assertRaises(ThriftRequestException) as cm:\n            DAL.getGridData(req)\n        self.assertIn(\'ResponseTooLargeException\', str(cm.exception))\n\n    def testGetIdentifierValues(self):\n        req = DAL.newDataRequest(self.datatype)\n        optionalIds = set(DAL.getOptionalIdentifiers(req))\n        requiredIds = set(DAL.getRequiredIdentifiers(req))\n        self.runGetIdValuesTest(optionalIds | requiredIds)\n\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n'"
awips/test/dafTests/testWarning.py,0,"b'#\n# Test DAF support for warning data\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    01/19/16        4795          mapeters       Initial Creation.\n#    04/11/16        5548          tgurney        Cleanup\n#    04/18/16        5548          tgurney        More cleanup\n#    04/26/16        5587          tgurney        Add identifier values tests\n#    06/08/16        5574          tgurney        Add advanced query tests\n#    06/10/16        5548          tgurney        Clean up references to name\n#                                                 of data type\n#    06/13/16        5574          tgurney        Fix checks for None\n#    06/21/16        5548          tgurney        Skip tests that cause errors\n#    06/30/16        5725          tgurney        Add test for NOT IN\n#    12/12/16        5981          tgurney        Improve test performance\n#\n#\n\nfrom __future__ import print_function\nfrom awips.dataaccess import DataAccessLayer as DAL\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataquery.requests import RequestConstraint\n\nfrom awips.test.dafTests import baseDafTestCase\nimport unittest\n\n\nclass WarningTestCase(baseDafTestCase.DafTestCase):\n    """"""Test DAF support for warning data""""""\n\n    datatype = ""warning""\n\n    def _getLocationNames(self):\n        req = DAL.newDataRequest()\n        req.setDatatype(self.datatype)\n        return DAL.getAvailableLocationNames(req)\n\n    def _getAllRecords(self):\n        req = DAL.newDataRequest()\n        req.setDatatype(self.datatype)\n        req.setParameters(\'id\')\n        return DAL.getGeometryData(req)\n\n    def testGetAvailableParameters(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runParametersTest(req)\n\n    def testGetAvailableLocations(self):\n        req = DAL.newDataRequest(self.datatype)\n        self.runLocationsTest(req)\n\n    def testGetAvailableTimes(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""etn"", ""wmoid"")\n        self.runTimesTest(req)\n\n    def testGetGeometryData(self):\n        req = DAL.newDataRequest(self.datatype)\n        req.setParameters(""etn"", ""wmoid"")\n        self.runGeometryDataTest(req)\n\n    def testFilterOnLocationName(self):\n        allLocationNames = self._getLocationNames()\n        if len(allLocationNames) == 0:\n            errmsg = ""No {0} data exists on {1}. Try again with {0} data.""\n            raise unittest.SkipTest(errmsg.format(self.datatype, DAL.THRIFT_HOST))\n        testCount = 3  # number of different location names to test\n        for locationName in allLocationNames[:testCount]:\n            req = DAL.newDataRequest()\n            req.setDatatype(self.datatype)\n            req.setParameters(\'id\')\n            req.setLocationNames(locationName)\n            geomData = DAL.getGeometryData(req)\n            for geom in geomData:\n                self.assertEqual(geom.getLocationName(), locationName)\n\n    def testFilterOnNonexistentLocationReturnsEmpty(self):\n        req = DAL.newDataRequest()\n        req.setDatatype(self.datatype)\n        req.setParameters(\'id\')\n        req.setLocationNames(\'ZZZZ\')\n        self.assertEqual(len(DAL.getGeometryData(req)), 0)\n\n    def testFilterOnInvalidLocationThrowsIncompatibleRequestException(self):\n        req = DAL.newDataRequest()\n        req.setDatatype(self.datatype)\n        req.setParameters(\'id\')\n        req.setLocationNames(\') and 0=1\')\n        with self.assertRaises(Exception) as cm:\n            DAL.getGeometryData(req)\n        self.assertIn(\'IncompatibleRequestException\', str(cm.exception))\n\n    def testGetColumnIdentifierValues(self):\n        self.runGetIdValuesTest([\'act\'])\n\n    @unittest.skip(\'avoid EDEX error\')\n    def testGetInvalidIdentifierValuesThrowsException(self):\n        self.runInvalidIdValuesTest()\n\n    @unittest.skip(\'avoid EDEX error\')\n    def testGetNonexistentIdentifierValuesThrowsException(self):\n        self.runNonexistentIdValuesTest()\n\n    def _runConstraintTest(self, key, operator, value):\n        req = DAL.newDataRequest(self.datatype)\n        constraint = RequestConstraint.new(operator, value)\n        req.addIdentifier(key, constraint)\n        req.setParameters(""etn"", ""wmoid"", ""sig"")\n        return self.runGeometryDataTest(req)\n\n    def testGetDataWithEqualsString(self):\n        geometryData = self._runConstraintTest(\'sig\', \'=\', \'Y\')\n        for record in geometryData:\n            self.assertEqual(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithEqualsInt(self):\n        geometryData = self._runConstraintTest(\'etn\', \'=\', 1000)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'etn\'), \'1000\')\n\n    def testGetDataWithEqualsLong(self):\n        geometryData = self._runConstraintTest(\'etn\', \'=\', 1000)\n        for record in geometryData:\n            self.assertEqual(record.getString(\'etn\'), \'1000\')\n\n    def testGetDataWithEqualsFloat(self):\n        geometryData = self._runConstraintTest(\'etn\', \'=\', 1.0)\n        for record in geometryData:\n            self.assertEqual(round(float(record.getString(\'etn\')), 1), 1.0)\n\n    def testGetDataWithEqualsNone(self):\n        geometryData = self._runConstraintTest(\'sig\', \'=\', None)\n        for record in geometryData:\n            self.assertEqual(record.getType(\'sig\'), \'NULL\')\n\n    def testGetDataWithNotEquals(self):\n        geometryData = self._runConstraintTest(\'sig\', \'!=\', \'Y\')\n        for record in geometryData:\n            self.assertNotEqual(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithNotEqualsNone(self):\n        geometryData = self._runConstraintTest(\'sig\', \'!=\', None)\n        for record in geometryData:\n            self.assertNotEqual(record.getType(\'sig\'), \'NULL\')\n\n    def testGetDataWithGreaterThan(self):\n        geometryData = self._runConstraintTest(\'sig\', \'>\', \'Y\')\n        for record in geometryData:\n            self.assertGreater(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithLessThan(self):\n        geometryData = self._runConstraintTest(\'sig\', \'<\', \'Y\')\n        for record in geometryData:\n            self.assertLess(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithGreaterThanEquals(self):\n        geometryData = self._runConstraintTest(\'sig\', \'>=\', \'Y\')\n        for record in geometryData:\n            self.assertGreaterEqual(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithLessThanEquals(self):\n        geometryData = self._runConstraintTest(\'sig\', \'<=\', \'Y\')\n        for record in geometryData:\n            self.assertLessEqual(record.getString(\'sig\'), \'Y\')\n\n    def testGetDataWithInTuple(self):\n        collection = (\'Y\', \'A\')\n        geometryData = self._runConstraintTest(\'sig\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'sig\'), collection)\n\n    def testGetDataWithInList(self):\n        collection = [\'Y\', \'A\']\n        geometryData = self._runConstraintTest(\'sig\', \'in\', collection)\n        for record in geometryData:\n            self.assertIn(record.getString(\'sig\'), collection)\n\n    def testGetDataWithInGenerator(self):\n        collection = (\'Y\', \'A\')\n        generator = (item for item in collection)\n        geometryData = self._runConstraintTest(\'sig\', \'in\', generator)\n        for record in geometryData:\n            self.assertIn(record.getString(\'sig\'), collection)\n\n    def testGetDataWithNotInList(self):\n        collection = [\'Y\', \'W\']\n        geometryData = self._runConstraintTest(\'sig\', \'not in\', collection)\n        for record in geometryData:\n            self.assertNotIn(record.getString(\'sig\'), collection)\n\n    def testGetDataWithInvalidConstraintTypeThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'sig\', \'junk\', \'Y\')\n\n    def testGetDataWithInvalidConstraintValueThrowsException(self):\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'sig\', \'=\', {})\n\n    def testGetDataWithEmptyInConstraintThrowsException(self):\n        with self.assertRaises(ValueError):\n            self._runConstraintTest(\'sig\', \'in\', [])\n\n    def testGetDataWithNestedInConstraintThrowsException(self):\n        collection = (\'Y\', \'A\', ())\n        with self.assertRaises(TypeError):\n            self._runConstraintTest(\'sig\', \'in\', collection)\n'"
dynamicserialize/dstypes/com/__init__.py,0,"b""\n__all__ = [\n            'raytheon',\n            'vividsolutions'\n          ]\n"""
dynamicserialize/dstypes/gov/__init__.py,0,"b""\n__all__ = [\n            'noaa'\n          ]\n"""
dynamicserialize/dstypes/java/__init__.py,0,"b""\n__all__ = [\n            'awt',\n            'lang',\n            'sql',\n            'util'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/__init__.py,0,"b""\n__all__ = [\n            'uf'\n          ]\n"""
dynamicserialize/dstypes/com/vividsolutions/__init__.py,0,"b""\n__all__ = [\n            'jts'\n          ]\n"""
dynamicserialize/dstypes/gov/noaa/__init__.py,0,"b""\n__all__ = [\n            'nws'\n          ]\n"""
dynamicserialize/dstypes/java/awt/Point.py,0,"b'#\n# Custom python class representing a java.awt.Point.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen       Initial Creation.\n#\n#\n\n\nclass Point(object):\n\n    def __init__(self):\n        self.x = None\n        self.y = None\n\n    def __str__(self):\n        return str((self.x, self.y))\n\n    def __repr__(self):\n        return self.__str__()\n\n    def getX(self):\n        return self.x\n\n    def getY(self):\n        return self.y\n\n    def setX(self, x):\n        self.x = x\n\n    def setY(self, y):\n        self.y = y\n'"
dynamicserialize/dstypes/java/awt/__init__.py,0,"b""#\n# Package definition for java.awt\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen       Initial Creation.\n#\n\n__all__ = [\n            'Point'\n          ]\n\nfrom .Point import Point\n"""
dynamicserialize/dstypes/java/lang/StackTraceElement.py,0,"b'\n\nclass StackTraceElement(object):\n\n    def __init__(self):\n        self.declaringClass = None\n        self.methodName = None\n        self.fileName = None\n        self.lineNumber = 0\n\n    def getDeclaringClass(self):\n        return self.declaringClass\n\n    def setDeclaringClass(self, clz):\n        self.declaringClass = clz\n\n    def getMethodName(self):\n        return self.methodName\n\n    def setMethodName(self, methodName):\n        self.methodName = methodName\n\n    def getFileName(self):\n        return self.fileName\n\n    def setFileName(self, filename):\n        self.fileName = filename\n\n    def getLineNumber(self):\n        return self.lineNumber\n\n    def setLineNumber(self, lineNumber):\n        self.lineNumber = int(lineNumber)\n\n    def isNativeMethod(self):\n        return self.lineNumber == -2\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        msg = self.declaringClass.decode(\'cp437\') + ""."" + self.methodName.decode(\'cp437\')\n        if self.isNativeMethod():\n            msg += ""(Native Method)""\n        elif self.fileName is not None and self.lineNumber >= 0:\n            msg += ""("" + self.fileName.decode(\'cp437\') + "":"" + str(self.lineNumber) + "")""\n        elif self.fileName is not None:\n            msg += ""("" + self.fileName.decode(\'cp437\') + "")""\n        else:\n            msg += ""(Unknown Source)""\n        return msg\n'"
dynamicserialize/dstypes/java/lang/__init__.py,0,"b""\n__all__ = [\n            'StackTraceElement'\n          ]\n\nfrom .StackTraceElement import StackTraceElement\n"""
dynamicserialize/dstypes/java/sql/Timestamp.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/??                      xxxxxxxx       Initial Creation.\n#    06/24/15        4480          dgilling       implement based on Date class.\n#    Jun 23, 2016    5696          rjpeter        Make String version match java.\n#\n\nfrom dynamicserialize.dstypes.java.util import Date\nfrom time import gmtime, strftime\n\n\nclass Timestamp(Date):\n\n    def __init__(self, time=None):\n        super(Timestamp, self).__init__(time)\n\n    def __repr__(self):\n        return strftime(""%Y-%m-%d %H:%M:%S."", gmtime(self.time/1000.0)) + \\\n               \'{:03d}\'.format(self.time % 1000)\n'"
dynamicserialize/dstypes/java/sql/__init__.py,0,"b""\n__all__ = [\n            'Timestamp'\n          ]\n\nfrom .Timestamp import Timestamp\n"""
dynamicserialize/dstypes/java/util/Calendar.py,0,"b'# Custom python class representing a java.util.GregorianCalendar.\n#\n# This is a stripped-down version of the class that only supports\n# minimal methods for serialization.\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/29/10                      wldougher     Initial Creation.\n#\n\nfrom . import GregorianCalendar\n\n\nclass Calendar(object):\n\n    def __init__(self):\n        self.time = None\n\n    # Methods from the real class that we typically use\n    @staticmethod\n    def getInstance():\n        return GregorianCalendar()\n\n    def getTimeInMillis(self):\n        return self.time\n\n    def setTimeInMillis(self, timeInMillis):\n        self.time = timeInMillis\n'"
dynamicserialize/dstypes/java/util/Date.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    04/28/2015      4027          randerso       Added optional construction parameter to set the time\n#    06/26/2015      4480          dgilling       Implement __eq__ and __hash__.\n#\n\nfrom time import gmtime, strftime\n\n\nclass Date(object):\n\n    def __init__(self, timeInMillis=None):\n        self.time = timeInMillis\n\n    def getTime(self):\n        return self.time\n\n    def setTime(self, timeInMillis):\n        self.time = timeInMillis\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return strftime(""%b %d %y %H:%M:%S GMT"", gmtime(self.time/1000.0))\n\n    def __eq__(self, other):\n        return self.time == other.time\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.time)\n'"
dynamicserialize/dstypes/java/util/EnumSet.py,0,"b'##\n# NOTE: Please do not ever use this class unless you really must. It is not\n# designed to be directly accessed from client code. Hide its use from end-\n# users as best as you can.\n##\n\n##\n# IMPLEMENTATION DETAILS:\n# This class is an attempt to simulate Java\'s EnumSet class. When creating\n# a new instance of this class, you must specify the name of the Java enum\n# contained within as this is needed for serialization. Do not append the\n# ""dynamicserialize.dstypes"" portion of the Python package to the supplied\n# class name as Java won\'t know what class that is when deserializing.\n#\n# Since Python has no concept of enums, this class cannot provide the value-\n# checking that Java class does. Be very sure that you add only valid enum\n# values to your EnumSet.\n##\n\nimport collections\n\n\nclass EnumSet(collections.MutableSet):\n\n    def __init__(self, enumClassName, iterable=[]):\n        self.__enumClassName = enumClassName\n        self.__set = set(iterable)\n\n    def __repr__(self):\n        return ""EnumSet({0})"".format(list(self.__set))\n\n    def __len__(self):\n        return len(self.__set)\n\n    def __contains__(self, key):\n        return key in self.__set\n\n    def __iter__(self):\n        return iter(self.__set)\n\n    def add(self, value):\n        self.__set.add(value)\n\n    def discard(self, value):\n        self.__set.discard(value)\n\n    def getEnumClass(self):\n        return self.__enumClassName\n'"
dynamicserialize/dstypes/java/util/GregorianCalendar.py,0,"b'#\n# Custom python class representing a java.util.GregorianCalendar.\n#\n# This is a stripped-down version of the class that only supports\n# minimal methods for serialization.\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/29/10                      wldougher     Initial Creation.\n#\n\n\nclass GregorianCalendar(object):\n\n    def __init__(self):\n        self.time = None\n\n    # Methods from the real class that we typically use\n    @staticmethod\n    def getInstance():\n        return GregorianCalendar()\n\n    def getTimeInMillis(self):\n        return self.time\n\n    def setTimeInMillis(self, timeInMillis):\n        self.time = timeInMillis\n'"
dynamicserialize/dstypes/java/util/__init__.py,0,"b""\n__all__ = [\n            'Calendar',\n            'Date',\n            'EnumSet',\n            'GregorianCalendar'\n          ]\n\nfrom .Calendar import Calendar\nfrom .Date import Date\nfrom .EnumSet import EnumSet\nfrom .GregorianCalendar import GregorianCalendar\n"""
dynamicserialize/dstypes/com/raytheon/uf/__init__.py,0,"b""\n__all__ = [\n            'common'\n          ]\n"""
dynamicserialize/dstypes/com/vividsolutions/jts/__init__.py,0,"b""\n__all__ = [\n            'geom'\n          ]\n"""
dynamicserialize/dstypes/gov/noaa/nws/__init__.py,0,"b""\n__all__ = [\n            'ncep'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/__init__.py,0,"b""\n__all__ = [\n            'alertviz',\n            'auth',\n            'dataaccess',\n            'dataplugin',\n            'dataquery',\n            'datastorage',\n            'localization',\n            'management',\n            'message',\n            'pointdata',\n            'pypies',\n            'serialization',\n            'site',\n            'time'\n          ]\n"""
dynamicserialize/dstypes/com/vividsolutions/jts/geom/Coordinate.py,0,"b'\n\nclass Coordinate(object):\n\n    def __init__(self, x=None, y=None):\n        self.x = x\n        self.y = y\n\n    def getX(self):\n        return self.x\n\n    def getY(self):\n        return self.y\n\n    def setX(self, x):\n        self.x = x\n\n    def setY(self, y):\n        self.y = y\n\n    def __str__(self):\n        return str((self.x, self.y))\n\n    def __repr__(self):\n        return self.__str__()\n'"
dynamicserialize/dstypes/com/vividsolutions/jts/geom/Envelope.py,0,"b'# This class is a dummy implementation of the\n# com.vividsolutions.jts.geom.Envelope class. It was simply created to allow\n# serialization/deserialization of IDataRequest objects from the Data Access\n# Framework. This should be re-implemented if useful work needs to be\n# performed against serialized Envelope objects.\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/29/13         2023         dgilling       Initial Creation.\n#\n\n\nclass Envelope(object):\n\n    def __init__(self, env=None):\n        self.maxx = -1.0\n        self.maxy = -1.0\n        self.minx = 0.0\n        self.miny = 0.0\n        if env is not None:\n            (self.minx, self.miny, self.maxx, self.maxy) = env.bounds\n\n    def getMaxX(self):\n        return self.maxx\n\n    def getMaxY(self):\n        return self.maxy\n\n    def getMinX(self):\n        return self.minx\n\n    def getMinY(self):\n        return self.miny\n\n    def setMaxX(self, value):\n        self.maxx = value\n\n    def setMaxY(self, value):\n        self.maxy = value\n\n    def setMinX(self, value):\n        self.minx = value\n\n    def setMinY(self, value):\n        self.miny = value\n'"
dynamicserialize/dstypes/com/vividsolutions/jts/geom/Geometry.py,0,"b'# This class is a dummy implementation of the\n# com.vividsolutions.jts.geom.Geometry class. It was simply created to allow\n# serialization/deserialization of GridLocation objects. This should be\n# reimplemented if useful work needs to be performed against serialized\n# Geometry objects.\n\n\nclass Geometry(object):\n\n    def __init__(self):\n        self.binaryData = None\n\n    def getBinaryData(self):\n        return self.binaryData\n\n    def setBinaryData(self, data):\n        self.binaryData = data\n'"
dynamicserialize/dstypes/com/vividsolutions/jts/geom/__init__.py,0,"b""\n__all__ = [\n            'Coordinate',\n            'Envelope',\n            'Geometry'\n          ]\n\nfrom .Coordinate import Coordinate\nfrom .Envelope import Envelope\nfrom .Geometry import Geometry\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/__init__.py,0,"b""\n__all__ = [\n            'common'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/alertviz/AlertVizRequest.py,0,"b""# Jul 27, 2015 4654     skorolev     Added filters\n\n\nclass AlertVizRequest(object):\n\n    def __init__(self):\n        self.message = None\n        self.machine = None\n        self.priority = None\n        self.sourceKey = None\n        self.category = None\n        self.audioFile = None\n        self.filters = None\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n\n    def getMachine(self):\n        return self.machine\n\n    def setMachine(self, machine):\n        self.machine = machine\n\n    def getPriority(self):\n        return self.priority\n\n    def setPriority(self, priority):\n        self.priority = priority\n\n    def getSourceKey(self):\n        return self.sourceKey\n\n    def setSourceKey(self, sourceKey):\n        self.sourceKey = sourceKey\n\n    def getCategory(self):\n        return self.category\n\n    def setCategory(self, category):\n        self.category = category\n\n    def getAudioFile(self):\n        return self.audioFile\n\n    def setAudioFile(self, audioFile):\n        self.audioFile = audioFile\n\n    def getFilters(self):\n        return self.filters\n\n    def setFilters(self, filters):\n        if filters is None:\n            self.filters = {}\n        elif not(None in filters\n                 or filters.values().count(None) > 0\n                 or '' in filters\n                 or filters.values().count('') > 0):\n            self.filters = filters\n        else:\n            raise ValueError('Filters must not contain None or empty keys or values: %s' % filters)\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/alertviz/__init__.py,0,"b""\n__all__ = [\n            'AlertVizRequest'\n          ]\n\nfrom .AlertVizRequest import AlertVizRequest\n\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/auth/__init__.py,0,"b""\n__all__ = [\n            'resp',\n            'user'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/__init__.py,0,"b""\n__all__ = [\n            'impl',\n            'request',\n            'response'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/__init__.py,0,"b""\n__all__ = [\n            'events',\n            'gfe',\n            'grid',\n            'level',\n            'message',\n            'radar',\n            'text'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataquery/__init__.py,0,"b""\n__all__ = [\n            'requests'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/Request.py,0,"b'\n\nclass Request(object):\n\n    def __init__(self):\n        self.points = None\n        self.indices = None\n        self.minIndexForSlab = None\n        self.maxIndexForSlab = None\n        self.type = None\n\n    def getPoints(self):\n        return self.points\n\n    def setPoints(self, points):\n        self.points = points\n\n    def getIndices(self):\n        return self.indices\n\n    def setIndices(self, indices):\n        self.indices = indices\n\n    def getMinIndexForSlab(self):\n        return self.minIndexForSlab\n\n    def setMinIndexForSlab(self, minIndexForSlab):\n        self.minIndexForSlab = minIndexForSlab\n\n    def getMaxIndexForSlab(self):\n        return self.maxIndexForSlab\n\n    def setMaxIndexForSlab(self, maxIndexForSlab):\n        self.maxIndexForSlab = maxIndexForSlab\n\n    def getType(self):\n        return self.type\n\n    def setType(self, requesttype):\n        self.type = requesttype\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/StorageProperties.py,0,"b'\n\nclass StorageProperties(object):\n\n    def __init__(self):\n        self.compression = None\n        self.chunked = None\n\n    def getCompression(self):\n        return self.compression\n\n    def setCompression(self, compression):\n        self.compression = compression\n\n    def getChunked(self):\n        return self.chunked\n\n    def setChunked(self, chunked):\n        self.chunked = chunked\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/StorageStatus.py,0,"b'\n\nclass StorageStatus(object):\n\n    def __init__(self):\n        self.operationPerformed = None\n        self.indexOfAppend = None\n\n    def getOperationPerformed(self):\n        return self.operationPerformed\n\n    def setOperationPerformed(self, operationPerformed):\n        self.operationPerformed = operationPerformed\n\n    def getIndexOfAppend(self):\n        return self.indexOfAppend\n\n    def setIndexOfAppend(self, indexOfAppend):\n        self.indexOfAppend = indexOfAppend\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/__init__.py,0,"b""#\n# Package definition for com.raytheon.uf.common.datastorage\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen       Initial Creation.\n#\n\n__all__ = [\n            'records',\n            'Request',\n            'StorageProperties',\n            'StorageStatus'\n          ]\n\nfrom .Request import Request\nfrom .StorageProperties import StorageProperties\nfrom .StorageStatus import StorageStatus\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/localization/LocalizationContext.py,0,"b'\n\nclass LocalizationContext(object):\n\n    def __init__(self):\n        self.localizationType = None\n        self.localizationLevel = None\n        self.contextName = None\n\n    def getLocalizationType(self):\n        return self.localizationType\n\n    def setLocalizationType(self, localizationType):\n        self.localizationType = localizationType\n\n    def getLocalizationLevel(self):\n        return self.localizationLevel\n\n    def setLocalizationLevel(self, localizationLevel):\n        self.localizationLevel = localizationLevel\n\n    def getContextName(self):\n        return self.contextName\n\n    def setContextName(self, contextName):\n        self.contextName = contextName\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        delimitedString = str(self.localizationType).lower() + ""."" + str(self.localizationLevel).lower()\n        if self.contextName is not None and self.contextName != """":\n            delimitedString += ""."" + self.contextName\n        return delimitedString\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/LocalizationLevel.py,0,"b'\nknownLevels = {\n    ""BASE"": {""text"": ""BASE"", ""order"": 0, ""systemLevel"": True},\n    ""CONFIGURED"": {""text"": ""CONFIGURED"", ""order"": 250, ""systemLevel"": True},\n    ""SITE"": {""text"": ""SITE"", ""order"": 500, ""systemLevel"": False},\n    ""USER"": {""text"": ""USER"", ""order"": 1000, ""systemLevel"": False},\n    ""UNKNOWN"": {""text"": ""UNKNOWN"", ""order"": -1}\n}\n\n\nclass LocalizationLevel(object):\n\n    def __init__(self, level, order=750, systemLevel=False):\n        if level.upper() in knownLevels:\n            self.text = level.upper()\n            self.order = knownLevels[self.text][""order""]\n            self.systemLevel = knownLevels[self.text][""systemLevel""]\n        else:\n            self.text = level.upper()\n            self.order = int(order)\n            self.systemLevel = systemLevel\n\n    def getText(self):\n        return self.text\n\n    def setText(self, text):\n        self.text = text\n\n    def getOrder(self):\n        return self.order\n\n    def setOrder(self, order):\n        self.order = int(order)\n\n    def isSystemLevel(self):\n        return self.systemLevel\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return str(self.text)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/LocalizationType.py,0,"b'\n\nclass LocalizationType(object):\n\n    def __init__(self, text=None):\n        self.text = text\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return str(self.text)\n\n    def getText(self):\n        return self.text\n\n    def setText(self, text):\n        self.text = text\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/__init__.py,0,"b""\n__all__ = [\n            'msgs',\n            'stream',\n            'LocalizationContext',\n            'LocalizationLevel',\n            'LocalizationType'\n          ]\n\nfrom .LocalizationContext import LocalizationContext\nfrom .LocalizationLevel import LocalizationLevel\nfrom .LocalizationType import LocalizationType\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/__init__.py,0,"b""\n__all__ = [\n            'request',\n            'response'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/message/Body.py,0,"b'\n\nclass Body(object):\n\n    def __init__(self):\n        self.responses = None\n\n    def getResponses(self):\n        return self.responses\n\n    def setResponses(self, responses):\n        self.responses = responses\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/message/Header.py,0,"b'from .Property import Property\n\n\nclass Header(object):\n\n    def __init__(self, properties=None, multimap=None):\n        if properties is None:\n            self.properties = []\n        else:\n            self.properties = properties\n\n        if multimap is not None:\n            for k, l in multimap.items():\n                for v in l:\n                    self.properties.append(Property(k, v))\n\n    def getProperties(self):\n        return self.properties\n\n    def setProperties(self, properties):\n        self.properties = properties\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/message/Message.py,0,"b'\n\nclass Message(object):\n\n    def __init__(self, header=None, body=None):\n        self.header = header\n        self.body = body\n\n    def getHeader(self):\n        return self.header\n\n    def setHeader(self, header):\n        self.header = header\n\n    def getBody(self):\n        return self.body\n\n    def setBody(self, body):\n        self.body = body\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/message/Property.py,0,"b'\n\nclass Property(object):\n\n    def __init__(self, name=None, value=None):\n        self.name = name\n        self.value = value\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getValue(self):\n        return self.value\n\n    def setValue(self, value):\n        self.value = value\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/message/WsId.py,0,"b'#\n# SOFTWARE HISTORY\n#\n# Date          Ticket#  Engineer  Description\n# ------------- -------- --------- ---------------------------------------------\n# Apr 25, 2012  545      randerso  Repurposed the lockKey field as threadId\n# Jun 12, 2013  2099     dgilling  Implemented toPrettyString().\n# Feb 06, 2017  5959     randerso  Removed Java .toString() calls\n#\n\nimport struct\nimport socket\nimport os\ntry:\n    import pwd\n    pwd_error = False\nexcept ImportError:\n    pwd_error = True\ntry:\n    import _thread\nexcept ImportError:\n    import thread as _thread\n\n\nclass WsId(object):\n\n    def __init__(self, networkId=None, userName=None, progName=None):\n        self.networkId = networkId\n        if networkId is None:\n            self.networkId = str(struct.unpack(\'<L\', socket.inet_aton(socket.gethostbyname(socket.gethostname())))[0])\n\n        self.userName = userName\n        if userName is None:\n            if not pwd_error:\n                self.userName = pwd.getpwuid(os.getuid()).pw_name\n            else:\n                self.userName = ""GenericUsername""\n\n        self.progName = progName\n        if progName is None:\n            self.progName = ""unknown""\n\n        self.pid = os.getpid()\n\n        self.threadId = int(_thread.get_ident())\n\n    def getNetworkId(self):\n        return self.networkId\n\n    def setNetworkId(self, networkId):\n        self.networkId = networkId\n\n    def getUserName(self):\n        return self.userName\n\n    def setUserName(self, userName):\n        self.userName = userName\n\n    def getProgName(self):\n        return self.progName\n\n    def setProgName(self, progName):\n        self.progName = progName\n\n    def getPid(self):\n        return self.pid\n\n    def setPid(self, pid):\n        self.pid = pid\n\n    def getThreadId(self):\n        return self.threadId\n\n    def setThreadId(self, threadId):\n        self.threadId = threadId\n\n    def toPrettyString(self):\n        hostname = socket.gethostbyaddr(socket.inet_ntoa(struct.pack(\'<L\', int(self.networkId))))[0]\n        return self.userName + ""@"" + hostname + "":"" + self.progName + "":"" + str(self.pid) + "":"" + str(self.threadId)\n\n    def __str__(self):\n        return self.networkId + "":"" + self.userName + "":"" + self.progName + "":"" \\\n               + str(self.pid) + "":"" + str(self.threadId)\n\n    def __repr__(self):\n        return self.__str__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/message/__init__.py,0,"b""\n__all__ = [\n            'Body',\n            'Header',\n            'Message',\n            'Property',\n            'WsId'\n          ]\n\n#\n# Package definition for com.raytheon.uf.common.message\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/16/10                      dgilling       Initial Creation.\n#    08/19/14        2926          bclement       added Message files\n#\n#\n\nfrom .Body import Body\nfrom .Header import Header\nfrom .Message import Message\nfrom .Property import Property\nfrom .WsId import WsId\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pointdata/__init__.py,0,"b""\n__all__ = [\n            'requests'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/PointTest.py,0,"b'\n\nclass PointTest:\n\n    def __init__(self):\n        self.points = None\n\n    def getPoints(self):\n        return self.points\n\n    def setPoints(self, points):\n        self.points = points\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/__init__.py,0,"b""\n__all__ = [\n            'records',\n            'request',\n            'response',\n            'PointTest'\n          ]\n\nfrom .PointTest import PointTest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/serialization/SerializableExceptionWrapper.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    2015-02-27      4174          nabowle        Output full stacktrace.\n#    2018-10-05                    mjames@ucar    Fix returned retVal encoding.\n#\n\n\nclass SerializableExceptionWrapper(object):\n\n    def __init__(self):\n        self.stackTrace = None\n        self.message = None\n        self.exceptionClass = None\n        self.wrapper = None\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        if not self.message:\n            self.message = \'\'\n        retVal = """" + str(self.exceptionClass) + "" exception thrown: "" + str(self.message) + ""\\n""\n        for element in self.stackTrace:\n            retVal += ""\\tat "" + str(element) + ""\\n""\n\n        if self.wrapper:\n            retVal += ""Caused by: "" + self.wrapper.__repr__()\n        return str(retVal)\n\n    def getStackTrace(self):\n        return self.stackTrace\n\n    def setStackTrace(self, stackTrace):\n        self.stackTrace = stackTrace\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n\n    def getExceptionClass(self):\n        return self.exceptionClass\n\n    def setExceptionClass(self, exceptionClass):\n        self.exceptionClass = exceptionClass\n\n    def getWrapper(self):\n        return self.wrapper\n\n    def setWrapper(self, wrapper):\n        self.wrapper = wrapper\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/serialization/__init__.py,0,"b""\n__all__ = [\n            'comm',\n            'SerializableExceptionWrapper'\n          ]\n\nfrom .SerializableExceptionWrapper import SerializableExceptionWrapper\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/site/__init__.py,0,"b""\n__all__ = [\n            'notify',\n            'requests'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/time/CommutativeTimestamp.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/23/2016      #5696         rjpeter        Initial creation.\n#\n\nfrom dynamicserialize.dstypes.java.sql import Timestamp\n\n\nclass CommutativeTimestamp(Timestamp):\n\n    def __init__(self, timeInMillis=None):\n        super(CommutativeTimestamp, self).__init__(timeInMillis)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/time/DataTime.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/??                      xxxxxxxx       Initial Creation.\n#    05/28/13         2023         dgilling       Implement __str__().\n#    01/22/14         2667         bclement       preserved milliseconds in string representation\n#    03/03/14         2673         bsteffen       allow construction using a Date for refTime\n#    06/24/14         3096         mnash          implement __cmp__\n#    06/24/15         4480         dgilling       implement __hash__ and __eq__,\n#                                                 replace __cmp__ with rich comparison\n#                                                 operators.\n#    05/26/16         2416         rjpeter        Added str based constructor.\n#    08/02/16         2416         tgurney        Forecast time regex bug fix,\n#                                                 plus misc cleanup\n#\n\nimport calendar\nimport datetime\nimport re\nimport time\nimport numpy\nfrom six.moves import cStringIO as StringIO\n\nfrom dynamicserialize.dstypes.java.util import Date\nfrom dynamicserialize.dstypes.java.util import EnumSet\n\nfrom .TimeRange import TimeRange\n\n_DATE = r\'(\\d{4}-\\d{2}-\\d{2})\'\n_TIME = r\'(\\d{2}:\\d{2}:\\d{2})\'\n_MILLIS = \'(?:\\.(\\d{1,3})(?:\\d{1,4})?)?\'  # might have microsecond but that is thrown out\nREFTIME_PATTERN_STR = _DATE + \'[ _]\' + _TIME + _MILLIS\nFORECAST_PATTERN_STR = r\'(?:[ _]\\((\\d+)(?::(\\d{1,2}))?\\))?\'\nVALID_PERIOD_PATTERN_STR = r\'(?:\\[\' + REFTIME_PATTERN_STR + \'--\' + REFTIME_PATTERN_STR + r\'\\])?\'\nSTR_PATTERN = re.compile(REFTIME_PATTERN_STR + FORECAST_PATTERN_STR + VALID_PERIOD_PATTERN_STR)\n\n\nclass DataTime(object):\n\n    def __init__(self, refTime=None, fcstTime=None, validPeriod=None):\n        """"""\n        Construct a new DataTime.\n        May also be called as DataTime(str) to parse a string and create a\n        DataTime from it. Some examples of valid DataTime strings:\n\n             \'2016-08-02 01:23:45.0\'\n             \'2016-08-02 01:23:45.123\'\n             \'2016-08-02 01:23:45.0 (17)\',\n             \'2016-08-02 01:23:45.0 (17:34)\'\n             \'2016-08-02 01:23:45.0[2016-08-02_02:34:45.0--2016-08-02_03:45:56.0]\'\n             \'2016-08-02 01:23:45.456_(17:34)[2016-08-02_02:34:45.0--2016-08-02_03:45:56.0]\'\n        """"""\n        if fcstTime is not None:\n            self.fcstTime = int(fcstTime)\n        else:\n            self.fcstTime = 0\n        self.refTime = refTime\n        if validPeriod is not None and not isinstance(validPeriod, TimeRange):\n            raise ValueError(""Invalid validPeriod object specified for DataTime."")\n        self.validPeriod = validPeriod\n        self.utilityFlags = EnumSet(\'com.raytheon.uf.common.time.DataTime$FLAG\')\n        self.levelValue = numpy.float64(-1.0)\n\n        if self.refTime is not None:\n            if isinstance(self.refTime, datetime.datetime):\n                self.refTime = int(calendar.timegm(self.refTime.utctimetuple()) * 1000)\n            elif isinstance(self.refTime, time.struct_time):\n                self.refTime = int(calendar.timegm(self.refTime) * 1000)\n            elif hasattr(self.refTime, \'getTime\'):\n                # getTime should be returning ms, there is no way to check this\n                # This is expected for java Date\n                self.refTime = int(self.refTime.getTime())\n            else:\n                try:\n                    self.refTime = int(self.refTime)\n                except ValueError:\n                    # Assume first arg is a string. Attempt to parse.\n                    match = STR_PATTERN.match(self.refTime)\n                    if match is None:\n                        raise ValueError(\'Could not parse DataTime info from \'\n                                         + str(refTime))\n\n                    groups = match.groups()\n                    rMillis = groups[2] or 0\n                    fcstTimeHr = groups[3]\n                    fcstTimeMin = groups[4]\n                    periodStart = groups[5], groups[6], (groups[7] or 0)\n                    periodEnd = groups[8], groups[9], (groups[10] or 0)\n                    self.refTime = self._getTimeAsEpochMillis(groups[0], groups[1], rMillis)\n\n                    if fcstTimeHr is not None:\n                        self.fcstTime = int(fcstTimeHr) * 3600\n                        if fcstTimeMin is not None:\n                            self.fcstTime += int(fcstTimeMin) * 60\n\n                    if periodStart[0] is not None:\n                        self.validPeriod = TimeRange()\n                        periodStartTime = self._getTimeAsEpochMillis(*periodStart)\n                        self.validPeriod.setStart(periodStartTime / 1000)\n                        periodEndTime = self._getTimeAsEpochMillis(*periodEnd)\n                        self.validPeriod.setEnd(periodEndTime / 1000)\n\n            self.refTime = Date(self.refTime)\n\n            if self.validPeriod is None:\n                validTimeMillis = self.refTime.getTime() + int(self.fcstTime * 1000)\n                self.validPeriod = TimeRange()\n                self.validPeriod.setStart(validTimeMillis / 1000)\n                self.validPeriod.setEnd(validTimeMillis / 1000)\n\n        # figure out utility flags\n        if self.fcstTime:\n            self.utilityFlags.add(""FCST_USED"")\n        if self.validPeriod and self.validPeriod.isValid():\n            self.utilityFlags.add(""PERIOD_USED"")\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getFcstTime(self):\n        return self.fcstTime\n\n    def setFcstTime(self, fcstTime):\n        self.fcstTime = fcstTime\n\n    def getValidPeriod(self):\n        return self.validPeriod\n\n    def setValidPeriod(self, validPeriod):\n        self.validPeriod = validPeriod\n\n    def getUtilityFlags(self):\n        return self.utilityFlags\n\n    def setUtilityFlags(self, utilityFlags):\n        self.utilityFlags = utilityFlags\n\n    def getLevelValue(self):\n        return self.levelValue\n\n    def setLevelValue(self, levelValue):\n        self.levelValue = numpy.float64(levelValue)\n\n    def __str__(self):\n        sbuffer = StringIO()\n\n        if self.refTime is not None:\n            refTimeInSecs = self.refTime.getTime() / 1000\n            micros = (self.refTime.getTime() % 1000) * 1000\n            dtObj = datetime.datetime.utcfromtimestamp(refTimeInSecs)\n            dtObj = dtObj.replace(microsecond=micros)\n            # This won\'t be compatible with java or string from java since its to microsecond\n            sbuffer.write(dtObj.isoformat(\' \'))\n\n        if ""FCST_USED"" in self.utilityFlags:\n            hrs = int(self.fcstTime / 3600)\n            mins = int((self.fcstTime - (hrs * 3600)) / 60)\n            sbuffer.write("" ("" + str(hrs))\n            if mins != 0:\n                sbuffer.write("":"" + str(mins))\n            sbuffer.write("")"")\n\n        if ""PERIOD_USED"" in self.utilityFlags:\n            sbuffer.write(""["")\n            sbuffer.write(self.validPeriod.start.isoformat(\' \'))\n            sbuffer.write(""--"")\n            sbuffer.write(self.validPeriod.end.isoformat(\' \'))\n            sbuffer.write(""]"")\n\n        strVal = sbuffer.getvalue()\n        sbuffer.close()\n        return strVal\n\n    def __repr__(self):\n        return ""<DataTime instance: "" + str(self) + "" >""\n\n    def __hash__(self):\n        hashCode = hash(self.refTime) ^ hash(self.fcstTime)\n        if self.validPeriod is not None and self.validPeriod.isValid():\n            hashCode ^= hash(self.validPeriod.getStart())\n            hashCode ^= hash(self.validPeriod.getEnd())\n        hashCode ^= hash(self.levelValue)\n        return hashCode\n\n    def __eq__(self, other):\n        if not isinstance(self, type(other)):\n            return False\n\n        if other.getRefTime() is None:\n            return self.fcstTime == other.fcstTime\n\n        dataTime1 = (self.refTime, self.fcstTime, self.validPeriod, self.levelValue)\n        dataTime2 = (other.refTime, other.fcstTime, other.validPeriod, other.levelValue)\n        return dataTime1 == dataTime2\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n\n        myValidTime = self.getRefTime().getTime() + self.getFcstTime()\n        otherValidTime = other.getRefTime().getTime() + other.getFcstTime()\n        if myValidTime < otherValidTime:\n            return True\n\n        if self.fcstTime < other.fcstTime:\n            return True\n\n        if self.levelValue < other.levelValue:\n            return True\n\n        myValidPeriod = self.validPeriod\n        otherValidPeriod = other.validPeriod\n        if myValidPeriod != otherValidPeriod:\n            if myValidPeriod.duration() < otherValidPeriod.duration():\n                return True\n            return myValidPeriod.getStartInMillis() < otherValidPeriod.getStartInMillis()\n        return False\n\n    def __le__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n\n        myValidTime = self.getRefTime().getTime() + self.getFcstTime()\n        otherValidTime = other.getRefTime().getTime() + other.getFcstTime()\n        if myValidTime > otherValidTime:\n            return True\n\n        if self.fcstTime > other.fcstTime:\n            return True\n\n        if self.levelValue > other.levelValue:\n            return True\n\n        myValidPeriod = self.validPeriod\n        otherValidPeriod = other.validPeriod\n        if myValidPeriod != otherValidPeriod:\n            if myValidPeriod.duration() > otherValidPeriod.duration():\n                return True\n            return myValidPeriod.getStartInMillis() > otherValidPeriod.getStartInMillis()\n        return False\n\n    def __ge__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n\n        return self.__gt__(other) or self.__eq__(other)\n\n    def _getTimeAsEpochMillis(self, dateStr, timeStr, millis):\n        t = time.strptime(dateStr + \' \' + timeStr, \'%Y-%m-%d %H:%M:%S\')\n        epochSeconds = calendar.timegm(t)\n        return int(epochSeconds * 1000) + int(millis)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/time/FormattedDate.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/21/2015      4486          rjpeter        Initial creation.\n#    06/23/2016      #5696         rjpeter        Extend CommutativeTimestamp\n#\n\nfrom .CommutativeTimestamp import CommutativeTimestamp\n\n\n# TODO: Remove after 16.4.1 no longer in field\nclass FormattedDate(CommutativeTimestamp):\n\n    def __init__(self, timeInMillis=None):\n        super(FormattedDate, self).__init__(timeInMillis)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/time/TimeRange.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/??                      xxxxxxxx       Initial Creation.\n#    01/22/14        2667          bclement       fixed millisecond support\n#    02/28/14        2667          bclement       constructor can take extra micros for start and end\n#    06/24/15        4480          dgilling       fix __eq__.\n#\n#\n\nimport calendar\nimport datetime\nimport time\n\nMAX_TIME = 2147483647\nMICROS_IN_SECOND = 1000000\n\n\nclass TimeRange(object):\n    def __init__(self, start=None, end=None, startExtraMicros=None, endExtraMicros=None):\n        self.start = self.__convertToDateTimeWithExtra(start, startExtraMicros)\n        self.end = self.__convertToDateTimeWithExtra(end, endExtraMicros)\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return ""("" + self.start.strftime(""%b %d %y %H:%M:%S %Z"") + "", "" + \\\n               self.end.strftime(""%b %d %y %H:%M:%S %Z"") + "")""\n\n    def __eq__(self, other):\n        if not isinstance(self, type(other)):\n            return False\n\n        if self.isValid() and other.isValid():\n            return self.getStart() == other.getStart() and self.getEnd() == other.getEnd()\n        elif not self.isValid() and not other.isValid():\n            return True\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __convertToDateTimeWithExtra(self, timeArg, extraMicros):\n        rval = self.__convertToDateTime(timeArg)\n        if rval is not None and extraMicros is not None:\n            rval = rval + datetime.timedelta(microseconds=extraMicros)\n        return rval\n\n    def __convertToDateTime(self, timeArg):\n        if timeArg is None:\n            return None\n        if isinstance(timeArg, datetime.datetime):\n            return timeArg\n        elif isinstance(timeArg, time.struct_time):\n            return datetime.datetime(*timeArg[:6])\n        elif isinstance(timeArg, float):\n            # seconds as float, should be avoided due to floating point errors\n            totalSecs = int(timeArg)\n            micros = int((timeArg - totalSecs) * MICROS_IN_SECOND)\n            return self.__convertSecsAndMicros(totalSecs, micros)\n        elif isinstance(timeArg, int):\n            # seconds as integer\n            totalSecs = timeArg\n            return self.__convertSecsAndMicros(totalSecs, 0)\n        else:\n            return None\n\n    def __convertSecsAndMicros(self, seconds, micros):\n        if seconds < MAX_TIME:\n            rval = datetime.datetime.utcfromtimestamp(seconds)\n        else:\n            extraTime = datetime.timedelta(seconds=(seconds - MAX_TIME))\n            rval = datetime.datetime.utcfromtimestamp(MAX_TIME) + extraTime\n        return rval.replace(microsecond=micros)\n\n    def getStart(self):\n        return self.start.utctimetuple()\n\n    def getStartInMillis(self):\n        return self._getInMillis(self.start)\n\n    def setStart(self, start, extraMicros=None):\n        self.start = self.__convertToDateTimeWithExtra(start, extraMicros)\n\n    def getEnd(self):\n        return self.end.utctimetuple()\n\n    def getEndInMillis(self):\n        return self._getInMillis(self.end)\n\n    def _getInMillis(self, time):\n        rval = int(calendar.timegm(time.utctimetuple()) * 1000)\n        rval += time.microsecond // 1000\n        return rval\n\n    def setEnd(self, end, extraMicros=None):\n        self.end = self.__convertToDateTimeWithExtra(end, extraMicros)\n\n    def duration(self):\n        delta = self.end - self.start\n        return int(delta.total_seconds())\n\n    def contains(self, timeArg):\n        if isinstance(timeArg, TimeRange):\n            if self.duration() == 0:\n                return self.__eq__(timeArg)\n            elif timeArg.duration() == 0:\n                return self.contains(timeArg.start)\n            return timeArg.start >= self.start and timeArg.end <= self.end\n        else:\n            convTime = self.__convertToDateTime(timeArg)\n            if not isinstance(convTime, datetime.datetime):\n                raise TypeError(""Invalid type for argument time specified to TimeRange.contains()."")\n            if self.duration() != 0:\n                return self.start <= convTime < self.end\n            return convTime == self.start\n\n    def isValid(self):\n        return bool(self.start != self.end)\n\n    def overlaps(self, timeRange):\n        return timeRange.contains(self.start) or self.contains(timeRange.start)\n\n    def combineWith(self, timeRange):\n        if self.isValid() and timeRange.isValid():\n            newStart = min(self.start, timeRange.start)\n            newEnd = max(self.end, timeRange.end)\n            return TimeRange(newStart, newEnd)\n        elif self.isValid():\n            return self\n\n        return timeRange\n\n    @staticmethod\n    def allTimes():\n        return TimeRange(0, MAX_TIME)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/time/__init__.py,0,"b""\n__all__ = [\n            'CommutativeTimestamp',\n            'DataTime',\n            'FormattedDate',\n            'TimeRange'\n          ]\n\nfrom .DataTime import DataTime\nfrom .TimeRange import TimeRange\nfrom .FormattedDate import FormattedDate\nfrom .CommutativeTimestamp import CommutativeTimestamp\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/__init__.py,0,"b""\n__all__ = [\n            'dataplugin'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/auth/resp/AbstractFailedResponse.py,0,"b'from six import with_metaclass\nimport abc\n\n\nclass AbstractFailedResponse(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.request = None\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/auth/resp/AuthServerErrorResponse.py,0,"b""# nothing to implement here that isn't already covered by ServerErrorResponse\n# Just need the separate class for de-serialization.\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.serialization.comm.response import ServerErrorResponse\n\n\nclass AuthServerErrorResponse(ServerErrorResponse):\n\n    def __init__(self):\n        super(AuthServerErrorResponse, self).__init__()\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/auth/resp/SuccessfulExecution.py,0,"b'\n\nclass SuccessfulExecution(object):\n\n    def __init__(self):\n        self.response = None\n        self.updatedData = None\n\n    def getResponse(self):\n        return self.response\n\n    def setResponse(self, response):\n        self.response = response\n\n    def getUpdatedData(self):\n        return self.updatedData\n\n    def setUpdatedData(self, updatedData):\n        self.updatedData = updatedData\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/auth/resp/UserNotAuthorized.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.auth.resp import AbstractFailedResponse\n\n\nclass UserNotAuthorized(AbstractFailedResponse):\n\n    def __init__(self):\n        super(UserNotAuthorized, self).__init__()\n        self.message = None\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/auth/resp/__init__.py,0,"b""\n__all__ = [\n            'AbstractFailedResponse',\n            'AuthServerErrorResponse',\n            'SuccessfulExecution',\n            'UserNotAuthorized'\n          ]\n\nfrom .AbstractFailedResponse import AbstractFailedResponse\nfrom .AuthServerErrorResponse import AuthServerErrorResponse\nfrom .SuccessfulExecution import SuccessfulExecution\nfrom .UserNotAuthorized import UserNotAuthorized\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/auth/user/User.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.auth.user import UserId\n\n\nclass User(object):\n\n    def __init__(self, userId=None):\n        if userId is None:\n            self.userId = UserId.UserId()\n        else:\n            self.userId = userId\n        self.authenticationData = None\n\n    def getUserId(self):\n        return self.userId\n\n    def setUserId(self, userId):\n        self.userId = userId\n\n    def getAuthenticationData(self):\n        return self.authenticationData\n\n    def setAuthenticationData(self, authenticationData):\n        self.authenticationData = authenticationData\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/auth/user/UserId.py,0,"b'import os\ntry:\n    import pwd\n    pwd_error = False\nexcept ImportError:\n    pwd_error = True\n\n\nclass UserId(object):\n\n    def __init__(self, userid=None):\n        if userid is None:\n            if not pwd_error:\n                self.id = pwd.getpwuid(os.getuid()).pw_name\n            else:\n                self.id = ""GenericUsername""\n        else:\n            self.id = userid\n\n    def getId(self):\n        return self.id\n\n    def setId(self, userid):\n        self.id = userid\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/auth/user/__init__.py,0,"b""\n__all__ = [\n            'User',\n            'UserId'\n          ]\n\nfrom .User import User\nfrom .UserId import UserId\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/impl/DefaultDataRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13        2023          dgilling       Initial Creation.\n#    12/15/16        6040          tgurney        Override __str__\n#\n#\n\nfrom awips.dataaccess import IDataRequest\nfrom dynamicserialize.dstypes.com.vividsolutions.jts.geom import Envelope\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.level import Level\n\n\nclass DefaultDataRequest(IDataRequest):\n\n    def __init__(self):\n        self.datatype = None\n        self.identifiers = {}\n        self.parameters = []\n        self.levels = []\n        self.locationNames = []\n        self.envelope = None\n\n    def setDatatype(self, datatype):\n        self.datatype = str(datatype)\n\n    def addIdentifier(self, key, value):\n        self.identifiers[key] = value\n\n    def removeIdentifier(self, key):\n        del self.identifiers[key]\n\n    def setParameters(self, *params):\n        self.parameters = list(map(str, params))\n\n    def setLevels(self, *levels):\n        self.levels = list(map(self.__makeLevel, levels))\n\n    def __makeLevel(self, level):\n        if isinstance(level, Level):\n            return level\n        elif isinstance(level, str):\n            return Level(level)\n        else:\n            raise TypeError(""Invalid object type specified for level."")\n\n    def setEnvelope(self, env):\n        self.envelope = Envelope(env.envelope)\n\n    def setLocationNames(self, *locationNames):\n        self.locationNames = list(map(str, locationNames))\n\n    def getDatatype(self):\n        return self.datatype\n\n    def getIdentifiers(self):\n        return self.identifiers\n\n    def getParameters(self):\n        return self.parameters\n\n    def getLevels(self):\n        return self.levels\n\n    def getEnvelope(self):\n        return self.envelope\n\n    def getLocationNames(self):\n        return self.locationNames\n\n    def __str__(self):\n        fmt = (\'DefaultDataRequest(datatype={}, identifiers={}, parameters={}, \' +\n               \'levels={}, locationNames={}, envelope={})\')\n        return fmt.format(self.datatype, self.identifiers, self.parameters, self.levels,\n                          self.locationNames, self.envelope)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/impl/DefaultNotificationFilter.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/03/16        2416          rjpeter        Initial Creation.\n#    08/01/16        2416          tgurney        Implement accept()\n#\n#\n\nfrom awips.dataaccess import INotificationFilter\nimport sys\n\nif sys.version_info.major == 2:\n    from itertools import izip\n    # shadowing built-in zip\n    zip = izip\n\n\nclass DefaultNotificationFilter(INotificationFilter):\n\n    def __init__(self):\n        self.constraints = None\n\n    def getConstraints(self):\n        return self.constraints\n\n    def setConstraints(self, constraints):\n        self.constraints = constraints\n\n    def accept(self, dataUri):\n        tokens = dataUri.split('/')[1:]\n        if len(self.constraints) != len(tokens):\n            return False\n        for constraint, token in zip(self.constraints, tokens):\n            if not constraint.evaluate(token):\n                return False\n        return True\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/impl/__init__.py,0,"b""\n__all__ = [\n            'DefaultDataRequest',\n            'DefaultNotificationFilter'\n          ]\n\nfrom .DefaultDataRequest import DefaultDataRequest\nfrom .DefaultNotificationFilter import DefaultNotificationFilter\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/AbstractDataAccessRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13         #2023        dgilling       Initial Creation.\n#\n#\n\nfrom six import with_metaclass\nimport abc\n\n\nclass AbstractDataAccessRequest(with_metaclass(abc.ABCMeta, object)):\n    def __init__(self):\n        self.requestParameters = None\n\n    def getRequestParameters(self):\n        return self.requestParameters\n\n    def setRequestParameters(self, requestParameters):\n        self.requestParameters = requestParameters\n\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/AbstractIdentifierRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#    Jun 01, 2016     5587         tgurney        Change self.datatype to\n#                                                 self.request\n#\n#\n\nfrom six import with_metaclass\nimport abc\n\n\nclass AbstractIdentifierRequest(with_metaclass(abc.ABCMeta, object)):\n    def __init__(self):\n        self.request = None\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetAvailableLevelsRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetAvailableLevelsRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetAvailableLevelsRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetAvailableLocationNamesRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13         #2023        dgilling       Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetAvailableLocationNamesRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetAvailableLocationNamesRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetAvailableParametersRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetAvailableParametersRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetAvailableParametersRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetAvailableTimesRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13         #2023        dgilling       Initial Creation.\n#    03/03/14         #2673        bsteffen       Add ability to query only ref times.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetAvailableTimesRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetAvailableTimesRequest, self).__init__()\n        self.refTimeOnly = False\n\n    def getRefTimeOnly(self):\n        return self.refTimeOnly\n\n    def setRefTimeOnly(self, refTimeOnly):\n        self.refTimeOnly = refTimeOnly\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetGeometryDataRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13         #2023        dgilling       Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetGeometryDataRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetGeometryDataRequest, self).__init__()\n        self.requestedTimes = None\n        self.requestedPeriod = None\n\n    def getRequestedTimes(self):\n        return self.requestedTimes\n\n    def setRequestedTimes(self, requestedTimes):\n        self.requestedTimes = requestedTimes\n\n    def getRequestedPeriod(self):\n        return self.requestedPeriod\n\n    def setRequestedPeriod(self, requestedPeriod):\n        self.requestedPeriod = requestedPeriod\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetGridDataRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/28/13         #2023        dgilling       Initial Creation.\n#    05/28/13         #5916        bsteffen       Add includeLatLonData\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetGridDataRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetGridDataRequest, self).__init__()\n        self.requestedTimes = None\n        self.requestedPeriod = None\n        self.includeLatLonData = True\n\n    def getRequestedTimes(self):\n        return self.requestedTimes\n\n    def setRequestedTimes(self, requestedTimes):\n        self.requestedTimes = requestedTimes\n\n    def getRequestedPeriod(self):\n        return self.requestedPeriod\n\n    def setRequestedPeriod(self, requestedPeriod):\n        self.requestedPeriod = requestedPeriod\n\n    def getIncludeLatLonData(self):\n        return self.includeLatLonData\n\n    def setIncludeLatLonData(self, includeLatLonData):\n        self.includeLatLonData = includeLatLonData\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetGridLatLonRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Oct 10, 2016    5916          bsteffen       Generated\n\n\nclass GetGridLatLonRequest(object):\n\n    def __init__(self):\n        self.envelope = None\n        self.crsWkt = None\n        self.nx = None\n        self.ny = None\n\n    def getEnvelope(self):\n        return self.envelope\n\n    def setEnvelope(self, envelope):\n        self.envelope = envelope\n\n    def getCrsWkt(self):\n        return self.crsWkt\n\n    def setCrsWkt(self, crsWkt):\n        self.crsWkt = crsWkt\n\n    def getNx(self):\n        return self.nx\n\n    def setNx(self, nx):\n        self.nx = nx\n\n    def getNy(self):\n        return self.ny\n\n    def setNy(self, ny):\n        self.ny = ny\n\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetIdentifierValuesRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    04/15/2016      5379          tgurney        Initial creation\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetIdentifierValuesRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetIdentifierValuesRequest, self).__init__()\n        self.identifierKey = None\n\n    def getIdentifierKey(self):\n        return self.identifierKey\n\n    def setIdentifierKey(self, identifierKey):\n        self.identifierKey = identifierKey\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetNotificationFilterRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/26/16        2416          rjpeter        Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractDataAccessRequest\n\n\nclass GetNotificationFilterRequest(AbstractDataAccessRequest):\n\n    def __init__(self):\n        super(GetNotificationFilterRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetOptionalIdentifiersRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#    07/30/14         #3185        njensen        Renamed valid to optional\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractIdentifierRequest\n\n\nclass GetOptionalIdentifiersRequest(AbstractIdentifierRequest):\n\n    def __init__(self):\n        super(GetOptionalIdentifiersRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetRequiredIdentifiersRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.request import AbstractIdentifierRequest\n\n\nclass GetRequiredIdentifiersRequest(AbstractIdentifierRequest):\n\n    def __init__(self):\n        super(GetRequiredIdentifiersRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/GetSupportedDatatypesRequest.py,0,b'#\n#    SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    07/23/14         #3185        njensen        Initial Creation.\n#\n#\n\n\nclass GetSupportedDatatypesRequest(object):\n\n    def __init__(self):\n        pass\n'
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/request/__init__.py,0,"b""\n__all__ = [\n            'AbstractDataAccessRequest',\n            'AbstractIdentifierRequest',\n            'GetAvailableLevelsRequest',\n            'GetAvailableLocationNamesRequest',\n            'GetAvailableParametersRequest',\n            'GetAvailableTimesRequest',\n            'GetGeometryDataRequest',\n            'GetGridDataRequest',\n            'GetGridLatLonRequest',\n            'GetIdentifierValuesRequest',\n            'GetNotificationFilterRequest',\n            'GetOptionalIdentifiersRequest',\n            'GetRequiredIdentifiersRequest',\n            'GetSupportedDatatypesRequest'\n          ]\n\nfrom .AbstractDataAccessRequest import AbstractDataAccessRequest\nfrom .AbstractIdentifierRequest import AbstractIdentifierRequest\nfrom .GetAvailableLevelsRequest import GetAvailableLevelsRequest\nfrom .GetAvailableLocationNamesRequest import GetAvailableLocationNamesRequest\nfrom .GetAvailableParametersRequest import GetAvailableParametersRequest\nfrom .GetAvailableTimesRequest import GetAvailableTimesRequest\nfrom .GetGeometryDataRequest import GetGeometryDataRequest\nfrom .GetGridDataRequest import GetGridDataRequest\nfrom .GetGridLatLonRequest import GetGridLatLonRequest\nfrom .GetIdentifierValuesRequest import GetIdentifierValuesRequest\nfrom .GetNotificationFilterRequest import GetNotificationFilterRequest\nfrom .GetOptionalIdentifiersRequest import GetOptionalIdentifiersRequest\nfrom .GetRequiredIdentifiersRequest import GetRequiredIdentifiersRequest\nfrom .GetSupportedDatatypesRequest import GetSupportedDatatypesRequest\n\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/AbstractResponseData.py,0,"b""import abc\nimport six\n\n\nclass AbstractResponseData(six.with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.time = None\n        self.level = None\n        self.locationName = None\n        self.attributes = None\n\n    def getTime(self):\n        return self.time\n\n    def setTime(self, time):\n        self.time = time\n\n    def getLevel(self):\n        return self.level\n\n    def setLevel(self, level):\n        self.level = level\n\n    def getLocationName(self):\n        if six.PY2:\n            return self.locationName\n        if self.locationName is not None:\n            return self.locationName.decode('utf-8')\n        return self.locationName\n\n    def setLocationName(self, locationName):\n        self.locationName = locationName\n\n    def getAttributes(self):\n        if six.PY2:\n            return self.attributes\n        return self.convert(self.attributes)\n\n    def setAttributes(self, attributes):\n        self.attributes = attributes\n\n    def convert(self, data):\n        if isinstance(data, dict):\n            return dict(map(self.convert, data.items()))\n        if isinstance(data, bytes):\n            return data.decode('utf-8')\n        if isinstance(data, tuple):\n            return tuple(map(self.convert, data))\n        if isinstance(data, list):\n            return list(map(self.convert, data))\n        return data\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GeometryResponseData.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/04/13         #2023        dgilling       Initial Creation.\n#    01/06/14         #2537        bsteffen       Store geometry index instead of WKT.\n#    06/30/15         #4569        nabowle        Rename *WKT* to *WKB*.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.response import AbstractResponseData\n\n\nclass GeometryResponseData(AbstractResponseData):\n\n    def __init__(self):\n        super(GeometryResponseData, self).__init__()\n        self.dataMap = None\n        self.geometryWKBindex = None\n\n    def getDataMap(self):\n        return self.dataMap\n\n    def setDataMap(self, dataMap):\n        self.dataMap = dataMap\n\n    def getGeometryWKBindex(self):\n        return self.geometryWKBindex\n\n    def setGeometryWKBindex(self, geometryWKBindex):\n        self.geometryWKBindex = geometryWKBindex\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GetGeometryDataResponse.py,0,"b'\n\nclass GetGeometryDataResponse(object):\n\n    def __init__(self):\n        self.geometryWKBs = None\n        self.geoData = None\n\n    def getGeometryWKBs(self):\n        return self.geometryWKBs\n\n    def setGeometryWKBs(self, geometryWKBs):\n        self.geometryWKBs = geometryWKBs\n\n    def getGeoData(self):\n        return self.geoData\n\n    def setGeoData(self, geoData):\n        self.geoData = geoData\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GetGridDataResponse.py,0,"b'\n\nclass GetGridDataResponse(object):\n\n    def __init__(self):\n        self.gridData = None\n        self.siteNxValues = None\n        self.siteNyValues = None\n        self.siteLatGrids = None\n        self.siteLonGrids = None\n        self.siteEnvelopes = None\n        self.siteCrsWkt = None\n\n    def getGridData(self):\n        return self.gridData\n\n    def setGridData(self, gridData):\n        self.gridData = gridData\n\n    def getSiteNxValues(self):\n        return self.siteNxValues\n\n    def setSiteNxValues(self, siteNxValues):\n        self.siteNxValues = siteNxValues\n\n    def getSiteNyValues(self):\n        return self.siteNyValues\n\n    def setSiteNyValues(self, siteNyValues):\n        self.siteNyValues = siteNyValues\n\n    def getSiteLatGrids(self):\n        return self.siteLatGrids\n\n    def setSiteLatGrids(self, siteLatGrids):\n        self.siteLatGrids = siteLatGrids\n\n    def getSiteLonGrids(self):\n        return self.siteLonGrids\n\n    def setSiteLonGrids(self, siteLonGrids):\n        self.siteLonGrids = siteLonGrids\n\n    def getSiteEnvelopes(self):\n        return self.siteEnvelopes\n\n    def setSiteEnvelopes(self, siteEnvelopes):\n        self.siteEnvelopes = siteEnvelopes\n\n    def getSiteCrsWkt(self):\n        return self.siteCrsWkt\n\n    def setSiteCrsWkt(self, siteCrsWkt):\n        self.siteCrsWkt = siteCrsWkt\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GetGridLatLonResponse.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Oct 10, 2016    5916          bsteffen       Generated\n\n\nclass GetGridLatLonResponse(object):\n\n    def __init__(self):\n        self.lats = None\n        self.lons = None\n        self.nx = None\n        self.ny = None\n\n    def getLats(self):\n        return self.lats\n\n    def setLats(self, lats):\n        self.lats = lats\n\n    def getLons(self):\n        return self.lons\n\n    def setLons(self, lons):\n        self.lons = lons\n\n    def getNx(self):\n        return self.nx\n\n    def setNx(self, nx):\n        self.nx = nx\n\n    def getNy(self):\n        return self.ny\n\n    def setNy(self, ny):\n        self.ny = ny\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GetNotificationFilterResponse.py,0,"b'\n\nclass GetNotificationFilterResponse(object):\n\n    def __init__(self):\n        self.notificationFilter = None\n        self.jmsConnectionInfo = None\n\n    def getNotificationFilter(self):\n        return self.notificationFilter\n\n    def setNotificationFilter(self, notificationFilter):\n        self.notificationFilter = notificationFilter\n\n    def getJmsConnectionInfo(self):\n        return self.jmsConnectionInfo\n\n    def setJmsConnectionInfo(self, jmsConnectionInfo):\n        self.jmsConnectionInfo = jmsConnectionInfo\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/GridResponseData.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/04/13         #2023        dgilling       Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataaccess.response import AbstractResponseData\nimport six\n\n\nclass GridResponseData(AbstractResponseData):\n\n    def __init__(self):\n        super(GridResponseData, self).__init__()\n        self.parameter = None\n        self.unit = None\n        self.gridData = None\n\n    def getParameter(self):\n        if six.PY2:\n            return self.parameter\n        if self.parameter is not None:\n            return self.parameter.decode('utf-8')\n        return self.parameter\n\n    def setParameter(self, parameter):\n        self.parameter = parameter\n\n    def getUnit(self):\n        if six.PY2:\n            return self.unit\n        if self.unit is not None:\n            return self.unit.decode('utf-8')\n        return self.unit\n\n    def setUnit(self, unit):\n        self.unit = unit\n\n    def getGridData(self):\n        return self.gridData\n\n    def setGridData(self, gridData):\n        self.gridData = gridData\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataaccess/response/__init__.py,0,"b""\n__all__ = [\n            'AbstractResponseData',\n            'GeometryResponseData',\n            'GetGeometryDataResponse',\n            'GetGridDataResponse',\n            'GetGridLatLonResponse',\n            'GetNotificationFilterResponse',\n            'GridResponseData'\n          ]\n\nfrom .AbstractResponseData import AbstractResponseData\nfrom .GeometryResponseData import GeometryResponseData\nfrom .GetGeometryDataResponse import GetGeometryDataResponse\nfrom .GetGridDataResponse import GetGridDataResponse\nfrom .GetGridLatLonResponse import GetGridLatLonResponse\nfrom .GetNotificationFilterResponse import GetNotificationFilterResponse\nfrom .GridResponseData import GridResponseData\n\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/events/__init__.py,0,"b""\n__all__ = [\n            'hazards'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/GridDataHistory.py,0,"b'\n\nclass GridDataHistory(object):\n\n    def __init__(self):\n        self.origin = None\n        self.originParm = None\n        self.originTimeRange = None\n        self.timeModified = None\n        self.whoModified = None\n        self.updateTime = None\n        self.publishTime = None\n        self.lastSentTime = None\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        retVal = ""Origin: "" + self.origin + \'\\n\'\n        retVal += ""Origin Parm: "" + str(self.originParm) + \'\\n\'\n        retVal += ""Origin Time Range: "" + str(self.originTimeRange) +\\\n                  "" Time Modified: "" + str(self.timeModified) +\\\n                  "" Who Modified: "" + str(self.whoModified) + \'\\n\'\n        retVal += ""Update Time: "" + str(self.updateTime) + \'\\n\'\n        retVal += ""Publish Time: "" + str(self.publishTime) + \'\\n\'\n        retVal += ""Last Sent Time: "" + str(self.lastSentTime) + \'\\n\'\n        return retVal\n\n    def getOrigin(self):\n        return self.origin\n\n    def setOrigin(self, origin):\n        self.origin = origin\n\n    def getOriginParm(self):\n        return self.originParm\n\n    def setOriginParm(self, originParm):\n        self.originParm = originParm\n\n    def getOriginTimeRange(self):\n        return self.originTimeRange\n\n    def setOriginTimeRange(self, originTimeRange):\n        self.originTimeRange = originTimeRange\n\n    def getTimeModified(self):\n        return self.timeModified\n\n    def setTimeModified(self, timeModified):\n        self.timeModified = timeModified\n\n    def getWhoModified(self):\n        return self.whoModified\n\n    def setWhoModified(self, whoModified):\n        self.whoModified = whoModified\n\n    def getUpdateTime(self):\n        return self.updateTime\n\n    def setUpdateTime(self, updateTime):\n        self.updateTime = updateTime\n\n    def getPublishTime(self):\n        return self.publishTime\n\n    def setPublishTime(self, publishTime):\n        self.publishTime = publishTime\n\n    def getLastSentTime(self):\n        return self.lastSentTime\n\n    def setLastSentTime(self, lastSentTime):\n        self.lastSentTime = lastSentTime\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/__init__.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/22/2015       4573         randerso       Added svcbu package\n#    10/06/2015                    mjames@ucar    Removed svcbu package\n#\n\n__all__ = [\n            'config',\n            'db',\n            'discrete',\n            'grid',\n            'request',\n            'server',\n            'slice',\n            'weather',\n            'GridDataHistory'\n          ]\n\nfrom .GridDataHistory import GridDataHistory\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/grid/__init__.py,0,"b""\n__all__ = [\n            'request'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/level/Level.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/29/13         2023         dgilling       Initial Creation.\n#    02/12/14         2672         bsteffen       Allow String constructor to parse floats.\n#    06/29/15         4480         dgilling       Implement __hash__, __eq__,\n#                                                 __str__ and rich comparison operators.\n#\n\nimport re\nimport numpy\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.level import MasterLevel\n\nLEVEL_NAMING_REGEX = re.compile(""^(\\d*(?:\\.\\d*)?)(?:_(\\d*(?:\\.\\d*)?))?([a-zA-Z]+)$"")\nINVALID_VALUE = numpy.float64(-999999)\n\n\nclass Level(object):\n\n    def __init__(self, levelString=None):\n        self.id = 0\n        self.identifier = None\n        self.masterLevel = None\n        self.levelonevalue = INVALID_VALUE\n        self.leveltwovalue = INVALID_VALUE\n\n        if levelString is not None:\n            matcher = LEVEL_NAMING_REGEX.match(str(levelString))\n            if matcher is not None:\n                self.levelonevalue = numpy.float64(matcher.group(1))\n                self.masterLevel = MasterLevel.MasterLevel(matcher.group(3))\n                levelTwo = matcher.group(2)\n                if levelTwo:\n                    self.leveltwovalue = numpy.float64(levelTwo)\n\n    def __hash__(self):\n        # XOR-ing the 3 items in a tuple ensures that order of the\n        # values matters\n        hashCode = hash(self.masterLevel) ^ hash(self.levelonevalue) ^ hash(self.leveltwovalue)\n        hashCode ^= hash((self.masterLevel, self.levelonevalue, self.leveltwovalue))\n        return hashCode\n\n    def __eq__(self, other):\n        if isinstance(self, type(other)):\n            return (self.masterLevel, self.levelonevalue, self.leveltwovalue) == \\\n                (other.masterLevel, other.levelonevalue, other.leveltwovalue)\n        return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n        elif self.masterLevel.getName() != other.masterLevel.getName():\n            return NotImplemented\n\n        myLevel1 = self.levelonevalue\n        myLevel2 = self.leveltwovalue\n        otherLevel1 = other.levelonevalue\n        otherLevel2 = other.leveltwovalue\n        if myLevel1 == INVALID_VALUE and myLevel2 != INVALID_VALUE:\n            myLevel1 = myLevel2\n            myLevel2 = INVALID_VALUE\n        if otherLevel1 == INVALID_VALUE and otherLevel2 != INVALID_VALUE:\n            otherLevel1 = otherLevel2\n            otherLevel2 = INVALID_VALUE\n\n        # We default to descending order to make sorting levels from the DAF easier\n        compareType = self.masterLevel.getType() if self.masterLevel.getType() else ""DEC""\n        if myLevel1 != INVALID_VALUE and otherLevel1 != INVALID_VALUE:\n            level1Cmp = self.__compareLevelValues(compareType, myLevel1, otherLevel1)\n            if level1Cmp == -1:\n                if myLevel2 != INVALID_VALUE and otherLevel2 != INVALID_VALUE:\n                    level2Cmp = self.__compareLevelValues(compareType, myLevel2, otherLevel2)\n                    return level2Cmp == -1\n                elif myLevel2 != INVALID_VALUE:\n                    level2Cmp = self.__compareLevelValues(compareType, myLevel2, otherLevel1)\n                    return level2Cmp == -1\n                return True\n        return False\n\n    def __le__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n        elif self.masterLevel.getName() != other.masterLevel.getName():\n            return NotImplemented\n\n        return self.__lt__(other) or self.__eq__(other)\n\n    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n        elif self.masterLevel.getName() != other.masterLevel.getName():\n            return NotImplemented\n\n        myLevel1 = self.levelonevalue\n        myLevel2 = self.leveltwovalue\n        otherLevel1 = other.levelonevalue\n        otherLevel2 = other.leveltwovalue\n        if myLevel1 == INVALID_VALUE and myLevel2 != INVALID_VALUE:\n            myLevel1 = myLevel2\n            myLevel2 = INVALID_VALUE\n        if otherLevel1 == INVALID_VALUE and otherLevel2 != INVALID_VALUE:\n            otherLevel1 = otherLevel2\n            otherLevel2 = INVALID_VALUE\n\n        # We default to descending order to make sorting levels from the DAF easier\n        compareType = self.masterLevel.getType() if self.masterLevel.getType() else ""DEC""\n        if myLevel1 != INVALID_VALUE and otherLevel1 != INVALID_VALUE:\n            level1Cmp = self.__compareLevelValues(compareType, myLevel1, otherLevel1)\n            if level1Cmp == 1:\n                if myLevel2 != INVALID_VALUE and otherLevel2 != INVALID_VALUE:\n                    level2Cmp = self.__compareLevelValues(compareType, myLevel2, otherLevel2)\n                    return level2Cmp == 1\n                elif otherLevel2 != INVALID_VALUE:\n                    level2Cmp = self.__compareLevelValues(compareType, myLevel1, otherLevel2)\n                    return level2Cmp == 1\n                return True\n        return False\n\n    def __ge__(self, other):\n        if not isinstance(self, type(other)):\n            return NotImplemented\n        elif self.masterLevel.getName() != other.masterLevel.getName():\n            return NotImplemented\n\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __compareLevelValues(self, compareType, val1, val2):\n        returnVal = 0\n        if val1 < val2:\n            returnVal = -1 if compareType == \'INC\' else 1\n        elif val2 < val1:\n            returnVal = 1 if compareType == \'INC\' else -1\n        return returnVal\n\n    def __str__(self):\n        retVal = """"\n        if INVALID_VALUE != self.levelonevalue:\n            retVal += str(self.levelonevalue)\n        if INVALID_VALUE != self.leveltwovalue:\n            retVal += ""_"" + str(self.leveltwovalue)\n        retVal += str(self.masterLevel.getName())\n        return retVal\n\n    def getId(self):\n        return self.id\n\n    def setId(self, levelid):\n        self.id = levelid\n\n    def getMasterLevel(self):\n        return self.masterLevel\n\n    def setMasterLevel(self, masterLevel):\n        self.masterLevel = masterLevel\n\n    def getLevelonevalue(self):\n        return self.levelonevalue\n\n    def setLevelonevalue(self, levelonevalue):\n        self.levelonevalue = numpy.float64(levelonevalue)\n\n    def getLeveltwovalue(self):\n        return self.leveltwovalue\n\n    def setLeveltwovalue(self, leveltwovalue):\n        self.leveltwovalue = numpy.float64(leveltwovalue)\n\n    def getIdentifier(self):\n        return self.identifier\n\n    def setIdentifier(self, identifier):\n        self.identifier = identifier\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/level/MasterLevel.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/29/13         2023         dgilling       Initial Creation.\n#    06/29/15         4480         dgilling       Implement __hash__, __eq__\n#                                                 and __str__.\n\nimport six\n\n\nclass MasterLevel(object):\n\n    def __init__(self, name=None):\n        self.name = name\n        self.description = None\n        self.unitString = None\n        self.type = None\n        self.identifier = None\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def __eq__(self, other):\n        if not isinstance(self, type(other)):\n            return False\n        else:\n            return self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __str__(self):\n        if six.PY2:\n            retVal = ""MasterLevel[""\n            retVal += ""name="" + str(self.name) + "",""\n            retVal += ""type="" + str(self.type) + "",""\n            retVal += ""unit="" + str(self.unitString) + "",""\n            retVal += ""description="" + str(self.description)\n            retVal += ""]""\n        else:\n            retVal = ""MasterLevel[""\n            retVal += ""name="" + str(self.name.decode(\'utf-8\')) + "",""\n            retVal += ""type="" + str(self.type.decode(\'utf-8\')) + "",""\n            retVal += ""unit="" + str(self.unitString.decode(\'utf-8\')) + "",""\n            retVal += ""description="" + str(self.description.decode(\'utf-8\'))\n            retVal += ""]""\n        return retVal\n\n    def getName(self):\n        if six.PY2:\n            return self.name\n        if (self.name is not None) and (not isinstance(self.name, str)):\n            return self.name.decode(\'utf-8\')\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getDescription(self):\n        if six.PY2:\n            return self.description\n        if self.description is not None:\n            return self.description.decode(\'utf-8\')\n        return self.description\n\n    def setDescription(self, description):\n        self.description = description\n\n    def getUnitString(self):\n        if six.PY2:\n            return self.unitString\n        if self.unitString is not None:\n            return self.unitString.decode(\'utf-8\')\n        return self.unitString\n\n    def setUnitString(self, unitString):\n        self.unitString = unitString\n\n    def getType(self):\n        if six.PY2:\n            return self.type\n        if self.type is not None:\n            return self.type.decode(\'utf-8\')\n        return self.type\n\n    def setType(self, leveltype):\n        self.type = leveltype\n\n    def getIdentifier(self):\n        if six.PY2:\n            return self.identifier\n        if self.identifier is not None:\n            return self.identifier.decode(\'utf-8\')\n        return self.identifier\n\n    def setIdentifier(self, identifier):\n        self.identifier = identifier\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/level/__init__.py,0,"b""\n__all__ = [\n            'Level',\n            'MasterLevel'\n          ]\n\nfrom .Level import Level\nfrom .MasterLevel import MasterLevel\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/message/DataURINotificationMessage.py,0,"b'\n\nclass DataURINotificationMessage(object):\n\n    def __init__(self):\n        self.dataURIs = None\n        self.ids = None\n\n    def getDataURIs(self):\n        return self.dataURIs\n\n    def setDataURIs(self, dataURIs):\n        self.dataURIs = dataURIs\n\n    def getIds(self):\n        return self.ids\n\n    def setIds(self, ids):\n        self.ids = ids\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/message/__init__.py,0,"b""\n__all__ = [\n            'DataURINotificationMessage'\n          ]\n\nfrom .DataURINotificationMessage import DataURINotificationMessage\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/__init__.py,0,"b""\n__all__ = [\n            'request',\n            'response'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/__init__.py,0,"b""\n__all__ = [\n            'dbsrv',\n            'subscription'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataquery/requests/RequestConstraint.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Jun 01, 2016    5574          tgurney        Initial creation\n#     Jun 27, 2016    5725          tgurney        Add NOT IN\n#     Jul 22, 2016    2416          tgurney        Add evaluate()\n#     Oct 05, 2018                  mjames@ucar    Python 3 types\n#\n#\n\nimport re\nimport six\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import DataTime\n\n\nclass RequestConstraint(object):\n\n    TOLERANCE = 0.0001\n\n    IN_PATTERN = re.compile(\',\\s?\')\n\n    def __init__(self):\n        self.constraintValue = None\n        self.constraintType = None\n\n    def getConstraintValue(self):\n        return self.constraintValue\n\n    def setConstraintValue(self, constraintValue):\n        if hasattr(self, \'_evalValue\'):\n            del self._evalValue\n        self.constraintValue = constraintValue\n\n    def getConstraintType(self):\n        return self.constraintType\n\n    def setConstraintType(self, constraintType):\n        if hasattr(self, \'_evalValue\'):\n            del self._evalValue\n        self.constraintType = constraintType\n\n    def evaluate(self, value):\n        if not hasattr(self, \'_evalValue\'):\n            self._setupEvalValue()\n\n        if self.constraintType == \'EQUALS\':\n            return self._evalEquals(value)\n        elif self.constraintType == \'NOT_EQUALS\':\n            return not self._evalEquals(value)\n        elif self.constraintType == \'GREATER_THAN\':\n            return self._evalGreaterThan(value)\n        elif self.constraintType == \'GREATER_THAN_EQUALS\':\n            return self._evalGreaterThanEquals(value)\n        elif self.constraintType == \'LESS_THAN\':\n            return self._evalLessThan(value)\n        elif self.constraintType == \'LESS_THAN_EQUALS\':\n            return self._evalLessThanEquals(value)\n        elif self.constraintType == \'BETWEEN\':\n            return self._evalBetween(value)\n        elif self.constraintType == \'IN\':\n            return self._evalIn(value)\n        elif self.constraintType == \'NOT_IN\':\n            return not self._evalIn(value)\n        elif self.constraintType == \'LIKE\':\n            return self._evalLike(value)\n        # setupConstraintType already adds correct flags for ilike\n        # on regex pattern\n        elif self.constraintType == \'ILIKE\':\n            return self._evalLike(value)\n        elif self.constraintType == \'ISNULL\':\n            return self._evalIsNull(value)\n        elif self.constraintType == \'ISNOTNULL\':\n            return not self._evalIsNull(value)\n        else:\n            errmsg = \'{} is not a valid constraint type.\'\n            raise ValueError(errmsg.format(self.constraintType))\n\n    def _makeRegex(self, pattern, flags):\n        """"""Make a pattern using % wildcard into a regex""""""\n        pattern = re.escape(pattern)\n        pattern = pattern.replace(\'\\\\%\', \'.*\')\n        pattern = pattern.replace(\'\\\\_\', \'.\')\n        pattern = pattern + \'$\'\n        return re.compile(pattern, flags)\n\n    def _setupEvalValue(self):\n        if self.constraintType == \'BETWEEN\':\n            self._evalValue = self.constraintValue.split(\'--\')\n            self._evalValue[0] = self._adjustValueType(self._evalValue[0])\n            self._evalValue[1] = self._adjustValueType(self._evalValue[1])\n        elif self.constraintType in (\'IN\', \'NOT_IN\'):\n            splitValue = self.IN_PATTERN.split(self.constraintValue)\n            self._evalValue = {\n                self._adjustValueType(value)\n                for value in splitValue\n                }\n            # if collection now contains multiple types we have to force\n            # everything to string instead\n            initialType = next(iter(self._evalValue)).__class__\n            for item in self._evalValue:\n                if item.__class__ is not initialType:\n                    self._evalValue = {str(value) for value in splitValue}\n                    break\n        elif self.constraintType == \'LIKE\':\n            self._evalValue = self._makeRegex(self.constraintValue, re.DOTALL)\n        elif self.constraintType == \'ILIKE\':\n            self._evalValue = self._makeRegex(self.constraintValue, re.IGNORECASE | re.DOTALL)\n        elif self.constraintValue is None:\n            self._evalValue = None\n        else:\n            self._evalValue = self._adjustValueType(self.constraintValue)\n\n    def _adjustValueType(self, value):\n        """"""\n        Try to take part of a constraint value, encoded as a string, and\n        return it as its \'true type\'.\n\n        _adjustValueType(\'3.0\') -> 3.0\n        _adjustValueType(\'3\') -> 3.0\n        _adjustValueType(\'a string\') -> \'a string\'\n        """"""\n        try:\n            return float(value)\n        except ValueError:\n            pass\n        try:\n            return DataTime(value)\n        except ValueError:\n            pass\n        return value\n\n    def _matchType(self, value, otherValue):\n        """"""\n        Return value coerced to be the same type as otherValue. If this is\n        not possible, just return value unmodified.\n        """"""\n        if not isinstance(value, otherValue.__class__):\n            try:\n                return otherValue.__class__(value)\n            except ValueError:\n                pass\n        return value\n\n    def _evalEquals(self, value):\n        value = self._matchType(value, self._evalValue)\n        if isinstance(value, float):\n            return abs(float(self._evalValue) - value) < self.TOLERANCE\n        return value == self._evalValue\n\n    def _evalGreaterThan(self, value):\n        value = self._matchType(value, self._evalValue)\n        return value > self._evalValue\n\n    def _evalGreaterThanEquals(self, value):\n        value = self._matchType(value, self._evalValue)\n        return value >= self._evalValue\n\n    def _evalLessThan(self, value):\n        value = self._matchType(value, self._evalValue)\n        return value < self._evalValue\n\n    def _evalLessThanEquals(self, value):\n        value = self._matchType(value, self._evalValue)\n        return value <= self._evalValue\n\n    def _evalBetween(self, value):\n        value = self._matchType(value, self._evalValue[0])\n        return self._evalValue[0] <= value <= self._evalValue[1]\n\n    def _evalIn(self, value):\n        anEvalValue = next(iter(self._evalValue))\n        if isinstance(anEvalValue, float):\n            for otherValue in self._evalValue:\n                try:\n                    if abs(otherValue - float(value)) < self.TOLERANCE:\n                        return True\n                except ValueError:\n                    pass\n            return False\n        value = self._matchType(value, anEvalValue)\n        return value in self._evalValue\n\n    def _evalLike(self, value):\n        value = self._matchType(value, self._evalValue)\n        if self.constraintValue == \'%\':\n            return True\n        return self._evalValue.match(value) is not None\n\n    def _evalIsNull(self, value):\n        return value is None or value == \'null\'\n\n    # DAF-specific stuff begins here ##########################################\n\n    CONSTRAINT_MAP = {\'=\': \'EQUALS\',\n                      \'!=\': \'NOT_EQUALS\',\n                      \'>\': \'GREATER_THAN\',\n                      \'>=\': \'GREATER_THAN_EQUALS\',\n                      \'<\': \'LESS_THAN\',\n                      \'<=\': \'LESS_THAN_EQUALS\',\n                      \'IN\': \'IN\',\n                      \'NOT IN\': \'NOT_IN\'\n                      }\n\n    @staticmethod\n    def _stringify(value):\n        if six.PY2:\n            if isinstance(value, (str, int, long, bool, float, unicode)):\n                return str(value)\n            else:\n                # Collections are not allowed; they are handled separately.\n                # Arbitrary objects are not allowed because the string\n                # representation may not be sufficient to reconstruct the object.\n                raise TypeError(\'Constraint values of type \' + repr(type(value)) +\n                                \'are not allowed\')\n        else:\n            if isinstance(value, (str, int, bool, float)):\n                return str(value)\n            else:\n                # Collections are not allowed; they are handled separately.\n                # Arbitrary objects are not allowed because the string\n                # representation may not be sufficient to reconstruct the object.\n                raise TypeError(\'Constraint values of type \' + repr(type(value)) +\n                                \'are not allowed\')\n\n    @classmethod\n    def _constructIn(cls, constraintType, constraintValue):\n        """"""Build a new ""IN"" or ""NOT IN"" constraint from an iterable.""""""\n        try:\n            iterator = iter(constraintValue)\n        except TypeError:\n            raise TypeError(""value for IN / NOT IN constraint must be an iterable"")\n        stringValue = \', \'.join(cls._stringify(item) for item in iterator)\n        if not stringValue:\n            raise ValueError(\'cannot use IN / NOT IN with empty collection\')\n        obj = cls()\n        obj.setConstraintType(constraintType)\n        obj.setConstraintValue(stringValue)\n        return obj\n\n    @classmethod\n    def _constructEq(cls, constraintType, constraintValue):\n        """"""Build a new = or != constraint. Handle None specially by making an\n        ""is null"" or ""is not null"" instead.\n        """"""\n        obj = cls()\n        if constraintValue is None:\n            if constraintType == \'EQUALS\':\n                obj.setConstraintType(\'ISNULL\')\n            elif constraintType == \'NOT_EQUALS\':\n                obj.setConstraintType(\'ISNOTNULL\')\n        else:\n            obj = cls._construct(constraintType, constraintValue)\n        return obj\n\n    @classmethod\n    def _construct(cls, constraintType, constraintValue):\n        """"""Build a new constraint.""""""\n        stringValue = cls._stringify(constraintValue)\n        obj = cls()\n        obj.setConstraintType(constraintType)\n        obj.setConstraintValue(stringValue)\n        return obj\n\n    @classmethod\n    def new(cls, operator, constraintValue):\n        """"""Build a new RequestConstraint.""""""\n        try:\n            constraintType = cls.CONSTRAINT_MAP[operator.upper()]\n        except KeyError:\n            errmsg = \'{} is not a valid operator. Valid operators are: {}\'\n            validOperators = list(sorted(cls.CONSTRAINT_MAP.keys()))\n            raise ValueError(errmsg.format(operator, validOperators))\n        if constraintType in (\'IN\', \'NOT_IN\'):\n            return cls._constructIn(constraintType, constraintValue)\n        elif constraintType in {\'EQUALS\', \'NOT_EQUALS\'}:\n            return cls._constructEq(constraintType, constraintValue)\n        return cls._construct(constraintType, constraintValue)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataquery/requests/__init__.py,0,"b""\n__all__ = [\n            'RequestConstraint'\n          ]\n\nfrom .RequestConstraint import RequestConstraint\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/AbstractDataRecord.py,0,"b'\nfrom six import with_metaclass\nimport abc\n\n\nclass AbstractDataRecord(with_metaclass(abc.ABCMeta, object)):\n\n    def __init__(self):\n        self.name = None\n        self.dimension = None\n        self.sizes = None\n        self.maxSizes = None\n        self.props = None\n        self.minIndex = None\n        self.group = None\n        self.dataAttributes = None\n        self.fillValue = None\n        self.maxChunkSize = None\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getDimension(self):\n        return self.dimension\n\n    def setDimension(self, dimension):\n        self.dimension = dimension\n\n    def getSizes(self):\n        return self.sizes\n\n    def setSizes(self, sizes):\n        self.sizes = sizes\n\n    def getMaxSizes(self):\n        return self.maxSizes\n\n    def setMaxSizes(self, maxSizes):\n        self.maxSizes = maxSizes\n\n    def getProps(self):\n        return self.props\n\n    def setProps(self, props):\n        self.props = props\n\n    def getMinIndex(self):\n        return self.minIndex\n\n    def setMinIndex(self, minIndex):\n        self.minIndex = minIndex\n\n    def getGroup(self):\n        return self.group\n\n    def setGroup(self, group):\n        self.group = group\n\n    def getDataAttributes(self):\n        return self.dataAttributes\n\n    def setDataAttributes(self, dataAttributes):\n        self.dataAttributes = dataAttributes\n\n    def getFillValue(self):\n        return self.fillValue\n\n    def setFillValue(self, fillValue):\n        self.fillValue = fillValue\n\n    def getMaxChunkSize(self):\n        return self.maxChunkSize\n\n    def setMaxChunkSize(self, maxChunkSize):\n        self.maxChunkSize = maxChunkSize\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/ByteDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass ByteDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(ByteDataRecord, self).__init__()\n        self.byteData = None\n\n    def getByteData(self):\n        return self.byteData\n\n    def setByteData(self, byteData):\n        self.byteData = byteData\n\n    def retrieveDataObject(self):\n        return self.getByteData()\n\n    def putDataObject(self, obj):\n        self.setByteData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/DoubleDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass DoubleDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(DoubleDataRecord, self).__init__()\n        self.doubleData = None\n\n    def getDoubleData(self):\n        return self.doubleData\n\n    def setDoubleData(self, doubleData):\n        self.doubleData = doubleData\n\n    def retrieveDataObject(self):\n        return self.getDoubleData()\n\n    def putDataObject(self, obj):\n        self.setDoubleData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/FloatDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass FloatDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(FloatDataRecord, self).__init__()\n        self.floatData = None\n\n    def getFloatData(self):\n        return self.floatData\n\n    def setFloatData(self, floatData):\n        self.floatData = floatData\n\n    def retrieveDataObject(self):\n        return self.getFloatData()\n\n    def putDataObject(self, obj):\n        self.setFloatData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/IntegerDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass IntegerDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(IntegerDataRecord, self).__init__()\n        self.intData = None\n\n    def getIntData(self):\n        return self.intData\n\n    def setIntData(self, intData):\n        self.intData = intData\n\n    def retrieveDataObject(self):\n        return self.getIntData()\n\n    def putDataObject(self, obj):\n        self.setIntData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/LongDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass LongDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(LongDataRecord, self).__init__()\n        self.longData = None\n\n    def getLongData(self):\n        return self.longData\n\n    def setLongData(self, longData):\n        self.longData = longData\n\n    def retrieveDataObject(self):\n        return self.getLongData()\n\n    def putDataObject(self, obj):\n        self.setLongData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/ShortDataRecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass ShortDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(ShortDataRecord, self).__init__()\n        self.shortData = None\n\n    def getShortData(self):\n        return self.shortData\n\n    def setShortData(self, shortData):\n        self.shortData = shortData\n\n    def retrieveDataObject(self):\n        return self.getShortData()\n\n    def putDataObject(self, obj):\n        self.setShortData(obj)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/StringDataRecord.py,0,"b""from dynamicserialize.dstypes.com.raytheon.uf.common.datastorage.records import AbstractDataRecord\n\n\nclass StringDataRecord(AbstractDataRecord):\n\n    def __init__(self):\n        super(StringDataRecord, self).__init__()\n        self.stringData = None\n        self.maxLength = None\n        self.numpyData = None\n\n    def getStringData(self):\n        return self.stringData\n\n    def setStringData(self, stringData):\n        self.stringData = stringData\n\n    def getMaxLength(self):\n        return self.maxLength\n\n    def setMaxLength(self, maxLength):\n        self.maxLength = maxLength\n\n    def retrieveDataObject(self):\n        if not self.numpyData:\n            import numpy\n            from h5py import h5t\n            if self.maxLength:\n                dtype = h5t.py_create('S' + str(self.maxLength))\n            else:\n                from pypies.impl.H5pyDataStore import vlen_str_type as dtype\n            # dtype.set_strpad(h5t.STR_NULLTERM)\n            return numpy.asarray(self.getStringData(), dtype)\n        return self.numpyData\n\n    def putDataObject(self, obj):\n        self.setStringData(obj)\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/datastorage/records/__init__.py,0,"b""#\n# Package definition for com.raytheon.uf.common.datastorage.records\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    08/31/10                      njensen        Initial Creation.\n#    Apr 24, 2015    4425          nabowle        Add DoubleDataRecord\n#\n\n__all__ = [\n            'AbstractDataRecord',\n            'ByteDataRecord',\n            'DoubleDataRecord',\n            'FloatDataRecord',\n            'IntegerDataRecord',\n            'LongDataRecord',\n            'ShortDataRecord',\n            'StringDataRecord'\n          ]\n\nfrom .AbstractDataRecord import AbstractDataRecord\nfrom .ByteDataRecord import ByteDataRecord\nfrom .DoubleDataRecord import DoubleDataRecord\nfrom .FloatDataRecord import FloatDataRecord\nfrom .IntegerDataRecord import IntegerDataRecord\nfrom .LongDataRecord import LongDataRecord\nfrom .ShortDataRecord import ShortDataRecord\nfrom .StringDataRecord import StringDataRecord\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/DeleteUtilityCommand.py,0,"b'\n\nclass DeleteUtilityCommand(object):\n\n    def __init__(self):\n        self.filename = None\n        self.context = None\n        self.myContextName = None\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n\n    def getMyContextName(self):\n        return self.myContextName\n\n    def setMyContextName(self, contextName):\n        self.myContextName = str(contextName)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/DeleteUtilityResponse.py,0,"b'\n\nclass DeleteUtilityResponse(object):\n\n    def __init__(self):\n        self.context = None\n        self.pathName = None\n        self.errorText = None\n        self.timeStamp = None\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n\n    def getPathName(self):\n        return self.pathName\n\n    def setPathName(self, pathName):\n        self.pathName = pathName\n\n    def getErrorText(self):\n        return self.errorText\n\n    def setErrorText(self, errorText):\n        self.errorText = errorText\n\n    def getTimeStamp(self):\n        return self.timeStamp\n\n    def setTimeStamp(self, timeStamp):\n        self.timeStamp = timeStamp\n\n    def getFormattedErrorMessage(self):\n        return ""Error deleting "" + self.getContextRelativePath() + "": "" + self.getErrorText()\n\n    def getContextRelativePath(self):\n        return str(self.getContext()) + ""/"" + self.getPathName()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/ListResponseEntry.py,0,"b'\n\nclass ListResponseEntry(object):\n\n    def __init__(self):\n        self.fileName = None\n        self.context = None\n        self.date = None\n        self.checksum = None\n        self.directory = None\n        self.protectedLevel = None\n        self.existsOnServer = None\n\n    def getFileName(self):\n        return self.fileName\n\n    def setFileName(self, fileName):\n        self.fileName = fileName\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n\n    def getDate(self):\n        return self.date\n\n    def setDate(self, date):\n        self.date = date\n\n    def getChecksum(self):\n        return self.checksum\n\n    def setChecksum(self, checksum):\n        self.checksum = checksum\n\n    def getDirectory(self):\n        return self.directory\n\n    def setDirectory(self, directory):\n        self.directory = directory\n\n    def getProtectedFile(self):\n        return self.protectedLevel is not None\n\n    def getProtectedLevel(self):\n        return self.protectedLevel\n\n    def setProtectedLevel(self, protectedLevel):\n        self.protectedLevel = protectedLevel\n\n    def getExistsOnServer(self):\n        return self.existsOnServer\n\n    def setExistsOnServer(self, existsOnServer):\n        self.existsOnServer = existsOnServer\n\n    def __str__(self):\n        return self.fileName\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/ListUtilityCommand.py,0,"b'\n\nclass ListUtilityCommand(object):\n\n    def __init__(self):\n        self.subDirectory = None\n        self.recursive = None\n        self.filesOnly = None\n        self.localizedSite = None\n        self.context = None\n\n    def getSubDirectory(self):\n        return self.subDirectory\n\n    def setSubDirectory(self, subDirectory):\n        self.subDirectory = subDirectory\n\n    def getRecursive(self):\n        return self.recursive\n\n    def setRecursive(self, recursive):\n        self.recursive = recursive\n\n    def getFilesOnly(self):\n        return self.filesOnly\n\n    def setFilesOnly(self, filesOnly):\n        self.filesOnly = filesOnly\n\n    def getLocalizedSite(self):\n        return self.localizedSite\n\n    def setLocalizedSite(self, localizedSite):\n        self.localizedSite = localizedSite\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/ListUtilityResponse.py,0,"b'\n\nclass ListUtilityResponse(object):\n\n    def __init__(self):\n        self.entries = None\n        self.context = None\n        self.pathName = None\n        self.errorText = None\n\n    def getEntries(self):\n        return self.entries\n\n    def setEntries(self, entries):\n        self.entries = entries\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n\n    def getPathName(self):\n        return self.pathName\n\n    def setPathName(self, pathName):\n        self.pathName = pathName\n\n    def getErrorText(self):\n        return self.errorText\n\n    def setErrorText(self, errorText):\n        self.errorText = errorText\n\n    def __str__(self):\n        if self.errorText is None:\n            return str(self.entries)\n        else:\n            return ""Error retrieving file listing for "" + self.pathName + "": "" + \\\n                    self.errorText\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/PrivilegedUtilityRequestMessage.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.auth.user import User\n\n\nclass PrivilegedUtilityRequestMessage(object):\n\n    def __init__(self):\n        self.commands = None\n        self.user = User()\n\n    def getCommands(self):\n        return self.commands\n\n    def setCommands(self, commands):\n        self.commands = commands\n\n    def getUser(self):\n        return self.user\n\n    def setUser(self, user):\n        self.user = user\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/UtilityRequestMessage.py,0,"b'\n\nclass UtilityRequestMessage(object):\n\n    def __init__(self):\n        self.commands = None\n\n    def getCommands(self):\n        return self.commands\n\n    def setCommands(self, commands):\n        self.commands = commands\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/UtilityResponseMessage.py,0,"b'\n\nclass UtilityResponseMessage(object):\n\n    def __init__(self):\n        self.responses = None\n\n    def getResponses(self):\n        return self.responses\n\n    def setResponses(self, responses):\n        self.responses = responses\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/msgs/__init__.py,0,"b""\n__all__ = [\n            'DeleteUtilityCommand',\n            'DeleteUtilityResponse',\n            'ListResponseEntry',\n            'ListUtilityCommand',\n            'ListUtilityResponse',\n            'PrivilegedUtilityRequestMessage',\n            'UtilityRequestMessage',\n            'UtilityResponseMessage'\n          ]\n\nfrom .DeleteUtilityCommand import DeleteUtilityCommand\nfrom .DeleteUtilityResponse import DeleteUtilityResponse\nfrom .ListResponseEntry import ListResponseEntry\nfrom .ListUtilityCommand import ListUtilityCommand\nfrom .ListUtilityResponse import ListUtilityResponse\nfrom .PrivilegedUtilityRequestMessage import PrivilegedUtilityRequestMessage\nfrom .UtilityRequestMessage import UtilityRequestMessage\nfrom .UtilityResponseMessage import UtilityResponseMessage\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/localization/stream/AbstractLocalizationStreamRequest.py,0,"b'from six import with_metaclass\nimport abc\nimport os\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.auth.user import User\n\n\nclass AbstractLocalizationStreamRequest(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.context = None\n        self.fileName = None\n        self.myContextName = None\n        self.user = User()\n\n    def getContext(self):\n        return self.context\n\n    def setContext(self, context):\n        self.context = context\n\n    def getFileName(self):\n        return self.fileName\n\n    def setFileName(self, fileName):\n        if fileName[0] == os.sep:\n            fileName = fileName[1:]\n        self.fileName = fileName\n\n    def getMyContextName(self):\n        return self.myContextName\n\n    def setMyContextName(self, contextName):\n        self.myContextName = str(contextName)\n\n    def getUser(self):\n        return self.user\n\n    def setUser(self, user):\n        self.user = user\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/stream/LocalizationStreamGetRequest.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.localization.stream import AbstractLocalizationStreamRequest\n\n\nclass LocalizationStreamGetRequest(AbstractLocalizationStreamRequest):\n\n    def __init__(self):\n        super(LocalizationStreamGetRequest, self).__init__()\n        self.offset = None\n        self.numBytes = None\n\n    def getOffset(self):\n        return self.offset\n\n    def setOffset(self, offset):\n        self.offset = offset\n\n    def getNumBytes(self):\n        return self.numBytes\n\n    def setNumBytes(self, numBytes):\n        self.numBytes = numBytes\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/stream/LocalizationStreamPutRequest.py,0,"b'\nimport uuid\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.localization.stream import AbstractLocalizationStreamRequest\n\n\nclass LocalizationStreamPutRequest(AbstractLocalizationStreamRequest):\n\n    def __init__(self):\n        super(LocalizationStreamPutRequest, self).__init__()\n        self.id = str(uuid.uuid4())\n        self.bytes = None\n        self.end = None\n        self.offset = None\n        self.localizedSite = None\n\n    def getId(self):\n        return self.id\n\n    def setId(self, requestid):\n        self.id = requestid\n\n    def getBytes(self):\n        return self.bytes\n\n    def setBytes(self, streambytes):\n        self.bytes = streambytes\n\n    def getEnd(self):\n        return self.end\n\n    def setEnd(self, end):\n        self.end = end\n\n    def getOffset(self):\n        return self.offset\n\n    def setOffset(self, offset):\n        self.offset = offset\n\n    def getLocalizedSite(self):\n        return self.localizedSite\n\n    def setLocalizedSite(self, localizedSite):\n        self.localizedSite = localizedSite\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/localization/stream/__init__.py,0,"b""\n__all__ = [\n            'AbstractLocalizationStreamRequest',\n            'LocalizationStreamGetRequest',\n            'LocalizationStreamPutRequest'\n          ]\n\nfrom .AbstractLocalizationStreamRequest import AbstractLocalizationStreamRequest\nfrom .LocalizationStreamGetRequest import LocalizationStreamGetRequest\nfrom .LocalizationStreamPutRequest import LocalizationStreamPutRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/ChangeContextRequest.py,0,"b'\n\nclass ChangeContextRequest(object):\n\n    def __init__(self):\n        self.action = None\n        self.contextName = None\n\n    def getAction(self):\n        return self.action\n\n    def setAction(self, action):\n        self.action = action\n\n    def getContextName(self):\n        return self.contextName\n\n    def setContextName(self, contextName):\n        self.contextName = contextName\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/PassThroughRequest.py,0,"b'\n\nclass PassThroughRequest(object):\n\n    def __init__(self):\n        self.request = None\n        self.hostname = None\n        self.jvmName = None\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n\n    def getHostname(self):\n        return self.hostname\n\n    def setHostname(self, hostname):\n        self.hostname = hostname\n\n    def getJvmName(self):\n        return self.jvmName\n\n    def setJvmName(self, jvmName):\n        self.jvmName = jvmName\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/__init__.py,0,"b""\n__all__ = [\n            'diagnostic',\n            'ChangeContextRequest',\n            'PassThroughRequest'\n          ]\n\nfrom .ChangeContextRequest import ChangeContextRequest\nfrom .PassThroughRequest import PassThroughRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/response/__init__.py,0,"b""\n__all__ = [\n            'diagnostic'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pointdata/requests/NewAdaptivePlotRequest.py,0,"b'\n\nclass NewAdaptivePlotRequest(object):\n\n    def __init__(self):\n        self.fileContents = None\n        self.fileName = None\n        self.bundleName = None\n        self.description = None\n\n    def getFileContents(self):\n        return self.fileContents\n\n    def setFileContents(self, fileContents):\n        self.fileContents = fileContents\n\n    def getFileName(self):\n        return self.fileName\n\n    def setFileName(self, fileName):\n        self.fileName = fileName\n\n    def getBundleName(self):\n        return self.bundleName\n\n    def setBundleName(self, bundleName):\n        self.bundleName = bundleName\n\n    def getDescription(self):\n        return self.description\n\n    def setDescription(self, description):\n        self.description = description\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pointdata/requests/__init__.py,0,"b""\n__all__ = [\n            'NewAdaptivePlotRequest'\n          ]\n\nfrom .NewAdaptivePlotRequest import NewAdaptivePlotRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/records/CompressedDataRecord.py,0,"b'#\n# Compressed version of a DataRecord.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    12/02/16        5992          bsteffen       Initial Creation.\n#    06/26/17        6341          rjpeter        Optimize decompress\n#\n\nimport numpy\nimport zlib\n\n\nclass CompressedDataRecord(object):\n\n    def __init__(self):\n        self.type = None\n        self.uncompressedData = None\n        self.compressedData = None\n        self.name = None\n        self.dimension = None\n        self.sizes = None\n        self.maxSizes = None\n        self.props = None\n        self.minIndex = None\n        self.group = None\n        self.dataAttributes = None\n        self.fillValue = None\n        self.maxChunkSize = None\n\n    def getType(self):\n        return self.type\n\n    def setType(self, recordtype):\n        self.type = recordtype\n\n    def getCompressedData(self):\n        return self.compressedData\n\n    def setCompressedData(self, compressedData):\n        self.compressedData = compressedData\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getDimension(self):\n        return self.dimension\n\n    def setDimension(self, dimension):\n        self.dimension = dimension\n\n    def getSizes(self):\n        return self.sizes\n\n    def setSizes(self, sizes):\n        self.sizes = sizes\n\n    def getMaxSizes(self):\n        return self.maxSizes\n\n    def setMaxSizes(self, maxSizes):\n        self.maxSizes = maxSizes\n\n    def getProps(self):\n        return self.props\n\n    def setProps(self, props):\n        self.props = props\n\n    def getMinIndex(self):\n        return self.minIndex\n\n    def setMinIndex(self, minIndex):\n        self.minIndex = minIndex\n\n    def getGroup(self):\n        return self.group\n\n    def setGroup(self, group):\n        self.group = group\n\n    def getDataAttributes(self):\n        return self.dataAttributes\n\n    def setDataAttributes(self, dataAttributes):\n        self.dataAttributes = dataAttributes\n\n    def getFillValue(self):\n        return self.fillValue\n\n    def setFillValue(self, fillValue):\n        self.fillValue = fillValue\n\n    def getMaxChunkSize(self):\n        return self.maxChunkSize\n\n    def setMaxChunkSize(self, maxChunkSize):\n        self.maxChunkSize = maxChunkSize\n\n    def determineStorageType(self):\n        if self.type == ""BYTE"":\n            return numpy.byte\n        elif self.type == ""SHORT"":\n            return numpy.short\n        elif self.type == ""INT"":\n            return numpy.int32\n        elif self.type == ""LONG"":\n            return numpy.int64\n        elif self.type == ""FLOAT"":\n            return numpy.float32\n        elif self.type == ""DOUBLE"":\n            return numpy.float64\n        else:\n            raise TypeError(""Unexpected compressed type "" + str(self.type))\n\n    # utilize zlib directly to take advantage of passing in initial size of the\n    # decompress buffer, which prevents repeated allocation of a growing buffer\n    # for each chunk\n    def decompress(self):\n        datatype = numpy.dtype(self.determineStorageType()).newbyteorder(\'>\')\n        compressedBuffer = numpy.getbuffer(self.compressedData)\n        self.compressedData = None\n        uncompressedSize = datatype.itemsize\n        for s in self.sizes:\n            uncompressedSize *= s\n\n        # zlib.MAX_WBITS | 16, add 16 to window bits to support gzip header/trailer\n        # http://www.zlib.net/manual.html#Advanced\n        decompressedBuffer = zlib.decompress(compressedBuffer, zlib.MAX_WBITS | 16, uncompressedSize)\n        self.uncompressedData = numpy.frombuffer(decompressedBuffer, datatype)\n\n    def retrieveDataObject(self):\n        if self.uncompressedData is None:\n            self.decompress()\n        return self.uncompressedData\n\n    def putDataObject(self, obj):\n        self.compressedData = None\n        self.uncompressedData = obj\n\n    prepareStore = decompress\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/records/__init__.py,0,"b""\n__all__ = [\n            'CompressedDataRecord'\n          ]\n\nfrom .CompressedDataRecord import CompressedDataRecord\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/CopyRequest.py,0,"b'\n\nclass CopyRequest(object):\n\n    def __init__(self):\n        self.repack = None\n        self.repackCompression = None\n        self.outputDir = None\n        self.minMillisSinceLastChange = None\n        self.maxMillisSinceLastChange = None\n        self.filename = None\n\n    def getRepack(self):\n        return self.repack\n\n    def setRepack(self, repack):\n        self.repack = repack\n\n    def getRepackCompression(self):\n        return self.repackCompression\n\n    def setRepackCompression(self, repackCompression):\n        self.repackCompression = repackCompression\n\n    def getOutputDir(self):\n        return self.outputDir\n\n    def setOutputDir(self, outputDir):\n        self.outputDir = outputDir\n\n    def getMinMillisSinceLastChange(self):\n        return self.minMillisSinceLastChange\n\n    def setMinMillisSinceLastChange(self, minMillisSinceLastChange):\n        self.minMillisSinceLastChange = minMillisSinceLastChange\n\n    def getMaxMillisSinceLastChange(self):\n        return self.maxMillisSinceLastChange\n\n    def setMaxMillisSinceLastChange(self, maxMillisSinceLastChange):\n        self.maxMillisSinceLastChange = maxMillisSinceLastChange\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/CreateDatasetRequest.py,0,"b'\n\nclass CreateDatasetRequest(object):\n\n    def __init__(self):\n        self.record = None\n        self.filename = None\n\n    def getRecord(self):\n        return self.record\n\n    def setRecord(self, record):\n        self.record = record\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/DatasetDataRequest.py,0,"b'\n\nclass DatasetDataRequest(object):\n\n    def __init__(self):\n        self.datasetGroupPath = None\n        self.request = None\n        self.filename = None\n\n    def getDatasetGroupPath(self):\n        return self.datasetGroupPath\n\n    def setDatasetGroupPath(self, datasetGroupPath):\n        self.datasetGroupPath = datasetGroupPath\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/DatasetNamesRequest.py,0,"b'\n\nclass DatasetNamesRequest(object):\n\n    def __init__(self):\n        self.group = None\n        self.filename = None\n\n    def getGroup(self):\n        return self.group\n\n    def setGroup(self, group):\n        self.group = group\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/DeleteFilesRequest.py,0,"b'\n\nclass DeleteFilesRequest(object):\n\n    def __init__(self):\n        self.datesToDelete = None\n\n    def getDatesToDelete(self):\n        return self.datesToDelete\n\n    def setDatesToDelete(self, datesToDelete):\n        self.datesToDelete = datesToDelete\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/DeleteOrphansRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Jul 27, 2015    1574          nabowle        Generated\n#     Feb 23, 2016    5389          nabowle        Regenerated\n\n\nclass DeleteOrphansRequest(object):\n\n    def __init__(self):\n        self.oldestDateMap = None\n        self.filename = None\n\n    def getOldestDateMap(self):\n        return self.oldestDateMap\n\n    def setOldestDateMap(self, oldestDateMap):\n        self.oldestDateMap = oldestDateMap\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/DeleteRequest.py,0,"b'\n\nclass DeleteRequest(object):\n\n    def __init__(self):\n        self.datasets = None\n        self.groups = None\n        self.filename = None\n\n    def getDatasets(self):\n        return self.datasets\n\n    def setDatasets(self, datasets):\n        self.datasets = datasets\n\n    def getGroups(self):\n        return self.groups\n\n    def setGroups(self, groups):\n        self.groups = groups\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/GroupsRequest.py,0,"b'\n\nclass GroupsRequest(object):\n\n    def __init__(self):\n        self.groups = None\n        self.request = None\n        self.filename = None\n\n    def getGroups(self):\n        return self.groups\n\n    def setGroups(self, groups):\n        self.groups = groups\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/RepackRequest.py,0,"b'\n\nclass RepackRequest(object):\n\n    def __init__(self):\n        self.compression = None\n        self.filename = None\n\n    def getCompression(self):\n        return self.compression\n\n    def setCompression(self, compression):\n        self.compression = compression\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/RetrieveRequest.py,0,"b'\n\nclass RetrieveRequest(object):\n\n    def __init__(self):\n        self.group = None\n        self.dataset = None\n        self.request = None\n        self.filename = None\n\n    def getGroup(self):\n        return self.group\n\n    def setGroup(self, group):\n        self.group = group\n\n    def getDataset(self):\n        return self.dataset\n\n    def setDataset(self, dataset):\n        self.dataset = dataset\n\n    def getRequest(self):\n        return self.request\n\n    def setRequest(self, request):\n        self.request = request\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/StoreRequest.py,0,"b'\n\nclass StoreRequest(object):\n\n    def __init__(self):\n        self.op = None\n        self.records = None\n        self.filename = None\n\n    def getOp(self):\n        return self.op\n\n    def setOp(self, op):\n        self.op = op\n\n    def getRecords(self):\n        return self.records\n\n    def setRecords(self, records):\n        self.records = records\n\n    def getFilename(self):\n        return self.filename\n\n    def setFilename(self, filename):\n        self.filename = filename\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/request/__init__.py,0,"b""\n__all__ = [\n            'CopyRequest',\n            'CreateDatasetRequest',\n            'DatasetDataRequest',\n            'DatasetNamesRequest',\n            'DeleteFilesRequest',\n            'DeleteOrphansRequest',\n            'DeleteRequest',\n            'GroupsRequest',\n            'RepackRequest',\n            'RetrieveRequest',\n            'StoreRequest'\n          ]\n\nfrom .CopyRequest import CopyRequest\nfrom .CreateDatasetRequest import CreateDatasetRequest\nfrom .DatasetDataRequest import DatasetDataRequest\nfrom .DatasetNamesRequest import DatasetNamesRequest\nfrom .DeleteFilesRequest import DeleteFilesRequest\nfrom .DeleteOrphansRequest import DeleteOrphansRequest\nfrom .DeleteRequest import DeleteRequest\nfrom .GroupsRequest import GroupsRequest\nfrom .RepackRequest import RepackRequest\nfrom .RetrieveRequest import RetrieveRequest\nfrom .StoreRequest import StoreRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/DeleteResponse.py,0,"b'\n\nclass DeleteResponse(object):\n\n    def __init__(self):\n        self.success = None\n\n    def getSuccess(self):\n        return self.success\n\n    def setSuccess(self, success):\n        self.success = success\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/ErrorResponse.py,0,"b'\n\nclass ErrorResponse(object):\n\n    def __init__(self):\n        self.error = None\n\n    def getError(self):\n        return self.error\n\n    def setError(self, error):\n        self.error = error\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/FileActionResponse.py,0,"b'\n\nclass FileActionResponse(object):\n\n    def __init__(self):\n        self.successfulFiles = None\n        self.failedFiles = None\n\n    def getSuccessfulFiles(self):\n        return self.successfulFiles\n\n    def setSuccessfulFiles(self, successfulFiles):\n        self.successfulFiles = successfulFiles\n\n    def getFailedFiles(self):\n        return self.failedFiles\n\n    def setFailedFiles(self, failedFiles):\n        self.failedFiles = failedFiles\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/RetrieveResponse.py,0,"b'\n\nclass RetrieveResponse(object):\n\n    def __init__(self):\n        self.records = None\n\n    def getRecords(self):\n        return self.records\n\n    def setRecords(self, records):\n        self.records = records\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/StoreResponse.py,0,"b'\n\nclass StoreResponse(object):\n\n    def __init__(self):\n        self.status = None\n        self.exceptions = None\n        self.failedRecords = None\n\n    def getStatus(self):\n        return self.status\n\n    def setStatus(self, status):\n        self.status = status\n\n    def getExceptions(self):\n        return self.exceptions\n\n    def setExceptions(self, exceptions):\n        self.exceptions = exceptions\n\n    def getFailedRecords(self):\n        return self.failedRecords\n\n    def setFailedRecords(self, failedRecords):\n        self.failedRecords = failedRecords\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/pypies/response/__init__.py,0,"b""\n__all__ = [\n            'DeleteResponse',\n            'ErrorResponse',\n            'FileActionResponse',\n            'RetrieveResponse',\n            'StoreResponse'\n          ]\n\nfrom .DeleteResponse import DeleteResponse\nfrom .ErrorResponse import ErrorResponse\nfrom .FileActionResponse import FileActionResponse\nfrom .RetrieveResponse import RetrieveResponse\nfrom .StoreResponse import StoreResponse\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/serialization/comm/__init__.py,0,"b""\n__all__ = [\n            'response'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/site/notify/ClusterActivationNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/10/14         #3623        randerso       Manually created, do not regenerate\n#\n\nfrom .SiteActivationNotification import SiteActivationNotification\n\n\nclass ClusterActivationNotification(SiteActivationNotification):\n\n    def __init__(self):\n        self.clusterActive = False\n        SiteActivationNotification.__init__(self)\n\n    def isClusterActive(self):\n        return self.clusterActive\n\n    def setClusterActive(self, clusterActive):\n        self.clusterActive = clusterActive\n\n    def __str__(self):\n        s = self.modifiedSite\n\n        if self.type == \'ACTIVATE\':\n            if self.status == \'FAILURE\':\n                s += "" has failed to activate on some or all cluster members.  See logs for details""\n            else:\n                s += "" has been successfully activated on all cluster members""\n\n        else:\n            if self.status == \'FAILURE\':\n                s += "" has failed to deactivate on some or all cluster members.  See logs for details""\n            else:\n                s += "" has been successfully deactivated on all cluster members""\n\n        return s\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/notify/SiteActivationNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/10/14         #3623        randerso       Manually created, do not regenerate\n#\n\n\nclass SiteActivationNotification(object):\n\n    def __init__(self):\n        self.type = None\n        self.status = None\n        self.primarySite = None\n        self.modifiedSite = None\n        self.runMode = None\n        self.serverName = None\n        self.pluginName = None\n\n    def getType(self):\n        return self.type\n\n    def setType(self, notificationType):\n        self.type = notificationType\n\n    def getStatus(self):\n        return self.status\n\n    def setStatus(self, status):\n        self.status = status\n\n    def getPrimarySite(self):\n        return self.primarySite\n\n    def setPrimarySite(self, primarysite):\n        self.primarySite = primarysite\n\n    def getModifiedSite(self):\n        return self.modifiedSite\n\n    def setModifiedSite(self, modifiedSite):\n        self.modifiedSite = modifiedSite\n\n    def getRunMode(self):\n        return self.runMode\n\n    def setRunMode(self, runMode):\n        self.runMode = runMode\n\n    def getServerName(self):\n        return self.serverName\n\n    def setServerName(self, serverName):\n        self.serverName = serverName\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def __str__(self):\n        return self.pluginName.upper() + "":"" \\\n             + self.status + "":"" \\\n             + self.type + "" "" \\\n             + self.modifiedSite.upper() + "" on "" \\\n             + self.serverName + "":"" \\\n             + self.runMode\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/notify/__init__.py,0,"b""\n__all__ = [\n            'ClusterActivationNotification',\n            'SiteActivationNotification'\n          ]\n\nfrom .ClusterActivationNotification import ClusterActivationNotification\nfrom .SiteActivationNotification import SiteActivationNotification\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/ActivateSiteRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/10/14         #3623        randerso       Manually created, do not regenerate\n#\n\n\nclass ActivateSiteRequest(object):\n\n    def __init__(self, siteID=None, plugin=None):\n        self.siteID = siteID\n        self.plugin = plugin\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n\n    def getPlugin(self):\n        return self.plugin\n\n    def setPlugin(self, plugin):\n        self.plugin = plugin\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/DeactivateSiteRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/10/14         #3623        randerso       Manually created, do not regenerate\n#\n\n\nclass DeactivateSiteRequest(object):\n\n    def __init__(self, siteID=None, plugin=None):\n        self.siteID = siteID\n        self.plugin = plugin\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n\n    def getPlugin(self):\n        return self.plugin\n\n    def setPlugin(self, plugin):\n        self.plugin = plugin\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/GetActiveSitesRequest.py,0,"b'\n\nclass GetActiveSitesRequest(object):\n\n    def __init__(self):\n        super(GetActiveSitesRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/GetPrimarySiteRequest.py,0,"b'\n\nclass GetPrimarySiteRequest(object):\n\n    def __init__(self):\n        super(GetPrimarySiteRequest, self).__init__()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/ValidateConfigRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/12/16         #5888        dgilling       Initial  creation.\n#\n\n\nclass ValidateConfigRequest(object):\n\n    def __init__(self, siteID=None, plugin=None):\n        self.siteID = siteID\n        self.plugin = plugin\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n\n    def getPlugin(self):\n        return self.plugin\n\n    def setPlugin(self, plugin):\n        self.plugin = plugin\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/site/requests/__init__.py,0,"b""\n__all__ = [\n            'ActivateSiteRequest',\n            'DeactivateSiteRequest',\n            'GetActiveSitesRequest',\n            'GetPrimarySiteRequest',\n            'ValidateConfigRequest'\n          ]\n\nfrom .ActivateSiteRequest import ActivateSiteRequest\nfrom .DeactivateSiteRequest import DeactivateSiteRequest\nfrom .GetActiveSitesRequest import GetActiveSitesRequest\nfrom .GetPrimarySiteRequest import GetPrimarySiteRequest\nfrom .ValidateConfigRequest import ValidateConfigRequest\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/__init__.py,0,"b""\n__all__ = [\n            'atcf',\n            'gempak',\n            'gpd',\n            'pgen'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/events/hazards/__init__.py,0,"b""\n__all__ = [\n            'requests'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/config/ProjectionData.py,0,"b""\n\nclass ProjectionData(object):\n\n    def __init__(self):\n        self.projectionID = None\n        self.projectionType = None\n        self.latLonLL = None\n        self.latLonUR = None\n        self.latLonOrigin = None\n        self.stdParallelOne = None\n        self.stdParallelTwo = None\n        self.gridPointLL = None\n        self.gridPointUR = None\n        self.latIntersect = None\n        self.lonCenter = None\n        self.lonOrigin = None\n\n    def getProjectionID(self):\n        return self.projectionID\n\n    def setProjectionID(self, projectionID):\n        self.projectionID = projectionID\n\n    def getProjectionType(self):\n        return self.projectionType\n\n    def setProjectionType(self, projectionType):\n        self.projectionType = projectionType\n\n    def getLatLonLL(self):\n        return self.latLonLL\n\n    def setLatLonLL(self, latLonLL):\n        self.latLonLL = latLonLL\n\n    def getLatLonUR(self):\n        return self.latLonUR\n\n    def setLatLonUR(self, latLonUR):\n        self.latLonUR = latLonUR\n\n    def getLatLonOrigin(self):\n        return self.latLonOrigin\n\n    def setLatLonOrigin(self, latLonOrigin):\n        self.latLonOrigin = latLonOrigin\n\n    def getStdParallelOne(self):\n        return self.stdParallelOne\n\n    def setStdParallelOne(self, stdParallelOne):\n        self.stdParallelOne = stdParallelOne\n\n    def getStdParallelTwo(self):\n        return self.stdParallelTwo\n\n    def setStdParallelTwo(self, stdParallelTwo):\n        self.stdParallelTwo = stdParallelTwo\n\n    def getGridPointLL(self):\n        return self.gridPointLL\n\n    def setGridPointLL(self, gridPointLL):\n        self.gridPointLL = gridPointLL\n\n    def getGridPointUR(self):\n        return self.gridPointUR\n\n    def setGridPointUR(self, gridPointUR):\n        self.gridPointUR = gridPointUR\n\n    def getLatIntersect(self):\n        return self.latIntersect\n\n    def setLatIntersect(self, latIntersect):\n        self.latIntersect = latIntersect\n\n    def getLonCenter(self):\n        return self.lonCenter\n\n    def setLonCenter(self, lonCenter):\n        self.lonCenter = lonCenter\n\n    def getLonOrigin(self):\n        return self.lonOrigin\n\n    def setLonOrigin(self, lonOrigin):\n        self.lonOrigin = lonOrigin\n\n    def keys(self):\n        return ['projectionID', 'projectionType', 'latLonLL', 'latLonUR',\n                'latLonOrigin', 'stdParallelOne', 'stdParallelTwo',\n                'gridPointLL', 'gridPointUR', 'latIntersect', 'lonCenter',\n                'lonOrigin']\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/config/__init__.py,0,"b""\n__all__ = [\n            'ProjectionData'\n          ]\n\nfrom .ProjectionData import ProjectionData\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/__init__.py,0,"b""\n__all__ = [\n            'objects'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/discrete/DiscreteKey.py,0,"b'#  NOTE: Because the pure python dynamicserialize code does not\n#  have a means of accessing the DiscreteDefinition, this class\n#  is only really useful as a container for deserialized data\n#  from EDEX. I would not recommend trying to use it for anything\n#  else.\n\nSUBKEY_SEPARATOR = \'^\'\nAUXDATA_SEPARATOR = \':\'\n\n\nclass DiscreteKey(object):\n\n    def __init__(self):\n        self.siteId = None\n        self.subKeys = None\n        self.parmID = None\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return SUBKEY_SEPARATOR.join(self.subKeys)\n\n    def __getitem__(self, key):\n        try:\n            index = int(key)\n        except TypeError:\n            raise TypeError(""list indices must be integers, not "" + str(type(key)))\n        if index < 0 or index > len(self.subKeys):\n            raise IndexError(""index out of range"")\n        return self.subKeys[index]\n\n    def __hash__(self):\n        prime = 31\n        result = 1\n        result = prime * result + (0 if self.parmID is None else hash(self.parmID))\n        result = prime * result + (0 if self.siteId is None else hash(self.siteId))\n        result = prime * result + (0 if self.subKeys is None else hash(self.subKeys))\n        return result\n\n    def __eq__(self, other):\n        if not isinstance(other, DiscreteKey):\n            return False\n        if self.parmID != other.parmID:\n            return False\n        if self.siteId != other.siteId:\n            return False\n        return self.subKeys == other.subKeys\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    @staticmethod\n    def auxData(subkey):\n        pos = subkey.find(AUXDATA_SEPARATOR)\n        if pos != -1:\n            return subkey[pos + 1:]\n        else:\n            return """"\n\n    @staticmethod\n    def baseData(subkey):\n        pos = subkey.find(AUXDATA_SEPARATOR)\n        if pos != -1:\n            return subkey[:pos]\n        else:\n            return subkey\n\n    def getSiteId(self):\n        return self.siteId\n\n    def setSiteId(self, siteId):\n        self.siteId = siteId\n\n    def getSubKeys(self):\n        return self.subKeys\n\n    def setSubKeys(self, subKeys):\n        self.subKeys = subKeys\n\n    def getParmID(self):\n        return self.parmID\n\n    def setParmID(self, parmID):\n        self.parmID = parmID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/discrete/__init__.py,0,"b""\n__all__ = [\n            'DiscreteKey'\n          ]\n\nfrom .DiscreteKey import DiscreteKey\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/grid/Grid2DByte.py,0,"b'import numpy\n\n\nclass Grid2DByte(object):\n\n    def __init__(self):\n        self.buffer = None\n        self.xdim = None\n        self.ydim = None\n\n    def getBuffer(self):\n        return self.buffer\n\n    def setBuffer(self, bytebuffer):\n        self.buffer = bytebuffer\n\n    def getXdim(self):\n        return self.xdim\n\n    def setXdim(self, xdim):\n        self.xdim = xdim\n\n    def getYdim(self):\n        return self.ydim\n\n    def setYdim(self, ydim):\n        self.ydim = ydim\n\n    def getNumPyGrid(self):\n        return numpy.resize(self.buffer, (self.xdim, self.ydim))\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/grid/Grid2DFloat.py,0,"b'import numpy\n\n\nclass Grid2DFloat(object):\n\n    def __init__(self):\n        self.buffer = None\n        self.xdim = None\n        self.ydim = None\n\n    def getBuffer(self):\n        return self.buffer\n\n    def setBuffer(self, bytebuffer):\n        self.buffer = bytebuffer\n\n    def getXdim(self):\n        return self.xdim\n\n    def setXdim(self, xdim):\n        self.xdim = xdim\n\n    def getYdim(self):\n        return self.ydim\n\n    def setYdim(self, ydim):\n        self.ydim = ydim\n\n    def getNumPyGrid(self):\n        return numpy.resize(self.buffer, (self.xdim, self.ydim))\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/grid/__init__.py,0,"b""\n__all__ = [\n            'Grid2DByte',\n            'Grid2DFloat'\n          ]\n\nfrom .Grid2DByte import Grid2DByte\nfrom .Grid2DFloat import Grid2DFloat\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/AbstractGfeRequest.py,0,"b'import abc\nfrom six import with_metaclass\n\n\nclass AbstractGfeRequest(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.siteID = None\n        self.workstationID = None\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/CommitGridsRequest.py,0,"b'\n\nclass CommitGridsRequest(object):\n\n    def __init__(self):\n        self.commits = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getCommits(self):\n        return self.commits\n\n    def setCommits(self, commits):\n        self.commits = commits\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/ConfigureTextProductsRequest.py,0,"b'\n\nclass ConfigureTextProductsRequest(object):\n\n    def __init__(self):\n        self.mode = None\n        self.template = None\n        self.site = None\n        self.destinationDir = None\n\n    def getMode(self):\n        return self.mode\n\n    def setMode(self, mode):\n        self.mode = mode\n\n    def getTemplate(self):\n        return self.template\n\n    def setTemplate(self, template):\n        self.template = template\n\n    def getSite(self):\n        return self.site\n\n    def setSite(self, site):\n        self.site = site\n\n    def getDestinationDir(self):\n        return self.destinationDir\n\n    def setDestinationDir(self, destinationDir):\n        self.destinationDir = destinationDir\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/ExecuteIfpNetCDFGridRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    xx/xx/??                      dgilling       Initial Creation.\n#    03/13/13         1759         dgilling       Add software history header.\n#    05/13/15         4427         dgilling       Add siteIdOverride field.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.message import WsId\n\n\nclass ExecuteIfpNetCDFGridRequest(AbstractGfeRequest):\n\n    def __init__(self, outputFilename=None, parmList=[], databaseID=None,\n                 startTime=None, endTime=None, mask=None, geoInfo=False,\n                 compressFile=False, configFileName=None, compressFileFactor=0,\n                 trim=False, krunch=False, userID=None, logFileName=None, siteIdOverride=None):\n        super(ExecuteIfpNetCDFGridRequest, self).__init__()\n        self.outputFilename = outputFilename\n        self.parmList = parmList\n        self.databaseID = databaseID\n        self.startTime = startTime\n        self.endTime = endTime\n        self.mask = mask\n        self.geoInfo = geoInfo\n        self.compressFile = compressFile\n        self.configFileName = configFileName\n        self.compressFileFactor = compressFileFactor\n        self.trim = trim\n        self.krunch = krunch\n        self.userID = userID\n        self.logFileName = logFileName\n        self.siteIdOverride = siteIdOverride\n        if self.userID is not None:\n            self.workstationID = WsId(progName=\'ifpnetCDF\', userName=self.userID)\n        if self.databaseID is not None:\n            self.siteID = self.databaseID.getSiteId()\n\n    def __cstr__(self):\n        retVal = ""workstationID: "" + str(self.workstationID) + "", ""\n        retVal += ""siteID: "" + str(self.siteID) + "", ""\n        retVal += ""outputFilename: "" + str(self.outputFilename) + "", ""\n        retVal += ""parmList: "" + str(self.parmList) + "", ""\n        retVal += ""databaseID: "" + str(self.databaseID) + "", ""\n        retVal += ""startTime: "" + str(self.startTime) + "", ""\n        retVal += ""endTime: "" + str(self.endTime) + "", ""\n        retVal += ""mask: "" + str(self.mask) + "", ""\n        retVal += ""geoInfo: "" + str(self.geoInfo) + "", ""\n        retVal += ""compressFile: "" + str(self.compressFile) + "", ""\n        retVal += ""configFileName: "" + str(self.configFileName) + "", ""\n        retVal += ""compressFileFactor: "" + str(self.compressFileFactor) + "", ""\n        retVal += ""trim: "" + str(self.trim) + "", ""\n        retVal += ""krunch: "" + str(self.krunch) + "", ""\n        retVal += ""userID: "" + str(self.userID) + "", ""\n        retVal += ""logFileName: "" + str(self.logFileName) + "", ""\n        retVal += ""siteIdOverride: "" + str(self.siteIdOverride)\n        return retVal\n\n    def __str__(self):\n        return ""ExecuteIfpNetCDFGridRequest["" + self.__cstr__() + ""]""\n\n    def __repr__(self):\n        return ""ExecuteIfpNetCDFGridRequest("" + self.__cstr__() + "")""\n\n    def getOutputFilename(self):\n        return self.outputFilename\n\n    def setOutputFilename(self, outputFilename):\n        self.outputFilename = outputFilename\n\n    def getParmList(self):\n        return self.parmList\n\n    def setParmList(self, parmList):\n        self.parmList = parmList\n\n    def getDatabaseID(self):\n        return self.databaseID\n\n    def setDatabaseID(self, databaseID):\n        self.databaseID = databaseID\n\n    def getStartTime(self):\n        return self.startTime\n\n    def setStartTime(self, startTime):\n        self.startTime = startTime\n\n    def getEndTime(self):\n        return self.endTime\n\n    def setEndTime(self, endTime):\n        self.endTime = endTime\n\n    def getMask(self):\n        return self.mask\n\n    def setMask(self, mask):\n        self.mask = mask\n\n    def getGeoInfo(self):\n        return self.geoInfo\n\n    def setGeoInfo(self, geoInfo):\n        self.geoInfo = geoInfo\n\n    def getCompressFile(self):\n        return self.compressFile\n\n    def setCompressFile(self, compressFile):\n        self.compressFile = compressFile\n\n    def getConfigFileName(self):\n        return self.configFileName\n\n    def setConfigFileName(self, configFileName):\n        self.configFileName = configFileName\n\n    def getCompressFileFactor(self):\n        return self.compressFileFactor\n\n    def setCompressFileFactor(self, compressFileFactor):\n        self.compressFileFactor = compressFileFactor\n\n    def getTrim(self):\n        return self.trim\n\n    def setTrim(self, trim):\n        self.trim = trim\n\n    def getKrunch(self):\n        return self.krunch\n\n    def setKrunch(self, krunch):\n        self.krunch = krunch\n\n    def getUserID(self):\n        return self.userID\n\n    def setUserID(self, userID):\n        self.userID = userID\n\n    def getLogFileName(self):\n        return self.logFileName\n\n    def setLogFileName(self, logFileName):\n        self.logFileName = logFileName\n\n    def getSiteIdOverride(self):\n        return self.siteIdOverride\n\n    def setSiteIdOverride(self, siteIdOverride):\n        self.siteIdOverride = siteIdOverride\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/ExportGridsRequest.py,0,"b'#\n# A pure python implementation of com.raytheon.uf.common.dataplugin.gfe.request.ExportGridsRequest\n# for use by the python implementation of DynamicSerialize.\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    04/05/13                      dgilling       Initial Creation.\n#\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\n\n\nclass ExportGridsRequest(AbstractGfeRequest):\n\n    def __init__(self):\n        super(ExportGridsRequest, self).__init__()\n        self.site = None\n        self.mode = None\n\n    def getSite(self):\n        return self.site\n\n    def setSite(self, site):\n        self.site = site\n\n    def getMode(self):\n        return self.mode\n\n    def setMode(self, mode):\n        validValues = [\'CRON\', \'MANUAL\', \'GRIB2\']\n        inputVal = str(mode).upper()\n        if inputVal in validValues:\n            self.mode = mode\n        else:\n            raise ValueError(inputVal + "" invalid ExportGridsMode. Must be "" + str(validValues))\n\n    def __str__(self):\n        retVal = ""ExportGridsRequest[""\n        retVal += ""wokstationID: "" + str(self.workstationID) + "", ""\n        retVal += ""siteID: "" + str(self.siteID) + "", ""\n        retVal += ""site: "" + str(self.site) + "", ""\n        retVal += ""mode: "" + str(self.mode) + ""]""\n        return retVal\n\n    def __repr__(self):\n        retVal = ""ExportGridsRequest(""\n        retVal += ""wokstationID="" + repr(self.workstationID) + "", ""\n        retVal += ""siteID="" + repr(self.siteID) + "", ""\n        retVal += ""site="" + repr(self.site) + "", ""\n        retVal += ""mode="" + repr(self.mode) + "")""\n        return retVal\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetASCIIGridsRequest.py,0,"b'\n\nclass GetASCIIGridsRequest(object):\n\n    def __init__(self):\n        self.databaseIds = None\n        self.parmIds = None\n        self.timeRange = None\n        self.coordConversionString = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getDatabaseIds(self):\n        return self.databaseIds\n\n    def setDatabaseIds(self, databaseIds):\n        self.databaseIds = databaseIds\n\n    def getParmIds(self):\n        return self.parmIds\n\n    def setParmIds(self, parmIds):\n        self.parmIds = parmIds\n\n    def getTimeRange(self):\n        return self.timeRange\n\n    def setTimeRange(self, timeRange):\n        self.timeRange = timeRange\n\n    def getCoordConversionString(self):\n        return self.coordConversionString\n\n    def setCoordConversionString(self, coordConversionString):\n        self.coordConversionString = coordConversionString\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetGridDataRequest.py,0,"b'import abc\nfrom six import with_metaclass\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.server.request import GetGridRequest\n\n\nclass GetGridDataRequest(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.requests = []\n        self.workstationID = None\n        self.siteID = None\n\n    def addRequest(self, gridDataReq):\n        if not isinstance(gridDataReq, GetGridRequest):\n            raise TypeError(""Invalid request specified: "" + str(type(gridDataReq)) +\n                            "". Only GetGridRequests are supported."")\n        else:\n            self.requests.append(gridDataReq)\n\n    def getRequests(self):\n        return self.requests\n\n    def setRequests(self, requests):\n        del self.requests[:]\n        for req in requests:\n            self.addRequest(req)\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetGridInventoryRequest.py,0,"b'\n\nclass GetGridInventoryRequest(object):\n\n    def __init__(self):\n        self.parmIds = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getParmIds(self):\n        return self.parmIds\n\n    def setParmIds(self, parmIds):\n        self.parmIds = parmIds\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetLatestDbTimeRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/22/13         2025         dgilling       Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import DatabaseID\n\n\nclass GetLatestDbTimeRequest(AbstractGfeRequest):\n\n    def __init__(self, dbId=None):\n        super(GetLatestDbTimeRequest, self).__init__()\n        if dbId is not None and isinstance(dbId, DatabaseID):\n            self.dbId = dbId\n            self.siteID = dbId.getSiteId()\n        elif dbId is not None and not isinstance(dbId, DatabaseID):\n            raise TypeError(\n                ""Attempt to construct GetLatestDbTimeRequest without providing a valid DatabaseID."")\n\n    def __str__(self):\n        retVal = ""GetLatestDbTimeRequest[""\n        retVal += ""wokstationID: "" + str(self.workstationID) + "", ""\n        retVal += ""siteID: "" + str(self.siteID) + "", ""\n        retVal += ""dbId: "" + str(self.dbId) + ""]""\n        return retVal\n\n    def __repr__(self):\n        retVal = ""ExecuteIfpNetCDFGridRequest(""\n        retVal += ""wokstationID="" + repr(self.workstationID) + "", ""\n        retVal += ""siteID="" + repr(self.siteID) + "", ""\n        retVal += ""dbId="" + repr(self.dbId) + "")""\n        return retVal\n\n    def getDbId(self):\n        return self.dbId\n\n    def setDbId(self, dbId):\n        if isinstance(dbId, DatabaseID):\n            self.dbId = dbId\n        else:\n            raise TypeError(\n                ""Attempt to call GetLatestDbTimeRequest.setDbId() without providing a valid DatabaseID."")\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetLatestModelDbIdRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    05/22/13         2025         dgilling       Initial Creation.\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\n\n\nclass GetLatestModelDbIdRequest(AbstractGfeRequest):\n\n    def __init__(self, siteId=None, modelName=None):\n        super(GetLatestModelDbIdRequest, self).__init__()\n        if siteId is not None:\n            self.siteID = str(siteId)\n        if modelName is not None:\n            self.modelName = str(modelName)\n\n    def __str__(self):\n        retVal = ""GetLatestModelDbIdRequest[""\n        retVal += ""wokstationID: "" + str(self.workstationID) + "", ""\n        retVal += ""siteID: "" + str(self.siteID) + "", ""\n        retVal += ""modelName: "" + str(self.modelName) + ""]""\n        return retVal\n\n    def __repr__(self):\n        retVal = ""ExecuteIfpNetCDFGridRequest(""\n        retVal += ""wokstationID="" + repr(self.workstationID) + "", ""\n        retVal += ""siteID="" + repr(self.siteID) + "", ""\n        retVal += ""modelName="" + repr(self.modelName) + "")""\n        return retVal\n\n    def getModelName(self):\n        return self.modelName\n\n    def setModelName(self, modelName):\n        self.modelName = str(modelName)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetLockTablesRequest.py,0,"b'\n\nclass GetLockTablesRequest(object):\n\n    def __init__(self):\n        self.requests = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getRequests(self):\n        return self.requests\n\n    def setRequests(self, requests):\n        self.requests = requests\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetOfficialDbNameRequest.py,0,"b'\n\nclass GetOfficialDbNameRequest(object):\n\n    def __init__(self):\n        self.workstationID = None\n        self.siteID = None\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetParmListRequest.py,0,"b'\n\nclass GetParmListRequest(object):\n\n    def __init__(self):\n        self.dbIds = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getDbIds(self):\n        return self.dbIds\n\n    def setDbIds(self, dbIds):\n        self.dbIds = dbIds\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetSelectTimeRangeRequest.py,0,"b'\n\nclass GetSelectTimeRangeRequest(object):\n\n    def __init__(self):\n        self.name = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetSingletonDbIdsRequest.py,0,"b'\n\nclass GetSingletonDbIdsRequest(object):\n\n    def __init__(self):\n        self.workstationID = None\n        self.siteID = None\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GetSiteTimeZoneInfoRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    xx/xx/??                      dgilling       Initial Creation.\n#    12/02/15         5129         dgilling       Refactor based on AbstractGfeRequest.\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\n\n\nclass GetSiteTimeZoneInfoRequest(AbstractGfeRequest):\n\n    def __init__(self):\n        super(GetSiteTimeZoneInfoRequest, self).__init__()\n        self.requestedSiteIDs = None\n\n    def getRequestedSiteIDs(self):\n        return self.requestedSiteIDs\n\n    def setRequestedSiteIDs(self, requestedSiteIDs):\n        self.requestedSiteIDs = requestedSiteIDs\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GfeClientRequest.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request.AbstractGfeRequest import AbstractGfeRequest\n\n# Manually updated\n#\n# SOFTWARE HISTORY\n#\n# Date          Ticket#  Engineer  Description\n# ------------- -------- --------- ---------------------------------------------\n# Dec 06, 2016  6092     randerso  Initial Creation\n\n\nclass GfeClientRequest(AbstractGfeRequest):\n\n    def __init__(self, script, siteID, configFile, user, args=[]):\n        super(GfeClientRequest, self).__init__()\n        self.script = script\n        self.siteID = siteID\n        self.configFile = configFile\n        self.user = user\n        self.args = args\n        self.time = None\n\n    def getConfigFile(self):\n        return self.configFile\n\n    def setConfigFile(self, configFile):\n        self.configFile = configFile\n\n    def getUser(self):\n        return self.user\n\n    def setUser(self, user):\n        self.user = user\n\n    def getArgs(self):\n        return self.args\n\n    def setArgs(self, args):\n        self.args = args\n\n    def getTime(self):\n        return self.time\n\n    def setTime(self, time):\n        self.time = time\n\n    def getScript(self):\n        return self.script\n\n    def setScript(self, script):\n        self.script = script\n\n    def __str__(self):\n        retval = ""GfeClientRequest(""\n        retval += ""siteID:"" + self.siteID + "", ""\n        retval += ""script:"" + self.script + "", ""\n        retval += ""configFile:"" + self.configFile + "", ""\n        retval += ""user:"" + self.user + "", ""\n        if self.time:\n            retval += ""time:"" + str(self.time) + "", ""\n        retval += ""args:"" + str(self.args) + "")""\n        return retval\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/GridLocRequest.py,0,"b'\n\nclass GridLocRequest(object):\n\n    def __init__(self):\n        self.workstationID = None\n        self.siteID = None\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/LockChangeRequest.py,0,"b'\n\nclass LockChangeRequest(object):\n\n    def __init__(self):\n        self.requests = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getRequests(self):\n        return self.requests\n\n    def setRequests(self, requests):\n        self.requests = requests\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/ProcessReceivedConfRequest.py,0,"b'\n\nclass ProcessReceivedConfRequest(object):\n\n    def __init__(self):\n        self.receivedConfFile = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getReceivedConfFile(self):\n        return self.receivedConfFile\n\n    def setReceivedConfFile(self, receivedConfFile):\n        self.receivedConfFile = receivedConfFile\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/ProcessReceivedDigitalDataRequest.py,0,"b'\n\nclass ProcessReceivedDigitalDataRequest(object):\n\n    def __init__(self):\n        self.receivedConfFile = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getReceivedDataFile(self):\n        return self.receivedConfFile\n\n    def setReceivedDataFile(self, receivedConfFile):\n        self.receivedConfFile = receivedConfFile\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/PurgeGfeGridsRequest.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\n\n\nclass PurgeGfeGridsRequest(AbstractGfeRequest):\n\n    def __init__(self):\n        super(PurgeGfeGridsRequest, self).__init__()\n        self.databaseID = None\n\n    def __str__(self):\n        retVal = ""PurgeGfeGridsRequest[""\n        retVal += ""wokstationID: "" + str(self.workstationID) + "", ""\n        retVal += ""siteID: "" + str(self.siteID) + "", ""\n        retVal += ""databaseID: "" + str(self.databaseID) + ""]""\n        return retVal\n\n    def getDatabaseID(self):\n        return self.databaseID\n\n    def setDatabaseID(self, databaseID):\n        self.databaseID = databaseID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/RsyncGridsToCWFRequest.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    Jul 15, 2015     #4013        randerso       Initial creation (hand generated)\n#\n#\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.request import AbstractGfeRequest\n\n\nclass RsyncGridsToCWFRequest(AbstractGfeRequest):\n\n    def __init__(self, siteId=None):\n        super(RsyncGridsToCWFRequest, self).__init__()\n        if siteId is not None:\n            self.siteID = str(siteId)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/SaveASCIIGridsRequest.py,0,"b'\n\nclass SaveASCIIGridsRequest(object):\n\n    def __init__(self):\n        self.asciiGridData = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getAsciiGridData(self):\n        return self.asciiGridData\n\n    def setAsciiGridData(self, asciiGridData):\n        self.asciiGridData = asciiGridData\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/SmartInitRequest.py,0,"b'\n\nclass SmartInitRequest(object):\n\n    def __init__(self):\n        self.moduleName = None\n        self.modelTime = None\n        self.calculateAll = None\n        self.workstationID = None\n        self.siteID = None\n\n    def getModuleName(self):\n        return self.moduleName\n\n    def setModuleName(self, moduleName):\n        self.moduleName = moduleName\n\n    def getModelTime(self):\n        return self.modelTime\n\n    def setModelTime(self, modelTime):\n        self.modelTime = modelTime\n\n    def getCalculateAll(self):\n        return self.calculateAll\n\n    def setCalculateAll(self, calculateAll):\n        self.calculateAll = calculateAll\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/request/__init__.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    Jul 15, 2015     #4013        randerso       Added RsyncGridsToCWFRequest\n#\n\n__all__ = [\n            'AbstractGfeRequest',\n            'CommitGridsRequest',\n            'ConfigureTextProductsRequest',\n            'ExecuteIfpNetCDFGridRequest',\n            'ExportGridsRequest',\n            'GetASCIIGridsRequest',\n            'GetGridDataRequest',\n            'GetGridInventoryRequest',\n            'GetLatestDbTimeRequest',\n            'GetLatestModelDbIdRequest',\n            'GetLockTablesRequest',\n            'GetOfficialDbNameRequest',\n            'GetParmListRequest',\n            'GetSelectTimeRangeRequest',\n            'GetSingletonDbIdsRequest',\n            'GetSiteTimeZoneInfoRequest',\n            'GfeClientRequest',\n            'GridLocRequest',\n            'LockChangeRequest',\n            'ProcessReceivedConfRequest',\n            'ProcessReceivedDigitalDataRequest',\n            'PurgeGfeGridsRequest',\n            'RsyncGridsToCWFRequest',\n            'SaveASCIIGridsRequest',\n            'SmartInitRequest'\n          ]\n\nfrom .AbstractGfeRequest import AbstractGfeRequest\nfrom .CommitGridsRequest import CommitGridsRequest\nfrom .ConfigureTextProductsRequest import ConfigureTextProductsRequest\nfrom .ExecuteIfpNetCDFGridRequest import ExecuteIfpNetCDFGridRequest\nfrom .ExportGridsRequest import ExportGridsRequest\nfrom .GetASCIIGridsRequest import GetASCIIGridsRequest\nfrom .GetGridDataRequest import GetGridDataRequest\nfrom .GetGridInventoryRequest import GetGridInventoryRequest\nfrom .GetLatestDbTimeRequest import GetLatestDbTimeRequest\nfrom .GetLatestModelDbIdRequest import GetLatestModelDbIdRequest\nfrom .GetLockTablesRequest import GetLockTablesRequest\nfrom .GetOfficialDbNameRequest import GetOfficialDbNameRequest\nfrom .GetParmListRequest import GetParmListRequest\nfrom .GetSelectTimeRangeRequest import GetSelectTimeRangeRequest\nfrom .GetSingletonDbIdsRequest import GetSingletonDbIdsRequest\nfrom .GetSiteTimeZoneInfoRequest import GetSiteTimeZoneInfoRequest\nfrom .GfeClientRequest import GfeClientRequest\nfrom .GridLocRequest import GridLocRequest\nfrom .LockChangeRequest import LockChangeRequest\nfrom .ProcessReceivedConfRequest import ProcessReceivedConfRequest\nfrom .ProcessReceivedDigitalDataRequest import ProcessReceivedDigitalDataRequest\nfrom .PurgeGfeGridsRequest import PurgeGfeGridsRequest\nfrom .SaveASCIIGridsRequest import SaveASCIIGridsRequest\nfrom .SmartInitRequest import SmartInitRequest\nfrom .RsyncGridsToCWFRequest import RsyncGridsToCWFRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/__init__.py,0,"b""\n__all__ = [\n            'lock',\n            'message',\n            'notify',\n            'request'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/AbstractGridSlice.py,0,"b'import abc\nfrom six import with_metaclass\n\n\nclass AbstractGridSlice(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.validTime = None\n        self.gridParmInfo = None\n        self.gridDataHistory = None\n\n    @abc.abstractmethod\n    def getNumPyGrid(self):\n        raise NotImplementedError\n\n    def getValidTime(self):\n        return self.validTime\n\n    def setValidTime(self, validTime):\n        self.validTime = validTime\n\n    def getGridParmInfo(self):\n        return self.gridParmInfo\n\n    def setGridParmInfo(self, gridParmInfo):\n        self.gridParmInfo = gridParmInfo\n\n    def getGridDataHistory(self):\n        return self.gridDataHistory\n\n    def setGridDataHistory(self, gridDataHistory):\n        self.gridDataHistory = gridDataHistory\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/DiscreteGridSlice.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.slice import AbstractGridSlice\n\n\nclass DiscreteGridSlice(AbstractGridSlice):\n\n    def __init__(self):\n        super(DiscreteGridSlice, self).__init__()\n        self.discreteGrid = None\n        self.key = []\n\n    def getDiscreteGrid(self):\n        return self.discreteGrid\n\n    def setDiscreteGrid(self, discreteGrid):\n        self.discreteGrid = discreteGrid\n\n    def getNumPyGrid(self):\n        return self.discreteGrid.getNumPyGrid(), self.key\n\n    def getKey(self):\n        return self.key\n\n    def setKey(self, key):\n        self.key = key\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/ScalarGridSlice.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.slice import AbstractGridSlice\n\n\nclass ScalarGridSlice(AbstractGridSlice):\n\n    def __init__(self):\n        super(ScalarGridSlice, self).__init__()\n        self.scalarGrid = None\n\n    def getNumPyGrid(self):\n        return self.scalarGrid.getNumPyGrid()\n\n    def getScalarGrid(self):\n        return self.scalarGrid\n\n    def setScalarGrid(self, scalarGrid):\n        self.scalarGrid = scalarGrid\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/VectorGridSlice.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.slice import ScalarGridSlice\n\n\nclass VectorGridSlice(ScalarGridSlice):\n\n    def __init__(self):\n        super(VectorGridSlice, self).__init__()\n        self.dirGrid = None\n\n    def getNumPyGrid(self):\n        return self.scalarGrid.getNumPyGrid(), self.dirGrid.getNumPyGrid()\n\n    def getDirGrid(self):\n        return self.dirGrid\n\n    def setDirGrid(self, dirGrid):\n        self.dirGrid = dirGrid\n\n    def getMagGrid(self):\n        return self.scalarGrid\n\n    def setMagGrid(self, magGrid):\n        self.scalarGrid = magGrid\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/WeatherGridSlice.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.slice import AbstractGridSlice\n\n\nclass WeatherGridSlice(AbstractGridSlice):\n\n    def __init__(self):\n        super(WeatherGridSlice, self).__init__()\n        self.weatherGrid = None\n        self.keys = []\n\n    def getNumPyGrid(self):\n        pass\n\n    def getWeatherGrid(self):\n        return self.weatherGrid\n\n    def setWeatherGrid(self, weatherGrid):\n        self.weatherGrid = weatherGrid\n\n    def getKeys(self):\n        return self.keys\n\n    def setKeys(self, keys):\n        self.keys = keys\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/slice/__init__.py,0,"b""\n__all__ = [\n            'AbstractGridSlice',\n            'DiscreteGridSlice',\n            'ScalarGridSlice',\n            'VectorGridSlice',\n            'WeatherGridSlice'\n          ]\n\nfrom .AbstractGridSlice import AbstractGridSlice\nfrom .DiscreteGridSlice import DiscreteGridSlice\nfrom .ScalarGridSlice import ScalarGridSlice\nfrom .VectorGridSlice import VectorGridSlice\nfrom .WeatherGridSlice import WeatherGridSlice\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/weather/WeatherKey.py,0,"b'SUBKEY_SEPARATOR = \'^\'\n\n\nclass WeatherKey(object):\n    # FIXME: Implement WeatherSubKey and use it in this class when needed.\n\n    def __init__(self, siteId="""", subKeys=[]):\n        self.siteId = siteId\n        if isinstance(subKeys, str):\n            self.__parseString(str(subKeys))\n        else:\n            self.subKeys = subKeys\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return SUBKEY_SEPARATOR.join(self.subKeys)\n\n    def __eq__(self, other):\n        if not isinstance(other, WeatherKey):\n            return False\n        return self.subKeys == self.subKeys\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        prime = 31\n        result = 1\n        result = prime * result + (0 if self.subKeys is None else hash(self.subKeys))\n        return result\n\n    def getSiteId(self):\n        return self.siteId\n\n    def setSiteId(self, siteId):\n        self.siteId = siteId\n\n    def getSubKeys(self):\n        return self.subKeys\n\n    def setSubKeys(self, subKeys):\n        self.subKeys = subKeys\n\n    def __parseString(self, subKeys):\n        self.subKeys = subKeys.split(SUBKEY_SEPARATOR)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/weather/WeatherSubKey.py,0,"b'# TODO: Implement WeatherSubKey when it is explicitly needed. For now\n# WeatherSubKeys will be list of str within the WeatherKey class.\n\n\nclass WeatherSubKey(object):\n\n    def __init__(self):\n        raise NotImplementedError(""WeatherSubKey is not currently supported."")\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/weather/__init__.py,0,"b""\n__all__ = [\n            'WeatherKey',\n            'WeatherSubKey'\n          ]\n\nfrom .WeatherKey import WeatherKey\nfrom .WeatherSubKey import WeatherSubKey\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/grid/request/DeleteAllGridDataRequest.py,0,"b'\n\nclass DeleteAllGridDataRequest(object):\n\n    def __init__(self, modelName=None):\n        self.modelName = modelName\n\n    def getModelName(self):\n        return self.modelName\n\n    def setModelName(self, modelName):\n        self.modelName = modelName\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/grid/request/__init__.py,0,"b""\n__all__ = [\n            'DeleteAllGridDataRequest'\n          ]\n\nfrom .DeleteAllGridDataRequest import DeleteAllGridDataRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/request/GetRadarDataRecordRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Aug 19, 2014                  nabowle        Generated\n\nimport numpy\n\n\nclass GetRadarDataRecordRequest(object):\n\n    def __init__(self):\n        self.timeRange = None\n        self.productCode = None\n        self.radarId = None\n        self.primaryElevationAngle = None\n\n    def getTimeRange(self):\n        return self.timeRange\n\n    def setTimeRange(self, timeRange):\n        self.timeRange = timeRange\n\n    def getProductCode(self):\n        return self.productCode\n\n    def setProductCode(self, productCode):\n        self.productCode = productCode\n\n    def getRadarId(self):\n        return self.radarId\n\n    def setRadarId(self, radarId):\n        self.radarId = radarId\n\n    def getPrimaryElevationAngle(self):\n        return self.primaryElevationAngle\n\n    def setPrimaryElevationAngle(self, primaryElevationAngle):\n        self.primaryElevationAngle = numpy.float64(primaryElevationAngle)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/request/__init__.py,0,"b""\n__all__ = [\n            'GetRadarDataRecordRequest'\n          ]\n\nfrom .GetRadarDataRecordRequest import GetRadarDataRecordRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/response/GetRadarDataRecordResponse.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Aug 19, 2014                  nabowle        Generated\n\n\nclass GetRadarDataRecordResponse(object):\n\n    def __init__(self):\n        self.data = None\n\n    def getData(self):\n        return self.data\n\n    def setData(self, data):\n        self.data = data\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/response/RadarDataRecord.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Aug 19, 2014                  nabowle        Generated\n\n\nclass RadarDataRecord(object):\n\n    def __init__(self):\n        self.hdf5Data = None\n        self.trueElevationAngle = None\n        self.elevationNumber = None\n        self.elevation = None\n        self.longitude = None\n        self.latitude = None\n        self.dataTime = None\n        self.volumeCoveragePattern = None\n\n    def getHdf5Data(self):\n        return self.hdf5Data\n\n    def setHdf5Data(self, hdf5Data):\n        self.hdf5Data = hdf5Data\n\n    def getTrueElevationAngle(self):\n        return self.trueElevationAngle\n\n    def setTrueElevationAngle(self, trueElevationAngle):\n        self.trueElevationAngle = trueElevationAngle\n\n    def getElevationNumber(self):\n        return self.elevationNumber\n\n    def setElevationNumber(self, elevationNumber):\n        self.elevationNumber = elevationNumber\n\n    def getElevation(self):\n        return self.elevation\n\n    def setElevation(self, elevation):\n        self.elevation = elevation\n\n    def getLongitude(self):\n        return self.longitude\n\n    def setLongitude(self, longitude):\n        self.longitude = longitude\n\n    def getLatitude(self):\n        return self.latitude\n\n    def setLatitude(self, latitude):\n        self.latitude = latitude\n\n    def getDataTime(self):\n        return self.dataTime\n\n    def setDataTime(self, dataTime):\n        self.dataTime = dataTime\n\n    def getVolumeCoveragePattern(self):\n        return self.volumeCoveragePattern\n\n    def setVolumeCoveragePattern(self, volumeCoveragePattern):\n        self.volumeCoveragePattern = volumeCoveragePattern\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/radar/response/__init__.py,0,"b""\n__all__ = [\n            'GetRadarDataRecordResponse',\n            'RadarDataRecord'\n          ]\n\nfrom .GetRadarDataRecordResponse import GetRadarDataRecordResponse\nfrom .RadarDataRecord import RadarDataRecord\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/dbsrv/TextDBRequest.py,0,"b'\n\nclass TextDBRequest(object):\n\n    def __init__(self):\n        self.message = None\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/dbsrv/__init__.py,0,"b""\n__all__ = [\n            'TextDBRequest'\n          ]\n\nfrom .TextDBRequest import TextDBRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/subscription/__init__.py,0,"b""\n__all__ = [\n            'request'\n          ]\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/diagnostic/GetClusterMembersRequest.py,0,b'\n\nclass GetClusterMembersRequest(object):\n\n    def __init__(self):\n        pass\n'
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/diagnostic/GetContextsRequest.py,0,"b'\n\nclass GetContextsRequest(object):\n\n    def __init__(self):\n        self.contextState = None\n\n    def getContextState(self):\n        return self.contextState\n\n    def setContextState(self, contextState):\n        self.contextState = contextState\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/diagnostic/StatusRequest.py,0,b'\n\nclass StatusRequest(object):\n\n    def __init__(self):\n        pass\n'
dynamicserialize/dstypes/com/raytheon/uf/common/management/request/diagnostic/__init__.py,0,"b""\n__all__ = [\n            'GetClusterMembersRequest',\n            'GetContextsRequest',\n            'StatusRequest'\n          ]\n\nfrom .GetClusterMembersRequest import GetClusterMembersRequest\nfrom .GetContextsRequest import GetContextsRequest\nfrom .StatusRequest import StatusRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/response/diagnostic/ClusterMembersResponse.py,0,"b""\n\nclass ClusterMembersResponse(object):\n\n    def __init__(self):\n        self.status = None\n\n    def getStatus(self):\n        return self.status\n\n    def setStatus(self, status):\n        self.status = status\n\n    def __repr__(self):\n        msg = ''\n        for x in self.status:\n            msg += str(x) + '\\n'\n        return msg\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/response/diagnostic/ContextsResponse.py,0,"b'\n\nclass ContextsResponse(object):\n\n    def __init__(self):\n        self.contextState = None\n        self.contexts = None\n\n    def getContextState(self):\n        return self.contextState\n\n    def setContextState(self, contextState):\n        self.contextState = contextState\n\n    def getContexts(self):\n        return self.contexts\n\n    def setContexts(self, contexts):\n        self.contexts = contexts\n\n    def __repr__(self):\n        return str(self.contexts)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/management/response/diagnostic/StatusResponse.py,0,"b""\n\nclass StatusResponse(object):\n\n    def __init__(self):\n        self.hostname = None\n        self.jvmName = None\n        self.statistics = None\n\n    def getHostname(self):\n        return self.hostname\n\n    def setHostname(self, hostname):\n        self.hostname = hostname\n\n    def getJvmName(self):\n        return self.jvmName\n\n    def setJvmName(self, jvmName):\n        self.jvmName = jvmName\n\n    def getStatistics(self):\n        return self.statistics\n\n    def setStatistics(self, statistics):\n        self.statistics = statistics\n\n    def __repr__(self):\n        return self.hostname + ':' + self.jvmName\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/management/response/diagnostic/__init__.py,0,"b""\n__all__ = [\n            'ClusterMembersResponse',\n            'ContextsResponse',\n            'StatusResponse'\n          ]\n\nfrom .ClusterMembersResponse import ClusterMembersResponse\nfrom .ContextsResponse import ContextsResponse\nfrom .StatusResponse import StatusResponse\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/serialization/comm/response/ServerErrorResponse.py,0,"b'\n\nclass ServerErrorResponse(object):\n\n    def __init__(self):\n        self.exception = None\n\n    def getException(self):\n        return self.exception\n\n    def setException(self, exception):\n        self.exception = exception\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/serialization/comm/response/__init__.py,0,"b""#\n# Package definition for com.raytheon.uf.common.serialization.comm.response\n#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    09/21/10                      njensen       Initial Creation.\n#\n#\n#\n\n__all__ = [\n            'ServerErrorResponse'\n          ]\n\nfrom .ServerErrorResponse import ServerErrorResponse\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/atcf/__init__.py,0,"b""\n__all__ = [\n            'request'\n          ]\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/__init__.py,0,"b""\n__all__ = [\n            'request'\n          ]\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gpd/__init__.py,0,"b""\n__all__ = [\n            'query'\n          ]\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/ActivityInfo.py,0,"b'\n\nclass ActivityInfo(object):\n\n    def __init__(self):\n        self.activityName = None\n        self.activityType = None\n        self.activitySubtype = None\n        self.activityLabel = None\n        self.site = None\n        self.desk = None\n        self.forecaster = None\n        self.refTime = None\n        self.mode = None\n        self.status = None\n\n    def getActivityName(self):\n        return self.activityName\n\n    def setActivityName(self, activityName):\n        self.activityName = activityName\n\n    def getActivityType(self):\n        return self.activityType\n\n    def setActivityType(self, activityType):\n        self.activityType = activityType\n\n    def getActivitySubtype(self):\n        return self.activitySubtype\n\n    def setActivitySubtype(self, activitySubtype):\n        self.activitySubtype = activitySubtype\n\n    def getActivityLabel(self):\n        return self.activityLabel\n\n    def setActivityLabel(self, activityLabel):\n        self.activityLabel = activityLabel\n\n    def getSite(self):\n        return self.site\n\n    def setSite(self, site):\n        self.site = site\n\n    def getDesk(self):\n        return self.desk\n\n    def setDesk(self, desk):\n        self.desk = desk\n\n    def getForecaster(self):\n        return self.forecaster\n\n    def setForecaster(self, forecaster):\n        self.forecaster = forecaster\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getMode(self):\n        return self.mode\n\n    def setMode(self, mode):\n        self.mode = mode\n\n    def getStatus(self):\n        return self.status\n\n    def setStatus(self, status):\n        self.status = status\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/DerivedProduct.py,0,"b'\n\nclass DerivedProduct(object):\n\n    def __init__(self):\n        self.name = None\n        self.productType = None\n        self.product = None\n\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def getProductType(self):\n        return self.productType\n\n    def setProductType(self, productType):\n        self.productType = productType\n\n    def getProduct(self):\n        return self.product\n\n    def setProduct(self, product):\n        self.product = product\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/ResponseMessageValidate.py,0,"b'\n\nclass ResponseMessageValidate(object):\n\n    def __init__(self):\n        self.result = None\n        self.message = None\n        self.fileType = None\n        self.dataURI = None\n        self.validTime = None\n\n    def getResult(self):\n        return self.result\n\n    def setResult(self, result):\n        self.result = result\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n\n    def getFileType(self):\n        return self.fileType\n\n    def setFileType(self, fileType):\n        self.fileType = fileType\n\n    def getDataURI(self):\n        return self.dataURI\n\n    def setDataURI(self, dataURI):\n        self.dataURI = dataURI\n\n    def getValidTime(self):\n        return self.validTime\n\n    def setValidTime(self, validTime):\n        self.validTime = validTime\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/__init__.py,0,"b""\n__all__ = [\n            'request',\n            'response',\n            'ActivityInfo',\n            'DerivedProduct',\n            'ResponseMessageValidate'\n          ]\n\nfrom .ActivityInfo import ActivityInfo\nfrom .DerivedProduct import DerivedProduct\nfrom .ResponseMessageValidate import ResponseMessageValidate\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/events/hazards/requests/RegionLookupRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Oct 08, 2014                  reblum         Generated\n\n\nclass RegionLookupRequest(object):\n\n    def __init__(self):\n        self.region = None\n        self.site = None\n\n    def getRegion(self):\n        return self.region\n\n    def setRegion(self, region):\n        self.region = region\n\n    def getSite(self):\n        return self.site\n\n    def setSite(self, site):\n        self.site = site\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/events/hazards/requests/__init__.py,0,"b""\n__all__ = [\n            'RegionLookupRequest'\n          ]\n\nfrom .RegionLookupRequest import RegionLookupRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/DatabaseID.py,0,"b'# Modified by njensen to add __repr__\n\nimport time\n\n\nclass DatabaseID(object):\n\n    def __init__(self, dbIdentifier=None):\n        self.siteId = None\n        self.format = ""NONE""\n        self.dbType = None\n        self.modelName = None\n        self.modelTime = None\n        self.modelId = None\n        self.shortModelId = None\n        if dbIdentifier is not None:\n            if self.__decodeIdentifier(dbIdentifier):\n                self.__encodeIdentifier()\n            else:\n                self.format = ""NONE""\n                self.dbType = """"\n                self.siteId = """"\n                self.modelName = """"\n                self.modelTime = ""00000000_0000""\n                self.modelId = """"\n                self.shortModelId = """"\n\n    def isValid(self):\n        return self.format != ""NONE""\n\n    def getSiteId(self):\n        return self.siteId\n\n    def setSiteId(self, siteId):\n        self.siteId = siteId\n\n    def getFormat(self):\n        return self.format\n\n    def setFormat(self, dbformat):\n        self.format = dbformat\n\n    def getDbType(self):\n        return self.dbType\n\n    def setDbType(self, dbType):\n        self.dbType = dbType\n\n    def getModelName(self):\n        return self.modelName\n\n    def setModelName(self, modelName):\n        self.modelName = modelName\n\n    def getModelTime(self):\n        return self.modelTime\n\n    def setModelTime(self, modelTime):\n        self.modelTime = modelTime\n\n    def getModelId(self):\n        return self.modelId\n\n    def setModelId(self, modelId):\n        self.modelId = modelId\n\n    def getShortModelId(self):\n        return self.shortModelId\n\n    def setShortModelId(self, shortModelId):\n        self.shortModelId = shortModelId\n\n    def __encodeIdentifier(self):\n        if self.dbType is not None:\n            self.modelId = self.siteId + ""_"" + self.format + ""_"" \\\n                           + self.dbType + ""_"" + self.modelName\n        else:\n            self.modelId = self.siteId + ""_"" + self.format + ""__"" \\\n                           + self.modelName\n\n        self.shortModelId = self.modelName\n        if self.dbType is not None and self.dbType != """":\n            self.shortModelId += ""_"" + self.dbType\n\n        if self.modelTime != ""00000000_0000"":\n            self.modelId += ""_"" + self.modelTime\n            self.shortModelId += ""_"" + self.modelTime[6:8] + self.modelTime[9:11]\n        else:\n            self.modelId += ""_"" + ""00000000_0000""\n\n        self.shortModelId += "" ("" + self.siteId + "")""\n\n    def __decodeIdentifier(self, dbIdentifier):\n        self.format = ""NONE""\n        self.dbType = """"\n        self.siteId = """"\n        self.modelName = """"\n        self.modelTime = ""00000000_0000""\n\n        # parse into \'_\' separated strings\n        strings = dbIdentifier.split(""_"")\n        if len(strings) != 6:\n            return False\n\n        # store the data\n        if strings[1] == ""GRID"":\n            self.format = ""GRID""\n        else:\n            return False\n\n        self.siteId = strings[0]\n        self.dbType = strings[2]\n        self.modelName = strings[3]\n\n        # date-time group\n        if len(strings[4]) != 8 or len(strings[5]) != 4:\n            return False\n\n        # make sure the digits are there\n        dtg = strings[4] + \'_\' + strings[5]  # back together\n        if dtg != ""00000000_0000"":\n            if not self.__decodeDtg(dtg):\n                return False\n\n        return True\n\n    @staticmethod\n    def decodeDtg(dtgString):\n        dateStruct = time.gmtime(0)\n        try:\n            dateStruct = time.strptime(dtgString, ""%Y%m%d_%H%M"")\n        except ValueError:\n            return False, dateStruct\n        return True, dateStruct\n\n    def __decodeDtg(self, dtgString):\n        try:\n            time.strptime(dtgString, ""%Y%m%d_%H%M"")\n            self.modelTime = dtgString\n        except ValueError:\n            return False\n        return True\n\n    def getModelTimeAsDate(self):\n        if self.modelTime == ""00000000_0000"":\n            return time.gmtime(0)\n        else:\n            return time.strptime(self.modelTime, ""%Y%m%d_%H%M"")\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return self.modelId\n\n    def __hash__(self):\n        prime = 31\n        result = 1\n        result = prime * result + (0 if self.dbType is None else hash(self.dbType))\n        result = prime * result + (0 if self.format is None else hash(self.format))\n        result = prime * result + (0 if self.modelId is None else hash(self.modelId))\n        result = prime * result + (0 if self.modelTime is None else hash(self.modelTime))\n        result = prime * result + (0 if self.siteId is None else hash(self.siteId))\n        return result\n\n    def __cmp__(self, other):\n        if not isinstance(other, DatabaseID):\n            siteComp = cmp(self.siteId, other.siteId)\n            if siteComp != 0:\n                return siteComp\n\n            formatComp = cmp(self.format, other.format)\n            if formatComp != 0:\n                return formatComp\n\n            typeComp = cmp(self.dbType, other.dbType)\n            if typeComp != 0:\n                return typeComp\n\n            nameComp = cmp(self.modelName, other.modelName)\n            if nameComp != 0:\n                return nameComp\n\n            return -cmp(self.getModelTimeAsDate(), other.getModelTimeAsDate())\n        else:\n            return NotImplemented\n\n    def __eq__(self, other):\n        if not isinstance(other, DatabaseID):\n            return False\n        return str(self) == str(other)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/GFERecord.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import ParmID\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import DataTime\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import TimeRange\n\n\nclass GFERecord(object):\n\n    def __init__(self, parmId=None, timeRange=None):\n        self.gridHistory = []\n        self.dataURI = None\n        self.pluginName = ""gfe""\n        self.insertTime = None\n        self.messageData = None\n        self.identifier = None\n        self.dataTime = None\n        self.parmId = None\n        if timeRange is not None:\n            if isinstance(timeRange, TimeRange):\n                self.dataTime = DataTime(refTime=timeRange.getStart(), validPeriod=timeRange)\n            else:\n                raise TypeError(""Invalid TimeRange object specified."")\n        if parmId is not None:\n            if isinstance(parmId, ParmID.ParmID):\n                self.parmId = parmId\n                self.parmName = parmId.getParmName()\n                self.parmLevel = parmId.getParmLevel()\n                self.dbId = parmId.getDbId()\n            else:\n                raise TypeError(""Invalid ParmID object specified. Type:"" + str(type(parmId)))\n\n    def getParmName(self):\n        return self.parmName\n\n    def setParmName(self, parmName):\n        self.parmName = parmName\n\n    def getParmLevel(self):\n        return self.parmLevel\n\n    def setParmLevel(self, parmLevel):\n        self.parmLevel = parmLevel\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getDbId(self):\n        return self.dbId\n\n    def setDbId(self, dbId):\n        self.dbId = dbId\n\n    def getGridHistory(self):\n        return self.gridHistory\n\n    def setGridHistory(self, gridHistory):\n        self.gridHistory = gridHistory\n\n    def getDataURI(self):\n        return self.dataURI\n\n    def setDataURI(self, dataURI):\n        self.dataURI = dataURI\n\n    def getPluginName(self):\n        return ""gfe""\n\n    def getDataTime(self):\n        return self.dataTime\n\n    def setDataTime(self, dataTime):\n        self.dataTime = dataTime\n\n    def getInsertTime(self):\n        return self.insertTime\n\n    def setInsertTime(self, insertTime):\n        self.insertTime = insertTime\n\n    def getMessageData(self):\n        return self.messageData\n\n    def setMessageData(self, messageData):\n        self.messageData = messageData\n\n    def getIdentifier(self):\n        return self.identifier\n\n    def setIdentifier(self, identifier):\n        self.identifier = identifier\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/GridLocation.py,0,"b'\n\nclass GridLocation(object):\n\n    def __init__(self):\n        self.siteId = None\n        self.nx = None\n        self.ny = None\n        self.timeZone = None\n        self.projection = None\n        self.origin = None\n        self.extent = None\n        self.geometry = None\n        self.crsWKT = None\n        self.identifier = None\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        # TODO: Handle geometry in dynamicserialize\n        # ,loc="" + this.geometry.getGeometryType()\n        s = ""[SiteID ="" + self.siteId + "",ProjID="" + self.projection.getProjectionID() +\\\n            "",gridSize=("" + str(self.nx) + \',\' + str(self.ny) + "")]""\n        return s\n\n    def __eq__(self, other):\n        if not isinstance(other, GridLocation):\n            return False\n        if self.siteId != other.siteId:\n            return False\n        if self.crsWKT != other.crsWKT:\n            return False\n        # FIXME: Geometry/Polygon objects don\'t really work in dynamicserialize\n        # commenting out this check unless it causes problems\n#        if self.geometry != other.geometry:\n#            return False\n        if self.nx != other.nx:\n            return False\n        if self.ny != other.ny:\n            return False\n        return True\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def getSiteId(self):\n        return self.siteId\n\n    def setSiteId(self, siteId):\n        self.siteId = siteId\n\n    def getNx(self):\n        return self.nx\n\n    def setNx(self, nx):\n        self.nx = nx\n\n    def getNy(self):\n        return self.ny\n\n    def setNy(self, ny):\n        self.ny = ny\n\n    def getTimeZone(self):\n        return self.timeZone\n\n    def setTimeZone(self, timeZone):\n        self.timeZone = timeZone\n\n    def getProjection(self):\n        return self.projection\n\n    def setProjection(self, projection):\n        self.projection = projection\n\n    def getOrigin(self):\n        return self.origin\n\n    def setOrigin(self, origin):\n        self.origin = origin\n\n    def getExtent(self):\n        return self.extent\n\n    def setExtent(self, extent):\n        self.extent = extent\n\n    def getGeometry(self):\n        return self.geometry\n\n    def setGeometry(self, geometry):\n        self.geometry = geometry\n\n    def getCrsWKT(self):\n        return self.crsWKT\n\n    def setCrsWKT(self, crsWKT):\n        self.crsWKT = crsWKT\n\n    def getIdentifier(self):\n        return self.identifier\n\n    def setIdentifier(self, identifier):\n        self.identifier = identifier\n\n    def isValid(self):\n        if self.projection is None:\n            return False\n        if self.nx < 2 or self.ny < 2:\n            return False\n        if self.origin is None or self.extent is None:\n            return False\n        return True\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/GridParmInfo.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import GridLocation\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import ParmID\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import TimeConstraints\n\n\nclass GridParmInfo(object):\n\n    def __init__(self, parmid=None, gridLoc=None, gridType=""NONE"", unit=None,\n                 descriptiveName="""", minValue=0.0, maxValue=0.0, precision=0,\n                 timeIndependentParm=False, timeConstraints=None, rateParm=False):\n        self.parmID = parmid\n        self.gridLoc = gridLoc\n        self.gridType = gridType\n        self.descriptiveName = descriptiveName\n        self.unitString = unit\n        self.minValue = float(minValue)\n        self.maxValue = float(maxValue)\n        self.precision = int(precision)\n        self.rateParm = rateParm\n        self.timeConstraints = timeConstraints\n        self.timeIndependentParm = timeIndependentParm\n\n#        (valid, errors) = self.__validCheck()\n#        if not valid:\n#            errorMessage = ""GridParmInfo is invalid: "" + str(errors)\n#            warnings.warn(errorMessage)\n#            self.__setDefaultValues()\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        if self.isValid():\n            out = ""ParmID: "" + str(self.parmID) + \\\n                  "" TimeConstraints: "" + str(self.timeConstraints) + \\\n                  "" GridLoc: "" + str(self.gridLoc) + \\\n                  "" Units: "" + self.unitString + \\\n                  "" Name: "" + self.descriptiveName + \\\n                  "" Min/Max AllowedValues: "" + str(self.minValue) + "","" + \\\n                  str(self.maxValue) + "" Precision: "" + str(self.precision) + \\\n                  "" TimeIndependent: "" + str(self.timeIndependentParm) + \\\n                  "" RateParm: "" + str(self.rateParm) + \\\n                  "" GridType: "" + self.gridType\n            return out\n        return ""<Invalid>""\n\n    def __eq__(self, other):\n        if not isinstance(other, GridParmInfo):\n            return False\n        if self.descriptiveName != other.descriptiveName:\n            return False\n        if self.gridLoc != other.gridLoc:\n            return False\n        if self.gridType != other.gridType:\n            return False\n        if self.minValue != other.minValue:\n            return False\n        if self.maxValue != other.maxValue:\n            return False\n        if self.parmID != other.parmID:\n            return False\n        if self.precision != other.precision:\n            return False\n        if self.rateParm != other.rateParm:\n            return False\n        if self.timeConstraints != other.timeConstraints:\n            return False\n        if self.timeIndependentParm != other.timeIndependentParm:\n            return False\n        if self.unitString != other.unitString:\n            return False\n        return True\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __validCheck(self):\n        status = []\n\n        if not self.parmID.isValid():\n            status.append(""GridParmInfo.ParmID is not valid ["" + str(self.parmID) + ""]"")\n        if not self.timeConstraints.isValid():\n            status.append(""GridParmInfo.TimeConstraints are not valid ["" +\n                          str(self.timeConstraints) + ""]"")\n        if not self.gridLoc.isValid():\n            status.append(""GridParmInfo.GridLocation is not valid"")\n        if self.timeIndependentParm and self.timeConstraints.anyConstraints():\n            status.append(""GridParmInfo is invalid. There are time constraints"" +\n                          "" for a time independent parm. Constraints: "" +\n                          str(self.timeConstraints))\n        if not self.unitString:\n            status.append(""GridParmInfo.Units are not defined."")\n        if self.precision < -2 or self.precision > 5:\n            status.append(""GridParmInfo is invalid. Precision out of limits."" +\n                          "" Precision is: "" + str(self.precision) + "". Must be between -2 and 5."")\n\n        retVal = True\n        if status:\n            retVal = False\n        return retVal, status\n\n    def isValid(self):\n        (valid, errors) = self.__validCheck()\n        return valid\n\n    def __setDefaultValues(self):\n        self.parmID = ParmID()\n        self.gridLoc = GridLocation()\n        self.gridType = ""NONE""\n        self.descriptiveName = """"\n        self.unitString = """"\n        self.minValue = 0.0\n        self.maxValue = 0.0\n        self.precision = 0\n        self.rateParm = False\n        self.timeConstraints = TimeConstraints()\n        self.timeIndependentParm = False\n\n    def getParmID(self):\n        return self.parmID\n\n    def setParmID(self, parmID):\n        self.parmID = parmID\n\n    def getGridLoc(self):\n        return self.gridLoc\n\n    def setGridLoc(self, gridLoc):\n        self.gridLoc = gridLoc\n\n    def getGridType(self):\n        return self.gridType\n\n    def setGridType(self, gridType):\n        self.gridType = gridType\n\n    def getDescriptiveName(self):\n        return self.descriptiveName\n\n    def setDescriptiveName(self, descriptiveName):\n        self.descriptiveName = descriptiveName\n\n    def getUnitString(self):\n        return self.unitString\n\n    def setUnitString(self, unitString):\n        self.unitString = unitString\n\n    def getMinValue(self):\n        return self.minValue\n\n    def setMinValue(self, minValue):\n        self.minValue = minValue\n\n    def getMaxValue(self):\n        return self.maxValue\n\n    def setMaxValue(self, maxValue):\n        self.maxValue = maxValue\n\n    def getPrecision(self):\n        return self.precision\n\n    def setPrecision(self, precision):\n        self.precision = precision\n\n    def getRateParm(self):\n        return self.rateParm\n\n    def setRateParm(self, rateParm):\n        self.rateParm = rateParm\n\n    def getTimeConstraints(self):\n        return self.timeConstraints\n\n    def setTimeConstraints(self, timeConstraints):\n        self.timeConstraints = timeConstraints\n\n    def getTimeIndependentParm(self):\n        return self.timeIndependentParm\n\n    def setTimeIndependentParm(self, timeIndependentParm):\n        self.timeIndependentParm = timeIndependentParm\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/ParmID.py,0,"b'# Modified by njensen to add __repr__\n\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import DatabaseID\n\n\nclass ParmID(object):\n\n    def __init__(self, parmIdentifier=None, dbId=None, level=None):\n        self.parmName = None\n        self.parmLevel = None\n        self.dbId = None\n        self.compositeName = None\n        self.shortParmId = None\n        self.parmId = None\n\n        if (parmIdentifier is not None) and (dbId is not None):\n            self.parmName = parmIdentifier\n\n            if isinstance(dbId, DatabaseID):\n                self.dbId = dbId\n            elif isinstance(dbId, str):\n                self.dbId = DatabaseID(dbId)\n            else:\n                raise TypeError(""Invalid database ID specified."")\n\n            if level is None:\n                self.parmLevel = self.defaultLevel()\n            else:\n                self.parmLevel = level\n\n            self.__encodeIdentifier()\n\n        elif parmIdentifier is not None:\n            self.__decodeIdentifier(parmIdentifier)\n            self.__encodeIdentifier()\n\n    def getParmName(self):\n        return self.parmName\n\n    def getParmLevel(self):\n        return self.parmLevel\n\n    def getDbId(self):\n        return self.dbId\n\n    def getCompositeName(self):\n        return self.compositeName\n\n    def getShortParmId(self):\n        return self.shortParmId\n\n    def getParmId(self):\n        return self.parmId\n\n    def __decodeIdentifier(self, parmIdentifier):\n        parts = parmIdentifier.split("":"")\n        nameLevel = parts[0].split(""_"")\n        self.dbId = DatabaseID(parts[1])\n        if len(nameLevel) == 2:\n            self.parmName = nameLevel[0]\n            self.parmLevel = nameLevel[1]\n        else:\n            self.parmName = nameLevel[0]\n            self.parmLevel = self.defaultLevel()\n\n    def __encodeIdentifier(self):\n        self.compositeName = self.parmName + ""_"" + self.parmLevel\n        self.shortParmId = self.compositeName + "":"" + self.dbId.getShortModelId()\n        self.parmId = self.compositeName + "":"" + self.dbId.getModelId()\n\n    def isValid(self):\n        if len(self.parmName) is None or len(self.parmLevel) is None or self.dbId is None:\n            return False\n        if len(self.parmName) < 1 or len(self.parmLevel) < 1 or not self.dbId.isValid():\n            return False\n\n        if not self.parmName.isalnum():\n            return False\n        if not self.parmLevel.isalnum():\n            return False\n\n        return True\n\n    @staticmethod\n    def defaultLevel():\n        return ""SFC""\n\n    @staticmethod\n    def parmNameAndLevel(composite):\n        pos = composite.find(\'_\')\n        if pos != -1:\n            return composite[:pos], composite[pos+1:]\n        else:\n            return composite, ""SFC""\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        return self.parmName + \'_\' + self.parmLevel + "":"" + str(self.dbId)\n\n    def __hash__(self):\n        return hash(self.parmId)\n\n    def __cmp__(self, other):\n        if isinstance(other, ParmID):\n            nameComp = cmp(self.parmName, other.parmName)\n            if nameComp != 0:\n                return nameComp\n\n            levelComp = cmp(self.parmLevel, other.parmLevel)\n            if levelComp != 0:\n                return levelComp\n\n            return cmp(self.dbId, other.dbId)\n        else:\n            return NotImplemented\n\n    def __eq__(self, other):\n        if not isinstance(other, ParmID):\n            return False\n        if self.dbId != other.dbId:\n            return False\n        if self.parmLevel != other.parmLevel:\n            return False\n        if self.parmName != other.parmName:\n            return False\n        return True\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/TimeConstraints.py,0,"b'#\n# 03/20/2013     #1774    randerso  Removed setters, added isValid.\n\n\nimport logging\n\nHOUR = 3600\nDAY = 24 * HOUR\n\n\nclass TimeConstraints(object):\n\n    def __init__(self, duration=0, repeatInterval=0, startTime=0):\n        duration = int(duration)\n        repeatInterval = int(repeatInterval)\n        startTime = int(startTime)\n\n        self.valid = False\n        if duration == 0 and repeatInterval == 0 and startTime == 0:\n            self.valid = True\n        else:\n            if self.isInvalidInterval(repeatInterval, duration, startTime):\n                logging.warning(""Bad init values for TimeConstraints: ""\n                                + str(duration) + "", ""\n                                + str(repeatInterval) + "", ""\n                                + str(startTime))\n                self.valid = False\n                duration = 0\n                repeatInterval = 0\n                startTime = 0\n            else:\n                self.valid = True\n\n        self.duration = duration\n        self.repeatInterval = repeatInterval\n        self.startTime = startTime\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __repr__(self):\n        if not self.isValid():\n            return ""<Invalid>""\n        elif not self.anyConstraints():\n            return ""<NoConstraints>""\n        else:\n            return ""[s="" + str(self.startTime / HOUR) + ""h, i="" + \\\n                   str(self.repeatInterval / HOUR) + ""h, d="" + \\\n                   str(self.duration / HOUR) + ""h]""\n\n    def __eq__(self, other):\n        if not isinstance(other, TimeConstraints):\n            return False\n        if self.isValid() != other.isValid():\n            return False\n        if self.duration != other.duration:\n            return False\n        if self.repeatInterval != other.repeatInterval:\n            return False\n        return self.startTime == other.startTime\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def anyConstraints(self):\n        return self.duration != 0\n\n    def isValid(self):\n        return self.valid\n\n    def getDuration(self):\n        return self.duration\n\n    def getRepeatInterval(self):\n        return self.repeatInterval\n\n    def getStartTime(self):\n        return self.startTime\n\n    def isInvalidInterval(self, interval, duration, startTime):\n        if interval <= 0 or interval > DAY or interval < duration:\n            return False\n        if startTime < 0 or startTime > DAY:\n            return False\n        if duration < 0 or duration > DAY:\n            return False\n        if DAY % interval != 0:\n            return False\n        return True\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/db/objects/__init__.py,0,"b""\n__all__ = [\n            'DatabaseID',\n            'GFERecord',\n            'GridLocation',\n            'GridParmInfo',\n            'ParmID',\n            'TimeConstraints'\n          ]\n\nfrom .DatabaseID import DatabaseID\nfrom .GFERecord import GFERecord\nfrom .GridLocation import GridLocation\nfrom .GridParmInfo import GridParmInfo\nfrom .ParmID import ParmID\nfrom .TimeConstraints import TimeConstraints\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/lock/Lock.py,0,"b'#\n#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    xx/xx/xxxx                    xxxxxxx        Initial Creation.\n#    xx/xx/xxxx      xxxx          njensen        Implemented __repr__.\n#    06/12/2013      2099          dgilling       Make class immutable,\n#                                                 add getTimeRange().\n#\n\nimport time\nfrom dynamicserialize.dstypes.com.raytheon.uf.common.time import TimeRange\n\n\nclass Lock(object):\n\n    def __init__(self, parmId, wsId, startTime, endTime):\n        self.parmId = parmId\n        self.wsId = wsId\n        self.startTime = startTime\n        self.endTime = endTime\n        self.timeRange = None\n\n    def getParmId(self):\n        return self.parmId\n\n    def getWsId(self):\n        return self.wsId\n\n    def getStartTime(self):\n        return self.startTime\n\n    def getEndTime(self):\n        return self.endTime\n\n    def getTimeRange(self):\n        if not self.timeRange:\n            start = self.startTime / 1000.0\n            end = self.endTime / 1000.0\n            self.timeRange = TimeRange(start, end)\n        return self.timeRange\n\n    def __repr__(self):\n        t0 = time.gmtime(self.getStartTime() / 1000.0)\n        t1 = time.gmtime(self.getEndTime() / 1000.0)\n        timeformat = \'%b %d %y %H:%M:%S %Z\'\n        msg = \'TR: (\' + time.strftime(timeformat, t0) \\\n              + \', \' + time.strftime(timeformat, t1)\n        msg += "" WsId: "" + str(self.wsId)\n        return msg\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/lock/LockTable.py,0,"b'#\n# SOFTWARE HISTORY\n#\n# Date          Ticket#  Engineer  Description\n# ------------- -------- --------- ---------------------------------------------\n# Feb 06, 2017  5959     randerso  Removed Java .toString() calls\n#\n\n# Modified by njensen to add __repr__\n\n\nclass LockTable(object):\n\n    def __init__(self):\n        self.locks = None\n        self.wsId = None\n        self.parmId = None\n\n    def getLocks(self):\n        return self.locks\n\n    def setLocks(self, locks):\n        self.locks = locks\n\n    def getWsId(self):\n        return self.wsId\n\n    def setWsId(self, wsId):\n        self.wsId = wsId\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def __repr__(self):\n        msg = ""ParmID: "" + str(self.parmId)\n        msg += "" LockTable WsId: "" + str(self.wsId)\n        for i in self.locks:\n            msg += ""\\n  Lock: "" + str(i)\n        return msg\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/lock/__init__.py,0,"b""\n__all__ = [\n            'Lock',\n            'LockTable'\n          ]\n\nfrom .Lock import Lock\nfrom .LockTable import LockTable\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/message/ServerMsg.py,0,"b'\n\nclass ServerMsg(object):\n\n    def __init__(self):\n        self.message = None\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/message/ServerResponse.py,0,"b'\n\nclass ServerResponse(object):\n\n    def __init__(self):\n        self.messages = None\n        self.payload = None\n        self.notifications = None\n\n    def getMessages(self):\n        return self.messages\n\n    def setMessages(self, messages):\n        self.messages = messages\n\n    def getPayload(self):\n        return self.payload\n\n    def setPayload(self, payload):\n        self.payload = payload\n\n    def getNotifications(self):\n        return self.notifications\n\n    def setNotifications(self, notifications):\n        self.notifications = notifications\n\n    def isOkay(self):\n        return self.messages is None or len(self.messages) == 0\n\n    def message(self):\n        if self.isOkay():\n            return """"\n        else:\n            compMessage = """"\n            for serverMsg in self.messages:\n                compMessage += serverMsg.getMessage() + ""\\n""\n\n            return compMessage\n\n    def __str__(self):\n        return self.message()\n\n    def __bool__(self):\n        return self.isOkay()\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/message/__init__.py,0,"b""\n__all__ = [\n            'ServerMsg',\n            'ServerResponse'\n          ]\n\nfrom .ServerMsg import ServerMsg\nfrom .ServerResponse import ServerResponse\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/CombinationsFileChangedNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/22/2015       4573         randerso       Initial creation (hand generated)\n#\n\nfrom . import GfeNotification\n\n\nclass CombinationsFileChangedNotification(GfeNotification.GfeNotification):\n\n    def __init__(self):\n        super(CombinationsFileChangedNotification, self).__init__()\n        self.combinationsFileName = None\n        self.whoChanged = None\n\n    def __str__(self):\n        msg = ""fileName: "" + str(self.combinationsFileName)\n        msg += \'\\n\' + ""whoChanged: "" + str(self.whoChanged)\n        return msg\n\n    def getCombinationsFileName(self):\n        return self.combinationsFileName\n\n    def setCombinationsFileName(self, combinationsFileName):\n        self.combinationsFileName = combinationsFileName\n\n    def getWhoChanged(self):\n        return self.whoChanged\n\n    def setWhoChanged(self, whoChanged):\n        self.whoChanged = whoChanged\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/DBInvChangeNotification.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/????       ????         njensen        Modified to add __repr__\n#    06/22/2015       4573         randerso       Change to extend GfeNotification\n#                                                 removed inventory methods\n#\n\nfrom . import GfeNotification\n\n\nclass DBInvChangeNotification(GfeNotification.GfeNotification):\n\n    def __init__(self):\n        super(DBInvChangeNotification, self).__init__()\n        self.additions = None\n        self.deletions = None\n\n    def getAdditions(self):\n        return self.additions\n\n    def setAdditions(self, additions):\n        self.additions = additions\n\n    def getDeletions(self):\n        return self.deletions\n\n    def setDeletions(self, deletions):\n        self.deletions = deletions\n\n    def __str__(self):\n        msg = 'Additions' + str(self.additions) + '\\n'\n        msg += 'Deletions' + str(self.deletions)\n        return msg\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/GfeNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    10/07/2014       3684         randerso       Manually updated to add sourceID\n#\n\nimport abc\nfrom six import with_metaclass\n\n\nclass GfeNotification(with_metaclass(abc.ABCMeta, object)):\n    @abc.abstractmethod\n    def __init__(self):\n        self.siteID = None\n        self.sourceID = None\n\n    def getSiteID(self):\n        return self.siteID\n\n    def setSiteID(self, siteID):\n        self.siteID = siteID\n\n    def getSourceID(self):\n        return self.sourceID\n\n    def setSourceID(self, sourceID):\n        self.sourceID = sourceID\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/GridHistoryUpdateNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/22/2015       4573         randerso       Initial creation (hand generated)\n#\n\nfrom . import GfeNotification\n\n\nclass GridHistoryUpdateNotification(GfeNotification):\n\n    def __init__(self):\n        super(GridHistoryUpdateNotification, self).__init__()\n        self.parmId = None\n        self.workstationID = None\n        self.histories = None\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getHistories(self):\n        return self.histories\n\n    def setHistories(self, histories):\n        self.histories = histories\n\n    def __str__(self):\n        msg = ""ParmID: "" + str(self.parmId)\n        msg += \'\\n\' + ""Histories: "" + str(self.histories)\n        return msg\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/GridUpdateNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/????       ????         njensen        Modified to add __repr__\n#    06/22/2015       4573         randerso       Change to extend GfeNotification\n#\n\nfrom . import GfeNotification\n\n\nclass GridUpdateNotification(GfeNotification):\n\n    def __init__(self):\n        super(GridUpdateNotification, self).__init__()\n        self.parmId = None\n        self.replacementTimeRange = None\n        self.workstationID = None\n        self.histories = None\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getReplacementTimeRange(self):\n        return self.replacementTimeRange\n\n    def setReplacementTimeRange(self, replacementTimeRange):\n        self.replacementTimeRange = replacementTimeRange\n\n    def getWorkstationID(self):\n        return self.workstationID\n\n    def setWorkstationID(self, workstationID):\n        self.workstationID = workstationID\n\n    def getHistories(self):\n        return self.histories\n\n    def setHistories(self, histories):\n        self.histories = histories\n\n    def __str__(self):\n        msg = ""ParmID: "" + str(self.parmId)\n        msg += \'\\n\' + ""Replacement TimeRange: "" + str(self.replacementTimeRange)\n        msg += \'\\n\' + ""Histories: "" + str(self.histories)\n        return msg\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/LockNotification.py,0,"b'#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    ??/??/????       ????         njensen        Modified to add __repr__\n#    06/22/2015       4573         randerso       Change to extend GfeNotification\n#\n\nfrom . import GfeNotification\n\n\nclass LockNotification(GfeNotification):\n\n    def __init__(self):\n        super(LockNotification, self).__init__()\n        self.lockTable = None\n\n    def getLockTable(self):\n        return self.lockTable\n\n    def setLockTable(self, lockTable):\n        self.lockTable = lockTable\n\n    def __str__(self):\n        return str(self.lockTable)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/UserMessageNotification.py,0,"b""#\n#     SOFTWARE HISTORY\n#\n#    Date            Ticket#       Engineer       Description\n#    ------------    ----------    -----------    --------------------------\n#    06/22/2015       4573         randerso       Change to extend GfeNotification\n#\n\nfrom . import GfeNotification\n\n\nclass UserMessageNotification(GfeNotification):\n\n    def __init__(self):\n        super(UserMessageNotification, self).__init__()\n        self.category = None\n        self.priority = None\n        self.message = None\n\n    def getCategory(self):\n        return self.category\n\n    def setCategory(self, category):\n        self.category = category\n\n    def getPriority(self):\n        return self.priority\n\n    def setPriority(self, priority):\n        self.priority = priority\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n\n    def __str__(self):\n        msg = 'Message: ' + str(self.message) + '\\n'\n        msg += 'Priority: ' + str(self.priority) + '\\n'\n        msg += 'Category: ' + str(self.category) + '\\n'\n        return msg\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/notify/__init__.py,0,"b""\n__all__ = [\n            'CombinationsFileChangedNotification',\n            'DBInvChangeNotification',\n            'GfeNotification',\n            'GridHistoryUpdateNotification',\n            'GridUpdateNotification',\n            'LockNotification',\n            'UserMessageNotification'\n          ]\n\nfrom .CombinationsFileChangedNotification import CombinationsFileChangedNotification\nfrom .DBInvChangeNotification import DBInvChangeNotification\nfrom .GfeNotification import GfeNotification\nfrom .GridHistoryUpdateNotification import GridHistoryUpdateNotification\nfrom .GridUpdateNotification import GridUpdateNotification\nfrom .LockNotification import LockNotification\nfrom .UserMessageNotification import UserMessageNotification\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/request/CommitGridRequest.py,0,"b'\n\nclass CommitGridRequest(object):\n\n    def __init__(self):\n        self.parmId = None\n        self.dbId = None\n        self.timeRange = None\n        self.clientSendStatus = False\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getDbId(self):\n        return self.dbId\n\n    def setDbId(self, dbId):\n        self.dbId = dbId\n\n    def getTimeRange(self):\n        return self.timeRange\n\n    def setTimeRange(self, timeRange):\n        self.timeRange = timeRange\n\n    def getClientSendStatus(self):\n        return self.clientSendStatus\n\n    def setClientSendStatus(self, clientSendStatus):\n        self.clientSendStatus = bool(clientSendStatus)\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/request/GetGridRequest.py,0,"b'from dynamicserialize.dstypes.com.raytheon.uf.common.dataplugin.gfe.db.objects import GFERecord\n\n\nclass GetGridRequest(object):\n\n    def __init__(self, parmId=None, trs=[]):\n        self.convertUnit = False\n        self.records = []\n        self.parmId = parmId\n        if self.parmId is not None:\n            for tr in trs:\n                self.records.append(GFERecord(parmId, tr))\n\n    def getRecords(self):\n        return self.records\n\n    def setRecords(self, records):\n        self.records = records\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getConvertUnit(self):\n        return self.convertUnit\n\n    def setConvertUnit(self, convertUnit):\n        self.convertUnit = convertUnit\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/request/LockRequest.py,0,"b'\n\nclass LockRequest(object):\n\n    def __init__(self):\n        self.timeRange = None\n        self.parmId = None\n        self.dbId = None\n        self.mode = None\n\n    def getTimeRange(self):\n        return self.timeRange\n\n    def setTimeRange(self, timeRange):\n        self.timeRange = timeRange\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getDbId(self):\n        return self.dbId\n\n    def setDbId(self, dbId):\n        self.dbId = dbId\n\n    def getMode(self):\n        return self.mode\n\n    def setMode(self, mode):\n        self.mode = mode\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/request/LockTableRequest.py,0,"b'\n\nclass LockTableRequest(object):\n\n    def __init__(self):\n        self.parmId = None\n        self.dbId = None\n\n    def getParmId(self):\n        return self.parmId\n\n    def setParmId(self, parmId):\n        self.parmId = parmId\n\n    def getDbId(self):\n        return self.dbId\n\n    def setDbId(self, dbId):\n        self.dbId = dbId\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/gfe/server/request/__init__.py,0,"b""\n__all__ = [\n            'CommitGridRequest',\n            'GetGridRequest',\n            'LockRequest',\n            'LockTableRequest'\n          ]\n\nfrom .CommitGridRequest import CommitGridRequest\nfrom .GetGridRequest import GetGridRequest\nfrom .LockRequest import LockRequest\nfrom .LockTableRequest import LockTableRequest\n"""
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/subscription/request/SubscriptionRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 05, 2014                  bclement       Generated\n\n\nclass SubscriptionRequest(object):\n\n    def __init__(self):\n        self.message = None\n\n    def getMessage(self):\n        return self.message\n\n    def setMessage(self, message):\n        self.message = message\n'"
dynamicserialize/dstypes/com/raytheon/uf/common/dataplugin/text/subscription/request/__init__.py,0,"b""\n__all__ = [\n            'SubscriptionRequest'\n          ]\n\nfrom .SubscriptionRequest import SubscriptionRequest\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/atcf/request/RetrieveAtcfDeckRequest.py,0,"b'\n\nclass RetrieveAtcfDeckRequest(object):\n\n    def __init__(self):\n        self.deckID = None\n\n    def getDeckID(self):\n        return self.deckID\n\n    def setDeckID(self, deckID):\n        self.deckID = deckID\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/atcf/request/__init__.py,0,"b""\n__all__ = [\n            'RetrieveAtcfDeckRequest'\n          ]\n\nfrom .RetrieveAtcfDeckRequest import RetrieveAtcfDeckRequest\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetGridDataRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetGridDataRequest(object):\n\n    def __init__(self):\n        self.vcoord = None\n        self.level2 = None\n        self.modelId = None\n        self.parm = None\n        self.level1 = None\n        self.reftime = None\n        self.pluginName = None\n        self.fcstsec = None\n\n    def getVcoord(self):\n        return self.vcoord\n\n    def setVcoord(self, vcoord):\n        self.vcoord = vcoord\n\n    def getLevel2(self):\n        return self.level2\n\n    def setLevel2(self, level2):\n        self.level2 = level2\n\n    def getModelId(self):\n        return self.modelId\n\n    def setModelId(self, modelId):\n        self.modelId = modelId\n\n    def getParm(self):\n        return self.parm\n\n    def setParm(self, parm):\n        self.parm = parm\n\n    def getLevel1(self):\n        return self.level1\n\n    def setLevel1(self, level1):\n        self.level1 = level1\n\n    def getReftime(self):\n        return self.reftime\n\n    def setReftime(self, reftime):\n        self.reftime = reftime\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getFcstsec(self):\n        return self.fcstsec\n\n    def setFcstsec(self, fcstsec):\n        self.fcstsec = fcstsec\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetGridInfoRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetGridInfoRequest(object):\n\n    def __init__(self):\n        self.modelId = None\n        self.reftime = None\n        self.pluginName = None\n        self.fcstsec = None\n\n    def getModelId(self):\n        return self.modelId\n\n    def setModelId(self, modelId):\n        self.modelId = modelId\n\n    def getReftime(self):\n        return self.reftime\n\n    def setReftime(self, reftime):\n        self.reftime = reftime\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getFcstsec(self):\n        return self.fcstsec\n\n    def setFcstsec(self, fcstsec):\n        self.fcstsec = fcstsec\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetGridNavRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetGridNavRequest(object):\n\n    def __init__(self):\n        self.modelId = None\n        self.pluginName = None\n\n    def getModelId(self):\n        return self.modelId\n\n    def setModelId(self, modelId):\n        self.modelId = modelId\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetStationsRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetStationsRequest(object):\n\n    def __init__(self):\n        self.pluginName = None\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetTimesRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetTimesRequest(object):\n\n    def __init__(self):\n        self.pluginName = None\n        self.timeField = None\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getTimeField(self):\n        return self.timeField\n\n    def setTimeField(self, timeField):\n        self.timeField = timeField\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/GetTimesResponse.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass GetTimesResponse(object):\n\n    def __init__(self):\n        self.times = None\n\n    def getTimes(self):\n        return self.times\n\n    def setTimes(self, times):\n        self.times = times\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/Station.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\nimport numpy\n\n\nclass Station(object):\n\n    def __init__(self):\n        self.elevation = None\n        self.state = None\n        self.stationId = None\n        self.longitude = None\n        self.latitude = None\n        self.wmoIndex = None\n        self.country = None\n\n    def getElevation(self):\n        return self.elevation\n\n    def setElevation(self, elevation):\n        self.elevation = elevation\n\n    def getState(self):\n        return self.state\n\n    def setState(self, state):\n        self.state = state\n\n    def getStationId(self):\n        return self.stationId\n\n    def setStationId(self, stationId):\n        self.stationId = stationId\n\n    def getLongitude(self):\n        return self.longitude\n\n    def setLongitude(self, longitude):\n        self.longitude = numpy.float64(longitude)\n\n    def getLatitude(self):\n        return self.latitude\n\n    def setLatitude(self, latitude):\n        self.latitude = numpy.float64(latitude)\n\n    def getWmoIndex(self):\n        return self.wmoIndex\n\n    def setWmoIndex(self, wmoIndex):\n        self.wmoIndex = wmoIndex\n\n    def getCountry(self):\n        return self.country\n\n    def setCountry(self, country):\n        self.country = country\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/StationDataRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass StationDataRequest(object):\n\n    def __init__(self):\n        self.refTime = None\n        self.pluginName = None\n        self.parmList = None\n        self.stationId = None\n        self.partNumber = None\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getParmList(self):\n        return self.parmList\n\n    def setParmList(self, parmList):\n        self.parmList = parmList\n\n    def getStationId(self):\n        return self.stationId\n\n    def setStationId(self, stationId):\n        self.stationId = stationId\n\n    def getPartNumber(self):\n        return self.partNumber\n\n    def setPartNumber(self, partNumber):\n        self.partNumber = partNumber\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/SurfaceDataRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass SurfaceDataRequest(object):\n\n    def __init__(self):\n        self.refTime = None\n        self.pluginName = None\n        self.parmList = None\n        self.stationId = None\n        self.partNumber = None\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getParmList(self):\n        return self.parmList\n\n    def setParmList(self, parmList):\n        self.parmList = parmList\n\n    def getStationId(self):\n        return self.stationId\n\n    def setStationId(self, stationId):\n        self.stationId = stationId\n\n    def getPartNumber(self):\n        return self.partNumber\n\n    def setPartNumber(self, partNumber):\n        self.partNumber = partNumber\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/UpperAirDataRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     Sep 16, 2016                  pmoyer         Generated\n\n\nclass UpperAirDataRequest(object):\n\n    def __init__(self):\n        self.refTime = None\n        self.pluginName = None\n        self.parmList = None\n        self.stationId = None\n        self.partNumber = None\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getPluginName(self):\n        return self.pluginName\n\n    def setPluginName(self, pluginName):\n        self.pluginName = pluginName\n\n    def getParmList(self):\n        return self.parmList\n\n    def setParmList(self, parmList):\n        self.parmList = parmList\n\n    def getStationId(self):\n        return self.stationId\n\n    def setStationId(self, stationId):\n        self.stationId = stationId\n\n    def getPartNumber(self):\n        return self.partNumber\n\n    def setPartNumber(self, partNumber):\n        self.partNumber = partNumber\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gempak/request/__init__.py,0,"b""\n__all__ = [\n            'GetGridDataRequest',\n            'GetGridInfoRequest',\n            'GetGridNavRequest',\n            'GetStationsRequest',\n            'GetTimesRequest',\n            'GetTimesResponse',\n            'Station',\n            'StationDataRequest',\n            'SurfaceDataRequest',\n            'UpperAirDataRequest'\n          ]\n\nfrom .GetGridDataRequest import GetGridDataRequest\nfrom .GetGridInfoRequest import GetGridInfoRequest\nfrom .GetGridNavRequest import GetGridNavRequest\nfrom .GetStationsRequest import GetStationsRequest\nfrom .GetTimesRequest import GetTimesRequest\nfrom .GetTimesResponse import GetTimesResponse\nfrom .Station import Station\nfrom .StationDataRequest import StationDataRequest\nfrom .SurfaceDataRequest import SurfaceDataRequest\nfrom .UpperAirDataRequest import UpperAirDataRequest\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gpd/query/GenericPointDataReqMsg.py,0,"b'\n\nclass GenericPointDataReqMsg(object):\n\n    def __init__(self):\n        self.reqType = None\n        self.refTime = None\n        self.productName = None\n        self.stnId = None\n        self.slat = None\n        self.slon = None\n        self.productVersion = None\n        self.querySpecifiedProductVersion = False\n        self.queryKey = None\n        self.gpdDataString = None\n        self.maxNumLevel = 1\n\n    def getReqType(self):\n        return self.reqType\n\n    def setReqType(self, reqType):\n        self.reqType = reqType\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getProductName(self):\n        return self.productName\n\n    def setProductName(self, productName):\n        self.productName = productName\n\n    def getStnId(self):\n        return self.stnId\n\n    def setStnId(self, stnId):\n        self.stnId = stnId\n\n    def getSlat(self):\n        return self.slat\n\n    def setSlat(self, slat):\n        self.slat = slat\n\n    def getSlon(self):\n        return self.slon\n\n    def setSlon(self, slon):\n        self.slon = slon\n\n    def getMaxNumLevel(self):\n        return self.maxNumLevel\n\n    def setMaxNumLevel(self, maxNumLevel):\n        self.maxNumLevel = maxNumLevel\n\n    def getProductVersion(self):\n        return self.productVersion\n\n    def setProductVersion(self, productVersion):\n        self.productVersion = productVersion\n\n    def getQuerySpecifiedProductVersion(self):\n        return self.querySpecifiedProductVersion\n\n    def setQuerySpecifiedProductVersion(self, querySpecifiedProductVersion):\n        self.querySpecifiedProductVersion = querySpecifiedProductVersion\n\n    def getQueryKey(self):\n        return self.queryKey\n\n    def setQueryKey(self, queryKey):\n        self.queryKey = queryKey\n\n    def getGpdDataString(self):\n        return self.gpdDataString\n\n    def setGpdDataString(self, gpdDataString):\n        self.gpdDataString = gpdDataString\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/gpd/query/__init__.py,0,"b""\n__all__ = [\n            'GenericPointDataReqMsg'\n          ]\n\nfrom .GenericPointDataReqMsg import GenericPointDataReqMsg\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/request/RetrieveActivityMapRequest.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     May 05, 2016                  root           Generated\n\n\nclass RetrieveActivityMapRequest(object):\n\n    def __init__(self):\n        return\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/request/RetrieveAllProductsRequest.py,0,"b'\n\nclass RetrieveAllProductsRequest(object):\n\n    def __init__(self):\n        self.dataURI = None\n\n    def getDataURI(self):\n        return self.dataURI\n\n    def setDataURI(self, dataURI):\n        self.dataURI = dataURI\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/request/StoreActivityRequest.py,0,"b'\n\nclass StoreActivityRequest(object):\n\n    def __init__(self):\n        self.activityInfo = None\n        self.activityXML = None\n\n    def getActivityInfo(self):\n        return self.activityInfo\n\n    def setActivityInfo(self, activityInfo):\n        self.activityInfo = activityInfo\n\n    def getActivityXML(self):\n        return self.activityXML\n\n    def setActivityXML(self, activityXML):\n        self.activityXML = activityXML\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/request/StoreDerivedProductRequest.py,0,"b'\n\nclass StoreDerivedProductRequest(object):\n\n    def __init__(self):\n        self.dataURI = None\n        self.productList = None\n\n    def getDataURI(self):\n        return self.dataURI\n\n    def setDataURI(self, dataURI):\n        self.dataURI = dataURI\n\n    def getProductList(self):\n        return self.productList\n\n    def setProductList(self, productList):\n        self.productList = productList\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/request/__init__.py,0,"b""\n__all__ = [\n            'RetrieveActivityMapRequest',\n            'RetrieveAllProductsRequest',\n            'StoreActivityRequest',\n            'StoreDerivedProductRequest'\n          ]\n\nfrom .RetrieveAllProductsRequest import RetrieveAllProductsRequest\nfrom .StoreActivityRequest import StoreActivityRequest\nfrom .StoreDerivedProductRequest import StoreDerivedProductRequest\nfrom .RetrieveActivityMapRequest import RetrieveActivityMapRequest\n"""
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/response/ActivityMapData.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     May 06, 2016                  root           Generated\n\n\nclass ActivityMapData(object):\n\n    def __init__(self):\n        self.refTime = None\n        self.activityLabel = None\n        self.activitySubtype = None\n        self.dataURI = None\n        self.activityType = None\n        self.activityName = None\n\n    def getRefTime(self):\n        return self.refTime\n\n    def setRefTime(self, refTime):\n        self.refTime = refTime\n\n    def getActivityLabel(self):\n        return self.activityLabel\n\n    def setActivityLabel(self, activityLabel):\n        self.activityLabel = activityLabel\n\n    def getActivitySubtype(self):\n        return self.activitySubtype\n\n    def setActivitySubtype(self, activitySubtype):\n        self.activitySubtype = activitySubtype\n\n    def getDataURI(self):\n        return self.dataURI\n\n    def setDataURI(self, dataURI):\n        self.dataURI = dataURI\n\n    def getActivityType(self):\n        return self.activityType\n\n    def setActivityType(self, activityType):\n        self.activityType = activityType\n\n    def getActivityName(self):\n        return self.activityName\n\n    def setActivityName(self, activityName):\n        self.activityName = activityName\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/response/RetrieveActivityMapResponse.py,0,"b'#\n#      SOFTWARE HISTORY\n#\n#     Date            Ticket#       Engineer       Description\n#     ------------    ----------    -----------    --------------------------\n#     May 06, 2016                  root           Generated\n\n\nclass RetrieveActivityMapResponse(object):\n\n    def __init__(self):\n        self.data = None\n\n    def getData(self):\n        return self.data\n\n    def setData(self, data):\n        self.data = data\n'"
dynamicserialize/dstypes/gov/noaa/nws/ncep/common/dataplugin/pgen/response/__init__.py,0,"b""\n__all__ = [\n            'ActivityMapData',\n            'RetrieveActivityMapResponse'\n          ]\n\nfrom .ActivityMapData import ActivityMapData\nfrom .RetrieveActivityMapResponse import RetrieveActivityMapResponse\n"""
