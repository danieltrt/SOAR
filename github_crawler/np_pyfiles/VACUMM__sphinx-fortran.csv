file_path,api_count,code
setup.py,0,"b'# -*- coding: utf-8 -*-\n# Inits\nfrom setuptools import setup, find_packages\nimport sys\nimport os\n\n# Version, etc\nsys.path.insert(0, \'sphinxfortran\')\nfrom  sphinxfortran import ( __version__ as version, __author__ as author,\n    __email__ as author_email, __date__ as date)\ndel sys.path[0]\n\n# From files\nbase = os.path.dirname(__file__)\nwith open(os.path.join(base, \'README.rst\')) as f:\n    long_description = f.read()\nwith open(os.path.join(base, \'requirements.txt\')) as f:\n    requires = filter(None, f.read().split(\'\\n\'))\n\n\n# Other infos\ndescription = \'Fortran domain and autodoc extensions to Sphinx\'\nmaintainer = author\nmaintainer_email = author_email\nlicense = ""CeCiLL-A""\nurl = ""http://sphinx-fortran.readthedocs.org""\nclassifiers = [\n        (""License :: OSI Approved :: CEA CNRS Inria Logiciel ""\n         ""Libre License, version 2.1 (CeCILL-2.1)""),\n        ""Topic :: Scientific/Engineering"",\n        ""Programming Language :: Python :: 2.7"",\n        ""Programming Language :: Python :: 3.4"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        ]\n\nif __name__ == \'__main__\':\n\n    # Lauch setup\n    setup(name=\'sphinx-fortran\',\n        version=version,\n        date=date,\n        description=description,\n        long_description=long_description,\n        author=author,\n        author_email=author_email,\n        maintainer=author,\n        maintainer_email=author_email,\n        license=license,\n        url=url,\n        classifiers=classifiers,\n        packages=find_packages(),\n        install_requires=requires,\n    )\n\n\n\n'"
sphinxfortran/__init__.py,0,"b'# -*- coding: utf8 -*-\n""""""Fortran domain and autodoc extensions to Sphinx\n\n\n""""""\n# Copyright or \xc2\xa9 or Copr. Actimar/IFREMER (2010-2019)\n#\n# This software is a computer program whose purpose is to provide\n# utilities for handling oceanographic and atmospheric data,\n# with the ultimate goal of validating the MARS model from IFREMER.\n#\n# This software is governed by the CeCILL license under French law and\n# abiding by the rules of distribution of free software.  You can  use,\n# modify and/ or redistribute the software under the terms of the CeCILL\n# license as circulated by CEA, CNRS and INRIA at the following URL\n# ""http://www.cecill.info"".\n#\n# As a counterpart to the access to the source code and  rights to copy,\n# modify and redistribute granted by the license, users are provided only\n# with a limited warranty  and the software\'s author,  the holder of the\n# economic rights,  and the successive licensors  have only  limited\n# liability.\n#\n# In this respect, the user\'s attention is drawn to the risks associated\n# with loading,  using,  modifying and/or developing or reproducing the\n# software by the user in light of its specific status of free software,\n# that may mean  that it is complicated to manipulate,  and  that  also\n# therefore means  that it is reserved for developers  and  experienced\n# professionals having in-depth computer knowledge. Users are therefore\n# encouraged to load and test the software\'s suitability as regards their\n# requirements in conditions enabling the security of their systems and/or\n# data to be ensured and,  more generally, to use and operate it in the\n# same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n#\n\n__version__ = \'1.1.1\'\n__date__ = ""2019-11-20""\n__author__ = \'Stephane Raynaud\'\n__email__ = \'stephane.raynaud@gmail.com\'\n__copyright__ = \'Copyright (c) 2010-2019 Actimar/IFREMER\'\n'"
sphinxfortran/fortran_autodoc.py,0,"b'# -*- coding: utf-8 -*-\n""""""Sphinx extension for autodocumenting fortran codes.\n\n\n""""""\n# Copyright or \xc2\xa9 or Copr. Actimar/IFREMER (2010-2019)\n#\n# This software is a computer program whose purpose is to provide\n# utilities for handling oceanographic and atmospheric data,\n# with the ultimate goal of validating the MARS model from IFREMER.\n#\n# This software is governed by the CeCILL license under French law and\n# abiding by the rules of distribution of free software.  You can  use,\n# modify and/ or redistribute the software under the terms of the CeCILL\n# license as circulated by CEA, CNRS and INRIA at the following URL\n# ""http://www.cecill.info"".\n#\n# As a counterpart to the access to the source code and  rights to copy,\n# modify and redistribute granted by the license, users are provided only\n# with a limited warranty  and the software\'s author,  the holder of the\n# economic rights,  and the successive licensors  have only  limited\n# liability.\n#\n# In this respect, the user\'s attention is drawn to the risks associated\n# with loading,  using,  modifying and/or developing or reproducing the\n# software by the user in light of its specific status of free software,\n# that may mean  that it is complicated to manipulate,  and  that  also\n# therefore means  that it is reserved for developers  and  experienced\n# professionals having in-depth computer knowledge. Users are therefore\n# encouraged to load and test the software\'s suitability as regards their\n# requirements in conditions enabling the security of their systems and/or\n# data to be ensured and,  more generally, to use and operate it in the\n# same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n#\nfrom __future__ import print_function\nfrom builtins import str\nfrom builtins import range\nfrom builtins import object\nimport six\nimport re\nimport os\nfrom collections import OrderedDict\nfrom operator import itemgetter\n\nfrom docutils.parsers.rst import Directive\nfrom docutils.parsers.rst.directives import unchanged\nfrom docutils.statemachine import string2lines\nfrom sphinx.util.console import bold\nfrom glob import glob\nfrom numpy.f2py.crackfortran import crackfortran, fortrantypes\nfrom sphinx.util import logging\n\nfrom sphinxfortran.fortran_domain import FortranDomain\n\n\nlogger = logging.getLogger(__name__)\n\n\n# Fortran parser and formatter\n# ----------------------------\n\nclass F90toRstException(Exception):\n    pass\n\n\nclass F90toRst(object):\n    \'\'\'Fortran 90 parser and restructeredtext formatter\n\n    :Parameters:\n\n         - **ffiles**: Fortran files (glob expression allowed) or dir (or list of)\n\n    :Options:\n\n        - **ic**: Indentation char.\n        - **ulc**: Underline char for titles.\n        - **sst**: Subsection type.\n        - **vl**: Verbose level (0=quiet).\n    \'\'\'\n    _re_unended_match = re.compile(r\'(.*)&\\s*\', re.I).match\n    _re_unstarted_match = re.compile(r\'\\s*&(.*)\', re.I).match\n    _re_comment_match = re.compile(r\'\\s*!(.*)\', re.I).match\n    _re_space_prefix_match = re.compile(r\'^(\\s*).*$\', re.I).match\n#    _re_sub_numvardesc_match = re.compile(r\'\\$(\\d+)\',re.I).match\n#    _re_vardesc_match = re.compile(r\'\\s*(?P<varname>\\w+)[\\s,&]*!\\s*(?P<vardesc>.+)\',re.I).match\n#    _re_type_var_findall = re.compile(r\'(\\w+)\',re.I).match\n    _fmt_vardesc = \':%(role)s %(vtype)s %(vname)s%(vdim)s%(vattr)s: %(vdesc)s\'\n    #_fmt_vardesc = \'**%(vname)s** %(vdim)s :: %(vtype)s %(vattr)s: %(vdesc)s\'\n    _fmt_vattr = "" [%(vattr)s]""\n    _fmt_fvardesc = \'%(vtype)s%(vdim)s %(vattr)s%(vdesc)s\'\n    #_fmt_fvardim = \', **dim%(vdim)s**\'\n#    _re_call_subr_search = re.compile(r\'\\bcall\\s+(\\w+)\\(\',re.I).search\n#    _re_call_func_findall = re.compile(r\'\\b(\\w+)\\(\',re.I).search\n\n    def __init__(\n            self,\n            ffiles,\n            ic=\'\\t\',\n            ulc=\'-\',\n            vl=0,\n            encoding=\'utf8\',\n            sst=\'rubric\'):\n        # Be sure to have a list\n        if not isinstance(ffiles, list):\n            ffiles = [ffiles]\n\n        # Read and store them\n        self.src = OrderedDict()\n        self.ffiles = ffiles\n        for ff in ffiles:\n            f = open(ff)\n            self.src[ff] = []\n            for l in f.readlines():\n                try:\n                    self.src[ff].append(l[:-1].decode(encoding))\n                except AttributeError:\n                    self.src[ff].append(l[:-1])\n                except BaseException:\n                    raise F90toRstException(\n                        \'Encoding error\\n  file = %s\\n  line = %s\' %\n                        (ff, l))\n            #self.src[ff] = [l.decode(encoding) for l in f.readlines()]\n            #self.src[ff] = [l.decode(encoding) for l in f.read().split(\'\\n\')]\n\n            f.close()\n\n        # Crack files\n        global verbose, quiet\n        import numpy.f2py.crackfortran\n        self._verbose = numpy.f2py.crackfortran.verbose = verbose = vl\n        numpy.f2py.crackfortran.quiet = quiet = 1 - verbose\n        self.crack = []\n        for ff in ffiles:\n            self.crack.extend(crackfortran(ff))\n\n        # Build index\n        self.build_index()\n\n        # Scan all files to get description, etc\n        self.scan()\n\n        # Add function \'call from\' to index\n        self.build_callfrom_index()\n\n        # Other inits\n        self.rst = OrderedDict()\n        self._ic = ic\n        self._ulc = ulc\n        self._sst = sst\n\n    # Indexing ---\n\n    def build_index(self):\n        """"""Register modules, functions, types and module variables for quick access\n\n        Index constituents are:\n\n            .. attribute:: modules\n\n                Dictionary where each key is a module name, and each value is the cracked block.\n\n            .. attribute:: routines\n\n                Module specific functions and subroutines\n\n            .. attribute:: types\n\n                Module specific types\n\n            .. attribute:: variables\n\n                Module specific variables\n        """"""\n        # Containers\n        self.modules = OrderedDict()\n        self.types = OrderedDict()\n        self.routines = self.functions = self.subroutines = OrderedDict()\n        self.variables = OrderedDict()\n        self.programs = OrderedDict()\n\n        # Loop on all blocks and subblocks\n        for block in self.crack:\n\n            # Modules\n            if block[\'block\'] == \'module\':\n\n                # Index module\n                module = block[\'name\']\n                self.modules[module] = block\n\n                # Loop inside module\n                for subblock in block[\'body\']:\n\n                    # Types and routines as subblock\n                    if subblock[\'block\'] in [\'function\', \'type\', \'subroutine\']:\n\n                        # Index\n                        container = getattr(self, subblock[\'block\'] + \'s\')\n                        container[subblock[\'name\']] = subblock\n                        subblock[\'module\'] = module\n\n                        # Variables\n                        varnames = subblock[\'sortvars\']\n                        if subblock[\'block\'] == \'type\':\n                            varnames.sort()\n                        for varname in varnames:\n                            subblock[\'vars\'][varname][\'name\'] = varname\n\n                # Function aliases from ""use only"" (rescan)\n                for bfunc in list(self.routines.values()):\n                    bfunc[\'aliases\'] = []\n                for subblock in block[\'body\']:\n                    if not subblock[\'block\'] == \'use\':\n                        continue\n                    for monly in list(block[\'use\'].values()):\n                        if not monly:\n                            continue\n                        for fname, falias in list(monly[\'map\'].items()):\n                            self.routines[falias] = self.routines[fname]\n                            if falias not in self.routines[fname][\'aliases\']:\n                                self.routines[fname][\'aliases\'].append(falias)\n\n                # Module variables\n                for varname in sorted(block[\'sortvars\']):\n                    bvar = block[\'vars\'][varname]\n                    if varname not in self.routines and varname not in self.types:\n                        self.variables[varname] = bvar\n                        # self.variables.pop(varname)\n                        bvar[\'name\'] = varname\n                        bvar[\'module\'] = module\n\n            # Local functions, subroutines and programs\n            elif block[\'block\'] in [\'function\', \'subroutine\', \'program\']:\n\n                # Index\n                container = getattr(self, block[\'block\'] + \'s\')\n                container[block[\'name\']] = block\n\n                # Variables\n                for varname in block[\'sortvars\']:\n                    block[\'vars\'][varname][\'name\'] = varname\n\n        # Regular expression for fast search\n        # - function calls\n        subs = [block[\'name\'].lower() for block in list(\n            self.routines.values()) if block[\'block\'] == \'subroutine\']\n        self._re_callsub_findall = subs and re.compile(\n            r\'call\\s+\\b(%s)\\b\' %\n            (\'|\'.join(subs)),\n            re.I).findall or (\n            lambda line: [])\n        funcs = [block[\'name\'].lower() for block in list(\n            self.routines.values()) if block[\'block\'] == \'function\']\n        self._re_callfunc_findall = funcs and re.compile(\n            r\'\\b(%s)\\b\\s*\\(\' %\n            (\'|\'.join(funcs)),\n            re.I).findall or (\n            lambda line: [])\n        # - function variables\n        for block in list(self.routines.values())+list(self.types.values()):\n            vars = (r\'|\').join(block[\'sortvars\']) + r\'|\\$(?P<varnum>\\d+)\'\n            sreg = r\'[\\s\\*\\-:]*(?:@param\\w*)?\\b(?P<varname>%s)\\b\\W+(?P<vardesc>.*)\' % vars\n            block[\'vardescmatch\'] = re.compile(sreg).match\n        # - variables with description\n#        for block in self.types.values()+self.modules.values():\n        for block in list(self.types.values()) + \\\n                list(self.modules.values()) + list(self.routines.values()):\n            #sreg = r\'\\b(?P<varname>%s)\\b[\\W\\d]*!\\s*(?P<vardesc>.*)\'%\'|\'.join(block[\'sortvars\'])\n            #sreg = r\'[\\W\\(\\),\\b\\*=\\-\\&]*?:?:[ \\t\\&]*(?P<varname>%s)\\b[\\w\\s\\(\\)\\*,_=]*!\\s*(?P<vardesc>.*)\'%\'|\'.join(block[\'sortvars\'])\n            #sreg = r\'.*[\\W\\(\\),\\b\\*=\\-\\&]*?:?:[ \\t\\&]*(?P<varname>%s)\\b[\\w\\s\\(\\)\\*,_=\\.]*!\\s*(?P<vardesc>.*)\'%\'|\'.join(block[\'sortvars\'])\n            # reversed+sorted is a hack to avoid conflicts when variables share\n            # the same prefix\n            if block[\'sortvars\']:\n                sreg = r\'.*\\b(?P<varname>%s)\\b\\s*(?P<dims>\\([\\*:,\\w]+\\))?[^!\\)]*!\\s*(?P<vardesc>.*)\\s*\' % \'|\'.join(\n                    reversed(sorted(block[\'sortvars\'])))\n                block[\'vardescsearch\'] = re.compile(sreg, re.I).search\n            else:\n                block[\'vardescsearch\'] = lambda x: None\n\n    def build_callfrom_index(self):\n        """"""For each function, index which function call it""""""\n        for bfunc in list(self.routines.values()):\n            bfunc[\'callfrom\'] = []\n            for bfuncall in list(self.routines.values()) + \\\n                    list(self.programs.values()):\n                if bfunc[\'name\'] in bfuncall[\'callto\']:\n                    bfunc[\'callfrom\'].append(bfuncall[\'name\'])\n\n    def filter_by_srcfile(self, sfile, mode=None, objtype=None, **kwargs):\n        """"""Search for subblocks according to origin file\n\n        :Params:\n            - **sfile**: Source file name.\n            - **mode**, optional: Mode for searching for sfile.\n              If ``""strict""``, exact match is needed, else only basename.\n            - **objtype**, optional: Restrict search to one or a list of object types\n              (i.e. ``""function""``, ``""program""``, etc).\n        """"""\n        if mode is None:\n            mode = \'basename\'\n        if objtype and not isinstance(objtype, list):\n            objtype = [objtype]\n        bb = []\n        if mode != \'strict\':\n            sfile = os.path.basename(sfile)\n        for b in self.crack:\n            if objtype and objtype != \'all\' and b[\'block\'] not in objtype:\n                continue\n            bfile = b[\'from\'].split(\':\')[0]  # remove module name\n            if mode != \'strict\':\n                bfile = os.path.basename(bfile)\n            if sfile == bfile:\n                bb.append(b)\n\n        return bb\n\n    def scan(self):\n        """"""Scan """"""\n        # Loop on all blocks\n        for block in self.crack:\n\n            # Modules\n            if block[\'block\'] == \'module\':\n\n                # Get source lines\n                modsrc = self.get_blocksrc(block)\n\n                # Get module description\n                block[\'desc\'] = self.get_comment(modsrc, aslist=True)\n\n                # Scan types and routines\n                for subblock in block[\'body\']:\n\n                    self.scan_container(subblock, insrc=modsrc)\n\n                # Scan module variables\n                self.strip_blocksrc(\n                    block, [\n                        \'type\', \'function\', \'subroutine\'], src=modsrc)\n                if modsrc:\n                    for line in modsrc:\n                        if line.strip().startswith(\'!\'):\n                            continue\n                        m = block[\'vardescsearch\'](line)\n                        if m:\n                            block[\'vars\'][m.group(\'varname\').lower()][\'desc\'] = m.group(\n                                \'vardesc\')\n                for bvar in list(block[\'vars\'].values()):\n                    bvar.setdefault(\'desc\', \'\')\n\n            # Routines\n            elif block[\'block\'] in [\'function\', \'subroutine\', \'program\']:\n\n                self.scan_container(block)\n\n    def scan_container(self, block, insrc=None):\n        """"""Scan a block of program, routines or type""""""\n\n        # Check block type\n        if block[\'block\'] not in [\'type\', \'function\', \'subroutine\', \'program\']:\n            return\n\n        # Source lines\n        subsrc = self.get_blocksrc(block, insrc)\n\n        # Comment\n        block[\'desc\'] = self.get_comment(subsrc, aslist=True)\n\n        # Scan comments to find descriptions\n        if block[\'desc\'] and block[\'block\'] in [\n                \'function\', \'subroutine\', \'type\']:\n            varname = None\n            for iline, line in enumerate(block[\'desc\']):\n                if \'vardescmatch\' in block:\n                    m = block[\'vardescmatch\'](line)\n                    if m:  # There is a variable and its description\n\n                        # Name of variable\n                        varname = m.group(\'varname\')\n\n                        # Numeric name\n                        if m.group(\'varnum\'):  # $[1-9]+\n                            ivar = int(m.group(\'varnum\'))\n                            ivar = ivar - 1\n                            if ivar < 0 or ivar >= len(block[\'args\']):\n                                continue\n                            block[\'desc\'][iline] = line.replace(\n                                varname, block[\'args\'][ivar])\n                            varname = block[\'args\'][ivar]\n\n                        # Store description\n                        ifirst = len(line) - len(line.strip())\n                        if varname != \'\':\n                            block[\'vars\'][varname][\'desc\'] = m.group(\n                                \'vardesc\')\n\n                elif line.strip() and varname is not None and \\\n                        (len(line) - len(line.strip())) > ifirst:\n                    # Description continuation?\n\n                    block[\'vars\'][varname][\'desc\'].append(\n                        \' \' + line.strip())\n\n                else:\n                    varname = None\n\n        # Callable objects\n        if block[\'block\'] in [\'function\', \'subroutine\', \'program\']:\n\n            # Index calls\n            block[\'callto\'] = []\n            if subsrc is not None:\n                self.join_src(subsrc)\n                for line in subsrc[1:-1]:\n                    if line.strip().startswith(\'!\'):\n                        continue\n                    line = line.lower()\n                    for fn in self._re_callsub_findall(\n                            line) + self._re_callfunc_findall(line):\n                        if fn not in block[\'callto\']:\n                            block[\'callto\'].append(fn)\n                            pass\n\n        # Get description of variables from inline comment that overwrites\n        # description inferred from header comment\n        if block[\'block\'] in [\n            \'function\',\n            \'subroutine\',\n                \'type\'] and subsrc is not None:\n            for line in subsrc:\n                if line.strip().startswith(\'!\'):\n                    continue\n                if \'vardescsearch\' in block:\n                    m = block[\'vardescsearch\'](line)\n                    if m:\n                        block[\'vars\'][m.group(\'varname\').lower()][\'desc\'] = m.group(\n                            \'vardesc\')\n\n        # Fill empty descriptions\n        for bvar in list(block[\'vars\'].values()):\n            bvar.setdefault(\'desc\', \'\')\n\n        del subsrc\n\n    # Getting info ---\n\n    def get_module(self, block):\n        """"""Get the name of the current module""""""\n        while block[\'block\'] != \'module\':\n            if block[\'parentblock\'] == \'unknown\':\n                break\n            block = block[\'parentblock\']\n        return block[\'name\']\n\n    def get_src(self, block):\n        """"""Get the source lines of the file including this block""""""\n        srcfile = block[\'from\'].split(\':\')[0]\n        return self.src[srcfile]\n\n    def join_src(self, src):\n        """"""Join unended lines that does not finish with a comment""""""\n        for iline, line in enumerate(src):\n            m = self._re_unended_match(line)\n            if m:\n                thisline = m.group(1)\n                m = self._re_unstarted_match(src[iline + 1])\n                nextline = m.group(1) if m else src[iline + 1]\n                src[iline] = thisline + nextline\n                del src[iline + 1]\n        return src\n\n    def get_blocksrc(\n            self,\n            block,\n            src=None,\n            istart=0,\n            getidx=False,\n            stopmatch=None,\n            exclude=None):\n        """"""Extract an identified block of source code\n\n        :Parameters:\n\n            - *block*: Cracked block\n\n        :Options:\n\n            - *src*: List of source line including the block\n            - *istart*: Start searching from this line number\n\n        :Return:\n\n            ``None`` or a list of lines\n        """"""\n        # Set up\n        if src is None:\n            src = self.get_src(block)\n        blocktype = block[\'block\'].lower()\n        blockname = block[\'name\'].lower()\n        ftypes = r\'(?:(?:%s).*\\s+)?\' % fortrantypes if blocktype == \'function\' else \'\'\n        rstart = re.compile(\n            r""^\\s*%s%s\\s+%s\\b.*$"" %\n            (ftypes, blocktype, blockname), re.I).match\n        rend = re.compile(r""^\\s*end\\s+%s\\b.*$"" % blocktype, re.I).match\n        if isinstance(stopmatch, str):\n            stopmatch = re.compile(stopmatch).match\n\n        # Beginning\n        for ifirst in range(istart, len(src)):\n            # Simple stop on match\n            if stopmatch and stopmatch(src[ifirst]):\n                return\n            # Ok, now check\n            if rstart(src[ifirst]):\n                break\n        else:\n            return\n\n        # End\n        for ilast in range(ifirst, len(src)):\n            if stopmatch and stopmatch(src[ilast]):\n                break\n            if rend(src[ilast].lower()):\n                break\n\n        # Extraction\n        mysrc = list(src[ifirst:ilast + 1])\n\n        # Block exclusions\n        self.strip_blocksrc(block, exclude, src=mysrc)\n\n        if getidx:\n            return mysrc, (ifirst, ilast)\n        return mysrc\n\n    def strip_blocksrc(self, block, exc, src=None):\n        """"""Strip blocks from source lines\n\n        :Parameters:\n\n            - *block*:\n            - *exc* list of block type to remove\n\n        :Options:\n\n            - *src*: list of source lines\n\n        :Example:\n\n        >>> obj.strip_blocksrc(lines, \'type\')\n        >>> obj.strip_blocksrc(lines, [\'function\', \'type\']\n        """"""\n        if src is None:\n            self.get_blocksrc(block)\n        if exc is None:\n            return\n        if not isinstance(exc, list):\n            exc = [exc]\n        for subblock in block[\'body\']:\n            if subblock[\'block\'] in exc:\n                subsrc = self.get_blocksrc(subblock, src=src, getidx=True)\n                if subsrc is None:\n                    continue  # Already stripped\n                del src[subsrc[1][0]:subsrc[1][1]]\n                del subsrc\n\n    def get_comment(\n            self,\n            src,\n            iline=1,\n            aslist=False,\n            stripped=False,\n            getilast=False,\n            rightafter=True):\n        """"""Search for and return the comment starting after ``iline`` in ``src``\n\n        :Params:\n\n            - **src**: A list of lines.\n            - **iline**, optional: Index of first line to read.\n            - **aslist**, optional: Return the comment as a list.\n            - **stripped**, optional: Strip each line of comment.\n            - **getilast**, optional: Get also index of last line of comment.\n            - **rightafter**, optional: Suppose the comment right after\n              the signature line. If True, it prevents from reading a comment\n              that is not a description of the routine.\n\n        :Return:\n\n            - ``scomment``: string or list\n            - OR ``scomment,ilast``: if ``getilast is True``\n        """"""\n        scomment = []\n        if src:\n            in_a_breaked_line = src[0].strip().endswith(\'&\')\n            for iline in range(iline, len(src)):\n                line = src[iline].strip()\n\n                # Breaked line\n                if line.startswith(\'&\'):\n                    continue\n\n                # Manage no comment line\n                m = self._re_comment_match(line)\n                if m is None:\n\n                    if not scomment:\n\n                        # Not the end of signature\n                        if line.endswith(\'&\'):\n                            in_a_breaked_line = True\n                            continue\n                        if in_a_breaked_line:\n                            in_a_breaked_line = False\n                            continue\n\n                        # Empty line but we continue searching\n                        if not rightafter and not line:\n                            continue\n\n                    # Stop searching\n                    break\n\n                # Get comment part\n                comment = m.group(1)\n\n                # Strip?\n                if stripped:\n                    comment = comment.strip()\n\n                # Load and remove space prefix\n                if not scomment:\n                    prefix = self._re_space_prefix_match(comment).group(1)\n                if comment.startswith(prefix):\n                    comment = comment[len(prefix):]\n\n                # Save comment\n                scomment.append(comment)\n\n        if not aslist:\n            scomment = self.format_lines(scomment, nlc=\' \')\n        if getilast:\n            return scomment, iline\n        return scomment\n\n    def get_synopsis(self, block, nmax=2):\n        """"""Get the first ``nmax`` non empty lines of the function, type or module comment as 1 line.\n\n        If the header has more than ``nmax`` lines, the first one is taken and appended of \'...\'.\n        If description if empty, it returns an empty string.\n        """"""\n        sd = []\n        for line in block[\'desc\']:\n            line = line.strip()\n            if not line:\n                if not sd:\n                    continue\n                break\n            sd.append(line)\n            if len(sd) > nmax:\n                if sd[-1].endswith(\'.\'):\n                    sd[-1] += \'...\'\n                break\n        if not sd:\n            return \'\'\n        sd = \' \'.join(sd)\n        return sd\n\n    def get_blocklist(self, choice, module, sort=True):\n        """"""Get the list of types, variables or function of a module""""""\n        choice = choice.lower()\n        if not choice.endswith(\'s\'):\n            choice += \'s\'\n        assert choice in [\'types\', \'variables\', \'functions\',\n                          \'subroutines\'], ""Wrong type of declaration""\n        module = module.lower()\n        assert module in self.modules, ""Wrong module name""\n        baselist = list(getattr(self, choice).values())\n        sellist = [v for v in baselist if \'module\' in v and v[\'module\']\n                   == module.lower()]\n        if sort:\n            sellist.sort(key=itemgetter(\'name\'))\n        return sellist\n\n    # Formating ---\n\n    def set_ulc(self, ulc):\n        """"""Set the underline character for title inside module description""""""\n        self._ulc = ulc\n\n    def get_ulc(self):\n        """"""Get the underline character for title inside module description""""""\n        return self._ulc\n    ulc = property(\n        get_ulc,\n        set_ulc,\n        doc=\'Underline character for title inside module description\')\n\n    def set_ic(self, ic):\n        """"""Set the indentation character""""""\n        self._ic = ic\n\n    def get_ic(self):\n        """"""Get the indentation character""""""\n        return self._ic\n    ic = property(get_ic, set_ic, doc=\'Indentation character\')\n\n    def set_sst(self, sst):\n        """"""Set the subsection type""""""\n        self._sst = sst\n\n    def get_sst(self):\n        """"""Get the subsection type""""""\n        return self._sst\n    sst = property(\n        get_sst,\n        set_sst,\n        doc=\'Subsection type (""title"" or ""rubric"")\')\n\n    def indent(self, n):\n        """"""Get a proper indentation""""""\n        return n * self.ic\n\n    def format_lines(\n            self,\n            lines,\n            indent=0,\n            bullet=None,\n            nlc=\'\\n\',\n            strip=False):\n        """"""Convert a list of lines to text""""""\n        if not lines:\n            return \'\'\n\n        # Bullet\n        if bullet is True:\n            bullet = \'-\'\n        bullet = (str(bullet) + \' \') if bullet else \'\'\n\n        # Get current indentation for reduction\n        if isinstance(lines, six.string_types):\n            lines = [lines]\n\n        # Split lines\n        tmp = []\n        for line in lines:\n            if not line:\n                tmp.append(line)\n            else:\n                tmp.extend(line.splitlines())\n        lines = tmp\n        del tmp\n\n        # Expand tabs\n        lines = [line.expandtabs(4) for line in lines]\n\n        # Strip\n        if strip:\n            tmp = []\n            for line in lines:\n                if not tmp and not line:\n                    continue\n                tmp.append(line)\n            lines = tmp\n            del tmp\n        if not lines:\n            return \'\'\n\n        # Column of first non space car\n        goodlines = [(len(line) - len(line.lstrip()))\n                     for line in lines if line.expandtabs().strip()]\n        firstchar = goodlines and min(goodlines) or 0\n        del goodlines\n\n        # Redent\n        mylines = [self.indent(indent) + bullet + line[firstchar:]\n                   for line in lines]\n\n        # Create text block\n        text = nlc.join(mylines) + nlc\n        del mylines\n        return text\n\n    def format_title(self, text, ulc=None, indent=0):\n        """"""Create a simple rst titlec with indentation\n\n        :Parameters:\n\n            - *text*: text of the title\n\n        :Options:\n\n            - *ulc*: underline character (default to attribute :attr:`ucl`)\n\n        :Example:\n\n            >>> print(o.format_title(\'My title\', \'-\'))\n            My title\n            --------\n        """"""\n        if ulc is None:\n            ulc = self.ulc\n        return self.format_lines([text, ulc * len(text)], indent=indent) + \'\\n\'\n\n    def format_rubric(self, text, indent=0):\n        """"""Create a simple rst rubric with indentation\n\n        :Parameters:\n\n            - *text*: text of the rubric\n\n        :Example:\n\n            >>> print(o.format_rubric(\'My title\', \'-\'))\n            .. rubric:: My rubric\n        """"""\n        return self.format_lines(\'.. rubric:: \' + text, indent=indent) + \'\\n\'\n\n    def format_subsection(self, text, indent=indent, **kwargs):\n        """"""Format a subsection for describing list of subroutines, types, etc""""""\n        if self.sst == \'title\':\n            return self.format_title(text, indent=indent, **kwargs)\n        return self.format_rubric(text, indent=indent, **kwargs)\n\n    def format_declaration(\n            self,\n            dectype,\n            name,\n            description=None,\n            indent=0,\n            bullet=None,\n            options=None):\n        """"""Create an simple rst declaration\n\n        :Example:\n\n        >>> print(format_declaration(\'var\', \'myvar\', \'my description\', indent=1, bullet=\'-\'))\n            - .. f:var:: myvar\n\n                my description\n        """"""\n        declaration = self.format_lines(\n            \'.. f:%(dectype)s:: %(name)s\' %\n            locals(), bullet=bullet, indent=indent)\n        if options:\n            declaration += self.format_options(options, indent=indent + 1)\n        declaration += \'\\n\'\n        if description:\n            declaration += self.format_lines(description, indent=indent + 1)\n        return declaration + \'\\n\'\n\n    def format_options(self, options, indent=0):\n        """"""Format directive options""""""\n        options = [\n            \':%s: %s\' %\n            option for option in list(\n                options.items()) if option[1] is not None]\n        return self.format_lines(options, indent=indent)\n\n    def format_funcref(\n            self,\n            fname,\n            current_module=None,\n            aliasof=None,\n            module=None):\n        """"""Format the reference link to a module function\n\n        Formatting may vary depending on if function is local\n        and is an alias.\n\n        :Example:\n\n        >>> print(obj.format_type(\'myfunc\'))\n        :f:func:`~mymodule.myfunc`\n        """"""\n        # Alias?\n        fname = fname.lower()\n        if aliasof is not None:\n            falias = fname\n            fname = aliasof\n        if fname in self.routines and fname in self.routines[fname].get(\'aliases\', [\n        ]):\n            falias = fname\n            fname = self.routines[fname][\'name\']\n        else:\n            falias = None\n\n        # Local reference ?\n        if module is None and fname in self.routines:\n            module = self.routines[fname].get(\'module\')\n        if module is None or (\n                current_module is not None and module == current_module):\n            if falias:\n                return \':f:func:`%(falias)s<%(fname)s>`\' % locals()\n            return \':f:func:`%(fname)s`\' % locals()\n\n        # Remote reference\n        from sphinxfortran.fortran_domain import f_sep\n        if falias:\n            \':f:func:`%(falias)s<~%(module)s%(f_sep)s%(fname)s>`\' % locals()\n        return \':f:func:`~%(module)s%(f_sep)s%(fname)s`\' % locals()\n\n    def format_use(self, block, indent=0, short=False):\n        """"""Format use statement\n\n        :Parameters:\n\n            - *block*: a module block\n        """"""\n        # TODO: format aliases bug\n        use = \'\'\n        if \'use\' in block:\n            if short:\n                use = \':use: \'\n            else:\n                use = self.format_subsection(\'Needed modules\', indent=indent)\n            lines = []\n            for mname, monly in list(block[\'use\'].items()):\n\n                # Reference to the module\n                line = (self.indent(indent) if not short else \'\') + \\\n                    \':f:mod:`%s`\' % mname\n\n                # Reference to the routines\n                if monly:\n                    funcs = []\n                    for fname, falias in list(monly[\'map\'].items()):\n                        func = self.format_funcref(fname, module=mname)\n                        if fname != falias:\n                            falias = self.format_funcref(\n                                falias, module=mname, aliasof=fname)\n                            func = \'%s => %s\' % (falias, func)\n                        funcs.append(func)\n                    line += \' (%s)\' % \', \'.join(funcs)\n\n                # Short description\n                if mname in self.modules and not short:\n                    sdesc = self.get_synopsis(self.modules[mname])\n                    if sdesc:\n                        line += \': \' + sdesc\n\n                # Append\n                lines.append(line)\n            if short:\n                use += \', \'.join(lines)\n                use = self.format_lines(use, indent)\n            else:\n                use += self.format_lines(lines, indent, bullet=\'-\') + \'\\n\'\n            del lines\n        return use\n\n    # def format_arithm(self, expr):\n        #""""""Format an arithmetic expression""""""\n        #ops = re.findall(r\'(\\W+)\',expr)\n        #nums = re.split(r\'\\W+\', expr)\n        # if expr.startswith(ops[0]):\n        #nums = [\'\']+nums\n        #if len(nums)!=len(ops): ops.append(\'\')\n        #newexpr = \'\'\n        # for num, op in zip(nums, ops):\n        # if num.isalpha():\n        #num = \' :f:var:`%s` \'%num\n        # if \'*\' in op:\n        #op = op.replace(\'*\', \'\\*\')\n        #newexpr += num+op\n        # return newexpr\n\n    def format_argdim(self, block):\n        """"""Format the dimension of a variable\n\n         :Parameters:\n\n            - *block*: a variable block\n        """"""\n        if \'dimension\' in block:\n            return\'(%s)\' % (\',\'.join([s.strip(\'()\') for s in block[\'dimension\']]))\n            # return\'(%s)\'%(\',\'.join([s.replace(\':\',\'\\:\').strip(\'()\') for s in\n            # block[\'dimension\']]))\n        return \'\'\n\n    def format_argattr(self, block):\n        """"""Filter and format the attributes (optional, in/out/inout, etc) of a variable\n\n         :Parameters:\n\n            - *block*: a variable block\n        """"""\n        vattr = []\n        if \'intent\' in block and block[\'intent\']:\n            vattr.append(\'/\'.join(block[\'intent\']))\n        if \'attrspec\' in block and block[\'attrspec\']:\n            newattrs = []\n            default_value = (block[\'=\'] if \'=\' in block and\n                             not block[\'=\'].startswith(\'shape(\') else None)\n            for attr in block[\'attrspec\']:\n                #                if \'=\' in block:\n                #                    if attr==\'optional\':\n                #                        continue\n                #                    elif attr==\'parameter\':\n                #                        attr += \'=\'+block[\'=\']\n                #                        #attr += \'=\'+self.format_arithm(block[\'=\'])\n                #                if attr in []:\n                #                    attr = attr.upper()\n                if attr == \'optional\' and default_value is None:\n                    continue\n                newattrs.append(attr)\n            if default_value is not None:\n                newattrs.append(\'default=\' + default_value)\n            if \'private\' in newattrs and \'public\' in newattrs:\n                newattrs.remove(\'private\')\n            vattr.append(\'/\'.join(newattrs))\n        if not vattr:\n            return \'\'\n        vattr = \',\'.join(vattr)\n        return self._fmt_vattr % locals() if vattr else \'\'\n\n    def format_argtype(self, block):\n        if \'typespec\' not in block:\n            return \'\'\n        vtype = block[\'typespec\']\n        if vtype == \'type\':\n            vtype = block[\'typename\']\n        elif vtype == \'character\' and \'charselector\' in block:\n            if \'len\' in block[\'charselector\']:\n                vtype += \'(len=%s)\' % block[\'charselector\'][\'len\']\n            elif \'*\' in block[\'charselector\'] and block[\'charselector\'][\'*\'] != \'(*)\':\n                vtype += \'(len=%s)\' % block[\'charselector\'][\'*\']\n            else:\n                vtype += \'(len=*)\'\n        return vtype\n\n    def format_argfield(self, blockvar, role=None, block=None):\n        """"""Format the description of a variable\n\n         :Parameters:\n\n            - *block*: a variable block\n        """"""\n        vname = blockvar[\'name\']\n        vtype = self.format_argtype(blockvar)  # [\'typespec\']\n        #if vtype==\'type\': vtype = block[\'typename\']\n\n        vdim = self.format_argdim(blockvar)\n        if \':\' in vdim:\n            vdim = vdim.replace(\':\', \'*\')\n        vattr = self.format_argattr(blockvar)\n        vdesc = blockvar[\'desc\'] if \'desc\' in blockvar else \'\'\n        optional = \'attrspec\' in blockvar and \'optional\' in blockvar[\'attrspec\'] and \'depend\' not in blockvar\n        if not role:\n            if block and vname in [block[\'name\'], block.get(\'result\')]:\n                role = \'r\'\n            else:\n                role = \'o\' if optional else \'p\'\n        return self._fmt_vardesc % locals()\n\n    def format_type(self, block, indent=0, bullet=True):\n        """"""Format the description of a module type\n\n         :Parameters:\n\n            - *block*: block of the type\n        """"""\n        # Declaration and description\n        declaration = self.format_declaration(\n            \'type\',\n            block[\'name\'],\n            block[\'desc\'],\n            indent=indent,\n            bullet=bullet) + \'\\n\'\n\n        # Variables\n        vlines = []\n        for varname in sorted(block[\'sortvars\']):\n            bvar = block[\'vars\'][varname]\n            vlines.append(self.format_argfield(bvar, role=\'f\'))\n        variables = self.format_lines(vlines, indent=indent + 1) + \'\\n\'\n        del vlines\n\n        return declaration + variables\n\n    def get_varopts(self, block):\n        """"""Get options for variable declaration as a dict""""""\n        options = OrderedDict()\n        vdim = self.format_argdim(block)\n        #if vdim!=\'\': vdim = self._fmt_fvardim%locals()\n        if vdim:\n            options[\'shape\'] = vdim\n        options[\'type\'] = self.format_argtype(block)\n        vattr = self.format_argattr(block).strip(\' []\')\n        if vattr:\n            options[\'attrs\'] = vattr\n        return options\n\n    # def format_vardesc(self, block):\n        #""""""Format the specification of a variable at top of its declaration content""""""\n        #specs = self.format_varspecs(block)\n        #vdesc = block.get(\'desc\', \'\')\n        # return specs+\'\\n\'+vdesc+\'\\n\'\n\n    def format_var(self, block, indent=0, bullet=True):\n        """"""Format the description of a module type\n\n         :Parameters:\n\n            - *block*: block of the variable\n        """"""\n        # Description of the variable\n        options = self.get_varopts(block)\n        description = block.get(\'desc\', None)\n        if \'name\' in block:\n            declaration = self.format_declaration(\n                \'variable\',\n                block[\'name\'],\n                description=description,\n                options=options,\n                indent=indent,\n                bullet=bullet)\n        else:\n            declaration = \'\'\n\n        # Description of the sub-variables\n        # if block[\'typespec\']==\'type\':\n            # xxxx\n            #variables = []\n            #btype = self.types[block[\'typename\']]\n            # for bvar in btype[\'vars\'].values():\n            #vname = \'%s%%%s\'%(block[\'name\'], bvar[\'name\'])\n            #desc = self.format_vardesc(bvar, indent=0, vname=vname)\n            #variables.append(self.format_declaration(\'var\', vname, desc, indent=indent+1, bullet=True)[:-1])\n            #variables = \'\\n\'.join(variables)\n        # else:\n            #variables = \'\'\n\n        return declaration  # +variables\n\n    def format_signature(self, block):\n        signature = \'\'\n        nopt = 0\n        for i, var in enumerate(block[\'args\']):\n            optional = \'optional\' in block[\'vars\'][var][\'attrspec\'] and \'=\' not in block[\'vars\'][var] \\\n                if \'attrspec\' in block[\'vars\'][var] else False\n            signature += \'[\' if optional else \'\'\n            signature += \', \' if i else \'\'\n            if optional:\n                nopt += 1\n            signature += var\n        signature += nopt * \']\'\n        return signature\n\n    def format_routine(self, block, indent=0):\n        """"""Format the description of a function, a subroutine or a program""""""\n        # Declaration of a subroutine or function\n        if isinstance(block, six.string_types):\n            if block not in list(self.programs.keys()) + \\\n                    list(self.routines.keys()):\n                raise F90toRstException(\n                    \'Unknown function, subroutine or program: %s\' %\n                    block)\n            if block in self.programs:\n                block = self.programs[block]\n            else:\n                block = self.routines[block]\n        elif block[\'name\'] not in list(self.modules.keys()) + list(self.routines.keys()) + list(self.programs.keys()):\n            raise F90toRstException(\n                \'Unknown %s: %s\' %\n                (block[\'block\'], block[\'name\']))\n\n        name = block[\'name\']\n        blocktype = block[\'block\']\n        signature = \'(%s)\' % self.format_signature(\n            block) if blocktype != \'program\' else \'\'\n        declaration = self.format_declaration(\n            blocktype, \'%(name)s%(signature)s\' %\n            locals(), indent=indent)\n        #declaration = self.indent(indent)+\'.. f:%(blocktype)s:: %(name)s%(signature)s\\n\\n\'%locals()\n\n        # Treat variables in comment (subroutines and functions only)\n        comments = list(block[\'desc\']) + [\'\']\n        if blocktype != \'program\':\n            found = []\n            for iline in range(len(comments)):\n                if \'vardescmatch\' in block:\n                    m = block[\'vardescmatch\'](comments[iline])\n                    if m:\n                        varname = m.group(\'varname\')\n                        found.append(varname)\n                        if varname != \'\':\n                            comments[iline] = self.format_argfield(\n                                block[\'vars\'][varname], block=block)\n            for varname in block[\'args\'] + block[\'sortvars\']:\n                if varname not in found:\n                    comments.append(\n                        self.format_argfield(\n                            block[\'vars\'][varname],\n                            block=block))\n                    found.append(varname)\n\n        # Description\n        description = self.format_lines(comments, indent + 1)\n\n        # Add use of modules\n        use = self.format_use(block, indent=indent + 1, short=True)\n\n        # Add calls\n        calls = []\n        module = block.get(\'module\')\n        # - call froms\n        if blocktype in [\'function\', \'subroutine\']:\n            if \'callfrom\' in block and block[\'callfrom\']:\n                callfrom = []\n\n                for fromname in block[\'callfrom\']:\n                    if fromname in self.routines:\n                        cf = self.format_funcref(fromname, module)\n                    else:\n                        cf = \':f:prog:`%s`\' % fromname\n                    callfrom.append(cf)\n\n                # callfrom += \', \'.join([self.format_funcref(getattr(self,\n                # routines[fn][\'name\'], module) for fn in block[\'callfrom\']])\n                callfrom = \':from: \' + \', \'.join(callfrom)\n\n                calls.append(callfrom)\n        # - call tos\n        if block[\'callto\']:\n            callto = \', \'.join([self.format_funcref(fn, module)\n                                for fn in block[\'callto\']])\n            #callto = \', \'.join([self.format_funcref(self.routines[fn][\'name\'], module) for fn in block[\'callto\']])\n            if callto == \'\':\n                callto = \'None\'\n            callto = \':to: \' + callto\n            calls.append(callto)\n        calls = \'\\n\' + self.format_lines(calls, indent=indent + 1)\n        return declaration + description + use + calls + \'\\n\\n\'\n\n    format_function = format_routine\n    format_subroutine = format_routine\n\n    def format_quickaccess(self, module, indent=indent):\n        """"""Format an abstract of all types, variables and routines of a module""""""\n        if not isinstance(module, six.string_types):\n            module = module[\'name\']\n\n        # Title\n        title = self.format_subsection(\'Quick access\', indent=indent) + \'\\n\'\n\n        # Types\n        decs = []\n        tlist = sorted(self.get_blocklist(\'types\', module))\n        if tlist:\n            decs.append(\':Types: \' +\n                        \', \'.join([\':f:type:`%s`\' %\n                                   tt[\'name\'] for tt in tlist]))\n\n        # Variables\n        vlist = self.get_blocklist(\'variables\', module)\n        if vlist:\n            decs.append(\':Variables: \' +\n                        \', \'.join([\':f:var:`%s`\' %\n                                   vv[\'name\'] for vv in vlist]))\n\n        # Functions and subroutines\n        flist = self.get_blocklist(\'functions\', module)\n        if flist:\n            decs.append(\':Routines: \' +\n                        \', \'.join([\':f:func:`~%s/%s`\' %\n                                   (module, ff[\'name\']) for ff in flist]))\n\n        if decs:\n            return self.format_lines(title + \'\\n\'.join(decs)) + \'\\n\\n\'\n        return \'\'\n\n    def format_types(self, block, indent=0):\n        """"""Format the description of all fortran types""""""\n        types = []\n        for subblock in block[\'body\']:\n            if subblock[\'block\'] == \'type\':\n                types.append(self.format_type(subblock, indent=indent))\n        if types:\n            types = self.format_subsection(\n                \'Types\', indent=indent) + \'\\n\'.join(types)\n        else:\n            types = \'\'\n        return types\n\n    def format_variables(self, block, indent=0):\n        """"""Format the description of all variables (global or module)""""""\n        variables = \'\'\n        if block[\'vars\']:\n            varnames = block[\'sortvars\']\n            if block[\'block\'] == \'module\':\n                varnames.sort()\n            for varname in varnames:\n                bvar = block[\'vars\'][varname]\n                variables += self.format_var(bvar, indent=indent)\n            variables = self.format_subsection(\n                \'Variables\', indent=indent) + variables + \'\\n\\n\'\n        return variables\n\n    def format_description(self, block, indent=0):\n        """"""Format the description of an object""""""\n        description = \'\'\n        if block[\'desc\']:\n            description = self.format_subsection(\'Description\', indent=indent)\n            description += self.format_lines(\n                block[\'desc\'], indent=indent, strip=True) + \'\\n\'\n        return description\n\n    def format_routines(self, block, indent=0):\n        """"""Format the list of all subroutines and functions""""""\n        routines = \'\'\n        blocks = block if isinstance(block, list) else block[\'body\']\n        fdecs = []\n        for subblock in blocks:  # block[\'body\']:\n            if subblock[\'block\'] in [\'function\', \'subroutine\']:\n                fdecs.append(self.format_routine(subblock, indent))\n        if fdecs:\n            fdecs = \'\\n\'.join(fdecs)\n            routines = self.format_subsection(\n                \'Subroutines and functions\', indent=indent) + fdecs\n        return routines\n\n    def format_module(self, block, indent=0):\n        """"""Recursively format a module and its declarations""""""\n\n        # Declaration of the module\n        if isinstance(block, six.string_types):\n            if block not in self.modules:\n                raise F90toRstException(\'Unknown module: %s\' % block)\n            block = self.modules[block]\n        elif block[\'name\'] not in self.modules:\n            raise F90toRstException(\'Unknown module: %\' % block[\'name\'])\n\n        modname = block[\'name\']\n        declaration = self.format_declaration(\n            \'module\', modname, indent=indent, options=dict(\n                synopsis=self.get_synopsis(block).strip() or None))\n\n        # Description\n        description = self.format_description(block, indent=indent)\n\n        # Quick access\n        quickaccess = self.format_quickaccess(modname, indent=indent)\n\n        # Use of other modules\n        use = self.format_use(block, indent=indent)\n\n        # Types\n        types = self.format_types(block, indent=indent)\n\n        # Variables\n        variables = self.format_variables(block, indent=indent)\n\n        # Subroutines and functions\n        routines = self.format_routines(block, indent=indent)\n\n        return declaration + description + quickaccess + \\\n            use + types + variables + routines\n\n    def format_srcfile(\n            self,\n            srcfile,\n            indent=0,\n            objtype=None,\n            search_mode=\'basename\',\n            **kwargs):\n        """"""Format all declaration of a file, except modules""""""\n        rst = \'\'\n        if objtype is not None and not isinstance(objtype, (list, tuple)):\n            objtype = [objtype]\n\n        # Programs\n        if objtype is None or \'program\' in objtype:\n            bprog = self.filter_by_srcfile(\n                srcfile, objtype=\'program\', mode=search_mode)\n            if bprog:\n                rst += self.format_subsection(\'Program\', indent=indent) + \'\\n\'\n                rst += self.format_routine(bprog[0], indent=indent) + \'\\n\'\n\n        # Modules\n        if objtype is None or \'module\' in objtype:\n            bmod = self.filter_by_srcfile(\n                srcfile, objtype=\'module\', mode=search_mode)\n            if bmod:\n                rst += self.format_subsection(\'Module\', indent=indent) + \'\\n\'\n                rst += self.format_module(bmod[0], indent=indent) + \'\\n\'\n\n        # Functions and subroutines\n        oal = [\'function\', \'subroutine\']\n        oo = [o for o in oal if o in objtype] if objtype is not None else oal\n        if oo:\n            brouts = self.filter_by_srcfile(\n                srcfile, objtype=oo, mode=search_mode)\n            rst += self.format_routines(brouts, indent=indent) + \'\\n\'\n\n        return rst\n\n    def __getitem__(self, module):\n        return self.format_module(self.modules[module])\n\n\n# Sphinx directive ---\n\ndef list_files(fortran_src, exts=[\'f\', \'f90\', \'f95\'], absolute=True):\n    """"""Get the list of fortran files""""""\n\n    # Extensions (suffixes)\n    if not isinstance(exts, list):\n        exts = list(exts)\n    for e in exts:\n        if e.lower() not in exts:\n            exts.append(e.lower())\n        if e.upper() not in exts:\n            exts.append(e.upper())\n    exts = list(set(exts))\n\n    # List the files using globs\n    ffiles = []\n    for fg in fortran_src:\n        if not isinstance(fg, six.string_types):\n            continue\n        if os.path.isdir(fg):\n            for ext in exts:\n                ffiles.extend(glob(os.path.join(fg, \'*.\' + ext)))\n        else:\n            ffiles.extend(glob(fg))\n    if absolute:\n        ffiles = [os.path.abspath(ffile) for ffile in ffiles]\n    ffiles.sort()\n    return ffiles\n\n\ndef fortran_parse(app):\n    env = app.builder.env\n    if isinstance(app.config.fortran_src, (str, list)):\n        logger.info(bold(\'parsing fortran sources...\'), nonl=True)\n\n        # Sources a list\n        if not isinstance(app.config.fortran_src, list):\n            app.config.fortran_src = [app.config.fortran_src]\n\n        # All files\n        ffiles = list_files(app.config.fortran_src, app.config.fortran_ext)\n\n        # Parse files\n        if not ffiles:\n            logger.info("" no fortran files found"")\n            app.config._f90torst = None\n        else:\n            app.config.fortran_indent = fmt_indent(app.config.fortran_indent)\n            app.config._f90torst = F90toRst(\n                ffiles,\n                ic=app.config.fortran_indent,\n                ulc=app.config.fortran_title_underline,\n                encoding=app.config.fortran_encoding)\n            logger.info(\' done\')\n        app._status.flush()\n\n    else:\n        logger.warning(\n            ""wrong list of fortran 90 source specifications: "" + str(app.config.fortran_src))\n        app.config._f90torst = None\n#    app.config._f90files = []\n\n\ndef fmt_indent(string):\n    if string is None:\n        return\n    if isinstance(string, int):\n        string = \' \' * string\n    if string == \'tab\':\n        string = \'\\t\'\n    elif string == \'space\':\n        string = \' \'\n    return string\n\n\n# class fortran_module(nodes.General, nodes.Element):\n    # pass\n\n\nclass FortranAutoModuleDirective(Directive):\n    has_content = True\n    option_spec = dict(title_underline=unchanged, indent=fmt_indent,\n                       subsection_type=unchanged)\n    required_arguments = 1\n    optional_arguments = 0\n\n    def run(self):\n\n        # Get environment\n        f90torst = self.state.document.settings.env.config._f90torst\n        if f90torst is None:\n            return []\n\n        # Check module name\n        module = self.arguments[0]\n        if module not in f90torst.modules:\n            self.state_machine.reporter.warning(\n                \'Wrong fortran module name: \' + module, line=self.lineno)\n#            self.warn(\'Wrong fortran module name: \'+module)\n\n        # Options\n        ic = f90torst.ic\n        ulc = f90torst.ulc\n        sst = f90torst.sst\n        if self.options.get(\'indent\'):\n            f90torst.ic = self.options[\'indent\']\n        if self.options.get(\'title_underline\'):\n            f90torst.ulc = self.options[\'title_underline\']\n        if self.options.get(\'subsection_type\'):\n            f90torst.sst = self.options[\'subsection_type\']\n\n        # Get rst\n        raw_text = f90torst.format_module(module)\n\n        # Insert it\n        source = self.state_machine.input_lines.source(\n            self.lineno - self.state_machine.input_offset - 1)\n        include_lines = string2lines(raw_text, convert_whitespace=1)\n        self.state_machine.insert_input(include_lines, source)\n\n        # Restore defaults\n        if \'indent\' in self.options:\n            f90torst.ic = ic\n        if \'title_underline\' in self.options:\n            f90torst.ulc = ulc\n        if \'subsection_type\' in self.options:\n            f90torst.sst = sst\n\n        return []\n\n\nclass FortranAutoObjectDirective(Directive):\n    """"""Generic directive for fortran object auto-documentation\n\n    Redefine :attr:`_warning` and :attr:`_objtype` attribute when subcassling.\n\n    .. attribute:: _warning\n\n        Warning message when object is not found, like:\n\n        >>> _warning = \'Wrong function or subroutine name: %s\'\n\n    .. attribute:: _objtype\n\n        Type of fortran object.\n        If ""toto"" is set as object type, then :class:`F90toRst` must have\n        attribute :attr:`totos` containg index of all related fortran objects,\n        and method :meth:`format_totos` for formatting the object.\n\n    """"""\n    has_content = False\n    option_spec = OrderedDict()\n    required_arguments = 1\n    optional_arguments = 0\n    _warning = \'Wrong routine name: %s\'\n    _objtype = \'routine\'\n\n    def run(self):\n\n        # Get environment\n        f90torst = self.state.document.settings.env.config._f90torst\n        if f90torst is None:\n            return []\n\n        # Check object name\n        objname = self.arguments[0].lower()\n        from sphinxfortran.fortran_domain import f_sep\n        if f_sep in objname:\n            objname = objname.split(f_sep)[-1]  # remove module name\n        objects = getattr(f90torst, self._objtype + \'s\')\n        if objname not in objects:\n#            print(self._warning % objname)\n            self.state_machine.reporter.warning(\n                self._warning %\n                objname, line=self.lineno)\n#            self.warn(self._warning%objname)\n\n        # Get rst\n        raw_text = getattr(f90torst, \'format_\' + self._objtype)(objname)\n\n        # Check if inside module\n        b = objects[objname]\n        if \'parent_block\' in b:\n            curmod_text = \'.. f:currentmodule:: %s\\n\\n\' % b[\'parent_block\'][\'name\']\n            raw_text = curmod_text + raw_text\n\n        # Insert it\n        source = self.state_machine.input_lines.source(\n            self.lineno - self.state_machine.input_offset - 1)\n        include_lines = string2lines(raw_text, convert_whitespace=1)\n        self.state_machine.insert_input(include_lines, source)\n\n        return []\n\n\nclass FortranAutoFunctionDirective(FortranAutoObjectDirective):\n    _warning = \'Wrong function name: %s\'\n    _objtype = \'function\'\n\n\nclass FortranAutoSubroutineDirective(FortranAutoObjectDirective):\n    _warning = \'Wrong subroutine name: %s\'\n    _objtype = \'subroutine\'\n\n\nclass FortranAutoTypeDirective(FortranAutoObjectDirective):\n    _warning = \'Wrong type name: %s\'\n    _objtype = \'type\'\n\n\nclass FortranAutoVariableDirective(FortranAutoObjectDirective):\n    _warning = \'Wrong variable name: %s\'\n    _objtype = \'variable\'\n\n\nclass FortranAutoProgramDirective(Directive):\n    has_content = False\n    option_spec = OrderedDict()\n    required_arguments = 1\n    optional_arguments = 0\n\n    def run(self):\n\n        # Get environment\n        f90torst = self.state.document.settings.env.config._f90torst\n        if f90torst is None:\n            return []\n\n        # Check routine name\n        program = self.arguments[0].lower()\n        if program not in f90torst.programs:\n#            print(\'Wrong program name: \' + program)\n            self.state_machine.reporter.warning(\n                \'Wrong program name: \' + program, line=self.lineno)\n#            self.warning(\'Wrong program name: \'+program)\n\n        # Get rst\n        raw_text = f90torst.format_routine(program)\n\n        # Insert it\n        source = self.state_machine.input_lines.source(\n            self.lineno - self.state_machine.input_offset - 1)\n        include_lines = string2lines(raw_text, convert_whitespace=1)\n        self.state_machine.insert_input(include_lines, source)\n\n        return []\n\n\nclass FortranAutoSrcfileDirective(Directive):\n    has_content = False\n    option_spec = dict(search_mode=unchanged, objtype=unchanged)\n    required_arguments = 1\n    optional_arguments = 0\n\n    def run(self):\n\n        # Get environment\n        f90torst = self.state.document.settings.env.config._f90torst\n        if f90torst is None:\n            return []\n\n        # Options\n        search_mode = self.options.get(\'search_mode\')\n        objtype = self.options.get(\'objtype\')\n        if objtype:\n            objtype = objtype.split(\' ,\')\n\n        # Get rst\n        srcfile = self.arguments[0].lower()\n        raw_text = f90torst.format_srcfile(\n            srcfile, search_mode=search_mode, objtype=objtype)\n        if not raw_text:\n            msg = \'No valid content found for file: \' + srcfile\n#            print(msg)\n            self.state_machine.reporter.warning(msg, line=self.lineno)\n#            self.warning(\'No valid content found for file: \'+srcfile)\n\n        # Insert it\n        source = self.state_machine.input_lines.source(\n            self.lineno - self.state_machine.input_offset - 1)\n        include_lines = string2lines(raw_text, convert_whitespace=1)\n        self.state_machine.insert_input(include_lines, source)\n\n        return []\n\n\ndef setup(app):\n\n    app.add_object_type(\n        \'ftype\',\n        \'ftype\',\n        indextemplate=\'pair: %s; Fortran type\',\n    )\n    app.add_object_type(\n        \'fvar\',\n        \'fvar\',\n        indextemplate=\'pair: %s; Fortran variable\',\n    )\n\n    app.add_config_value(\'fortran_title_underline\', \'-\', False)\n    app.add_config_value(\'fortran_indent\', 4, False)\n    app.add_config_value(\'fortran_subsection_type\', \'rubric\', False)\n    app.add_config_value(\'fortran_src\', [\'.\'], False)\n    app.add_config_value(\'fortran_ext\', [\'f90\', \'f95\'], False)\n    app.add_config_value(\'fortran_encoding\', \'utf8\', False)\n\n    #app.add_directive(\'fortran_module\', IncludeFortranDirective)\n    FortranDomain.directives.update(\n        automodule=FortranAutoModuleDirective,\n        autoroutine=FortranAutoObjectDirective,\n        autofunction=FortranAutoFunctionDirective,\n        autosubroutine=FortranAutoSubroutineDirective,\n        autoprogram=FortranAutoProgramDirective,\n        autosrcfile=FortranAutoSrcfileDirective,\n    )\n    app.connect(\'builder-inited\', fortran_parse)\n'"
sphinxfortran/fortran_domain.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nA fortran domain for sphinx\n\n""""""\n# Copyright or \xc2\xa9 or Copr. Actimar/IFREMER (2010-2019)\n#\n# This software is a computer program whose purpose is to provide\n# utilities for handling oceanographic and atmospheric data,\n# with the ultimate goal of validating the MARS model from IFREMER.\n#\n# This software is governed by the CeCILL license under French law and\n# abiding by the rules of distribution of free software.  You can  use,\n# modify and/ or redistribute the software under the terms of the CeCILL\n# license as circulated by CEA, CNRS and INRIA at the following URL\n# ""http://www.cecill.info"".\n#\n# As a counterpart to the access to the source code and  rights to copy,\n# modify and redistribute granted by the license, users are provided only\n# with a limited warranty  and the software\'s author,  the holder of the\n# economic rights,  and the successive licensors  have only  limited\n# liability.\n#\n# In this respect, the user\'s attention is drawn to the risks associated\n# with loading,  using,  modifying and/or developing or reproducing the\n# software by the user in light of its specific status of free software,\n# that may mean  that it is complicated to manipulate,  and  that  also\n# therefore means  that it is reserved for developers  and  experienced\n# professionals having in-depth computer knowledge. Users are therefore\n# encouraged to load and test the software\'s suitability as regards their\n# requirements in conditions enabling the security of their systems and/or\n# data to be ensured and,  more generally, to use and operate it in the\n# same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n#\n\nfrom __future__ import print_function\nfrom builtins import zip\nfrom builtins import str\nfrom builtins import object\nimport re\nfrom collections import OrderedDict\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import Directive, directives\n\nfrom sphinx import addnodes, version_info\nfrom sphinx.roles import XRefRole\nfrom sphinx.locale import _\nfrom sphinx.domains import Domain, ObjType, Index\nfrom sphinx.directives import ObjectDescription\nfrom sphinx.util.nodes import make_refnode\nfrom sphinx.util.docfields import Field, GroupedField, TypedField, DocFieldTransformer, _is_single_paragraph\n\nimport six\n\n\n# FIXME: surlignage en jaune de la recherche inactive si ""/"" dans target\n\n# Utilities\n\ndef convert_arithm(node, expr, modname=None, nodefmt=nodes.Text):\n    """"""Format an arithmetic expression for a node""""""\n    ops = re.findall(r\'(\\W+)\', expr)\n    nums = re.split(r\'\\W+\', expr)\n    if len(nums) != len(ops):\n        ops.append(\'\')\n    for num, op in zip(nums, ops):\n        if num:\n            if num[0].isalpha():\n                refnode = addnodes.pending_xref(\n                    \'\', refdomain=\'f\', reftype=\'var\', reftarget=num,\n                    modname=modname)\n                refnode += nodefmt(num, num)\n                node += refnode\n            else:\n                node += nodefmt(num, num)\n        if op:\n            op = op.replace(\':\', \'*\')\n            node += nodefmt(op, op)\n\n\ndef parse_shape(shape):\n    if not shape:\n        return\n    if not shape.startswith(\'(\'):\n        shape = \'(\' + shape\n    if not shape.endswith(\')\'):\n        shape += \')\'\n    return shape\n\n\ndef add_shape(node, shape, modname=None, nodefmt=nodes.Text):\n    """"""Format a shape expression for a node""""""\n    dims = re.split(r\'\\s*,\\s*\', shape.strip(\'( )\'))\n    node += nodefmt(\' (\', \' (\')\n    convert_arithm(node, shape.strip(\'( )\'), modname=modname, nodefmt=nodefmt)\n    node += nodefmt(\')\', \')\')\n\n#class fortranfield(nodes.Admonition, nodes.TextElement): pass\n\n# Doc fields\n\n\nre_name_shape = re.compile(r\'(\\w+)(\\(.+\\))?\')\n\nre_fieldname_match = re.compile(\n    r\'(?P<type>\\b\\w+\\b(?P<kind>\\s*\\(.*\\))?)?\\s*(?P<name>\\b\\w+\\b)\\s*(?P<shape>\\(.*\\))?\\s*(?P<sattrs>\\[.+\\])?\').match\n\n\nclass FortranField(Field):\n    def make_xref(self, rolename, domain, target, innernode=nodes.emphasis,\n                  modname=None, typename=None):\n        if not rolename:\n            return innernode(target, target)\n        refnode = addnodes.pending_xref(\n            \'\',\n            refdomain=domain,\n            refexplicit=False,\n            reftype=rolename,\n            reftarget=target,\n            modname=modname,\n            typename=typename)\n        refnode += innernode(target, target)\n        return refnode\n\n\nclass FortranCallField(FortranField):\n    is_grouped = True\n\n    def __init__(self, name, names=(), label=None, rolename=None):\n        Field.__init__(self, name, names, label, True, rolename)\n\n    def make_field(self, types, domain, items, **kwargs):\n\n        fieldname = nodes.field_name(\'\', self.label)\n        #par = Field.make_field(self, types, domain, items[0])\n        par = nodes.paragraph()\n        for i, item in enumerate(items):\n            if i:\n                par += nodes.Text(\' \')\n            par += item[1]  # Field.make_field(self, types, domain, item)\n        fieldbody = nodes.field_body(\'\', par)\n        return nodes.field(\'\', fieldname, fieldbody)\n\n\nclass FortranCompleteField(FortranField, GroupedField):\n    """"""\n    A doc field that is grouped and has type information for the arguments.  It\n    always has an argument.  The argument can be linked using the given\n    *rolename*, the type using the given *typerolename*.\n\n    Two uses are possible: either parameter and type description are given\n    separately, using a field from *names* and one from *typenames*,\n    respectively, or both are given using a field from *names*, see the example.\n\n    Example::\n\n       :param foo: description of parameter foo\n       :type foo:  SomeClass\n\n       -- or --\n\n       :param SomeClass foo: description of parameter foo\n    """"""\n    is_typed = 2\n\n    def __init__(self, name, names=(), typenames=(), label=None,\n                 rolename=None, typerolename=None,\n                 shapenames=None, attrnames=None,\n                 prefix=None,\n                 strong=True,\n                 can_collapse=False):\n        GroupedField.__init__(self, name, names, label, rolename, can_collapse)\n        self.typenames = typenames\n        self.typerolename = typerolename\n        self.shapenames = shapenames\n        self.attrnames = attrnames\n        self.prefix = prefix\n        if strong:\n            self.namefmt = nodes.strong\n        else:\n            self.namefmt = addnodes.desc_name\n\n    def make_field(self, types, domain, items, shapes=None, attrs=None,\n                   modname=None, typename=None):\n        def handle_item(fieldarg, content):\n            par = nodes.paragraph()\n            if self.prefix:\n                par += self.namefmt(self.prefix, self.prefix)\n\n            par += self.make_xref(self.rolename,\n                                  domain,\n                                  fieldarg,\n                                  self.namefmt,\n                                  modname=modname,\n                                  typename=typename)\n            #par += self.namefmt(fieldarg, fieldarg)\n\n            fieldtype = types.pop(fieldarg, None)\n            fieldshape = shapes and shapes.pop(fieldarg, None)\n            fieldattrs = attrs and attrs.pop(fieldarg, None)\n            if fieldshape:\n                shape = parse_shape(fieldshape[0].astext())\n                #par += nodes.Text(\' %s\'%shape)\n                add_shape(par, shape, modname=modname)\n            if fieldtype or fieldattrs:\n                par += nodes.emphasis(\' [\', \' [\')\n            if fieldtype:\n                if len(fieldtype) == 1 and isinstance(\n                        fieldtype[0], nodes.Text):\n                    thistypename = fieldtype[0].astext()\n                    #typename = u\'\'.join(n.astext() for n in fieldtype)\n                    par += self.make_xref(self.typerolename,\n                                          domain,\n                                          thistypename,\n                                          modname=modname,\n                                          typename=typename)\n                else:\n                    par += fieldtype\n            if fieldattrs:\n                if fieldtype:\n                    par += nodes.emphasis(\',\', \',\')\n                par += fieldattrs\n            if fieldtype or fieldattrs:\n                par += nodes.emphasis(\']\', \']\')\n            if content:\n                par += nodes.Text(\' :: \')\n                par += content\n            return par\n\n        if len(items) == 1 and self.can_collapse:\n            fieldarg, content = items[0]\n            bodynode = handle_item(fieldarg, content)\n        else:\n            bodynode = self.list_type()\n            for fieldarg, content in items:\n                bodynode += nodes.list_item(\'\', handle_item(fieldarg, content))\n        label = self.label or \'\'\n        fieldname = nodes.field_name(\'\', label)\n        fieldbody = nodes.field_body(\'\', bodynode)\n        return nodes.field(\'\', fieldname, fieldbody)\n\n\nclass FortranDocFieldTransformer(DocFieldTransformer):\n    """"""\n    Transforms field lists in ""doc field"" syntax into better-looking\n    equivalents, using the field type definitions given on a domain.\n    """"""\n\n    def __init__(self, directive, modname=None, typename=None):\n        self.domain = directive.domain\n        if \'_doc_field_type_map\' not in directive.__class__.__dict__:\n            directive.__class__._doc_field_type_map = \\\n                self.preprocess_fieldtypes(directive.__class__.doc_field_types)\n        self.typemap = directive._doc_field_type_map\n        self.modname = modname\n        self.typename = typename\n\n    def preprocess_fieldtypes(self, types):\n        typemap = OrderedDict()\n        for fieldtype in types:\n            for name in fieldtype.names:\n                typemap[name] = fieldtype, False\n            if fieldtype.is_typed:\n                for name in fieldtype.typenames:\n                    typemap[name] = fieldtype, \'types\'\n                for name in fieldtype.shapenames:\n                    typemap[name] = fieldtype, \'shapes\'\n                for name in fieldtype.attrnames:\n                    typemap[name] = fieldtype, \'attrs\'\n        return typemap\n\n    def scan_fieldarg(self, fieldname):\n        """"""Extract type, name, shape and attributes from a field name.\n\n        :Some possible syntaxes:\n\n            - ``p name``\n            - ``p type name(shape) [attr1,attr2]``\n            - ``p type name``\n            - ``p name [attr1, attr2]``\n\n        :Returns: ``name, shape, type, list of attributes``.\n            if no shape is specified, it is set to ``None``,\n        """"""\n        m = re_fieldname_match(fieldname.strip())\n        if not m:\n            raise ValueError(\n                \'Wrong field (%s). It must have at least one parameter name and one argument\' %\n                fieldname)\n        ftype, kind, name, shape, attrs = m.groups()\n        attrs = attrs and attrs[1:-1]\n        # if attrs:\n        #attrs = [a.strip() for a in attrs[1:-1].split(\',\')]\n        # else:\n        #attrs = []\n        return name, shape, ftype, attrs\n\n    def transform(self, node):\n        """"""Transform a single field list *node*.""""""\n        typemap = self.typemap\n        fmodname = self.modname\n        ftypename = self.typename\n\n        entries = []\n        groupindices = OrderedDict()\n        types = OrderedDict()\n        shapes = OrderedDict()\n        attrs = OrderedDict()\n\n        # step 1: traverse all fields and collect field types and content\n        for field in node:\n\n            fieldname, fieldbody = field\n            try:\n                # split into field type and argument\n                fieldtype, fieldarg = fieldname.astext().split(None, 1)\n            except ValueError:\n                # maybe an argument-less field type?\n                fieldtype, fieldarg = fieldname.astext(), \'\'\n            typedesc, is_typefield = typemap.get(fieldtype, (None, None))\n\n            # sort out unknown fields\n            if typedesc is None:  # or typedesc.has_arg != bool(fieldarg):\n                # either the field name is unknown, or the argument doesn\'t\n                # match the spec; capitalize field name and be done with it\n                new_fieldname = fieldtype.capitalize() + \' \' + fieldarg\n                fieldname[0] = nodes.Text(new_fieldname)\n                entries.append(field)\n                continue\n\n            typename = typedesc.name\n\n            # collect the content, trying not to keep unnecessary paragraphs\n            if _is_single_paragraph(fieldbody):\n                content = fieldbody.children[0].children\n            else:\n                content = fieldbody.children\n\n            # if the field specifies a type, put it in the types collection\n            if is_typefield:\n                # filter out only inline nodes; others will result in invalid\n                # markup being written out\n                content = [n for n in content if isinstance(n, nodes.Inline) or\n                           isinstance(n, nodes.Text)]\n                if content:\n                    eval(is_typefield).setdefault(\n                        typename, OrderedDict())[fieldarg] = content\n                continue\n\n            # also support syntax like ``:param type name [attrs]:``\n            if typedesc.is_typed == 2:\n                argname, argshape, argtype, argattrs = self.scan_fieldarg(\n                    fieldarg)\n                if argtype:\n                    types.setdefault(typename, OrderedDict())[argname] = \\\n                        [nodes.Text(argtype)]\n                if argshape:\n                    shapes.setdefault(typename, OrderedDict())[argname] = \\\n                        [nodes.Text(argshape)]\n                if argattrs:\n                    attrs.setdefault(typename, OrderedDict())[argname] = \\\n                        [nodes.emphasis(argattrs, argattrs)]\n                fieldarg = argname\n            elif typedesc.is_typed:\n                try:\n                    argtype, argname = fieldarg.split(None, 1)\n                except ValueError:\n                    pass\n                else:\n                    types.setdefault(typename, OrderedDict())[argname] = \\\n                        [nodes.Text(argtype)]\n                    fieldarg = argname\n\n            # grouped entries need to be collected in one entry, while others\n            # get one entry per field\n            if typedesc.is_grouped:\n                if typename in groupindices:\n                    group = entries[groupindices[typename]]\n                else:\n                    groupindices[typename] = len(entries)\n                    group = [typedesc, []]\n                    entries.append(group)\n                group[1].append(typedesc.make_entry(fieldarg, content))\n            else:\n                entries.append([typedesc,\n                                typedesc.make_entry(fieldarg, content)])\n\n        # step 2: all entries are collected, construct the new field list\n        new_list = nodes.field_list()\n        for entry in entries:\n            if isinstance(entry, nodes.field):\n                # pass-through old field\n                new_list += entry\n            else:\n                fieldtype, content = entry\n                fieldtypes = types.get(fieldtype.name, OrderedDict())\n                fieldshapes = shapes.get(fieldtype.name, OrderedDict())\n                fieldattrs = attrs.get(fieldtype.name, OrderedDict())\n                new_list += fieldtype.make_field(fieldtypes,\n                                                 self.domain,\n                                                 content,\n                                                 shapes=fieldshapes,\n                                                 attrs=fieldattrs,\n                                                 modname=fmodname,\n                                                 typename=ftypename)\n\n        node.replace_self(new_list)\n\n\n# REs for Fortran signatures\nf_sep = \'/\'\nf_sig_re = re.compile(\n    r\'\'\'^ (\\w+(?:[^%%%(f_sep)s]%(f_sep)s\\w+))? \\s*          # type\n          (\\b(?:subroutine|function))?  \\s*             # objtype\n          (\\b\\w+%(f_sep)s)?              # module name\n          (\\b\\w+%%)?              # type name\n          (\\b\\w+)  \\s*             # thing name\n          (?: \\((.*)\\))?           # optional: arguments\n           $                   # and nothing more\n          \'\'\' % dict(f_sep=f_sep), re.VERBOSE + re.I)\n\n\n# Directives\n\n# RE to split at word boundaries\nwsplit_re = re.compile(r\'(\\W+)\')\nf_type_re = re.compile(r\'^([\\w]+).*$\')\n\nf_paramlist_re = re.compile(r\'([\\[\\],])\')  # split at \'[\', \']\' and \',\'\n\n\n# def fortran_rsplit(fullname):\n#    items = [item for item in f_separator.findall(fullname)]\n#    return \'\'.join(items[:-2]), items[-1]\n\ndef _pseudo_parse_arglist(signode, arglist):\n    """"""""Parse"" a list of arguments separated by commas.\n\n    Arguments can have ""optional"" annotations given by enclosing them in\n    brackets.  Currently, this will split at any comma, even if it\'s inside a\n    string literal (e.g. default argument value).\n    """"""\n    paramlist = addnodes.desc_parameterlist()\n    stack = [paramlist]\n    try:\n        for argument in arglist.split(\',\'):\n            argument = argument.strip()\n            ends_open = ends_close = 0\n            while argument.startswith(\'[\'):\n                stack.append(addnodes.desc_optional())\n                stack[-2] += stack[-1]\n                argument = argument[1:].strip()\n            while argument.startswith(\']\'):\n                stack.pop()\n                argument = argument[1:].strip()\n            while argument.endswith(\']\'):\n                ends_close += 1\n                argument = argument[:-1].strip()\n            while argument.endswith(\'[\'):\n                ends_open += 1\n                argument = argument[:-1].strip()\n            if argument:\n                stack[-1] += addnodes.desc_parameter(argument, argument)\n            while ends_open:\n                stack.append(addnodes.desc_optional())\n                stack[-2] += stack[-1]\n                ends_open -= 1\n            while ends_close:\n                stack.pop()\n                ends_close -= 1\n        if len(stack) != 1:\n            raise IndexError\n    except IndexError:\n        # if there are too few or too many elements on the stack, just give up\n        # and treat the whole argument list as one argument, discarding the\n        # already partially populated paramlist node\n        signode += addnodes.desc_parameterlist()\n        signode[-1] += addnodes.desc_parameter(arglist, arglist)\n    else:\n        signode += paramlist\n\n\nclass FortranObject(ObjectDescription):\n    """"""\n    Description of a general Fortran object.\n    """"""\n    option_spec = {\n        \'noindex\': directives.flag,\n        \'module\': directives.unchanged,\n        \'type\': directives.unchanged,\n        \'shape\': parse_shape,\n        \'attrs\': directives.unchanged,\n    }\n\n    doc_field_types = [\n        FortranCompleteField(\'parameter\', label=_(\'Parameters\'),\n                             names=(\n            \'p\', \'param\', \'parameter\', \'a\', \'arg\', \'argument\'),\n            # rolename=\'var\',\n            typerolename=\'type\',\n            typenames=(\'paramtype\', \'type\', \'ptype\'),\n            shapenames=(\'shape\', \'pshape\'),\n            attrnames=(\'attrs\', \'pattrs\', \'attr\'),\n            can_collapse=True),\n        FortranCompleteField(\'optional\', label=_(\'Options\'),\n                             names=(\n            \'o\', \'optional\', \'opt\', \'keyword\', \'option\'),\n            # rolename=\'var\',\n            typerolename=\'type\',\n            typenames=(\'optparamtype\', \'otype\'),\n            shapenames=(\'oshape\',),\n            attrnames=(\'oattrs\', \'oattr\'),\n            can_collapse=True),\n        FortranCompleteField(\'typefield\', label=_(\'Type fields\'),\n                             names=(\'f\', \'field\', \'typef\', \'typefield\'),\n                             # rolename=\'typef\',\n                             typerolename=\'type\',\n                             typenames=(\'fieldtype\', \'ftype\'),\n                             shapenames=(\'fshape\',),\n                             attrnames=(\'fattrs\', \'fattr\'),\n                             prefix=\'% \',\n                             strong=False,\n                             can_collapse=False),\n        FortranCompleteField(\'return\', label=_(\'Return\'),\n                             names=(\'r\', \'return\', \'returns\'),\n                             typerolename=\'type\',\n                             typenames=(\'returntype\', \'rtype\'),\n                             shapenames=(\'rshape\',),\n                             attrnames=(\'rattrs\', \'rattr\'),\n                             can_collapse=True),\n        FortranCallField(\'calledfrom\', label=_(\'Called from\'),\n                         names=(\'calledfrom\', \'from\')),\n        FortranCallField(\'callto\', label=_(\'Call to\'),\n                         names=(\'callto\', \'to\')),\n    ]\n\n    # These Fortran types aren\'t described anywhere, so don\'t try to create\n    # a cross-reference to them\n    stopwords = set((\'float\', \'integer\', \'character\', \'double\', \'long\'))\n\n    _parens = \'\'\n\n#    def _parse_type(self, node, ftype):\n#        m = f_type_re.match(ftype)\n#        tnode = nodes.Text(ftype, ftype)\n#        modname = self.options.get(\n#            \'module\', self.env.temp_data.get(\'f:module\'))\n#        if m :\n#            ftype = m.groups(0)\n#            if ftype not in self.stopwords:\n#                pnode = addnodes.pending_xref(\n#                    \'\', refdomain=\'f\', reftype=\'type\', reftarget=ftype,\n#                    modname=modname)\n#                pnode += tnode\n#                node += pnode\n#            else:\n#                node += tnode\n#        else:\n#            node += tnode\n\n    def get_signature_prefix(self, sig):\n        """"""\n        May return a prefix to put before the object name in the signature.\n        """"""\n        return \'\'\n\n    def needs_arglist(self):\n        """"""\n        May return true if an empty argument list is to be generated even if\n        the document contains none.\n        """"""\n        return False\n\n    def handle_signature(self, sig, signode):\n        """"""\n        Transform a Fortran signature into RST nodes.\n        Returns (fully qualified name of the thing, classname if any).\n\n        If inside a class, the current class name is handled intelligently:\n        * it is stripped from the displayed name if present\n        * it is added to the full name (return value) if not present\n        """"""\n        m = f_sig_re.match(sig)\n        if m is None:\n            raise ValueError\n        ftype, objtype, modname, typename, name, arglist = m.groups()\n        if not typename:\n            typename = """"\n\n        # determine module, type, shape and attributes\n        modname = (modname and modname[:-1]) or self.options.get(\n            \'module\', self.env.temp_data.get(\'f:module\'))\n        if typename:\n            name = typename[:-1]\n        attrs = self.options.get(\'attrs\')\n        shape = parse_shape(self.options.get(\'shape\'))\n        ftype = ftype or self.options.get(\'type\')\n        if self.objtype == \'typefield\' and not typename:\n            raise ValueError\n\n        #if typename: name = typename+\'%\'+name\n\n        #fullname = name\n        # if modname:\n        if self.objtype == \'program\':\n            fullname = name\n        else:\n            fullname = (modname or \'_\') + f_sep + name\n\n        signode[\'module\'] = modname\n        signode[\'type\'] = typename\n        signode[\'fullname\'] = fullname\n\n        # Add ""function"" or ""subroutine"" tag\n        sig_prefix = self.get_signature_prefix(sig)\n        if objtype or sig_prefix:\n            objtype = objtype or sig_prefix\n            signode += addnodes.desc_annotation(objtype + \' \', objtype + \' \')\n\n        # Add module\n        if self.env.config.add_module_names and modname and self.objtype != \'typefield\':\n            nodetext = modname + f_sep\n            signode += addnodes.desc_addname(nodetext, nodetext)\n\n        # Add name\n        signode += addnodes.desc_name(name, name)\n\n        # In the parenthesis\n        if self.needs_arglist():  # call for functions and subroutines\n            if arglist:  # Calling arguments\n                _pseudo_parse_arglist(signode, arglist)\n            elif self.needs_arglist():  # for callables, add an empty parameter list\n                signode += addnodes.desc_parameterlist()\n        # Declare shape instead of arguments (variables)\n        elif arglist and not shape:\n            shape = arglist\n\n        # Add remaining\n        self.add_shape_and_attrs(signode, modname, ftype, shape, attrs)\n\n        return fullname, ftype\n\n    def add_shape_and_attrs(self, signode, modname, ftype, shape, attrs):\n        # add shape\n        if shape:\n            add_shape(signode, shape, modname=modname)\n            #signode += nodes.Text(\' \'+shape)\n        # add type (\'float\', \'interger\', etc)\n        if ftype or attrs:\n            signode += nodes.emphasis(\' [\', \' [\')\n        if ftype:\n            refnode = addnodes.pending_xref(\n                \'\', refdomain=\'f\', reftype=\'type\', reftarget=ftype,\n                modname=modname,)\n            refnode += nodes.emphasis(ftype, ftype)\n            signode += refnode\n            #tnode = addnodes.desc_type(ftype, ftype)\n            # tnode +=\n            #signode += addnodes.desc_type(ftype, ftype)\n            # signode +=\n    #        signode += addnodes.desc_type(\'\', \'\')\n    #        self._parse_type(signode[-1], ftype)\n        if attrs:\n            if ftype:\n                signode += nodes.emphasis(\',\', \',\')\n            for iatt, att in enumerate(re.split(r\'\\s*,\\s*\', attrs)):\n                if iatt:\n                    signode += nodes.emphasis(\',\', \',\')\n                if att.startswith(\'parameter\'):\n                    value = att.split(\'=\')[1]\n                    signode += nodes.emphasis(\'parameter=\', \'parameter=\')\n                    convert_arithm(signode, value, modname=modname)\n                else:\n                    signode += nodes.emphasis(att, att)\n            #signode += nodes.emphasis(attrs, attrs)\n\n        if ftype or attrs:\n            signode += nodes.emphasis(\']\', \']\')\n\n    def add_target_and_index(self, name, sig, signode):\n        # modname = self.options.get(\n            # \'module\', self.env.temp_data.get(\'f:module\'))\n        modname = signode.get(\n            \'module\', self.env.temp_data.get(\'f:module\'))\n#        fullname = (modname and modname + \'/\' or \'\') + name[0]\n        fullname = \'f\' + f_sep + name[0]\n\n        # note target\n        if fullname not in self.state.document.ids:\n            signode[\'names\'].append(fullname)\n            signode[\'ids\'].append(fullname)\n            signode[\'first\'] = (not self.names)\n            self.state.document.note_explicit_target(signode)\n            objects = self.env.domaindata[\'f\'][\'objects\']\n            if fullname in objects:\n                self.env.warn(\n                    self.env.docname,\n                    \'duplicate object description of %s, \' % fullname +\n                    \'other instance in \' +\n                    self.env.doc2path(objects[fullname][0]),\n                    self.lineno)\n            objects[fullname] = (self.env.docname, self.objtype)\n        indextext = self.get_index_text(modname, fullname)\n        if indextext:\n            # self.indexnode[\'entries\'].append((\'single\', indextext,\n                                              # fullname, fullname,None))\n            self.indexnode[\'entries\'].append(\n                FortranCreateIndexEntry(\n                    indextext, fullname, fullname))\n\n    def before_content(self):\n        # needed for automatic qualification of fields (reset in subclasses)\n        self.typename_set = False\n\n    def after_content(self):\n        if self.typename_set:\n            self.env.temp_data[\'f:type\'] = None\n\n    def get_index_text(self, modname, name):\n        add_modules = self.env.config.add_module_names\n        if name.startswith(\'f\' + f_sep):\n            name = name[2:]\n        mn = modname or \'_\'\n        sobj = \'\'\n        if name.startswith(mn + f_sep):\n            name = name[len(mn) + 1:]\n        if self.objtype == \'type\':\n            sobj = _(\'fortran type\')\n        if self.objtype == \'typefield\':\n            sobj = _(\'fortran type field\')\n        elif self.objtype == \'variable\':\n            sobj = _(\'fortran variable\')\n        elif self.objtype == \'subroutine\':\n            sobj = _(\'fortran subroutine\')\n        elif self.objtype == \'function\':\n            sobj = _(\'fortran function\')\n        elif self.objtype == \'module\':\n            sobj = _(\'fortran module\')\n            modname = \'\'\n        elif self.objtype == \'program\':\n            sobj = _(\'fortran program\')\n            modname = \'\'\n        sinmodule = (\n            _(\' in module %s\') %\n            modname) if modname and add_modules else \'\'\n        return \'%s%s (%s%s)\' % (name, self._parens, sobj, sinmodule)\n\n\nclass FortranSpecial(object):\n    def get_signature_prefix(self, sig):\n        """"""\n        May return a prefix to put before the object name in the signature.\n        """"""\n        return self.objtype + \' \'\n\n\nclass WithFortranDocFieldTransformer(object):\n    def run(self):\n        """"""Same as :meth:`sphinx.directives.ObjectDescription`\n        but using :class:`FortranDocFieldTransformer`""""""\n        if \':\' in self.name:\n            self.domain, self.objtype = self.name.split(\':\', 1)\n        else:\n            self.domain, self.objtype = \'\', self.name\n        if not hasattr(self, \'env\'):\n            self.env = self.state.document.settings.env\n        self.indexnode = addnodes.index(entries=[])\n\n        node = addnodes.desc()\n        node.document = self.state.document\n        node[\'domain\'] = self.domain\n        # \'desctype\' is a backwards compatible attribute\n        node[\'objtype\'] = node[\'desctype\'] = self.objtype\n        node[\'noindex\'] = noindex = (\'noindex\' in self.options)\n\n        self.names = []\n        signatures = self.get_signatures()\n        for i, sig in enumerate(signatures):\n            # add a signature node for each signature in the current unit\n            # and add a reference target for it\n            signode = addnodes.desc_signature(sig, \'\')\n            signode[\'first\'] = False\n            node.append(signode)\n            try:\n                # name can also be a tuple, e.g. (classname, objname);\n                # this is strictly domain-specific (i.e. no assumptions may\n                # be made in this base class)\n                name = self.handle_signature(sig, signode)\n            except ValueError:\n                # signature parsing failed\n                signode.clear()\n                signode += addnodes.desc_name(sig, sig)\n                continue  # we don\'t want an index entry here\n            if not isinstance(name[0], six.string_types):\n                name = (str(name), name[1])\n            if not noindex and name not in self.names:\n                # only add target and index entry if this is the first\n                # description of the object with this name in this desc block\n                self.names.append(name)\n                self.add_target_and_index(name, sig, signode)\n\n        modname = signode.get(\'module\')\n        typename = signode.get(\'type\')\n        contentnode = addnodes.desc_content()\n        node.append(contentnode)\n        if self.names:\n            # needed for association of version{added,changed} directives\n            self.env.temp_data[\'object\'] = self.names[0]\n        self.before_content()\n        self.state.nested_parse(self.content, self.content_offset, contentnode)\n        FortranDocFieldTransformer(\n            self,\n            modname=modname,\n            typename=typename).transform_all(contentnode)\n        self.env.temp_data[\'object\'] = None\n        self.after_content()\n        return [self.indexnode, node]\n\n\nclass FortranType(\n        FortranSpecial,\n        WithFortranDocFieldTransformer,\n        FortranObject):\n    def before_content(self):\n        FortranObject.before_content(self)\n        if self.names:\n            self.env.temp_data[\'f:type\'] = self.names[0][0].split(f_sep)[-1]\n            self.typename_set = True\n\n\nclass FortranTypeField(FortranObject):\n    # def handle_signature(self, sig, signode):\n        # """"""\n        # Transform a Fortran signature into RST nodes.\n        # Returns (fully qualified name of the thing, classname if any).\n\n        # If inside a class, the current class name is handled intelligently:\n        # * it is stripped from the displayed name if present\n        # * it is added to the full name (return value) if not present\n        # """"""\n        #m = f_sig_re.match(sig)\n        # if m is None:\n            #raise ValueError\n        #ftype, objtype, modname, typename, name, arglist = m.groups()\n        # print \'handle_signature\', ftype, objtype, modname, typename, name, arglist\n        #if not typename: typename = """"\n\n        # determine module and type\n        # modname = (modname and modname[:-1]) or self.options.get(\n            # \'module\', self.env.temp_data.get(\'f:module\'))\n        # typename = (typename and typename[:-1]) or self.options.get(\n            # \'type\', self.env.temp_data.get(\'f:type\'))\n        # print \' mod type\', modname, typename\n        # print self.objtype\n        # if self.objtype==\'typefield\' and not typename:\n            #raise ValueError\n\n        #if typename: name = typename+\'%\'+name\n\n        #fullname = name\n        # if modname:\n            #fullname = modname + f_sep + name\n\n        #signode[\'module\'] = modname\n        #signode[\'type\'] = typename\n        #signode[\'fullname\'] = fullname\n\n        # Fill node\n        #signode += addnodes.desc_name(name, name)\n        #shape = self.options.get(\'shape\')\n        #if shape: signode += nodes.Text(shape, shape)\n        #ftype = self.options.get(\'type\', ftype)\n        #attr= self.options.get(\'attr\')\n        # if ftype or attr:\n            #signode += nodes.Text(\' :: \', \' :: \')\n            #if ftype: signode += nodes.emphasis(\'\', ftype)\n            #if attr: signode += nodes.literal(\'\', \'[\'+attr+\']\')\n        # if self.content:\n            #signode += nodes.Text(\': \', \': \')\n            #argnodes, msgs = self.state.inline_text(\' \'.join(self.content), self.lineno)\n            #signode += argnodes\n            #signode += msgs\n\n        # return fullname, ftype\n\n    def before_content(self):\n        FortranObject.before_content(self)\n        lastname = self.names and self.names[-1][1]\n        if lastname and not self.env.temp_data.get(\'f:type\'):\n            self.env.temp_data[\'f:type\'] = lastname.split(f_sep)[-1]\n            self.typename_set = True\n\n\nclass FortranProgram(\n        FortranSpecial,\n        WithFortranDocFieldTransformer,\n        FortranObject):\n    pass\n\n\nclass FortranWithSig(\n        FortranSpecial,\n        WithFortranDocFieldTransformer,\n        FortranObject):\n    """"""\n    Description of a function of subroutine\n    """"""\n    _parens = \'()\'\n\n    def needs_arglist(self):\n        return True\n\n    def get_signature_prefix(self, sig):\n        """"""\n        May return a prefix to put before the object name in the signature.\n        """"""\n        return self.objtype + \' \'\n\n\nclass FortranField(Directive):\n    """"""\n    Directive to describe a change/addition/deprecation in a specific version.\n    """"""\n\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec = {\n        \'type\': directives.unchanged,\n        \'shape\': parse_shape,\n        \'attrs\': directives.unchanged,\n    }\n\n    def run(self):\n        from docutils import nodes\n        node = nodes.paragraph()\n        node += addnodes.desc_name(self.arguments[0], self.arguments[0])\n        shape = self.options.get(\'shape\')\n        if shape:\n            #node += nodes.Text(shape, shape)\n            add_shape(node, shape)\n        type = self.options.get(\'type\')\n        attrs = self.options.get(\'attrs\')\n        if type or attrs:\n            node += nodes.Text(\' :: \', \' :: \')\n            if type:\n                node += nodes.emphasis(\'\', type)\n            if attr:\n                node += nodes.literal(\'\', \'[\' + attr + \']\')\n        if self.content:\n            node += nodes.Text(\': \', \': \')\n            argnodes, msgs = self.state.inline_text(\n                \' \'.join(self.content), self.lineno)\n            node += argnodes\n            node += msgs\n        ret = [node]\n#        env = self.state.document.settings.env\n#        env.note_versionchange(node[\'type\'], node[\'version\'], node, self.lineno)\n        return ret\n\n\nclass FortranModule(Directive):\n    """"""\n    Directive to mark description of a new module.\n    """"""\n\n    has_content = False\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = False\n    option_spec = {\n        \'platform\': lambda x: x,\n        \'synopsis\': lambda x: x,\n        \'noindex\': directives.flag,\n        \'deprecated\': directives.flag,\n    }\n\n    def run(self):\n        env = self.state.document.settings.env\n        modname = self.arguments[0].strip()\n        noindex = \'noindex\' in self.options\n        env.temp_data[\'f:module\'] = modname\n        env.domaindata[\'f\'][\'modules\'][modname] = \\\n            (env.docname, self.options.get(\'synopsis\', \'\'),\n             self.options.get(\'platform\', \'\'), \'deprecated\' in self.options)\n        env.domaindata[\'f\'][\'objects\'][\'f\' + \\\n            f_sep + modname] = (env.docname, \'module\')\n        #targetnode = nodes.target(\'\', \'\', ids=[\'module-\' + modname], ismod=True)\n        targetnode = nodes.target(\n            \'\', \'\', ids=[\n                \'f\' + f_sep + modname], ismod=True)\n        self.state.document.note_explicit_target(targetnode)\n        ret = [targetnode]\n        # XXX this behavior of the module directive is a mess...\n        if \'platform\' in self.options:\n            platform = self.options[\'platform\']\n            node = nodes.paragraph()\n            node += nodes.emphasis(\'\', _(\'Platforms: \'))\n            node += nodes.Text(platform, platform)\n            ret.append(node)\n        # the synopsis isn\'t printed; in fact, it is only used in the\n        # modindex currently\n        if not noindex:\n            indextext = _(\'%s (module)\') % modname\n            # inode = addnodes.index(entries=[(\'single\', indextext,\n            # \'module-\' + modname, modname)])\n            # inode = addnodes.index(entries=[(\'single\', indextext,\n            # \'f\' + f_sep + modname, modname)])\n            inode = addnodes.index(\n                entries=[\n                    FortranCreateIndexEntry(\n                        indextext,\n                        \'f\' + f_sep + modname,\n                        modname)])\n            ret.append(inode)\n        return ret\n\n\ndef FortranCreateIndexEntry(indextext, fullname, modname):\n    # See https://github.com/sphinx-doc/sphinx/issues/2673\n    if version_info < (1, 4):\n        return (\'single\', indextext, fullname, modname)\n    else:\n        return (\'single\', indextext, fullname, modname, None)\n\n\nclass FortranCurrentModule(Directive):\n    """"""\n    This directive is just to tell Sphinx that we\'re documenting\n    stuff in module foo, but links to module foo won\'t lead here.\n    """"""\n\n    has_content = False\n    required_arguments = 0\n    optional_arguments = 1\n    final_argument_whitespace = False\n    option_spec = OrderedDict()\n\n    def run(self):\n        env = self.state.document.settings.env\n        modname = self.arguments and (\n            self.arguments[0] or self.arguments[0].strip()) or None\n        if modname:\n            env.temp_data[\'f:module\'] = None\n        else:\n            env.temp_data[\'f:module\'] = modname\n        return []\n\n\nclass FortranXRefRole(XRefRole):\n    def process_link(self, env, refnode, has_explicit_title, title, target):\n        refnode[\'f:module\'] = env.temp_data.get(\'f:module\')\n        refnode[\'f:type\'] = env.temp_data.get(\'f:type\')\n        if not has_explicit_title:\n            title = title.lstrip(\'.\')   # only has a meaning for the target\n            target = target.lstrip(\'~\')  # only has a meaning for the title\n            # if the first character is a tilde, don\'t display the module/class\n            # parts of the contents\n            if title[0:1] == \'~\':\n                title = title[1:].split(f_sep)[-1]\n            # elif \'%\' not in title and refnode[\'f:type\']:\n                #title = \'%s%%%s\'%(refnode[\'f:type\'], title)\n        # if the first character is a sep, search more specific namespaces first\n        # else search builtins first\n        if target.startswith(f_sep):\n            target = target[1:]\n            refnode[\'refspecific\'] = True\n        return title, target\n\n\nclass FortranModuleIndex(Index):\n    """"""\n    Index subclass to provide the Fortran module index.\n    """"""\n\n    name = \'modindex\'\n    localname = _(\'Fortran Module Index\')\n    shortname = _(\'fortran modules\')\n\n    def generate(self, docnames=None):\n        content = OrderedDict()\n        # list of prefixes to ignore\n        ignores = self.domain.env.config[\'modindex_common_prefix\']\n        ignores = sorted(ignores, key=len, reverse=True)\n        # list of all modules, sorted by module name\n        modules = sorted(six.iteritems(self.domain.data[\'modules\']),\n                         key=lambda x: x[0].lower())\n        # sort out collapsable modules\n        prev_modname = \'\'\n        num_toplevels = 0\n        for modname, (docname, synopsis, platforms, deprecated) in modules:\n            if docnames and docname not in docnames:\n                continue\n\n            for ignore in ignores:\n                if modname.startswith(ignore):\n                    modname = modname[len(ignore):]\n                    stripped = ignore\n                    break\n            else:\n                stripped = \'\'\n\n            # we stripped the whole module name?\n            if not modname:\n                modname, stripped = stripped, \'\'\n\n            entries = content.setdefault(modname[0].lower(), [])\n\n            package = modname.split(f_sep)[0]\n            if package != modname:\n                # it\'s a submodule\n                if prev_modname == package:\n                    # first submodule - make parent a group head\n                    entries[-1][1] = 1\n                elif not prev_modname.startswith(package):\n                    # submodule without parent in list, add dummy entry\n                    entries.append([stripped + package, 1, \'\', \'\', \'\', \'\', \'\'])\n                subtype = 2\n            else:\n                num_toplevels += 1\n                subtype = 0\n\n            qualifier = deprecated and _(\'Deprecated\') or \'\'\n            # entries.append([stripped + modname, subtype, docname,\n            #\'module-\' + stripped + modname, platforms,\n            # qualifier, synopsis])\n            entries.append([stripped + modname, subtype, docname,\n                            \'f\' + f_sep + stripped + modname, platforms,\n                            qualifier, synopsis or \'\'])\n            prev_modname = modname\n\n        # apply heuristics when to collapse modindex at page load:\n        # only collapse if number of toplevel modules is larger than\n        # number of submodules\n        collapse = len(modules) - num_toplevels < num_toplevels\n\n        # sort by first letter\n        content = sorted(six.iteritems(content))\n\n        return content, collapse\n\n\nclass FortranDomain(Domain):\n    """"""Fortran language domain.""""""\n    name = \'f\'\n    label = \'Fortran\'\n    object_types = {\n        \'program\': ObjType(_(\'program\'), \'prog\'),\n        \'type\': ObjType(_(\'type\'), \'type\'),\n        \'variable\': ObjType(_(\'variable\'), \'var\'),\n        \'function\': ObjType(_(\'function\'), \'func\'),\n        \'subroutine\': ObjType(_(\'subroutine\'), \'func\', \'subr\'),\n        \'module\': ObjType(_(\'module\'), \'mod\'),\n    }\n\n    directives = {\n        \'program\': FortranProgram,\n        \'type\': FortranType,\n        \'variable\': FortranObject,\n        \'function\': FortranWithSig,\n        \'subroutine\': FortranWithSig,\n        \'module\': FortranModule,\n        \'currentmodule\': FortranCurrentModule,\n    }\n\n    roles = {\n        \'prog\': FortranXRefRole(),\n        \'type\': FortranXRefRole(),\n        \'var\': FortranXRefRole(),\n        \'func\': FortranXRefRole(fix_parens=True),\n        \'subr\': FortranXRefRole(fix_parens=True),\n        \'mod\': FortranXRefRole(),\n    }\n    initial_data = {\n        \'objects\': OrderedDict(),  # fullname -> docname, objtype\n        \'modules\': OrderedDict(),  # modname -> docname, synopsis, platform, deprecated\n    }\n    indices = [\n        FortranModuleIndex,\n    ]\n\n    def clear_doc(self, docname):\n        for fullname, (fn, _) in list(self.data[\'objects\'].items()):\n            if fn == docname:\n                del self.data[\'objects\'][fullname]\n        for modname, (fn, _, _, _) in list(self.data[\'modules\'].items()):\n            if fn == docname:\n                del self.data[\'modules\'][modname]\n\n    def find_obj(self, env, modname, name, role, searchorder=0):\n        """"""\n        Find a Fortran object for ""name"", perhaps using the given module and/or\n        typename.\n\n        :Params:\n\n            - **searchorder**, optional: Start using relative search\n        """"""\n        # skip parens\n        if name.endswith(\'()\'):\n            name = name[:-2]\n\n        if not name:\n            return None, None\n        if f_sep in name:\n            modname, name = name.split(f_sep)\n        #modname = modname or \'_\'\n        if \'%\' in name:\n            name, tmp = name.split(\'%\')\n\n        objects = self.data[\'objects\']\n        newname = None\n        matches = []\n        objtypes = self.objtypes_for_role(role)\n        if searchorder == 1:  # :role:`/toto`\n            if role in [\'mod\', \'prog\']:\n                if \'f\' + f_sep + name not in objects:  # exact match\n                    return []\n                newname = \'f\' + f_sep + name\n            elif modname and \'f\' + f_sep + modname + f_sep + name in objects and \\\n                    objects[\'f\' + f_sep + modname + f_sep + name][1] in objtypes:\n                newname = \'f\' + f_sep + modname + f_sep + name\n            elif \'f\' + f_sep + \'_\' + f_sep + name in objects and \\\n                    objects[\'f\' + f_sep + \'_\' + f_sep + name][1] in objtypes:\n                newname = \'f\' + f_sep + \'_\' + f_sep + name\n            elif \'f\' + f_sep + name in objects and \\\n                    objects[\'f\' + f_sep + name][1] in objtypes:\n                newname = \'f\' + f_sep + name\n            elif name in objects and \\\n                    objects[name][1] in objtypes:\n                newname = name\n\n        else:  # :role:`toto`\n            # NOTE: searching for exact match, object type is not considered\n            if \'f\' + f_sep + name in objects:\n                newname = \'f\' + f_sep + name\n            elif role in [\'mod\', \'prog\']:\n                # only exact matches allowed for modules\n                return []\n            elif \'f\' + f_sep + \'_\' + f_sep + name in objects:\n                newname = \'f\' + f_sep + \'_\' + f_sep + name\n            elif modname and \'f\' + f_sep + modname + f_sep + name in objects:\n                newname = \'f\' + f_sep + modname + f_sep + name\n\n        # Last chance: fuzzy search\n        if newname is None:\n            matches = [(oname, objects[oname]) for oname in objects\n                       if oname.endswith(f_sep + name)\n                       and objects[oname][1] in objtypes]\n        else:\n            matches.append((newname, objects[newname]))\n        return matches\n\n    def resolve_xref(self, env, fromdocname, builder,\n                     type, target, node, contnode):\n        modname = node.get(\'f:module\', node.get(\'modname\'))\n        typename = node.get(\'f:type\', node.get(\'typename\'))\n        searchorder = node.hasattr(\'refspecific\') and 1 or 0\n        matches = self.find_obj(env, modname, target, type, searchorder)\n        if not matches:\n            return None\n        elif len(matches) > 1:\n            env.warn(fromdocname,\n                     \'more than one target found for cross-reference \'\n                     \'%r: %s\' % (target,\n                                 \', \'.join(match[0] for match in matches)),\n                     node.line)\n        name, obj = matches[0]\n\n        if obj[1] == \'module\':\n            # get additional info for modules\n            docname, synopsis, platform, deprecated = self.data[\'modules\'][name[1 + len(\n                f_sep):]]\n            assert docname == obj[0]\n            title = name\n            if synopsis:\n                title += \': \' + synopsis\n            if deprecated:\n                title += _(\' (deprecated)\')\n            # return make_refnode(builder, fromdocname, docname,\n                # \'module-\' + name, contnode, title)\n            return make_refnode(builder, fromdocname, docname,\n                                name, contnode, title)\n        else:\n            return make_refnode(builder, fromdocname, obj[0], name,\n                                contnode, name)\n\n    def get_objects(self):\n        for modname, info in six.iteritems(self.data[\'modules\']):\n            yield (modname, modname, \'module\', info[0], \'module-\' + modname, 0)\n        for refname, (docname, type) in six.iteritems(self.data[\'objects\']):\n            yield (refname, refname, type, docname, refname, 1)\n\n\ndef setup(app):\n    app.add_domain(FortranDomain)\n'"
tests/conftest.py,0,"b'# -*- coding: utf-8 -*-\n""""""pytest config\n================\n\nAdapted from sphinx/tests/conftest.py.\n""""""\n\nimport os\nimport shutil\nimport sys\n\nimport pytest\n\nfrom sphinx.testing.path import path\n\npytest_plugins = \'sphinx.testing.fixtures\'\n\n# Exclude \'roots\' dirs for pytest test collector\ncollect_ignore = [\'roots\']\n\n## Disable Python version-specific\n#if sys.version_info < (3,):\n#    collect_ignore += [\'py3\']\n#\n#if sys.version_info < (3, 5):\n#    collect_ignore += [\'py35\']\n\n\n@pytest.fixture(scope=\'session\')\ndef rootdir():\n    return path(os.path.dirname(__file__) or \'.\').abspath() / \'roots\'\n\n\ndef pytest_report_header(config):\n    return \'Running Sphinx test suite (with Python %s)...\' % (\n        sys.version.split()[0])\n\n\ndef _initialize_test_directory(session):\n    testroot = os.path.join(str(session.config.rootdir), \'tests\')\n    tempdir = os.path.abspath(os.getenv(\'SPHINX_TEST_TEMPDIR\',\n                              os.path.join(testroot, \'build\')))\n    os.environ[\'SPHINX_TEST_TEMPDIR\'] = tempdir\n\n    print(\'Temporary files will be placed in %s.\' % tempdir)\n\n    if os.path.exists(tempdir):\n        shutil.rmtree(tempdir)\n\n    os.makedirs(tempdir)\n\n\ndef pytest_sessionstart(session):\n    _initialize_test_directory(session)\n'"
tests/test_autodoc.py,0,"b'# -*- coding: utf-8 -*-\n""""""\ntest_fortran_autodoc\n====================\n\nTest the fortran_autodoc extension.\n\nAdapted from sphinx/tests/test_autodoc.py.\n""""""\nfrom __future__ import print_function\n\nimport pickle\nimport os\nimport warnings\nimport difflib\n\nimport pytest\n\n#from sphinx import addnodes\n\nthis_dir = os.path.dirname(__file__)\n\n\ndef checkdir(path):\n    pdir = os.path.dirname(path)\n    if not os.path.exists(pdir):\n        os.makedirs(pdir)\n\n\ndef check_result(test_name, result):\n    xml_result = result[0].pformat()\n\n    ref_file = os.path.join(this_dir,\n                            \'references\',\n                            \'test-fortran-autodoc\',\n                            test_name + \'.xml\')\n    out_file = os.path.join(this_dir,\n                            \'outputs\',\n                            \'test-fortran-autodoc\',\n                            test_name + \'.xml\')\n    if not os.path.exists(ref_file):\n        warnings.warn(\'Creating missing reference file: \' + ref_file)\n        checkdir(ref_file)\n        with open(ref_file, \'w\') as f:\n            f.write(xml_result)\n    else:\n        checkdir(out_file)\n        with open(out_file, \'w\') as f:\n            f.write(xml_result)\n        with open(ref_file) as f:\n            xml_ref = f.read()\n        xml_result = xml_result.replace(""u\'"", ""\'"")\n        equal = xml_ref == xml_result\n        assert equal, (\n                \'Invalid xml result. \\n\' +\n                \'Reference file: {}\\n\'.format(ref_file) +\n                \'Actual output: {}\\n\'.format(out_file) +\n                \'Differences:\\n\' +\n                \'\\n\'.join(difflib.context_diff(xml_ref.split(\'\\n\'),\n                                               xml_result.split(\'\\n\'))))\n\n\n@pytest.mark.sphinx(\'dummy\', testroot=\'fortran-autodoc\')\ndef test_autodoc_module_assim(app, status, warning):\n    app.builder.build_all()\n    result = pickle.loads((app.doctreedir / \'module_assim.doctree\').bytes())\n    check_result(\'module_assim\', result)\n\n\n#    utl_matsqrt = module_assim[0][2]\n#    utl_matsqrt_sig, utl_matsqrt_desc = utl_matsqrt\n#    utl_matsqrt_desc_header, utl_matsqrt_desc_params = utl_matsqrt_desc\n#    assert utl_matsqrt_sig[0].astext().strip() == \'subroutine\'\n#    assert utl_matsqrt_sig[1].astext().strip() == \'utl_matsqrt\'\n#    assert utl_matsqrt_desc_header.astext().strip() == \'Calculate square root of an error covariance matrix\'\n#    assert utl_matsqrt_desc_params[0].astext() == \'Parameters\\n\\npa (kn,kn) [real,inout] :: on entry, the original matrix; on exit, the sqrt matrix\\n\\nzsign [real,in] :: sign of the exponent\'\n#    assert utl_matsqrt_desc_params[1].astext() == \'Options\\n\\nkn [integer,in,optional/default=shape(pa,0)] :: order of the matrix\\n\\nprintinformation_opt [logical,in,optional] :: request more verbose output\'\n\n\n@pytest.mark.sphinx(\'dummy\', testroot=\'fortran-autodoc\')\ndef test_autodoc_module_generic(app, status, warning):\n    app.builder.build_all()\n    result = pickle.loads((app.doctreedir / \'module_generic.doctree\').bytes())\n    check_result(\'module_generic\', result)\n\n\n@pytest.mark.sphinx(\'dummy\', testroot=\'fortran-autodoc\')\ndef test_autodoc_misc_routines(app, status, warning):\n    app.builder.build_all()\n    result = pickle.loads((app.doctreedir / \'misc_routines.doctree\').bytes())\n    check_result(\'misc_routines\', result)\n'"
tests/test_domain.py,0,"b""\nfrom unittest import TestCase\n\nclass FortranDomainTestCase(TestCase):\n\n    pass #TODO: write unittests\n\n\n#if __name__ == '__main__':\n#    unittest.main()\n"""
doc/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# SphinxFortran documentation build configuration file, created by\n# sphinx-quickstart on Thu Oct  1 12:03:51 2015.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\nimport shlex\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.ifconfig\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.extlinks\',\n    \'sphinxfortran.fortran_domain\',\n    \'sphinxfortran.fortran_autodoc\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# Import a few things\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), os.path.abspath(\'../..\')))\nfrom setup import author, version\ndel sys.path[0]\n\n# General information about the project.\nproject = u\'SphinxFortran\'\ncopyright = u\'2010-2015, Actimar/IFREMER\'\n#author = u\'Stephane Raynaud for Actimar/IFREMER \'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'1.0\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'1.0\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only \'ja\' uses this config value\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'SphinxFortrandoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n\n# Latex figure (float) alignment\n#\'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n  (master_doc, \'SphinxFortran.tex\', u\'SphinxFortran Documentation\',\n   u\'Stephane Raynaud\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'sphinxfortran\', u\'SphinxFortran Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (master_doc, \'SphinxFortran\', u\'SphinxFortran Documentation\',\n   author, \'SphinxFortran\', \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    \'https://docs.python.org/\': None,\n    \'numpy\':(\'http://docs.scipy.org/doc/numpy\', None),\n}\n\n# Extlinks\nextlinks = {\n    \'basemap\': (\'http://matplotlib.github.com/basemap/%s\', None),\n    \'sphinx\': (\'http://sphinx.pocoo.org/%s\', None),\n    \'rstdoc\': (\'http://docutils.sourceforge.net/docs/ref/rst/%s\', None),\n    }\n\n\ndef setup(app):\n    app.add_object_type(\'confopt\', \'confopt\',\n        objname=\'configuration option\',\n        indextemplate=\'pair: %s; configuration option\')\n    app.add_object_type(\'confsec\', \'confsec\',\n        objname=\'configuration section\',\n        indextemplate=\'pair: %s; configuration section\')\n\n# autodoc\nautodoc_default_flags = [\'members\', \'undoc-members\', \'private-members\', \'show-inheritance\']\n\n'"
tests/roots/test-fortran-autodoc/conf.py,0,"b""# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nthis_dir = os.path.dirname(__file__)\nsrc_dir = os.path.abspath(os.path.join(this_dir, '..', '..', '..'))\nsys.path.insert(0, src_dir)\n\nextensions = ['sphinxfortran.fortran_domain',\n              'sphinxfortran.fortran_autodoc']\n\nmaster_doc = 'index'\nhtml_theme = 'classic'\nexclude_patterns = ['_build']\n\n# Fortran autodoc\nfortran_src = [os.path.abspath(os.path.join(this_dir, path))\n               for path in ('module_assim.f90',\n                            'module_generic.f90',\n                            'misc_routines.f90',\n                            )]\nprint fortran_src\n\n"""
