file_path,api_count,code
Source/v0.1/activeCancelation v0.1.py,0,"b'import globalQueue #Lists shared between files\nimport sampleSettings #Settings of frequency to generate\nimport createSoundFile #Lib used to make the sound file\nimport waveformGrapher #Lib used to graph the sound files.\nimport generateSounds\n\nprint ""Welcome to Active Noise Cancelation v 0.1!""\nprint ""This program is used to demonstrate the ability of two sounds canceling one another out.""\nprint ""This causes the \'sound\' output to be nothing! In other words, complete silence.""\n\nprint ""\\nVerboose mode in this program allows you to see the values printed on screen as they are added to a global queue along with other things.""\nVERBOOSE = (raw_input(""Would you like the program to run in verboose mode? (1=YES 0=NO): ""))\nglobalQueue.VERBOOSE_SETTING = VERBOOSE\n\n#Run setup function for the global lists:\nglobalQueue.initLists(globalQueue.VERBOOSE_SETTING)\n\nsampleSettings.FREQUENCY_GRABBER()\nsampleSettings.GET_DURATION()\nsampleSettings.GET_SAMPLES()\n\nprint ""\\nPreparing to generate sound file, this may take a while.""\n\ncreateSoundFile.CSV()\ncreateSoundFile.SIN_WAVE_GENERATOR(globalQueue.sampleSettings[0], globalQueue.sampleSettings[1], globalQueue.sampleSettings[2], globalQueue.createSoundFile[0])\ncreateSoundFile.INVERSE_WAVE_GENERATOR(globalQueue.sampleSettings[0], globalQueue.sampleSettings[1], globalQueue.sampleSettings[2], globalQueue.createSoundFile[0])\n\nprint ""\\nSoundwave forms have been mapped!""\nprint ""\\nPlease note: CSV\'s that were generated with over 1024 samples or over 5 seconds may require a massive amount of RAM to open.""\nprint ""To see the values of a certian sample rate, enter the sample rate you want to evaluate and reduce the time to one second.""\nprint ""If you didn\'t generate CSV\'s, several values that are of importance are listed below:""\nglobalQueue.printLists()\n\nprint ""\\nDisplaying graphs of the two waves generated to ensure they are opposite phases....""\nprint ""If the graphs do not appear to be opposite phases, please run the program again""\nprint ""NOTE: SAMPLES BELOW 10000 WILL LOOK STAGGERED ON THE GRAPH. RETRY USING A DIFFERENT RATE IF NEEDED""\nprint ""The graph has been saved locally as a file named WAVEFORMS.png""\nwaveformGrapher.graphWaveforms()\n\nprint ""\\nBegining the creation of the audio files now...""\ngenerateSounds.monoStereo()\n\nprint ""\\nWAV Files have been created successfully!""'"
Source/v0.1/createSoundFile.py,0,"b'from decimal import Decimal\nimport numpy\nimport pyaudio\nimport globalQueue\nimport sampleSettings\n\n#Take the frequency that the user wants.  Make a sweeping wave of it now.\n#So for a frequency \'x\' we need to begin at the middle of it ""x/2"" as an INT. NOT FLOAT\n#Then add one to that list until we hit the frequency value, then down to zero and back to\n#the middle of the frequency.  This is one period of the frequency.  \n\ndef CSV(): #Ask the user for a CSV preference\n    CSV = int(raw_input(""Would you like a CSV with the sample points? (0 is No, 1 is Yes): ""))\n    globalQueue.appendCreateSoundSamples(CSV,globalQueue.VERBOOSE_SETTING) #Append CSV preferences\n\n\ndef SIN_WAVE_GENERATOR(FREQUENCY, DURATION, SAMPLES, CSV): #Generate Sin Wave samples for that frequency\n    print ""\\nGENERATING SINE WAVEFORM.....""\n    SIN_SAMPLES = ((numpy.sin(2*numpy.pi*numpy.arange(SAMPLES*DURATION)*FREQUENCY/SAMPLES))) * 1000\n    if CSV == 1: numpy.savetxt(""SIN_DATA.csv"", SIN_SAMPLES, delimiter=\'\\n\') #Save them if the user wants to\n\n    MIDPOINT = SAMPLES / 2 #Midpoint of the samples (should be a positive value)\n    MIDPOINT_SAMPLE = \'%.2e\' % Decimal(SIN_SAMPLES[MIDPOINT])\n\n    globalQueue.appendSIN_WAVE_SAMPLES(SIN_SAMPLES, globalQueue.VERBOOSE_SETTING) #Append sin wave values\n\n    globalQueue.appendCreateSoundSamples(SIN_SAMPLES[0], globalQueue.VERBOOSE_SETTING) #Append the first sin value\n    globalQueue.appendCreateSoundSamples(SIN_SAMPLES[MIDPOINT], globalQueue.VERBOOSE_SETTING) #Append the midpoint value\n\ndef INVERSE_WAVE_GENERATOR(FREQUENCY, DURATION, SAMPLES, CSV): #Generate the inverse phase wave\n    print ""GENERATING INVERSE WAVEFORM.....""\n    INVERSE_SIN_SAMPLES = (-1*(numpy.sin(2*numpy.pi*numpy.arange(SAMPLES*DURATION)*FREQUENCY/SAMPLES))) * 1000 #Math for samples\n    if CSV == 1: numpy.savetxt(""INVERSE_SIN_DATA.csv"", INVERSE_SIN_SAMPLES, delimiter=\'\\n\') #Save them if wanted\n    \n    MIDPOINT = SAMPLES / 2\n    MIDPOINT_SAMPLE = \'%.2e\' % Decimal(INVERSE_SIN_SAMPLES[MIDPOINT])\n\n    globalQueue.appendINVERSE_SIN_WAVE_SAMPLES(INVERSE_SIN_SAMPLES, globalQueue.VERBOOSE_SETTING) #Append all values \n \n    globalQueue.appendCreateSoundSamples(INVERSE_SIN_SAMPLES[0], globalQueue.VERBOOSE_SETTING) #Append the first value\n    globalQueue.appendCreateSoundSamples(INVERSE_SIN_SAMPLES[MIDPOINT], globalQueue.VERBOOSE_SETTING) #Append midpoint.  Must be opposite sign!\n'"
Source/v0.1/generateSounds.py,0,"b'import globalQueue\nimport numpy\nimport scipy\nimport scipy.io.wavfile\n\n\n#This library is used to create the actual files of audio from the samples of the sin wave and inverse sin wave.\n#STRUCTUTRE\n#   L or R or COMBINE\n#   Generate sin\n#   generate inverse\n#   save files\n#       name them sin and inverse sine if monos\n#       name them sin-inverse sin if stereo.\n\ndef SIN_GENERATION():\n    print ""SIN GENERATING......""\n    SIN_SAMPLES = []\n    SIN_SAMPLES.append(globalQueue.SIN_WAVE_SAMPLES)\n    SIN_SAMPLES = numpy.asarray(SIN_SAMPLES, dtype=numpy.int16)\n    scipy.io.wavfile.write(\'SIN.wav\', globalQueue.sampleSettings[2], SIN_SAMPLES)\n\ndef INVERSE_GENERATION():\n    print ""INVERSE GENERATING.....""\n    INVERSE_SAMPLES = []\n    INVERSE_SAMPLES.append(globalQueue.INVERSE_SIN_WAVE_SAMPLES)\n    INVERSE_SAMPLES = numpy.asarray(INVERSE_SAMPLES, dtype=numpy.int16)\n    scipy.io.wavfile.write(\'INVERSE_SIN.wav\', globalQueue.sampleSettings[2], INVERSE_SAMPLES)\n    \n    \n\n\ndef SIN_AND_INVERSE_GENERATION():\n    print ""ADDING""\n\n\ndef monoStereo():\n    MONO_STEREO = int(raw_input(""Would you like to use one channel for each sound or one combined sound file? (0 for mono, 1 for stereo)""))\n    globalQueue.appendGenerateSounds(MONO_STEREO, globalQueue.VERBOOSE_SETTING)\n\n    if MONO_STEREO == 0:\n        print ""MONO SELECTED.  The SIN wave will be the left speaker and the inverse phase will be the right speaker seperately""\n        print ""Please hold while the sounds are created.""\n\n        SIN_GENERATION()\n        INVERSE_GENERATION()\n\n    if MONO_STEREO == 1:\n        print ""STEREO SELECTED. The SIN wave and inverse phase wave will be saved as two different files!""\n        print ""Please hold while the sounds are created.""\n\n        SIN_AND_INVERSE_GENERATION()\n\n'"
Source/v0.1/globalQueue.py,0,"b'#This file is a ""RAM"" for the porgram.  All variables used in each library gets its own list.\n#As things are collected, the values get added into the list. \n#The order of elements in the list is defined by the order of functions in the file.\n#So for the settings library, we have FREQUENCY_GRABBER and GET_DURATION in that order.\n#The FREQUENCY_GRABBER info comes first, then the GET_DURATION info.\n\n\n#Initalization funtion to make each library specific list:\nVERBOOSE_SETTING = \'0\' #changes to one if the user picks run verboose.\n\ndef initLists(VERBOOSE): #VERBOOSE allows the user to see the lists as the program runs.\n    global sampleSettings #List for sample options\n    global createSoundFile #List with peaks, valleys, and midpoints\n    global SIN_WAVE_SAMPLES #List of all sin wave points\n    global INVERSE_SIN_WAVE_SAMPLES #List of all inverse wave points\n    global generateSounds\n    sampleSettings = [] \n    createSoundFile = []        #INITS \n    SIN_WAVE_SAMPLES = []\n    INVERSE_SIN_WAVE_SAMPLES = []\n    generateSounds = []\n\n    if int(VERBOOSE) == 1:\n        #PRINTS ALL LISTS FROM INIT!!\n        print ""\\nsamplesSettings: "" + str(sampleSettings[:]).rjust(20, )\n        print ""createSoundFile: "" + str(createSoundFile[:]).rjust(20, )\n        print ""SinWaveSamples"" + str(SIN_WAVE_SAMPLES[:]).rjust(20, )\n        print ""InverseSampple"" + str(INVERSE_SIN_WAVE_SAMPLES[:]).rjust(20, )\n        print ""GenerateSounds"" + str(generateSounds[:]).rjust(20, )\n        print ""Lists Initalized, moving on...\\n""\n\ndef printLists():\n    #Print out the lists with their current values at any point.\n    createSoundFile_FORMATTED = [\'%.1e\' % elem for elem in createSoundFile]\n    print ""\\nsamplesSettings: "" + (str(sampleSettings[:])).rjust(30, )\n    try:\n        print ""createSoundFile: "" +  (\'[\' + str(createSoundFile_FORMATTED[2]) + \']\' +  \' \' + \'[\' + str(createSoundFile_FORMATTED[4]) + \']\').rjust(30, )\n    except:\n        print ""createSoundFile: "" + str(createSoundFile[:]).rjust(30) + \'\\n\'\n\ndef appendSampleSettings(value, VERBOOSE): #add value to the settings of each wave\n    sampleSettings.append(value)\n    if int(VERBOOSE) == 1:\n        printLists()\n\ndef appendCreateSoundSamples(value, VERBOOSE): #Add value to the creation points\n    createSoundFile.append(value)\n    if int(VERBOOSE) == 1:\n        printLists()\n\ndef appendSIN_WAVE_SAMPLES(value, VERBOOSE): #Add value to the sin wave samples\n    SIN_WAVE_SAMPLES.append(value)\n    if int(VERBOOSE) == 1:\n        print SIN_WAVE_SAMPLES[:]\n\n\ndef appendINVERSE_SIN_WAVE_SAMPLES(value, VERBOOSE): #Add value to inverse phase samples\n    INVERSE_SIN_WAVE_SAMPLES.append(value)\n    if int(VERBOOSE) == 1:\n        print INVERSE_SIN_WAVE_SAMPLES[:]\n\ndef appendGenerateSounds(value, VERBOOSE): #Add Values to the generate sounds file.\n    generateSounds.append(value)\n    if int(VERBOOSE == 1):\n        print generateSounds[:]\n'"
Source/v0.1/sampleSettings.py,0,"b'import globalQueue\n\n#This is a proof of concept test for active noise cancling.  \n#Each file will act as a library, calling functions from each one as needed.\n#This file gathers settings about the frequency which we want to cancel.\n\n#Function to take a frequency of the sound to be generated\ndef FREQUENCY_GRABBER():\n    global GENERATE_FREQUENCY\n    GENERATE_FREQUENCY = int(raw_input(""\\nENTER FREQUENCY IN HERZT (IN BASE 0: 10kHz is 10000): ""))\n\n    if GENERATE_FREQUENCY < 10: #Confirm if the sound is valid.\n        print ""FREQUENCY TOO LOW! ENTER NEW FREQUENCY""\n        FREQUENCY_GRABBER() #Recursively call back to pick again.\n    elif GENERATE_FREQUENCY > 20000: #Confirm again.\n        print ""FREQUENCY TOO HIGH! ENTER NEW FREQUENCY""\n        FREQUENCY_GRABBER() #Recursively call back to pick again.\n\n    print ""\\nSelected frequency is "" + str(GENERATE_FREQUENCY) + ""hz""\n    #Display a confirmation of what the user picked.\n\n    RESPONSE = raw_input(""Is this correct? Yes or No: "") #Confirm if the selection is right or not.\n    if RESPONSE.lower() == ""no"" or RESPONSE.lower() == ""n"": #Check answer\n        print ""ENTER A NEW FREQUENCY""\n        FREQUENCY_GRABBER() #If the user fucked up, they are redirected to pick a new sound again.\n    #BUG: WHEN RESELECTING TWICE IN ONE RUN THE APP DOES NOT CORRECTLY RUN THE FUNCTION\n    else:\n        globalQueue.appendSampleSettings(GENERATE_FREQUENCY,globalQueue.VERBOOSE_SETTING) #APPEND THE VALUE TO THE GLOBAL QUEUE\n\ndef GET_DURATION(): #Get time for the frequency to play in the program\n    global TIME\n    TIME = int(raw_input(""\\nENTER A TIME DURATION OF THE FREQUENCY IN SECONDS: "")) #Get duration\n    if TIME > 0: #Check for a valid duratio!\n        print ""A "" + str(GENERATE_FREQUENCY) + ""hz frequency will play for "" + str(TIME) + "" seconds.""\n    if TIME < 0:\n        print ""MUST HAVE A DURATION OVER 0!""\n        GET_DURATION()\n    \n    globalQueue.appendSampleSettings(TIME,globalQueue.VERBOOSE_SETTING) #APPEND THE VALUE TO THE GLOBAL QUEUE!\n\ndef GET_SAMPLES():\n    global SAMPLES\n    print ""NOTE: SAMPLES UNDER 1024 WILL LOOK STRANGE.  SAMPLES ABOVE 192000 WILL AS WELL.""\n    SAMPLES = int(raw_input(""\\nEnter a number of samples to take for each wave to be generated.  (A good value is 72000 for fast computing): ""))\n    if SAMPLES <= 0:\n        print ""MUST HAVE A SAMPLE RATE OVER 0!""\n        GET_SAMPLES()\n    globalQueue.appendSampleSettings(SAMPLES, globalQueue.VERBOOSE_SETTING)\n\n'"
Source/v0.1/waveformGrapher.py,0,"b'#This is the graphical plotting for each wave. Calculates the values for each one again.\n#Puts the values into localized lists and prints them out to the plot\n#Thiis function is a basic implimentation of the matplotlib and can be modified slightly for\n#clearer output readings.  \n\n#BUG The plot tends to get very squished when using higher frequencies!\n#BUG Try to impliment a log function for plotting\n\nimport matplotlib.pyplot as plt\nimport numpy \nimport globalQueue\n\n\ndef graphWaveforms():\n    SAMPLES = globalQueue.sampleSettings[2] #Local Vars for easier use/calling\n    FREQUENCY = globalQueue.sampleSettings[0]\n    DURATION = globalQueue.sampleSettings[1]\n\n    SIN_SAMPLES =  (numpy.sin(2*numpy.pi*numpy.arange(SAMPLES*DURATION)*FREQUENCY/SAMPLES)) #Make our sin samples\n    INVERSE_SIN_SAMPLES = -1*SIN_SAMPLES #Inverse sin samples should just be a negated version of the sin samples globally\n    #so this method of creation is ok.\n\n    TIME = (numpy.arange(0.0, FREQUENCY/2, 1) / 100) * 2 * 2 #Calculations\n    SIN_WAVE = (SIN_SAMPLES[0:FREQUENCY/2]) * FREQUENCY #Calculations\n    INVERSE_SIN = (INVERSE_SIN_SAMPLES[0:FREQUENCY/2]) * FREQUENCY #Calculations\n\n    plt.plot(TIME, SIN_WAVE, color=\'b\')\n    plt.plot(TIME, INVERSE_SIN, color=\'r\')\n\n    plt.xlabel(\'TIME (S)\')\n    plt.ylabel(\'FREQUENCY CHANGE\')\n    plt.title(\'WAVEFORM COMPARISONS\')      #Plot settings\n    plt.grid(True)\n    plt.savefig(""/WAVEFORMS.png"")\n    plt.show() #DRAW IT!\n\n'"
