file_path,api_count,code
PyGLM_performance.py,0,"b'#import numpy, glm\n\nimport time\n\nstart_time = time.time()\nimport glm\nglm_import_time = time.time() - start_time\n\nstart_time = time.time()\nimport numpy\nnumpy_import_time = time.time() - start_time\n\nnumpy_import_time /= glm_import_time\nnumpy_import_time = (1. / numpy_import_time) * 100\nglm_import_time = 100\n\nREPETITIONS = 100000\n\ndef test_func(func, *args, **kw):\n    before = time.time()\n    for i in range(REPETITIONS):\n        func(*args, **kw)\n    return time.time() - before\n\nglm_create_mat4 = lambda: glm.mat4()\n\nnumpy_create_mat4 = lambda: numpy.identity(4, dtype=numpy.float32)\n\nglm_v3 = glm.vec3()\nnumpy_v3 = numpy.array((0,0,0), dtype=numpy.float32)\n\nglm_v4 = glm.vec4()\nnumpy_v4 = numpy.zeros((4,), dtype=numpy.float32)#numpy.array((0,0,0,0), dtype=numpy.float32)\n\nglm_m44 = glm.mat4()\nnumpy_m44 = numpy.identity(4, dtype=numpy.float32)\n\nglm_dot = lambda: glm.dot(glm_v3, glm_v3)\nnumpy_dot = lambda: numpy.vdot(numpy_v3, numpy_v3)\n\nglm_transpose = lambda: glm.transpose(glm_m44)\nnumpy_transpose = lambda: numpy.transpose(numpy_m44)\n\nglm_mul_v4_v4 = lambda: glm_v4 * glm_v4\nnumpy_mul_v4_v4 = lambda: numpy_v4 * numpy_v4\n\nglm_mul_m44_v4 = lambda: glm_m44 * glm_v4\nnumpy_mul_m44_v4 = lambda: numpy_m44 * numpy_v4\n\nglm_mat4_getitem = lambda: glm_m44[0]\nnumpy_mat4_getitem = lambda: numpy_m44[0]\n\nprint(""How PyGLM\'s performance roughly compares to NumPy\'s performance:"")\n\nprint(""instruction\\t | np speed (%)\\t | glm speed (%)\\t "")\n\ndef print_instruction(string_, np_func, glm_func):\n    np_result = test_func(np_func)\n    glm_result = test_func(glm_func)\n    np_result /= glm_result\n    np_result = (1. / np_result) * 100\n    glm_result = 100\n\n    print(string_ + "" | {: 6.2f}\\t | {: 6.2f}"".format(np_result, glm_result))\n\nprint(""import\\t\\t | {: 6.2f}\\t | {: 6.2f}"".format(numpy_import_time, glm_import_time))\n\ninstructions = [\n    (""mat4()\\t\\t"", numpy_create_mat4, glm_create_mat4),\n    (""dot(vec3, vec3)\\t"", numpy_dot, glm_dot),\n    (""transpose(mat4)\\t"", numpy_transpose, glm_transpose),\n    (""vec4 * vec4\\t"", numpy_mul_v4_v4, glm_mul_v4_v4),\n    (""mat4 * vec4\\t"", numpy_mul_m44_v4, glm_mul_m44_v4),\n    (""mat4[0]\\t\\t"", numpy_mat4_getitem, glm_mat4_getitem),\n    ]\n\nfor s, np_f, glm_f in instructions:\n    print_instruction(s, np_f, glm_f)\n'"
PyGLM_test.py,0,"b'import glm, sys, random, time, copy\n\nglm.silence(0)\n\n## type checking definitions ##\nPyGLM_DT_UNKNOWN\t= 0x0000000\nPyGLM_DT_FLOAT\t\t= 0x0000001\nPyGLM_DT_DOUBLE\t\t= 0x0000002\nPyGLM_DT_INT\t\t= 0x0000004\nPyGLM_DT_UINT\t\t= 0x0000008\nPyGLM_DT_INT8\t\t= 0x0000010\nPyGLM_DT_UINT8\t\t= 0x0000020\nPyGLM_DT_INT16\t\t= 0x0000040\nPyGLM_DT_UINT16\t\t= 0x0000080\nPyGLM_DT_INT64\t\t= 0x0000100\nPyGLM_DT_UINT64\t\t= 0x0000200\nPyGLM_DT_BOOL\t\t= 0x0000400\n\nPyGLM_SHAPE_2x2\t\t= 0x0000800\nPyGLM_SHAPE_2x3\t\t= 0x0001000\nPyGLM_SHAPE_2x4\t\t= 0x0002000\nPyGLM_SHAPE_3x2\t\t= 0x0004000\nPyGLM_SHAPE_3x3\t\t= 0x0008000\nPyGLM_SHAPE_3x4\t\t= 0x0010000\nPyGLM_SHAPE_4x2\t\t= 0x0020000\nPyGLM_SHAPE_4x3\t\t= 0x0040000\nPyGLM_SHAPE_4x4\t\t= 0x0080000\n\nPyGLM_SHAPE_1\t\t= 0x0100000\nPyGLM_SHAPE_2\t\t= 0x0200000\nPyGLM_SHAPE_3\t\t= 0x0400000\nPyGLM_SHAPE_4\t\t= 0x0800000\n\nPyGLM_T_VEC\t\t\t= 0x1000000\nPyGLM_T_MVEC\t\t= 0x2000000\nPyGLM_T_MAT\t\t\t= 0x4000000\nPyGLM_T_QUA\t\t\t= 0x8000000\n\nPyGLM_T_NUMBER\t\t= 0x10000000\n\nPyGLM_T_ANY_VEC\t    = (PyGLM_T_VEC | PyGLM_T_MVEC)\nPyGLM_T_ANY_ARR\t    = (PyGLM_T_ANY_VEC | PyGLM_T_QUA)\n\nPyGLM_SHAPE_SQUARE  = (PyGLM_SHAPE_2x2 | PyGLM_SHAPE_3x3 | PyGLM_SHAPE_4x4)\n\nPyGLM_SHAPE_2xM\t    = (PyGLM_SHAPE_2x2 | PyGLM_SHAPE_2x3 | PyGLM_SHAPE_2x4)\nPyGLM_SHAPE_3xM\t    = (PyGLM_SHAPE_3x2 | PyGLM_SHAPE_3x3 | PyGLM_SHAPE_3x4)\nPyGLM_SHAPE_4xM\t    = (PyGLM_SHAPE_4x2 | PyGLM_SHAPE_4x3 | PyGLM_SHAPE_4x4)\n\nPyGLM_DT_ALL\t    = ((1 << 11) - 1)\nPyGLM_SHAPE_ALL\t\t= (((1 << 13) - 1) << 11)\nPyGLM_T_ALL\t\t\t= (((1 << 5) - 1) << 24)\n\nPyGLM_ALL           = (PyGLM_DT_ALL | PyGLM_SHAPE_ALL | PyGLM_T_ALL)\n##/type checking definitions ##\n\n#def get_info(num):\n#    glob = globals()\n#    vars_ = [x for x in glob if x.startswith(""PyGLM_"") and not ""ANY"" in x and not ""xM"" in x and not ""ALL"" in x and not ""SQUARE"" in x]\n#    out = []\n#    for var in vars_:\n#        if (glob[var] & num):\n#            out.append(var)\n\n#    return "", "".join(out)\n\n#def get_info_of(obj):\n#    return get_info(glm._get_type_info(PyGLM_ALL, obj))\n\n#gio = get_info_of\n\nprint(""Testing PyGLM..."")\nstart_time = time.time()\n\ndatatypes = (""float"", ""double"", ""int"", ""glm::uint"", ""glm::i64"", ""glm::u64"", ""glm::i16"", ""glm::u16"", ""glm::i8"", ""glm::u8"", ""bool"")\nprefixes = (""f"", ""d"", ""i"", ""u"", ""i64"", ""u64"", ""i16"", ""u16"", ""i8"", ""u8"", ""b"")\n\nsuffixes = ""fFiIqQsSuUB""\n\nvector_type_ids = tuple(range(len(datatypes)))\n\nmatrix_type_ids = tuple(range(4))\n\nquat_type_ids = tuple(range(2))\n\nvector_type_dict = {}\n\nvector_length_dict = {}\n\nvector_types = []\n\nmatrix_type_dict = {}\n\nmatrix_length_dict = {}\n\nmatrix_types = []\n\nquat_type_dict = {}\n\nquat_types = []\n\nfor type_id in vector_type_ids:\n    vector_type_dict[type_id] = []\n    this_list = vector_type_dict[type_id]\n\n    for L in range(1, 5):\n        tp = getattr(glm, ""{T}vec{L}"".format(T=prefixes[type_id], L=L))\n        vll = vector_length_dict.get(L, [])\n        vll.append(tp)\n        vector_length_dict[L] = vll\n        this_list.append(tp)\n\n    vector_types += this_list\n\n\nfor type_id in matrix_type_ids:\n    matrix_type_dict[type_id] = []\n    this_list = matrix_type_dict[type_id]\n\n    for C in range(2, 5):\n        for R in range(2, 5):\n            tp = getattr(glm, ""{T}mat{C}x{R}"".format(T=prefixes[type_id], C=C, R=R))\n            mll = matrix_length_dict.get((C,R), [])\n            mll.append(tp)\n            matrix_length_dict[(C,R)] = mll\n            this_list.append(tp)\n\n    matrix_types += this_list\n\nfor type_id in quat_type_ids:\n    quat_type_dict[type_id] = []\n    this_list = quat_type_dict[type_id]\n\n    this_list.append(getattr(glm, ""{T}quat"".format(T=prefixes[type_id])))\n\n    quat_types += this_list\n\nobj_gen = lambda types: (T() for T in types)\n\ndef list_replace(list_, x, y):\n    list_copy = list(list_)\n    for i in range(len(list_copy)):\n        list_copy[i] = list_copy[i].replace(x, y)\n    return list_copy\n\nrandf = lambda: random.random()*100\nrandfs = lambda: randf()-50\n\ndef get_args(arg_string, type_, rand_func=None):\n    if not rand_func:\n        if type_ in ""IQSU"":\n            rand_func = randf\n        else:\n            rand_func = randfs\n    args = []\n    for arg in arg_string:\n        if arg == ""N"":\n            if type_ in ""fF"":\n                args.append(float(rand_func()))\n            if type_ in ""iqsu"":\n                args.append(int(rand_func()))\n            if type_ in ""IQSU"":\n                args.append(int(randf()))\n            if type_ == ""B"":\n                args.append(random.choice((True, False)))\n\n        elif arg == ""Ni"":\n            args.append(int(rand_func()))\n\n        elif arg == ""NB"":\n            args.append(random.choice((True, False)))\n\n        elif ""V"" in arg:\n            if len(arg) == 3 and arg[2] in ""fFiB"":\n                T = prefixes[suffixes.index(arg[2])]\n            else:\n                T = prefixes[suffixes.index(type_)]\n\n            L = int(arg[1])\n            args.append(getattr(glm, ""{T}vec{L}"".format(T=T, L=L))(*([rand_func()] * L)))\n\n        elif arg == ""Q"":\n            args.append(getattr(glm, ""{T}quat"".format(T=prefixes[suffixes.index(type_)]))(rand_func(), rand_func(), rand_func(), rand_func()))\n\n        elif ""M"" in arg:\n            if len(arg) == 4 and arg[3] in ""fFiI"":\n                T = prefixes[suffixes.index(arg[3])]\n            else:\n                T = prefixes[suffixes.index(type_)]\n\n            n = int(arg[1])\n            m = int(arg[2])\n            args.append(getattr(glm, ""{T}mat{n}x{m}"".format(T=prefixes[suffixes.index(type_)], n=n, m=m))(*[rand_func() for i in range(n*m)]))\n\n    return args\n\n\ndef gen_args(args_string):\n    if ""#u"" in args_string:\n        rand_func = randf\n        args_string = args_string.replace(""#u"", """")\n    elif ""#p"" in args_string:\n        rand_func = lambda: randf() + 1\n        args_string = args_string.replace(""#p"", """")\n    elif ""#d"" in args_string:\n        rand_func = random.random\n        args_string = args_string.replace(""#d"", """")\n    else:\n        rand_func = None\n\n    if ""__"" in args_string:\n        arg_part, type_part = args_string.split(""__"")\n        parts = arg_part.split(""_"")\n        types = type_part\n    else:\n        parts = args_string.split(""_"")\n        types = suffixes\n    \n    for part in parts:\n        arg_strings = []\n        current_text = """"\n        for char in part:\n            if not char in ""1234"" + ""fFiB"":\n                if current_text != """":\n                    arg_strings.append(current_text)\n                    current_text = """"\n            current_text += char\n        if current_text:\n            arg_strings.append(current_text)\n        \n        if ""N"" in arg_strings and not (""V"" in arg_strings or ""M"" in arg_strings):\n            yield get_args(arg_strings, ""F"" if ""F"" in types else ""f"" if ""f"" in types else ""i"" if ""i"" in types else ""I"" if ""I"" in types else types[0], rand_func)\n        elif ""V"" in arg_strings:\n            for T in types:\n                for L in range(1, 5):\n                    yield get_args(list_replace(arg_strings, ""V"", ""V{L}"".format(L=L)), T, rand_func)\n\n        elif ""Vf"" in arg_strings:\n            for L in range(1, 5):\n                yield get_args(list_replace(arg_strings, ""Vf"", ""V{L}"".format(L=L)), ""f"", rand_func)\n\n        elif ""VF"" in arg_strings:\n            for L in range(1, 5):\n                yield get_args(list_replace(arg_strings, ""VF"", ""V{L}"".format(L=L)), ""F"", rand_func)\n\n        elif ""Vi"" in arg_strings:\n            for L in range(1, 5):\n                yield get_args(list_replace(arg_strings, ""Vi"", ""V{L}"".format(L=L)), ""i"", rand_func)\n\n        elif ""VB"" in arg_strings:\n            for L in range(1, 5):\n                yield get_args(list_replace(arg_strings, ""VB"", ""V{L}"".format(L=L)), ""B"", lambda: random.choice((True, False)))\n\n        elif ""V1"" in arg_strings or ""V2"" in arg_strings or ""V3"" in arg_strings or ""V4"" in arg_strings or ""M22"" in arg_strings or ""M23"" in arg_strings or ""M24"" in arg_strings or ""M32"" in arg_strings or ""M33"" in arg_strings or ""M34"" in arg_strings or ""M42"" in arg_strings or ""M43"" in arg_strings or ""M44"" in arg_strings:\n            for T in types:\n                yield get_args(arg_strings, T, rand_func)\n\n        elif ""Q"" in arg_strings:\n            for T in types:\n                if not T in ""fF"":\n                    continue\n                yield get_args(arg_strings, T, rand_func)\n\n        elif ""M"" in arg_strings:\n            for T in types:\n                if not T in ""fFiI"":\n                    continue\n                for C in range(2,5):\n                    for R in range(2,5):\n                        yield get_args(list_replace(arg_strings, ""M"", ""M{C}{R}"".format(C=C,R=R)), T, rand_func)\n\n        elif ""Mf"" in arg_strings:\n            for C in range(2,5):\n                for R in range(2,5):\n                    yield get_args(list_replace(arg_strings, ""Mf"", ""M{C}{R}"".format(C=C,R=R)), ""f"", rand_func)\n\n        elif ""MF"" in arg_strings:\n            for C in range(2,5):\n                for R in range(2,5):\n                    yield get_args(list_replace(arg_strings, ""MF"", ""M{C}{R}"".format(C=C,R=R)), ""F"", rand_func)\n\n        elif ""-"" in arg_strings:\n            yield ()\n\ndef gen_obj(args_string):\n    for args in gen_args(args_string):\n        yield args[0]\n\n\n#v1 = glm.vec1()\n#v2 = glm.vec2()\n#v3 = glm.vec3()\n#v4 = glm.vec4()\n\n#vectors = [v1, v2, v3, v4]\n\n#vector_types = [glm.vec1, glm.vec2, glm.vec3, glm.vec4]\n\n#m22 = glm.mat2x2()\n#m23 = glm.mat2x3()\n#m24 = glm.mat2x4()\n#m32 = glm.mat3x2()\n#m33 = glm.mat3x3()\n#m34 = glm.mat3x4()\n#m42 = glm.mat4x2()\n#m43 = glm.mat4x3()\n#m44 = glm.mat4x4()\n\n#matrices = [m22, m23, m24, m32, m33, m34, m42, m43, m44]\n\n#matrix_types = [glm.mat2x2, glm.mat2x3, glm.mat2x4, glm.mat3x2, glm.mat3x3, glm.mat3x4, glm.mat4x2, glm.mat4x3, glm.mat4x4]\n\n#q = glm.quat()\n\n#all_types = vector_types + matrix_types + [glm.quat]\n\n#all_type_objects = vectors + matrices + [q]\n\n#get_obj_generator = lambda types: (x() for x in types)\n\nclass FAssertionError(Exception):\n    pass\n\ndef fassert(func, args):\n    try:\n        return func(*args)\n    except:\n        raise FAssertionError(""{} raised {} with {}"".format(func, sys.exc_info()[1], repr(args)))\n\ndef fail(*args):\n    raise FAssertionError(""Failed with "" + str(args)) \n# Specific #\nassert isinstance(glm.version, str)\nassert isinstance(glm.license, str)\n#/Specific #\n\n# Initialization #\n## vec1\nfor args in gen_args(""#u-_N""): # need to add support for _V1_V2_V3_V4\n    for T in vector_length_dict[1]:\n        fassert(T, args)\n\n## vec2\nfor args in gen_args(""#u-_N_NN_V2""):\n    for T in vector_length_dict[2]:\n        fassert(T, args)\n\nfor args in gen_args(""#uV2V3_V2V4""):\n    fassert(type(args[0]), args[1:])\n\n## vec3\nfor args in gen_args(""#u-_N_NNN_V3""):\n    for T in vector_length_dict[3]:\n        fassert(T, args)\n\nfor args in gen_args(""#uV3V4_V3NV2_V3V2N""):\n    fassert(type(args[0]), args[1:])\n\n## vec4\nfor args in gen_args(""#u-_N_NNNN_V4""):\n    for T in vector_length_dict[4]:\n        fassert(T, args)\n\nfor args in gen_args(""#uV4V2NN_V4NV2N_V4NNV2_V4NV3_V4V3N""):\n    fassert(type(args[0]), args[1:])\n\n## mat\nfor C in range(2, 5):\n    for R in range(2, 5):\n        for args in gen_args(""#u-_N_"" + ""N""*(C*R) + ""_M{C}{R}__fFiI"".format(C=C, R=R)): # need support for _M\n            for T in matrix_length_dict[(C,R)]:\n                fassert(T, args)\n\n        for args in gen_args(""#uM{C}{R}"".format(C=C, R=R) + ""V{R}"".format(R=R)*C + ""_"" + ""_"".join([""M{C}{R}M{c}{r}"".format(C=C, R=R, c=c, r=r) for c in range(2, 5) for r in range(2,5)]) + ""__fFiI""):\n            fassert(type(args[0]), args[1:])\n\n## quat\nfor args in gen_args(""#u-_V3_M33_M44_NV3_V3V3_NNNN_Q__f""): # need support for conversion constructors\n    fassert(glm.quat, args)\n\n## dquat\nfor args in gen_args(""#u-_V3_M33_M44_NV3_V3V3_NNNN_Q__F""): # need support for conversion constructors\n    fassert(glm.dquat, args)\n\n## array\nfor args in gen_args(""V_M_Q_VV_MM_QQ_VVV_MMM_QQQ""):\n    fassert(glm.array, args)\n\nassert glm.array([glm.vec4() for x in range(10)])\nassert glm.array(tuple([glm.vec4() for x in range(10)]))\nassert glm.array({x : glm.vec4() for x in range(10)}.values())\nassert glm.array(memoryview(glm.array([glm.vec4() for x in range(10)])))\n\nassert glm.array([glm.quat() for x in range(10)])\nassert glm.array(tuple([glm.quat() for x in range(10)]))\nassert glm.array({x : glm.quat() for x in range(10)}.values())\nassert glm.array(memoryview(glm.array([glm.quat() for x in range(10)])))\n\nassert glm.array([glm.mat4() for x in range(10)])\nassert glm.array(tuple([glm.mat4() for x in range(10)]))\nassert glm.array({x : glm.mat4() for x in range(10)}.values())\nassert glm.array(memoryview(glm.array([glm.mat4() for x in range(10)])))\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert len(arr) == 2, arr\nassert arr.typecode == ""f"", arr\nassert arr.dtype == ""float32"", arr\nassert arr.dt_size == 4, arr\nassert arr.itemsize == arr.dt_size * 4 * 4, arr\nassert arr.ptr, arr\nassert arr.nbytes == arr.itemsize * len(arr), arr\nassert arr.element_type == glm.mat4, arr\n\n# repr #\nglm_locals = {a : getattr(glm, a) for a in dir(glm)}\nfor T in vector_types + matrix_types + quat_types:\n    fassert(lambda o: eval(repr(o), glm_locals), (T(),))\n\narr = glm.array(glm.vec4(*[-1.23457e+06]*4), glm.vec4(*[-7.65432e+06]*4))\narr2 = glm.array(glm.quat(*[-1.23457e+06]*4), glm.quat(*[-7.65432e+06]*4))\narr3 = glm.array(glm.mat4(*[-1.23457e+06]*16), glm.mat4(*[-7.65432e+06]*16))\nassert repr(arr), arr\nassert repr(arr2), arr2\nassert repr(arr3), arr3\nassert str(arr), arr\nassert str(arr2), arr2\nassert str(arr3), arr3\n\narr = glm.array(glm.vec4(*[1]*4), glm.vec4(*[2]*4))\narr2 = glm.array(glm.quat(*[1]*4), glm.quat(*[2]*4))\narr3 = glm.array(glm.mat4(*[1]*16), glm.mat4(*[2]*16))\nassert eval(repr(arr), glm_locals) == arr, (arr, repr(arr), eval(repr(arr), glm_locals))\nassert eval(repr(arr2), glm_locals) == arr2, (arr2, repr(arr2), eval(repr(arr2), glm_locals))\nassert eval(repr(arr3), glm_locals) == arr3, (arr3, repr(arr3), eval(repr(arr3), glm_locals))\n#/repr #\n\n# neg #\nfor obj in gen_obj(""V_M_Q__fFiqsu""):\n    fassert(obj.__neg__, ())\n#/neg #\n\n# pos #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__pos__, ())\n#/pos #\n\n# abs #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__pos__, ())\n#/abs #\n\n# add #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__add__, (obj,))\n\narr = glm.array(glm.mat4())\nfassert(arr.__add__, (arr,))\nfassert((arr+arr).__add__, (arr,))\n#/add #\n\n# sub #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__sub__, (obj,))\n#/sub #\n\n# mul #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__mul__, (1,))\n\narr = glm.array(glm.mat4())\nfassert(arr.__mul__, (3,))\nfassert((arr*4).__mul__, (2,))\n#/mul #\n\n# div #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__truediv__, (1,))\n\nfor obj in gen_obj(""V__iqsuIQSU""):\n    try:\n        obj.__truediv__(type(obj)(0))\n        fail(obj)\n    except ZeroDivisionError:\n        pass\n\nfor obj in gen_obj(""V_M_Q__iqsuIQSU""):\n    try:\n        obj.__truediv__(0)\n        fail(obj)\n    except ZeroDivisionError:\n        pass\n#/div #\n\n# mod #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__mod__, (1,))\n#/mod #\n\n# floordiv #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__floordiv__, (1,))\n#/floordiv #\n\n# divmod #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__divmod__, (1,))\n#/divmod #\n\n# pow #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__pow__, (obj,))\n    fassert(obj.__pow__, (obj, obj))\n#/pow #\n\n# iadd #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__iadd__, (obj,))\n    \narr = glm.array(glm.mat4())\nfassert(arr.__iadd__, (arr,))\nfassert(arr.__iadd__, (arr,))\n#/iadd #\n\n# isub #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__isub__, (obj,))\n#/isub #\n\n# imul #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__imul__, (1,))\n\narr = glm.array(glm.mat4())\nfassert(arr.__imul__, (3,))\nfassert(arr.__imul__, (3,))\n#/imul #\n\n# idiv #\nfor obj in gen_obj(""V_M_Q__fFiqsuIQSU""):\n    fassert(obj.__itruediv__, (1,))\n#/idiv #\n\n# imod #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__imod__, (1,))\n#/imod #\n\n# ifloordiv #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__ifloordiv__, (1,))\n#/ifloordiv #\n\n# ipow #\nfor obj in gen_obj(""V__fF""):\n    fassert(obj.__ipow__, (obj,))\n#/ipow #\n\n# str #\nfor obj in gen_obj(""V_M_Q""):\n    assert str(obj), obj\n#/str #\n\n# repr #\nfor obj in gen_obj(""V_M_Q""):\n    assert repr(obj), obj\n#/repr #\n\n# len #\nfor obj in gen_obj(""V_M_Q""):\n    assert len(obj), obj\n\narr = glm.array(glm.mat4())\narr2 = arr + arr\nassert len(arr) == 1, arr\nassert len(arr2) == 2, arr2\n#/len #\n\n# getitem #\nfor obj in gen_obj(""V_M_Q""):\n    for i in range(len(obj)):\n        assert obj[i] != None, obj\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert arr[0] == glm.mat4(), arr\nassert arr[1] == glm.mat4(2) == arr[-1], arr\n#/getitem #\n\n# setitem #\nfor obj in gen_obj(""V_M_Q""):\n    for i in range(len(obj)):\n        fassert(obj.__setitem__,(i, obj[i]))\n\narr = glm.array(glm.mat4(), glm.mat4(2))\narr[0] = glm.mat4(3)\nassert arr[0] == glm.mat4(3), arr\n#/setitem #\n\n# contains #\nfor obj in gen_obj(""V_M_Q""):\n    assert obj[0] in obj, obj\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert glm.mat4(2) in arr and not glm.mat4(3) in arr, arr\n#/contains #\n\n# Richcompare #\n## EQ\nfor obj in gen_obj(""V_M_Q""):\n    assert obj == type(obj)(obj), obj\n\narr = glm.array(glm.mat4(), glm.mat4(2))\narr2 = glm.array(glm.mat4(), glm.mat4(2))\narr3 = glm.array(glm.mat4(), glm.mat4(2), glm.mat4(0))\nassert arr == arr2 and not arr == arr3, (arr, arr2, arr3)\n\n## NE\nfor obj in gen_obj(""#uV_M__fFiqsuIQSU""):\n    assert obj != (obj + 1), obj\n\nfor obj in gen_obj(""V_M__B""):\n    assert obj != (not obj), obj\n\nfor obj in gen_obj(""Q""):\n    assert obj != (1,0,0,0)\n\narr = glm.array(glm.mat4(), glm.mat4(2))\narr2 = glm.array(glm.mat4(), glm.mat4(2))\narr3 = glm.array(glm.mat4(), glm.mat4(2), glm.mat4(0))\nassert not arr != arr2 and arr != arr3, (arr, arr2, arr3)\n\n## LT\nfor obj in gen_obj(""#uV__fFiqsuIQSU""):\n    assert all(obj < (obj + 1)) and not any(obj < obj), obj\n\n## LE\nfor obj in gen_obj(""#uV__fFiqsuIQSU""):\n    assert all(obj <= obj) and all(obj <= (obj + 1)) and not any((obj + 1) <= obj), obj\n\n## GT\nfor obj in gen_obj(""#uV__fFiqsuIQSU""):\n    assert all((obj + 1) > obj) and not any(obj > obj), obj\n\n## GE\nfor obj in gen_obj(""#uV__fFiqsuIQSU""):\n    assert all(obj >= obj) and all((obj + 1) >= obj) and not any(obj >= (obj + 1)), obj\n#/Richcompare #\n\n# iter #\nfor obj in gen_obj(""V_M_Q""):\n    fassert(iter, (obj,))\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert list(arr) == arr.to_list(), arr\n#/iter #\n\n# buffer protocol #\ndef check_buffer_protocol(type_, shape, format):\n    obj = type_()\n    memview = memoryview(obj)\n    assert shape == memview.shape\n    assert format == memview.format\n\nfor t, s, f in (\n    (glm.vec1, (1,), ""f""),\n    (glm.vec2, (2,), ""f""),\n    (glm.vec3, (3,), ""f""),\n    (glm.vec4, (4,), ""f""),\n    \n    (glm.dvec1, (1,), ""d""),\n    (glm.dvec2, (2,), ""d""),\n    (glm.dvec3, (3,), ""d""),\n    (glm.dvec4, (4,), ""d""),\n\n    (glm.ivec1, (1,), ""i""),\n    (glm.ivec2, (2,), ""i""),\n    (glm.ivec3, (3,), ""i""),\n    (glm.ivec4, (4,), ""i""),\n\n    (glm.uvec1, (1,), ""I""),\n    (glm.uvec2, (2,), ""I""),\n    (glm.uvec3, (3,), ""I""),\n    (glm.uvec4, (4,), ""I""),\n    \n    (glm.i8vec1, (1,), ""b""),\n    (glm.i8vec2, (2,), ""b""),\n    (glm.i8vec3, (3,), ""b""),\n    (glm.i8vec4, (4,), ""b""),\n    \n    (glm.u8vec1, (1,), ""B""),\n    (glm.u8vec2, (2,), ""B""),\n    (glm.u8vec3, (3,), ""B""),\n    (glm.u8vec4, (4,), ""B""),\n    \n    (glm.i16vec1, (1,), ""h""),\n    (glm.i16vec2, (2,), ""h""),\n    (glm.i16vec3, (3,), ""h""),\n    (glm.i16vec4, (4,), ""h""),\n    \n    (glm.u16vec1, (1,), ""H""),\n    (glm.u16vec2, (2,), ""H""),\n    (glm.u16vec3, (3,), ""H""),\n    (glm.u16vec4, (4,), ""H""),\n\n    (glm.i64vec1, (1,), ""q""),\n    (glm.i64vec2, (2,), ""q""),\n    (glm.i64vec3, (3,), ""q""),\n    (glm.i64vec4, (4,), ""q""),\n    \n    (glm.u64vec1, (1,), ""Q""),\n    (glm.u64vec2, (2,), ""Q""),\n    (glm.u64vec3, (3,), ""Q""),\n    (glm.u64vec4, (4,), ""Q""),\n    \n    (glm.bvec1, (1,), ""?""),\n    (glm.bvec2, (2,), ""?""),\n    (glm.bvec3, (3,), ""?""),\n    (glm.bvec4, (4,), ""?""),\n    \n    (glm.mat2x2, (2, 2), ""f""),\n    (glm.mat2x3, (2, 3), ""f""),\n    (glm.mat2x4, (2, 4), ""f""),\n    (glm.mat3x2, (3, 2), ""f""),\n    (glm.mat3x3, (3, 3), ""f""),\n    (glm.mat3x4, (3, 4), ""f""),\n    (glm.mat4x2, (4, 2), ""f""),\n    (glm.mat4x3, (4, 3), ""f""),\n    (glm.mat4x4, (4, 4), ""f""),\n    \n    \n    (glm.dmat2x2, (2, 2), ""d""),\n    (glm.dmat2x3, (2, 3), ""d""),\n    (glm.dmat2x4, (2, 4), ""d""),\n    (glm.dmat3x2, (3, 2), ""d""),\n    (glm.dmat3x3, (3, 3), ""d""),\n    (glm.dmat3x4, (3, 4), ""d""),\n    (glm.dmat4x2, (4, 2), ""d""),\n    (glm.dmat4x3, (4, 3), ""d""),\n    (glm.dmat4x4, (4, 4), ""d""),\n    \n    \n    (glm.imat2x2, (2, 2), ""i""),\n    (glm.imat2x3, (2, 3), ""i""),\n    (glm.imat2x4, (2, 4), ""i""),\n    (glm.imat3x2, (3, 2), ""i""),\n    (glm.imat3x3, (3, 3), ""i""),\n    (glm.imat3x4, (3, 4), ""i""),\n    (glm.imat4x2, (4, 2), ""i""),\n    (glm.imat4x3, (4, 3), ""i""),\n    (glm.imat4x4, (4, 4), ""i""),\n    \n    \n    (glm.umat2x2, (2, 2), ""I""),\n    (glm.umat2x3, (2, 3), ""I""),\n    (glm.umat2x4, (2, 4), ""I""),\n    (glm.umat3x2, (3, 2), ""I""),\n    (glm.umat3x3, (3, 3), ""I""),\n    (glm.umat3x4, (3, 4), ""I""),\n    (glm.umat4x2, (4, 2), ""I""),\n    (glm.umat4x3, (4, 3), ""I""),\n    (glm.umat4x4, (4, 4), ""I""),\n    \n    (glm.quat, (4,), ""f""),\n    \n    (glm.dquat, (4,), ""d""),\n    ):\n    check_buffer_protocol(t,s,f)\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nmv = memoryview(arr)\nassert glm.array(mv) == arr, arr\n#/buffer protocol #\n\n# lists and tuples #\nfor tp, arg in (\n    (glm.vec1, (1,)),\n    (glm.vec2, (1, 2,)),\n    (glm.vec3, (1, 2, 3,)),\n    (glm.vec4, (1, 2, 3, 4)),\n    (glm.vec1, [1]),\n    (glm.vec2, [1, 2]),\n    (glm.vec3, [1, 2, 3]),\n    (glm.vec4, [1, 2, 3, 4]),\n    (glm.mat2x2, ((1, 2), (3, 4))),\n    (glm.mat2x3, ((1, 2, 3), (4, 5, 6))),\n    (glm.mat2x4, ((1, 2, 3, 4), (5, 6, 7, 8))),\n    (glm.mat3x2, ((1, 2), (3, 4), (5, 6))),\n    (glm.mat3x3, ((1, 2, 3), (4, 5, 6), (7, 8, 9))),\n    (glm.mat3x4, ((1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12))),\n    (glm.mat4x2, ((1, 2), (3, 4), (5, 6), (7, 8))),\n    (glm.mat4x3, ((1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12))),\n    (glm.mat4x4, ((1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16))),\n    (glm.quat, (1, 2, 3, 4)),\n    ):\n    fassert(tp, [arg]);\n#/lists and tuples #\n\n# copy module #\nfor args in gen_args(""V_M_Q""):\n    fassert(copy.copy, args)\n    fassert(copy.deepcopy, args)\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert copy.copy(arr) == arr, arr\nassert copy.deepcopy(arr) == arr, arr\n#/copy module #\n\n# to_list #\nfor args in gen_args(""V_Q""):\n    for arg in args:\n        assert arg.to_list() == [x for x in arg]\n\nfor args in gen_args(""M""):\n    for arg in args:\n        assert arg.to_list() == [[y for y in x] for x in arg]\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert arr.to_list() == [glm.mat4(), glm.mat4(2)]\n#/to_list #\n\n# to_tuple #\nfor args in gen_args(""V_Q""):\n    for arg in args:\n        assert arg.to_tuple() == tuple([x for x in arg])\n\nfor args in gen_args(""M""):\n    for arg in args:\n        assert arg.to_tuple() == tuple([tuple([y for y in x]) for x in arg])\n\narr = glm.array(glm.mat4(), glm.mat4(2))\nassert arr.to_tuple() == (glm.mat4(), glm.mat4(2))\n#/to_tuple #\n\n## DETAIL ##\n\n# func_packing #\nfassert(glm.packDouble2x32, (glm.uvec2(randf()),))\nfassert(glm.packUnorm2x16, (glm.vec2(randfs()),))\nfassert(glm.packSnorm2x16, (glm.vec2(randfs()),))\nfassert(glm.packSnorm4x8, (glm.vec4(randfs()),))\nfassert(glm.packUnorm4x8, (glm.vec4(randfs()),))\nfassert(glm.packHalf2x16, (glm.vec2(randfs()),))\nfassert(glm.unpackDouble2x32, (randfs(),))\nfassert(glm.unpackUnorm2x16, (int(randf()),))\nfassert(glm.unpackSnorm2x16, (int(randf()),))\nfassert(glm.unpackUnorm4x8, (int(randf()),))\nfassert(glm.unpackSnorm4x8, (int(randf()),))\nfassert(glm.unpackHalf2x16, (int(randf()),))\n#/func_packing #\n\n# func_integer #\nfor args in gen_args(""#uVVV__I""):\n    fassert(glm.uaddCarry, args)\n\nfor args in gen_args(""#uVVV__I""):\n    fassert(glm.usubBorrow, args)\n\nfor args in gen_args(""#uVVVV__I""):\n    fassert(glm.umulExtended, args)\n\nfor args in gen_args(""#uVVVV__i""):\n    fassert(glm.imulExtended, args)\n\nfor args in gen_args(""#uNNN_VNN__i""):\n    fassert(glm.bitfieldExtract, args)\n\nfor args in gen_args(""#uNNNN_VVNN__i""):\n    fassert(glm.bitfieldInsert, args)\n\nfor args in gen_args(""#uV_N__I""):\n    fassert(glm.bitfieldReverse, args)\n\nfor args in gen_args(""#uV_N__i""):\n    fassert(glm.bitCount, args)\n    fassert(glm.findLSB, args)\n    fassert(glm.findMSB, args)\n#/func_integer #\n\n# func_vector_relational #\nfor args in gen_args(""#uVV_QQ_NNNi_VfVfNi_VFVFNi_MfMfNi_MFMFNi""): # need to add support for _MM\n    fassert(glm.equal, args)\n    fassert(glm.notEqual, args)\n\nfor args in gen_args(""#uVV""):\n    fassert(glm.lessThan, args)\n    fassert(glm.lessThanEqual, args)\n\nfor args in gen_args(""#uV__B""):\n    fassert(glm.any, args)\n    fassert(glm.all, args)\n    fassert(glm.not_, args)\n#/func_vector_relational #\n\n# func_exponential #\nfor args in gen_args(""VV_QN_NN__fF""):\n    fassert(glm.pow, args)\n\nfor args in gen_args(""N_V_Q__fF""):\n    fassert(glm.exp, args)\n    fassert(glm.log, args)\n    fassert(glm.sqrt, args)\n\nfor args in gen_args(""N_V__fF""):\n    fassert(glm.exp2, args)\n    fassert(glm.log2, args)\n    fassert(glm.inversesqrt, args)\n#/func_exponential #\n\n    \n# func_common #\nfor args in gen_args(""N_V__fF""):\n    fassert(glm.abs, args)\n    fassert(glm.sign, args)\n    fassert(glm.floor, args)\n    fassert(glm.trunc, args)\n    fassert(glm.round, args)\n    fassert(glm.roundEven, args)\n    fassert(glm.ceil, args)\n    fassert(glm.fract, args)\n\nfor args in gen_args(""NN_VV_VN__fF""):\n    fassert(glm.mod, args)\n\nfor args in gen_args(""NN_VV_VN_NNN_VVV_NNNN_VVVV__fFiqsuIQSU""):\n    fassert(glm.min, args)\n    fassert(glm.max, args)\n\nfor args in gen_args(""NN_VV_VN_NNN_VVV_NNNN_VVVV__fF""):\n    fassert(glm.fmin, args)\n    fassert(glm.fmax, args)\n\nfor args in gen_args(""NNN_VVV_VNN__fF""):\n    fassert(glm.clamp, args)\n\nfor args in list(gen_args(""NNNB_NNN_QQN__fF"")) + list(gen_args(""VVN_VVVf_VVVF_VVVB"")): # need to add support for _MMN_MMMf_MMMF\n    fassert(glm.mix, args)\n\nfor args in gen_args(""NN_NV_VV""):\n    fassert(glm.step, args)\n\nfor args in gen_args(""NNN_NNV_VVV__fF""):\n    fassert(glm.smoothstep, args)\n\nfor args in gen_args(""N_V_Q__fF""):\n    fassert(glm.isnan, args)\n    fassert(glm.isinf, args)\n\nfassert(glm.fma, ((randfs(), randfs(), randfs())))\n\nfor args in gen_args(""NNi_VVi__fF""):\n    fassert(glm.frexp, args)\n\nfor args in gen_args(""VVi__fF""):\n    fassert(glm.ldexp, args)\n#/func_common #\n\n# func_geometric #\nfor args in gen_args(""N_V_Q__fF""):\n    fassert(glm.length, args)\n\nfor args in gen_args(""NN_VV__fF""):\n    fassert(glm.distance, args)\n\nfor args in gen_args(""NN_VV_QQ__fF""):\n    fassert(glm.dot, args)\n\nfor args in gen_args(""V3V3_QQ__fF""):\n    fassert(glm.cross, args)\n\nfor args in gen_args(""V_Q__fF""):\n    fassert(glm.normalize, args)\n\nfor args in gen_args(""NNN_VVV__fF""):\n    fassert(glm.faceforward, args)\n\nfor args in gen_args(""NN_VV__fF""):\n    fassert(glm.reflect, args)\n\nfor args in gen_args(""NNN_VVN__fF""):\n    fassert(glm.refract, args)\n#/func_geometric #\n\n# func_matrix #\nfor args in gen_args(""MM__fF""):\n    fassert(glm.matrixCompMult, args)\n\nfor args in gen_args(""V2V2_V2V3_V2V4_V3V2_V3V3_V3V4_V4V2_V4V3_V4V4__fF""):\n    fassert(glm.outerProduct, args)\n\nfor args in gen_args(""M__fF""):\n    fassert(glm.transpose, args)\n\nfor args in gen_args(""M22_M33_M44__fF""):\n    fassert(glm.determinant, args)\n\nfor args in gen_args(""M22_M33_M44_Q__fF""):\n    fassert(glm.inverse, args)\n#/func_matrix #\n\n# func_trigonometric #\nfor args in gen_args(""N_V__fF""):\n    fassert(glm.radians, args)\n    fassert(glm.degrees, args)\n    fassert(glm.sin, args)\n    fassert(glm.cos, args)\n    fassert(glm.tan, args)\n    fassert(glm.asin, args)\n    fassert(glm.acos, args)\n    fassert(glm.sinh, args)\n    fassert(glm.cosh, args)\n    fassert(glm.tanh, args)\n    fassert(glm.asinh, args)\n    fassert(glm.acosh, args)\n    fassert(glm.atanh, args)\n\nfor args in gen_args(""NN_VV_N_V__fF""):\n    fassert(glm.atan, args)\n#/func_trigonometric #\n##/DETAIL ##\n\n## EXTENSIONS ##\n# color_space #\nfor args in gen_args(""V_VN__fF""):\n    fassert(glm.convertLinearToSRGB, args)\n    fassert(glm.convertSRGBToLinear, args)\n#/color_space #\n\n# constants #\nfassert(glm.epsilon, (()))\nfassert(glm.zero, (()))\nfassert(glm.one, (()))\nfassert(glm.pi, (()))\nfassert(glm.two_pi, (()))\nfassert(glm.root_pi, (()))\nfassert(glm.half_pi, (()))\nfassert(glm.three_over_two_pi, (()))\nfassert(glm.quarter_pi, (()))\nfassert(glm.one_over_pi, (()))\nfassert(glm.one_over_two_pi, (()))\nfassert(glm.two_over_pi, (()))\nfassert(glm.four_over_pi, (()))\nfassert(glm.two_over_root_pi, (()))\nfassert(glm.one_over_root_two, (()))\nfassert(glm.root_half_pi, (()))\nfassert(glm.root_two_pi, (()))\nfassert(glm.root_ln_four, (()))\nfassert(glm.e, (()))\nfassert(glm.euler, (()))\nfassert(glm.root_two, (()))\nfassert(glm.root_three, (()))\nfassert(glm.root_five, (()))\nfassert(glm.ln_two, (()))\nfassert(glm.ln_ten, (()))\nfassert(glm.ln_ln_two, (()))\nfassert(glm.third, (()))\nfassert(glm.two_thirds, (()))\nfassert(glm.golden_ratio, (()))\n#/constants #\n\n# epsilon #\nfor args in gen_args(""NNN_VVN_QQN_VVV__fF""):\n    fassert(glm.epsilonEqual, args)\n    fassert(glm.epsilonNotEqual, args)\n#/epsilon #\n\n# integer #\nfor args in gen_args(""#uN_V__fF""):\n    fassert(glm.iround, args)\n    fassert(glm.uround, args)\n#/integer #\n\n# matrix_inverse #\nfor args in gen_args(""M33_M44__fF""):\n    fassert(glm.affineInverse, args)\n\nfor args in gen_args(""M22_M33_M44__fF""):\n    fassert(glm.inverseTranspose, args)\n#/matrix_inverse #\n\n# matrix_transform #\nfor type_ in matrix_types:\n    fassert(glm.identity, (type_,))\n\nfor args in gen_args(""M44V3__fF""):\n    fassert(glm.translate, args)\n    fassert(glm.scale, args)\n    fassert(glm.scale_slow, args)\n\nfor args in gen_args(""M44NV3_QNV3__fF""):\n    fassert(glm.rotate, args)\n\nfor args in gen_args(""M44NV3__fF""):\n    fassert(glm.rotate_slow, args)\n\nfor args in gen_args(""NNNN_NNNNNN""):\n    fassert(glm.ortho, args)\n\nfor args in gen_args(""NNNNNN""):\n    fassert(glm.orthoLH_ZO, args)\n    fassert(glm.orthoLH_NO, args)\n    fassert(glm.orthoRH_ZO, args)\n    fassert(glm.orthoRH_NO, args)\n    fassert(glm.orthoZO, args)\n    fassert(glm.orthoNO, args)\n    fassert(glm.orthoLH, args)\n    fassert(glm.orthoRH, args)\n    fassert(glm.frustum, args)\n    fassert(glm.frustumLH_ZO, args)\n    fassert(glm.frustumLH_NO, args)\n    fassert(glm.frustumRH_ZO, args)\n    fassert(glm.frustumRH_NO, args)\n    fassert(glm.frustumZO, args)\n    fassert(glm.frustumNO, args)\n    fassert(glm.frustumLH, args)\n    fassert(glm.frustumRH, args)\n\nfor args in gen_args(""NNNN""):\n    fassert(glm.perspective, args)\n    fassert(glm.perspectiveLH_ZO, args)\n    fassert(glm.perspectiveLH_NO, args)\n    fassert(glm.perspectiveRH_ZO, args)\n    fassert(glm.perspectiveRH_NO, args)\n    fassert(glm.perspectiveZO, args)\n    fassert(glm.perspectiveNO, args)\n    fassert(glm.perspectiveLH, args)\n    fassert(glm.perspectiveRH, args)\n\nfor args in gen_args(""#uNNNNN""):\n    fassert(glm.perspectiveFov, args)\n    fassert(glm.perspectiveFovLH_ZO, args)\n    fassert(glm.perspectiveFovLH_NO, args)\n    fassert(glm.perspectiveFovRH_ZO, args)\n    fassert(glm.perspectiveFovRH_NO, args)\n    fassert(glm.perspectiveFovZO, args)\n    fassert(glm.perspectiveFovNO, args)\n    fassert(glm.perspectiveFovLH, args)\n    fassert(glm.perspectiveFovRH, args)\n\nfor args in gen_args(""NNN""):\n    fassert(glm.infinitePerspective, args)\n    fassert(glm.infinitePerspectiveRH, args)\n    fassert(glm.infinitePerspectiveLH, args)\n\nfor args in gen_args(""NNN_NNNN""):\n    fassert(glm.tweakedInfinitePerspective, args)\n\nfor args in gen_args(""V3M44M44V4__fF""):\n    fassert(glm.project, args)\n    fassert(glm.projectNO, args)\n    fassert(glm.projectZO, args)\n    fassert(glm.unProject, args)\n    fassert(glm.unProjectNO, args)\n    fassert(glm.unProjectZO, args)\n\nfor args in gen_args(""#pV2V2V4__fF""):\n    fassert(glm.pickMatrix, args)\n\nfor args in gen_args(""V3V3V3__fF""):\n    fassert(glm.lookAt, args)\n    fassert(glm.lookAtRH, args)\n    fassert(glm.lookAtLH, args)\n#/matrix_transform #\n\n# quaternion #\nfor args in gen_args(""V3V3__fF""):\n    fassert(glm.quatLookAt, args)\n    fassert(glm.quatLookAtLH, args)\n    fassert(glm.quatLookAtRH, args)\n\nfor args in gen_args(""#dQQN__fF""):\n    fassert(glm.lerp, args)\n\nfor args in gen_args(""QQN__fF""):\n    fassert(glm.slerp, args)\n\nfor args in gen_args(""Q""):\n    fassert(glm.conjugate, args)\n    fassert(glm.eulerAngles, args)\n    fassert(glm.roll, args)\n    fassert(glm.pitch, args)\n    fassert(glm.yaw, args)\n    fassert(glm.mat3_cast, args)\n    fassert(glm.mat4_cast, args)\n    fassert(glm.angle, args)\n    fassert(glm.axis, args)\n\nfor args in gen_args(""M33_M44__fF""):\n    fassert(glm.quat_cast, args)\n\nfor args in gen_args(""NV3__fF""):\n    fassert(glm.angleAxis, args)\n#/quaternion #\n\n# matrix_access #\nfor T_id in matrix_type_ids:\n    T = prefixes[T_id]\n    for C in range(2, 5):\n        for R in range(2, 5):\n            m = getattr(glm, ""{T}mat{C}x{R}"".format(T=T,C=C,R=R))()\n            row_i = random.randrange(R)\n            row_v = getattr(glm, ""{T}vec{C}"".format(T=T, C=C))()\n            column_i = random.randrange(C)\n            column_v = getattr(glm, ""{T}vec{R}"".format(T=T, R=R))()\n            fassert(glm.row, (m, row_i))\n            fassert(glm.row, (m, row_i, row_v))\n            fassert(glm.column, (m, column_i))\n            fassert(glm.column, (m, column_i, column_v))\n#/matrix_access #\n\n# noise #\nfor args in gen_args(""V2_V3_V4_V2V2_V3V3_V4V4__fF""):\n    fassert(glm.perlin, args)\n\nfor args in gen_args(""V2_V3_V4__fF""):\n    fassert(glm.simplex, args)\n#/noise #\n\n# packing #\nfassert(glm.packInt2x8, (glm.i8vec2(),))\nfassert(glm.unpackInt2x8, (0,))\nfassert(glm.packInt4x8, (glm.i8vec4(),))\nfassert(glm.unpackInt4x8, (0,))\nfassert(glm.packInt2x16, (glm.i16vec2(),))\nfassert(glm.unpackInt2x16, (0,))\nfassert(glm.packInt4x16, (glm.i16vec4(),))\nfassert(glm.unpackInt4x16, (0,))\nfassert(glm.packInt2x32, (glm.i32vec2(),))\nfassert(glm.unpackInt2x32, (0,))\nfassert(glm.packUint2x8, (glm.u8vec2(),))\nfassert(glm.unpackUint2x8, (0,))\nfassert(glm.packUint4x8, (glm.u8vec4(),))\nfassert(glm.unpackUint4x8, (0,))\nfassert(glm.packUint2x16, (glm.u16vec2(),))\nfassert(glm.unpackUint2x16, (0,))\nfassert(glm.packUint4x16, (glm.u16vec4(),))\nfassert(glm.unpackUint4x16, (0,))\nfassert(glm.packUint2x32, (glm.u32vec2(),))\nfassert(glm.unpackUint2x32, (0,))\nfassert(glm.packHalf1x16, (0.,))\nfassert(glm.unpackHalf1x16, (0,))\nfassert(glm.packHalf4x16, (glm.vec4(),))\nfassert(glm.unpackHalf4x16, (0,))\nfassert(glm.packUnorm1x8, (0.,))\nfassert(glm.unpackUnorm1x8, (0,))\nfassert(glm.packUnorm2x8, (glm.vec2(),))\nfassert(glm.unpackUnorm2x8, (0,))\nfassert(glm.packUnorm1x16, (0.,))\nfassert(glm.unpackUnorm1x16, (0,))\nfassert(glm.packUnorm4x16, (glm.vec4(),))\nfassert(glm.unpackUnorm4x16, (0,))\nfassert(glm.packUnorm3x10_1x2, (glm.vec4(),))\nfassert(glm.unpackUnorm3x10_1x2, (0,))\nfassert(glm.packUnorm2x4, (glm.vec2(),))\nfassert(glm.unpackUnorm2x4, (0,))\nfassert(glm.packUnorm4x4, (glm.vec4(),))\nfassert(glm.unpackUnorm4x4, (0,))\nfassert(glm.packUnorm1x5_1x6_1x5, (glm.vec3(),))\nfassert(glm.unpackUnorm1x5_1x6_1x5, (0,))\nfassert(glm.packUnorm3x5_1x1, (glm.vec4(),))\nfassert(glm.unpackUnorm3x5_1x1, (0,))\nfassert(glm.packUnorm2x3_1x2, (glm.vec3(),))\nfassert(glm.unpackUnorm2x3_1x2, (0,))\nfassert(glm.packSnorm1x8, (0.,))\nfassert(glm.unpackSnorm1x8, (0,))\nfassert(glm.packSnorm2x8, (glm.vec2(),))\nfassert(glm.unpackSnorm2x8, (0,))\nfassert(glm.packSnorm1x16, (0.,))\nfassert(glm.unpackSnorm1x16, (0,))\nfassert(glm.packSnorm4x16, (glm.vec4(),))\nfassert(glm.unpackSnorm4x16, (0,))\nfassert(glm.packSnorm3x10_1x2, (glm.vec4(),))\nfassert(glm.unpackSnorm3x10_1x2, (0,))\nfassert(glm.packI3x10_1x2, (glm.ivec4(),))\nfassert(glm.unpackI3x10_1x2, (0,))\nfassert(glm.packU3x10_1x2, (glm.uvec4(),))\nfassert(glm.unpackU3x10_1x2, (0,))\nfassert(glm.packF2x11_1x10, (glm.vec3(),))\nfassert(glm.unpackF2x11_1x10, (0,))\nfassert(glm.packF3x9_E1x5, (glm.vec3(),))\nfassert(glm.unpackF3x9_E1x5, (0,))\n\nfor args in gen_args(""V3__fF""):\n    fassert(glm.packRGBM, args)\n\nfor args in gen_args(""V4__fF""):\n    fassert(glm.unpackRGBM, args)\n\nfor args in gen_args(""V__f""):\n    fassert(glm.packHalf, args)\n\nfor args in gen_args(""V__S""):\n    fassert(glm.unpackHalf, args)\n#/packing #\n\n# random #\nfor args in gen_args(""NN_VV__fFiqsuIQSU""):\n    comp = args[0] > args[1]\n    if type(comp) != bool: comp = any(comp)\n    if len(args) == 2 and comp:\n        args = (args[1], args[0])\n    fassert(glm.linearRand, args)\n    fassert(glm.gaussRand, args)\n\nfor args in gen_args(""#pN""):\n    fassert(glm.circularRand, args)\n    fassert(glm.sphericalRand, args)\n    fassert(glm.diskRand, args)\n    fassert(glm.ballRand, args)\n#/random #\n\n# round #\nfor args in gen_args(""N_V__iqsu""):\n    # need to add support for isPowerOfTwo\n    fassert(glm.isPowerOfTwo, args)\n    fassert(glm.ceilPowerOfTwo, args)\n    fassert(glm.floorPowerOfTwo, args)\n    fassert(glm.roundPowerOfTwo, args)\n\nfor args in gen_args(""#pNN_VV__iqsu""):\n    # need to add support for isMultiple\n    fassert(glm.ceilMultiple, args)\n    fassert(glm.floorMultiple, args)\n    fassert(glm.roundMultiple, args)\n#/round #\n\n# reciprocal #\nfor args in gen_args(""N_V__fF""):\n    fassert(glm.sec, args)\n    fassert(glm.csc, args)\n    fassert(glm.cot, args)\n    fassert(glm.asec, args)\n    fassert(glm.acsc, args)\n    fassert(glm.acot, args)\n    fassert(glm.sech, args)\n    fassert(glm.csch, args)\n    fassert(glm.coth, args)\n    fassert(glm.asech, args)\n    fassert(glm.acsch, args)\n    fassert(glm.acoth, args)\n#/reciprocal #\n\n# type_ptr #\nfor args in gen_args(""V2_V3_V4_M_Q""):\n    fassert(glm.value_ptr, args)\n\nfor args in list(gen_args(""V_M_Q"")) + [(x,) for x in (list(vector_types) + list(matrix_types) + list(quat_types))]:\n    fassert(glm.sizeof, args)\n\nfor L in range(2, 5):\n    for T in prefixes:\n        vec = getattr(glm, ""{T}vec{L}"".format(T=T,L=L))()\n        ptr = glm.value_ptr(vec)\n        fassert(getattr(glm, ""make_vec{L}"".format(L=L)), (ptr,))\n\nfor C in range(2, 5):\n    for R in range(2, 5):\n        for T_id in matrix_type_ids:\n            T = prefixes[T_id]\n            mat = getattr(glm, ""{T}mat{C}x{R}"".format(T=T,C=C,R=R))()\n            ptr = glm.value_ptr(mat)\n            fassert(getattr(glm, ""make_mat{C}x{R}"".format(C=C,R=R)), (ptr,))\n\nfor T_id in quat_type_ids:\n    T = prefixes[T_id]\n    quat = getattr(glm, ""{T}quat"".format(T=T))()\n    ptr = glm.value_ptr(quat)\n    fassert(glm.make_quat, (ptr,))\n#/type_ptr #\n\n# ulp #\nfor args in gen_args(""#uN_V_NNi_VNi_VVi__fF""):\n    fassert(glm.next_float, args)\n    fassert(glm.prev_float, args)\n\nfor args in gen_args(""NN_VV__fF""):\n    fassert(glm.float_distance, args)\n#/ulp #\n##/EXTENSIONS ##\n    \n## UNSTABLE EXTENSIONS ##\n# polar_coordinates #\nfor args in gen_args(""V3__fF""):\n    fassert(glm.polar, args)\n    \nfor args in gen_args(""V2__fF""):\n    fassert(glm.euclidean, args)\n#/polar_coordinates #\n\n# norm #\nfor args in gen_args(""VV__fF""):\n    fassert(glm.distance2, args)\n\nfor args in gen_args(""V_N__fF""):\n    fassert(glm.length2, args)\n\nfor args in gen_args(""V3V3_V3__fF""):\n    fassert(glm.l1Norm, args)\n\nfor args in gen_args(""V3V3_V3__fF""):\n    fassert(glm.l2Norm, args)\n\nfor args in gen_args(""#uV3V3Ni_V3Ni__fF""):\n    fassert(glm.lxNorm, args)\n#/norm #\n\n# matrix_decompose #\nfor args in gen_args(""M44V3QV3V3V4__fF""):\n    fassert(glm.decompose, args)\n#/matrix_decompose #\n##/UNSTABLE EXTENSIONS ##\n    \nprint(""Finished tests in {:.3g}s"".format(time.time()-start_time))\n'"
setup.py,0,"b'""""""A setuptools based setup module.\nSee:\nhttps://packaging.python.org/en/latest/distributing.html\nhttps://github.com/pypa/sampleproject\n""""""\n\nimport sys\nif sys.version_info.major < 3 or sys.version_info.minor < 5:\n    raise Exception(""PyGLM (0.5.0b1+) requires Python 3.5 or higher. Please install PyGLM==0.4.8b1"")\n\n# Always prefer setuptools over distutils\nfrom setuptools import setup, find_packages, Extension\n# To use a consistent encoding\nfrom codecs import open\nfrom os import path\n\nimport re\n\nmodule1 = Extension(\'glm\',\n                    sources = [\'PyGLM.cpp\'], include_dirs=[""glm/""], extra_compile_args=[\'-std=c++11\'])\n\nhere = path.abspath(path.dirname(__file__))\n\nwith open(path.join(here, ""version.h"")) as f:\n    __version__ = re.search(\'""(.*?)""\', f.read()).group().strip(\'""\')\n\n# Get the long description from the README file\nwith open(path.join(here, \'README.md\'), encoding=\'utf-8\') as f:\n    long_description = f.read()\n    long_description = long_description.replace(""\\r"", """")\n\nsetup(\n    name=\'PyGLM\',\n\n    # Versions should comply with PEP440.  For a discussion on single-sourcing\n    # the version across setup.py and the project code, see\n    # https://packaging.python.org/en/latest/single_source_version.html\n    version=__version__,\n\n    description=\'OpenGL Mathematics library for Python\',\n    long_description=long_description,\n    long_description_content_type=\'text/markdown\',\n\n    # The project\'s main homepage.\n    url=\'https://github.com/Zuzu-Typ/PyGLM\',\n\n    # Author details\n    author=\'Zuzu_Typ\',\n    author_email=""zuzu.typ@gmail.com"",\n\n    # Choose your license\n    license=\'zlib/libpng license\',\n\n##    install_requires=[],\n\n    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        \'Development Status :: 5 - Production/Stable\',\n\n        # Indicate who your project is intended for\n        \'Intended Audience :: Developers\',\n        \'Topic :: Multimedia :: Graphics\',\n\n        # Pick your license as you wish (should match ""license"" above)\n        \'License :: OSI Approved :: zlib/libpng License\',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n\t\'Programming Language :: Python :: 3 :: Only\',\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Programming Language :: Python :: 3.6\',\n        \'Programming Language :: Python :: 3.7\',\n        \'Programming Language :: Python :: 3.8\',\n        \'Operating System :: Microsoft :: Windows\',\n        \'Operating System :: POSIX :: Linux\',\n        ""Operating System :: MacOS"",\n        \'Topic :: Software Development :: Libraries\',\n\t\'Topic :: Scientific/Engineering :: Physics\'\n        \n    ],\n\n    # What does your project relate to?\n    keywords=\'GLM OpenGL matrix vector vec mat Mathematics 3D python python3 3 library python-c-api c-api math-library numpy pyrr pip pypi matrix-manipulation matrix-multiplication matrix-functions quaternion c glsl\',\n\n    # You can just specify the packages manually here if your project is\n    # simple. Or you can use find_packages().\n    packages={},#find_packages(exclude=[\'contrib\', \'docs\', \'tests\'],include=[""*.h""]),\n\n##    package_data={\n##        """":[""*.h""]\n##        },\n\n    platforms = [""Windows"", ""Linux"", ""MacOS""],\n    \n    include_package_data=True,\n\n    # Alternatively, if you want to distribute just a my_module.py, uncomment\n    # this:\n    #py_modules=[""glm""],\n\n    ext_modules = [module1],\n\n    # List run-time dependencies here.  These will be installed by pip when\n    # your project is installed. For an analysis of ""install_requires"" vs pip\'s\n    # requirements files see:\n    # https://packaging.python.org/en/latest/requirements.html\n\n    # List additional groups of dependencies here (e.g. development\n    # dependencies). You can install these using the following syntax,\n    # for example:\n    # $ pip install -e .[dev,test]\n\n    # If there are data files included in your packages that need to be\n    # installed, specify them here.  If using Python 2.6 or less, then these\n    # have to be included in MANIFEST.in as well.\n\n    # Although \'package_data\' is the preferred approach, in some case you may\n    # need to place data files outside of your packages. See:\n    # http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files # noqa\n    # In this case, \'data_file\' will be installed into \'<sys.prefix>/my_data\'\n\n    # To provide executable scripts, use entry points in preference to the\n    # ""scripts"" keyword. Entry points provide cross-platform support and allow\n    # pip to create the appropriate form of executable for the target platform.\n)\n'"
