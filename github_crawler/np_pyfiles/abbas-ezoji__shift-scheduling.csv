file_path,api_count,code
GA_tester.py,2,"b""import pandas as pd\nimport numpy as np\nfrom libs import GA_dataframes as ga\n\nchromosom_df = pd.DataFrame(np.random.randint(15, size=(4, 30)),\n                            index = ['A', 'B', 'C', 'D'],\n                            columns = pd.date_range('1/1/2019', periods=30) )\n\nindividual = chromosom_df.sample(frac=1).reset_index(drop=False)\n# =============================================================================\n# ga = ga.GeneticAlgorithm(chromosom_df,\n#                       population_size=200,\n#                       generations=5,\n#                       crossover_probability=0.8,\n#                       mutation_probability=0.2,\n#                       elitism=True,\n#                       maximise_fitness=False)\n# def fitness(individual, data):\n#     sigma = 0.5\n#     mu = 0.8\n#     return sigma * np.random.randn(1) + mu\n# \n# ga.fitness_function = fitness               # set the GA's fitness function\n# ga.run()                                    # run the GA\n# sol_fitness, sol_df = ga.best_individual()                # print the GA's best solution\n# =============================================================================\n\n"""
__init__.py,0,"b""# -*- coding: utf-8 -*-\n\n\n__author__ = 'Ayodeji Remi-Omosowon'\n__email__ = 'abbas.ezoji@gmail.com'\n__version__ = '0.0.1'\n"""
day_shift_based.py,2,"b""import numpy as np\nimport pandas as pd\nimport pyodbc\nfrom sklearn.preprocessing import scale, normalize, minmax_scale\n\n'''\n            <<<<Shift Recommandeation by Genetic Algorithm>>>>            \n    - Create initial gene by pivot table\n    - Fetch Personnel, Shift and WorkSection Requirements Info\n'''\n# -----------------------Connection String------------------------------------#\nsql_conn = pyodbc.connect('''DRIVER={SQL Server Native Client 11.0};\n                             SERVER=172.16.47.154\\MSSQLSERVER2017;\n                             DATABASE=Didgah_Timekeeper_DM;\n                             Integrated_Security=false;\n                             Trusted_Connection=yes;\n                             UID=sa;\n                             PWD=1qaz!QAZ\n                          ''')\n\n# -----------------------Query for gene pivoted-------------------------------#\nquery_gene = '''SELECT \n            \t   Code SHIFTID\n            \t  ,139803 *100 + PersianDayOfMonth as PersianDayOfMonth\n            \t  ,NULL PersonnelBaseId\n               FROM \n    \t          Shifts S JOIN \n                  Dim_Date D ON D.PersianYear = 1398 AND PersianMonth=3\n            '''\nchromosom_df = pd.read_sql(query_gene, sql_conn)\nchromosom_df.head(3)\nchromosom_df = pd.pivot_table(chromosom_df, values='PersonnelBaseId'\n                              , index=['PersianDayOfMonth'],\n                              columns=['SHIFTID'], aggfunc=np.sum)\n\n# -----------------------Query for personnel info-----------------------------#\nquery_personnel = '''SELECT [PersonnelBaseId]\n                           ,[WorkSectionId]\n                           ,[YearWorkingPeriod]\n                           ,[RequirementWorkMins_esti]\n                           ,[RequirementWorkMins_real]\n                           ,[TypeId]\n                           ,[EfficiencyRolePoint]\n                      FROM [Personnel]\n                   '''\npersonnel_df = pd.read_sql(query_personnel,sql_conn)\n\n# -----------------------Randomize gene---------------------------------------#\nprs_count,_ = personnel_df.shape\nfor col in chromosom_df.columns :       \n    chromosom_df[col] = chromosom_df.apply(lambda row : int(np.random.choice(personnel_df.PersonnelBaseId, size=1))\n                                            ,axis=1)\n    \n# -----------------------Query for personnel info-----------------------------#\n\n\n# ----------------Query for insert shift assignment info----------------------#\n# =============================================================================\n# cursor = sql_conn.cursor()\n# year_workingperiod = 1398 * 100 + 3\n# day_count,shift_count = chromosom_df.shape                     \n# cursor.execute('''truncate table PersonnelShiftDateAssignments''')\n# \n# for shift in range(shift_count):    \n#     for day in range(day_count): \n#         cursor.execute('''insert into PersonnelShiftDateAssignments \n#                        values (?, ?, ?, ?, ?)'''\n#                        ,( personnel_df.loc[chromosom_df.loc[day+1][[shift+1]]][[1]] # personnelID\n#                          ,shift+1                     # \n#                          ,year_workingperiod * 100 + day+1,0,0)\n#                        )       \n# \n# sql_conn.commit()                     \n# =============================================================================\n\n"""
fit_moga.py,0,"b""def fitness (individual, meta_data, fit_count):\n    sht = shift_df.reset_index()\n    df = pd.melt(individual.reset_index(), \n                 id_vars=['PersonnelBaseId',\n                          'TypeId',\n                          'EfficiencyRolePoint',\n                          'RequirementWorkMins_esti'\n                         ],\n                 var_name='Day', \n                 value_name='ShiftCode')\n    df = df.merge(sht, left_on='ShiftCode', right_on='ShiftCode', how='inner')\n    if (fit_count==1):\n        cost = calc_day_const(df, sum_typid_req)\n    elif (fit_count==2):\n        cost = calc_prs_const(df, sum_typid_req)\n    else:\n        day_const = 0.8*calc_day_const(df, sum_typid_req)\n        prs_const = 0.2*calc_prs_const(df, sum_typid_req)\n        cost = day_const + prs_const\n        \n    return cost"""
main.py,10,"b'\'\'\'\n            <<<<Shift Recommandeation by Genetic Algorithm>>>>            \n    - Create initial gene by pivot table\n    - Fetch Personnel, Shift and WorkSection Requirements Info\n\'\'\'\nimport sys\n\nimport numpy as np\nimport pandas as pd\nfrom data_access.sql_server import data \nfrom libs import GA_dataframes \nimport datetime\nfrom time import strftime, gmtime\nfrom libs.get_random import get_best_first_rank as get_rank\n\ndef prs_day_alg(work_sction_id, year_working_period):\n#    work_sction_id = 1\n#    year_working_period = 139806\n    \n    PersianYear  = int(year_working_period / 100)\n    PersianMonth = int(year_working_period % 100)\n    # ----------------------- get data -------------------------------------------#\n    conn_str = \'\'\'DRIVER={SQL Server Native Client 11.0};\n                 SERVER=172.16.47.154;\n                 DATABASE=Didgah_Timekeeper_DM;\n                 Integrated_Security=false;\n                 Trusted_Connection=yes;\n                 UID=sa;\n                 PWD=1qaz!QAZ\n              \'\'\'\n    query_gene_last = \'\'\'SELECT DISTINCT   \n                                [Rank]\n                               ,[Cost]      \n                               ,[WorkSectionId]\n                               ,[YearWorkingPeriod]\n                               ,[EndTime]\n                               ,DATEDIFF(SECOND,EndTime,GETDATE())life_cycle\t \n                               ,[UsedParentCount]\n                         FROM [PersonnelShiftDateAssignments]                         \n                         WHERE WorkSectionId = {0} AND YearWorkingPeriod = {1}                                \n                       \'\'\'.format(work_sction_id,year_working_period)                        \n    parent_rank = get_rank(conn_str, query_gene_last)\n    by_parent = True \n    query_gene_last =\'\'\'SELECT S.[PersonnelBaseId]                 \n                              ,S.[YearWorkingPeriod]\n                              ,S.[Day]      \n                          \t  ,ShiftId as ShiftCode \n                        FROM \n                        \t[PersonnelShiftDateAssignments] S\n                        WHERE                           \t\n                            WorkSectionId = {0}                      \n                            AND S.YearWorkingPeriod = {1}   \n                            AND S.RANK = {2}\n                     \'\'\'.format(work_sction_id,\n                                year_working_period,\n                                parent_rank)\n                        \n    query_gene_new = \'\'\'SELECT \n                             PersonnelBaseId     \t\t\t\t\t \n    \t\t\t\t\t\t,YearWorkingPeriod\n                            ,PersianDayOfMonth as Day\n                            ,1 ShiftCode\n                        FROM \n                            Personnel P JOIN\n                            Dim_Date D ON D.PersianYear = {0} \n                            AND PersianMonth={1} and WorkSectionId = {2}\n                      \'\'\'.format(PersianYear, PersianMonth, work_sction_id)\n                      \n    \n    query_personnel = \'\'\'SELECT  [PersonnelBaseId]\n    \t\t\t\t\t\t\t,[WorkSectionId]\n    \t\t\t\t\t\t\t,[YearWorkingPeriod]\n    \t\t\t\t\t\t\t,[RequirementWorkMins_esti]\n    \t\t\t\t\t\t\t,[RequirementWorkMins_real]\n    \t\t\t\t\t\t\t,[TypeId] prs_typ_id\n    \t\t\t\t\t\t\t,[EfficiencyRolePoint]\n                                ,[DiffNorm]\n                        FROM [Personnel]\n                        WHERE WorkSectionId = {0} AND YearWorkingPeriod = {1}\n                      \'\'\'.format(work_sction_id,year_working_period)\n                      \n    query_shift = \'\'\'SELECT [id] as ShiftCode\n    \t\t\t\t\t ,[Title]\n    \t\t\t\t\t ,[Length]\n    \t\t\t\t\t ,[StartTime]\n    \t\t\t\t\t ,[EndTime]\n    \t\t\t\t\t ,[Type] ShiftTypeID\n                    FROM [Shifts]\n    \t\t\t \'\'\'   \n    query_shift_req = \'\'\'SELECT [PersianDayOfMonth] AS Day                          \n                              ,[PersonnelTypeReqID] as prs_typ_id\n                              ,[ShiftTypeID]\n                              ,[ReqMinCount]\n                              ,[ReqMaxCount]\n                              ,[day_diff_typ]\n                        FROM \n                        \t[WorkSectionRequirements] R\n                        \tJOIN Dim_Date D ON D.PersianYear=R.Year\n                        \tAND D.PersianMonth = R.Month                    \t\n                        WHERE \n    \t\t\t\t\t\tYEAR = {0} AND Month = {1}\n                            AND WorkSectionId = {2}\n                        ORDER BY \n                        \tWorkSectionId,D.Date\n                        \t,PersonnelTypeReqID,ShiftTypeID                        \n                      \'\'\'.format(PersianYear, PersianMonth, work_sction_id)      \n    query_prs_req = \'\'\'SELECT  [PersonnelBaseId]\n                              ,[YearWorkingPeriod]\n                              ,[WorkSectionId]\n                              ,[Day]\n                              ,[ShiftTypeID]\n                              ,[Value]\n                      FROM [PersonnelRequest]\n                      WHERE [WorkSectionId] = {0}\n                            and [YearWorkingPeriod] = {1}\n                      ORDER BY[PersonnelBaseId]\n                              ,[YearWorkingPeriod]\n                              ,[Day]\n                              ,[ShiftTypeID]\n                    \'\'\'.format(work_sction_id,year_working_period)\n                         \n    db = data(conn_str =  conn_str,\n              query_gene_last = query_gene_last,\n              query_gene_new = query_gene_new,\n              query_personnel=query_personnel,\n              query_shift=query_shift,\n              query_shift_req=query_shift_req,\n              query_prs_req=query_prs_req\n             )\n    sql_conn = db.get_sql_conn()\n    chromosom_df = pd.DataFrame(db.get_chromosom(work_sction_id, \n                                                 year_working_period))\n    personnel_df = pd.DataFrame(db.get_personnel())\n    shift_df = pd.DataFrame(db.get_shift())\n    day_req_df = pd.DataFrame(db.get_day_req())\n    prs_req_df = pd.DataFrame(db.get_prs_req())\n    is_new = db.is_new()\n    # ----------------------- gene pivoted ---------------------------------------#\n    chromosom_df = chromosom_df.merge(personnel_df, \n                                      left_on=\'PersonnelBaseId\', \n                                      right_on=\'PersonnelBaseId\', \n                                      how=\'inner\')\n    chromosom_df = pd.pivot_table(chromosom_df, values=\'ShiftCode\', \n                                  index=[\'PersonnelBaseId\',\n                                          \'prs_typ_id\',\n                                          \'EfficiencyRolePoint\',\n                                          \'RequirementWorkMins_esti\'                                                                           \n                                        ],\n                                  columns=[\'Day\'], aggfunc=np.sum)\n    # ----------------------- set personnel_df -----------------------------------#\n    personnel_df = personnel_df.set_index(\'PersonnelBaseId\')\n    personnel_df[\'DiffNorm\'] = 0\n    # ----------------------- set shift_df ---------------------------------------#\n    shift_df = shift_df.set_index(\'ShiftCode\')\n    # ----------------------- set day_req_df -------------------------------------#\n    day_req_df = day_req_df.set_index([\'Day\',\'prs_typ_id\',\'ShiftTypeID\'])\n    day_req_df[\'day_diff_typ\'] = 0\n    day_count =len(day_req_df.groupby(axis=0, level=0, as_index=True).count())\n    # -----------------------Randomize gene---------------------------------------#\n    if (is_new):      \n        shift_list = np.flip(shift_df.index.values.tolist())   \n        for prs in chromosom_df.index :       \n            chromosom_df.loc[prs] = np.random.choice(shift_list,\n                                                     p=[1/14,1/14,1/14,\n                                                        1/14,2/14,3/14,5/14],\n                                                     size=len(chromosom_df.columns)\n                                                     )    \n    # ---------------------- calcute typid_req_day--------------------------------#\n    req_day = day_req_df.reset_index()\n    typid_req_day = req_day.groupby([\'Day\',\'prs_typ_id\',\'ShiftTypeID\']).agg(\n                    ReqMinCount = pd.NamedAgg(column=\'ReqMinCount\', \n                                              aggfunc=\'sum\'),\n                    ReqMaxCount = pd.NamedAgg(column=\'ReqMaxCount\', \n                                              aggfunc=\'sum\')\n                    )\n    typid_req_day[\'ReqMean\'] = (typid_req_day[\'ReqMaxCount\']+ \n                                typid_req_day[\'ReqMinCount\'])/2   \n    # ---------------------- Calcute diff require and resource--------------------# \n                        #---------------sum_typid_req---------------#\n    sum_typid_req = typid_req_day.reset_index()          \n    sum_typid_req = sum_typid_req.groupby(\'prs_typ_id\').agg(\n                req_min  = pd.NamedAgg(column=\'ReqMinCount\', \n                                              aggfunc=\'sum\'), \n                req_max = pd.NamedAgg(column=\'ReqMaxCount\', \n                                              aggfunc=\'sum\'),\n                req_mean= pd.NamedAgg(column=\'ReqMean\', \n                                              aggfunc=\'sum\'),            \n            )\n    sum_typid_req = sum_typid_req[:]*480\n                         #--------------sum_typid_prs----------------#\n    sum_typid_prs = personnel_df.groupby(\'prs_typ_id\').agg(\n                all_rec  = pd.NamedAgg(column=\'RequirementWorkMins_esti\', \n                                              aggfunc=\'sum\'), \n                count_prs = pd.NamedAgg(column=\'RequirementWorkMins_esti\', \n                                              aggfunc=\'count\'),\n            )\n                         #--------------sum_typid_prs----------------#\n    diff_req_rec = sum_typid_req.join(sum_typid_prs,how=\'inner\')                   \n    diff_req_rec[\'diff_min\'] = (diff_req_rec[\'req_min\'] - \n                                diff_req_rec[\'all_rec\'] )/diff_req_rec[\'count_prs\'] \n    diff_req_rec[\'diff_max\'] = (diff_req_rec[\'req_max\'] - \n                                diff_req_rec[\'all_rec\'] )/diff_req_rec[\'count_prs\'] \n    diff_req_rec[\'diff_mean\'] = (diff_req_rec[\'req_mean\'] - \n                                diff_req_rec[\'all_rec\'] )/diff_req_rec[\'count_prs\']\n    #diff_req_rec = diff_req_rec.reset_index()\n    #------------------------ Consttraint day_const function for day -------------# \n    def calc_day_const (individual,meta_data):  \n        df = individual           \n        df = df[df[\'Length\']>0].groupby([\'Day\',\n                                         \'prs_typ_id\',\n                                         \'ShiftTypeID\']).agg(\n                            prs_count = pd.NamedAgg(column=\'Length\', \n                                              aggfunc=\'count\'), \n                            prs_points = pd.NamedAgg(column=\'EfficiencyRolePoint\', \n                                              aggfunc=\'sum\'),\n                            )\n        df = df.merge(meta_data, left_on=[\'Day\',\'prs_typ_id\',\'ShiftTypeID\'], \n                      right_on=[\'Day\',\'prs_typ_id\',\'ShiftTypeID\'], how=\'right\') \n        df.fillna(0,inplace=True)\n        df[\'diff_max\'] = abs(df[\'prs_count\'] - df[\'ReqMaxCount\'])\n        df[\'diff_min\'] = abs(df[\'prs_count\'] - df[\'ReqMinCount\'])  \n        df[\'diff\'] = df[[\'diff_max\',\'diff_min\']].apply(np.min, axis=1)\n        df[\'diff_norm\'] = df[\'diff\']/df[\'ReqMaxCount\']\n    #    cost = np.mean(df[\'diff_norm\'])\n        df[\'diff_norm\'] = df[\'diff_norm\']**2\n        cost = np.sum(df[\'diff_norm\']) / len(df)\n    #    cost = np.max(df[\'diff_norm\']) / len(df)\n    #    print(\'cost: \' + str(cost))\n        return cost\n    \n    #------------------------ Consttraint prs_const function for day -------------# \n    def calc_prs_const (individual, meta_data):\n        df = individual    \n        df = df.groupby([\'PersonnelBaseId\',\n                          \'prs_typ_id\',\n                          \'EfficiencyRolePoint\',\n                          \'RequirementWorkMins_esti\',                      \n                         ]).sum().drop(columns=[\'ShiftCode\', \'StartTime\', \n                                                \'EndTime\', \'ShiftTypeID\'])    \n        df = df.reset_index()\n        meta_data = meta_data.reset_index()\n        df = df.merge(meta_data, left_on=\'prs_typ_id\', right_on=\'prs_typ_id\'\n                      ,how=\'inner\')\n        \n        df[\'diff\'] = abs(df[\'RequirementWorkMins_esti\'] + \n                         df[\'diff_min\'] - df[\'Length\'])         \n        df[\'diff_norm\'] = df[\'diff\']/df[\'RequirementWorkMins_esti\']\n    #    cost = np.mean(df[\'diff_norm\'])    \n        df[\'diff_norm\'] = df[\'diff_norm\']**2\n        cost = np.sum(df[\'diff_norm\']) / len(df)\n    #    print(\'cost: \' + str(cost))\n        return cost \n    #------------------------ Objective prs_req function for prs req -------------# \n    def calc_prs_req_cost (individual,meta_data):  \n        df = individual     \n        df[\'Assigned\'] = 1\n        df_req = meta_data.merge(df,  \n                                 left_on =[\'PersonnelBaseId\',\'Day\',\'ShiftTypeID\'],\n                                 right_on=[\'PersonnelBaseId\',\'Day\',\'ShiftTypeID\'],\n                                 how=\'left\'\n                                )\n        df_req = df_req.fillna(-1)\n        \n        df_req[\'cost\'] = df_req[\'Assigned\']*df_req[\'Value\']\n    \n        return 0\n    \n    # ----------------------- fitness all ----------------------------------------#\n    def fitness (individual, meta_data):\n        sht = shift_df.reset_index()\n        sht_2 = sht[sht[\'ShiftCode\']>10]\n        sht_2[\'Length\'] = sht_2[\'Length\'] // 2\n        sht_2[\'ShiftTypeID\'] = sht_2[\'ShiftTypeID\'] // 10\n        sht_2.index = [7,8,9]\n        sht[\'Length\'] = sht[\'Length\'] // 2\n        sht[\'ShiftTypeID\'] = sht[\'ShiftTypeID\'] % 10\n        sht = sht.append(sht_2)\n        #sht[sht[\'ShiftCode\']>10]\n        df = pd.melt(individual.reset_index(), \n                     id_vars=[\'PersonnelBaseId\',\n                              \'prs_typ_id\',\n                              \'EfficiencyRolePoint\',\n                              \'RequirementWorkMins_esti\',\n                              \n                             ],\n                     var_name=\'Day\', \n                     value_name=\'ShiftCode\')\n        df = df.merge(sht, left_on=\'ShiftCode\', right_on=\'ShiftCode\', how=\'inner\')\n        day_const = 0.8*calc_day_const(df, typid_req_day)\n        prs_const = 0.2*calc_prs_const(df, diff_req_rec)\n        prs_req_cost = calc_prs_req_cost(df, prs_req_df)\n        cost = day_const + prs_const\n        return cost\n    # -----------------------Define GA--------------------------------------------#        \n    ga = GA_dataframes.GeneticAlgorithm( seed_data=chromosom_df,\n                              meta_data=shift_df,\n                              population_size=50,\n                              generations=200,\n                              crossover_probability=0.8,\n                              mutation_probability=0.2,\n                              elitism=True,\n                              by_parent=by_parent,\n                              maximise_fitness=False)\n     \n     # ----------------------- run ga --------------------------------------------# \n    ga.fitness_function = fitness         # set the GA\'s fitness function\n    start_time = gmtime()\n    ga.run()                                    # run the GA\n    end_time = gmtime()\n    time_consum_hour   = end_time[3] - start_time[3]\n    time_consum_minute = end_time[4] - start_time[4]\n    time_consum_second = end_time[5] - start_time[5]\n    print(\'time_consum : \' + str(time_consum_hour) + \':\'+ \n                             str(time_consum_minute) + \':\'+ \n                             str(time_consum_second)\n                            )\n    sol_fitness, sol_df = ga.best_individual()\n    sol_tbl = sol_df.stack()\n    sol_tbl = sol_tbl.reset_index()\n    \n    sol_tbl[\'Rank\'] = 1\n    sol_tbl[\'Cost\'] = sol_fitness\n    sol_tbl[\'EndTime\'] =  strftime(\'%Y-%m-%d %H:%M:%S\')\n    sol_tbl[\'UsedParentCount\'] =  0\n    sol_tbl[\'WorkSectionId\'] = work_sction_id\n    sol_tbl[\'YearWorkingPeriod\'] = year_working_period\n    sol_tbl = sol_tbl.drop(columns=[\'prs_typ_id\', \n                                    \'EfficiencyRolePoint\', \n                                    \'RequirementWorkMins_esti\'])\n    sol_tbl = sol_tbl.values.tolist()\n    # ----------------------- inserting ------------------------------------------# \n    #db.delete_last_sol(work_sction_id,year_working_period)\n    db.insert_sol(sol_tbl, personnel_df, \n                  sol_fitness,work_sction_id,year_working_period,\n                  parent_rank)\n    #-------------------- output show --------------------------------------------#\n    #########################################################\n    sht = shift_df.reset_index()\n    sht_2 = sht[sht[\'ShiftCode\']>10]\n    sht_2[\'Length\'] = sht_2[\'Length\'] // 2\n    sht_2[\'ShiftTypeID\'] = sht_2[\'ShiftTypeID\'] // 10\n    sht_2.index = [7,8,9]\n    sht[\'Length\'] = sht[\'Length\'] // 2\n    sht[\'ShiftTypeID\'] = sht[\'ShiftTypeID\'] % 10\n    sht = sht.append(sht_2)\n    df = pd.melt(sol_df.reset_index(), \n                 id_vars=[\'PersonnelBaseId\',\n                          \'prs_typ_id\',\n                          \'EfficiencyRolePoint\',\n                          \'RequirementWorkMins_esti\',\n                         \n                         ],\n                 var_name=\'Day\', \n                 value_name=\'ShiftCode\')\n    df = df.merge(sht, left_on=\'ShiftCode\', right_on=\'ShiftCode\', how=\'inner\')\n    #######################################################\n    cons_prs = df.groupby([\'PersonnelBaseId\',\n                          \'prs_typ_id\',\n                          \'EfficiencyRolePoint\',\n                          \'RequirementWorkMins_esti\',\n                          \n                         ]).sum().drop(columns=[\'ShiftCode\', \'StartTime\', \n                                                \'EndTime\', \'ShiftTypeID\'])\n    cons_prs = cons_prs.reset_index(level=3)\n    cons_prs[\'diff\'] = (cons_prs[\'RequirementWorkMins_esti\'] - cons_prs[\'Length\'])\n    #########################################################3\n    \n    cons_day = df[df[\'Length\']>0].groupby([\'Day\',\n                                           \'prs_typ_id\',\n                                           \'ShiftTypeID\']).agg(\n                                  prs_count = pd.NamedAgg(column=\'Length\', \n                                              aggfunc=\'count\'), \n                                  prs_points = pd.NamedAgg(column=\'EfficiencyRolePoint\', \n                                              aggfunc=\'sum\'),\n                                )\n                                  \n    cons_day = cons_day.merge(typid_req_day, \n                              left_on=[\'Day\',\'prs_typ_id\',\'ShiftTypeID\'], \n                              right_on=[\'Day\',\'prs_typ_id\',\'ShiftTypeID\'], \n                              how=\'right\') \n    cons_day.fillna(0,inplace=True)            \n    cons_day[\'diff_max\'] = abs(cons_day[\'prs_count\'] - cons_day[\'ReqMaxCount\'])\n    cons_day[\'diff_min\'] = abs(cons_day[\'prs_count\'] - cons_day[\'ReqMinCount\'])  \n    cons_day[\'diff\'] = cons_day[[\'diff_max\',\'diff_min\']].apply(np.min, axis=1) \n    cons_day.sort_index(axis=0, level=[0,1,2], ascending=True, inplace=True)\n    \nif __name__ == ""__main__"":\n    work_sction_id = int(sys.argv[1])\n    year_working_period = int(sys.argv[2])\n    prs_day_alg(work_sction_id=work_sction_id,\n                year_working_period=year_working_period)'"
prs_day_based.py,10,"b""'''\n            <<<<Shift Recommandeation by Genetic Algorithm>>>>            \n    - Create initial gene by pivot table\n    - Fetch Personnel, Shift and WorkSection Requirements Info\n'''\nimport sys\n\nimport numpy as np\nimport pandas as pd\nfrom data_access.sql_server import data \nfrom libs import GA_dataframes \nimport datetime\nfrom time import strftime, gmtime\nfrom libs.get_random import get_best_first_rank as get_rank\n\nwork_sction_id = 1\nyear_working_period = 139806\n\nPersianYear  = int(year_working_period / 100)\nPersianMonth = int(year_working_period % 100)\n# ----------------------- get data -------------------------------------------#\nconn_str = '''DRIVER={SQL Server Native Client 11.0};\n             SERVER=.;\n             DATABASE=Didgah_Timekeeper_DM;\n             Integrated_Security=false;\n             Trusted_Connection=yes;\n             UID=sa;\n             PWD=1qaz!QAZ\n          '''\nquery_gene_last = '''SELECT DISTINCT   \n                            [Rank]\n                           ,[Cost]      \n                           ,[WorkSectionId]\n                           ,[YearWorkingPeriod]\n                           ,[EndTime]\n                           ,DATEDIFF(SECOND,EndTime,GETDATE())life_cycle\t \n                           ,[UsedParentCount]\n                     FROM [PersonnelShiftDateAssignments]                         \n                     WHERE WorkSectionId = {0} AND YearWorkingPeriod = {1}                                \n                   '''.format(work_sction_id,year_working_period)                        \nparent_rank = get_rank(conn_str, query_gene_last)\nby_parent = False\nquery_gene_last ='''SELECT S.[PersonnelBaseId]                 \n                          ,S.[YearWorkingPeriod]\n                          ,S.[Day]  \n                      \t  ,ShiftId as ShiftCode \n                    FROM \n                    \t[PersonnelShiftDateAssignments] S\n                    WHERE                           \t\n                        WorkSectionId = {0}                      \n                        AND S.YearWorkingPeriod = {1}   \n                        AND S.RANK = {2}\n                 '''.format(work_sction_id,\n                            year_working_period,\n                            parent_rank)\n                    \nquery_gene_new = '''SELECT \n                         PersonnelBaseId     \t\t\t\t\t \n\t\t\t\t\t\t,YearWorkingPeriod\n                        ,PersianDayOfMonth as Day\n                        ,1 ShiftCode\n                    FROM \n                        Personnel P JOIN\n                        Dim_Date D ON D.PersianYear = {0} \n                        AND PersianMonth={1} and WorkSectionId = {2}\n                  '''.format(PersianYear, PersianMonth, work_sction_id)                  \n\nquery_personnel = '''SELECT  [PersonnelBaseId]\n\t\t\t\t\t\t\t,[WorkSectionId]\n\t\t\t\t\t\t\t,[YearWorkingPeriod]\n\t\t\t\t\t\t\t,[RequirementWorkMins_esti]\n\t\t\t\t\t\t\t,[RequirementWorkMins_real]\n\t\t\t\t\t\t\t,[TypeId] prs_typ_id\n\t\t\t\t\t\t\t,[EfficiencyRolePoint]\n                            ,[DiffNorm]\n                    FROM [Personnel]\n                    WHERE WorkSectionId = {0} AND YearWorkingPeriod = {1}\n                  '''.format(work_sction_id,year_working_period)\n                  \nquery_shift = '''SELECT [id] as ShiftCode\n\t\t\t\t\t ,[Title]\n\t\t\t\t\t ,[Length]\n\t\t\t\t\t ,[StartTime]\n\t\t\t\t\t ,[EndTime]\n\t\t\t\t\t ,[Type] ShiftTypeID\n                FROM [Shifts]\n\t\t\t '''   \nquery_shift_req = '''SELECT [PersianDayOfMonth] AS Day                          \n                          ,[PersonnelTypeReqID] as prs_typ_id\n                          ,[ShiftTypeID]\n                          ,[ReqMinCount]\n                          ,[ReqMaxCount]\n                          ,[day_diff_typ]\n                    FROM \n                    \t[WorkSectionRequirements] R\n                    \tJOIN Dim_Date D ON D.PersianYear=R.Year\n                    \tAND D.PersianMonth = R.Month                    \t\n                    WHERE \n\t\t\t\t\t\tYEAR = {0} AND Month = {1}\n                        AND WorkSectionId = {2}\n                    ORDER BY \n                    \tWorkSectionId,D.Date\n                    \t,PersonnelTypeReqID,ShiftTypeID                        \n                  '''.format(PersianYear, PersianMonth, work_sction_id)      \nquery_prs_req = '''SELECT  [PersonnelBaseId]\n                          ,[YearWorkingPeriod]\n                          ,[WorkSectionId]\n                          ,[Day]\n                          ,[ShiftTypeID]\n                          ,[Value]\n                  FROM [PersonnelRequest]\n                  WHERE [WorkSectionId] = {0}\n                        and [YearWorkingPeriod] = {1}\n                  ORDER BY[PersonnelBaseId]\n                          ,[YearWorkingPeriod]\n                          ,[Day]\n                          ,[ShiftTypeID]\n                '''.format(work_sction_id,year_working_period)\n                     \ndb = data(conn_str =  conn_str,\n          query_gene_last = query_gene_last,\n          query_gene_new = query_gene_new,\n          query_personnel=query_personnel,\n          query_shift=query_shift,\n          query_shift_req=query_shift_req,\n          query_prs_req=query_prs_req\n         )\nsql_conn = db.get_sql_conn()\nchromosom_df = pd.DataFrame(db.get_chromosom(work_sction_id, \n                                             year_working_period))\npersonnel_df = pd.DataFrame(db.get_personnel())\nshift_df = pd.DataFrame(db.get_shift())\nday_req_df = pd.DataFrame(db.get_day_req())\nprs_req_df = pd.DataFrame(db.get_prs_req())\nis_new = db.is_new()\n# ----------------------- gene pivoted ---------------------------------------#\nchromosom_df = chromosom_df.merge(personnel_df, \n                                  left_on='PersonnelBaseId', \n                                  right_on='PersonnelBaseId', \n                                  how='inner')\nchromosom_df = pd.pivot_table(chromosom_df, values='ShiftCode', \n                              index=['PersonnelBaseId',\n                                      'prs_typ_id',\n                                      'EfficiencyRolePoint',\n                                      'RequirementWorkMins_esti'                                                                           \n                                    ],\n                              columns=['Day'], aggfunc=np.sum)\n# ----------------------- set personnel_df -----------------------------------#\npersonnel_df = personnel_df.set_index('PersonnelBaseId')\npersonnel_df['DiffNorm'] = 0\n# ----------------------- set shift_df ---------------------------------------#\nshift_df = shift_df.set_index('ShiftCode')\n# ----------------------- set day_req_df -------------------------------------#\nday_req_df = day_req_df.set_index(['Day','prs_typ_id','ShiftTypeID'])\nday_req_df['day_diff_typ'] = 0\nday_count =len(day_req_df.groupby(axis=0, level=0, as_index=True).count())\n# -----------------------Randomize gene---------------------------------------#\nif (is_new):      \n    shift_list = np.flip(shift_df.index.values.tolist())   \n    for prs in chromosom_df.index :       \n        chromosom_df.loc[prs] = np.random.choice(shift_list,\n                                                 p=[1/14,1/14,1/14,\n                                                    1/14,2/14,3/14,5/14],\n                                                 size=len(chromosom_df.columns)\n                                                 )    \n# ---------------------- calcute typid_req_day--------------------------------#\nreq_day = day_req_df.reset_index()\ntypid_req_day = req_day.groupby(['Day','prs_typ_id','ShiftTypeID']).agg(\n                ReqMinCount = pd.NamedAgg(column='ReqMinCount', \n                                          aggfunc='sum'),\n                ReqMaxCount = pd.NamedAgg(column='ReqMaxCount', \n                                          aggfunc='sum')\n                )\ntypid_req_day['ReqMean'] = (typid_req_day['ReqMaxCount']+ \n                            typid_req_day['ReqMinCount'])/2   \n# ---------------------- Calcute diff require and resource--------------------# \n                    #---------------sum_typid_req---------------#\nsum_typid_req = typid_req_day.reset_index()          \nsum_typid_req = sum_typid_req.groupby('prs_typ_id').agg(\n            req_min  = pd.NamedAgg(column='ReqMinCount', \n                                          aggfunc='sum'), \n            req_max = pd.NamedAgg(column='ReqMaxCount', \n                                          aggfunc='sum'),\n            req_mean= pd.NamedAgg(column='ReqMean', \n                                          aggfunc='sum'),            \n        )\nsum_typid_req = sum_typid_req[:]*480\n                     #--------------sum_typid_prs----------------#\nsum_typid_prs = personnel_df.groupby('prs_typ_id').agg(\n            all_rec  = pd.NamedAgg(column='RequirementWorkMins_esti', \n                                          aggfunc='sum'), \n            count_prs = pd.NamedAgg(column='RequirementWorkMins_esti', \n                                          aggfunc='count'),\n        )\n                     #--------------sum_typid_prs----------------#\ndiff_req_rec = sum_typid_req.join(sum_typid_prs,how='inner')                   \ndiff_req_rec['diff_min'] = (diff_req_rec['req_min'] - \n                            diff_req_rec['all_rec'] )/diff_req_rec['count_prs'] \ndiff_req_rec['diff_max'] = (diff_req_rec['req_max'] - \n                            diff_req_rec['all_rec'] )/diff_req_rec['count_prs'] \ndiff_req_rec['diff_mean'] = (diff_req_rec['req_mean'] - \n                            diff_req_rec['all_rec'] )/diff_req_rec['count_prs']\n#diff_req_rec = diff_req_rec.reset_index()\n#------------------------ Consttraint day_const function for day -------------# \ndef calc_day_const (individual,meta_data):  \n    df = individual           \n    df = df[df['Length']>0].groupby(['Day',\n                                     'prs_typ_id',\n                                     'ShiftTypeID']).agg(\n                        prs_count = pd.NamedAgg(column='Length', \n                                          aggfunc='count'), \n                        prs_points = pd.NamedAgg(column='EfficiencyRolePoint', \n                                          aggfunc='sum'),\n                        )\n    df = df.merge(meta_data, left_on=['Day','prs_typ_id','ShiftTypeID'], \n                  right_on=['Day','prs_typ_id','ShiftTypeID'], how='right') \n    df.fillna(0,inplace=True)\n    df['diff_max'] = abs(df['prs_count'] - df['ReqMaxCount'])\n    df['diff_min'] = abs(df['prs_count'] - df['ReqMinCount'])  \n    df['diff'] = df[['diff_max','diff_min']].apply(np.min, axis=1)\n    df['diff_norm'] = df['diff']/df['ReqMaxCount']\n#    cost = np.mean(df['diff_norm'])\n    df['diff_norm'] = df['diff_norm']**2\n    cost = np.sum(df['diff_norm']) / len(df)\n#    cost = np.max(df['diff_norm']) / len(df)\n#    print('cost: ' + str(cost))\n    return cost\n\n#------------------------ Consttraint prs_const function for day -------------# \ndef calc_prs_const (individual, meta_data):\n    df = individual    \n    df = df.groupby(['PersonnelBaseId',\n                      'prs_typ_id',\n                      'EfficiencyRolePoint',\n                      'RequirementWorkMins_esti',                      \n                     ]).sum().drop(columns=['ShiftCode', 'StartTime', \n                                            'EndTime', 'ShiftTypeID'])    \n    df = df.reset_index()\n    meta_data = meta_data.reset_index()\n    df = df.merge(meta_data, left_on='prs_typ_id', right_on='prs_typ_id'\n                  ,how='inner')\n    \n    df['diff'] = abs(df['RequirementWorkMins_esti'] + \n                     df['diff_min'] - df['Length'])         \n    df['diff_norm'] = df['diff']/df['RequirementWorkMins_esti']\n#    cost = np.mean(df['diff_norm'])    \n    df['diff_norm'] = df['diff_norm']**2\n    cost = np.sum(df['diff_norm']) / len(df)\n#    print('cost: ' + str(cost))\n    return cost \n#------------------------ Objective prs_req function for prs req -------------# \ndef calc_prs_req_cost (individual,meta_data):  \n    df = individual     \n    df['Assigned'] = 1\n    df_req = meta_data.merge(df,  \n                             left_on =['PersonnelBaseId','Day','ShiftTypeID'],\n                             right_on=['PersonnelBaseId','Day','ShiftTypeID'],\n                             how='left'\n                            )\n    df_req = df_req.fillna(-1)\n    \n    df_req['cost'] = df_req['Assigned']*df_req['Value']\n\n    return 0\n\n# ----------------------- fitness all ----------------------------------------#\ndef fitness (individual, meta_data):\n    sht = shift_df.reset_index()\n    sht_2 = sht[sht['ShiftCode']>10]\n    sht_2['Length'] = sht_2['Length'] // 2\n    sht_2['ShiftTypeID'] = sht_2['ShiftTypeID'] // 10\n    sht_2.index = [7,8,9]\n    sht_len = sht[sht['ShiftCode']>10]['Length'] // 2\n    sht.update(sht_len)\n    sht['ShiftTypeID'] = sht['ShiftTypeID'] % 10\n    sht = sht.append(sht_2)\n    #sht[sht['ShiftCode']>10]\n    df = pd.melt(individual.reset_index(), \n                 id_vars=['PersonnelBaseId',\n                          'prs_typ_id',\n                          'EfficiencyRolePoint',\n                          'RequirementWorkMins_esti',                          \n                         ],\n                 var_name='Day', \n                 value_name='ShiftCode')\n    df = df.merge(sht, left_on='ShiftCode', right_on='ShiftCode', how='inner')\n    day_const = 0.8*calc_day_const(df, typid_req_day)\n    prs_const = 0.2*calc_prs_const(df, diff_req_rec)\n    prs_req_cost = calc_prs_req_cost(df, prs_req_df)\n    cost = day_const + prs_const\n    return cost\n# -----------------------Define GA--------------------------------------------#        \nga = GA_dataframes.GeneticAlgorithm( seed_data=chromosom_df,\n                          meta_data=shift_df,\n                          population_size=60,\n                          generations=200,\n                          crossover_probability=0.8,\n                          mutation_probability=0.2,\n                          elitism=True,\n                          by_parent=by_parent,\n                          maximise_fitness=False)\n \n # ----------------------- run ga --------------------------------------------# \nga.fitness_function = fitness         # set the GA's fitness function\nstart_time = gmtime()\nga.run()                                    # run the GA\nend_time = gmtime()\ntime_consum_hour   = end_time[3] - start_time[3]\ntime_consum_minute = end_time[4] - start_time[4]\ntime_consum_second = end_time[5] - start_time[5]\nprint('time_consum : ' + str(time_consum_hour) + ':'+ \n                         str(time_consum_minute) + ':'+ \n                         str(time_consum_second)\n                        )\nsol_fitness, sol_df = ga.best_individual()\nsol_tbl = sol_df.stack()\nsol_tbl = sol_tbl.reset_index()\n\nsol_tbl['Rank'] = 1\nsol_tbl['Cost'] = sol_fitness\nsol_tbl['EndTime'] =  strftime('%Y-%m-%d %H:%M:%S')\nsol_tbl['UsedParentCount'] =  0\nsol_tbl['WorkSectionId'] = work_sction_id\nsol_tbl['YearWorkingPeriod'] = year_working_period\nsol_tbl = sol_tbl.drop(columns=['prs_typ_id', \n                                'EfficiencyRolePoint', \n                                'RequirementWorkMins_esti'])\nsol_tbl = sol_tbl.values.tolist()\n# ----------------------- inserting ------------------------------------------# \n\ndb.insert_sol(sol_tbl, personnel_df, \n              sol_fitness,work_sction_id,year_working_period,\n              parent_rank)\n#-------------------- output show --------------------------------------------#\n########################################################\nsht = shift_df.reset_index()\nsht_2 = sht[sht['ShiftCode']>10]\nsht_2['Length'] = sht_2['Length'] // 2\nsht_2['ShiftTypeID'] = sht_2['ShiftTypeID'] // 10\nsht_2.index = [7,8,9]\nsht_len = sht[sht['ShiftCode']>10]['Length'] // 2\nsht.update(sht_len)\nsht['ShiftTypeID'] = sht['ShiftTypeID'] % 10\nsht = sht.append(sht_2)\ndf = pd.melt(sol_df.reset_index(), \n             id_vars=['PersonnelBaseId',\n                      'prs_typ_id',\n                      'EfficiencyRolePoint',\n                      'RequirementWorkMins_esti',\n                     \n                     ],\n             var_name='Day', \n             value_name='ShiftCode')\ndf = df.merge(sht, left_on='ShiftCode', right_on='ShiftCode', how='inner')\n#########################################################\ncons_prs = df.groupby(['PersonnelBaseId',\n                      'prs_typ_id',\n                      'EfficiencyRolePoint',\n                      'RequirementWorkMins_esti',\n                      \n                     ]).sum().drop(columns=['ShiftCode', 'StartTime', \n                                            'EndTime', 'ShiftTypeID'])\ncons_prs = cons_prs.reset_index(level=3)\ncons_prs['diff'] = (cons_prs['RequirementWorkMins_esti'] - cons_prs['Length'])\n#########################################################\ncons_day = df[df['Length']>0].groupby(['Day',\n                                       'prs_typ_id',\n                                       'ShiftTypeID']).agg(\n                              prs_count = pd.NamedAgg(column='Length', \n                                          aggfunc='count'), \n                              prs_points = pd.NamedAgg(column='EfficiencyRolePoint', \n                                          aggfunc='sum'),\n                            )\n                              \ncons_day = cons_day.merge(typid_req_day, \n                          left_on=['Day','prs_typ_id','ShiftTypeID'], \n                          right_on=['Day','prs_typ_id','ShiftTypeID'], \n                          how='right') \ncons_day.fillna(0,inplace=True)            \ncons_day['diff_max'] = abs(cons_day['prs_count'] - cons_day['ReqMaxCount'])\ncons_day['diff_min'] = abs(cons_day['prs_count'] - cons_day['ReqMinCount'])  \ncons_day['diff'] = cons_day[['diff_max','diff_min']].apply(np.min, axis=1) \ncons_day.sort_index(axis=0, level=[0,1,2], ascending=True, inplace=True)\n"""
prs_day_by_csv.py,4,"b""import numpy as np\nimport pandas as pd\nfrom libs import GA_dataframes as ga\n\n# -----------------------Query for gene pivoted-------------------------------#\n\nchromosom_df = pd.read_csv('C:/MyFiles/Projects/DM/sample files/output.csv')\nchromosom_df = pd.pivot_table(chromosom_df, values='SHIFTID', \n                              index=['PersonnelBaseId'],\n                              columns=['PersianDayOfMonth'], aggfunc=np.sum)\n\n# -----------------------Query for personnel info-----------------------------#\npersonnel_df = pd.read_csv('C:/MyFiles/Projects/DM/sample files/personnel.csv')\npersonnel_df = personnel_df.set_index('PersonnelBaseId')\n# -----------------------Query for shift info---------------------------------#\nshift_df = pd.read_csv('C:/MyFiles/Projects/DM/sample files/shifts.csv')\nshift_df = shift_df.set_index('Code')\n# -----------------------Randomize gene---------------------------------------#\nfor prs in chromosom_df.index :       \n    chromosom_df.loc[prs] = np.random.choice(shift_df.index.values.tolist(),size=len(chromosom_df.columns))\nchromosom_df = chromosom_df.astype(int)\n#------------------------fitness function-------------------------------------# \ndef fitness (individual, meta_data):\n    prs_count,day_count = individual.shape    \n    shift_prs = personnel_df.reset_index()\n    shift_prs['diff'] = 0\n    prs_count = 0\n    shift_lenght_diff = []\n    for prs in personnel_df.index: \n        shift_lenght = 0          \n        for day in range(day_count):\n#            print('shiftcode:'+str(individual.loc[prs,day+1]))\n            shift_lenght += meta_data.loc[individual.loc[prs,day+1]][1]\n\n        shift_lenght_diff.append(abs((shift_lenght/shift_prs.iloc[prs_count,3]) - 1))\n        shift_prs.set_value(prs_count,'RequirementWorkMins_real',shift_lenght)\n        shift_prs.set_value(prs_count,'diff',\n            abs(shift_lenght - shift_prs.iloc[prs_count,3])\n                               )        \n#        print(shift_lenght - shift_prs.iloc[prs_count,3])\n        prs_count += 1 \n        \n    cost = np.mean(shift_lenght_diff)\n#    print('cost: ' + str(cost))\n    return cost  \n# -----------------------prs output function-------------------------------------# \ndef get_personnel_diff_len (individual, meta_data):\n    prs_count,day_count = individual.shape    \n    shift_prs = personnel_df.reset_index()\n    shift_prs['diff'] = 0\n    prs_count = 0\n    shift_lenght_diff = []\n    for prs in personnel_df.index: \n        shift_lenght = 0          \n        for day in range(day_count):\n#            print('shiftcode:'+str(individual.loc[prs,day+1]))\n            shift_lenght += meta_data.loc[individual.loc[prs,day+1]][1]\n\n        shift_lenght_diff.append(shift_lenght-shift_prs.iloc[prs_count,3])\n        shift_prs.set_value(prs_count,'RequirementWorkMins_real',shift_lenght)\n        shift_prs.set_value(prs_count,'diff',\n            abs(shift_lenght - shift_prs.iloc[prs_count,3])\n                               )        \n#        print(shift_lenght - shift_prs.iloc[prs_count,3])\n        prs_count += 1 \n        \n    cost = np.mean(shift_lenght_diff)\n#    print('cost: ' + str(cost))\n    return cost,shift_prs\n# -----------------------Define GA--------------------------------------------# \n \nga = ga.GeneticAlgorithm( seed_data=chromosom_df,\n                          meta_data=shift_df,\n                          population_size=20,\n                          generations=10,\n                          crossover_probability=0.8,\n                          mutation_probability=0.2,\n                          elitism=True,\n                          maximise_fitness=False)\n \n # -----------------------run ga-----------------------------------------------# \n \nga.fitness_function = fitness               # set the GA's fitness function\nga.run()                                    # run the GA\nsol_fitness, sol_df = ga.best_individual()\nsol_fitness, prs_diff_df = get_personnel_diff_len(sol_df,shift_df)"""
run_treads.py,0,"b'import random\nfrom multiprocessing import Pool\nimport prs_day_based\n\n\n\nif __name__ == \'__main__\':\n    pool = Pool()\n    to_factor = [ random.randint(100000, 50000000) for i in range(20)]\n    results = pool.map(prs_day_based, to_factor)\n    for value, factors in zip(to_factor, results):\n        print(""The factors of {} are {}"".format(value, factors))'"
test.py,0,"b""import requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\n\n\n\n\nclass scrapy(object):\n    def __init__(self,\n                 url='http://tik8.com/category/',\n                 elems_class='card_banner card'\n                 ):\n        self.url = url\n        self.elems_class = elems_class\n        page = requests.get(self.url)\n\n        soup = BeautifulSoup(page.content, 'html.parser')\n\n        self.elems = soup.find_all('div', class_=elems_class)\n\n    def get_data(self):\n        server_url = self.url\n        api_url = self.url\n        api_list = ['theater', 'concert', 'cinema', 'kid', 'conference',\n                    'entertainment', 'Cultural-Heritage', 'escape-room']\n        data = []\n        for url in api_list:\n            event_type = url\n            url = api_url + url\n            print(event_type, url)\n            page = requests.get(url)\n            soup = BeautifulSoup(page.content, 'html.parser')\n            elems = soup.find_all('div', class_='card_banner card')\n            #################################################################\n            headers = ['event_type', 'details_api', 'title', 'location', 'image']\n            for elem in elems:\n                details_api = elem.find('a', class_='card_banner-box-hover__link-main')\n                title = elem.find('img', class_='card_poster2')\n                location = elem.find('span')\n\n                if None in details_api:\n                    continue\n                details_api = server_url + str(details_api['href'])\n                image = title['src']\n                title = title['alt']\n                location = location.text.strip()\n                data.append([event_type, details_api, title, location, image])\n\n        return pd.DataFrame(data, columns=headers)\n    def run(self):\n        self.get_data()\n\ns= scrapy()\ndata = s.get_data()\n        """
data_access/__init__.py,0,b'# -*- coding: utf-8 -*-\n\n'
data_access/csv.py,0,b'# -*- coding: utf-8 -*-\n\n'
data_access/sql_server.py,0,"b""# -*- coding: utf-8 -*-\n\nimport pandas as pd\nimport pyodbc\n\nclass data(object): \n    def __init__(self, \n                 conn_str, \n                 query_gene_last,\n                 query_gene_new,\n                 query_personnel,\n                 query_shift,\n                 query_shift_req,\n                 query_prs_req\n                 ):\n        # -------------------- Connection String -----------------------------#\n        self.conn_str = conn_str\n        self.sql_conn = pyodbc.connect(self.conn_str)\n        # ------------------ Query for gene pivoted --------------------------#\n        self.query_gene_last = query_gene_last\n        self.query_gene_new = query_gene_new\n        # ----------------- Query for personnel info -------------------------#\n        self.query_personnel = query_personnel        \n        # -------------------Query for shift info-----------------------------#\n        self.query_shift = query_shift  \n        # -------------------Query for shift_req info-------------------------#\n        self.query_shift_req = query_shift_req \n        # -------------------Query for shift_req info-------------------------#\n        self.query_prs_req = query_prs_req \n        #---------------------------------------------------------------------#         \n        self.cursor = self.sql_conn.cursor() \n        \n        self.new = 0\n               \n    def get_sql_conn(self):\n        sql_conn = self.sql_conn\n        return sql_conn\n        \n    def get_chromosom(self, work_sction_id, year_working_period):        \n        chromosom_df = pd.read_sql(self.query_gene_last, self.sql_conn)\n        if(chromosom_df.empty):              \n            self.new = 1\n            chromosom_df = pd.read_sql(self.query_gene_new, self.sql_conn)        \n            \n        return chromosom_df\n    \n    def get_personnel(self):\n        personnel_df = pd.read_sql(self.query_personnel,self.sql_conn)    \n        return personnel_df\n    \n    def get_shift(self):\n        shift_df = pd.read_sql(self.query_shift,self.sql_conn)\n        return shift_df\n    \n    def get_day_req(self):\n        day_req_df = pd.read_sql(self.query_shift_req,self.sql_conn)\n        return day_req_df\n    \n    def get_prs_req(self):\n        query_prs_req = pd.read_sql(self.query_prs_req,self.sql_conn)\n        return query_prs_req\n        \n    def delete_last_sol(self,work_sction_id,year_working_period):\n        cursor = self.cursor\n        query_delete = '''delete from PersonnelShiftDateAssignments \n                          where WorkSectionId ={0} and YearWorkingPeriod = {1}\n                        '''.format(work_sction_id,year_working_period)\n        cursor.execute(query_delete)\n        self.sql_conn.commit()                     \n    def is_new(self):\n        return self.new\n    def insert_sol(self, sol_tbl, personnel_df, sol_fitness,\n                   work_sction_id,year_working_period,\n                   rank): \n        cursor = self.cursor        \n        #------------------------ insert new solution ------------------------#\n        for i in range(len(sol_tbl)):\n            cursor.execute('''insert into PersonnelShiftDateAssignments  \n                               values (?, ?, ?, ?, ?, ?, ?, ?, ?)'''\n                               ,(sol_tbl[i])\n                               )  \n        #---------------- update UsedParentCount of parent solution ----------#\n        cursor.execute('''exec [dbo].[UpdateUsedParentCount] {0}, {1}, {2}\n                       '''.format(work_sction_id,year_working_period,rank))            \n        #---------------- update Rank of last solutions ----------------------#\n        cursor.execute('''exec [dbo].[UpdateLastRanks] {0}, {1}                         \n                       '''.format(work_sction_id,year_working_period))            \n# =============================================================================\n#         for prs in personnel_df.index:\n#             cursor.execute('''update [Personnel]\n#                               set [DiffNorm] = ?\n#                               where [PersonnelBaseId] = ? and\n#                                     [WorkSectionId] = ? and\n#                                     [YearWorkingPeriod] = ?\n#                            ''',\n#                            (float(personnel_df.loc[prs,'DiffNorm']),\n#                             prs,\n#                             int(personnel_df.loc[prs,'WorkSectionId']),\n#                             int(personnel_df.loc[prs,'YearWorkingPeriod'])\n#                             )\n#                            )\n#          \n# =============================================================================\n        self.sql_conn.commit()"""
libs/GA_dataframes.py,28,"b'# -*- coding: utf-8 -*-\n""""""\n    pyeasyga module\n""""""\n\nimport random\nimport copy\nfrom operator import attrgetter\nimport numpy as np\nfrom time import gmtime, strftime\nimport matplotlib.pyplot as plt\nfrom libs.get_random import get_rollet_wheel as rollet\n\nfrom six.moves import range\n\n\nclass GeneticAlgorithm(object):\n    """"""Genetic Algorithm class.\n    This is the main class that controls the functionality of the Genetic\n    Algorithm over 2 dim matrics.    \n    """"""\n\n    def __init__(self,\n                 seed_data,\n                 meta_data,\n                 population_size=50,\n                 generations=100,\n                 crossover_probability=0.8,\n                 mutation_probability=0.2,\n                 elitism=True,\n                 by_parent=False,\n                 maximise_fitness=True,\n                 initial_elit_prob=0.5,\n                 initial_random_prob=0.5):       \n\n        self.seed_data = seed_data\n        self.meta_data = meta_data\n        self.population_size = population_size\n        self.generations = generations\n        self.crossover_probability = crossover_probability\n        self.mutation_probability = mutation_probability\n        self.elitism = elitism\n        self.by_parent = by_parent\n        self.maximise_fitness = maximise_fitness\n        self.single_count = 0\n        self.double_count = 0\n        self.uniform_count = 0\n        self.mutate_count = 0\n        self.initial_elit_prob=initial_elit_prob,\n        self.initial_random_prob = initial_random_prob\n\n        self.current_generation = []\n             \n        \n        def single_crossover(parent_1, parent_2):                       \n            child_1, child_2 = parent_1, parent_2\n            row, col = parent_1.shape\n            for r in range(row):\n                crossover_index = (random.randrange(1, col - 1))\n                colt = crossover_index\n                child_1.iloc[r] = np.append(parent_1.iloc[r, :colt],\n                                            parent_2.iloc[r, colt:])    \n                child_2.iloc[r] = np.append(parent_1.iloc[r , \n                                            colt:],parent_2.iloc[r, :colt])            \n            return child_1, child_2\n        \n        def double_crossover(parent_1, parent_2):                       \n            child_1, child_2 = parent_1, parent_2\n            row, col = parent_1.shape\n            for r in range(row):\n                colt1 = (random.randrange(1, col - 1))\n                colt2 = (random.randrange(colt1, col - 1))  \n                 \n                s1 = parent_2.iloc[r, :colt1]\n                s1 = np.append(s1, parent_1.iloc[r, colt1:colt2])\n                s1 = np.append(s1, parent_2.iloc[r, colt2:])\n                child_1.iloc[r] = s1\n                                            \n                s2 = parent_1.iloc[r, :colt1]\n                s2 = np.append(s2, parent_2.iloc[r, colt1:colt2])\n                s2 = np.append(s2, parent_1.iloc[r, colt2:])\n                child_2.iloc[r] = s1         \n            return child_1, child_2\n        \n        def uniform_crossover(parent_1, parent_2):                       \n            child_1, child_2 = parent_1, parent_2\n            row, col = parent_1.shape\n            for r in range(row):\n                colt1 = (random.randrange(1, col - 1))   \n                colt2 = (random.randrange(colt1, col - 1))\n                colt3 = (random.randrange(colt2, col - 1))\n                colt4 = (random.randrange(colt3, col - 1))\n                colt5 = (random.randrange(colt4, col - 1))\n                colt6 = (random.randrange(colt5, col - 1))\n                colt7 = (random.randrange(colt6, col - 1))\n                colt8 = (random.randrange(colt7, col - 1))\n                colt9 = (random.randrange(colt8, col - 1))\n                 \n                s1= parent_2.iloc[r, :colt1]\n                s1 = np.append(s1, parent_1.iloc[r, colt1:colt2])\n                s1 = np.append(s1, parent_2.iloc[r, colt2:colt3])\n                s1 = np.append(s1, parent_1.iloc[r, colt3:colt4])\n                s1 = np.append(s1, parent_2.iloc[r, colt4:colt5])\n                s1 = np.append(s1, parent_1.iloc[r, colt5:colt6])\n                s1 = np.append(s1, parent_2.iloc[r, colt6:colt7])\n                s1 = np.append(s1, parent_1.iloc[r, colt7:colt8])\n                s1 = np.append(s1, parent_2.iloc[r, colt8:colt9])\n                s1 = np.append(s1, parent_1.iloc[r, colt9:])\n                child_1.iloc[r] = s1\n                                               \n                s2= parent_1.iloc[r, :colt1]\n                s2 = np.append(s2, parent_2.iloc[r, colt1:colt2])\n                s2 = np.append(s2, parent_1.iloc[r, colt2:colt3])\n                s2 = np.append(s2, parent_2.iloc[r, colt3:colt4])\n                s2 = np.append(s2, parent_1.iloc[r, colt4:colt5])\n                s2 = np.append(s2, parent_2.iloc[r, colt5:colt6])\n                s2 = np.append(s2, parent_1.iloc[r, colt6:colt7])\n                s2 = np.append(s2, parent_2.iloc[r, colt7:colt8])\n                s2 = np.append(s2, parent_1.iloc[r, colt8:colt9])\n                s2 = np.append(s2, parent_2.iloc[r, colt9:])\n                child_2.iloc[r] = s2\n                \n            return child_1, child_2\n\n        def mutate(individual):\n            parent = individual\n            row , col = parent.shape\n            shift_list = np.flip(meta_data.index.values.tolist())\n            for r in range(row):\n                mutate_index1 = random.randrange(1, col)\n                mutate_index2 = random.randrange(1, col)                \n                parent.iloc[r][mutate_index1] = np.random.choice(shift_list,\n                                                 p=[0.0,0.0,0.0,\n                                                    0.05,0.15,0.35,0.45],\n                                                 size=1)\n                parent.iloc[r][mutate_index2] = np.random.choice(shift_list,\n                                                 p=[0.0,0.0,0.0,\n                                                    0.05,0.15,0.35,0.45],\n                                                 size=1)\n        \n        def create_individual(data,meta_data):  \n            individual = data[:]\n            shift_list = meta_data.index.values.tolist()\n            for col in individual.columns :                  \n                individual[col] = np.random.choice(shift_list,\n                                                   size=len(individual))\n            return individual\n        \n        def create_individual_local_search(data,meta_data):  \n            individual = data[:]\n            p = random.random()\n            if p < 0.25:\n                individual, _ = single_crossover(individual, individual)\n            elif p < 0.5:\n                individual, _ = double_crossover(individual, individual)\n            elif p < 0.75:\n                individual, _ = uniform_crossover(individual, individual)                \n            else:\n                mutate(individual)         \n            return individual\n        \n        def random_selection(population):\n            """"""Select and return a random member of the population.""""""\n            return random.choice(population)\n        \n        def weighted_random_choice(population):\n            max = sum(chromosome.fitness for chromosome in population)\n            pick = random.uniform(0, max)\n            current = 0\n            for chromosome in population:\n                current += chromosome.fitness\n                if current > pick:\n                    return chromosome\n\n        def tournament_selection(population):\n            """"""Select a random number of individuals from the population and\n            return the fittest member of them all.\n            """"""\n            if self.tournament_size == 0:\n                self.tournament_size = 2\n            members = random.sample(population, self.tournament_size)\n            members.sort(\n                key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n            return members[0]\n\n        self.fitness_function = None\n        self.tournament_selection = tournament_selection\n        self.tournament_size = self.population_size // 10\n        self.random_selection = random_selection\n        self.create_individual = create_individual\n        self.single_crossover_function = single_crossover\n        self.double_crossover_function = double_crossover\n        self.uniform_crossover_function = uniform_crossover\n        self.mutate_function = mutate\n        self.selection_function = self.tournament_selection        \n\n    def create_initial_population(self):\n        """"""Create members of the first population randomly.\n        """"""\n        initial_population = []\n        individual = Chromosome(self.seed_data)\n        parent = copy.deepcopy(individual)\n               \n        for i in range(self.population_size):\n            genes = self.create_individual(self.seed_data,self.meta_data)                     \n            individual = Chromosome(genes)                              \n            individual.life_cycle = 1                                  \n            self.single_count += 1\n            initial_population.append(individual)\n        \n        if self.by_parent:\n            initial_population[0] = parent\n        self.current_generation = initial_population                  \n        \n        \n    def calculate_population_fitness(self):\n        """"""Calculate the fitness of every member of the given population using\n        the supplied fitness_function.\n        """"""\n        for individual in self.current_generation:\n            individual.set_fitness(self.fitness_function(individual.genes, \n                                                         self.meta_data)\n                                  )\n\n    def rank_population(self):\n        """"""Sort the population by fitness according to the order defined by\n        maximise_fitness.\n        """"""\n        self.current_generation.sort(\n            key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n        \n        \n\n    def create_new_population(self):\n        """"""Create a new population using the genetic operators (selection,\n        crossover, and mutation) supplied.\n        """"""\n        new_population = []\n        elite = copy.deepcopy(self.current_generation[0])\n        selection = self.selection_function\n\n        while len(new_population) < self.population_size:\n            parent_1 = copy.deepcopy(selection(self.current_generation))\n            parent_2 = copy.deepcopy(selection(self.current_generation))\n\n            child_1, child_2 = parent_1, parent_2\n            child_1.parent_fitness, child_2.parent_fitness = (parent_1.fitness, \n                                                              parent_2.fitness)\n            #-------------------- use tabu search ----------------------------#\n            \'\'\' if parent_1 or parent_2 use any opertator then these operators\n                shoud not play for create child_1 and child_2.\n                    << Tabu Search by last state of serach operation >>\n            \'\'\'\n            parent_single_cross_count = max(parent_1.single_cross_count,\n                                            parent_2.single_cross_count)                \n            parent_double_cross_count = max(parent_1.double_cross_count,\n                                            parent_2.double_cross_count)\n            parent_uniform_cross_count = max(parent_1.uniform_cross_count,\n                                             parent_2.uniform_cross_count)\n            parent_mutate_count = max(parent_1.mutate_count,\n                                      parent_2.mutate_count)\n            \n            prob_single_cross  = int(parent_single_cross_count == 0)\n            prob_double_cross  = int(parent_double_cross_count == 0)\n            prob_uniform_cross = int(parent_uniform_cross_count == 0)\n            prob_mutate        = int(parent_mutate_count == 0)\n            sum_all_prob = (prob_single_cross+prob_double_cross+\n                            prob_uniform_cross+prob_mutate)\n#            sum_all_prob = 0.00001 if sum_all_prob==0 else sum_all_prob\n            prob_single_cross  = prob_single_cross/sum_all_prob\n            prob_double_cross  = prob_double_cross/sum_all_prob\n            prob_uniform_cross = prob_uniform_cross/sum_all_prob\n            prob_mutate        = prob_mutate/sum_all_prob\n            #------------- rollet wheel -----------------#\n            p = random.random()            \n            cdf_prob_single_cross  =  prob_single_cross\n            cdf_prob_double_cross  = (prob_single_cross + \n                                      prob_double_cross \n                                      if prob_double_cross else 0) \n            cdf_prob_uniform_cross = (prob_single_cross + \n                                      prob_double_cross + \n                                      prob_uniform_cross\n                                      if prob_uniform_cross else 0) \n            cdf_prob_mutate        = (prob_single_cross + \n                                      prob_double_cross + \n                                      prob_uniform_cross+ \n                                      prob_mutate\n                                      if prob_mutate else 0) \n            \n            if p < cdf_prob_single_cross: \n                child_1.genes, child_2.genes = self.single_crossover_function(\n                    parent_1.genes, parent_2.genes)\n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.single_cross_count, child_2.single_cross_count = 1, 1                           \n                self.single_count += 1\n#                print(\'single_crossover_function\')\n            elif p < cdf_prob_double_cross: \n                child_1.genes, child_2.genes = self.double_crossover_function(\n                    parent_1.genes, parent_2.genes)          \n                child_1.set_init_count()\n                child_2.set_init_count()                \n                child_1.double_cross_count, child_2.double_cross_count = 1, 1                \n                self.double_count += 1\n#                print(\'double_crossover_function\')\n            elif p < cdf_prob_uniform_cross:\n                child_1.genes, child_2.genes = self.uniform_crossover_function(\n                    parent_1.genes, parent_2.genes) \n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.uniform_cross_count, child_2.uniform_cross_count = 1, 1                \n                self.uniform_count += 1\n#                print(\'uniform_crossover_function\')\n            else:\n                self.mutate_function(child_1.genes)\n                self.mutate_function(child_2.genes)\n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.mutate_count, child_2.mutate_count = 1, 1\n                self.mutate_count += 1\n#                print(\'mutate_function\')\n            #------------- ------------- -----------------#\n            \n\n            new_population.append(child_1)\n            if len(new_population) < self.population_size:\n                new_population.append(child_2)\n\n        if self.elitism:\n            new_population[0] = elite\n\n        self.current_generation = new_population\n\n    def create_first_generation(self):\n        """"""Create the first population, calculate the population\'s fitness and\n        rank the population by fitness according to the order specified.\n        """"""\n        self.create_initial_population()\n        self.calculate_population_fitness()\n        self.rank_population()\n\n    def create_next_generation(self):\n        """"""Create subsequent populations, calculate the population fitness and\n        rank the population by fitness in the order specified.\n        """"""\n        self.create_new_population()\n        self.calculate_population_fitness()\n        self.rank_population()\n\n    def run(self):\n        """"""Run (solve) the Genetic Algorithm.""""""\n        print(\'start: \'+ strftime(""%Y-%m-%d %H:%M:%S:%SS"", gmtime()))\n        self.create_first_generation()       \n        for g in range(1, self.generations):\n            print(\'---------- Start ---------------\')            \n            print(\'generation-\' +str(g) + \' -> start: \')                        \n            self.create_next_generation()  \n            print(\'best cost: \' + str(self.current_generation[0].fitness))\n            print(\'single_count:\' +str(self.single_count))\n            print(\'double_count:\' +str(self.double_count))\n            print(\'uniform_count:\' +str(self.uniform_count))\n            print(\'mutate_count:\' +str(self.mutate_count))\n        print(\'----------- End ----------------\')\n        print(\'end: \'+ strftime(""%Y-%m-%d %H:%M:%S:%SS"", gmtime()))\n    def best_individual(self):\n        """"""Return the individual with the best fitness in the current\n        generation.\n        """"""\n        best = self.current_generation[0]        \n        return (best.fitness, best.genes)\n\n    def last_generation(self):\n        """"""Return members of the last generation as a generator function.""""""\n        return ((member.fitness, member.genes) for member\n                in self.current_generation)\n\n\nclass Chromosome(object):\n    """""" Chromosome class that encapsulates an individual\'s fitness and solution\n    representation.\n    """"""\n    def __init__(self, genes):\n        """"""Initialise the Chromosome.""""""\n        self.genes = genes\n        self.fitness = 0\n        self.parent_fitness = 0\n        self.life_cycle = 0\n        self.fitness_const_count = 0\n        self.single_cross_count = 0\n        self.double_cross_count = 0\n        self.uniform_cross_count = 0\n        self.mutate_count = 0\n        self.elit = 0\n\n    def __repr__(self):\n        """"""Return initialised Chromosome representation in human readable form.\n        """"""\n        return repr((self.fitness, self.genes))\n    def set_fitness(self, fitness):\n        self.life_cycle += 1\n        #print(\'life_cycle:\' + str(self.life_cycle))\n        self.fitness = fitness\n        if self.parent_fitness == self.fitness :\n            self.fitness_const_count += 1\n            #print(\'fitness_const_count:\' + str(self.fitness_const_count))\n    def set_init_count(self):\n        self.single_cross_count = 0\n        self.double_cross_count = 0\n        self.uniform_cross_count = 0\n        self.mutate_count = 0\n        \n        \n        '"
libs/MOGA_s.py,6,"b'# -*- coding: utf-8 -*-\n""""""\n    pyeasyga module\n""""""\n\nimport random\nimport copy\nfrom operator import attrgetter\nimport numpy as np\nfrom time import gmtime, strftime\nimport matplotlib.pyplot as plt\n\nfrom six.moves import range\n\n\nclass GeneticAlgorithm(object):\n    """"""Genetic Algorithm class.\n    This is the main class that controls the functionality of the Genetic\n    Algorithm.\n    A simple example of usage:\n    >>> # Select only two items from the list and maximise profit\n    >>> from pyeasyga.pyeasyga import GeneticAlgorithm\n    >>> input_data = [(\'pear\', 50), (\'apple\', 35), (\'banana\', 40)]\n    >>> easyga = GeneticAlgorithm(input_data)\n    >>> def fitness (member, data):\n    >>>     return sum([profit for (selected, (fruit, profit)) in\n    >>>                 zip(member, data) if selected and\n    >>>                 member.count(1) == 2])\n    >>> easyga.fitness_function = fitness\n    >>> easyga.run()\n    >>> print easyga.best_individual()\n    """"""\n\n    def __init__(self,\n                 seed_data,\n                 meta_data,\n                 population_size=50,\n                 generations=100,\n                 crossover_probability=0.8,\n                 mutation_probability=0.2,\n                 elitism=True,\n                 maximise_fitness=True):\n        """"""Instantiate the Genetic Algorithm.\n        :param seed_data: input data to the Genetic Algorithm\n        :type seed_data: list of objects\n        :param int population_size: size of population\n        :param int generations: number of generations to evolve\n        :param float crossover_probability: probability of crossover operation\n        :param float mutation_probability: probability of mutation operation\n        """"""\n\n        self.seed_data = seed_data\n        self.meta_data = meta_data\n        self.population_size = population_size\n        self.generations = generations\n        self.crossover_probability = crossover_probability\n        self.mutation_probability = mutation_probability\n        self.elitism = elitism\n        self.maximise_fitness = maximise_fitness\n\n        self.current_generation = []\n\n        def create_individual(data,meta_data):  \n            individual = data[:]\n            for col in individual.columns :                  \n                individual[col] = np.random.choice(meta_data.index.values.tolist(),\n                                                   size=len(individual))\n            return individual\n        \n        def create_individual_elitism(data,meta_data, count):  \n            individual = data[:]\n            #print(individual)\n            row, col = individual.shape\n            if (count==0 and self.elitism):\n                individual = data[:]                                                  \n            else:\n                for r in range(row):\n                    crossover_index = (random.randrange(1, col - 1))\n                    colt = crossover_index\n                    individual.iloc[r] = np.append(individual.iloc[r, colt:],\n                                                   individual.iloc[r, :colt])                    \n            return individual\n\n        \n        def crossover(parent_1, parent_2):                       \n            child_1, child_2 = parent_1, parent_2\n            row, col = parent_1.shape\n            for r in range(row):\n                crossover_index = (random.randrange(1, col - 1))\n                colt = crossover_index\n                child_1.iloc[r] = np.append(parent_1.iloc[r, :colt],parent_2.iloc[r, colt:])    \n                child_2.iloc[r] = np.append(parent_1.iloc[r , colt:],parent_2.iloc[r, :colt])            \n            return child_1, child_2\n\n        def mutate(individual):\n            parent = individual\n            row , col = parent.shape\n            for r in range(row):\n                mutate_index1 = random.randrange(1, col)\n                mutate_index2 = random.randrange(1, col)                \n                parent.iloc[r][mutate_index1] = np.random.choice(meta_data.index.values.tolist(),\n                                                   size=1)\n                parent.iloc[r][mutate_index2] = np.random.choice(meta_data.index.values.tolist(),\n                                                   size=1)\n        \n\n        def random_selection(population):\n            """"""Select and return a random member of the population.""""""\n            return random.choice(population)\n\n        def tournament_selection(population):\n            """"""Select a random number of individuals from the population and\n            return the fittest member of them all.\n            """"""\n            if self.tournament_size == 0:\n                self.tournament_size = 2\n            members = random.sample(population, self.tournament_size)\n            members.sort(\n                key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n            return members[0]\n\n        self.fitness_function = None\n        self.tournament_selection = tournament_selection\n        self.tournament_size = self.population_size // 10\n        self.random_selection = random_selection\n        self.create_individual = create_individual_elitism\n        self.crossover_function = crossover\n        self.mutate_function = mutate\n        self.selection_function = self.tournament_selection\n\n    def create_initial_population(self):\n        """"""Create members of the first population randomly.\n        """"""\n        initial_population = []\n        for i in range(self.population_size):\n            genes = self.create_individual(self.seed_data,self.meta_data, i)            \n            individual = Chromosome(genes)\n            initial_population.append(individual)\n        self.current_generation = initial_population\n\n    def calculate_population_fitness(self,fit_count):\n        """"""Calculate the fitness of every member of the given population using\n        the supplied fitness_function.\n        """"""\n        for individual in self.current_generation:\n            individual.fitness = self.fitness_function(\n                individual.genes, self.meta_data, fit_count)\n\n    def rank_population(self):\n        """"""Sort the population by fitness according to the order defined by\n        maximise_fitness.\n        """"""\n        self.current_generation.sort(\n            key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n\n\n    def create_new_population(self):\n        """"""Create a new population using the genetic operators (selection,\n        crossover, and mutation) supplied.\n        """"""\n        new_population = []\n        elite = copy.deepcopy(self.current_generation[0])\n        selection = self.selection_function\n        max_pop = 2 * len(self.current_generation)\n        while len(new_population) < max_pop:\n            parent_1 = copy.deepcopy(selection(self.current_generation))\n            parent_2 = copy.deepcopy(selection(self.current_generation))\n\n            child_1, child_2 = parent_1, parent_2\n            child_1.fitness, child_2.fitness = 0, 0\n\n            can_crossover = random.random() < self.crossover_probability\n            can_mutate = random.random() < self.mutation_probability\n\n            if can_crossover:\n                child_1.genes, child_2.genes = self.crossover_function(\n                    parent_1.genes, parent_2.genes)\n\n            if can_mutate:\n                self.mutate_function(child_1.genes)\n                self.mutate_function(child_2.genes)\n\n            new_population.append(child_1)\n            if len(new_population) < max_pop:\n                new_population.append(child_2)        \n        \n        if self.elitism:\n            new_population[0] = elite\n        self.current_generation = new_population\n\n    def create_first_generation(self):\n        """"""Create the first population, calculate the population\'s fitness and\n        rank the population by fitness according to the order specified.\n        """"""\n        self.create_initial_population()\n        self.calculate_population_fitness(0)\n        self.rank_population()\n        print(\'best cost: \' + str(self.current_generation[0].fitness))\n        print(\'npop: \' + str(len(self.current_generation)))\n\n    def create_next_generation(self):\n        """"""Create subsequent populations, calculate the population fitness and\n        rank the population by fitness in the order specified.\n        """"""\n        self.create_new_population()        \n        \n        for i in range(2):                               # 2 is count of Obectives func\n            self.calculate_population_fitness(i+1)\n            self.rank_population()              \n            len_pop = len(self.current_generation)\n            precent_inx = (len_pop - round(len_pop * (1 / 100)) - 1)\n            if(len_pop > 3*self.population_size):\n                precent_inx = len_pop // 2\n            kill_pop = self.current_generation[precent_inx:len_pop-1]\n            self.current_generation = self.current_generation[0:precent_inx-1]\n                 \n\n    def run(self):\n        """"""Run (solve) the Genetic Algorithm.""""""\n        print(\'start: \'+ strftime(""%Y-%m-%d %H:%M:%S:%SS"", gmtime()))\n        self.create_first_generation()\n        lagr_t = 0.0001\n        for g in range(1, self.generations):\n            print(\'---------- Start ---------------\')            \n            print(\'generation-\' +str(g) + \' -> start: \'+ strftime(""%Y-%m-%d %H:%M:%S:%SS"", gmtime()))\n            if (g>100):\n                self.crossover_probability = (g/self.generations)\n                self.mutation_probability =  1.0 - (g/self.generations)\n            self.create_next_generation() \n            self.calculate_population_fitness(0)\n            self.rank_population()\n            print(\'best cost: \' + str(self.current_generation[0].fitness))\n            print(\'npop: \' + str(len(self.current_generation)))\n            if (g/100 - g//100 == 0):\n                csv_name = \'./output/out_MOGA_\' + str(g/100) + \'.csv\'\n                self.current_generation[0].genes.to_csv(csv_name)\n            print(\'----------- End ----------------\')\n\n    def best_individual(self):\n        """"""Return the individual with the best fitness in the current\n        generation.\n        """"""\n        best = self.current_generation[0]        \n        return (best.fitness, best.genes)\n\n    def last_generation(self):\n        """"""Return members of the last generation as a generator function.""""""\n        return ((member.fitness, member.genes) for member\n                in self.current_generation)\n\n\nclass Chromosome(object):\n    """""" Chromosome class that encapsulates an individual\'s fitness and solution\n    representation.\n    """"""\n    def __init__(self, genes):\n        """"""Initialise the Chromosome.""""""\n        self.genes = genes\n        self.fitness = 0\n\n    def __repr__(self):\n        """"""Return initialised Chromosome representation in human readable form.\n        """"""\n        return repr((self.fitness, self.genes))'"
libs/__init__.py,0,b''
libs/get_random.py,0,"b""# -*- coding: utf-8 -*-\nimport random\nimport copy\nimport pyodbc\nimport pandas as pd\n\ndef get_rollet_wheel(prob_list, rank_list):\n    cd_prob = copy.deepcopy(prob_list)\n    p = random.random()\n    for i in range(len(rank_list)):        \n        cd_prob[i] =  sum(prob_list[:i+1]) if prob_list[i] else 0    \n    \n    r = -1    \n    for i in range(len(cd_prob)):    \n        if p < cd_prob[i]:\n            r = rank_list[i]\n            break\n    return r\n\ndef get_best_first_rank(conn_str, query_gene_last):    \n    sql_conn = pyodbc.connect(conn_str)        \n    last_df = pd.read_sql(query_gene_last, sql_conn)\n    if last_df.empty:\n        return 0\n    min_diff = min(last_df['life_cycle'])\n    last_df['life_cycle'] = last_df['life_cycle'] / min_diff\n    \n    last_df['point'] = ( last_df['life_cycle']\n                          / \n                         (last_df['Rank'] * \n                          last_df['Cost'] * \n                          (last_df['UsedParentCount'] + 1 )                      \n                         )\n                        )\n    sum_point = sum(last_df['point'])\n    last_df['point'] = last_df['point'] / sum_point\n    rank_list = last_df['Rank']\n    prob_list = last_df['point']\n    \n    return get_rollet_wheel(prob_list,rank_list)\n\n\n"""
planing/covertor.py,0,"b""# -*- coding: utf-8 -*-\nimport pandas as pd\n\ndata_xls = pd.read_excel('attractions2.xlsx', 'Sheet1', index_col=None)\ndata_xls.to_csv('attractions2.csv', encoding='utf-8', index=False)\n\n"""
planing/dist_matrix.py,0,"b'import requests\nimport time\nimport pandas as pd\nfrom sqlalchemy import create_engine\n\nUSER = \'planuser\'\nPASSWORD = \'1qaz!QAZ\'\nHOST = \'localhost\'\nPORT = \'5432\'\nNAME = \'planing\'\ndb_connection_url = ""postgresql://{}:{}@{}:{}/{}"".format(USER,\n                                                         PASSWORD,\n                                                         HOST,\n                                                         PORT,\n                                                         NAME\n                                                        )\nengine = create_engine(db_connection_url)\ndf = pd.read_sql_query(\'\'\' SELECT \n                                 O.city AS CITY\n                            \t,O.ID AS ORIGIN\n                            \t,D.ID AS DIST\n                            \t,O.latt AS ORIG_LATT\n                            \t,O.long AS ORIG_LONG\n                            \t,D.latt AS DIST_LATT\n                            \t,D.long AS DIST_LONG\n                            FROM\n                            \tplan_attractions O\n                            \tJOIN plan_attractions D ON O.city = D.city\n                            WHERE O.city = \'\xd8\xa7\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\xd8\xa8\xd9\x88\xd9\x84\'\n                            ORDER BY O.city, O.ID, D.ID\n                       \'\'\'\n                          ,con=engine)\ndf[\'weight\'] = 0\ndf[\'duration\'] = 0\ndf[\'distance\'] = 0\n\nfor ind in df.index:\n          \n     status = \'\'\n     while status != \'Ok\':\n         origin = str(df.iloc[ind][3]) + \',\' + str(df.loc[ind][4])\n         dist   = str(df.loc[ind][5]) + \',\' + str(df.loc[ind][6])\n         url = \'http://router.project-osrm.org/route/v1/driving/{0};{1}?overview=false\'\\\n                    .format(origin, dist)\n                    \n         r = requests.get(url)\n         data = r.json() \n         try:\n             status = data[\'code\']\n         except:\n             status = \'\'\n         if status != \'Ok\':\n             time.sleep(0.5)         \n          \n     t = data[\'routes\'][0]\n     t = t[\'legs\'][0]\n     \n     df.at[ind,\'weight\'] = t[\'weight\']\n     df.at[ind,\'duration\'] = t[\'duration\']\n     df.at[ind,\'distance\'] = t[\'distance\']\n     print(\'index: \' + str(ind) + \' - \' + str(t[\'duration\']))\n\ndf.to_csv(\'mat.csv\') \n     '"
planing/ga_numpy.py,14,"b'import copy\nfrom operator import attrgetter\nimport numpy as np\nimport random\nimport numpy_indexed as npi\nfrom time import gmtime, strftime\n\n\nclass GeneticAlgorithm(object):\n    """"""Genetic Algorithm class.\n    This is the main class that controls the functionality of the Genetic\n    Algorithm over 2 dim matrics.    \n    """"""\n\n    def __init__(self,\n                 seed_data,\n                 meta_data,\n                 population_size=50,\n                 generations=100,\n                 crossover_probability=0.8,\n                 mutation_probability=0.2,\n                 elitism=True,\n                 by_parent=False,\n                 maximise_fitness=True,\n                 initial_elit_prob=0.5,\n                 initial_random_prob=0.5):       \n\n        self.seed_data = seed_data\n        self.meta_data = meta_data\n        self.population_size = population_size\n        self.generations = generations\n        self.crossover_probability = crossover_probability\n        self.mutation_probability = mutation_probability\n        self.elitism = elitism\n        self.by_parent = by_parent\n        self.maximise_fitness = maximise_fitness\n        self.single_count = 0\n        self.double_count = 0        \n        self.mutate_count = 0\n        self.add_swap_count = 0\n        self.initial_elit_prob=initial_elit_prob,\n        self.initial_random_prob = initial_random_prob\n\n        self.current_generation = []\n             \n        \n        def single_crossover(parent_1, parent_2):   \n            """"""This funcvtion create 2 childs by same sizes\n               but reverses (len(p1) = len(ch2) and ...)\n            """"""\n            row1, col1 = parent_1.shape\n            row2, col2 = parent_2.shape\n            row = np.min([row1,row2])\n            rowt = (random.randrange(1, row - 1 if row>2 else row))\n            #print(rowt)\n            \n            child_1 = np.concatenate((parent_1[:rowt, :], parent_2[rowt:, :]), axis = 0)    \n            child_2 = np.concatenate((parent_2[:rowt, :], parent_1[rowt:, :]), axis = 0)\n            """"""after create childs by composit of parents\n               probably create duplicated columns then shoud be remove\n               by ""group by"" of ""numpy_indexed"" \n            """"""    \n            _, child_1 = npi.group_by(child_1[:,0]).min(child_1)\n            _, child_2 = npi.group_by(child_2[:,0]).max(child_2)        \n            \n            return child_1, child_2\n            \n        def double_crossover(parent_1, parent_2):   \n            """"""This funcvtion create 2 childs by same sizes\n               but reverses (len(p1) = len(ch2) and ...)\n            """"""\n            row1, col1 = parent_1.shape\n            row2, col2 = parent_2.shape\n            row = np.min([row1,row2])\n            rowt1 = (random.randrange(1, row - 1 if row>2 else row))\n            rowt2 = (random.randrange(1, row - 1 if row>2 else row))\n            #print(rowt1,rowt2)\n            \n            child_1 = np.concatenate((parent_1[:rowt1, :], \n                                      parent_2[rowt1:rowt2, :],\n                                      parent_1[rowt2:, :]\n                                      ), axis = 0)    \n            child_2 = np.concatenate((parent_2[:rowt1, :], \n                                      parent_1[rowt1:rowt2, :],\n                                      parent_2[rowt2:, :]\n                                     ), axis = 0)\n            """"""after create childs by composit of parents\n               probably create duplicated columns then shoud be remove\n               by ""group by"" of ""numpy_indexed"" \n            """"""\n            \n            _, child_1 = npi.group_by(child_1[:,0]).min(child_1)\n            _, child_2 = npi.group_by(child_2[:,0]).max(child_2)\n            \n            return child_1, child_2\n            \n        def mutate(parent, meta_date):\n            child = parent\n            points = meta_data[0]\n            rq_time = meta_data[1]                                            \n            \n            row , col = child.shape    \n            rowt = random.randrange(1, row - 1 if row>2 else row)\n            #print(rowt)\n            child[rowt,0] = np.random.choice(points, size=1)[0]\n            child[rowt,1] = np.random.choice(rq_time, size=1)[0]\n            _, child = npi.group_by(child[:,0]).min(child)\n            return child\n        \n        def add_swap(parent, meta_date):\n            """"""This function vreate new child with adding\n               rows and then swaping last and random row\n            """"""\n        \n            child = parent\n            points = meta_data[0]\n            rq_time = meta_data[1]\n            \n            msk = np.isin(points, child[:,0])\n            points_accpt = points[~msk]\n            p = 1/len(points_accpt) if len(points_accpt)>0 else 1 \n            #print(points_accpt)\n            \n            while p < 1:\n                #print(p)\n                new_row = np.array([[np.random.choice(points_accpt, 1, p)[0],60]])    \n                child = np.append(child, new_row, axis=0)\n                \n                msk = np.isin(points, child[:,0])\n                points_accpt = points[~msk]\n                p = 1/len(points_accpt) if len(points_accpt)>0 else 1 \n            \n            row , col = child.shape\n            rowt = random.randrange(1, row - 1 if row>2 else row)\n            #print(rowt)\n            child[rowt, 0] ,child[row-1, 0] = child[row-1, 0], child[rowt, 0]\n            _, child = npi.group_by(child[:,0]).min(child)\n            \n            return child\n        \n        def create_individual(data,meta_data):  \n            """"""create new individual different to parent\n            """"""\n        \n            individual = data[:]\n            points = meta_data[0]\n            rq_time = meta_data[1]\n            #print(data.shape)\n            individual[:, 0] = np.random.choice(points, \n                                                size=len(individual),\n                                                replace=False).T\n            individual[:, 1] = np.random.choice(rq_time, \n                                                size=len(individual),\n                                                replace=False).T\n            return individual\n        \n        def create_individual_local_search(data,meta_data): \n            """"""create new individual similar to parent\n            """"""\n            \n            individual = data[:]\n            p = random.random()\n            if p < 0.25:\n                individual, _ = single_crossover(individual, individual)\n            elif p < 0.5:\n                individual, _ = double_crossover(individual, individual)\n            elif p < 0.75:\n                individual    = mutate(individual, meta_data)          \n            else:\n                individual    = add_swap(individual, meta_data)\t\t\t\t\n            return individual\n        \n        def random_selection(population):\n            """"""Select and return a random member of the population.""""""\n            return random.choice(population)\n        \n        def weighted_random_choice(population):\n            max = sum(chromosome.fitness for chromosome in population)\n            pick = random.uniform(0, max)\n            current = 0\n            for chromosome in population:\n                current += chromosome.fitness\n                if current > pick:\n                    return chromosome\n\n        def tournament_selection(population):\n            """"""Select a random number of individuals from the population and\n            return the fittest member of them all.\n            """"""\n            if self.tournament_size == 0:\n                self.tournament_size = 2\n            members = random.sample(population, self.tournament_size)\n            members.sort(\n                key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n            return members[0]\n\n        self.fitness_function = None\n        self.tournament_selection = tournament_selection\n        self.tournament_size = self.population_size // 10\n        self.random_selection = random_selection\n        self.create_individual = create_individual_local_search\n        self.single_crossover_function = single_crossover\n        self.double_crossover_function = double_crossover        \n        self.mutate_function = mutate\n        self.add_swap_function = add_swap\n        self.selection_function = self.tournament_selection        \n\n    def create_initial_population(self):\n        """"""Create members of the first population randomly.\n        """"""\n        initial_population = []\n        individual = Chromosome(self.seed_data)        \n        parent = copy.deepcopy(individual)\n        \n               \n        for i in range(self.population_size):\n            genes = self.create_individual(self.seed_data,self.meta_data)                     \n            individual = Chromosome(genes)                              \n            individual.life_cycle = 1                                  \n            self.single_count += 1\n            initial_population.append(individual)\n        \n        if self.by_parent:\n            initial_population[0] = parent\n        self.current_generation = initial_population                  \n        \n        \n    def calculate_population_fitness(self):\n        """"""Calculate the fitness of every member of the given population using\n        the supplied fitness_function.\n        """"""\n        for individual in self.current_generation:\n            individual.set_fitness(self.fitness_function(individual.genes, \n                                                         self.meta_data)\n                                  )\n\n    def rank_population(self):\n        """"""Sort the population by fitness according to the order defined by\n        maximise_fitness.\n        """"""\n        self.current_generation.sort(\n            key=attrgetter(\'fitness\'), reverse=self.maximise_fitness)\n        \n        \n\n    def create_new_population(self):\n        """"""Create a new population using the genetic operators (selection,\n        crossover, and mutation) supplied.\n        """"""\n        new_population = []\n        elite = copy.deepcopy(self.current_generation[0])\n        selection = self.selection_function\n                \n        while len(new_population) < self.population_size:\n            parent_1 = copy.deepcopy(selection(self.current_generation))\n            parent_2 = copy.deepcopy(selection(self.current_generation))\n\n            child_1, child_2 = parent_1, parent_2\n            child_1.parent_fitness, child_2.parent_fitness = (parent_1.fitness, \n                                                              parent_2.fitness)\n            #-------------------- use tabu search ----------------------------#\n            \'\'\' if parent_1 or parent_2 use any opertator then these operators\n                shoud not play for create child_1 and child_2.\n                    << Tabu Search by last state of serach operation >>\n            \'\'\'\n            parent_single_cross_count = max(parent_1.single_cross_count,\n                                            parent_2.single_cross_count)                \n            parent_double_cross_count = max(parent_1.double_cross_count,\n                                            parent_2.double_cross_count)            \n            parent_mutate_count = max(parent_1.mutate_count,\n                                      parent_2.mutate_count)\n            parent_add_swap_count = max(parent_1.add_swap_count,\n                                             parent_2.add_swap_count)\n            \n            prob_single_cross  = int(parent_single_cross_count == 0)\n            prob_double_cross  = int(parent_double_cross_count == 0)            \n            prob_mutate        = int(parent_mutate_count == 0)\n            prob_add_swap\t   = int(parent_add_swap_count == 0)\n            \n            sum_all_prob = (prob_single_cross+prob_double_cross+\n                            prob_mutate+prob_add_swap)\n            #            sum_all_prob = 0.00001 if sum_all_prob==0 else sum_all_prob\n            prob_single_cross  = prob_single_cross/sum_all_prob\n            prob_double_cross  = prob_double_cross/sum_all_prob            \n            prob_mutate        = prob_mutate/sum_all_prob\n            prob_add_swap \t   = prob_add_swap/sum_all_prob\n            #------------- rollet wheel -----------------#\n            p = random.random()            \n            cdf_prob_single_cross  =  prob_single_cross\n            cdf_prob_double_cross  = (prob_single_cross + \n                                      prob_double_cross if prob_double_cross else 0)             \n            cdf_prob_mutate        = (prob_single_cross + \n                                      prob_double_cross + \n                                      prob_mutate if prob_mutate else 0)\n            cdf_prob_add_swap \t   = (prob_single_cross + \n                                      prob_double_cross + \n                                      prob_mutate+ \n                                      prob_add_swap if prob_add_swap else 0)    \n            \n            if p < cdf_prob_single_cross: \n                child_1.genes, child_2.genes = self.single_crossover_function(\n                    parent_1.genes, parent_2.genes)\n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.single_cross_count, child_2.single_cross_count = 1, 1                           \n                self.single_count += 1\n#                print(\'single_crossover_function\')\n            elif p < cdf_prob_double_cross: \n                child_1.genes, child_2.genes = self.double_crossover_function(\n                    parent_1.genes, parent_2.genes)          \n                child_1.set_init_count()\n                child_2.set_init_count()                \n                child_1.double_cross_count, child_2.double_cross_count = 1, 1                \n                self.double_count += 1\n#                print(\'double_crossover_function\')\n            elif p < cdf_prob_mutate:\n                self.mutate_function(child_1.genes, self.meta_data)\n                self.mutate_function(child_2.genes, self.meta_data)\n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.mutate_count, child_2.mutate_count = 1, 1\n                self.mutate_count += 1\n#                print(\'mutate_function\')\n            else:\n                self.add_swap_function(child_1.genes, self.meta_data)\n                self.add_swap_function(child_2.genes, self.meta_data)\n                child_1.set_init_count()\n                child_2.set_init_count()\n                child_1.add_swap_count, child_2.add_swap_count = 1, 1\n                self.add_swap_count += 1\n#                print(\'add_swap_function\')\n            #------------- ------------- -----------------#\n            \n\n            new_population.append(child_1)\n            if len(new_population) < self.population_size:\n                new_population.append(child_2)\n\n        if self.elitism:\n            new_population[0] = elite\n\n        self.current_generation = new_population\n\n    def create_first_generation(self):\n        """"""Create the first population, calculate the population\'s fitness and\n        rank the population by fitness according to the order specified.\n        """"""\n        self.create_initial_population()\n        self.calculate_population_fitness()\n        self.rank_population()\n\n    def create_next_generation(self):\n        """"""Create subsequent populations, calculate the population fitness and\n        rank the population by fitness in the order specified.\n        """"""\n        self.create_new_population()\n        self.calculate_population_fitness()\n        self.rank_population()\n\n    def run(self):\n        """"""Run (solve) the Genetic Algorithm.""""""\n        start = gmtime()\n        self.create_first_generation()       \n        for g in range(1, self.generations):\n            #print(\'---------- Start ---------------\')            \n            print(\'generation: \' +str(g) + \' - cost: \' +\n                  str(self.current_generation[0].fitness))                        \n            self.create_next_generation()   \n        \n        end = gmtime()\n        duration = ((end.tm_hour-start.tm_hour)*360)+ \\\n                   ((end.tm_min-start.tm_min)*60)+ \\\n                   (end.tm_sec-start.tm_sec)*1\n        print(\'----------- End ----------------\')\n        print(\'best cost: \' + str(self.current_generation[0].fitness))\n        print(\'single_count:\' +str(self.single_count))\n        print(\'double_count:\' +str(self.double_count))            \n        print(\'mutate_count:\' +str(self.mutate_count))\n        print(\'add_swap_count:\' +str(self.add_swap_count))\n        print(\'duration: \'+ str(duration) + \'sec\')\n    def best_individual(self):\n        """"""Return the individual with the best fitness in the current\n        generation.\n        """"""\n        best = self.current_generation[0] \n        _, genes = npi.group_by(best.genes[:,0]).max(best.genes)\n        return (best.fitness, genes)\n\n    def last_generation(self):\n        """"""Return members of the last generation as a generator function.""""""\n        return ((member.fitness, member.genes) for member\n                in self.current_generation)\n\n\nclass Chromosome(object):\n    """""" Chromosome class that encapsulates an individual\'s fitness and solution\n    representation.\n    """"""\n    def __init__(self, genes):\n        """"""Initialise the Chromosome.""""""\n        self.genes = genes\n        self.fitness = 0\n        self.parent_fitness = 0\n        self.life_cycle = 0\n        self.fitness_const_count = 0\n        self.single_cross_count = 0\n        self.double_cross_count = 0        \n        self.mutate_count = 0\n        self.add_swap_count = 0\n        self.elit = 0\n        \n    def get_genes(self):\n        \n        return self.genes\n\n    def __repr__(self):\n        """"""Return initialised Chromosome representation in human readable form.\n        """"""\n        return repr((self.fitness, self.genes))\n    def set_fitness(self, fitness):\n        self.life_cycle += 1\n        #print(\'life_cycle:\' + str(self.life_cycle))\n        self.fitness = fitness\n        if self.parent_fitness == self.fitness :\n            self.fitness_const_count += 1\n            #print(\'fitness_const_count:\' + str(self.fitness_const_count))\n    def set_init_count(self):\n        self.single_cross_count = 0\n        self.double_cross_count = 0        \n        self.mutate_count = 0\n        self.add_swap_count = 0'"
planing/new_plan.py,13,"b'# -*- coding: utf-8 -*-\nimport pandas as pd\nimport numpy as np\nfrom ga_numpy import GeneticAlgorithm as ga\nimport numpy_indexed as npi\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy import create_engine\n\n\n##############################\ncity = 24 #  \'\xd8\xa7\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\xd8\xa8\xd9\x88\xd9\x84\'\nstart_time = 480\nend_time = 1260\n\ncoh_fultm = 0.8\ncoh_lntm  = 0.0\ncoh_cnt   = 0.2\ncoh_dffRqTime  = 0.0\n##############################\n\nUSER = \'planuser\'\nPASSWORD = \'1qaz!QAZ\'\nHOST = \'localhost\'\nPORT = \'5432\'\nNAME = \'planing\'\ndb_connection = ""postgresql://{}:{}@{}:{}/{}"".format(USER,\n                                                         PASSWORD,\n                                                         HOST,\n                                                         PORT,\n                                                         NAME\n                                                        )\nengine = create_engine(db_connection)\ndf = pd.read_sql_query(\'SELECT * FROM\tplan_attractions\',con=engine)\ndf = df.drop([\'image\'], axis=1)\n\ndf_city = df[df[\'city_id\']==city]\n\ndist_mat_query = \'\'\' select \n                         origin_id as orgin\n                        ,destination_id as dist\n                        ,len_time as len\n                     from \n                       plan_distance_mat\n                     where\n                       origin_id in \n                       (select id from plan_attractions\n                        where city_id = {0})\n                       \'\'\'.format(city)\n             \ndist_df = pd.read_sql_query(dist_mat_query\n                          ,con=engine)\n\ndist_mat = pd.pivot_table(dist_df,                           \n                          index=[\'orgin\'],\n                          columns=[\'dist\'], \n                          values=\'len\', \n                          aggfunc=np.sum)\n\nvst_time_from = df_city[\'vis_time_from\'] \nvst_time_to = df_city[\'vis_time_to\']\npoints = df_city[\'id\']\nrq_time = df_city[\'rq_time\']\n\nmeta_data = np.array([points, rq_time], dtype=int)\n\npln_gene1 = np.array([points, \n                      rq_time, \n                      ], dtype=int).T\npln_gene2 = np.array([np.flip(points), \n                      np.flip(rq_time), \n                     ], dtype=int).T\t\t\t\t\t\t  \n\t\t\t\t\t\t\t  \ndef cost_fulltime(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    edge = len_pln - 1   \n    all_dist = 0\n    all_duration = np.sum(plan[:,1])\n    pln_pnt = plan[:,0]\n    for i,orig in enumerate(pln_pnt):    \n        if i<edge:\n            all_dist += dist_mat.loc[orig , pln_pnt[i+1]]\n    plan_lenght = all_dist + all_duration  \n    cost = np.abs((start_time + plan_lenght) - end_time) / 1440.0     \n      \n    return cost\n\ndef cost_lentime(individual, all_dist, all_duration ):         \n    cost = all_dist / (all_duration + all_dist)\n      \n    return cost\n\t\ndef cost_count(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    len_points = len(meta_data[0])\n    cost = np.abs(len_points-len_pln) / len_points\n    \n    return cost\n\ndef cost_rqTime(individual, meta_data):\n    plan = individual\n   \n    t = np.concatenate((plan, meta_data.T))\n    _, t_max = npi.group_by(t[:,0]).max(t)\n    _, t_min = npi.group_by(t[:,0]).min(t)\n    t = (t_max - t_min)/t_max\n    cost = np.sum(t[:,1]) / len(plan)   \n    \n    return cost\n\ndef fitness(individual, meta_data):    \n    _, individual = npi.group_by(individual[:,0]).max(individual)\n    \n    len_pln = len(individual)\n    edge = len_pln - 1   \n    pln_pnt = individual[:,0]\n    len_points = len(points)\n    all_duration = np.sum(individual[:,1])\n    all_dist = 0\n    for i,orig in enumerate(pln_pnt):    \n        if i<edge:\n            all_dist += dist_mat.loc[orig , pln_pnt[i+1]]\n    \n\n    cost_fultm = cost_fulltime(individual, meta_data)\n    cost_lntm  = cost_lentime(individual, all_dist, all_duration)\n    cost_cnt   = cost_count(individual, meta_data)\n    cost_diff_rqTime = cost_rqTime(individual, meta_data)\n#    print(len_cost, cnt_cost, diff_rqTime_cost)\n    cost =((coh_fultm*cost_fultm) + \n           (coh_lntm*cost_lntm) + \n           (coh_cnt*cost_cnt) + \n           (coh_dffRqTime*cost_diff_rqTime)\n           )\n#    print(cost)\n    \n    return cost\n\nga = ga(seed_data=pln_gene1,\n        meta_data=meta_data,\n        population_size=50,\n        generations=100,\n        crossover_probability=0.8,\n        mutation_probability=0.2,\n        elitism=True,\n        by_parent=False,\n        maximise_fitness=False)\t\nga.fitness_function = fitness\n\nga.run()   \n\nsol_fitness, sol_df = ga.best_individual()\n\ndef lenght(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    edge = len_pln - 1   \n    all_dist = 0\n    all_duration = np.sum(plan[:,1])\n    pln_pnt = plan[:,0]\n    for i,orig in enumerate(pln_pnt):    \n        if i<edge:\n            all_dist += dist_mat.loc[orig , pln_pnt[i+1]]\n    \n    return all_duration + all_dist\n\nlen_pln = len(sol_df)\nedge = len_pln - 1   \npln_pnt = sol_df[:,0]\nlen_points = len(points)\nall_duration = np.sum(sol_df[:,1])\nall_dist = lenght(sol_df, meta_data)\nall_lenght = all_dist + all_duration\n    \ncost_fultm = cost_fulltime(sol_df, meta_data)\ncost_lntm  = cost_lentime(sol_df, all_dist, all_duration)\ncost_cnt   = cost_count(sol_df, meta_data)\ncost_diff_rqTime = cost_rqTime(sol_df, meta_data)\ndiff_full_time = (start_time + all_lenght) - end_time\n\n\n\n\n\n'"
planing/plan.py,11,"b'import pandas as pd\nimport numpy as np\nfrom ga_numpy import GeneticAlgorithm as ga\nimport numpy_indexed as npi\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy import create_engine\n\n\n##############################\ncity = 24 #  \'\xd8\xa7\xd8\xb3\xd8\xaa\xd8\xa7\xd9\x86\xd8\xa8\xd9\x88\xd9\x84\'\nstart_time = 480\nend_time = 1260\n\nalpha = 0.8\nbeta = 0.2\ngama = 0.0\n##############################\n\nUSER = \'planuser\'\nPASSWORD = \'1qaz!QAZ\'\nHOST = \'localhost\'\nPORT = \'5432\'\nNAME = \'planing\'\ndb_connection = ""postgresql://{}:{}@{}:{}/{}"".format(USER,\n                                                         PASSWORD,\n                                                         HOST,\n                                                         PORT,\n                                                         NAME\n                                                        )\nengine = create_engine(db_connection)\ndf = pd.read_sql_query(\'SELECT * FROM\tplan_attractions\',con=engine)\ndf = df.drop([\'image\'], axis=1)\n\ndf_city = df[df[\'city_id\']==city]\n\ndist_mat_query = \'\'\' select \n                         origin_id as orgin\n                        ,destination_id as dist\n                        ,len_time as len\n                     from \n                       plan_distance_mat\n                     where\n                       origin_id in \n                       (select id from plan_attractions\n                        where city_id = {0})\n                       \'\'\'.format(city)\n             \ndist_df = pd.read_sql_query(dist_mat_query\n                          ,con=engine)\n\ndist_mat = pd.pivot_table(dist_df,                           \n                          index=[\'orgin\'],\n                          columns=[\'dist\'], \n                          values=\'len\', \n                          aggfunc=np.sum)\n\nvst_time_from = df_city[\'vis_time_from\'] \nvst_time_to = df_city[\'vis_time_to\']\npoints = df_city[\'id\']\nrq_time = df_city[\'rq_time\']\n\nmeta_data = np.array([points, rq_time], dtype=int)\n\npln_gene1 = np.array([points, \n                      rq_time, \n                      ], dtype=int).T\npln_gene2 = np.array([np.flip(points), \n                      np.flip(rq_time), \n                     ], dtype=int).T\t\t\t\t\t\t  \n\t\t\t\t\t\t\t  \ndef fulltime_cost(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    edge = len_pln - 1   \n    all_dist = 0\n    all_duration = np.sum(plan[:,1])\n    pln_pnt = plan[:,0]\n    for i,orig in enumerate(pln_pnt):    \n        if i<edge:\n            all_dist += dist_mat.loc[orig , pln_pnt[i+1]]\n    plan_lenght = all_dist + all_duration  \n    cost = np.abs((start_time + plan_lenght) - end_time) / 1440.0    \n      \n    return cost\n\t\ndef count_cost(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    len_points = len(meta_data[0])\n    cost = np.abs(len_points-len_pln) / len_points\n    \n    return cost\n\ndef rqTime_cost(individual, meta_data):\n    plan = individual\n   \n    t = np.concatenate((plan, meta_data.T))\n    _, t_max = npi.group_by(t[:,0]).max(t)\n    _, t_min = npi.group_by(t[:,0]).min(t)\n    t = (t_max - t_min)/t_max\n    cost = np.sum(t[:,1]) / len(plan)   \n    \n    return cost\n\ndef fitness(individual, meta_data):    \n    _, individual = npi.group_by(individual[:,0]).max(individual)\n    fultm_cost = fulltime_cost(individual, meta_data)\n    cnt_cost = count_cost(individual, meta_data)\n    diff_rqTime_cost = rqTime_cost(individual, meta_data)\n#    print(len_cost, cnt_cost, diff_rqTime_cost)\n    cost = (alpha*fultm_cost) + (beta*cnt_cost) + (gama*diff_rqTime_cost)\n#    print(cost)\n    \n    return cost\n\nga = ga(seed_data=pln_gene1,\n        meta_data=meta_data,\n        population_size=50,\n        generations=100,\n        crossover_probability=0.8,\n        mutation_probability=0.2,\n        elitism=True,\n        by_parent=False,\n        maximise_fitness=False)\t\nga.fitness_function = fitness\n\nga.run()   \n\nsol_fitness, sol_df = ga.best_individual()\n\ndef lenght(individual, meta_data):\n    plan = individual\n    len_pln = len(plan)\n    edge = len_pln - 1   \n    all_dist = 0\n    all_duration = np.sum(plan[:,1])\n    pln_pnt = plan[:,0]\n    for i,orig in enumerate(pln_pnt):    \n        if i<edge:\n            all_dist += dist_mat.loc[orig , pln_pnt[i+1]]\n    \n    return all_duration + all_dist\n\ncost_len = fulltime_cost(sol_df, meta_data)\ncost_cnt = count_cost(sol_df, meta_data)\ncost_diff_rqTime = rqTime_cost(sol_df, meta_data)\nall_lenght = lenght(sol_df, meta_data)\ndiff_full_time = (start_time + all_lenght) - end_time\n\n\n\n\n'"
libs/test/__init__.py,0,b'# -*- coding: utf-8 -*-\n\n'
libs/test/binary_tets.py,0,"b""from libs.pyeasyga import binary_ga as ga\n\n# setup data\ndata = [(821, 0.8, 118), (1144, 1, 322), (634, 0.7, 166), (701, 0.9, 195),\n        (291, 0.9, 100), (1702, 0.8, 142), (1633, 0.7, 100), (1086, 0.6, 145),\n        (124, 0.6, 100), (718, 0.9, 208), (976, 0.6, 100), (1438, 0.7, 312),\n        (910, 1, 198), (148, 0.7, 171), (1636, 0.9, 117), (237, 0.6, 100),\n        (771, 0.9, 329), (604, 0.6, 391), (1078, 0.6, 100), (640, 0.8, 120),\n        (1510, 1, 188), (741, 0.6, 271), (1358, 0.9, 334), (1682, 0.7, 153),\n        (993, 0.7, 130), (99, 0.7, 100), (1068, 0.8, 154), (1669, 1, 289)]\n\nga = ga.GeneticAlgorithm(data)        # initialise the GA with data\nga.population_size = 200                    # increase population size to 200\n\n# define a fitness function\ndef fitness(individual, data):\n    weight, volume, price = 0, 0, 0\n    for (selected, item) in zip(individual, data):\n        if selected:\n            weight += item[0]\n            volume += item[1]\n            price += item[2]\n    if weight > 12210 or volume > 12:\n        price = 0\n    return price\n\nga.fitness_function = fitness               # set the GA's fitness function\nga.run()                                    # run the GA\nprint(ga.best_individual())                  # print the GA's best solution\n"""
libs/test/integer_test.py,0,"b""import random\nfrom libs.pyeasyga import binary_ga as pyeasyga\n# setup seed data\nseed_data = [0, 1, 2, 3, 4, 5, 6, 7]\n# initialise the GA\nga = pyeasyga.GeneticAlgorithm(seed_data,\n                                population_size=200,\n                                generations=100,\n                                crossover_probability=0.8,\n                                mutation_probability=0.2,\n                                elitism=True,\n                                maximise_fitness=False)\n# define and set the GA's selection operation\ndef selection(population):\n    return random.choice(population)\n\nga.selection_function = selection\n\n# define a fitness function\ndef fitness (individual, data):\n    collisions = 0\n    for item in individual:\n        item_index = individual.index(item)\n        for elem in individual:\n            elem_index = individual.index(elem)\n            if item_index != elem_index:\n                if item - (elem_index - item_index) == elem \\\n                    or (elem_index - item_index) + item == elem:\n                    collisions += 1\n    return collisions\n\nga.fitness_function = fitness # set the GA's fitness function\nga.run() # run the GA\n\n# function to print out chess board with queens placed in position\ndef print_board(board_representation):\n    def print_x_in_row(row_length, x_position):\n        print( '',)\n        for _ in range(row_length):\n            print ('---',)\n        print( '\\n|',)\n        for i in range(row_length):\n            if i == x_position:\n                print( '{} |'.format('X'),)\n            else:\n                print (' |',)\n        print ('')\n    def print_board_bottom(row_length):\n        print ('',)\n        for _ in range(row_length):\n            print ('---',)\n            \n    num_of_rows = len(board_representation)\n    row_length = num_of_rows #rows == columns in a chessboard\n    for row in range(num_of_rows):\n        print_x_in_row(row_length, board_representation[row])\n        \n    print_board_bottom(row_length)\n    print ('\\n')\n\n# print the GA's best solution; a solution is valid only if there are no collisions\nif ga.best_individual()[0] == 0:\n    print (ga.best_individual())\n    print_board(ga.best_individual()[1])\nelse:\n    print( None)"""
