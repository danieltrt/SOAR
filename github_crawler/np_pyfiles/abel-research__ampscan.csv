file_path,api_count,code
setup.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nfrom setuptools import setup, find_packages\nfrom os import path, walk\n\n\ndef readme():\n    with open(\'README.md\') as f:\n        return f.read()\n\ndef requirements():\n    with open(\'requirements.txt\') as f:\n        return f.read().split(\'\\n\')\n\n\nsetup(name=\'ampscan\',\n      version=\'0.3.0\',\n      description=(\'Package for analysis of \'\n                   \'surface scan data for P&O applications\'),\n      long_description=readme(),\n      author=\'Joshua Steer\',\n      author_email=\'Joshua.Steer@soton.ac.uk\',\n      license=\'MIT\',\n      include_package_data=True,\n      packages=find_packages(),\n      python_requires=\'>=3.5\',  # Your supported Python ranges\n      install_requires=requirements(),\n      url = \'https://ampscan.readthedocs.io/en/latest/\',\n      zip_safe=False,)\n'"
ampscan/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nfrom .core import AmpObject\nfrom .registration import registration\nfrom .align import align\nfrom . import analyse\nfrom . import vis'"
ampscan/align.py,70,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for dealing with alignment methods between two AmpObject meshes\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nimport numpy as np\nimport copy\nimport vtk\nimport math\nfrom scipy import spatial\nfrom scipy.optimize import minimize\nfrom ampscan.core import AmpObject\nfrom ampscan.vis import vtkRenWin\n\n# For doc examples\nimport os\nstaticfh = os.path.join(os.getcwd(), ""tests"", ""stl_file.stl"")\nmovingfh = os.path.join(os.getcwd(), ""tests"", ""stl_file_2.stl"")\n\n\nclass align(object):\n    r""""""\n    Automated alignment methods between two meshes\n    \n    Parameters\n    ----------\n    moving: AmpObject\n        The moving AmpObject that is to be aligned to the static object\n    static: AmpObject\n        The static AmpObject that the moving AmpObject that the moving object \n        will be aligned to\n    method: str, default \'linPoint2Plane\'\n        A string of the method used for alignment\n    *args:\n    \tThe arguments used for the alignment methods\n    **kwargs:\n    \tThe keyword arguments used for the alignment methods\n\n    Returns\n    -------\n    m: AmpObject\n        The aligned AmpObject, it same number of vertices and face array as \n        the moving AmpObject\n        Access this using align.m\n\n    Examples\n    --------\n    >>> static = AmpObject(staticfh)\n    >>> moving = AmpObject(movingfh)\n    >>> al = align(moving, static).m\n\n    """"""    \n\n    def __init__(self, moving, static, method = \'linPoint2Plane\', *args, **kwargs):\n        mData = dict(zip([\'vert\', \'faces\', \'values\'], \n                         [moving.vert, moving.faces, moving.values]))\n        alData = copy.deepcopy(mData)\n        self.m = AmpObject(alData, stype=\'reg\')\n        self.s = static\n        self.runICP(method=method, *args, **kwargs)\n        \n    \n    def runICP(self, method = \'linPoint2Plane\', maxiter=20, inlier=1.0,\n               initTransform=None, *args, **kwargs):\n        r""""""\n        The function to run the ICP algorithm, this function calls one of \n        multiple methods to calculate the affine transformation \n        \n        Parameters\n        ----------\n        method: str, default \'linPoint2Plane\'\n            A string of the method used for alignment\n        maxiter: int, default 20\n            Maximum number of iterations to run the ICP algorithm\n        inlier: float, default 1.0\n            The proportion of closest points to use to calculate the \n            transformation, if < 1 then vertices with highest error are \n            discounted\n        *args:\n        \tThe arguments used for the alignment methods\n        **kwargs:\n        \tThe keyword arguments used for the alignment methods\n        \n        """"""\n        # Define the rotation, translation, error and quaterion arrays\n        Rs = np.zeros([3, 3, maxiter+1])\n        Ts = np.zeros([3, maxiter+1])\n#        qs = np.r_[np.ones([1, maxiter+1]), \n#                   np.zeros([6, maxiter+1])]\n#        dq  = np.zeros([7, maxiter+1])\n#        dTheta = np.zeros([maxiter+1])\n        err = np.zeros([maxiter+1])\n        if initTransform is None:\n            initTransform = np.eye(4)\n        Rs[:, :, 0] = initTransform[:3, :3]\n        Ts[:, 0] = initTransform[3, :3]\n#        qs[:4, 0] = self.rot2quat(Rs[:, :, 0]) \n#        qs[4:, 0] = Ts[:, 0]\n        # Define \n        fC = self.s.vert[self.s.faces].mean(axis=1)\n        kdTree = spatial.cKDTree(fC)\n        self.m.rigidTransform(Rs[:, :, 0], Ts[:, 0])\n        inlier = math.ceil(self.m.vert.shape[0]*inlier)\n        [dist, idx] = kdTree.query(self.m.vert, 1)\n        # Sort by distance\n        sort = np.argsort(dist)\n        # Keep only those within the inlier fraction\n        [dist, idx] = [dist[sort], idx[sort]]\n        [dist, idx, sort] = dist[:inlier], idx[:inlier], sort[:inlier]\n        err[0] = math.sqrt(dist.mean())\n        for i in range(maxiter):\n            if method == \'linPoint2Point\':\n                [R, T] = getattr(self, method)(self.m.vert[sort, :],\n                                               fC[idx, :], \n                                               *args, **kwargs)\n            elif method == \'linPoint2Plane\': \n                [R, T] = getattr(self, method)(self.m.vert[sort, :],\n                                               fC[idx, :], \n                                               self.s.norm[idx, :],\n                                               *args, **kwargs)\n            elif method == \'optPoint2Point\':\n                [R, T] = getattr(self, method)(self.m.vert[sort, :],\n                                               fC[idx, :],\n                                               *args, **kwargs)\n            elif method == \'contPoints\':\n                [R, T] = getattr(self, method)(*args, **kwargs)\n                self.m.rigidTransform(R, T)\n                [dist, idx] = kdTree.query(self.m.vert, 1)\n                sort = np.argsort(dist)\n                [dist, idx] = [dist[sort], idx[sort]]\n                [dist, idx, sort] = dist[:inlier], idx[:inlier], sort[:inlier]\n                self.tForm = np.r_[np.c_[R, np.zeros(3)], np.append(T, 1)[:, None].T]\n                self.R = R\n                self.T = T\n                self.rmse = math.sqrt(dist.mean())\n                return \n            else: KeyError(\'Not a supported alignment method\')\n            Rs[:, :, i+1] = np.dot(R, Rs[:, :, i])\n            Ts[:, i+1] = np.dot(R, Ts[:, i]) + T\n            self.m.rigidTransform(R, T)\n            [dist, idx] = kdTree.query(self.m.vert, 1)\n            sort = np.argsort(dist)\n            [dist, idx] = [dist[sort], idx[sort]]\n            [dist, idx, sort] = dist[:inlier], idx[:inlier], sort[:inlier]\n            err[i+1] = math.sqrt(dist.mean())\n#            qs[:, i+1] = np.r_[self.rot2quat(R), T]\n        R = Rs[:, :, -1]\n        #Simpl\n        [U, s, V] = np.linalg.svd(R)\n        R = np.dot(U, V)\n        self.tForm = np.r_[np.c_[R, np.zeros(3)], np.append(Ts[:, -1], 1)[:, None].T]\n        self.R = R\n        self.T = Ts[:, -1]\n        self.rmse = err[-1]\n        \n            \n    \n    @staticmethod\n    def linPoint2Plane(mv, sv, sn):\n        r""""""\n        Iterative Closest Point algorithm which relies on using least squares\n        method from converting the minimisation problem into a set of linear \n        equations. This uses a \n        \n        Parameters\n        ----------\n        mv: ndarray\n            The array of vertices to be moved \n        sv: ndarray\n            The array of static vertices, these are the face centroids of the \n            static mesh\n        sn: ndarray\n            The normals of the point in teh static array, these are derived \n            from the normals of the faces for each centroid\n        \n        Returns\n        -------\n        R: ndarray\n            The optimal rotation array \n        T: ndarray\n            The optimal translation array\n        \n        References\n        ----------\n        .. [1] Besl, Paul J.; N.D. McKay (1992). ""A Method for Registration of 3-D\n           Shapes"". IEEE Trans. on Pattern Analysis and Machine Intelligence (Los\n           Alamitos, CA, USA: IEEE Computer Society) 14 (2): 239-256.\n        \n        .. [2] Chen, Yang; Gerard Medioni (1991). ""Object modelling by registration of\n           multiple range images"". Image Vision Comput. (Newton, MA, USA:\n           Butterworth-Heinemann): 145-155\n\n        Examples\n        --------\n        >>> static = AmpObject(staticfh)\n        >>> moving = AmpObject(movingfh)\n        >>> al = align(moving, static, method=\'linPoint2Plane\').m\n        \n        """"""\n        cn = np.c_[np.cross(mv, sn), sn]\n        C = np.dot(cn.T, cn)\n        v = sv - mv\n        b = np.zeros([6])\n        for i, col in enumerate(cn.T):\n            b[i] = (v * np.repeat(col[:, None], 3, axis=1) * sn).sum()\n        X = np.linalg.lstsq(C, b, rcond=None)[0]\n        [cx, cy, cz] = np.cos(X[:3])\n        [sx, sy, sz] = np.sin(X[:3])\n        R = np.array([[cy*cz, sx*sy*cz-cx*sz, cx*sy*cz+sx*sz],\n                      [cy*sz, cx*cz+sx*sy*sz, cx*sy*sz-sx*cz],\n                      [-sy,            sx*cy,          cx*cy]])\n        T = X[3:]\n        return (R, T)\n    \n    @staticmethod\n    def linPoint2Point(mv, sv):\n        r""""""\n        Point-to-Point Iterative Closest Point algorithm which \n        relies on using singular value decomposition on the centered arrays.  \n        \n        Parameters\n        ----------\n        mv: ndarray\n            The array of vertices to be moved \n        sv: ndarray\n            The array of static vertices, these are the face centroids of the \n            static mesh\n        \n        Returns\n        -------\n        R: ndarray\n            The optimal rotation array \n        T: ndarray\n            The optimal translation array\n        \n        References\n        ----------\n        .. [1] Besl, Paul J.; N.D. McKay (1992). ""A Method for Registration of 3-D\n           Shapes"". IEEE Trans. on Pattern Analysis and Machine Intelligence (Los\n           Alamitos, CA, USA: IEEE Computer Society) 14 (2): 239-256.\n        \n        .. [2] Chen, Yang; Gerard Medioni (1991). ""Object modelling by registration of\n           multiple range images"". Image Vision Comput. (Newton, MA, USA:\n           Butterworth-Heinemann): 145-155\n\n        Examples\n        --------\n        >>> static = AmpObject(staticfh)\n        >>> moving = AmpObject(movingfh)\n        >>> al = align(moving, static, method=\'linPoint2Point\').m\n\n        """"""\n        mCent = mv - mv.mean(axis=0)\n        sCent = sv - sv.mean(axis=0)\n        C = np.dot(mCent.T, sCent)\n        [U,_,V] = np.linalg.svd(C)\n        det = np.linalg.det(np.dot(U, V))\n        sign = np.eye(3)\n        sign[2,2] = np.sign(det)\n        R = np.dot(V.T, sign)\n        R = np.dot(R, U.T)\n        T = sv.mean(axis=0) - np.dot(R, mv.mean(axis=0))\n        return (R, T)\n\n    @staticmethod\n    def contPoints(mv=None, sv=None):\n        r""""""\n        Point-to-Point Iterative Closest Point algorithm which \n        relies on using singular value decomposition on the centered arrays.  \n        \n        Parameters\n        ----------\n        mv: ndarray\n            The array of control points to be moved \n        sv: ndarray\n            The array of control points \n        \n        Returns\n        -------\n        R: ndarray\n            The optimal rotation array \n        T: ndarray\n            The optimal translation array\n        \n        References\n        ----------\n        .. [1] Besl, Paul J.; N.D. McKay (1992). ""A Method for Registration of 3-D\n           Shapes"". IEEE Trans. on Pattern Analysis and Machine Intelligence (Los\n           Alamitos, CA, USA: IEEE Computer Society) 14 (2): 239-256.\n        \n        .. [2] Chen, Yang; Gerard Medioni (1991). ""Object modelling by registration of\n           multiple range images"". Image Vision Comput. (Newton, MA, USA:\n           Butterworth-Heinemann): 145-155\n\n        Examples\n        --------\n        >>> static = AmpObject(staticfh)\n        >>> moving = AmpObject(movingfh)\n        >>> al = align(moving, static, method=\'linPoint2Point\').m\n\n        """"""\n        if mv is None or sv is None:\n            return ValueError(\'To call the contPoints ICP method, ensure that \'\n                              \'mv and sv have been defined as keyword arguments\')\n        mv = np.asarray(mv)\n        sv = np.asarray(sv)\n        if mv.shape != sv.shape:\n            return ValueError(\'Not the same number of static and moving control points\')\n        mCent = mv - mv.mean(axis=0)\n        sCent = sv - sv.mean(axis=0)\n        C = np.dot(mCent.T, sCent)\n        [U,_,V] = np.linalg.svd(C)\n        det = np.linalg.det(np.dot(U, V))\n        sign = np.eye(3)\n        sign[2,2] = np.sign(det)\n        R = np.dot(V.T, sign)\n        R = np.dot(R, U.T)\n        T = sv.mean(axis=0) - np.dot(R, mv.mean(axis=0))\n        print(R)\n        print(T)\n        return (R, T)\n    \n    @staticmethod\n    def optPoint2Point(mv, sv, opt=\'L-BFGS-B\'):\n        r""""""\n        Direct minimisation of the rmse between the points of the two meshes. This \n        method enables access to all of Scipy\'s minimisation algorithms \n        \n        Parameters\n        ----------\n        mv: ndarray\n            The array of vertices to be moved \n        sv: ndarray\n            The array of static vertices, these are the face centroids of the \n            static mesh\n        opt: str, default \'L_BFGS-B\'\n            The string of the scipy optimiser to use \n        \n        Returns\n        -------\n        R: ndarray\n            The optimal rotation array \n        T: ndarray\n            The optimal translation array\n            \n        Examples\n        --------\n        >>> static = AmpObject(staticfh)\n        >>> moving = AmpObject(movingfh)\n        >>> al = align(moving, static, method=\'optPoint2Point\', opt=\'SLSQP\').m\n            \n        """"""\n        X = np.zeros(6)\n        lim = [-np.pi/4, np.pi/4] * 3 + [-5, 5] * 3\n        lim = np.reshape(lim, [6, 2])\n        try:\n            X = minimize(align.optDistError, X,\n                         args=(mv, sv),\n                         bounds=lim, method=opt)\n        except:\n            X = minimize(align.optDistError, X,\n                         args=(mv, sv),\n                         method=opt)\n        [angx, angy, angz] = X.x[:3]\n        Rx = np.array([[1, 0, 0],\n                       [0, np.cos(angx), -np.sin(angx)],\n                       [0, np.sin(angx), np.cos(angx)]])\n        Ry = np.array([[np.cos(angy), 0, np.sin(angy)],\n                       [0, 1, 0],\n                       [-np.sin(angy), 0, np.cos(angy)]])\n        Rz = np.array([[np.cos(angz), -np.sin(angz), 0],\n                       [np.sin(angz), np.cos(angz), 0],\n                       [0, 0, 1]])\n        R = np.dot(np.dot(Rz, Ry), Rx)\n        T = X.x[3:]\n        return (R, T)\n\n    @staticmethod\n    def optDistError(X, mv, sv):\n        r""""""\n        The function to minimise. It performs the affine transformation then returns \n        the rmse between the two vertex sets\n        \n        Parameters\n        ----------\n        X:  ndarray\n            The affine transformation corresponding to [Rx, Ry, Rz, Tx, Ty, Tz]\n        mv: ndarray\n            The array of vertices to be moved \n        sv: ndarray\n            The array of static vertices, these are the face centroids of the \n            static mesh\n\n        Returns\n        -------\n        err: float\n            The RMSE between the two meshes\n        \n        """"""\n        [angx, angy, angz] = X[:3]\n        Rx = np.array([[1, 0, 0],\n                       [0, np.cos(angx), -np.sin(angx)],\n                       [0, np.sin(angx), np.cos(angx)]])\n        Ry = np.array([[np.cos(angy), 0, np.sin(angy)],\n                       [0, 1, 0],\n                       [-np.sin(angy), 0, np.cos(angy)]])\n        Rz = np.array([[np.cos(angz), -np.sin(angz), 0],\n                       [np.sin(angz), np.cos(angz), 0],\n                       [0, 0, 1]])\n        R = np.dot(np.dot(Rz, Ry), Rx)\n        moved = np.dot(mv, R.T)\n        moved += X[3:]\n        dist = (moved - sv)**2\n        dist = dist.sum(axis=1)\n        err = np.sqrt(dist.mean())\n        return err\n\n    \n    @staticmethod\n    def rot2quat(R):\n        """"""\n        Convert a rotation matrix to a quaternionic matrix\n        \n        Parameters\n        ----------\n        R: array_like\n            The 3x3 rotation array to be converted to a quaternionic matrix\n        \n        Returns\n        -------\n        Q: ndarray\n            The quaternionic matrix\n\n        """"""\n        [[Qxx, Qxy, Qxz],\n         [Qyx, Qyy, Qyz],\n         [Qzx, Qzy, Qzz]] = R\n        t = Qxx + Qyy + Qzz\n        if t >= 0:\n            r = math.sqrt(1+t)\n            s = 0.5/r\n            w = 0.5*r\n            x = (Qzy-Qyz)*s\n            y = (Qxz-Qzx)*s\n            z = (Qyx-Qxy)*s\n        else:\n            maxv = max([Qxx, Qyy, Qzz])\n            if maxv == Qxx:\n                r = math.sqrt(1+Qxx-Qyy-Qzz)\n                s = 0.5/r\n                w = (Qzy-Qyz)*s\n                x = 0.5*r\n                y = (Qyx+Qxy)*s\n                z = (Qxz+Qzx)*s\n            elif maxv == Qyy:\n                r = math.sqrt(1+Qyy-Qxx-Qzz)\n                s = 0.5/r\n                w = (Qxz-Qzx)*s\n                x = (Qyx+Qxy)*s\n                y = 0.5*r\n                z = (Qzy+Qyz)*s\n            else:\n                r = math.sqrt(1+Qzz-Qxx-Qyy)\n                s = 0.5/r\n                w = (Qyx-Qxy)*s\n                x = (Qxz+Qzx)*s\n                y = (Qzy+Qyz)*s\n                z = 0.5*r\n        return np.array([w, x, y, z])\n    \n    def display(self):\n        r""""""\n        Display the static mesh and the aligned within an interactive VTK \n        window \n        \n        """"""\n        if not hasattr(self.s, \'actor\'):\n            self.s.addActor()\n        if not hasattr(self.m, \'actor\'):\n            self.m.addActor()\n        # Generate a renderer window\n        win = vtkRenWin()\n        # Set the number of viewports\n        win.setnumViewports(1)\n        # Set the background colour\n        win.setBackground([1,1,1])\n        # Set camera projection \n        renderWindowInteractor = vtk.vtkRenderWindowInteractor()\n        renderWindowInteractor.SetRenderWindow(win)\n        renderWindowInteractor.SetInteractorStyle(vtk.vtkInteractorStyleTrackballCamera())\n        # Set camera projection \n        win.setView()\n        self.s.actor.setColor([1.0, 0.0, 0.0])\n        self.s.actor.setOpacity(0.5)\n        self.m.actor.setColor([0.0, 0.0, 1.0])\n        self.m.actor.setOpacity(0.5)\n        win.renderActors([self.s.actor, self.m.actor])\n        win.Render()\n        win.rens[0].GetActiveCamera().Azimuth(180)\n        win.rens[0].GetActiveCamera().SetParallelProjection(True)\n        win.Render()\n        return win\n\n\n    def genIm(self, crop=False):\n        r""""""\n        Display the static mesh and the aligned within an interactive VTK \n        window \n        \n        """"""\n        if not hasattr(self.s, \'actor\'):\n            self.s.addActor()\n        if not hasattr(self.m, \'actor\'):\n            self.m.addActor()\n        # Generate a renderer window\n        win = vtkRenWin()\n        # Set the number of viewports\n        win.setnumViewports(1)\n        # Set the background colour\n        win.setBackground([1,1,1])\n        # Set camera projection \n        # Set camera projection \n        win.setView([0, -1, 0], 0)\n        win.SetSize(512, 512)\n        win.Modified()\n        win.OffScreenRenderingOn()\n        self.s.actor.setColor([1.0, 0.0, 0.0])\n        self.s.actor.setOpacity(0.5)\n        self.m.actor.setColor([0.0, 0.0, 1.0])\n        self.m.actor.setOpacity(0.5)\n        win.renderActors([self.s.actor, self.m.actor])\n        win.Render()\n        win.rens[0].GetActiveCamera().Azimuth(0)\n        win.rens[0].GetActiveCamera().SetParallelProjection(True)\n        win.Render()\n        im = win.getImage()\n        if crop is True:\n            mask = np.all(im == 1, axis=2)\n            mask = ~np.all(mask, axis=1)\n            im = im[mask, :, :]\n            mask = np.all(im == 1, axis=2)\n            mask = ~np.all(mask, axis=0)\n            im = im[:, mask, :]\n        return im, win\n\n'"
ampscan/core.py,66,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for defining the core AmpObject\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n\n""""""\n\nimport numpy as np\nimport os\nimport struct\nfrom ampscan.trim import trimMixin\nfrom ampscan.smooth import smoothMixin\nfrom ampscan.vis import visMixin\n\n\n# The file path used in doc examples\nfilename = os.path.join(os.getcwd(), ""tests"", ""stl_file.stl"")\n\n\nclass AmpObject(trimMixin, smoothMixin, visMixin):\n    r""""""\n    Base class for the ampscan project.\n    Stores mesh data and extra information \n    Inherits methods via mixins\n    Flexible class able to deal with surface data using 3 or 4 node faces and \n    visualise nodal data such as FEA outputs or shape deviations\n    \n    Parameters\n    ----------\n    data : str or dict\n        Data input as either a string to import from an external file or a \n        dictionary to pull values directly\n    stype : str, optional\n        descriptor of the type of data the AmpObject is representing, e.g \n        \'limb\' or \'socket\'. Default is \'limb\'\n    \n    Returns\n    -------\n    AmpObject\n        Initiation of the object\n    \n    Examples\n    -------\n    >>> amp = AmpObject(filename)\n\n    """"""\n\n    def __init__(self, data=None, stype=\'limb\', unify=True, struc=True):\n        self.stype = stype\n        self.createCMap()\n        if isinstance(data, str):\n            self.read_stl(data, unify, struc)\n        elif isinstance(data, dict):\n            for k, v in data.items():\n                setattr(self, k, v)\n            self.calcStruct()\n        elif isinstance(data, bytes):\n            self.read_bytes(data, unify, struc)\n\n    \n\n\n    def read_stl(self, filename, unify=True, struc=True):\n        """"""\n        Function to read .stl file from filename and import data into \n        the AmpObj \n        \n        Parameters\n        -----------\n        filename: str \n            file path of the .stl file to read \n        unify: boolean, default True\n            unify the coincident vertices of each face\n        struc: boolean, default True\n            Calculate the underlying structure of the mesh, such as edges\n\n        """"""\n        with open(filename, \'rb\') as fh:\n        # Defined no of bytes for header and no of faces\n            HEADER_SIZE = 80\n            COUNT_SIZE = 4\n            # State the data type and length in bytes of the normals and vertices\n            data_type = np.dtype([(\'normals\', np.float32, (3, )),\n                                  (\'vertices\', np.float32, (9, )),\n                                  (\'atttr\', \'<i2\', (1, ))])\n            # Read the header of the STL\n            head = fh.read(HEADER_SIZE).lower()\n            # Read the number of faces\n            NFaces, = struct.unpack(\'@i\', fh.read(COUNT_SIZE))\n            # Read the remaining data and save as void, then close file\n            data = np.fromfile(fh, data_type)\n        # Test if the file is ascii\n        if str(head[:5], \'utf-8\') == \'solid\':\n            raise ValueError(""ASCII files not supported"")\n        # Write the data to a numpy arrays in AmpObj\n        tfcond = NFaces==data[\'vertices\'].shape[0]\t\t\t#assigns true or false to tfcond\n        if not tfcond:\t\t\t\t\t\t\t#if tfcond is false, raise error\n            raise ValueError(""File is corrupt"")\t\t\t\t\t\t\t#if true, move on\n        vert = np.resize(np.array(data[\'vertices\']), (NFaces*3, 3))\n        norm = np.array(data[\'normals\'])\n        faces = np.reshape(range(NFaces*3), [NFaces,3])\n        self.faces = faces\n        self.vert = vert\n        self.norm = norm\n        \n        # Call function to unify vertices of the array\n        if unify is True:\n            self.unifyVert()\n        # Call function to calculate the edges array\n#        self.fixNorm()\n        if struc is True:\n            self.calcStruct()\n        self.values = np.zeros([len(self.vert)])\n\n    def read_bytes(self, data, unify=True, struc=True):\n        """"""\n        Function to read .stl file from filename and import data into \n        the AmpObj \n        \n        Parameters\n        -----------\n        filename: str \n            file path of the .stl file to read \n        unify: boolean, default True\n            unify the coincident vertices of each face\n        struc: boolean, default True\n            Calculate the underlying structure of the mesh, such as edges\n\n        """"""\n        # Defined no of bytes for header and no of faces\n        HEADER_SIZE = 80\n        COUNT_SIZE = 4\n        # State the data type and length in bytes of the normals and vertices\n        data_type = np.dtype([(\'normals\', np.float32, (3, )),\n                                (\'vertices\', np.float32, (9, )),\n                                (\'atttr\', \'<i2\', (1, ))])\n        # Read the header of the STL\n        head = data[:HEADER_SIZE].lower()\n        # Read the number of faces\n        NFaces, = struct.unpack(\'@i\', data[HEADER_SIZE:HEADER_SIZE+COUNT_SIZE])\n        # Read the remaining data and save as void, then close file\n        data = np.frombuffer(data[COUNT_SIZE+HEADER_SIZE:], data_type)\n        # Test if the file is ascii\n        if str(head[:5], \'utf-8\') == \'solid\':\n            raise ValueError(""ASCII files not supported"")\n        # Write the data to a numpy arrays in AmpObj\n        tfcond = NFaces==data[\'vertices\'].shape[0]\t\t\t#assigns true or false to tfcond\n        if not tfcond:\t\t\t\t\t\t\t#if tfcond is false, raise error\n            raise ValueError(""File is corrupt"")\t\t\t\t\t\t\t#if true, move on\n        vert = np.resize(np.array(data[\'vertices\']), (NFaces*3, 3))\n        norm = np.array(data[\'normals\'])\n        faces = np.reshape(range(NFaces*3), [NFaces,3])\n        self.faces = faces\n        self.vert = vert\n        self.norm = norm\n        \n        # Call function to unify vertices of the array\n        if unify is True:\n            self.unifyVert()\n        # Call function to calculate the edges array\n#        self.fixNorm()\n        if struc is True:\n            self.calcStruct()\n        self.values = np.zeros([len(self.vert)])\n        \n    def calcStruct(self, norm=True, edges=True, \n                   edgeFaces=True, faceEdges=True, vNorm=False):\n        r""""""\n        Top level function to calculate the underlying structure of the \n        AmpObject\n        \n        Parameters\n        ----------\n        norm: boolean, default True\n            If true, the normals of each face in the mesh will be calculated\n        edges: boolean, default True\n            If true, the edges of the mesh will be calculated, the refers to\n            the vertex index that make up any edge\n        edgeFaces: boolean, default True\n            If true, the edgeFaces array of the mesh will be calculated, this \n            refers to the index of the three edges that make up each face\n        faceEdges: boolean, default True\n            If true, the faceEdges array will be calculated, this refers to \n            index of the faces that are coincident to each edge. Normally, \n            there are two faces per edge, if there is only one, then -99999 \n            will be used to indicate this \n        vNorm: boolean, default False\n            If true, the normals of each vertex in the mesh will be calculated\n\n        """"""\n        if norm is True:\n            self.calcNorm()\n        if edges is True:\n            self.calcEdges()\n        if edgeFaces is True:\n            self.calcEdgeFaces()\n        if faceEdges is True:\n            self.calcFaceEdges()\n        if vNorm is True:\n            self.calcVNorm()\n\n    def unifyVert(self):\n        r""""""\n        Function to unify coincident vertices of the mesh to reduce\n        size of the vertices array enabling speed increases when performing\n        calculations using the vertex array\n        \n        Examples\n        --------\n        >>> amp = AmpObject(filename, unify=False)\n        >>> amp.vert.shape\n        (44832, 3)\n        >>> amp.unifyVert()\n        >>> amp.vert.shape\n        (7530, 3)\n\n        """"""\n        # Requires numpy 1.13\n        self.vert, indC = np.unique(self.vert, return_inverse=True, axis=0)\n        # Maps the new vertices index to the face array\n        self.faces = np.resize(indC[self.faces], \n                               (len(self.norm), 3)).astype(np.int32)\n\n    def calcEdges(self):\n        """"""\n        Function to compute the edges array ie the index of the two vertices\n        that make up each edge\n        \n        Returns\n        -------\n        edges: ndarray\n            Denoting the indicies of two vertices on each edge\n\n        """"""\n        # Get edges array\n        self.edges = np.reshape(self.faces[:, [0, 1, 0, 2, 1, 2]], [-1, 2])\n        self.edges = np.sort(self.edges, 1)\n        # Unify the edges\n        self.edges, indC = np.unique(self.edges, return_inverse=True, axis=0)\n\n    def calcEdgeFaces(self):\n        r""""""\n        Function that calculates the indicies of the three edges that make up\n        each face \n        \n        Returns\n        -------\n        edgesFace: ndarray\n            Denoting the indicies of the three edges on each face\n        \n        """"""\n        edges = np.reshape(self.faces[:, [0, 1, 0, 2, 1, 2]], [-1, 2])\n        edges = np.sort(edges, 1)\n        # Unify the edges\n        edges, indC = np.unique(edges, return_inverse=True, axis=0)\n        # Get edges on each face \n        self.edgesFace = np.reshape(range(len(self.faces)*3), [-1,3])\n        #Remap the edgesFace array \n        self.edgesFace = indC[self.edgesFace].astype(np.int32)\n\n    def calcFaceEdges(self):\n        r""""""\n        Function that calculates the indicies of the faces on each edge\n        \n        Returns\n        -------\n        faceEdges: ndarray\n            The indicies of the faces in each edge, edges may have either \n            1 or 2 faces, if 1 then the second index will be NaN\n\n        """"""\n        #Initiate the faceEdges array\n        self.faceEdges = np.empty([len(self.edges), 2], dtype=np.int32)\n        self.faceEdges.fill(-99999)\n        # Denote the face index for flattened edge array\n        fInd = np.repeat(np.array(range(len(self.faces))), 3)\n        # Flatten edge array\n        eF = np.reshape(self.edgesFace, [-1])\n        eFInd = np.unique(eF, return_index=True)[1]\n        logic = np.zeros([len(eF)], dtype=bool)\n        logic[eFInd] = True\n        self.faceEdges[eF[logic], 0] = fInd[logic]\n        self.faceEdges[eF[~logic], 1] = fInd[~logic]        \n        \n\n    def calcNorm(self):\n        r""""""\n        Calculate the normal of each face of the AmpObj\n        \n        Returns\n        -------\n        \n        norm: ndarray\n            normal of each face\n\n        """"""\n        norms = np.cross(self.vert[self.faces[:,1]] -\n                         self.vert[self.faces[:,0]],\n                         self.vert[self.faces[:,2]] -\n                         self.vert[self.faces[:,0]])\n        mag = np.linalg.norm(norms, axis=1)\n        self.norm = np.divide(norms, mag[:,None])\n    \n    def fixNorm(self):\n        r""""""\n        Fix normals of faces so they all face outwards \n        """"""\n        fC = self.vert[self.faces].mean(axis=1)\n        cent = self.vert.mean(axis=0)\n        # polarity = np.sum(self.norm * (fC-cent), axis=1) < 0\n        # if polarity.mean() > 0.5:\n        #     self.faces[:, [1,2]] = self.faces[:, [2,1]]\n        #     self.calcNorm()\n        #     if hasattr(self, \'vNorm\'): self.calcVNorm()\n        polarity  = np.einsum(\'ij, ij->i\', fC - cent, self.norm) < 0\n        # self.faces[polarity, [1,2]] = self.faces[polarity, [2,1]]\n        for i, f in enumerate(self.faces):\n            if polarity[i] == True:\n                self.faces[i, :] = [f[0], f[2], f[1]]\n\n        self.calcNorm()\n        if hasattr(self, \'vNorm\'): self.calcVNorm()\n        \n    def calcVNorm(self):\n        """"""\n        Function to compute the vertex normals based upon the mean of the\n        connected face normals \n        \n        Returns\n        -------\n        vNorm: ndarray\n            normal of each vertex\n\n        """"""\n        f = self.faces.flatten()\n        o_idx = f.argsort()\n        row, col = np.unravel_index(o_idx, self.faces.shape)\n        ndx = np.searchsorted(f[o_idx], range(self.vert.shape[0]), side=\'right\')\n        ndx = np.r_[0, ndx]\n        norms = self.norm[row, :]\n        self.vNorm = np.zeros(self.vert.shape)\n        for i in range(self.vert.shape[0]):\n            self.vNorm[i, :] = np.nanmean(norms[ndx[i]:ndx[i+1], :], axis=0)\n            \n\n    def save(self, filename):\n        r""""""\n        Function to save the AmpObj as a binary .stl file \n        \n        Parameters\n        -----------\n        filename: str\n            file path of the .stl file to save to\n\n        """"""\n        self.calcNorm()\n        fv = self.vert[np.reshape(self.faces, len(self.faces)*3)]\n        with open(filename, \'wb\') as fh:\n            header = \'%s\' % (filename)\n            header = header.split(\'/\')[-1].encode(\'utf-8\')\n            header = header[:80].ljust(80, b\' \')\n            packed = struct.pack(\'@i\', len(self.faces))\n            fh.write(header)\n            fh.write(packed)\n            data_type = np.dtype([(\'normals\', np.float32, (3, )),\n                                  (\'vertices\', np.float32, (9, )),\n                                  (\'atttr\', \'<i2\', (1, ))])\n            data_write = np.zeros(len(self.faces), dtype=data_type)\n            data_write[\'normals\'] = self.norm\n            data_write[\'vertices\'] = np.reshape(fv, (len(self.faces), 9))\n            data_write.tofile(fh)\n\n    def translate(self, trans):\n        r""""""\n        Translate the AmpObj in 3D space\n\n        Parameters\n        -----------\n        trans: array_like\n            Translation in [x, y, z]\n\n        """"""\n\n        # Check that trans is array like\n        if isinstance(trans, (list, np.ndarray, tuple)):\n            # Check that trans has exactly 3 dimensions\n            if len(trans) == 3:\n                self.vert[:] += trans\n            else:\n                raise ValueError(""Translation has incorrect dimensions. Expected 3 but found: "" + str(len(trans)))\n        else:\n            raise TypeError(""Translation is not array_like: "" + trans)\n\n    def centre(self):\n        r""""""\n        Centre the AmpObject based upon the mean of all the vertices\n\n        """"""\n        self.translate(-self.vert.mean(axis=0))\n\n    def centreStatic(self, static):\n        r""""""\n        Centre this AmpObject on the static AmpObject\'s centroid based upon the mean of all the vertices\n\n        Parameters\n        ----------\n        static : AmpObject\n            The static shape to center this object onto\n\n        """"""\n        if isinstance(static, AmpObject):\n            self.translate(-self.vert.mean(axis=0)+static.vert.mean(axis=0))\n        else:\n            raise TypeError(""centre_static method expects AmpObject, found: {}"".format(type(static)))\n    \n    def rotateAng(self, rot, ang=\'rad\', norms=True):\n        r""""""\n        Rotate the AmpObj in 3D space according to three angles\n\n        Parameters\n        -----------\n        rot: array_like\n            Rotation around [x, y, z]\n        ang: str, default \'rad\'\n            Specify if the euler angles are in degrees or radians. \n            Default is radians\n        \n        Examples\n        --------\n        >>> amp = AmpObject(filename)\n        >>> ang = [np.pi/2, -np.pi/4, np.pi/3]\n        >>> amp.rotateAng(ang, ang=\'rad\')\n        """"""\n\n        # Check that ang is valid\n        if ang not in (\'rad\', \'deg\'):\n            raise ValueError(""Ang expected \'rad\' or \'deg\' but {} was found"".format(ang))\n\n        if isinstance(rot, (tuple, list, np.ndarray)):\n            R = self.rotMatrix(rot, ang)\n            self.rotate(R, norms)\n        else:\n            raise TypeError(""rotateAng requires a list"")\n\n            \n    def rotate(self, R, norms=True):\n        r""""""\n        Rotate the AmpObject using a rotation matrix \n        \n        Parameters\n        ----------\n        R: array_like\n            A 3x3 array specifying the rotation matrix\n        norms: boolean, default True\n            \n        """"""\n        if isinstance(R, (list, tuple)):\n            # Make R a np array if its a list or tuple\n            R = np.array(R, np.float)\n        elif not isinstance(R, np.ndarray):\n            # If\n            raise TypeError(""Expected R to be array-like but found: "" + str(type(R)))\n        if len(R) != 3 or len(R[0]) != 3:\n            # Incorrect dimensions\n            if isinstance(R, np.ndarray):\n                raise ValueError(""Expected 3x3 array, but found: {}"".format(R.shape))\n            else:\n                raise ValueError(""Expected 3x3 array, but found: 3x""+str(len(R)))\n        self.vert[:, :] = np.dot(self.vert, R.T)\n        if norms is True:\n            self.norm[:, :] = np.dot(self.norm, R.T)\n            if hasattr(self, \'vNorm\'):\n                self.vNorm[:, :] = np.dot(self.vNorm, R.T)\n            \n            \n    def rigidTransform(self, R=None, T=None):\n        r""""""\n        Perform a rigid transformation on the AmpObject, first the rotation, \n        then the translation \n        \n        Parameters\n        ----------\n        R: array_like, default None\n            A 3x3 array specifying the rotation matrix\n        T: array_like, defauly None\n            An array of the form [x, y, z] which specifies the translation\n            \n        """"""\n        if R is not None:\n            if isinstance(R, (tuple, list, np.ndarray)):\n                self.rotate(R, True)\n            else:\n                raise TypeError(""Expecting array-like rotation, but found: ""+type(R))\n        if T is not None:\n            if isinstance(T, (tuple, list, np.ndarray)):\n                self.translate(T)\n            else:\n                raise TypeError(""Expecting array-like translation, but found: ""+type(T))\n        \n\n    @staticmethod\n    def rotMatrix(rot, ang=\'rad\'):\n        r""""""\n        Calculate the rotation matrix from three angles, the order is assumed \n        as around the x, then y, then z axis\n        \n        Parameters\n        ----------\n        rot: array_like\n            Rotation around [x, y, z]\n        ang: str, default \'rad\'\n            Specify if the Euler angles are in degrees or radians\n        \n        Returns\n        -------\n        R: array_like\n            The calculated 3x3 rotation matrix \n    \n        """"""\n\n        # Check that rot is valid\n        if not isinstance(rot, (tuple, list, np.ndarray)):\n            raise TypeError(""Expecting array-like rotation, but found: ""+type(rot))\n        elif len(rot) != 3:\n            raise ValueError(""Expecting 3 arguments but found: {}"".format(len(rot)))\n\n        # Check that ang is valid\n        if ang not in (\'rad\', \'deg\'):\n            raise ValueError(""Ang expected \'rad\' or \'deg\' but {} was found"".format(ang))\n\n        if ang == \'deg\':\n            rot = np.deg2rad(rot)\n\n        [angx, angy, angz] = rot\n        Rx = np.array([[1, 0, 0],\n                       [0, np.cos(angx), -np.sin(angx)],\n                       [0, np.sin(angx), np.cos(angx)]])\n        Ry = np.array([[np.cos(angy), 0, np.sin(angy)],\n                       [0, 1, 0],\n                       [-np.sin(angy), 0, np.cos(angy)]])\n        Rz = np.array([[np.cos(angz), -np.sin(angz), 0],\n                       [np.sin(angz), np.cos(angz), 0],\n                       [0, 0, 1]])\n        R = np.dot(np.dot(Rz, Ry), Rx)\n        return R\n    \n    def flip(self, axis=1):\n        r""""""\n        Flip the mesh in a plane\n        \n        Parameters\n        ----------\n        axis: int, default 1\n            The axis in which to flip the mesh\n\n        """"""\n        if isinstance(axis, int):\n            if 0 <= axis < 3:  # Check axis is between 0-2\n                self.vert[:, axis] *= -1.0\n                # Switch face order to normals face same direction\n                self.faces[:, [1, 2]] = self.faces[:, [2, 1]]\n                self.calcNorm()\n                self.calcVNorm()\n            else:\n                raise ValueError(""Expected axis to be within range 0-2 but found: {}"".format(axis))\n        else:\n            raise TypeError(""Expected axis to be int, but found: {}"".format(type(axis)))\n'"
ampscan/registration.py,24,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for dealing with registration methods between two AmpObject meshes\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\nimport numpy as np\nimport copy\nfrom scipy import spatial\nfrom ampscan.core import AmpObject\nimport matplotlib.pyplot as plt\n\n# For the doc examples\nimport os\nbasefh = os.path.join(os.getcwd(), ""tests"", ""stl_file.stl"")\ntargfh = os.path.join(os.getcwd(), ""tests"", ""stl_file_2.stl"")\n\nclass registration(object):\n    r""""""\n    Registration methods between two AmpObject meshes. This function morphs the baseline \n    vertices onto the surface of the target and returns a new AmpObject\n    \n    Parameters\n    ----------\n    baseline: AmpObject\n    \tThe baseline AmpObject, the vertices from this will be morphed onto the target\n    target: AmpObject\n    \tThe target AmpObject, the shape that the baseline attempts to morph onto\n    method: str: default \'point2plane\'\n    \tA string of the method used for registration\n    *args:\n    \tThe arguments used for the registration methods\n    **kwargs:\n    \tThe keyword arguments used for the registration methods\n        \n    Returns\n    -------\n    reg: AmpObject\n        The registered AmpObject, the vertices of this are on the surface of the target \n        and it has the same number of vertices and face array as the baseline AmpObject\n        Access this accessing the registration.reg \n    \n    Examples\n    --------\n    >>> from ampscan.core import AmpObject\n    >>> baseline = AmpObject(basefh)\n    >>> target = AmpObject(targfh)\n    >>> reg = registration(baseline, target, steps=10, neigh=10, smooth=1).reg\n\t\t\n    """""" \n    def __init__(self, baseline, target, method=\'point2plane\', *args, **kwargs):\n        self.b = baseline\n        self.t = target\n        if method is not None:\n            getattr(self, method)(*args, **kwargs)\n        \n        \n    def point2plane(self, steps = 1, neigh = 10, inside = True, subset = None, \n                    scale=None, smooth=1, fixBrim=False, error=\'norm\'):\n        r""""""\n        Point to Plane method for registration between the two meshes \n        \n        Parameters\n        ----------\n        steps: int, default 1\n            Number of iterations\n        int, default 10\n            Number of nearest neighbours to interrogate for each baseline point\n        inside: bool, default True\n            If True, a barycentric centre check is made to ensure the registered \n            point lines within the target triangle\n        subset: array_like, default None\n            Indicies of the baseline nodes to include in the registration, default is none so \n            all are used\n        scale: float, default None\n            If not None scale the baseline mesh to match the target mesh in the z-direction, \n            the value of scale will be used as a plane from which the nodes are scaled.\n            Nodes with a higher z value will not be scaled. \n        smooth: int, default 1\n            Indicate number of Laplacian smooth steps in between the steps \n        fixBrim: bool, default False\n            If True, the nodes on the brim line will not be included in the smooth\n        error: bool, default False\n            If True, the polarity will be included when calculating the distance \n            between the target and baseline mesh\n\t\t\n        """"""\n        # Calc FaceCentroids\n        fC = self.t.vert[self.t.faces].mean(axis=1)\n        # Construct knn tree\n        tTree = spatial.cKDTree(fC)\n        bData = dict(zip([\'vert\', \'faces\', \'values\'], \n                         [self.b.vert, self.b.faces, self.b.values]))\n        regData = copy.deepcopy(bData)\n        self.reg = AmpObject(regData, stype=\'reg\')\n        self.disp = AmpObject({\'vert\': np.zeros(self.reg.vert.shape),\n                               \'faces\': self.reg.faces,\n                               \'values\':self.reg.values})\n        if scale is not None:\n            tmin = self.t.vert.min(axis=0)[2]\n            rmin = self.reg.vert.min(axis=0)[2]\n            SF = ((tmin-scale)/(rmin-scale)) - 1\n            logic = self.reg.vert[:, 2] < scale\n            d = (self.reg.vert[logic, 2] - scale) * SF\n            self.disp.vert[logic, 2] += d\n            self.reg.vert = self.b.vert + self.disp.vert\n        normals = np.cross(self.t.vert[self.t.faces[:,1]] -\n                         self.t.vert[self.t.faces[:,0]],\n                         self.t.vert[self.t.faces[:,2]] -\n                         self.t.vert[self.t.faces[:,0]])\n        mag = (normals**2).sum(axis=1)\n        for step in np.arange(steps, 0, -1, dtype=float):\n            # Index of 10 centroids nearest to each baseline vertex\n            ind = tTree.query(self.reg.vert, neigh)[1]\n            # Define normals for faces of nearest faces\n            norms = normals[ind]\n            # Get a point on each face\n            fPoints = self.t.vert[self.t.faces[ind, 0]]\n            # Calculate dot product between point on face and normals\n            d = np.einsum(\'ijk, ijk->ij\', norms, fPoints)\n            t = (d - np.einsum(\'ijk, ik->ij\', norms, self.reg.vert))/mag[ind]\n            # Calculate the vector from old point to new point\n            G = self.reg.vert[:, None, :] + np.einsum(\'ijk, ij->ijk\', norms, t)\n            # Ensure new points lie inside points otherwise set to 99999\n            # Find smallest distance from old to new point \n            if inside is False:\n                G = G - self.reg.vert[:, None, :]\n                GMag = np.sqrt(np.einsum(\'ijk, ijk->ij\', G, G))\n                GInd = GMag.argmin(axis=1)\n            else:\n                G, GInd = self.__calcBarycentric(self.reg.vert, G, ind)\n            # Define vector from baseline point to intersect point\n            D = G[np.arange(len(G)), GInd, :]\n#            rVert += D/step\n            self.disp.vert += D/step\n            if smooth > 0 and step > 1:\n                self.disp.lp_smooth(smooth, brim = fixBrim)\n                self.reg.vert = self.b.vert + self.disp.vert\n            else:\n                self.reg.vert = self.b.vert + self.disp.vert\n                self.reg.calcNorm()\n        self.reg.calcStruct(vNorm=True)\n        self.reg.values[:] = self.calcError(error)\n        \n    def calcError(self, method=\'norm\'):\n        r""""""\n        Calculate the magnitude of distances between the baseline and registered array\n\t\t\n        Parameters\n        ----------\n        method: str, default \'norm\'\n            The method used to calculate the distances. \'abs\' returns the absolute\n            distance. \'cent\'calculates polarity based upon distance from centroid.\n            \'norm\' calculates dot product between baseline vertex normal and distance \n            normal\n\n        Returns\n        -------\n        values: array_like\n            Magnitude of distances\n\n        """"""\n        method = \'_registration__\' + method + \'Dist\'\n        try:\n            values = getattr(self, method)()\n            return values\n        except: ValueError(\'""%s"" is not a method, try ""abs"", ""cent"" or ""prod""\' % method)\n        \n\n    \n    def __absDist(self):\n        r""""""\n        Return the error based upon the absolute distance\n        \n        Returns\n        -------\n        values: array_like\n            Magnitude of distances\n\n        """"""\n        return np.linalg.norm(self.reg.vert - self.b.vert, axis=1)\n    \n    def __centDist(self):\n        r""""""\n        Return the error based upon distance from centroid \n        \n        Returns\n        -------\n        values: array_like\n            Magnitude of distances\n\n        """"""\n        values = np.linalg.norm(self.reg.vert - self.b.vert, axis=1)\n        cent = self.b.vert.mean(axis=0)\n        r = np.linalg.norm(self.reg.vert - cent, axis=1)\n        b = np.linalg.norm(self.b.vert - cent, axis=1)\n        polarity = np.ones([self.reg.vert.shape[0]])\n        polarity[r<b] = -1\n        return values * polarity\n\n    def __normDist(self):\n        r""""""\n        Returns error based upon scalar product of normal \n        \n        Returns\n        -------\n        values: array_like\n            Magnitude of distances\n\n        """"""\n        self.b.calcVNorm()\n        D = self.reg.vert - self.b.vert\n        n = self.b.vNorm\n        values = np.linalg.norm(D, axis=1)\n        polarity = np.sum(n*D, axis=1) < 0\n        values[polarity] *= -1.0\n        return values\n        \n        \n    def __calcBarycentric(self, vert, G, ind):\n        r""""""\n        Calculate the barycentric co-ordinates of each target face and the registered vertex, \n        this ensures that the registered vertex is within the bounds of the target face. If not \n        the registered vertex is moved to the nearest vertex on the target face \n\n        Parameters\n        ----------\n        vert: array_like\n            The array of baseline vertices\n        G: array_like\n            The array of candidates for registered vertices. If neigh>1 then axis 2 will correspond \n            to the number of nearest neighbours selected\n        ind: array_like\n            The index of the nearest faces to the baseline vertices\n        \n        Returns\n        -------\n        G: array_like \n            The new array of candidates for registered vertices, from here, the one with \n            smallest magnitude is selected. All these points will lie within the target face\n        GInd: array_like\n            The index of the shortest distance between each baseline vertex and the registered vertex\n            \n        """"""\n        P0 = self.t.vert[self.t.faces[ind, 0]]\n        P1 = self.t.vert[self.t.faces[ind, 1]]\n        P2 = self.t.vert[self.t.faces[ind, 2]]\n        \n        v0 = P2 - P0\n        v1 = P1 - P0\n        v2 = G - P0\n        \n        d00 = np.einsum(\'ijk, ijk->ij\', v0, v0)\n        d01 = np.einsum(\'ijk, ijk->ij\', v0, v1)\n        d02 = np.einsum(\'ijk, ijk->ij\', v0, v2)\n        d11 = np.einsum(\'ijk, ijk->ij\', v1, v1)\n        d12 = np.einsum(\'ijk, ijk->ij\', v1, v2)\n        \n        denom = d00*d11 - d01*d01\n        u = (d11 * d02 - d01 * d12)/denom\n        v = (d00 * d12 - d01 * d02)/denom\n        # Test if inside \n        logic = (u >= 0) * (v >= 0) * (u + v < 1)\n        \n        P = np.stack([P0, P1, P2], axis=3)\n        pg = G[:, :, :, None] - P\n        pd =  np.linalg.norm(pg, axis=2)\n        pdx = pd.argmin(axis=2)\n        i, j = np.meshgrid(np.arange(P.shape[0]), np.arange(P.shape[1]))\n        nearP = P[i.T, j.T, :, pdx]\n        G[~logic, :] = nearP[~logic, :]\n        G = G - vert[:, None, :]\n        GMag = np.sqrt(np.einsum(\'ijk, ijk->ij\', G, G))\n        GInd = GMag.argmin(axis=1)\n        return G, GInd\n    \n    def plotResults(self, name=None, xrange=None, color=None, alpha=None):\n        r""""""\n        Function to generate a mpl figure. Includes a rendering of the \n        AmpObject, a histogram of the registration values \n        \n        Returns\n        -------\n        fig: mplfigure\n            A matplot figure of the standard analysis\n        \n        """"""\n        fig, ax = plt.subplots(1)\n        n, bins, _ = ax.hist(self.reg.values, 50, density=True, range=xrange,\n                             color=color, alpha=alpha)\n        mean = self.reg.values.mean()\n        stdev = self.reg.values.std()\n        ax.set_title(r\'Distribution of shape variance, \'\n                     \'$\\mu=%.2f$, $\\sigma=%.2f$\' % (mean, stdev))\n        ax.set_xlim(None)\n        if name is not None:\n            plt.savefig(name, dpi = 300)\n        return ax, n, bins'"
ampscan/smooth.py,19,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for dealing with smoothing functions for the AmpObject mesh\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nimport numpy as np\nimport copy\n\nclass smoothMixin(object):\n    \n    def lp_smooth(self, n=1, brim = True):\n        r""""""\n        Function to apply a Laplacian smooth to the mesh. This method replaces \n        each vertex with the mean of its connected neighbours \n\n        Parameters\n        ----------\n        \n        n: int, default 1\n            number of iterations of smoothing\n        \n        """"""\n        if brim is True:\n            eidx = (self.faceEdges == -99999).sum(axis=1).astype(bool)\n            vBrim = np.unique(self.edges[eidx, :])\n        else: vBrim = []\n        # Flatten the edges array to 1D\n        e = self.edges.flatten()\n        # Get the indicies to sort edges \n        o_idx = e.argsort()\n        # Get indicies of sorted array where last of each vertex index \n        # occurs \n        ndx = np.searchsorted(e[o_idx], np.arange(len(self.vert)), \n                              side=\'right\')\n        ndx = np.r_[0, ndx]\n        # Map indicies between flatted edges array and standard\n        row, col = np.unravel_index(o_idx, self.edges.shape)\n        for i in np.arange(n):\n            # List all vertices \n            vert = copy.deepcopy(self.vert)\n            neighVerts = vert[self.edges[row, 1-col], :]\n            vRange = np.arange(self.vert.shape[0])\n            log = np.isin(vRange, vBrim)\n            vRange = vRange[~log]\n            for j in vRange:\n                # Calculate the mean of the vertex set\n                self.vert[j, :] = neighVerts[ndx[j]:ndx[j+1]].mean(axis=0)\n        self.calcNorm()\n        self.calcVNorm()\n\n    def hc_smooth(self, n=1 ,beta=0.6, brim=True):\n        r""""""\n        Function to apply a Humphrey\xe2\x80\x99s Classes smooth to the mesh. Note, this assumes\n        that alpha=0 (ie the original point through the iteration has no effect). \n        If beta=1, then this effectively acts as the Laplacian smooth \n\n        Parameters\n        ----------\n        \n        n: int, default 1\n            number of iterations of smoothing\n        beta: float, default 0.6\n            scalar between [0, 1] which dictates influence of distance from adjacent to original point.  \n            If beta=1, then this effectively acts as the Laplacian smooth \n        brim: bool, default True\n            If true, then this will not smooth the vertices on the brim\n        \n        """"""\n        if brim is True:\n            eidx = (self.faceEdges == -99999).sum(axis=1).astype(bool)\n            vBrim = np.unique(self.edges[eidx, :])\n        else: vBrim = []\n        # Flatten the edges array to 1D\n        e = self.edges.flatten()\n        # Get the indicies to sort edges \n        o_idx = e.argsort()\n        # Get indicies of sorted array where last of each vertex index \n        # occurs \n        ndx = np.searchsorted(e[o_idx], np.arange(len(self.vert)), \n                              side=\'right\')\n        ndx = np.r_[0, ndx]\n        # Map indicies between flatted edges array and standard\n        row, col = np.unravel_index(o_idx, self.edges.shape)\n        for i in np.arange(n):\n            # List all vertices \n            vert = copy.deepcopy(self.vert)\n            neighVerts = vert[self.edges[row, 1-col], :]\n            vRange = np.arange(self.vert.shape[0])\n            log = np.isin(vRange, vBrim)\n            vRange = vRange[~log]\n            for j in vRange:\n                # Get the adjacent vertices\n                adj = neighVerts[ndx[j]:ndx[j+1]]\n                # Get the original vertex\n                q = self.vert[j, :]\n                # calculate new Laplacian location \n                p = adj.mean(axis=0)\n                # Distance between Laplacian and original \n                b = p - q\n                # Mean distance adjacent between original \n                d = (adj - q).mean(axis=0)\n                # Based upon beta, get the updated location \n                self.vert[j, :] = q + beta*b - (1-beta)*d\n        self.calcNorm()\n        self.calcVNorm()\n    \n    def smoothValues(self, n=1):\n        """"""\n        Function to apply a simple Laplacian smooth to the values array. \n        Identical to the vertex smoothing except it applies the smoothing\n        to the values\n\n        Parameters\n        ----------\n        \n        n: int, default 1\n            number of iterations of smoothing\n        \n        """"""\n        # Flatten the edges array to 1D\n        e = self.edges.flatten()\n        # Get the indicies to sort edges \n        o_idx = e.argsort()\n        # Get indicies of sorted array where last of each vertex index \n        # occurs \n        ndx = np.searchsorted(e[o_idx], np.arange(len(self.values)), \n                              side=\'right\')\n        ndx = np.r_[0, ndx]\n        # Map indicies between flatted edges array and standard\n        row, col = np.unravel_index(o_idx, self.edges.shape)\n        for i in np.arange(n):\n            neighValues = self.values[self.edges[row, 1-col]]\n            for j in np.arange(self.values.shape[0]):\n                # Calculate mean of values set \n                self.values[j] = neighValues[ndx[j]:ndx[j+1]].mean()\n            '"
ampscan/trim.py,12,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for dealing with trimming the AmpObject mesh\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nimport numpy as np\nfrom numbers import Number\nimport os\n\n# Used by doc tests\nfilename = os.path.join(os.getcwd(), ""tests"", ""stl_file.stl"")\n\n\nclass trimMixin(object):\n    r""""""\n    Methods for trimming the AmpObject mesh\n\n    """"""\n    \n    def planarTrim(self, height, plane = 2, above = True):\n        r""""""\n        Trim the vertices using a flat plane, all vertices above plane will be \n        trimmed\n\n        Parameters\n        -----------\n        height: float\n            Trim height, values above this will be deleted\n        plane: int, default 2\n            plane for slicing\n        \n        Examples\n        --------\n\n        >>> from ampscan import AmpObject\n        >>> amp = AmpObject(filename)\n        >>> amp.planarTrim(100, 2)\n\n        """"""\n        if isinstance(height, Number) and isinstance(plane, int):\n            # planar values for each vert on face \n            fv = self.vert[self.faces, plane]\n            # Number points on each face are above cut plane\n            fvlogic = (fv > height).sum(axis=1)\n            # Faces with points both above and below cut plane\n            adjf = self.faces[np.logical_or(fvlogic == 2, fvlogic == 1)]\n            # Get adjacent vertices\n            adjv = np.unique(adjf)\n            # Get vert above height and set to height\n            abvInd = adjv[self.vert[adjv, plane] > height]\n            self.vert[abvInd, plane] = height\n            # Find all verts above plane\n            delv = self.vert[:, plane] > height\n            # Reorder verts to account for deleted one\n            vInd = np.cumsum(~delv) - 1\n            self.faces = self.faces[fvlogic != 3, :]\n            self.faces = vInd[self.faces]\n            self.vert = self.vert[~delv, :]\n            self.values = self.values[~delv]\n            self.calcStruct()\n        else:\n            raise TypeError(""height arg must be a float"")\n\n\n    def threePointTrim(self, p0, p1, p2, above = True):\n        r""""""\n        Trim the vertices using a plane defined by three points. By default, all points  \n        above the plane are deleted.\n\n        Parameters\n        -----------\n        p0: array_like \n            The co-ordinates of the first point to define the plane\n        p1: array_like \n            The co-ordinates of the second point to define the plane\n        p2: array_like \n            The co-ordinates of the third point to define the plane\n\n        \n        Examples\n        --------\n\n        >>> from ampscan import AmpObject\n        >>> amp = AmpObject(filename)\n        >>> p0 = [50, 50, 0]\n        >>> p1 = [50, -50, -40]\n        >>> p2 = [-50, 50, 10]\n        >>> amp.threePointTrim(p0, p1, p2)\n\n        """"""\n        # Ensure asarrays\n        p0 = np.asarray(p0)\n        p1 = np.asarray(p1)\n        p2 = np.asarray(p2)\n\n        # Calculate plane \n        v0 = p1 - p0\n        v1 = p2 - p0\n        c = np.cross(v0, v1)\n        c = c/np.linalg.norm(c)\n        k = -np.multiply(c, p0).sum()\n        # planar values for each vert on face \n        height = -(self.vert[:, 0]*c[0] + self.vert[:, 1]*c[0] + k)/c[2]\n        # Number points on each face are above cut plane\n        fv = self.vert[self.faces, 2]\n        fvHeight = height[self.faces]\n        fvlogic = (fv > fvHeight).sum(axis=1)\n        # Faces with points both above and below cut plane\n        adjf = self.faces[np.logical_or(fvlogic == 2, fvlogic == 1)]\n        # Get adjacent vertices\n        adjv = np.unique(adjf)\n        # Get vert above height and set to height\n        abvInd = adjv[self.vert[adjv, 2] > height[adjv]]\n        self.vert[abvInd, 2] = height[abvInd]\n        # Find all verts above plane\n        delv = self.vert[:, 2] > height\n        # Reorder verts to account for deleted one\n        vInd = np.cumsum(~delv) - 1\n        self.faces = self.faces[fvlogic != 3, :]\n        self.faces = vInd[self.faces]\n        self.vert = self.vert[~delv, :]\n        self.values = self.values[~delv]\n        self.calcStruct()'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nimport sphinx_rtd_theme\nsys.path.insert(0, os.path.abspath(\'.\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'ampscan\'\ncopyright = \'2020, ampscan developers\'\nauthor = \'Joshua Steer\'\n\n# The short X.Y version\nversion = \'0.3\'\n# The full version, including alpha/beta/rc tags\nrelease = \'0.3.0\'\n\non_rtd = os.environ.get(\'READTHEDOCS\') == \'True\'\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\n\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.napoleon\',\n    \'nbsphinx\',\n]\n\nnapoleon_numpy_docstring=True\n\nautodoc_mock_imports=[\'vtk\']\n\nadd_module_names = False\n\nmodindex_common_prefix = [\'ampscan.\']\n\nautoclass_content = \'both\'\n\nhtml_use_index = False\n\nnbsphinx_kernel_name = \'python3\'\n\nhtml_logo = ""ampscanlogosmall.svg""\n\nhtml_favicon = ""ampscanlogo.ico""\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\', \'**.ipynb_checkpoints\', \'**/.pyx\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'ampscandoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'ampscan.tex\', \'ampscan Documentation\',\n     \'Joshua Steer\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'ampscan\', \'ampscan Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'ampscan\', \'ampscan Documentation\',\n     author, \'ampscan\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n'"
gui/ampscanGUI.py,6,"b'import sys\nimport webbrowser\n\nimport numpy as np\nimport vtk\nfrom ampscan import AmpObject, analyse\nfrom ampscan.registration import registration\nfrom ampscan.align import align\nfrom ampscan.vis import qtVtkWindow, vtkRenWin\nfrom PyQt5.QtCore import QPoint, QSize, Qt, QTimer, QRect, pyqtSignal\nfrom PyQt5.QtGui import (QColor, QFontMetrics, QImage, QPainter, QIcon,\n                         QOpenGLVersionProfile)\nfrom PyQt5.QtWidgets import (QAction, QApplication, QGridLayout, QHBoxLayout,\n                             QMainWindow, QMessageBox, QComboBox, QButtonGroup,\n                             QOpenGLWidget, QFileDialog, QLabel, QPushButton,\n                             QSlider, QWidget, QTableWidget, QTableWidgetItem,\n                             QAbstractButton, QCheckBox, QErrorMessage)\n\n\nclass ampscanGUI(QMainWindow):\n    """"""\n    Generates an GUI for handling stl data. Window is derived from QT.\n\n\n    Example\n    -------\n    Perhaps an example implementation:\n\n    >>> from GUIs.ampscanGUI import ampscanGUI\n\n    """"""\n\n    def __init__(self, parent = None):\n        super(ampscanGUI, self).__init__()\n        self.vtkWidget = qtVtkWindow()\n        self.renWin = self.vtkWidget._RenderWindow\n        self.renWin.setBackground([1,1,1])\n        self.mainWidget = QWidget()\n        self.files = {}\n        self.filesDrop = list(self.files.keys())\n#        self.CMap = np.array([[212.0, 221.0, 225.0],\n#                              [31.0, 73.0, 125.0]])/255.0\n        self.setCentralWidget(self.mainWidget)\n        self.createActions()\n        self.createMenus()\n        self.Layout = QGridLayout()\n        self.Layout.addWidget(self.vtkWidget, 0, 0)\n        self.mainWidget.setLayout(self.Layout)\n        self.setWindowTitle(""ampscan"")\n        self.resize(800, 800)\n        self.show()\n        self.fileManager = fileManager(self)\n        self.fileManager.show()\n        self.fileManager.table.itemChanged.connect(self.display)\n        self.pnt = None\n        self.AmpObj = None\n\n    def chooseOpenFile(self):\n        """"""\n        Handles importing of stls into the GUI.\n\n        \n        """"""\n        fname = QFileDialog.getOpenFileName(self, \'Open file\',\n                                            filter=""Meshes (*.stl)"")\n        if fname[0] == \'\':\n            return\n        name = fname[0][:-4].split(\'/\')[-1]\n        self.files[name] = AmpObject(fname[0], \'limb\')\n        amp = self.files[name]\n        amp.addActor()\n        amp.tform = vtk.vtkTransform()\n        amp.tform.PostMultiply()\n        amp.actor.SetUserTransform(amp.tform)\n#        amp.centre()\n        self.fileManager.addRow(name, amp)\n        self.display()\n        self.filesDrop.append(name)\n        if hasattr(self, \'alCont\'):\n            self.alCont.getNames()\n        if hasattr(self, \'regCont\'):\n            self.regCont.getNames()\n#        self.AmpObj.lp_smooth()\n\n    def saveFile(self):\n        self.saveCont = saveControls(self.filesDrop, self)\n        self.saveCont.show()\n        self.saveCont.save.clicked.connect(self.chooseSaveFile)\n\n    def chooseSaveFile(self):\n        fname = QFileDialog.getSaveFileName(self, \'Save file\',\n                                            filter=""Meshes (*.stl)"")\n        if fname[0] == \'\':\n            return\n        file = str(self.saveCont.files.currentText())\n        self.files[file].save(fname[0])\n        try:\n            f = open(fname[0]+\'.txt\',\'w+\')\n            f.write(\'{}\'.format(self.pnt))\n        except AttributeError:\n            print(\'A point has not been selected\')\n\n    def display(self):\n        render = []\n\n        for r in range(self.fileManager.n):\n            [name, _, color, opacity, display] = self.fileManager.getRow(r)\n            # Make the object visible\n            if display == 2:\n                # TODO fix duplicate names\n                if name in self.files.keys():\n                    render.append(self.files[name].actor)\n                else:\n                    show_message(""Invalid name: {}"".format(name))\n                    # Temp workaround name change crash\n                    # TODO make names actually change\n                    continue\n\n            # Change the color\n            try:\n                color = color[1:-1].split(\',\')\n                color = [float(c) for c in color]\n                if len(color) != 3:\n                    raise ValueError\n                self.files[name].actor.setColor(color)\n            except ValueError:\n                show_message(""Invalid colour: {}"".format(color))\n                continue\n\n            # Change opacity\n            try:\n                self.files[name].actor.setOpacity(float(opacity))\n            except ValueError:\n                show_message(""Invalid opacity: {}"".format(opacity))\n            \n            # transform = vtk.vtkTransform()\n            # transform.Translate(1.0, 0.0, 0.0)\n            # axes = vtk.vtkAxesActor()\n            # #  The axes are positioned with a user transform\n            # axes.SetUserTransform(transform)\n            self.renWin.renderActors(render)\n        self.renWin.addTriad(render, color = [0, 0, 0])\n        # print(self.renWin.lim)\n\n    def align(self):\n        """"""\n        Numpy style docstring.\n\n        """"""\n        if self.objectsReady(1):\n            self.alCont = AlignControls(self.filesDrop, self)\n            self.alCont.show()\n            self.alCont.centre.clicked.connect(self.centreMesh)\n            self.alCont.icp.clicked.connect(self.runICP)\n            self.alCont.xrotButton.buttonClicked[QAbstractButton].connect(self.rotatex)\n            self.alCont.yrotButton.buttonClicked[QAbstractButton].connect(self.rotatey)\n            self.alCont.zrotButton.buttonClicked[QAbstractButton].connect(self.rotatez)\n            self.alCont.xtraButton.buttonClicked[QAbstractButton].connect(self.transx)\n            self.alCont.ytraButton.buttonClicked[QAbstractButton].connect(self.transy)\n            self.alCont.ztraButton.buttonClicked[QAbstractButton].connect(self.transz)\n        else:\n            show_message(""Must be at least 1 object loaded to run align"")\n\n    def Point_Pick(self):\n        """"""\n        Waits for a point click to occur before calling further functions\n        TODO: Create \'Picker controls\'? Similar to Alignment controls, but where\n        user can enter the name of the point they select - this can allow\n        multiple landmark locations to be stored and marked?\n        """"""\n        self.vtkWidget.iren.AddObserver(\'RightButtonPressEvent\', self.pick_loc)\n        self.renWin.Render()\n\n    def pick_loc(self, event, x):\n        """"""\n        calcs the location of click in GUI (x,y)\n        calls function in ampVis.py which converts from GUI coordinates to\n        mesh coordinates and marks the point\n        """"""\n        #print(event, x)\n        self.vtkWidget.iren.RemoveObservers(\'RightButtonPressEvent\')\n        loc = event.GetEventPosition()\n\n        # Currently this only allow one pick points, but in the future, more reference points may be needed\n        if self.pnt is None:  # Check no points are already picked\n            self.pnt = vtkRenWin.Pick_point(self.renWin, loc)\n        else:\n            show_message(""A point is already set as the reference.\\n""\n                         ""Clear the picked points to change reference"",\n                         message_type=""info"")\n        #vtkRenWin.mark(self.renWin,self.pnt[0],self.pnt[1],self.pnt[2])\n        # print(self.pnt)\n\n    def removePick(self):\n        """"""\n        delete all marked points and labels\n        TODO: be able to delete individual points?\n        """"""\n        self.pnt = None\n        vtkRenWin.delMarker(self.renWin)\n\n    def rotatex(self, button):\n        moving = str(self.alCont.moving.currentText())\n        ang = float(button.text())\n        idx = [1, 0, 0]\n        self.files[moving].rotateAng([ang*i for i in idx], \'deg\')\n        self.files[moving].tform.RotateX(ang)\n        self.renWin.Render()\n#        print(\'rotate x by %.1f\' % ang)\n\n    def rotatey(self, button):\n        moving = str(self.alCont.moving.currentText())\n        ang = float(button.text())\n        idx = [0, 1, 0]\n        self.files[moving].rotateAng([ang*i for i in idx], \'deg\')\n        self.files[moving].tform.RotateY(ang)\n        self.renWin.Render()\n#        print(\'rotate y by %.1f\' % ang)\n\n    def rotatez(self, button):\n        moving = str(self.alCont.moving.currentText())\n        ang = float(button.text())\n        idx = [0, 0, 1]\n        self.files[moving].rotateAng([ang*i for i in idx], \'deg\')\n        self.files[moving].tform.RotateZ(ang)\n        self.renWin.Render()\n\n    def transx(self, button):\n        moving = str(self.alCont.moving.currentText())\n        t = [float(button.text()),0, 0]\n        self.files[moving].translate(t)\n        self.files[moving].tform.Translate(t)\n        self.renWin.Render()\n#        print(\'rotate x by %.1f\' % ang)\n\n    def transy(self, button):\n        moving = str(self.alCont.moving.currentText())\n        t = [0, float(button.text()), 0]\n        self.files[moving].translate(t)\n        self.files[moving].tform.Translate(t)\n        self.renWin.Render()\n#        print(\'rotate y by %.1f\' % ang)\n\n    def transz(self, button):\n        moving = str(self.alCont.moving.currentText())\n        t = [0, 0, float(button.text())]\n        self.files[moving].translate(t)\n        self.files[moving].tform.Translate(t)\n        self.renWin.Render()\n#        print(\'rotate z by %.1f\' % ang)\n#        self.files[moving].rotateAng(ang, \'deg\')\n\n    def centreMesh(self):\n        moving = str(self.alCont.moving.currentText())\n        c = -1 * self.files[moving].vert.mean(axis=0)\n        t = c.tolist()\n        self.files[moving].centre()\n        self.files[moving].tform.Translate(t)\n        self.renWin.Render()\n\n    def runICP(self):\n        if self.objectsReady(1):\n            static = str(self.alCont.static.currentText())\n            moving = str(self.alCont.moving.currentText())\n            al = align(self.files[moving], self.files[static],\n                       maxiter=10, method=\'linPoint2Plane\').m\n            al.tform = vtk.vtkTransform()\n            al.tform.PostMultiply()\n            al.addActor()\n            al.actor.SetUserTransform(al.tform)\n            alName = moving + \'_al\'\n            self.files[alName] = al\n            self.filesDrop.append(alName)\n            self.fileManager.addRow(alName, self.files[alName])\n            self.fileManager.setTable(static, [1,0,0], 0.5, 2)\n            self.fileManager.setTable(moving, [1,1,1], 1, 0)\n            self.fileManager.setTable(alName, [0,0,1], 0.5, 2)\n            if hasattr(self, \'alCont\'):\n                self.alCont.getNames()\n            if hasattr(self, \'regCont\'):\n                self.regCont.getNames()\n        else:\n            show_message(""Must be at least 2 objects loaded to run ICP"")\n\n    def runRegistration(self):\n        if self.objectsReady(2):\n            c1 = [31.0, 73.0, 125.0]\n            c3 = [170.0, 75.0, 65.0]\n            c2 = [212.0, 221.0, 225.0]\n            CMap1 = np.c_[[np.linspace(st, en) for (st, en) in zip(c1, c2)]]\n            CMap2 = np.c_[[np.linspace(st, en) for (st, en) in zip(c2, c3)]]\n            CMap = np.c_[CMap1[:, :-1], CMap2]\n            self.CMapN2P = np.transpose(CMap)/255.0\n            self.CMap02P = np.flip(np.transpose(CMap1)/255.0, axis=0)\n            baseline = str(self.regCont.baseline.currentText())\n            target = str(self.regCont.target.currentText())\n            self.fileManager.setTable(baseline, [1,0,0], 0.5, 0)\n            self.fileManager.setTable(target, [0,0,1], 0.5, 0)\n            reg = registration(self.files[baseline], self.files[target], steps = 5,\n                               smooth=1).reg\n            #reg.addActor(CMap = self.CMap02P)\n            reg.addActor(CMap = self.CMapN2P)\n            regName = target + \'_reg\'\n            self.files[regName] = reg\n            self.filesDrop.append(regName)\n            self.fileManager.addRow(regName, self.files[regName])\n            if hasattr(self, \'alCont\'):\n                self.alCont.getNames()\n            if hasattr(self, \'regCont\'):\n                self.regCont.getNames()\n            #im = []\n            reg.actor.setScalarRange([-5,5])\n            reg.actor.setShading(False)\n            analyse.CMapOut(reg, colors=self.CMapN2P)\n                # reg.plotResults(name=""distributionofshapevariance.png"")\n            self.display()  # Reset which objects are displayed\n            self.renWin.setScalarBar(reg.actor, title = \'Shape difference, mm\')\n\n            print(\'Run the Registration code between %s and %s\' % (baseline, target))\n        else:\n            show_message(""Must be at least 2 objects loaded to run registration"")\n\n    def register(self):\n        """"""\n        Numpy style docstring.\n\n        """"""\n        self.regCont = RegistrationControls(self.filesDrop, self)\n        self.regCont.show()\n        self.regCont.reg.clicked.connect(self.runRegistration)\n\n\n\n    def analyse(self):\n        """"""\n        Numpy style docstring.\n\n        """"""\n        #self.RegObj.plot_slices()\n        if self.AmpObj != None:  # Check object is loaded\n            self.AmpObj.vert[:, 0] *= 2\n            self.AmpObj.actor.points.Modified()\n            #self.renWin.renderActors([self.AmpObj.actor,])\n            #self.AmpObj.vert[0,0] = 1\n            #self.AmpObj._v = numpy_support.numpy_to_vtk(self.AmpObj.vert)\n        else:\n            show_message(""Please load object first"")\n\n    def measure(self):\n        # If no point selected condition move to analyse.py\n        if not self.objectsReady(1):\n            show_message(""Please import an object first"")\n        elif self.pnt is None:\n            show_message(""Please select a reference point first using pick"")\n        else:\n            [name, _, color, opacity, display] = self.fileManager.getRow(0)\n            output_file_path = analyse.MeasurementsOut(self.files[name], self.pnt)\n            if output_file_path == 1:\n                show_message(""Analysis file cannot be found, ensure you have downloaded the pdf files and placed them into the ampscan/analyse folder"")\n            # Open Report in webbrowser\n            else:\n                webbrowser.get().open(output_file_path)  # .get() gets the default browser\n    \n    def createActions(self):\n        """"""\n        Numpy style docstring.\n\n        """"""\n        self.openFile = QAction(QIcon(\'open.png\'), \'Open\', self,\n                                shortcut=\'Ctrl+O\',\n                                triggered=self.chooseOpenFile)\n        self.saveFile = QAction(QIcon(\'open.png\'), \'Save\', self,\n                                shortcut=\'Ctrl+S\',\n                                triggered=self.saveFile)\n        self.exitAct = QAction(""E&xit"", self, shortcut=""Ctrl+Q"",\n                               triggered=self.close)\n        self.align = QAction(QIcon(\'open.png\'), \'Align\', self,\n                                triggered=self.align)\n        self.rect = QAction(QIcon(\'open.png\'), \'Register\', self,\n                                triggered=self.register)\n        self.analyse = QAction(QIcon(\'open.png\'), \'Analyse\', self,\n                                triggered=self.analyse)\n        self.pick = QAction(QIcon(\'open.png\'), \'Right click to select Mid-Patella\', self,\n                                triggered=self.Point_Pick)\n        self.removePick = QAction(QIcon(\'open.png\'), \'Clear all picked points\', self,\n                                triggered = self.removePick)\n        self.Measure = QAction(QIcon(\'open.png\'), \'Generate Measurements File\', self,\n                                triggered = self.measure)\n        self.openObjectManager = QAction(QIcon(\'open.png\'), \'Show Object Manager\', self,\n                                triggered=self.openAmpObjectManager)\n\n    def createMenus(self):\n        """"""\n        Numpy style docstring.\n\n        """"""\n        self.fileMenu = self.menuBar().addMenu(""&File"")\n        self.fileMenu.addAction(self.openFile)\n        self.fileMenu.addAction(self.saveFile)\n        self.fileMenu.addSeparator()\n        self.fileMenu.addAction(self.exitAct)\n        self.alignMenu = self.menuBar().addMenu(""&Align"")\n        self.alignMenu.addAction(self.align)\n        self.regMenu = self.menuBar().addMenu(""&Registration"")\n        self.regMenu.addAction(self.rect)\n        self.measureMenu = self.menuBar().addMenu(""&Measure"")\n        self.measureMenu.addAction(self.pick)\n        self.measureMenu.addAction(self.removePick)\n        self.measureMenu.addAction(self.Measure)\n        self.viewMenu = self.menuBar().addMenu(""&View"")\n        self.viewMenu.addAction(self.openObjectManager)\n\n    def openAmpObjectManager(self):\n        self.fileManager.show()\n\n    def objectsReady(self, n):\n        """"""Check there are at least n objects loaded\n\n        """"""\n        return len(self.files) >= n\n\n\nclass fileManager(QMainWindow):\n    """"""\n    Controls to manage the displayed \n    \n    Example\n    -------\n    Perhaps an example implementation:\n\n    >>> from GUIs.ampscanGUI import ampscanGUI\n\n    """"""\n\n    def __init__(self, parent = None):\n        super(fileManager, self).__init__(parent)\n        self.main = QWidget()\n        self.table = QTableWidget()\n        self.setCentralWidget(self.main)\n        self.layout = QGridLayout()\n        self.layout.addWidget(self.table, 0, 0)\n        self.main.setLayout(self.layout)\n        self.setWindowTitle(""AmpObject Manager"")\n        self.table.setRowCount(0)\n        self.table.setColumnCount(5)\n        self.table.setHorizontalHeaderLabels([\'Name\', \'Type\', \'Colour\', \'Opacity\', \'Display\'])\n        self.n = self.table.rowCount()\n        # Set the minimum table size to when it is fully expanded\n        self.table.setMinimumWidth(self.table.frameWidth()*2\n                                   + self.table.horizontalHeader().length()\n                                   + self.table.verticalHeader().width())\n        \n    def addRow(self, name, amp):\n        self.table.insertRow(self.n)\n        self.table.setItem(self.n, 0, QTableWidgetItem(name))\n        self.table.setItem(self.n, 1, QTableWidgetItem(amp.stype))\n        self.table.setItem(self.n, 2, QTableWidgetItem(str(amp.actor.GetProperty().GetColor())))\n        self.table.setItem(self.n, 3, QTableWidgetItem(str(amp.actor.GetProperty().GetOpacity())))\n        chkBoxItem = QTableWidgetItem()\n        chkBoxItem.setTextAlignment(Qt.AlignCenter)\n        chkBoxItem.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)\n        chkBoxItem.setCheckState(Qt.Checked)       \n        \n        self.table.setItem(self.n,4,chkBoxItem)\n        self.n = self.table.rowCount()\n        \n    def getRow(self, i):\n        row = []\n        for r in range(self.table.columnCount() - 1):\n            row.append(self.table.item(i, r).text())\n        row.append(self.table.item(i, r+1).checkState())\n        return row\n    \n    def setTable(self, name, color = [1.0, 1.0, 1.0], opacity=1.0, display=2):\n        for i in range(self.n):\n            if self.table.item(i, 0).text() == name:\n                self.table.item(i, 2).setText(str(color))\n                self.table.item(i, 3).setText(str(opacity))\n                self.table.item(i, 4).setCheckState(display)\n\nclass AlignControls(QMainWindow):\n    """"""\n    Pop up for controls to align the \n    \n    Example\n    -------\n    Perhaps an example implementation:\n\n    >>> from GUIs.ampscanGUI import ampscanGUI\n\n    """"""\n\n    def __init__(self, names, parent = None):\n        super(AlignControls, self).__init__(parent)\n        self.main = QWidget()\n        self.names = names\n        self.static = QComboBox()\n        self.moving = QComboBox()\n        self.icp = QPushButton(""Run ICP"")\n        self.centre = QPushButton(""Centre"")\n        self.setCentralWidget(self.main)\n        self.layout = QGridLayout()\n        self.layout.addWidget(QLabel(\'Static\'), 0, 0)\n        self.layout.addWidget(QLabel(\'Moving\'), 1, 0)\n        self.layout.addWidget(self.static, 0, 1)\n        self.layout.addWidget(self.moving, 1, 1)\n        self.layout.addWidget(self.centre, 2, 0, 1, -1)\n        self.layout.addWidget(self.icp, 3, 0, 1, -1)\n        rots = [\'x\', \'y\', \'z\']\n        vals = [\'-5\', \'-0.5\', \'+0.5\', \'+5\']\n        for i, r in enumerate(rots):\n            setattr(self, r + \'rotBox\', QHBoxLayout())\n            setattr(self, r + \'rotButton\', QButtonGroup())\n            lab = QLabel(r + \' rotation\')\n            getattr(self, r + \'rotBox\').addWidget(lab)\n            for v in vals:\n                button = QPushButton(v)\n                getattr(self, r + \'rotBox\').addWidget(button)\n                getattr(self, r + \'rotButton\').addButton(button)\n            self.layout.addLayout(getattr(self, r + \'rotBox\'), i+4, 0, 1, -1)\n        for i, r in enumerate(rots):\n            setattr(self, r + \'traBox\', QHBoxLayout())\n            setattr(self, r + \'traButton\', QButtonGroup())\n            lab = QLabel(r + \' translation\')\n            getattr(self, r + \'traBox\').addWidget(lab)\n            for v in vals:\n                button = QPushButton(v)\n                getattr(self, r + \'traBox\').addWidget(button)\n                getattr(self, r + \'traButton\').addButton(button)\n            self.layout.addLayout(getattr(self, r + \'traBox\'), i+7, 0, 1, -1)\n        self.main.setLayout(self.layout)\n        self.setWindowTitle(""Alignment Manager"")\n        self.getNames()\n    \n    def getNames(self):\n        """"""\n        """"""\n        self.static.clear()\n        self.static.addItems(self.names)\n        self.moving.clear()\n        self.moving.addItems(self.names)\n\n     \nclass RegistrationControls(QMainWindow):\n    """"""\n    Pop up for controls to align the \n    \n    Example\n    -------\n    Perhaps an example implementation:\n\n    >>> from GUIs.ampscanGUI import ampscanGUI\n\n    """"""\n\n    def __init__(self, names, parent = None):\n        super(RegistrationControls, self).__init__(parent)\n        self.main = QWidget()\n        self.names = names\n        self.baseline = QComboBox()\n        self.target = QComboBox()\n        self.reg = QPushButton(""Run Registration"")\n        # self.tick = QCheckBox(""Generate Output File for Comparison?"")\n        self.setCentralWidget(self.main)\n        self.layout = QGridLayout()\n        self.layout.addWidget(QLabel(\'Baseline\'), 0, 0)\n        self.layout.addWidget(QLabel(\'Target\'), 1, 0)\n        self.layout.addWidget(self.baseline, 0, 1)\n        self.layout.addWidget(self.target, 1, 1)\n        # self.layout.addWidget(self.tick, 2,1)\n        self.layout.addWidget(self.reg, 3, 0, 1, -1)\n        self.main.setLayout(self.layout)\n        self.setWindowTitle(""Registration Manager"")\n        self.getNames()\n    \n    def getNames(self):\n        """"""\n        """"""\n        self.baseline.clear()\n        self.baseline.addItems(self.names)\n        self.target.clear()\n        self.target.addItems(self.names)\n\nclass saveControls(QMainWindow):\n    """"""\n    Pop up for controls to align the \n    \n    Example\n    -------\n    Perhaps an example implementation:\n\n    >>> from GUIs.ampscanGUI import ampscanGUI\n\n    """"""\n\n    def __init__(self, names, parent = None):\n        super(saveControls, self).__init__(parent)\n        self.main = QWidget()\n        self.names = names\n        self.files = QComboBox()\n        self.files.clear()\n        self.files.addItems(names)\n        self.save = QPushButton(""Save file"")\n        # self.tick = QCheckBox(""Generate Output File for Comparison?"")\n        self.setCentralWidget(self.main)\n        self.layout = QGridLayout()\n        self.layout.addWidget(QLabel(\'File\'), 0, 0)\n        self.layout.addWidget(self.files, 0, 1)\n        # self.layout.addWidget(self.tick, 2,1)\n        self.layout.addWidget(self.save, 1, 0, 1, -1)\n        self.main.setLayout(self.layout)\n        self.setWindowTitle(""Save file Manager"")\n\n\n\ndef show_message(message, message_type=""err"", title=""An Error Occured...""):\n    """"""\n    Parameters\n    ----------\n    message : string\n        The message to be displayed\n    message_type : string\n        The type of message e.g. ""err"" or ""info""\n    title : string\n        The title of the dialog window\n\n    Examples\n    --------\n    >>> show_message(""test"")\n    >>> show_message(""test2"", ""info"", ""test"")\n\n    """"""\n    dialog = QMessageBox()\n    dialog.setText(message)\n    dialog.setWindowTitle(title)\n    icons = {\n        ""err"": QMessageBox.Critical,\n        ""info"": QMessageBox.Information\n    }\n    dialog.setIcon(icons[message_type])\n    dialog.setStandardButtons(QMessageBox.Ok)\n\n    # Makes sure doesn\'t close until user closes it\n    dialog.exec_()\n\n    return dialog\n\n\nif __name__ == ""__main__"":\n    app = QApplication(sys.argv)\n#    mainWin = AlignControls([\'\'])\n    mainWin = ampscanGUI()\n    mainWin.show()\n    sys.exit(app.exec_())'"
tests/__init__py.py,0,b''
tests/test_align.py,0,"b'""""""\nTesting suite for the align module\n""""""\n\nimport unittest\nfrom util import get_path\nfrom ampscan import align\n\n\nclass TestAlign(unittest.TestCase):\n    DELTA = 0.01\n\n    def setUp(self):\n        """"""Runs before each unit test.\n        Sets up AmpObject object using ""stl_file_4.stl"" ""stl_file_5.stl"".\n        """"""\n        from ampscan.core import AmpObject\n        # Load 2 spheres with radius 1, and 1.2\n        stl_path = get_path(""stl_file_5.stl"") # R=1\n        self.amp1 = AmpObject(stl_path)\n        stl_path = get_path(""stl_file_4.stl"") # R=1.2\n        self.amp2 = AmpObject(stl_path)\n\n    def test_align(self):\n        """"""Test that objects that are already centered on origin are aligned correctly""""""\n        al = align(self.amp1, self.amp2).m\n\n        # Both objects are already centered, so should be close to origin (allowing for some inaccuracy)\n        self.assertAlmostEqual(al.vert.mean(axis=0)[0], 0, delta=TestAlign.DELTA)\n        self.assertAlmostEqual(al.vert.mean(axis=0)[1], 0, delta=TestAlign.DELTA)\n        self.assertAlmostEqual(al.vert.mean(axis=0)[2], 0, delta=TestAlign.DELTA)\n\n\n    def test_align_points(self):\n        """"""Test that the shape can be aligned to -5mm in z axis""""""\n        mv = [\n            [0, 0, 5],\n            [5, 0, 5],\n            [0, 5, 5]\n        ]\n        sv = [\n            [0, 0, 0],\n            [5, 0, 0],\n            [0, 5, 0]\n        ]\n        al = align(self.amp1, self.amp2, mv=mv, sv=sv, method=\'contPoints\').m\n        zMax = self.amp1.vert[:, 2].max() - 5\n        # Both objects are already centered, so should be close to origin (allowing for some inaccuracy)\n        self.assertAlmostEqual(al.vert[:, 2].max(), zMax, delta=TestAlign.DELTA)\n'"
tests/test_analyse.py,0,"b'""""""\nTesting suite for the registration module\n""""""\n\nimport unittest\nfrom util import get_path\nfrom ampscan import analyse\nimport math\n\n\nclass TestAnalyse(unittest.TestCase):\n    DELTA = 0.2\n\n    def setUp(self):\n        """"""Runs before each unit test.\n        Sets up the AmpObject object using ""stl_file.stl"".\n        """"""\n        from ampscan.core import AmpObject\n\n        # Radius = 1\n        stl_path = get_path(""stl_file_4.stl"")\n        self.amp1 = AmpObject(stl_path)\n\n        # Radius = 1.2\n        stl_path = get_path(""stl_file_5.stl"")\n        self.amp2 = AmpObject(stl_path)\n\n        # Spheroid with major radius 1 and minor 0.5\n        stl_path = get_path(""stl_file_7.stl"")\n        self.amp3 = AmpObject(stl_path)\n\n    def test_registration_spheres(self):\n        """"""Test the analyse module by calculating the theoretical volume of a sphere \n        and compring """"""\n        # Check the volume is correct\n        # Object is a sphere, so area is (4/3)*math.pi*(R**3)\n        # In this case R = 1.2\n        self.assertAlmostEqual(analyse.calc_volume_closed(self.amp2, return_closed=False), (4/3)*math.pi*(1.2**3), delta=TestAnalyse.DELTA)'"
tests/test_basics.py,0,"b'""""""\nTesting suite for basic functionality\n""""""\nimport unittest\nimport os\nimport sys\n\n\nclass TestBasicFunction(unittest.TestCase):\n\n    def test_setup(self):\n        """"""Tests that the path can be obtained""""""\n        modPath = os.path.abspath(os.getcwd())\n        sys.path.insert(0, modPath)\n\n    def test_python_imports(self):\n        """"""Test imports""""""\n        import numpy, scipy, matplotlib, vtk, ampscan.core\n        s = str(type(numpy))\n        self.assertEqual(s, ""<class \'module\'>"")\n        s = str(type(scipy))\n        self.assertEqual(s, ""<class \'module\'>"")\n        s = str(type(matplotlib))\n        self.assertEqual(s, ""<class \'module\'>"")\n        s = str(type(vtk))\n        self.assertEqual(s, ""<class \'module\'>"")\n        s = str(type(ampscan.core))\n        self.assertEqual(s, ""<class \'module\'>"", ""Failed import: ampscan.core"")\n'"
tests/test_core.py,6,"b'""""""\nTesting suite for the core module\n""""""\n\nimport unittest\nimport numpy as np\nfrom random import randrange\nfrom util import get_path\nfrom ampscan import analyse\n\n\nclass TestCore(unittest.TestCase):\n    ACCURACY = 5  # The number of decimal places to value accuracy for - needed due to floating point inaccuracies\n\n    def setUp(self):\n        """"""Runs before each unit test.\n        Sets up the AmpObject object using ""stl_file.stl"".\n        """"""\n        from ampscan.core import AmpObject\n        stl_path = get_path(""stl_file.stl"")\n        self.amp = AmpObject(stl_path)\n\n    def test_centre(self):\n        """"""Test the centre method of AmpObject""""""\n\n        # Translate the mesh\n        self.amp.translate([1, 0, 0])\n        # Recenter the mesh\n        self.amp.centre()\n        centre = self.amp.vert.mean(axis=0)\n\n        # Check that the mesh is centred correctly (to at least the number of decimal places of ACCURACY)\n        self.assertTrue(all(centre[i] < (10**-TestCore.ACCURACY) for i in range(3)))\n\n    def test_centre_static(self):\n\n        with self.assertRaises(TypeError):\n            self.amp.centreStatic(1)\n        with self.assertRaises(TypeError):\n            self.amp.centreStatic([])\n\n        # Import second shape\n        from ampscan.core import AmpObject\n        stl_path = get_path(""stl_file_2.stl"")\n        amp2 = AmpObject(stl_path)\n\n        self.amp.centreStatic(amp2)\n\n        for i in range(3):\n            # This method has a large degree of error so, it\'s only testing to 2 dp\n            self.assertAlmostEqual(self.amp.vert.mean(axis=0)[i], amp2.vert.mean(axis=0)[i], 2)\n\n    def test_rotate_ang(self):\n        """"""Tests the rotateAng method of AmpObject""""""\n\n        # Test rotation on random node\n        n = randrange(len(self.amp.vert))\n        rot = [0, 0, np.pi/3]\n        before = self.amp.vert[n].copy()\n        self.amp.rotateAng(rot)\n        after_vert_pos = self.amp.vert[n].copy()\n        # Use 2D rotation matrix formula to test rotate method on z axis\n        expected = [np.cos(rot[2])*before[0]-np.sin(rot[2])*before[1], np.sin(rot[2])*before[0]+np.cos(rot[2])*before[1], before[2]]\n        # Check all coordinate dimensions are correct\n        all(self.assertAlmostEqual(expected[i], after_vert_pos[i], TestCore.ACCURACY) for i in range(3))\n\n        # Check single floats cause TypeError\n        with self.assertRaises(TypeError):\n            self.amp.rotateAng(7)\n\n        # Check dictionaries cause TypeError\n        with self.assertRaises(TypeError):\n            self.amp.rotateAng(dict())\n\n        # Tests that incorrect number of elements causes ValueError\n        with self.assertRaises(ValueError):\n            self.amp.rotateAng(rot, ""test"")\n        with self.assertRaises(ValueError):\n            self.amp.rotateAng(rot, [])\n\n    def test_rotate(self):\n        """"""Tests the rotate method of AmpObject""""""\n        # A test rotation and translation using list\n        m = [[1, 0, 0], [0, np.sqrt(3)/2, 1/2], [0, -1/2, np.sqrt(3)/2]]\n        self.amp.rotate(m)\n\n        # Check single floats cause TypeError\n        with self.assertRaises(TypeError):\n            self.amp.rotate(7)\n\n        # Check dictionaries cause TypeError\n        with self.assertRaises(TypeError):\n            self.amp.rotate(dict())\n\n        # Check invalid dimensions cause ValueError\n        with self.assertRaises(ValueError):\n            self.amp.rotate([])\n        with self.assertRaises(ValueError):\n            self.amp.rotate([[0, 0, 1]])\n        with self.assertRaises(ValueError):\n            self.amp.rotate([[], [], []])\n\n    def test_translate(self):\n        """"""Test translating method of AmpObject""""""\n\n        # Check that everything has been translated correctly to a certain accuracy\n        start = self.amp.vert.mean(axis=0).copy()\n        self.amp.translate([1, -1, 0])\n        end = self.amp.vert.mean(axis=0).copy()\n        self.assertAlmostEqual(start[0]+1, end[0], places=TestCore.ACCURACY)\n        self.assertAlmostEqual(start[1]-1, end[1], places=TestCore.ACCURACY)\n        self.assertAlmostEqual(start[2], end[2], places=TestCore.ACCURACY)\n\n        # Check that translating raises TypeError when translating with an invalid type\n        with self.assertRaises(TypeError):\n            self.amp.translate("""")\n\n        # Check that translating raises ValueError when translating with 2 dimensions\n        with self.assertRaises(ValueError):\n            self.amp.translate([0, 0])\n\n        # Check that translating raises ValueError when translating with 4 dimensions\n        with self.assertRaises(ValueError):\n            self.amp.translate([0, 0, 0, 0])\n\n    def test_rigid_transform(self):\n        """"""Test the rigid transform method of AmpObject""""""\n\n        # Test if no transform is applied, vertices aren\'t affected\n        before_vert = self.amp.vert.copy()\n        self.amp.rigidTransform(R=None, T=None)\n        all(self.assertEqual(self.amp.vert[y][x], before_vert[y][x])\n            for y in range(len(self.amp.vert))\n            for x in range(len(self.amp.vert[0])))\n\n        # A test rotation and translation\n        m = [[1, 0, 0], [0, np.sqrt(3)/2, 1/2], [0, -1/2, np.sqrt(3)/2]]\n        self.amp.rigidTransform(R=m, T=[1, 0, -1])\n\n        # Check that translating raises TypeError when translating with an invalid type\n        with self.assertRaises(TypeError):\n            self.amp.rigidTransform(T=dict())\n\n        # Check that rotating raises TypeError when translating with an invalid type\n        with self.assertRaises(TypeError):\n            self.amp.rigidTransform(R=7)\n\n    def test_rot_matrix(self):\n        """"""Tests the rotMatrix method in AmpObject""""""\n\n        # Tests that a transformation by 0 in all axis is 0 matrix\n        all(self.amp.rotMatrix([0, 0, 0])[y][x] == 0\n            for x in range(3)\n            for y in range(3))\n\n        expected = [[1, 0, 0], [0, np.sqrt(3)/2, 1/2], [0, -1/2, np.sqrt(3)/2]]\n        all(self.amp.rotMatrix([np.pi/6, 0, 0])[y][x] == expected[y][x]\n            for x in range(3)\n            for y in range(3))\n\n        # Tests that string passed into rot causes TypeError\n        with self.assertRaises(TypeError):\n            self.amp.rotMatrix("" "")\n        with self.assertRaises(TypeError):\n            self.amp.rotMatrix(dict())\n\n        # Tests that incorrect number of elements causes ValueError\n        with self.assertRaises(ValueError):\n            self.amp.rotMatrix([0, 1])\n        with self.assertRaises(ValueError):\n            self.amp.rotMatrix([0, 1, 3, 0])\n\n    def test_flip(self):\n        """"""Tests the flip method in AmpObject""""""\n        # Check invalid axis types cause TypeError\n        with self.assertRaises(TypeError):\n            self.amp.flip("" "")\n        with self.assertRaises(TypeError):\n            self.amp.flip(dict())\n\n        # Check invalid axis values cause ValueError\n        with self.assertRaises(ValueError):\n            self.amp.flip(-1)\n        with self.assertRaises(ValueError):\n            self.amp.flip(3)\n\n'"
tests/test_registration.py,0,"b'""""""\nTesting suite for the registration module\n""""""\n\nimport unittest\nfrom util import get_path\nfrom ampscan import registration, analyse\nimport math\n\n\nclass TestRegistration(unittest.TestCase):\n    DELTA = 0.2\n\n    def setUp(self):\n        """"""Runs before each unit test.\n        Sets up the AmpObject object using ""stl_file.stl"".\n        """"""\n        from ampscan.core import AmpObject\n\n        # Radius = 1\n        stl_path = get_path(""stl_file_4.stl"")\n        self.amp1 = AmpObject(stl_path)\n\n        # Radius = 1.2\n        stl_path = get_path(""stl_file_5.stl"")\n        self.amp2 = AmpObject(stl_path)\n\n        # Spheroid with major radius 1 and minor 0.5\n        stl_path = get_path(""stl_file_7.stl"")\n        self.amp3 = AmpObject(stl_path)\n\n    def test_registration_spheres(self):\n        """"""Test that registration runs on two spheres correctly by checking volume of resultant registered AmpObject.\n        Note that this is reliant on an accurate analyse module.""""""\n        reg = registration(self.amp1, self.amp2).reg\n        poly = analyse.create_slices(reg, [0.001, 0.999], 0.001, typ=\'norm_intervals\', axis=2)\n\n        # Check the volume is correct\n        # Object is a sphere, so area is (4/3)*math.pi*(R**3)\n        # In this case R = 1.2\n        self.assertAlmostEqual(analyse.est_volume(poly), (4/3)*math.pi*(1.2**3), delta=TestRegistration.DELTA)\n\n        # Test the diameter is correct\n        diameter = reg.vert[:, 2].max() - reg.vert[:, 2].min()\n        self.assertAlmostEqual(diameter, 1.2*2, delta=TestRegistration.DELTA)\n\n    def test_registration_spheres(self):\n        """"""Test that registration runs between a sphere and a spheroid correctly\n        by checking volume of resultant registered AmpObject.\n        Note that this is reliant on an accurate analyse module.""""""\n        reg = registration(self.amp3, self.amp1).reg\n        poly = analyse.create_slices(reg, [0.001, 0.999], 0.001, typ=\'norm_intervals\', axis=2)\n\n        # Check the volume is correct\n        # Object is a sphere, so area is (4/3)*math.pi*(R**3)\n        # In this case R = 1\n        self.assertAlmostEqual(analyse.est_volume(poly), (4/3)*math.pi*(1**3), delta=TestRegistration.DELTA)\n\n        # Test the diameter is correct\n        diameter = reg.vert[:, 2].max() - reg.vert[:, 2].min()\n        self.assertAlmostEqual(diameter, 2, delta=TestRegistration.DELTA)\n\n'"
tests/test_smoothing.py,0,"b'""""""\nTesting suite for the smoothing module\n""""""\n\nimport unittest\nfrom util import get_path\nfrom ampscan import analyse\nimport math\n\n\nclass TestSmoothing(unittest.TestCase):\n    ACCURACY = 5  # The number of decimal places to value accuracy for - needed due to floating point inaccuracies\n    DELTA = 0.5\n\n    def setUp(self):\n        """"""Runs before each unit test.\n        Sets up the AmpObject object using ""stl_file.stl"".\n        """"""\n        from ampscan.core import AmpObject\n        stl_path = get_path(""stl_file.stl"")\n        self.amp = AmpObject(stl_path)\n        self.amp2 = AmpObject(stl_path)\n        self.amp3 = AmpObject(stl_path)\n\n    def test_smoothing_nans(self):\n        """"""Tests that NaNs are properly dealt with by smooth method""""""\n        # Test that smoothing runs\n        self.amp.smoothValues()\n        # TODO add test with NaNs\n\n    def test_smoothing_volume(self):\n        """"""Tests that smoothing affects the volume within given acceptable range""""""\n        # TODO check this is actually working properly\n        poly1 = analyse.create_slices(self.amp, [0.01, 0.99], 0.005, typ=\'norm_intervals\', axis=2)\n        vol1 = analyse.est_volume(poly1) \n        print(vol1)\n        \n        self.amp2.lp_smooth(20)\n        poly2 = analyse.create_slices(self.amp2, [0.01, 0.99], 0.005, typ=\'norm_intervals\', axis=2)\n        vol2 = analyse.est_volume(poly2) \n        print(vol2)\n        # self.assertAlmostEqual(analyse.est_volume(poly1), analyse.est_volume(poly2), delta=TestSmoothing.DELTA)\n        \n        self.amp3.hc_smooth(n=20)\n        poly3 = analyse.create_slices(self.amp3, [0.01, 0.99], 0.005, typ=\'norm_intervals\', axis=2)\n        vol3 = analyse.est_volume(poly3) \n        print(vol3)\n        # self.assertAlmostEqual(analyse.est_volume(poly1), analyse.est_volume(poly3), delta=TestSmoothing.DELTA)\n        self.assertLess(vol1-vol3, vol1-vol2)\n\n'"
tests/test_trim.py,6,"b'""""""\nTesting suite for trim module\n""""""\nimport unittest\nfrom util import get_path\nimport numpy as np\n\n\nclass TestTrim(unittest.TestCase):\n\n    def setUp(self):\n        """"""Runs before each unit test\n        Sets up the AmpObject object using ""stl_file.stl""\n        """"""\n        from ampscan.core import AmpObject\n        stl_path = get_path(""stl_file.stl"")\n        self.amp = AmpObject(stl_path)\n\n    def test_trim(self):\n        """"""Tests the trim method of AmpObject for TypeErrors""""""\n\n        # Testing that the method runs\n        self.amp.planarTrim(0.6, plane=2)\n\n        # Testing invalid data types raise TypeErrors\n        with self.assertRaises(TypeError):\n            self.amp.planarTrim(0.6, plane=[])\n        with self.assertRaises(TypeError):\n            self.amp.planarTrim(0.6, plane=0.9)\n        with self.assertRaises(TypeError):\n            self.amp.planarTrim([], plane=[])\n\n    def test_trim_2(self):\n        """"""Tests the trim method of AmpObject by checking no vertices are above trim line""""""\n        # Test no points are above 10\n        h = 10\n        self.amp.planarTrim(h, plane=2)\n        self.assertLessEqual(self.amp.vert[:, 2].max(), h)\n\n        # Test no points are above 0\n        h = 0\n        self.amp.planarTrim(h, plane=2)\n        self.assertLessEqual(self.amp.vert[:, 2].max(), h)\n\n    def test_trim_3(self):\n        """"""Tests the trim method of AmpObject by checking no vertices are above trim line""""""\n        # Test no points are above 10\n        p0 = np.array([50, 50, 0])\n        p1 = np.array([50, -50, -40])\n        p2 = np.array([-50, 50, 10])\n        v0 = p1 - p0\n        v1 = p2 - p0\n        c = np.cross(v0, v1)\n        c = c/np.linalg.norm(c)\n        k = -np.multiply(c, p0).sum()\n        # planar values for each vert on face \n        \n        self.amp.threePointTrim(p0, p1, p2)\n        height = -(self.amp.vert[:, 0]*c[0] + self.amp.vert[:, 1]*c[0] + k)/c[2]\n        self.assertLessEqual(self.amp.vert[:, 2].max(), height.max())\n'"
tests/util.py,0,"b'""""""\nCommon test utilities\n""""""\nimport os\n\n\ndef get_path(filename):\n    """"""Returns the absolute path to a test file\n\n    Parameters\n    ----------\n    filename : string\n        Name of file in tests to get path to\n\n    Returns\n    -------\n    stl_path : string\n        The path to the file\n    """"""\n\n    # Check if the parent directory is tests (this is for Pycharm unittests)\n    if os.path.basename(os.getcwd()) == ""tests"":\n        # This is for Pycharm testing\n        stl_path = filename\n    else:\n        # This is for the Github testing\n        stl_path = os.path.join(os.path.abspath(os.getcwd()), ""tests"", filename)\n    return stl_path\n'"
ampscan/analyse/__init__.py,0,"b'from .analyse import (calc_volume_closed, create_slices, calc_perimeter, calc_widths, calc_csa, est_volume, \n                      visualise_slices, plot_slices, MeasurementsOut, CMapOut)\nfrom .output import getPDF, generateRegBinsCsv, generateRegCsv\n\ndel analyse, output'"
ampscan/analyse/analyse.py,40,"b'# -*- coding: utf-8 -*-\n""""""\nPackage for dealing with analysis methods of the ampObject and generating \nreports \nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk\n""""""\n\nimport numpy as np\nfrom ampscan.core import AmpObject\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as clr\nimport matplotlib.colorbar as clb\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom collections import defaultdict\nfrom .output import getPDF\nfrom math import floor\n#from .cython_ext import planeEdgeIntersect_cy, logEuPath_cy\nimport os\n\n# The file path used in doc examples\nfilename = os.path.join(os.getcwd(), ""tests"", ""stl_file.stl"")\n\ndef calc_volume_closed(amp_in, return_closed=False):\n    r""""""\n    Calculates the volume of a closed surface. If the surface is not closed the algorithm fills in the holes using a simple\n    hole filling algorithm, the surface without holes can be accessed if return_closed is set to True.\n\n\n    Parameters\n    ----------\n    amp: AmpObject \n        The AmpObject to analyse\n    return_closed: bool, default False\n        Indicate whether to return the shape with holes filled in  \n\n    Returns\n    -------\n    vol: float\n        The volume of the AmpObject\n    amp: AmpObject\n        If return_closed is True, then the closed shape is returned \n    """"""\n    amp = AmpObject({\n        \'vert\': amp_in.vert.copy(),\n        \'faces\': amp_in.faces.copy(),\n        \'values\': amp_in.values.copy(),\n    })\n    amp.calcStruct()\n    # Fill in the holes\n    while (amp.faceEdges == -99999).sum() != 0: \n        # Find the edges which are only conected to one face\n        edges = (amp.faceEdges == -99999).sum(axis=1).astype(bool)\n        edges = amp.edges[edges, :]\n        # Return the vert indicies for the loop\n        vInd = logEuPath(edges)\n        # Calculate the mmidpoint \n        midpoint = amp.vert[vInd, :].mean(axis=0)\n        # Add in the new vertex\n        amp.vert = np.r_[amp.vert, midpoint[None, :]]\n        f0 = amp.vert.shape[0] - 1\n        # Add in each face using adjacent vertices in loop\n        for f1, f2 in zip(vInd, np.roll(vInd, 1)):\n            amp.faces = np.r_[amp.faces, [[f1, f0, f2]]]\n        # Update structure and check if any more holes (algorithm keeps going until all holes filled)\n        amp.calcStruct()\n    # Calculate the area of each face in the array using vector cross product\n    v01 = amp.vert[amp.faces[:, 1], :] - amp.vert[amp.faces[:, 0], :]\n    v02 = amp.vert[amp.faces[:, 2], :] - amp.vert[amp.faces[:, 0], :]\n    cp = np.square(np.cross(v01, v02))\n    area = 0.5 * np.sqrt(cp.sum(axis=1))\n    # Get surface volume contributions \n    sVC = area * amp.vert[amp.faces, 2].mean(axis=1) * amp.norm[:, 2]\n    if return_closed is True:\n        return sVC.sum(), amp\n    else:\n        return sVC.sum()\n\n\n\ndef create_slices(amp, *args,  typ=\'slices\', axis = 2):\n    r""""""\n    Generate polygons from planar slices through the AmpObject. The slices are either defined as a \n    list of positions in some axis\n    \n    Parameters\n    ----------\n    amp: AmpObject \n        The AmpObject to analyse\n    slices: array_like\n        An array of the slice positions to take in the specified axis\n    limits: array_like\n        The limits of the slices, either in real world units or normalised depending on that specified in typ\n    intervals: float\n        The distance between slices, use in conjunction with \n    typ: str, \'slices\', \'real_intervals\', \'norm_intervals\'\n        The height of the slice planes\n    axis: int, default 2\n        The index of the axis to take the slices along\n    \n    Returns\n    -------\n    polys: list\n        A list of numpy arrays, each array contains the vertices of the \n        polygon generated from the slice\n\n    Examples\n    -------\n    >>> amp = AmpObject(filename)\n    >>> polys = create_slices(amp, [0.05, 0.95], 0.01, typ=\'norm_intervals\', axis=2)\n    >>> polys = create_slices(amp, [-150, -100, -50, 0], typ=\'slices\', axis=2)\n    >>> polys = create_slices(amp, [-150, 0], 10, typ=\'real_intervals\', axis=2)\n    """"""\n    # Setup the slices array \n    if typ == \'slices\':\n        # Return error if no slices given provided \n        slices = args[0]\n    elif typ == \'real_intervals\':\n        lim = args[0]\n        intervals = args[1]\n        slices = np.arange(lim[0], lim[1], intervals)\n    elif typ == \'norm_intervals\':\n        # Get the minimum and maximum of the limb\n        limb_min = amp.vert[:, axis].min()\n        limb_max = amp.vert[:, axis].max()\n        limb_len = limb_max - limb_min\n        lim = args[0]\n        intervals = args[1]\n        slices = np.arange(lim[0], lim[1], intervals)\n        slices = limb_min + (slices * limb_len)\n        \n    else: \n        return\n        # Return error that typ is an invalid value \n    \n    # Now start to calculate the polyons on each slice\n    \n    # Get the vertices on each edges \n    vE = amp.vert[:, axis][amp.edges]\n    # Find all vertices below plane \n    polys = []\n    for plane in slices:\n        ind = vE < plane\n        # Select edges with one vertex above and one below the slice plane \n        validEdgeInd = np.where(np.logical_xor(ind[:,0], ind[:,1]))[0]\n        validfE = amp.faceEdges[validEdgeInd, :].astype(int)\n        faceOrder = logEuPath(validfE)\n        # Get array of three edges attached to each face\n        validEdges = amp.edgesFace[faceOrder, :]\n        # Remove the edge that is not intersected by the plane\n        edges = validEdges[np.isin(validEdges, validEdgeInd)].reshape([-1,2])\n        # Remove the duplicate edge from order \n        e = edges.flatten()\n        sortE = []\n        for ed in e:\n            if ed not in sortE:\n                sortE.append(ed)\n        sortE.append(sortE[0])\n        # Add first edge to end of array\n#            sortE = np.append(sortE, sortE[0])\n        sortE = np.asarray(sortE)\n        polyEdge = amp.edges[sortE]\n        EdgePoints = np.c_[amp.vert[polyEdge[:,0], :], \n                            amp.vert[polyEdge[:,1], :]]\n        #Create poly from \n        polys.append(planeEdgeIntersect_cy(EdgePoints, plane, axis))\n    return polys\n\ndef calc_perimeter(polys):\n    r""""""\n    Calculate the perimeter of each polygon from the slicing of the AmpObject  \n\n    Parameters\n    ----------\n    polys: list\n        A list of numpy arrays, each array contains the vertices of the \n        polygon generated from the slice. Generate using ampscan.analyse.create_slices()\n\n    Returns\n    -------\n    perimeter: array_like\n        Returns the perimeter of the limb in mm along the axis \n    """"""\n    perimeter = np.zeros(len(polys))\n    # Iterate over each polygon\n    for i, p in enumerate(polys):\n        # Get the distances in each dimension between adjacent points \n        d = p[1:, :] - p[:-1, :]\n        # Calculate the normalised distance between points \n        dist = np.linalg.norm(d, axis=1)\n        # Sum the distances to get the perimeter\n        perimeter[i] = dist.sum()\n    # Return the perimeter and distance of limb over which perimeter calculated\n    return perimeter\n\n\n\ndef calc_widths(polys):\n    r""""""\n    Calculate the coronal and sagittal widths of each polygon from the slicing of the AmpObject  \n\n    Parameters\n    ----------\n    polys: list\n        A list of numpy arrays, each array contains the vertices of the \n        polygon generated from the slice. Generate using ampscan.analyse.create_slices()\n\n    Returns\n    -------\n    cor_width: array_like\n        Returns the coronal width in mm along the axis\n    sag_width: array_like\n        Returns the sagittal width in mm along the axis \n    """"""\n    cor_width = np.zeros(len(polys))\n    sag_width = np.zeros(len(polys))\n    # Automatically check the axis of slicing by finding the axis with minimal deviation\n    # The correct axis should have 0 deviation\n    ix = np.argmin(polys[0].max(axis=0) - polys[0].min(axis=0))\n    # Remove from list the index for slicing axis \n    ind = [0,1,2]\n    ind.remove(ix)\n    for i, p in enumerate(polys):\n        # Get the widths through min - max \n        sag_width[i], cor_width[i] = p[:, ind].max(axis=0) - p[:, ind].min(axis=0)\n    return cor_width, sag_width\n\ndef calc_csa(polys):\n    r""""""\n    Calculate the cross sectional area of each polygon from the slicing of the AmpObject  \n\n    Parameters\n    ----------\n    polys: list\n        A list of numpy arrays, each array contains the vertices of the \n        polygon generated from the slice. Generate using ampscan.analyse.create_slices()\n\n    Returns\n    -------\n    csa: array_like\n        Returns the cross-sectional area of the limb in mm^2 along the axis \n    """"""\n    csa = np.zeros(len(polys))\n    # Automatically check the axis of slicing by finding the axis with minimal deviation\n    # The correct axis should have 0 deviation\n    ix = np.argmin(polys[0].max(axis=0) - polys[0].min(axis=0))\n    # Remove from list the index for slicing axis \n    ind = [0,1,2]\n    ind.remove(ix)\n    # Iterate over each poly to calculcate cross sectional area \n    for i, p in enumerate(polys):\n        csa[i] = 0.5*np.abs(\n                            np.dot(\n                                   p[:,ind[0]], \n                                   np.roll(p[:,ind[1]], 1)\n                                  ) \n                            -\n                            np.dot(\n                                   p[:,ind[1]], \n                                   np.roll(p[:,ind[0]], 1)\n                                   )\n                            )\n    return csa\n\ndef est_volume(polys):\n    r""""""\n    Estimate the volume of the limb using bounds of the slices \n\n    Parameters\n    ----------\n    polys: list\n        A list of numpy arrays, each array contains the vertices of the \n        polygon generated from the slice. Generate using ampscan.analyse.create_slices()\n\n    Returns\n    -------\n    Volume: float\n        Returns the estimated volume of the limb in mm^3 along the axis \n    """"""\n    # Automatically check the axis of slicing by finding the axis with minimal deviation\n    # The correct axis should have 0 deviation\n    ix = np.argmin(polys[0].max(axis=0) - polys[0].min(axis=0))\n    # Remove from list the index for slicing axis \n    ind = [0,1,2]\n    ind.remove(ix)\n    # Calculate the csa\n    csa = calc_csa(polys)\n    # Get the distance between each slice \n    d = []\n    for p in polys: \n        d.append(p[:, ix].mean())\n    d = np.asarray(d)\n    # Get distance between each slice \n    dist = np.abs(d[1:]- d[:-1])\n    # Calculate volume between each slice by mutliplying the \n    # mean cross sectional area by the distance \n    vol = np.c_[csa[1:], csa[:-1]]\n    vol = np.mean(vol, axis=1) * dist\n    return vol.sum()\n    \n\ndef logEuPath(arr):\n    """"""\n    Calculate the eularian path for an array of edges so the vertices all connect\n    """"""\n    vmax = arr.shape[0]\n    rows = list(range(vmax))\n    # order = np.zeros([vmax], dtype=int)\n    order = [];\n    i = 0\n    val = arr[i, 0]\n    nmax = vmax-1\n    for n in range(nmax):\n        del rows[i]\n        # order[n] = val\n        order.append(val)\n        i=0\n        for x in rows: \n            if arr[x, 0] == val:\n                val = arr[x, 1]\n                break\n            if arr[x, 1] == val:\n                val = arr[x, 0]\n                break\n            i+=1\n    # order[n+1] = val\n    order.append(val)\n    order = np.asarray(order, dtype=int)\n    return order\n\n\ndef planeEdgeIntersect_cy(arr, plane, axisInd):\n    r""""""\n    Calculate the intersection between a an array of edges and a plane\n    \n    Parameters \n    ----------\n    edges: array_like \n        The edge array which have been calculated to cross the plane\n    plane: float\n        The height of the plane\n    axis: int, default 2\n        The index of the axis of the slice\n    \n    Returns\n    -------\n    intersectPoints: ndarray\n        The intersection points between the edges and the plane\n    \n    """"""\n    emax = arr.shape[0]\n    intersectPoints = np.zeros((emax, 3), dtype=np.float32)\n    intersectPoints[:, axisInd] = plane\n    for i in range(emax):\n        for j in range(2):\n            e1 = arr[i, j]\n            e2 = arr[i, axisInd]\n            e3 = arr[i, j+3]\n            e4 = arr[i, axisInd+3]\n            intersectPoints[i, j] = e1 + (plane - e2) * (e3 - e1) / (e4 - e2)\n    return intersectPoints\n\ndef planeEdgeintersect(edges, plane, axis=2):\n    r""""""\n    Calculate the intersection between a an array of edges and a plane\n    \n    Parameters \n    ----------\n    edges: array_like \n        The edge array which have been calculated to cross the plane\n    plane: float\n        The height of the plane\n    axis: int, default 2\n        The index of the axis of the slice\n    \n    Returns\n    -------\n    intersectPoints: ndarray\n        The intersection points between the edges and the plane\n    \n    """"""\n    # Allocate intersect points array\n    intersectPoints = np.zeros((edges.shape[0], 3))\n    # Define the plane of intersect points\n    intersectPoints[:, axis] = plane\n    axesInd = np.array([0,1,2])[np.array([0,1,2]) != axis]\n    for i in axesInd:\n        intersectPoints[:, i] = (edges[:, i] +\n                                    (plane - edges[:, axis]) *\n                                    (edges[:, i+3] - edges[:, i]) /\n                                    (edges[:, axis+3] - edges[:, axis]))\n    return intersectPoints\n\n\ndef visualise_slices(amp):\n    r""""""\n    Create an mpl figure with the 3D rendering, slices, slice height and cross sectional area\n    """"""\n    fig = plt.figure()\n    fig.set_size_inches(8, 8)\n    ax = plt.axes(projection=""3d"")\n    X = amp.vert[:, 0]\n    Y = amp.vert[:, 1]\n    Z = amp.vert[:, 2]\n    ax.view_init(elev=0., azim=-90)\n    ax.axis(\'off\')\n    ax.set_proj_type(\'ortho\')\n    ax.set_aspect(\'equal\')\n    ax.plot_trisurf(X, Y, Z, triangles=amp.faces, color=(1.0, 1.0, 1.0), \n                    shade=False, edgecolor=\'none\', linewidth=0, antialiased=False)\n    plt.savefig(\'test1.png\', dpi=600)\n    plt.close(fig)\n\ndef plot_slices(amp, axis=2, slWidth=10):\n    r""""""\n    Generate a mpl figure with information about the AmpObject\n    \n    Top Left - Slices\n    Top Right - Change in cross sectional area through slices\n    Bottom Left - Rendering of shape\n    Bottom Right - Rendering of shape with values \n    \n    TODO: Split this up so each figure is it\'s own function, top level \n    function to tailor figure to user \n    \n    Parameters\n    ----------\n    axis: int, default 2\n        Axis along which to take slices\n    slWidth: float, default 10\n        Distance between slices\n    \n    Returns\n    -------\n    fig: mpl figure\n        The mpl figure generated by the function\n    ax: tuple\n        A tuple of axes used for each subplot in the figure\n\n    """"""\n    # Find the brim edges \n    ind = np.where(amp.faceEdges[:,1] == -99999)[0]\n    # Define max Z from lowest point on brim\n    maxZ = amp.vert[amp.edges[ind, :], 2].min()\n    # Create slices\n    slices = np.arange(amp.vert[:,2].min() + slWidth,\n                        maxZ, slWidth)\n    # Create polys \n    polys = create_slices(amp, slices, axis)\n    # Plot each poly\n    fig = plt.figure()\n    fig.set_size_inches(6, 4.5)\n    ax1 = fig.add_subplot(221, projection=\'3d\')\n    for p in polys:\n        ax1.plot(p[:,0],\n                 p[:,1],\n                 p[:,2],\n                 c=\'b\')\n    extents = np.array([getattr(ax1, \'get_{}lim\'.format(dim))() for dim in \'xyz\'])\n    sz = extents[:,1] - extents[:,0]\n    centers = np.mean(extents, axis=1)\n    maxsize = max(abs(sz))\n    r = maxsize/2\n    for ctr, dim in zip(centers, \'xyz\'):\n        getattr(ax1, \'set_{}lim\'.format(dim))(ctr - r, ctr + r)\n    ax1.set_axis_off()\n\n    # Calculate the area along the length of the limb \n    PolyArea = calc_csa(polys)\n    # Plot area along limb \n    ax2 = fig.add_subplot(222)\n    ax2.plot(slices-slices[0], PolyArea)\n\n    # Rendering of the limb scan\n    ax3 = fig.add_subplot(2,2,3)\n    Im = amp.genIm()[0]\n    ax3.imshow(Im, None)\n    ax3.set_axis_off()\n\n    # Rendering of the rectification map \n    ax4 = fig.add_subplot(2,2,4)\n    amp.addActor(CMap = amp.CMapN2P)\n    Im = amp.genIm()[0]\n    ax4.imshow(Im, None)\n    ax4.set_axis_off()\n    plt.tight_layout()\n    plt.show()\n    return fig, (ax1, ax2, ax3, ax4)\n\ndef MeasurementsOut(amp, pos):\n    """"""\n    Calculates perimeter of limb/cast at intervals from mid-patella to the\n    end of stump\n    Takes position of mid-patella (x,y,z) coordinates as input\n    Also creates images of limb views and graphs of CSA/Widths, which are\n    used in the PDF.\n    Calls the function responsible for adding the information to the PDF\n    template.\n    TODO: Split this into functions for each part i.e. Volume measure, CSA,\n    widths\n\n    Returns\n    -------\n    The path to the output file\n    """"""\n    # print(pos)\n    maxZ = []\n    for i in [0,1,2]:\n        maxZ.append((amp.vert[:, i]).max() - (amp.vert[:, i]).min())\n    #slice in longest axis of scan\n    axis = maxZ.index(max(maxZ))\n    maxZ = max(maxZ)\n    zval = pos[axis]\n    # Get 6 equally spaced pts between mid-patella and stump end\n    slices = np.linspace(zval, (amp.vert[:, axis]).min()+0.1, 6)\n    # uses create_slices\n    polys = create_slices(amp, slices, axis=axis)\n    # calc perimeter of slices\n    perimeter = calc_perimeter(polys)\n    # distance between slice and mid-patella\n    lngth = (slices - zval) / 10\n    #print(lngth, perimeter)\n    #generate png files of anterior and lateral views\n    amp.genIm(out=\'fh\',fh=\'lat.png\',az=-90)\n    amp.genIm(mag=1,out=\'fh\',fh=\'ant.png\')\n\n    #calculations at %length intervals of 10%\n    L = maxZ - ((amp.vert[:,axis]).max()-zval)-10\n    pL = np.linspace(0,1.2,13)\n    slices2 = []\n    for i in pL:\n        slices2.append((amp.vert[:,axis]).min()+10+(i*L))\n    # uses create_slices\n    polys = create_slices(amp, slices2, axis=axis)\n\n    PolyArea = calc_csa(polys)\n    MLWidth, APWidth = calc_widths(polys)\n\n    # Plot the figure \n    fig = plt.figure()\n    fig.set_size_inches(7.5, 4.5)\n    ax = fig.add_subplot(221)\n    ax.plot(pL*100, PolyArea)\n    ax.set_xlabel(""% length"")\n    ax.set_ylabel(""Area (cm^2)"")\n    ax2 = fig.add_subplot(222)\n    ax2.plot(pL*100, MLWidth, \'ro\',label=\'Medial-Lateral\')\n    ax2.plot(pL*100, APWidth, \'b.\',label=\'Anterior-Posterior\')\n    ax2.set_xlabel(""% length"")\n    ax2.set_ylabel(""width (cm)"")\n    ax2.legend()\n    fig.savefig(""figure.png"")\n    return getPDF(lngth, perimeter, PolyArea, APWidth, MLWidth)  # PDF Creation function (in output.py)\n    # Divided by 10 to convert to cms, assumes stl files are in mm\n    # TODO: Some sort of metric conversion function?\n\n\ndef CMapOut(amp, colors):\n    """"""\n    Colour Map with 4 views (copied Josh\'s code)\n    """"""\n    titles = [\'Anterior\', \'Medial\', \'Proximal\', \'Lateral\']\n    fig,axes = plt.subplots(ncols=5)\n    cmap = clr.ListedColormap(colors, name=\'Amp\')\n    norm = clr.Normalize(vmin=-10,vmax=10)\n    cb1 = clb.ColorbarBase(axes[-1], cmap=cmap,norm=norm)\n    cb1.set_label(\'Shape deviation / mm\')\n    for i, ax in enumerate(axes[:-1]):\n        im = amp.genIm(size=[3200, 8000],crop=True, az = i*90)[0]\n        ax.imshow(im)\n        ax.set_title(titles[i])\n        ax.set_axis_off()\n    #plt.colorbar(CMap)\n    fig.set_size_inches([12.5, 4])\n    plt.savefig(""Limb Views.png"", dpi=600)\n\n'"
ampscan/analyse/output.py,0,"b'from PyPDF2 import PdfFileReader, PdfFileWriter\nimport pathlib\nfrom pathlib import Path\nfrom reportlab.pdfgen import canvas\nimport io\nimport os\nimport csv\n\n\ndef getPDF(lngths, perimeters, CSA, APW, MLW):\n    """"""\n    creates a PDF file containing information about the limb in correct\n    locations on the page\n    then merges the PDF file with the existing template to create the output\n    file\n\n    Returns\n    -------\n    The file path to the PDF\n    """"""\n    path = pathlib.Path(__file__).parent.absolute()\n    my_file = Path(path, ""Measurements Template.pdf"")\n    try:\n        my_abs_path = my_file.resolve(strict=True)\n    except:\n        return(1) \n    packet = io.BytesIO()\n    c = canvas.Canvas(packet)\n    for i in range(1, len(lngths)-1):\n        stringl = ""{}"".format(abs(round(lngths[i],1)))\n        stringp = ""{}"".format(abs(round(perimeters[i],1)))\n        c.drawString(360+((i-1)*27), 474-((i-1)*41.5), stringl)\n        c.drawString(88, 524.5- ((i-1)*74.5), stringp)\n    stringmaxZ = ""{}"".format(abs(round(lngths[len(lngths)-1],1)))\n    c.drawString(514, 419, stringmaxZ)\n    c.setFont(""Courier-Bold"", 12)\n    c.drawString(65, 575, ""Perimeter / cm"")\n    c.drawString(400, 520, ""Distance / cm"")\n    c.showPage()\n    c.drawImage(""ant.png"", 38,225, 256,256)\n    c.drawImage(""lat.png"", 300,225,256,256)\n    c.drawImage(""figure.png"", -2.5,-50, 334,200)\n    for i in range(1,len(CSA),2):\n        sCSA = ""{}"".format(round(CSA[i],1))\n        sAPW = ""{}"".format(round(APW[i],1))\n        sMLW = ""{}"".format(round(MLW[i],1))\n        c.drawString(403, 145-((i-1)*11.5), sCSA)\n        c.drawString(465, 145-((i-1)*11.5), sAPW)\n        c.drawString(520, 145-((i-1)*11.5), sMLW)\n    c.save()\n    packet.seek(0)\n    newpdf = PdfFileReader(packet)\n\n    template = PdfFileReader(open(os.path.join(path, ""Measurements Template.pdf""), ""rb""))\n    t2 = PdfFileReader(open(os.path.join(path, ""Output Template.pdf""), ""rb""))\n    output = PdfFileWriter()\n    page = t2.getPage(0)\n    page.mergePage(newpdf.getPage(1))\n    page2 = template.getPage(0)\n    page2.mergePage(newpdf.getPage(0))\n    output.addPage(page)\n    output.addPage(page2)\n\n    output_file_path = os.path.join(get_downloads_folder(), ""ampscanReport.pdf"")\n    outputStream = open(output_file_path, ""wb"")\n    output.write(outputStream)\n\n    outputStream.close()\n\n    return output_file_path\n\n\ndef get_downloads_folder():\n    """"""Gets the downloads folder in a relatively platform independent way""""""\n\n    # Get user dir\n    downloads_path = os.path.join(os.path.expanduser(""~""), ""Downloads"")\n    if not os.path.exists(downloads_path):  # If downloads folder doesn\'t exist, create it\n        os.mkdir(downloads_path)\n\n    return downloads_path\n\n\ndef generateRegBinsCsv(file, regObject, numBins, scalarMin, scalarMax):\n    """"""\n    Generates a CSV file output of scalar values put into bins\n    :param file: The open file to save csv output to. Should be open with newline=\'\'\n    :param regObject: The reg object with scalar values\n    :param numBins: Number of bins for scalar values\n    :param scalarMin: The min scalar value to look for\n    :param scalarMax: The max scalar value to look for\n    :return: None\n    """"""\n    writer = csv.writer(file)\n\n    binSize = (scalarMax - scalarMin) / numBins\n    bins = []\n    binValues = []\n    for i in range(numBins):\n        binValues.append(scalarMin + binSize * i)\n        bins.append(0)\n    for point in regObject.values:\n        bin = int((point - scalarMin) / binSize)\n        if bin < 0:\n            bins[0] += 1\n        elif bin >= len(bins):\n            bins[-1] += 1\n        else:\n            bins[bin] += 1\n    l = len(regObject.values)\n\n    for i in range(numBins):\n        writer.writerow([scalarMin+binSize*i, bins[i] / l])\n\n\ndef generateRegCsv(file, regObject):\n    """"""\n    Generates a CSV file output of scalar values put into bins\n    :param file: The open file to save csv output to. Should be open with newline=\'\'\n    :param regObject: The reg object with scalar values\n    :return: None\n    """"""\n    writer = csv.writer(file)\n    for i in regObject.values:\n        writer.writerow([i])\n\n'"
ampscan/vis/__init__.py,0,"b'from .vis import vtkRenWin, qtVtkWindow, visMixin, ampActor\ndel vis'"
ampscan/vis/vis.py,15,"b'# -*- coding: utf-8 -*-\n""""""\nClasses and functions to deal with the visualisation of the AmpObjects. These\ninclude wrappers for vtk and Qt\nCopyright: Joshua Steer 2020, Joshua.Steer@soton.ac.uk \n""""""\n\nimport numpy as np\nimport vtk\nfrom vtk.util import numpy_support\nfrom vtk.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor\nvtk.vtkObject.GlobalWarningDisplayOff()\n\n\nclass vtkRenWin(vtk.vtkRenderWindow):\n    r""""""\n    This class inherits from the vtkRenderWindow and wraps extra functions on\n    top \n    \n    This window can be either be used on it\'s own, or embedded within a \n    Qt Window\n\n    """"""\n    def __init__(self):\n        super(vtkRenWin, self).__init__()\n        self.rens = [vtk.vtkRenderer(),]\n#        self.cams = [vtk.vtkCamera(),]\n        self.axes = []\n        self.AddRenderer(self.rens[0])\n#        self.setView()\n        self.scalar_bar = None\n#        self.cams.append(vtk.vtkCamera())\n#        self.setView()\n#        self.rens.append(vtkRender())\n#        self.rens[0].SetBackground(0.1, 0.2, 0.4)\n#        self.rens[0].SetBackground(1.0,1.0,1.0)\n        #self.rens[0].SetActiveCamera(self.cams[0])\n#        self.axes.append(vtk.vtkCubeAxesActor())\n        self.markers = []\n        self.labels = []\n        self.triad = None\n\n        \n    def renderActors(self, actors, viewport=0, zoom=1.0):\n        r""""""\n        Given a list of ampActors, this function removes those which are not in \n        the new list, and adds in the new ones \n        \n        Parameters\n        ----------\n        actors: list of ampActors\n            A list of actors to be displayed in the render window\n        viewport: int, default 0\n            The viewport index to render the actor within\n        zoom: float, default 1.0\n            The zoom magnitude of the camera\n        \n        """"""\n        for actor in self.rens[viewport].GetActors():\n            self.rens[viewport].RemoveActor(actor)\n        for actor in actors:\n            self.rens[viewport].AddActor(actor)\n            if hasattr(actor, \'pActors\'):\n                for p in actor.pActors:\n                    self.rens[viewport].AddActor(p)\n            if hasattr(actor, \'lActors\'):\n                for l in actor.lActors:\n                    self.rens[viewport].AddActor(l)\n        self.rens[viewport].ResetCamera()\n        self.rens[viewport].GetActiveCamera().Zoom(zoom)\n        self.Render()\n\n    def setScalarBar(self, actor, viewport=0, title=\'\'):\n        r""""""\n        Set the scalar bar within the window based upon a look-up table defined\n        within an actor\n        \n        Parameters\n        ---------\n        actor: ampActor\n            The actor from which the lut is read from, the actor must have the\n            attribute actor.lut\n        viewport: int, default 0\n            The viewport index to render the scalar bar within \n        title: str\n            The accompanying title for the scalar bar\n        \n        Returns\n        -------\n        scalar_bar\n            A vtkScalarBarActor attribute to the vtkRenWin\n        \n        """"""\n        if self.scalar_bar is not None:\n            self.rens[0].RemoveActor(self.scalar_bar)\n        self.scalar_bar = vtk.vtkScalarBarActor()\n#        self.scalar_bar.AnnotationTextScalingOff()\n#        self.scalar_bar.SetTitle(\'Interfacial Pressure, kPa\')\n        self.scalar_bar.SetLookupTable(actor.lut)\n        self.scalar_bar.UnconstrainedFontSizeOn()\n        self.scalar_bar.SetOrientationToVertical()\n        self.scalar_bar.SetPosition(0.8, 0.15)\n        self.scalar_bar.SetPosition2(0.1, 0.7)\n        self.scalar_bar.SetLabelFormat(\'%-#3.1f\')\n        self.scalar_bar.GetLabelTextProperty().SetFontFamilyToArial()\n        self.scalar_bar.GetLabelTextProperty().BoldOff()\n        self.scalar_bar.GetLabelTextProperty().ShadowOff()\n        self.scalar_bar.GetLabelTextProperty().SetColor(0, 0, 0)\n        self.scalar_bar.GetLabelTextProperty().SetFontSize(18)\n        self.scalar_bar.GetLabelTextProperty().ItalicOff()\n        self.scalar_bar.SetTitle(title)\n        self.scalar_bar.GetTitleTextProperty().SetFontFamilyToArial()\n        self.scalar_bar.GetTitleTextProperty().BoldOff()\n        self.scalar_bar.GetTitleTextProperty().ShadowOff()\n        self.scalar_bar.GetTitleTextProperty().SetColor(0, 0, 0)\n        self.scalar_bar.GetTitleTextProperty().SetFontSize(20)\n        self.scalar_bar.GetTitleTextProperty().ItalicOff()\n        self.rens[viewport].AddActor(self.scalar_bar)\n\n    def setView(self, view = [0, -1, 0], viewport=0):\n        r""""""\n        Function to set the camera view within the specified viewport\n        \n        Parameters\n        ----------\n        view: array_like, default [0, -1, 0]\n            The view of the vtk camera \n        viewport: int, default 0\n            The index of the viewport to set the camera view\n        \n        """"""\n        #self.cams[viewport].SetPosition(view[0], view[1], view[2])\n        #self.cams[viewport].SetViewUp(-0.0, 1.0, 0.0)\n        cam = self.rens[viewport].GetActiveCamera()\n        cam.Elevation(-90)\n    \n    def setBackground(self, color=[0.1, 0.2, 0.4]):\n        r""""""\n        Set the background colour of the renderer\n        \n        Parameters\n        ----------\n        color: array_like\n            The RGB values as floats of the background colour between [0, 1]\n\n        """"""\n        for ren in self.rens:\n            ren.SetBackground(color)\n    \n    def setProjection(self, perspective=False, viewport=0):\n        r""""""\n        Set the projection of the camera to either parallel or perspective \n        \n        Parameters\n        ----------\n        perspective: boolean, default False\n            If true, then perspective will be used as the projection for the\n            camera\n        viewport: int, default 0\n            The index of the viewport to set the projection of the camera in\n        \n        """"""\n        cam = self.rens[viewport].GetActiveCamera()\n        cam.SetParallelProjection(perspective)\n        \n            \n    def addAxes(self, actors, viewport=0, color = [1.0, 1.0, 1.0], font=None):\n        r""""""\n        Add 3D axes to the vtk window \n        \n        Parameters\n        ----------\n        actors: list\n            List of ampActors, this is used to determine the necessary limits\n            of the axes\n        viewport: int, default 0\n            The index of the viewport add the axes into\n        color: array_like\n            The RGB values as floats of the axes line and text colour\n            between [0, 1]\n        """"""\n        self.axes = vtk.vtkCubeAxesActor()\n        lim = []\n        ax = self.axes\n        for actor in actors:\n            lim.append(actor.GetBounds())\n        if lim:\n            lim = np.array(lim) * 1.2\n            ax.SetBounds(tuple(lim.max(axis=0)))\n        ax.SetCamera(self.rens[viewport].GetActiveCamera())\n        ax.SetFlyModeToClosestTriad()\n        for axes in range(3):\n            ax.GetTitleTextProperty(axes).SetColor(color)\n            ax.GetLabelTextProperty(axes).SetColor(color)\n            ax.GetTitleTextProperty(axes).SetFontFamilyToCourier()\n            ax.GetLabelTextProperty(axes).SetFontFamilyToCourier()\n        ax.GetXAxesLinesProperty().SetColor(color)\n        ax.GetYAxesLinesProperty().SetColor(color)\n        ax.GetZAxesLinesProperty().SetColor(color)\n        ax.XAxisMinorTickVisibilityOff()\n        ax.YAxisMinorTickVisibilityOff()\n        ax.ZAxisMinorTickVisibilityOff()\n        actors.append(ax)\n        self.renderActors(actors)\n\n    def addTriad(self, actors, viewport=0, color = [1.0, 1.0, 1.0], font=None):\n        r""""""\n        Add 3D axes to the vtk window \n        \n        Parameters\n        ----------\n        actors: list\n            List of ampActors, this is used to determine the necessary limits\n            of the axes\n        viewport: int, default 0\n            The index of the viewport add the axes into\n        color: array_like\n            The RGB values as floats of the axes line and text colour\n            between [0, 1]\n        """"""\n        lim = []\n        for actor in actors:\n            lim.append(actor.GetBounds())\n        if lim:\n            lim = np.array(lim) * 1.1\n            lim = lim.max(axis=0)\n        else:\n            lim = [0, 1, 0, 1, 0, 1]\n        transform = vtk.vtkTransform()\n        transform.Translate(lim[0], lim[2], lim[4])\n        scale = (lim[5] - lim[4]) * 0.1\n        transform.Scale(scale, scale, scale)\n        if self.triad:\n            self.rens[viewport].RemoveActor(self.triad)\n        self.triad = vtk.vtkAxesActor()\n        #  The axes are positioned with a user transform\n        self.triad.SetUserTransform(transform)\n        for ax in [self.triad.GetXAxisCaptionActor2D(), self.triad.GetYAxisCaptionActor2D(), self.triad.GetZAxisCaptionActor2D()]:\n            ax.GetTextActor().GetTextProperty().SetFontFamilyToCourier()\n            ax.GetTextActor().GetTextProperty().SetColor(0, 0, 0)\n            ax.GetTextActor().GetTextProperty().ShadowOff()\n            ax.GetTextActor().GetTextProperty().BoldOff()\n            ax.GetTextActor().GetTextProperty().ItalicOff()\n            ax.GetTextActor().GetTextProperty().SetFontSize(8)\n        self.rens[viewport].AddActor(self.triad)\n        self.Render()\n\n\n    def setnumViewports(self, n):\n        r""""""\n        Function to set multiple viewports within the vtkWindow\n\n        Parameters\n        ------------\n        n: int\n            number of viewports required\n        \n        """"""\n        dif = n - len(self.rens)\n        if dif == 0:\n            return\n        elif dif < 0:\n            for ren in self.rens[n:]:\n                self.RemoveRenderer(ren)\n            self.rens = self.rens[:n]\n        elif dif > 0:\n            for i in range(dif):\n                self.rens.append(vtk.vtkRenderer())\n                self.axes.append(vtk.vtkCubeAxesActor())\n                self.AddRenderer(self.rens[-1])\n                if len(self.cams) < len(self.rens):\n                    self.cams.append(vtk.vtkCamera())\n                self.rens[-1].SetActiveCamera(self.cams[len(self.rens)-1])\n        for i, ren in enumerate(self.rens):\n            ren.SetViewport(float(i)/n, 0, float(i+1)/n, 1)\n        self.setBackground()\n        \n    \n    def getImage(self):\n        r""""""\n        Return an array representation of the image \n        \n        Returns\n        -------\n        im: ndarray\n            The array representation of the image \n        \n        """"""\n        vtkRGB = vtk.vtkUnsignedCharArray()\n        width, height = self.GetSize()\n        self.GetPixelData(0, 0, width-1, height-1,\n                          1, vtkRGB)\n        vtkRGB.Squeeze()\n        im =  np.flipud(np.resize(np.array(vtkRGB),\n                                  [height, width, 3])) / 255.0\n        return im\n                                       \n    def getScreenshot(self, fname, mag=10):\n        r""""""\n        Generate a screenshot of the window and save to a png file\n        \n        Parameters\n        ----------\n        fname: str\n            The file handle to save the image to \n        mag: int, default 10\n            The magnificaiton of the image, this will scale the resolution of \n            the saved image by this face \n        \n        """"""\n        self.SetAlphaBitPlanes(1)\n        w2if = vtk.vtkWindowToImageFilter()\n        w2if.SetInput(self)\n        w2if.SetScale(mag)\n        w2if.SetInputBufferTypeToRGBA()\n        w2if.Update()\n        \n        writer = vtk.vtkPNGWriter()\n        writer.SetFileName(fname)\n        writer.SetInputConnection(w2if.GetOutputPort())\n        writer.Write()\n\n    def Pick_point(self, loc):\n        """"""\n        This receives coordinates in the GUI where user has picked, converts it\n        to mesh coordinates using vtkCellPicker, and places a sphere at picked\n        location as a visual aid. Also places a label at the point in the \n        render window.\n        TO-DO: Add functionality so user can type the label in, rather than\n        have it read \'Mid Patella\' every time\n        """"""\n        \n        x, y = loc\n        renderer = self.rens[0]\n        picker = vtk.vtkCellPicker()\n        picker.SetTolerance(0.01)\n        picker.Pick(x, y, 0, renderer)\n        points = picker.GetPickedPositions()\n        numPoints = points.GetNumberOfPoints()\n        #if no points selected, exits function\n        if numPoints<1: return\n        # Calls function to create a sphere at selected point\n        pnt = points.GetPoint(0)\n        self.mark(pnt[0], pnt[1], pnt[2])\n        # Creating label at selected point\n        label = vtk.vtkStringArray()\n        label.SetName(\'label\')\n        label.InsertNextValue(""   Mid Patella"")\n        lPoints = vtk.vtkPolyData()\n        lPoints.SetPoints(points)\n        lPoints.GetPointData().AddArray(label)\n        \n        hier = vtk.vtkPointSetToLabelHierarchy()\n        hier.SetInputData(lPoints)\n        hier.SetLabelArrayName(\'label\')\n        hier.GetTextProperty().SetColor(0,0,0)\n        hier.GetTextProperty().SetFontSize(30)\n        \n        lMapper = vtk.vtkLabelPlacementMapper()\n        lMapper.SetInputConnection(hier.GetOutputPort())\n        lMapper.SetBackgroundColor(0.3,0.3,0.3)\n        lMapper.SetBackgroundOpacity(0.8)\n        lMapper.SetMargin(10)\n        \n        lActor = vtk.vtkActor2D()\n        lActor.SetMapper(lMapper)\n        self.labels.append(lActor) # keep track of all label actors\n        \n        self.rens[0].AddActor(lActor)\n        self.Render()\n        return pnt\n        \n\n    def mark(self, x,y,z):\n        """"""\n        mark the picked point with a sphere\n        """"""\n        sphere = vtk.vtkSphereSource()\n        sphere.SetRadius(3)\n        res = 20\n        sphere.SetThetaResolution(res)\n        sphere.SetPhiResolution(res)\n        sphere.SetCenter(x,y,z)\n        mapper = vtk.vtkPolyDataMapper()\n        mapper.SetInputConnection(sphere.GetOutputPort())\n\n        self.marker = vtk.vtkActor()\n        self.marker.SetMapper(mapper)\n        self.rens[0].AddActor(self.marker)\n        self.marker.GetProperty().SetColor( (1,0,0) )\n        self.markers.append(self.marker) #keep track of all marker actors\n        self.Render()\n\n    def delMarker(self):\n        """"""\n        removes the sphere marker and label from the renderer\n        """"""\n        for i in self.markers:\n            self.rens[0].RemoveActor(i)\n        for i in self.labels:\n            self.rens[0].RemoveActor(i)\n        self.markers = []\n        self.labels = []\n\n\nclass qtVtkWindow(QVTKRenderWindowInteractor):\n    r""""""\n    This provides the interface between Qt and the vtkRenWin\n    """"""\n    \n    def __init__(self):\n        super(qtVtkWindow, self).__init__(rw=vtkRenWin())\n        self.style = vtk.vtkInteractorStyleTrackballCamera()\n        self.SetInteractorStyle(self.style)\n        self.iren = self._RenderWindow.GetInteractor()\n        self.iren.Initialize()        \n\n\nclass visMixin(object):\n    r""""""\n    Set of visualisation methods that are contained within the AmpActor\n    \n    """"""\n\n    def genIm(self, size=[512, 512], views=[[0, -1, 0]], \n              background=[1.0, 1.0, 1.0], projection=True,\n              shading=True, mag=10, out=\'im\', fh=\'test.tiff\', \n              zoom=1.0, az = 0, el=0,crop=False, cam=None):\n        r""""""\n        Creates a temporary off screen vtkRenWin which is then either returned\n        as a numpy array or saved as a .png file\n        \n        Parameters\n        ----------\n        out: str: default \'im\'\n            If \'im\' the the image will be returned as an array, if \'fh\' the \n            image will be saved as .png image\n        size: array_like, default [512, 512]\n            The width and height of the vtkRenWin to create\n        views: array_like, default [[0, -1, 0],]\n            The camera view set for each viewport, the length of this also\n            sets the number of viewports\n        background: array_like, default [1, 1, 1]\n            The RGB values as floats of the background colour between [0, 1]\n        projection: boolean, default True\n            If true, then perspective will be used as the projection for the\n            camera\n        shading: boolean, default True\n            If true, shading will be used on the ampActor\n        mag: int, default 10\n            The magnification for saving the image\n        fh: str\n            The file handle used if out =\'fh\'\n        \n        Returns\n        -------\n        im: ndarray\n            The array representation of the image if out = \'im\'\n        \n        """"""\n        if not hasattr(self, \'actor\'):\n            self.addActor()\n        # Generate a renderer window\n        win = vtkRenWin()\n        win.OffScreenRenderingOn()\n        # Set the number of viewports\n        win.setnumViewports(len(views))\n        # Set the background colour\n        win.setBackground(background)\n        # Set camera projection \n        win.setProjection(projection)\n        win.SetSize(size[0], size[1])\n        win.Modified()\n        win.OffScreenRenderingOn()\n        \n        for i, view in enumerate(views):\n#            win.addAxes([self.actor,], color=[0.0, 0.0, 0.0], viewport=i)\n            win.setView(view, i)\n#            win.setProjection(projection, viewport=i)\n            win.renderActors([self.actor,], zoom=zoom)\n        win.rens[0].GetActiveCamera().Azimuth(az)\n        win.rens[0].GetActiveCamera().Elevation(el)\n        if cam is not None:\n            win.rens[0].SetActiveCamera(cam)\n        win.Render()\n        if out == \'im\':\n            im = win.getImage()\n            if crop is True:\n                mask = np.all(im == 1, axis=2)\n                mask = ~np.all(mask, axis=1)\n                im = im[mask, :, :]\n                mask = np.all(im == 1, axis=2)\n                mask = ~np.all(mask, axis=0)\n                im = im[:, mask, :]\n            return im, win\n        elif out == \'fh\':\n            win.getScreenshot(fh)\n            return\n        \n    def display(self):\n        r""""""\n        Function to display the ampActor within in an interactable \n        vtkRenWin window\n        \n        Returns\n        -------\n        win: vtkRenWin\n            The generated vtkRenWin\n        \n        """"""\n        if not hasattr(self, \'actor\'):\n            self.addActor()\n        # Generate a renderer window\n        win = vtkRenWin()\n        # Set the number of viewports\n        win.setnumViewports(1)\n        # Set the background colour\n        win.setBackground([1,1,1])\n        # Set camera projection \n        renderWindowInteractor = vtk.vtkRenderWindowInteractor()\n        renderWindowInteractor.SetRenderWindow(win)\n        renderWindowInteractor.SetInteractorStyle(vtk.vtkInteractorStyleTrackballCamera())\n        # Set camera projection \n        win.setView()\n        win.renderActors([self.actor,])\n        win.Render()\n        win.rens[0].GetActiveCamera().Azimuth(0)\n        win.rens[0].GetActiveCamera().SetParallelProjection(True)\n        win.Render()\n        return win\n\n\n    def addActor(self, CMap=None, bands=128, sRange=[0,8]):\n        r""""""\n        Creates an ampActor based upon the ampObject \n        \n        """"""\n        self.actor = ampActor()\n        #self._v = numpy_support.numpy_to_vtk(self.vert, deep=0)\n        self.actor.setVert(self.vert)\n        self.actor.setFaces(self.faces)\n        self.actor.setNorm()\n        # Test if values array is non-zero\n        if self.values.any():\n            self.actor.setValues(self.values)\n            self.createCMap()\n            if self.values.min() < 0:\n                self.actor.setCMap(self.CMapN2P, bands)\n                self.actor.setScalarRange([self.values.min(), self.values.max()])\n                self.actor.Mapper.SetLookupTable(self.actor.lut)\n            else: \n                self.actor.setCMap(self.CMap02P, bands)\n                self.actor.setScalarRange([0, self.values.max()])\n                self.actor.Mapper.SetLookupTable(self.actor.lut)\n\n    def createCMap(self, cmap=None, n = 50):\n        r""""""\n        Function to generate a linear colormap for the AmpObj based upon \n        base colours \n        \n        cmap: array_like\n            The rgb float values of the base colors used to generate the \n            colormap\n        n: int, default 50\n            The number of bands that form the colormap\n\n        """"""\n        if cmap is None:\n            c1 = [31.0, 73.0, 125.0]\n            c3 = [170.0, 75.0, 65.0]\n            c2 = [212.0, 221.0, 225.0]\n            CMap1 = np.c_[[np.linspace(st, en) for (st, en) in zip(c1, c2)]]\n            CMap2 = np.c_[[np.linspace(st, en) for (st, en) in zip(c2, c3)]]\n            CMap = np.c_[CMap1[:, :-1], CMap2]\n            self.CMapN2P = np.transpose(CMap)/255.0\n            self.CMap02P = np.flip(np.transpose(CMap1)/255.0, axis=0)\n        \n\nclass ampActor(vtk.vtkActor):\n    r""""""\n    A wrapper around the classic vtkActor that makes it easier to transfer \n    data from the ampObject \n    """"""\n\n    def __init__(self, CMap=None, bands=128):\n        super(ampActor, self).__init__()\n        self.mesh = vtk.vtkPolyData()\n        self.points = vtk.vtkPoints()\n        self.polys = vtk.vtkCellArray()\n        self.Mapper = vtk.vtkPolyDataMapper()\n        #self.setVert(data[\'vert\'])\n        #self.setFaces(data[\'faces\'])\n        #self.setNorm()\n        #if CMap is not None:\n        #    self.setRect(data[\'values\'])\n        #    self.setCMap(CMap, bands)\n        self.Mapper.InterpolateScalarsBeforeMappingOn()\n        self.Mapper.SetInputData(self.mesh)\n        #if CMap is not None:\n        #    self.setScalarRange()\n        #    self.Mapper.SetLookupTable(self.lut)\n        self.SetMapper(self.Mapper)\n        \n\n    def setVert(self, vert, deep=0):\n        """"""\n        Set the vertices of the ampActor\n        \n        Parameters\n        ----------\n        vert: ndarray\n            The numpy array specifying the vertices \n        deep: int, default 0\n            If 1, the numpy array will be deep-copied to the ampActor\n        \n        """"""\n        self._v = numpy_support.numpy_to_vtk(vert, deep=deep)\n        self.points.SetData(self._v)\n#            self.points.SetData(vert)\n        self.mesh.SetPoints(self.points)\n        \n    def setFaces(self, faces, deep=0):\n        r""""""\n        Sets the faces of the ampActor\n        \n        Parameters\n        ----------\n        faces: ndarray\n            The numpy array specifying the faces, or connectivity index based\n            upon the vertex array\n        deep: int, default 0\n            If 1, the numpy array will be deep-copied to the ampActor\n        """"""\n        self._faces = np.c_[np.tile(faces.shape[1], faces.shape[0]),\n                            faces].flatten().astype(np.int64)\n        self._f = numpy_support.numpy_to_vtkIdTypeArray(self._faces, deep=deep)\n        self.polys.SetCells(len(faces), self._f)\n        self.mesh.SetPolys(self.polys)\n    \n    def setNorm(self, norm=None, deep=0):\n        r""""""\n        Sets or calculates the vertex normals \n        \n        Parameters\n        ----------\n        norm: ndarray, default None\n            The numpy array specifying the face normals. If None, the inbuilt \n            vtk method will be used to calculate the normals\n        deep: int, default 0\n            If 1, the numpy array will be deep-copied to the ampActor\n\n        """"""\n        if norm is not None:\n            self._n = numpy_support.numpy_to_vtk(norm, deep=deep)\n            self.mesh.GetPointData().SetNormals(self._n)\n        else:\n            self.norm = vtk.vtkPolyDataNormals()\n            self.norm.ComputePointNormalsOn()\n            self.norm.ComputeCellNormalsOff()\n            self.norm.SetFeatureAngle(30.0)\n            self.norm.SetInputData(self.mesh)\n            self.norm.Update()\n            self.mesh.DeepCopy(self.norm.GetOutput())\n        self.GetProperty().SetInterpolationToGouraud()\n\n    def setValues(self, values, deep=0):\n        """"""\n        Set the values of the ampActor\n        \n        Parameters\n        ----------\n        values: ndarray\n            Scalar data attached to each vertex\n        deep: int, default 0\n            If 1, the numpy array will be deep-copied to the ampActor\n        \n        """"""\n        self._values = numpy_support.numpy_to_vtk(values, deep=deep)\n        self.mesh.GetPointData().SetScalars(self._values)\n        \n    def setOpacity(self, opacity=1.0):\n        r""""""\n        Sets the opacity of the ampActor\n        \n        Parameters\n        ----------\n        opacity: float, default 1.0\n            Opacity value between [0 1]\n        """"""\n        self.GetProperty().SetOpacity(opacity)\n        \n    def setColor(self, color=[1.0, 1.0, 1.0]):\n        r""""""\n        Sets the color of the ampActor\n        \n        Parameters\n        ----------\n        color: array_like, default [1.0, 1.0, 1.0]\n            The RGB values as floats of the ampActor colour between [0, 1]\n        \n        """"""\n        self.GetProperty().SetColor(color)\n        \n    def setScalarRange(self, sRange):\n        r""""""\n        Sets the scalar range on the ampActor\n        \n        Parameters\n        ----------\n        sRange: array_like\n            Specifies the lower and upper bound of the scalar range to display\n        """"""\n        self.Mapper.SetScalarRange(sRange[0], sRange[1])\n        \n\n    def setCMap(self, CMap, bands=128):\n        r""""""\n        Sets the colormap used to display scalar values\n        \n        Parameters\n        ----------\n        CMap: array_like\n            The base colors used to define the color map\n        bands: int, default 128\n            The number of contour bands to divide up the color map\n        """"""\n        self.ctf = vtk.vtkColorTransferFunction()\n        self.ctf.SetColorSpaceToDiverging()\n        for ind, point in zip(np.linspace(0, 1, len(CMap)), CMap):\n            self.ctf.AddRGBPoint(ind, point[0], point[1], point[2])\n        self.lut = vtk.vtkLookupTable()\n        self.lut.SetNumberOfTableValues(bands)\n        self.lut.Build()\n        for i in range(bands):\n            rgb = list(self.ctf.GetColor(float(i) / bands)) + [1]\n            self.lut.SetTableValue(i, rgb)\n        self.Mapper.SetLookupTable(self.lut)\n    \n    def setShading(self, shading=True):\n        r""""""\n        Sets whether shading is used on the ampActor\n        \n        Parameters\n        ----------\n        shading: boolean, default True\n            If True, shading is used in the display of the ampActor\n        """"""\n        if shading is True:\n            self.GetProperty().LightingOn()\n        if shading is False:\n            self.GetProperty().LightingOff()\n\n    def addSlices(self, slices):\n        r""""""\n        Adds slices into the AmpActor which can then be rendered \n\n        Parameters\n        ----------\n        slices: array_like\n            The values in the z-axis of which to make the slices \n        """"""\n        self.planes = []\n        self.cutters = []\n        self.pMapper = []\n        self.pActors = []\n        self.lActors = []\n        self.labels = []\n        self.hier = []\n        self.lMapper = []\n        for s in slices:\n            p = vtk.vtkPlane()\n            p.SetOrigin(0, 0, s)\n            p.SetNormal(0, 0, 1)\n            c = vtk.vtkCutter()\n            c.SetCutFunction(p)\n            c.SetInputData(self.mesh)\n            c.Update()\n            cM=vtk.vtkPolyDataMapper()\n            cM.SetInputConnection(c.GetOutputPort())\n            pA=vtk.vtkActor()\n            pA.GetProperty().SetColor(31.0/255.0, 73.0/255.0, 125.0/255.0)\n            pA.GetProperty().SetLineWidth(5)\n            pA.GetProperty().SetInterpolationToFlat()\n            pA.GetProperty().EdgeVisibilityOn()\n            pA.GetProperty().SetRenderLinesAsTubes(True)\n            pA.SetMapper(cM)\n\n            text = vtk.vtkBillboardTextActor3D()\n            text.SetInput(\'test\')\n            text.SetPosition(0,0,s)\n            text.GetTextProperty().SetColor(0, 0, 0)\n\n\n            self.planes.append(p)\n            self.cutters.append(c)\n            self.pMapper.append(cM)\n            self.pActors.append(pA)\n            self.lActors.append(text)\n        self.setOpacity(0.1)\n\n\n'"
