file_path,api_count,code
nms.py,0,"b'def overlapping_area(detection_1, detection_2):\n    \n    x1_tl = detection_1[0]\n    x2_tl = detection_2[0]\n    x1_br = detection_1[0] + detection_1[3]\n    x2_br = detection_2[0] + detection_2[3]\n    y1_tl = detection_1[1]\n    y2_tl = detection_2[1]\n    y1_br = detection_1[1] + detection_1[4]\n    y2_br = detection_2[1] + detection_2[4]\n    # Calculate the overlapping Area\n    x_overlap = max(0, min(x1_br, x2_br)-max(x1_tl, x2_tl))\n    y_overlap = max(0, min(y1_br, y2_br)-max(y1_tl, y2_tl))\n    overlap_area = x_overlap * y_overlap\n    area_1 = detection_1[3] * detection_2[4]\n    area_2 = detection_2[3] * detection_2[4]\n    total_area = area_1 + area_2 - overlap_area\n    return overlap_area / float(total_area)\n\ndef nms(detections, threshold=.5):\n   \n    detections = sorted(detections, key=lambda detections: detections[2],\n            reverse=True)\n    \n    new_detections=[]\n    \n    new_detections.append(detections[0])\n    \n    del detections[0]\n    \n    for index, detection in enumerate(detections):\n        for new_detection in new_detections:\n            if overlapping_area(detection, new_detection) > threshold:\n                del detections[index]\n                break\n        else:\n            new_detections.append(detection)\n            del detections[index]\n    return new_detections\n\nif __name__ == ""__main__"":\n    \n    detections = [[31, 31, .9, 10, 10], [31, 31, .12, 10, 10], [100, 34, .8,10, 10]]\n    print (""Detections before NMS = {}"".format(detections))\n    print (""Detections after NMS = {}"".format(nms(detections)))\n'"
run.py,0,"b'import cv2\nimport numpy as np\nimport time\nfrom skimage.feature import hog\nfrom sklearn.externals import joblib\nfrom nms import nms\nimport argparse\n\n# made by abhinav sagar on 7/2/2019\n\ndef appendRects(i, j, conf, c, rects):\n    x = int((j)*pow(scaleFactor, c))\n    y = int((i)*pow(scaleFactor, c))\n    w = int((64)*pow(scaleFactor, c))\n    h = int((128)*pow(scaleFactor, c))\n    rects.append((x, y, conf, w, h))\n\nparser = argparse.ArgumentParser(description=\'To read image name\')\n\nparser.add_argument(\'-i\', ""--image"", help=""Path to the test image"", required=True)\nparser.add_argument(\'-d\',\'--downscale\', help=""Downscale ratio"", default=1.2, type=float)\nparser.add_argument(\'-v\', \'--visualize\', help=""Visualize the sliding window"", action=""store_true"")\nparser.add_argument(\'-w\', \'--winstride\', help=""Pixels to move in one step, in any direction"", default=8, type=int)\nparser.add_argument(\'-n\', \'--nms_threshold\', help=""Threshold Values between 0 to 1 for NMS thresholding. Default is 0.2"", default=0.2, type=float)\nargs = vars(parser.parse_args())\n\n\n\nclf = joblib.load(""pedestrian.pkl"")\n\n\norig = cv2.imread(args[""image""])\n\nimg = orig.copy()\n\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n\nscaleFactor = args[""downscale""]\ninverse = 1.0/scaleFactor\nwinStride = (args[""winstride""], args[""winstride""])\nwinSize = (128, 64)\n\nrects = []\n\nh, w = gray.shape\ncount = 0\nwhile (h >= 128 and w >= 64):\n\n    print (gray.shape)\n\n    h, w= gray.shape\n    horiz = w - 64\n    vert = h - 128\n    print (horiz, vert)\n    i = 0\n    j = 0\n    while i < vert:\n        j = 0\n        while j < horiz:\n\n            portion = gray[i:i+winSize[0], j:j+winSize[1]]\n            features = hog(portion, orientations=9, pixels_per_cell=(8, 8), cells_per_block=(2, 2), block_norm=""L2"")\n\n            result = clf.predict([features])\n\n            if args[""visualize""]:\n                visual = gray.copy()\n                cv2.rectangle(visual, (j, i), (j+winSize[1], i+winSize[0]), (0, 0, 255), 2)\n                cv2.imshow(""visual"", visual)\n                cv2.waitKey(1)\n\n            if int(result[0]) == 1:\n                print (result, i, j)\n                confidence = clf.decision_function([features])\n                appendRects(i, j, confidence, count, rects)\n\n\n            j = j + winStride[0]\n\n        i = i + winStride[1]\n\n    gray = cv2.resize(gray, (int(w*inverse), int(h*inverse)), interpolation=cv2.INTER_AREA)\n    count = count + 1\n    print (count)\n\nprint (rects)\n\nnms_rects = nms(rects, args[""nms_threshold""])\n\nfor (a, b, conf, c, d) in rects:\n    cv2.rectangle(orig, (a, b), (a+c, b+d), (0, 255, 0), 2)\n\ncv2.imshow(""Before NMS"", orig)\ncv2.waitKey(0)\n\n\n\nfor (a, b, conf, c, d) in nms_rects:\n    cv2.rectangle(img, (a, b), (a+c, b+d), (0, 255, 0), 2)\n\ncv2.imshow(""After NMS"", img)\n\ncv2.waitKey(0)\n\n# save output\ncv2.imwrite(""../output.jpg"", img)\n\n\n'"
