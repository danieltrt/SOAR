file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n\nimport io\nimport re\nfrom glob import glob\nfrom os.path import basename\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import splitext\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\ndef read(*names, **kwargs):\n    return io.open(\n        join(dirname(__file__), *names),\n        encoding=kwargs.get(\'encoding\', \'utf8\')\n    ).read()\n\n\nsetup(\n    name=\'twelve-tone\',\n    version=\'0.4.1\',\n    license=\'BSD\',\n    description=\'Twelve-tone matrix to generate dodecaphonic melodies\',\n    long_description=\'%s\\n%s\' % (\n        re.compile(\'^.. start-badges.*^.. end-badges\', re.M | re.S).sub(\'\', read(\'README.rst\')),\n        re.sub(\':[a-z]+:`~?(.*?)`\', r\'``\\1``\', read(\'CHANGELOG.rst\'))\n    ),\n    author=\'Andy Craze\',\n    author_email=\'accraze@gmail.com\',\n    url=\'https://github.com/accraze/python-twelve-tone\',\n    packages=find_packages(\'src\'),\n    package_dir={\'\': \'src\'},\n    py_modules=[splitext(basename(path))[0] for path in glob(\'src/*.py\')],\n    include_package_data=True,\n    zip_safe=False,\n    classifiers=[\n        # complete classifier list: http://pypi.python.org/pypi?%3Aaction=list_classifiers\n        \'Development Status :: 5 - Production/Stable\',\n        \'Intended Audience :: Developers\',\n        \'License :: OSI Approved :: BSD License\',\n        \'Operating System :: Unix\',\n        \'Operating System :: POSIX\',\n        \'Operating System :: Microsoft :: Windows\',\n        \'Programming Language :: Python\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: 3.3\',\n        \'Programming Language :: Python :: 3.4\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Topic :: Utilities\',\n    ],\n    keywords=[\n        \'music\', \'composition\', \'matrix\', \'atonal\', \'midi\'\n    ],\n    install_requires=[\n        \'click\',\n        \'numpy\',\n        \'miditime\'\n    ],\n    extras_require={\n        # eg:\n        #   \'rst\': [\'docutils>=0.11\'],\n        #   \':python_version==""2.6""\': [\'argparse\'],\n    },\n    entry_points={\n        \'console_scripts\': [\n            \'twelve-tone = twelve_tone.cli:main\',\n        ]\n    },\n)\n'"
ci/appveyor-bootstrap.py,0,"b'""""""\nAppVeyor will at least have few Pythons around so there\'s no point of implementing a bootstrapper in PowerShell.\n\nThis is a port of https://github.com/pypa/python-packaging-user-guide/blob/master/source/code/install.ps1\nwith various fixes and improvements that just weren\'t feasible to implement in PowerShell.\n""""""\nfrom __future__ import print_function\n\nfrom os import environ\nfrom os.path import exists\nfrom subprocess import CalledProcessError\nfrom subprocess import check_call\n\ntry:\n    from urllib.request import urlretrieve\nexcept ImportError:\n    from urllib import urlretrieve\n\nBASE_URL = ""https://www.python.org/ftp/python/""\nGET_PIP_URL = ""https://bootstrap.pypa.io/get-pip.py""\nGET_PIP_PATH = ""C:\\get-pip.py""\nURLS = {\n    (""2.7"", ""64""): BASE_URL + ""2.7.10/python-2.7.10.amd64.msi"",\n    (""2.7"", ""32""): BASE_URL + ""2.7.10/python-2.7.10.msi"",\n    # NOTE: no .msi installer for 3.3.6\n    (""3.3"", ""64""): BASE_URL + ""3.3.3/python-3.3.3.amd64.msi"",\n    (""3.3"", ""32""): BASE_URL + ""3.3.3/python-3.3.3.msi"",\n    (""3.4"", ""64""): BASE_URL + ""3.4.3/python-3.4.3.amd64.msi"",\n    (""3.4"", ""32""): BASE_URL + ""3.4.3/python-3.4.3.msi"",\n    (""3.5"", ""64""): BASE_URL + ""3.5.0/python-3.5.0-amd64.exe"",\n    (""3.5"", ""32""): BASE_URL + ""3.5.0/python-3.5.0.exe"",\n}\nINSTALL_CMD = {\n    # Commands are allowed to fail only if they are not the last command.  Eg: uninstall (/x) allowed to fail.\n    ""2.7"": [[""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/x"", ""{path}""],\n            [""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/i"", ""{path}"", ""TARGETDIR={home}""]],\n    ""3.3"": [[""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/x"", ""{path}""],\n            [""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/i"", ""{path}"", ""TARGETDIR={home}""]],\n    ""3.4"": [[""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/x"", ""{path}""],\n            [""msiexec.exe"", ""/L*+!"", ""install.log"", ""/qn"", ""/i"", ""{path}"", ""TARGETDIR={home}""]],\n    ""3.5"": [[""{path}"", ""/quiet"", ""TargetDir={home}""]],\n}\n\n\ndef download_file(url, path):\n    print(""Downloading: {} (into {})"".format(url, path))\n    progress = [0, 0]\n\n    def report(count, size, total):\n        progress[0] = count * size\n        if progress[0] - progress[1] > 1000000:\n            progress[1] = progress[0]\n            print(""Downloaded {:,}/{:,} ..."".format(progress[1], total))\n\n    dest, _ = urlretrieve(url, path, reporthook=report)\n    return dest\n\n\ndef install_python(version, arch, home):\n    print(""Installing Python"", version, ""for"", arch, ""bit architecture to"", home)\n    if exists(home):\n        return\n\n    path = download_python(version, arch)\n    print(""Installing"", path, ""to"", home)\n    success = False\n    for cmd in INSTALL_CMD[version]:\n        cmd = [part.format(home=home, path=path) for part in cmd]\n        print(""Running:"", "" "".join(cmd))\n        try:\n            check_call(cmd)\n        except CalledProcessError as exc:\n            print(""Failed command"", cmd, ""with:"", exc)\n            if exists(""install.log""):\n                with open(""install.log"") as fh:\n                    print(fh.read())\n        else:\n            success = True\n    if success:\n        print(""Installation complete!"")\n    else:\n        print(""Installation failed"")\n\n\ndef download_python(version, arch):\n    for _ in range(3):\n        try:\n            return download_file(URLS[version, arch], ""installer.exe"")\n        except Exception as exc:\n            print(""Failed to download:"", exc)\n        print(""Retrying ..."")\n\n\ndef install_pip(home):\n    pip_path = home + ""/Scripts/pip.exe""\n    python_path = home + ""/python.exe""\n    if exists(pip_path):\n        print(""pip already installed."")\n    else:\n        print(""Installing pip..."")\n        download_file(GET_PIP_URL, GET_PIP_PATH)\n        print(""Executing:"", python_path, GET_PIP_PATH)\n        check_call([python_path, GET_PIP_PATH])\n\n\ndef install_packages(home, *packages):\n    cmd = [home + ""/Scripts/pip.exe"", ""install""]\n    cmd.extend(packages)\n    check_call(cmd)\n\n\nif __name__ == ""__main__"":\n    install_python(environ[\'PYTHON_VERSION\'], environ[\'PYTHON_ARCH\'], environ[\'PYTHON_HOME\'])\n    install_pip(environ[\'PYTHON_HOME\'])\n    install_packages(environ[\'PYTHON_HOME\'], ""setuptools>=18.0.1"", ""wheel"", ""tox"", ""virtualenv>=13.1.0"")\n'"
ci/appveyor-download.py,0,"b'#!/usr/bin/env python\n""""""\nUse the AppVeyor API to download Windows artifacts.\n\nTaken from: https://bitbucket.org/ned/coveragepy/src/tip/ci/download_appveyor.py\n# Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0\n# For details: https://bitbucket.org/ned/coveragepy/src/default/NOTICE.txt\n""""""\nfrom __future__ import unicode_literals\n\nimport argparse\nimport os\nimport zipfile\n\nimport requests\n\n\ndef make_auth_headers():\n    """"""Make the authentication headers needed to use the Appveyor API.""""""\n    path = os.path.expanduser(""~/.appveyor.token"")\n    if not os.path.exists(path):\n        raise RuntimeError(\n            ""Please create a file named `.appveyor.token` in your home directory. ""\n            ""You can get the token from https://ci.appveyor.com/api-token""\n        )\n    with open(path) as f:\n        token = f.read().strip()\n\n    headers = {\n        \'Authorization\': \'Bearer {}\'.format(token),\n    }\n    return headers\n\n\ndef download_latest_artifacts(account_project, build_id):\n    """"""Download all the artifacts from the latest build.""""""\n    if build_id is None:\n        url = ""https://ci.appveyor.com/api/projects/{}"".format(account_project)\n    else:\n        url = ""https://ci.appveyor.com/api/projects/{}/build/{}"".format(account_project, build_id)\n    build = requests.get(url, headers=make_auth_headers()).json()\n    jobs = build[\'build\'][\'jobs\']\n    print(u""Build {0[build][version]}, {1} jobs: {0[build][message]}"".format(build, len(jobs)))\n\n    for job in jobs:\n        name = job[\'name\']\n        print(u""  {0}: {1[status]}, {1[artifactsCount]} artifacts"".format(name, job))\n\n        url = ""https://ci.appveyor.com/api/buildjobs/{}/artifacts"".format(job[\'jobId\'])\n        response = requests.get(url, headers=make_auth_headers())\n        artifacts = response.json()\n\n        for artifact in artifacts:\n            is_zip = artifact[\'type\'] == ""Zip""\n            filename = artifact[\'fileName\']\n            print(u""    {0}, {1} bytes"".format(filename, artifact[\'size\']))\n\n            url = ""https://ci.appveyor.com/api/buildjobs/{}/artifacts/{}"".format(job[\'jobId\'], filename)\n            download_url(url, filename, make_auth_headers())\n\n            if is_zip:\n                unpack_zipfile(filename)\n                os.remove(filename)\n\n\ndef ensure_dirs(filename):\n    """"""Make sure the directories exist for `filename`.""""""\n    dirname = os.path.dirname(filename)\n    if dirname and not os.path.exists(dirname):\n        os.makedirs(dirname)\n\n\ndef download_url(url, filename, headers):\n    """"""Download a file from `url` to `filename`.""""""\n    ensure_dirs(filename)\n    response = requests.get(url, headers=headers, stream=True)\n    if response.status_code == 200:\n        with open(filename, \'wb\') as f:\n            for chunk in response.iter_content(16 * 1024):\n                f.write(chunk)\n    else:\n        print(u""    Error downloading {}: {}"".format(url, response))\n\n\ndef unpack_zipfile(filename):\n    """"""Unpack a zipfile, using the names in the zip.""""""\n    with open(filename, \'rb\') as fzip:\n        z = zipfile.ZipFile(fzip)\n        for name in z.namelist():\n            print(u""      extracting {}"".format(name))\n            ensure_dirs(name)\n            z.extract(name)\n\n\nparser = argparse.ArgumentParser(description=\'Download artifacts from AppVeyor.\')\nparser.add_argument(\'--id\',\n                    metavar=\'PROJECT_ID\',\n                    default=\'accraze/python-twelve-tone\',\n                    help=\'Project ID in AppVeyor.\')\nparser.add_argument(\'build\',\n                    nargs=\'?\',\n                    metavar=\'BUILD_ID\',\n                    help=\'Build ID in AppVeyor. Eg: master-123\')\n\nif __name__ == ""__main__"":\n    # import logging\n    # logging.basicConfig(level=""DEBUG"")\n    args = parser.parse_args()\n    download_latest_artifacts(args.id, args.build)\n'"
ci/bootstrap.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nimport os\nimport sys\nfrom os.path import abspath\nfrom os.path import dirname\nfrom os.path import exists\nfrom os.path import join\n\n\nif __name__ == ""__main__"":\n    base_path = dirname(dirname(abspath(__file__)))\n    print(""Project path: {0}"".format(base_path))\n    env_path = join(base_path, "".tox"", ""bootstrap"")\n    if sys.platform == ""win32"":\n        bin_path = join(env_path, ""Scripts"")\n    else:\n        bin_path = join(env_path, ""bin"")\n    if not exists(env_path):\n        import subprocess\n\n        print(""Making bootstrap env in: {0} ..."".format(env_path))\n        try:\n            subprocess.check_call([""virtualenv"", env_path])\n        except subprocess.CalledProcessError:\n            subprocess.check_call([sys.executable, ""-m"", ""virtualenv"", env_path])\n        print(""Installing `jinja2` into bootstrap environment..."")\n        subprocess.check_call([join(bin_path, ""pip""), ""install"", ""jinja2""])\n    activate = join(bin_path, ""activate_this.py"")\n    # noinspection PyCompatibility\n    exec(compile(open(activate, ""rb"").read(), activate, ""exec""), dict(__file__=activate))\n\n    import jinja2\n\n    import subprocess\n\n    jinja = jinja2.Environment(\n        loader=jinja2.FileSystemLoader(join(base_path, ""ci"", ""templates"")),\n        trim_blocks=True,\n        lstrip_blocks=True,\n        keep_trailing_newline=True\n    )\n\n    tox_environments = [\n        line.strip()\n        # WARNING: \'tox\' must be installed globally or in the project\'s virtualenv\n        for line in subprocess.check_output([\'tox\', \'--listenvs\'], universal_newlines=True).splitlines()\n    ]\n    tox_environments = [line for line in tox_environments if line not in [\'clean\', \'report\', \'docs\', \'check\']]\n\n    for name in os.listdir(join(""ci"", ""templates"")):\n        with open(join(base_path, name), ""w"") as fh:\n            fh.write(jinja.get_template(name).render(tox_environments=tox_environments))\n        print(""Wrote {}"".format(name))\n    print(""DONE."")\n'"
docs/conf.py,0,"b""# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport os\n\n\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.autosummary',\n    'sphinx.ext.coverage',\n    'sphinx.ext.doctest',\n    'sphinx.ext.extlinks',\n    'sphinx.ext.ifconfig',\n    'sphinx.ext.napoleon',\n    'sphinx.ext.todo',\n    'sphinx.ext.viewcode',\n]\nif os.getenv('SPELLCHECK'):\n    extensions += 'sphinxcontrib.spelling',\n    spelling_show_suggestions = True\n    spelling_lang = 'en_US'\n\nsource_suffix = '.rst'\nmaster_doc = 'index'\nproject = u'Twelve Tone'\nyear = u'2018'\nauthor = u'Andy Craze'\ncopyright = '{0}, {1}'.format(year, author)\nversion = release = u'0.4.1'\n\npygments_style = 'trac'\ntemplates_path = ['.']\nextlinks = {\n    'issue': ('https://github.com/accraze/python-twelve-tone/issues/%s', '#'),\n    'pr': ('https://github.com/accraze/python-twelve-tone/pull/%s', 'PR #'),\n}\n# on_rtd is whether we are on readthedocs.org\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\n\nif not on_rtd:  # only set the theme if we're building docs locally\n    html_theme = 'sphinx_rtd_theme'\n\nhtml_use_smartypants = True\nhtml_last_updated_fmt = '%b %d, %Y'\nhtml_split_index = False\nhtml_sidebars = {\n   '**': ['searchbox.html', 'globaltoc.html', 'sourcelink.html'],\n}\nhtml_short_title = '%s-%s' % (project, version)\n\nnapoleon_use_ivar = True\nnapoleon_use_rtype = False\nnapoleon_use_param = False\n"""
tests/test_composer.py,0,"b""import unittest\n\nfrom twelve_tone.composer import Composer\n\n\nclass TestMatrix(unittest.TestCase):\n\n    def test_get_tone_row(self):\n        m = Composer()\n        m.compose()\n        row = m._get_tone_row(1, None)\n        self.assertEquals(list(row), list(m.matrix[1]))\n        col = m._get_tone_row(0, 1)\n        self.assertEquals(list(col), list(m.matrix[:, 1]))\n\n    def test_top_row(self):\n        m = Composer().compose()\n        # check top row is unique\n        duplicate_val = False\n        if len(m[0]) > len(set(m[0])):\n            duplicate_val = True\n        self.assertFalse(duplicate_val)\n        self.assertEquals(len(m[0]), 12)\n\n    def test_transform_cell(self):\n        negative = -3\n        transformed_num = Composer()._transform_cell(negative)\n        self.assertEqual(transformed_num, 9)\n\n    def test_translate_pitch(self):\n        cell = 3\n        pitch = Composer().get_pitch(cell)\n        self.assertEqual(pitch, 'D')\n\n    def test_master(self):\n        row = [3, 1, 9, 5, 4, 6, 8, 7, 12, 10, 11, 2]\n        m = Composer().compose(top_row=row)\n        self.assertEqual(m[0][0], 3)\n        self.assertEqual(m[11][0], 4)\n        self.assertEqual(m[0][11], 2)\n        self.assertEqual(m[11][11], 3)\n        # check for 3s all the way diagonal\n        for x in range(0, 12):\n            self.assertEqual(m[x][x], 3)\n"""
tests/test_midi.py,0,"b'import os\nimport shutil\nimport unittest\n\nfrom twelve_tone.midi import MIDIFile\n\n\nclass TestMIDIFile(unittest.TestCase):\n\n    def test_init(self):\n        m = MIDIFile()\n        self.assertEquals(m.step_counter, 0)\n        m = MIDIFile(filename=""test.mid"")\n        self.assertEquals(m.filename, \'test.mid\')\n\n    def test_create(self):\n        notes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        path = \'tmp\'\n        os.makedirs(path)\n        os.chdir(path)\n        m = MIDIFile(filename=\'test.mid\')\n        m.create(notes)\n        self.assertTrue(os.path.exists(os.path.join(os.getcwd(), \'test.mid\')))\n        os.chdir(os.pardir)\n        shutil.rmtree(\'tmp\', ignore_errors=True)\n'"
tests/test_twelve_tone.py,0,"b'\nfrom click.testing import CliRunner\n\nfrom twelve_tone.cli import main\n\n\ndef test_main():\n    runner = CliRunner()\n    result = runner.invoke(main, [])\n\n    assert result.exit_code == 0\n'"
src/twelve_tone/__init__.py,0,"b'__version__ = ""0.4.1""\n'"
src/twelve_tone/__main__.py,0,"b'""""""\nEntrypoint module, in case you use `python -mtwelve_tone`.\n\n\nWhy does this file exist, and why __main__? For more info, read:\n\n- https://www.python.org/dev/peps/pep-0338/\n- https://docs.python.org/2/using/cmdline.html#cmdoption-m\n- https://docs.python.org/3/using/cmdline.html#cmdoption-m\n""""""\nfrom twelve_tone.cli import main\n\nif __name__ == ""__main__"":\n    main()\n'"
src/twelve_tone/cli.py,0,"b'""""""\nModule that contains the command line app.\n\nWhy does this file exist, and why not put this in __main__?\n\n  You might be tempted to import things from __main__ later, but that will cause\n  problems: the code will get executed twice:\n\n  - When you run `python -mtwelve_tone` python will execute\n    ``__main__.py`` as a script. That means there won\'t be any\n    ``twelve_tone.__main__`` in ``sys.modules``.\n  - When you import __main__ it will get executed again (as a module) because\n    there\'s no ``twelve_tone.__main__`` in ``sys.modules``.\n\n  Also see (1) from http://click.pocoo.org/5/setuptools/#setuptools-integration\n""""""\nimport click\n\nfrom twelve_tone.composer import Composer\n\n\n@click.command()\n@click.option(\'--row\', \'-r\', default=0, help=\'Row to use as row tone\')\n@click.option(\'--column\', \'-c\', default=0, help=\'Column to use as column tone\')\n@click.option(\'--midi\', \'-m\', help=\'MIDI output file\')\ndef main(row, column, midi):\n    c = Composer()\n    c.compose()\n    if row < 0 or column < 0:\n        click.echo(""Invalid row or column arguments."")\n        exit(1)\n    elif row >= c.matrix.shape[0]:\n        click.echo(""Row number exceeds melody row count."")\n        exit(1)\n    elif column >= c.matrix.shape[1]:\n        click.echo(""Column number exceeds melody column count."")\n        exit(1)\n    click.echo(c.get_melody(row=row, column=column))\n    if midi is not None:\n        c.save_to_midi(filename=midi)\n'"
src/twelve_tone/composer.py,1,"b'import random\n\nimport numpy as np\n\nfrom .midi import MIDIFile  # noqa\n\n\nclass Composer(object):\n    matrix = np.zeros((12, 12), dtype=int)\n\n    def compose(self, top_row=None):\n        # top_row\n        self._load_top_row(top_row)\n        # load first column\n        self._load_first_column()\n        # load rest of matrix\n        self._compute_matrix()\n\n        return self.matrix\n\n    def get_melody(self, row=0, column=None):\n        """"""\n        Returns a tone row that can be used\n        as a 12 tone melody.\n\n        You can specify a specific row or column,\n        otherwise the top most tone row will be returned.\n        """"""\n        melody = []\n        tone_row = self._get_tone_row(row, column)\n\n        for cell in tone_row:\n            melody.append(self.get_pitch(int(cell)))\n        return melody\n\n    def _get_tone_row(self, row, column):\n        if column:\n            return self.matrix[:, column]\n        return self.matrix[row]\n\n    def save_to_midi(self, tone_rows=1, filename=\'example.mid\'):\n        m = MIDIFile(filename=filename)\n        for index in range(0, tone_rows):\n            row = self.matrix[index]\n            m.create(row)\n\n    def get_pitch(self, cell):\n        pitch_map = {\n            \'1\': \'C\',\n            \'2\': \'C# / Db\',\n            \'3\': \'D\',\n            \'4\': \'D# / Eb\',\n            \'5\': \'E\',\n            \'6\': \'F\',\n            \'7\': \'F# / Gb\',\n            \'8\': \'G\',\n            \'9\': \'G# / Ab\',\n            \'10\': \'A\',\n            \'11\': \'A# / Bb\',\n            \'12\': \'B\'\n        }\n\n        return pitch_map.get(str(cell))\n\n    def _load_top_row(self, top_row):\n        row = random.sample(range(1, 13), 12)\n        # load top row of matrix rows\n        for x in range(0, 12):\n            self.matrix[0][x] = top_row[x] if top_row else row[x]\n\n    def _load_first_column(self):\n        # load first column\n        for x in range(0, 11):\n            self._load_col_cell(x)\n\n    def _load_col_cell(self, x):\n        diff = (self.matrix[0][x + 1] - self.matrix[0][x])\n        opposite = diff * -1\n        result = opposite + self.matrix[x][0]\n        if result in range(1, 13):\n            self.matrix[x + 1][0] = result\n        else:\n            self.matrix[x + 1][0] = self._transform_cell(result)\n\n    def _compute_matrix(self):\n        for x in range(1, 12):\n            for y in range(0, 11):\n                calc = (self.matrix[x][y] - self.matrix[x - 1][y]) \\\n                    + self.matrix[x - 1][y + 1]\n                if calc not in range(1, 13):\n                    calc = self._transform_cell(calc)\n                self.matrix[x][y + 1] = calc\n\n    def _transform_cell(self, cell):\n        if cell in range(1, 13):\n            return cell\n        if cell < 0 or cell == 0:\n            return self._transform_cell(cell + 12)\n        else:\n            return self._transform_cell(cell - 12)\n'"
src/twelve_tone/midi.py,0,"b""from miditime.miditime import MIDITime\n\n\nclass MIDIFile(object):\n\n    def __init__(self, BPM=120, filename='example.mid'):\n        self.pattern = MIDITime(BPM, filename)\n        self.step_counter = 0\n        self.filename = filename\n\n    def create(self, notes):\n        midinotes = []\n        offset = 60\n        attack = 200\n        beats = 1\n        for note in notes:\n            pitch = (note - 1) + offset\n            midinote = [self.step_counter, pitch, attack, beats]\n            midinotes.append(midinote)\n            self.step_counter = self.step_counter + 1\n\n        # Add a track with those notes\n        self.pattern.add_track(midinotes)\n\n        # Output the .mid file\n        self.pattern.save_midi()\n"""
