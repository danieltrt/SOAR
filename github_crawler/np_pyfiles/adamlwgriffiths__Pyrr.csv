file_path,api_count,code
setup.py,0,"b""#!/usr/bin/env python\n\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\n# get our version but don't import it\n# or we'll need our dependencies already installed\n# https://github.com/todddeluca/happybase/commit/63573cdaefe3a2b98ece87e19d9ceb18f00bc0d9\nwith open('pyrr/version.py', 'r') as f:\n    exec(f.read())\n\nsetup(\n    name='pyrr',\n    version=__version__,\n    description='3D mathematical functions using NumPy',\n    license='BSD',\n    author='Adam Griffiths',\n    url='https://github.com/adamlwgriffiths/Pyrr',\n    install_requires=['numpy', 'multipledispatch'],\n    platforms=['any'],\n    test_suite='tests',\n    packages=['pyrr', 'pyrr.objects'],\n    classifiers=[\n        'Natural Language :: English',\n        'Intended Audience :: Developers',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Programming Language :: Python',\n        'License :: OSI Approved :: BSD License',\n        'Topic :: Multimedia :: Graphics',\n        'Topic :: Scientific/Engineering :: Mathematics',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n)\n"""
pyrr/__init__.py,0,"b""# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\n\n# the version of software\n# this is used by the setup.py script\nfrom .version import __version__\n\n__all__ = [\n    'aabb',\n    'aambb',\n    'euler',\n    'geometric_tests',\n    'geometry',\n    'integer',\n    'line',\n    'matrix33',\n    'matrix44',\n    'plane',\n    'quaternion',\n    'ray',\n    'rectangle',\n    'sphere',\n    'trig',\n    'utils',\n    'vector',\n    'vector3',\n    'vector4',\n    'Matrix33',\n    'Matrix44',\n    'Quaternion',\n    'Vector3',\n    'Vector4',\n]\n\nfrom . import (\n    aabb,\n    aambb,\n    euler,\n    geometric_tests,\n    geometry,\n    integer,\n    line,\n    matrix33,\n    matrix44,\n    plane,\n    quaternion,\n    ray,\n    rectangle,\n    sphere,\n    trig,\n    utils,\n    vector,\n    vector3,\n    vector4,\n)\n\nfrom .objects import (\n    Matrix33,\n    Matrix44,\n    Quaternion,\n    Vector3,\n    Vector4\n)\n\n# because of circular imports, we cannot put these inside each module\n# so insert them here\nsetattr(matrix33, 'Matrix33', Matrix33)\nsetattr(matrix44, 'Matrix44', Matrix44)\nsetattr(quaternion, 'Quaternion', Quaternion)\nsetattr(vector3, 'Vector3', Vector3)\nsetattr(vector4, 'Vector4', Vector4)\n\n"""
pyrr/aabb.py,11,"b'# -*- coding: utf-8 -*-\n""""""Provides functions to calculate and manipulate\nAxis-Aligned Bounding Boxes (AABB).\n\nAABB are a simple 3D rectangle with no orientation.\nIt is up to the user to provide translation.\n\nAn AABB is represented by an array of 2 x 3D vectors.\nThe first vector represents the minimum extent.\nThe second vector represents the maximum extent.\n\nIt should be noted that rotating the object within\nan AABB will invalidate the AABB.\nIt is up to the user to either:\n\n    * recalculate the AABB.\n    * use an AAMBB instead.\n\nTODO: add transform( matrix )\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the minimum vector within the AABB\n    minimum = 0\n\n    #: The index of the maximum vector within the AABB\n    maximum = 1\n\n\ndef create_zeros(dtype=None):\n    return np.zeros((2,3), dtype=dtype)\n\n@parameters_as_numpy_arrays(\'min\', \'max\')\ndef create_from_bounds(min, max, dtype=None):\n    """"""Creates an AABB using the specified minimum\n    and maximum values.\n    """"""\n    dtype = dtype or min.dtype\n    return np.array([min, max], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'points\')\ndef create_from_points(points, dtype=None):\n    """"""Creates an AABB from the list of specified points.\n\n    Points must be a 2D list. Ie::\n        numpy.array([\n            [ x, y, z ],\n            [ x, y, z ],\n            ])\n    """"""\n    dtype = dtype or points.dtype\n    return np.array(\n        [\n            np.amin(points, axis=0),\n            np.amax(points, axis=0)\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'aabbs\')\ndef create_from_aabbs(aabbs, dtype=None):\n    """"""Creates an AABB from a list of existing AABBs.\n\n    AABBs must be a 2D list. Ie::\n        numpy.array([\n            AABB,\n            AABB,\n            ])\n    """"""\n    dtype = dtype or aabbs.dtype\n    # reshape the AABBs as a series of points\n    points = aabbs.reshape((-1, 3))\n\n    return create_from_points(points, dtype)\n\n@parameters_as_numpy_arrays(\'aabb\')\ndef add_points(aabb, points):\n    """"""Extends an AABB to encompass a list\n    of points.\n    """"""\n    # find the minimum and maximum point values\n    minimum = np.amin(points, axis=0)\n    maximum = np.amax(points, axis=0)\n\n    # compare to existing AABB\n    return np.array(\n        [\n            np.minimum(aabb[0], minimum),\n            np.maximum(aabb[1], maximum)\n        ],\n        dtype=aabb.dtype\n    )\n\n@parameters_as_numpy_arrays( \'aabbs\' )\ndef add_aabbs(aabb, aabbs):\n    """"""Extend an AABB to encompass a list\n    of other AABBs.\n    """"""\n    # convert to points and use our existing add_points\n    # function\n    points = aabbs.reshape((-1, 3))\n\n    return add_points(aabb, points)\n\n@all_parameters_as_numpy_arrays\ndef centre_point(aabb):\n    """"""Returns the centre point of the AABB.\n    """"""\n    return (aabb[0] + aabb[1]) * 0.5\n\n@all_parameters_as_numpy_arrays\ndef minimum(aabb):\n    """"""Returns the minimum point of the AABB.\n    """"""\n    return aabb[0].copy()\n\n@all_parameters_as_numpy_arrays\ndef maximum(aabb):\n    """""" Returns the maximum point of the AABB.\n    """"""\n    return aabb[1].copy()\n\n@all_parameters_as_numpy_arrays\ndef clamp_points(aabb, points):\n    """"""Takes a list of points and modifies them to\n    fit within the AABB.\n    """"""\n    return np.clip(points, a_min=aabb[0], a_max=aabb[1])\n\n'"
pyrr/aambb.py,11,"b'# -*- coding: utf-8 -*-\n""""""Provides functions to calculate and manipulate\nAxis-Aligned Minimum Bounding Boxes (AAMBB).\n\nAAMBB are a simple 3D rectangle with no orientation.\nIt is up to the user to provide translation.\nAAMBB differ from AABB in that they allow for the\ncontent to rotate freely and still be within the AAMBB.\n\nAn AAMBB is represented in the same way an AABB is;\na array of 2 x 3D vectors.\nThe first vector represents the minimum extent.\nThe second vector represents the maximum extent.\n\nNote that because the AAMBB set\'s it\'s dimensions using\nthe vector length of any points set within it, the user\nshould be careful to avoid adding the AAMBB to itself\nor the AAMBB will continue to grow.\n\nTODO: add transform( matrix )\nTODO: add point_within_aabb\nTODO: use point_within_aabb for unit tests\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import aabb, vector\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the minimum vector within the AAMBB\n    minimum = 0\n\n    #: The index of the minimum vector within the AAMBB\n    maximum = 1\n\n\ndef create_zeros(dtype=None):\n    return np.zeros((2,3), dtype=dtype)\n\n@parameters_as_numpy_arrays(\'min\', \'max\')\ndef create_from_bounds(min, max, dtype=None):\n    """"""Creates an AAMBB using the specified minimum\n    and maximum values.\n    """"""\n    dtype = dtype or min.dtype\n    # stack our bounds together and add them as points\n    points = np.vstack((min, max))\n    return create_from_points(points, dtype)\n\n@parameters_as_numpy_arrays(\'points\')\ndef create_from_points(points, dtype=None):\n    """"""Creates an AAMBB from the list of specified points.\n\n    Points must be a 2D list. Ie::\n        numpy.array([\n            [ x, y, z ],\n            [ x, y, z ],\n            ])\n    """"""\n    dtype = dtype or points.dtype\n\n    # convert any negative values to positive\n    abs_points = np.absolute(points)\n\n    # find the length of this vector\n    length = np.amax(vector.length(abs_points))\n\n    # our AAMBB extends from +length to -length\n    # in all directions\n    return np.array(\n        [\n            [-length,-length,-length ],\n            [ length, length, length ]\n        ],\n        dtype=dtype\n    )\n\ndef create_from_aabbs(aabbs, dtype=None):\n    """"""Creates an AAMBB from a list of existing AABBs.\n\n    AABBs must be a 2D list. Ie::\n        numpy.array([\n            AABB,\n            AABB,\n            ])\n    """"""\n\n    aabbs = np.asarray(aabbs)\n\n    dtype = dtype or aabbs.dtype\n    # reshape the AABBs as a series of points\n    points = aabbs.reshape((-1, 3))\n\n    return create_from_points(points, dtype=dtype)\n\n@parameters_as_numpy_arrays(\'bb\')\ndef add_points(bb, points):\n    """"""Extends an AAMBB to encompass a list\n    of points.\n\n    It should be noted that this ensures that\n    the encompassed points can rotate freely.\n    Calling this using the min / max points from\n    the AAMBB will create an even bigger AAMBB.\n    """"""\n    # add our AABB to the list of points\n    values = np.vstack((points, bb[0], bb[1]))\n\n    # convert any negative values to positive\n    abs_points = np.absolute(values)\n\n    # extract the maximum extent as a vector\n    #vec = np.amax(abs_points, axis=0)\n\n    # find the length of this vector\n    #length = vector.length(vec)\n    length = np.amax(vector.length(abs_points))\n\n    # our AAMBB extends from +length to -length\n    # in all directions\n    return np.array(\n        [\n            [-length,-length,-length ],\n            [ length, length, length ]\n        ],\n        dtype=bb.dtype\n    )\n\n@parameters_as_numpy_arrays(\'bbs\')\ndef add_aabbs(bb, bbs):\n    """"""Extend an AAMBB to encompass a list\n    of other AABBs or AAMBBs.\n\n    It should be noted that this ensures that\n    the encompassed AABBs can rotate freely.\n    Using the AAMBB itself in this calculation\n    will create an event bigger AAMBB.\n    """"""\n    # reshape the AABBs as a series of points\n    points = bbs.reshape((-1, 3))\n\n    # use the add_points\n    return add_points(bb, points)\n\ndef centre_point(bb):\n    """"""Returns the centre point of the AABB.\n    This should always be [0.0, 0.0, 0.0]\n    """"""\n    return aabb.centre_point(bb)\n\ndef minimum(bb):\n    """"""Returns the minimum point of the AABB.\n    """"""\n    return aabb.minimum(bb)\n\ndef maximum(bb):\n    """"""Returns the maximum point of the AABB.\n    """"""\n    return aabb.maximum(bb)\n\ndef clamp_points(bb, points):\n    """"""Takes a list of points and modifies them to\n    fit within the AABB.\n    """"""\n    # use the same function as present in AABB\n    aabb.clamp_points(bb, points)\n\n'"
pyrr/euler.py,4,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of Euler angles.\n\nEulers represent 3 rotations: Pitch, Roll and Yaw.\n\nEulers are represented using a numpy.array of shape (3,).\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\n\n\nclass index:\n    """"""Defines the indices used to store the Euler values in the numpy array.\n    """"""\n    #: The index of the roll value within the euler.\n    roll = 0\n\n    #: The index of the pitch value within the euler.\n    pitch = 1\n\n    #: The index of the yaw value within the euler.\n    yaw = 2\n\n\ndef create(roll=0., pitch=0., yaw=0., dtype=None):\n    """"""Creates an array storing the specified euler angles.\n\n    Input values are in radians.\n\n    :param float pitch: The pitch in radians.\n    :param float roll: The roll in radians.\n    :param float yaw: The yaw in radians.\n    :rtype: numpy.array\n    """"""\n    return np.array((roll, pitch, yaw), dtype=dtype)\n\n\ndef create_from_x_rotation(theta, dtype=None):\n    return np.array([theta, 0., 0.], dtype=dtype)\n\n\ndef create_from_y_rotation(theta, dtype=None):\n    return np.array([0., theta, 0.], dtype=dtype)\n\n\ndef create_from_z_rotation(theta, dtype=None):\n    return np.array([0., 0., theta], dtype=dtype)\n\n\ndef roll(eulers):\n    """"""Extracts the roll value from the euler.\n\n    :rtype: float.\n    """"""\n    return eulers[0]\n\n\ndef yaw(eulers):\n    """"""Extracts the yaw value from the euler.\n\n    :rtype: float.\n    """"""\n    return eulers[2]\n\n\ndef pitch(eulers):\n    """"""Extracts the pitch value from the euler.\n\n    :rtype: float.\n    """"""\n    return eulers[1]\n'"
pyrr/geometric_tests.py,11,"b'# -*- coding: utf-8 -*-\n""""""Defines a number of functions to test interactions between\nvarious forms data types.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport math\nimport numpy as np\nfrom . import rectangle, vector, vector3, plane\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays, solve_quadratic_equation\n\n""""""\nTODO: line_intersect_plane\nTODO: line_segment_intersect_plane\nTODO: ray_intersect_ray\nTODO: line_intersect_line\nTODO: line_segment_intersect_line_segment\n""""""\n\n@all_parameters_as_numpy_arrays\ndef point_intersect_line(point, line):\n    """"""Calculates the intersection point of a point and aline.\n\n    Performed by checking if the cross-product\n    of the point relative to the line is\n    0.\n    """"""\n    rl = line[1] - line[0]\n    rp = point - line[0]\n    cross = vector3.cross(rl, rp)\n\n    # check if the cross product is zero\n    if np.count_nonzero(cross) > 0:\n        return None\n    return point\n\n@all_parameters_as_numpy_arrays\ndef point_intersect_line_segment(point, line):\n    """"""Calculates the intersection point of a point and a line segment.\n\n    Performed by checking if the cross-product\n    of the point relative to the line is\n    0 and if the dot product of the point\n    relative to the line start AND the end\n    point relative to the line start is\n    less than the segment\'s squared length.\n    """"""\n    rl = line[1] - line[0]\n    rp = point - line[0]\n    cross = vector3.cross(rl, rp)\n    dot = vector.dot(rp, rl)\n    squared_length = vector.squared_length(rl)\n\n    if np.count_nonzero(cross) > 0:\n        return None\n\n    if dot < 0.0 or dot > squared_length:\n        return None\n    return point\n\n@all_parameters_as_numpy_arrays\ndef point_intersect_rectangle(point, rect):\n    """"""Calculates the intersection point of a point and a 2D rectangle.\n\n    For 3D points, the Z axis will be ignored.\n\n    :return: Returns True if the point is touching\n    or within the rectangle.\n    """"""\n    left, right, bottom, top = rectangle.bounds(rect)\n    if \\\n        point[0] < left or \\\n        point[0] > right or \\\n        point[1] < bottom or \\\n        point[1] > top:\n        return None\n    return point\n\n@parameters_as_numpy_arrays(\'ray\', \'pl\')\ndef ray_intersect_plane(ray, pl, front_only=False):\n    """"""Calculates the intersection point of a ray and a plane.\n\n    :param numpy.array ray: The ray to test for intersection.\n    :param numpy.array pl: The plane to test for intersection.\n    :param boolean front_only: Specifies if the ray should\n    only hit the front of the plane.\n    Collisions from the rear of the plane will be\n    ignored.\n\n    :return The intersection point, or None\n    if the ray is parallel to the plane.\n    Returns None if the ray intersects the back\n    of the plane and front_only is True.\n    """"""\n    """"""\n    Distance to plane is defined as\n    t = (pd - p0.n) / rd.n\n    where:\n    rd is the ray direction\n    pd is the point on plane . plane normal\n    p0 is the ray position\n    n is the plane normal\n\n    if rd.n == 0, the ray is parallel to the\n    plane.\n    """"""\n    p = plane.position(pl)\n    n = plane.normal(pl)\n    rd_n = vector.dot(ray[1], n)\n\n    if rd_n == 0.0:\n        return None\n\n    if front_only == True:\n        if rd_n >= 0.0:\n            return None\n\n    pd = vector.dot(p, n)\n    p0_n = vector.dot(ray[0], n)\n    t = (pd - p0_n) / rd_n\n    return ray[0] + (ray[1] * t)\n\n@all_parameters_as_numpy_arrays\ndef point_closest_point_on_ray(point, ray):\n    """"""Calculates the point on a ray that is closest to a point.\n\n    :param numpy.array point: The point to check with.\n    :param numpy.array ray: The ray to check against.\n    :rtype: numpy.array\n    :return: The closest point on the ray to the point.\n    """"""\n    """"""\n    t = (p - rp).n\n    cp = rp + (n * t)\n    where\n    p is the point\n    rp is the ray origin\n    n is the ray normal of unit length\n    t is the distance along the ray to the point\n    """"""\n    normalized_n = vector.normalize(ray[1])\n    relative_point = (point - ray[0])\n    t = vector.dot(relative_point, normalized_n)\n    return ray[0] + (normalized_n * t)\n\n@all_parameters_as_numpy_arrays\ndef point_closest_point_on_line(point, line):\n    """"""Calculates the point on the line that is closest to\n    the specified point.\n\n    :param numpy.array point: The point to check with.\n    :param numpy.array line: The line to check against.\n    :rtype: numpy.array\n    :return: The closest point on the line to the point.\n    """"""\n    """"""\n    rl = va->b (relative line)\n    rp = va->p (relative point)\n    u\' = u / |u| (normalize)\n    cp = a + (u\' * (u\'.v))\n    where:\n    a = line start\n    b = line end\n    p = point\n    cp = closest point\n    """"""\n    rl = line[1] - line[0]\n    rp = point - line[0]\n    rl = vector.normalize(rl)\n    dot = vector.dot(rl, rp)\n    return line[0] + (rl * dot)\n\n@all_parameters_as_numpy_arrays\ndef point_closest_point_on_line_segment(point, segment):\n    """"""Calculates the point on the line segment that is closest\n    to the specified point.\n\n    This is similar to point_closest_point_on_line, except this\n    is against the line segment of finite length. Whereas point_closest_point_on_line\n    checks against a line of infinite length.\n\n    :param numpy.array point: The point to check with.\n    :param numpy.array line_segment: The finite line segment to check against.\n    :rtype: numpy.array\n    :return: The closest point on the line segment to the point.\n    """"""\n    # check if the line has any length\n    rl = segment[1] - segment[0]\n    squared_length = vector.squared_length(rl)\n    if squared_length == 0.0:\n        return segment[0]\n\n    rp = point - segment[0]\n    # check that / squared_length is correct\n    dot = vector.dot(rp, rl) / squared_length;\n\n    if dot < 0.0:\n        return segment[0]\n    elif dot > 1.0:\n        return segment[1]\n\n    # within segment\n    # perform the same calculation as closest_point_on_line\n    return segment[0] + (rl * dot)\n\n@all_parameters_as_numpy_arrays\ndef vector_parallel_vector(v1, v2):\n    """"""Checks if two vectors are parallel.\n\n    :param numpy.array v1, v2: The vectors to check.\n    :rtype: boolean\n    :return: Returns True if the two vectors are parallel.\n    """"""\n    # we cross product the 2 vectors\n    # if the result is 0, then they are parallel\n    cross = vector3.cross(v1, v2)\n    return 0 == np.count_nonzero(cross)\n\n@all_parameters_as_numpy_arrays\ndef ray_parallel_ray(ray1, ray2):\n    """"""Checks if two rays are parallel.\n\n    :param numpy.array ray1, ray2: The rays to check.\n    :rtype: boolean\n    :return: Returns True if the two rays are parallel.\n    """"""\n    # we use a cross product in-case the ray direction\n    # isn\'t unit length\n    return vector_parallel_vector(ray1[ 1 ], ray2[ 1 ])\n\n@all_parameters_as_numpy_arrays\ndef ray_coincident_ray(ray1, ray2):\n    """"""Check if rays are coincident.\n\n    Rays must not only be parallel to each other, but reside\n    along the same vector.\n\n    :param numpy.array ray1, ray2: The rays to check.\n    :rtype: boolean\n    :return: Returns True if the two rays are co-incident.\n    """"""\n    # ensure the ray\'s directions are the same\n    if ray_parallel_ray(ray1, ray2):\n        # get the delta between the two ray\'s start point\n        delta = ray2[0] - ray1[0]\n\n        # get the cross product of the ray delta and\n        # the direction of the rays\n        cross = vector3.cross(delta, ray2[1])\n\n        # if the cross product is zero, the start of the\n        # second ray is in line with the direction of the\n        # first ray\n        if np.count_nonzero(cross) > 0:\n            return False\n\n        return True\n    return False\n\n@all_parameters_as_numpy_arrays\ndef ray_intersect_aabb(ray, aabb):\n    """"""Calculates the intersection point of a ray and an AABB\n\n    :param numpy.array ray1: The ray to check.\n    :param numpy.array aabb: The Axis-Aligned Bounding Box to check against.\n    :rtype: numpy.array\n    :return: Returns a vector if an intersection occurs.\n        Returns None if no intersection occurs.\n    """"""\n    """"""\n    http://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\n    """"""\n    # this is basically ""numpy.divide( 1.0, ray[ 1 ] )""\n    # except we\'re trying to avoid a divide by zero warning\n    # so where the ray direction value is 0.0, just use infinity\n    # which is what we want anyway\n    direction = ray[1]\n    dir_fraction = np.empty(3, dtype = ray.dtype)\n    dir_fraction[direction == 0.0] = np.inf\n    dir_fraction[direction != 0.0] = np.divide(1.0, direction[direction != 0.0])\n\n    t1 = (aabb[0,0] - ray[0,0]) * dir_fraction[ 0 ]\n    t2 = (aabb[1,0] - ray[0,0]) * dir_fraction[ 0 ]\n    t3 = (aabb[0,1] - ray[0,1]) * dir_fraction[ 1 ]\n    t4 = (aabb[1,1] - ray[0,1]) * dir_fraction[ 1 ]\n    t5 = (aabb[0,2] - ray[0,2]) * dir_fraction[ 2 ]\n    t6 = (aabb[1,2] - ray[0,2]) * dir_fraction[ 2 ]\n\n\n    tmin = max(min(t1, t2), min(t3, t4), min(t5, t6))\n    tmax = min(max(t1, t2), max(t3, t4), max(t5, t6))\n\n    # if tmax < 0, ray (line) is intersecting AABB\n    # but the whole AABB is behind the ray start\n    if tmax < 0:\n        return None\n\n    # if tmin > tmax, ray doesn\'t intersect AABB\n    if tmin > tmax:\n        return None\n\n    # t is the distance from the ray point\n    # to intersection\n\n    t = min(x for x in [tmin, tmax] if x >= 0)\n    point = ray[0] + (ray[1] * t)\n    return point\n\n@all_parameters_as_numpy_arrays\ndef point_height_above_plane(point, pl):\n    """"""Calculates how high a point is above a plane.\n\n    :param numpy.array point: The point to check.\n    :param numpy.array plane: The plane to check.\n    :rtype: float\n    :return: The height above the plane as a float. The value will be\n        negative if the point is behind the plane.\n    """"""\n    """"""\n    Because we store normalised normal, we can simply\n    use: n . (p - p0)\n    where:\n        n is the plane normal\n        p is the plane position\n        p0 is the point\n    """"""\n    return vector.dot(plane.normal(pl), point - plane.position(pl))\n\n@all_parameters_as_numpy_arrays\ndef point_closest_point_on_plane(point, pl):\n    """"""Calculates the point on a plane that is closest to a point.\n\n    :param numpy.array point: The point to check with.\n    :param numpy.array plane: The infinite plane to check against.\n    :rtype: numpy.array\n    :return: The closest point on the plane to the point.\n    """"""\n    """"""\n    point on plane is defined as:\n    q\' = q + (d - q.n)n\n    where:\n    q\' is the point on the plane\n    q is the point we are checking\n    d is the value of normal dot position\n    n is the plane normal\n    """"""\n    n = plane.normal(pl)\n    p = n * plane.distance(pl)\n    d = np.dot(p, n)\n    qn = np.dot(point, n)\n    return point + (n * (d - qn))\n\n@all_parameters_as_numpy_arrays\ndef sphere_does_intersect_sphere(s1, s2):\n    """"""Checks if two spheres overlap.\n\n    Note: This will return True if the two spheres are\n    touching perfectly but sphere_penetration_sphere\n    will return 0.0 as the touch but don\'t penetrate.\n\n    This is faster than circle_penetrate_amount_circle\n    as it avoids a square root calculation.\n\n    :param numpy.array s1: The first circle.\n    :param numpy.array s2: The second circle.\n    :rtype: boolean\n    :return: Returns True if the circles overlap.\n        Otherwise, returns False.\n    """"""\n    delta = s2[:3] - s1[:3]\n    distance_squared = vector.squared_length(delta)\n\n    radii_squared = math.pow(s1[3] + s2[3], 2.0)\n\n    if distance_squared > radii_squared:\n        return False\n    return True\n\n@all_parameters_as_numpy_arrays\ndef sphere_penetration_sphere(s1, s2):\n    """"""Calculates the distance two spheres have penetrated\n    into one another.\n\n    :param numpy.array s1: The first circle.\n    :param numpy.array s2: The second circle.\n    :rtype: float\n    :return: The total overlap of the two spheres.\n        This is essentially:\n        r1 + r2 - distance\n        Where r1 and r2 are the radii of circle 1 and 2\n        and distance is the length of the vector p2 - p1.\n        Will return 0.0 if the circles do not overlap.\n    """"""\n    delta = s2[:3] - s1[:3]\n    distance = vector.length(delta)\n\n    combined_radii = s1[3] + s2[3]\n    penetration = combined_radii - distance\n\n    if penetration <= 0.0:\n        return 0.0\n    return penetration\n\n@all_parameters_as_numpy_arrays\ndef ray_intersect_sphere(ray, sphere):\n    """""" Returns the intersection points of a ray and a sphere.\n    See: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n    The ray is defined via the following equation O+tD. Where O is the origin point and D is a direction vector.\n    A sphere is defined as |P\xe2\x88\x92C|^2=R2 where P is the origin and C is the center of the sphere.\n    R is the radius of the sphere.\n\n    Args:\n        ray: Ray geometry\n        sphere: Sphere geometry\n\n    Returns:\n        list: Intersection points as 3D vector list\n\n    :param numpy.array ray: Ray parameter.\n    :param numpy.array sphere: Sphere parameter.\n    :rtype: float\n    :return: Intersection points as a list of points.\n    """"""\n    sphere_center = sphere[:3]\n    sphere_radius = sphere[3]\n    ray_origin = ray[0]\n    ray_direction = ray[1]\n\n    a = 1\n    b = 2 * np.dot(ray_direction, (ray_origin - sphere_center))\n    c = np.dot(ray_origin - sphere_center, ray_origin - sphere_center) - sphere_radius * sphere_radius\n\n    t_list = solve_quadratic_equation(a, b, c)\n\n    ret = list()\n    for t in t_list:\n        # We are calculating intersection for ray not line! Use only positive t for ray.\n        if t >= 0:\n            ret.append(ray_origin + ray_direction * t)\n    return ret\n'"
pyrr/geometry.py,31,"b'# -*- coding: utf-8 -*-\n""""""Geometry functions.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\n\n\ndef create_quad(scale=(1.0,1.0), st=False, rgba=False, dtype=\'float32\', type=\'triangles\'):\n    """"""Returns a Quad reading for rendering.\n\n    Output is a tuple of numpy arrays.\n    The first value is the vertex data, the second is the indices.\n\n    The first dimension of the vertex data contains the list of vertices.\n    The second dimension is the vertex data.\n\n    Vertex data is always in the following order::\n\n        [x, y, z, s, t, r, g, b, a]\n\n    ST and RGBA are optional.\n    If ST is dropped but RGBA is included the format will be::\n\n        [x, y, z, r, g, b, a]\n\n    If both ST and RGBA are dropped the format will be::\n\n        [x, y, z]\n\n    RGBA can also be of size 3 (RGB) or 4 (RGBA).\n\n    Output format is as follows::\n\n        numpy.array([\n            # vertex 1\n            [x, y, z, s, t, r, g, b, a],\n            # vertex 2\n            [x, y, z, s, t, r, g, b, a],\n            ...\n            # vertex N\n            [x, y, z, s, t, r, g, b, a],\n        ], dtype = dtype)\n\n\n    :param bool,scalar,list,tuple,numpy.ndarray st: The ST texture co-ordinates.\n\n        Default is False, which means ST will not be included in the array.\n\n        If True is passed, the default ST values will be provided with the bottom-left\n        of the quad being located at ST=(0.0,0.0) and the top-right being located at\n        ST=(1.0,1.0).\n\n        If a 2d list, tuple or numpy array is passed, it must have one of the following\n        shapes::\n\n                (2,2,), (4,2,),\n\n        If the shape is (2,2,), the values are interpreted as the minimum and maximum\n        values for ST.\n\n        For example::\n\n            st=((0.1,0.3),(0.2,0.4))\n\n        S values will be between 0.1 to 0.2.\n        T values will be between 0.3 to 0.4.\n\n        The bottom left will receive the minimum of both, and the top right will receive\n        the maximum.\n\n        If the shape is (4,2,), the values are interpreted as being the actual ST values\n        for the 4 vertices of the Quad.\n\n        The vertices are in counter-clockwise winding order from the top right::\n\n            [top-right, top-left, bottom-left, bottom-right,]\n\n    :param bool,scalar,list,tuple,numpy.ndarray rgba: The RGBA colour.\n\n        Default is False, which means RGBA will not be included in the array.\n\n        If True is passed, the default RGBA values will be provided with all vertices\n        being RGBA=(1.0, 1.0, 1.0, 1.0)\n\n        If a 2d list, tuple or numpy array is passed, it must have one of the following\n        shapes::\n\n            (3,), (4,), (4,3,), (4,4,),\n\n        If the shape is (3,), the values are interpreted as being an RGB value (no alpha)\n        to set on all vertices.\n\n        If the shape is (4,), the values are intepreted the same as the shape (3,) except\n        the alpha value is included.\n\n        If the shape is (4,3,), the values are interpreted as being a colour to set on\n        the 4 vertices of the Quad.\n\n        The vertices are in counter-clockwise winding order from the top right::\n\n            [top-right, top-left, bottom-left, bottom-right]\n\n        If the shape is (4,4,), the values are intepreted the same as the shape (4,3,)\n        except the alpha value is included.\n\n    :param string type: The type of indices to generate.\n\n        Valid values are::\n\n            [\'triangles\', \'triangle_strip\', \'triangle_fan\', \'quads\', \'quad_strip\',]\n\n        If you just want the vertices without any index manipulation, use \'quads\'.\n\n    """"""\n    shape = [4, 3]\n    rgba_offset = 3\n\n    width, height = scale\n    # half the dimensions\n    width /= 2.0\n    height /= 2.0\n\n    vertices = np.array([\n        # top right\n        ( width, height, 0.0,),\n        # top left\n        (-width, height, 0.0,),\n        # bottom left\n        (-width,-height, 0.0,),\n        # bottom right\n        ( width,-height, 0.0,),\n    ], dtype=dtype)\n\n    st_values = None\n    rgba_values = None\n\n    if st:\n        # default st values\n        st_values = np.array([\n            (1.0, 1.0,),\n            (0.0, 1.0,),\n            (0.0, 0.0,),\n            (1.0, 0.0,),\n        ], dtype=dtype)\n\n        if isinstance(st, bool):\n            pass\n        elif isinstance(st, (int, float)):\n            st_values *= st\n        elif isinstance(st, (list, tuple, np.ndarray)):\n            st = np.array(st, dtype=dtype)\n            if st.shape == (2,2,):\n                # min / max\n                st_values *= st[1] - st[0]\n                st_values += st[0]\n            elif st.shape == (4,2,):\n                # st values specified manually\n                st_values[:] = st\n            else:\n                raise ValueError(\'Invalid shape for st\')\n        else:\n            raise ValueError(\'Invalid value for st\')\n\n        shape[-1] += st_values.shape[-1]\n        rgba_offset += st_values.shape[-1]\n\n    if rgba:\n        # default rgba values\n        rgba_values = np.tile(np.array([1.0, 1.0, 1.0, 1.0], dtype=dtype), (4,1,))\n\n        if isinstance(rgba, bool):\n            pass\n        elif isinstance(rgba, (int, float)):\n            # int / float expands to RGBA with all values == value\n            rgba_values *= rgba \n        elif isinstance(rgba, (list, tuple, np.ndarray)):\n            rgba = np.array(rgba, dtype=dtype)\n\n            if rgba.shape == (3,):\n                rgba_values = np.tile(rgba, (4,1,))\n            elif rgba.shape == (4,):\n                rgba_values[:] = rgba\n            elif rgba.shape == (4,3,):\n                rgba_values = rgba\n            elif rgba.shape == (4,4,):\n                rgba_values = rgba\n            else:\n                raise ValueError(\'Invalid shape for rgba\')\n        else:\n            raise ValueError(\'Invalid value for rgba\')\n\n        shape[-1] += rgba_values.shape[-1]\n\n    data = np.empty(shape, dtype=dtype)\n    data[:,:3] = vertices\n    if st_values is not None:\n        data[:,3:5] = st_values\n    if rgba_values is not None:\n        data[:,rgba_offset:] = rgba_values\n\n    if type == \'triangles\':\n        # counter clockwise\n        # top right -> top left -> bottom left\n        # top right -> bottom left -> bottom right\n        indices = np.array([0, 1, 2, 0, 2, 3])\n    elif type == \'triangle_strip\':\n        # verify\n        indices = np.arange(len(data))\n    elif type == \'triangle_fan\':\n        # verify\n        indices = np.arange(len(data))\n    elif type == \'quads\':\n        indices = np.arange(len(data))\n    elif type == \'quad_strip\':\n        indices = np.arange(len(data))\n    else:\n        raise ValueError(\'Unknown type\')\n\n    return data, indices\n\ndef create_cube(scale=(1.0,1.0,1.0), st=False, rgba=False, dtype=\'float32\', type=\'triangles\'):\n    """"""Returns a Cube reading for rendering.\n\n    Output is a tuple of numpy arrays.\n    The first value is the vertex data, the second is the indices.\n\n    The first dimension of the vertex data contains the list of vertices.\n    The second dimension is the vertex data.\n\n    Vertex data is always in the following order::\n\n        [x, y, z, s, t, r, g, b, a]\n\n    ST and RGBA are optional.\n    If ST is dropped but RGBA is included the format will be::\n\n        [x, y, z, r, g, b, a]\n\n    If both ST and RGBA are dropped the format will be::\n\n        [x, y, z]\n\n    RGBA can also be of size 3 (RGB) or 4 (RGBA).\n\n    Output format is as follows::\n\n        numpy.array([\n            # vertex 1\n            [x, y, z, s, t, r, g, b, a],\n            # vertex 2\n            [x, y, z, s, t, r, g, b, a],\n            ...\n            # vertex N\n            [x, y, z, s, t, r, g, b, a],\n        ], dtype = dtype)\n\n    :param bool,scalar,list,tuple,numpy.ndarray st: The ST texture co-ordinates.\n\n        Default is False, which means ST will not be included in the array.\n\n        If True is passed, the default ST values will be provided with the bottom-left\n        of the quad being located at ST=(0.0,0.0) and the top-right being located at\n        ST=(1.0,1.0).\n\n        If a 2d list, tuple or numpy array is passed, it must have one of the following\n        shapes::\n\n            (2,2,), (4,2,), (6,2,),\n\n        If the shape is (2,2,), the values are interpreted as the minimum and maximum\n        values for ST.\n\n        For example::\n\n            st=((0.1,0.3),(0.2,0.4))\n\n        S values will be between 0.1 to 0.2.\n        T values will be between 0.3 to 0.4.\n\n        The bottom left will receive the minimum of both, and the top right will receive\n        the maximum.\n\n        If the shape is (4,2,), the values are interpreted as being the actual ST values\n        for the 4 vertices of each face.\n\n        The vertices are in counter-clockwise winding order from the top right::\n\n            [top-right, top-left, bottom-left, bottom-right,]\n\n        If the shape is (6,2,), the values are interpreted as being the minimum and maximum\n        values for each face of the cube.\n\n        The faces are in the following order::\n\n            [front, right, back, left, top, bottom,]\n\n\n    :param bool,scalar,list,tuple,numpy.ndarray rgba: The RGBA colour.\n\n        Default is False, which means RGBA will not be included in the array.\n\n        If True is passed, the default RGBA values will be provided with all vertices\n        being RGBA=(1.0, 1.0, 1.0, 1.0).\n\n        If a 2d list, tuple or numpy array is passed, it must have one of the following\n        shapes.::\n\n                (3,), (4,), (4,3,), (4,4,), (6,3,), (6,4,), (24,3,), (24,4,),\n\n        If the shape is (3,), the values are interpreted as being an RGB value (no alpha)\n        to set on all vertices.\n\n        If the shape is (4,), the values are intepreted the same as the shape (3,) except\n        the alpha value is included.\n\n        If the shape is (4,3,), the values are interpreted as being a colour to set on\n        the 4 vertices of each face.\n\n        The vertices are in counter-clockwise winding order from the top right::\n\n            [top-right, top-left, bottom-left, bottom-right]\n\n        If the shape is (4,4,), the values are intepreted the same as the shape (4,3,)\n        except the alpha value is included.\n\n        If the shape is (6,3,), the values are interpreted as being one RGB value (no alpha)\n        for each face.\n\n        The faces are in the following order::\n\n            [front, right, back, left, top, bottom,]\n\n        If the shape is (6,4,), the values are interpreted the same as the shape (6,3,) except\n        the alpha value is included.\n\n        If the shape is (24,3,), the values are interpreted as being an RGB value (no alpha)\n        to set on each vertex of each face (4 * 6).\n\n        The faces are in the following order::\n\n            [front, right, back, left, top, bottom,]\n\n        The vertices are in counter-clockwise winding order from the top right::\n\n            [top-right, top-left, bottom-left, bottom-right]\n\n        If the shape is (24,4,), the values are interpreted the same as the shape (24,3,)\n        except the alpha value is included.\n\n\n    :param string type: The type of indices to generate.\n\n        Valid values are::\n\n            [\'triangles\', \'triangle_strip\', \'triangle_fan\', \'quads\', \'quad_strip\',]\n\n        If you just want the vertices without any index manipulation, use \'quads\'.\n    """"""\n\n    shape = [24, 3]\n    rgba_offset = 3\n\n    width, height, depth = scale\n    # half the dimensions\n    width /= 2.0\n    height /= 2.0\n    depth /= 2.0\n\n    vertices = np.array([\n        # front\n        # top right\n        ( width, height, depth,),\n        # top left\n        (-width, height, depth,),\n        # bottom left\n        (-width,-height, depth,),\n        # bottom right\n        ( width,-height, depth,),\n\n        # right\n        # top right\n        ( width, height,-depth),\n        # top left\n        ( width, height, depth),\n        # bottom left\n        ( width,-height, depth),\n        # bottom right\n        ( width,-height,-depth),\n\n        # back\n        # top right\n        (-width, height,-depth),\n        # top left\n        ( width, height,-depth),\n        # bottom left\n        ( width,-height,-depth),\n        # bottom right\n        (-width,-height,-depth),\n\n        # left\n        # top right\n        (-width, height, depth),\n        # top left\n        (-width, height,-depth),\n        # bottom left\n        (-width,-height,-depth),\n        # bottom right\n        (-width,-height, depth),\n\n        # top\n        # top right\n        ( width, height,-depth),\n        # top left\n        (-width, height,-depth),\n        # bottom left\n        (-width, height, depth),\n        # bottom right\n        ( width, height, depth),\n\n        # bottom\n        # top right\n        ( width,-height, depth),\n        # top left\n        (-width,-height, depth),\n        # bottom left\n        (-width,-height,-depth),\n        # bottom right\n        ( width,-height,-depth),\n    ], dtype=dtype)\n\n    st_values = None\n    rgba_values = None\n\n    if st:\n        # default st values\n        st_values = np.tile(\n            np.array([\n                (1.0, 1.0,),\n                (0.0, 1.0,),\n                (0.0, 0.0,),\n                (1.0, 0.0,),\n            ], dtype=dtype),\n            (6,1,)\n        )\n\n        if isinstance(st, bool):\n            pass\n        elif isinstance(st, (int, float)):\n            st_values *= st\n        elif isinstance(st, (list, tuple, np.ndarray)):\n            st = np.array(st, dtype=dtype)\n            if st.shape == (2,2,):\n                # min / max\n                st_values *= st[1] - st[0]\n                st_values += st[0]\n            elif st.shape == (4,2,):\n                # per face st values specified manually\n                st_values[:] = np.tile(st, (6,1,))\n            elif st.shape == (6,2,):\n                # st values specified manually\n                st_values[:] = st\n            else:\n                raise ValueError(\'Invalid shape for st\')\n        else:\n            raise ValueError(\'Invalid value for st\')\n\n        shape[-1] += st_values.shape[-1]\n        rgba_offset += st_values.shape[-1]\n\n    if rgba:\n        # default rgba values\n        rgba_values = np.tile(np.array([1.0, 1.0, 1.0, 1.0], dtype=dtype), (24,1,))\n\n        if isinstance(rgba, bool):\n            pass\n        elif isinstance(rgba, (int, float)):\n            # int / float expands to RGBA with all values == value\n            rgba_values *= rgba \n        elif isinstance(rgba, (list, tuple, np.ndarray)):\n            rgba = np.array(rgba, dtype=dtype)\n\n            if rgba.shape == (3,):\n                rgba_values = np.tile(rgba, (24,1,))\n            elif rgba.shape == (4,):\n                rgba_values[:] = np.tile(rgba, (24,1,))\n            elif rgba.shape == (4,3,):\n                rgba_values = np.tile(rgba, (6,1,))\n            elif rgba.shape == (4,4,):\n                rgba_values = np.tile(rgba, (6,1,))\n            elif rgba.shape == (6,3,):\n                rgba_values = np.repeat(rgba, 4, axis=0)\n            elif rgba.shape == (6,4,):\n                rgba_values = np.repeat(rgba, 4, axis=0)\n            elif rgba.shape == (24,3,):\n                rgba_values = rgba\n            elif rgba.shape == (24,4,):\n                rgba_values = rgba\n            else:\n                raise ValueError(\'Invalid shape for rgba\')\n        else:\n            raise ValueError(\'Invalid value for rgba\')\n\n        shape[-1] += rgba_values.shape[-1]\n\n    data = np.empty(shape, dtype=dtype)\n    data[:,:3] = vertices\n    if st_values is not None:\n        data[:,3:5] = st_values\n    if rgba_values is not None:\n        data[:,rgba_offset:] = rgba_values\n\n    if type == \'triangles\':\n        # counter clockwise\n        # top right -> top left -> bottom left\n        # top right -> bottom left -> bottom right\n        indices = np.tile(np.array([0, 1, 2, 0, 2, 3], dtype=\'int\'), (6,1))\n        for face in range(6):\n            indices[face] += (face * 4)\n        indices.shape = (-1,)\n    elif type == \'triangle_strip\':\n        raise NotImplementedError\n    elif type == \'triangle_fan\':\n        raise NotImplementedError\n    elif type == \'quads\':\n        raise NotImplementedError\n    elif type == \'quad_strip\':\n        raise NotImplementedError\n    else:\n        raise ValueError(\'Unknown type\')\n\n    return data, indices\n'"
pyrr/integer.py,0,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the manipulation of integers.\n""""""\n\ndef count_bits(value):\n    """"""Counts the number of bits set to 1 in an integer.\n\n    For example::\n\n        >>> count_bits(0b101111)\n        5\n        >>> count_bits(0xf)\n        4\n        >>> count_bits(8)\n        1\n        >>> count_bits(3)\n        2\n    \n    :param int value: An integer.\n    :rtype: integer\n    :return: The count of bits set to 1.\n\n    .. seealso:: http://wiki.python.org/moin/BitManipulation\n    """"""\n    count = 0\n    while (value):\n        count += (value & 1)\n        value >>= 1\n    \n    return count\n\n'"
pyrr/line.py,3,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of Lines.\n\nA Line data structure is simply a numpy.array with 2 vectors::\n\n    start = numpy.array( [ -1.0, 0.0, 0.0 ] )\n    end = numpy.array( [ 1.0, 0.0, 0.0 ] )\n    line = numpy.array( [ start, end ] )\n\nBoth Lines and Line Segments are defined using the same data structure.\nThe only difference is how the data is interpreted.\n\nA line is defined by two points but extends infinitely.\n\nA line segment only exists between two points.\nIt does not extend forever.\n\nThe choice to interprete a line as a line or line segment is up to the\nfunction being called. Check the function signature of documentation\nto determine how a line will be interpreted.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the start vector within the line\n    start = 0\n\n    #: The index of the end vector within the line\n    end = 1\n\n\ndef create_zeros(dtype=None):\n    """"""Creates a line with the start and end at the origin.\n\n    :rtype: numpy.array\n    :return: A line with both start and end points at (0,0,0).\n    """"""\n    return np.zeros((2,3), dtype=dtype)\n\ndef create_from_points(v1, v2, dtype=None):\n    """"""Creates a line from 2 vectors.\n\n    The 2 vectors represent the start and end point of the line.\n\n    :param numpy.array v1: Start point.\n    :param numpy.array v2: End point.\n    :rtype: numpy.array\n    :return: A line extending from v1 to v2.\n    """"""\n    return np.array([v1, v2], dtype=dtype)\n\n@all_parameters_as_numpy_arrays\ndef create_from_ray(ray):\n    """"""Converts a ray to a line.\n\n    The line will extend from \'ray origin -> ray origin + ray direction\'.\n\n    :param numpy.array ray: The ray to convert.\n    :rtype: numpy.array\n    :return: A line beginning at the ray start and extending for 1 unit\n        in the direction of the ray.\n    """"""\n    # convert ray relative direction to absolute\n    # position\n    return np.array([ray[0], ray[0] + ray[1]], dtype=ray.dtype)\n\n@all_parameters_as_numpy_arrays\ndef start(line):\n    """"""Extracts the start point of the line.\n\n    :param numpy.array line: The line to extract the start from.\n    :rtype: numpy.array\n    :return: The starting point of the line.\n    """"""\n    return line[0].copy()\n\n@all_parameters_as_numpy_arrays\ndef end(line):\n    """"""Extracts the end point of the line.\n\n    :param numpy.array line: The line to extract the end from.\n    :rtype: numpy.array\n    :return: The ending point of the line.\n    """"""\n    return line[1].copy()\n\n'"
pyrr/matrix33.py,31,"b'# -*- coding: utf-8 -*-\n""""""3x3 Matrix which supports rotation, translation, scale and skew.\n\nMatrices are laid out in row-major format and can be loaded directly\ninto OpenGL.\nTo convert to column-major format, transpose the array using the\nnumpy.array.T method.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import vector, quaternion, euler\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\ndef create_identity(dtype=None):\n    """"""Creates a new matrix33 and sets it to\n    an identity matrix.\n\n    :rtype: numpy.array\n    :return: A matrix representing an identity matrix with shape (3,3).\n    """"""\n    return np.identity(3, dtype=dtype)\n\ndef create_from_matrix44(mat, dtype=None):\n    """"""Creates a Matrix33 from a Matrix44.\n\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3) with the input matrix rotation.\n    """"""\n    mat = np.asarray(mat)\n    return np.array(mat[0:3,0:3], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'eulers\')\ndef create_from_eulers(eulers, dtype=None):\n    """"""Creates a matrix from the specified Euler rotations.\n\n    :param numpy.array eulers: A set of euler rotations in the format\n        specified by the euler modules.\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3) with the euler\'s rotation.\n    """"""\n    dtype = dtype or eulers.dtype\n\n    pitch, roll, yaw = euler.pitch(eulers), euler.roll(eulers), euler.yaw(eulers)\n\n    sP = np.sin(pitch)\n    cP = np.cos(pitch)\n    sR = np.sin(roll)\n    cR = np.cos(roll)\n    sY = np.sin(yaw)\n    cY = np.cos(yaw)\n\n    return np.array(\n        [\n            # m1\n            [\n                cY * cP,\n                -cY * sP * cR + sY * sR,\n                cY * sP * sR + sY * cR,\n            ],\n            # m2\n            [\n                sP,\n                cP * cR,\n                -cP * sR,\n            ],\n            # m3\n            [\n                -sY * cP,\n                sY * sP * cR + cY * sR,\n                -sY * sP * sR + cY * cR,\n            ]\n        ],\n        dtype=dtype\n    )\n\n\n@parameters_as_numpy_arrays(\'axis\')\ndef create_from_axis_rotation(axis, theta, dtype=None):\n    """"""Creates a matrix from the specified theta rotation around an axis.\n\n    :param numpy.array axis: A (3,) vector specifying the axis of rotation.\n    :param float theta: A rotation speicified in radians.\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3).\n    """"""\n    dtype = dtype or axis.dtype\n\n    axis = vector.normalize(axis)\n    x,y,z = axis\n\n    s = np.sin(theta);\n    c = np.cos(theta);\n    t = 1 - c;\n\n    # Construct the elements of the rotation matrix\n    return np.array(\n        [\n            [ x * x * t + c,     y * x * t + z * s, z * x * t - y * s],\n            [ x * y * t - z * s, y * y * t + c,     z * y * t + x * s],\n            [ x * z * t + y * s, y * z * t - x * s, z * z * t + c]\n        ],\n        dtype= dtype\n    )\n\n\n@parameters_as_numpy_arrays(\'quat\')\ndef create_from_quaternion(quat, dtype=None):\n    """"""Creates a matrix with the same rotation as a quaternion.\n\n    :param quat: The quaternion to create the matrix from.\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3) with the quaternion\'s rotation.\n    """"""\n    dtype = dtype or quat.dtype\n\n    # the quaternion must be normalized\n    if not np.isclose(np.linalg.norm(quat), 1.):\n        quat = quaternion.normalize(quat)\n\n    # http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/index.htm\n    qx, qy, qz, qw = quat[0], quat[1], quat[2], quat[3]\n\n    sqw = qw**2\n    sqx = qx**2\n    sqy = qy**2\n    sqz = qz**2\n    qxy = qx * qy\n    qzw = qz * qw\n    qxz = qx * qz\n    qyw = qy * qw\n    qyz = qy * qz\n    qxw = qx * qw\n\n    invs = 1 / (sqx + sqy + sqz + sqw)\n    m00 = ( sqx - sqy - sqz + sqw) * invs\n    m11 = (-sqx + sqy - sqz + sqw) * invs\n    m22 = (-sqx - sqy + sqz + sqw) * invs\n    m10 = 2.0 * (qxy + qzw) * invs\n    m01 = 2.0 * (qxy - qzw) * invs\n    m20 = 2.0 * (qxz - qyw) * invs\n    m02 = 2.0 * (qxz + qyw) * invs\n    m21 = 2.0 * (qyz + qxw) * invs\n    m12 = 2.0 * (qyz - qxw) * invs\n\n    return np.array([\n        [m00, m01, m02],\n        [m10, m11, m12],\n        [m20, m21, m22],\n    ], dtype=dtype)\n\n\n@parameters_as_numpy_arrays(\'quat\')\ndef create_from_inverse_of_quaternion(quat, dtype=None):\n    """"""Creates a matrix with the inverse rotation of a quaternion.\n\n    :param numpy.array quat: The quaternion to make the matrix from (shape 4).\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3) that respresents the inverse of\n        the quaternion.\n    """"""\n    dtype = dtype or quat.dtype\n\n    x, y, z, w = quat\n\n    x2 = x**2\n    y2 = y**2\n    z2 = z**2\n    wx = w * x\n    wy = w * y\n    xy = x * y\n    wz = w * z\n    xz = x * z\n    yz = y * z\n\n    return np.array(\n        [\n            # m1\n            [\n                # m11 = 1.0 - 2.0 * (q.y * q.y + q.z * q.z)\n                1.0 - 2.0 * (y2 + z2),\n                # m21 = 2.0 * (q.x * q.y + q.w * q.z)\n                2.0 * (xy + wz),\n                # m31 = 2.0 * (q.x * q.z - q.w * q.y)\n                2.0 * (xz - wy),\n            ],\n            # m2\n            [\n                # m12 = 2.0 * (q.x * q.y - q.w * q.z)\n                2.0 * (xy - wz),\n                # m22 = 1.0 - 2.0 * (q.x * q.x + q.z * q.z)\n                1.0 - 2.0 * (x2 + z2),\n                # m32 = 2.0 * (q.y * q.z + q.w * q.x)\n                2.0 * (yz + wx),\n            ],\n            # m3\n            [\n                # m13 = 2.0 * ( q.x * q.z + q.w * q.y)\n                2.0 * (xz + wy),\n                # m23 = 2.0 * (q.y * q.z - q.w * q.x)\n                2.0 * (yz - wx),\n                # m33 = 1.0 - 2.0 * (q.x * q.x + q.y * q.y)\n                1.0 - 2.0 * (x2 + y2),\n            ]\n        ],\n        dtype=dtype\n    )\n\ndef create_from_scale(scale, dtype=None):\n    """"""Creates an identity matrix with the scale set.\n\n    :param numpy.array scale: The scale to apply as a vector (shape 3).\n    :rtype: numpy.array\n    :return: A matrix with shape (3,3) with the scale\n        set to the specified vector.\n    """"""\n    # apply the scale to the values diagonally\n    # down the matrix\n    m = np.diagflat(scale)\n    if dtype:\n        m = m.astype(dtype)\n    return m\n\ndef create_from_x_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the X axis.\n\n    :param float theta: The rotation, in radians, about the X-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (3,3) with the specified rotation about\n        the X-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    cosT = np.cos(theta)\n    sinT = np.sin(theta)\n\n    return np.array(\n        [\n            [ 1.0, 0.0, 0.0 ],\n            [ 0.0, cosT,-sinT ],\n            [ 0.0, sinT, cosT ]\n        ],\n        dtype=dtype\n    )\n\ndef create_from_y_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the Y axis.\n\n    :param float theta: The rotation, in radians, about the Y-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (3,3) with the specified rotation about\n        the Y-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    cosT = np.cos(theta)\n    sinT = np.sin(theta)\n\n    return np.array(\n        [\n            [ cosT, 0.0,sinT ],\n            [ 0.0, 1.0, 0.0 ],\n            [-sinT, 0.0, cosT ]\n        ],\n        dtype=dtype\n    )\n\ndef create_from_z_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the Z axis.\n\n    :param float theta: The rotation, in radians, about the Z-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (3,3) with the specified rotation about\n        the Z-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    cosT = np.cos(theta)\n    sinT = np.sin(theta)\n\n    return np.array(\n        [\n            [ cosT,-sinT, 0.0 ],\n            [ sinT, cosT, 0.0 ],\n            [ 0.0, 0.0, 1.0 ]\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'vec\')\ndef apply_to_vector(mat, vec):\n    """"""Apply a matrix to a vector.\n\n    The matrix\'s rotation are applied to the vector.\n    Supports multiple matrices and vectors.\n\n    :param numpy.array mat: The rotation / translation matrix.\n        Can be a list of matrices.\n    :param numpy.array vec: The vector to modify.\n        Can be a list of vectors.\n    :rtype: numpy.array\n    :return: The vectors rotated by the specified matrix.\n    """"""\n    if vec.size == 3:\n        return np.dot(vec, mat)\n    else:\n        raise ValueError(""Vector size unsupported"")\n\ndef multiply(m1, m2):\n    """"""Multiply two matricies, m1 . m2.\n\n    This is essentially a wrapper around\n    numpy.dot( m1, m2 )\n\n    :param numpy.array m1: The first matrix.\n        Can be a list of matrices.\n    :param numpy.array m2: The second matrix.\n        Can be a list of matrices.\n    :rtype: numpy.array\n    :return: A matrix that results from multiplying m1 by m2.\n    """"""\n    return np.dot(m1, m2)\n\ndef inverse(mat):\n    """"""Returns the inverse of the matrix.\n\n    This is essentially a wrapper around numpy.linalg.inv.\n\n    :param numpy.array m: A matrix.\n    :rtype: numpy.array\n    :return: The inverse of the specified matrix.\n\n    .. seealso:: http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html\n    """"""\n    return np.linalg.inv(mat)\n\ndef create_direction_scale(direction, scale):\n    """"""Creates a matrix which can apply a directional scaling to a set of vectors.\n\n    An example usage for this is to flatten a mesh against a\n    single plane.\n\n    :param numpy.array direction: a numpy.array of shape (3,) of the direction to scale.\n    :param float scale: a float value for the scaling along the specified direction.\n        A scale of 0.0 will flatten the vertices into a single plane with the direction being the\n        plane\'s normal.\n    :rtype: numpy.array\n    :return: The scaling matrix.\n    """"""\n    """"""\n    scaling is defined as:\n\n    [p\'][1 + (k - 1)n.x^2, (k - 1)n.x n.y^2, (k - 1)n.x n.z   ]\n    S(n,k) = [q\'][(k - 1)n.x n.y,   1 + (k - 1)n.y,   (k - 1)n.y n.z   ]\n    [r\'][(k - 1)n.x n.z,   (k - 1)n.y n.z,   1 + (k - 1)n.z^2 ]\n\n    where:\n    v\' is the resulting vector after scaling\n    v is the vector to scale\n    n is the direction of the scaling\n    n.x is the x component of n\n    n.y is the y component of n\n    n.z is the z component of n\n    k is the scaling factor\n    """"""\n    if not np.isclose(np.linalg.norm(direction), 1.):\n        direction = vector.normalize(direction)\n\n    x,y,z = direction\n\n    x2 = x**2.\n    y2 = y**2.\n    z2 = z**2\n\n    scaleMinus1 = scale - 1.\n    return np.array(\n        [\n            # m1\n            [\n                # m11 = 1 + (k - 1)n.x^2\n                1. + scaleMinus1 * x2,\n                # m12 = (k - 1)n.x n.y^2\n                scaleMinus1 * x * y2,\n                # m13 = (k - 1)n.x n.z\n                scaleMinus1 * x * z\n            ],\n            # m2\n            [\n                # m21 = (k - 1)n.x n.y\n                scaleMinus1 * x * y,\n                # m22 = 1 + (k - 1)n.y\n                1. + scaleMinus1 * y,\n                # m23 = (k - 1)n.y n.z\n                scaleMinus1 * y * z\n            ],\n            # m3\n            [\n                # m31 = (k - 1)n.x n.z\n                scaleMinus1 * x * z,\n                # m32 = (k - 1)n.y n.z\n                scaleMinus1 * y * z,\n                # m33 = 1 + (k - 1)n.z^2\n                1. + scaleMinus1 * z2\n            ]\n        ]\n    )\n'"
pyrr/matrix44.py,23,"b'# -*- coding: utf-8 -*-\n""""""4x4 Matrix which supports rotation, translation, scale and skew.\n\nMatrices are laid out in row-major format and can be loaded directly\ninto OpenGL.\nTo convert to column-major format, transpose the array using the\nnumpy.array.T method.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import matrix33\nfrom . import vector\nfrom . import vector3\nfrom . import quaternion\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\ndef create_identity(dtype=None):\n    """"""Creates a new matrix44 and sets it to\n    an identity matrix.\n\n    :rtype: numpy.array\n    :return: A matrix representing an identity matrix with shape (4,4).\n    """"""\n    return np.identity(4, dtype=dtype)\n\ndef create_from_matrix33(mat, dtype=None):\n    """"""Creates a Matrix44 from a Matrix33.\n\n    The translation will be 0,0,0.\n\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) with the input matrix rotation.\n    """"""\n    mat4 = np.identity(4, dtype=dtype)\n    mat4[0:3, 0:3] = mat\n    return mat4\n\ndef create_matrix33_view(mat):\n    """"""Returns a view into the matrix in Matrix33 format.\n\n    This is different from matrix33.create_from_matrix44, in that\n    changes to the returned matrix will also alter the original matrix.\n\n    :rtype: numpy.array\n    :return: A view into the matrix in the format of a matrix33 (shape (3,3)).\n    """"""\n    return mat[0:3, 0:3]\n\n@parameters_as_numpy_arrays(\'eulers\')\ndef create_from_eulers(eulers, dtype=None):\n    """"""Creates a matrix from the specified Euler rotations.\n\n    :param numpy.array eulers: A set of euler rotations in the format\n        specified by the euler modules.\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) with the euler\'s rotation.\n    """"""\n    dtype = dtype or eulers.dtype\n    # set to identity matrix\n    # this will populate our extra rows for us\n    mat = create_identity(dtype)\n\n    # we\'ll use Matrix33 for our conversion\n    mat[0:3, 0:3] = matrix33.create_from_eulers(eulers, dtype)\n    return mat\n\n@parameters_as_numpy_arrays(\'axis\')\ndef create_from_axis_rotation(axis, theta, dtype=None):\n    """"""Creates a matrix from the specified rotation theta around an axis.\n\n    :param numpy.array axis: A (3,) vector.\n    :param float theta: A rotation in radians.\n\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4).\n    """"""\n    dtype = dtype or axis.dtype\n    # set to identity matrix\n    # this will populate our extra rows for us\n    mat = create_identity(dtype)\n\n    # we\'ll use Matrix33 for our conversion\n    mat[0:3, 0:3] = matrix33.create_from_axis_rotation(axis, theta, dtype)\n    return mat\n\n@parameters_as_numpy_arrays(\'quat\')\ndef create_from_quaternion(quat, dtype=None):\n    """"""Creates a matrix with the same rotation as a quaternion.\n\n    :param quat: The quaternion to create the matrix from.\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) with the quaternion\'s rotation.\n    """"""\n    dtype = dtype or quat.dtype\n    # set to identity matrix\n    # this will populate our extra rows for us\n    mat = create_identity(dtype)\n\n    # we\'ll use Matrix33 for our conversion\n    mat[0:3, 0:3] = matrix33.create_from_quaternion(quat, dtype)\n    return mat\n\n@parameters_as_numpy_arrays(\'quat\')\ndef create_from_inverse_of_quaternion(quat, dtype=None):\n    """"""Creates a matrix with the inverse rotation of a quaternion.\n\n    This can be used to go from object space to intertial space.\n\n    :param numpy.array quat: The quaternion to make the matrix from (shape 4).\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) that respresents the inverse of\n        the quaternion.\n    """"""\n    dtype = dtype or quat.dtype\n    # set to identity matrix\n    # this will populate our extra rows for us\n    mat = create_identity(dtype)\n\n    # we\'ll use Matrix33 for our conversion\n    mat[0:3, 0:3] = matrix33.create_from_inverse_of_quaternion(quat, dtype)\n    return mat\n\n@parameters_as_numpy_arrays(\'vec\')\ndef create_from_translation(vec, dtype=None):\n    """"""Creates an identity matrix with the translation set.\n\n    :param numpy.array vec: The translation vector (shape 3 or 4).\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) that represents a matrix\n        with the translation set to the specified vector.\n    """"""\n    dtype = dtype or vec.dtype\n    mat = create_identity(dtype)\n    mat[3, 0:3] = vec[:3]\n    return mat\n\ndef create_from_scale(scale, dtype=None):\n    """"""Creates an identity matrix with the scale set.\n\n    :param numpy.array scale: The scale to apply as a vector (shape 3).\n    :rtype: numpy.array\n    :return: A matrix with shape (4,4) with the scale\n        set to the specified vector.\n    """"""\n    # we need to expand \'scale\' into it\'s components\n    # because numpy isn\'t flattening them properly.\n    m = np.diagflat([scale[0], scale[1], scale[2], 1.0])\n    if dtype:\n        m = m.astype(dtype)\n    return m\n\ndef create_from_x_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the X axis.\n\n    :param float theta: The rotation, in radians, about the X-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (4,4) with the specified rotation about\n        the X-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    mat = create_identity(dtype)\n    mat[0:3, 0:3] = matrix33.create_from_x_rotation(theta, dtype)\n    return mat\n\ndef create_from_y_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the Y axis.\n\n    :param float theta: The rotation, in radians, about the Y-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (4,4) with the specified rotation about\n        the Y-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    mat = create_identity(dtype)\n    mat[0:3, 0:3] = matrix33.create_from_y_rotation(theta, dtype)\n    return mat\n\ndef create_from_z_rotation(theta, dtype=None):\n    """"""Creates a matrix with the specified rotation about the Z axis.\n\n    :param float theta: The rotation, in radians, about the Z-axis.\n    :rtype: numpy.array\n    :return: A matrix with the shape (4,4) with the specified rotation about\n        the Z-axis.\n\n    .. seealso:: http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions\n    """"""\n    mat = create_identity(dtype)\n    mat[0:3, 0:3] = matrix33.create_from_z_rotation(theta, dtype)\n    return mat\n\n@all_parameters_as_numpy_arrays\ndef apply_to_vector(mat, vec):\n    """"""Apply a matrix to a vector.\n\n    The matrix\'s rotation and translation are applied to the vector.\n    Supports multiple matrices and vectors.\n\n    :param numpy.array mat: The rotation / translation matrix.\n        Can be a list of matrices.\n    :param numpy.array vec: The vector to modify.\n        Can be a list of vectors.\n    :rtype: numpy.array\n    :return: The vectors rotated by the specified matrix.\n    """"""\n    if vec.size == 3:\n        # convert to a vec4\n        vec4 = np.array([vec[0], vec[1], vec[2], 1.], dtype=vec.dtype)\n        vec4 = np.dot(vec4, mat)\n        if np.allclose(vec4[3], 0.):\n            vec4[:] = [np.inf, np.inf, np.inf, np.inf]\n        else:\n            vec4 /= vec4[3]\n        return vec4[:3]\n    elif vec.size == 4:\n        return np.dot(vec, mat)\n    else:\n        raise ValueError(""Vector size unsupported"")\n\ndef multiply(m1, m2):\n    """"""Multiply two matricies, m1 . m2.\n\n    This is essentially a wrapper around\n    numpy.dot(m1, m2)\n\n    :param numpy.array m1: The first matrix.\n        Can be a list of matrices.\n    :param numpy.array m2: The second matrix.\n        Can be a list of matrices.\n    :rtype: numpy.array\n    :return: A matrix that results from multiplying m1 by m2.\n    """"""\n    return np.dot(m1, m2)\n\ndef create_perspective_projection(fovy, aspect, near, far, dtype=None):\n    """"""Creates perspective projection matrix.\n\n    .. seealso:: http://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml\n    .. seealso:: http://www.geeks3d.com/20090729/howto-perspective-projection-matrix-in-opengl/\n\n    :param float fovy: field of view in y direction in degrees\n    :param float aspect: aspect ratio of the view (width / height)\n    :param float near: distance from the viewer to the near clipping plane (only positive)\n    :param float far: distance from the viewer to the far clipping plane (only positive)\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified perpective.\n    """"""\n    ymax = near * np.tan(fovy * np.pi / 360.0)\n    xmax = ymax * aspect\n    return create_perspective_projection_from_bounds(-xmax, xmax, -ymax, ymax, near, far, dtype=dtype)\n\ndef create_perspective_projection_matrix(fovy, aspect, near, far, dtype=None):    # TDOO: mark as deprecated\n    """"""Creates perspective projection matrix.\n\n    .. seealso:: http://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml\n    .. seealso:: http://www.geeks3d.com/20090729/howto-perspective-projection-matrix-in-opengl/\n\n    :param float fovy: field of view in y direction in degrees\n    :param float aspect: aspect ratio of the view (width / height)\n    :param float near: distance from the viewer to the near clipping plane (only positive)\n    :param float far: distance from the viewer to the far clipping plane (only positive)\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified perpective.\n    """"""\n    return create_perspective_projection(fovy, aspect, near, far, dtype)\n\ndef create_perspective_projection_from_bounds(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far,\n    dtype=None\n):\n    """"""Creates a perspective projection matrix using the specified near\n    plane dimensions.\n\n    :param float left: The left of the near plane relative to the plane\'s centre.\n    :param float right: The right of the near plane relative to the plane\'s centre.\n    :param float top: The top of the near plane relative to the plane\'s centre.\n    :param float bottom: The bottom of the near plane relative to the plane\'s centre.\n    :param float near: The distance of the near plane from the camera\'s origin.\n        It is recommended that the near plane is set to 1.0 or above to avoid rendering issues\n        at close range.\n    :param float far: The distance of the far plane from the camera\'s origin.\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified perspective.\n\n    .. seealso:: http://www.gamedev.net/topic/264248-building-a-projection-matrix-without-api/\n    .. seealso:: http://www.glprogramming.com/red/chapter03.html\n    """"""\n\n    """"""\n    E 0 A 0\n    0 F B 0\n    0 0 C D\n    0 0-1 0\n\n    A = (right+left)/(right-left)\n    B = (top+bottom)/(top-bottom)\n    C = -(far+near)/(far-near)\n    D = -2*far*near/(far-near)\n    E = 2*near/(right-left)\n    F = 2*near/(top-bottom)\n    """"""\n    A = (right + left) / (right - left)\n    B = (top + bottom) / (top - bottom)\n    C = -(far + near) / (far - near)\n    D = -2. * far * near / (far - near)\n    E = 2. * near / (right - left)\n    F = 2. * near / (top - bottom)\n\n    return np.array((\n        (  E, 0., 0., 0.),\n        ( 0.,  F, 0., 0.),\n        (  A,  B,  C,-1.),\n        ( 0., 0.,  D, 0.),\n    ), dtype=dtype)\n\ndef create_perspective_projection_matrix_from_bounds(\n    left, right, bottom, top, near, far, dtype=None):    # TDOO: mark as deprecated\n    """"""Creates a perspective projection matrix using the specified near\n    plane dimensions.\n\n    :param float left: The left of the near plane relative to the plane\'s centre.\n    :param float right: The right of the near plane relative to the plane\'s centre.\n    :param float top: The top of the near plane relative to the plane\'s centre.\n    :param float bottom: The bottom of the near plane relative to the plane\'s centre.\n    :param float near: The distance of the near plane from the camera\'s origin.\n        It is recommended that the near plane is set to 1.0 or above to avoid rendering issues\n        at close range.\n    :param float far: The distance of the far plane from the camera\'s origin.\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified perspective.\n\n    .. seealso:: http://www.gamedev.net/topic/264248-building-a-projection-matrix-without-api/\n    .. seealso:: http://www.glprogramming.com/red/chapter03.html\n    """"""\n\n    """"""\n    E 0 A 0\n    0 F B 0\n    0 0 C D\n    0 0-1 0\n\n    A = (right+left)/(right-left)\n    B = (top+bottom)/(top-bottom)\n    C = -(far+near)/(far-near)\n    D = -2*far*near/(far-near)\n    E = 2*near/(right-left)\n    F = 2*near/(top-bottom)\n    """"""\n    return create_perspective_projection_from_bounds(\n        left, right, bottom, top, near, far, dtype\n    )\n\ndef create_orthogonal_projection(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far,\n    dtype=None\n):\n    """"""Creates an orthogonal projection matrix.\n\n    :param float left: The left of the near plane relative to the plane\'s centre.\n    :param float right: The right of the near plane relative to the plane\'s centre.\n    :param float top: The top of the near plane relative to the plane\'s centre.\n    :param float bottom: The bottom of the near plane relative to the plane\'s centre.\n    :param float near: The distance of the near plane from the camera\'s origin.\n        It is recommended that the near plane is set to 1.0 or above to avoid rendering issues\n        at close range.\n    :param float far: The distance of the far plane from the camera\'s origin.\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified orthogonal perspective.\n\n    .. seealso:: http://msdn.microsoft.com/en-us/library/dd373965(v=vs.85).aspx\n    """"""\n\n    """"""\n    A 0 0 Tx\n    0 B 0 Ty\n    0 0 C Tz\n    0 0 0 1\n\n    A = 2 / (right - left)\n    B = 2 / (top - bottom)\n    C = -2 / (far - near)\n\n    Tx = (right + left) / (right - left)\n    Ty = (top + bottom) / (top - bottom)\n    Tz = (far + near) / (far - near)\n    """"""\n    rml = right - left\n    tmb = top - bottom\n    fmn = far - near\n\n    A = 2. / rml\n    B = 2. / tmb\n    C = -2. / fmn\n    Tx = -(right + left) / rml\n    Ty = -(top + bottom) / tmb\n    Tz = -(far + near) / fmn\n\n    return np.array((\n        ( A, 0., 0., 0.),\n        (0.,  B, 0., 0.),\n        (0., 0.,  C, 0.),\n        (Tx, Ty, Tz, 1.),\n    ), dtype=dtype)\n\ndef create_orthogonal_projection_matrix(\n    left, right, bottom, top, near, far, dtype=None):    # TDOO: mark as deprecated\n    """"""Creates an orthogonal projection matrix.\n\n    :param float left: The left of the near plane relative to the plane\'s centre.\n    :param float right: The right of the near plane relative to the plane\'s centre.\n    :param float top: The top of the near plane relative to the plane\'s centre.\n    :param float bottom: The bottom of the near plane relative to the plane\'s centre.\n    :param float near: The distance of the near plane from the camera\'s origin.\n        It is recommended that the near plane is set to 1.0 or above to avoid rendering issues\n        at close range.\n    :param float far: The distance of the far plane from the camera\'s origin.\n    :rtype: numpy.array\n    :return: A projection matrix representing the specified orthogonal perspective.\n\n    .. seealso:: http://msdn.microsoft.com/en-us/library/dd373965(v=vs.85).aspx\n    """"""\n\n    """"""\n    A 0 0 Tx\n    0 B 0 Ty\n    0 0 C Tz\n    0 0 0 1\n\n    A = 2 / (right - left)\n    B = 2 / (top - bottom)\n    C = -2 / (far - near)\n\n    Tx = (right + left) / (right - left)\n    Ty = (top + bottom) / (top - bottom)\n    Tz = (far + near) / (far - near)\n    """"""\n    return create_orthogonal_projection(\n        left, right, bottom, top, near, far, dtype\n    )\n\ndef create_look_at(eye, target, up, dtype=None):\n    """"""Creates a look at matrix according to OpenGL standards.\n\n    :param numpy.array eye: Position of the camera in world coordinates.\n    :param numpy.array target: The position in world coordinates that the\n        camera is looking at.\n    :param numpy.array up: The up vector of the camera.\n    :rtype: numpy.array\n    :return: A look at matrix that can be used as a viewMatrix\n    """"""\n\n    eye = np.asarray(eye)\n    target = np.asarray(target)\n    up = np.asarray(up)\n\n    forward = vector.normalize(target - eye)\n    side = vector.normalize(np.cross(forward, up))\n    up = vector.normalize(np.cross(side, forward))\n\n    return np.array((\n            (side[0], up[0], -forward[0], 0.),\n            (side[1], up[1], -forward[1], 0.),\n            (side[2], up[2], -forward[2], 0.),\n            (-np.dot(side, eye), -np.dot(up, eye), np.dot(forward, eye), 1.0)\n        ), dtype=dtype)\n\n\ndef inverse(m):\n    """"""Returns the inverse of the matrix.\n\n    This is essentially a wrapper around numpy.linalg.inv.\n\n    :param numpy.array m: A matrix.\n    :rtype: numpy.array\n    :return: The inverse of the specified matrix.\n\n    .. seealso:: http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html\n    """"""\n    return np.linalg.inv(m)\n\n\ndef decompose(m):\n    """"""Decomposes an affine transformation matrix into its scale, rotation and\n    translation components.\n\n    :param numpy.array m: A matrix.\n    :return: tuple (scale, rotation, translation)\n        numpy.array scale vector3\n        numpy.array rotation quaternion\n        numpy.array translation vector3\n    """"""\n    m = np.asarray(m)\n\n    scale = np.linalg.norm(m[:3, :3], axis=1)\n\n    det = np.linalg.det(m)\n    if det < 0:\n        scale[0] *= -1\n\n    position = m[3, :3]\n\n    rotation = m[:3, :3] * (1 / scale)[:, None]\n\n    return scale, quaternion.create_from_matrix(rotation), position\n'"
pyrr/plane.py,7,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of Planes.\n\nPlanes are represented using a numpy.array of shape (4,).\nThe values represent the plane equation using the values A,B,C,D.\n\nThe first three values are the normal vector.\nThe fourth value is the distance of the origin from the plane, down the normal.\nA negative value indicates the origin is behind the plane, relative to the normal.\n\n.. seealso: http://en.wikipedia.org/wiki/Plane_(geometry)\n.. seealso: http://mathworld.wolfram.com/Plane.html\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import vector\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\ndef create(normal=None, distance=0.0, dtype=None):\n    """"""Creates a plane oriented toward the normal, at distance below the origin.\n    If no normal is provided, the plane will by created at the origin with a normal\n    of [0, 0, 1].\n\n    Negative distance indicates the plane is facing toward the origin.\n\n    :rtype: numpy.array\n    :return: A plane with the specified normal at a distance from the origin of\n    -distance.\n    """"""\n    if normal is None:\n        normal = [0.0, 0.0, 1.0]\n    return np.array([normal[0], normal[1], normal[2], distance], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'vector1\', \'vector2\', \'vector3\')\ndef create_from_points(vector1, vector2, vector3, dtype=None):\n    """"""Create a plane from 3 co-planar vectors.\n\n    The vectors must all lie on the same\n    plane or an exception will be thrown.\n\n    The vectors must not all be in a single line or\n    the plane is undefined.\n\n    The order the vertices are passed in will determine the\n    normal of the plane.\n\n    :param numpy.array vector1: a vector that lies on the desired plane.\n    :param numpy.array vector2: a vector that lies on the desired plane.\n    :param numpy.array vector3: a vector that lies on the desired plane.\n    :raise ValueError: raised if the vectors are co-incident (in a single line).\n    :rtype: numpy.array\n    :return: A plane that contains the 3 specified vectors.\n    """"""\n    dtype = dtype or vector1.dtype\n\n    # make the vectors relative to vector2\n    relV1 = vector1 - vector2\n    relV2 = vector3 - vector2\n\n    # cross our relative vectors\n    normal = np.cross(relV1, relV2)\n    if np.count_nonzero(normal) == 0:\n        raise ValueError(""Vectors are co-incident"")\n\n    # create our plane\n    return create_from_position(position=vector2, normal=normal, dtype=dtype)\n\n@parameters_as_numpy_arrays(\'position\', \'normal\')\ndef create_from_position(position, normal, dtype=None):\n    """"""Creates a plane at position with the normal being above the plane\n    and up being the rotation of the plane.\n\n    :param numpy.array position: The position of the plane.\n    :param numpy.array normal: The normal of the plane. Will be normalized\n        during construction.\n    :rtype: numpy.array\n    :return: A plane that crosses the specified position with the specified\n        normal.\n    """"""\n    dtype = dtype or position.dtype\n    # -d = a * x  + b * y + c * z\n    n = vector.normalize(normal)\n    d = -np.sum(n * position)\n    return create(n, -d, dtype)\n\ndef create_xy(invert=False, distance=0., dtype=None):\n    """"""Create a plane on the XY plane, starting at the origin with +Z being\n    the up vector.\n\n    The plane is distance units along the Z axis. -Z if inverted.\n    """"""\n    pl = np.array([0., 0., 1., distance])\n    if invert:\n        pl = invert_normal(pl)\n    return pl\n\ndef create_xz(invert=False, distance=0., dtype=None):\n    """"""Create a plane on the XZ plane, starting at the origin with +Y being\n    the up vector.\n\n    The plane is distance units along the Y axis. -Y if inverted.\n    """"""\n    pl = np.array([0., 1., 0., distance])\n    if invert:\n        pl = invert_normal(pl)\n    return pl\n\ndef create_yz(invert=False, distance=0., dtype=None):\n    """"""Create a plane on the YZ plane, starting at the origin with +X being\n    the up vector.\n\n    The plane is distance units along the X axis. -X if inverted.\n    """"""\n    pl = np.array([1., 0., 0., distance])\n    if invert:\n        pl = invert_normal(pl)\n    return pl\n\ndef invert_normal(plane):\n    """"""Flips the normal of the plane.\n\n    The plane is **not** changed in place.\n\n    :rtype: numpy.array\n    :return: The plane with the normal inverted.\n    """"""\n    # flip the normal, and the distance\n    return -plane\n\ndef position(plane):\n    """"""Extracts the position vector from a plane.\n\n    This will be a vector co-incident with the plane\'s normal.\n\n    :param numpy.array plane: The plane.\n    :rtype: numpy.array\n    :return: A valid position that lies on the plane.\n    """"""\n    return normal(plane) * distance(plane)\n\ndef normal(plane):\n    """"""Extracts the normal vector from a plane.\n\n    :param numpy.array plane: The plane.\n    :rtype: numpy.array\n    :return: The normal vector of the plane.\n    """"""\n    return plane[:3].copy()\n\ndef distance(plane):\n    """"""Distance the plane is from the origin along its the normal.\n\n    Negative value indicates the plane is facing the origin.\n    """"""\n    return plane[3]\n'"
pyrr/quaternion.py,62,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of Quaternions.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import vector, vector3, vector4, euler\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the X value within the quaternion\n    x = 0\n\n    #: The index of the Y value within the quaternion\n    y = 1\n\n    #: The index of the Z value within the quaternion\n    z = 2\n\n    #: The index of the W value within the quaternion\n    w = 3\n\n\ndef create(x=0., y=0., z=0., w=1., dtype=None):\n    return np.array([x, y, z, w], dtype=dtype)\n\ndef create_from_x_rotation(theta, dtype=None):\n    thetaOver2 = theta * 0.5\n\n    return np.array(\n        [\n            np.sin(thetaOver2),\n            0.0,\n            0.0,\n            np.cos(thetaOver2)\n        ],\n        dtype=dtype\n    )\n\ndef create_from_y_rotation(theta, dtype=None):\n    thetaOver2 = theta * 0.5\n\n    return np.array(\n        [\n            0.0,\n            np.sin(thetaOver2),\n            0.0,\n            np.cos(thetaOver2)\n        ],\n        dtype=dtype\n    )\n\ndef create_from_z_rotation(theta, dtype=None):\n    thetaOver2 = theta * 0.5\n\n    return np.array(\n        [\n            0.0,\n            0.0,\n            np.sin(thetaOver2),\n            np.cos(thetaOver2)\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'axis\')\ndef create_from_axis_rotation(axis, theta, dtype=None):\n    dtype = dtype or axis.dtype\n    # make sure the vector is normalized\n    if not np.isclose(np.linalg.norm(axis), 1.):\n        axis = vector.normalize(axis)\n\n    thetaOver2 = theta * 0.5\n    sinThetaOver2 = np.sin(thetaOver2)\n\n    return np.array(\n        [\n            sinThetaOver2 * axis[0],\n            sinThetaOver2 * axis[1],\n            sinThetaOver2 * axis[2],\n            np.cos(thetaOver2)\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'axis\')\ndef create_from_axis(axis, dtype=None):\n    dtype = dtype or axis.dtype\n    theta = np.linalg.norm(axis)\n    return create_from_axis_rotation(axis, theta, dtype)\n\n@parameters_as_numpy_arrays(\'mat\')\ndef create_from_matrix(mat, dtype=None):\n    # http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n    # optimised ""alternative version"" does not produce correct results\n    # see issue #42\n    dtype = dtype or mat.dtype\n\n    trace = mat[0][0] + mat[1][1] + mat[2][2]\n    if trace > 0:\n        s = 0.5 / np.sqrt(trace + 1.0)\n        qx = (mat[2][1] - mat[1][2]) * s\n        qy = (mat[0][2] - mat[2][0]) * s\n        qz = (mat[1][0] - mat[0][1]) * s\n        qw = 0.25 / s\n    elif mat[0][0] > mat[1][1] and mat[0][0] > mat[2][2]:\n        s = 2.0 * np.sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2])\n        qx = 0.25 * s\n        qy = (mat[0][1] + mat[1][0]) / s\n        qz = (mat[0][2] + mat[2][0]) / s\n        qw = (mat[2][1] - mat[1][2]) / s\n    elif mat[1][1] > mat[2][2]:\n        s = 2.0 * np.sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2])\n        qx = (mat[0][1] + mat[1][0]) / s\n        qy = 0.25 * s\n        qz = (mat[1][2] + mat[2][1]) / s\n        qw = (mat[0][2] - mat[2][0]) / s\n    else:\n        s = 2.0 * np.sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1])\n        qx = (mat[0][2] + mat[2][0]) / s\n        qy = (mat[1][2] + mat[2][1]) / s\n        qz = 0.25 * s\n        qw = (mat[1][0] - mat[0][1]) / s\n\n    quat = np.array([qx, qy, qz, qw], dtype=dtype)\n    return quat\n\n@parameters_as_numpy_arrays(\'eulers\')\ndef create_from_eulers(eulers, dtype=None):\n    """"""Creates a quaternion from a set of Euler angles.\n\n    Eulers are an array of length 3 in the following order:\n        [roll, pitch, yaw]\n    """"""\n    dtype = dtype or eulers.dtype\n\n    roll, pitch, yaw = euler.roll(eulers), euler.pitch(eulers), euler.yaw(eulers)\n\n    halfRoll = roll * 0.5\n    sR = np.sin(halfRoll)\n    cR = np.cos(halfRoll)\n\n    halfPitch = pitch * 0.5\n    sP = np.sin(halfPitch)\n    cP = np.cos(halfPitch)\n\n    halfYaw = yaw * 0.5\n    sY = np.sin(halfYaw)\n    cY = np.cos(halfYaw)\n\n    return np.array(\n        [\n            (sR * cP * cY) + (cR * sP * sY),\n            (cR * sP * cY) - (sR * cP * sY),\n            (cR * cP * sY) + (sR * sP * cY),\n            (cR * cP * cY) - (sR * sP * sY),\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'eulers\')\ndef create_from_inverse_of_eulers(eulers, dtype=None):\n    """"""Creates a quaternion from the inverse of a set of Euler angles.\n\n    Eulers are an array of length 3 in the following order:\n        [roll, pitch, yaw]\n    """"""\n    dtype = dtype or eulers.dtype\n\n    roll, pitch, yaw = euler.roll(eulers), euler.pitch(eulers), euler.yaw(eulers)\n\n    halfRoll = roll * 0.5\n    sinRoll = np.sin(halfRoll)\n    cosRoll = np.cos(halfRoll)\n\n    halfPitch = pitch * 0.5\n    sinPitch = np.sin(halfPitch)\n    cosPitch = np.cos(halfPitch)\n\n    halfYaw = yaw * 0.5\n    sinYaw = np.sin(halfYaw)\n    cosYaw = np.cos(halfYaw)\n\n    return np.array(\n        [\n            # x = cy * sp * cr + sy * cp * sr\n            (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll),\n            # y = -cy * sp * sr + sy * cp * cr\n            (-cosYaw * sinPitch * sinRoll) + (sinYaw * cosPitch * cosRoll),\n            # z = -sy * sp * cr + cy * cp * sr\n            (-sinYaw * sinPitch * cosRoll) + (cosYaw * cosPitch * sinRoll),\n            # w = cy * cp * cr + sy * sp * sr\n            (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll)\n        ],\n        dtype=dtype\n    )\n\n@all_parameters_as_numpy_arrays\ndef cross(quat1, quat2):\n    """"""Returns the cross-product of the two quaternions.\n\n    Quaternions are **not** communicative. Therefore, order is important.\n\n    This is NOT the same as a vector cross-product.\n    Quaternion cross-product is the equivalent of matrix multiplication.\n    """"""\n    q1x, q1y, q1z, q1w = quat1\n    q2x, q2y, q2z, q2w = quat2\n\n    return np.array(\n        [\n             q1x * q2w + q1y * q2z - q1z * q2y + q1w * q2x,\n            -q1x * q2z + q1y * q2w + q1z * q2x + q1w * q2y,\n             q1x * q2y - q1y * q2x + q1z * q2w + q1w * q2z,\n            -q1x * q2x - q1y * q2y - q1z * q2z + q1w * q2w,\n        ],\n        dtype=quat1.dtype\n    )\n\ndef lerp(quat1, quat2, t):\n    """"""Interpolates between quat1 and quat2 by t.\n    The parameter t is clamped to the range [0, 1]\n    """"""\n\n    quat1 = np.asarray(quat1)\n    quat2 = np.asarray(quat2)\n\n    t = np.clip(t, 0, 1)\n    return normalize(quat1 * (1 - t) + quat2 * t)\n\ndef slerp(quat1, quat2, t):\n    """"""Spherically interpolates between quat1 and quat2 by t.\n    The parameter t is clamped to the range [0, 1]\n    """"""\n\n    quat1 = np.asarray(quat1)\n    quat2 = np.asarray(quat2)\n\n    t = np.clip(t, 0, 1)\n    dot = vector4.dot(quat1, quat2)\n\n    if dot < 0.0:\n        dot = -dot\n        quat3 = -quat2\n\n    else:\n        quat3 = quat2\n\n    if dot < 0.95:\n        angle = np.arccos(dot)\n        res = (quat1 * np.sin(angle * (1 - t)) + quat3 * np.sin(angle * t)) / np.sin(angle)\n\n    else:\n        res = lerp(quat1, quat2, t)\n\n    return res\n\ndef is_zero_length(quat):\n    """"""Checks if a quaternion is zero length.\n\n    :param numpy.array quat: The quaternion to check.\n    :rtype: boolean.\n    :return: True if the quaternion is zero length, otherwise False.\n    """"""\n    return quat[0] == quat[1] == quat[2] == quat[3] == 0.0\n\ndef is_non_zero_length(quat):\n    """"""Checks if a quaternion is not zero length.\n\n    This is the opposite to \'is_zero_length\'.\n    This is provided for readability.\n\n    :param numpy.array quat: The quaternion to check.\n    :rtype: boolean\n    :return: False if the quaternion is zero length, otherwise True.\n\n    .. seealso:: is_zero_length\n    """"""\n    return not is_zero_length(quat)\n\ndef squared_length(quat):\n    """"""Calculates the squared length of a quaternion.\n\n    Useful for avoiding the performanc penalty of\n    the square root function.\n\n    :param numpy.array quat: The quaternion to measure.\n    :rtype: float, numpy.array\n    :return: If a 1d array was passed, it will be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    return vector4.squared_length(quat)\n\ndef length(quat):\n    """"""Calculates the length of a quaternion.\n\n    :param numpy.array quat: The quaternion to measure.\n    :rtype: float, numpy.array\n    :return: If a 1d array was passed, it will be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    return vector4.length(quat)\n\ndef normalize(quat):\n    """"""Ensure a quaternion is unit length (length ~= 1.0).\n\n    The quaternion is **not** changed in place.\n\n    :param numpy.array quat: The quaternion to normalize.\n    :rtype: numpy.array\n    :return: The normalized quaternion(s).\n    """"""\n    return vector4.normalize(quat)\n\ndef normalise(quat):    # TODO: mark as deprecated\n    """"""Ensure a quaternion is unit length (length ~= 1.0).\n\n    The quaternion is **not** changed in place.\n\n    :param numpy.array quat: The quaternion to normalize.\n    :rtype: numpy.array\n    :return: The normalized quaternion(s).\n    """"""\n    return vector4.normalize(quat)\n\ndef rotation_angle(quat):\n    """"""Calculates the rotation around the quaternion\'s axis.\n\n    :param numpy.array quat: The quaternion.\n    :rtype: float.\n    :return: The quaternion\'s rotation about the its axis in radians.\n    """"""\n    # extract the W component\n    thetaOver2 = np.arccos(quat[3])\n    return thetaOver2 * 2.0\n\n@all_parameters_as_numpy_arrays\ndef rotation_axis(quat):\n    """"""Calculates the axis of the quaternion\'s rotation.\n\n    :param numpy.array quat: The quaternion.\n    :rtype: numpy.array.\n    :return: The quaternion\'s rotation axis.\n    """"""\n    # extract W component\n    sinThetaOver2Sq = 1.0 - (quat[3] ** 2)\n\n    # check for zero before we sqrt\n    if sinThetaOver2Sq <= 0.0:\n        # identity quaternion or numerical imprecision.\n        # return a valid vector\n        # we\'ll treat -Z as the default\n        return np.array([0.0, 0.0, -1.0], dtype=quat.dtype)\n\n    oneOverSinThetaOver2 = 1.0 / np.sqrt(sinThetaOver2Sq)\n\n    # we use the x,y,z values\n    return np.array(\n        [\n            quat[0] * oneOverSinThetaOver2,\n            quat[1] * oneOverSinThetaOver2,\n            quat[2] * oneOverSinThetaOver2\n        ],\n        dtype=quat.dtype\n    )\n\ndef dot(quat1, quat2):\n    """"""Calculate the dot product of quaternions.\n\n    This is the same as a vector dot product.\n\n    :param numpy.array quat1: The first quaternion(s).\n    :param numpy.array quat2: The second quaternion(s).\n    :rtype: float, numpy.array\n    :return: If a 1d array was passed, it will be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    return vector4.dot(quat1, quat2)\n\n@all_parameters_as_numpy_arrays\ndef conjugate(quat):\n    """"""Calculates a quaternion with the opposite rotation.\n\n    :param numpy.array quat: The quaternion.\n    :rtype: numpy.array.\n    :return: A quaternion representing the conjugate.\n    """"""\n\n    # invert x,y,z and leave w as is\n    return np.array(\n        [\n            -quat[0],\n            -quat[1],\n            -quat[2],\n            quat[3]\n        ],\n        dtype=quat.dtype\n    )\n\n@parameters_as_numpy_arrays(\'quat\')\ndef exp(quat):\n    """"""Calculate the exponential of the quaternion\n\n    :param numpy.array quat: The quaternion.\n    :rtype: numpy.array.\n    :return: The exponential of the quaternion\n    """"""\n    e = np.exp(quat[3])\n    vector_norm = np.linalg.norm(quat[:3])\n\n    if np.isclose(vector_norm, 0):\n        return np.array(\n            [0, 0, 0, e],\n            dtype = quat.dtype\n        )\n\n    s = np.sin(vector_norm) / vector_norm\n    return e * np.array(\n        [\n            quat[0] * s,\n            quat[1] * s,\n            quat[2] * s,\n            np.cos(vector_norm),\n        ],\n        dtype = quat.dtype\n    )\n\n@parameters_as_numpy_arrays(\'quat\')\ndef power(quat, exponent):\n    """"""Multiplies the quaternion by the exponent.\n\n    The quaternion is **not** changed in place.\n\n    :param numpy.array quat: The quaternion.\n    :param float scalar: The exponent.\n    :rtype: numpy.array.\n    :return: A quaternion representing the original quaternion\n        to the specified power.\n    """"""\n    # check for identify quaternion\n    if np.fabs(quat[3]) > 0.9999:\n        # assert for the time being\n        assert False\n        print(""rotation axis was identity"")\n\n        return quat\n\n    alpha = np.arccos(quat[3])\n    newAlpha = alpha * exponent\n    multi = np.sin(newAlpha) / np.sin(alpha)\n\n    return np.array(\n        [\n            quat[0] * multi,\n            quat[1] * multi,\n            quat[2] * multi,\n            np.cos(newAlpha)\n        ],\n        dtype=quat.dtype\n    )\n\ndef inverse(quat):\n    """"""Calculates the inverse quaternion.\n\n    The inverse of a quaternion is defined as\n    the conjugate of the quaternion divided\n    by the magnitude of the original quaternion.\n\n    :param numpy.array quat: The quaternion to invert.\n    :rtype: numpy.array.\n    :return: The inverse of the quaternion.\n    """"""\n    return conjugate(quat) / length(quat)\n\n@all_parameters_as_numpy_arrays\ndef negate(quat):\n    """"""Calculates the negated quaternion.\n\n    This is essentially the quaternion * -1.0.\n\n    :param numpy.array quat: The quaternion.\n    :rtype: numpy.array\n    :return: The negated quaternion.\n    """"""\n    return quat * -1.0\n\ndef is_identity(quat):\n    return np.allclose(quat, [0.,0.,0.,1.])\n\n@all_parameters_as_numpy_arrays\ndef apply_to_vector(quat, vec):\n    """"""Rotates a vector by a quaternion.\n\n    :param numpy.array quat: The quaternion.\n    :param numpy.array vec: The vector.\n    :rtype: numpy.array\n    :return: The vector rotated by the quaternion.\n    :raise ValueError: raised if the vector is an unsupported size\n    """"""\n    def apply(quat, vec4):\n        result = cross(quat, cross(vec4, conjugate(quat)))\n        return result\n\n    if vec.size == 3:\n        # convert to vector4\n        # ignore w component by setting it to 0.\n        vec = np.array([vec[0], vec[1], vec[2], 0.0], dtype=vec.dtype)\n        vec = apply(quat, vec)\n        vec = vec[:3]\n        return vec\n    elif vec.size == 4:\n        vec = apply(quat, vec)\n        return vec\n    else:\n        raise ValueError(""Vector size unsupported"")\n'"
pyrr/ray.py,2,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of Rays.\n\nA ray begins as a single point and extends\ninfinitely in a direction.\n\nThe first vector is the origin of the ray.\nThe second vector is the direction of the ray\nrelative to the origin.\n\nThe following functions will normalize the ray\ndirection to unit length.\nSome functions may work correctly with directions\nthat are not unit length, but this may vary from\nfunction to function.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom . import vector\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the start vector within the ray\n    position = 0\n\n    #: The index of the direction vector within the ray\n    direction = 1\n\n\n@parameters_as_numpy_arrays(\'start\', \'direction\')\ndef create(start, direction, dtype=None):\n    dtype = dtype or start.dtype\n    return np.array(\n        [\n            start,\n            vector.normalize(direction)\n        ],\n        dtype=dtype\n    )\n\n@parameters_as_numpy_arrays(\'line\')\ndef create_from_line(line, dtype=None):\n    """"""Converts a line or line segment to a ray.\n    """"""\n    dtype = dtype or line.dtype\n    # direction = vend - vstart\n    return np.array(\n        [\n            line[0],\n            vector.normalize(line[1] - line[0])\n        ],\n        dtype=dtype\n    )\n\n@all_parameters_as_numpy_arrays\ndef invert(r):\n    r2 = r.copy()\n    r2[1] *= -1\n    return r2\n\n@all_parameters_as_numpy_arrays\ndef position(ray):\n    return ray[0].copy()\n\n@all_parameters_as_numpy_arrays\ndef direction(ray):\n    return ray[1].copy()\n\n'"
pyrr/rectangle.py,3,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of 2D Rectangles.\n\nRectangles are represented using a numpy.array of shape (2,2,).\n\nThe first value is a vector of x, y position of the rectangle.\nThe second value is a vector with the width, height of the rectangle.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\nclass index:\n    #: The index of the position vector within the rectangle\n    position = 0\n\n    #: The index of the size vector within the rectangle\n    size = 1\n\n\ndef create(x=0., y=0., width=1., height=1., dtype=None):\n    """"""Creates a rectangle from the specified position and sizes.\n\n    This function will interpret the values literally. A negative width\n    or height will be represented by the returned value.\n\n    :rtype: numpy.array\n    :return: Returns a rectangle with the specified values.\n    """"""\n    return np.array([[x, y], [width, height]], dtype=dtype)\n\ndef create_zeros(dtype=None):\n    return np.zeros((2,2), dtype=dtype)\n\ndef create_from_bounds(left, right, bottom, top, dtype=None):\n    """"""Creates a rectangle from the specified boundaries.\n\n    This caters for the left and right, and for the\n    top and bottom being swapped.\n\n    :rtype: numpy.array\n    :return: Returns a rectangle with the specified values.\n        The rectangle will have a positive width and height\n        regardless of the values passed in.\n    """"""\n    xmin = min(left, right)\n    xmax = max(left, right)\n    ymin = min(top, bottom)\n    ymax = max(top, bottom)\n\n    return create(\n        xmin,\n        ymin,\n        xmax - xmin,\n        ymax - ymin,\n        dtype\n    )\n\n@all_parameters_as_numpy_arrays\ndef bounds(rect):\n    """"""Returns the absolute boundaries of the rectangle.\n\n    This caters for rectangles with a negative width.\n\n    :rtype: Tuple of 4 floats\n    :return: The absolute left, right, bottom and top of the rectangle.\n    """"""\n    left = rect[0,0]\n    right = rect[0,0] + rect[1,0]\n    top = rect[0,1]\n    bottom = rect[0,1] + rect[1,1]\n\n    xmin = min(left, right)\n    xmax = max(left, right)\n    ymin = min(top, bottom)\n    ymax = max(top, bottom)\n\n    return xmin, xmax, ymin, ymax\n\n@all_parameters_as_numpy_arrays\ndef position(rect):\n    """"""Returns the literal position of the rectangle.\n\n    This is the bottom-left point of the rectangle for\n    rectangles with positive width and height\n\n    :rtype: numpy.array\n    :return: The position of the rectangle.\n    """"""\n    return rect[0].copy()\n\n@all_parameters_as_numpy_arrays\ndef size(rect):\n    """"""Returns the literal size of the rectangle.\n\n    These values may be negative.\n\n    :rtype: numpy.array\n    :return: The size of the rectangle.\n    """"""\n    return rect[1].copy()\n\ndef abs_size(rect):\n    """"""Returns the absolute size of the rectangle.\n\n    :rtype: numpy.array\n    :return: The absolute size of the rectangle.\n    """"""\n    return np.absolute(rect[1])\n\ndef x(rect):\n    """"""Returns the X position of the rectangle.\n\n    This will be the left for rectangles with positive height values.\n\n    :rtype: float\n    :return: The X position of the rectangle. This value\n        will be further right than the \'right\' if the width is negative.\n    """"""\n    return rect[0][0]\n\ndef y(rect):\n    """"""Returns the Y position of the rectangle.\n\n    This will be the bottom for rectangles with positive height values.\n\n    :rtype: float\n    :return: The Y position of the rectangle. This value\n        will be above the bottom if the height is negative.\n    """"""\n    return rect[0][1]\n\ndef width(rect):\n    """"""Returns the literal width of the rectangle.\n\n    :rtype: float\n    :return: The width of the rectangle. This can be a\n        negative value.\n    """"""\n    return rect[1][0]\n\ndef abs_width(rect):\n    """"""Returns the absolute width of the rectangle.\n\n    This caters for rectangles with a negative width.\n\n    :rtype: float\n    :return: The absolute width of the rectangle.\n    """"""\n    return abs(width(rect))\n\ndef height(rect):\n    """"""Returns the literal height of the rectangle.\n\n    :rtype: float\n    :return: The height of the rectangle. This can be a\n        negative value.\n    """"""\n    return rect[1][1]\n\ndef abs_height(rect):\n    """"""Returns the absolute height of the rectangle.\n\n    This caters for rectangles with a negative height.\n\n    :rtype: float\n    :return: The absolute height of the rectangle.\n    """"""\n    return abs(height(rect))\n\ndef top(rect):\n    """"""Returns the top most Y value of the rectangle.\n\n    This caters for rectangles with a negative height.\n\n    :rtype: float\n    :return: The biggest Y value.\n    """"""\n    return max(\n        rect[0][1],\n        rect[0][1] + rect[1][1]\n       )\n\ndef bottom(rect):\n    """"""Returns the bottom most Y value of the rectangle.\n\n    This caters for rectangles with a negative height.\n\n    :rtype: float\n    :return: The smallest Y value.\n    """"""\n    return min(\n        rect[0][1],\n        rect[0][1] + rect[1][1]\n       )\n\ndef left(rect):\n    """"""Returns the left most X value of the rectangle.\n\n    This caters for rectangles with a negative width.\n\n    :rtype: float\n    :return: The smallest X value.\n    """"""\n    return min(\n        rect[0][0],\n        rect[0][0] + rect[1][0]\n       )\n\ndef right(rect):\n    """"""Returns the right most X value of the rectangle.\n\n    This caters for rectangles with a negative width.\n\n    :rtype: float\n    :return: The biggest X value.\n    """"""\n    return max(\n        rect[0][0],\n        rect[0][0] + rect[1][0]\n       )\n\n@parameters_as_numpy_arrays(\'rect\')\ndef scale_by_vector(rect, vec):\n    """"""Scales a rectangle by a 2D vector.\n\n    Note that this will also scale the X,Y\n    value of the rectangle, which will cause\n    the rectangle to move, not just increase\n    in size.\n\n    :param numpy.array rect: the rectangle to scale.\n        Both x,y and width,height will be scaled.\n    :param vec: A 2D vector to scale the rect by.\n    :rtype: numpy.array.\n    """"""\n    return rect * vec[:2]\n\ndef aspect_ratio(rect):\n    width = float(abs_width(rect))\n    height = float(abs_height(rect))\n    return width / height\n\n\n'"
pyrr/sphere.py,5,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the creation and manipulation of 3D Spheres.\n\nSphere are represented using a numpy.array of shape (4,).\n\nThe first three values are the sphere\'s position.\nThe fourth value is the sphere\'s radius.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n@parameters_as_numpy_arrays(\'center\')\ndef create(center=None, radius=1.0, dtype=None):\n    if center is None:\n        center = [0.,0.,0.]\n    return np.array([center[0], center[1], center[2], radius], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'points\')\ndef create_from_points(points, dtype=None):\n    """"""Creates a sphere centred around 0,0,0 that encompasses\n    the furthest point in the provided list.\n\n    :param numpy.array points: An Nd array of vectors.\n    :rtype: A sphere as a two value tuple.\n    """"""\n    dtype = dtype or points.dtype\n    # calculate the lengths of all the points\n    # use squared length to save processing\n    lengths = np.apply_along_axis(\n        np.sum,\n        points.ndim - 1,\n        points**2\n    )\n\n    # find the maximum value\n    maximum = lengths.max()\n\n    # square root this, this is the radius\n    radius = np.sqrt(maximum)\n    return np.array([0.0, 0.0, 0.0, radius], dtype=dtype)\n\n@all_parameters_as_numpy_arrays\ndef position(sphere):\n    """"""Returns the position of the sphere.\n\n    :param numpy.array sphere: The sphere to extract the position from.\n    :rtype: numpy.array\n    :return: The centre of the sphere.\n    """"""\n    return sphere[:3].copy()\n\n@all_parameters_as_numpy_arrays\ndef radius(sphere):\n    """"""Returns the radius of the sphere.\n\n    :param numpy.array sphere: The sphere to extract the radius from.\n    :rtype: float\n    :return: The radius of the sphere.\n    """"""\n    return sphere[3]\n'"
pyrr/trig.py,0,"b'# -*- coding: utf-8 -*-\n""""""Provide functions for the trigonometric functions.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport math\n\n\ndef aspect_ratio(width, height):\n    return float(width) / float(height)\n\ndef calculate_fov(zoom, height=1.0):\n    """"""Calculates the required FOV to set the\n    view frustrum to have a view with the specified height\n    at the specified distance.\n\n    :param float zoom: The distance to calculate the FOV for.\n    :param float height: The desired view height at the specified\n        distance.\n        The default is 1.0.\n    :rtype: A float representing the FOV to use in degrees.\n    """"""\n    # http://www.glprogramming.com/red/chapter03.html\n    rad_theta = 2.0 * math.atan2(height / 2.0, zoom)\n    return math.degrees(rad_theta)\n\ndef calculate_zoom(fov, height=1.0):\n    """"""Calculates the zoom (distance) from the camera\n    with the specified FOV and height of image.\n\n    :param float fov: The FOV to use.\n    :param float height: The height of the image at the\n        desired distance.\n    :rtype: A float representing the zoom (distance) from the camera for the\n        desired height at the specified FOV.\n    :raise ZeroDivisionError: Raised if the fov is\n        0.0.\n    """"""\n    return float(height) / math.tan(fov / 2.0)\n\ndef calculate_height(fov, zoom):\n    """"""Performs the opposite of calculate_fov.\n    Used to find the current height at a specific distance.\n\n    :param float fov: The current FOV.\n    :param float zoom: The distance to calculate the height\n        for.\n    :rtype: A float representing the height at the specified distance for the\n        specified FOV.\n    """"""\n    height = zoom * (math.tan(fov / 2.0))\n    return height\n\ndef calculate_plane_size(aspect_ratio, fov, distance):\n    """"""Calculates the width and height of a plane at the\n    specified distance using the FOV of the frustrum\n    and aspect ratio of the viewport.\n\n    :param float aspect_ratio: The aspect ratio of the viewport.\n    :param float fov: The FOV of the frustrum.\n    :param float distance: The distance from the origin/camera\n        of the plane to calculate.\n    :rtype: A tuple of two floats: width and height: The width and height of\n        the plane.\n    """"""\n    # http://www.songho.ca/opengl/gl_transform.html\n    # http://nehe.gamedev.net/article/replacement_for_gluperspective/21002/\n    # http://steinsoft.net/index.php?site=Programming/Code%20Snippets/OpenGL/gluperspective&printable=1\n    tangent = math.radians(fov)\n    height = distance * tangent\n    width = height * aspect_ratio\n\n    return width * 2.0, height * 2.0\n\n'"
pyrr/utils.py,5,"b'# -*- coding: utf-8 -*-\n""""""Provides common utility functions.\n""""""\nimport inspect\nfrom functools import wraps\nimport numpy as np\n\n\ndef all_parameters_as_numpy_arrays(fn):\n    """"""Converts all of a function\'s arguments to numpy arrays.\n\n    Used as a decorator to reduce duplicate code.\n    """"""\n    # wraps allows us to pass the docstring back\n    # or the decorator will hide the function from our doc generator\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        args = list(args)\n        for i, v in enumerate(args):\n            if v is not None:\n                args[i] = np.asarray(v)\n        for k,v in kwargs.items():\n            if v is not None:\n                kwargs[k] = np.asarray(v)\n        return fn(*args, **kwargs)\n    return wrapper\n\ndef parameters_as_numpy_arrays(*args_to_convert):\n    """"""Converts specific arguments to numpy arrays.\n\n    Used as a decorator to reduce duplicate code.\n\n    Arguments are specified by their argument name.\n    For example\n    ::\n\n        @parameters_as_numpy_arrays(\'a\', \'b\', \'optional\')\n        def myfunc(a, b, *args, **kwargs):\n            pass\n\n        myfunc(1, [2,2], optional=[3,3,3])\n    """"""\n    def decorator(fn):\n        # wraps allows us to pass the docstring back\n        # or the decorator will hide the function from our doc generator\n\n        try:\n            getfullargspec = inspect.getfullargspec\n        except AttributeError:\n            getfullargspec = inspect.getargspec\n\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            # get the arguements of the function we\'re decorating\n            fn_args = getfullargspec(fn)\n\n            # convert any values that are specified\n            # if the argument isn\'t in our list, just pass it through\n\n            # convert the *args list\n            # we zip the args with the argument names we received from\n            # the inspect function\n            args = list(args)\n            for i, (k, v) in enumerate(zip(fn_args.args, args)):\n                if k in args_to_convert and v is not None:\n                    args[i] = np.array(v)\n\n            # convert the **kwargs dict\n            for k,v in kwargs.items():\n                if k in args_to_convert and v is not None:\n                    kwargs[k] = np.array(v)\n\n            # pass the converted values to our function\n            return fn(*args, **kwargs)\n        return wrapper\n    return decorator\n\ndef solve_quadratic_equation(a, b, c):\n    """"""Quadratic equation solver.\n    Solve function of form f(x) = ax^2 + bx + c\n\n    :param float a: Quadratic part of equation.\n    :param float b: Linear part of equation.\n    :param float c: Static part of equation.\n    :rtype: list\n    :return: List contains either two elements for two solutions, one element for one solution, or is empty if\n        no solution for the quadratic equation exists.\n    """"""\n    delta = b * b - 4 * a * c\n    if delta > 0:\n        # Two solutions\n        # See https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n        # Why not use simple form:\n        # s1 = (-b + math.sqrt(delta)) / (2 * a)\n        # s2 = (-b - math.sqrt(delta)) / (2 * a)\n        q = -0.5 * (b + np.math.sqrt(delta)) if b > 0 else -0.5 * (b - np.math.sqrt(delta))\n        s1 = q / a\n        s2 = c / q\n        return [s1, s2]\n    elif delta == 0:\n        # One solution\n        return [-b / (2 * a)]\n    else:\n        # No solution exists\n        return list()\n'"
pyrr/vector.py,8,"b'# -*- coding: utf-8 -*-\n""""""Common Vector manipulation functions.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import all_parameters_as_numpy_arrays, parameters_as_numpy_arrays\n\n\n@all_parameters_as_numpy_arrays\ndef normalize(vec):\n    """"""normalizes an Nd list of vectors or a single vector\n    to unit length.\n\n    The vector is **not** changed in place.\n\n    For zero-length vectors, the result will be np.nan.\n\n    :param numpy.array vec: an Nd array with the final dimension\n        being vectors\n        ::\n\n            numpy.array([ x, y, z ])\n\n        Or an NxM array::\n\n            numpy.array([\n                [x1, y1, z1],\n                [x2, y2, z2]\n            ]).\n\n    :rtype: A numpy.array the normalized value\n    """"""\n    # calculate the length\n    # this is a duplicate of length(vec) because we\n    # always want an array, even a 0-d array.\n    return (vec.T  / np.sqrt(np.sum(vec**2,axis=-1))).T\n\n\n\n@all_parameters_as_numpy_arrays\ndef normalise(vec):    # TODO: mark as deprecated\n    """"""normalizes an Nd list of vectors or a single vector\n    to unit length.\n\n    The vector is **not** changed in place.\n\n    For zero-length vectors, the result will be np.nan.\n\n    :param numpy.array vec: an Nd array with the final dimension\n        being vectors\n        ::\n\n            numpy.array([ x, y, z ])\n\n        Or an NxM array::\n\n            numpy.array([\n                [x1, y1, z1],\n                [x2, y2, z2]\n            ]).\n\n    :rtype: A numpy.array the normalized value\n    """"""\n    # calculate the length\n    # this is a duplicate of length(vec) because we\n    # always want an array, even a 0-d array.\n    return (vec.T  / np.sqrt(np.sum(vec**2,axis=-1))).T\n\n\n\n@all_parameters_as_numpy_arrays\ndef squared_length(vec):\n    """"""Calculates the squared length of a vector.\n\n    Useful when trying to avoid the performance\n    penalty of a square root operation.\n\n    :param numpy.array vec: An Nd numpy.array.\n    :rtype: If one vector is supplied, the result with be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    lengths = np.sum(vec ** 2., axis=-1)\n\n    return lengths\n\n@all_parameters_as_numpy_arrays\ndef length(vec):\n    """"""Returns the length of an Nd list of vectors\n    or a single vector.\n\n    :param numpy.array vec: an Nd array with the final dimension\n        being size 3 (a vector).\n\n        Single vector::\n\n            numpy.array([ x, y, z ])\n\n        Nd array::\n\n            numpy.array([\n                [x1, y1, z1],\n                [x2, y2, z2]\n            ]).\n\n    :rtype: If a 1d array was passed, it will be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    return np.sqrt(np.sum(vec**2,axis=-1))\n\n\n@parameters_as_numpy_arrays(\'vec\')\ndef set_length(vec, len):\n    """"""Resizes an Nd list of vectors or a single vector to \'length\'.\n\n    The vector is **not** changed in place.\n\n    :param numpy.array vec: an Nd array with the final dimension\n        being size 3 (a vector).\n\n        Single vector::\n            numpy.array([ x, y, z ])\n\n        Nd array::\n            numpy.array([\n                [x1, y1, z1],\n                [x2, y2, z2]\n            ]).\n\n    :rtype: A numpy.array of shape vec.shape.\n    """"""\n    # calculate the length\n    # this is a duplicate of length(vec) because we\n    # always want an array, even a 0-d array.\n\n    return (vec.T  / np.sqrt(np.sum(vec**2,axis=-1)) * len).T\n\n\n@all_parameters_as_numpy_arrays\ndef dot(v1, v2):\n    """"""Calculates the dot product of two vectors.\n\n    :param numpy.array v1: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array v2: an Nd array with the final dimension\n        being size 3 (a vector)\n    :rtype: If a 1d array was passed, it will be a scalar.\n        Otherwise the result will be an array of scalars with shape\n        vec.ndim with the last dimension being size 1.\n    """"""\n    return np.sum(v1 * v2, axis=-1)\n\n@parameters_as_numpy_arrays(\'v1\', \'v2\')\ndef interpolate(v1, v2, delta):\n    """"""Interpolates between 2 arrays of vectors (shape = N,3)\n    by the specified delta (0.0 <= delta <= 1.0).\n\n    :param numpy.array v1: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array v2: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param float delta: The interpolation percentage to apply,\n        where 0.0 <= delta <= 1.0.\n        When delta is 0.0, the result will be v1.\n        When delta is 1.0, the result will be v2.\n        Values inbetween will be an interpolation.\n    :rtype: A numpy.array with shape v1.shape.\n    """"""\n    # scale the difference based on the time\n    # we must do it this \'unreadable\' way to avoid\n    # loss of precision.\n    # the \'readable\' method (f_now = f_0 + (f1 - f0) * delta)\n    # causes floating point errors due to the small values used\n    # in md2 files and the values become corrupted.\n    # this horrible code curtousey of this comment:\n    # http://stackoverflow.com/questions/5448322/temporal-interpolation-in-numpy-matplotlib\n    return v1 + ((v2 - v1) * delta)\n    #return v1 * (1.0 - delta ) + v2 * delta\n    t = delta\n    t0 = 0.0\n    t1 = 1.0\n    delta_t = t1 - t0\n    return (t1 - t) / delta_t * v1 + (t - t0) / delta_t * v2\n'"
pyrr/vector3.py,12,"b'# -*- coding: utf-8 -*-\n""""""Provides functions for creating and manipulating 3D vectors.\n""""""\nfrom __future__ import absolute_import, division, print_function, unicode_literals\nimport numpy as np\n\n# import common vector operations\nfrom .vector import *\n\n\ndef create(x=0., y=0., z=0., dtype=None):\n    if isinstance(x, (list, np.ndarray)):\n        raise ValueError(\'Function requires non-list arguments\')\n    return np.array([x,y,z], dtype=dtype)\n\ndef create_unit_length_x(dtype=None):\n    return np.array([1.0, 0.0, 0.0], dtype=dtype)\n\ndef create_unit_length_y(dtype=None):\n    return np.array([0.0, 1.0, 0.0], dtype=dtype)\n\ndef create_unit_length_z(dtype=None):\n    return np.array([0.0, 0.0, 1.0], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'vector\')\ndef create_from_vector4(vector, dtype=None):\n    """"""Returns a vector3 and the W component as a tuple.\n    """"""\n    dtype = dtype or vector.dtype\n    return (np.array([vector[0], vector[1], vector[2]], dtype=dtype), vector[3])\n\n@parameters_as_numpy_arrays(\'mat\')\ndef create_from_matrix44_translation(mat, dtype=None):\n    return np.array(mat[3, :3], dtype=dtype)\n\ndef cross(v1, v2):\n    """"""Calculates the cross-product of two vectors.\n\n    :param numpy.array v1: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array v2: an Nd array with the final dimension\n        being size 3. (a vector)\n    :rtype: A np.array with shape v1.shape.\n    """"""\n    return np.cross(v1, v2)\n\ndef generate_normals(v1, v2, v3, normalize_result=True):\n    """"""Generates a normal vector for 3 vertices.\n\n    The result is a normalized vector.\n\n    It is assumed the ordering is counter-clockwise starting\n    at v1, v2 then v3::\n\n        v1      v3\n          \\    /\n            v2\n\n    The vertices are Nd arrays and may be 1d or Nd.\n    As long as the final axis is of size 3.\n\n    For 1d arrays::\n        >>> v1 = numpy.array( [ 1.0, 0.0, 0.0 ] )\n        >>> v2 = numpy.array( [ 0.0, 0.0, 0.0 ] )\n        >>> v3 = numpy.array( [ 0.0, 1.0, 0.0 ] )\n        >>> vector.generate_normals( v1, v2, v3 )\n        array([ 0.,  0., -1.])\n\n    For Nd arrays::\n        >>> v1 = numpy.array( [ [ 1.0, 0.0, 0.0 ], [ 1.0, 0.0, 0.0 ] ] )\n        >>> v2 = numpy.array( [ [ 0.0, 0.0, 0.0 ], [ 0.0, 0.0, 0.0 ] ] )\n        >>> v3 = numpy.array( [ [ 0.0, 1.0, 0.0 ], [ 0.0, 1.0, 0.0 ] ] )\n        >>> vector.generate_normals( v1, v2, v3 )\n        array([[ 0.,  0., -1.],\n               [ 0.,  0., -1.]])\n\n    :param numpy.array v1: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array v2: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array v3: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param boolean normalize_result: Specifies if the result should\n        be normalized before being returned.\n    """"""\n    # make vectors relative to v2\n    # we assume opengl counter-clockwise ordering\n    a = v1 - v2\n    b = v3 - v2\n    n = cross(b, a)\n    if normalize_result:\n        n = normalize(n)\n    return n\n\ndef generate_vertex_normals(vertices, index, normalize_result=True):\n    """"""Generates a normal vector for each vertex.\n\n    The result is a normalized vector.\n\n    The index array should list the faces by indexing into the\n    vertices array. It is assumed the ordering in index is\n    counter-clockwise.\n\n    The vertices and index arrays are Nd arrays and must be 2d,\n    where the final axis is of size 3.\n\n    An example::\n        >>> vertices = numpy.array( [ [ 1.0, 0.0, 0.0 ], [ 0.0, 0.0, 0.0 ], [ 0.0, 1.0, 0.0 ] ] )\n        >>> index = numpy.array( [ [ 0, 2, 1 ] ] )\n        >>> vector.generate_vertex_normals( vertices, index )\n        array([[ 0.,  0., 1.], [ 0.,  0., 1.], [ 0.,  0., 1.]])\n\n    :param numpy.array vertices: an 2d array with the final dimension\n        being size 3. (a vector)\n    :param numpy.array index: an Nd array with the final dimension\n        being size 3. (a vector)\n    :param boolean normalize_result: Specifies if the result should\n        be normalized before being returned.\n    """"""\n    v1, v2, v3 = np.rollaxis(vertices[index], axis=-2)\n    face_normals = generate_normals(v1, v2, v3, normalize_result=False)\n    vertex_normals = np.zeros_like(vertices)\n    for i in range(3):\n        np.add.at(vertex_normals, index[..., i], face_normals)\n    if normalize_result:\n        vertex_normals = normalize(vertex_normals)\n    return vertex_normals\n\n\nclass index:\n    #: The index of the X value within the vector\n    x = 0\n\n    #: The index of the Y value within the vector\n    y = 1\n\n    #: The index of the Z value within the vector\n    z = 2\n\n\nclass unit:\n    #: A vector of unit length in the X-axis. (1.0, 0.0, 0.0)\n    x = create_unit_length_x()\n\n    #: A vector of unit length in the Y-axis. (0.0, 1.0, 0.0)\n    y = create_unit_length_y()\n\n    #: A vector of unit length in the Z-axis. (0.0, 0.0, 1.0)\n    z = create_unit_length_z()\n'"
pyrr/vector4.py,8,"b'# -*- coding: utf-8 -*-\n""""""Provides functions for creating and manipulating 4D vectors.\n""""""\nfrom __future__ import absolute_import, division, print_function\nimport numpy as np\nfrom .utils import parameters_as_numpy_arrays\n\n# import common vector operations\nfrom .vector import *\n\n\ndef create(x=0., y=0., z=0., w=0.0, dtype=None):\n    if isinstance(x, (list, np.ndarray)):\n        raise ValueError(\'Function requires non-list arguments\')\n    return np.array([x,y,z,w], dtype=dtype)\n\ndef create_unit_length_x(dtype=None):\n    return np.array([1.0, 0.0, 0.0, 0.0], dtype=dtype)\n\ndef create_unit_length_y(dtype=None):\n    return np.array([0.0, 1.0, 0.0, 0.0], dtype=dtype)\n\ndef create_unit_length_z(dtype=None):\n    return np.array([0.0, 0.0, 1.0, 0.0], dtype=dtype)\n\ndef create_unit_length_w(dtype=None):\n    return np.array([0.0, 0.0, 0.0, 1.0], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'vector\')\ndef create_from_vector3(vector, w=0., dtype=None):\n    dtype = dtype or vector.dtype\n    return np.array([vector[0], vector[1], vector[2], w], dtype=dtype)\n\n@parameters_as_numpy_arrays(\'mat\')\ndef create_from_matrix44_translation(mat, dtype=None):\n    return np.array(mat[3, :4], dtype=dtype)\n\nclass index:\n    #: The index of the X value within the vector\n    x = 0\n\n    #: The index of the Y value within the vector\n    y = 1\n\n    #: The index of the Z value within the vector\n    z = 2\n\n    #: The index of the W value within the vector\n    w = 3\n\n\nclass unit:\n    #: A vector of unit length in the X-axis. (1.0, 0.0, 0.0, 0.0)\n    x = create_unit_length_x()\n\n    #: A vector of unit length in the Y-axis. (0.0, 1.0, 0.0, 0.0)\n    y = create_unit_length_y()\n\n    #: A vector of unit length in the Z-axis. (0.0, 0.0, 1.0, 0.0)\n    z = create_unit_length_z()\n'"
pyrr/version.py,0,"b""# -*- coding: utf-8 -*-\n# the version of software\n# this is used by the setup.py script\n__version__ = '0.10.3'\n\n"""
tests/__init__.py,0,b''
tests/test_aabb.py,38,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import aabb\n\n\nclass test_aabb(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.aabb\n        from pyrr import aabb\n\n    def test_create_zeros(self):\n        result = aabb.create_zeros()\n        self.assertTrue(np.array_equal(result, [[0,0,0],[0,0,0]]))\n\n    def test_create_from_bounds(self):\n        result = aabb.create_from_bounds([-1,-1,-1],[1,1,1])\n        self.assertTrue(np.array_equal(result, [[-1,-1,-1],[1,1,1]]))\n\n    def test_create_from_points(self):\n        points = np.array([[-1.0,-1.0,-1.0]])\n        result = aabb.create_from_points(points)\n        expected = np.array([\n                [-1.0,-1.0,-1.0],\n                [-1.0,-1.0,-1.0]\n        ])\n        self.assertTrue(np.array_equal(result, expected))\n\n        points = np.array([\n            [-1.0,-1.0,-1.0],\n            [-1.0, 2.0,-2.0],\n        ])\n        result = aabb.create_from_points(points)\n        expected = np.array([\n            [-1.0,-1.0,-2.0],\n            [-1.0, 2.0,-1.0],\n        ])\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_create_from_aabbs(self):\n        # -1\n        a1 = np.array([\n            [-1.0, 0.0, 0.0 ],\n            [-1.0,-1.0,-1.0 ]\n        ])\n        # +1\n        a2 = np.array([\n            [ 1.0,-1.0,-1.0 ],\n            [ 1.0, 1.0, 1.0 ]\n        ])\n\n        # -1 to +1\n        result = aabb.create_from_aabbs(np.array([a1, a2]))\n        expected = np.array([\n            [-1.0,-1.0,-1.0 ],\n            [ 1.0, 1.0, 1.0 ]\n        ])\n\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_add_point(self):\n        obj = np.array([\n            [-1.0,-1.0,-1.0],\n            [-1.0,-1.0,-1.0]\n        ])\n        points = np.array([1.0, 1.0, 1.0])\n        result = aabb.add_points(obj, points)\n        expected = np.array([\n            [-1.0,-1.0,-1.0 ],\n            [ 1.0, 1.0, 1.0 ]\n        ])\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_add_aabbs(self):\n        a = aabb.create_zeros()\n\n        a1 = np.array([\n            [-1.0,-1.0,-1.0],\n            [ 1.0, 1.0, 1.0]\n        ])\n        result = aabb.add_aabbs(a, a1)\n        expected = np.array([\n            [-1.0,-1.0,-1.0],\n            [ 1.0, 1.0, 1.0]\n        ])\n        self.assertTrue(np.array_equal(result, expected))\n\n\n        a = np.array([\n            [-1.0,-1.0,-1.0],\n            [ 1.0, 1.0, 1.0]\n        ])\n        a2 = np.array([\n            [-1.0, 0.0,-1.0],\n            [ 2.0, 1.0, 1.0]\n        ])\n        result = aabb.add_aabbs(a, a2)\n        expected = np.array([\n            [-1.0,-1.0,-1.0],\n            [ 2.0, 1.0, 1.0]\n        ])\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_centre_point_single_point(self):\n        points = np.array([[-1.0,-1.0,-1.0]])\n        obj = aabb.create_from_points(points)\n        result = aabb.centre_point(obj)\n        expected = np.array([-1.0,-1.0,-1.0])\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_centre_point_multiple_points(self):\n        points = np.array([\n            [ 1.0, 1.0, 1.0],\n            [-1.0,-1.0,-1.0]\n        ])\n        obj = aabb.create_from_points(points)\n        result = aabb.centre_point(obj)\n        expected = np.zeros(3)\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_minimum(self):\n        a = aabb.create_from_bounds([-1,-1,-1],[1,1,1])\n        result = aabb.minimum(a)\n        self.assertTrue(np.array_equal(result, [-1,-1,-1]))\n\n    def test_maximum(self):\n        a = aabb.create_from_bounds([-1,-1,-1],[1,1,1])\n        result = aabb.maximum(a)\n        self.assertTrue(np.array_equal(result, [1,1,1]))\n\n    def test_clamp_points_single(self):\n        a = aabb.create_from_bounds([-1,-1,-1],[1,1,1])\n        points = np.array([2,1,1])\n        result = aabb.clamp_points(a, points)\n        expected = np.array([1,1,1])\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_clamp_points_list(self):\n        a = aabb.create_from_bounds([-1,-1,-1],[1,1,1])\n        points = np.array([\n            [1,1,1],\n            [2,1,1],\n            [-1,-1,-1],\n            [-2,-2,-2],\n        ])\n        result = aabb.clamp_points(a, points)\n        expected = np.array([[1,1,1],[1,1,1],[-1,-1,-1],[-1,-1,-1]])\n        self.assertTrue(np.array_equal(result, expected))\n\nif __name__ == '__main__':\n    unittest.main()\n\n"""
tests/test_aambb.py,18,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import aambb\nfrom pyrr import aabb\nfrom pyrr import vector\n\n\nclass test_aambb(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.aambb\n        from pyrr import aambb\n\n    def test_create_zeros(self):\n        result = aambb.create_zeros()\n        self.assertTrue(np.array_equal(result, [[0.,0.,0.],[0.,0.,0.]]))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_create_from_bounds(self):\n        bounds = [[-1.,1.,-1.], [2.,1.,0.]]\n        result = aambb.create_from_bounds(*bounds)\n        length = max(vector.length(bounds[0]), vector.length(bounds[1]))\n        self.assertTrue(np.array_equal(result, [[-length,-length,-length],[length,length,length]]))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_create_from_points(self):\n        result = aambb.create_from_points(np.array([[-1.0, 0.0, 0.0]]))\n        self.assertTrue(np.array_equal(result, [[-1.0,-1.0,-1.0],[ 1.0, 1.0, 1.0]]))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_center_point(self):\n        # this should always be 0,0,0\n        result = aambb.create_from_bounds([-1.,1.,-1.], [2.,1.,0.])\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_create_from_aabbs(self):\n        a1 = aambb.create_from_points([\n            [ 0.0, 0.0, 0.0],\n            [ 1.0, 1.0,-1.0]\n        ])\n        a2 = aambb.create_from_points([\n            [ 0.0, 0.0, 2.0],\n            [-1.0,-1.0, 1.0]\n        ])\n        result = aambb.create_from_aabbs([a1, a2])\n        length = np.amax(vector.length([a1, a2]))\n        self.assertTrue(np.array_equal(result, [[-length,-length,-length],[length,length,length]]), (result,))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_add_point(self):\n        a = aambb.create_from_bounds([-0.5,-0.5,-0.5], [0.5,0.5,0.5])\n        points = np.array([\n            [ 2.0,-1.0,-1.0],\n            [ 1.0, 3.0,-1.0],\n        ])\n        result = aambb.add_points(a, points)\n        length = np.amax(vector.length([a, points]))\n        self.assertTrue(np.array_equal(result, [[-length,-length,-length],[length,length,length]]), (result,))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n    def test_add_aabbs(self):\n        a1 = aambb.create_from_bounds([-0.5,-0.5,-0.5], [0.5,0.5,0.5])\n        a2 = aambb.create_from_bounds([1.0,-2.0, 1.0], [2.0,-1.0, 1.0])\n        result = aambb.add_aabbs(a1, [a2])\n        length = np.amax(vector.length([a1, a2]))\n        self.assertTrue(np.array_equal(result, [[-length,-length,-length],[length,length,length]]), (result,))\n        self.assertTrue(np.array_equal(aambb.centre_point(result), [0.0,0.0,0.0]))\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"""
tests/test_equivalence.py,18,"b'from __future__ import absolute_import, division, print_function\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import quaternion, matrix44, matrix33, euler\n\n\nclass test_matrix_quaternion(unittest.TestCase):\n    def test_m44_q_equivalence(self):\n        """"""Test for equivalance of matrix and quaternion rotations.\n\n        Create a matrix and quaternion, rotate each by the same values\n        then convert matrix<->quaternion and check the results are the same.\n        """"""\n        m = matrix44.create_from_x_rotation(np.pi / 2.)\n        mq = quaternion.create_from_matrix(m)\n\n        q = quaternion.create_from_x_rotation(np.pi / 2.)\n        qm = matrix44.create_from_quaternion(q)\n\n        self.assertTrue(np.allclose(np.dot([1., 0., 0., 1.], m), [1., 0., 0., 1.]))\n        self.assertTrue(np.allclose(np.dot([1., 0., 0., 1.], qm), [1., 0., 0., 1.]))\n\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0., 1.]), [1., 0., 0., 1.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(mq, [1., 0., 0., 1.]), [1., 0., 0., 1.]))\n\n        np.testing.assert_almost_equal(q, mq, decimal=5)\n        np.testing.assert_almost_equal(m, qm, decimal=5)\n\n    def test_euler_equivalence(self):\n        eulers = euler.create_from_x_rotation(np.pi / 2.)\n        m = matrix33.create_from_x_rotation(np.pi / 2.)\n        q = quaternion.create_from_x_rotation(np.pi / 2.)\n        qm = matrix33.create_from_quaternion(q)\n        em = matrix33.create_from_eulers(eulers)\n        self.assertTrue(np.allclose(qm, m))\n        self.assertTrue(np.allclose(qm, em))\n        self.assertTrue(np.allclose(m, em))\n\n    def test_quaternion_matrix_conversion(self):\n        # https://au.mathworks.com/help/robotics/ref/quat2rotm.html?requestedDomain=www.mathworks.com\n        q = quaternion.create(0.7071, 0., 0., 0.7071)\n        m33 = matrix33.create_from_quaternion(q)\n        expected = np.array([\n            [1., 0., 0.],\n            [0.,-0.,-1.],\n            [0., 1.,-0.],\n        ])\n        self.assertTrue(np.allclose(m33, expected))\n\n        # issue #42\n        q = quaternion.create(*[0.80087974, 0.03166748, 0.59114721,-0.09018753])\n        m33 = matrix33.create_from_quaternion(q)\n        q2 = quaternion.create_from_matrix(m33)\n        print(q, q2)\n        self.assertTrue(np.allclose(q, q2))\n\n        q3 = quaternion.create_from_matrix(m33.T)\n        self.assertFalse(np.allclose(q, q3))\n\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tests/test_euler.py,2,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import euler\n\n\nclass test_euler(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.euler\n        from pyrr import euler\n\n    def test_create(self):\n        self.assertTrue(np.array_equal(euler.create(), [0., 0., 0.]))\n        e = euler.create(roll=1., pitch=2., yaw=3.)\n        self.assertEqual(euler.roll(e), 1.)\n        self.assertEqual(euler.pitch(e), 2.)\n        self.assertEqual(euler.yaw(e), 3.)\n        self.assertTrue(np.array_equal(e, [1., 2., 3.]))\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_examples.py,1,"b'from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\n\n\nclass test_procedural_examples(unittest.TestCase):\n    def test_procedural_examples(self):\n        from pyrr import quaternion, matrix44, vector3\n        import numpy as np\n\n        point = vector3.create(1.,2.,3.)\n        orientation = quaternion.create()\n        translation = vector3.create()\n        scale = vector3.create(1,1,1)\n\n        # translate along X by 1\n        translation += [1.0, 0.0, 0.0]\n\n        # rotate about Y by pi/2\n        rotation = quaternion.create_from_y_rotation(np.pi / 2.0)\n        orientation = quaternion.cross(rotation, orientation)\n\n        # create a matrix\n        # start our matrix off using the scale\n        matrix = matrix44.create_from_scale(scale)\n\n        # apply our orientation\n        orientation = matrix44.create_from_quaternion(orientation)\n        matrix = matrix44.multiply(matrix, orientation)\n\n        # apply our translation\n        translation_matrix = matrix44.create_from_translation(translation)\n        matrix = matrix44.multiply(matrix, translation_matrix)\n\n        # transform our point by the matrix\n        point = matrix44.apply_to_vector(matrix, point)\n'"
tests/test_geometric_tests.py,65,"b""from pyrr.geometric_tests import ray_intersect_sphere\n\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import geometric_tests as gt\nfrom pyrr import line, plane, ray, sphere\n\n\nclass test_geometric_tests(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.geometric_tests\n        from pyrr import geometric_tests\n\n    def test_point_intersect_line(self):\n        p = np.array([1.,1.,1.])\n        l = np.array([[0.,0.,0.],[2.,2.,2.]])\n        result = gt.point_intersect_line(p, l)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_line_invalid(self):\n        p = np.array([3.,3.,3.])\n        l = np.array([[0.,0.,0.],[2.,2.,2.]])\n        result = gt.point_intersect_line(p, l)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_line_segment(self):\n        p = np.array([1.,1.,1.])\n        l = np.array([[0.,0.,0.],[2.,2.,2.]])\n        result = gt.point_intersect_line_segment(p, l)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_line_segment_invalid(self):\n        p = np.array([3.,3.,3.])\n        l = np.array([[0.,0.,0.],[2.,2.,2.]])\n        result = gt.point_intersect_line_segment(p, l)\n        self.assertEqual(result, None)\n\n    def test_point_intersect_rectangle_valid_intersections_1(self):\n        r = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n        p = [ 0.0, 0.0]\n        result = gt.point_intersect_rectangle(p, r)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_rectangle_valid_intersections_2(self):\n        r = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n        p = [ 5.0, 5.0]\n        result = gt.point_intersect_rectangle(p, r)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_rectangle_valid_intersections_3(self):\n        r = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n        p = [ 1.0, 1.0]\n        result = gt.point_intersect_rectangle(p, r)\n        self.assertTrue(np.array_equal(result, p))\n\n    def test_point_intersect_rectangle_invalid_intersections_1(self):\n        r = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n\n        p = [-1.0, 1.0]\n        result = gt.point_intersect_rectangle(p, r)\n        self.assertFalse(np.array_equal(result, p))\n\n    def test_point_intersect_rectangle_invalid_intersections_2(self):\n        r = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n        p = [ 1.0, 10.0]\n        result = gt.point_intersect_rectangle(p, r)\n        self.assertFalse(np.array_equal(result, p))\n\n    def test_point_intersect_rectangle_invalid_intersections_3(self):\n        rect = np.array([\n            [0.0, 0.0],\n            [5.0, 5.0]\n        ])\n        point = [ 1.0,-1.0]\n        result = gt.point_intersect_rectangle(point, rect)\n        self.assertFalse(np.array_equal(result, point))\n\n    def test_ray_intersect_plane(self):\n        r = ray.create([0.,-1.,0.],[0.,1.,0.])\n        p = plane.create([0.,1.,0.], 0.)\n        result = gt.ray_intersect_plane(r, p)\n        self.assertFalse(np.array_equal(result, [0.,1.,0.]))\n\n    def test_ray_intersect_plane_front_only(self):\n        r = ray.create([0.,-1.,0.],[0.,1.,0.])\n        p = plane.create([0.,1.,0.], 0.)\n        result = gt.ray_intersect_plane(r, p, front_only=True)\n        self.assertEqual(result, None)\n\n    def test_ray_intersect_plane_invalid(self):\n        r = ray.create([0.,-1.,0.],[1.,0.,0.])\n        p = plane.create([0.,1.,0.], 0.)\n        result = gt.ray_intersect_plane(r, p)\n        self.assertEqual(result, None)\n\n    def test_point_closest_point_on_ray(self):\n        l = line.create_from_points(\n            [ 0.0, 0.0, 0.0 ],\n            [10.0, 0.0, 0.0 ]\n        )\n        p = np.array([ 0.0, 1.0, 0.0])\n        result = gt.point_closest_point_on_ray(p, l)\n        self.assertTrue(np.array_equal(result, [ 0.0, 0.0, 0.0]))\n\n    def test_point_closest_point_on_line(self):\n        p = np.array([0.,1.,0.])\n        l = np.array([[0.,0.,0.],[2.,0.,0.]])\n        result = gt.point_closest_point_on_line(p, l)\n        self.assertTrue(np.array_equal(result, [0.,0.,0.]), (result,))\n\n    def test_point_closest_point_on_line_2(self):\n        p = np.array([3.,0.,0.])\n        l = np.array([[0.,0.,0.],[2.,0.,0.]])\n        result = gt.point_closest_point_on_line(p, l)\n        self.assertTrue(np.array_equal(result, [3.,0.,0.]), (result,))\n\n    def test_point_closest_point_on_line_segment(self):\n        p = np.array([0.,1.,0.])\n        l = np.array([[0.,0.,0.],[2.,0.,0.]])\n        result = gt.point_closest_point_on_line_segment(p, l)\n        self.assertTrue(np.array_equal(result, [0.,0.,0.]), (result,))\n\n    def test_vector_parallel_vector(self):\n        v1 = np.array([1.,0.,0.])\n        v2 = np.array([2.,0.,0.])\n        self.assertTrue(gt.vector_parallel_vector(v1,v2))\n\n    def test_vector_parallel_vector_invalid(self):\n        v1 = np.array([1.,0.,0.])\n        v2 = np.array([0.,1.,0.])\n        self.assertTrue(False == gt.vector_parallel_vector(v1,v2))\n\n    def test_ray_parallel_ray(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([1.,0.,0.],[2.,0.,0.])\n        self.assertTrue(gt.ray_parallel_ray(r1,r2))\n\n    def test_ray_parallel_ray_2(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([1.,0.,0.],[0.,1.,0.])\n        self.assertTrue(False == gt.ray_parallel_ray(r1,r2))\n\n    def test_ray_parallel_ray_3(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([0.,1.,0.],[1.,0.,0.])\n        self.assertTrue(gt.ray_parallel_ray(r1,r2))\n\n    def test_ray_coincident_ray(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([1.,0.,0.],[2.,0.,0.])\n        self.assertTrue(gt.ray_coincident_ray(r1,r2))\n\n    def test_ray_coincident_ray_2(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([1.,0.,0.],[0.,1.,0.])\n        self.assertTrue(False == gt.ray_coincident_ray(r1,r2))\n\n    def test_ray_coincident_ray_3(self):\n        r1 = ray.create([0.,0.,0.],[1.,0.,0.])\n        r2 = ray.create([0.,1.,0.],[1.,0.,0.])\n        self.assertTrue(False == gt.ray_coincident_ray(r1,r2))\n\n    def test_ray_intersect_aabb_valid_1(self):\n        a = np.array([[-1.0,-1.0,-1.0], [ 1.0, 1.0, 1.0]])\n        r = np.array([[ 0.5, 0.5, 0.0], [ 0.0, 0.0,-1.0]])\n        result = gt.ray_intersect_aabb(r, a)\n        self.assertTrue(np.array_equal(result, [ 0.5, 0.5,-1.0]))\n\n    def test_ray_intersect_aabb_valid_2(self):\n        a = np.array([[-1.0,-1.0,-1.0], [ 1.0, 1.0, 1.0]])\n        r = np.array([[2.0, 2.0, 2.0], [ -1.0, -1.0, -1.0]])\n        result = gt.ray_intersect_aabb(r, a)\n        self.assertTrue(np.array_equal(result, [1.0, 1.0, 1.0]))\n\n    def test_ray_intersect_aabb_valid_3(self):\n        a = np.array([[-1.0, -1.0, -1.0], [1.0, 1.0, 1.0]])\n        r = np.array([[.5, .5, .5], [0, 0, 1.0]])\n        result = gt.ray_intersect_aabb(r, a)\n        self.assertTrue(np.array_equal(result, [.5, .5, 1.0]))\n\n    def test_ray_intersect_aabb_invalid_1(self):\n        a = np.array([[-1.0,-1.0,-1.0], [ 1.0, 1.0, 1.0]])\n        r = np.array([[2.0, 2.0, 2.0], [ 1.0, 1.0, 1.0]])\n        result = gt.ray_intersect_aabb(r, a)\n        self.assertEqual(result, None)\n\n    def test_point_height_above_plane(self):\n        pl = plane.create([0., 1., 0.], 1.)\n        p = np.array([0., 1., 0.])\n        result = gt.point_height_above_plane(p, pl)\n        self.assertEqual(result, 0.)\n\n        p = np.array([0., 0., 0.])\n        result = gt.point_height_above_plane(p, pl)\n        self.assertEqual(result, -1.)\n\n        v1 = np.array([ 0.0, 0.0, 1.0])\n        v2 = np.array([ 1.0, 0.0, 1.0])\n        v3 = np.array([ 0.0, 1.0, 1.0])\n        p = np.array([0.0, 0.0, 20.0])\n\n        pl = plane.create_from_points(v1, v2, v3)\n        pl = plane.invert_normal(pl)\n\n        result = gt.point_height_above_plane(p, pl)\n        self.assertEqual(result, 19.)\n\n        pl = plane.create_xz(distance=5.)\n        p = np.array([0., 5., 0.])\n        h = gt.point_height_above_plane(p, pl)\n        self.assertEqual(h, 0.)\n\n    def test_point_closest_point_on_plane(self):\n        pl = np.array([ 0.0, 1.0, 0.0, 0.0])\n        p = np.array([ 5.0, 20.0, 5.0])\n        result = gt.point_closest_point_on_plane(p, pl)\n        self.assertTrue(np.array_equal(result, [ 5.0, 0.0, 5.0]))\n\n    def test_sphere_does_intersect_sphere_1(self):\n        s1 = sphere.create()\n        s2 = sphere.create()\n        self.assertTrue(gt.sphere_does_intersect_sphere(s1, s2))\n\n    def test_sphere_does_intersect_sphere_2(self):\n        s1 = sphere.create()\n        s2 = sphere.create([1.,0.,0.])\n        self.assertTrue(gt.sphere_does_intersect_sphere(s1, s2))\n\n    def test_sphere_does_intersect_sphere_3(self):\n        s1 = sphere.create()\n        s2 = sphere.create([2.,0.,0.], 1.0)\n        self.assertTrue(gt.sphere_does_intersect_sphere(s1, s2))\n\n    def test_sphere_does_intersect_sphere_4(self):\n        s1 = sphere.create()\n        s2 = sphere.create([2.,0.,0.], 0.5)\n        self.assertTrue(False == gt.sphere_does_intersect_sphere(s1, s2))\n\n    def test_sphere_penetration_sphere_1(self):\n        s1 = sphere.create()\n        s2 = sphere.create()\n        self.assertEqual(gt.sphere_penetration_sphere(s1, s2), 2.0)\n\n    def test_sphere_penetration_sphere_2(self):\n        s1 = sphere.create()\n        s2 = sphere.create([1.,0.,0.], 1.0)\n        self.assertEqual(gt.sphere_penetration_sphere(s1, s2), 1.0)\n\n    def test_sphere_penetration_sphere_3(self):\n        s1 = sphere.create()\n        s2 = sphere.create([2.,0.,0.], 1.0)\n        self.assertEqual(gt.sphere_penetration_sphere(s1, s2), 0.0)\n\n    def test_sphere_penetration_sphere_4(self):\n        s1 = sphere.create()\n        s2 = sphere.create([3.,0.,0.], 1.0)\n        self.assertEqual(gt.sphere_penetration_sphere(s1, s2), 0.0)\n\n    def test_ray_intersect_sphere_no_solution_1(self):\n        r = ray.create([0, 2, 0], [1, 0, 0])\n        s = sphere.create([0, 0, 0], 1)\n        intersections = ray_intersect_sphere(r, s)\n        self.assertEqual(len(intersections), 0)\n\n    def test_ray_intersect_sphere_no_solution_2(self):\n        r = ray.create([0, 0, 0], [1, 0, 0])\n        s = sphere.create([0, 2, 0], 1)\n        intersections = ray_intersect_sphere(r, s)\n        self.assertEqual(len(intersections), 0)\n\n    def test_ray_intersect_sphere_one_solution_1(self):\n        r = ray.create([0, 0, 0], [1, 0, 0])\n        s = sphere.create([0, 0, 0], 1)\n        intersections = ray_intersect_sphere(r, s)\n        self.assertEqual(len(intersections), 1)\n        np.testing.assert_array_almost_equal(intersections[0], np.array([1, 0, 0]), decimal=2)\n\n    def test_ray_intersect_sphere_two_solutions_1(self):\n        r = ray.create([-2, 0, 0], [1, 0, 0])\n        s = sphere.create([0, 0, 0], 1)\n        intersections = ray_intersect_sphere(r, s)\n        self.assertEqual(len(intersections), 2)\n        np.testing.assert_array_almost_equal(intersections[0], np.array([1, 0, 0]), decimal=2)\n        np.testing.assert_array_almost_equal(intersections[1], np.array([-1, 0, 0]), decimal=2)\n\n    def test_ray_intersect_sphere_two_solutions_2(self):\n        r = ray.create([2.48, 1.45, 1.78], [-3.1, 0.48, -3.2])\n        s = sphere.create([1, 1, 0], 1)\n        intersections = ray_intersect_sphere(r, s)\n        self.assertEqual(len(intersections), 2)\n        np.testing.assert_array_almost_equal(intersections[0], np.array([0.44, 1.77, -0.32]), decimal=2)\n        np.testing.assert_array_almost_equal(intersections[1], np.array([1.41, 1.62, 0.67]), decimal=2)\n\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_geometry.py,28,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import geometry\n\n# TODO: test all combinations of st, rgba, and type\n\nclass test_geometry(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.geometry\n        from pyrr import geometry\n\n    def test_create_quad(self):\n        v, i = geometry.create_quad()\n        expected_v = np.array([\n            [ 0.5, 0.5, 0.],\n            [-0.5, 0.5, 0.],\n            [-0.5,-0.5, 0.],\n            [ 0.5,-0.5, 0.],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_quad_scale(self):\n        v, i = geometry.create_quad((2.0,0.5))\n        expected_v = np.array([\n            [ 1., 0.25, 0.],\n            [-1., 0.25, 0.],\n            [-1.,-0.25, 0.],\n            [ 1.,-0.25, 0.],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_quad_st(self):\n        v, i = geometry.create_quad(st=True)\n        expected_v = np.array([\n            [ 0.5, 0.5, 0., 1., 1.],\n            [-0.5, 0.5, 0., 0., 1.],\n            [-0.5,-0.5, 0., 0., 0.],\n            [ 0.5,-0.5, 0., 1., 0.],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_quad_st_values(self):\n        v, i = geometry.create_quad(st=((0.1,0.2),(0.3,0.4)))\n        expected_v = np.array([\n            [ 0.5, 0.5, 0., 0.3, 0.4],\n            [-0.5, 0.5, 0., 0.1, 0.4],\n            [-0.5,-0.5, 0., 0.1, 0.2],\n            [ 0.5,-0.5, 0., 0.3, 0.2],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_quad_rgba(self):\n        v, i = geometry.create_quad(rgba=True)\n        expected_v = np.array([\n            [ 0.5, 0.5, 0., 1., 1., 1., 1.],\n            [-0.5, 0.5, 0., 1., 1., 1., 1.],\n            [-0.5,-0.5, 0., 1., 1., 1., 1.],\n            [ 0.5,-0.5, 0., 1., 1., 1., 1.],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_quad_rgba_values(self):\n        v, i = geometry.create_quad(rgba=((0.1,0.2,0.3,0.4),(0.5,0.6,0.7,0.8),(0.9,1.0,1.1,1.2),(1.3,1.4,1.5,1.6)))\n        expected_v = np.array([\n            [ 0.5, 0.5, 0., .1, .2, .3, .4],\n            [-0.5, 0.5, 0., .5, .6, .7, .8],\n            [-0.5,-0.5, 0., .9, 1., 1.1, 1.2],\n            [ 0.5,-0.5, 0., 1.3, 1.4, 1.5, 1.6],\n        ])\n        expected_i = np.array([0,1,2,0,2,3])\n        self.assertTrue(np.allclose(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i))\n\n    def test_create_cube(self):\n        v, i = geometry.create_cube()\n        expected_v = np.array([\n            [ 0.5,  0.5,  0.5],\n            [-0.5,  0.5,  0.5],\n            [-0.5, -0.5,  0.5],\n            [ 0.5, -0.5,  0.5],\n            [ 0.5,  0.5, -0.5],\n            [ 0.5,  0.5,  0.5],\n            [ 0.5, -0.5,  0.5],\n            [ 0.5, -0.5, -0.5],\n            [-0.5,  0.5, -0.5],\n            [ 0.5,  0.5, -0.5],\n            [ 0.5, -0.5, -0.5],\n            [-0.5, -0.5, -0.5],\n            [-0.5,  0.5,  0.5],\n            [-0.5,  0.5, -0.5],\n            [-0.5, -0.5, -0.5],\n            [-0.5, -0.5,  0.5],\n            [ 0.5,  0.5, -0.5],\n            [-0.5,  0.5, -0.5],\n            [-0.5,  0.5,  0.5],\n            [ 0.5,  0.5,  0.5],\n            [ 0.5, -0.5,  0.5],\n            [-0.5, -0.5,  0.5],\n            [-0.5, -0.5, -0.5],\n            [ 0.5, -0.5, -0.5]\n        ])\n        expected_i = np.array([\n            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n            14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n        ])\n        self.assertTrue(np.array_equal(v, expected_v), (v,))\n        self.assertTrue(np.array_equal(i, expected_i), (i,))\n\nif __name__ == '__main__':\n    unittest.main()\n\n"""
tests/test_integer.py,0,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nfrom pyrr import integer\n\nclass test_integer(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.integer\n        from pyrr import integer\n\n    def test_count_bits(self):\n        i = 0b010101\n        self.assertEqual(integer.count_bits(i), 3)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_line.py,5,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import line, ray\n\nclass test_line(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.line\n        from pyrr import line\n\n    def test_create_zeros(self):\n        result = line.create_zeros()\n        self.assertTrue(np.allclose(result, [[0,0,0],[0,0,0]]))\n\n    def test_create_from_points(self):\n        result = line.create_from_points([-1.,0.,0.],[1.,0.,0.])\n        self.assertTrue(np.allclose(result, [[-1,0,0],[1,0,0]]))\n\n    def test_create_from_ray(self):\n        r = ray.create([0.,0.,0.], [1., 0.,0.])\n        result = line.create_from_ray(r)\n        self.assertTrue(np.allclose(result, [[0,0,0],[1,0,0]]))\n\n    def test_start(self):\n        l = line.create_from_points([-1.,0.,0.],[1.,0.,0.])\n        result = line.start(l)\n        self.assertTrue(np.allclose(result, [-1,0,0]))\n\n    def test_end(self):\n        l = line.create_from_points([-1.,0.,0.],[1.,0.,0.])\n        result = line.end(l)\n        self.assertTrue(np.allclose(result, [1,0,0]))\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_matrix33.py,68,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import matrix33, quaternion, vector3\n\n\nclass test_matrix33(unittest.TestCase):\n    # use wolfram alpha to get information on quaternion conversion values\n    # be aware that wolfram lists it as w,x,y,z\n    def test_import(self):\n        import pyrr\n        pyrr.matrix33\n        from pyrr import matrix33\n\n    def test_create_from_quaternion_unit(self):\n        result = matrix33.create_from_quaternion([0.,0.,0.,1.])\n        np.testing.assert_almost_equal(result, np.eye(3), decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_x(self):\n        result = matrix33.create_from_quaternion([1.,0.,0.,0.])\n        expected = [\n            [1.,0.,0.],\n            [0.,-1.,0.],\n            [0.,0.,-1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_y(self):\n        result = matrix33.create_from_quaternion([0.,1.,0.,0.])\n        expected = [\n            [-1.,0.,0.],\n            [0.,1.,0.],\n            [0.,0.,-1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_z(self):\n        result = matrix33.create_from_quaternion([0.,0.,1.,0.])\n        expected = [\n            [-1.,0.,0.],\n            [0.,-1.,0.],\n            [0.,0.,1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_rotation(self):\n        result = matrix33.create_from_quaternion([.57735,.57735,.57735,0.])\n        expected = [\n            [-0.333333, 0.666667, 0.666667],\n            [0.666667, -0.333333, 0.666667],\n            [0.666667, 0.666667, -0.333333],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_equivalent(self):\n        result = matrix33.create_from_quaternion(quaternion.create_from_x_rotation(0.5))\n        expected = matrix33.create_from_x_rotation(0.5)\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_inverse_equivalence(self):\n        q = [5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17]\n        result = matrix33.create_from_quaternion(quaternion.inverse(q))\n        expected = matrix33.inverse(matrix33.create_from_quaternion(q))\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n        q = quaternion.create_from_x_rotation(0.5)\n        result = matrix33.create_from_inverse_of_quaternion(q)\n        expected = matrix33.inverse(matrix33.create_from_quaternion(q))\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_create_from_inverse_of_quaternion(self):\n        q = quaternion.create_from_x_rotation(np.pi / 2.0)\n        result = matrix33.create_from_inverse_of_quaternion(q)\n        self.assertTrue(np.allclose(result, matrix33.create_from_x_rotation(-np.pi / 2.0)))\n\n    def test_create_identity(self):\n        result = matrix33.create_identity()\n        np.testing.assert_almost_equal(result, np.eye(3), decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def create_from_matrix44(self):\n        m44 = np.arange((4,4))\n        result = matrix33.create_from_matrix44(m44)\n        self.assertTrue(np.allclose(result, m44[:3][:3]))\n\n    @unittest.skip('Not implemented')\n    def test_create_from_eulers(self):\n        # just call the function\n        # TODO: check the result\n        matrix33.create_from_eulers([1,2,3])\n\n    def test_create_from_axis_rotation(self):\n        # wolfram alpha can be awesome sometimes\n        result = matrix33.create_from_axis_rotation([0.57735, 0.57735, 0.57735],np.pi)\n        np.testing.assert_almost_equal(result, matrix33.create_from_quaternion([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17]), decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_axis_rotation_non_normalized(self):\n        result = matrix33.create_from_axis_rotation([1.,1.,1.], np.pi)\n        np.testing.assert_almost_equal(result, matrix33.create_from_quaternion([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17]), decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_x_rotation(self):\n        mat = matrix33.create_from_x_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.], mat), [1.,0.,0.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.], mat), [0.,0.,-1.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.], mat), [0.,1.,0.]))\n\n    def test_create_from_y_rotation(self):\n        mat = matrix33.create_from_y_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.], mat), [0.,0.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.], mat), [0.,1.,0.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.], mat), [-1.,0.,0.]))\n\n    def test_create_from_z_rotation(self):\n        mat = matrix33.create_from_z_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.], mat), [0.,-1.,0.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.], mat), [1.,0.,0.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.], mat), [0.,0.,1.]))\n\n    def test_create_from_scale(self):\n        scale = np.array([ 2.0, 3.0, 4.0])\n        mat = matrix33.create_from_scale(scale)\n        result = mat.diagonal()\n        expected = scale\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_create_from_quaternion_identity(self):\n        quat = quaternion.create()\n        result = matrix33.create_from_quaternion(quat)\n        expected = np.eye(3)\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_create_from_quaternion_rotated_x(self):\n        quat = quaternion.create_from_x_rotation(np.pi)\n        result = matrix33.create_from_quaternion(quat)\n        expected = matrix33.create_from_x_rotation(np.pi)\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_create_from_quaternion_rotated_y(self):\n        quat = quaternion.create_from_y_rotation(np.pi)\n        result = matrix33.create_from_quaternion(quat)\n        expected = matrix33.create_from_y_rotation(np.pi)\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_create_from_quaternion_rotated_z(self):\n        quat = quaternion.create_from_z_rotation(np.pi)\n        result = matrix33.create_from_quaternion(quat)\n        expected = matrix33.create_from_z_rotation(np.pi)\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_apply_to_vector_identity(self):\n        mat = matrix33.create_identity()\n        vec = vector3.unit.x\n        result = matrix33.apply_to_vector(mat, vec)\n        expected = vec\n        self.assertTrue(np.array_equal(result, expected))\n\n    def test_apply_to_vector_rotated_x(self):\n        mat = matrix33.create_from_x_rotation(np.pi)\n        vec = vector3.unit.y\n        result = matrix33.apply_to_vector(mat, vec)\n        expected = -vec\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_apply_to_vector_rotated_y(self):\n        mat = matrix33.create_from_y_rotation(np.pi)\n        vec = vector3.unit.x\n        result = matrix33.apply_to_vector(mat, vec)\n        expected = -vec\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_apply_to_vector_rotated_z(self):\n        mat = matrix33.create_from_z_rotation(np.pi)\n        vec = vector3.unit.x\n        result = matrix33.apply_to_vector(mat, vec)\n        expected = -vec\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_multiply_identity(self):\n        m1 = matrix33.create_identity()\n        m2 = matrix33.create_identity()\n        result = matrix33.multiply(m1, m2)\n        self.assertTrue(np.allclose(result, np.dot(m1,m2)))\n\n    def test_multiply_rotation(self):\n        m1 = matrix33.create_from_x_rotation(np.pi)\n        m2 = matrix33.create_from_y_rotation(np.pi / 2.0)\n        result = matrix33.multiply(m1, m2)\n        self.assertTrue(np.allclose(result, np.dot(m1,m2)))\n\n    def test_inverse(self):\n        m = matrix33.create_from_y_rotation(np.pi)\n        result = matrix33.inverse(m)\n        self.assertTrue(np.allclose(result, matrix33.create_from_y_rotation(-np.pi)))\n\n    def test_create_direction_scale(self):\n        m = matrix33.create_direction_scale([0.,1.,0.], 0.5)\n        v = np.array([\n            [1.,0.,0.],\n            [1.,1.,1.],\n            [10.,10.,10.]\n        ])\n        result = np.array([\n            matrix33.apply_to_vector(m, v[0]),\n            matrix33.apply_to_vector(m, v[1]),\n            matrix33.apply_to_vector(m, v[2]),\n        ])\n        expected = np.array([\n            [1.,0.,0.],\n            [1.,.5,1.],\n            [10.,5.,10.]\n        ])\n        self.assertTrue(np.allclose(result, expected))\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_matrix44.py,168,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import matrix44, quaternion, vector3\n\n\nclass test_matrix44(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.matrix44\n        from pyrr import matrix44\n\n    def test_create_identity(self):\n        result = matrix44.create_identity()\n        np.testing.assert_almost_equal(result, np.eye(4), decimal=5)\n\n    def test_create_from_quaternion_unit(self):\n        result = matrix44.create_from_quaternion([0.,0.,0.,1.])\n        np.testing.assert_almost_equal(result, np.eye(4), decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_x(self):\n        result = matrix44.create_from_quaternion([1.,0.,0.,0.])\n        expected = [\n            [1.,0.,0.,0.],\n            [0.,-1.,0.,0.],\n            [0.,0.,-1.,0.],\n            [0.,0.,0.,1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_y(self):\n        result = matrix44.create_from_quaternion([0.,1.,0.,0.])\n        expected = [\n            [-1.,0.,0.,0.],\n            [0.,1.,0.,0.],\n            [0.,0.,-1.,0.],\n            [0.,0.,0.,1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_z(self):\n        result = matrix44.create_from_quaternion([0.,0.,1.,0.])\n        expected = [\n            [-1.,0.,0.,0.],\n            [0.,-1.,0.,0.],\n            [0.,0.,1.,0.],\n            [0.,0.,0.,1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_quaternion_rotation(self):\n        result = matrix44.create_from_quaternion([.57735,.57735,.57735,0.])\n        expected = [\n            [-0.333333, 0.666667, 0.666667,0.],\n            [0.666667, -0.333333, 0.666667,0.],\n            [0.666667, 0.666667, -0.333333,0.],\n            [0.,0.,0.,1.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_axis_rotation(self):\n        # wolfram alpha can be awesome sometimes\n        result = matrix44.create_from_axis_rotation([0.57735, 0.57735, 0.57735],np.pi)\n        np.testing.assert_almost_equal(result, matrix44.create_from_quaternion([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17]), decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_axis_rotation_non_normalized(self):\n        result = matrix44.create_from_axis_rotation([1.,1.,1.], np.pi)\n        np.testing.assert_almost_equal(result, matrix44.create_from_quaternion([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17]), decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_inverse_of_quaternion(self):\n        q = quaternion.create_from_x_rotation(np.pi / 2.0)\n        result = matrix44.create_from_inverse_of_quaternion(q)\n        self.assertTrue(np.allclose(result, matrix44.create_from_x_rotation(-np.pi / 2.0)))\n\n    def test_create_from_translation( self ):\n        result = matrix44.create_from_translation([2.,3.,4.])\n        expected = np.eye(4)\n        expected[3,:3] = [2.,3.,4.]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_create_from_scale( self ):\n        result = matrix44.create_from_scale([2.,3.,4.])\n        np.testing.assert_almost_equal(result.diagonal()[:-1], [2.,3.,4.], decimal=5)\n\n    def test_create_matrix33_view( self ):\n        mat = matrix44.create_identity()\n        result = matrix44.create_matrix33_view(mat)\n        np.testing.assert_almost_equal(result, mat[:3,:3], decimal=5)\n        mat[0,0] = 2.\n        np.testing.assert_almost_equal(result, mat[:3,:3], decimal=5)\n\n    def test_create_from_matrix33( self ):\n        mat = np.array([\n            [1.,2.,3.],\n            [3.,4.,5.],\n            [6.,7.,8.]\n        ])\n        result = matrix44.create_from_matrix33(mat)\n        np.testing.assert_almost_equal(result[:3,:3], mat, decimal=5)\n        orig = mat.copy()\n        mat[0,0] = 2.\n        np.testing.assert_almost_equal(result[:3,:3], orig, decimal=5)\n\n    def test_create_perspective_projection_matrix_vector3(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            self.assertTrue(inside == (np.amax(np.absolute(p)) <= 1.), (inside, point, p))\n\n        m = matrix44.create_perspective_projection_matrix(90, 1024./768., 1., 10.)\n\n        apply_test(m, np.array((0.,0.,0.)), False)\n        apply_test(m, np.array((0.,0.,-.5)), False)\n        apply_test(m, np.array((0.,0.,-1.)), True)\n        apply_test(m, np.array((0.,0.,-2.)), True)\n        apply_test(m, np.array((0.,0.,-9.)), True)\n        apply_test(m, np.array((0.,0.,-11.)), False)\n        apply_test(m, np.array((1.,1.,-5.)), True)\n\n    def test_create_perspective_projection_matrix_dtype(self):\n        m1 = matrix44.create_perspective_projection_matrix(90, 1024./768., 1., 10., dtype='float32')\n        m2 = matrix44.create_perspective_projection_matrix(90, 1024./768., 1., 10., dtype='float64')\n        self.assertEqual(m1.dtype, np.float32)\n        self.assertEqual(m2.dtype, np.float64)\n\n    def test_create_perspective_projection_matrix_vector4_inside(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n            if np.allclose(p[3], 0.):\n                self.assertFalse(inside)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            if np.allclose(p[3],0.):\n                p[:] = [np.inf,np.inf,np.inf,np.inf]\n            else:\n                p[:3] /= p[3]\n            self.assertTrue(inside == (np.amax(np.absolute(p[:3])) <= 1.), (inside, point, p))\n\n        m = matrix44.create_perspective_projection_matrix(90, 1024./768., 1., 10.)\n        apply_test(m, np.array((0.,0.,0.,1.)), False)\n        apply_test(m, np.array((0.,0.,-.5,1.)), False)\n        apply_test(m, np.array((0.,0.,-1.,1.)), True)\n        apply_test(m, np.array((0.,0.,-2.,1.)), True)\n        apply_test(m, np.array((0.,0.,-9.,1.)), True)\n        apply_test(m, np.array((0.,0.,-11.,1.)), False)\n        apply_test(m, np.array((1.,1.,-5.,1.)), True)\n\n    def test_create_orthogonal_projection_matrix_vector3(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            self.assertTrue(inside == (np.amax(np.absolute(p[:3])) <= 1.), (inside, point, p))\n\n        m = matrix44.create_orthogonal_projection_matrix(-1., 1., -1., 1., 1., 10.)\n\n        # +Z\n        apply_test(m, np.array((0.,0.,0.)), False)\n        apply_test(m, np.array((0.,0.,1.)), False)\n        # -Z but outside near, far\n        apply_test(m, np.array((0.,0.,-.5)), False)\n        apply_test(m, np.array((0.,0.,-11.)), False)\n        apply_test(m, np.array((0.,0.,1.)), False)\n        # Valid\n        apply_test(m, np.array((0.,0.,-10.)), True)\n        apply_test(m, np.array((0.,0.,-1.)), True)\n        apply_test(m, np.array((0.,0.,-2.)), True)\n        apply_test(m, np.array((0.,0.,-9.)), True)\n        apply_test(m, np.array((-1.,-1.,-1.)), True)\n        apply_test(m, np.array((-1.,-1.,-10.)), True)\n        apply_test(m, np.array((1.,1.,-1.)), True)\n        apply_test(m, np.array((1.,1.,-10.)), True)\n        # Outside left, right, top, bottom\n        apply_test(m, np.array((1.1,1.1,-1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-1.)), False)\n        apply_test(m, np.array((1.1,1.1,-10.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-10.)), False)\n\n\n    def test_create_orthogonal_projection_matrix_vector4(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n            if p[3] == 0.:\n                self.assertFalse(inside)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            self.assertTrue(inside == (np.amax(np.absolute(p[:3])) <= 1.), (inside, point, p))\n\n        m = matrix44.create_orthogonal_projection_matrix(-1., 1., -1., 1., 1., 10.)\n\n        # +Z\n        apply_test(m, np.array((0.,0.,0.,1.)), False)\n        apply_test(m, np.array((0.,0.,1.,1.)), False)\n        # -Z but outside near, far\n        apply_test(m, np.array((0.,0.,-.5,1.)), False)\n        apply_test(m, np.array((0.,0.,-11.,1.)), False)\n        apply_test(m, np.array((0.,0.,1.,1.)), False)\n        # Valid\n        apply_test(m, np.array((0.,0.,-10.,1.)), True)\n        apply_test(m, np.array((0.,0.,-1.,1.)), True)\n        apply_test(m, np.array((0.,0.,-2.,1.)), True)\n        apply_test(m, np.array((0.,0.,-9.,1.)), True)\n        apply_test(m, np.array((-1.,-1.,-1.,1.)), True)\n        apply_test(m, np.array((-1.,-1.,-10.,1.)), True)\n        apply_test(m, np.array((1.,1.,-1.,1.)), True)\n        apply_test(m, np.array((1.,1.,-10.,1.)), True)\n        # Outside left, right, top, bottom\n        apply_test(m, np.array((1.1,1.1,-1.,1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-1.,1.)), False)\n        apply_test(m, np.array((1.1,1.1,-10.,1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-10.,1.)), False)\n\n    def create_perspective_projection_matrix_from_bounds_vector3(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            self.assertTrue(inside == (np.amax(np.absolute(p[:3])) <= 1.), (inside, point, p))\n\n        m = matrix44.create_perspective_projection_matrix_from_bounds(-1.,1.,-1.,1.,1.,10.)\n\n        # +Z\n        apply_test(m, np.array((0.,0.,0.)), False)\n        apply_test(m, np.array((0.,0.,1.)), False)\n        # -Z but outside near, far\n        apply_test(m, np.array((0.,0.,-.5)), False)\n        apply_test(m, np.array((0.,0.,-11.)), False)\n        apply_test(m, np.array((0.,0.,1.)), False)\n        # Valid\n        apply_test(m, np.array((0.,0.,-10.)), True)\n        apply_test(m, np.array((0.,0.,-1.)), True)\n        apply_test(m, np.array((0.,0.,-2.)), True)\n        apply_test(m, np.array((0.,0.,-9.)), True)\n        apply_test(m, np.array((-1.,-1.,-1.)), True)\n        apply_test(m, np.array((-1.,-1.,-10.)), True)\n        apply_test(m, np.array((1.,1.,-1.)), True)\n        apply_test(m, np.array((1.,1.,-10.)), True)\n        # Outside left, right, top, bottom\n        apply_test(m, np.array((1.1,1.1,-1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-1.)), False)\n        apply_test(m, np.array((1.1,1.1,-10.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-10.)), False)\n\n    def create_perspective_projection_matrix_from_bounds_vector4(self):\n        def apply_test(m, point, inside):\n            p = matrix44.apply_to_vector(m, point)\n            if p[3] == 0.:\n                self.assertFalse(inside)\n\n            # the values are now in clip space from (-1.,-1.,-1.) -> (1.,1.,1.)\n            # to be inside = all(-1. < value < 1.)\n            self.assertTrue(inside == (np.amax(np.absolute(p[:3])) <= 1.), (inside, point, p))\n\n        m = matrix44.create_perspective_projection_matrix_from_bounds(-1.,1.,-1.,1.,1.,10.)\n\n        # +Z\n        apply_test(m, np.array((0.,0.,0.,1.)), False)\n        apply_test(m, np.array((0.,0.,1.,1.)), False)\n        # -Z but outside near, far\n        apply_test(m, np.array((0.,0.,-.5,1.)), False)\n        apply_test(m, np.array((0.,0.,-11.,1.)), False)\n        apply_test(m, np.array((0.,0.,1.,1.)), False)\n        # Valid\n        apply_test(m, np.array((0.,0.,-10.,1.)), True)\n        apply_test(m, np.array((0.,0.,-1.,1.)), True)\n        apply_test(m, np.array((0.,0.,-2.,1.)), True)\n        apply_test(m, np.array((0.,0.,-9.,1.)), True)\n        apply_test(m, np.array((-1.,-1.,-1.,1.)), True)\n        apply_test(m, np.array((-1.,-1.,-10.,1.)), True)\n        apply_test(m, np.array((1.,1.,-1.,1.)), True)\n        apply_test(m, np.array((1.,1.,-10.,1.)), True)\n        # Outside left, right, top, bottom\n        apply_test(m, np.array((1.1,1.1,-1.,1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-1.,1.)), False)\n        apply_test(m, np.array((1.1,1.1,-10.,1.)), False)\n        apply_test(m, np.array((-1.1,-1.1,-10.,1.)), False)\n\n    def test_create_look_at_determinant(self):\n        m = matrix44.create_look_at(\n            np.array((300.0, 200.0, 100.0)),\n            np.array((0.0, 0.0, 0.0)),\n            np.array((0.0, 0.0, 1.0)),\n        )\n\n        self.assertAlmostEqual(np.linalg.det(m), 1.0)\n\n    def test_create_look_at(self):\n        m = matrix44.create_look_at(\n            np.array((300.0, 200.0, 100.0)),\n            np.array((0.0, 0.0, 10.0)),\n            np.array((0.0, 0.0, 1.0)),\n        )\n\n        points = [\n            (-10.0, -10.0, 0.0, 1.0),\n            (-10.0, 10.0, 0.0, 1.0),\n            (10.0, -10.0, 0.0, 1.0),\n            (10.0, 10.0, 0.0, 1.0),\n            (-10.0, -10.0, 20.0, 1.0),\n            (-10.0, 10.0, 20.0, 1.0),\n            (10.0, -10.0, 20.0, 1.0),\n            (10.0, 10.0, 20.0, 1.0),\n        ]\n\n        for point in points:\n            x, y, z, w = matrix44.apply_to_vector(m, point)\n            self.assertTrue(-20.0 < x and x < 20.0)\n            self.assertTrue(-20.0 < y and y < 20.0)\n            self.assertTrue(z < 0.0)\n            self.assertAlmostEqual(w, 1.0)\n\n    def test_create_look_at_2(self):\n        m = matrix44.create_look_at(\n            np.array((10.0, 0.0, 0.0)),\n            np.array((-10.0, 0.0, 0.0)),\n            np.array((0.0, 1.0, 0.0)),\n        )\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (1.0, 0.0, 0.0, 1.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, -9.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 1.0, 0.0, 1.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 1.0)\n        self.assertAlmostEqual(z, -10.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 0.0, 1.0, 1.0))\n        self.assertAlmostEqual(x, -1.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, -10.0)\n\n    def test_create_look_at_3(self):\n        m = matrix44.create_look_at(\n            np.array((10.0, 0.0, 0.0)),\n            np.array((-10.0, 0.0, 0.0)),\n            np.array((0.0, 1.0, 0.0)),\n        )\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (1.0, 0.0, 0.0, 0.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, 1.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 1.0, 0.0, 0.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 1.0)\n        self.assertAlmostEqual(z, 0.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 0.0, 1.0, 0.0))\n        self.assertAlmostEqual(x, -1.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, 0.0)\n\n    def test_create_look_at_4(self):\n        m = matrix44.create_look_at(\n            np.array((0.0, 0.0, 0.0)),\n            np.array((0.0, 0.0, -1.0)),\n            np.array((0.0, 1.0, 0.0)),\n        )\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (1.0, 0.0, 0.0, 0.0))\n        self.assertAlmostEqual(x, 1.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, 0.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 1.0, 0.0, 0.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 1.0)\n        self.assertAlmostEqual(z, 0.0)\n\n        x, y, z, _ = matrix44.apply_to_vector(m, (0.0, 0.0, 1.0, 0.0))\n        self.assertAlmostEqual(x, 0.0)\n        self.assertAlmostEqual(y, 0.0)\n        self.assertAlmostEqual(z, 1.0)\n\n    def test_apply_to_vector_identity(self):\n        mat = matrix44.create_identity()\n        result = matrix44.apply_to_vector(mat, [1.,0.,0.])\n        np.testing.assert_almost_equal(result, [1.,0.,0.], decimal=5)\n\n    def test_apply_to_vector_x_rotation(self):\n        mat = matrix44.create_from_x_rotation(np.pi)\n        result = matrix44.apply_to_vector(mat, [0.,1.,0.])\n        np.testing.assert_almost_equal(result, [0.,-1.,0.], decimal=5)\n\n    def test_apply_to_vector_y_rotation(self):\n        mat = matrix44.create_from_y_rotation(np.pi)\n        result = matrix44.apply_to_vector(mat, [1.,0.,0.])\n        np.testing.assert_almost_equal(result, [-1.,0.,0.], decimal=5)\n\n    def test_apply_to_vector_z_rotation(self):\n        mat = matrix44.create_from_z_rotation(np.pi)\n        result = matrix44.apply_to_vector(mat, [1.,0.,0.])\n        np.testing.assert_almost_equal(result, [-1.,0.,0.], decimal=5)\n\n    def test_apply_to_vector_with_translation(self):\n        mat = matrix44.create_from_translation([2.,3.,4.])\n        result = matrix44.apply_to_vector(mat, [1.,1.,1.])\n        np.testing.assert_almost_equal(result, [3.,4.,5.], decimal=5)\n\n    @unittest.skip('Not implemented')\n    def test_create_from_eulers(self):\n        # just call the function\n        # TODO: check the result\n        matrix44.create_from_eulers([1,2,3])\n\n    def test_create_from_x_rotation(self):\n        mat = matrix44.create_from_x_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.,1.], mat), [1.,0.,0.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.,1.], mat), [0.,0.,-1.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.,1.], mat), [0.,1.,0.,1.]))\n\n    def test_create_from_y_rotation(self):\n        mat = matrix44.create_from_y_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.,1.], mat), [0.,0.,1.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.,1.], mat), [0.,1.,0.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.,1.], mat), [-1.,0.,0.,1.]))\n\n    def test_create_from_z_rotation(self):\n        mat = matrix44.create_from_z_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(np.dot([1.,0.,0.,1.], mat), [0.,-1.,0.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,1.,0.,1.], mat), [1.,0.,0.,1.]))\n        self.assertTrue(np.allclose(np.dot([0.,0.,1.,1.], mat), [0.,0.,1.,1.]))\n\n    def test_multiply_identity(self):\n        m1 = matrix44.create_identity()\n        m2 = matrix44.create_identity()\n        result = matrix44.multiply(m1, m2)\n        self.assertTrue(np.allclose(result, np.dot(m1,m2)))\n\n    def test_multiply_rotation(self):\n        m1 = matrix44.create_from_x_rotation(np.pi)\n        m2 = matrix44.create_from_y_rotation(np.pi / 2.0)\n        result = matrix44.multiply(m1, m2)\n        self.assertTrue(np.allclose(result, np.dot(m1,m2)))\n\n    def test_inverse(self):\n        m = matrix44.create_from_y_rotation(np.pi)\n        result = matrix44.inverse(m)\n        self.assertTrue(np.allclose(result, matrix44.create_from_y_rotation(-np.pi)))\n    \n    def test_decompose(self):\n        # define expectations\n        expected_scale = vector3.create(*[1, 1, 2], dtype='f4')\n        expected_rotation = quaternion.create_from_y_rotation(np.pi, dtype='f4')\n        expected_translation = vector3.create(*[10, 0, -5], dtype='f4')\n        expected_model = np.array([\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -2, 0],\n            [10, 0, -5, 1],\n        ], dtype='f4')\n\n        # compose matrix using Pyrr\n        s = matrix44.create_from_scale(expected_scale, dtype='f4')\n        r = matrix44.create_from_quaternion(expected_rotation, dtype='f4')\n        t = matrix44.create_from_translation(expected_translation, dtype='f4')\n        model = s.dot(r).dot(t)\n        np.testing.assert_almost_equal(model, expected_model)\n        self.assertTrue(model.dtype == expected_model.dtype)\n\n        # decompose matrix\n        scale, rotation, translation = matrix44.decompose(model)\n        np.testing.assert_almost_equal(scale, expected_scale)\n        self.assertTrue(scale.dtype == expected_scale.dtype)\n        np.testing.assert_almost_equal(rotation, expected_rotation)\n        self.assertTrue(rotation.dtype == expected_rotation.dtype)\n        np.testing.assert_almost_equal(translation, expected_translation)\n        self.assertTrue(translation.dtype == expected_translation.dtype)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_plane.py,24,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import plane, vector\n\nclass test_plane(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.plane\n        from pyrr import plane\n\n    def test_create(self):\n        result = plane.create()\n        self.assertTrue(np.allclose(result, [0,0,1,0]))\n\n        result = plane.create([1.,0.,0.], 5.)\n        self.assertTrue(np.allclose(result, [1.,0.,0.,5.]))\n\n    def test_create_from_points(self):\n        result = plane.create_from_points(\n            [1., 0., 0.],\n            [0., 1., 0.],\n            [1., 1., 0.],\n        )\n        self.assertTrue(np.allclose(result, [0.,0.,1.,0.]))\n        self.assertTrue(np.allclose(plane.position(result), [0., 0., 0.]))\n\n        result = plane.create_from_points(\n            [1., 1., 0.],\n            [1., 1., 1.],\n            [0., 1., 1.],\n        )\n        expected = plane.create([0.,1.,0.], 1.)\n        self.assertTrue(np.allclose(result, expected))\n        self.assertTrue(np.allclose(plane.position(result), [0., 1., 0.]))\n\n    def test_create_from_position(self):\n        position = np.array([1.0, 0.0, 0.0])\n        normal = np.array([0.0, 3.0, 0.0])\n        result = plane.create_from_position(position, normal)\n        self.assertTrue(np.allclose(result, [0., 1., 0., 0.]))\n\n        p0 = position + [1., 0., 0.]\n        p = position\n        n = vector.normalise(normal)\n        coplanar = p - p0\n        self.assertEqual(np.sum(n * coplanar), 0.)\n\n    def test_create_xy(self):\n        result = plane.create_xy()\n        self.assertTrue(np.allclose(result, [0., 0., 1., 0.]))\n\n        result = plane.create_xy(distance=2.)\n        self.assertTrue(np.allclose(result, [0., 0., 1., 2.]))\n\n        result = plane.create_xy(invert=True, distance=2.)\n        self.assertTrue(np.allclose(result, [0., 0., -1., -2.]))\n\n    def test_create_xz(self):\n        result = plane.create_xz()\n        self.assertTrue(np.allclose(result, [0., 1., 0., 0.]))\n\n        result = plane.create_xz(distance=2.)\n        self.assertTrue(np.allclose(result, [0., 1., 0., 2.]))\n\n        result = plane.create_xz(invert=True, distance=2.)\n        self.assertTrue(np.allclose(result, [0., -1., 0., -2.]))\n\n    def test_create_yz(self):\n        result = plane.create_yz()\n        self.assertTrue(np.allclose(result, [1., 0., 0., 0.]))\n\n        result = plane.create_yz(distance=2.)\n        self.assertTrue(np.allclose(result, [1., 0., 0., 2.]))\n\n        result = plane.create_yz(invert=True, distance=2.)\n        print(result)\n        self.assertTrue(np.allclose(result, [-1., 0., 0., -2.]))\n\n    def test_invert_normal(self):\n        p = np.array([1.0, 0.0, 0.0, 1.0])\n        result = plane.invert_normal(p)\n        self.assertTrue(np.allclose(result, [-1.0, 0.0, 0.0, -1.0]))\n\n    def test_position(self):\n        p = plane.create_xz(distance=-5.)\n        result = plane.position(p)\n        self.assertTrue(np.allclose(result, [0.,-5.,0.]))\n\n        p = plane.create_from_position(position=[0., 0., 1.], normal=[0., 0., 1.])\n        self.assertTrue(np.allclose(plane.position(p), [0., 0., 1.]))\n\n    def test_normal(self):\n        p = plane.create_xz(distance=5.)\n        result = plane.normal(p)\n        self.assertTrue(np.allclose(result, [0.,1.,0.]))\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_quaternion.py,156,"b""#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import quaternion\n\n\nclass test_quaternion(unittest.TestCase):\n    # many of these values are taken from searches on wolfram alpha\n\n    def test_import(self):\n        import pyrr\n        pyrr.quaternion\n        from pyrr import quaternion\n\n    def test_create(self):\n        result = quaternion.create()\n        np.testing.assert_almost_equal(result, [0., 0., 0., 1.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_parameters(self):\n        result = quaternion.create(1.0, 2.0, 3.0, 4.0)\n        np.testing.assert_almost_equal(result, [1.0, 2.0, 3.0, 4.0], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_x_rotation(self):\n        # 180 degree turn around X axis\n        q = quaternion.create_from_x_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [1., 0., 0., 0.]))\n\n        # 90 degree rotation around X axis\n        q = quaternion.create_from_x_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [np.sqrt(0.5), 0., 0., np.sqrt(0.5)]))\n\n        # -90 degree rotation around X axis\n        q = quaternion.create_from_x_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(q, [-np.sqrt(0.5), 0., 0., np.sqrt(0.5)]))\n\n    def test_create_from_y_rotation(self):\n        # 180 degree turn around Y axis\n        q = quaternion.create_from_y_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [0., 1., 0., 0.]))\n\n        # 90 degree rotation around Y axis\n        q = quaternion.create_from_y_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., np.sqrt(0.5), 0., np.sqrt(0.5)]))\n\n        # -90 degree rotation around Y axis\n        q = quaternion.create_from_y_rotation(-np.pi / 2.)\n\n    def test_create_from_z_rotation(self):\n        # 180 degree turn around Z axis\n        q = quaternion.create_from_z_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [0., 0., 1., 0.]))\n\n        # 90 degree rotation around Z axis\n        q = quaternion.create_from_z_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., 0., np.sqrt(0.5), np.sqrt(0.5)]))\n\n        # -90 degree rotation around Z axis\n        q = quaternion.create_from_z_rotation(-np.pi / 2.)\n\n    def test_create_from_axis_rotation(self):\n        # wolfram alpha can be awesome sometimes\n        result = quaternion.create_from_axis_rotation([0.57735, 0.57735, 0.57735], np.pi)\n        np.testing.assert_almost_equal(result, [5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17], decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_axis_rotation_non_normalized(self):\n        result = quaternion.create_from_axis_rotation([1., 1., 1.], np.pi)\n        np.testing.assert_almost_equal(result, [5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17], decimal=3)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_axis(self):\n        source = np.array([np.pi, np.pi, np.pi])\n        result = quaternion.create_from_axis(source)\n        expected = np.array([0.2358916, 0.2358916, 0.2358916, -0.9127242])\n        np.testing.assert_almost_equal(result, expected)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix_unit(self):\n        result = quaternion.create_from_matrix(np.eye(3))\n        np.testing.assert_almost_equal(result, [0., 0., 0., 1.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix_x(self):\n        result = quaternion.create_from_matrix([\n            [1., 0., 0.],\n            [0., -1., 0.],\n            [0., 0., -1.],\n        ])\n        np.testing.assert_almost_equal(result, [1., 0., 0., 0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix_y(self):\n        result = quaternion.create_from_matrix([\n            [-1., 0., 0.],\n            [0., 1., 0.],\n            [0., 0., -1.],\n        ])\n        np.testing.assert_almost_equal(result, [0., 1., 0., 0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix_z(self):\n        result = quaternion.create_from_matrix([\n            [-1., 0., 0.],\n            [0., -1., 0.],\n            [0., 0., 1.],\n        ])\n        np.testing.assert_almost_equal(result, [0., 0., 1., 0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_eulers_identity(self):\n        result = quaternion.create_from_eulers([0., 0., 0.])\n        np.testing.assert_equal(result, [0., 0., 0., 1.])\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_eulers(self):\n        result = quaternion.create_from_eulers([1.0, 2.0, 3.0])\n        np.testing.assert_almost_equal(result, [0.7549338, -0.2061492, 0.5015091, -0.3688714], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    @unittest.skip('Not implemented')\n    def test_create_from_inverse_of_eulers(self):\n        pass\n\n    def test_cross(self):\n        q1 = quaternion.create_from_x_rotation(np.pi / 2.0)\n        q2 = quaternion.create_from_x_rotation(-np.pi / 2.0)\n        result = quaternion.cross(q1, q2)\n        np.testing.assert_almost_equal(result, quaternion.create(), decimal=5)\n\n\n    def test_quaternion_slerp(self):\n        sqrt2 = np.sqrt(2) / 2\n\n        identity = np.array([0.0, 0.0, 0.0, 1.0])\n        y90rot = np.array([0.0, sqrt2, 0.0, sqrt2])\n        y180rot = np.array([0.0, 1.0, 0.0, 0.0])\n\n        # Testing a == 0\n        # Must be id\n        result = quaternion.slerp(identity, y90rot, 0.0)\n        np.testing.assert_almost_equal(result, identity, decimal=4)\n\n        # Testing a == 1\n        # Must be 90\xc2\xb0 rotation on Y : 0 0.7 0 0.7\n        result = quaternion.slerp(identity, y90rot, 1.0)\n        np.testing.assert_almost_equal(result, y90rot, decimal=4)\n\n        # Testing standard, easy case\n        # Must be 45\xc2\xb0 rotation on Y : 0 0.38 0 0.92\n        y45rot1 = quaternion.slerp(identity, y90rot, 0.5)\n\n        # Testing reverse case\n        # Must be 45\xc2\xb0 rotation on Y : 0 0.38 0 0.92\n        y45rot2 = quaternion.slerp(y90rot, identity, 0.5)\n        np.testing.assert_almost_equal(y45rot1, y45rot2, decimal=4)\n\n        # Testing against full circle around the sphere instead of shortest path\n        # Must be 45\xc2\xb0 rotation on Y\n        # certainly not a 135\xc2\xb0 rotation\n        # y45rot3 = quaternion.slerp(identity, quaternion.negate(y90rot), 0.5)\n        y45rot3 = quaternion.slerp(identity, y90rot, 0.5)\n        y45angle3 = quaternion.rotation_angle(y45rot3)\n        np.testing.assert_almost_equal(y45angle3 * 180 / np.pi, 45, decimal=4)\n        np.testing.assert_almost_equal(y45angle3, np.pi / 4, decimal=4)\n\n        # # Same, but inverted\n        # # Must also be 45\xc2\xb0 rotation on Y :  0 0.38 0 0.92\n        # # -0 -0.38 -0 -0.92 is ok too\n        y45rot4 = quaternion.slerp(-y90rot, identity, 0.5)\n        np.testing.assert_almost_equal(np.abs(y45rot4), y45rot2, decimal=4)\n\n        # # Testing q1 = q2\n        # # Must be 90\xc2\xb0 rotation on Y : 0 0.7 0 0.7\n        y90rot3 = quaternion.slerp(y90rot, y90rot, 0.5);\n        np.testing.assert_almost_equal(y90rot3, y90rot, decimal=4)\n\n        # # Testing 180\xc2\xb0 rotation\n        # # Must be 90\xc2\xb0 rotation on almost any axis that is on the XZ plane\n        xz90rot = quaternion.slerp(identity, -y90rot, 0.5)\n        xz90rot = quaternion.rotation_angle(xz90rot)\n        np.testing.assert_almost_equal(xz90rot, np.pi / 4, decimal=4)\n\n    def test_is_zero_length(self):\n        result = quaternion.is_zero_length([1., 0., 0., 0.])\n        self.assertFalse(result)\n\n    def test_is_zero_length_zero(self):\n        result = quaternion.is_zero_length([0., 0., 0., 0.])\n        self.assertTrue(result)\n\n    def test_is_non_zero_length(self):\n        result = quaternion.is_non_zero_length([1., 0., 0., 0.])\n        self.assertTrue(result)\n\n    def test_is_non_zero_length_zero(self):\n        result = quaternion.is_non_zero_length([0., 0., 0., 0.])\n        self.assertFalse(result)\n\n    def test_squared_length_identity(self):\n        result = quaternion.squared_length([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_squared_length(self):\n        result = quaternion.squared_length([1., 1., 1., 1.])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_squared_length_batch(self):\n        result = quaternion.squared_length([\n            [0., 0., 0., 1.],\n            [1., 1., 1., 1.],\n        ])\n        np.testing.assert_almost_equal(result, [1., 4.], decimal=5)\n\n    def test_length_identity(self):\n        result = quaternion.length([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_length(self):\n        result = quaternion.length([1., 1., 1., 1.])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_length_batch(self):\n        result = quaternion.length([\n            [0., 0., 0., 1.],\n            [1., 1., 1., 1.],\n        ])\n        np.testing.assert_almost_equal(result, [1., 2.], decimal=5)\n\n    def test_normalize_identity(self):\n        # normalize an identity quaternion\n        result = quaternion.normalize([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, [0., 0., 0., 1.], decimal=5)\n\n    def test_normalize_non_identity(self):\n        # normalize an identity quaternion\n        result = quaternion.normalize([1., 2., 3., 4.])\n        np.testing.assert_almost_equal(result, [1. / np.sqrt(30.), np.sqrt(2. / 15.), np.sqrt(3. / 10.), 2. * np.sqrt(2. / 15.)], decimal=5)\n\n    def test_normalize_batch(self):\n        # normalize an identity quaternion\n        result = quaternion.normalize([\n            [0., 0., 0., 1.],\n            [1., 2., 3., 4.],\n        ])\n        expected = [\n            [0., 0., 0., 1.],\n            [1. / np.sqrt(30.), np.sqrt(2. / 15.), np.sqrt(3. / 10.), 2. * np.sqrt(2. / 15.)],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_rotation_angle(self):\n        result = quaternion.rotation_angle([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17])\n        np.testing.assert_almost_equal(result, np.pi, decimal=5)\n\n    def test_rotation_axis(self):\n        result = quaternion.rotation_axis([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17])\n        np.testing.assert_almost_equal(result, [0.57735, 0.57735, 0.57735], decimal=5)\n\n    def test_dot_adjacent(self):\n        result = quaternion.dot([1., 0., 0., 0.], [0., 1., 0., 0.])\n        np.testing.assert_almost_equal(result, 0.0, decimal=5)\n\n    def test_dot_parallel(self):\n        result = quaternion.dot([0., 1., 0., 0.], [0., 1., 0., 0.])\n        np.testing.assert_almost_equal(result, 1.0, decimal=5)\n\n    def test_dot_angle(self):\n        result = quaternion.dot([.2, .2, 0., 0.], [2., -.2, 0., 0.])\n        np.testing.assert_almost_equal(result, 0.36, decimal=5)\n\n    def test_dot_batch(self):\n        result = quaternion.dot([\n            [1., 0., 0., 0.],\n            [0., 1., 0., 0.],\n            [.2, .2, 0., 0.]\n        ], [\n            [0., 1., 0., 0.],\n            [0., 1., 0., 0.],\n            [2., -.2, 0., 0.]\n        ])\n        expected = [0., 1., 0.36]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_conjugate(self):\n        #result = quaternion.conjugate([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17])\n        result = quaternion.conjugate([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, [0., 0., 0., 1.], decimal=5)\n\n    def test_conjugate_rotation(self):\n        result = quaternion.conjugate([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17])\n        np.testing.assert_almost_equal(result, [-0.57735, -0.57735, -0.57735, 6.12323e-17], decimal=5)\n\n    def test_exp(self):\n        source = np.array([0, 0, 0, 1.0])\n        result = quaternion.exp(source)\n        expected = np.array([0, 0, 0, np.exp(1)])\n        np.testing.assert_almost_equal(result, expected)\n\n        source = quaternion.create_from_eulers([np.pi, 0, 0])\n        result = quaternion.exp(source)\n        expected = np.array([0.84147098, 0, 0, 0.54030231])\n        np.testing.assert_almost_equal(result, expected)\n\n        # Tests from the boost::math::quaternion\n        source = np.array([4 * np.arctan(1), 0, 0, 0])\n        result = quaternion.exp(source) + [0, 0, 0, 1.0]\n        result = np.linalg.norm(result)\n        expected = 2 * np.finfo(result.dtype).eps\n        np.testing.assert_almost_equal(result, expected)\n\n        source = np.array([0, 4 * np.arctan(1), 0, 0])\n        result = quaternion.exp(source) + [0, 0, 0, 1.0]\n        result = np.linalg.norm(result)\n        expected = 2 * np.finfo(result.dtype).eps\n        np.testing.assert_almost_equal(result, expected)\n\n        source = np.array([0, 0, 4 * np.arctan(1), 0])\n        result = quaternion.exp(source) + [0, 0, 0, 1.0]\n        result = np.linalg.norm(result)\n        expected = 2 * np.finfo(result.dtype).eps\n        np.testing.assert_almost_equal(result, expected)\n\n    @unittest.skip('Not implemented')\n    def test_power(self):\n        pass\n\n    def test_inverse(self):\n        result = quaternion.inverse([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, [0., 0., 0., 1.], decimal=5)\n\n    def test_inverse_rotation(self):\n        result = quaternion.inverse([5.77350000e-01, 5.77350000e-01, 5.77350000e-01, 6.12323400e-17])\n        np.testing.assert_almost_equal(result, [-0.577351, -0.577351, -0.577351, 6.12324e-17], decimal=5)\n\n    def test_inverse_non_unit(self):\n        q = [1, 2, 3, 4]\n        result = quaternion.inverse(q)\n        expected = quaternion.conjugate(q) / quaternion.length(q)\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_negate_unit(self):\n        result = quaternion.negate([0., 0., 0., 1.])\n        np.testing.assert_almost_equal(result, [0., 0., 0., -1.], decimal=5)\n\n    def test_negate(self):\n        result = quaternion.negate([1., 2., 3., 4.])\n        np.testing.assert_almost_equal(result, [-1., -2., -3., -4.], decimal=5)\n\n    def test_apply_to_vector_unit_x(self):\n        result = quaternion.apply_to_vector([0., 0., 0., 1.], [1., 0., 0.])\n        np.testing.assert_almost_equal(result, [1., 0., 0.], decimal=5)\n\n    def test_apply_to_vector_x(self):\n        # 180 degree turn around X axis\n        q = quaternion.create_from_x_rotation(np.pi)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 0.,-1.]))\n\n        # 90 degree rotation around X axis\n        q = quaternion.create_from_x_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0., 0., 1.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0.,-1., 0.]))\n\n        # -90 degree rotation around X axis\n        q = quaternion.create_from_x_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0., 0.,-1.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 1., 0.]))\n\n    def test_apply_to_vector_y(self):\n        # 180 degree turn around Y axis\n        q = quaternion.create_from_y_rotation(np.pi)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 0.,-1.]))\n\n        # 90 degree rotation around Y axis\n        q = quaternion.create_from_y_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [0., 0.,-1.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [1., 0., 0.]))\n\n        # -90 degree rotation around Y axis\n        q = quaternion.create_from_y_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [0., 0., 1.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [-1., 0., 0.]))\n\n    def test_apply_to_vector_z(self):\n        # 180 degree turn around Z axis\n        q = quaternion.create_from_z_rotation(np.pi)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 0., 1.]))\n\n        # 90 degree rotation around Z axis\n        q = quaternion.create_from_z_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 0., 1.]))\n\n        # -90 degree rotation around Z axis\n        q = quaternion.create_from_z_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [1., 0., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 1., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 1.]), [0., 0., 1.]))\n\n    def test_apply_to_vector_non_unit(self):\n        q = quaternion.create_from_x_rotation(np.pi)\n        # zero length\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 0.]), [0., 0., 0.]))\n\n        # >1 length\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [2., 0., 0.]), [2., 0., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 2., 0.]), [0.,-2., 0.]))\n        self.assertTrue(np.allclose(quaternion.apply_to_vector(q, [0., 0., 2.]), [0., 0.,-2.]))\n\n    def test_identity(self):\n        # https://en.wikipedia.org/wiki/Quaternion\n        i = quaternion.create(1., 0., 0., 0.)\n        j = quaternion.create(0., 1., 0., 0.)\n        k = quaternion.create(0., 0., 1., 0.)\n        one = quaternion.create(0., 0., 0., 1.)\n\n        # i * 1 = i\n        # j * 1 = j\n        # k * 1 = k\n        # 1 * i = i\n        # 1 * j = j\n        # 1 * k = k\n        i1 = quaternion.cross(i, one)\n        j1 = quaternion.cross(j, one)\n        k1 = quaternion.cross(k, one)\n        _1i = quaternion.cross(one, i)\n        _1j = quaternion.cross(one, j)\n        _1k = quaternion.cross(one, k)\n\n        self.assertTrue(np.allclose(i1, _1i, i))\n        self.assertTrue(np.allclose(j1, _1j, j))\n        self.assertTrue(np.allclose(k1, _1k, k))\n\n        # result = -1\n        ii = quaternion.cross(i, i)\n        kk = quaternion.cross(k, k)\n        jj = quaternion.cross(j, j)\n        ijk = quaternion.cross(quaternion.cross(i, j), k)\n\n        self.assertTrue(np.allclose(ii, -one))\n        self.assertTrue(np.allclose(jj, -one))\n        self.assertTrue(np.allclose(kk, -one))\n        self.assertTrue(np.allclose(ijk, -one))\n\n        # ij = k\n        # ji = -k\n        # jk = i\n        # kj = -i\n        # ki = j\n        # ik = -j\n\n        ij = quaternion.cross(i, j)\n        ji = quaternion.cross(j, i)\n        jk = quaternion.cross(j, k)\n        kj = quaternion.cross(k, j)\n        ki = quaternion.cross(k, i)\n        ik = quaternion.cross(i, k)\n\n        self.assertTrue(np.allclose(ij, k))\n        self.assertTrue(np.allclose(ji, -k))\n        self.assertTrue(np.allclose(jk, i))\n        self.assertTrue(np.allclose(kj, -i))\n        self.assertTrue(np.allclose(ki, j))\n        self.assertTrue(np.allclose(ik, -j))\n\n        # -k = ijkk = ij(k^2) = ij(-1)\n\n        ijkk = quaternion.cross(quaternion.cross(ij, k), k)\n        ijk2 = quaternion.cross(ij, quaternion.cross(k, k))\n        ij_m1 = quaternion.cross(ij, -one)\n\n        self.assertTrue(np.allclose(ijkk, ijk2))\n        self.assertTrue(np.allclose(ijk2, ij_m1))\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_ray.py,11,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import ray\n\n\nclass test_ray(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.ray\n        from pyrr import ray\n\n    def test_create(self):\n        result = ray.create([0.,0.,0.],[0.,0.,1.])\n        np.testing.assert_almost_equal(result, [[0.,0.,0.],[0.,0.,1.]], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_dtype(self):\n        result = ray.create([0,0,0],[0,0,1], dtype=np.int)\n        np.testing.assert_almost_equal(result, [[0,0,0],[0,0,1]], decimal=5)\n        self.assertTrue(result.dtype == np.int)\n\n    def test_create_from_line(self):\n        result = ray.create_from_line([\n            [0.,10.,0.],\n            [10.,10.,0.]\n        ])\n        np.testing.assert_almost_equal(result, [[0.,10.,0.],[1.,0.,0.]], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_invert(self):\n        result = ray.invert([[0.,10.,0.],[1.,0.,0.]])\n        np.testing.assert_almost_equal(result, [[0.,10.,0.],[-1.,0.,0.]], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_position(self):\n        result = ray.position([[0.,10.,0.],[1.,0.,0.]])\n        np.testing.assert_almost_equal(result, [0.,10.,0.], decimal=5)\n\n    def test_direction(self):\n        result = ray.direction([[0.,10.,0.],[1.,0.,0.]])\n        np.testing.assert_almost_equal(result, [1.,0.,0.], decimal=5)\n\n\nif __name__ == '__main__':\n    unittest.main()\n\n"""
tests/test_rectangle.py,30,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import rectangle\n\n\nclass test_rectangle(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.rectangle\n        from pyrr import rectangle\n\n    def test_create(self):\n        result = rectangle.create()\n        np.testing.assert_almost_equal(result, [[0,0],[1,1]], decimal=5)\n\n    def test_create_dtype(self):\n        result = rectangle.create(dtype=np.float)\n        np.testing.assert_almost_equal(result, [[0.,0.],[1.,1.]], decimal=5)\n\n    def test_create_zeros(self):\n        result = rectangle.create_zeros()\n        np.testing.assert_almost_equal(result, [[0,0],[0,0]], decimal=5)\n\n    def test_create_from_bounds(self):\n        result = rectangle.create_from_bounds(-1, 1, -2, 2)\n        np.testing.assert_almost_equal(result, [[-1,-2],[2,4]], decimal=5)\n\n    def test_bounds(self):\n        rect = rectangle.create_from_bounds(-1, 1, -2, 2)\n        result = rectangle.bounds(rect)\n        np.testing.assert_almost_equal(result, (-1,1,-2,2), decimal=5)\n\n    def test_scale_by_vector(self):\n        result = rectangle.scale_by_vector([[-1.,-2.],[2.,4.]], [2.,3.])\n        np.testing.assert_almost_equal(result, [[-2.,-6.],[4.,12.]], decimal=5)\n\n    def test_scale_by_vector3(self):\n        result = rectangle.scale_by_vector([[-1.,-2.],[2.,4.]], [2.,3.,4.])\n        np.testing.assert_almost_equal(result, [[-2.,-6.],[4.,12.]], decimal=5)\n\n    def test_right(self):\n        result = rectangle.right([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_right_negative(self):\n        result = rectangle.right([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_left(self):\n        result = rectangle.left([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_left_negative(self):\n        result = rectangle.left([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, -2., decimal=5)\n\n    def test_top(self):\n        result = rectangle.top([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 6., decimal=5)\n\n    def test_top_negative(self):\n        result = rectangle.top([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_bottom(self):\n        result = rectangle.bottom([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_bottom_negative(self):\n        result = rectangle.bottom([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, -2., decimal=5)\n\n    def test_x(self):\n        result = rectangle.x([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_x_negative(self):\n        result = rectangle.x([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 1., decimal=5)\n\n    def test_y(self):\n        result = rectangle.y([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_y_negative(self):\n        result = rectangle.y([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_width(self):\n        result = rectangle.width([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 3., decimal=5)\n\n    def test_width_negative(self):\n        result = rectangle.width([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, -3., decimal=5)\n\n    def test_height(self):\n        result = rectangle.height([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_height_negative(self):\n        result = rectangle.height([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, -4., decimal=5)\n\n    def test_abs_height(self):\n        result = rectangle.abs_height([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_abs_height_negative(self):\n        result = rectangle.abs_height([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_abs_width(self):\n        result = rectangle.abs_width([[1.,2.],[3.,4.]])\n        np.testing.assert_almost_equal(result, 3., decimal=5)\n\n    def test_abs_width_negative(self):\n        result = rectangle.abs_width([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, 3., decimal=5)\n\n    def test_position(self):\n        result = rectangle.position([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, [1.,2.], decimal=5)\n\n    def test_size(self):\n        result = rectangle.size([[1.,2.],[-3.,-4.]])\n        np.testing.assert_almost_equal(result, [-3.,-4.], decimal=5)\n\n    \nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_sphere.py,3,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import sphere\n\n\nclass test_sphere(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.sphere\n        from pyrr import sphere\n\n    def test_create_from_points(self):\n        # the biggest should be 5,5,5\n        result = sphere.create_from_points([\n            [ 0.0, 0.0, 0.0 ],\n            [ 5.0, 5.0, 5.0 ],\n            [ 0.0, 0.0, 5.0 ],\n            [-5.0, 0.0, 0.0 ],\n        ])\n        # centred around 0,0,0\n        # with MAX LENGTH as radius\n        np.testing.assert_almost_equal(result, [0.,0.,0., 8.66025], decimal=5)\n\n    def test_position(self):\n        result = sphere.position([1.,2.,3.,4.])\n        np.testing.assert_almost_equal(result, [1.,2.,3.], decimal=5)\n\n    def test_radius(self):\n        result = sphere.radius([1.,2.,3.,4.])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_trig.py,0,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nfrom pyrr import trig\n\n\nclass test_trig(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.trig\n        from pyrr import trig\n\n    def test_aspec_ratio(self):\n        self.assertEqual(trig.aspect_ratio(1920, 1080), 1920./1080.)\n\n    @unittest.skip('Need a test here')\n    def test_calculate_fov(self):\n        pass\n\n    @unittest.skip('Need a test here')\n    def test_calculate_zoom(self):\n        pass\n\n    @unittest.skip('Need a test here')\n    def test_calculate_height(self):\n        pass\n\n    @unittest.skip('Need a test here')\n    def test_calculate_plane_size(self):\n        pass\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_vector.py,16,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import vector, vector3, vector4\n\n\nclass test_vector(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.vector\n        from pyrr import vector\n\n    def test_normalize_single_vector(self):\n        result = vector3.normalize([1.,1.,1.])\n        np.testing.assert_almost_equal(result, [0.57735, 0.57735, 0.57735], decimal=5)\n\n    def test_normalize_batch(self):\n        result = vector3.normalize([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            [0.57735, 0.57735, 0.57735],\n            [-0.57735,-0.57735,-0.57735],\n            [0., 0.274721, 0.961524],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_squared_length_single_vector(self):\n        result = vector3.squared_length([1.,1.,1.])\n        np.testing.assert_almost_equal(result, 3., decimal=5)\n\n    def test_squared_length_batch(self):\n        result = vector3.squared_length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            3.,\n            3.,\n            53.,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_length_vector3(self):\n        result = vector3.length([1.,1.,1.])\n        np.testing.assert_almost_equal(result, 1.73205, decimal=5)\n\n    def test_length_vector4(self):\n        result = vector3.length([1.,1.,1.,1.])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_length_vector3_batch(self):\n        result = vector3.length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            1.73205,\n            1.73205,\n            7.28011,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length_vector3(self):\n        result = vector3.set_length([1.,1.,1.],2.)\n        expected = [1.15470,1.15470,1.15470]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length_vector4(self):\n        result = vector4.set_length([1.,1.,1.,1.],2.)\n        expected = [1.,1.,1.,1.]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length_batch_vector(self):\n        result = vector3.set_length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n            ], 2.0)\n        expected = [\n            [1.15470,1.15470,1.15470],\n            [-1.15470,-1.15470,-1.15470],\n            [0.,0.54944,1.92304],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_dot_adjacent(self):\n        result = vector3.dot([1.,0.,0.], [0.,1.,0.])\n        np.testing.assert_almost_equal(result, 0.0, decimal=5)\n\n    def test_dot_parallel(self):\n        result = vector3.dot([0.,1.,0.], [0.,1.,0.])\n        np.testing.assert_almost_equal(result, 1.0, decimal=5)\n\n    def test_dot_angle(self):\n        result = vector3.dot([.2,.2,0.], [2.,-.2,0.])\n        np.testing.assert_almost_equal(result, 0.36, decimal=5)\n\n    def test_dot_batch(self):\n        result = vector3.dot([\n            [1.,0.,0.],\n            [0.,1.,0.],\n            [.2,.2,0.]\n        ],[\n            [0.,1.,0.],\n            [0.,1.,0.],\n            [2.,-.2,0.]\n        ])\n        expected = [0.,1.,0.36]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_interoplation(self):\n        result = vector3.interpolate([0.,0.,0.], [1.,1.,1.], 0.5)\n        np.testing.assert_almost_equal(result, [.5,.5,.5], decimal=5)\n\n        result = vector3.interpolate([0.,0.,0.], [2.,2.,2.], 0.5)\n        np.testing.assert_almost_equal(result, [1.,1.,1.], decimal=5)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_vector3.py,64,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import vector3\n\n\nclass test_vector3(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.vector3\n        from pyrr import vector3\n\n    def test_create(self):\n        result = vector3.create()\n        np.testing.assert_almost_equal(result, [0.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_values(self):\n        result = vector3.create(1., 2., 3., dtype=np.float32)\n        np.testing.assert_almost_equal(result, [1.,2.,3.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_list(self):\n        with self.assertRaises(ValueError):\n            vector3.create([1., 2., 3.])\n\n    def test_create_unit_length_x(self):\n        result = vector3.create_unit_length_x()\n        np.testing.assert_almost_equal(result, [1.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_x_dtype(self):\n        result = vector3.create_unit_length_x(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [1.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_unit_length_y(self):\n        result = vector3.create_unit_length_y()\n        np.testing.assert_almost_equal(result, [0.,1.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_y_dtype(self):\n        result = vector3.create_unit_length_y(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [0.,1.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_unit_length_z(self):\n        result = vector3.create_unit_length_z()\n        np.testing.assert_almost_equal(result, [0.,0.,1.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_z_dtype(self):\n        result = vector3.create_unit_length_z(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [0.,0.,1.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_from_vector4(self):\n        v4 = [1., 2., 3., 4.]\n        result = vector3.create_from_vector4(v4)\n        v, w = result\n        np.testing.assert_almost_equal(v, [1.,2.,3.], decimal=5)\n        np.testing.assert_almost_equal(w, 4., decimal=5)\n\n    def test_create_from_matrix44_translation(self):\n        mat = np.array([\n            [1.,2.,3.,4.,],\n            [5.,6.,7.,8.,],\n            [9.,10.,11.,12.,],\n            [13.,14.,15.,16.,],\n        ])\n        result = vector3.create_from_matrix44_translation(mat)\n        np.testing.assert_almost_equal(result, [13.,14.,15.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix44_translation_dtype_matches(self):\n        mat = np.array([\n            [1.,2.,3.,4.,],\n            [5.,6.,7.,8.,],\n            [9.,10.,11.,12.,],\n            [13.,14.,15.,16.,],\n        ], dtype=np.float32)\n        result = vector3.create_from_matrix44_translation(mat)\n        np.testing.assert_almost_equal(result, [13.,14.,15.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_normalize_single_vector(self):\n        result = vector3.normalize([1.,1.,1.])\n        np.testing.assert_almost_equal(result, [0.57735, 0.57735, 0.57735], decimal=5)\n\n    def test_normalize_batch(self):\n        result = vector3.normalize([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            [0.57735, 0.57735, 0.57735],\n            [-0.57735,-0.57735,-0.57735],\n            [0., 0.274721, 0.961524],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_generate_normals(self):\n        vertices = np.array([\n            [2.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [0.0, 2.0, 0.0],\n            [2.0, 2.0, 0.0]\n        ])\n        index = np.array([\n            [0, 2, 1],\n            [0, 3, 2],\n        ])\n        v1, v2, v3 = np.rollaxis(vertices[index], axis=1)\n        result = vector3.generate_normals(v1, v2, v3)\n        expected = np.array([\n            [0., 0., 1.],\n            [0., 0., 1.]\n        ])\n        np.testing.assert_array_equal(result, expected)\n\n    def test_generate_normals_unnormalized(self):\n        vertices = np.array([\n            [2.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [0.0, 2.0, 0.0],\n            [2.0, 2.0, 0.0]\n        ])\n        index = np.array([\n            [0, 2, 1],\n            [0, 3, 2],\n        ])\n        v1, v2, v3 = np.rollaxis(vertices[index], axis=1)\n        result = vector3.generate_normals(v1, v2, v3, normalize_result=False)\n        expected = np.array([\n            [0., 0., 4.],\n            [0., 0., 4.]\n        ])\n        np.testing.assert_array_equal(result, expected)\n\n    def test_generate_vertex_normals(self):\n        vertices = np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [1.0, 1.0, 0.0]\n        ])\n        index = np.array([\n            [0, 2, 1],\n            [0, 3, 2],\n        ])\n        result = vector3.generate_vertex_normals(vertices, index)\n        expected = np.array([\n            [0., 0., 1.],\n            [0., 0., 1.],\n            [0., 0., 1.],\n            [0., 0., 1.]\n        ])\n        np.testing.assert_array_equal(result, expected)\n    \n    def test_generate_vertex_normals_unnormalized(self):\n        vertices = np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [1.0, 1.0, 0.0]\n        ])\n        index = np.array([\n            [0, 2, 1],\n            [0, 3, 2],\n        ])\n        result = vector3.generate_vertex_normals(\n            vertices, index, normalize_result=False)\n        expected = np.array([\n            [0., 0., 2.],\n            [0., 0., 1.],\n            [0., 0., 2.],\n            [0., 0., 1.]\n        ])\n        np.testing.assert_array_equal(result, expected)\n\n    def test_squared_length_single_vector(self):\n        result = vector3.squared_length([1.,1.,1.])\n        np.testing.assert_almost_equal(result, 3., decimal=5)\n\n    def test_squared_length_batch(self):\n        result = vector3.squared_length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            3.,\n            3.,\n            53.,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_length(self):\n        result = vector3.length([1.,1.,1.])\n        np.testing.assert_almost_equal(result, 1.73205, decimal=5)\n\n    def test_length_batch(self):\n        result = vector3.length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n        ])\n        expected = [\n            1.73205,\n            1.73205,\n            7.28011,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length(self):\n        result = vector3.set_length([1.,1.,1.],2.)\n        expected = [1.15470,1.15470,1.15470]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length_batch_vector(self):\n        result = vector3.set_length([\n            [1.,1.,1.],\n            [-1.,-1.,-1.],\n            [0.,2.,7.],\n            ], 2.0)\n        expected = [\n            [1.15470,1.15470,1.15470],\n            [-1.15470,-1.15470,-1.15470],\n            [0.,0.54944,1.92304],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_dot_adjacent(self):\n        result = vector3.dot([1.,0.,0.], [0.,1.,0.])\n        np.testing.assert_almost_equal(result, 0.0, decimal=5)\n\n    def test_dot_parallel(self):\n        result = vector3.dot([0.,1.,0.], [0.,1.,0.])\n        np.testing.assert_almost_equal(result, 1.0, decimal=5)\n\n    def test_dot_angle(self):\n        result = vector3.dot([.2,.2,0.], [2.,-.2,0.])\n        np.testing.assert_almost_equal(result, 0.36, decimal=5)\n\n    def test_dot_batch(self):\n        result = vector3.dot([\n            [1.,0.,0.],\n            [0.,1.,0.],\n            [.2,.2,0.]\n        ],[\n            [0.,1.,0.],\n            [0.,1.,0.],\n            [2.,-.2,0.]\n        ])\n        expected = [\n            0.,\n            1.,\n            0.36\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_cross_single_vector(self):\n        result = vector3.cross([1.,0.,0.], [0.,1.,0.])\n        np.testing.assert_almost_equal(result, [0.,0.,1.], decimal=5)\n\n    def test_cross_coincident(self):\n        result = vector3.cross([1.,0.,0.], [1.,0.,0.])\n        np.testing.assert_almost_equal(result, [0.,0.,0.], decimal=5)\n\n    def test_cross_batch(self):\n        result = vector3.cross([\n            [1.,0.,0.],\n            [0.,0.,1.]\n        ],[\n            [0.,1.,0.],\n            [0.,1.,0.],\n        ])\n        expected = [\n            [0.,0.,1.],\n            [-1.,0.,0.],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_interoplation( self ):\n        result = vector3.interpolate([0.,0.,0.], [1.,1.,1.], 0.5)\n        np.testing.assert_almost_equal(result, [.5,.5,.5], decimal=5)\n\n        result = vector3.interpolate([0.,0.,0.], [2.,2.,2.], 0.5)\n        np.testing.assert_almost_equal(result, [1.,1.,1.], decimal=5)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/test_vector4.py,44,"b""try:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import vector4\n\n\nclass test_vector4(unittest.TestCase):\n    def test_import(self):\n        import pyrr\n        pyrr.vector4\n        from pyrr import vector4\n\n    def test_create(self):\n        result = vector4.create()\n        np.testing.assert_almost_equal(result, [0.,0.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_values(self):\n        result = vector4.create(1.,2.,3.,4., dtype=np.float32)\n        np.testing.assert_almost_equal(result, [1.,2.,3.,4.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_list(self):\n        with self.assertRaises(ValueError):\n            vector4.create([1., 2., 3., 4.])\n\n    def test_create_unit_length_x(self):\n        result = vector4.create_unit_length_x()\n        np.testing.assert_almost_equal(result, [1.,0.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_x_dtype(self):\n        result = vector4.create_unit_length_x(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [1.,0.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_unit_length_y(self):\n        result = vector4.create_unit_length_y()\n        np.testing.assert_almost_equal(result, [0.,1.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_y_dtype(self):\n        result = vector4.create_unit_length_y(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [0.,1.,0.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_unit_length_z(self):\n        result = vector4.create_unit_length_z()\n        np.testing.assert_almost_equal(result, [0.,0.,1.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_z_dtype(self):\n        result = vector4.create_unit_length_z(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [0.,0.,1.,0.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_unit_length_w(self):\n        result = vector4.create_unit_length_w()\n        np.testing.assert_almost_equal(result, [0.,0.,0.,1.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_unit_length_w_dtype(self):\n        result = vector4.create_unit_length_w(dtype=np.float32)\n        np.testing.assert_almost_equal(result, [0.,0.,0.,1.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_create_from_matrix44_translation(self):\n        mat = np.array([\n            [1.,2.,3.,4.,],\n            [5.,6.,7.,8.,],\n            [9.,10.,11.,12.,],\n            [13.,14.,15.,16.,],\n        ])\n        result = vector4.create_from_matrix44_translation(mat)\n        np.testing.assert_almost_equal(result, [13.,14.,15.,16.], decimal=5)\n        self.assertTrue(result.dtype == np.float)\n\n    def test_create_from_matrix44_translation_dtype_matches(self):\n        mat = np.array([\n            [1.,2.,3.,4.,],\n            [5.,6.,7.,8.,],\n            [9.,10.,11.,12.,],\n            [13.,14.,15.,16.,],\n        ], dtype=np.float32)\n        result = vector4.create_from_matrix44_translation(mat)\n        np.testing.assert_almost_equal(result, [13.,14.,15.,16.], decimal=5)\n        self.assertTrue(result.dtype == np.float32)\n\n    def test_normalize_single_vector(self):\n        result = vector4.normalize([1.,1.,1.,1.])\n        np.testing.assert_almost_equal(result, [0.5, 0.5, 0.5, 0.5], decimal=5)\n\n    def test_normalize_batch(self):\n        result = vector4.normalize([\n            [1.,1.,1.,1.],\n            [-1.,-1.,-1.,1.],\n            [0.,2.,7.,1.],\n        ])\n        expected = [\n            [0.5, 0.5, 0.5, 0.5],\n            [-0.5,-0.5,-0.5, 0.5],\n            [0., 0.27216553, 0.95257934, 0.13608276],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_squared_length_single_vector(self):\n        result = vector4.squared_length([1.,1.,1.,1.])\n        np.testing.assert_almost_equal(result, 4., decimal=5)\n\n    def test_squared_length_batch(self):\n        result = vector4.squared_length([\n            [1.,1.,1.,1.],\n            [-1.,-1.,-1.,1.],\n            [0.,2.,7.,1.],\n        ])\n        expected = [\n            4.,\n            4.,\n            54.,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_length(self):\n        result = vector4.length([1.,1.,1.,1.])\n        np.testing.assert_almost_equal(result, 2., decimal=5)\n\n    def test_length_batch(self):\n        result = vector4.length([\n            [1.,1.,1.,1.],\n            [-1.,-1.,-1.,1.],\n            [0.,2.,7.,1.],\n        ])\n        expected = [\n            2.,\n            2.,\n            7.34846923,\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length(self):\n        result = vector4.set_length([1.,1.,1.,1.],3.)\n        expected = [1.5,1.5,1.5,1.5]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_set_length_batch_vector(self):\n        result = vector4.set_length([\n            [1.,1.,1.,1.],\n            [-1.,-1.,-1.,1.],\n            [0.,2.,7.,1.],\n            ], 2.0)\n        expected = [\n            [1.,1.,1.,1.],\n            [-1.,-1.,-1.,1.],\n            [0., 0.54433105, 1.90515869, 0.27216553],\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n    def test_dot_adjacent(self):\n        result = vector4.dot([1.,0.,0.,1.], [0.,1.,0.,1.])\n        np.testing.assert_almost_equal(result, 1.0, decimal=5)\n\n    def test_dot_parallel(self):\n        result = vector4.dot([0.,1.,0.,1.], [0.,1.,0.,1.])\n        np.testing.assert_almost_equal(result, 2.0, decimal=5)\n\n    def test_dot_angle(self):\n        result = vector4.dot([.2,.2,0.,1.], [2.,-.2,0.,1.])\n        np.testing.assert_almost_equal(result, 1.359999, decimal=5)\n\n    def test_dot_batch(self):\n        result = vector4.dot([\n            [1.,0.,0.,1.],\n            [0.,1.,0.,1.],\n            [.2,.2,0.,1.]\n        ],[\n            [0.,1.,0.,1.],\n            [0.,1.,0.,1.],\n            [2.,-.2,0.,1.]\n        ])\n        expected = [\n            1.,\n            2.,\n            1.36\n        ]\n        np.testing.assert_almost_equal(result, expected, decimal=5)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
docs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Pyrr documentation build configuration file, created by\n# sphinx-quickstart on Mon Jul  2 16:14:36 2012.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named \'sphinx.ext.*\') or your custom ones.\nextensions = [\'sphinx.ext.autodoc\', \'sphinx.ext.intersphinx\', \'sphinx.ext.todo\', \'sphinx.ext.pngmath\', \'sphinx.ext.ifconfig\', \'sphinx.ext.viewcode\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Pyrr\'\ncopyright = u\'Adam Griffiths\'\n\nwith open(\'../../pyrr/version.py\', \'r\') as f:\n    exec(f.read())\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = __version__\n# The full version, including alpha/beta/rc tags.\nrelease = __version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'default\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'Pyrrdoc\'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\'index\', \'Pyrr.tex\', u\'Pyrr Documentation\',\n   u\'Adam Griffiths\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'pyrr\', u\'Pyrr Documentation\',\n     [u\'Adam Griffiths\'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'Pyrr\', u\'Pyrr Documentation\',\n   u\'Adam Griffiths\', \'Pyrr\', \'3D mathematical functions using NumPy.\',\n   \'Mathematics\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'http://docs.python.org/\': None}\n\n# ensure __init__ is always documented\n# http://stackoverflow.com/questions/5599254/how-to-use-sphinxs-autodoc-to-document-a-classs-init-self-method\ndef skip(app, what, name, obj, skip, options):\n    if name == ""__init__"":\n        return False\n    return skip\n\ndef setup(app):\n    app.connect(""autodoc-skip-member"", skip)\n\n'"
pyrr/objects/__init__.py,0,"b""# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import, division, print_function\n\n__all__ = [\n    'base',\n    'matrix33',\n    'matrix44',\n    'quaternion',\n    'vector3',\n    'vector4',\n]\n\nfrom . import (\n    base,\n    matrix33,\n    matrix44,\n    quaternion,\n    vector3,\n    vector4,\n)\n\nfrom .matrix33 import Matrix33\nfrom .matrix44 import Matrix44\nfrom .quaternion import Quaternion\nfrom .vector3 import Vector3\nfrom .vector4 import Vector4\n\n"""
pyrr/objects/base.py,1,"b'# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nimport numpy as np\nfrom pyrr import vector, vector3\n\nclass NpProxy(object):\n    def __init__(self, index):\n        self._index = index\n\n    def __get__(self, obj, cls):\n        return obj[self._index]\n\n    def __set__(self, obj, value):\n        obj[self._index] = value\n\nclass BaseObject(np.ndarray):\n    _module = None\n    _shape = None\n    def __new__(cls, obj):\n        # ensure the object matches the required shape\n        obj.shape = cls._shape\n        return obj\n\n    def _unsupported_type(self, method, other):\n        raise ValueError(\'Cannot {} a {} to a {}\'.format(method, type(other).__name__, type(self).__name__))\n\n    ########################\n    # Redirect assignment operators\n    def __iadd__(self, other):\n        self[:] = self.__add__(other)\n        return self\n\n    def __isub__(self, other):\n        self[:] = self.__sub__(other)\n        return self\n\n    def __imul__(self, other):\n        self[:] = self.__mul__(other)\n        return self\n\n    def __idiv__(self, other):\n        self[:] = self.__div__(other)\n        return self\n\nclass BaseMatrix(BaseObject):\n    @classmethod\n    def identity(cls, dtype=None):\n        """"""Creates an identity Matrix.\n        """"""\n        return cls(cls._module.create_identity(dtype), dtype)\n\n    @classmethod\n    def from_eulers(cls, eulers, dtype=None):\n        """"""Creates a Matrix from the specified Euler angles.\n        """"""\n        return cls(cls._module.create_from_eulers(eulers, dtype=dtype))\n\n    @classmethod\n    def from_quaternion(cls, quat, dtype=None):\n        """"""Creates a Matrix from a Quaternion.\n        """"""\n        return cls(cls._module.create_from_quaternion(quat, dtype=dtype))\n\n    @classmethod\n    def from_inverse_of_quaternion(cls, quat, dtype=None):\n        """"""Creates a Matrix from the inverse of the specified Quaternion.\n        """"""\n        return cls(cls._module.create_from_inverse_of_quaternion(quat, dtype=dtype))\n\n    @classmethod\n    def from_scale(cls, scale, dtype=None):\n        return cls(cls._module.create_from_scale(scale, dtype=dtype))\n\n    @classmethod\n    def from_x_rotation(cls, theta, dtype=None):\n        """"""Creates a Matrix with a rotation around the X-axis.\n        """"""\n        return cls(cls._module.create_from_x_rotation(theta, dtype=dtype))\n\n    @classmethod\n    def from_y_rotation(cls, theta, dtype=None):\n        return cls(cls._module.create_from_y_rotation(theta, dtype=dtype))\n\n    @classmethod\n    def from_z_rotation(cls, theta, dtype=None):\n        """"""Creates a Matrix with a rotation around the Z-axis.\n        """"""\n        return cls(cls._module.create_from_z_rotation(theta, dtype=dtype))\n\n    @property\n    def inverse(self):\n        """"""Returns the inverse of this matrix.\n        """"""\n        return type(self)(self._module.inverse(self))\n\nclass BaseVector(BaseObject):\n    @classmethod\n    def from_matrix44_translation(cls, matrix, dtype=None):\n        return cls(cls._module.create_from_matrix44_translation(matrix, dtype))\n\n    def normalize(self):\n        self[:] = self.normalized\n\n    @property\n    def normalized(self):\n        return type(self)(self._module.normalize(self))\n\n    def normalise(self):    # TODO: mark as deprecated\n        self[:] = self.normalized\n\n    @property\n    def normalised(self):    # TODO: mark as deprecated\n        return type(self)(self._module.normalize(self))\n\n    @property\n    def squared_length(self):\n        return self._module.squared_length(self)\n\n    @property\n    def length(self):\n        return self._module.length(self)\n\n    @length.setter\n    def length(self, length):\n        self[:] = vector.set_length(self, length)\n\n    def dot(self, other):\n        return vector.dot(self, type(self)(other))\n\n    def cross(self, other):\n        return type(self)(vector3.cross(self[:3], other[:3]))\n\n    def interpolate(self, other, delta):\n        return type(self)(vector.interpolate(self, type(self)(other), delta))\n\n    def normal(self, v2, v3, normalize_result=True):\n        return type(self)(vector3.generate_normals(self, type(self)(v2), type(self)(v3), normalize_result))\n\nclass BaseQuaternion(BaseObject):\n    pass\n\n# pre-declarations to prevent circular imports\nclass BaseMatrix33(BaseMatrix):\n    pass\n\nclass BaseMatrix44(BaseMatrix):\n    pass\n\nclass BaseVector3(BaseVector):\n    pass\n\nclass BaseVector4(BaseVector):\n    pass\n'"
pyrr/objects/matrix33.py,17,"b'# -*- coding: utf-8 -*-\n""""""Represents a 3x3 Matrix.\n\nThe Matrix33 class provides a number of convenient functions and\nconversions.\n::\n\n    import numpy as np\n    from pyrr import Quaternion, Matrix33, Matrix44, Vector3\n\n    m = Matrix33()\n    m = Matrix33([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]])\n\n    # copy constructor\n    m = Matrix44(Matrix44())\n\n    # explicit creation\n    m = Matrix33.identity()\n    m = Matrix33.from_matrix44(Matrix44())\n\n    # inferred conversions\n    m = Matrix33(Quaternion())\n    m = Matrix33(Matrix44())\n\n    # multiply matricies together\n    m = Matrix33() * Matrix33()\n    m = Matrix33() * Matrix44()\n\n    # extract a quaternion from a matrix\n    q = m.quaternion\n\n    # convert from quaternion back to matrix\n    m = q.matrix33\n    m = Matrix33(q)\n\n    # rotate a matrix by a quaternion\n    m = Matrix33.identity() * Quaternion()\n\n    # rotate a vector 3 by a matrix\n    v = Matrix33.from_x_rotation(np.pi) * Vector3([1.,2.,3.])\n\n    # undo a rotation\n    m = Matrix33.from_x_rotation(np.pi)\n    v = m * Vector3([1.,1.,1.])\n    # ~m is the same as m.inverse\n    v = ~m * v\n\n    # access specific parts of the matrix\n    # first row\n    m1 = m.m1\n    # first element, first row\n    m11 = m.m11\n    # third element, third row\n    m33 = m.m33\n    # first row, same as m1\n    r1 = m.r1\n    # first column\n    c1 = m.c1\n""""""\nfrom __future__ import absolute_import\nfrom numbers import Number\nimport numpy as np\nfrom multipledispatch import dispatch\nfrom .base import BaseObject, BaseMatrix, BaseMatrix33, BaseQuaternion, BaseVector, NpProxy\nfrom .. import matrix33\n\nclass Matrix33(BaseMatrix33):\n    _module = matrix33\n    _shape = (3,3,)\n\n    # m<c> style access\n    #: The first row of this Matrix as a numpy.ndarray.\n    m1 = NpProxy(0)\n    #: The second row of this Matrix as a numpy.ndarray.\n    m2 = NpProxy(1)\n    #: The third row of this Matrix as a numpy.ndarray.\n    m3 = NpProxy(2)\n\n    # m<r><c> access\n    #: The [0,0] value of this Matrix.\n    m11 = NpProxy((0,0))\n    #: The [0,1] value of this Matrix.\n    m12 = NpProxy((0,1))\n    #: The [0,2] value of this Matrix.\n    m13 = NpProxy((0,2))\n    #: The [1,0] value of this Matrix.\n    m21 = NpProxy((1,0))\n    #: The [1,1] value of this Matrix.\n    m22 = NpProxy((1,1))\n    #: The [1,2] value of this Matrix.\n    m23 = NpProxy((1,2))\n    #: The [2,0] value of this Matrix.\n    m31 = NpProxy((2,0))\n    #: The [2,1] value of this Matrix.\n    m32 = NpProxy((2,1))\n    #: The [2,2] value of this Matrix.\n    m33 = NpProxy((2,2))\n\n    # rows\n    #: The first row of this Matrix as a numpy.ndarray. This is the same as m1.\n    r1 = NpProxy(0)\n    #: The second row of this Matrix as a numpy.ndarray. This is the same as m2.\n    r2 = NpProxy(1)\n    #: The third row of this Matrix as a numpy.ndarray. This is the same as m3.\n    r3 = NpProxy(2)\n\n    # columns\n    #: The first column of this Matrix as a numpy.ndarray.\n    c1 = NpProxy((slice(0,3),0))\n    #: The second column of this Matrix as a numpy.ndarray.\n    c2 = NpProxy((slice(0,3),1))\n    #: The third column of this Matrix as a numpy.ndarray.\n    c3 = NpProxy((slice(0,3),2))\n\n    ########################\n    # Creation\n    @classmethod\n    def from_matrix44(cls, matrix, dtype=None):\n        """"""Creates a Matrix33 from a Matrix44.\n\n        The Matrix44 translation will be lost.\n        """"""\n        return cls(matrix33.create_from_matrix44(matrix, dtype))\n\n    def __new__(cls, value=None, dtype=None):\n        if value is not None:\n            obj = value\n            if not isinstance(value, np.ndarray):\n                obj = np.array(value, dtype=dtype)\n\n            # matrix44\n            if obj.shape == (4,4) or isinstance(obj, Matrix44):\n                obj = matrix33.create_from_matrix44(obj, dtype=dtype)\n            # quaternion\n            elif obj.shape == (4,) or isinstance(obj, Quaternion):\n                obj = matrix33.create_from_quaternion(obj, dtype=dtype)\n        else:\n            obj = np.zeros(cls._shape, dtype=dtype)\n        obj = obj.view(cls)\n        return super(Matrix33, cls).__new__(cls, obj)\n\n    ########################\n    # Basic Operators\n\n    @dispatch(BaseObject)\n    def __add__(self, other):\n        self._unsupported_type(\'add\', other)\n\n    @dispatch(BaseObject)\n    def __sub__(self, other):\n        self._unsupported_type(\'subtract\', other)\n\n    @dispatch(BaseObject)\n    def __mul__(self, other):\n        self._unsupported_type(\'multiply\', other)\n\n    @dispatch(BaseObject)\n    def __truediv__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch(BaseObject)\n    def __div__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    def __invert__(self):\n        return self.inverse\n\n    ########################\n    # Matrices\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __add__(self, other):\n        return Matrix33(super(Matrix33, self).__add__(Matrix33(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __sub__(self, other):\n        return Matrix33(super(Matrix33, self).__sub__(Matrix33(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __mul__(self, other):\n        return Matrix33(matrix33.multiply(Matrix33(other), self))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __ne__(self, other):\n        return bool(np.any(super(Matrix33, self).__ne__(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __eq__(self, other):\n        return bool(np.all(super(Matrix33, self).__eq__(other)))\n\n    ########################\n    # Quaternions\n    @dispatch(BaseQuaternion)\n    def __mul__(self, other):\n        m = other.matrix33\n        return self * m\n\n    ########################\n    # Vectors\n    @dispatch(BaseVector)\n    def __mul__(self, other):\n        return type(other)(matrix33.apply_to_vector(self, other))\n\n    ########################\n    # Number\n    @dispatch((Number, np.number))\n    def __add__(self, other):\n        return Matrix33(super(Matrix33, self).__add__(other))\n\n    @dispatch((Number, np.number))\n    def __sub__(self, other):\n        return Matrix33(super(Matrix33, self).__sub__(other))\n\n    @dispatch((Number, np.number))\n    def __mul__(self, other):\n        return Matrix33(super(Matrix33, self).__mul__(other))\n\n    @dispatch((Number, np.number))\n    def __truediv__(self, other):\n        return Matrix33(super(Matrix33, self).__truediv__(other))\n\n    @dispatch((Number, np.number))\n    def __div__(self, other):\n        return Matrix33(super(Matrix33, self).__div__(other))\n\n    ########################\n    # Methods and Properties\n    @property\n    def matrix33(self):\n        """"""Returns the Matrix33.\n\n        This can be handy if you\'re not sure what type of Matrix class you have\n        but require a Matrix33.\n        """"""\n        return self\n\n    @property\n    def matrix44(self):\n        """"""Returns a Matrix44 representing this matrix.\n        """"""\n        return Matrix44(self)\n\n    @property\n    def quaternion(self):\n        """"""Returns a Quaternion representing this matrix.\n        """"""\n        return Quaternion(self)\n\nfrom .matrix44 import Matrix44\nfrom .quaternion import Quaternion\n'"
pyrr/objects/matrix44.py,17,"b'# -*- coding: utf-8 -*-\n""""""Represents a 4x4 Matrix.\n\nThe Matrix44 class provides a number of convenient functions and\nconversions.\n::\n\n    import numpy as np\n    from pyrr import Quaternion, Matrix33, Matrix44, Vector4\n\n    m = Matrix44()\n    m = Matrix44([[1.,0.,0.,0.],[0.,1.,0.,0.],[0.,0.,1.,0.],[0.,0.,0.,1.]])\n\n    # copy constructor\n    m = Matrix44(Matrix44())\n\n    # explicit creation\n    m = Matrix44.identity()\n    m = Matrix44.from_matrix44(Matrix44())\n\n    # inferred conversions\n    m = Matrix44(Quaternion())\n    m = Matrix44(Matrix33())\n\n    # multiply matricies together\n    m = Matrix44() * Matrix44()\n\n    # extract a quaternion from a matrix\n    q = m.quaternion\n\n    # convert from quaternion back to matrix\n    m = q.matrix44\n    m = Matrix44(q)\n\n    # rotate a matrix by a quaternion\n    m = Matrix44.identity() * Quaternion()\n\n    # rotate a vector 4 by a matrix\n    v = Matrix44.from_x_rotation(np.pi) * Vector4([1.,2.,3.,1.])\n\n    # undo a rotation\n    m = Matrix44.from_x_rotation(np.pi)\n    v = m * Vector4([1.,1.,1.,1.])\n    # ~m is the same as m.inverse\n    v = ~m * v\n\n    # access specific parts of the matrix\n    # first row\n    m1 = m.m1\n    # first element, first row\n    m11 = m.m11\n    # fourth element, fourth row\n    m44 = m.m44\n    # first row, same as m1\n    r1 = m.r1\n    # first column\n    c1 = m.c1\n""""""\nfrom __future__ import absolute_import\nfrom numbers import Number\nimport numpy as np\nfrom multipledispatch import dispatch\nfrom .base import BaseObject, BaseMatrix, BaseMatrix44, BaseQuaternion, BaseVector, NpProxy\nfrom .. import matrix44\n\nclass Matrix44(BaseMatrix44):\n    _module = matrix44\n    _shape = (4,4,)\n\n    # m<c> style access\n    #: The first row of this Matrix as a numpy.ndarray.\n    m1 = NpProxy(0)\n    #: The second row of this Matrix as a numpy.ndarray.\n    m2 = NpProxy(1)\n    #: The third row of this Matrix as a numpy.ndarray.\n    m3 = NpProxy(2)\n    #: The fourth row of this Matrix as a numpy.ndarray.\n    m4 = NpProxy(3)\n\n    # m<r><c> access\n    #: The [0,0] value of this Matrix.\n    m11 = NpProxy((0,0))\n    #: The [0,1] value of this Matrix.\n    m12 = NpProxy((0,1))\n    #: The [0,2] value of this Matrix.\n    m13 = NpProxy((0,2))\n    #: The [0,3] value of this Matrix.\n    m14 = NpProxy((0,3))\n    #: The [1,0] value of this Matrix.\n    m21 = NpProxy((1,0))\n    #: The [1,1] value of this Matrix.\n    m22 = NpProxy((1,1))\n    #: The [1,2] value of this Matrix.\n    m23 = NpProxy((1,2))\n    #: The [1,3] value of this Matrix.\n    m24 = NpProxy((1,3))\n    #: The [2,0] value of this Matrix.\n    m31 = NpProxy((2,0))\n    #: The [2,1] value of this Matrix.\n    m32 = NpProxy((2,1))\n    #: The [2,2] value of this Matrix.\n    m33 = NpProxy((2,2))\n    #: The [2,3] value of this Matrix.\n    m34 = NpProxy((2,3))\n    #: The [3,0] value of this Matrix.\n    m41 = NpProxy((3,0))\n    #: The [3,1] value of this Matrix.\n    m42 = NpProxy((3,1))\n    #: The [3,2] value of this Matrix.\n    m43 = NpProxy((3,2))\n    #: The [3,3] value of this Matrix.\n    m44 = NpProxy((3,3))\n\n    # rows\n    #: The first row of this Matrix as a numpy.ndarray. This is the same as m1.\n    r1 = NpProxy(0)\n    #: The second row of this Matrix as a numpy.ndarray. This is the same as m2.\n    r2 = NpProxy(1)\n    #: The third row of this Matrix as a numpy.ndarray. This is the same as m3.\n    r3 = NpProxy(2)\n    #: The fourth row of this Matrix as a numpy.ndarray. This is the same as m4.\n    r4 = NpProxy(3)\n\n    # columns\n    #: The first column of this Matrix as a numpy.ndarray.\n    c1 = NpProxy((slice(0,4),0))\n    #: The second column of this Matrix as a numpy.ndarray.\n    c2 = NpProxy((slice(0,4),1))\n    #: The third column of this Matrix as a numpy.ndarray.\n    c3 = NpProxy((slice(0,4),2))\n    #: The fourth column of this Matrix as a numpy.ndarray.\n    c4 = NpProxy((slice(0,4),3))\n\n    ########################\n    # Creation\n    @classmethod\n    def from_matrix33(cls, matrix, dtype=None):\n        """"""Creates a Matrix44 from a Matrix33.\n        """"""\n        return cls(matrix44.create_from_matrix33(matrix, dtype))\n\n    @classmethod\n    def perspective_projection(cls, fovy, aspect, near, far, dtype=None):\n        """"""Creates a Matrix44 for use as a perspective projection matrix.\n        """"""\n        return cls(matrix44.create_perspective_projection(fovy, aspect, near, far, dtype))\n\n    @classmethod\n    def perspective_projection_bounds(cls, left, right, top, bottom, near, far, dtype=None):\n        """"""Creates a Matrix44 for use as a perspective projection matrix.\n        """"""\n        return cls(matrix44.create_perspective_projection_from_bounds(left, right, top, bottom, near, far, dtype))\n\n    @classmethod\n    def orthogonal_projection(cls, left, right, top, bottom, near, far, dtype=None):\n        """"""Creates a Matrix44 for use as an orthogonal projection matrix.\n        """"""\n        return cls(matrix44.create_orthogonal_projection(left, right, top, bottom, near, far, dtype))\n\n    @classmethod\n    def look_at(cls, eye, target, up, dtype=None):\n        """"""Creates a Matrix44 for use as a lookAt matrix.\n        """"""\n        return cls(matrix44.create_look_at(eye, target, up, dtype))\n\n    @classmethod\n    def from_translation(cls, translation, dtype=None):\n        """"""Creates a Matrix44 from the specified translation.\n        """"""\n        return cls(matrix44.create_from_translation(translation, dtype=dtype))\n\n    def __new__(cls, value=None, dtype=None):\n        if value is not None:\n            obj = value\n            if not isinstance(value, np.ndarray):\n                obj = np.array(value, dtype=dtype)\n\n            # matrix33\n            if obj.shape == (3,3) or isinstance(obj, Matrix33):\n                obj = matrix44.create_from_matrix33(obj, dtype=dtype)\n            # quaternion\n            elif obj.shape == (4,) or isinstance(obj, Quaternion):\n                obj = matrix44.create_from_quaternion(obj, dtype=dtype)\n        else:\n            obj = np.zeros(cls._shape, dtype=dtype)\n        obj = obj.view(cls)\n        return super(Matrix44, cls).__new__(cls, obj)\n\n    ########################\n    # Basic Operators\n    @dispatch(BaseObject)\n    def __add__(self, other):\n        self._unsupported_type(\'add\', other)\n\n    @dispatch(BaseObject)\n    def __sub__(self, other):\n        self._unsupported_type(\'subtract\', other)\n\n    @dispatch(BaseObject)\n    def __mul__(self, other):\n        self._unsupported_type(\'multiply\', other)\n\n    @dispatch(BaseObject)\n    def __truediv__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch(BaseObject)\n    def __div__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    def __invert__(self):\n        return self.inverse\n\n    ########################\n    # Matrices\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __add__(self, other):\n        return Matrix44(super(Matrix44, self).__add__(Matrix44(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __sub__(self, other):\n        return Matrix44(super(Matrix44, self).__sub__(Matrix44(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __mul__(self, other):\n        return Matrix44(matrix44.multiply(Matrix44(other), self))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __ne__(self, other):\n        return bool(np.any(super(Matrix44, self).__ne__(other)))\n\n    @dispatch((BaseMatrix, np.ndarray, list))\n    def __eq__(self, other):\n        return bool(np.all(super(Matrix44, self).__eq__(other)))\n\n    ########################\n    # Quaternions\n    @dispatch(BaseQuaternion)\n    def __mul__(self, other):\n        m = other.matrix44\n        return self * m\n\n    ########################\n    # Vectors\n    @dispatch(BaseVector)\n    def __mul__(self, other):\n        return type(other)(matrix44.apply_to_vector(self, other))\n\n    ########################\n    # Number\n    @dispatch((Number, np.number))\n    def __add__(self, other):\n        return Matrix44(super(Matrix44, self).__add__(other))\n\n    @dispatch((Number, np.number))\n    def __sub__(self, other):\n        return Matrix44(super(Matrix44, self).__sub__(other))\n\n    @dispatch((Number, np.number))\n    def __mul__(self, other):\n        return Matrix44(super(Matrix44, self).__mul__(other))\n\n    @dispatch((Number, np.number))\n    def __truediv__(self, other):\n        return Matrix44(super(Matrix44, self).__truediv__(other))\n\n    @dispatch((Number, np.number))\n    def __div__(self, other):\n        return Matrix44(super(Matrix44, self).__div__(other))\n\n    ########################\n    # Methods and Properties\n    @property\n    def matrix33(self):\n        """"""Returns a Matrix33 representing this matrix.\n        """"""\n        return Matrix33(self)\n\n    @property\n    def matrix44(self):\n        """"""Returns the Matrix44.\n\n        This can be handy if you\'re not sure what type of Matrix class you have\n        but require a Matrix44.\n        """"""\n        return self\n\n    @property\n    def quaternion(self):\n        """"""Returns a Quaternion representing this matrix.\n        """"""\n        return Quaternion(self)\n\n    def decompose(self):\n        """"""Decomposes an affine transformation matrix into its scale, rotation and\n        translation components.\n\n        :param numpy.array m: A matrix.\n        :return: tuple (scale, rotation, translation)\n            Vector3 scale\n            Quaternion rotation\n            Vector3 translation\n        """"""\n        scale, rotate, translate = matrix44.decompose(self)\n        return Vector3(scale), Quaternion(rotate), Vector3(translate)\n\nfrom .matrix33 import Matrix33\nfrom .quaternion import Quaternion\nfrom .vector3 import Vector3\n'"
pyrr/objects/quaternion.py,15,"b'# -*- coding: utf-8 -*-\n""""""Represents a Quaternion rotation.\n\nThe Quaternion class provides a number of convenient functions and\nconversions.\n::\n\n    import numpy as np\n    from pyrr import Quaternion, Matrix33, Matrix44, Vector3, Vector4\n\n    q = Quaternion()\n\n    # explicit creation\n    q = Quaternion.from_x_rotation(np.pi / 2.0)\n    q = Quaternion.from_matrix(Matrix33.identity())\n    q = Quaternion.from_matrix(Matrix44.identity())\n\n    # inferred conversions\n    q = Quaternion(Quaternion())\n    q = Quaternion(Matrix33.identity())\n    q = Quaternion(Matrix44.identity())\n\n    # apply one quaternion to another\n    q1 = Quaternion.from_y_rotation(np.pi / 2.0)\n    q2 = Quaternion.from_x_rotation(np.pi / 2.0)\n    q3 = q1 * q2\n\n    # extract a matrix from the quaternion\n    m33 = q3.matrix33\n    m44 = q3.matrix44\n\n    # convert from matrix back to quaternion\n    q4 = Quaternion(m44)\n\n    # rotate a quaternion by a matrix\n    q = Quaternion() * Matrix33.identity()\n    q = Quaternion() * Matrix44.identity()\n\n    # apply quaternion to a vector\n    v3 = Quaternion() * Vector3()\n    v4 = Quaternion() * Vector4()\n\n    # undo a rotation\n    q = Quaternion.from_x_rotation(np.pi / 2.0)\n    v = q * Vector3([1.,1.,1.])\n    # ~q is the same as q.conjugate\n    original = ~q * v\n    assert np.allclose(original, v)\n\n    # get the dot product of 2 Quaternions\n    dot = Quaternion() | Quaternion.from_x_rotation(np.pi / 2.0)\n""""""\n\nfrom __future__ import absolute_import\nimport numpy as np\nfrom multipledispatch import dispatch\nfrom .base import BaseObject, BaseQuaternion, BaseMatrix, BaseVector, NpProxy\nfrom .. import quaternion\n\nclass Quaternion(BaseQuaternion):\n    _module = quaternion\n    _shape = (4,)\n\n    #: The X value of this Quaternion.\n    x = NpProxy(0)\n    #: The Y value of this Quaternion.\n    y = NpProxy(1)\n    #: The Z value of this Quaternion.\n    z = NpProxy(2)\n    #: The W value of this Quaternion.\n    w = NpProxy(3)\n    #: The X,Y value of this Quaternion as a numpy.ndarray.\n    xy = NpProxy([0,1])\n    #: The X,Y,Z value of this Quaternion as a numpy.ndarray.\n    xyz = NpProxy([0,1,2])\n    #: The X,Y,Z,W value of this Quaternion as a numpy.ndarray.\n    xyzw = NpProxy([0,1,2,3])\n    #: The X,Z value of this Quaternion as a numpy.ndarray.\n    xz = NpProxy([0,2])\n    #: The X,Z,W value of this Quaternion as a numpy.ndarray.\n    xzw = NpProxy([0,2,3])\n    #: The X,Y,W value of this Quaternion as a numpy.ndarray.\n    xyw = NpProxy([0,1,3])\n    #: The X,W value of this Quaternion as a numpy.ndarray.\n    xw = NpProxy([0,3])\n\n    ########################\n    # Creation\n    @classmethod\n    def from_x_rotation(cls, theta, dtype=None):\n        """"""Creates a new Quaternion with a rotation around the X-axis.\n        """"""\n        return cls(quaternion.create_from_x_rotation(theta, dtype))\n\n    @classmethod\n    def from_y_rotation(cls, theta, dtype=None):\n        """"""Creates a new Quaternion with a rotation around the Y-axis.\n        """"""\n        return cls(quaternion.create_from_y_rotation(theta, dtype))\n\n    @classmethod\n    def from_z_rotation(cls, theta, dtype=None):\n        """"""Creates a new Quaternion with a rotation around the Z-axis.\n        """"""\n        return cls(quaternion.create_from_z_rotation(theta, dtype))\n\n    @classmethod\n    def from_axis_rotation(cls, axis, theta, dtype=None):\n        """"""Creates a new Quaternion with a rotation around the specified axis.\n        """"""\n        return cls(quaternion.create_from_axis_rotation(axis, theta, dtype))\n\n    @classmethod\n    def from_axis(cls, axis, dtype=None):\n        """"""Creates a new Quaternion from an axis with angle magnitude.\n        """"""\n        return cls(quaternion.create_from_axis(axis, dtype))\n\n    @classmethod\n    def from_matrix(cls, matrix, dtype=None):\n        """"""Creates a Quaternion from the specified Matrix (Matrix33 or Matrix44).\n        """"""\n        return cls(quaternion.create_from_matrix(matrix, dtype))\n\n    @classmethod\n    def from_eulers(cls, eulers, dtype=None):\n        """"""Creates a Quaternion from the specified Euler angles.\n        """"""\n        return cls(quaternion.create_from_eulers(eulers, dtype))\n\n    @classmethod\n    def from_inverse_of_eulers(cls, eulers, dtype=None):\n        """"""Creates a Quaternion from the inverse of the specified Euler angles.\n        """"""\n        return cls(quaternion.create_from_inverse_of_eulers(eulers, dtype))\n\n    def __new__(cls, value=None, dtype=None):\n        if value is not None:\n            obj = value\n            if not isinstance(value, np.ndarray):\n                obj = np.array(value, dtype=dtype)\n\n            # matrix33, matrix44\n            if obj.shape in ((4,4,), (3,3,)) or isinstance(obj, (Matrix33, Matrix44)):\n                obj = quaternion.create_from_matrix(obj, dtype=dtype)\n        else:\n            obj = quaternion.create(dtype=dtype)\n        obj = obj.view(cls)\n        return super(Quaternion, cls).__new__(cls, obj)\n\n    ########################\n    # Basic Operators\n    @dispatch(BaseObject)\n    def __add__(self, other):\n        self._unsupported_type(\'add\', other)\n\n    @dispatch(BaseObject)\n    def __sub__(self, other):\n        self._unsupported_type(\'subtract\', other)\n\n    @dispatch(BaseObject)\n    def __mul__(self, other):\n        self._unsupported_type(\'multiply\', other)\n\n    @dispatch(BaseObject)\n    def __truediv__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch(BaseObject)\n    def __div__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    ########################\n    # Quaternions\n    @dispatch((BaseQuaternion, np.ndarray, list))\n    def __sub__(self, other):\n        return Quaternion(super(Quaternion, self).__sub__(other))\n\n    @dispatch((BaseQuaternion, list))\n    def __mul__(self, other):\n        return self.cross(other)\n\n    @dispatch((BaseQuaternion, list))\n    def __or__(self, other):\n        return self.dot(other)\n\n    def __invert__(self):\n        return self.conjugate\n\n    @dispatch((BaseQuaternion, np.ndarray, list))\n    def __ne__(self, other):\n        # For quaternions q and -q represent the same rotation\n        return bool(np.any(super(Quaternion, self).__ne__(other)))\\\n               or bool(np.all(super(Quaternion, self).__eq__(-other)))\n\n    @dispatch((BaseQuaternion, np.ndarray, list))\n    def __eq__(self, other):\n        # For quaternions q and -q represent the same rotation\n        return bool(np.all(super(Quaternion, self).__eq__(other))) \\\n               or bool(np.all(super(Quaternion, self).__eq__(-other)))\n\n    ########################\n    # Matrices\n    @dispatch(BaseMatrix)\n    def __mul__(self, other):\n        return self * Quaternion(other)\n\n    ########################\n    # Vectors\n    @dispatch(BaseVector)\n    def __mul__(self, other):\n        return type(other)(quaternion.apply_to_vector(self, other))\n\n    ########################\n    # Methods and Properties\n    @property\n    def length(self):\n        """"""Returns the length of this Quaternion.\n        """"""\n        return quaternion.length(self)\n\n    def normalize(self):\n        """"""normalizes this Quaternion in-place.\n        """"""\n        self[:] = quaternion.normalize(self)\n\n    @property\n    def normalized(self):\n        """"""Returns a normalized version of this Quaternion as a new Quaternion.\n        """"""\n        return Quaternion(quaternion.normalize(self))\n\n    def normalise(self):    # TODO: mark as deprecated\n        """"""normalizes this Quaternion in-place.\n        """"""\n        self[:] = quaternion.normalize(self)\n\n    @property\n    def normalised(self):    # TODO: mark as deprecated\n        """"""Returns a normalized version of this Quaternion as a new Quaternion.\n        """"""\n        return Quaternion(quaternion.normalize(self))\n\n    @property\n    def angle(self):\n        """"""Returns the angle around the axis of rotation of this Quaternion as a float.\n        """"""\n        return quaternion.rotation_angle(self)\n\n    @property\n    def axis(self):\n        """"""Returns the axis of rotation of this Quaternion as a Vector3.\n        """"""\n        return Vector3(quaternion.rotation_axis(self))\n\n    def cross(self, other):\n        """"""Returns the cross of this Quaternion and another.\n\n        This is the equivalent of combining Quaternion rotations (like Matrix multiplication).\n        """"""\n        return Quaternion(quaternion.cross(self, other))\n\n    def lerp(self, other, t):\n        """"""Interpolates between quat1 and quat2 by t.\n        The parameter t is clamped to the range [0, 1]\n        """"""\n        return Quaternion(quaternion.lerp(self, other, t))\n\n    def slerp(self, other, t):\n        """"""Spherically interpolates between quat1 and quat2 by t.\n        The parameter t is clamped to the range [0, 1]\n        """"""\n        return Quaternion(quaternion.slerp(self, other, t))\n\n    def dot(self, other):\n        """"""Returns the dot of this Quaternion and another.\n        """"""\n        return quaternion.dot(self, other)\n\n    @property\n    def conjugate(self):\n        """"""Returns the conjugate of this Quaternion.\n\n        This is a Quaternion with the opposite rotation.\n        """"""\n        return Quaternion(quaternion.conjugate(self))\n\n    @property\n    def inverse(self):\n        """"""Returns the inverse of this quaternion.\n        """"""\n        return Quaternion(quaternion.inverse(self))\n\n    def exp(self):\n        """"""Returns a new Quaternion representing the exponentional of this Quaternion\n        """"""\n        return Quaternion(quaternion.exp(self))\n\n    def power(self, exponent):\n        """"""Returns a new Quaternion representing this Quaternion to the power of the exponent.\n        """"""\n        return Quaternion(quaternion.power(self, exponent))\n\n    @property\n    def negative(self):\n        """"""Returns the negative of the Quaternion.\n        """"""\n        return Quaternion(quaternion.negate(self))\n\n    @property\n    def is_identity(self):\n        """"""Returns True if the Quaternion has no rotation (0.,0.,0.,1.).\n        """"""\n        return quaternion.is_identity(self)\n\n    @property\n    def matrix44(self):\n        """"""Returns a Matrix44 representation of this Quaternion.\n        """"""\n        return Matrix44.from_quaternion(self)\n\n    @property\n    def matrix33(self):\n        """"""Returns a Matrix33 representation of this Quaternion.\n        """"""\n        return Matrix33.from_quaternion(self)\n\nfrom .vector3 import Vector3\nfrom .matrix33 import Matrix33\nfrom .matrix44 import Matrix44\n'"
pyrr/objects/vector3.py,24,"b'# -*- coding: utf-8 -*-\n""""""Represents a 3 dimensional Vector.\n\nThe Vector3 class provides a number of convenient functions and\nconversions.\n::\n\n    import numpy as np\n    from pyrr import Quaternion, Matrix33, Matrix44, Vector3\n\n    v = Vector3()\n    v = Vector3([1.,2.,3.])\n\n    # copy constructor\n    v = Vector3(Vector3())\n\n    # add / subtract vectors\n    v = Vector3([1.,2.,3.]) + Vector3([4.,5.,6.])\n\n    # rotate a vector by a Matrix\n    v = Matrix33.identity() * Vector3([1.,2.,3.])\n    v = Matrix44.identity() * Vector3([1.,2.,3.])\n\n    # rotate a vector by a Quaternion\n    v = Quaternion() * Vector3([1.,2.,3.])\n\n    # get the dot-product of 2 vectors\n    d = Vector3([1.,0.,0.]) | Vector3([0.,1.,0.])\n\n    # get the cross-product of 2 vectors\n    x = Vector3([1.,0.,0.]) ^ Vector3([0.,1.,0.])\n\n    # access specific parts of the vector\n    # x value\n    x,y,z = v.x, v.y, v.z\n\n    # access groups of values as np.ndarray\'s\n    xy = v.xy\n    xz = v.xz\n    xyz = v.xyz\n""""""\nfrom __future__ import absolute_import, division\nfrom numbers import Number\nimport numpy as np\nfrom multipledispatch import dispatch\nfrom .base import BaseObject, BaseVector3, BaseMatrix44, NpProxy\nfrom .. import vector3\n\n# TODO: add < <= > >= == != operators\n\nclass Vector3(BaseVector3):\n    _module = vector3\n    _shape = (3,)\n\n    #: The X value of this Vector.\n    x = NpProxy(0)\n    #: The Y value of this Vector.\n    y = NpProxy(1)\n    #: The Z value of this Vector.\n    z = NpProxy(2)\n    #: The X,Y values of this Vector as a numpy.ndarray.\n    xy = NpProxy([0,1])\n    #: The X,Y,Z values of this Vector as a numpy.ndarray.\n    xyz = NpProxy([0,1,2])\n    #: The X,Z values of this Vector as a numpy.ndarray.\n    xz = NpProxy([0,2])\n\n    ########################\n    # Creation\n    @classmethod\n    def from_vector4(cls, vector, dtype=None):\n        """"""Create a Vector3 from a Vector4.\n\n        Returns the Vector3 and the W component as a tuple.\n        """"""\n        vec, w = vector3.create_from_vector4(vector, dtype)\n        return (cls(vec), w)\n\n    def __new__(cls, value=None, w=0.0, dtype=None):\n        if value is not None:\n            obj = value\n            if not isinstance(value, np.ndarray):\n                obj = np.array(value, dtype=dtype)\n\n            # matrix44\n            if obj.shape in ((4,4,)) or isinstance(obj, BaseMatrix44):\n                obj = vector3.create_from_matrix44_translation(obj, dtype=dtype)\n        else:\n            obj = np.zeros(cls._shape, dtype=dtype)\n        obj = obj.view(cls)\n        return super(Vector3, cls).__new__(cls, obj)\n\n    ########################\n    # Basic Operators\n    @dispatch(BaseObject)\n    def __add__(self, other):\n        self._unsupported_type(\'add\', other)\n\n    @dispatch(BaseObject)\n    def __sub__(self, other):\n        self._unsupported_type(\'subtract\', other)\n\n    @dispatch(BaseObject)\n    def __mul__(self, other):\n        self._unsupported_type(\'multiply\', other)\n\n    @dispatch(BaseObject)\n    def __truediv__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch(BaseObject)\n    def __div__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __xor__(self, other):\n        self._unsupported_type(\'XOR\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __or__(self, other):\n        self._unsupported_type(\'OR\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __ne__(self, other):\n        self._unsupported_type(\'NE\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __eq__(self, other):\n        self._unsupported_type(\'EQ\', other)\n\n    ########################\n    # Vectors\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __add__(self, other):\n        return Vector3(super(Vector3, self).__add__(other))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __sub__(self, other):\n        return Vector3(super(Vector3, self).__sub__(other))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __mul__(self, other):\n        return Vector3(super(Vector3, self).__mul__(other))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __truediv__(self, other):\n        return Vector3(super(Vector3, self).__truediv__(other))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __div__(self, other):\n        return Vector3(super(Vector3, self).__div__(other))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __xor__(self, other):\n        return self.cross(other)\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __or__(self, other):\n        return self.dot(other)\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __ne__(self, other):\n        return bool(np.any(super(Vector3, self).__ne__(other)))\n\n    @dispatch((BaseVector3, np.ndarray, list))\n    def __eq__(self, other):\n        return bool(np.all(super(Vector3, self).__eq__(other)))\n\n    ########################\n    # Number\n    @dispatch((Number,np.number))\n    def __add__(self, other):\n        return Vector3(super(Vector3, self).__add__(other))\n\n    @dispatch((Number,np.number))\n    def __sub__(self, other):\n        return Vector3(super(Vector3, self).__sub__(other))\n\n    @dispatch((Number,np.number))\n    def __mul__(self, other):\n        return Vector3(super(Vector3, self).__mul__(other))\n\n    @dispatch((Number,np.number))\n    def __truediv__(self, other):\n        return Vector3(super(Vector3, self).__truediv__(other))\n\n    @dispatch((Number,np.number))\n    def __div__(self, other):\n        return Vector3(super(Vector3, self).__div__(other))\n\n    ########################\n    # Methods and Properties\n    @property\n    def inverse(self):\n        """"""Returns the opposite of this vector.\n        """"""\n        return Vector3(-self)\n\n    @property\n    def vector3(self):\n        return self\n'"
pyrr/objects/vector4.py,23,"b'# -*- coding: utf-8 -*-\n""""""Represents a 4 dimensional Vector.\n\nThe Vector4 class provides a number of convenient functions and\nconversions.\n::\n\n    import numpy as np\n    from pyrr import Quaternion, Matrix33, Matrix44, Vector4\n\n    v = Vector4()\n    v = Vector4([1.,2.,3.])\n\n    # explicit creation\n    v = Vector4.from_vector3(Vector3([1.,2.,3.]), w=1.0)\n\n    # copy constructor\n    v = Vector4(Vector4())\n\n    # add / subtract vectors\n    v = Vector4([1.,2.,3.,4.]) + Vector4([4.,5.,6.,7.])\n\n    # rotate a vector by a Matrix\n    v = Matrix44.identity() * Vector4([1.,2.,3.,4.])\n\n    # rotate a vector by a Quaternion\n    v = Quaternion() * Vector4([1.,2.,3.,4.])\n\n    # get the dot-product of 2 vectors\n    d = Vector4([1.,0.,0.,0.]) | Vector4([0.,1.,0.,0.])\n\n    # access specific parts of the vector\n    # x value\n    x,y,z,w = v.x, v.y, v.z, v.w\n\n    # access groups of values as np.ndarray\'s\n    xy = v.xy\n    xyz = v.xyz\n    xyzw = v.xyzw\n    xz = v.xz\n    xw = v.xw\n    xyw = v.xyw\n    xzw = v.xzw\n""""""\nfrom __future__ import absolute_import\nfrom numbers import Number\nimport numpy as np\nfrom multipledispatch import dispatch\nfrom .base import BaseObject, BaseVector4, BaseMatrix44, NpProxy\nfrom .. import vector4\n\n# TODO: add < <= > >= == != operators\n\nclass Vector4(BaseVector4):\n    _module = vector4\n    _shape = (4,)\n\n    #: The X value of this Vector.\n    x = NpProxy(0)\n    #: The Y value of this Vector.\n    y = NpProxy(1)\n    #: The Z value of this Vector.\n    z = NpProxy(2)\n    #: The W value of this Vector.\n    w = NpProxy(3)\n    #: The X,Y values of this Vector as a numpy.ndarray.\n    xy = NpProxy([0,1])\n    #: The X,Y,Z values of this Vector as a numpy.ndarray.\n    xyz = NpProxy([0,1,2])\n    #: The X,Y,Z,W values of this Vector as a numpy.ndarray.\n    xyzw = NpProxy(slice(0,4))\n    #: The X,Z values of this Vector as a numpy.ndarray.\n    xz = NpProxy([0,2])\n    #: The X,W values of this Vector as a numpy.ndarray.\n    xw = NpProxy([0,3])\n    #: The X,Y,W values of this Vector as a numpy.ndarray.\n    xyw = NpProxy([0,1,3])\n    #: The X,Z,W values of this Vector as a numpy.ndarray.\n    xzw = NpProxy([0,2,3])\n\n    ########################\n    # Creation\n    @classmethod\n    def from_vector3(cls, vector, w=0.0, dtype=None):\n        """"""Create a Vector4 from a Vector3.\n\n        By default, the W value is 0.0.\n        """"""\n        return cls(vector4.create_from_vector3(vector, w, dtype))\n\n    def __new__(cls, value=None, dtype=None):\n        if value is not None:\n            obj = value\n            if not isinstance(value, np.ndarray):\n                obj = np.array(value, dtype=dtype)\n\n            # matrix44\n            if obj.shape in ((4,4,)) or isinstance(obj, BaseMatrix44):\n                obj = vector4.create_from_matrix44_translation(obj, dtype=dtype)\n        else:\n            obj = np.zeros(cls._shape, dtype=dtype)\n        obj = obj.view(cls)\n        return super(Vector4, cls).__new__(cls, obj)\n\n    ########################\n    # Basic Operators\n    @dispatch(BaseObject)\n    def __add__(self, other):\n        self._unsupported_type(\'add\', other)\n\n    @dispatch(BaseObject)\n    def __sub__(self, other):\n        self._unsupported_type(\'subtract\', other)\n\n    @dispatch(BaseObject)\n    def __mul__(self, other):\n        self._unsupported_type(\'multiply\', other)\n\n    @dispatch(BaseObject)\n    def __truediv__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch(BaseObject)\n    def __div__(self, other):\n        self._unsupported_type(\'divide\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __xor__(self, other):\n        self._unsupported_type(\'XOR\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __or__(self, other):\n        self._unsupported_type(\'OR\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __ne__(self, other):\n        self._unsupported_type(\'NE\', other)\n\n    @dispatch((BaseObject, Number, np.number))\n    def __eq__(self, other):\n        self._unsupported_type(\'EQ\', other)\n\n    ########################\n    # Vectors\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __add__(self, other):\n        return Vector4(super(Vector4, self).__add__(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __sub__(self, other):\n        return Vector4(super(Vector4, self).__sub__(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __mul__(self, other):\n        return Vector4(super(Vector4, self).__mul__(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __truediv__(self, other):\n        return Vector4(super(Vector4, self).__truediv__(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __div__(self, other):\n        return Vector4(super(Vector4, self).__div__(other))\n\n    #@dispatch(BaseVector)\n    #def __xor__(self, other):\n    #    return self.cross(Vector4(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __or__(self, other):\n        return self.dot(Vector4(other))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __ne__(self, other):\n        return bool(np.any(super(Vector4, self).__ne__(other)))\n\n    @dispatch((BaseVector4, np.ndarray, list))\n    def __eq__(self, other):\n        return bool(np.all(super(Vector4, self).__eq__(other)))\n\n    ########################\n    # Number\n    @dispatch((Number, np.number))\n    def __add__(self, other):\n        return Vector4(super(Vector4, self).__add__(other))\n\n    @dispatch((Number, np.number))\n    def __sub__(self, other):\n        return Vector4(super(Vector4, self).__sub__(other))\n\n    @dispatch((Number, np.number))\n    def __mul__(self, other):\n        return Vector4(super(Vector4, self).__mul__(other))\n\n    @dispatch((Number, np.number))\n    def __truediv__(self, other):\n        return Vector4(super(Vector4, self).__truediv__(other))\n\n    @dispatch((Number, np.number))\n    def __div__(self, other):\n        return Vector4(super(Vector4, self).__div__(other))\n\n    ########################\n    # Methods and Properties\n    @property\n    def inverse(self):\n        """"""Returns the opposite of this vector.\n        """"""\n        return Vector4(-self)\n\n    @property\n    def vector3(self):\n        """"""Returns a Vector3 and the W component as a tuple.\n        """"""\n        return (Vector3(self[:3]), self[3])\n\nfrom .matrix44 import Matrix44\nfrom .vector3 import Vector3\n'"
tests/objects/__init__.py,0,b''
tests/objects/test_equivalence.py,18,"b'from __future__ import absolute_import, division, print_function\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr import Quaternion, Matrix44, Matrix33, Vector3, Vector4, euler\n\n\nclass test_matrix_quaternion(unittest.TestCase):\n    def test_m44_q_equivalence(self):\n        """"""Test for equivalance of matrix and quaternion rotations.\n\n        Create a matrix and quaternion, rotate each by the same values\n        then convert matrix<->quaternion and check the results are the same.\n        """"""\n        m = Matrix44.from_x_rotation(np.pi / 2.)\n        mq = Quaternion.from_matrix(m)\n\n        q = Quaternion.from_x_rotation(np.pi / 2.)\n        qm = Matrix44.from_quaternion(q)\n\n        self.assertTrue(np.allclose(np.dot([1., 0., 0., 1.], m), [1., 0., 0., 1.]))\n        self.assertTrue(np.allclose(np.dot([1., 0., 0., 1.], qm), [1., 0., 0., 1.]))\n\n        self.assertTrue(np.allclose(q * Vector4([1., 0., 0., 1.]), [1., 0., 0., 1.]))\n        self.assertTrue(np.allclose(mq * Vector4([1., 0., 0., 1.]), [1., 0., 0., 1.]))\n\n        np.testing.assert_almost_equal(np.array(q), np.array(mq), decimal=5)\n        np.testing.assert_almost_equal(np.array(m), np.array(qm), decimal=5)\n\n    def test_euler_equivalence(self):\n        eulers = euler.create_from_x_rotation(np.pi / 2.)\n        m = Matrix33.from_x_rotation(np.pi / 2.)\n        q = Quaternion.from_x_rotation(np.pi / 2.)\n        qm = Matrix33.from_quaternion(q)\n        em = Matrix33.from_eulers(eulers)\n        self.assertTrue(np.allclose(qm, m))\n        self.assertTrue(np.allclose(qm, em))\n        self.assertTrue(np.allclose(m, em))\n\n    def test_quaternion_matrix_conversion(self):\n        # https://au.mathworks.com/help/robotics/ref/quat2rotm.html?requestedDomain=www.mathworks.com\n        q = Quaternion([0.7071, 0., 0., 0.7071])\n        m33 = q.matrix33\n        expected = np.array([\n            [1., 0., 0.],\n            [0.,-0.,-1.],\n            [0., 1.,-0.],\n        ])\n        self.assertTrue(np.allclose(m33, expected))\n\n        # issue #42\n        q = Quaternion([0.80087974, 0.03166748, 0.59114721,-0.09018753])\n        m33 = q.matrix33\n        q2 = Quaternion.from_matrix(m33)\n        print(q, q2)\n        self.assertTrue(np.allclose(q, q2))\n\n        q3 = Quaternion.from_matrix(m33.T)\n        self.assertFalse(np.allclose(q2, q3))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tests/objects/test_examples.py,2,"b'from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\n\n\nclass test_oo_examples(unittest.TestCase):\n    def test_oo_examples(self):\n        from pyrr import Quaternion, Matrix44, Vector3\n        import numpy as np\n\n        point = Vector3([1.,2.,3.])\n        orientation = Quaternion()\n        translation = Vector3()\n        scale = Vector3([1.,1.,1.])\n\n        # translate along X by 1\n        translation += [1.0, 0.0, 0.0]\n\n        # rotate about Y by pi/2\n        rotation = Quaternion.from_y_rotation(np.pi / 2.0)\n        orientation = rotation * orientation\n\n        # create a matrix\n        # start our matrix off using the scale\n        matrix = Matrix44.from_scale(scale)\n\n        # apply our orientation\n        # we can multiply matricies and quaternions directly!\n        matrix = matrix * orientation\n\n        # apply our translation\n        translation = Matrix44.from_translation(translation)\n        matrix = matrix * translation\n\n        # transform our point by the matrix\n        # vectors are transformable by matrices and quaternions directly\n        point = matrix * point\n\n    def test_conversions(self):\n        from pyrr import Quaternion, Matrix33, Matrix44, Vector3, Vector4\n\n        v3 = Vector3([1.,0.,0.])\n        v4 = Vector4.from_vector3(v3, w=1.0)\n        v3, w = Vector3.from_vector4(v4)\n\n        m44 = Matrix44()\n        q = Quaternion(m44)\n        m33 = Matrix33(q)\n\n        m33 = Matrix44().matrix33\n        m44 = Matrix33().matrix44\n        q = Matrix44().quaternion\n        q = Matrix33().quaternion\n\n        m33 = Quaternion().matrix33\n        m44 = Quaternion().matrix44\n\n    def test_operators(self):\n        from pyrr import Quaternion, Matrix44, Matrix33, Vector3, Vector4\n        import numpy as np\n\n        # matrix multiplication\n        m = Matrix44() * Matrix33()\n        m = Matrix44() * Quaternion()\n        m = Matrix33() * Quaternion()\n\n        # matrix inverse\n        m = ~Matrix44.from_x_rotation(np.pi)\n\n        # quaternion multiplication\n        q = Quaternion() * Quaternion()\n        q = Quaternion() * Matrix44()\n        q = Quaternion() * Matrix33()\n\n        # quaternion inverse (conjugate)\n        q = ~Quaternion()\n\n        # quaternion dot product\n        d = Quaternion() | Quaternion()\n\n        # vector oprations\n        v = Vector3() + Vector3()\n        v = Vector4() - Vector4()\n\n        # vector transform\n        v = Quaternion() * Vector3()\n        v = Matrix44() * Vector3()\n        v = Matrix44() * Vector4()\n        v = Matrix33() * Vector3()\n\n        # dot and cross products\n        dot = Vector3() | Vector3()\n        cross = Vector3() ^ Vector3()\n'"
tests/objects/test_matrix33.py,62,"b""from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr.objects.matrix33 import Matrix33\nfrom pyrr.objects.matrix44 import Matrix44\nfrom pyrr.objects.quaternion import Quaternion\nfrom pyrr.objects.vector3 import Vector3\nfrom pyrr.objects.vector4 import Vector4\nfrom pyrr import matrix33\nfrom pyrr import matrix44\nfrom pyrr import quaternion\n\n\nclass test_object_matrix33(unittest.TestCase):\n    _shape = (3,3)\n    _size = np.multiply.reduce(_shape)\n\n    def test_imports(self):\n        import pyrr\n        pyrr.Matrix33()\n        pyrr.matrix33.Matrix33()\n        pyrr.objects.matrix33.Matrix33()\n\n        from pyrr import Matrix33\n        from pyrr.objects import Matrix33\n        from pyrr.objects.matrix33 import Matrix33\n\n    def test_create(self):\n        m = Matrix33()\n        self.assertTrue(np.array_equal(m, np.zeros(self._shape)))\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix33(np.arange(self._size))\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix33([[1,2,3],[4,5,6],[7,8,9]])\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix33(Matrix33())\n        self.assertTrue(np.array_equal(m, np.zeros(self._shape)))\n        self.assertEqual(m.shape, self._shape)\n\n    def test_identity(self):\n        m = Matrix33.identity()\n        self.assertTrue(np.array_equal(m, np.eye(3)))\n\n    @unittest.skip('Not implemented')\n    def test_perspective_projection(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_perspective_projection_bounds(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_orthogonal_projection(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_from_translation(self):\n        pass\n\n    def test_create_from_matrix44(self):\n        m1 = Matrix44.identity()\n        m = Matrix33.from_matrix44(m1)\n        self.assertTrue(np.array_equal(m, np.eye(3)))\n\n        m = Matrix33(m1)\n        self.assertTrue(np.array_equal(m, np.eye(3)))\n\n    def test_create_from_scale(self):\n        v = Vector3([1,2,3])\n        m = Matrix33.from_scale(v)\n        self.assertTrue(np.array_equal(m, np.diag([1,2,3])))\n\n    def test_create_from_eulers(self):\n        e = Vector3([1,2,3])\n        m = Matrix33.from_eulers(e)\n        self.assertTrue(np.array_equal(m, matrix33.create_from_eulers([1,2,3])))\n\n    def test_create_from_quaternion(self):\n        q = Quaternion()\n        m = Matrix33.from_quaternion(q)\n        self.assertTrue(np.array_equal(m, np.eye(3)))\n        self.assertTrue(np.array_equal(m.quaternion, q))\n\n        m = Matrix33(q)\n        self.assertTrue(np.array_equal(m, np.eye(3)))\n\n    def test_create_from_inverse_quaternion(self):\n        q = Quaternion.from_x_rotation(0.5)\n        m = Matrix33.from_inverse_of_quaternion(q)\n        expected = matrix33.create_from_quaternion(quaternion.inverse(quaternion.create_from_x_rotation(0.5)))\n        np.testing.assert_almost_equal(np.array(m), expected, decimal=5)\n        #self.assertTrue(np.array_equal(m, expected))\n\n    def test_multiply(self):\n        m1 = Matrix33(np.arange(self._size))\n        m2 = Matrix33(np.arange(self._size)[::-1])\n        m = m1 * m2\n        self.assertTrue(np.array_equal(m, matrix33.multiply(m2, m1)))\n\n        m1 = Matrix33(np.arange(self._size))\n        m2 = Matrix44(np.arange(16))\n        m = m1 * m2\n        self.assertTrue(np.array_equal(m, matrix33.multiply(matrix33.create_from_matrix44(m2), m1)))\n\n    def test_inverse(self):\n        m1 = Matrix33.identity() * Matrix33.from_x_rotation(0.5)\n        m = m1.inverse\n        self.assertTrue(np.array_equal(m, matrix33.inverse(m1)))\n\n    def test_matrix33(self):\n        m1 = Matrix33.identity() * Matrix33.from_x_rotation(0.5)\n        m = m1.matrix33\n        self.assertTrue(m1 is m)\n\n    def test_matrix44(self):\n        m1 = Matrix33.identity() * Matrix33.from_x_rotation(0.5)\n        m = m1.matrix44\n        self.assertTrue(np.array_equal(m, matrix44.create_from_matrix33(m1)))\n\n    def test_operators_matrix33(self):\n        m1 = Matrix33.identity()\n        m2 = Matrix33.from_x_rotation(0.5)\n\n        # add\n        self.assertTrue(np.array_equal(m1 + m2, matrix33.create_identity() + matrix33.create_from_x_rotation(0.5)))\n\n        # subtract\n        self.assertTrue(np.array_equal(m1 - m2, matrix33.create_identity() - matrix33.create_from_x_rotation(0.5)))\n\n        # multiply\n        self.assertTrue(np.array_equal(m1 * m2, matrix33.multiply(matrix33.create_from_x_rotation(0.5), matrix33.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m1 / m2)\n\n        # inverse\n        self.assertTrue(np.array_equal(~m2, matrix33.inverse(matrix33.create_from_x_rotation(0.5))))\n\n        # ==\n        self.assertTrue(Matrix33() == Matrix33())\n        self.assertFalse(Matrix33() == Matrix33([1. for n in range(9)]))\n\n        # !=\n        self.assertTrue(Matrix33() != Matrix33([1. for n in range(9)]))\n        self.assertFalse(Matrix33() != Matrix33())\n\n    def test_operators_matrix44(self):\n        m1 = Matrix33.identity()\n        m2 = Matrix44.from_x_rotation(0.5)\n\n        # add\n        self.assertTrue(np.array_equal(m1 + m2, matrix33.create_identity() + matrix33.create_from_x_rotation(0.5)))\n\n        # subtract\n        self.assertTrue(np.array_equal(m1 - m2, matrix33.create_identity() - matrix33.create_from_x_rotation(0.5)))\n\n        # multiply\n        self.assertTrue(np.array_equal(m1 * m2, matrix33.multiply(matrix33.create_from_x_rotation(0.5), matrix33.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m1 / m2)\n\n    def test_operators_quaternion(self):\n        m = Matrix33.identity()\n        q = Quaternion.from_x_rotation(0.7)\n\n        # add\n        self.assertRaises(ValueError, lambda: m + q)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - q)\n\n        # multiply\n        self.assertTrue(np.array_equal(m * q, matrix33.multiply(matrix33.create_from_quaternion(quaternion.create_from_x_rotation(0.7)), matrix33.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / q)\n\n    def test_operators_vector3(self):\n        m = Matrix33.identity()\n        v = Vector3([1,1,1])\n\n        # add\n        self.assertRaises(ValueError, lambda: m + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - v)\n\n        # multiply\n        self.assertTrue(np.array_equal(m * v, matrix33.apply_to_vector(matrix33.create_identity(), [1,1,1])))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / v)\n\n    def test_operators_vector4(self):\n        m = Matrix33.identity()\n        v = Vector4([1,1,1,1])\n\n        # add\n        self.assertRaises(ValueError, lambda: m + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - v)\n\n        # multiply\n        self.assertTrue(ValueError, lambda: m * v)\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / v)\n\n    def test_operators_number(self):\n        m = Matrix33.identity()\n        fv = np.empty((1,), dtype=[('i', np.int16, 1),('f', np.float32, 1)])\n        fv[0] = (2, 2.0)\n\n        # add\n        self.assertTrue(np.array_equal(m + 1.0, matrix33.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + 1, matrix33.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + np.float(1.), matrix33.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + fv[0]['f'], matrix33.create_identity()[:] + 2.0))\n        self.assertTrue(np.array_equal(m + fv[0]['i'], matrix33.create_identity()[:] + 2.0))\n\n        # subtract\n        self.assertTrue(np.array_equal(m - 1.0, matrix33.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - 1, matrix33.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - np.float(1.), matrix33.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - fv[0]['f'], matrix33.create_identity()[:] - 2.0))\n        self.assertTrue(np.array_equal(m - fv[0]['i'], matrix33.create_identity()[:] - 2.0))\n\n        # multiply\n        self.assertTrue(np.array_equal(m * 2.0, matrix33.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * 2, matrix33.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * np.float(2.), matrix33.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * fv[0]['f'], matrix33.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * fv[0]['i'], matrix33.create_identity()[:] * 2.0))\n\n        # divide\n        self.assertTrue(np.array_equal(m / 2.0, matrix33.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / 2, matrix33.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / np.float(2.), matrix33.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / fv[0]['f'], matrix33.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / fv[0]['i'], matrix33.create_identity()[:] / 2.0))\n\n    def test_accessors(self):\n        m = Matrix33(np.arange(self._size))\n        self.assertTrue(np.array_equal(m.m1,[0,1,2]))\n        self.assertTrue(np.array_equal(m.m2,[3,4,5]))\n        self.assertTrue(np.array_equal(m.m3,[6,7,8]))\n\n        self.assertTrue(np.array_equal(m.r1,[0,1,2]))\n        self.assertTrue(np.array_equal(m.r2,[3,4,5]))\n        self.assertTrue(np.array_equal(m.r3,[6,7,8]))\n\n        self.assertTrue(np.array_equal(m.c1,[0,3,6]))\n        self.assertTrue(np.array_equal(m.c2,[1,4,7]))\n        self.assertTrue(np.array_equal(m.c3,[2,5,8]))\n\n        self.assertEqual(m.m11, 0)\n        self.assertEqual(m.m12, 1)\n        self.assertEqual(m.m13, 2)\n        self.assertEqual(m.m21, 3)\n        self.assertEqual(m.m22, 4)\n        self.assertEqual(m.m23, 5)\n        self.assertEqual(m.m31, 6)\n        self.assertEqual(m.m32, 7)\n        self.assertEqual(m.m33, 8)\n\n        m.m11 = 1\n        self.assertEqual(m.m11, 1)\n        self.assertEqual(m[0,0], 1)\n        m.m11 += 1\n        self.assertEqual(m.m11, 2)\n        self.assertEqual(m[0,0], 2)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/objects/test_matrix44.py,70,"b""from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr.objects.matrix33 import Matrix33\nfrom pyrr.objects.matrix44 import Matrix44\nfrom pyrr.objects.quaternion import Quaternion\nfrom pyrr.objects.vector3 import Vector3\nfrom pyrr.objects.vector4 import Vector4\nfrom pyrr import matrix33\nfrom pyrr import matrix44\nfrom pyrr import quaternion\n\n\nclass test_object_matrix44(unittest.TestCase):\n    _shape = (4,4)\n    _size = np.multiply.reduce(_shape)\n\n    def test_imports(self):\n        import pyrr\n        pyrr.Matrix44()\n        pyrr.matrix44.Matrix44()\n        pyrr.objects.matrix44.Matrix44()\n\n        from pyrr import Matrix44\n        from pyrr.objects import Matrix44\n        from pyrr.objects.matrix44 import Matrix44\n\n    def test_create(self):\n        m = Matrix44()\n        self.assertTrue(np.array_equal(m, np.zeros(self._shape)))\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix44(np.arange(self._size))\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix44([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])\n        self.assertEqual(m.shape, self._shape)\n\n        m = Matrix44(Matrix44())\n        self.assertTrue(np.array_equal(m, np.zeros(self._shape)))\n        self.assertEqual(m.shape, self._shape)\n\n    def test_identity(self):\n        m = Matrix44.identity()\n        self.assertTrue(np.array_equal(m, np.eye(4)))\n\n    @unittest.skip('Not implemented')\n    def test_perspective_projection(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_perspective_projection_bounds(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_orthogonal_projection(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_from_translation(self):\n        pass\n\n    def test_create_from_matrix44(self):\n        m1 = Matrix33.identity()\n        m = Matrix44.from_matrix33(m1)\n        self.assertTrue(np.array_equal(m, np.eye(4)))\n\n        m = Matrix44(m1)\n        self.assertTrue(np.array_equal(m, np.eye(4)))\n\n    def test_create_from_scale(self):\n        v = Vector3([1,2,3])\n        m = Matrix44.from_scale(v)\n        self.assertTrue(np.array_equal(m, np.diag([1,2,3,1])))\n\n    def test_create_from_eulers(self):\n        e = Vector3([1,2,3])\n        m = Matrix44.from_eulers(e)\n        self.assertTrue(np.array_equal(m, matrix44.create_from_eulers([1,2,3])))\n\n    def test_create_from_quaternion(self):\n        q = Quaternion()\n        m = Matrix44.from_quaternion(q)\n        self.assertTrue(np.array_equal(m, np.eye(4)))\n        self.assertTrue(np.array_equal(m.quaternion, q))\n\n        m = Matrix44(q)\n        self.assertTrue(np.array_equal(m, np.eye(4)))\n\n    def test_create_from_inverse_quaternion(self):\n        q = Quaternion.from_x_rotation(0.5)\n        m = Matrix44.from_inverse_of_quaternion(q)\n        expected = matrix44.create_from_quaternion(quaternion.inverse(quaternion.create_from_x_rotation(0.5)))\n        np.testing.assert_almost_equal(np.array(m), expected, decimal=5)\n        #self.assertTrue(np.array_equal(m, expected))\n\n    def test_multiply(self):\n        m1 = Matrix44(np.arange(self._size))\n        m2 = Matrix44(np.arange(self._size)[::-1])\n        m = m1 * m2\n        self.assertTrue(np.array_equal(m, matrix44.multiply(m2, m1)))\n\n        m1 = Matrix44(np.arange(self._size))\n        m2 = Matrix33(np.arange(9))\n        m = m1 * m2\n        self.assertTrue(np.array_equal(m, matrix44.multiply(matrix44.create_from_matrix33(m2), m1)))\n\n    def test_inverse(self):\n        m1 = Matrix44.identity() * Matrix44.from_x_rotation(0.5)\n        m = m1.inverse\n        self.assertTrue(np.array_equal(m, matrix44.inverse(m1)))\n\n    def test_matrix33(self):\n        m1 = Matrix44.identity() * Matrix44.from_x_rotation(0.5)\n        m = m1.matrix33\n        self.assertTrue(np.array_equal(m, matrix33.create_from_matrix44(m1)))\n\n    def test_matrix44(self):\n        m1 = Matrix44.identity() * Matrix44.from_x_rotation(0.5)\n        m = m1.matrix44\n        self.assertTrue(m1 is m)\n\n    def test_operators_matrix33(self):\n        m1 = Matrix44.identity()\n        m2 = Matrix33.from_x_rotation(0.5)\n\n        # add\n        self.assertTrue(np.array_equal(m1 + m2, matrix44.create_identity() + matrix44.create_from_x_rotation(0.5)))\n\n        # subtract\n        self.assertTrue(np.array_equal(m1 - m2, matrix44.create_identity() - matrix44.create_from_x_rotation(0.5)))\n\n        # multiply\n        self.assertTrue(np.array_equal(m1 * m2, matrix44.multiply(matrix44.create_from_x_rotation(0.5), matrix44.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m1 / m2)\n\n    def test_operators_matrix44(self):\n        m1 = Matrix44.identity()\n        m2 = Matrix44.from_x_rotation(0.5)\n\n        # add\n        self.assertTrue(np.array_equal(m1 + m2, matrix44.create_identity() + matrix44.create_from_x_rotation(0.5)))\n\n        # subtract\n        self.assertTrue(np.array_equal(m1 - m2, matrix44.create_identity() - matrix44.create_from_x_rotation(0.5)))\n\n        # multiply\n        self.assertTrue(np.array_equal(m1 * m2, matrix44.multiply(matrix44.create_from_x_rotation(0.5), matrix44.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m1 / m2)\n\n        # inverse\n        self.assertTrue(np.array_equal(~m2, matrix44.inverse(matrix44.create_from_x_rotation(0.5))))\n\n        # ==\n        self.assertTrue(Matrix44() == Matrix44())\n        self.assertFalse(Matrix44() == Matrix44([1. for n in range(16)]))\n\n        # !=\n        self.assertTrue(Matrix44() != Matrix44([1. for n in range(16)]))\n        self.assertFalse(Matrix44() != Matrix44())\n\n    def test_operators_quaternion(self):\n        m = Matrix44.identity()\n        q = Quaternion.from_x_rotation(0.7)\n\n        # add\n        self.assertRaises(ValueError, lambda: m + q)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - q)\n\n        # multiply\n        self.assertTrue(np.array_equal(m * q, matrix44.multiply(matrix44.create_from_quaternion(quaternion.create_from_x_rotation(0.7)), matrix44.create_identity())))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / q)\n\n    def test_operators_vector3(self):\n        m = Matrix44.identity()\n        v = Vector3([1,1,1])\n\n        # add\n        self.assertRaises(ValueError, lambda: m + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - v)\n\n        # multiply\n        self.assertTrue(np.array_equal(m * v, matrix44.apply_to_vector(matrix44.create_identity(), [1,1,1])))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / v)\n\n    def test_operators_vector4(self):\n        m = Matrix44.identity()\n        v = Vector4([1,1,1,1])\n\n        # add\n        self.assertRaises(ValueError, lambda: m + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: m - v)\n\n        # multiply\n        self.assertTrue(np.array_equal(m * v, matrix44.apply_to_vector(matrix44.create_identity(), [1,1,1,1])))\n\n        # divide\n        self.assertRaises(ValueError, lambda: m / v)\n\n    def test_operators_number(self):\n        m = Matrix44.identity()\n        fv = np.empty((1,), dtype=[('i', np.int16, 1),('f', np.float32, 1)])\n        fv[0] = (2, 2.0)\n\n        # add\n        self.assertTrue(np.array_equal(m + 1.0, matrix44.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + 1, matrix44.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + np.float(1.), matrix44.create_identity()[:] + 1.0))\n        self.assertTrue(np.array_equal(m + fv[0]['f'], matrix44.create_identity()[:] + 2.0))\n        self.assertTrue(np.array_equal(m + fv[0]['i'], matrix44.create_identity()[:] + 2.0))\n\n        # subtract\n        self.assertTrue(np.array_equal(m - 1.0, matrix44.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - 1, matrix44.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - np.float(1.), matrix44.create_identity()[:] - 1.0))\n        self.assertTrue(np.array_equal(m - fv[0]['f'], matrix44.create_identity()[:] - 2.0))\n        self.assertTrue(np.array_equal(m - fv[0]['i'], matrix44.create_identity()[:] - 2.0))\n\n        # multiply\n        self.assertTrue(np.array_equal(m * 2.0, matrix44.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * 2, matrix44.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * np.float(2.), matrix44.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * fv[0]['f'], matrix44.create_identity()[:] * 2.0))\n        self.assertTrue(np.array_equal(m * fv[0]['i'], matrix44.create_identity()[:] * 2.0))\n\n        # divide\n        self.assertTrue(np.array_equal(m / 2.0, matrix44.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / 2, matrix44.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / np.float(2.), matrix44.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / fv[0]['f'], matrix44.create_identity()[:] / 2.0))\n        self.assertTrue(np.array_equal(m / fv[0]['i'], matrix44.create_identity()[:] / 2.0))\n\n    def test_accessors(self):\n        m = Matrix44(np.arange(self._size))\n        self.assertTrue(np.array_equal(m.m1,[0,1,2,3]))\n        self.assertTrue(np.array_equal(m.m2,[4,5,6,7]))\n        self.assertTrue(np.array_equal(m.m3,[8,9,10,11]))\n        self.assertTrue(np.array_equal(m.m4,[12,13,14,15]))\n\n        self.assertTrue(np.array_equal(m.r1,[0,1,2,3]))\n        self.assertTrue(np.array_equal(m.r2,[4,5,6,7]))\n        self.assertTrue(np.array_equal(m.r3,[8,9,10,11]))\n        self.assertTrue(np.array_equal(m.r4,[12,13,14,15]))\n\n        self.assertTrue(np.array_equal(m.c1,[0,4,8,12]))\n        self.assertTrue(np.array_equal(m.c2,[1,5,9,13]))\n        self.assertTrue(np.array_equal(m.c3,[2,6,10,14]))\n        self.assertTrue(np.array_equal(m.c4,[3,7,11,15]))\n\n        self.assertEqual(m.m11, 0)\n        self.assertEqual(m.m12, 1)\n        self.assertEqual(m.m13, 2)\n        self.assertEqual(m.m14, 3)\n        self.assertEqual(m.m21, 4)\n        self.assertEqual(m.m22, 5)\n        self.assertEqual(m.m23, 6)\n        self.assertEqual(m.m24, 7)\n        self.assertEqual(m.m31, 8)\n        self.assertEqual(m.m32, 9)\n        self.assertEqual(m.m33, 10)\n        self.assertEqual(m.m34, 11)\n        self.assertEqual(m.m41, 12)\n        self.assertEqual(m.m42, 13)\n        self.assertEqual(m.m43, 14)\n        self.assertEqual(m.m44, 15)\n\n        m.m11 = 1\n        self.assertEqual(m.m11, 1)\n        self.assertEqual(m[0,0], 1)\n        m.m11 += 1\n        self.assertEqual(m.m11, 2)\n        self.assertEqual(m[0,0], 2)\n\n    def test_decompose(self):\n        # define expectations for multiple cases\n        testsets = [\n            (\n                Vector3([1, 1, 2], dtype='f4'),\n                Quaternion.from_y_rotation(np.pi, dtype='f4'),\n                Vector3([10, 0, -5], dtype='f4'),\n                Matrix44([\n                    [-1, 0, 0, 0],\n                    [0, 1, 0, 0],\n                    [0, 0, -2, 0],\n                    [10, 0, -5, 1],\n                ], dtype='f4')\n            ),\n            (\n                Vector3([-1, 3, .5], dtype='f4'),\n                Quaternion.from_axis_rotation(Vector3([.75, .75, 0], dtype='f4').normalized, np.pi, dtype='f4').normalized,\n                Vector3([1, -1, 1], dtype='f4'),\n                Matrix44([\n                    [0, -1, 0, 0],\n                    [3, 0, 0, 0],\n                    [0, 0, -.5, 0],\n                    [1, -1, 1, 1],\n                ], dtype='f4')\n            ),\n        ]\n\n        for expected_scale, expected_rotation, expected_translation, expected_model in testsets:\n            # compose model matrix using original inputs\n            s = Matrix44.from_scale(expected_scale, dtype='f4')\n            r = Matrix44.from_quaternion(expected_rotation, dtype='f4')\n            t = Matrix44.from_translation(expected_translation, dtype='f4')\n            m = t * r * s\n\n            # check that it's the same as the expected matrix\n            np.testing.assert_almost_equal(np.array(m), np.array(expected_model))\n            self.assertTrue(m.dtype == expected_model.dtype)\n            self.assertTrue(isinstance(m, expected_model.__class__))\n\n            # decompose this matrix and recompose the model matrix from the decomposition\n            ds, dr, dt = m.decompose()\n            ds = Matrix44.from_scale(ds, dtype='f4')\n            dr = Matrix44.from_quaternion(dr, dtype='f4')\n            dt = Matrix44.from_translation(dt, dtype='f4')\n            dm = dt * dr * ds\n\n            # check that it's the same as the original matrix\n            np.testing.assert_almost_equal(np.array(m), np.array(dm))\n            self.assertTrue(m.dtype == dm.dtype)\n            self.assertTrue(isinstance(dm, m.__class__))\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/objects/test_quaternion.py,116,"b""from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr.objects.matrix33 import Matrix33\nfrom pyrr.objects.matrix44 import Matrix44\nfrom pyrr.objects.quaternion import Quaternion\nfrom pyrr.objects.vector3 import Vector3\nfrom pyrr.objects.vector4 import Vector4\nfrom pyrr import matrix33\nfrom pyrr import matrix44\nfrom pyrr import quaternion\n\n\nclass test_object_quaternion(unittest.TestCase):\n    _shape = (4,)\n    _size = np.multiply.reduce(_shape)\n\n    def test_imports(self):\n        import pyrr\n        pyrr.Quaternion()\n        pyrr.quaternion.Quaternion()\n        pyrr.objects.quaternion.Quaternion()\n\n        from pyrr import Quaternion\n        from pyrr.objects import Quaternion\n        from pyrr.objects.quaternion import Quaternion\n\n    def test_create(self):\n        q = Quaternion()\n        self.assertTrue(np.array_equal(q, [0., 0., 0., 1.]))\n        self.assertEqual(q.shape, self._shape)\n\n        q = Quaternion([1., 2., 3., 4.])\n        self.assertTrue(np.array_equal(q, [1., 2., 3., 4.]))\n        self.assertEqual(q.shape, self._shape)\n\n        q = Quaternion(Quaternion([1., 2., 3., 4.]))\n        self.assertTrue(np.array_equal(q, [1., 2., 3., 4.]))\n        self.assertEqual(q.shape, self._shape)\n\n    def test_from_x_rotation(self):\n        # 180 degree turn around X axis\n        q = Quaternion.from_x_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [1., 0., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 0.,-1.]))\n\n        # 90 degree rotation around X axis\n        q = Quaternion.from_x_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [np.sqrt(0.5), 0., 0., np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 0., 1.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0.,-1., 0.]))\n\n        # -90 degree rotation around X axis\n        q = Quaternion.from_x_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(q, [-np.sqrt(0.5), 0., 0., np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 0.,-1.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 1., 0.]))\n\n    def test_from_y_rotation(self):\n        # 180 degree turn around Y axis\n        q = Quaternion.from_y_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [0., 1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 0.,-1.]))\n\n        # 90 degree rotation around Y axis\n        q = Quaternion.from_y_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., np.sqrt(0.5), 0., np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [0., 0.,-1.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [1., 0., 0.]))\n\n        # -90 degree rotation around Y axis\n        q = Quaternion.from_y_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., -np.sqrt(0.5), 0., np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [0., 0., 1.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [-1., 0., 0.]))\n\n    def test_from_z_rotation(self):\n        # 180 degree turn around Z axis\n        q = Quaternion.from_z_rotation(np.pi)\n        self.assertTrue(np.allclose(q, [0., 0., 1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 0., 1.]))\n\n        # 90 degree rotation around Z axis\n        q = Quaternion.from_z_rotation(np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., 0., np.sqrt(0.5), np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [0., 1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [-1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 0., 1.]))\n\n        # -90 degree rotation around Z axis\n        q = Quaternion.from_z_rotation(-np.pi / 2.)\n        self.assertTrue(np.allclose(q, [0., 0., -np.sqrt(0.5), np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [0.,-1., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0., 0., 1.]))\n\n    def test_from_axis_rotation(self):\n        q = Quaternion.from_axis_rotation([1., 0., 0.], np.pi / 2.)\n        self.assertTrue(np.allclose(q, [np.sqrt(0.5), 0., 0., np.sqrt(0.5)]))\n        self.assertTrue(np.allclose(q * Vector3([1., 0., 0.]), [1., 0., 0.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 1., 0.]), [0., 0., 1.]))\n        self.assertTrue(np.allclose(q * Vector3([0., 0., 1.]), [0.,-1., 0.]))\n\n    def test_from_axis(self):\n        source = np.array([np.pi / 2, 0, 0])\n        result = Quaternion.from_axis(source)\n        expected = np.array([np.sqrt(0.5), 0, 0, np.sqrt(0.5)])\n        self.assertTrue(np.allclose(result, expected))\n\n        source = np.array([0, np.pi, 0])\n        result = Quaternion.from_axis(source)\n        expected = np.array([0, 1, 0, 0])\n        self.assertTrue(np.allclose(result, expected))\n\n        source = np.array([0, 0, 2 * np.pi])\n        result = Quaternion.from_axis(source)\n        expected = np.array([0, 0, 0, -1])\n        self.assertTrue(np.allclose(result, expected))\n\n    @unittest.skip('Not implemented')\n    def test_from_eulers(self):\n        pass\n\n    @unittest.skip('Not implemented')\n    def test_from_inverse_of_eulers(self):\n        pass\n\n    def test_length(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.length, quaternion.length(q)))\n\n    def test_normalize(self):\n        q = Quaternion([1., 2., 3., 4.])\n        self.assertFalse(np.allclose(q.length, 1.))\n\n        q.normalize()\n        self.assertTrue(np.allclose(q.length, 1.))\n\n    def test_normalized(self):\n        q1 = Quaternion([1., 2., 3., 4.])\n        self.assertFalse(np.allclose(q1.length, 1.))\n\n        q2 = q1.normalized\n        self.assertFalse(np.allclose(q1.length, 1.))\n        self.assertTrue(np.allclose(q2.length, 1.))\n\n    def test_angle(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertEqual(q.angle, quaternion.rotation_angle(q))\n\n    def test_axis(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.axis, quaternion.rotation_axis(q)))\n\n    def test_cross(self):\n        q1 = Quaternion.from_x_rotation(np.pi / 2.0)\n        q2 = Quaternion.from_y_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q1.cross(q2), quaternion.cross(q1, q2)))\n\n    def test_dot(self):\n        q1 = Quaternion.from_x_rotation(np.pi / 2.0)\n        q2 = Quaternion.from_y_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q1.dot(q2), quaternion.dot(q1, q2)))\n\n    def test_conjugate(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.conjugate, quaternion.conjugate(q)))\n\n    def test_inverse(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.inverse, quaternion.inverse(q)))\n\n    def test_exp(self):\n        source = Quaternion.from_eulers([0, np.pi / 2, 0])\n        result = source.exp()\n        expected = np.array([0, 1.31753841, 0, 1.54186346])\n        self.assertTrue(np.allclose(result, expected))\n\n    def test_power(self):\n        q1 = Quaternion.from_x_rotation(np.pi / 2.0)\n        q2 = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q1.power(2.0), quaternion.power(q2, 2.0)))\n\n    def test_negative(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.negative, quaternion.negate(q)))\n\n    def test_is_identity(self):\n        self.assertTrue(quaternion.is_identity(Quaternion()))\n        self.assertTrue(quaternion.is_identity(Quaternion([0., 0., 0., 1.])))\n        self.assertFalse(quaternion.is_identity(Quaternion([1., 0., 0., 0.])))\n\n    def test_matrix33(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.matrix33, matrix33.create_from_quaternion(q)))\n\n    def test_matrix44(self):\n        q = Quaternion.from_x_rotation(np.pi / 2.0)\n        self.assertTrue(np.allclose(q.matrix44, matrix44.create_from_quaternion(q)))\n\n    def test_operators_matrix33(self):\n        q = Quaternion()\n        m = Matrix33.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: q + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: q - m)\n\n        # multiply\n        self.assertTrue(np.array_equal(q * m, quaternion.cross(quaternion.create(), quaternion.create_from_matrix(matrix33.create_from_x_rotation(0.5)))))\n\n        # divide\n        self.assertRaises(ValueError, lambda: q / m)\n\n    def test_operators_matrix44(self):\n        q = Quaternion()\n        m = Matrix44.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: q + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: q - m)\n\n        # multiply\n        self.assertTrue(np.array_equal(q * m, quaternion.cross(quaternion.create(), quaternion.create_from_matrix(matrix44.create_from_x_rotation(0.5)))))\n\n        # divide\n        self.assertRaises(ValueError, lambda: q / m)\n\n    def test_operators_quaternion(self):\n        q1 = Quaternion()\n        q2 = Quaternion.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: q1 + q2)\n\n        # subtract\n        # we had to add this to enable np.array_equal to work\n        # as it uses subtraction\n        #self.assertRaises(ValueError, lambda: q1 - q2)\n\n        # multiply\n        self.assertTrue(np.array_equal(q1 * q2, quaternion.cross(quaternion.create(), quaternion.create_from_x_rotation(0.5))))\n\n        # divide\n        self.assertRaises(ValueError, lambda: q1 / q2)\n\n        # or\n        self.assertTrue(np.array_equal(q1 | q2, quaternion.dot(quaternion.create(), quaternion.create_from_x_rotation(0.5))))\n\n        # inverse\n        self.assertTrue(np.array_equal(~q2, quaternion.conjugate(quaternion.create_from_x_rotation(0.5))))\n\n        # ==\n        self.assertTrue(Quaternion() == Quaternion())\n        self.assertFalse(Quaternion() == Quaternion([0., 0., 0., 0.]))\n\n        # !=\n        self.assertTrue(Quaternion() != Quaternion([1., 1., 1., 1.]))\n        self.assertFalse(Quaternion() != Quaternion())\n\n    def test_operators_vector3(self):\n        q = Quaternion.from_x_rotation(0.5)\n        v = Vector3([1., 0., 0.])\n\n        # add\n        self.assertRaises(ValueError, lambda: q + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: q - v)\n\n        # multiply\n        self.assertTrue(np.array_equal(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(0.5), [1., 0., 0.])))\n\n        # divide\n        self.assertRaises(ValueError, lambda: q / v)\n\n    def test_operators_vector4(self):\n        q = Quaternion.from_x_rotation(0.5)\n        v = Vector4([1., 0., 0., 1.])\n\n        # add\n        self.assertRaises(ValueError, lambda: q + v)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: q - v)\n\n        # multiply\n        self.assertTrue(np.array_equal(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(0.5), [1., 0., 0., 1.])))\n\n        # divide\n        self.assertRaises(ValueError, lambda: q / v)\n\n\n    def test_apply_to_vector_non_unit(self):\n        q = Quaternion.from_x_rotation(np.pi)\n\n        # zero length\n        v = Vector3([0., 0., 0.])\n        self.assertTrue(np.allclose(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(np.pi), [0., 0., 0.])))\n\n        # >1 length\n        v = Vector3([2., 0., 0.])\n        self.assertTrue(np.allclose(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(np.pi), [2., 0., 0.])))\n        v = Vector3([0., 2., 0.])\n        self.assertTrue(np.allclose(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(np.pi), [0., 2., 0.])))\n        v = Vector3([0., 0., 2.])\n        self.assertTrue(np.allclose(q * v, quaternion.apply_to_vector(quaternion.create_from_x_rotation(np.pi), [0., 0., 2.])))\n\n\n    def test_accessors(self):\n        q = Quaternion(np.arange(self._size))\n        self.assertTrue(np.array_equal(q.xy, [0, 1]))\n        self.assertTrue(np.array_equal(q.xyz, [0, 1, 2]))\n        self.assertTrue(np.array_equal(q.xyzw, [0, 1, 2, 3]))\n\n        self.assertTrue(np.array_equal(q.xz, [0, 2]))\n        self.assertTrue(np.array_equal(q.xyz, [0, 1, 2]))\n        self.assertTrue(np.array_equal(q.xyw, [0, 1, 3]))\n        self.assertTrue(np.array_equal(q.xw, [0, 3]))\n\n        self.assertEqual(q.x, 0)\n        self.assertEqual(q.y, 1)\n        self.assertEqual(q.z, 2)\n        self.assertEqual(q.w, 3)\n\n        q.x = 1\n        self.assertEqual(q.x, 1)\n        self.assertEqual(q[0], 1)\n        q.x += 1\n        self.assertEqual(q.x, 2)\n        self.assertEqual(q[0], 2)\n\n    def test_equality(self):\n        q1 = Quaternion([0, 0, 0, 1])\n        q2 = Quaternion([0, 0, 0, 1])\n        q3 = Quaternion([0, 0, 1, -1])\n        self.assertEqual(q1, q2)\n        self.assertNotEqual(q1, q3)\n        self.assertNotEqual(q2, q3)\n\n    def test_equality_negative(self):\n        q1 = Quaternion([0, 0, 0, 1])\n        q2 = Quaternion([0, 0, 0, -1])\n        q3 = Quaternion([0, 0, 1, -1])\n        self.assertEqual(q1, q2)\n        self.assertNotEqual(q1, q3)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/objects/test_vector3.py,51,"b""from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr.objects.matrix33 import Matrix33\nfrom pyrr.objects.matrix44 import Matrix44\nfrom pyrr.objects.quaternion import Quaternion\nfrom pyrr.objects.vector3 import Vector3\nfrom pyrr.objects.vector4 import Vector4\nfrom pyrr import vector3\n\n\nclass test_object_vector3(unittest.TestCase):\n    _shape = (3,)\n    _size = np.multiply.reduce(_shape)\n\n    def test_imports(self):\n        import pyrr\n        pyrr.Vector3()\n        pyrr.vector3.Vector3()\n        pyrr.objects.vector3.Vector3()\n\n    def test_imports_1(self):\n        from pyrr import Vector3\n        Vector3\n\n    def test_imports_2(self):\n        from pyrr.objects import Vector3\n        Vector3\n\n    def test_imports_3(self):\n        from pyrr.objects.vector3 import Vector3\n        Vector3\n\n    def test_create(self):\n        v = Vector3()\n        self.assertTrue(np.array_equal(v, [0.,0.,0.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v = Vector3([1.,2.,3.])\n        self.assertTrue(np.array_equal(v, [1.,2.,3.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v = Vector3(Vector3())\n        self.assertTrue(np.array_equal(v, [0.,0.,0.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v4 = [1., 2., 3., 4.]\n        result = vector3.create_from_vector4(v4)\n        v, w = result\n        np.testing.assert_almost_equal(v, [1.,2.,3.], decimal=5)\n        np.testing.assert_almost_equal(w, 4., decimal=5)\n\n        v4 = Vector4([1., 2., 3., 4.])\n        result = vector3.create_from_vector4(v4)\n        v, w = result\n        np.testing.assert_almost_equal(v, [1.,2.,3.], decimal=5)\n        np.testing.assert_almost_equal(w, 4., decimal=5)\n\n\n        m = Matrix44.from_translation([1.,2.,3.])\n        v = Vector3.from_matrix44_translation(m)\n        self.assertTrue(np.array_equal(v, [1.,2.,3.]))\n\n        m = Matrix44.from_translation([1.,2.,3.])\n        v = Vector3(m)\n        self.assertTrue(np.array_equal(v, [1.,2.,3.]))\n\n    def test_inverse(self):\n        v = Vector3([1.,2.,3.])\n        self.assertTrue(np.array_equal(v.inverse, [-1.,-2.,-3.]))\n\n    def test_normalize(self):\n        v = Vector3([1.,1.,1.])\n        np.testing.assert_almost_equal(np.array(v.normalized), [0.57735, 0.57735, 0.57735], decimal=5)\n\n        v.normalize()\n        np.testing.assert_almost_equal(np.array(v), [0.57735, 0.57735, 0.57735], decimal=5)\n\n    def test_operators_matrix33(self):\n        v = Vector3()\n        m = Matrix33.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / m)\n\n    def test_operators_matrix44(self):\n        v = Vector3()\n        m = Matrix44.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v * m)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / m)\n\n    def test_operators_quaternion(self):\n        v = Vector3()\n        q = Quaternion.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + q)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - q)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v * q)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / q)\n\n    def test_operators_vector3(self):\n        v1 = Vector3()\n        v2 = Vector3([1.,2.,3.])\n\n        # add\n        self.assertTrue(np.array_equal(v1 + v2, [1.,2.,3.]))\n\n        # subtract\n        self.assertTrue(np.array_equal(v1 - v2, [-1.,-2.,-3.]))\n\n        # multiply\n        self.assertTrue(np.array_equal(v1 * v2, [0.,0.,0.]))\n\n        # divide\n        self.assertTrue(np.array_equal(v1 / v2, [0.,0.,0.]))\n\n        # or\n        self.assertTrue(np.array_equal(v1 | v2, vector3.dot(v1, v2)))\n\n        # xor\n        self.assertTrue(np.array_equal(v1 ^ v2, vector3.cross(v1, v2)))\n\n        # ==\n        self.assertTrue(Vector3() == Vector3())\n        self.assertFalse(Vector3() == Vector3([1.,1.,1.]))\n\n        # !=\n        self.assertTrue(Vector3() != Vector3([1.,1.,1.]))\n        self.assertFalse(Vector3() != Vector3())\n\n    def test_operators_vector4(self):\n        v1 = Vector3()\n        v2 = Vector4([1.,2.,3.,4.])\n\n        # add\n        self.assertRaises(ValueError, lambda: v1 + v2)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v1 - v2)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v1 * v2)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v1 / v2)\n\n        # or\n        self.assertRaises(ValueError, lambda: v1 | v2)\n\n        # xor\n        self.assertRaises(ValueError, lambda: v1 ^ v2)\n\n        # ==\n        self.assertRaises(ValueError, lambda: Vector3() == Vector4())\n\n        # !=\n        self.assertRaises(ValueError, lambda: Vector3() != Vector4([1.,1.,1.,1.]))\n\n    def test_operators_number(self):\n        v1 = Vector3([1.,2.,3.])\n        fv = np.empty((1,), dtype=[('i', np.int16, 1),('f', np.float32, 1)])\n        fv[0] = (2, 2.0)\n\n        # add\n        self.assertTrue(np.array_equal(v1 + 1., [2., 3., 4.]))\n        self.assertTrue(np.array_equal(v1 + 1, [2., 3., 4.]))\n        self.assertTrue(np.array_equal(v1 + np.float(1.), [2., 3., 4.]))\n        self.assertTrue(np.array_equal(v1 + fv[0]['f'], [3., 4., 5.]))\n        self.assertTrue(np.array_equal(v1 + fv[0]['i'], [3., 4., 5.]))\n\n        # subtract\n        self.assertTrue(np.array_equal(v1 - 1., [0., 1., 2.]))\n        self.assertTrue(np.array_equal(v1 - 1, [0., 1., 2.]))\n        self.assertTrue(np.array_equal(v1 - np.float(1.), [0., 1., 2.]))\n        self.assertTrue(np.array_equal(v1 - fv[0]['f'], [-1., 0., 1.]))\n        self.assertTrue(np.array_equal(v1 - fv[0]['i'], [-1., 0., 1.]))\n\n        # multiply\n        self.assertTrue(np.array_equal(v1 * 2., [2., 4., 6.]))\n        self.assertTrue(np.array_equal(v1 * 2, [2., 4., 6.]))\n        self.assertTrue(np.array_equal(v1 * np.float(2.), [2., 4., 6.]))\n        self.assertTrue(np.array_equal(v1 * fv[0]['f'], [2., 4., 6.]))\n        self.assertTrue(np.array_equal(v1 * fv[0]['i'], [2., 4., 6.]))\n\n        # divide\n        self.assertTrue(np.array_equal(v1 / 2., [.5, 1., 1.5]))\n        self.assertTrue(np.array_equal(v1 / 2, [.5, 1., 1.5]))\n        self.assertTrue(np.array_equal(v1 / np.float(2.), [.5, 1., 1.5]))\n        self.assertTrue(np.array_equal(v1 / fv[0]['f'], [.5, 1., 1.5]))\n        self.assertTrue(np.array_equal(v1 / fv[0]['i'], [.5, 1., 1.5]))\n\n        # or\n        self.assertRaises(ValueError, lambda: v1 | .5)\n        self.assertRaises(ValueError, lambda: v1 | 5)\n        self.assertRaises(ValueError, lambda: v1 | np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 | fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 | fv[0]['i'])\n\n        # xor\n        self.assertRaises(ValueError, lambda: v1 ^ .5)\n        self.assertRaises(ValueError, lambda: v1 ^ 5)\n        self.assertRaises(ValueError, lambda: v1 ^ np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 ^ fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 ^ fv[0]['i'])\n\n        # ==\n        self.assertRaises(ValueError, lambda: v1 == .5)\n        self.assertRaises(ValueError, lambda: v1 == 5)\n        self.assertRaises(ValueError, lambda: v1 == np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 == fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 == fv[0]['i'])\n\n        # !=\n        self.assertRaises(ValueError, lambda: v1 != .5)\n        self.assertRaises(ValueError, lambda: v1 != 5)\n        self.assertRaises(ValueError, lambda: v1 != np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 != fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 != fv[0]['i'])\n\n    def test_bitwise(self):\n        v1 = Vector3([1.,0.,0.])\n        v2 = Vector3([0.,1.,0.])\n\n        # xor (cross)\n        self.assertTrue(np.array_equal(v1 ^ v2, vector3.cross(v1, v2)))\n\n        # or (dot)\n        self.assertTrue(np.array_equal(v1 | v2, vector3.dot(v1, v2)))\n\n    def test_accessors(self):\n        v = Vector3(np.arange(self._size))\n        self.assertTrue(np.array_equal(v.xy,[0,1]))\n        self.assertTrue(np.array_equal(v.xyz,[0,1,2]))\n        self.assertTrue(np.array_equal(v.xz,[0,2]))\n        self.assertTrue(np.array_equal(v.xyz,[0,1,2]))\n\n        self.assertEqual(v.x, 0)\n        self.assertEqual(v.y, 1)\n        self.assertEqual(v.z, 2)\n\n        v.x = 1\n        self.assertEqual(v.x, 1)\n        self.assertEqual(v[0], 1)\n        v.x += 1\n        self.assertEqual(v.x, 2)\n        self.assertEqual(v[0], 2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
tests/objects/test_vector4.py,47,"b""from __future__ import absolute_import\ntry:\n    import unittest2 as unittest\nexcept:\n    import unittest\nimport numpy as np\nfrom pyrr.objects.matrix33 import Matrix33\nfrom pyrr.objects.matrix44 import Matrix44\nfrom pyrr.objects.quaternion import Quaternion\nfrom pyrr.objects.vector3 import Vector3\nfrom pyrr.objects.vector4 import Vector4\nfrom pyrr import vector4\n\n\nclass test_object_vector4(unittest.TestCase):\n    _shape = (4,)\n    _size = np.multiply.reduce(_shape)\n\n    def test_imports(self):\n        import pyrr\n        pyrr.Vector4()\n        pyrr.vector4.Vector4()\n        pyrr.objects.vector4.Vector4()\n\n        from pyrr import Vector4\n        from pyrr.objects import Vector4\n        from pyrr.objects.vector4 import Vector4\n\n    def test_create(self):\n        v = Vector4()\n        self.assertTrue(np.array_equal(v, [0.,0.,0.,0.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v = Vector4([1.,2.,3.,4.])\n        self.assertTrue(np.array_equal(v, [1.,2.,3.,4.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v = Vector4.from_vector3([1.,2.,3.], w=0.0)\n        self.assertTrue(np.array_equal(v, [1.,2.,3.,0.]))\n        self.assertEqual(v.shape, self._shape)\n\n        v = Vector4(Vector4())\n        self.assertTrue(np.array_equal(v, [0.,0.,0.,0.]))\n        self.assertEqual(v.shape, self._shape)\n\n        m = Matrix44.from_translation([1.,2.,3.])\n        v = Vector4.from_matrix44_translation(m)\n        self.assertTrue(np.array_equal(v, [1.,2.,3.,1.]))\n\n        m = Matrix44.from_translation([1.,2.,3.])\n        v = Vector4(m)\n        self.assertTrue(np.array_equal(v, [1.,2.,3.,1.]))\n\n    def test_inverse(self):\n        v = Vector4([1.,2.,3.,4.])\n        self.assertTrue(np.array_equal(v.inverse, [-1.,-2.,-3.,-4.]))\n\n    def test_normalize(self):\n        v = Vector4([1.,1.,1.,1.])\n        np.testing.assert_almost_equal(np.array(v.normalized), [0.5, 0.5, 0.5, 0.5], decimal=5)\n\n        v.normalize()\n        np.testing.assert_almost_equal(np.array(v), [0.5, 0.5, 0.5, 0.5], decimal=5)\n\n    def test_operators_matrix33(self):\n        v = Vector4()\n        m = Matrix33.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / m)\n\n    def test_operators_matrix44(self):\n        v = Vector4()\n        m = Matrix44.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + m)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - m)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v * m)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / m)\n\n    def test_operators_quaternion(self):\n        v = Vector4()\n        q = Quaternion.from_x_rotation(0.5)\n\n        # add\n        self.assertRaises(ValueError, lambda: v + q)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v - q)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v * q)\n\n        # divide\n        self.assertRaises(ValueError, lambda: v / q)\n\n    def test_operators_vector3(self):\n        v1 = Vector4()\n        v2 = Vector3([1.,2.,3.])\n\n        # add\n        self.assertRaises(ValueError, lambda: v1 + v2)\n\n        # subtract\n        self.assertRaises(ValueError, lambda: v1 - v2)\n\n        # multiply\n        self.assertRaises(ValueError, lambda: v1 * v2)\n\n        # divide\n        #self.assertRaises(ValueError, lambda: v1 / v2)\n\n        # or\n        self.assertRaises(ValueError, lambda: v1 | v2)\n\n        # xor\n        #self.assertRaises(ValueError, lambda: v1 ^ v2)\n\n        # ==\n        self.assertRaises(ValueError, lambda: Vector4() == Vector3())\n\n        # !=\n        self.assertRaises(ValueError, lambda: Vector4() != Vector3([1.,1.,1.]))\n\n    def test_operators_vector4(self):\n        v1 = Vector4()\n        v2 = Vector4([1.,2.,3.,4.])\n\n        # add\n        self.assertTrue(np.array_equal(v1 + v2, [1.,2.,3.,4.]))\n\n        # subtract\n        self.assertTrue(np.array_equal(v1 - v2, [-1.,-2.,-3.,-4]))\n\n        # multiply\n        self.assertTrue(np.array_equal(v1 * v2, [0.,0.,0.,0.]))\n\n        # divide\n        self.assertTrue(np.array_equal(v1 / v2, [0.,0.,0.,0.]))\n\n        # or\n        self.assertTrue(np.array_equal(v1 | v2, vector4.dot([0.,0.,0.,0.], [1.,2.,3.,4.])))\n\n        # xor\n        #self.assertTrue(np.array_equal(v1 ^ v2, vector4.cross([0.,0.,0.,0.], [1.,2.,3.,4.])))\n\n        # ==\n        self.assertTrue(Vector4() == Vector4())\n        self.assertFalse(Vector4() == Vector4([1.,1.,1.,1.]))\n\n        # !=\n        self.assertTrue(Vector4() != Vector4([1.,1.,1.,1.]))\n        self.assertFalse(Vector4() != Vector4())\n\n    def test_operators_number(self):\n        v1 = Vector4([1.,2.,3.,4.])\n        fv = np.empty((1,), dtype=[('i', np.int16, 1),('f', np.float32, 1)])\n        fv[0] = (2, 2.0)\n\n        # add\n        self.assertTrue(np.array_equal(v1 + 1., [2., 3., 4., 5.]))\n        self.assertTrue(np.array_equal(v1 + 1, [2., 3., 4., 5.]))\n        self.assertTrue(np.array_equal(v1 + np.float(1.), [2., 3., 4., 5.]))\n        self.assertTrue(np.array_equal(v1 + fv[0]['f'], [3., 4., 5., 6.]))\n        self.assertTrue(np.array_equal(v1 + fv[0]['i'], [3., 4., 5., 6.]))\n\n        # subtract\n        self.assertTrue(np.array_equal(v1 - 1., [0., 1., 2., 3.]))\n        self.assertTrue(np.array_equal(v1 - 1, [0., 1., 2., 3.]))\n        self.assertTrue(np.array_equal(v1 - np.float(1.), [0., 1., 2., 3.]))\n        self.assertTrue(np.array_equal(v1 - fv[0]['f'], [-1., 0., 1., 2.]))\n        self.assertTrue(np.array_equal(v1 - fv[0]['i'], [-1., 0., 1., 2.]))\n\n        # multiply\n        self.assertTrue(np.array_equal(v1 * 2., [2., 4., 6., 8.]))\n        self.assertTrue(np.array_equal(v1 * 2, [2., 4., 6., 8.]))\n        self.assertTrue(np.array_equal(v1 * np.float(2.), [2., 4., 6., 8.]))\n        self.assertTrue(np.array_equal(v1 * fv[0]['f'], [2., 4., 6., 8.]))\n        self.assertTrue(np.array_equal(v1 * fv[0]['i'], [2., 4., 6., 8.]))\n\n        # divide\n        self.assertTrue(np.array_equal(v1 / 2., [.5, 1., 1.5, 2.]))\n        self.assertTrue(np.array_equal(v1 / 2, [.5, 1., 1.5, 2.]))\n        self.assertTrue(np.array_equal(v1 / np.float(2.), [.5, 1., 1.5, 2.]))\n        self.assertTrue(np.array_equal(v1 / fv[0]['f'], [.5, 1., 1.5, 2.]))\n        self.assertTrue(np.array_equal(v1 / fv[0]['i'], [.5, 1., 1.5, 2.]))\n\n        # or\n        self.assertRaises(ValueError, lambda: v1 | .5)\n        self.assertRaises(ValueError, lambda: v1 | 5)\n        self.assertRaises(ValueError, lambda: v1 | np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 | fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 | fv[0]['i'])\n\n        # xor\n        self.assertRaises(ValueError, lambda: v1 ^ .5)\n        self.assertRaises(ValueError, lambda: v1 ^ 5)\n        self.assertRaises(ValueError, lambda: v1 ^ np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 ^ fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 ^ fv[0]['i'])\n\n        # ==\n        self.assertRaises(ValueError, lambda: v1 == .5)\n        self.assertRaises(ValueError, lambda: v1 == 5)\n        self.assertRaises(ValueError, lambda: v1 == np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 == fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 == fv[0]['i'])\n\n        # !=\n        self.assertRaises(ValueError, lambda: v1 != .5)\n        self.assertRaises(ValueError, lambda: v1 != 5)\n        self.assertRaises(ValueError, lambda: v1 != np.float(2.))\n        self.assertRaises(ValueError, lambda: v1 != fv[0]['f'])\n        self.assertRaises(ValueError, lambda: v1 != fv[0]['i'])\n\n    def test_bitwise(self):\n        v1 = Vector4([1.,0.,0.,1.])\n        v2 = Vector4([0.,1.,0.,1.])\n\n        # or (dot)\n        self.assertTrue(np.array_equal(v1 | v2, vector4.dot(v1, v2)))\n\n    def test_accessors(self):\n        v = Vector4(np.arange(self._size))\n        self.assertTrue(np.array_equal(v.xy,[0,1]))\n        self.assertTrue(np.array_equal(v.xyz,[0,1,2]))\n        self.assertTrue(np.array_equal(v.xz,[0,2]))\n        self.assertTrue(np.array_equal(v.xyz,[0,1,2]))\n\n        self.assertEqual(v.x, 0)\n        self.assertEqual(v.y, 1)\n        self.assertEqual(v.z, 2)\n\n        v.x = 1\n        self.assertEqual(v.x, 1)\n        self.assertEqual(v[0], 1)\n        v.x += 1\n        self.assertEqual(v.x, 2)\n        self.assertEqual(v[0], 2)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
