file_path,api_count,code
SmallWorldCA.py,20,"b""'''\r\nCreated on Feb 3, 2018\r\n\r\n@author: aditya\r\n\r\nThis class can be used to generate spatio temporal patterns of 1D cellular automata \r\n'''\r\nimport numpy as np\r\nclass CA_SmallWorld:\r\n    def __init__(self, rule, p = 1, q = 0.1, world_size = 1080, lifespan = 1920, config = 'regular'):\r\n        self.rule = np.array([int(i) for i in '{:08b}'.format(rule)])\r\n        self.height_img = world_size\r\n        self.width_img = lifespan\r\n        self.X = np.zeros((world_size, lifespan), dtype = int)\r\n        self.gates = np.zeros(world_size, dtype=int)\r\n        self.p = p\r\n        self.q = q\r\n        \r\n        if config not in ['regular', 'random']:\r\n            raise ValueError('Configurations not present in available options:[\\'regular\\', \\'random\\', \\'smallworld\\']')\r\n        self.config = config\r\n        \r\n        # neighbors for periodic boundary conditions\r\n        self.left = [world_size-1]+[i for i in range(world_size-1)]\r\n        self.right = [i for i in range(1, world_size)]+[0]\r\n        \r\n        self.setup()\r\n    \r\n    def resetworld(self):\r\n        self.X = np.zeros((self.height_img, self.width_img), dtype = int)\r\n        self.setup()\r\n        \r\n    def setup(self):\r\n        if self.config=='regular':\r\n            start_life = [i for i in range(int(self.height_img/2-len(self.rule)/2),int(self.height_img/2+len(self.rule)/2))]\r\n            self.X[start_life,0]=1\r\n        else:\r\n            p = np.random.rand(self.height_img)\r\n            self.X[p>0.5,0] = 1\r\n            \r\n    def simulation(self):\r\n        # This method takes care of cellular automata with given rule and randomness       \r\n        # Main Logic\r\n        for t in range(self.width_img):\r\n            world = self.X[:, t]\r\n            \r\n            p_t, q_t = np.random.rand(self.height_img), np.random.rand(self.height_img)\r\n            \r\n            self.gates[p_t<=self.p] = 1\r\n            \r\n            world_future_1 = 4*world[self.left] + 2*world + world[self.right]\r\n            world_future_1 = self.rule[world_future_1.astype(int)]\r\n            world_future_1 = np.multiply(world_future_1, self.gates)\r\n            \r\n            world_future_2 = np.zeros(self.height_img, dtype=int)\r\n            world_future_2[q_t<=self.q]=1\r\n            world_future_2 = np.multiply(world_future_2, np.logical_not(self.gates))\r\n            \r\n            world = world_future_1 + world_future_2\r\n            \r\n            if t+1>=self.width_img: break\r\n            \r\n            self.X[:,t+1] = world\r\n        \r\n        image = np.multiply(self.X,255)\r\n        image = image.astype(np.uint8)\r\n            \r\n        self.resetworld()\r\n        return image  \r\n        \r\n    def smallworld(self, f = 0.1):\r\n        # This method takes care of small world simulation\r\n        left, right = self.setneighbor_smallworld(f)\r\n        \r\n        # Main Logic\r\n        for t in range(self.width_img):\r\n            world = self.X[:, t]\r\n            \r\n            p_t, q_t = np.random.rand(self.height_img), np.random.rand(self.height_img)\r\n            \r\n            self.gates[p_t<=self.p] = 1\r\n            \r\n            world_future_1 = 4*world[left] + 2*world + world[right]\r\n            world_future_1 = self.rule[world_future_1.astype(int)]\r\n            world_future_1 = np.multiply(world_future_1, self.gates)\r\n            \r\n            world_future_2 = np.zeros(self.height_img, dtype=int)\r\n            world_future_2[q_t<=self.q]=1\r\n            world_future_2 = np.multiply(world_future_2, np.logical_not(self.gates))\r\n            \r\n            world = world_future_1 + world_future_2\r\n            \r\n            if t+1>=self.width_img: break\r\n            \r\n            self.X[:,t+1] = world\r\n        \r\n        image = np.multiply(self.X,255)\r\n        image = image.astype(np.uint8)\r\n\r\n        self.resetworld()\r\n        return image\r\n\r\n    def setneighbor_smallworld(self, f):\r\n        # randomizing the neighborhood for small world\r\n        left = self.left\r\n        right = self.right\r\n        for i in range(self.height_img):\r\n            rand = np.random.rand(2)\r\n            if rand[0]<f and rand[1]<0.5:\r\n                left[i] = np.random.randint(self.height_img)\r\n            elif rand[0]<f and rand[1]>0.5:\r\n                right[i] = np.random.randint(self.height_img)        \r\n        return left, right\r\n\r\nif __name__=='__main__':\r\n    \r\n    import matplotlib.pyplot as plt\r\n    RULE = 129\r\n    CA = CA_SmallWorld(RULE)\r\n    \r\n    image1 = CA.simulation()\r\n    im = plt.imshow(image1)\r\n    plt.xticks([]), plt.yticks([])\r\n    plt.title('Rule {}'.format(RULE))\r\n    plt.show()\r\n    \r\n    image2 = CA.smallworld()\r\n    im = plt.imshow(image2)\r\n    plt.xticks([]), plt.yticks([])\r\n    plt.title('Small World Network - Rule {}'.format(RULE))\r\n    plt.show()\r\n    """
main.py,0,"b'\'\'\'\r\nCreated on Feb 3, 2018\r\n\r\n@author: aditya\r\n\'\'\'\r\n\r\nfrom SmallWorldCA import CA_SmallWorld as CAS\r\nimport matplotlib.pyplot as plt\r\n\r\nif __name__==\'__main__\':\r\n    RULE = 129\r\n    subplot_h, subplot_v = 3, 2\r\n    \r\n    p = [1, 0.999, 0.99, 0.9, 0.5, 0]\r\n    q = [0.5, 0.1] \r\n    for j in range(len(q)): # col    \r\n        fig = plt.figure()\r\n        fig.suptitle(""RULE {}"".format(RULE), fontsize=""x-large"")\r\n        for i in range(len(p)):     # row\r\n            CA = CAS(RULE, p[i], q[j], world_size=400, lifespan=400)\r\n            image1 = CA.simulation()\r\n            plt.subplot(subplot_h, subplot_v, i+1)\r\n            plt.imshow(image1)\r\n            plt.xticks([]), plt.yticks([])\r\n            plt.title(\'p = {0}, q = {1}\'.format(p[i], q[j]) )\r\n        plt.tight_layout()\r\n        plt.show()\r\n    \r\n    f = [0 , 0.001, 0.01, 0.1, 0.5, 1]\r\n    fig = plt.figure()\r\n    fig.suptitle(""SMALL WORLD NETWORK - RULE {}"".format(RULE), fontsize=""x-large"")\r\n    for j in range(len(f)):\r\n        CA = CAS(RULE, world_size=400, lifespan=400)\r\n        image2 = CA.smallworld(f[j])\r\n        plt.subplot(subplot_h, subplot_v, j+1)\r\n        im = plt.imshow(image2)\r\n        plt.xticks([]), plt.yticks([])\r\n        plt.title(\'p = {0}, f = {1}\'.format(1, f[j]) )\r\n    plt.tight_layout()\r\n    plt.show()\r\n    '"
