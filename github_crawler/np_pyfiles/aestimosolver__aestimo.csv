file_path,api_count,code
DDGelectron_driftdiffusion.py,20,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Aug 19 13:59:47 2019\n\n\n\n## Copyright (C) 2004-2008  Carlo de Falco\n##\n## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n##\n##  SECS1D is free software; you can redistribute it and/or modify\n##  it under the terms of the GNU General Public License as published by\n##  the Free Software Foundation; either version 2 of the License, or\n##  (at your option) any later version.\n##\n##  SECS1D is distributed in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n##  GNU General Public License for more details.\n##\n##  You should have received a copy of the GNU General Public License\n##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n##\n## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n\n## -*- texinfo -*-\n##\n## @deftypefn {Function File}@\n## {@var{n}} = DDGelectron_driftdiffusion(@var{psi},@var{xaxis},@var{ng},@var{p},@var{ni},@var{TAUN0},@var{TAUP0},@var{mun})\n##\n## Solve the continuity equation for electrons\n##\n## Input:\n## @itemize @minus\n## @item psi: electric potential\n## @item xaxis: integration domain\n## @item ng: initial guess and BCs for electron density\n## @item p: hole density (for SRH recombination)\n## @end itemize\n##\n## Output:\n## @itemize @minus\n## @item n: updated electron density\n## @end itemize\n##\n## @end deftypefn\n""""""\n\nimport numpy as np\nfrom math import*\nfrom scipy import sparse as sp\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import func_lib\n    from .func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst,Ubernoulli\n    from .aestimo_poisson1d import equi_np_fi222\n    from . import config\nelse:\n    import func_lib\n    from func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst,Ubernoulli\n    from aestimo_poisson1d import equi_np_fi222\n    import config\n    \ndef DDGelectron_driftdiffusion(psi,xaxis,ng,p,ni,TAUN0,TAUP0,mun,fi_e,fi_h,model,Vt,idata):\n    \n    nodes        = xaxis\n    n_max     =len(nodes)\n    """"""\n    n=np.zeros(n_max)\n    p=np.zeros(n_max)\n    """"""\n    fi_n=np.zeros(n_max)\n    fi_p=np.zeros(n_max)    \n    elements=np.zeros((n_max-1,2))\n    elements[:,0]= np.arange(0,n_max-1)\n    elements[:,1]=np.arange(1,n_max)\n    Nelements=np.size(elements[:,0])\n    \n    BCnodes= [0,n_max-1]\n    \n    nl = ng[0]\n    nr = ng[n_max-1]\n    h=nodes[1:n_max]-nodes[0:n_max-1]\n    \n    c=1/h\n    """"""\n    print(""c="",c)\n    print(""h="",h)\n    print(""nr="",nr)\n    print(""nl="",nl)\n    print(""BCnodes="",BCnodes)\n    print(""Nelements="",Nelements)\n    print(""elements="",elements)\n    print(""n_max="",n_max)\n    print(""nodes="",nodes)\n    check_point_15\n    """"""\n    if model.N_wells_virtual-2!=0 and config.quantum_effect:\n        fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,psi,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,idata.n,p)    \n    Bneg=Ubernoulli(-(psi[1:n_max]-psi[0:n_max-1])-(fi_n[1:n_max]-fi_n[0:n_max-1]),1)    \n    Bpos=Ubernoulli( (psi[1:n_max]-psi[0:n_max-1])+(fi_p[1:n_max]-fi_p[0:n_max-1]),1)\n    """"""\n    print(""Bneg="",Bneg)\n    print(""Bpos="",Bpos)\n    check_point_16 \n    """"""\n    \n    d0=np.zeros(n_max)\n    d0[0]=c[0]*Bneg[0]\n    d0[n_max-1]=c[len(c)-1]*Bpos[len(Bpos)-1]\n    d0[1:n_max-1]=c[0:len(c)-1]*Bpos[0:len(Bpos)-1]+c[1:len(c)]*Bneg[1:len(Bneg)]    \n    \n    d1\t= np.zeros(n_max)\n    d1[0]=n_max\n    d1[1:n_max]=-c* Bpos      \n    dm1\t= np.zeros(n_max)\n    dm1[n_max-1]=n_max\n    dm1[0:n_max-1]=-c* Bneg \n    """"""\n    print(""d0="",d0)\n    print(""d1="",d1)\n    print(""dm1="",dm1)\n    check_point_17\n    """"""\n    A = sp.spdiags([dm1, d0, d1],np.array([-1,0,1]),n_max,n_max).todense() \n    \n    \n    b = np.zeros(n_max)#%- A * ng\n \n    ## SRH Recombination term\n    SRHD = TAUP0 * (ng + ni) + TAUN0 * (p + ni)\n    SRHL = p / SRHD\n    SRHR = ni**2 / SRHD\n    \n    ASRH = Ucompmass (nodes,n_max,elements,Nelements,SRHL,np.ones(Nelements))\n    bSRH = Ucompconst (nodes,n_max,elements,Nelements,SRHR,np.ones(Nelements))\n    """"""\n    print(""ASRH="",ASRH)\n    print(""bSRH="",bSRH)\n    check_point_18\n    """"""    \n    A = A + ASRH\n    b = b + bSRH\n    """""" \n    print(""A="",A)\n    print(""b="",b)\n    check_point_19\n    """"""  \n    ## Boundary conditions\n    b=np.delete(b, BCnodes, 0)\n    b[0]         = - A[1,0] * nl\n    b[len(b)-1]       =-A[n_max-2,n_max-1] * nr\n    A=np.delete(A, BCnodes, 0)\n    A=np.delete(A, BCnodes, 1)\n\n    nn= np.linalg.solve(A, b)\n    n=np.zeros(n_max)\n    n[1:n_max-1]=nn\n    n[0]=nl\n    n[len(n)-1]=nr\n    """"""\n    print(""BCnodes="",BCnodes)\n    print(""A="",A)\n    print(""b="",b)\n    print(""n="",n)\n    check_point_20    \n    """"""\n    return n\n'"
DDGgummelmap.py,10,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Aug 14 07:27:07 2019\n\n""""""\n\n## Copyright (C) 2004-2008  Carlo de Falco\n##\n## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n##\n##  SECS1D is free software you can redistribute it and/or modify\n##  it under the terms of the GNU General Public License as published by\n##  the Free Software Foundation either version 2 of the License, or\n##  (at your option) any later version.\n##\n##  SECS1D is distributed in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY without even the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n##  GNU General Public License for more details.\n##\n##  You should have received a copy of the GNU General Public License\n##  along with SECS1D If not, see <http://www.gnu.org/licenses/>.\n##\n## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n\n## -*- texinfo -*-\n##\n## @deftypefn {Function File}@\n## {@var{odata},@var{it},@var{res}} =  DDGgummelmap(@var{xaxis},@var{idata},@var{toll},@var{maxit},@var{ptoll},@var{pmaxit},@var{verbose})\n##\n## Solve the scaled stationary bipolar DD equation system using Gummel\n## algorithm\n##\n## Input:\n## @itemize @minus\n## @item xaxis: spatial grid\n## @item idata.dop: doping profile\n## @item idata.Ppz_Psp: Piezoelectric (Ppz) and Spontious (Psp) built-in polarization charge density profile\n## @item idata.p: initial guess for hole concentration\n## @item idata.n: initial guess for electron concentration\n## @item idata.V: initial guess for electrostatic potential\n## @item idata.Fn: initial guess for electron Fermi potential\n## @item idata.Fp: initial guess for hole Fermi potential\n## @item idata.l2: scaled electric permittivity (diffusion coefficient in Poisson equation)\n## @item idata.mun: scaled electron mobility\n## @item idata.mup: scaled electron mobility\n## @item idata.nis: scaled intrinsic carrier density\n## @item idata.TAUN0: scaled electron lifetime\n## @item idata.TAUP0: scaled hole lifetime\n## @item toll: tolerance for Gummel iterarion convergence test\n## @item maxit: maximum number of Gummel iterarions\n## @item ptoll: tolerance for Newton iterarion convergence test for non linear Poisson\n## @item pmaxit: maximum number of Newton iterarions\n## @item verbose: verbosity level (0,1,2)\n## @end itemize\n##\n## Output:\n## @itemize @minus\n## @item odata.n: electron concentration\n## @item odata.p: hole concentration\n## @item odata.V: electrostatic potential\n## @item odata.Fn: electron Fermi potential\n## @item odata.Fp: hole Fermi potential\n## @item it: number of Gummel iterations performed\n## @item res: total potential increment at each step\n## @end itemize\n##\n## @end deftypefn\nimport numpy as np\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import DDGnlpoisson\n    from .DDGnlpoisson import DDGnlpoisson\n    from .DDGelectron_driftdiffusion import DDGelectron_driftdiffusion\n    from .DDGhole_driftdiffusion import DDGhole_driftdiffusion\n    from . import func_lib\n    from .func_lib import DDGp2phip,DDGn2phin\nelse:        \n    import DDGnlpoisson\n    from DDGnlpoisson import DDGnlpoisson\n    from DDGelectron_driftdiffusion import DDGelectron_driftdiffusion\n    from DDGhole_driftdiffusion import DDGhole_driftdiffusion\n    import func_lib\n    from func_lib import DDGp2phip,DDGn2phin\n\ndef DDGgummelmap (n_max,xaxis,idata,odata,toll,maxit,ptoll,pmaxit,verbose,ni,fi_e,fi_h,model,Vt):\n\n    odata  = idata\n    dop         = idata.dop\n    Ppz_Psp= idata.Ppz_Psp\n    vout=np.zeros((n_max,2))\n    hole_density=np.zeros((n_max,3))\n    electron_density=np.zeros((n_max,3))\n    fermin=np.zeros((n_max,2))\n    fermip=np.zeros((n_max,2))\n    v_Nnodes=np.arange(n_max)\n    \n    vout[:,0] = idata.V\n    hole_density [:,0] = idata.p\n    electron_density [:,0]= idata.n\n    fermin [:,0]=idata.Fn\n    fermip [:,0]=idata.Fp\n    nrm=np.zeros(maxit)\n    for i in range (1,maxit):\n        if (verbose>1):\n          print(1,""*****************************************************************\\n"")  \n          print(1,""****    start of gummel iteration number: %d\\n"",i)\n          print(1,""*****************************************************************\\n"")        \n        if (verbose>1):\n            print(1,""solving non linear poisson equation\\n\\n"")\n        \n        #print(""here_1"",""i="",i,""/"",maxit)                                \n        [vout[:,1],electron_density[:,1],hole_density[:,1]] =DDGnlpoisson (idata,xaxis,v_Nnodes,vout[:,0],electron_density[:,0],hole_density[:,0],fermin[:,0],fermip[:,0],dop,Ppz_Psp,idata.l2,ptoll,pmaxit,verbose,ni,fi_e,fi_h,model,Vt)\n        \n        #print(""here_2"")\n        \n        """"""\n        print(""vout="",vout[:,1])\n        print(""electron_density="",electron_density[:,1])\n        print(""hole_density="",hole_density[:,1])\n        \n        \n        check_point_7 \n        """"""\n                                                        \t\n        if (verbose>1):\n          print (1,""\\n\\nupdating electron qfl\\n\\n"")\n        electron_density[:,2]=DDGelectron_driftdiffusion(vout[:,1], xaxis, electron_density[:,1],hole_density[:,1],idata.nis,idata.TAUN0,idata.TAUP0,idata.mun,fi_e,fi_h,model,Vt,idata)\n        \n        fermin[:,1] = DDGn2phin(vout[:,1],electron_density[:,2])\n        fermin[0,1]   = idata.Fn[0]\n        fermin[n_max-1,1] = idata.Fn[len(idata.Fn)-1]\n        \n       \n        if (verbose>1):\n          print(""updating hole qfl\\n\\n"")\n        hole_density[:,2] = DDGhole_driftdiffusion(vout[:,1], xaxis, hole_density[:,1],electron_density[:,1],idata.nis,idata.TAUN0,idata.TAUP0,idata.mup,fi_e,fi_h,model,Vt,idata)\n        \n        fermip[:,1] = DDGp2phip(vout[:,1],hole_density[:,2])\n        fermip[0,1]   = idata.Fp[0]\n        """""" \n        print(""vout="",vout[:,1])\n        print(""electron_density="",electron_density[:,2])\n        print(""hole_density="",hole_density[:,2])\n        \n        \n        check_point_14 \n        """"""\n        fermip[n_max-1,1] = idata.Fp[len(idata.Fp)-1]\n        \n        if (verbose>1):\n          print(""checking for convergence\\n\\n"")\n        nrfn= np.linalg.norm(fermin[:,1]-fermin[:,0],np.inf)\n        nrfp= np.linalg.norm (fermip[:,1]-fermip[:,0],np.inf)\n        nrv = np.linalg.norm (vout[:,1]-vout[:,0],np.inf)\n        nrm[i] = max([nrfn,nrfp,nrv])\n        if (verbose>1):\n          print ("" max(|phin_(k+1)-phinn_(k)| , |phip_(k+1)-phip_(k)| , |v_(k+1)- v_(k)| )= %d \\n""%nrm[i])\n        #print(""norm="",nrm[i],toll)\n        if (nrm[i]<toll):\n        \t\tbreak\n        \n        vout[:,0] = vout[:,1]\n        hole_density [:,0] = hole_density [:,2] \n        electron_density [:,0]= electron_density [:,2]\n        fermin [:,0]= fermin [:,1]\n        fermip [:,0]= fermip [:,1]\n        if(verbose and 1==2):\n            DDGplotresults(xaxis,electron_density,hole_density,vout,fermin,fermip)\t\t\n    \n    it = i\n    res = nrm\n    \n    if (verbose>0):\n        print(""\\n\\nInitial guess computed by DD: # of Gummel iterations = %d \\n\\n""%it)\n        \n    odata.n     = electron_density[:,2]\n    odata.p     = hole_density[:,2]\n    odata.V     = vout[:,1]\n    odata.Fn    = fermin[:,1]\n    odata.Fp    = fermip[:,1]\n \n    \n    return [odata,it,res]\n'"
DDGhole_driftdiffusion.py,20,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Aug 19 20:39:48 2019\n\n\n## Copyright (C) 2004-2008  Carlo de Falco\n##\n## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n##\n##  SECS1D is free software; you can redistribute it and/or modify\n##  it under the terms of the GNU General Public License as published by\n##  the Free Software Foundation; either version 2 of the License, or\n##  (at your option) any later version.\n##\n##  SECS1D is distributed in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n##  GNU General Public License for more details.\n##\n##  You should have received a copy of the GNU General Public License\n##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n##\n## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n\n## -*- texinfo -*-\n##\n## @deftypefn {Function File}@\n## {@var{p}} = DDGhole_driftdiffusio(@var{psi},@var{xaxis},@var{pg},@var{n},@var{ni},@var{TAUN0},@var{TAUP0},@var{mup})\n##\n## Solve the continuity equation for holes\n##\n## Input:\n## @itemize @minus\n## @item psi: electric potential\n## @item xaxis: spatial grid\n## @item ng: initial guess and BCs for electron density\n## @item n: electron density (for SRH recombination)\n## @end itemize\n##\n## Output:\n## @itemize @minus\n## @item p: updated hole density\n## @end itemize\n##\n## @end deftypefn\n""""""\nimport numpy as np\nfrom math import*\nfrom scipy import sparse as sp\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import func_lib\n    from .func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst,Ubernoulli\n    from .aestimo_poisson1d import equi_np_fi222\n    from . import config\nelse:    \n    import func_lib\n    from func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst,Ubernoulli\n    from aestimo_poisson1d import equi_np_fi222\n    import config\n\ndef  DDGhole_driftdiffusion(psi,xaxis,pg,n,ni,TAUN0,TAUP0,mup,fi_e,fi_h,model,Vt,idata):\n    \n    nodes        = xaxis\n    n_max     =len(nodes)\n    """"""\n    n=np.zeros(n_max)\n    p=np.zeros(n_max)\n    """"""\n    fi_n=np.zeros(n_max)\n    fi_p=np.zeros(n_max)\n    elements=np.zeros((n_max-1,2))\n    elements[:,0]= np.arange(0,n_max-1)\n    elements[:,1]=np.arange(1,n_max)\n    Nelements=np.size(elements[:,0])\n    \n    BCnodes= [0,n_max-1]\n    \n    pl = pg[0]\n    pr = pg[n_max-1]\n    h=nodes[1:len(nodes)]-nodes[0:len(nodes)-1]\n    \n    c=1/h\n    if model.N_wells_virtual-2!=0 and config.quantum_effect:\n        fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,psi,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,n,idata.p)\n    Bneg=Ubernoulli(-(psi[1:n_max]-psi[0:n_max-1])-(fi_n[1:n_max]-fi_n[0:n_max-1]),1)\n    Bpos=Ubernoulli( (psi[1:n_max]-psi[0:n_max-1])+(fi_p[1:n_max]-fi_p[0:n_max-1]),1)\n    \n    d0=np.zeros(n_max)\n    d0[0]=c[0]*Bneg[0]\n    d0[n_max-1]=c[len(c)-1]*Bpos[len(Bpos)-1]\n    d0[1:n_max-1]=c[0:len(c)-1]*Bpos[0:len(Bpos)-1]+c[1:len(c)]*Bneg[1:len(Bneg)]    \n    \n    d1\t= np.zeros(n_max)\n    d1[0]=n_max\n    d1[1:n_max]=-c* Bneg      \n    dm1\t= np.zeros(n_max)\n    dm1[n_max-1]=n_max\n    dm1[0:n_max-1]=-c* Bpos   \n    A = sp.spdiags([dm1, d0, d1],np.array([-1,0,1]),n_max,n_max).todense() \n    b = np.zeros(n_max)#%- A * ng\n    \n    ## SRH Recombination term\n        \n    SRHD = TAUP0 * (n + ni) + TAUN0 * (pg + ni)\n    SRHL = n / SRHD\n    SRHR = ni**2 / SRHD\n    \n    ASRH = Ucompmass (nodes,n_max,elements,Nelements,SRHL,np.ones(Nelements))\n    bSRH = Ucompconst (nodes,n_max,elements,Nelements,SRHR,np.ones(Nelements))\n    \n    A = A + ASRH\n    b = b + bSRH\n    \n    ## Boundary conditions\n    b=np.delete(b, BCnodes, 0)\n    b[0]         = - A[1,0] * pl\n    b[len(b)-1]       = - A[n_max-2,n_max-1] * pr\n    A=np.delete(A, BCnodes, 0)\n    A=np.delete(A, BCnodes, 1)\n    \n    pp= np.linalg.solve(A,b)\n    p=np.zeros(n_max)\n    p[1:n_max-1]=pp    \n    p[0]=pl\n    p[len(p)-1]=pr\n    return p\n'"
DDGnlpoisson.py,79,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Aug 14 08:52:43 2019\n\n\n## Copyright (C) 2004-2008  Carlo de Falco\n##\n## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n##\n##  SECS1D is free software you can redistribute it and/or modify\n##  it under the terms of the GNU General Public License as published by\n##  the Free Software Foundation either version 2 of the License, or\n##  (at your option) any later version.\n##\n##  SECS1D is distributed in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY without even the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n##  GNU General Public License for more details.\n##\n##  You should have received a copy of the GNU General Public License\n##  along with SECS1D If not, see <http://www.gnu.org/licenses/>.\n##\n## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n\n## -*- texinfo -*-\n##\n## @deftypefn {Function File}@\n## {@var{V},@var{n},@var{p},@var{res},@var{niter}} = @\n## DDGnlpoisson(@var{xaxis},@var{sinodes},@var{Vin},@var{nin},@var{pin},@var{Fnin},@var{Fpin},@var{dop},@var{Ppz_Psp},@var{l2},@var{toll},@var{maxit},@var{verbose})\n##\n## Solve the non linear Poisson equation\n## \n## - lamda^2 *V\'\' + (n(V,Fn) - p(V,Fp) -dop-Ppz_Psp) = 0 \n##\n## Input:\n## @itemize @minus\n## @item xaxis: spatial grid\n## @item sinodes: index of the nodes of the grid which are in the\n## semiconductor subdomain (remaining nodes are assumed to be in the oxide subdomain)\n## @item Vin: initial guess for the electrostatic potential\n## @item nin: initial guess for electron concentration\n## @item pin: initial guess for hole concentration\n## @item Fnin: initial guess for electron Fermi potential\n## @item Fpin: initial guess for hole Fermi potential\n## @item dop: doping profile\n## @item Ppz_Psp: Piezoelectric (Ppz) and Spontious (Psp) built-in polarization charge density profile\n## @item l2: scaled electric permittivity (diffusion coefficient)\n## @item toll: tolerance for convergence test\n## @item maxit: maximum number of Newton iterations\n## @item verbose: verbosity level (0,1,2)\n## @end itemize\n##\n## Output:\n## @itemize @minus\n## @item V: electrostatic potential\n## @item n: electron concentration\n## @item p: hole concentration\n## @item res: residual norm at each step\n## @item niter: number of Newton iterations\n## @end itemize\n##\n## @end deftypefn\n""""""\nimport numpy as np\nfrom math import*\nfrom scipy import sparse as sp\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import func_lib\n    from .func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst\n    from .aestimo_poisson1d import equi_np_fi222,equi_np_fi3,equi_np_fi\n    from . import config\nelse:\n    import func_lib\n    from func_lib import DDGphin2n,DDGphip2p,Ucompmass,Ucomplap,Ucompconst\n    from aestimo_poisson1d import equi_np_fi222,equi_np_fi3,equi_np_fi\n    import config\n    \ndef  DDGnlpoisson_new (idata,xaxis,sinodes,Vin,nin,pin,toll,maxit,verbose,fi_e,fi_h,model,Vt,surface,fi_stat,iteration,ns):\n    ## Set some useful constants\n    dampit = 10\n    dampcoeff\t= 5\n    \n    ## Convert grid info to FEM form\n    #Ndiricheletnodes= 2\n    nodes \t= xaxis\n    sielements=np.zeros(len(sinodes)-1) \n    sielements[:] = sinodes[1:len(sinodes)]\n    n_max\t= len(nodes)\n    #totdofs = n_max - Ndiricheletnodes\n    elements=np.zeros((n_max-1,2))\n    elements[:,0]= np.arange(0,n_max-1)\n    elements[:,1]=np.arange(1,n_max)\n    Nelements=np.size(elements[:,0])\n    BCnodes= n_max\n    normr=np.zeros(maxit+1)\n    """"""\n    print(""nodes="",nodes)\n    print(""sielements="",sielements)    \n    print(""n_max="",n_max)\n    print(""elements="",elements)\n    print(""Nelements="",Nelements)\n    print(""BCnodes="",BCnodes)\n    check_point_8    \n    """"""\n    ## Initialization\n    V = Vin\n    EF = 0.0\n    if iteration == 1:\n        # Determination of the Fermi Level\n        EF = 0.0\n        V = np.zeros(n_max)\n        n, p, V = equi_np_fi(\n            iteration, idata.dop, idata.Ppz_Psp, n_max, idata.ni, model, Vt, surface\n        )\n        fi_stat = V\n    else:\n        if model.N_wells_virtual - 2 != 0:\n            n, p, fi_non, EF = equi_np_fi3(\n            V,\n            idata.wfh_general,\n            idata.wfe_general,\n            model,\n            idata.E_state_general,\n            idata.E_statec_general,\n            idata.meff_state_general,\n            idata.meff_statec_general,\n            n_max,\n            idata.ni*ns,\n        )\n        else:\n            n = np.exp(V)\n            p = np.exp(-V)       \n        n=n*idata.ni\n        p=p*idata.ni\n    """"""\n    print(""sinodes="",sinodes)\n    print(""n="",n)\n    print(""p="",p)\n    check_point_9\n    """"""\n    if (sinodes[0]==0):\n        n[1]=nin[0]\n        p[1]=pin[0]\n    if (sinodes[n_max-1]==n_max-1):\n        n[n_max-1]=nin[n_max-1]\n        p[n_max-1]=pin[n_max-1]\n    \n    ## Compute LHS matrices\n    l22=idata.l2*np.ones(Nelements)\n    L      = Ucomplap (nodes,n_max,elements,Nelements,l22)\n    \n    ## Compute Mv =  ( n + p)\n    Mv            =  np.zeros(n_max)\n    Mv[sinodes]   =  (n + p)\n    Cv            =  np.ones(Nelements)\n    M             =  Ucompmass (nodes,n_max,elements,Nelements,Mv,Cv)\n    \n    ## Compute RHS vector\n    Tv0            =  np.zeros(n_max)\n    Tv0[sinodes]   = (n - p -idata.dop-idata.Ppz_Psp)\n    Cv=  np.ones(Nelements)\n    T0             =  Ucompconst (nodes,n_max,elements,Nelements,Tv0,Cv)\n    \n    """"""\n    print(\'L=\',L)\n    print(\'M=\',M)\n    print(\'T0=\',T0)\n    check_point_10\n    """"""\n    ## Build LHS matrix and RHS of the linear system for 1st Newton step\n    A=np.zeros((n_max,n_max))\n    R=np.zeros(n_max)\n    Anew=np.zeros((n_max,n_max))\n    Rnew=np.zeros(n_max)\n    \n    A \t\t= L + M\n    LV=np.dot(np.array(L) , V)\n    R \t\t=  LV +T0\n    \n    ## Apply boundary conditions\n    """"""\n    print(\'A=\',A)\n    print(\'R=\',R)\n    check_point_11\n    """"""\n    \n    A=np.delete(A, [0,BCnodes-1], 0)\n    A=np.delete(A, [0,BCnodes-1], 1)\n    R=np.delete(R, [0,BCnodes-1], 0)\n    \n    normr[0]\t\t=  np.linalg.norm(R,np.inf)\n    relresnorm \t= 1\n    reldVnorm   = 1\n    normrnew\t= normr[0]\n    \n    ## Start of the newton cycle\n    for newtit in range(1,maxit):\n        if verbose:\n            print(""\\n newton iteration: %d, reldVnorm = %f""%(newtit,reldVnorm))\n        \n        cc= np.linalg.solve(A, -R)#, rcond=None)[0]\n        dV=np.zeros(n_max)\n        dV[1:n_max-1] =cc\n        ## Start of the damping procedure\n        tk = 1\n \n        for dit in range(1,dampit):\n            if verbose:\n                print(""\\n damping iteration: %d, residual norm = %f""%(dit,normrnew))\n            Vnew   = V + tk * dV\n            if iteration == 1:\n                n = np.exp(Vnew)*idata.ni\n                p = np.exp(-Vnew)*idata.ni\n            else:\n                if model.N_wells_virtual - 2 != 0:\n                    n, p, fi_non, EF = equi_np_fi3(\n                    Vnew,\n                    idata.wfh_general,\n                    idata.wfe_general,\n                    model,\n                    idata.E_state_general,\n                    idata.E_statec_general,\n                    idata.meff_state_general,\n                    idata.meff_statec_general,\n                    n_max,\n                    idata.ni*ns,\n                )\n                else:\n                    n = np.exp(Vnew)\n                    p = np.exp(-Vnew)               \n                n=n*idata.ni\n                p=p*idata.ni            \n            if (sinodes[0]==0):\n                n[0]=nin[0]\n                p[0]=pin[0]\n            if (sinodes[n_max-1]==n_max-1):\n                n[n_max-1]=nin[n_max-1]\n                p[n_max-1]=pin[n_max-1]\n            \n            ## Compute LHS matrices\n            Mv            =  np.zeros(n_max)\n            Mv[sinodes]   =  (n + p)\n            Cv            =  np.ones(Nelements)\n            #Cv[sielements]=  1        \n            M    = Ucompmass (nodes,n_max,elements,Nelements,Mv,Cv)\n            \n            ## Compute RHS vector (-residual)\n            Tv0            =  np.zeros(n_max)\n            Tv0[sinodes]   =  (n - p -idata.dop-idata.Ppz_Psp)\n            Cv=  np.ones(Nelements)\n            Cv            =  np.ones(Nelements)\n            #Cv[sielements]=  1\n            T0     = Ucompconst (nodes,n_max,elements,Nelements,Tv0,Cv)\n            """""" \n            print(\'L=\',L)\n            print(\'M=\',M)\n            print(\'T0=\',T0)\n            check_point_12\n            """"""           \n            ## Build LHS matrix and RHS of the linear system for 1st Newton step\n            Anew \t\t= L + M\n            LVnew=np.dot(np.array(L) , Vnew)\n            Rnew \t\t=  LVnew +T0\n            """"""\n            print(\'Anew=\',Anew)\n            print(\'Rnew=\',Rnew)\n            check_point_13\n            """"""\n            ## Apply boundary conditions\n            Anew=np.delete(Anew, [0,BCnodes-1], 0)\n            Anew=np.delete(Anew, [0,BCnodes-1], 1)\n            Rnew=np.delete(Rnew, [0,BCnodes-1], 0)\n            \n            if ((dit>1) and (np.linalg.norm(Rnew,np.inf) >= np.linalg.norm(R,np.inf))):\n                if verbose:\n                    print(""\\nexiting damping cycle \\n"")\n                break\n            else:\n                A = Anew\n                R = Rnew\n        \n            ## Compute | R_{k+1} | for the convergence test\n            normrnew= np.linalg.norm(R,np.inf)\n            \n            ## Check if more damping is needed\n            if (normrnew > normr[newtit]):\n                tk = tk/dampcoeff\n            else:\n                if verbose:\n                    print(""\\nexiting damping cycle because residual norm = %f \\n""%normrnew)\n                break\n    \n        V= Vnew\t\n        normr[newtit+1] = normrnew\n        dVnorm= np.linalg.norm(tk*dV,np.inf)\n    \n        ## Check if convergence has been reached\n        reldVnorm           = dVnorm / np.linalg.norm(V,np.inf)\n        if (reldVnorm <= toll):\n            if(verbose):\n                print(""\\nexiting newton cycle because reldVnorm= %f \\n""%reldVnorm)\n            break\n    \n    res = normr\n    niter = newtit\n    \n    return [V,n,p,fi_stat]#,res,niter\n\ndef  DDGnlpoisson (idata,xaxis,sinodes,Vin,nin,pin,Fnin,Fpin,dop,Ppz_Psp,l2,toll,maxit,verbose,ni,fi_e,fi_h,model,Vt):\n    ## Set some useful constants\n    dampit = 10\n    dampcoeff\t= 5\n    \n    ## Convert grid info to FEM form\n    #Ndiricheletnodes= 2\n    nodes \t= xaxis\n    sielements=np.zeros(len(sinodes)-1) \n    sielements[:] = sinodes[1:len(sinodes)]\n    n_max\t= len(nodes)\n    fi_n=np.zeros(n_max)\n    fi_p=np.zeros(n_max)\n    #totdofs = n_max - Ndiricheletnodes\n    elements=np.zeros((n_max-1,2))\n    elements[:,0]= np.arange(0,n_max-1)\n    elements[:,1]=np.arange(1,n_max)\n    Nelements=np.size(elements[:,0])\n    BCnodes= n_max\n    normr=np.zeros(maxit+1)\n    """"""\n    print(""nodes="",nodes)\n    print(""sielements="",sielements)    \n    print(""n_max="",n_max)\n    print(""elements="",elements)\n    print(""Nelements="",Nelements)\n    print(""BCnodes="",BCnodes)\n    check_point_8    \n    """"""\n    ## Initialization\n    V = Vin\n    Fn = Fnin\n    Fp = Fpin\n    if model.N_wells_virtual-2!=0 and config.quantum_effect:\n        fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,V,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,idata.n,idata.p)\n\n    n = DDGphin2n(V[sinodes]+fi_n[sinodes],Fn,idata.n)\n    p = DDGphip2p(V[sinodes]+fi_p[sinodes],Fp,idata.p)\n    """"""\n    print(""sinodes="",sinodes)\n    print(""n="",n)\n    print(""p="",p)\n    check_point_9\n    """"""\n    if (sinodes[0]==0):\n        n[1]=nin[0]\n        p[1]=pin[0]\n    if (sinodes[n_max-1]==n_max-1):\n        n[n_max-1]=nin[n_max-1]\n        p[n_max-1]=pin[n_max-1]\n    \n    ## Compute LHS matrices\n    l22=l2*np.ones(Nelements)\n    L      = Ucomplap (nodes,n_max,elements,Nelements,l22)\n    \n    ## Compute Mv =  ( n + p)\n    Mv            =  np.zeros(n_max)\n    Mv[sinodes]   =  (n + p)\n    Cv            =  np.ones(Nelements)\n    M             =  Ucompmass (nodes,n_max,elements,Nelements,Mv,Cv)\n    \n    ## Compute RHS vector\n    Tv0            =  np.zeros(n_max)\n    Tv0[sinodes]   = (n - p -dop-Ppz_Psp)\n    Cv=  np.ones(Nelements)\n    T0             =  Ucompconst (nodes,n_max,elements,Nelements,Tv0,Cv)\n    \n    """"""\n    print(\'L=\',L)\n    print(\'M=\',M)\n    print(\'T0=\',T0)\n    check_point_10\n    """"""\n    ## Build LHS matrix and RHS of the linear system for 1st Newton step\n    A=np.zeros((n_max,n_max))\n    R=np.zeros(n_max)\n    Anew=np.zeros((n_max,n_max))\n    Rnew=np.zeros(n_max)\n    \n    A \t\t= L + M\n    LV=np.dot(np.array(L) , V)\n    R \t\t=  LV +T0\n    \n    ## Apply boundary conditions\n    """"""\n    print(\'A=\',A)\n    print(\'R=\',R)\n    check_point_11\n    """"""\n    \n    A=np.delete(A, [0,BCnodes-1], 0)\n    A=np.delete(A, [0,BCnodes-1], 1)\n    R=np.delete(R, [0,BCnodes-1], 0)\n    \n    normr[0]\t\t=  np.linalg.norm(R,np.inf)\n    relresnorm \t= 1\n    reldVnorm   = 1\n    normrnew\t= normr[0]\n    \n    ## Start of the newton cycle\n    for newtit in range(1,maxit):\n        if verbose:\n            print(""\\n newton iteration: %d, reldVnorm = %f""%(newtit,reldVnorm))\n        \n        cc= np.linalg.solve(A, -R)#, rcond=None)[0]\n        dV=np.zeros(n_max)\n        dV[1:n_max-1] =cc\n        ## Start of the damping procedure\n        tk = 1\n \n        for dit in range(1,dampit):\n            if verbose:\n                print(""\\n damping iteration: %d, residual norm = %f""%(dit,normrnew))\n            Vnew   = V + tk * dV\n            if model.N_wells_virtual-2!=0 and config.quantum_effect:\n                fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,Vnew,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,n,p)             \n            n = DDGphin2n(Vnew[sinodes]+fi_n[sinodes],Fn,idata.n)\n            p = DDGphip2p(Vnew[sinodes]+fi_p[sinodes],Fp,idata.p)\n            if (sinodes[0]==0):\n                n[0]=nin[0]\n                p[0]=pin[0]\n            if (sinodes[n_max-1]==n_max-1):\n                n[n_max-1]=nin[n_max-1]\n                p[n_max-1]=pin[n_max-1]\n            \n            ## Compute LHS matrices\n            Mv            =  np.zeros(n_max)\n            Mv[sinodes]   =  (n + p)\n            Cv            =  np.ones(Nelements)\n            #Cv[sielements]=  1        \n            M    = Ucompmass (nodes,n_max,elements,Nelements,Mv,Cv)\n            \n            ## Compute RHS vector (-residual)\n            Tv0            =  np.zeros(n_max)\n            Tv0[sinodes]   =  (n - p -dop-Ppz_Psp)\n            Cv=  np.ones(Nelements)\n            Cv            =  np.ones(Nelements)\n            #Cv[sielements]=  1\n            T0     = Ucompconst (nodes,n_max,elements,Nelements,Tv0,Cv)\n            """""" \n            print(\'L=\',L)\n            print(\'M=\',M)\n            print(\'T0=\',T0)\n            check_point_12\n            """"""           \n            ## Build LHS matrix and RHS of the linear system for 1st Newton step\n            Anew \t\t= L + M\n            LVnew=np.dot(np.array(L) , Vnew)\n            Rnew \t\t=  LVnew +T0\n            """"""\n            print(\'Anew=\',Anew)\n            print(\'Rnew=\',Rnew)\n            check_point_13\n            """"""\n            ## Apply boundary conditions\n            Anew=np.delete(Anew, [0,BCnodes-1], 0)\n            Anew=np.delete(Anew, [0,BCnodes-1], 1)\n            Rnew=np.delete(Rnew, [0,BCnodes-1], 0)\n            \n            if ((dit>1) and (np.linalg.norm(Rnew,np.inf) >= np.linalg.norm(R,np.inf))):\n                if verbose:\n                    print(""\\nexiting damping cycle \\n"")\n                break\n            else:\n                A = Anew\n                R = Rnew\n        \n            ## Compute | R_{k+1} | for the convergence test\n            normrnew= np.linalg.norm(R,np.inf)\n            \n            ## Check if more damping is needed\n            if (normrnew > normr[newtit]):\n                tk = tk/dampcoeff\n            else:\n                if verbose:\n                    print(""\\nexiting damping cycle because residual norm = %f \\n""%normrnew)\n                break\n    \n        V= Vnew\t\n        normr[newtit+1] = normrnew\n        dVnorm= np.linalg.norm(tk*dV,np.inf)\n    \n        ## Check if convergence has been reached\n        reldVnorm           = dVnorm / np.linalg.norm(V,np.inf)\n        if (reldVnorm <= toll):\n            if(verbose):\n                print(""\\nexiting newton cycle because reldVnorm= %f \\n""%reldVnorm)\n            break\n    \n    res = normr\n    niter = newtit\n    \n    return [V,n,p]#,res,niter\n'"
DDNnewtonmap.py,33,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Thu Aug 29 14:14:03 2019\n\n""""""\n\n## Copyright (C) 2004-2008  Carlo de Falco\n##\n## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n##\n##  SECS1D is free software; you can redistribute it and/or modify\n##  it under the terms of the GNU General Public License as published by\n##  the Free Software Foundation; either version 2 of the License, or\n##  (at your option) any later version.\n##\n##  SECS1D is distributed in the hope that it will be useful,\n##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n##  GNU General Public License for more details.\n##\n##  You should have received a copy of the GNU General Public License\n##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n##\n## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n\n## -*- texinfo -*-\n##\n## @deftypefn {Function File}@\n## {@var{odata},@var{it},@var{res}} = DDNnewtonmap(@var{xaxis},@var{idata},@var{toll},@var{maxit},@var{verbose})\n##\n## Solve the scaled stationary bipolar DD equation system using a\n## coupled Newton algorithm\n##\n## Input:\n## @itemize @minus\n## @item xaxis: spatial grid\n## @item idata.dop: doping profile\n## @item idata.Ppz_Psp: Piezoelectric (Ppz) and Spontious (Psp) built-in polarization charge density profile\n## @item idata.p: initial guess for hole concentration\n## @item idata.n: initial guess for electron concentration\n## @item idata.V: initial guess for electrostatic potential\n## @item idata.Fn: initial guess for electron Fermi potential\n## @item idata.Fp: initial guess for hole Fermi potential\n## @item idata.l2: scaled electric permittivity (diffusion coefficient in Poisson equation)\n## @item idata.mun: scaled electron mobility\n## @item idata.mup: scaled electron mobility\n## @item idata.nis: scaled intrinsic carrier density\n## @item idata.TAUN0: scaled electron lifetime\n## @item idata.TAUP0: scaled hole lifetime\n## @item toll: tolerance for Newton iterarion convergence test\n## @item maxit: maximum number of Newton iterarions\n## @item verbose: verbosity level: 0,1,2\n## @end itemize\n##\n## Output:\n## @itemize @minus\n## @item odata.n: electron concentration\n## @item odata.p: hole concentration\n## @item odata.V: electrostatic potential\n## @item odata.Fn: electron Fermi potential\n## @item odata.Fp: hole Fermi potential\n## @item it: number of Newton iterations performed\n## @item res: residual at each step\n## @end itemize\n##\n## @end deftypefn\n\nimport numpy as np\nfrom math import*\nfrom scipy import sparse as sp\nfrom scipy.sparse import bsr_matrix\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import func_lib\n    from .func_lib import Uscharfettergummel,Ucompmass,Ucomplap,Umediaarmonica\n    from .aestimo_poisson1d import equi_np_fi222\n    from . import config\nelse:    \n    import func_lib\n    from func_lib import Uscharfettergummel,Ucompmass,Ucomplap,Umediaarmonica\n    from aestimo_poisson1d import equi_np_fi222\n    import config\n\n\ndef  DDNnewtonmap (ni,fi_e,fi_h,xaxis,idata,toll,maxit,verbose,model,Vt):\n    odata     = idata\n    n_max    = len(xaxis)\n    fi_n=np.zeros(n_max)\n    fi_p=np.zeros(n_max)\n    Nelements=n_max-1\n    elements=np.zeros((n_max-1,2))\n    elements[:,0]= np.arange(0,n_max-1)\n    elements[:,1]=np.arange(1,n_max)\n    BCnodesp = [0,n_max-1]\n    BCnodesp1 = [n_max,2*n_max-1]\n    BCnodesp2 = [2*n_max,3*n_max-1]\n    BCnodes_=np.zeros((3,2))\n    BCnodes_[0,:]=BCnodesp\n    BCnodes_[1,:]=BCnodesp1\n    BCnodes_[2,:]=BCnodesp2\n    BCnodes=BCnodes_.flatten()\n\n    totaldofs= n_max-2\n    dampcoef = 10\n    maxdamp  = 2\n    nrm_du_old=1.\n    V = odata.V\n    n = odata.n\n    p = odata.p\n    dop = idata.dop\n    Ppz_Psp=idata.Ppz_Psp\n    \n    ## Create the complete unknown vector\n    u = np.hstack(([V, n, p]))\n    if model.N_wells_virtual-2!=0 and config.quantum_effect:\n        fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,V,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,n,p)    \n    ## Build fem matrices\n    L = Ucomplap (xaxis,n_max,elements,Nelements,idata.l2*np.ones(Nelements))\n    M = Ucompmass (xaxis,n_max,elements,Nelements,np.ones(n_max),np.ones(Nelements))\n    DDn = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mun,1,V+fi_n)\n    DDp = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mup,1,-V-fi_p)\n    \n    ## Initialise RHS\n    denomsrh   = idata.TAUN0 * (p + idata.theta) + idata.TAUP0 * (n + idata.theta)\n    factauger  = idata.Cn * n + idata.Cp * p\n    fact       = (1 / denomsrh + factauger)\n    r1  = np.dot(np.array(L) , V) + np.dot(np.array(M) , (n - p - dop-Ppz_Psp))\n    r2  = np.dot(np.array(DDn) , n)+ np.dot(np.array(M) , (p * n - idata.theta** 2) * fact)\n    r3  = np.dot(np.array(DDp) , p)+ np.dot(np.array(M) , (p * n - idata.theta** 2) * fact)\n    RHS=-np.hstack(( r1, r2, r3))\n\n    ##  Apply BCs\n    RHS=np.delete(RHS, BCnodes, 0)\n    nrm = np.linalg.norm(RHS,np.inf)\n    res=np.zeros(maxit)\n    res[0] = nrm\n    ## Begin Newton Cycle\n    for count in range (0, maxit):\n        if verbose:\n          print (""Newton Iteration Number:%d\\n""%count)\t\n        Ln = Ucomplap (xaxis,n_max,elements,Nelements,Umediaarmonica(idata.mun*n))\n        Lp = Ucomplap (xaxis,n_max,elements,Nelements,Umediaarmonica(idata.mup*p))\n        Mn = Ucompmass (xaxis,n_max,elements,Nelements,np.ones(n_max),n[0:n_max-1]*fact[0:n_max-1])\n        Mp = Ucompmass (xaxis,n_max,elements,Nelements,np.ones(n_max),p[0:n_max-1]*fact[0:n_max-1])\n        Z  = np.zeros((n_max,n_max))   \n        DDn = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mun,1,V+fi_n)\n        DDp = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mup,1,-V-fi_p)\n        A \t= L  #A11\n        B\t= M #A12\n        C\t=-M #A13\n        DDD\t=-Ln #A21\n        E\t= DDn+Mp#A22\n        F\t= Z+Mn  #A23\n        G\t= Lp #A31\n        H\t= Z+Mp #A32\n        I\t= DDp+Mn#A33\n        ## Build LHS\n        LHS= np.asarray(np.bmat([(A,\tB, C),(DDD, E, F),(G, H, I)]))\n        ## Apply BCs\n        LHS=np.delete(LHS, BCnodes, 0)\n        LHS=np.delete(LHS, BCnodes, 1)        \n        ## Solve the linearised system\n        dutmp= np.linalg.solve(LHS, RHS)#, rcond=None)[0]\n        dv    = dutmp[0:totaldofs]\n        dn    = dutmp[totaldofs:2*totaldofs]\n        dp    = dutmp[2*totaldofs:3*totaldofs]\n        du=np.hstack((0,dv,0,0,dn,0,0,dp,0))\n        ## Check Convergence\n        nrm_u = np.linalg.norm(u,np.inf)\n        nrm_du = np.linalg.norm(du,np.inf)\n    \t\n        ratio = nrm_du/nrm_u \n        if verbose:\n          print (""ratio = %e\\n""% ratio)\t\t\n        \n        if (ratio <= toll):\n            V \t = u[0:n_max]\n            n\t    = u[n_max:2*n_max]\n            p\t    = u[2*n_max:len(u)]\n            res[count]  = nrm\n            break\n        ## Begin damping cycle\n        tj = 1\n        if model.N_wells_virtual-2!=0 and config.quantum_effect:\n            fi_n,fi_p =equi_np_fi222(ni,idata,fi_e,fi_h,V,Vt,idata.wfh_general,idata.wfe_general,model,idata.E_state_general,idata.E_statec_general,idata.meff_state_general,idata.meff_statec_general,n_max,n,p)\n        for cc in range( 1,maxdamp):\n          if verbose:\n            print (""damping iteration number:%d\\n""%cc)\n            print (""reference residual norm:%f\\n""%nrm)\n          \n          ## Update the unknown vector\t\t\n          utmp    = u + tj*du\n          Vnew \t    = utmp[0:n_max]\n          nnew\t    = utmp[n_max:2*n_max]\n          pnew\t    = utmp[2*n_max:len(utmp)]\n          ## Try a new RHS\n          \n          DDn = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mun,1,Vnew+fi_n)\n          DDp = Uscharfettergummel(xaxis,n_max,elements,Nelements,idata.mup,1,-Vnew-fi_p)\n          \n          r1  = np.dot(np.array(L) , V) + np.dot(np.array(M) , (nnew - pnew - dop-Ppz_Psp))\n          r2  = np.dot(np.array(DDn) , nnew)+ np.dot(np.array(M) , (pnew * nnew - idata.theta** 2) * fact)\n          r3  = np.dot(np.array(DDp) , pnew) + np.dot(np.array(M) , (pnew * nnew - idata.theta** 2) * fact)\n          RHS=-np.hstack(( r1, r2, r3))\n\n          ## Apply BCs\n          RHS=np.delete(RHS, BCnodes, 0)\n          nrmtmp=np.linalg.norm(RHS,np.inf)\n          \n          ## Update the damping coefficient\n          if verbose:\n              print(""residual norm:%f\\n\\n""%nrmtmp)\n            \n          if (nrmtmp>nrm):\n              tj = tj/(dampcoef*cc)\n              if verbose:                  \n                  print (""\\ndamping coefficients = %f""%tj)\n          else:\n              break\n        nrm_du = np.linalg.norm(tj*du,np.inf)\n        u \t= utmp\n        \n        if (count>0):\n            ratio = nrm_du/nrm_du_old\n            if (ratio<.005):\n                V \t    = u[0:n_max]\n                n\t    = u[n_max:2*n_max]\n                p\t    = u[2*n_max:len(u)]            \n                res[count]  = nrm\n                break           \n        nrm = nrmtmp\n        res[count]  = nrm\n        ## Convert result vector into distinct output vectors \n        V \t    = u[0:n_max]\n        n\t    = u[n_max:2*n_max]\n        p\t    = u[2*n_max:len(u)]    \n        nrm_du_old = nrm_du\n    odata.V = V\n    odata.n = n\n    odata.p = p\n    \n\n    it   = count\n\n    return [odata,it,res]\n'"
VBHM.py,102,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""\nWe consider the upper 3 \xc3\x97 3 Hamiltonian for a (001)-oriented\nzinc blende (ZB) crystal see ref [1], after block diagonalization \nthe KP-FDM (k.P theory + Finite Difference Method ) method is explained\nin ref [2] to ensure the Hermitian property of Hamiltonian you have to\napply the we have to write all operators of the form presented in ref [3],\nto understand Hermiticity property see ref [2]. page 110,same code in fortran\nlanguage presented in the index of ref [1]. Dirichlet boundary conditions\nwere applied [1].\n[1]:D.Ahn & S-H.Park \'ENGINEERING QUANTUM MECHANICS\' P 238\n[2]:P.Harrison \'QUANTUM WELLS, WIRES AND DOTS\' P 357-362\n[3]: S-L.CHUANG \'physics of Optoelectronic Devices\' P 183\n""""""\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2016 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n""""""\n#from scipy.optimize import fsolve\nimport numpy as np\nfrom math import *\n#start\n#material parametre for barrier and well\ndef qsv(GA1,GA2,GA3,RATIO,VNIT,ZETA,CNIT,AC1,n_max,delta,A1,A2,A3,A4,A5,A6,delta_so,delta_cr,mat_type):\n    AP1= np.zeros(n_max+2)\n    AP2= np.zeros(n_max+2)\n    AP3= np.zeros(n_max+2)\n    AP4= np.zeros(n_max+2)\n    AP5= np.zeros(n_max+2)\n    AP6= np.zeros(n_max+2)\n    GDELM= np.zeros(n_max+2)\n    FH= np.zeros(n_max+2)\n    FL= np.zeros(n_max+2)\n    FSO=  np.zeros(n_max+2)\n    DEL3=  np.zeros(n_max+2)\n    DEL1=  np.zeros(n_max+2)\n    DEL2=  np.zeros(n_max+2)\n    Pce=  np.zeros(n_max+2)\n    if mat_type==\'Zincblende\':     \n        AP1=GA1\n        AP2=GA2\n        AP3=GA1\n        AP4=GA2\n        AP5=(GA2+GA3)/2.0\n        AP6=GA3\n        GDELM=RATIO*(sqrt(2.0)*ZETA)/AC1\n        FH=RATIO*(VNIT+ZETA)/AC1\n        FL=RATIO*(VNIT-ZETA)/AC1\n        FSO=RATIO*(VNIT+delta)/AC1\n        Pce=RATIO*(CNIT)/AC1\n    if mat_type==\'Wurtzite\':\n        AP1=A1\n        AP2=A2\n        AP3=A3\n        AP4=A4\n        AP5=A5\n        AP6=A6\n        FH=RATIO*(ZETA)/AC1\n        FL=RATIO*(VNIT)/AC1\n        DEL3=RATIO*(delta_so/3)/AC1\n        DEL1=RATIO*(delta_cr)/AC1\n        DEL2=RATIO*(delta_so/3)/AC1\n        Pce=RATIO*(CNIT)/AC1+DEL1+DEL2\n    AP1=np.resize(AP1,n_max+2)\n    AP2=np.resize(AP2,n_max+2)\n    AP3=np.resize(AP3,n_max+2)\n    AP4=np.resize(AP4,n_max+2)\n    AP5=np.resize(AP5,n_max+2)\n    AP6=np.resize(AP6,n_max+2)\n    FH=np.resize(FH,n_max+2)\n    FL=np.resize(FL,n_max+2)\n    FSO=np.resize(FSO,n_max+2)\n    GDELM=np.resize(GDELM,n_max+2)\n    DEL3=np.resize(DEL3,n_max+2)\n    DEL1=np.resize(DEL1,n_max+2)\n    DEL2=np.resize(DEL2,n_max+2)\n    Pce=np.resize(Pce,n_max+2)\n    return AP1,AP2,AP3,AP4,AP5,AP6,FH,FL,FSO,Pce,GDELM,DEL3,DEL1,DEL2\n#\n#define VB Hamiltonian\n\ndef VBMAT1(KP,AP1,AP2,AP3,AP4,AP5,AP6,FH,FL,FSO,GDELM,x_max,n_max,AC1,UNIM,KPINT):\n    AVH1= np.zeros(n_max+2)\n    AVH2= np.zeros(n_max+2)\n    BVH1= np.zeros(n_max+2)\n    BVH2= np.zeros(n_max+2)\n    GVH1= np.zeros(n_max+2)\t\n    GVH2= np.zeros(n_max+2)\t\t\n    CVH= np.zeros(n_max+2)\n    DVH= np.zeros(n_max+2)\t\t \n    FVH1= np.zeros(n_max+2)\n    FVH2= np.zeros(n_max+2)\n    AVHDF2=np.zeros((n_max+2, n_max+2))\n    BVHDF2=np.zeros((n_max+2, n_max+2))\n    FVHDF2=np.zeros((n_max+2, n_max+2))\n    GVHDF2=np.zeros((n_max+2, n_max+2))\n    DVHDF1=np.zeros((n_max+2, n_max+2))\n    B=np.zeros((n_max*3, n_max*3)) \n#=====DEFINE MATRIX=================\n    for I in range(0,n_max+2,1):\n            AVH1[I]=0.5*(AP3[I]+AP4[I])*((x_max*KP*KPINT)**2)\n            AVH2[I]=0.5*(AP1[I]-2.0*AP2[I])\n            BVH1[I]=0.5*(AP3[I]-AP4[I])*((x_max*KP*KPINT)**2)\n            BVH2[I]=0.5*(AP1[I]+2.0*AP2[I])\n            GVH1[I]=0.5*AP3[I]*((x_max*KP*KPINT)**2)\t\n            GVH2[I]=0.5*AP1[I]\t\t\t\n            CVH[I]=0.5*sqrt(3.0)*AP5[I]*((x_max*KP*KPINT)**2) \n            DVH[I]=sqrt(3.0)*AP6[I]*x_max*KP*KPINT\t\t\t \n            FVH1[I]=AP4[I]/sqrt(2.0)*((x_max*KP*KPINT)**2) \n            FVH2[I]=sqrt(2.0)*AP2[I]\n            #boundary condition between barrier and well \n    for I in range (0,n_max,1):\n                AVH2[I]=(AVH2[I-1]+AVH2[I+1])/2.0\n                BVH2[I]=(BVH2[I-1]+BVH2[I+1])/2.0\n                GVH2[I]=(GVH2[I-1]+GVH2[I+1])/2.0\n                FVH2[I]=(FVH2[I-1]+FVH2[I+1])/2.0\n                DVH[I]=(DVH[I-1]+DVH[I+1])/2.0\n                CVH[I]=(CVH[I-1]+CVH[I+1])/2.0\n                FVH1[I]=(FVH1[I-1]+FVH1[I+1])/2.0\n                BVH1[I]=(BVH1[I-1]+BVH1[I+1])/2.0\n                GVH1[I]=(GVH1[I-1]+GVH1[I+1])/2.0\n                AVH1[I]=(AVH1[I-1]+AVH1[I+1])/2.0  \n    for I in range (0,n_max,1):\n            # filling i row\n            AVHDF2[I,I]+=-AVH2[I+1]-(AVH2[I]+AVH2[I+2])/2.0\n            BVHDF2[I,I]+=-BVH2[I+1]-(BVH2[I]+BVH2[I+2])/2.0\n            FVHDF2[I,I]+=-FVH2[I+1]-(FVH2[I]+FVH2[I+2])/2.0\n            GVHDF2[I,I]+=-GVH2[I+1]-(GVH2[I]+GVH2[I+2])/2.0\n            # filling i-1 and i+1 rows\n            AVHDF2[I,I+1]+=(AVH2[I+1]+AVH2[I+2])/2.0\n            AVHDF2[I+1,I]+=(AVH2[I+2]+AVH2[I+1])/2.0\n            BVHDF2[I,I+1]+=(BVH2[I+1]+BVH2[I+2])/2.0\n            BVHDF2[I+1,I]+=(BVH2[I+2]+BVH2[I+1])/2.0\n            FVHDF2[I,I+1]+=(FVH2[I+1]+FVH2[I+2])/2.0\n            FVHDF2[I+1,I]+=(FVH2[I+2]+FVH2[I+1])/2.0\n            GVHDF2[I,I+1]+=(GVH2[I+1]+GVH2[I+2])/2.0\n            GVHDF2[I+1,I]+=(GVH2[I+2]+GVH2[I+1])/2.0\n            DVHDF1[I,I+1]+=(DVH[I+2]+DVH[I+1])/2.0\n            DVHDF1[I+1,I]+=-(DVH[I+2]+DVH[I+1])/2.0\n    for I in range (0,n_max,1):\n            for J in range (0,n_max,1):        \n                AVHDF2[I,J]*=AC1\n                BVHDF2[I,J]*=AC1\n                FVHDF2[I,J]*=AC1\n                GVHDF2[I,J]*=AC1\n                DVHDF1[I,J]*=sqrt(AC1)/2.0\n                #here where start filling the matrix\n    for I in range (0,n_max,1):\n        for J in range (0,n_max,1):\n                B[I,J]+=AVH1[I+1]*UNIM[I,J]-AVHDF2[I,J]+FH[I+1]*UNIM[I,J]*AC1\n                B[I+n_max,J+n_max]+=BVH1[I+1]*UNIM[I,J]-BVHDF2[I,J]+FL[I+1]*UNIM[I,J]*AC1\n                B[I+n_max*2,J+n_max*2]+=GVH1[I+1]*UNIM[I,J]-GVHDF2[I,J]+FSO[I+1]*UNIM[I,J]*AC1\n                B[I+n_max,J]+=CVH[I+1]*UNIM[I,J]+DVHDF1[I,J]\n                B[I+n_max*2,J]+=sqrt(2.0)*CVH[I+1]*UNIM[I,J]-DVHDF1[I,J]/sqrt(2.0)\n                B[I+n_max*2,J+n_max]+=FVH1[I+1]*UNIM[I,J]+FVHDF2[I,J]-sqrt(3.0/2.0)*DVHDF1[I,J]+GDELM[I+1]*UNIM[I,J]*AC1\n                #filling the symitric part of the hamiltonian matrix\n                B[I,J+n_max]=B[J+n_max,I]\n                B[I,J+n_max*2]=B[J+n_max*2,I]\n                B[I+n_max,J+n_max*2]=B[J+n_max*2,I+n_max]  \n    return B\n\ndef VBMAT2(KP,AP1,AP2,AP3,AP4,AP5,AP6,FH,FL,x_max,n_max,AC1,UNIM,KPINT,DEL3,DEL1,DEL2):\n    B11V1= np.zeros(n_max+2)\n    B11V2= np.zeros(n_max+2)\n    B12V1= np.zeros(n_max+2)\n    B13V1= np.zeros(n_max+2)\t\n    B21V1= np.zeros(n_max+2)\t\t\n    B22V1= np.zeros(n_max+2)\n    B22V2= np.zeros(n_max+2)\t\t \n    B23V1= np.zeros(n_max+2)\n    B31V1= np.zeros(n_max+2)\n    B32V1= np.zeros(n_max+2)\t\t \n    B33V1= np.zeros(n_max+2)\n    B33V2= np.zeros(n_max+2)\n    B11=np.zeros((n_max+2, n_max+2))\n    B22=np.zeros((n_max+2, n_max+2))\n    B33=np.zeros((n_max+2, n_max+2))\n    B13=np.zeros((n_max+2, n_max+2))\n    B23=np.zeros((n_max+2, n_max+2))\n    B31=np.zeros((n_max+2, n_max+2))\n    B32=np.zeros((n_max+2, n_max+2))\n    B=np.zeros((n_max*3, n_max*3)) \n#=====DEFINE MATRIX=================\n    for I in range(0,n_max+2,1):\n            B11V2[I]=0.5*(AP2[I]+AP4[I])*((KP*x_max*KPINT)**2)\n            B12V1[I]=0.5*AP5[I]*((KP*x_max*KPINT)**2)\n            B21V1[I]=0.5*AP5[I]*((KP*x_max*KPINT)**2)\n            B22V2[I]=0.5*(AP2[I]+AP4[I])*((KP*x_max*KPINT)**2)\n            B33V2[I]=0.5*AP2[I]*(KP*x_max*KPINT)**2\n            ###################################################\n            B33V1[I]=-0.5*AP1[I]\n            B22V1[I]=-0.5*(AP1[I]+AP3[I])\n            B11V1[I]=-0.5*(AP1[I]+AP3[I])\n            ###################################################\n            B13V1[I]=0.5*AP6[I]*(KP*x_max*KPINT)\n            B23V1[I]=0.5*AP6[I]*(KP*x_max*KPINT)\n            B31V1[I]=0.5*AP6[I]*(KP*x_max*KPINT)\n            B32V1[I]=0.5*AP6[I]*(KP*x_max*KPINT)\n            #boundary condition between barrier and well \n    for I in range (0,n_max,1):\n                B33V2[I]=(B33V2[I-1]+B33V2[I+1])/2.0\n                B33V1[I]=(B33V1[I-1]+B33V1[I+1])/2.0\n                B32V1[I]=(B32V1[I-1]+B32V1[I+1])/2.0\n                B31V1[I]=(B31V1[I-1]+B31V1[I+1])/2.0\n                B23V1[I]=(B23V1[I-1]+B23V1[I+1])/2.0\n                B22V2[I]=(B22V2[I-1]+B22V2[I+1])/2.0\n                B22V1[I]=(B22V1[I-1]+B22V1[I+1])/2.0\n                B21V1[I]=(B21V1[I-1]+B21V1[I+1])/2.0\n                B13V1[I]=(B13V1[I-1]+B13V1[I+1])/2.0\n                B12V1[I]=(B12V1[I-1]+B12V1[I+1])/2.0\n                B11V2[I]=(B11V2[I-1]+B11V2[I+1])/2.0\n                B11V1[I]=(B11V1[I-1]+B11V1[I+1])/2.0                \n    for I in range (0,n_max,1):\n            # filling i row\n            B11[I,I]+=-B11V1[I+1]-(B11V1[I]+B11V1[I+2])/2.0\n            B22[I,I]+=-B22V1[I+1]-(B22V1[I]+B22V1[I+2])/2.0\n            B33[I,I]+=-B33V1[I+1]-(B33V1[I]+B33V1[I+2])/2.0\n            # filling i-1 and i+1 rows\n            B11[I,I+1]+=(B11V1[I+1]+B11V1[I+2])/2.0\n            B11[I+1,I]+=(B11V1[I+2]+B11V1[I+1])/2.0\n            B13[I,I+1]+=-(B13V1[I+1]+B13V1[I+2])/2.0\n            B13[I+1,I]+=(B13V1[I+1]+B13V1[I+1])/2.0\n            B22[I,I+1]+=(B22V1[I+1]+B22V1[I+2])/2.0\n            B22[I+1,I]+=(B22V1[I+1]+B22V1[I+1])/2.0\n            B23[I,I+1]+=-(B23V1[I+1]+B23V1[I+2])/2.0\n            B23[I+1,I]+=(B23V1[I+1]+B23V1[I+1])/2.0\n            B31[I,I+1]+=(B31V1[I+2]+B31V1[I+1])/2.0\n            B31[I+1,I]+=-(B31V1[I+1]+B31V1[I+1])/2.0\n            B32[I,I+1]+=(B32V1[I+1]+B32V1[I+2])/2.0\n            B32[I+1,I]+=-(B32V1[I+1]+B32V1[I+1])/2.0\n            B33[I,I+1]+=(B33V1[I+1]+B33V1[I+2])/2.0\n            B33[I+1,I]+=(B33V1[I+2]+B33V1[I+1])/2.0           \n\n    for I in range (0,n_max,1):\n            for J in range (0,n_max,1):        \n                B11[I,J]*=AC1\n                B13[I,J]*=sqrt(AC1)/2\n                B22[I,J]*=AC1\n                B23[I,J]*=sqrt(AC1)/2\n                B31[I,J]*=sqrt(AC1)/2\n                B32[I,J]*=sqrt(AC1)/2\n                B33[I,J]*=AC1\n                #here where start filling the matrix\n    for I in range (0,n_max,1):\n        for J in range (0,n_max,1):\n                B[I,J]+=B11[I,J]+B11V2[I+1]*UNIM[I,J]+(DEL1[I+1]+DEL2[I+1]+FH[I+1]+FL[I+1])*UNIM[I,J]*AC1\n                B[I+n_max,J+n_max]+=B22[I,J]+B22V2[I+1]*UNIM[I,J]+(DEL1[I+1]-DEL2[I+1]+FH[I+1]+FL[I+1])*UNIM[I,J]*AC1\n                B[I+n_max*2,J+n_max*2]+=B33[I,J]+B33V2[I+1]*UNIM[I,J]+FH[I+1]*UNIM[I,J]*AC1\n                B[I+n_max,J]+=B21V1[I+1]*UNIM[I,J]\n                B[I+n_max*2,J]+=B31[I,J]\n                B[I+n_max*2,J+n_max]+=B32[I,J]+sqrt(2)*DEL3[I+1]*UNIM[I,J]*AC1       \n                B[I,J+n_max]+=B12V1[I+1]*UNIM[I,J]\n                B[I,J+n_max*2]+=B13[I,J]\n                B[I+n_max,J+n_max*2]+=B23[I,J]+sqrt(2)*DEL3[I+1]*UNIM[I,J]*AC1\n    return B\ndef VBMAT_V(B2,fi_h,RATIO,n_max,UNIM):\n    """"""B2 - float?\n    fi_h - 1d array, potential\n    RATIO - float?\n    n_max - int, number of points in grid.\n    UNIM - 2d array\n    """"""\n    #tmp=np.resize(fi_h,n_max+1)[1:]\n    tmp = -RATIO*np.roll(fi_h,-1)\n    #tmp[-1] = 0.0 #?\n    A = tmp[:,np.newaxis]*UNIM\n    Z = np.zeros((n_max,n_max))\n    #Creating HUPMAT4\n    #1\n    #HUPMAT4 = np.vstack((np.hstack((A,Z,Z)),\n    #                     np.hstack((Z,A,Z)),\n    #                     np.hstack((Z,Z,A))))\n    #2 - using the strange c_ and r_ \'functions\'\n    #HUPMAT4 = np.r_[np.c_[A,Z,Z],\n    #                np.c_[Z,A,Z],\n    #                np.c_[Z,Z,A]]\n    #3 - using block matrices (skips intermediates)\n    HUPMAT4 = np.asarray(np.bmat([(A,Z,Z),(Z,A,Z),(Z,Z,A)]))\n    \n    HUPMAT4+=B2       \n    return HUPMAT4\n\ndef VBMAT_V_2(B2,fi_h,RATIO,i_1,I1,UNIM):\n    """"""B2 - float?\n    fi_h - 1d array, potential\n    RATIO - float?\n    n_max - int, number of points in grid.\n    UNIM - 2d array\n    """"""\n    I2=I1+i_1\n    #tmp=np.resize(fi_h,n_max+1)[1:]\n    tmp = -RATIO*np.roll(fi_h[I1:I2],-1)\n    #tmp[-1] = 0.0 #?\n    A = tmp[:,np.newaxis]*UNIM[I1:I2,I1:I2]\n    Z = np.zeros((i_1,i_1))\n    #Creating HUPMAT4\n    #1\n    #HUPMAT4 = np.vstack((np.hstack((A,Z,Z)),\n    #                     np.hstack((Z,A,Z)),\n    #                     np.hstack((Z,Z,A))))\n    #2 - using the strange c_ and r_ \'functions\'\n    #HUPMAT4 = np.r_[np.c_[A,Z,Z],\n    #                np.c_[Z,A,Z],\n    #                np.c_[Z,Z,A]]\n    #3 - using block matrices (skips intermediates)\n    HUPMAT3_general_2 = np.asarray(np.bmat([(A,Z,Z),(Z,A,Z),(Z,Z,A)]))\n    \n    HUPMAT3_general_2+=B2       \n    return HUPMAT3_general_2\n \ndef VBMAT_V_old(B2,fi_h,RATIO,n_max,UNIM):\n    HUPMAT4=np.zeros((n_max*3, n_max*3))\n    tmp1=np.zeros(n_max)\n    tmp1=fi_h\n    tmp1=np.resize(tmp1,n_max+2)    \n    tmp=RATIO*(-tmp1)\n    tmp=tmp.tolist()\n    for I in range (0,n_max,1):\n        for J in range (0,n_max,1):\n            HUPMAT4[I,J]+=tmp[I+1]*UNIM[I,J]\n            HUPMAT4[I+n_max,J+n_max]+=tmp[I+1]*UNIM[I,J]\n            HUPMAT4[I+n_max*2,J+n_max*2]+=tmp[I+1]*UNIM[I,J]\n    HUPMAT4+=B2       \n    return HUPMAT4\n\ndef CBMAT(KP,Pce,EM,x_max,n_max,AC1,UNIM,KPINT):\n    B11V1= np.zeros(n_max+2)\n    B11V2= np.zeros(n_max+2)\n    B11=np.zeros((n_max+2, n_max+2))\n    B=np.zeros((n_max, n_max))\n    EM=np.resize(EM,n_max+2)\n#=====DEFINE MATRIX=================\n    for I in range(0,n_max+2,1):\n            B11V2[I]=0.5*((KP*x_max*KPINT)**2)/EM[I]\n            B11V1[I]=-0.5/EM[I]\n            #boundary condition between barrier and well\n    for I in range (0,n_max,1):\n                B11V2[I]=(B11V2[I-1]+B11V2[I+1])/2.0\n                B11V1[I]=(B11V1[I-1]+B11V1[I+1])/2.0\n    for I in range (0,n_max,1):\n            # filling i row\n            B11[I,I]+=-B11V1[I+1]-(B11V1[I]+B11V1[I+2])/2.0\n            # filling i-1 and i+1 rows\n            B11[I,I+1]+=(B11V1[I+1]+B11V1[I+2])/2.0\n            B11[I+1,I]+=(B11V1[I+2]+B11V1[I+1])/2.0\n\n    for I in range (0,n_max,1):\n            for J in range (0,n_max,1):\n                B11[I,J]*=AC1\n                #here where start filling the matrix\n    #UNIM=np.resize(UNIM,n_max+2)\n    for I in range (0,n_max,1):\n        for J in range (0,n_max,1):\n                B[I,J]+=B11[I,J]+B11V2[I+1]*UNIM[I,J]+Pce[I+1]*UNIM[I,J]*AC1\n    return B\n\ndef CBMAT_V(BC,fi,RATIO,n_max,UNIM):\n    #tmp=np.resize(fi_h,n_max+1)[1:]\n    tmp = RATIO*np.roll(fi,-1)\n    #tmp[-1] = 0.0 #?\n    HUPMAT7 = tmp[:,np.newaxis]*UNIM    \n    HUPMAT7+=BC       \n    return HUPMAT7\n\ndef CBMAT_V_old(BC,fi,RATIO,n_max,UNIM):\n    HUPMAT7=np.zeros((n_max, n_max))\n    tmp1=np.zeros(n_max)\n    tmp=np.zeros(n_max+2)\n    tmp1=fi\n    tmp1=np.resize(tmp1,n_max+2)\n    tmp=RATIO*(tmp1)\n    tmp=tmp.tolist()\n    for I in range (0,n_max,1):\n        for J in range (0,n_max,1):\n            HUPMAT7[I,J]+=tmp[I+1]*UNIM[I,J]\n    HUPMAT7+=BC\n    return HUPMAT7\n\n'"
__init__.py,0,"b'from . import aestimo\nfrom . import aestimo_eh\nfrom . import config\nfrom . import database\nfrom . import intersubband_optical_transitions\n\nimport os\n\nlocalpath = lambda fname: os.path.abspath(\n    os.path.join(os.path.dirname(__file__), fname)\n)\n\n# load module docstring\n__doc__ = open(localpath(""README.md"")).read()\n\n__version__ = aestimo.__version__\n'"
aestimo.py,52,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2020 Aestimo Group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS \n\nFile Information:\n-----------------\nThis is the aestimo calculator of conduction band structure for quantum wells.\n\naestimo.py can be used as a script or a library.\n\nTo use as a script, define the simulation in a python file (see the sample-*.py \nfiles for examples of the parameters needed) and then run aestimo on the command\nline as \n  ./aestimo.py -i <input file>\nSince we are abusing the python module system, the input \'file\' needs to be \nimportable by the aestimo script. Alternatively, define the input file in the\nconfig module using the inputfilename parameter.\n\nTo use aestimo as a library, first create an instance of the Structure class; \nthis can be more conveniently done using the StructureFrom class which builds \nthe arrays describing a structure from a simple list format that describes the\nstructure\'s layers. See the class docstrings for details on the required \nparameters.\n\nThe simplest way to then calculate the structure is to use the Poisson_Schrodinger()\nfunction. See the run_aestimo() function\'s source code for details on presenting or \nsaving the results of this calculation using the returned object.\n\nCalculations can be sped up by compiling the cythonised version of the psi_at_inf*\nfunctions. This can be done using the setup_cython.py module.\n""""""\n__version__ = ""2.0.2""\n\nimport time\n\ntime0 = time.time()  # timing audit\n# from scipy.optimize import fsolve\nimport matplotlib.pyplot as pl\nimport numpy as np\n\nalen = np.alen\nimport os, sys\n\n#importing examples directory\nexamplesdir = os.path.abspath(os.path.join(os.path.dirname(__file__), \'examples\'))\nsys.path.append(examplesdir)\n\nfrom math import log, exp\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import config, database\nelse:\n    import config, database\n# --------------------------------------\nimport logging\n\nlogger = logging.getLogger(""aestimo"")\n# Create log-result directory \nif not os.path.isdir(os.path.abspath(os.path.join(examplesdir, config.output_directory))):\n    os.makedirs(os.path.abspath(os.path.join(examplesdir, config.output_directory)))\n\n# File\nhdlr = logging.FileHandler(os.path.abspath(os.path.join(examplesdir, os.path.join(config.output_directory,config.logfile))))\nformatter = logging.Formatter(""%(asctime)s %(levelname)s %(name)s %(message)s"")\nhdlr.setFormatter(formatter)\nlogger.addHandler(hdlr)\n# stderr\nch = logging.StreamHandler()\nformatter2 = logging.Formatter(""%(levelname)s %(message)s"")\nch.setFormatter(formatter2)\nlogger.addHandler(ch)\n# LOG level can be INFO, WARNING, ERROR\nlogger.setLevel(logging.INFO)\n\nos.sys.stderr.write(\n    ""WARNING aestimo logs automatically to aestimo.log in the example\'s directory.\\n""\n)\n# --------------------------------------\n\n# Defining constants and material parameters\nq = 1.602176e-19  # C\nkb = 1.3806504e-23  # J/K\nnii = 0.0\nhbar = 1.054588757e-34\nm_e = 9.1093826e-31  # kg\npi = np.pi\neps0 = 8.8541878176e-12  # F/m\n\nJ2meV = 1e3 / q  # Joules to meV\nmeV2J = 1e-3 * q  # meV to Joules\n\ntime1 = time.time()  # timing audit\n# logger.info(""Aestimo is starting..."")\n\n# Input Class\n# -------------------------------------\n\n\ndef round2int(x):\n    """"""int is sensitive to floating point numerical errors near whole numbers,\n    this moves the discontinuity to the half interval. It is also equivalent\n    to the normal rules for rounding positive numbers.""""""\n    # int(x + (x>0) -0.5) # round2int for positive and negative numbers\n    return int(x + 0.5)\n\n\nclass Structure:\n    def __init__(\n        self,\n        T,\n        Fapp,\n        subnumber_e,\n        dx,\n        n_max,  # parameters\n        fi,\n        eps,\n        dop,\n        cb_meff,  # arrays\n        comp_scheme,\n        meff_method,\n        fermi_np_scheme,  # model choices\n        boundary_scheme=0,  # optional model choices\n        cb_meff_alpha=None,\n        Eg=None,\n        Ep=None,\n        F=None,\n        delta_S0=None,  # optional arrays\n        **kwargs\n    ):\n        """"""This class holds details on the structure to be simulated.\n        database is the module containing the material properties. Then\n        this class should have the following attributes set\n          Fapp - float - applied field (Vm**-1)\n          T - float - Temperature (K)\n          subnumber_e - int- number of subbands to look for.\n          comp_scheme - int - computing scheme (see below)\n          meff_method - int - choose effective mass function to model non-parabolicity (see below)\n          fermi_np_scheme - bool - include nonparabolicity in calculation of Fermi level\n          boundary_scheme - int (optional) - choose boundary condition for Poisson field (see below)\n        \n          dx - float - grid step size (m)\n          n_max - int - number of grid points\n        \n        #arrays - float/double (len = n_max)\n          fi - Bandstructure potential (J) \n          eps - dielectric constant (including eps0)\n          dop - doping distribution (m**-3)\n          cb_meff - conduction band effective mass (kg)\n        \n        #optional arrays - float/double (len = n_max)\n          cb_meff_alpha - non-parabolicity constant. Used for Nelson\'s empirical 2-band model)\n          Eg - band gap energy (Used for k.p model found in Vurgaftman)\n          Ep - (Used for k.p model found in Vurgaftman)\n          F - (Used for k.p model found in Vurgaftman)\n          delta_S0 - spin split-off energy (Used for k.p model found in Vurgaftman)\n                \n        COMPUTATIONAL SCHEMES (comp_scheme)\n        0: Schrodinger\n        1: Schrodinger + nonparabolicity\n        2: Schrodinger-Poisson\n        3: Schrodinger-Poisson with nonparabolicity\n        4: Schrodinger-Exchange interaction\n        5: Schrodinger-Poisson + Exchange interaction\n        6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n        \n        EFFECTIVE MASS MODELS (meff_method) \n                        - for when nonparabolicity is modelled (see comp_scheme)\n        0: no energy dependence\n        1: Nelson\'s effective 2-band model\n        2: k.p model from Vurgaftman\'s 2001 paper\n        \n        POISSON BOUNDARY CONDITION (boundary_scheme) (optional)\n                        - not for applied field, only for field generated by the dopants.\n        0: Electric field = 0 at boundaries (Default)\n        1: Potential(x=0) = Potential(x=max) - periodic boundary conditions.\n        """"""\n        # value attributes\n        self.T = T\n        self.Fapp = Fapp\n        self.subnumber_e = subnumber_e\n        self.comp_scheme = comp_scheme\n        self.fermi_np_scheme = fermi_np_scheme\n        self.boundary_scheme = boundary_scheme\n        self.dx = dx\n        self.n_max = n_max\n        self.x_max = dx * n_max\n\n        self.fi = fi\n        self.eps = eps\n        self.dop = dop\n        self.cb_meff = cb_meff\n\n        # Nelson\'s 2-band nonparabolicity model\n        self.cb_meff_alpha = cb_meff_alpha\n        # Vurgaftman\'s k.p nonparabolicity model\n        self.Eg = Eg\n        self.Ep = Ep\n        self.F = F\n        self.delta_S0 = delta_S0\n\n        # setting any extra parameters provided with initialisation\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n        # choosing effective mass function for non-parabolicity calculations\n        self.meff_method = meff_method\n        if self.meff_method == 1:\n            self.cb_meff_E = self.cb_meff_E1\n        elif self.meff_method == 2:\n            self.cb_meff_E = self.cb_meff_E2\n\n    def cb_meff_E(self, E, fi):\n        """"""returns an array for the structure giving the effective mass for a particular\n        energy. This version simply returns the conduction-band edge effective mass without\n        any energy dependence. This default method should be overwritten in the class\'\n        __init__() method in order to model non-parabolicity.\n        E - energy (J)\n        fi - bandstructure potential (J) (numpy array)\n        """"""\n        return self.cb_meff * np.ones_like(E)\n\n    def cb_meff_E1(self, E, fi):\n        """"""returns an array for the structure giving the effective mass for a particular\n        energy. This method implements Nelson\'s empirical 2-band model of non-parabolicity.\n        This method needs to be aliased to the cb_meff_E() method in order for aestimo to\n        use it.\n        E - energy (J)\n        fi - bandstructure potential (J) (numpy array)\n        """"""\n        return self.cb_meff * (1.0 + self._cb_meff_alpha * (E - fi))\n\n    def cb_meff_E2(self, E, fi):\n        """"""returns an array for the structure giving the effective mass for a particular\n        energy. This uses the non-parabolicity calculation as given by Vurgaftman\'s 2001 \n        paper on semiconductor properties. This method needs to be aliased to the \n        cb_meff_E() method in order for aestimo to use it.\n        E - energy (J)\n        fi - bandstructure potential (J) (numpy array)\n        """"""\n        EeV = (E - fi) / q\n        return m_e / (\n            (1 + 2 * self.F)\n            + self.Ep\n            / 3.0\n            * (2.0 / (EeV + self.Eg) + 1.0 / (EeV + self.Eg + self.delta_SO))\n        )\n\n\nclass AttrDict(dict):\n    """"""turns a dictionary into an object with attribute style lookups""""""\n\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n\nclass StructureFrom(Structure):\n    def __init__(self, inputfile, database):\n        """"""database is a module or object containing the semiconductor material\n        properties. Normally this is just aestimo\'s database.py module.\n        \n        inputfile is a dict or object with the following required parameters or\n        attributes. These are exactly the parameters normally defined in the \n        input files (note that the parameter names are not exactly the same \n        as those for the Structure class) :\n        \n          Fapplied - applied field (Vm**-1) (float)\n          T - Temperature (K) (float)\n          subnumber_e - number of subbands to look for. (int)\n          computation_scheme - computing scheme (see below) (int)\n          meff_method - choose effective mass function to model non-parabolicity (see below) (int)\n          fermi_np_scheme - include nonparabolicity in calculation of Fermi level (bool)\n          boundary_scheme - (optional) choose boundary condition for Poisson field (see below) (int)\n\n          gridfactor - grid step size (m) (float)\n          maxgridpoints - number of grid points (int)\n        \n          material - a list describing a structure\'s layers. Each layer is a list\n                     containing the following fields:\n               thickness -  (nm)\n               material type - any defined in the database ie. {GaAs,AlAs,AlGaAs,InGaAs...}  \n               alloy fraction - value between 0.0 and 1.0\n               doping (cm^-3) - density of dopants in the layer\n               doping type - whether the dopants are n-type or p-type\n              i.e.\n              [[ 20.0, \'AlGaAs\', 0.3, 1e17, \'n\'],\n               [ 50.0,   \'GaAs\',   0,    0, \'n\']]\n        \n\n        COMPUTATIONAL SCHEMES (comp_scheme)\n        0: Schrodinger\n        1: Schrodinger + nonparabolicity\n        2: Schrodinger-Poisson\n        3: Schrodinger-Poisson with nonparabolicity\n        4: Schrodinger-Exchange interaction\n        5: Schrodinger-Poisson + Exchange interaction\n        6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n\n        EFFECTIVE MASS MODELS (meff_method) \n                        - for when nonparabolicity is modelled (see comp_scheme)\n        0: no energy dependence\n        1: Nelson\'s effective 2-band model\n        2: k.p model from Vurgaftman\'s 2001 paper\n        \n        POISSON BOUNDARY CONDITION (boundary_scheme) (optional)\n                        - not for applied field, only for field generated by the dopants.\n        0: Electric field = 0 at boundaries (Default)\n        1: Potential(x=0) = Potential(x=max) - periodic boundary conditions.\n        \n        Nb. If changes are made to an instance\'s input parameters after \n        initialisation, the method create_structure_arrays() should be run to\n        update the instance to the new parameters.\n        """"""\n        if type(inputfile) == dict:\n            inputfile = AttrDict(inputfile)\n        # Parameters for simulation\n        self.Fapp = inputfile.Fapplied\n        self.T = inputfile.T\n        self.subnumber_e = inputfile.subnumber_e\n        self.comp_scheme = inputfile.computation_scheme\n        self.fermi_np_scheme = inputfile.fermi_np_scheme\n        self.boundary_scheme = getattr(\n            inputfile, ""boundary_scheme"", 0\n        )  # optional parameter\n        self.dx = inputfile.gridfactor * 1e-9  # grid in m\n        self.maxgridpoints = inputfile.maxgridpoints\n\n        # Loading material list\n        self.material = inputfile.material\n        totallayer = alen(self.material)\n        logger.info(""Total layer number: %s"", totallayer)\n\n        # Calculate the required number of grid points\n        self.x_max = (\n            sum([layer[0] for layer in self.material]) * 1e-9\n        )  # total thickness (m)\n        self.n_max = int(self.x_max / self.dx)\n\n        # Check on n_max\n        max_val = inputfile.maxgridpoints\n        if self.n_max > max_val:\n            logger.error("" Grid number is exceeding the max number of %d"", max_val)\n            exit()\n        # Loading materials database\n        self.material_property = database.materialproperty\n        totalmaterial = alen(self.material_property)\n\n        self.alloy_property = database.alloyproperty\n        totalalloy = alen(self.alloy_property)\n\n        logger.info(\n            ""Total number of materials in database: %d"", (totalmaterial + totalalloy)\n        )\n\n        # choosing effective mass function for non-parabolicity calculations\n        self.meff_method = inputfile.meff_method\n        if self.meff_method == 1:\n            self.cb_meff_E = self.cb_meff_E1\n        elif self.meff_method == 2:\n            self.cb_meff_E = self.cb_meff_E2\n        # Initialise arrays\n\n        # cb_meff #conduction band effective mass (array, len n_max)\n        # fi #Bandstructure potential (array, len n_max)\n        # eps #dielectric constant (array, len n_max)\n        # dop #doping distribution (array, len n_max)\n        self.create_structure_arrays()\n\n    def create_structure_arrays(self):\n        """""" initialise arrays/lists for structure""""""\n        # Calculate the required number of grid points\n        self.x_max = (\n            sum([layer[0] for layer in self.material]) * 1e-9\n        )  # total thickness (m)\n        n_max = round2int(self.x_max / self.dx)\n        # Check on n_max\n        maxgridpoints = self.maxgridpoints\n        if n_max > maxgridpoints:\n            logger.error(""Grid number is exceeding the max number of %d"", maxgridpoints)\n            exit()\n        #\n        self.n_max = n_max\n        dx = self.dx\n        material_property = self.material_property\n        alloy_property = self.alloy_property\n\n        cb_meff = np.zeros(n_max)  # conduction band effective mass\n        cb_meff_alpha = np.zeros(n_max)  # non-parabolicity constant.\n        F = np.zeros(n_max)  # ? (?)\n        Eg = np.zeros(n_max)  # bandgap energy (?)\n        delta_SO = np.zeros(n_max)  # spin-split off energy (?)\n        Ep = np.zeros(n_max)  # ? (?)\n        fi = np.zeros(n_max)  # Bandstructure potential\n        eps = np.zeros(n_max)  # dielectric constant\n        dop = np.zeros(n_max)  # doping\n\n        position = 0.0  # keeping in nanometres (to minimise errors)\n        for layer in self.material:\n            startindex = round2int(position * 1e-9 / dx)\n            position += layer[0]  # update position to end of the layer\n            finishindex = round2int(position * 1e-9 / dx)\n            #\n            matType = layer[1]\n\n            if matType in material_property:\n                matprops = material_property[matType]\n                fi[startindex:finishindex] = (\n                    matprops[""Band_offset""] * matprops[""Eg""] * q\n                )  # Joule\n                eps[startindex:finishindex] = matprops[""epsilonStatic""] * eps0\n                cb_meff[startindex:finishindex] = matprops[""m_e""] * m_e\n                if self.meff_method == 1:\n                    cb_meff_alpha[startindex:finishindex] = matprops[""m_e_alpha""]\n                elif self.meff_method == 2:\n                    F[startindex:finishindex] = matprops[""F""]\n                    Eg[startindex:finishindex] = matprops[""Eg""]  # eV\n                    delta_SO[startindex:finishindex] = matprops[""delta""]\n                    Ep[startindex:finishindex] = matprops[""Ep""]\n            elif matType in alloy_property:\n                alloyprops = alloy_property[matType]\n                mat1 = material_property[alloyprops[""Material1""]]\n                mat2 = material_property[alloyprops[""Material2""]]\n                x = layer[2]  # alloy ratio\n                fi[startindex:finishindex] = (\n                    alloyprops[""Band_offset""]\n                    * (\n                        x * mat1[""Eg""]\n                        + (1 - x) * mat2[""Eg""]\n                        - alloyprops[""Bowing_param""] * x * (1 - x)\n                    )\n                    * q\n                )  # for electron. Joule\n                eps[startindex:finishindex] = (\n                    x * mat1[""epsilonStatic""] + (1 - x) * mat2[""epsilonStatic""]\n                ) * eps0\n                cb_meff_alloy = x * mat1[""m_e""] + (1 - x) * mat2[""m_e""]\n                cb_meff[startindex:finishindex] = cb_meff_alloy * m_e\n                if self.meff_method == 1:\n                    cb_meff_alpha[startindex:finishindex] = alloyprops[""m_e_alpha""] * (\n                        mat2[""m_e""] / cb_meff_alloy\n                    )  # non-parabolicity constant for alloy. THIS CALCULATION IS MOSTLY WRONG. MUST BE CONTROLLED. SBL\n                elif self.meff_method == 2:\n                    F[startindex:finishindex] = x * mat1[""F""] + (1 - x) * mat2[""F""]\n                    Eg[startindex:finishindex] = (\n                        x * mat1[""Eg""]\n                        + (1 - x) * mat2[""Eg""]\n                        - alloyprops[""Bowing_param""] * x * (1 - x)\n                    )  # eV\n                    delta_SO[startindex:finishindex] = (\n                        x * mat1[""delta""]\n                        + (1 - x) * mat2[""delta""]\n                        - alloyprops[""delta_bowing_param""] * x * (1 - x)\n                    )\n                    Ep[startindex:finishindex] = x * mat1[""Ep""] + (1 - x) * mat2[""Ep""]\n            # doping\n            if layer[4] == ""n"":\n                chargedensity = (\n                    layer[3] * 1e6\n                )  # charge density in m**-3 (conversion from cm**-3)\n            elif layer[4] == ""p"":\n                chargedensity = (\n                    -layer[3] * 1e6\n                )  # charge density in m**-3 (conversion from cm**-3)\n            else:\n                chargedensity = 0.0\n            dop[startindex:finishindex] = chargedensity\n        self.fi = fi\n        self.eps = eps\n        self.dop = dop\n        self.cb_meff = cb_meff\n        if (\n            self.meff_method == 1\n        ):  # only define optional arrays if we think that we need them\n            self._cb_meff_alpha = cb_meff_alpha\n        elif self.meff_method == 2:\n            self.F = F\n            self.Eg = Eg\n            self.delta_SO = delta_SO\n            self.Ep = Ep\n        # return fi,cb_meff,eps,dop\n\n    def layer_mask(self, idx):\n        """"""Return a binary array selecting the layer within the structure.""""""\n        dx = self.dx\n        position = 0.0  # keeping in nanometres (to minimise errors)\n        for layer in self.material[: idx + 1]:\n            startindex = round2int(position * 1e-9 / dx)\n            position += layer[0]  # update position to end of the layer\n            finishindex = round2int(position * 1e-9 / dx)\n        mask = np.zeros(self.n_max, dtype=bool)\n        mask[startindex:finishindex] = True\n        return mask\n\n\n# DO NOT EDIT UNDER HERE FOR PARAMETERS\n# --------------------------------------\n\n# Vegard\'s law for alloys\ndef vegard(first, second, mole):\n    return first * mole + second * (1 - mole)\n\n\n# This function returns the value of the wavefunction (psi)\n# at +infinity for a given value of the energy.  The solution\n# to the energy occurs for psi(+infinity)=0.\n\n\n# FUNCTIONS for SHOOTING ------------------\n\n\ndef psi_at_inf(E, fis, cb_meff, n_max, dx):\n    """"""Shooting method for heterostructure as given in Harrison\'s book.\n    This works much faster on lists than on numpy arrays for some reason \n    (probably type-casting related).\n    E - energy (Joules)\n    fis - potential energy (J)\n    cb_meff - effective mass in conduction band (array)\n    model - instance of Structure class\n    n_max - number of points in arrays describing structure wrt z-axis\n    dx - step size of distance quantisation (metres)\n    """"""\n    fis = fis.tolist()  # lists are faster than numpy arrays for loops\n    cb_meff = cb_meff.tolist()  # lists are faster than numpy arrays for loops\n    c0 = 2 * (dx / hbar) ** 2\n    # boundary conditions\n    psi0 = 0.0\n    psi1 = 1.0\n    psi2 = None\n    for j in range(1, n_max - 1, 1):\n        # Last potential not used\n        c1 = 2.0 / (cb_meff[j] + cb_meff[j - 1])\n        c2 = 2.0 / (cb_meff[j] + cb_meff[j + 1])\n        psi2 = ((c0 * (fis[j] - E) + c2 + c1) * psi1 - c1 * psi0) / c2\n        psi0 = psi1\n        psi1 = psi2\n    return psi2\n\n\ndef psi_at_inf1(E, fis, model, n_max, dx):\n    """"""shooting method with parabolic dispersions (energy independent effective mass).\n    E - energy (Joules)\n    fis - potential energy (J)\n    cb_meff_f is a function that returns an array of effective mass at a given Energy E\n    model - instance of Structure\n    n_max - number of points in arrays describing structure wrt z-axis\n    dx - step size of distance quantisation (metres)\n    """"""\n    return psi_at_inf(E, fis, model.cb_meff, n_max, dx)\n\n\ndef psi_at_inf2(E, fis, model, n_max, dx):\n    """"""shooting method with non-parabolicity.\n    E - energy (Joules)\n    fis - potential energy (J)\n    cb_meff_f is a function that returns an array of effective mass at a given Energy E\n    model - instance of Structure\n    n_max - number of points in arrays describing structure wrt z-axis\n    dx - step size of distance quantisation (metres)\n    """"""\n    cb_meff = model.cb_meff_E(E, fis)  # energy dependent mass\n    return psi_at_inf(E, fis, cb_meff, n_max, dx)\n\n\ntry:\n    if (\n        __package__\n    ):  # explicit relative imports for using aestimo as a package (in python3)\n        from .psi_at_inf_cython import psi_at_inf_numpy\n    else:\n        from psi_at_inf_cython import psi_at_inf_numpy\n\n    def psi_at_inf1_cython(E, fis, model, n_max, dx):\n        return psi_at_inf_numpy(E, fis, model.cb_meff, n_max, dx)\n\n    def psi_at_inf2_cython(E, fis, model, n_max, dx):\n        """"""shooting method with non-parabolicity""""""\n        cb_meff_E = model.cb_meff_E(E, fis)  # energy dependent mass\n        return psi_at_inf_numpy(E, fis, cb_meff_E, n_max, dx)\n\n    logger.info(""using psi_at_inf_cython module"")\nexcept ImportError:\n    logger.warning(""psi_at_inf_cython module not found"")\n# nb. function was much slower when fi is a numpy array than a python list.\ndef calc_E_state(numlevels, fi, model, energyx0):  # delta_E,d_E\n    """"""Finds the Eigen-energies of any bound states of the chosen potential.\n    numlevels - number of levels to find\n    fi - Potential energy (Joules)\n    model - any object with attributes: \n        cb_meff - array of effective mass (len n_max)\n        n_max - length of arrays\n        dx - step size (metres)\n    energyx0 - minimum energy for starting subband search (Joules)""""""\n    # Shooting method parameters for Schr\xc3\xb6dinger Equation solution\n    delta_E = (\n        config.delta_E\n    )  # 0.5*meV2J #Energy step (Joules) for initial search. Initial delta_E is 1 meV.\n    d_E = (\n        config.d_E\n    )  # 1e-5*meV2J #Energy step (Joules) for Newton-Raphson method when improving the precision of the energy of a found level.\n    Estate_convergence_test = config.Estate_convergence_test  # 1e-9*meV2J\n    #\n    E_state = [0.0] * numlevels  # Energies of subbands (meV)\n    cb_meff = model.cb_meff  # effective mass of electrons in conduction band (kg)\n    energyx = float(\n        energyx0\n    )  # starting energy for subband search (Joules) + floats are faster than numpy.float64\n    n_max = model.n_max\n    dx = model.dx\n\n    # choose shooting function\n    if config.use_cython == True:\n        if model.comp_scheme in (1, 3, 6):  # then include non-parabolicity calculation\n            psi_at_inf = psi_at_inf2_cython\n        else:\n            psi_at_inf = psi_at_inf1_cython\n    else:\n        if model.comp_scheme in (1, 3, 6):  # then include non-parabolicity calculation\n            psi_at_inf = psi_at_inf2\n        else:\n            psi_at_inf = psi_at_inf1\n    # print \'energyx\', energyx,type(energyx)\n    # print \'cb_meff\', cb_meff[0:10], type(cb_meff), type(cb_meff[0])\n    # print \'n_max\', n_max, type(n_max)\n    # print \'fi\', fi[0:10], type(fi), type(fi[0])\n    # print \'dx\', dx, type(dx)\n    # exit()\n\n    for i in range(0, numlevels, 1):\n        # increment energy-search for f(x)=0\n        y2 = psi_at_inf(energyx, fi, model, n_max, dx)\n        while True:\n            y1 = y2\n            energyx += delta_E\n            y2 = psi_at_inf(energyx, fi, model, n_max, dx)\n            if y1 * y2 < 0:\n                break\n        # improve estimate using midpoint rule\n        energyx -= abs(y2) / (abs(y1) + abs(y2)) * delta_E\n        # implement Newton-Raphson method\n        while True:\n            y = psi_at_inf(energyx, fi, model, n_max, dx)\n            dy = (\n                psi_at_inf(energyx + d_E, fi, model, n_max, dx)\n                - psi_at_inf(energyx - d_E, fi, model, n_max, dx)\n            ) / (2.0 * d_E)\n            energyx -= y / dy\n            if abs(y / dy) < Estate_convergence_test:\n                break\n        E_state[i] = energyx * J2meV\n        # clears x from solution\n        energyx += delta_E  # finish for i-th state.\n    return E_state\n\n\n# FUNCTIONS for ENVELOPE FUNCTION WAVEFUNCTION--------------------------------\ndef wf(E, fis, model):\n    """"""This function returns the value of the wavefunction (psi)\n    at +infinity for a given value of the energy.  The solution\n    to the energy occurs for psi(+infinity)=0.\n    psi[3] wavefunction at z-delta_z, z and z+delta_z \n    i index\n    \n    E - eigen-energy of state (Joules)\n    fis - Potential energy of system (Joules)\n    model - an object with atributes:\n        cb_meff - array of effective mass (len n_max)\n        n_max - length of arrays\n        dx - step size (metres)""""""\n    # choosing effective mass function\n    if model.comp_scheme in (1, 3, 6):  # non-parabolicity calculation\n        cb_meff_E = model.cb_meff_E(E, fis).tolist()\n    else:\n        cb_meff_E = (\n            model.cb_meff.tolist()\n        )  # lists are faster than numpy arrays for loops\n    fis = fis.tolist()  # lists are faster than numpy arrays for loops\n    n_max = model.n_max\n    dx = model.dx\n    #\n    N = 0.0  # Normalization integral\n    psi = []\n    psi = [0.0] * 3\n    # boundary conditions\n    psi[0] = 0.0\n    psi[1] = 1.0\n    b = [0.0] * n_max\n    b[0] = psi[0]\n    b[1] = psi[1]\n    N += (psi[0]) ** 2\n    N += (psi[1]) ** 2\n    for j in range(1, n_max - 1, 1):\n        # Last potential not used\n        c1 = 2.0 / (cb_meff_E[j] + cb_meff_E[j - 1])\n        c2 = 2.0 / (cb_meff_E[j] + cb_meff_E[j + 1])\n        psi[2] = (\n            (2 * (dx / hbar) ** 2 * (fis[j] - E) + c2 + c1) * psi[1] - c1 * psi[0]\n        ) / c2\n        b[j + 1] = psi[2]\n        N += (psi[2]) ** 2\n        psi[0] = psi[1]\n        psi[1] = psi[2]\n    b2 = np.array(b)\n    b2 /= N ** 0.5\n    return b2  # units of dx**0.5\n\n\n# FUNCTIONS for FERMI-DIRAC STATISTICS---SIMPLE---------------------------------\ndef fd2(Ei, Ef, T):\n    """"""integral of Fermi Dirac Equation for energy independent density of states.\n    Ei [meV], Ef [meV], T [K]""""""\n    return kb * T * log(exp(meV2J * (Ef - Ei) / (kb * T)) + 1)\n\n\ndef calc_meff_state(wfe, cb_meff):\n    """"""find subband effective masses""""""\n    tmp = 1.0 / np.sum(wfe ** 2 / cb_meff, axis=1)\n    meff_state = tmp.tolist()\n    return meff_state  # kg\n\n\ndef calc_meff_state2(wfe, E_state, fi, model):\n    """"""find subband effective masses including non-parabolicity\n    (but stilling using a fixed effective mass for each subband dispersion)""""""\n    cb_meff_states = np.vstack([model.cb_meff_E(E * meV2J, fi) for E in E_state])\n    tmp = 1.0 / np.sum(wfe ** 2 / cb_meff_states, axis=1)\n    meff_state = tmp.tolist()\n    return meff_state  # kg\n\n\ndef fermilevel_0K(Ntotal2d, E_state, meff_state):\n    Et, Ef = 0.0, 0.0\n    for i, (Ei, csb_meff) in enumerate(zip(E_state, meff_state)):\n        Et += Ei\n        Efnew = (Ntotal2d * hbar ** 2 * pi / csb_meff * J2meV + Et) / (i + 1)\n        if Efnew > Ei:\n            Ef = Efnew\n        else:\n            break  # we have found Ef and so we should break out of the loop\n    else:  # exception clause for \'for\' loop.\n        logger.warning(\n            ""Have processed all energy levels present and so can\'t be sure that Ef is below next higher energy level.""\n        )\n    N_state = [0.0] * len(E_state)\n    for i, (Ei, csb_meff) in enumerate(zip(E_state, meff_state)):\n        Ni = (Ef - Ei) * csb_meff / (hbar ** 2 * pi) * meV2J  # populations of levels\n        Ni *= Ni > 0.0\n        N_state[i] = Ni\n    return (\n        Ef,\n        N_state,\n    )  # Fermi levels at 0K (meV), number of electrons in each subband at 0K\n\n\ndef fermilevel(Ntotal2d, T, E_state, meff_state):\n    """"""Finds the Fermi level (meV)""""""\n    # parameters\n    FD_d_E = (\n        config.FD_d_E\n    )  # 1e-9 Initial and minimum Energy step (meV) for derivative calculation for Newton-Raphson method to find E_F\n    FD_convergence_test = config.FD_convergence_test  # 1e-6\n\n    def func(Ef, E_state, meff_state, Ntotal2d, T):\n        # return Ntotal2d - sum( [csb_meff*fd2(Ei,Ef,T) for Ei,csb_meff in zip(E_state,meff_state)] )/(hbar**2*pi)\n        diff = Ntotal2d\n        for Ei, csb_meff in zip(E_state, meff_state):\n            diff -= csb_meff * fd2(Ei, Ef, T) / (hbar ** 2 * pi)\n        return diff\n\n    Ef_0K, N_states_0K = fermilevel_0K(Ntotal2d, E_state, meff_state)\n    # Ef=fsolve(func,Ef_0K,args=(E_state,meff_state,Ntotal2d,T))[0]\n    # return float(Ef)\n    # implement Newton-Raphson method\n    Ef = Ef_0K\n    d_E = FD_d_E  # Energy step (meV)\n    while True:\n        y = func(Ef, E_state, meff_state, Ntotal2d, T)\n        dy = (\n            func(Ef + d_E, E_state, meff_state, Ntotal2d, T)\n            - func(Ef - d_E, E_state, meff_state, Ntotal2d, T)\n        ) / (2.0 * d_E)\n        if (\n            dy == 0.0\n        ):  # increases interval size for derivative calculation in case of numerical error\n            d_E *= 2.0\n            continue  # goes back to start of loop, therefore d_E will increase until a non-zero derivative is found\n        Ef -= y / dy\n        if abs(y / dy) < FD_convergence_test:\n            break\n        # reduces the interval by a couple of notches ready for the next iteration\n        for i in range(2):\n            if d_E > FD_d_E:\n                d_E *= 0.5\n    return Ef  # (meV)\n\n\ndef calc_N_state(Ef, T, Ns, E_state, meff_state):\n    # Find the subband populations, taking advantage of step like d.o.s. and analytic integral of FD\n    N_state = [\n        fd2(Ei, Ef, T) * csb_meff / (hbar ** 2 * pi)\n        for Ei, csb_meff in zip(E_state, meff_state)\n    ]\n    return N_state  # number of carriers in each subband\n\n\n# FUNCTIONS for FERMI-DIRAC STATISTICS---NON-PARABOLIC--------------------------\n\n\ndef calc_meff_state3(wfe, cb_meff):\n    """"""find subband effective masses""""""\n    meff_states = 1.0 / np.sum(wfe ** 2 / cb_meff, axis=1)\n    return meff_states  # kg\n\n\ndef calc_dispersions(Emin, Emax, dE, wfe, E_state, fi, model):\n    """"""Calculate dispersion curves and their effective masses for each subband.""""""\n    output = []  # (Ea,cb_meff,k)\n    for Ei, wfi in zip(E_state, wfe):\n        Ea = np.arange(Ei, Emax, dE)  # meV\n        cb_meff_2darray = model.cb_meff_E(Ea[:, np.newaxis] * meV2J, fi)\n        cb_meff_a = calc_meff_state3(\n            wfi, cb_meff_2darray\n        )  # effective mass of dispersion wrt Ea\n        ka = np.sqrt(\n            2.0 / hbar ** 2 * meV2J * (Ea - Ei) * cb_meff_a\n        )  # k-space array wrt Ea\n        output.append((Ea, cb_meff_a, ka))\n    return output\n\n\ndef calc_N_state_np(Ef, T, level_dispersions):\n    """"""numerical integral of Fermi Dirac Equation for 2d density of states with \n    energy dependent effective mass\n    level_dispersions - list of tuples describing each level\'s dispersion. Each tuple\n    is (energy array, effective mass array, k-vector array). This is non-coincidently\n    the output of calc_dispersions.\n    function.\n    Ef - Fermi energy (meV)\n    T - Temperature (K).""""""\n    N_state = []\n    for Ea, cb_meff_a, ka in level_dispersions:  # treat level separately\n        Ea2 = Ea * meV2J\n        tmp = (\n            cb_meff_a / (pi * hbar ** 2) / (np.exp((Ea2 - meV2J * Ef) / (kb * T)) + 1.0)\n        )\n        N_state.append(np.trapz(tmp, x=Ea2))\n    return N_state\n\n\ndef fermilevel_np(Ntotal2d, T, wfe, E_state, fi, model):\n    """"""Finds the Fermi level (meV) for non-parabolic subbands""""""\n    # parameters\n    FD_d_E = (\n        config.FD_d_E\n    )  # 1e-9 Initial and minimum Energy step (meV) for derivative calculation for Newton-Raphson method to find E_F\n    FD_convergence_test = config.FD_convergence_test  # 1e-6\n    # level dispersions\n    level_dispersions = calc_dispersions(\n        Emin=0.0,\n        Emax=E_state[-1] + kb * T * J2meV,\n        dE=config.np_d_E,\n        wfe=wfe,\n        E_state=E_state,\n        fi=fi,\n        model=model,\n    )\n    # error function\n    def func(Ef, Ntotal2d, T, level_dispersions):\n        return Ntotal2d - sum(calc_N_state_np(Ef, T, level_dispersions))\n\n    # starting estimates\n    Ef_0K, N_states_0K = fermilevel_0K(\n        Ntotal2d, E_state, calc_meff_state2(wfe, E_state, fi, model)\n    )\n    # Ef=fsolve(func,Ef_0K,args=(E_state,meff_state,Ntotal2d,T))[0]\n    # return float(Ef)\n    # implement Newton-Raphson method\n    Ef = Ef_0K\n    d_E = FD_d_E  # Energy step (meV)\n    while True:\n        y = func(Ef, Ntotal2d, T, level_dispersions)\n        dy = (\n            func(Ef + d_E, Ntotal2d, T, level_dispersions)\n            - func(Ef - d_E, Ntotal2d, T, level_dispersions)\n        ) / (2.0 * d_E)\n        if (\n            dy == 0.0\n        ):  # increases interval size for derivative calculation in case of numerical error\n            d_E *= 2.0\n            continue  # goes back to start of loop, therefore d_E will increase until a non-zero derivative is found\n        Ef -= y / dy\n        if abs(y / dy) < FD_convergence_test:\n            break\n        # reduces the interval by a couple of notches ready for the next iteration\n        for i in range(2):\n            if d_E > FD_d_E:\n                d_E *= 0.5\n    return Ef  # (meV)\n\n\n# FUNCTIONS for SELF-CONSISTENT POISSON----------------------------------------\n\n\ndef calc_sigma(wfe, N_state, model):\n    """"""This function calculates `net\' areal charge density\n    n-type dopants lead to -ve charge representing electrons, and additionally \n    +ve ionised donors.""""""\n    # note: model.dop is still a volume density, the delta_x converts it to an areal density\n    sigma = model.dop * model.dx  # The charges due to the dopant ions\n    for j in range(\n        0, model.subnumber_e, 1\n    ):  # The charges due to the electrons in the subbands\n        sigma -= N_state[j] * (wfe[j]) ** 2\n    return sigma  # charge per m**2 per dz (units of electronic charge)\n\n\n##\ndef calc_field(sigma, eps):\n    """"""calculate electric field as a function of z-\n    sigma is a number density per unit area\n    eps is dielectric constant""""""\n    # i index over z co-ordinates\n    # j index over z\' co-ordinates\n    # Note:\n    F0 = -np.sum(q * sigma) / (2.0)  # CMP\'deki i ve j yer de\xc4\x9fi\xc5\x9febilir - de + olabilir\n    # is the above necessary since the total field due to the structure should be zero.\n    # Do running integral\n    tmp = (\n        np.hstack(([0.0], sigma[:-1])) + sigma\n    )  # using trapezium rule for integration (?).\n    tmp *= (\n        q / 2.0\n    )  # Note: sigma is a number density per unit area, needs to be converted to Couloumb per unit area\n    tmp[0] = F0\n    F = np.cumsum(tmp) / eps\n    return F  # electric field\n\n\ndef calc_field_convolve(sigma, eps):\n    tmp = np.ones(len(sigma) - 1)\n    signstep = np.hstack((-tmp, [0.0], tmp))  # step function\n    F = np.convolve(signstep, sigma, mode=""valid"")\n    F *= q / (2.0 * eps)\n    return F\n\n\ndef calc_field_old(sigma, eps):\n    """"""calculate F electric field as a function of z-\n    sigma is a number density per unit area,\n    eps is dielectric constant""""""\n    # i index over z co-ordinates\n    # j index over z\' co-ordinates\n    n_max = len(sigma)\n    # For wave function initialise F\n    F = np.zeros(n_max)\n    for i in range(0, n_max, 1):\n        for j in range(0, n_max, 1):\n            # Note sigma is a number density per unit area, needs to be converted to Couloumb per unit area\n            F[i] = F[i] + q * sigma[j] * cmp(i, j) / (\n                2 * eps[i]\n            )  # CMP\'deki i ve j yer de\xc4\x9fi\xc5\x9febilir - de + olabilir\n    return F\n\n\ndef calc_potn(F, dx):\n    """"""This function calculates the potential (energy actually)""""""\n    # V electric field as a function of z-\n    # i\tindex over z co-ordinates\n\n    # Calculate the potential, defining the first point as zero\n    tmp = q * F * dx\n    V = np.cumsum(tmp)  # +q -> electron -q->hole?\n    return V\n\n\ndef calc_periodic_potn(V, eps, dx):\n    """"""Alters a potential so that it is periodic across the structure.\n    V - potential (array)\n    eps - dielectric constant (array)\n    dx - step size (nm)""""""\n    pseudoz = np.cumsum(dx / eps)\n    return V[-1] / pseudoz[-1] * pseudoz\n\n\n# FUNCTIONS FOR EXCHANGE INTERACTION-------------------------------------------\n\n\ndef calc_Vxc(sigma, dop, eps, cb_meff, dx):\n    """"""An effective field describing the exchange-interactions between the electrons\n    derived from Kohn-Sham density functional theory. This formula is given in many\n    papers, for example see Gunnarsson and Lundquist (1976), Ando, Taniyama, Ohtani \n    et al. (2003), or Ch.1 in the book \'Intersubband transitions in quantum wells\' (edited\n    by Liu and Capasso) by M. Helm.\n    eps = dielectric constant array\n    cb_meff = effective mass array\n    sigma = charge carriers per m**2, however this includes the donor atoms and we are only\n            interested in the electron density.""""""\n    a_B = 4 * pi * hbar ** 2 / q ** 2  # Bohr radius.\n    nz = -(sigma - dop * dx)  # electron density per m**2\n    nz_3 = nz ** (1 / 3.0)  # cube root of charge density.\n    # a_B_eff = eps/cb_meff*a_B #effective Bohr radius\n    # r_s occasionally suffers from division by zero errors due to nz=0.\n    # We will fix these by setting nz_3 = 1.0 for these points (a tiny charge in per m**2).\n    nz_3 = nz_3.clip(1.0, max(nz_3))\n\n    r_s = 1.0 / (\n        (4 * pi / 3.0) ** (1 / 3.0) * nz_3 * eps / cb_meff * a_B\n    )  # average distance between charges in units of effective Bohr radis.\n    # A = q**4/(32*pi**2*hbar**2)*(9*pi/4.0)**(1/3.)*2/pi*(4*pi/3.0)**(1/3.)*4*pi*hbar**2/q**2 #constant factor for expression.\n    A = (\n        q ** 2 / (4 * pi) * (3 / pi) ** (1 / 3.0)\n    )  # simplified constant factor for expression.\n    #\n    Vxc = -A * nz_3 / eps * (1.0 + 0.0545 * r_s * np.log(1.0 + 11.4 / r_s))\n    return Vxc\n\n\n# -----------------------------------------------------------------------------\n\n\ndef Poisson_Schrodinger(model):\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an instance of the Structure class or an object with the following attributes:\n      fi - float - Bandstructure potential (J) (array, len n_max)\n      cb_meff - float - conduction band effective mass (kg)(array, len n_max)\n      eps - float - dielectric constant (including eps0) (array, len n_max)\n      dop - float - doping distribution (m**-3) ( array, len n_max)\n      Fapp - float - Applied field (Vm**-1)\n      T - float - Temperature (K)\n      comp_scheme - int - simulation scheme\n      subnumber_e - int - number of subbands for look for in the conduction band\n      dx - float - grid spacing (m)\n      n_max - int - number of points.\n    """"""\n    fi = model.fi\n    cb_meff = (\n        model.cb_meff\n    )  # effective mass at band edge (effective mass with non-parabolicity is model.cb_meff_E(E,fi))\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n\n    # parameters\n    E_start = (\n        config.E_start\n    )  # 0.0 #Energy to start shooting method from (if E_start = 0.0 uses minimum of energy of bandstructure)\n    # Poisson Loop\n    damping = (\n        config.damping\n    )  # 0.5 #averaging factor between iterations to smooth convergence.\n    max_iterations = config.max_iterations  # 80 #maximum number of iterations.\n    convergence_test = (\n        config.convergence_test\n    )  # 1e-6 #convergence is reached when the ground state energy (meV) is stable to within this number between iterations.\n\n    # Check\n    if comp_scheme == 6:\n        scheme6warning = """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        logger.warning(scheme6warning)\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_e  # Number of carriers in subbands\n\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    # sigma = np.zeros(n_max)            #charge distribution (donors + free charges)\n    # F = np.zeros(n_max)                #Electric Field\n    # Vapp = np.zeros(n_max)             #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for electron list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n    wfe = np.zeros((subnumber_e, n_max))\n\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    Vapp = calc_potn(Fapp * eps0 / eps, dx)\n    Vapp -= Vapp[\n        n_max // 2\n    ]  # Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # This allows us to vary the applied voltage without changing the energy range within which we search for states.\n\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    previousE0 = 0  # (meV) energy of zeroth state for previous iteration(for testing convergence)\n    fitot = fi + Vapp  # For initial iteration sum bandstructure and applied field\n\n    fi_min = min(\n        fitot\n    )  # minimum potential energy of structure (for limiting the energy range when searching for states)\n    if (\n        abs(E_start) > 1e-3 * meV2J\n    ):  # energyx is the minimum energy (meV) when starting the search for bound states.\n        energyx = E_start\n    else:\n        energyx = fi_min\n    while True:\n        if not (config.messagesoff):\n            logger.info(""Iteration: %d"", iteration)\n        if iteration > 1:\n            energyx = min(fi_min, min(fitot),)\n        E_state = calc_E_state(subnumber_e, fitot, model, energyx)\n\n        # Envelope Function Wave Functions\n        # print \'wf\'\n        for j in range(0, subnumber_e, 1):\n            if not (config.messagesoff):\n                logger.info(""Working for subband no: %d"", (j + 1))\n            wfe[j] = wf(E_state[j] * meV2J, fitot, model)  # wavefunction units dx**0.5\n        # Calculate the effective mass of each subband\n        # print \'calc_meff_state\'\n        if model.comp_scheme in (1, 3, 6):  # include non-parabolicity in calculation\n            meff_state = calc_meff_state2(wfe, E_state, fitot, model)\n        else:\n            meff_state = calc_meff_state(wfe, cb_meff)\n        ## Self-consistent Poisson\n\n        # Calculate the Fermi energy and subband populations at 0K\n        # E_F_0K,N_state_0K=fermilevel_0K(Ntotal2d,E_state,meff_state)\n        # Calculate the Fermi energy at the temperature T (K)\n        if (\n            model.comp_scheme in (1, 3, 6) and model.fermi_np_scheme == True\n        ):  # include non-parabolicity in calculation\n            # print \'fermilevel\'\n            E_F = fermilevel_np(Ntotal2d, T, wfe, E_state, fi, model)\n            # Calculate the subband populations at the temperature T (K)\n            # print \'calc_N_state\'\n            Emin_np = 0.0\n            Emax_np = E_state[-1] + kb * T * J2meV\n            dE_np = config.np_d_E\n            level_dispersions = calc_dispersions(\n                Emin_np, Emax_np, dE_np, wfe, E_state, fi, model\n            )\n            N_state = calc_N_state_np(E_F, T, level_dispersions)\n        else:\n            level_dispersions = None\n            # print \'fermilevel\'\n            E_F = fermilevel(Ntotal2d, T, E_state, meff_state)\n            # Calculate the subband populations at the temperature T (K)\n            # print \'calc_N_state\'\n            N_state = calc_N_state(E_F, T, Ntotal2d, E_state, meff_state)\n        # Calculate `net\' areal charge density\n        # print \'calc_sigma\'\n        sigma = calc_sigma(wfe, N_state, model)  # one more instead of subnumber_e\n        # Calculate electric field (Poisson/Hartree Effects)\n        if comp_scheme != 4:  # in (0,1,2,3,5,6):\n            # Calculate electric field\n            F = calc_field(sigma, eps)\n            # Calculate potential due to charge distribution\n            Vnew = calc_potn(F, dx)\n            # Adjust potential to be periodic\n            if model.boundary_scheme == 1:\n                Vnew -= calc_periodic_potn(Vnew, eps, dx)\n        else:\n            F = np.zeros(n_max)\n            Vnew = 0\n        # Exchange interaction\n        if comp_scheme in (4, 5, 6):\n            # Exchange Potential\n            Vnew += calc_Vxc(sigma, dop, eps, cb_meff, dx)\n        #\n        # status\n        if not (config.messagesoff):\n            for i, level in enumerate(E_state):\n                logger.info(""E[%d]= %f meV"", i, level)\n            for i, meff in enumerate(meff_state):\n                logger.info(""meff[%d]= %f"", i, meff / m_e)\n            for i, Ni in enumerate(N_state):\n                logger.info(""N[%d]= %g m**-2"", i, Ni)\n            # print \'Efermi (at 0K) = \',E_F_0K,\' meV\'\n            # for i,Ni in enumerate(N_state_0K):\n            #    print \'N[\',i,\']= \',Ni\n            logger.info(""Efermi (at %gK) = %g meV"", T, E_F)\n            logger.info(""total donor charge = %g m**-2"", sum(dop) * dx)\n            logger.info(""total level charge = %g m**-2"", sum(N_state))\n            logger.info(""total system charge = %g m**-2"", sum(sigma))\n        #\n        if comp_scheme in (0, 1):\n            # if we are not self-consistently including Poisson Effects then only do one loop\n            break\n        # Combine band edge potential with potential due to charge distribution\n        # To increase convergence, we calculate a moving average of electric potential\n        # with previous iterations. By dampening the corrective term, we avoid oscillations.\n        V += damping * (Vnew - V)\n        fitot = fi + V + Vapp\n\n        if abs(E_state[0] - previousE0) < convergence_test:  # Convergence test\n            break\n        elif iteration >= max_iterations:  # Iteration limit\n            logger.warning(""Have reached maximum number of iterations"")\n            break\n        else:\n            iteration += 1\n            previousE0 = E_state[0]\n    # END OF SELF-CONSISTENT LOOP\n    time3 = time.time()  # timing audit\n    logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n\n    results.xaxis = xaxis\n    results.wfe = wfe\n    results.fitot = fitot\n    results.sigma = sigma\n    results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    results.meff_state = meff_state\n    results.Fapp = Fapp\n    results.T = T\n    results.E_F = E_F\n    results.dx = dx\n    results.subnumber_e = subnumber_e\n    results.level_dispersions = level_dispersions\n\n    return results\n\n\ndef save_and_plot(result, model):\n    xaxis = result.xaxis\n\n    output_directory = config.output_directory\n    output_directory = os.path.join(examplesdir, output_directory)\n\n    if not os.path.isdir(output_directory):\n        os.makedirs(output_directory)\n\n    def saveoutput(fname, datatuple, header=""""):\n        fname2 = os.path.join(output_directory, fname)\n        np.savetxt(\n            fname2, np.column_stack(datatuple), fmt=""%.6e"", delimiter="" "", header=header\n        )\n\n    def saveoutput2(fname2, datatuple, header="""", fmt=""%.6g"", delimiter="", ""):\n        fname2 = os.path.join(output_directory, fname2)\n        np.savetxt(\n            fname2,\n            np.column_stack(datatuple),\n            fmt=fmt,\n            delimiter=delimiter,\n            header=header,\n        )\n\n    if config.parameters:\n        saveoutput2(\n            ""parameters.dat"",\n            header=(""T (K), Fapp (V/m), E_F (meV)""),\n            datatuple=(result.T, result.Fapp, result.E_F),\n        )\n    if config.sigma_out:\n        saveoutput(""sigma.dat"", (xaxis, result.sigma))\n    if config.electricfield_out:\n        saveoutput(""efield.dat"", (xaxis, result.F))\n    if config.potential_out:\n        saveoutput(""potn.dat"", (xaxis, result.fitot))\n    if config.states_out:\n        rel_meff_state = [\n            meff / m_e for meff in result.meff_state\n        ]  # going to report relative effective mass.\n        columns = (\n            range(model.subnumber_e),\n            result.E_state,\n            result.N_state,\n            rel_meff_state,\n        )\n        # header = "" "".join([col.ljust(12) for col in (""State No."",""Energy (meV)"",""N (m**-2)"",""Subband m* (m_e)"")])\n        header = ""State No.    Energy (meV) N (m**-2)    Subband m* (kg)""\n        saveoutput(""states.dat"", columns, header=header)\n    if config.probability_out:\n        saveoutput(""wavefunctions.dat"", (xaxis, result.wfe.transpose()))\n    # Resultviewer\n\n    if config.resultviewer:\n        fig1 = pl.figure()\n        pl.suptitle(""Aestimo Results"")\n        pl.subplots_adjust(hspace=0.4, wspace=0.4)\n\n        # Plotting Sigma\n        # figure(0)\n        pl.subplot(2, 2, 1)\n        pl.plot(xaxis, result.sigma)\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Sigma (e/m^2)"")\n        pl.title(""Sigma"")\n        pl.grid(True)\n\n        # Plotting Efield\n        # figure(1)\n        pl.subplot(2, 2, 2)\n        pl.plot(xaxis, result.F)\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Electric Field strength (V/m)"")\n        pl.title(""Electric Field"")\n        pl.grid(True)\n\n        # Plotting Potential\n        # figure(2)\n        pl.subplot(2, 2, 3)\n        pl.plot(xaxis, result.fitot)\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""E_c (J)"")\n        pl.title(""Potential"")\n        pl.grid(True)\n\n        # Plotting State(s)\n        # figure(3)\n        pl.subplot(2, 2, 4)\n        for j, state in enumerate(result.wfe):\n            pl.plot(xaxis, state, label=""state %d"" % j)\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Psi"")\n        pl.title(""First state"")\n        pl.grid(True)\n\n        # QW representation\n        # figure(5)\n        fig2 = pl.figure()\n        pl.suptitle(""Aestimo Results"")\n        pl.subplot(1, 1, 1)\n        pl.plot(xaxis, result.fitot * J2meV, ""k"")\n        for level, state in zip(result.E_state, result.wfe):\n            pl.axhline(level, 0.1, 0.9, color=""g"", ls=""--"")\n            pl.plot(xaxis, state * config.wavefunction_scalefactor + level, ""b"")\n            # pl.plot(xaxis, state**2*1e-9/dx*200.0+level,\'b\')\n        pl.axhline(result.E_F, 0.1, 0.9, color=""r"", ls=""--"")\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Energy (meV)"")\n        pl.grid(True)\n\n        # dispersion plot\n        fig3 = pl.figure()\n        pl.suptitle(""Subband Dispersions"")\n        ax = pl.subplot(1, 1, 1)\n        result.level_dispersions\n        cb_meff0 = result.meff_state[0]  # kg\n        ka = np.linspace(\n            0.0, np.sqrt(2.0 * cb_meff0 * result.fitot.ptp()) / hbar, 50\n        )  # m**-1\n        kax = ka * 1e-9\n        for Ei, meffi in zip(result.E_state, result.meff_state):\n            (p1,) = pl.plot(kax, Ei + J2meV * hbar ** 2 * ka ** 2 / (2 * cb_meff0), ""k"")\n            (p2,) = pl.plot(kax, Ei + J2meV * hbar ** 2 * ka ** 2 / (2 * meffi), ""b"")\n        if result.level_dispersions:\n            for Ea, cb_meff_a, ka in result.level_dispersions:\n                (p3,) = pl.plot(ka * 1e-9, Ea, ""g"")\n            ax.legend(\n                [p1, p2, p3],\n                [\n                    ""parabolic dispersions"",\n                    ""parabolic dispersion (subband meff)"",\n                    ""non-parabolic dispersions"",\n                ],\n            )\n        else:\n            ax.legend(\n                [p1, p2],\n                [""parabolic dispersions"", ""parabolic dispersion (subband meff)""],\n            )\n        pl.axhline(result.E_F, 0.0, 1.0, color=""r"", ls=""--"")\n        pl.xlabel(""k-space (nm**-1)"")\n        pl.ylabel(""Energy (meV)"")\n        pl.grid(True)\n\n        pl.show()\n    return [fig1, fig2, fig3]\n\n\ndef QWplot(result, figno=None):\n    """"""QW representation""""""\n    xaxis = result.xaxis\n    fig = pl.figure(figno)\n    pl.suptitle(""Aestimo Results"")\n    ax = pl.subplot(1, 1, 1)\n    ax.plot(xaxis, result.fitot * J2meV, ""k"")\n    for level, state in zip(result.E_state, result.wfe):\n        ax.axhline(level, 0.1, 0.9, color=""g"", ls=""--"")\n        ax.plot(xaxis, state * config.wavefunction_scalefactor + level, ""b"")\n        # pl.plot(xaxis, state**2*1e-9/dx*200.0+level,\'b\')\n    ax.axhline(result.E_F, 0.1, 0.9, color=""r"", ls=""--"")\n    pl.xlabel(""Position (m)"")\n    pl.ylabel(""Energy (meV)"")\n    ax.grid(True)\n    pl.show()\n    return fig\n\n\ndef dispersionplot(result, figno=None):\n    """"""subband dispersion plot""""""\n    fig = pl.figure(figno)\n    pl.suptitle(""Subband Dispersions"")\n    ax = pl.subplot(1, 1, 1)\n    result.level_dispersions\n    cb_meff0 = result.meff_state[0]  # kg\n    kmax = np.sqrt(2.0 * cb_meff0 * result.fitot.ptp() * meV2J) / hbar\n    ka = np.linspace(0.0, kmax, 50)  # m**-1\n    kax = ka * 1e-9\n    for Ei, meffi in zip(result.E_state, result.meff_state):\n        (p1,) = ax.plot(kax, Ei + J2meV * hbar ** 2 * ka ** 2 / (2 * cb_meff0), ""k"")\n        (p2,) = ax.plot(kax, Ei + J2meV * hbar ** 2 * ka ** 2 / (2 * meffi), ""b"")\n    if result.level_dispersions:\n        for Ea, cb_meff_a, ka in result.level_dispersions:\n            (p3,) = ax.plot(ka * 1e-9, Ea, ""g"")\n        ax.legend(\n            [p1, p2, p3],\n            [\n                ""parabolic dispersions"",\n                ""parabolic dispersion (subband meff)"",\n                ""non-parabolic dispersions"",\n            ],\n        )\n    else:\n        ax.legend(\n            [p1, p2], [""parabolic dispersions"", ""parabolic dispersion (subband meff)""]\n        )\n    ax.axhline(result.E_F, 0.0, 1.0, color=""r"", ls=""--"")\n    pl.xlabel(""k-space (nm**-1)"")\n    pl.ylabel(""Energy (meV)"")\n    ax.grid(True)\n    pl.show()\n    return fig\n\n\ndef load_results():\n    """"""Loads the data stored in the output folder""""""\n\n    class Results:\n        pass\n\n    results = Results()\n\n    output_directory = config.output_directory\n\n    def loadoutput(fname, header=False, unpack=True):\n        fname2 = os.path.join(output_directory, fname)\n        skiprows = 1 if header else 0\n        data = np.loadtxt(fname2, delimiter="" "", unpack=unpack, skiprows=skiprows)\n        return data\n\n    if config.parameters:\n        results.T, results.Fapp, results.E_F = np.loadtxt(\n            open(os.path.join(output_directory, ""parameters.dat""), ""rb""),\n            unpack=True,\n            delimiter="","",\n            skiprows=1,\n        )\n    if config.sigma_out:\n        (results.xaxis, results.sigma) = loadoutput(""sigma.dat"")\n    if config.electricfield_out:\n        (results.xaxis, results.F) = loadoutput(""efield.dat"")\n    if config.potential_out:\n        (results.xaxis, results.fitot) = loadoutput(""potn.dat"")\n    if config.states_out:\n        (states, results.E_state, results.N_state, rel_meff_state) = loadoutput(\n            ""states.dat"", header=True\n        )\n        results.subnumber_e = max(states)\n        results.meff_state = rel_meff_state * m_e\n    if config.probability_out:\n        _wfe = loadoutput(""wavefunctions.dat"", unpack=False)\n        results.xaxis = _wfe[:, 0]\n        results.wfe = _wfe[:, 1:].transpose()\n    # missing variables\n    # results.V\n    results.dx = np.mean(results.xaxis[1:] - results.xaxis[:-1])\n    # results.level_dispersions = level_dispersions\n\n    return results\n\n\ndef run_aestimo(input_obj):\n    """"""A utility function that performs the standard simulation run\n    for \'normal\' input files. Input_obj can be a dict, class, named tuple or \n    module with the attributes needed to create the StructureFrom class, see \n    the class implementation or some of the sample-*.py files for details.""""""\n    logger.info(""Aestimo is starting..."")\n\n    # Initialise structure class\n    model = StructureFrom(input_obj, database)\n\n    # Perform the calculation\n    result = Poisson_Schrodinger(model)\n\n    time4 = time.time()  # timing audit\n    logger.info(""total running time (inc. loading libraries) %g s"", (time4 - time0))\n    logger.info(""total running time (exc. loading libraries) %g s"", (time4 - time1))\n\n    # Write the simulation results in files\n    save_and_plot(result, model)\n\n    logger.info(\n        """"""Simulation is finished. All files are closed. Please control the related files.\n-----------------------------------------------------------------""""""\n    )\n\n    return input_obj, model, result\n\n\nif __name__ == ""__main__"":\n    import optparse\n\n    parser = optparse.OptionParser()\n    parser.add_option(\n        ""-i"",\n        ""--inputfile"",\n        action=""store"",\n        dest=""inputfile"",\n        default=config.inputfilename,\n        help=""chose input file to override default in config.py"",\n    )\n    (options, args) = parser.parse_args()\n\n    # Import from config file\n    inputfile = __import__(options.inputfile)\n    logger.info(""inputfile is %s"", options.inputfile)\n\n    run_aestimo(inputfile)\n'"
aestimo_dd_lib_setup.py,0,"b'from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\nimport numpy\n\nEXT_MODULES = [Extension(""aestimo_dd_lib"", [""aestimo_dd_lib.pyx""])]\nsetup(\n    name = \'aestimo_dd_lib\' ,\n    cmdclass = {\'build_ext\': build_ext},\n    ext_modules = EXT_MODULES,\n    include_dirs=[numpy.get_include()]\n)'"
aestimo_eh.py,447,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""This is the 3x3 k.p aestimo calculator for valence band calculations \n   (Numpy version, there is no classic version for valence band calculations).\n\nIt can be used similarly to the aestimo.py module. aestimo_eh.py can be used as \na script or a library.\n\nTo use as a script, define the simulation in a python file. See the following \nsample files for examples on usage and the required parameters:\n    sample-qw-barrierdope-p.py\n    sample-qw-barrierdope-p_cdzno.py\n    sample-qw-barrierdope-p_ingran.py\n    sample-multi-qw-barrierdope-p.py\n    sample-multi-qw-barrierdope-p_ingran.py   \nand then run aestimo on the command line as\n  ./aestimo.py -i <input file>\nSince we are abusing the python module system, the input \'file\' needs to be \nimportable by the aestimo script. Alternatively, define the input file in the\nconfig module using the inputfilename parameter.\n\nTo use aestimo_eh.py as a library, first create an instance of the StructureFrom\nclass which builds the arrays describing a structure from the same input \nparameters that are found in the sample files. A simple list format is used to \ndescribes the structure\'s layers.\n""""""\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2020 Aestimo Group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n""""""\n__version__ = ""2.0.2""\nimport time\n\ntime0 = time.time()  # timing audit\n# from scipy.optimize import fsolve\nimport matplotlib.pyplot as pl\nimport numpy as np\nfrom math import log, exp, sqrt\nfrom scipy import linalg\n\nalen = np.alen\nimport os,sys\n\n#importing examples directory\nexamplesdir = os.path.abspath(os.path.join(os.path.dirname(__file__), \'examples\'))\nsys.path.append(examplesdir)\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import VBHM\n    from .VBHM import qsv, VBMAT1, VBMAT2, VBMAT_V, CBMAT, CBMAT_V, VBMAT_V_2\n    from . import config, database\n    from .aestimo_poisson1d import (\n        Poisson_equi2,\n        equi_np_fi,\n        Write_results_equi2,\n        equi_np_fi2,\n        equi_np_fi3,\n        Poisson_non_equi3,\n        Poisson_equi_non_2,\n        equi_np_fi22,\n        equi_np_fi222,\n    )\n    from .aestimo_poisson1d import (\n        Poisson_equi1,\n        Mobility2,\n        Continuity2,\n        Mobility3,\n        Continuity3,\n        Poisson_non_equi2,\n        Current2,\n        Write_results_non_equi2,\n        Write_results_equi1,\n        amort_wave,\n    )\n    from . import DDGgummelmap\n    from .DDGgummelmap import DDGgummelmap\n    from . import DDNnewtonmap\n    from .DDNnewtonmap import DDNnewtonmap\n    from . import func_lib\n    from .func_lib import Ubernoulli\n    from . import DDGnlpoisson\n    from .DDGnlpoisson import DDGnlpoisson_new\nelse:\n    import VBHM\n    from VBHM import qsv, VBMAT1, VBMAT2, VBMAT_V, CBMAT, CBMAT_V, VBMAT_V_2\n    import config, database\n    from aestimo_poisson1d import (\n        Poisson_equi2,\n        equi_np_fi,\n        Write_results_equi2,\n        equi_np_fi2,\n        equi_np_fi3,\n        Poisson_non_equi3,\n        Poisson_equi_non_2,\n        equi_np_fi22,\n        equi_np_fi222,\n    )\n    from aestimo_poisson1d import (\n        Poisson_equi1,\n        Mobility2,\n        Continuity2,\n        Mobility3,\n        Continuity3,\n        Poisson_non_equi2,\n        Current2,\n        Write_results_non_equi2,\n        Write_results_equi1,\n        amort_wave,\n    )\n    import DDGgummelmap\n    from DDGgummelmap import DDGgummelmap\n    import DDNnewtonmap\n    from DDNnewtonmap import DDNnewtonmap\n    import func_lib\n    from func_lib import Ubernoulli\n    import DDGnlpoisson\n    from DDGnlpoisson import DDGnlpoisson_new\n\n# --------------------------------------\nimport logging\n\nlogger = logging.getLogger(""aestimo"")\noutput_directory = config.output_directory + ""_eh""\n\nif not os.path.isdir(os.path.abspath(os.path.join(examplesdir, output_directory))):\n    os.makedirs(os.path.abspath(os.path.join(examplesdir, output_directory)))\n\nhdlr = logging.FileHandler(os.path.abspath(os.path.join(examplesdir, os.path.join(output_directory,config.logfile))))\nformatter = logging.Formatter(""%(asctime)s %(levelname)s %(name)s %(message)s"")\nhdlr.setFormatter(formatter)\nlogger.addHandler(hdlr)\n# stderr\nch = logging.StreamHandler()\nformatter2 = logging.Formatter(""%(levelname)s %(message)s"")\nch.setFormatter(formatter2)\nlogger.addHandler(ch)\n# LOG level can be INFO, WARNING, ERROR\nlogger.setLevel(logging.INFO)\nif not (config.messagesoff):\n    os.sys.stderr.write(\n        ""WARNING aestimo_eh logs automatically to aestimo.log in the example\'s directory.\\n""\n    )\n# --------------------------------------\n\n# Defining constants and material parameters\nq = 1.602176e-19  # C\nkb = 1.3806504e-23  # J/K\nhbar = 1.054588757e-34  # Js\nm_e = 9.1093826e-31  # kg\npi = np.pi\neps0 = 8.8541878176e-12  # F/m\n# TEMPERATURE\nT = 300.0  # Kelvin\nVt = kb * T / q  # [eV]\nJ2meV = 1e3 / q  # Joules to meV\nmeV2J = 1e-3 * q  # meV to Joules\n\ntime1 = time.time()  # timing audit\n# logger.info(""Aestimo is starting..."")\n# Input Class\n# -------------------------------------\n\n\ndef round2int(x):\n    """"""int is sensitive to floating point numerical errors near whole numbers,\n    this moves the discontinuity to the half interval. It is also equivalent\n    to the normal rules for rounding positive numbers.""""""\n    # int(x + (x>0) -0.5) # round2int for positive and negative numbers\n    return int(x + 0.5)\n\n\ndef vegard1(first, second, mole):\n    return first * mole + second * (1 - mole)\n\n\nclass Structure:\n    def __init__(self, database, **kwargs):\n        """"""This class holds details on the structure to be simulated.\n        database is the module containing the material properties. Then\n        this class should have the following attributes set\n        Fapp - applied field (Vm**-1)\n        T - Temperature (K)\n        subnumber_e - number of subbands to look for.\n        comp_scheme - computing scheme\n        dx - grid step size (m)\n        n_max - number of grid points\n        \n        cb_meff #conduction band effective mass (kg) (array, len n_max)\n        cb_meff_alpha #non-parabolicity constant.\n        fi #Bandstructure potential (J) (array, len n_max)\n        eps #dielectric constant (including eps0) (array, len n_max)\n        dop #doping distribution (m**-3) (array, len n_max)\n        \n        These last 4 can be created by using the method \n        create_structure_arrays(material_list)\n        """"""\n        # setting any parameters provided with initialisation\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n        # Loading materials database\n        self.material_property = database.materialproperty\n        totalmaterial = alen(self.material_property)\n\n        self.alloy_property = database.alloyproperty\n        totalalloy = alen(self.alloy_property)\n\n        self.alloy_property_4 = database.alloyproperty4\n        totalalloy += alen(self.alloy_property_4)\n\n        logger.info(\n            ""Total material number in database: %d"", (totalmaterial + totalalloy)\n        )\n\n    def create_structure_arrays(self):\n        """""" initialise arrays/lists for structure""""""\n        # self.N_wells_real0=sum(sum(np.char.count(self.material,\'w\')))\n        self.N_wells_real0 = sum(\n            np.char.count([layer[6] for layer in self.material], ""w"")\n        )\n        self.N_layers_real0 = len(\n            self.material\n        )  # sum(np.char.count([layer[6] for layer in self.material],\'w\'))+sum(np.char.count([layer[6] for layer in self.material],\'b\'))\n\n        # Calculate the required number of grid points\n        self.x_max = (\n            sum([layer[0] for layer in self.material]) * 1e-9\n        )  # total thickness (m)\n        n_max = round2int(self.x_max / self.dx)\n        # Check on n_max\n        maxgridpoints = self.maxgridpoints\n        mat_crys_strc = self.mat_crys_strc\n        if n_max > maxgridpoints:\n            logger.error(""Grid number is exceeding the max number of %d"", maxgridpoints)\n            exit()\n        #\n        self.n_max = n_max\n        dx = self.dx\n        material_property = self.material_property\n        alloy_property = self.alloy_property\n        alloy_property_4 = self.alloy_property_4\n        cb_meff = np.zeros(n_max)  # conduction band effective mass\n        cb_meff_alpha = np.zeros(n_max)  # non-parabolicity constant.\n        m_hh = np.zeros(n_max)\n        m_lh = np.zeros(n_max)\n        m_so = np.zeros(n_max)\n        # Elastic constants C11,C12\n        C12 = np.zeros(n_max)\n        C11 = np.zeros(n_max)\n        # Elastic constants Wurtzite C13,C33\n        C13 = np.zeros(n_max)\n        C33 = np.zeros(n_max)\n        C44 = np.zeros(n_max)\n        # Spontaneous and Piezoelectric Polarizations constants D15,D13,D33 and Psp\n        D15 = np.zeros(n_max)\n        D31 = np.zeros(n_max)\n        D33 = np.zeros(n_max)\n        Psp = np.zeros(n_max)\n        # Luttinger Parameters \xce\xb31,\xce\xb32,\xce\xb33\n        GA3 = np.zeros(n_max)\n        GA2 = np.zeros(n_max)\n        GA1 = np.zeros(n_max)\n        # Hole eff. mass parameter  Wurtzite Semiconductors\n        A1 = np.zeros(n_max)\n        A2 = np.zeros(n_max)\n        A3 = np.zeros(n_max)\n        A4 = np.zeros(n_max)\n        A5 = np.zeros(n_max)\n        A6 = np.zeros(n_max)\n        # Lattice constant a0\n        a0 = np.zeros(n_max)\n        a0_wz = np.zeros(n_max)\n        a0_sub = np.zeros(n_max)\n        #  Deformation potentials ac,av,b\n        Ac = np.zeros(n_max)\n        Av = np.zeros(n_max)\n        B = np.zeros(n_max)\n        # Deformation potentials Wurtzite Semiconductors\n        D1 = np.zeros(n_max)\n        D2 = np.zeros(n_max)\n        D3 = np.zeros(n_max)\n        D4 = np.zeros(n_max)\n        delta = np.zeros(n_max)  # delta splitt off\n        delta_so = np.zeros(n_max)  # delta Spin\xe2\x80\x93orbit split energy\n        delta_cr = np.zeros(n_max)  # delta Crystal-field split energy\n        # Strain related\n        fi_h = np.zeros(n_max)  # Bandstructure potential\n        fi_e = np.zeros(n_max)  # Bandstructure potential\n        eps = np.zeros(n_max)  # dielectric constant\n        dop = np.zeros(n_max)  # doping\n        pol_surf_char = np.zeros(n_max)\n        N_wells_real = 0\n        N_wells_real2 = 0\n        N_layers_real2 = 0\n        N_wells_real0 = self.N_wells_real0\n        N_layers_real0 = self.N_layers_real0\n        N_wells_virtual = N_wells_real0 + 2\n        N_wells_virtual2 = N_wells_real0 + 2\n        N_layers_virtual = N_layers_real0 + 2\n        Well_boundary = np.zeros((N_wells_virtual, 2), dtype=int)\n        Well_boundary2 = np.zeros((N_wells_virtual, 2), dtype=int)\n        barrier_boundary = np.zeros((N_wells_virtual + 1, 2), dtype=int)\n        layer_boundary = np.zeros((N_layers_virtual, 2), dtype=int)\n        n_max_general = np.zeros(N_wells_virtual, dtype=int)\n        Well_boundary[N_wells_virtual - 1, 0] = n_max - 1\n        Well_boundary[N_wells_virtual - 1, 1] = n_max - 1\n        Well_boundary2[N_wells_virtual - 1, 0] = n_max - 1\n        Well_boundary2[N_wells_virtual - 1, 1] = n_max - 1\n        barrier_boundary[N_wells_virtual, 0] = n_max - 1\n        barrier_len = np.zeros(N_wells_virtual + 1)\n        n = np.zeros(n_max)\n        p = np.zeros(n_max)\n        TAUN0 = np.zeros(n_max)\n        TAUP0 = np.zeros(n_max)\n        mun0 = np.zeros(n_max)\n        mup0 = np.zeros(n_max)\n\n        Cn0 = np.zeros(n_max)\n        Cp0 = np.zeros(n_max)\n        BETAN = np.zeros(n_max)\n        BETAP = np.zeros(n_max)\n        VSATN = np.zeros(n_max)\n        VSATP = np.zeros(n_max)\n        position = 0.0  # keeping in nanometres (to minimise errors)\n        for layer in self.material:\n            startindex = round2int(position * 1e-9 / dx)\n            z0 = round2int(position * 1e-9 / dx)\n            position += layer[0]  # update position to end of the layer\n            finishindex = round2int(position * 1e-9 / dx)\n            z1 = round2int(position * 1e-9 / dx)\n            #\n            matType = layer[1]\n            if matType in material_property:\n                matprops = material_property[matType]\n                cb_meff[startindex:finishindex] = matprops[""m_e""] * m_e\n                cb_meff_alpha[startindex:finishindex] = matprops[""m_e_alpha""]\n                fi_e[startindex:finishindex] = (\n                    matprops[""Band_offset""] * matprops[""Eg""] * q\n                )  # Joule\n                if mat_crys_strc == ""Zincblende"":\n                    a0_sub[startindex:finishindex] = matprops[""a0""] * 1e-10\n                    C11[startindex:finishindex] = matprops[""C11""] * 1e10\n                    C12[startindex:finishindex] = matprops[""C12""] * 1e10\n                    GA1[startindex:finishindex] = matprops[""GA1""]\n                    GA2[startindex:finishindex] = matprops[""GA2""]\n                    GA3[startindex:finishindex] = matprops[""GA3""]\n                    Ac[startindex:finishindex] = matprops[""Ac""] * q\n                    Av[startindex:finishindex] = matprops[""Av""] * q\n                    B[startindex:finishindex] = matprops[""B""] * q\n                    delta[startindex:finishindex] = matprops[""delta""] * q\n                    fi_h[startindex:finishindex] = (\n                        -(1 - matprops[""Band_offset""]) * matprops[""Eg""] * q\n                    )  # Joule  #-0.8*q-(1-matprops[\'Band_offset\'])*matprops[\'Eg\']*q #Joule\n                    eps[startindex:finishindex] = matprops[""epsilonStatic""] * eps0\n                    a0[startindex:finishindex] = matprops[""a0""] * 1e-10\n                    TAUN0[startindex:finishindex] = matprops[""TAUN0""]\n                    TAUP0[startindex:finishindex] = matprops[""TAUP0""]\n                    mun0[startindex:finishindex] = matprops[""mun0""]\n                    mup0[startindex:finishindex] = matprops[""mup0""]\n\n                    Cn0[startindex:finishindex] = matprops[""Cn0""] * 1e-12\n                    Cp0[startindex:finishindex] = matprops[""Cp0""] * 1e-12\n                    BETAN[startindex:finishindex] = matprops[""BETAN""]\n                    BETAP[startindex:finishindex] = matprops[""BETAP""]\n                    VSATN[startindex:finishindex] = matprops[""VSATN""]\n                    VSATP[startindex:finishindex] = matprops[""VSATP""]\n                if mat_crys_strc == ""Wurtzite"":\n                    a0_sub[startindex:finishindex] = matprops[""a0_sub""] * 1e-10\n                    C11[startindex:finishindex] = matprops[""C11""] * 1e10\n                    C12[startindex:finishindex] = matprops[""C12""] * 1e10\n                    C13[startindex:finishindex] = matprops[""C13""] * 1e10\n                    C33[startindex:finishindex] = matprops[""C33""] * 1e10\n                    A1[startindex:finishindex] = matprops[""A1""]\n                    A2[startindex:finishindex] = matprops[""A2""]\n                    A3[startindex:finishindex] = matprops[""A3""]\n                    A4[startindex:finishindex] = matprops[""A4""]\n                    A5[startindex:finishindex] = matprops[""A5""]\n                    A6[startindex:finishindex] = matprops[""A6""]\n                    Ac[startindex:finishindex] = matprops[""Ac""] * q\n                    D1[startindex:finishindex] = matprops[""D1""] * q\n                    D2[startindex:finishindex] = matprops[""D2""] * q\n                    D3[startindex:finishindex] = matprops[""D3""] * q\n                    D4[startindex:finishindex] = matprops[""D4""] * q\n                    D31[startindex:finishindex] = matprops[""D31""]\n                    D33[startindex:finishindex] = matprops[""D33""]\n                    a0_wz[startindex:finishindex] = matprops[""a0_wz""] * 1e-10\n                    delta_so[startindex:finishindex] = matprops[""delta_so""] * q\n                    delta_cr[startindex:finishindex] = matprops[""delta_cr""] * q\n                    eps[startindex:finishindex] = matprops[""epsilonStatic""] * eps0\n                    fi_h[startindex:finishindex] = (\n                        -(1 - matprops[""Band_offset""]) * matprops[""Eg""] * q\n                    )\n                    Psp[startindex:finishindex] = matprops[""Psp""]\n                    TAUN0[startindex:finishindex] = matprops[""TAUN0""]\n                    TAUP0[startindex:finishindex] = matprops[""TAUP0""]\n                    mun0[startindex:finishindex] = matprops[""mun0""]\n                    mup0[startindex:finishindex] = matprops[""mup0""]\n\n                    Cn0[startindex:finishindex] = matprops[""Cn0""] * 1e-12\n                    Cp0[startindex:finishindex] = matprops[""Cp0""] * 1e-12\n                    BETAN[startindex:finishindex] = matprops[""BETAN""]\n                    BETAP[startindex:finishindex] = matprops[""BETAP""]\n                    VSATN[startindex:finishindex] = matprops[""VSATN""]\n                    VSATP[startindex:finishindex] = matprops[""VSATP""]\n            elif matType in alloy_property:\n                alloyprops = alloy_property[matType]\n                mat1 = material_property[alloyprops[""Material1""]]\n                mat2 = material_property[alloyprops[""Material2""]]\n                x = layer[2]  # alloy ratio\n                cb_meff_alloy = x * mat1[""m_e""] + (1 - x) * mat2[""m_e""]\n                cb_meff[startindex:finishindex] = cb_meff_alloy * m_e\n                Eg = (\n                    x * mat1[""Eg""]\n                    + (1 - x) * mat2[""Eg""]\n                    - alloyprops[""Bowing_param""] * x * (1 - x)\n                )  # eV\n                fi_e[startindex:finishindex] = (\n                    alloyprops[""Band_offset""] * Eg * q\n                )  # for electron. Joule\n                a0_sub[startindex:finishindex] = alloyprops[""a0_sub""] * 1e-10\n                TAUN0[startindex:finishindex] = alloyprops[""TAUN0""]\n                TAUP0[startindex:finishindex] = alloyprops[""TAUP0""]\n\n                BETAN[startindex:finishindex] = alloyprops[""BETAN""]\n                BETAP[startindex:finishindex] = alloyprops[""BETAP""]\n                VSATN[startindex:finishindex] = alloyprops[""VSATN""]\n                VSATP[startindex:finishindex] = alloyprops[""VSATP""]\n                if mat_crys_strc == ""Zincblende"":\n                    C11[startindex:finishindex] = (\n                        x * mat1[""C11""] + (1 - x) * mat2[""C11""]\n                    ) * 1e10\n                    C12[startindex:finishindex] = (\n                        x * mat1[""C12""] + (1 - x) * mat2[""C12""]\n                    ) * 1e10\n                    GA1[startindex:finishindex] = (\n                        x * mat1[""GA1""] + (1 - x) * mat2[""GA1""]\n                    )\n                    GA2[startindex:finishindex] = (\n                        x * mat1[""GA2""] + (1 - x) * mat2[""GA2""]\n                    )\n                    GA3[startindex:finishindex] = (\n                        x * mat1[""GA3""] + (1 - x) * mat2[""GA3""]\n                    )\n                    Ac_alloy = x * mat1[""Ac""] + (1 - x) * mat2[""Ac""]\n                    Ac[startindex:finishindex] = Ac_alloy * q\n                    Av_alloy = x * mat1[""Av""] + (1 - x) * mat2[""Av""]\n                    Av[startindex:finishindex] = Av_alloy * q\n                    B_alloy = x * mat1[""B""] + (1 - x) * mat2[""B""]\n                    B[startindex:finishindex] = B_alloy * q\n                    delta_alloy = x * mat1[""delta""] + (1 - x) * mat2[""delta""]\n                    delta[startindex:finishindex] = delta_alloy * q\n                    fi_h[startindex:finishindex] = (\n                        -(1 - alloyprops[""Band_offset""]) * Eg * q\n                    )  # -(-1.33*(1-x)-0.8*x)for electron. Joule-1.97793434e-20 #\n                    eps[startindex:finishindex] = (\n                        x * mat1[""epsilonStatic""] + (1 - x) * mat2[""epsilonStatic""]\n                    ) * eps0\n                    a0[startindex:finishindex] = (\n                        (1 - x) * mat1[""a0""] + x * mat2[""a0""]\n                    ) * 1e-10\n                    cb_meff_alpha[startindex:finishindex] = alloyprops[""m_e_alpha""] * (\n                        mat2[""m_e""] / cb_meff_alloy\n                    )  # non-parabolicity constant for alloy. THIS CALCULATION IS MOSTLY WRONG. MUST BE CONTROLLED. SBL\n\n                    mun0[startindex:finishindex] = (\n                        x * mat1[""mun0""] + (1 - x) * mat2[""mun0""]\n                    )\n                    mup0[startindex:finishindex] = (\n                        x * mat1[""mup0""] + (1 - x) * mat2[""mup0""]\n                    )\n\n                    Cn0[startindex:finishindex] = (\n                        x * mat1[""Cn0""] + (1 - x) * mat2[""Cn0""]\n                    ) * 1e-12\n                    Cp0[startindex:finishindex] = (\n                        x * mat1[""Cp0""] + (1 - x) * mat2[""Cp0""]\n                    ) * 1e-12\n                if mat_crys_strc == ""Wurtzite"":\n                    # A1[startindex:finishindex] =vegard1(mat1[\'A1\'],mat1[\'A1\'],x)\n                    A1[startindex:finishindex] = x * mat1[""A1""] + (1 - x) * mat2[""A1""]\n                    A2[startindex:finishindex] = x * mat1[""A2""] + (1 - x) * mat2[""A2""]\n                    A3[startindex:finishindex] = x * mat1[""A3""] + (1 - x) * mat2[""A3""]\n                    A4[startindex:finishindex] = x * mat1[""A4""] + (1 - x) * mat2[""A4""]\n                    A5[startindex:finishindex] = x * mat1[""A5""] + (1 - x) * mat2[""A5""]\n                    A6[startindex:finishindex] = x * mat1[""A6""] + (1 - x) * mat2[""A6""]\n                    D1[startindex:finishindex] = (\n                        x * mat1[""D1""] + (1 - x) * mat2[""D1""]\n                    ) * q\n                    D2[startindex:finishindex] = (\n                        x * mat1[""D2""] + (1 - x) * mat2[""D2""]\n                    ) * q\n                    D3[startindex:finishindex] = (\n                        x * mat1[""D3""] + (1 - x) * mat2[""D3""]\n                    ) * q\n                    D4[startindex:finishindex] = (\n                        x * mat1[""D4""] + (1 - x) * mat2[""D4""]\n                    ) * q\n                    C13[startindex:finishindex] = (\n                        x * mat1[""C13""] + (1 - x) * mat2[""C13""]\n                    ) * 1e10  # for newton/meter\xc2\xb2\n                    C33[startindex:finishindex] = (\n                        x * mat1[""C33""] + (1 - x) * mat2[""C33""]\n                    ) * 1e10\n                    D31[startindex:finishindex] = (\n                        x * mat1[""D31""] + (1 - x) * mat2[""D31""]\n                    )\n                    D33[startindex:finishindex] = (\n                        x * mat1[""D33""] + (1 - x) * mat2[""D33""]\n                    )\n                    Psp[startindex:finishindex] = (\n                        x * mat1[""Psp""] + (1 - x) * mat2[""Psp""]\n                    )\n                    C11[startindex:finishindex] = (\n                        x * mat1[""C11""] + (1 - x) * mat2[""C11""]\n                    ) * 1e10\n                    C12[startindex:finishindex] = (\n                        x * mat1[""C12""] + (1 - x) * mat2[""C12""]\n                    ) * 1e10\n                    a0_wz[startindex:finishindex] = (\n                        x * mat1[""a0_wz""] + (1 - x) * mat2[""a0_wz""]\n                    ) * 1e-10\n                    eps[startindex:finishindex] = (\n                        x * mat1[""epsilonStatic""] + (1 - x) * mat2[""epsilonStatic""]\n                    ) * eps0\n                    fi_h[startindex:finishindex] = (\n                        -(1 - alloyprops[""Band_offset""]) * Eg * q\n                    )\n                    delta_so[startindex:finishindex] = (\n                        x * mat1[""delta_so""] + (1 - x) * mat2[""delta_so""]\n                    ) * q\n                    delta_cr[startindex:finishindex] = (\n                        x * mat1[""delta_cr""] + (1 - x) * mat2[""delta_cr""]\n                    ) * q\n                    Ac_alloy = x * mat1[""Ac""] + (1 - x) * mat2[""Ac""]\n                    Ac[startindex:finishindex] = Ac_alloy * q\n                    mun0[startindex:finishindex] = (\n                        x * mat1[""mun0""] + (1 - x) * mat2[""mun0""]\n                    )\n                    mup0[startindex:finishindex] = (\n                        x * mat1[""mup0""] + (1 - x) * mat2[""mup0""]\n                    )\n\n                    Cn0[startindex:finishindex] = (\n                        x * mat1[""Cn0""] + (1 - x) * mat2[""Cn0""]\n                    ) * 1e-12\n                    Cp0[startindex:finishindex] = (\n                        x * mat1[""Cp0""] + (1 - x) * mat2[""Cp0""]\n                    ) * 1e-12\n                    #############################################\n            elif matType in alloy_property_4:\n                alloyprops = alloy_property_4[matType]\n                TAUN0[startindex:finishindex] = alloyprops[""TAUN0""]\n                TAUP0[startindex:finishindex] = alloyprops[""TAUP0""]\n                BETAN[startindex:finishindex] = alloyprops[""BETAN""]\n                BETAP[startindex:finishindex] = alloyprops[""BETAP""]\n                VSATN[startindex:finishindex] = alloyprops[""VSATN""]\n                VSATP[startindex:finishindex] = alloyprops[""VSATP""]\n                if mat_crys_strc == ""Zincblende"":\n\n                    alloyprops = alloy_property_4[matType]\n                    mat1 = material_property[alloyprops[""Material1""]]\n                    mat2 = material_property[alloyprops[""Material2""]]\n                    mat3 = material_property[alloyprops[""Material3""]]\n                    mat4 = material_property[alloyprops[""Material4""]]\n                    # mat1:InAs\n                    # mat2:GaAs\n                    # mat3:InP\n                    # mat4:GaP\n                    # This is accourding to interpolated Vegard\xe2\x80\x99s law for quaternary AxB(1-x)CyD(1-y)=InxGa(1-x)AsyP(1-y)\n                    x = layer[2]  # alloy ratio x\n                    y = layer[3]  # alloy ratio y\n                    cb_meff_alloy_ABC_x = x * mat1[""m_e""] + (1 - x) * mat2[""m_e""]\n                    cb_meff_alloy_ABD_x = x * mat3[""m_e""] + (1 - x) * mat4[""m_e""]\n                    cb_meff_alloy_ACD_y = y * mat1[""m_e""] + (1 - y) * mat3[""m_e""]\n                    cb_meff_alloy_BCD_y = y * mat2[""m_e""] + (1 - y) * mat4[""m_e""]\n                    cb_meff_alloy = (\n                        x\n                        * (1 - x)\n                        * (y * cb_meff_alloy_ABC_x + (1 - y) * cb_meff_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * cb_meff_alloy_ACD_y + (1 - x) * cb_meff_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    cb_meff[startindex:finishindex] = cb_meff_alloy * m_e\n\n                    Eg_alloy_ABC_x = (\n                        x * mat1[""Eg""]\n                        + (1 - x) * mat2[""Eg""]\n                        - alloyprops[""Bowing_param_ABC""] * x * (1 - x)\n                    )  # eV InGaAs\n                    Eg_alloy_ABD_x = (\n                        x * mat3[""Eg""]\n                        + (1 - x) * mat4[""Eg""]\n                        - alloyprops[""Bowing_param_ABD""] * x * (1 - x)\n                    )  # eV InGaP\n                    Eg_alloy_ACD_y = (\n                        y * mat1[""Eg""]\n                        + (1 - y) * mat3[""Eg""]\n                        - alloyprops[""Bowing_param_ACD""] * y * (1 - y)\n                    )  # eV InAsP\n                    Eg_alloy_BCD_y = (\n                        y * mat2[""Eg""]\n                        + (1 - y) * mat4[""Eg""]\n                        - alloyprops[""Bowing_param_BCD""] * y * (1 - y)\n                    )  # eV GaAsP\n                    Eg = (\n                        x * (1 - x) * (y * Eg_alloy_ABC_x + (1 - y) * Eg_alloy_ABD_x)\n                        + y * (1 - y) * (x * Eg_alloy_ACD_y + (1 - x) * Eg_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    fi_e[startindex:finishindex] = (\n                        alloyprops[""Band_offset""] * Eg * q\n                    )  # for electron. Joule\n                    a0_sub[startindex:finishindex] = alloyprops[""a0_sub""] * 1e-10\n                    C11_alloy_ABC_x = x * mat1[""C11""] + (1 - x) * mat2[""C11""]\n                    C11_alloy_ABD_x = x * mat3[""C11""] + (1 - x) * mat4[""C11""]\n                    C11_alloy_ACD_y = y * mat1[""C11""] + (1 - y) * mat3[""C11""]\n                    C11_alloy_BCD_y = y * mat2[""C11""] + (1 - y) * mat4[""C11""]\n                    C11[startindex:finishindex] = (\n                        (\n                            x\n                            * (1 - x)\n                            * (y * C11_alloy_ABC_x + (1 - y) * C11_alloy_ABD_x)\n                            + y\n                            * (1 - y)\n                            * (x * C11_alloy_ACD_y + (1 - x) * C11_alloy_BCD_y)\n                        )\n                        / (x * (1 - x) + y * (1 - y))\n                    ) * 1e10\n\n                    C12_alloy_ABC_x = x * mat1[""C12""] + (1 - x) * mat2[""C12""]\n                    C12_alloy_ABD_x = x * mat3[""C12""] + (1 - x) * mat4[""C12""]\n                    C12_alloy_ACD_y = y * mat1[""C12""] + (1 - y) * mat3[""C12""]\n                    C12_alloy_BCD_y = y * mat2[""C12""] + (1 - y) * mat4[""C12""]\n                    C12[startindex:finishindex] = (\n                        (\n                            x\n                            * (1 - x)\n                            * (y * C12_alloy_ABC_x + (1 - y) * C12_alloy_ABD_x)\n                            + y\n                            * (1 - y)\n                            * (x * C12_alloy_ACD_y + (1 - x) * C12_alloy_BCD_y)\n                        )\n                        / (x * (1 - x) + y * (1 - y))\n                    ) * 1e10\n\n                    GA1_alloy_ABC_x = x * mat1[""GA1""] + (1 - x) * mat2[""GA1""]\n                    GA1_alloy_ABD_x = x * mat3[""GA1""] + (1 - x) * mat4[""GA1""]\n                    GA1_alloy_ACD_y = y * mat1[""GA1""] + (1 - y) * mat3[""GA1""]\n                    GA1_alloy_BCD_y = y * mat2[""GA1""] + (1 - y) * mat4[""GA1""]\n                    GA1[startindex:finishindex] = (\n                        x * (1 - x) * (y * GA1_alloy_ABC_x + (1 - y) * GA1_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * GA1_alloy_ACD_y + (1 - x) * GA1_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    GA2_alloy_ABC_x = x * mat1[""GA2""] + (1 - x) * mat2[""GA2""]\n                    GA2_alloy_ABD_x = x * mat3[""GA2""] + (1 - x) * mat4[""GA2""]\n                    GA2_alloy_ACD_y = y * mat1[""GA2""] + (1 - y) * mat3[""GA2""]\n                    GA2_alloy_BCD_y = y * mat2[""GA2""] + (1 - y) * mat4[""GA2""]\n                    GA2[startindex:finishindex] = (\n                        x * (1 - x) * (y * GA2_alloy_ABC_x + (1 - y) * GA2_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * GA2_alloy_ACD_y + (1 - x) * GA2_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    GA3_alloy_ABC_x = x * mat1[""GA3""] + (1 - x) * mat2[""GA3""]\n                    GA3_alloy_ABD_x = x * mat3[""GA3""] + (1 - x) * mat4[""GA3""]\n                    GA3_alloy_ACD_y = y * mat1[""GA3""] + (1 - y) * mat3[""GA3""]\n                    GA3_alloy_BCD_y = y * mat2[""GA3""] + (1 - y) * mat4[""GA3""]\n                    GA3[startindex:finishindex] = (\n                        x * (1 - x) * (y * GA3_alloy_ABC_x + (1 - y) * GA3_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * GA3_alloy_ACD_y + (1 - x) * GA3_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    Ac_alloy_ABC_x = x * mat1[""Ac""] + (1 - x) * mat2[""Ac""]\n                    Ac_alloy_ABD_x = x * mat3[""Ac""] + (1 - x) * mat4[""Ac""]\n                    Ac_alloy_ACD_y = y * mat1[""Ac""] + (1 - y) * mat3[""Ac""]\n                    Ac_alloy_BCD_y = y * mat2[""Ac""] + (1 - y) * mat4[""Ac""]\n                    Ac_alloy = (\n                        x * (1 - x) * (y * Ac_alloy_ABC_x + (1 - y) * Ac_alloy_ABD_x)\n                        + y * (1 - y) * (x * Ac_alloy_ACD_y + (1 - x) * Ac_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    Ac[startindex:finishindex] = Ac_alloy * q\n\n                    Av_alloy_ABC_x = x * mat1[""Av""] + (1 - x) * mat2[""Av""]\n                    Av_alloy_ABD_x = x * mat3[""Av""] + (1 - x) * mat4[""Av""]\n                    Av_alloy_ACD_y = y * mat1[""Av""] + (1 - y) * mat3[""Av""]\n                    Av_alloy_BCD_y = y * mat2[""Av""] + (1 - y) * mat4[""Av""]\n                    Av_alloy = (\n                        x * (1 - x) * (y * Av_alloy_ABC_x + (1 - y) * Av_alloy_ABD_x)\n                        + y * (1 - y) * (x * Av_alloy_ACD_y + (1 - x) * Av_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    Av[startindex:finishindex] = Av_alloy * q\n\n                    B_alloy_ABC_x = x * mat1[""B""] + (1 - x) * mat2[""B""]\n                    B_alloy_ABD_x = x * mat3[""B""] + (1 - x) * mat4[""B""]\n                    B_alloy_ACD_y = y * mat1[""B""] + (1 - y) * mat3[""B""]\n                    B_alloy_BCD_y = y * mat2[""B""] + (1 - y) * mat4[""B""]\n                    B_alloy = (\n                        x * (1 - x) * (y * B_alloy_ABC_x + (1 - y) * B_alloy_ABD_x)\n                        + y * (1 - y) * (x * B_alloy_ACD_y + (1 - x) * B_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    B[startindex:finishindex] = B_alloy * q\n\n                    delta_alloy_ABC_x = x * mat1[""delta""] + (1 - x) * mat2[""delta""]\n                    delta_alloy_ABD_x = x * mat3[""delta""] + (1 - x) * mat4[""delta""]\n                    delta_alloy_ACD_y = y * mat1[""delta""] + (1 - y) * mat3[""delta""]\n                    delta_alloy_BCD_y = y * mat2[""delta""] + (1 - y) * mat4[""delta""]\n                    delta_alloy = (\n                        x\n                        * (1 - x)\n                        * (y * delta_alloy_ABC_x + (1 - y) * delta_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * delta_alloy_ACD_y + (1 - x) * delta_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    delta[startindex:finishindex] = delta_alloy * q\n\n                    fi_h[startindex:finishindex] = (\n                        -(1 - alloyprops[""Band_offset""]) * Eg * q\n                    )  # -(-1.33*(1-x)-0.8*x)for electron. Joule-1.97793434e-20 #\n\n                    eps_alloy_ABC_x = (\n                        x * mat1[""epsilonStatic""] + (1 - x) * mat2[""epsilonStatic""]\n                    )\n                    eps_alloy_ABD_x = (\n                        x * mat3[""epsilonStatic""] + (1 - x) * mat4[""epsilonStatic""]\n                    )\n                    eps_alloy_ACD_y = (\n                        y * mat1[""epsilonStatic""] + (1 - y) * mat3[""epsilonStatic""]\n                    )\n                    eps_alloy_BCD_y = (\n                        y * mat2[""epsilonStatic""] + (1 - y) * mat4[""epsilonStatic""]\n                    )\n                    eps_alloy = (\n                        x * (1 - x) * (y * eps_alloy_ABC_x + (1 - y) * eps_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * eps_alloy_ACD_y + (1 - x) * eps_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    eps[startindex:finishindex] = eps_alloy * eps0\n\n                    a0_alloy_ABC_x = x * mat1[""a0""] + (1 - x) * mat2[""a0""]\n                    a0_alloy_ABD_x = x * mat3[""a0""] + (1 - x) * mat4[""a0""]\n                    a0_alloy_ACD_y = y * mat1[""a0""] + (1 - y) * mat3[""a0""]\n                    a0_alloy_BCD_y = y * mat2[""a0""] + (1 - y) * mat4[""a0""]\n                    a0_alloy = (\n                        x * (1 - x) * (y * a0_alloy_ABC_x + (1 - y) * a0_alloy_ABD_x)\n                        + y * (1 - y) * (x * a0_alloy_ACD_y + (1 - x) * a0_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n                    a0[startindex:finishindex] = a0_alloy * 1e-10\n\n                    mun0_alloy_ABC_x = x * mat1[""mun0""] + (1 - x) * mat2[""mun0""]\n                    mun0_alloy_ABD_x = x * mat3[""mun0""] + (1 - x) * mat4[""mun0""]\n                    mun0_alloy_ACD_y = y * mat1[""mun0""] + (1 - y) * mat3[""mun0""]\n                    mun0_alloy_BCD_y = y * mat2[""mun0""] + (1 - y) * mat4[""mun0""]\n                    mun0[startindex:finishindex] = (\n                        x\n                        * (1 - x)\n                        * (y * mun0_alloy_ABC_x + (1 - y) * mun0_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * mun0_alloy_ACD_y + (1 - x) * mun0_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    mup0_alloy_ABC_x = x * mat1[""mup0""] + (1 - x) * mat2[""mup0""]\n                    mup0_alloy_ABD_x = x * mat3[""mup0""] + (1 - x) * mat4[""mup0""]\n                    mup0_alloy_ACD_y = y * mat1[""mup0""] + (1 - y) * mat3[""mup0""]\n                    mup0_alloy_BCD_y = y * mat2[""mup0""] + (1 - y) * mat4[""mup0""]\n                    mup0[startindex:finishindex] = (\n                        x\n                        * (1 - x)\n                        * (y * mup0_alloy_ABC_x + (1 - y) * mup0_alloy_ABD_x)\n                        + y\n                        * (1 - y)\n                        * (x * mup0_alloy_ACD_y + (1 - x) * mup0_alloy_BCD_y)\n                    ) / (x * (1 - x) + y * (1 - y))\n\n                    Cn0_alloy_ABC_x = x * mat1[""Cn0""] + (1 - x) * mat2[""Cn0""]\n                    Cn0_alloy_ABD_x = x * mat3[""Cn0""] + (1 - x) * mat4[""Cn0""]\n                    Cn0_alloy_ACD_y = y * mat1[""Cn0""] + (1 - y) * mat3[""Cn0""]\n                    Cn0_alloy_BCD_y = y * mat2[""Cn0""] + (1 - y) * mat4[""Cn0""]\n                    Cn0[startindex:finishindex] = (\n                        (\n                            x\n                            * (1 - x)\n                            * (y * Cn0_alloy_ABC_x + (1 - y) * Cn0_alloy_ABD_x)\n                            + y\n                            * (1 - y)\n                            * (x * Cn0_alloy_ACD_y + (1 - x) * Cn0_alloy_BCD_y)\n                        )\n                        / (x * (1 - x) + y * (1 - y))\n                        * 1e-12\n                    )\n\n                    Cp0_alloy_ABC_x = x * mat1[""Cp0""] + (1 - x) * mat2[""Cp0""]\n                    Cp0_alloy_ABD_x = x * mat3[""Cp0""] + (1 - x) * mat4[""Cp0""]\n                    Cp0_alloy_ACD_y = y * mat1[""Cp0""] + (1 - y) * mat3[""Cp0""]\n                    Cp0_alloy_BCD_y = y * mat2[""Cp0""] + (1 - y) * mat4[""Cp0""]\n                    Cp0[startindex:finishindex] = (\n                        (\n                            x\n                            * (1 - x)\n                            * (y * Cp0_alloy_ABC_x + (1 - y) * Cp0_alloy_ABD_x)\n                            + y\n                            * (1 - y)\n                            * (x * Cp0_alloy_ACD_y + (1 - x) * Cp0_alloy_BCD_y)\n                        )\n                        / (x * (1 - x) + y * (1 - y))\n                        * 1e-12\n                    )\n\n                    cb_meff_alpha[startindex:finishindex] = alloyprops[""m_e_alpha""] * (\n                        mat2[""m_e""] / cb_meff_alloy\n                    )  # non-parabolicity constant for alloy. THIS CALCULATION IS MOSTLY WRONG. MUST BE CONTROLLED. SBL\n                if mat_crys_strc == ""Wurtzite"":\n                    alloyprops = alloy_property_4[matType]\n                    mat1 = material_property[alloyprops[""Material1""]]  # GaN\n                    mat2 = material_property[alloyprops[""Material2""]]  # InN\n                    mat3 = material_property[alloyprops[""Material3""]]  # AlN\n                    # This is accourding to interpolated Vegard\xe2\x80\x99s law for quaternary BxCyD1-x-yA=AlxInyGa1-x-yN\n                    """"""\n                        I. Vurgaftman, J.R. Meyer, L.R. RamMohan, J. Appl. Phys. 89 (2001) 5815.\n                        C. K. Williams, T. H. Glisson, J. R. Hauser, and M. A. Littlejohn, J. Electron. Mater. 7, 639 (1978).                       \n                        """"""\n                    x = layer[2]  # alloy ratio x\n                    y = layer[3]  # alloy ratio y\n                    u_4 = (1 - x + y) / 2\n                    v_4 = (2 - x - 2 * y) / 2\n                    w_4 = (2 - 2 * x - y) / 2\n                    cb_meff_alloy_ABC = (\n                        u_4 * mat2[""m_e""] + (1 - u_4) * mat3[""m_e""]\n                    )  # AlInN\n                    cb_meff_alloy_ACD = (\n                        v_4 * mat1[""m_e""] + (1 - v_4) * mat2[""m_e""]\n                    )  # InGaN\n                    cb_meff_alloy_ABD = (\n                        w_4 * mat1[""m_e""] + (1 - w_4) * mat3[""m_e""]\n                    )  # AlGaN\n                    cb_meff_alloy = (\n                        x * y * cb_meff_alloy_ABC\n                        + y * (1 - x - y) * cb_meff_alloy_ACD\n                        + x * (1 - x - y) * cb_meff_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    cb_meff[startindex:finishindex] = cb_meff_alloy * m_e\n\n                    Eg_alloy_ABC = (\n                        u_4 * mat2[""Eg""]\n                        + (1 - u_4) * mat3[""Eg""]\n                        - alloyprops[""Bowing_param_ABC""] * u_4 * (1 - u_4)\n                    )  # eV AlInN\n                    Eg_alloy_ACD = (\n                        v_4 * mat1[""Eg""]\n                        + (1 - v_4) * mat2[""Eg""]\n                        - alloyprops[""Bowing_param_ACD""] * v_4 * (1 - v_4)\n                    )  # eV InGaN\n                    Eg_alloy_ABD = (\n                        w_4 * mat1[""Eg""]\n                        + (1 - w_4) * mat3[""Eg""]\n                        - alloyprops[""Bowing_param_ABD""] * w_4 * (1 - w_4)\n                    )  # eV AlGaN\n                    Eg = (\n                        x * y * Eg_alloy_ABC\n                        + y * (1 - x - y) * Eg_alloy_ACD\n                        + x * (1 - x - y) * Eg_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    fi_e[startindex:finishindex] = (\n                        alloyprops[""Band_offset""] * Eg * q\n                    )  # for electron. Joule\n                    a0_sub[startindex:finishindex] = alloyprops[""a0_sub""] * 1e-10\n                    A1_alloy_ABC = u_4 * mat2[""A1""] + (1 - u_4) * mat3[""A1""]\n                    A1_alloy_ACD = v_4 * mat1[""A1""] + (1 - v_4) * mat2[""A1""]\n                    A1_alloy_ABD = w_4 * mat1[""A1""] + (1 - w_4) * mat3[""A1""]\n                    A1[startindex:finishindex] = (\n                        x * y * A1_alloy_ABC\n                        + y * (1 - x - y) * A1_alloy_ACD\n                        + x * (1 - x - y) * A1_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    A2_alloy_ABC = u_4 * mat2[""A2""] + (1 - u_4) * mat3[""A2""]\n                    A2_alloy_ACD = v_4 * mat1[""A2""] + (1 - v_4) * mat2[""A2""]\n                    A2_alloy_ABD = w_4 * mat1[""A2""] + (1 - w_4) * mat3[""A2""]\n                    A2[startindex:finishindex] = (\n                        x * y * A2_alloy_ABC\n                        + y * (1 - x - y) * A2_alloy_ACD\n                        + x * (1 - x - y) * A2_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    A3_alloy_ABC = u_4 * mat2[""A3""] + (1 - u_4) * mat3[""A3""]\n                    A3_alloy_ACD = v_4 * mat1[""A3""] + (1 - v_4) * mat2[""A3""]\n                    A3_alloy_ABD = w_4 * mat1[""A3""] + (1 - w_4) * mat3[""A3""]\n                    A3[startindex:finishindex] = (\n                        x * y * A3_alloy_ABC\n                        + y * (1 - x - y) * A3_alloy_ACD\n                        + x * (1 - x - y) * A3_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    A4_alloy_ABC = u_4 * mat2[""A4""] + (1 - u_4) * mat3[""A4""]\n                    A4_alloy_ACD = v_4 * mat1[""A4""] + (1 - v_4) * mat2[""A4""]\n                    A4_alloy_ABD = w_4 * mat1[""A4""] + (1 - w_4) * mat3[""A4""]\n                    A4[startindex:finishindex] = (\n                        x * y * A4_alloy_ABC\n                        + y * (1 - x - y) * A4_alloy_ACD\n                        + x * (1 - x - y) * A4_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    A5_alloy_ABC = u_4 * mat2[""A5""] + (1 - u_4) * mat3[""A5""]\n                    A5_alloy_ACD = v_4 * mat1[""A5""] + (1 - v_4) * mat2[""A5""]\n                    A5_alloy_ABD = w_4 * mat1[""A5""] + (1 - w_4) * mat3[""A5""]\n                    A5[startindex:finishindex] = (\n                        x * y * A5_alloy_ABC\n                        + y * (1 - x - y) * A5_alloy_ACD\n                        + x * (1 - x - y) * A5_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    A6_alloy_ABC = u_4 * mat2[""A6""] + (1 - u_4) * mat3[""A6""]\n                    A6_alloy_ACD = v_4 * mat1[""A6""] + (1 - v_4) * mat2[""A6""]\n                    A6_alloy_ABD = w_4 * mat1[""A6""] + (1 - w_4) * mat3[""A6""]\n                    A6[startindex:finishindex] = (\n                        x * y * A6_alloy_ABC\n                        + y * (1 - x - y) * A6_alloy_ACD\n                        + x * (1 - x - y) * A6_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    D1_alloy_ABC = u_4 * mat2[""D1""] + (1 - u_4) * mat3[""D1""]\n                    D1_alloy_ACD = v_4 * mat1[""D1""] + (1 - v_4) * mat2[""D1""]\n                    D1_alloy_ABD = w_4 * mat1[""D1""] + (1 - w_4) * mat3[""D1""]\n                    D1_alloy = (\n                        x * y * D1_alloy_ABC\n                        + y * (1 - x - y) * D1_alloy_ACD\n                        + x * (1 - x - y) * D1_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    D1[startindex:finishindex] = D1_alloy * q\n\n                    D2_alloy_ABC = u_4 * mat2[""D2""] + (1 - u_4) * mat3[""D2""]\n                    D2_alloy_ACD = v_4 * mat1[""D2""] + (1 - v_4) * mat2[""D2""]\n                    D2_alloy_ABD = w_4 * mat1[""D2""] + (1 - w_4) * mat3[""D2""]\n                    D2_alloy = (\n                        x * y * D2_alloy_ABC\n                        + y * (1 - x - y) * D2_alloy_ACD\n                        + x * (1 - x - y) * D2_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    D2[startindex:finishindex] = D2_alloy * q\n\n                    D3_alloy_ABC = u_4 * mat2[""D3""] + (1 - u_4) * mat3[""D3""]\n                    D3_alloy_ACD = v_4 * mat1[""D3""] + (1 - v_4) * mat2[""D3""]\n                    D3_alloy_ABD = w_4 * mat1[""D3""] + (1 - w_4) * mat3[""D3""]\n                    D3_alloy = (\n                        x * y * D3_alloy_ABC\n                        + y * (1 - x - y) * D3_alloy_ACD\n                        + x * (1 - x - y) * D3_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    D3[startindex:finishindex] = D3_alloy * q\n\n                    D4_alloy_ABC = u_4 * mat2[""D4""] + (1 - u_4) * mat3[""D4""]\n                    D4_alloy_ACD = v_4 * mat1[""D4""] + (1 - v_4) * mat2[""D4""]\n                    D4_alloy_ABD = w_4 * mat1[""D4""] + (1 - w_4) * mat3[""D4""]\n                    D4_alloy = (\n                        x * y * D4_alloy_ABC\n                        + y * (1 - x - y) * D4_alloy_ACD\n                        + x * (1 - x - y) * D4_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    D4[startindex:finishindex] = D4_alloy * q\n\n                    D31_alloy_ABC = u_4 * mat2[""D31""] + (1 - u_4) * mat3[""D31""]\n                    D31_alloy_ACD = v_4 * mat1[""D31""] + (1 - v_4) * mat2[""D31""]\n                    D31_alloy_ABD = w_4 * mat1[""D31""] + (1 - w_4) * mat3[""D31""]\n                    D31[startindex:finishindex] = (\n                        x * y * D31_alloy_ABC\n                        + y * (1 - x - y) * D31_alloy_ACD\n                        + x * (1 - x - y) * D31_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    D33_alloy_ABC = u_4 * mat2[""D33""] + (1 - u_4) * mat3[""D33""]\n                    D33_alloy_ACD = v_4 * mat1[""D33""] + (1 - v_4) * mat2[""D33""]\n                    D33_alloy_ABD = w_4 * mat1[""D33""] + (1 - w_4) * mat3[""D33""]\n                    D33[startindex:finishindex] = (\n                        x * y * D33_alloy_ABC\n                        + y * (1 - x - y) * D33_alloy_ACD\n                        + x * (1 - x - y) * D33_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    Psp_alloy_ABC = u_4 * mat2[""Psp""] + (1 - u_4) * mat3[""Psp""]\n                    Psp_alloy_ACD = v_4 * mat1[""Psp""] + (1 - v_4) * mat2[""Psp""]\n                    Psp_alloy_ABD = w_4 * mat1[""Psp""] + (1 - w_4) * mat3[""Psp""]\n                    Psp[startindex:finishindex] = (\n                        x * y * Psp_alloy_ABC\n                        + y * (1 - x - y) * Psp_alloy_ACD\n                        + x * (1 - x - y) * Psp_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    C11_alloy_ABC = u_4 * mat2[""C11""] + (1 - u_4) * mat3[""C11""]\n                    C11_alloy_ACD = v_4 * mat1[""C11""] + (1 - v_4) * mat2[""C11""]\n                    C11_alloy_ABD = w_4 * mat1[""C11""] + (1 - w_4) * mat3[""C11""]\n                    C11[startindex:finishindex] = (\n                        (\n                            x * y * C11_alloy_ABC\n                            + y * (1 - x - y) * C11_alloy_ACD\n                            + x * (1 - x - y) * C11_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e10\n                    )  # for newton/meter\xc2\xb2\n\n                    C12_alloy_ABC = u_4 * mat2[""C12""] + (1 - u_4) * mat3[""C12""]\n                    C12_alloy_ACD = v_4 * mat1[""C12""] + (1 - v_4) * mat2[""C12""]\n                    C12_alloy_ABD = w_4 * mat1[""C12""] + (1 - w_4) * mat3[""C12""]\n                    C12[startindex:finishindex] = (\n                        (\n                            x * y * C12_alloy_ABC\n                            + y * (1 - x - y) * C12_alloy_ACD\n                            + x * (1 - x - y) * C12_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e10\n                    )\n\n                    C13_alloy_ABC = u_4 * mat2[""C13""] + (1 - u_4) * mat3[""C13""]\n                    C13_alloy_ACD = v_4 * mat1[""C13""] + (1 - v_4) * mat2[""C13""]\n                    C13_alloy_ABD = w_4 * mat1[""C13""] + (1 - w_4) * mat3[""C13""]\n                    C13[startindex:finishindex] = (\n                        (\n                            x * y * C13_alloy_ABC\n                            + y * (1 - x - y) * C13_alloy_ACD\n                            + x * (1 - x - y) * C13_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e10\n                    )\n\n                    C33_alloy_ABC = u_4 * mat2[""C33""] + (1 - u_4) * mat3[""C33""]\n                    C33_alloy_ACD = v_4 * mat1[""C33""] + (1 - v_4) * mat2[""C33""]\n                    C33_alloy_ABD = w_4 * mat1[""C33""] + (1 - w_4) * mat3[""C33""]\n                    C33[startindex:finishindex] = (\n                        (\n                            x * y * C33_alloy_ABC\n                            + y * (1 - x - y) * C33_alloy_ACD\n                            + x * (1 - x - y) * C33_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e10\n                    )\n\n                    fi_h[startindex:finishindex] = (\n                        -(1 - alloyprops[""Band_offset""]) * Eg * q\n                    )  # -(-1.33*(1-x)-0.8*x)for electron. Joule-1.97793434e-20 #\n\n                    eps_alloy_ABC = (\n                        u_4 * mat2[""epsilonStatic""] + (1 - u_4) * mat3[""epsilonStatic""]\n                    )\n                    eps_alloy_ACD = (\n                        v_4 * mat1[""epsilonStatic""] + (1 - v_4) * mat2[""epsilonStatic""]\n                    )\n                    eps_alloy_ABD = (\n                        w_4 * mat1[""epsilonStatic""] + (1 - w_4) * mat3[""epsilonStatic""]\n                    )\n                    eps_alloy = (\n                        x * y * eps_alloy_ABC\n                        + y * (1 - x - y) * eps_alloy_ACD\n                        + x * (1 - x - y) * eps_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    eps[startindex:finishindex] = eps_alloy * eps0\n\n                    a0_wz_alloy_ABC = u_4 * mat2[""a0_wz""] + (1 - u_4) * mat3[""a0_wz""]\n                    a0_wz_alloy_ACD = v_4 * mat1[""a0_wz""] + (1 - v_4) * mat2[""a0_wz""]\n                    a0_wz_alloy_ABD = w_4 * mat1[""a0_wz""] + (1 - w_4) * mat3[""a0_wz""]\n                    a0_wz_alloy = (\n                        x * y * a0_wz_alloy_ABC\n                        + y * (1 - x - y) * a0_wz_alloy_ACD\n                        + x * (1 - x - y) * a0_wz_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    a0_wz[startindex:finishindex] = a0_wz_alloy * 1e-10\n\n                    delta_so_alloy_ABC = (\n                        u_4 * mat2[""delta_so""] + (1 - u_4) * mat3[""delta_so""]\n                    )\n                    delta_so_alloy_ACD = (\n                        v_4 * mat1[""delta_so""] + (1 - v_4) * mat2[""delta_so""]\n                    )\n                    delta_so_alloy_ABD = (\n                        w_4 * mat1[""delta_so""] + (1 - w_4) * mat3[""delta_so""]\n                    )\n                    delta_so_alloy = (\n                        x * y * delta_so_alloy_ABC\n                        + y * (1 - x - y) * delta_so_alloy_ACD\n                        + x * (1 - x - y) * delta_so_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    delta_so[startindex:finishindex] = delta_so_alloy * q\n\n                    delta_cr_alloy_ABC = (\n                        u_4 * mat2[""delta_cr""] + (1 - u_4) * mat3[""delta_cr""]\n                    )\n                    delta_cr_alloy_ACD = (\n                        v_4 * mat1[""delta_cr""] + (1 - v_4) * mat2[""delta_cr""]\n                    )\n                    delta_cr_alloy_ABD = (\n                        w_4 * mat1[""delta_cr""] + (1 - w_4) * mat3[""delta_cr""]\n                    )\n                    delta_cr_alloy = (\n                        x * y * delta_cr_alloy_ABC\n                        + y * (1 - x - y) * delta_cr_alloy_ACD\n                        + x * (1 - x - y) * delta_cr_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    delta_cr[startindex:finishindex] = delta_cr_alloy * q\n\n                    Ac_alloy_ABC = u_4 * mat2[""Ac""] + (1 - u_4) * mat3[""Ac""]\n                    Ac_alloy_ACD = v_4 * mat1[""Ac""] + (1 - v_4) * mat2[""Ac""]\n                    Ac_alloy_ABD = w_4 * mat1[""Ac""] + (1 - w_4) * mat3[""Ac""]\n                    Ac_alloy = (\n                        x * y * Ac_alloy_ABC\n                        + y * (1 - x - y) * Ac_alloy_ACD\n                        + x * (1 - x - y) * Ac_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                    Ac[startindex:finishindex] = Ac_alloy * q\n\n                    mun0_alloy_ABC = u_4 * mat2[""mun0""] + (1 - u_4) * mat3[""mun0""]\n                    mun0_alloy_ACD = v_4 * mat1[""mun0""] + (1 - v_4) * mat2[""mun0""]\n                    mun0_alloy_ABD = w_4 * mat1[""mun0""] + (1 - w_4) * mat3[""mun0""]\n                    mun0[startindex:finishindex] = (\n                        x * y * mun0_alloy_ABC\n                        + y * (1 - x - y) * mun0_alloy_ACD\n                        + x * (1 - x - y) * mun0_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    mup0_alloy_ABC = u_4 * mat2[""mup0""] + (1 - u_4) * mat3[""mup0""]\n                    mup0_alloy_ACD = v_4 * mat1[""mup0""] + (1 - v_4) * mat2[""mup0""]\n                    mup0_alloy_ABD = w_4 * mat1[""mup0""] + (1 - w_4) * mat3[""mup0""]\n                    mup0[startindex:finishindex] = (\n                        x * y * mup0_alloy_ABC\n                        + y * (1 - x - y) * mup0_alloy_ACD\n                        + x * (1 - x - y) * mup0_alloy_ABD\n                    ) / (x * y + y * (1 - x - y) + x * (1 - x - y))\n\n                    Cn0_alloy_ABC = u_4 * mat2[""Cn0""] + (1 - u_4) * mat3[""Cn0""]\n                    Cn0_alloy_ACD = v_4 * mat1[""Cn0""] + (1 - v_4) * mat2[""Cn0""]\n                    Cn0_alloy_ABD = w_4 * mat1[""Cn0""] + (1 - w_4) * mat3[""Cn0""]\n                    Cn0[startindex:finishindex] = (\n                        (\n                            x * y * Cn0_alloy_ABC\n                            + y * (1 - x - y) * Cn0_alloy_ACD\n                            + x * (1 - x - y) * Cn0_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e-12\n                    )\n\n                    Cp0_alloy_ABC = u_4 * mat2[""Cp0""] + (1 - u_4) * mat3[""Cp0""]\n                    Cp0_alloy_ACD = v_4 * mat1[""Cp0""] + (1 - v_4) * mat2[""Cp0""]\n                    Cp0_alloy_ABD = w_4 * mat1[""Cp0""] + (1 - w_4) * mat3[""Cp0""]\n                    Cp0[startindex:finishindex] = (\n                        (\n                            x * y * Cp0_alloy_ABC\n                            + y * (1 - x - y) * Cp0_alloy_ACD\n                            + x * (1 - x - y) * Cp0_alloy_ABD\n                        )\n                        / (x * y + y * (1 - x - y) + x * (1 - x - y))\n                        * 1e-12\n                    )\n            # wells and barriers boundaries\n            matRole = layer[6]\n            if matRole == ""w"":\n                N_wells_real2 += 1\n                Well_boundary2[N_wells_real2, 0] = startindex\n                Well_boundary2[N_wells_real2, 1] = finishindex\n            N_layers_real2 += 1\n            layer_boundary[N_layers_real2, 0] = startindex\n            layer_boundary[N_layers_real2, 1] = finishindex\n            for J in range(0, N_wells_virtual2):\n                barrier_boundary[J, 0] = Well_boundary2[J - 1, 1]\n                barrier_boundary[J, 1] = Well_boundary2[J, 0]\n                barrier_len[J] = barrier_boundary[J, 1] - barrier_boundary[J, 0]\n            # doping\n\n            dop_profile = self.dop_profile\n            if layer[5] == ""n"":\n                dop[startindex:finishindex] = (\n                    layer[4] * 1e6 + dop_profile[startindex:finishindex] + 1\n                )  # charge density in m**-3 (conversion from cm**-3)\n            elif layer[5] == ""p"":\n                dop[startindex:finishindex] = (\n                    -layer[4] * 1e6 + dop_profile[startindex:finishindex] - 1\n                )  # charge density in m**-3 (conversion from cm**-3)\n            else:\n                dop[startindex:finishindex] = dop_profile[startindex:finishindex] + 1\n        """"""\n        Here we remove barriers that are less than the anti_crossing_length\n        so we can constructe the new well boundary using the resulted barrier boundary\n        """"""\n        brr = 0\n        anti_crossing_length = config.anti_crossing_length * 1e-9\n        if not (self.Quantum_Regions):\n            for J in range(2, N_wells_virtual2 - 1):\n                if barrier_len[J] * dx <= anti_crossing_length:\n                    brr += 1\n            brr_vec = np.zeros(brr)\n            brr2 = 0\n            for J in range(2, N_wells_virtual2 - 1):\n                if barrier_len[J] * dx <= anti_crossing_length:\n                    brr2 += 1\n                    brr_vec[brr2 - 1] = J + 1 - brr2\n            for I in range(0, brr):\n                barrier_boundary = np.delete(barrier_boundary, brr_vec[I], 0)\n            N_wells_virtual = N_wells_virtual - brr\n            Well_boundary = np.resize(Well_boundary, (N_wells_virtual, 2))\n            for J in range(0, N_wells_virtual):\n                Well_boundary[J - 1, 1] = barrier_boundary[J, 0]\n                Well_boundary[J, 0] = barrier_boundary[J, 1]\n        else:\n            # setup of independent quantum regions\n            # ratio of half well\'s width for wavefunction  to penetration into the the left adjacent barrier\n            config.amort_wave_0 = 0.0\n            config.amort_wave_1 = 0.0\n            N_wells_real0 = len(self.Quantum_Regions_boundary[:, 0])\n            N_wells_virtual = N_wells_real0 + 2\n            N_wells_virtual2 = N_wells_real0 + 2\n            N_layers_virtual = N_layers_real0 + 2\n            Well_boundary = np.zeros((N_wells_virtual, 2), dtype=int)\n            Well_boundary2 = np.zeros((N_wells_virtual, 2), dtype=int)\n            barrier_boundary = np.zeros((N_wells_virtual + 1, 2), dtype=int)\n            layer_boundary = np.zeros((N_layers_virtual, 2), dtype=int)\n            n_max_general = np.zeros(N_wells_virtual, dtype=int)\n            Well_boundary[N_wells_virtual - 1, 0] = n_max - 1\n            Well_boundary[N_wells_virtual - 1, 1] = n_max - 1\n            Well_boundary2[N_wells_virtual - 1, 0] = n_max - 1\n            Well_boundary2[N_wells_virtual - 1, 1] = n_max - 1\n            barrier_boundary[N_wells_virtual, 0] = n_max - 1\n            barrier_len = np.zeros(N_wells_virtual + 1)\n            for i in range(len(self.Quantum_Regions_boundary[:, 0])):\n                for j in range(2):\n                    Well_boundary[i + 1, j] = round2int(\n                        self.Quantum_Regions_boundary[i, j] * 1e-9 / dx\n                    )\n        self.fi_e = fi_e\n        self.fi_h = fi_h\n        self.cb_meff = cb_meff\n        self.cb_meff_alpha = cb_meff_alpha\n        self.dop = dop\n        self.pol_surf_char = pol_surf_char\n        # return fi_e,cb_meff,eps,dop\n        self.C11 = C11\n        self.C12 = C12\n        self.GA1 = GA1\n        self.GA2 = GA2\n        self.GA3 = GA3\n        self.Ac = Ac\n        self.Av = Av\n        self.B = B\n        self.n = n\n        self.p = p\n        self.a0 = a0\n        self.delta = delta\n        self.eps = eps\n        self.A1 = A1\n        self.A2 = A2\n        self.A3 = A3\n        self.A4 = A4\n        self.A5 = A5\n        self.A6 = A6\n        self.D1 = D1\n        self.D2 = D2\n        self.D3 = D3\n        self.D4 = D4\n        self.C13 = C13\n        self.C33 = C33\n        self.D31 = D31\n        self.D33 = D33\n        self.Psp = Psp\n        self.a0_wz = a0_wz\n        self.a0_sub = a0_sub\n        self.delta_so = delta_so\n        self.delta_cr = delta_cr\n        self.N_wells_virtual = N_wells_virtual\n        self.N_wells_virtual2 = N_wells_virtual2\n        self.N_wells_real0 = N_wells_real0\n        self.Well_boundary = Well_boundary\n        self.Well_boundary2 = Well_boundary2\n        self.barrier_boundary = barrier_boundary\n        self.N_layers_real2 = N_layers_real2\n        self.layer_boundary = layer_boundary\n        self.TAUN0 = TAUN0\n        self.TAUP0 = TAUP0\n        self.mun0 = mun0\n        self.mup0 = mup0\n        self.Cn0 = Cn0\n        self.Cp0 = Cp0\n        self.BETAN = BETAN\n        self.BETAP = BETAP\n        self.VSATN = VSATN\n        self.VSATP = VSATP\n\n\nclass AttrDict(dict):\n    """"""turns a dictionary into an object with attribute style lookups""""""\n\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\n\n\nclass StructureFrom(Structure):\n    def __init__(self, inputfile, database):\n        if type(inputfile) == dict:\n            inputfile = AttrDict(inputfile)\n        # Parameters for simulation\n        self.Fapp = inputfile.Fapplied\n        self.vmax = inputfile.vmax\n        self.vmin = inputfile.vmin\n        self.Each_Step = inputfile.Each_Step\n        self.surface = inputfile.surface\n        self.T = inputfile.T\n        self.subnumber_h = inputfile.subnumber_h\n        self.subnumber_e = inputfile.subnumber_e\n        self.comp_scheme = inputfile.computation_scheme\n        self.dx = inputfile.gridfactor * 1e-9  # grid in m\n        self.maxgridpoints = inputfile.maxgridpoints\n        self.mat_crys_strc = inputfile.mat_type\n        # Loading material list\n        self.material = inputfile.material\n        self.inputfilename=inputfile.inputfilename\n        totallayer = alen(self.material)\n        if not (config.messagesoff):\n            logger.info(""Total layer number: %s"", totallayer)\n        # Calculate the required number of grid points\n        self.x_max = (\n            sum([layer[0] for layer in self.material]) * 1e-9\n        )  # total thickness (m)\n        self.n_max = int(self.x_max / self.dx)\n        # Check on n_max\n        max_val = inputfile.maxgridpoints\n\n        self.dop_profile = inputfile.dop_profile\n        self.Quantum_Regions_boundary = inputfile.Quantum_Regions_boundary\n        self.Quantum_Regions = inputfile.Quantum_Regions\n        if self.n_max > max_val:\n            logger.error("" Grid number is exceeding the max number of %d"", max_val)\n            exit()\n        # Loading materials database #\n        self.material_property = database.materialproperty\n        totalmaterial = alen(self.material_property)\n\n        self.alloy_property = database.alloyproperty\n        totalalloy = alen(self.alloy_property)\n\n        self.alloy_property_4 = database.alloyproperty4\n        totalalloy += alen(self.alloy_property_4)\n        if not (config.messagesoff):\n            logger.info(\n                ""Total number of materials in database: %d""\n                % (totalmaterial + totalalloy)\n            )\n        # Initialise arrays\n\n        # cb_meff #conduction band effective mass (array, len n_max)\n        # fi_e #Bandstructure potential (array, len n_max)\n        # eps #dielectric constant (array, len n_max)\n        # dop #doping distribution (array, len n_max)\n        self.create_structure_arrays()\n\n\n# No Shooting method parameters for Schr\xc3\xb6dinger Equation solution since we use a 3x3 KP solver\n# delta_E = 1.0*meV2J #Energy step (Joules) for initial search. Initial delta_E is 1 meV. #This can be included in config as a setting?\n# d_E = 1e-5*meV2J #Energy step (Joules) for Newton-Raphson method when improving the precision of the energy of a found level.\n""""""damping:An adjustable parameter  (0 < damping < 1) is typically set to 0.5 at low carrier densities. With increasing\ncarrier densities, a smaller value of it is needed for rapid convergence.""""""\ndamping = 0.1  # averaging factor between iterations to smooth convergence.\nmax_iterations = 120  # maximum number of iterations.\nconvergence_test = 1e-5  # convergence is reached when the ground state energy (eV) is stable to within this number between iterations.\nconvergence_test0 = 1e-5\n# DO NOT EDIT UNDER HERE FOR PARAMETERS\n# --------------------------------------\n\n# Vegard\'s law for alloys\ndef vegard(first, second, mole):\n    return first * mole + second * (1 - mole)\n\n\n# FUNCTIONS for FERMI-DIRAC STATISTICS-----------------------------------------\ndef fd1(Ei, Ef, model):  # use\n    """"""integral of Fermi Dirac Equation for energy independent density of states.\n    Ei [meV], Ef [meV], T [K]""""""\n    T = model.T\n    return kb * T * log(exp(meV2J * (Ei - Ef) / (kb * T)) + 1)\n\n\ndef fd2(Ei, Ef, model):\n    """"""integral of Fermi Dirac Equation for energy independent density of states.\n    Ei [meV], Ef [meV], T [K]""""""\n    T = model.T\n    return kb * T * log(exp(meV2J * (Ef - Ei) / (kb * T)) + 1)\n\n\ndef calc_meff_state_general(\n    wfh,\n    wfe,\n    model,\n    fi_e,\n    E_statec,\n    list,\n    m_hh,\n    m_lh,\n    m_so,\n    n_max_general,\n    j,\n    Well_boundary,\n    n_max,\n):\n    vb_meff = np.zeros((model.subnumber_h, n_max_general))\n    #\n    I1, I2, I11, I22 = amort_wave(j, Well_boundary, n_max)\n    i2 = I2 - I1\n    for i in range(0, model.subnumber_h, 1):\n        if list[i] == ""hh1"" or list[i] == ""hh2"" or list[i] == ""hh3"":\n            vb_meff[i] = m_hh[I1:I2]\n        elif list[i] == ""lh1"" or list[i] == ""lh2"" or list[i] == ""lh3"":\n            vb_meff[i] = m_lh[I1:I2]\n        else:\n            vb_meff[i] = m_so[I1:I2]\n    tmp = 1.0 / np.sum(wfh[:, 0:i2] ** 2 / vb_meff, axis=1)  # vb_meff[:,int(n_max/2)]\n    meff_state = tmp.tolist()\n    """"""find subband effective masses including non-parabolicity\n    (but stilling using a fixed effective mass for each subband dispersion)""""""\n    cb_meff = model.cb_meff  # effective mass of conduction band across structure\n    cb_meff_alpha = model.cb_meff_alpha  # non-parabolicity constant across structure\n    cb_meff_states = np.array(\n        [cb_meff * (1.0 + cb_meff_alpha * (E * meV2J - fi_e)) for E in E_statec]\n    )\n    tmp1 = 1.0 / np.sum(wfe[:, 0:i2] ** 2 / cb_meff_states[:, I1:I2], axis=1)\n    meff_statec = tmp1.tolist()\n    return meff_statec, meff_state\n\n\ndef calc_meff_state(wfh, wfe, subnumber_h, subnumber_e, list, m_hh, m_lh, m_so, model):\n    n_max = len(m_hh)\n    vb_meff = np.zeros((subnumber_h, n_max))\n    for i in range(0, subnumber_h, 1):\n        if list[i] == ""hh"":\n            vb_meff[i] = m_hh\n        elif list[i] == ""lh"":\n            vb_meff[i] = m_lh\n        else:\n            vb_meff[i] = m_so\n    tmp = 1.0 / np.sum(wfh ** 2 / vb_meff, axis=1)\n    meff_state = tmp.tolist()\n    """"""find subband effective masses including non-parabolicity\n    (but stilling using a fixed effective mass for each subband dispersion)""""""\n    cb_meff = model.cb_meff  # effective mass of conduction band across structure\n    # cb_meff_alpha = model.cb_meff_alpha # non-parabolicity constant across structure\n    # cb_meff_states = np.array([cb_meff*(1.0 + cb_meff_alpha*(E*meV2J - fi_e)) for E in E_statec])\n    # tmp1 = 1.0/np.sum(wfe**2/cb_meff_states,axis=1)\n    tmp1 = 1.0 / np.sum(wfe ** 2 / cb_meff, axis=1)\n    meff_statec = tmp1.tolist()\n    return meff_statec, meff_state\n\n\ndef fermilevel_0Kc(Ntotal2d, E_statec, meff_statec, model):  # use\n    Et2, Ef = 0.0, 0.0\n    meff_statec = np.array(meff_statec)\n    E_statec = np.array(E_statec)\n    for i in range(\n        model.subnumber_e, 0, -1\n    ):  # ,(Ei,vsb_meff) in enumerate(zip(E_state,meff_state)):\n        Efnew2 = sum(E_statec[0:i] * meff_statec[0:i])\n        m2 = sum(meff_statec[0:i])\n        Et2 += E_statec[i - model.subnumber_e]\n        Efnew = (Efnew2 + Ntotal2d * hbar ** 2 * pi * J2meV) / (m2)\n        if Efnew > Et2:\n            Ef = Efnew\n            # print \'Ef[\',i-subnumber_h,\']=\',Ef\n        else:\n            break  # we have found Ef and so we should break out of the loop\n    else:  # exception clause for \'for\' loop.\n        if not (config.messagesoff):\n            logger.warning(\n                ""Have processed all energy levels present and so can\'t be sure that Ef is below next higher energy level.""\n            )\n    # Ef1=(sum(E_state*meff_state)-Ntotal2d*hbar**2*pi)/(sum(meff_state))\n    N_statec = [0.0] * len(E_statec)\n    for i, (Ei, csb_meff) in enumerate(zip(E_statec, meff_statec)):\n        Nic = (Ef - Ei) * csb_meff / (hbar ** 2 * pi) * meV2J  # populations of levels\n        Nic *= Nic > 0.0\n        N_statec[i] = Nic\n    return (\n        Ef,\n        N_statec,\n    )  # Fermi levels at 0K (meV), number of electrons in each subband at 0K\n\n\ndef fermilevel_0K(Ntotal2d, E_state, meff_state, model):  # use\n    Et1, Ef = 0.0, 0.0\n    E_state = np.array(E_state)\n    for i in range(\n        model.subnumber_h, 0, -1\n    ):  # ,(Ei,vsb_meff) in enumerate(zip(E_state,meff_state)):\n        Efnew1 = sum(E_state[0:i] * meff_state[0:i])\n        m1 = sum(meff_state[0:i])\n        Et1 += E_state[i - model.subnumber_h]\n        Efnew = (Efnew1 + Ntotal2d * hbar ** 2 * pi * J2meV) / (m1)\n        if Efnew < Et1:\n            Ef = Efnew\n            # print \'Ef[\',i-subnumber_h,\']=\',Ef\n        else:\n            break  # we have found Ef and so we should break out of the loop\n    else:  # exception clause for \'for\' loop.\n        if not (config.messagesoff):\n            logger.warning(\n                ""Have processed all energy levels present and so can\'t be sure that Ef is below next higher energy level.""\n            )\n    # Ef1=(sum(E_state*meff_state)-Ntotal2d*hbar**2*pi)/(sum(meff_state))\n    N_state = [0.0] * len(E_state)\n    for i, (Ei, vsb_meff) in enumerate(zip(E_state, meff_state)):\n        Ni = (Ei - Ef) * vsb_meff / (hbar ** 2 * pi) * meV2J  # populations of levels\n        Ni *= Ni > 0.0\n        N_state[i] = Ni\n    return (\n        Ef,\n        N_state,\n    )  # Fermi levels at 0K (meV), number of electrons in each subband at 0K\n\n\ndef fermilevel(Ntotal2d, model, E_state, E_statec, meff_state, meff_statec):  # use\n    # find the Fermi level (meV)\n    def func(Ef, E_state, meff_state, E_statec, meff_statec, Ntotal2d, model):\n        # return Ntotal2d - sum( [vsb_meff*fd2(Ei,Ef,T) for Ei,vsb_meff in zip(E_state,meff_state)] )/(hbar**2*pi)\n        diff, diff1, diff2 = 0.0, 0.0, 0.0\n        diff = Ntotal2d\n        for Ei, csb_meff in zip(E_statec, meff_statec):\n            diff1 -= csb_meff * fd2(Ei, Ef, model) / (hbar ** 2 * pi)\n        for Ei, vsb_meff in zip(E_state, meff_state):\n            diff2 += vsb_meff * fd1(Ei, Ef, model) / (hbar ** 2 * pi)\n        if Ntotal2d > 0:\n            diff += diff1\n        else:\n            diff += diff2\n        return diff\n\n    if Ntotal2d > 0:\n        Ef_0K, N_states_0K = fermilevel_0Kc(Ntotal2d, E_statec, meff_statec, model)\n    else:\n        Ef_0K, N_states_0K = fermilevel_0K(Ntotal2d, E_state, meff_state, model)\n    # Ef=fsolve(func,Ef_0K,args=(E_state,meff_state,Ntotal2d,T))[0]\n    # return float(Ef)\n    # implement Newton-Raphson method\n    Ef = Ef_0K\n    # itr=0\n    # logger.info(\'Ef (at 0K)= %g\',Ef)\n    d_E = 1e-9  # Energy step (meV)\n    while True:\n        y = func(Ef, E_state, meff_state, E_statec, meff_statec, Ntotal2d, model)\n        dy = (\n            func(Ef + d_E, E_state, meff_state, E_statec, meff_statec, Ntotal2d, model)\n            - func(\n                Ef - d_E, E_state, meff_state, E_statec, meff_statec, Ntotal2d, model\n            )\n        ) / (2.0 * d_E)\n        if (\n            dy == 0.0\n        ):  # increases interval size for derivative calculation in case of numerical error\n            d_E *= 2.0\n            continue\n        Ef -= y / dy\n        if abs(y / dy) < 1e-12:\n            break\n        for i in range(2):\n            if d_E > 1e-9:\n                d_E *= 0.5\n    return Ef  # (meV)\n\n\ndef calc_N_state(\n    Ef, model, E_state, meff_state, E_statec, meff_statec, Ntotal2d\n):  # use\n    # Find the subband populations, taking advantage of step like d.o.s. and analytic integral of FD\n    N_statec, N_state = 0.0, 0.0\n    if Ntotal2d > 0:\n        N_statec = [\n            fd2(Ei, Ef, model) * csb_meff / (hbar ** 2 * pi)\n            for Ei, csb_meff in zip(E_statec, meff_statec)\n        ]\n    else:\n        N_state = [\n            fd1(Ei, Ef, model) * vsb_meff / (hbar ** 2 * pi)\n            for Ei, vsb_meff in zip(E_state, meff_state)\n        ]\n    return N_state, N_statec  # number of carriers in each subband\n\n\n# FUNCTIONS for SELF-CONSISTENT POISSON--------------------------------\n\n\ndef calc_sigma(wfh, wfe, N_state, N_statec, model, Ntotal2d):  # use\n    """"""This function calculates `net\' areal charge density\n    n-type dopants lead to -ve charge representing electrons, and additionally \n    +ve ionised donors.""""""\n    # note: model.dop is still a volume density, the delta_x converts it to an areal density\n    sigma = model.dop * model.dx  # The charges due to the dopant ions\n    if Ntotal2d > 0:\n        for j in range(\n            0, model.subnumber_e, 1\n        ):  # The charges due to the electrons in the subbands\n            sigma -= N_statec[j] * (wfe[j]) ** 2\n    else:\n        for i in range(\n            0, model.subnumber_h, 1\n        ):  # The charges due to the electrons in the subbands\n            sigma += N_state[i] * (wfh[i]) ** 2\n    return sigma  # charge per m**2 (units of electronic charge)\n\n\ndef calc_sigma_general2(n_max, dopi, n, p):  # use\n    """"""This function calculates `net\' areal charge density\n    n-type dopants lead to -ve charge representing electrons, and additionally \n    +ve ionised donors.""""""\n    sigma = np.zeros(len(dopi))\n    sigma = sigma + dopi  # The charges due to the dopant ions\n    for i in range(0, n_max):  # The charges due to the electrons in the subbands\n        sigma[i] += p[i] - n[i]\n    return sigma  # charge per m**3 (units of electronic charge)\n\n\ndef calc_sigma_general(\n    pol_surf_char, wfh, wfe, N_state, N_statec, model, Ntotal2d, j, Well_boundary\n):  # use\n    """"""This function calculates `net\' areal charge density\n    n-type dopants lead to -ve charge representing electrons, and additionally \n    +ve ionised donors.""""""\n    # note: model.dop is still a volume density, the delta_x converts it to an areal density\n    sigma = (\n        model.dop[Well_boundary[j - 1, 1] : Well_boundary[j + 1, 0]] * model.dx\n    )  # +pol_surf_char[Well_boundary[j-1,1]:Well_boundary[j+1,0]]  The charges due to the dopant ions\n    if Ntotal2d > 0:\n        for j in range(\n            0, model.subnumber_e, 1\n        ):  # The charges due to the electrons in the subbands\n            sigma -= N_statec[j] * (wfe[j]) ** 2\n    else:\n        for i in range(\n            0, model.subnumber_h, 1\n        ):  # The charges due to the electrons in the subbands\n            sigma += N_state[i] * (wfh[i]) ** 2\n    return sigma  # charge per m**2 (units of electronic charge)\n\n\ndef calc_field(sigma, eps):\n    # F electric field as a function of z-\n    # i index over z co-ordinates\n    # j index over z\' co-ordinates\n    # Note: sigma is a number density per unit area, needs to be converted to Couloumb per unit area\n    sigma = sigma\n    F0 = -np.sum(q * sigma) / (2.0)  # CMP\'deki i ve j yer de\xc4\x9fi\xc5\x9febilir - de + olabilir\n    # is the above necessary since the total field due to the structure should be zero.\n    # Do running integral\n    tmp = np.hstack(([0.0], sigma[:-1])) + sigma\n    tmp *= (\n        q / 2.0\n    )  # Note: sigma is a number density per unit area, needs to be converted to Couloumb per unit area\n    tmp[0] = F0\n    F = np.cumsum(tmp) / eps\n    return F\n\n\ndef calc_field_convolve(sigma, eps):  # use\n    tmp = np.ones(len(sigma) - 1)\n    signstep = np.hstack((-tmp, [0.0], tmp))  # step function\n    F = np.convolve(signstep, sigma, mode=""valid"")\n    F *= q / (2.0 * eps)\n    return F\n\n\ndef calc_field_old(sigma, eps):  # use\n    # F electric field as a function of z-\n    # i index over z co-ordinates\n    # j index over z\' co-ordinates\n    n_max = len(sigma)\n    # For wave function initialise F\n    F = np.zeros(n_max)\n    for i in range(0, n_max, 1):\n        for j in range(0, n_max, 1):\n            # Note sigma is a number density per unit area, needs to be converted to Couloumb per unit area\n            F[i] = F[i] + q * sigma[j] * cmp(i, j) / (\n                2 * eps[i]\n            )  # CMP\'deki i ve j yer de\xc4\x9fi\xc5\x9febilir - de + olabilir\n    return F\n\n\ndef calc_potn(F, model):  # use\n    # This function calculates the potential (energy actually)\n    # V electric field as a function of z-\n    # i\tindex over z co-ordinates\n\n    # Calculate the potential, defining the first point as zero\n    tmp = q * F * model.dx\n    V = np.cumsum(tmp)  # +q -> electron -q->hole?\n    return V\n\n\n# FUNCTIONS FOR EXCHANGE INTERACTION-------------------------------------------\n\n\ndef calc_Vxc(sigma, eps, cb_meff, model):\n    """"""An effective field describing the exchange-interactions between the electrons\n    derived from Kohn-Sham density functional theory. This formula is given in many\n    papers, for example see Gunnarsson and Lundquist (1976), Ando, Taniyama, Ohtani \n    et al. (2003), or Ch.1 in the book \'Intersubband transitions in quantum wells\' (edited\n    by Liu and Capasso) by M. Helm.\n    eps = dielectric constant array\n    cb_meff = effective mass array\n    sigma = charge carriers per m**2, however this includes the donor atoms and we are only\n            interested in the electron density.""""""\n    a_B = 4 * pi * hbar ** 2 / q ** 2  # Bohr radius.\n    nz = -(sigma - model.dop * model.dx)  # electron density per m**2\n    nz_3 = nz ** (1 / 3.0)  # cube root of charge density.\n    # a_B_eff = eps/cb_meff*a_B #effective Bohr radius\n    # r_s occasionally suffers from division by zero errors due to nz=0.\n    # We will fix these by setting nz_3 = 1.0 for these points (a tiny charge in per m**2).\n    nz_3 = nz_3.clip(1.0, max(nz_3))\n\n    r_s = 1.0 / (\n        (4 * pi / 3.0) ** (1 / 3.0) * nz_3 * eps / cb_meff * a_B\n    )  # average distance between charges in units of effective Bohr radis.\n    # A = q**4/(32*pi**2*hbar**2)*(9*pi/4.0)**(1/3.)*2/pi*(4*pi/3.0)**(1/3.)*4*pi*hbar**2/q**2 #constant factor for expression.\n    A = (\n        q ** 2 / (4 * pi) * (3 / pi) ** (1 / 3.0)\n    )  # simplified constant factor for expression.\n    #\n    Vxc = -A * nz_3 / eps * (1.0 + 0.0545 * r_s * np.log(1.0 + 11.4 / r_s))\n    return Vxc\n\n\n# -----------------------------------------------------------------------------\n\n\ndef wave_func_tri(j, Well_boundary, n_max, V1, V2, subnumber_h, subnumber_e, model):\n    # Envelope Function Wave Functions\n    wfh_general = np.zeros((model.N_wells_virtual, subnumber_h, n_max))\n    wfe_general = np.zeros((model.N_wells_virtual, subnumber_e, n_max))\n    # n_max_general = np.zeros(model.N_wells_virtual,int)\n    n_max_general2 = np.zeros(model.N_wells_virtual, int)\n    I1, I2, I11, I22 = amort_wave(j, Well_boundary, n_max)\n    i_1 = I2 - I1\n    n_max_general2[j] = int(I2 - I1)\n    # n_max_general[j]=int(Well_boundary[j+1,0]-Well_boundary[j-1,1])\n    wfh1s2 = np.zeros((subnumber_h, 3, i_1))\n    maxwfh = np.zeros((subnumber_h, 3))\n    list = [""""] * subnumber_h\n    for i in range(0, subnumber_e, 1):\n        wfe_general[j, i, 0:i_1] = V1[j, 0:i_1, i] + 1e-20\n    wfh_pow = np.zeros(n_max)\n    conter_hh, conter_lh, conter_so = 0, 0, 0\n    for jj in range(0, subnumber_h):\n        for i in range(0, 3):\n            wfh1s2[jj, i, :] = V2[j, i * i_1 : (i + 1) * i_1, jj]\n            wfh_pow = np.cumsum(wfh1s2[jj, i, :] * wfh1s2[jj, i, :])\n            maxwfh[jj, i] = wfh_pow[i_1 - 1]\n        if np.argmax(maxwfh[jj, :]) == 0:\n            conter_hh += 1\n            list[jj] = ""hh%d"" % conter_hh\n            wfh_general[j, jj, 0:i_1] = wfh1s2[jj, np.argmax(maxwfh[jj, :]), :] + 1e-20\n        elif np.argmax(maxwfh[jj, :]) == 1:\n            conter_lh += 1\n            list[jj] = ""lh%d"" % conter_lh\n            wfh_general[j, jj, 0:i_1] = wfh1s2[jj, np.argmax(maxwfh[jj, :]), :] + 1e-20\n        else:\n            conter_so += 1\n            list[jj] = ""so%d"" % conter_so\n            wfh_general[j, jj, 0:i_1] = wfh1s2[jj, np.argmax(maxwfh[jj, :]), :] + 1e-20\n    return wfh_general, wfe_general, list, n_max_general2\n\n\ndef Strain_and_Masses(model):\n    n_max = model.n_max\n    EXX = np.zeros(n_max)\n    EZZ = np.zeros(n_max)\n    ZETA = np.zeros(n_max)\n    CNIT = np.zeros(n_max)\n    VNIT = np.zeros(n_max)\n    S = np.zeros(n_max)\n    k1 = np.zeros(n_max)\n    k2 = np.zeros(n_max)\n    k3 = np.zeros(n_max)\n    fp = np.ones(n_max)\n    fm = np.ones(n_max)\n    EPC = np.zeros(n_max)\n    m_hh = np.zeros(n_max)\n    m_lh = np.zeros(n_max)\n    m_so = np.zeros(n_max)\n    Ppz = np.zeros(n_max)\n    Ppz_Psp = np.zeros(n_max)\n    Ppz_Psp0 = np.zeros(n_max)\n    pol_surf_char = np.zeros(n_max)\n    pol_surf_char1 = np.zeros(n_max)\n    x_max = model.dx * n_max\n    if config.strain:\n        if model.mat_crys_strc == ""Zincblende"":\n            EXX = (model.a0_sub - model.a0) / model.a0\n            EZZ = -2.0 * model.C12 / model.C11 * EXX\n            ZETA = -model.B / 2.0 * (EXX + EXX - 2.0 * EZZ)\n            CNIT = model.Ac * (EXX + EXX + EZZ)\n            VNIT = -model.Av * (EXX + EXX + EZZ)\n        if model.mat_crys_strc == ""Wurtzite"":\n            EXX = (model.a0_sub - model.a0_wz) / model.a0_wz\n            # EXX= (4.189*1e-10-model.a0_wz)/model.a0_wz\n            EZZ = -2.0 * model.C13 / model.C33 * EXX\n            CNIT = model.Ac * (EXX + EXX + EZZ)\n            ZETA = model.D2 * (EXX + EXX) + model.D1 * EZZ\n            VNIT = model.D4 * (EXX + EXX) + model.D3 * EZZ\n            Ppz = (model.D31 * (model.C11 + model.C12) + model.D33 * model.C13) * (\n                EXX + EXX\n            ) + (2 * model.D31 * model.C13 + model.D33 * model.C33) * (EZZ)\n\n            """"""\n            E31=(C11+C12)*D31+C13*D33\n            E33=2*C13*D31+C33*D33\n            print(\'E31=\',E31,\'E33=\',E33)\n            Ppz2=2*EXX*(E31-E33*C13/C33)\n            print(\'Pps2=\',Ppz2)\n            """"""\n            dx = x_max / n_max\n            sum_1 = 0.0\n            sum_2 = 0.0\n            if config.piezo:\n                """""" Spontaneous and piezoelectric polarization built-in field \n                [1] F. Bernardini and V. Fiorentini phys. stat. sol. (b) 216, 391 (1999)\n                [2] Book \'Quantum Wells,Wires & Dots\', Paul Harrison, pages 236-241""""""\n                for J in range(1, model.N_wells_virtual2 - 1):\n                    BW = model.Well_boundary2[J, 0]\n                    WB = model.Well_boundary2[J, 1]\n                    Lw = (WB - BW) * dx\n                    lb1 = (BW - model.Well_boundary2[J - 1, 1]) * dx\n                    # lb2=(Well_boundary2[J+1,0]-WB)*dx\n                    sum_1 += (model.Psp[BW + 1] + Ppz[BW + 1]) * Lw / model.eps[\n                        BW + 1\n                    ] + (model.Psp[BW - 1] + Ppz[BW - 1]) * lb1 / model.eps[BW - 1]\n                    sum_2 += Lw / model.eps[BW + 1] + lb1 / model.eps[BW - 1]\n                EPC = (sum_1 - (model.Psp + Ppz) * sum_2) / (model.eps * sum_2)\n            if config.piezo1:\n                pol_surf_char = np.zeros(n_max)\n                pol_surf_char1 = np.zeros(n_max)\n                for i in range(0, n_max):\n                    pol_surf_char[i] = (model.Psp[i] + Ppz[i]) / (q)\n                for i in range(1, n_max - 1):\n                    pol_surf_char1[i] = (\n                        (model.Psp[i - 1] + Ppz[i - 1])\n                        - (model.Psp[i + 1] + Ppz[i + 1])\n                    ) / (q)\n                for i in range(1, n_max - 1):\n                    Ppz_Psp0[i] = (pol_surf_char[i] - pol_surf_char[i - 1]) / (dx)\n                for I in range(1, model.N_wells_virtual2 - 1):\n                    BW = model.Well_boundary2[I, 0]\n                    WB = model.Well_boundary2[I, 1]\n                    Ppz_Psp[WB] = (pol_surf_char[WB + 1] - pol_surf_char[WB - 1]) / (dx)\n                    Ppz_Psp[BW] = (pol_surf_char[BW + 1] - pol_surf_char[BW - 1]) / (dx)\n                Ppz_Psp0[0] = (pol_surf_char[0] - 0.0) / (dx)\n\n                Ppz_Psp0[n_max - 1] = (0.0 - pol_surf_char[n_max - 1]) / (dx)\n                """"""\n                xaxis = np.arange(0,n_max)*dx\n                pl.plot(xaxis*1e6,Ppz_Psp0,\'r\')#,xaxis*1e6,Ppz_Psp0,\'b\'\n                pl.xlabel(\'x [um]\')\n                pl.ylabel(\'Energy [eV]\')\n                pl.title(\'pze (0 (red) & 1 (bleu)) vs Position\', fontsize=12)\n                pl.legend((\'Efn\',\'Efp\'),loc=\'best\',fontsize=12)\n                pl.grid(True)\n                pl.show()\n                ggggggggggggg\n                """"""\n    if config.piezo1 and not (config.strain):\n        if model.mat_crys_strc == ""Zincblende"":\n            EXX = (model.a0_sub - model.a0) / model.a0\n            EZZ = -2.0 * model.C12 / model.C11 * EXX\n        if model.mat_crys_strc == ""Wurtzite"":\n            EXX = (model.a0_sub - model.a0_wz) / model.a0_wz\n            EZZ = -2.0 * model.C13 / model.C33 * EXX\n        dx = x_max / n_max\n        Ppz = (model.D31 * (model.C11 + model.C12) + model.D33 * model.C13) * (\n            EXX + EXX\n        ) + (2 * model.D31 * model.C13 + model.D33 * model.C33) * (EZZ)\n        pol_surf_char = np.zeros(n_max)\n        pol_surf_char1 = np.zeros(n_max)\n        for i in range(0, n_max):\n            pol_surf_char[i] = (model.Psp[i] + Ppz[i]) / (q)\n        for i in range(1, n_max - 1):\n            Ppz_Psp0[i] = (pol_surf_char[i] - pol_surf_char[i - 1]) / (dx)\n        for i in range(1, n_max - 1):\n            pol_surf_char1[i] = (\n                (model.Psp[i - 1] + Ppz[i - 1]) - (model.Psp[i + 1] + Ppz[i + 1])\n            ) / (q)\n        for I in range(1, model.N_wells_virtual2 - 1):\n            BW = model.Well_boundary2[I, 0]\n            WB = model.Well_boundary2[I, 1]\n            Ppz_Psp[WB] = (pol_surf_char[WB + 1] - pol_surf_char[WB - 1]) / (dx)\n            Ppz_Psp[BW] = (pol_surf_char[BW + 1] - pol_surf_char[BW - 1]) / (dx)\n    if model.mat_crys_strc == ""Zincblende"":\n        for i in range(0, n_max, 1):\n            if EXX[i] != 0:\n                S[i] = ZETA[i] / model.delta[i]\n                k1[i] = sqrt(1 + 2 * S[i] + 9 * S[i] ** 2)\n                k2[i] = S[i] - 1 + k1[i]\n                k3[i] = S[i] - 1 - k1[i]\n                fp[i] = (2 * S[i] * (1 + 1.5 * k2[i]) + 6 * S[i] ** 2) / (\n                    0.75 * k2[i] ** 2 + k2[i] - 3 * S[i] ** 2\n                )\n                fm[i] = (2 * S[i] * (1 + 1.5 * k3[i]) + 6 * S[i] ** 2) / (\n                    0.75 * k3[i] ** 2 + k3[i] - 3 * S[i] ** 2\n                )\n        m_hh = m_e / (model.GA1 - 2 * model.GA2)\n        m_lh = m_e / (model.GA1 + 2 * fp * model.GA2)\n        m_so = m_e / (model.GA1 + 2 * fm * model.GA2)\n    if model.mat_crys_strc == ""Wurtzite"":\n        m_hh = -m_e / (model.A2 + model.A4 - model.A5)\n        m_lh = -m_e / (model.A2 + model.A4 + model.A5)\n        m_so = -m_e / (model.A2)\n    return m_hh, m_lh, m_so, VNIT, ZETA, CNIT, Ppz_Psp0, EPC, pol_surf_char\n\n\ndef calc_E_state_general(\n    HUPMAT3_reduced_list,\n    HUPMATC1,\n    subnumber_h,\n    subnumber_e,\n    fitot,\n    fitotc,\n    model,\n    Well_boundary,\n    UNIM,\n    RATIO,\n):\n    n_max = model.n_max\n    n_max_general = np.zeros(model.N_wells_virtual, dtype=int)\n    # HUPMAT3=np.zeros((n_max*3, n_max*3))\n    # HUPMAT3=VBMAT_V(HUPMAT1,fitot,RATIO,n_max,UNIM)\n    HUPMATC3 = CBMAT_V(HUPMATC1, fitotc, RATIO, n_max, UNIM)\n    # stop\n    tmp1 = np.zeros((model.N_wells_virtual, n_max))\n    KPV1 = np.zeros((model.N_wells_virtual, subnumber_e))\n    V1 = np.zeros((model.N_wells_virtual, n_max, n_max))\n    V11 = np.zeros((model.N_wells_virtual, n_max, n_max))\n    for J in range(1, model.N_wells_virtual - 1):\n        n_max_general[J] = Well_boundary[J + 1, 0] - Well_boundary[J - 1, 1]\n        I1, I2, I11, I22 = amort_wave(J, Well_boundary, n_max)\n        i_1 = I2 - I1\n        i1 = I1 - I1\n        i2 = I2 - I1\n        la1, v1 = linalg.eigh(HUPMATC3[I1:I2, I1:I2])\n        tmp1[J, i1:i2] = la1 / RATIO * J2meV\n        V1[J, i1:i2, i1:i2] = v1\n        if max(tmp1[J, 0:subnumber_e]) > max(fitotc[I11:I22]) * J2meV and 1 == 2:\n            logger.warning(\n                "":You may experience convergence problem due to unconfined states.""\n            )\n    """""" \n    for j in range(1,model.N_wells_virtual-1):            \n        for i in range(0,subnumber_e,1):\n            KPV1[j,i]=tmp1[j,i]\n    """"""\n    for j in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(j, Well_boundary, n_max)\n        i_1 = I2 - I1\n        i1 = I1 - I1\n        i2 = I2 - I1\n        i11 = I11 - I1\n        i22 = I22 - I1\n        couter = 0\n        for i in range(i1, i2):\n            wfe_pow1 = np.cumsum(\n                V1[j, i11:i22, i] * V1[j, i11:i22, i]\n            )  # and tmp1[j,i]<max(fitotc[I11-1:I22+1])*J2meV\n            if (\n                (tmp1[j, i] > min(fitotc[I11 - 1 : I22 + 1]) * J2meV)\n                and couter + 1 <= subnumber_e\n                and (wfe_pow1[i22 - i11 - 1] > 1e-1)\n            ):\n                KPV1[j, couter] = tmp1[j, i]\n                V11[j, i1:i2, couter] = V1[j, i1:i2, i]\n                couter += 1\n        if couter > subnumber_e:\n            print(""For this QW, the number confined states of e-levels is: "", couter)\n    KPV2 = np.zeros((model.N_wells_virtual, subnumber_h))\n\n    V22 = np.zeros((model.N_wells_virtual, 3 * n_max, 3 * n_max))\n    n_max_general3 = np.zeros(model.N_wells_virtual, int)\n    wfh_general3 = np.zeros((model.N_wells_virtual, n_max, n_max))\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, Well_boundary, n_max)\n        i_1 = I2 - I1\n\n        V2 = np.zeros((model.N_wells_virtual, i_1 * 3, i_1 * 3))\n        tmp = np.zeros((model.N_wells_virtual, i_1 * 3))\n        # HUPMAT3_general=np.zeros((i_1*3,i_1*3))\n        HUPMAT3_general_2 = np.zeros((i_1 * 3, i_1 * 3))\n        i1 = I1 - I1\n        i2 = I2 - I1\n        HUPMAT3_general_2 = HUPMAT3_reduced_list[k - 1]\n        HUPMAT3_general_2 = VBMAT_V_2(HUPMAT3_general_2, fitot, RATIO, i_1, I1, UNIM)\n        la2, v2 = linalg.eigh(HUPMAT3_general_2)\n        tmp[k, i1 : i2 * 3] = -la2 / RATIO * J2meV\n        V2[k, i1 : i2 * 3, i1 : i2 * 3] = v2\n\n        if max(tmp[k, 0:subnumber_h]) > max(fitot[I11:I22]) * J2meV and 1 == 2:\n            logger.warning(\n                "":You may experience convergence problem due to unconfined states.""\n            )\n        i11 = I11 - I1\n        i22 = I22 - I1\n        n_max_general3[k] = int(I2 - I1)\n        wfh1s3 = np.zeros((i2, 3, n_max_general3[k]))\n        maxwfh = np.zeros((i2, 3))\n        couter1 = 0\n        for i in range(i1, i2):\n            for kk in range(0, 3):\n                wfh1s3[i, kk, :] = V2[\n                    k, kk * n_max_general3[k] : (kk + 1) * n_max_general3[k], i\n                ]\n                wfh_pow = np.cumsum(wfh1s3[i, kk, :] * wfh1s3[i, kk, :])\n                maxwfh[i, kk] = wfh_pow[n_max_general3[k] - 1]\n            if np.argmax(maxwfh[i, :]) == 0:\n                wfh_general3[k, i, 0 : n_max_general3[k]] = wfh1s3[\n                    i, np.argmax(maxwfh[i, :]), :\n                ]\n            elif np.argmax(maxwfh[i, :]) == 1:\n                wfh_general3[k, i, 0 : n_max_general3[k]] = wfh1s3[\n                    i, np.argmax(maxwfh[i, :]), :\n                ]\n            else:\n                wfh_general3[k, i, 0 : n_max_general3[k]] = wfh1s3[\n                    i, np.argmax(maxwfh[i, :]), :\n                ]\n            wfh_pow1 = np.cumsum(\n                wfh_general3[k, i, i11:i22] * wfh_general3[k, i, i11:i22]\n            )  # tmp[k,i]<max(fitot[I11-1:I22+1])*J2meV and\n\n            if (\n                (tmp[k, i] > min(fitot[I11 - 1 : I22 + 1]) * J2meV)\n                and couter1 + 1 <= subnumber_h\n                and (wfh_pow1[i22 - i11 - 1] > 1e-1)\n            ):\n                # print(wfh_pow1[i22-i11-1],\'!=0\')\n                # print(max(fitot[I11-1:I22+1])*J2meV ,\'>\',tmp[j,i],\'>\',min(fitot[I11-1:I22+1])*J2meV)\n                KPV2[k, couter1] = tmp[k, i]\n                V22[k, i1 : i2 * 3, couter1] = V2[k, i1 : i2 * 3, i]\n                couter1 += 1\n        if couter1 > subnumber_h:\n            print(""For this QW, the number confined states of h-levels is: "", couter1)\n    """"""\n    for j in range(1,model.N_wells_virtual-1):            \n        for i in range(0,subnumber_h,1):\n            KPV2[j,i]=tmp[j,i]    \n    """"""\n    return KPV1, V11, KPV2, V22\n\n\ndef Main_Str_Array(model):\n    n_max = model.n_max\n    # HUPMAT1=np.zeros((n_max*3, n_max*3))\n    # HUPMATC1=np.zeros((n_max, n_max))\n    x_max = model.dx * n_max\n    m_hh, m_lh, m_so, VNIT, ZETA, CNIT, Ppz_Psp, EPC, pol_surf_char = Strain_and_Masses(\n        model\n    )\n    UNIM = np.identity(n_max)\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n    AC1 = (n_max + 1) ** 2\n    AP1, AP2, AP3, AP4, AP5, AP6, FH, FL, FSO, Pce, GDELM, DEL3, DEL1, DEL2 = qsv(\n        model.GA1,\n        model.GA2,\n        model.GA3,\n        RATIO,\n        VNIT,\n        ZETA,\n        CNIT,\n        AC1,\n        n_max,\n        model.delta,\n        model.A1,\n        model.A2,\n        model.A3,\n        model.A4,\n        model.A5,\n        model.A6,\n        model.delta_so,\n        model.delta_cr,\n        model.mat_crys_strc,\n    )\n    KP = 0.0\n    KPINT = 0.01\n    if model.mat_crys_strc == ""Zincblende"" and (model.N_wells_virtual - 2 != 0):\n        HUPMAT1 = VBMAT1(\n            KP,\n            AP1,\n            AP2,\n            AP3,\n            AP4,\n            AP5,\n            AP6,\n            FH,\n            FL,\n            FSO,\n            GDELM,\n            x_max,\n            n_max,\n            AC1,\n            UNIM,\n            KPINT,\n        )\n        HUPMATC1 = CBMAT(KP, Pce, model.cb_meff / m_e, x_max, n_max, AC1, UNIM, KPINT)\n    if model.mat_crys_strc == ""Wurtzite"" and (model.N_wells_virtual - 2 != 0):\n        HUPMAT1 = -VBMAT2(\n            KP,\n            AP1,\n            AP2,\n            AP3,\n            AP4,\n            AP5,\n            AP6,\n            FH,\n            FL,\n            x_max,\n            n_max,\n            AC1,\n            UNIM,\n            KPINT,\n            DEL3,\n            DEL1,\n            DEL2,\n        )\n        HUPMATC1 = CBMAT(KP, Pce, model.cb_meff / m_e, x_max, n_max, AC1, UNIM, KPINT)\n    return HUPMAT1, HUPMATC1, m_hh, m_lh, m_so, Ppz_Psp, pol_surf_char\n\n\ndef Schro(\n    HUPMAT3_reduced_list,\n    HUPMATC1,\n    subnumber_h,\n    subnumber_e,\n    fitot,\n    fitotc,\n    model,\n    Well_boundary,\n    UNIM,\n    RATIO,\n    m_hh,\n    m_lh,\n    m_so,\n    n_max,\n):\n    # V1=np.zeros((model.N_wells_virtual,n_max,n_max))\n    # V2=np.zeros((model.N_wells_virtual,n_max*3,n_max*3))\n    n_max_general = np.zeros(model.N_wells_virtual, dtype=int)\n    wfh_general = np.zeros((model.N_wells_virtual, subnumber_h, n_max))\n    wfe_general = np.zeros((model.N_wells_virtual, subnumber_e, n_max))\n    meff_statec_general = np.zeros((model.N_wells_virtual, subnumber_e))\n    meff_state_general = np.zeros((model.N_wells_virtual, subnumber_h))\n    E_statec_general, V1, E_state_general, V2 = calc_E_state_general(\n        HUPMAT3_reduced_list,\n        HUPMATC1,\n        subnumber_h,\n        subnumber_e,\n        fitot,\n        fitotc,\n        model,\n        Well_boundary,\n        UNIM,\n        RATIO,\n    )\n    for j in range(1, model.N_wells_virtual - 1):\n        wfh_general_tmp = np.zeros((model.N_wells_virtual, subnumber_h, n_max))\n        wfe_general_tmp = np.zeros((model.N_wells_virtual, subnumber_e, n_max))\n        wfh_general_tmp, wfe_general_tmp, list, n_max_general = wave_func_tri(\n            j, Well_boundary, n_max, V1, V2, subnumber_h, subnumber_e, model\n        )\n        wfh_general[j, :, :] += wfh_general_tmp[j, :, :]\n        wfe_general[j, :, :] += wfe_general_tmp[j, :, :]\n        meff_statec, meff_state = calc_meff_state_general(\n            wfh_general[j, :, :],\n            wfe_general[j, :, :],\n            model,\n            fitotc,\n            E_statec_general[j, :],\n            list,\n            m_hh,\n            m_lh,\n            m_so,\n            int(n_max_general[j]),\n            j,\n            Well_boundary,\n            n_max,\n        )\n        meff_statec_general[j, :], meff_state_general[j, :] = meff_statec, meff_state\n    return (\n        E_statec_general,\n        E_state_general,\n        wfe_general,\n        wfh_general,\n        meff_statec_general,\n        meff_state_general,\n    )\n\n\ndef Poisson_Schrodinger(model):\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an object with the following attributes:\n    fi_e - Bandstructure potential (J) (array, len n_max)\n    cb_meff - conduction band effective mass (kg)(array, len n_max)\n    eps - dielectric constant (including eps0) (array, len n_max)\n    dop - doping distribution (m**-3) ( array, len n_max)\n    Fapp - Applied field (Vm**-1)\n    T - Temperature (K)\n    comp_scheme - simulation scheme (currently unused)\n    subnumber_e - number of subbands for look for in the conduction band\n    dx - grid spacing (m)\n    n_max - number of points.\n    """"""\n    fi_e = model.fi_e\n    cb_meff = model.cb_meff\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    vmax = model.vmax\n    vmin = model.vmin\n    Each_Step = model.Each_Step\n    surface = model.surface\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_h = model.subnumber_h\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n    if comp_scheme in (4, 5, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include exchange interactions\n        in its valence band calculations.""""""\n        )\n        exit()\n    if comp_scheme in (1, 3, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include nonparabolicity effects in \n        its valence band calculations.""""""\n        )\n        exit()\n    fi_h = model.fi_h\n    N_wells_virtual = model.N_wells_virtual\n    Well_boundary = model.Well_boundary\n    Ppz_Psp = np.zeros(n_max)\n    """"""\n    HUPMAT1=np.zeros((n_max*3, n_max*3))\n    """"""\n    HUPMATC1 = np.zeros((n_max, n_max))\n\n    UNIM = np.identity(n_max)\n    x_max = dx * n_max\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n    HUPMAT3_reduced_list = []\n    if model.N_wells_virtual - 2 != 0:\n        HUPMAT1, HUPMATC1, m_hh, m_lh, m_so, Ppz_Psp, pol_surf_char = Main_Str_Array(\n            model\n        )\n        for k in range(1, model.N_wells_virtual - 1):\n            I1, I2, I11, I22 = amort_wave(k, Well_boundary, n_max)\n            i_1 = I2 - I1\n            HUPMAT3_reduced = np.zeros((i_1 * 3, i_1 * 3))\n            i1 = I1 - I1\n            i2 = I2 - I1\n            HUPMAT3_reduced[i1:i2, i1:i2] = HUPMAT1[I1:I2, I1:I2]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1:i2] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1:I2\n            ]\n            HUPMAT3_reduced[i1:i2, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1:I2, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced[i1 + i_1 * 2 : i2 + i_1 * 2, i1:i2] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1:I2\n            ]\n            HUPMAT3_reduced[i1:i2, i1 + i_1 * 2 : i2 + i_1 * 2] = HUPMAT1[\n                I1:I2, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[\n                i1 + i_1 * 2 : i2 + i_1 * 2, i1 + i_1 * 2 : i2 + i_1 * 2\n            ] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1 + i_1 * 2 : i2 + i_1 * 2] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[i1 + i_1 * 2 : i2 + i_1 * 2, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced_list.append(HUPMAT3_reduced)\n    else:\n        (\n            m_hh,\n            m_lh,\n            m_so,\n            VNIT,\n            ZETA,\n            CNIT,\n            Ppz_Psp,\n            EPC,\n            pol_surf_char,\n        ) = Strain_and_Masses(model)\n    # Check\n    if comp_scheme == 6:\n        logger.warning(\n            """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        )\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_h  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_h  # Number of carriers in subbands\n    E_statec = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_statec = [0.0] * subnumber_e  # Number of carriers in subbands\n    # Preparing empty subband energy arrays for multiquantum wells.\n    E_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Energies of subbands/levels (meV)\n    N_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Number of carriers in subbands\n    E_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Energies of subbands/levels (meV)\n    N_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Number of carriers in subbands\n    meff_statec_general = np.zeros((model.N_wells_virtual, subnumber_e))\n    meff_state_general = np.zeros((model.N_wells_virtual, subnumber_h))\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    fitotc = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potentia\n    # eps = np.zeros(n_max+2)\t    #dielectric constant\n    # dop = np.zeros(n_max+2)\t    #doping distribution\n    # sigma = np.zeros(n_max+2)      #charge distribution (donors + free charges)\n    # F = np.zeros(n_max+2)          #Electric Field\n    # Vapp = np.zeros(n_max+2)       #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for holes list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n    wfh = np.zeros((subnumber_h, n_max))\n    wfe = np.zeros((subnumber_e, n_max))\n    wfh_general = np.zeros((model.N_wells_virtual, subnumber_h, n_max))\n    wfe_general = np.zeros((model.N_wells_virtual, subnumber_e, n_max))\n    (\n        E_statec_general0,\n        E_state_general0,\n        wfe_general0,\n        wfh_general0,\n        meff_statec_general0,\n        meff_state_general0,\n    ) = (\n        E_statec_general,\n        E_state_general,\n        wfe_general,\n        wfh_general,\n        meff_statec_general,\n        meff_state_general,\n    )\n    E_F_general = np.zeros(model.N_wells_virtual)\n    sigma_general = np.zeros(n_max)\n    F_general = np.zeros(n_max)\n    Vnew_general = np.zeros(n_max)\n    fi = np.zeros(n_max)\n    fi_stat = np.zeros(n_max)\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    Vapp = calc_potn(Fapp * eps0 / eps, model)\n    Vapp[n_max - 1] -= Vapp[\n        n_max // 2\n    ]  # Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # s\n    # setting up Ldi and Ld p and n\n    Ld_n_p = np.zeros(n_max)\n    Ldi = np.zeros(n_max)\n    Nc = np.zeros(n_max)\n    Nv = np.zeros(n_max)\n    vb_meff = np.zeros(n_max)\n    ni = np.zeros(n_max)\n    n = np.zeros(n_max)\n    p = np.zeros(n_max)\n    hbark = hbar * 2 * pi\n    for i in range(n_max):\n        vb_meff[i] = (m_hh[i] ** (3 / 2) + m_lh[i] ** (3 / 2)) ** (2 / 3)\n    Nc = 2 * (2 * pi * cb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Nv = 2 * (2 * pi * vb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Half_Eg = np.zeros(n_max)\n    Eg_ = np.zeros(n_max)\n    ns1 = np.linalg.norm(dop, np.inf)\n    ns2 = np.linalg.norm(Ppz_Psp, np.inf)\n    ns = max(ns1, ns2)\n    offset0 = 0.0\n    offset1 = 0.0\n    for i in range(n_max):\n        ni[i] = sqrt(\n            Nc[i] * Nv[i] * exp(-(fi_e[i] - fi_h[i]) / (kb * T))\n        )  # Intrinsic carrier concentration [1/m^3]\n        if dop[i] == 1:\n            dop[i] *= ni[i]\n        Ld_n_p[i] = sqrt(eps[i] * Vt / (q * abs(dop[i])))\n        Ldi[i] = sqrt(eps[i] * Vt / (q * ns * ni[i]))\n        Half_Eg[i] = (fi_e[i] - fi_h[i]) / 2\n        Eg_[i] = fi_e[i] - fi_h[i]\n\n        fi_e[i] = Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n        fi_h[i] = -Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n    """"""\n    fi_e-=fi_e[0]\n    fi_h-=fi_e[0]\n    \n    fi_e+=offset0+offset1#+kb*T*np.log(Nv/Nc)/2\n    fi_h+=offset0+offset1#+kb*T*np.log(Nv/Nc)/2\n    \n    \n    pl.plot(xaxis, Half_Eg/q,\'k\')\n    pl.xlabel(\'Position (m)\')\n    pl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\n    pl.title(\'electrons (red) and holes (blue)\')\n    pl.grid(True)\n    """"""\n    if dx > min(Ld_n_p[:]) and 1 == 2:\n        logger.error(\n            """"""You are setting the grid size %g nm greater than the extrinsic Debye lengths %g nm"""""",\n            dx * 1e9,\n            min(Ld_n_p[:]) * 1e9,\n        )\n        # exit()\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    # previousE0= 0   (meV) energy of zeroth state for previous iteration(for testing convergence)\n    previousfi0 = 0  # (meV) energy of  for previous iteration(for testing convergence)\n    fitot = fi_h  # + Vapp #For initial iteration sum bandstructure and applied field\n    fitotc = fi_e  # + Vapp\n    # initializing Stern damping method variables\n    r = 0.0\n    w_n_minus_max = 1.0\n    w_n_max = 0.0\n    w_n = np.zeros(n_max)\n    damping_n_plus = 0.1\n    damping_n = 0.1\n    Ppz_Psp0 = Ppz_Psp\n    EF = 0.0\n\n    if config.predic_correc:\n        print(""Predictor\xe2\x80\x93corrector method is activated"")\n    while True:\n        if model.comp_scheme == 9:\n            break\n        print(""Iteration:"", iteration)\n        if not (config.messagesoff):\n            logger.info(""Iteration: %d"", iteration)\n        if model.N_wells_virtual - 2 != 0:\n            if config.predic_correc and iteration == 1:\n                (\n                    E_statec_general,\n                    E_state_general,\n                    wfe_general,\n                    wfh_general,\n                    meff_statec_general,\n                    meff_state_general,\n                ) = Schro(\n                    HUPMAT3_reduced_list,\n                    HUPMATC1,\n                    subnumber_h,\n                    subnumber_e,\n                    fitot,\n                    fitotc,\n                    model,\n                    Well_boundary,\n                    UNIM,\n                    RATIO,\n                    m_hh,\n                    m_lh,\n                    m_so,\n                    n_max,\n                )\n            elif not(config.predic_correc):\n                (\n                    E_statec_general,\n                    E_state_general,\n                    wfe_general,\n                    wfh_general,\n                    meff_statec_general,\n                    meff_state_general,\n                ) = Schro(\n                    HUPMAT3_reduced_list,\n                    HUPMATC1,\n                    subnumber_h,\n                    subnumber_e,\n                    fitot,\n                    fitotc,\n                    model,\n                    Well_boundary,\n                    UNIM,\n                    RATIO,\n                    m_hh,\n                    m_lh,\n                    m_so,\n                    n_max,\n                )\n            damping = 0.15  # 0.1 works between high and low doping\n        else:\n            damping = 1\n        n, p, fi, EF, fi_stat = Poisson_equi2(\n            ns,\n            fitotc,\n            fitot,\n            Nc,\n            Nv,\n            fi_e,\n            fi_h,\n            n,\n            p,\n            dx,\n            Ldi,\n            dop,\n            Ppz_Psp0,\n            pol_surf_char,\n            ni,\n            n_max,\n            iteration,\n            fi,\n            Vt,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            surface,\n            fi_stat,\n        )\n        #\n        if comp_scheme in (0, 1):\n            # if we are not self-consistently including Poisson Effects then only do one loop\n            break\n        """"""\n        # Combine band edge potential with potential due to charge distribution\n        # To increase convergence, we calculate a moving average of electric potential \n        #with previous iterations. By dampening the corrective term, we avoid oscillations.\n        #tryng new dmping method \n        F. Stern, J. Computational Physics 6, 56 (1970).\n        #the extrapolated-convergence-factor method instead of the fixed-convergence-factor method\n        """"""\n        Vnew_general = -Vt * q * fi\n        w_n = Vnew_general - V\n        w_n_max = max(abs(w_n[:])) * J2meV\n        r = w_n_max / w_n_minus_max\n        w_n_minus_max = w_n_max\n        damping_n_plus = damping_n / (1 - abs(r))\n        damping_n = damping_n_plus\n        if config.Stern_damping:\n            V += damping_n_plus * (w_n)\n        else:\n            V += damping * (w_n)\n        fitot = fi_h + V + Vapp\n        fitotc = fi_e + V + Vapp\n        xaxis = np.arange(0, n_max) * dx\n        delta0 = V - Vnew_general\n        delta_max0 = max(abs(delta0[:]))\n        # print(\'w_n_max=\',w_n_max)\n        # print(\'r=\',r)\n        # print(\'damping_n=\',damping_n)\n        # print(\'damping_n_plus=\',damping_n_plus)\n        # print(\'w_n_minus_max=\',w_n_minus_max)\n        print(""error_potential="", delta_max0 * J2meV, ""meV"")\n        if config.predic_correc:\n            delta1 = Vnew_general - previousfi0\n            delta_max1 = max(abs(delta1[:]))\n            if delta_max1 / q < convergence_test0:  # Convergence test\n                # print(\'error=\',abs(E_state_general[1,0]-previousE0)/1e3)\n                # if abs(E_state_general[1,0]-previousE0)/1e3 < convergence_test: #Convergence test\n                if model.N_wells_virtual - 2 != 0:\n                    (\n                        E_statec_general,\n                        E_state_general,\n                        wfe_general,\n                        wfh_general,\n                        meff_statec_general,\n                        meff_state_general,\n                    ) = Schro(\n                        HUPMAT3_reduced_list,\n                        HUPMATC1,\n                        subnumber_h,\n                        subnumber_e,\n                        fitot,\n                        fitotc,\n                        model,\n                        Well_boundary,\n                        UNIM,\n                        RATIO,\n                        m_hh,\n                        m_lh,\n                        m_so,\n                        n_max,\n                    )\n\n                break\n            elif iteration >= max_iterations:  # Iteration limit\n                logger.warning(""Have reached maximum number of iterations"")\n                break\n            else:\n                iteration += 1\n                previousfi0 = V\n        else:\n            delta1 = Vnew_general - previousfi0\n            delta_max1 = max(abs(delta1[:]))\n            if delta_max1 / q < convergence_test0:  # Convergence test\n                if model.N_wells_virtual - 2 != 0:\n                    (\n                        E_statec_general,\n                        E_state_general,\n                        wfe_general,\n                        wfh_general,\n                        meff_statec_general,\n                        meff_state_general,\n                    ) = Schro(\n                        HUPMAT3_reduced_list,\n                        HUPMATC1,\n                        subnumber_h,\n                        subnumber_e,\n                        fitot,\n                        fitotc,\n                        model,\n                        Well_boundary,\n                        UNIM,\n                        RATIO,\n                        m_hh,\n                        m_lh,\n                        m_so,\n                        n_max,\n                    )\n\n                break\n            elif iteration >= max_iterations:  # Iteration limit\n                logger.warning(""Have reached maximum number of iterations"")\n                break\n            else:\n                iteration += 1\n                previousfi0 = V\n                # END OF SELF-CONSISTENT LOOP\n    (\n        Ec_result,\n        Ev_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        fi_result,\n    ) = Write_results_equi2(ns, fitotc, fitot, Vt, q, ni, n, p, dop, dx, Ldi, fi, n_max)\n    time3 = time.time()  # timing audit\n    if not (config.messagesoff):\n        logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n    results.N_wells_virtual = N_wells_virtual\n    results.Well_boundary = Well_boundary\n    results.xaxis = xaxis\n    results.wfh = wfh\n    results.wfe = wfe\n    results.fitot = fitot\n    results.fitotc = fitotc\n    results.fi_e = fi_e\n    results.fi_h = fi_h\n    # results.sigma = sigma\n    results.sigma_general = sigma_general\n    # results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    # results.meff_state = meff_state\n    results.E_statec = E_statec\n    results.N_statec = N_statec\n    # results.meff_statec = meff_statec\n    results.F_general = F_general\n    results.E_state_general = E_state_general\n    results.N_state_general = N_state_general\n    results.meff_state_general = meff_state_general\n    results.E_statec_general = E_statec_general\n    results.N_statec_general = N_statec_general\n    results.meff_statec_general = meff_statec_general\n    results.wfh_general = wfh_general\n    results.wfe_general = wfe_general\n\n    results.E_state_general0 = E_state_general0\n    results.E_statec_general0 = E_statec_general0\n    results.meff_state_general0 = meff_state_general0\n    results.meff_statec_general0 = meff_statec_general0\n    results.wfh_general0 = wfh_general0\n    results.wfe_general0 = wfe_general0\n    results.Fapp = Fapp\n    results.T = T\n    # results.E_F = E_F\n    results.E_F_general = E_F_general\n    results.dx = dx\n    results.subnumber_h = subnumber_h\n    results.subnumber_e = subnumber_e\n    results.Ntotal2d = Ntotal2d\n    ########################\n    results.Ec_result = Ec_result\n    results.Ev_result = Ev_result\n    results.ro_result = ro_result\n    results.el_field1_result = el_field1_result\n    results.el_field2_result = el_field2_result\n    results.nf_result = nf_result\n    results.pf_result = pf_result\n    results.fi_result = fi_result\n    results.EF = EF\n    results.HUPMAT3_reduced_list = HUPMAT3_reduced_list\n    results.m_hh = m_hh\n    results.m_lh = m_lh\n    results.m_so = m_so\n    results.Ppz_Psp = Ppz_Psp\n    results.pol_surf_char = pol_surf_char\n    results.HUPMATC1 = HUPMATC1\n    ##########################\n    return results\n\ndef Poisson_Schrodinger_new(model):\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an object with the following attributes:\n    fi_e - Bandstructure potential (J) (array, len n_max)\n    cb_meff - conduction band effective mass (kg)(array, len n_max)\n    eps - dielectric constant (including eps0) (array, len n_max)\n    dop - doping distribution (m**-3) ( array, len n_max)\n    Fapp - Applied field (Vm**-1)\n    T - Temperature (K)\n    comp_scheme - simulation scheme (currently unused)\n    subnumber_e - number of subbands for look for in the conduction band\n    dx - grid spacing (m)\n    n_max - number of points.\n    """"""\n    fi_e = model.fi_e\n    cb_meff = model.cb_meff\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    surface = model.surface\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_h = model.subnumber_h\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n    if comp_scheme in (4, 5, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include exchange interactions\n        in its valence band calculations.""""""\n        )\n        exit()\n    if comp_scheme in (1, 3, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include nonparabolicity effects in \n        its valence band calculations.""""""\n        )\n        exit()\n    fi_h = model.fi_h\n    N_wells_virtual = model.N_wells_virtual\n    Well_boundary = model.Well_boundary\n    Ppz_Psp = np.zeros(n_max)\n    HUPMATC1 = np.zeros((n_max, n_max))\n    UNIM = np.identity(n_max)\n    x_max = dx * n_max\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n    HUPMAT3_reduced_list = []\n    if model.N_wells_virtual - 2 != 0:\n        HUPMAT1, HUPMATC1, m_hh, m_lh, m_so, Ppz_Psp, pol_surf_char = Main_Str_Array(\n            model\n        )\n        for k in range(1, model.N_wells_virtual - 1):\n            I1, I2, I11, I22 = amort_wave(k, Well_boundary, n_max)\n            i_1 = I2 - I1\n            HUPMAT3_reduced = np.zeros((i_1 * 3, i_1 * 3))\n            i1 = I1 - I1\n            i2 = I2 - I1\n            HUPMAT3_reduced[i1:i2, i1:i2] = HUPMAT1[I1:I2, I1:I2]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1:i2] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1:I2\n            ]\n            HUPMAT3_reduced[i1:i2, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1:I2, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced[i1 + i_1 * 2 : i2 + i_1 * 2, i1:i2] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1:I2\n            ]\n            HUPMAT3_reduced[i1:i2, i1 + i_1 * 2 : i2 + i_1 * 2] = HUPMAT1[\n                I1:I2, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[\n                i1 + i_1 * 2 : i2 + i_1 * 2, i1 + i_1 * 2 : i2 + i_1 * 2\n            ] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[i1 + i_1 : i2 + i_1, i1 + i_1 * 2 : i2 + i_1 * 2] = HUPMAT1[\n                I1 + n_max : I2 + n_max, I1 + n_max * 2 : I2 + n_max * 2\n            ]\n            HUPMAT3_reduced[i1 + i_1 * 2 : i2 + i_1 * 2, i1 + i_1 : i2 + i_1] = HUPMAT1[\n                I1 + n_max * 2 : I2 + n_max * 2, I1 + n_max : I2 + n_max\n            ]\n            HUPMAT3_reduced_list.append(HUPMAT3_reduced)\n    else:\n        (\n            m_hh,\n            m_lh,\n            m_so,\n            VNIT,\n            ZETA,\n            CNIT,\n            Ppz_Psp,\n            EPC,\n            pol_surf_char,\n        ) = Strain_and_Masses(model)\n    # Check\n    if comp_scheme == 6:\n        logger.warning(\n            """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        )\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_h  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_h  # Number of carriers in subbands\n    E_statec = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_statec = [0.0] * subnumber_e  # Number of carriers in subbands\n    # Preparing empty subband energy arrays for multiquantum wells.\n    E_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Energies of subbands/levels (meV)\n    N_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Number of carriers in subbands\n    E_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Energies of subbands/levels (meV)\n    N_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Number of carriers in subbands\n    meff_statec_general = np.zeros((model.N_wells_virtual, subnumber_e))\n    meff_state_general = np.zeros((model.N_wells_virtual, subnumber_h))\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    fitotc = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potentia\n    # eps = np.zeros(n_max+2)\t    #dielectric constant\n    # dop = np.zeros(n_max+2)\t    #doping distribution\n    # sigma = np.zeros(n_max+2)      #charge distribution (donors + free charges)\n    # F = np.zeros(n_max+2)          #Electric Field\n    # Vapp = np.zeros(n_max+2)       #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for holes list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n    wfh = np.zeros((subnumber_h, n_max))\n    wfe = np.zeros((subnumber_e, n_max))\n    wfh_general = np.zeros((model.N_wells_virtual, subnumber_h, n_max))\n    wfe_general = np.zeros((model.N_wells_virtual, subnumber_e, n_max))\n    (\n        E_statec_general0,\n        E_state_general0,\n        wfe_general0,\n        wfh_general0,\n        meff_statec_general0,\n        meff_state_general0,\n    ) = (\n        E_statec_general,\n        E_state_general,\n        wfe_general,\n        wfh_general,\n        meff_statec_general,\n        meff_state_general,\n    )\n    E_F_general = np.zeros(model.N_wells_virtual)\n    sigma_general = np.zeros(n_max)\n    F_general = np.zeros(n_max)\n    Vnew_general = np.zeros(n_max)\n    fi = np.zeros(n_max)\n    fi_stat = np.zeros(n_max)\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    Vapp = calc_potn(Fapp * eps0 / eps, model)\n    Vapp[n_max - 1] -= Vapp[\n        n_max // 2\n    ]  # Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # s\n    # setting up Ldi and Ld p and n\n    Ld_n_p = np.zeros(n_max)\n    Ldi = np.zeros(n_max)\n    Nc = np.zeros(n_max)\n    Nv = np.zeros(n_max)\n    vb_meff = np.zeros(n_max)\n    ni = np.zeros(n_max)\n    n = np.zeros(n_max)\n    p = np.zeros(n_max)\n    hbark = hbar * 2 * pi\n    for i in range(n_max):\n        vb_meff[i] = (m_hh[i] ** (3 / 2) + m_lh[i] ** (3 / 2)) ** (2 / 3)\n    Nc = 2 * (2 * pi * cb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Nv = 2 * (2 * pi * vb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Half_Eg = np.zeros(n_max)\n    Eg_ = np.zeros(n_max)\n    ns1 = np.linalg.norm(dop, np.inf)\n    ns2 = np.linalg.norm(Ppz_Psp, np.inf)\n    ns = max(ns1, ns2)\n\n    for i in range(n_max):\n        ni[i] = sqrt(\n            Nc[i] * Nv[i] * exp(-(fi_e[i] - fi_h[i]) / (kb * T))\n        )  # Intrinsic carrier concentration [1/m^3]\n        if dop[i] == 1:\n            dop[i] *= ni[i]\n        Ld_n_p[i] = sqrt(eps[i] * Vt / (q * abs(dop[i])))\n        Ldi[i] = sqrt(eps[i] * Vt / (q * ns * ni[i]))\n        Half_Eg[i] = (fi_e[i] - fi_h[i]) / 2\n        Eg_[i] = fi_e[i] - fi_h[i]\n\n        fi_e[i] = Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n        fi_h[i] = -Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n\n    if dx > min(Ld_n_p[:]) and 1 == 2:\n        logger.error(\n            """"""You are setting the grid size %g nm greater than the extrinsic Debye lengths %g nm"""""",\n            dx * 1e9,\n            min(Ld_n_p[:]) * 1e9,\n        )\n        # exit()\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    # previousE0= 0   (meV) energy of zeroth state for previous iteration(for testing convergence)\n    previousfi0 = 0  # (meV) energy of  for previous iteration(for testing convergence)\n    fitot = fi_h  # + Vapp #For initial iteration sum bandstructure and applied field\n    fitotc = fi_e  # + Vapp\n    # initializing Stern damping method variables\n    r = 0.0\n    w_n_minus_max = 1.0\n    w_n_max = 0.0\n    w_n = np.zeros(n_max)\n    damping_n_plus = 0.1\n    damping_n = 0.1\n    Ppz_Psp0 = Ppz_Psp\n    EF = 0.0\n\n    l2 = (Vt * eps[0 : n_max - 1]) / (q * ns * xaxis[n_max - 1] ** 2)\n    class data:\n        def __init__(self):\n            self.l2 = l2\n            self.dop = dop\n            self.V = V\n            self.n = n\n            self.p = p\n            self.Ppz_Psp = Ppz_Psp\n            self.E_state_general = E_state_general\n            self.meff_state_general = meff_state_general\n            self.E_statec_general = E_statec_general\n            self.meff_statec_general = meff_statec_general\n            self.wfh_general = wfh_general\n            self.wfe_general = wfe_general\n            self.ni=ni\n\n    idata = data()\n    odata = data()\n    toll = 1e-3\n    maxit = 10\n    ptoll = 1e-10\n    pmaxit = 30\n    verbose = 0\n    v_Nnodes=np.arange(n_max)\n    idata.l2 = (Vt * eps[0 : n_max - 1]) / (q * ns )#* xaxis[n_max - 1] ** 2\n    idata.ni = ni / ns\n    idata.dop = dop / ns\n    idata.Ppz_Psp = Ppz_Psp / ns\n    if config.predic_correc:\n        print(""Predictor\xe2\x80\x93corrector method is activated"")\n    while True:\n        if model.comp_scheme == 9:\n            break\n        print(""Iteration:"", iteration)\n        if not (config.messagesoff):\n            logger.info(""Iteration: %d"", iteration)\n        if model.N_wells_virtual - 2 != 0:\n            if config.predic_correc and iteration == 1:\n                (\n                    idata.E_statec_general,\n                    idata.E_state_general,\n                    idata.wfe_general,\n                    idata.wfh_general,\n                    idata.meff_statec_general,\n                    idata.meff_state_general,\n                ) = Schro(\n                    HUPMAT3_reduced_list,\n                    HUPMATC1,\n                    subnumber_h,\n                    subnumber_e,\n                    fitot,\n                    fitotc,\n                    model,\n                    Well_boundary,\n                    UNIM,\n                    RATIO,\n                    m_hh,\n                    m_lh,\n                    m_so,\n                    n_max,\n                )\n            elif not(config.predic_correc):\n                (\n                    idata.E_statec_general,\n                    idata.E_state_general,\n                    idata.wfe_general,\n                    idata.wfh_general,\n                    idata.meff_statec_general,\n                    idata.meff_state_general,\n                ) = Schro(\n                    HUPMAT3_reduced_list,\n                    HUPMATC1,\n                    subnumber_h,\n                    subnumber_e,\n                    fitot,\n                    fitotc,\n                    model,\n                    Well_boundary,\n                    UNIM,\n                    RATIO,\n                    m_hh,\n                    m_lh,\n                    m_so,\n                    n_max,\n                )\n            damping = 0.15  # 0.1 works between high and low doping\n        else:\n            damping = 1\n        [fi,n,p,fi_stat] =DDGnlpoisson_new (idata,xaxis,v_Nnodes,fi,n,p,ptoll,pmaxit,verbose,fi_e,fi_h,model,Vt,surface,fi_stat,iteration,ns)\n        #\n        if comp_scheme in (0, 1):\n            # if we are not self-consistently including Poisson Effects then only do one loop\n            break\n        """"""\n        # Combine band edge potential with potential due to charge distribution\n        # To increase convergence, we calculate a moving average of electric potential \n        #with previous iterations. By dampening the corrective term, we avoid oscillations.\n        #tryng new dmping method \n        F. Stern, J. Computational Physics 6, 56 (1970).\n        #the extrapolated-convergence-factor method instead of the fixed-convergence-factor method\n        """"""\n        Vnew_general = -Vt * q * fi\n        w_n = Vnew_general - V\n        w_n_max = max(abs(w_n[:])) * J2meV\n        r = w_n_max / w_n_minus_max\n        w_n_minus_max = w_n_max\n        damping_n_plus = damping_n / (1 - abs(r))\n        damping_n = damping_n_plus\n        if config.Stern_damping:\n            V += damping_n_plus * (w_n)\n        else:\n            V += damping * (w_n)\n        fitot = fi_h + V + Vapp\n        fitotc = fi_e + V + Vapp\n        xaxis = np.arange(0, n_max) * dx\n        delta0 = V - Vnew_general\n        delta_max0 = max(abs(delta0[:]))\n        # print(\'w_n_max=\',w_n_max)\n        # print(\'r=\',r)\n        # print(\'damping_n=\',damping_n)\n        # print(\'damping_n_plus=\',damping_n_plus)\n        # print(\'w_n_minus_max=\',w_n_minus_max)\n        print(""error_potential="", delta_max0 * J2meV, ""meV"")\n        if config.predic_correc:\n            delta1 = Vnew_general - previousfi0\n            delta_max1 = max(abs(delta1[:]))\n            if delta_max1 / q < convergence_test0 :  # Convergence test\n                # print(\'error=\',abs(E_state_general[1,0]-previousE0)/1e3)\n                # if abs(E_state_general[1,0]-previousE0)/1e3 < convergence_test: #Convergence test\n                if model.N_wells_virtual - 2 != 0:\n                    (\n                        E_statec_general,\n                        E_state_general,\n                        wfe_general,\n                        wfh_general,\n                        meff_statec_general,\n                        meff_state_general,\n                    ) = Schro(\n                        HUPMAT3_reduced_list,\n                        HUPMATC1,\n                        subnumber_h,\n                        subnumber_e,\n                        fitot,\n                        fitotc,\n                        model,\n                        Well_boundary,\n                        UNIM,\n                        RATIO,\n                        m_hh,\n                        m_lh,\n                        m_so,\n                        n_max,\n                    )\n\n                break\n            elif iteration >= max_iterations:  # Iteration limit\n                logger.warning(""Have reached maximum number of iterations"")\n                break\n            else:\n                iteration += 1\n                previousfi0 = V\n        else:\n            delta1 = Vnew_general - previousfi0\n            delta_max1 = max(abs(delta1[:]))\n            if delta_max1 / q < convergence_test0:  # Convergence test\n                if model.N_wells_virtual - 2 != 0:\n                    (\n                        E_statec_general,\n                        E_state_general,\n                        wfe_general,\n                        wfh_general,\n                        meff_statec_general,\n                        meff_state_general,\n                    ) = Schro(\n                        HUPMAT3_reduced_list,\n                        HUPMATC1,\n                        subnumber_h,\n                        subnumber_e,\n                        fitot,\n                        fitotc,\n                        model,\n                        Well_boundary,\n                        UNIM,\n                        RATIO,\n                        m_hh,\n                        m_lh,\n                        m_so,\n                        n_max,\n                    )\n\n                break\n            elif iteration >= max_iterations:  # Iteration limit\n                logger.warning(""Have reached maximum number of iterations"")\n                break\n            else:\n                iteration += 1\n                previousfi0 = V\n                # END OF SELF-CONSISTENT LOOP\n    (\n        Ec_result,\n        Ev_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        fi_result,\n    ) = Write_results_equi2(ns, fitotc, fitot, Vt, q, ni, n*ns/ni, p*ns/ni, dop, dx, Ldi, fi, n_max)\n    time3 = time.time()  # timing audit\n    if not (config.messagesoff):\n        logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n    results.N_wells_virtual = N_wells_virtual\n    results.Well_boundary = Well_boundary\n    results.xaxis = xaxis\n    results.wfh = wfh\n    results.wfe = wfe\n    results.fitot = fitot\n    results.fitotc = fitotc\n    results.fi_e = fi_e\n    results.fi_h = fi_h\n    # results.sigma = sigma\n    results.sigma_general = sigma_general\n    # results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    # results.meff_state = meff_state\n    results.E_statec = E_statec\n    results.N_statec = N_statec\n    # results.meff_statec = meff_statec\n    results.F_general = F_general\n    results.E_state_general = E_state_general\n    results.N_state_general = N_state_general\n    results.meff_state_general = meff_state_general\n    results.E_statec_general = E_statec_general\n    results.N_statec_general = N_statec_general\n    results.meff_statec_general = meff_statec_general\n    results.wfh_general = wfh_general\n    results.wfe_general = wfe_general\n\n    results.E_state_general0 = E_state_general0\n    results.E_statec_general0 = E_statec_general0\n    results.meff_state_general0 = meff_state_general0\n    results.meff_statec_general0 = meff_statec_general0\n    results.wfh_general0 = wfh_general0\n    results.wfe_general0 = wfe_general0\n    results.Fapp = Fapp\n    results.T = T\n    # results.E_F = E_F\n    results.E_F_general = E_F_general\n    results.dx = dx\n    results.subnumber_h = subnumber_h\n    results.subnumber_e = subnumber_e\n    results.Ntotal2d = Ntotal2d\n    ########################\n    results.Ec_result = Ec_result\n    results.Ev_result = Ev_result\n    results.ro_result = ro_result\n    results.el_field1_result = el_field1_result\n    results.el_field2_result = el_field2_result\n    results.nf_result = nf_result\n    results.pf_result = pf_result\n    results.fi_result = fi_result\n    results.EF = EF\n    results.HUPMAT3_reduced_list = HUPMAT3_reduced_list\n    results.m_hh = m_hh\n    results.m_lh = m_lh\n    results.m_so = m_so\n    results.Ppz_Psp = Ppz_Psp\n    results.pol_surf_char = pol_surf_char\n    results.HUPMATC1 = HUPMATC1\n    ##########################\n    return results\n\ndef Poisson_Schrodinger_DD(result, model):\n    fi = result.fi_result\n    E_state_general = result.E_state_general\n    meff_state_general = result.meff_state_general\n    E_statec_general = result.E_statec_general\n    meff_statec_general = result.meff_statec_general\n    wfh_general = result.wfh_general\n    wfe_general = result.wfe_general\n    n_max = model.n_max\n    dx = model.dx\n    HUPMAT3_reduced_list = result.HUPMAT3_reduced_list\n    HUPMATC1 = result.HUPMATC1\n    m_hh = result.m_hh\n    m_lh = result.m_lh\n    m_so = result.m_so\n    Ppz_Psp = result.Ppz_Psp\n    pol_surf_char = result.pol_surf_char\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an object with the following attributes:\n    fi_e - Bandstructure potential (J) (array, len n_max)\n    cb_meff - conduction band effective mass (kg)(array, len n_max)\n    eps - dielectric constant (including eps0) (array, len n_max)\n    dop - doping distribution (m**-3) ( array, len n_max)\n    Fapp - Applied field (Vm**-1)\n    T - Temperature (K)\n    comp_scheme - simulation scheme (currently unused)\n    subnumber_e - number of subbands for look for in the conduction band\n    dx - grid spacing (m)\n    n_max - number of points.\n    """"""\n    fi_e = model.fi_e\n    cb_meff = model.cb_meff\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    vmax = model.vmax\n    vmin = model.vmin\n    Each_Step = model.Each_Step\n    surface = model.surface\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_h = model.subnumber_h\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n    TAUN0 = model.TAUN0\n    TAUP0 = model.TAUP0\n    mun0 = model.mun0\n    mup0 = model.mup0\n    BETAN = model.BETAN\n    BETAP = model.BETAP\n    VSATN = model.VSATN\n    VSATP = model.VSATP\n    if comp_scheme in (4, 5, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include exchange interactions\n        in its valence band calculations.""""""\n        )\n        exit()\n    if comp_scheme in (1, 3, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include nonparabolicity effects in \n        its valence band calculations.""""""\n        )\n        exit()\n    fi_h = model.fi_h\n    N_wells_virtual = model.N_wells_virtual\n    Well_boundary = model.Well_boundary\n    x_max = dx * n_max\n    UNIM = np.identity(n_max)\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n\n    # Check\n    if comp_scheme == 6:\n        logger.warning(\n            """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        )\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_h  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_h  # Number of carriers in subbands\n    E_statec = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_statec = [0.0] * subnumber_e  # Number of carriers in subbands\n    # Preparing empty subband energy arrays for multiquantum wells.\n    """"""\n    E_state_general = np.zeros((model.N_wells_virtual,subnumber_h))     # Energies of subbands/levels (meV)\n    E_statec_general = np.zeros((model.N_wells_virtual,subnumber_e))     # Energies of subbands/levels (meV)\n    meff_statec_general= np.zeros((model.N_wells_virtual,subnumber_e))\n    meff_state_general= np.zeros((model.N_wells_virtual,subnumber_h))\n    """"""\n    N_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Number of carriers in subbands\n    N_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Number of carriers in subbands\n\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    fitotc = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potentia\n    # eps = np.zeros(n_max+2)\t    #dielectric constant\n    # dop = np.zeros(n_max+2)\t    #doping distribution\n    # sigma = np.zeros(n_max+2)      #charge distribution (donors + free charges)\n    # F = np.zeros(n_max+2)          #Electric Field\n    # Vapp = np.zeros(n_max+2)       #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for holes list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n\n    wfh = np.zeros((subnumber_h, n_max))\n    wfe = np.zeros((subnumber_e, n_max))\n    """"""\n    wfh_general = np.zeros((model.N_wells_virtual,subnumber_h,n_max))\n    wfe_general = np.zeros((model.N_wells_virtual,subnumber_e,n_max))\n    """"""\n    E_F_general = np.zeros(model.N_wells_virtual)\n    sigma_general = np.zeros(n_max)\n    F_general = np.zeros(n_max)\n    Vnew_general = np.zeros(n_max)\n    # fi = np.zeros(n_max)\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    # Vapp = calc_potn(Fapp*eps0/eps,model)\n    # Vapp[n_max-1] -= Vapp[n_max//2] #Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # s\n    # setting up Ldi and Ld p and n\n    Ld_n_p = np.zeros(n_max)\n    Ldi = np.zeros(n_max)\n    Nc = np.zeros(n_max)\n    Nv = np.zeros(n_max)\n    vb_meff = np.zeros(n_max)\n    ni = np.zeros(n_max)\n    hbark = hbar * 2 * pi\n    Ppz_Psp_tmp = Ppz_Psp\n    Ppz_Psp = np.zeros(n_max)\n    for i in range(n_max):\n        vb_meff[i] = (m_hh[i] ** (3 / 2) + m_lh[i] ** (3 / 2) + m_so[i] ** (3 / 2)) ** (\n            2 / 3\n        )\n    Nc = 2 * (2 * pi * cb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Nv = 2 * (2 * pi * vb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Half_Eg = np.zeros(n_max)\n    for i in range(n_max):\n        ni[i] = sqrt(\n            Nc[i] * Nv[i] * exp(-(fi_e[i] - fi_h[i]) / (kb * T))\n        )  # Intrinsic carrier concentration [1/m^3] kb*T/q\n        # print(""%.3E"" % (ni[i]*1e-6))\n        # print(fi_e[i]-fi_h[i])\n        Ld_n_p[i] = sqrt(eps[i] * Vt / (q * abs(dop[i])))\n        Ldi[i] = sqrt(eps[i] * Vt / (q * ni[i]))\n        if dop[i] == 1:\n            dop[i] *= ni[i]\n        Half_Eg[i] = (fi_e[i] - fi_h[i]) / 2\n        fi_e[i] = Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n        fi_h[i] = -Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n    n = result.nf_result / ni\n    p = result.pf_result / ni\n    if dx > min(Ld_n_p[:]) and 1 == 2:\n        logger.error(\n            """"""You are setting the grid size %g nm greater than the extrinsic Debye lengths %g nm"""""",\n            dx * 1e9,\n            min(Ld_n_p[:]) * 1e9,\n        )\n        # exit()\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    # previousE0= 0   #(meV) energy of zeroth state for previous iteration(for testing convergence)\n    # fitot = fi_h + Vapp #For initial iteration sum bandstructure and applied field\n    # fitotc = fi_e + Vapp\n    Va_max = vmax  # 1.8#input()0.625\n    # Va_max=0.625#input()0.625\n    dVa = 0.5 * Vt  # input()0.01\n    dVa = dVa / Vt\n    Each_Step = dVa\n    vmin = 0.0\n    Total_Steps = int(((Va_max - vmin) / Vt) / (Each_Step))\n    xaxis = np.arange(0, n_max) * dx  # metres\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n    EF = 0.0\n    av_curr = np.zeros(Total_Steps)\n    Va_t = np.zeros(Total_Steps)\n    Jnim1by2 = np.zeros((Total_Steps, n_max))\n    Jnip1by2 = np.zeros((Total_Steps, n_max))\n    Jelec = np.zeros((Total_Steps, n_max))\n    Jpim1by2 = np.zeros((Total_Steps, n_max))\n    Jpip1by2 = np.zeros((Total_Steps, n_max))\n    Jhole = np.zeros((Total_Steps, n_max))\n    Jtotal = np.zeros((Total_Steps, n_max))\n\n    fi_stat = fi\n    if Va_max == 0:\n        print(""Va_max=0"")\n    else:\n        print(""Convergence of the Gummel cycles"")\n        vindex = 0\n        for vindex in range(0, Total_Steps):\n            # if vindex>int(Total_Steps*4/5):\n            Ppz_Psp = Ppz_Psp_tmp\n            # Start Va increment loop\n            Va = Each_Step * vindex\n            if vindex == 0:\n                fi[0] += 0.0  # Apply potential to Anode (1st node)\n            else:\n                fi[0] += Each_Step\n            flag_conv_2 = True  # Convergence of the Poisson loop\n            #% Initialize the First and Last Node for Poisson\'s eqn\n\n            Va_t[vindex] = Va\n            print(""Va_t["", vindex, ""]="", Va_t[vindex] * Vt)\n            print(""vindex="", vindex)\n            # previousE0= 2   #(meV) energy of zeroth state for previous iteration(for testing convergence)\n            while flag_conv_2:\n                fi, flag_conv_2 = Poisson_non_equi2(\n                    fi_stat,\n                    n,\n                    p,\n                    dop,\n                    Ppz_Psp,\n                    pol_surf_char,\n                    n_max,\n                    dx,\n                    fi,\n                    flag_conv_2,\n                    Ldi,\n                    ni,\n                    fitotc,\n                    fitot,\n                    Nc,\n                    Nv,\n                    fi_e,\n                    fi_h,\n                    iteration,\n                    wfh_general,\n                    wfe_general,\n                    model,\n                    E_state_general,\n                    E_statec_general,\n                    meff_state_general,\n                    meff_statec_general,\n                )\n                #\n                mun, mup = Mobility2(\n                    mun0, mup0, fi, Vt, Ldi, VSATN, VSATP, BETAN, BETAP, n_max, dx\n                )\n                ########### END of FIELD Dependant Mobility Calculation ###########\n                n, p = Continuity2(n, p, mun, mup, fi, Vt, Ldi, n_max, dx, TAUN0, TAUP0)\n                ####################### END of HOLE Continuty Solver ###########\n                # End of WHILE Loop for Poisson\'s eqn solver\n                # print(\'inside while loop\')\n            Jnip1by2, Jnim1by2, Jelec, Jpip1by2, Jpim1by2, Jhole = Current2(\n                vindex,\n                n,\n                p,\n                mun,\n                mup,\n                fi,\n                Vt,\n                n_max,\n                Total_Steps,\n                q,\n                dx,\n                ni,\n                Ldi,\n                Jnip1by2,\n                Jnim1by2,\n                Jelec,\n                Jpip1by2,\n                Jpim1by2,\n                Jhole,\n            )\n\n            # End of main FOR loop for Va increment.\n            Jtotal = Jelec + Jhole\n        ##########################################################################\n        ##                 END OF NON-EQUILIBRIUM  SOLUTION PART                ##\n        ##########################################################################\n        # Write the results of the simulation in files #\n        (\n            fi_result,\n            Efn_result,\n            Efp_result,\n            ro_result,\n            el_field1_result,\n            el_field2_result,\n            nf_result,\n            pf_result,\n            Ec_result,\n            Ev_result,\n            Ei_result,\n            av_curr,\n        ) = Write_results_non_equi2(\n            Nc,\n            Nv,\n            fi_e,\n            fi_h,\n            Vt,\n            q,\n            ni,\n            n,\n            p,\n            dop,\n            dx,\n            Ldi,\n            fi,\n            n_max,\n            Jnip1by2,\n            Jnim1by2,\n            Jelec,\n            Jpip1by2,\n            Jpim1by2,\n            Jhole,\n            Jtotal,\n            Total_Steps,\n        )\n        fitot = fi_h - Vt * q * fi\n        fitotc = fi_e - Vt * q * fi\n        if model.N_wells_virtual - 2 != 0:\n\n            (\n                E_statec_general,\n                E_state_general,\n                wfe_general,\n                wfh_general,\n                meff_statec_general,\n                meff_state_general,\n            ) = Schro(\n                HUPMAT3_reduced_list,\n                HUPMATC1,\n                subnumber_h,\n                subnumber_e,\n                fitot,\n                fitotc,\n                model,\n                Well_boundary,\n                UNIM,\n                RATIO,\n                m_hh,\n                m_lh,\n                m_so,\n                n_max,\n            )\n    time3 = time.time()  # timing audit\n    if not (config.messagesoff):\n        logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n    results.N_wells_virtual = N_wells_virtual\n    results.Well_boundary = Well_boundary\n    results.xaxis = xaxis\n    results.wfh = wfh\n    results.wfe = wfe\n    results.wfh_general = wfh_general\n    results.wfe_general = wfe_general\n    results.fitot = fitot\n    results.fitotc = fitotc\n    results.fi_e = fi_e\n    results.fi_h = fi_h\n    # results.sigma = sigma\n    results.sigma_general = sigma_general\n    # results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    # results.meff_state = meff_state\n    results.E_statec = E_statec\n    results.N_statec = N_statec\n    # results.meff_statec = meff_statec\n    results.F_general = F_general\n    results.E_state_general = E_state_general\n    results.N_state_general = N_state_general\n    results.meff_state_general = meff_state_general\n    results.E_statec_general = E_statec_general\n    results.N_statec_general = N_statec_general\n    results.meff_statec_general = meff_statec_general\n    results.Fapp = Fapp\n    results.T = T\n    # results.E_F = E_F\n    results.E_F_general = E_F_general\n    results.dx = dx\n    results.subnumber_h = subnumber_h\n    results.subnumber_e = subnumber_e\n    results.Ntotal2d = Ntotal2d\n    ########################\n    results.Va_t = Va_t\n    results.Efn_result = Efn_result\n    results.Efp_result = Efp_result\n    results.Ei_result = Ei_result\n    results.av_curr = av_curr\n    results.Ec_result = Ec_result\n    results.Ev_result = Ev_result\n    results.ro_result = ro_result\n    results.el_field1_result = el_field1_result\n    results.el_field2_result = el_field2_result\n    results.nf_result = nf_result\n    results.pf_result = pf_result\n    results.fi_result = fi_result\n    results.EF = EF\n    results.Total_Steps = Total_Steps\n    return results\n\n\n################################################\ndef Poisson_Schrodinger_DD_test(result, model):\n    fi = result.fi_result\n    E_state_general = result.E_state_general\n    meff_state_general = result.meff_state_general\n    E_statec_general = result.E_statec_general\n    meff_statec_general = result.meff_statec_general\n    wfh_general = result.wfh_general\n    wfe_general = result.wfe_general\n    HUPMAT3_reduced_list = result.HUPMAT3_reduced_list\n    E_state_general0 = result.E_state_general0\n    meff_state_general0 = result.meff_state_general0\n    E_statec_general0 = result.E_statec_general0\n    meff_statec_general0 = result.meff_statec_general0\n    wfh_general0 = result.wfh_general0\n    wfe_general0 = result.wfe_general0\n    n_max = model.n_max\n    dx = model.dx\n    HUPMAT3_reduced_list = result.HUPMAT3_reduced_list\n    m_hh = result.m_hh\n    m_lh = result.m_lh\n    m_so = result.m_so\n    Ppz_Psp = result.Ppz_Psp\n    pol_surf_char = result.pol_surf_char\n    HUPMATC1 = result.HUPMATC1\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an object with the following attributes:\n    fi_e - Bandstructure potential (J) (array, len n_max)\n    cb_meff - conduction band effective mass (kg)(array, len n_max)\n    eps - dielectric constant (including eps0) (array, len n_max)\n    dop - doping distribution (m**-3) ( array, len n_max)\n    Fapp - Applied field (Vm**-1)\n    T - Temperature (K)\n    comp_scheme - simulation scheme (currently unused)\n    subnumber_e - number of subbands for look for in the conduction band\n    dx - grid spacing (m)\n    n_max - number of points.\n    """"""\n    fi_e = model.fi_e\n    cb_meff = model.cb_meff\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    vmax = model.vmax\n    vmin = model.vmin\n    Each_Step = model.Each_Step\n    surface = model.surface\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_h = model.subnumber_h\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n    TAUN0 = model.TAUN0\n    TAUP0 = model.TAUP0\n    mun0 = model.mun0\n    mup0 = model.mup0\n    BETAN = model.BETAN\n    BETAP = model.BETAP\n    VSATN = model.VSATN\n    VSATP = model.VSATP\n    if comp_scheme in (4, 5, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include exchange interactions\n        in its valence band calculations.""""""\n        )\n        exit()\n    if comp_scheme in (1, 3, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include nonparabolicity effects in \n        its valence band calculations.""""""\n        )\n        exit()\n    fi_h = model.fi_h\n    N_wells_virtual = model.N_wells_virtual\n    Well_boundary = model.Well_boundary\n\n    x_max = dx * n_max\n    # Check\n    if comp_scheme == 6:\n        logger.warning(\n            """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        )\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_h  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_h  # Number of carriers in subbands\n    E_statec = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_statec = [0.0] * subnumber_e  # Number of carriers in subbands\n    # Preparing empty subband energy arrays for multiquantum wells.\n    """"""\n    E_state_general = np.zeros((model.N_wells_virtual,subnumber_h))     # Energies of subbands/levels (meV)\n    E_statec_general = np.zeros((model.N_wells_virtual,subnumber_e))     # Energies of subbands/levels (meV)\n    meff_statec_general= np.zeros((model.N_wells_virtual,subnumber_e))\n    meff_state_general= np.zeros((model.N_wells_virtual,subnumber_h))\n    """"""\n    N_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Number of carriers in subbands\n    N_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Number of carriers in subbands\n\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    fitotc = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potentia\n    # eps = np.zeros(n_max+2)\t    #dielectric constant\n    # dop = np.zeros(n_max+2)\t    #doping distribution\n    # sigma = np.zeros(n_max+2)      #charge distribution (donors + free charges)\n    # F = np.zeros(n_max+2)          #Electric Field\n    # Vapp = np.zeros(n_max+2)       #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for holes list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n\n    wfh = np.zeros((subnumber_h, n_max))\n    wfe = np.zeros((subnumber_e, n_max))\n    """"""\n    wfh_general = np.zeros((model.N_wells_virtual,subnumber_h,n_max))\n    wfe_general = np.zeros((model.N_wells_virtual,subnumber_e,n_max))\n    """"""\n    E_F_general = np.zeros(model.N_wells_virtual)\n    sigma_general = np.zeros(n_max)\n    F_general = np.zeros(n_max)\n    Vnew_general = np.zeros(n_max)\n    # fi = np.zeros(n_max)\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    # Vapp = calc_potn(Fapp*eps0/eps,model)\n    # Vapp[n_max-1] -= Vapp[n_max//2] #Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # s\n    # setting up Ldi and Ld p and n\n    Ld_n_p = np.zeros(n_max)\n    Ldi = np.zeros(n_max)\n    Nc = np.zeros(n_max)\n    Nv = np.zeros(n_max)\n    vb_meff = np.zeros(n_max)\n    ni = np.zeros(n_max)\n    hbark = hbar * 2 * pi\n    # m_hh,m_lh,m_so,VNIT,ZETA,CNIT,Ppz_Psp,EPC,pol_surf_char=Strain_and_Masses(model)\n\n    Ppz_Psp_tmp = Ppz_Psp\n    Ppz_Psp = np.zeros(n_max)\n\n    UNIM = np.identity(n_max)\n    x_max = dx * n_max\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n    for i in range(n_max):\n        vb_meff[i] = (m_hh[i] ** (3 / 2) + m_lh[i] ** (3 / 2) + m_so[i] ** (3 / 2)) ** (\n            2 / 3\n        )\n    Nc = 2 * (2 * pi * cb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Nv = 2 * (2 * pi * vb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Half_Eg = np.zeros(n_max)\n    for i in range(n_max):\n        ni[i] = sqrt(\n            Nc[i] * Nv[i] * exp(-(fi_e[i] - fi_h[i]) / (kb * T))\n        )  # Intrinsic carrier concentration [1/m^3] kb*T/q\n        # print(""%.3E"" % (ni[i]*1e-6))\n        # print(fi_e[i]-fi_h[i])\n        if dop[i] == 1:\n            dop[i] *= ni[i]\n        Ld_n_p[i] = sqrt(eps[i] * Vt / (q * abs(dop[i])))\n        Ldi[i] = sqrt(eps[i] * Vt / (q * ni[i]))\n        Half_Eg[i] = (fi_e[i] - fi_h[i]) / 2\n        fi_e[i] = Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n        fi_h[i] = -Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n    n = result.nf_result / ni\n    p = result.pf_result / ni\n    if dx > min(Ld_n_p[:]) and 1 == 2:\n        logger.error(\n            """"""You are setting the grid size %g nm greater than the extrinsic Debye lengths %g nm"""""",\n            dx * 1e9,\n            min(Ld_n_p[:]) * 1e9,\n        )\n        exit()\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    previousE0 = 0  # (meV) energy of zeroth state for previous iteration(for testing convergence)\n    previousfi0 = 0  # (meV) energy of  for previous iteration(for testing convergence)\n    fitot = fi_h  # + Vapp #For initial iteration sum bandstructure and applied field\n    fitotc = fi_e  # + Vapp\n    Va_max = vmax  # 1.8#input()0.625\n    # Va_max=0.625#input()0.625\n    dVa = Each_Step  # *Vt#input()0.01\n    dVa = dVa / Vt\n    Each_Step = dVa\n    Total_Steps = int(((Va_max - vmin) / Vt) / (Each_Step))\n    xaxis = np.arange(0, n_max) * dx  # metres\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n    n_q = np.zeros(n_max)\n    p_q = np.zeros(n_max)\n    fi_n = np.zeros(n_max)\n    fi_p = np.zeros(n_max)\n    EF = 0.0\n    av_curr = np.zeros(Total_Steps)\n    Va_t = np.zeros(Total_Steps)\n    Jnim1by2 = np.zeros((Total_Steps, n_max))\n    Jnip1by2 = np.zeros((Total_Steps, n_max))\n    Jelec = np.zeros((Total_Steps, n_max))\n    Jpim1by2 = np.zeros((Total_Steps, n_max))\n    Jpip1by2 = np.zeros((Total_Steps, n_max))\n    Jhole = np.zeros((Total_Steps, n_max))\n    Jtotal = np.zeros((Total_Steps, n_max))\n    fi_stat = fi\n    if Va_max == 0:\n        print(""Va_max=0"")\n    else:\n        print(""Convergence of the Gummel cycles"")\n        vindex = 0\n        for vindex in range(0, Total_Steps):\n            iteration = 1  # iteration counter\n            Ppz_Psp = Ppz_Psp_tmp\n            # Start Va increment loop\n            Va = Each_Step * vindex\n            if vindex == 0:\n                fi[0] += 0.0  # Apply potential to Anode (1st node)\n            else:\n                fi[0] += Each_Step\n            flag_conv_2 = True  # Convergence of the Poisson loop\n            #% Initialize the First and Last Node for Poisson\'s eqn\n\n            Va_t[vindex] = Va\n            print(""Va_t["", vindex, ""]="", Va_t[vindex] * Vt)\n            print(""vindex="", vindex)\n            # previousE0= 2   #(meV) energy of zeroth state for previous iteration(for testing convergence)\n            while flag_conv_2:\n                fitot = fi_h - Vt * q * fi\n                fitotc = fi_e - Vt * q * fi\n                if model.N_wells_virtual - 2 != 0:\n                    (\n                        E_statec_general,\n                        E_state_general,\n                        wfe_general,\n                        wfh_general,\n                        meff_statec_general,\n                        meff_state_general,\n                    ) = Schro(\n                        HUPMAT3_reduced_list,\n                        HUPMATC1,\n                        subnumber_h,\n                        subnumber_e,\n                        fitot,\n                        fitotc,\n                        model,\n                        Well_boundary,\n                        UNIM,\n                        RATIO,\n                        m_hh,\n                        m_lh,\n                        m_so,\n                        n_max,\n                    )\n                fi, flag_conv_2, n_q, p_q, fi_n, fi_p = Poisson_non_equi3(\n                    vindex,\n                    fi_stat,\n                    n,\n                    p,\n                    dop,\n                    Ppz_Psp,\n                    pol_surf_char,\n                    n_max,\n                    dx,\n                    fi,\n                    flag_conv_2,\n                    Ldi,\n                    ni,\n                    fitotc,\n                    fitot,\n                    Nc,\n                    Nv,\n                    fi_e,\n                    fi_h,\n                    iteration,\n                    wfh_general,\n                    wfe_general,\n                    model,\n                    E_state_general,\n                    E_statec_general,\n                    meff_state_general,\n                    meff_statec_general,\n                )\n\n                mun, mup = Mobility3(\n                    mun0,\n                    mup0,\n                    fi,\n                    fi_n,\n                    fi_p,\n                    Vt,\n                    Ldi,\n                    VSATN,\n                    VSATP,\n                    BETAN,\n                    BETAP,\n                    n_max,\n                    dx,\n                )\n                ########### END of FIELD Dependant Mobility Calculation ###########\n                n, p = Continuity3(\n                    n, p, mun, mup, fi, fi_n, fi_p, Vt, Ldi, n_max, dx, TAUN0, TAUP0\n                )\n                # if config.quantum_effect:\n            Jnip1by2, Jnim1by2, Jelec, Jpip1by2, Jpim1by2, Jhole = Current2(\n                vindex,\n                n,\n                p,\n                mun,\n                mup,\n                fi,\n                Vt,\n                n_max,\n                Total_Steps,\n                q,\n                dx,\n                ni,\n                Ldi,\n                Jnip1by2,\n                Jnim1by2,\n                Jelec,\n                Jpip1by2,\n                Jpim1by2,\n                Jhole,\n            )\n\n            # End of main FOR loop for Va increment.\n            Jtotal = Jelec + Jhole\n            """"""                \n            pl.plot(xaxis*1e6,fitotc)\n            pl.xlabel(\'Position (m)\')\n            pl.ylabel(\'Energy (meV)\')\n            pl.grid(True)\n            """"""\n        ##########################################################################\n        ##                 END OF NON-EQUILIBRIUM  SOLUTION PART                ##\n        ##########################################################################\n        # Write the results of the simulation in files #\n        (\n            fi_result,\n            Efn_result,\n            Efp_result,\n            ro_result,\n            el_field1_result,\n            el_field2_result,\n            nf_result,\n            pf_result,\n            Ec_result,\n            Ev_result,\n            Ei_result,\n            av_curr,\n        ) = Write_results_non_equi2(\n            Nc,\n            Nv,\n            fi_e,\n            fi_h,\n            Vt,\n            q,\n            ni,\n            n,\n            p,\n            dop,\n            dx,\n            Ldi,\n            fi,\n            n_max,\n            Jnip1by2,\n            Jnim1by2,\n            Jelec,\n            Jpip1by2,\n            Jpim1by2,\n            Jhole,\n            Jtotal,\n            Total_Steps,\n        )\n        fitot = fi_h - Vt * q * fi\n        fitotc = fi_e - Vt * q * fi\n    time3 = time.time()  # timing audit\n    if not (config.messagesoff):\n        logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n    results.N_wells_virtual = N_wells_virtual\n    results.Well_boundary = Well_boundary\n    results.xaxis = xaxis\n    results.wfh = wfh\n    results.wfe = wfe\n    results.wfh_general = wfh_general\n    results.wfe_general = wfe_general\n    results.fitot = fitot\n    results.fitotc = fitotc\n    results.fi_e = fi_e\n    results.fi_h = fi_h\n    # results.sigma = sigma\n    results.sigma_general = sigma_general\n    # results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    # results.meff_state = meff_state\n    results.E_statec = E_statec\n    results.N_statec = N_statec\n    # results.meff_statec = meff_statec\n    results.F_general = F_general\n    results.E_state_general = E_state_general\n    results.N_state_general = N_state_general\n    results.meff_state_general = meff_state_general\n    results.E_statec_general = E_statec_general\n    results.N_statec_general = N_statec_general\n    results.meff_statec_general = meff_statec_general\n    results.Fapp = Fapp\n    results.T = T\n    # results.E_F = E_F\n    results.E_F_general = E_F_general\n    results.dx = dx\n    results.subnumber_h = subnumber_h\n    results.subnumber_e = subnumber_e\n    results.Ntotal2d = Ntotal2d\n    ########################\n    results.Va_t = Va_t\n    results.Efn_result = Efn_result\n    results.Efp_result = Efp_result\n    results.Ei_result = Ei_result\n    results.av_curr = av_curr\n    results.Ec_result = Ec_result\n    results.Ev_result = Ev_result\n    results.ro_result = ro_result\n    results.el_field1_result = el_field1_result\n    results.el_field2_result = el_field2_result\n    results.nf_result = nf_result\n    results.pf_result = pf_result\n    results.fi_result = fi_result\n    results.EF = EF\n    results.Total_Steps = Total_Steps\n    return results\n\n\ndef Poisson_Schrodinger_DD_test_2(result, model):\n    fi = result.fi_result\n    E_state_general = result.E_state_general\n    meff_state_general = result.meff_state_general\n    E_statec_general = result.E_statec_general\n    meff_statec_general = result.meff_statec_general\n    wfh_general = result.wfh_general\n    wfe_general = result.wfe_general\n    n_max = model.n_max\n    dx = model.dx\n    HUPMAT3_reduced_list = result.HUPMAT3_reduced_list\n    HUPMATC1 = result.HUPMATC1\n    m_hh = result.m_hh\n    m_lh = result.m_lh\n    m_so = result.m_so\n    Ppz_Psp = result.Ppz_Psp\n    pol_surf_char = result.pol_surf_char\n    """"""Performs a self-consistent Poisson-Schrodinger calculation of a 1d quantum well structure.\n    Model is an object with the following attributes:\n    fi_e - Bandstructure potential (J) (array, len n_max)\n    cb_meff - conduction band effective mass (kg)(array, len n_max)\n    eps - dielectric constant (including eps0) (array, len n_max)\n    dop - doping distribution (m**-3) ( array, len n_max)\n    Fapp - Applied field (Vm**-1)\n    T - Temperature (K)\n    comp_scheme - simulation scheme (currently unused)\n    subnumber_e - number of subbands for look for in the conduction band\n    dx - grid spacing (m)\n    n_max - number of points.\n    """"""\n    fi_e = model.fi_e\n    cb_meff = model.cb_meff\n    eps = model.eps\n    dop = model.dop\n    Fapp = model.Fapp\n    vmax = model.vmax\n    vmin = model.vmin\n    Each_Step = model.Each_Step\n    surface = model.surface\n    T = model.T\n    comp_scheme = model.comp_scheme\n    subnumber_h = model.subnumber_h\n    subnumber_e = model.subnumber_e\n    dx = model.dx\n    n_max = model.n_max\n    TAUN0 = model.TAUN0\n    TAUP0 = model.TAUP0\n    mun0 = model.mun0\n    mup0 = model.mup0\n    Cn0 = model.Cn0\n    Cp0 = model.Cp0\n    BETAN = model.BETAN\n    BETAP = model.BETAP\n    VSATN = model.VSATN\n    VSATP = model.VSATP\n\n    if comp_scheme in (4, 5, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include exchange interactions\n        in its valence band calculations.""""""\n        )\n        exit()\n    if comp_scheme in (1, 3, 6):\n        logger.error(\n            """"""aestimo_eh doesn\'t currently include nonparabolicity effects in \n        its valence band calculations.""""""\n        )\n        exit()\n    fi_h = model.fi_h\n    N_wells_virtual = model.N_wells_virtual\n    Well_boundary = model.Well_boundary\n    x_max = dx * n_max\n    UNIM = np.identity(n_max)\n    RATIO = m_e / hbar ** 2 * (x_max) ** 2\n\n    # Check\n    if comp_scheme == 6:\n        logger.warning(\n            """"""The calculation of Vxc depends upon m*, however when non-parabolicity is also \n                 considered m* becomes energy dependent which would make Vxc energy dependent.\n                 Currently this effect is ignored and Vxc uses the effective masses from the \n                 bottom of the conduction bands even when non-parabolicity is considered \n                 elsewhere.""""""\n        )\n    # Preparing empty subband energy lists.\n    E_state = [0.0] * subnumber_h  # Energies of subbands/levels (meV)\n    N_state = [0.0] * subnumber_h  # Number of carriers in subbands\n    E_statec = [0.0] * subnumber_e  # Energies of subbands/levels (meV)\n    N_statec = [0.0] * subnumber_e  # Number of carriers in subbands\n    # Preparing empty subband energy arrays for multiquantum wells.\n    """"""\n    E_state_general = np.zeros((model.N_wells_virtual,subnumber_h))     # Energies of subbands/levels (meV)\n    E_statec_general = np.zeros((model.N_wells_virtual,subnumber_e))     # Energies of subbands/levels (meV)\n    meff_statec_general= np.zeros((model.N_wells_virtual,subnumber_e))\n    meff_state_general= np.zeros((model.N_wells_virtual,subnumber_h))\n    """"""\n    N_state_general = np.zeros(\n        (model.N_wells_virtual, subnumber_h)\n    )  # Number of carriers in subbands\n    N_statec_general = np.zeros(\n        (model.N_wells_virtual, subnumber_e)\n    )  # Number of carriers in subbands\n\n    # Creating and Filling material arrays\n    xaxis = np.arange(0, n_max) * dx  # metres\n    fitot = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potential\n    fitotc = np.zeros(n_max)  # Energy potential = Bandstructure + Coulombic potentia\n    # eps = np.zeros(n_max+2)\t    #dielectric constant\n    # dop = np.zeros(n_max+2)\t    #doping distribution\n    # sigma = np.zeros(n_max+2)      #charge distribution (donors + free charges)\n    # F = np.zeros(n_max+2)          #Electric Field\n    # Vapp = np.zeros(n_max+2)       #Applied Electric Potential\n    V = np.zeros(n_max)  # Electric Potential\n\n    # Subband wavefunction for holes list. 2-dimensional: [i][j] i:stateno, j:wavefunc\n\n    wfh = np.zeros((subnumber_h, n_max))\n    wfe = np.zeros((subnumber_e, n_max))\n    """"""\n    wfh_general = np.zeros((model.N_wells_virtual,subnumber_h,n_max))\n    wfe_general = np.zeros((model.N_wells_virtual,subnumber_e,n_max))\n    """"""\n    E_F_general = np.zeros(model.N_wells_virtual)\n    sigma_general = np.zeros(n_max)\n    F_general = np.zeros(n_max)\n    Vnew_general = np.zeros(n_max)\n    # fi = np.zeros(n_max)\n    # Setup the doping\n    Ntotal = sum(dop)  # calculating total doping density m-3\n    Ntotal2d = Ntotal * dx\n    if not (config.messagesoff):\n        # print ""Ntotal "",Ntotal,""m**-3""\n        logger.info(""Ntotal2d %g m**-2"", Ntotal2d)\n    # Applied Field\n    # Vapp = calc_potn(Fapp*eps0/eps,model)\n    # Vapp[n_max-1] -= Vapp[n_max//2] #Offsetting the applied field\'s potential so that it is zero in the centre of the structure.\n    # s\n    # setting up Ldi and Ld p and n\n    Ld_n_p = np.zeros(n_max)\n    Ldi = np.zeros(n_max)\n    Nc = np.zeros(n_max)\n    Nv = np.zeros(n_max)\n    vb_meff = np.zeros(n_max)\n    ni = np.zeros(n_max)\n    hbark = hbar * 2 * pi\n    Ppz_Psp_tmp = Ppz_Psp\n    Ppz_Psp = np.zeros(n_max)\n    for i in range(n_max):\n        vb_meff[i] = (m_hh[i] ** (3 / 2) + m_lh[i] ** (3 / 2) + m_so[i] ** (3 / 2)) ** (\n            2 / 3\n        )\n    Nc = 2 * (2 * pi * cb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Nv = 2 * (2 * pi * vb_meff * kb * T / hbark ** 2) ** (3 / 2)\n    Half_Eg = np.zeros(n_max)\n    for i in range(n_max):\n        ni[i] = sqrt(\n            Nc[i] * Nv[i] * exp(-(fi_e[i] - fi_h[i]) / (kb * T))\n        )  # Intrinsic carrier concentration [1/m^3] kb*T/q\n        Ld_n_p[i] = sqrt(eps[i] * Vt / (q * abs(dop[i])))\n        Ldi[i] = sqrt(eps[i] * Vt / (q * ni[i]))\n        if dop[i] == 1:\n            dop[i] *= ni[i]\n        Half_Eg[i] = (fi_e[i] - fi_h[i]) / 2\n        fi_e[i] = Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n        fi_h[i] = -Half_Eg[i] - kb * T * log(Nv[i] / Nc[i]) / 2\n    n = result.nf_result / ni\n    p = result.pf_result / ni\n    if dx > min(Ld_n_p[:]) and 1 == 2:\n        logger.error(\n            """"""You are setting the grid size %g nm greater than the extrinsic Debye lengths %g nm"""""",\n            dx * 1e9,\n            min(Ld_n_p[:]) * 1e9,\n        )\n        # exit()\n    # STARTING SELF CONSISTENT LOOP\n    time2 = time.time()  # timing audit\n    iteration = 1  # iteration counter\n    # previousE0= 0   #(meV) energy of zeroth state for previous iteration(for testing convergence)\n    # fitot = fi_h + Vapp #For initial iteration sum bandstructure and applied field\n    # fitotc = fi_e + Vapp\n    xaxis = np.arange(0, n_max) * dx  # metres\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n    n_q = np.zeros(n_max)\n    p_q = np.zeros(n_max)\n    fi_n = np.zeros(n_max)\n    fi_p = np.zeros(n_max)\n    EF = 0.0\n    Total_Steps = int((vmax - vmin) / Each_Step) + 1\n    vindex = 0\n    Va_t = np.zeros(Total_Steps)\n\n    Jtotal = np.zeros((Total_Steps, n_max))\n    ###############################################################\n    len_ = xaxis[n_max - 1]\n\n    #\n    xm = np.mean(xaxis)\n    nis = np.zeros(n_max)\n    mun = np.zeros(n_max)\n    mup = np.zeros(n_max)\n    Cn = np.zeros(n_max)\n    Cp = np.zeros(n_max)\n    l2 = np.zeros(n_max - 1)\n    Fn = np.zeros(n_max)\n    Fp = np.zeros(n_max)\n    n = np.zeros(n_max)\n    p = np.zeros(n_max)\n    nn = np.zeros(n_max)\n    pp = np.zeros(n_max)\n    V = np.zeros(n_max)\n    vvect = np.zeros(Total_Steps)\n    n_ = np.zeros((Total_Steps, n_max))\n    p_ = np.zeros((Total_Steps, n_max))\n    Fn_ = np.zeros((Total_Steps, n_max))\n    Fp_ = np.zeros((Total_Steps, n_max))\n    V_ = np.zeros((Total_Steps, n_max))\n    Jn = np.zeros((Total_Steps, n_max))\n    Jp = np.zeros((Total_Steps, n_max))\n    # J=np.zeros((Total_Steps,n_max-1))\n    lambda2 = np.zeros((Total_Steps, n_max))\n    DV = np.zeros(Total_Steps)\n    Emax = np.zeros(Total_Steps)\n\n    nn, pp, fi_out = equi_np_fi(iteration, dop, Ppz_Psp, n_max, ni, model, Vt, surface)\n    # xn = xm+1e-7\n    # xp = xm-1e-7\n    ## Scaling coefficients\n    xs = len_\n    ns1 = np.linalg.norm(dop, np.inf)\n\n    ns2 = np.linalg.norm(Ppz_Psp_tmp, np.inf)\n\n    ns = max(ns1, ns2)\n        \n    class data:\n        def __init__(self):\n            self.dop = dop\n            self.TAUN0 = TAUN0\n            self.TAUP0 = TAUP0\n            self.Fn = Fn\n            self.Fp = Fp\n            self.V = V\n            self.n = n\n            self.p = p\n            self.nis = nis\n            self.mun = mun\n            self.mup = mup\n            self.l2 = l2\n            self.Ppz_Psp = Ppz_Psp\n            self.Cn = Cn\n            self.Cp = Cp\n            self.E_state_general = result.E_state_general\n            self.meff_state_general = result.meff_state_general\n            self.E_statec_general = result.E_statec_general\n            self.meff_statec_general = result.meff_statec_general\n            self.wfh_general = result.wfh_general\n            self.wfe_general = result.wfe_general\n\n    idata = data()\n    odata = data()\n\n    Vs = Vt\n    us = max(max(mun0), max(mup0))\n    Js = xs / (us * Vs * q * ns)\n    xbar = len_  # [m]\n    Vbar = Vt  # [V]\n    mubar = max(max(mun0), max(mup0))  # [m^2 V^{-1} s^{-1}]\n    tbar = xbar ** 2 / (mubar * Vbar)  # [s]\n    Rbar = ns / tbar\n    # [m^{-3} s^{-1}]\n    CAubar = Rbar / ns ** 3  # [m^6 s^{-1}]\n    idata.Cn = Cn0 / CAubar\n    idata.Cp = Cp0 / CAubar\n    if config.use_cython :\n        from aestimo_dd_lib import DDGgummelmap_cython,DDNnewtonmap_cython\n        print(""use_cython option is activated"")\n    ###############################################################\n    if vmax == 0:\n        print(""Va_max=0"")\n    else:\n        print(""Convergence of the Gummel cycles"")\n        vindex = 0\n        for vindex in range(0, Total_Steps):\n            # introducing piezo spont effect with increasing ratio till 33.33%\n            Ppz_Psp = Ppz_Psp_tmp / (Total_Steps + 2 - vindex)\n            # piezo_ratio=100*np.linalg.norm(Ppz_Psp,np.inf)/np.linalg.norm(Ppz_Psp_tmp,np.inf)\n            # print(""ratio of piezo=%.2f""%piezo_ratio,"" %"")\n            # Start Va increment loop\n            Va = vmin\n            Va += Each_Step * vindex\n            Va_t[vindex] = Va\n\n            print(""Va_t["", vindex, ""]=%.2f"" % Va_t[vindex])\n            #####################################################################################\n            vvect[vindex] = Va\n            # z\n            xin = xaxis / xs\n            n_[vindex, :] = nn * ni\n            p_[vindex, :] = pp * ni\n            #\n            Fn = Va * (xaxis <= xm)\n            Fp = Fn\n            #\n            V_[vindex, :] = Fn - Vt * np.log(p_[vindex, :] / ni)\n            #\n            ## Scaling\n\n            Fn_[vindex, :] = Fn - Vs * np.log(ni / ns)\n            Fp_[vindex, :] = Fp + Vs * np.log(ni / ns)\n            #\n            idata.l2 = (Vs * eps[0 : n_max - 1]) / (q * ns * xs ** 2)\n            idata.nis = ni / ns\n            idata.dop = dop / ns\n            idata.Ppz_Psp = Ppz_Psp / ns\n            # mun,mup=Mobility2(mun0,mup0,fi,Vt,Ldi,VSATN,VSATP,BETAN,BETAP,n_max,dx)\n            idata.mun = mun0 / us\n            idata.mup = mup0 / us\n\n            # sinodes = np.arange(len(xaxis))\n            idata.TAUN0 = TAUN0 / tbar  # np.inf\n            idata.TAUP0 = TAUP0 / tbar  # np.inf\n            idata.theta = ni / ns\n\n            idata.n = n_[vindex, :] / ns\n            idata.p = p_[vindex, :] / ns\n            idata.V = V_[vindex, :] / Vs\n            idata.Fn = Fn_[vindex, :] / Vs\n            idata.Fp = Fp_[vindex, :] / Vs\n            fitot = fi_h - Vt * q * idata.V\n            fitotc = fi_e - Vt * q * idata.V\n            if model.N_wells_virtual - 2 != 0 and config.quantum_effect:\n                (\n                    idata.E_statec_general,\n                    idata.E_state_general,\n                    idata.wfe_general,\n                    idata.wfh_general,\n                    idata.meff_statec_general,\n                    idata.meff_state_general,\n                ) = Schro(\n                    HUPMAT3_reduced_list,\n                    HUPMATC1,\n                    subnumber_h,\n                    subnumber_e,\n                    fitot,\n                    fitotc,\n                    model,\n                    Well_boundary,\n                    UNIM,\n                    RATIO,\n                    m_hh,\n                    m_lh,\n                    m_so,\n                    n_max,\n                )\n            ## Solution of DD system\n            #\n            ## Algorithm parameters\n            toll = 1e-3\n            maxit = 10\n            ptoll = 1e-10\n            pmaxit = 30\n            verbose = 0\n            if config.use_cython :\n                [odata, it, res] = DDGgummelmap_cython(idata,odata,model,xin,ni,fi_e,fi_h,toll,Vt,ptoll,pmaxit,n_max,verbose,maxit)\n            else:                \n                [odata, it, res] = DDGgummelmap(\n                    n_max,\n                    xin,\n                    idata,\n                    odata,\n                    toll,\n                    maxit,\n                    ptoll,\n                    pmaxit,\n                    verbose,\n                    ni,\n                    fi_e,\n                    fi_h,\n                    model,\n                    Vt,\n                )\n            \n            if config.use_cython :\n                [odata, it, res] = DDNnewtonmap_cython(odata,model,ni,fi_e,fi_h,xin,toll,Vt,maxit,verbose)\n            else:                \n                [odata, it, res] = DDNnewtonmap(\n                    ni, fi_e, fi_h, xin, odata, toll, maxit, verbose, model, Vt\n                )\n\n            n_[vindex, :] = odata.n\n            p_[vindex, :] = odata.p\n            V_[vindex, :] = odata.V\n\n            # print(""n_newt="",odata.n[:])\n            Fn_[vindex, :] = odata.Fn\n            Fp_[vindex, :] = odata.Fp\n            DV[vindex] = V_[vindex, n_max - 1] - V_[0, vindex]\n            Emax[vindex] = max(\n                abs(\n                    (V_[vindex, 1:n_max] - V_[vindex, 0 : n_max - 1])\n                    / (xin[1:n_max] - xin[0 : n_max - 1])\n                )\n            )\n            #\n\n            Bp = Ubernoulli(\n                (V_[vindex, 1:n_max] - V_[vindex, 0 : n_max - 1])\n                + (fi_n[1:n_max] - fi_n[0 : n_max - 1]),\n                1,\n            )\n            Bm = Ubernoulli(\n                (V_[vindex, 1:n_max] - V_[vindex, 0 : n_max - 1])\n                + (fi_p[1:n_max] - fi_p[0 : n_max - 1]),\n                0,\n            )\n            Jn[vindex, 0 : n_max - 1] = (\n                -odata.mun[0 : n_max - 1]\n                * (n_[vindex, 1:n_max] * Bp - n_[vindex, 0 : n_max - 1] * Bm)\n                / (xin[1:n_max] - xin[0 : n_max - 1])\n            )\n            Jp[vindex, 0 : n_max - 1] = (\n                odata.mup[0 : n_max - 1]\n                * (p_[vindex, 1:n_max] * Bm - p_[vindex, 0 : n_max - 1] * Bp)\n                / (xin[1:n_max] - xin[0 : n_max - 1])\n            )\n        ## Descaling\n        n_ = n_ * ns\n        p_ = p_ * ns\n        V_ = V_ * Vs\n        # J = abs (Jp+Jn)*Js\n        Jtotal = abs(Jp + Jn) * us * q * ns\n        Jtotal[:, n_max - 1] = Jtotal[:, n_max - 2]\n        #Fn = V_ / Vs - np.log(n_)\n        #Fp = V_ / Vs + np.log(p_)\n        # Fn_=Fn_*Vs\n        # Fp_=Fp_*Vs\n        #\n        time1 = time.time()\n        delta_t = (time1 - time0) / 60\n        print(""time=%.2fmn"" % delta_t)\n\n        ro_result = np.zeros(n_max)\n        el_field1_result = np.zeros(n_max)\n        el_field2_result = np.zeros(n_max)\n        Ec_result = np.zeros(n_max)\n        Ev_result = np.zeros(n_max)\n        Ei_result = np.zeros(n_max)\n        Efn_result = np.zeros(n_max)\n        Efp_result = np.zeros(n_max)\n        av_curr = np.zeros(Total_Steps)\n        fi_result = V_[vindex, :]\n        # Efn_result,Efp_result=Fn_[vindex,:],Fp_[vindex,:]\n        nf_result, pf_result = n_[vindex, :], p_[vindex, :]\n        av_curr = Jtotal[:, n_max - 1]\n        for i in range(1, n_max - 1):\n            Ec_result[i] = fi_e[i] / q - V_[vindex, i]  # Values from the second Node%\n            Ev_result[i] = fi_h[i] / q - V_[vindex, i]  # Values from the second Node%\n            Ei_result[i] = Ec_result[i] - ((fi_e[i] - fi_h[i]) / (2 * q))\n            ro_result[i] = -q * (n_[vindex, i] - p_[vindex, i] - ns * dop[i])\n            el_field1_result[i] = -(V_[vindex, i + 1] - V_[vindex, i]) / (dx)\n            el_field2_result[i] = -(V_[vindex, i + 1] - V_[vindex, i - 1]) / (2 * dx)\n            Efn_result[i] = Ei_result[i] + Vt * log(n_[vindex, i]/ni[i]+1)\n            Efp_result[i] = Ei_result[i] - Vt * log(p_[vindex, i]/ni[i]+1)\n        Ec_result[0] = Ec_result[1]\n        Ec_result[n_max - 1] = Ec_result[n_max - 2]\n        Ev_result[0] = Ev_result[1]\n        Ev_result[n_max - 1] = Ev_result[n_max - 2]\n\n        Ei_result[0] = Ei_result[1]\n        Ei_result[n_max - 1] = Ei_result[n_max - 2]\n        Efn_result[0] = Efn_result[1]\n        Efn_result[n_max - 1] = Efn_result[n_max - 2]\n\n        Efp_result[0] = Efp_result[1]\n        Efp_result[n_max - 1] = Efp_result[n_max - 2]\n        el_field1_result[0] = el_field1_result[1]\n        el_field2_result[0] = el_field2_result[1]\n        el_field1_result[n_max - 1] = el_field1_result[n_max - 2]\n        el_field2_result[n_max - 1] = el_field2_result[n_max - 2]\n        ro_result[0] = ro_result[1]\n        ro_result[n_max - 1] = ro_result[n_max - 2]\n        nf_result[0] = nf_result[1]\n        nf_result[n_max - 1] = nf_result[n_max - 2]\n        pf_result[0] = pf_result[1]\n        pf_result[n_max - 1] = pf_result[n_max - 2]\n        Va_t = vvect\n        fitot = fi_h - Vt * q * odata.V\n        fitotc = fi_e - Vt * q * odata.V\n        if model.N_wells_virtual - 2 != 0 and config.quantum_effect:\n            (\n                idata.E_statec_general,\n                idata.E_state_general,\n                idata.wfe_general,\n                idata.wfh_general,\n                idata.meff_statec_general,\n                idata.meff_state_general,\n            ) = Schro(\n                HUPMAT3_reduced_list,\n                HUPMATC1,\n                subnumber_h,\n                subnumber_e,\n                fitot,\n                fitotc,\n                model,\n                Well_boundary,\n                UNIM,\n                RATIO,\n                m_hh,\n                m_lh,\n                m_so,\n                n_max,\n            )\n    time3 = time.time()  # timing audit\n    if not (config.messagesoff):\n        logger.info(""calculation time  %g s"", (time3 - time2))\n\n    class Results:\n        pass\n\n    results = Results()\n    results.N_wells_virtual = N_wells_virtual\n    results.Well_boundary = Well_boundary\n    results.xaxis = xaxis\n    results.wfh = wfh\n    results.wfe = wfe\n    results.wfh_general = idata.wfh_general\n    results.wfe_general = idata.wfe_general\n    results.fitot = fitot\n    results.fitotc = fitotc\n    results.fi_e = fi_e\n    results.fi_h = fi_h\n    # results.sigma = sigma\n    results.sigma_general = sigma_general\n    # results.F = F\n    results.V = V\n    results.E_state = E_state\n    results.N_state = N_state\n    # results.meff_state = meff_state\n    results.E_statec = E_statec\n    results.N_statec = N_statec\n    # results.meff_statec = meff_statec\n    results.F_general = F_general\n    results.E_state_general = idata.E_state_general\n    results.N_state_general = N_state_general\n    results.meff_state_general = idata.meff_state_general\n    results.E_statec_general = idata.E_statec_general\n    results.N_statec_general = N_statec_general\n    results.meff_statec_general = idata.meff_statec_general\n    results.Fapp = Fapp\n    results.T = T\n    # results.E_F = E_F\n    results.E_F_general = E_F_general\n    results.dx = dx\n    results.subnumber_h = subnumber_h\n    results.subnumber_e = subnumber_e\n    results.Ntotal2d = Ntotal2d\n    ########################\n    results.Va_t = Va_t\n    results.Efn_result = Efn_result\n    results.Efp_result = Efp_result\n    results.Ei_result = Ei_result\n    results.av_curr = av_curr\n    results.Ec_result = Ec_result\n    results.Ev_result = Ev_result\n    results.ro_result = ro_result\n    results.el_field1_result = el_field1_result\n    results.el_field2_result = el_field2_result\n    results.nf_result = nf_result\n    results.pf_result = pf_result\n    results.fi_result = fi_result\n    results.EF = EF\n    results.Total_Steps = Total_Steps\n    return results\n\n\ndef save_and_plot2(result, model):\n    xaxis = result.xaxis\n    output_directory = ""output_""+model.inputfilename + ""_eh""\n    #output_directory = config.output_directory + ""_eh""\n    output_directory = os.path.join(examplesdir, output_directory)\n\n    if not os.path.isdir(output_directory):\n        os.makedirs(output_directory)\n\n    def saveoutput(fname, datatuple, header=""""):\n        fname2 = os.path.join(output_directory, fname)\n        np.savetxt(\n            fname2, np.column_stack(datatuple), fmt=""%.6e"", delimiter="" "", header=header\n        )\n\n    # Plotting results\n    # if config.Drift_Diffusion_out:\n    # saveoutput(""av_curr.dat"",(result.Va_t*Vt,result.av_curr*1e-4))\n    for jjj in range(result.Total_Steps - 1, result.Total_Steps):\n        vtt = result.Va_t[jjj]\n        vt = vtt\n        if config.Drift_Diffusion_out:\n            if config.sigma_out:\n                saveoutput(""sigma_eh_%.2f.dat"" % vt, (xaxis, result.ro_result))\n            if config.electricfield_out:\n                saveoutput(\n                    ""efield_eh_%.2f.dat"" % vt,\n                    (xaxis, result.el_field1_result, result.el_field2_result),\n                )\n            if config.potential_out:\n                saveoutput(\n                    ""potn_eh_%.2f.dat"" % vt,\n                    (xaxis * 1e2, result.Ec_result, result.Ev_result),\n                )\n                saveoutput(\n                    ""np_data0_%.2f.dat"" % vt,\n                    (xaxis * 1e2, result.nf_result * 1e-6, result.pf_result * 1e-6),\n                )\n            if config.states_out and 1 == 2:\n                for j in range(1, result.N_wells_virtual - 1):\n                    rel_meff_state = [\n                        meff / m_e for meff in result.meff_state_general[j]\n                    ]  # going to report relative effective mass.\n                    columns = (\n                        range(model.subnumber_h),\n                        result.E_state_general[j],\n                        result.N_state_general[j],\n                        rel_meff_state,\n                    )\n                    # header = "" "".join([col.ljust(12) for col in (""State No."",""Energy (meV)"",""N (m**-2)"",""Subband m* (m_e)"")])\n                    header = ""State No.    Energy (meV) N (m**-2)    Subband m* (kg)""\n                    saveoutput(\n                        ""states_h_QWR%d_%.2f.dat"" % (j, vt), columns, header=header\n                    )\n                    if config.probability_out:\n                        saveoutput(\n                            ""wavefunctions_h_QWR%d_%.2f.dat"" % (j, vt),\n                            (xaxis, result.wfh_general[j].transpose()),\n                        )\n            if config.states_out and 1 == 2:\n                for j in range(1, result.N_wells_virtual - 1):\n                    rel_meff_statec = [\n                        meff / m_e for meff in result.meff_statec_general[j]\n                    ]  # going to report relative effective mass.\n                    columns = (\n                        range(model.subnumber_e),\n                        result.E_statec_general[j],\n                        result.N_statec_general[j],\n                        rel_meff_statec,\n                    )\n                    # header = "" "".join([col.ljust(12) for col in (""State No."",""Energy (meV)"",""N (m**-2)"",""Subband m* (m_e)"")])\n                    header = ""State No.    Energy (meV) N (m**-2)    Subband m* (kg)""\n                    saveoutput(\n                        ""states_e_QWR%d_%.2f.dat"" % (j, vt), columns, header=header\n                    )\n                    if config.probability_out:\n                        saveoutput(\n                            ""wavefunctions_e_QWR%d_%.2f.dat"" % (j, vt),\n                            (xaxis, result.wfe_general[j].transpose()),\n                        )\n    if config.resultviewer:\n        span = np.ones(100000000)\n        fig1 = pl.figure(figsize=(10, 8))\n        pl.suptitle(""Aestimo Results"")\n        pl.subplot(1, 1, 1)\n        pl.plot(\n            xaxis * 1e6,\n            result.Ec_result,\n            xaxis * 1e6,\n            result.Ev_result,\n            xaxis * 1e6,\n            result.Ei_result,\n            xaxis * 1e6,\n            result.Efn_result,\n            ""r"",\n            xaxis * 1e6,\n            result.Efp_result,\n            ""b"",\n        )\n        if model.N_wells_virtual - 2 != 0:\n            for j in range(1, result.N_wells_virtual - 1):\n                I1, I2, I11, I22 = amort_wave(j, result.Well_boundary, model.n_max)\n                i1 = I1 - I1\n                i2 = I2 - I1\n                for levelc, statec in zip(\n                    result.E_statec_general[j, :], result.wfe_general[j, :, :]\n                ):\n                    # pl.axhline(levelc,0.1,0.9, hold=True,color=\'g\',ls=\'--\')\n                    pl.plot(\n                        xaxis[I1:I2] * 1e6,\n                        statec[i1:i2] * config.wavefunction_scalefactor * 1e-3\n                        + levelc * 1e-3,\n                        ""b"",\n                    )\n                    pl.plot(\n                        xaxis[I1:I2] * 1e6, levelc * span[I1:I2] * 1e-3, ""g"", ls=""--""\n                    )\n                for level, state in zip(\n                    result.E_state_general[j, :], result.wfh_general[j, :, :]\n                ):\n                    # pl.axhline(level,0.1,0.9,color=\'g\',ls=\'--\')\n                    pl.plot(\n                        xaxis[I1:I2] * 1e6,\n                        state[i1:i2] * config.wavefunction_scalefactor * 1e-3\n                        + level * 1e-3,\n                        ""b"",\n                    )\n                    pl.plot(\n                        xaxis[I1:I2] * 1e6, level * span[I1:I2] * 1e-3, ""g"", ls=""--""\n                    )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Energy [eV]"")\n        pl.title(""Quasi Fermi Levels (Efn (red) & Efp (bleu)) vs Position"", fontsize=12)\n        pl.legend((""Ec"", ""Ev"", ""Ei"", ""Efn"", ""Efp""), loc=""best"", fontsize=12)\n        pl.grid(True)\n\n        fig2 = pl.figure(figsize=(10, 8))\n        pl.suptitle(\n            ""1D Drift Diffusion Model Results - at Applied Bias (%.2f)""\n            % vt,\n            fontsize=12,\n        )\n        pl.subplots_adjust(hspace=0.4, wspace=0.4)\n\n        pl.subplot(2, 2, 1)\n        pl.plot(xaxis * 1e6, result.ro_result * 1e-6)\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Total Charge Density [C/cm^3]"")\n        pl.title(""Total Charge Density vs Position "", fontsize=12)\n        pl.legend((""Total Charge""), loc=""best"", fontsize=12)\n        pl.grid(True)\n        # Plotting Efield\n        # figure(1)\n        pl.subplot(2, 2, 2)\n        pl.plot(\n            xaxis * 1e6,\n            result.el_field1_result * 1e-8,\n            ""r"",\n            xaxis * 1e6,\n            result.el_field2_result * 1e-8,\n            ""b"",\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Electric Field 1(red) & 2 (bleu) [MV/cm]"")\n        pl.title(""Field Profile vs Position "", fontsize=12)\n        pl.legend((""Electric Field 1"", ""Electric Field 2""), loc=""best"", fontsize=12)\n        pl.grid(True)\n        # Plotting Potential\n        # figure(2)\n        pl.subplot(2, 2, 3)\n        pl.plot(xaxis * 1e6, result.Ec_result)\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Conduction Band Energy (eV)"")\n        pl.title(""Conduction Band vs Position "", fontsize=12)\n        pl.legend((""Conduction Band""), loc=""best"", fontsize=12)\n        pl.grid(True)\n        # Plotting State(s)\n        # figure(3)\n        pl.subplot(2, 2, 4)\n        pl.plot(result.Va_t , result.av_curr * 1e-4)\n        pl.xlabel(""Va [V]"")\n        pl.ylabel(""Total Current Density [Amp/cm^2]"")\n        pl.title(""I vs V Plot"", fontsize=12)\n        pl.legend((""Total Current""), loc=""best"", fontsize=12)\n        pl.grid(True)\n        pl.show()\n\n        fig3 = pl.figure(figsize=(10, 8))\n        pl.suptitle(\n            ""1D Drift Diffusion Model Results - at Applied Bias (%.2f)""\n            % vt,\n            fontsize=12,\n        )\n        pl.subplots_adjust(hspace=0.4, wspace=0.4)\n        pl.subplot(2, 2, 1)\n        pl.plot(\n            xaxis * 1e6,\n            result.nf_result * 1e-6,\n            ""r"",\n            xaxis * 1e6,\n            result.pf_result * 1e-6,\n            ""b"",\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Electron  & Hole  Densities [1/cm^3]"")\n        pl.title(""Electron (red) & Hole (bleu) Densities vs Position "", fontsize=12)\n        pl.legend((""Electron"", ""Hole""), loc=""best"", fontsize=12)\n        pl.grid(True)\n\n        pl.subplot(2, 2, 2)\n        pl.plot(\n            xaxis * 1e6,\n            result.Ec_result,\n            xaxis * 1e6,\n            result.Ev_result,\n            xaxis * 1e6,\n            result.Ei_result,\n            xaxis * 1e6,\n            result.Efn_result,\n            ""r"",\n            xaxis * 1e6,\n            result.Efp_result,\n            ""b"",\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Energy [eV]"")\n        pl.title(""Quasi Fermi Levels (Efn (red) & Efp (bleu)) vs Position"", fontsize=12)\n        pl.legend((""Ec"", ""Ev"", ""Ei"", ""Efn"", ""Efp""), loc=""best"", fontsize=12)\n        pl.grid(True)\n\n        pl.subplot(2, 2, 3)\n        pl.plot(xaxis * 1e6, Vt * result.fi_result)\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Potential [V]"")\n        pl.title(""Potential vs Position"", fontsize=12)\n        pl.legend((""fi""), loc=""best"", fontsize=12)\n        pl.grid(True)\n\n        pl.subplot(2, 2, 4)\n        pl.plot(\n            xaxis * 1e6, result.Efn_result, ""r"", xaxis * 1e6, result.Efp_result, ""b""\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Energy [eV]"")\n        pl.title(""Quasi Fermi Levels (Efn (red) & Efp (bleu)) vs Position"", fontsize=12)\n        pl.legend((""Efn"", ""Efp""), loc=""best"", fontsize=12)\n        pl.grid(True)\n        pl.show()\n    return [fig1, fig2, fig3]\n\n\ndef save_and_plot(result, model):\n\n    xaxis = result.xaxis\n    output_directory = ""output_""+model.inputfilename + ""_eh""\n    #output_directory = config.output_directory + ""_eh""\n    output_directory = os.path.join(examplesdir, output_directory)\n    \n    if not os.path.isdir(output_directory):\n        os.makedirs(output_directory)\n\n    def saveoutput(fname, datatuple, header=""""):\n        fname2 = os.path.join(output_directory, fname)\n        np.savetxt(\n            fname2, np.column_stack(datatuple), fmt=""%.6e"", delimiter="" "", header=header\n        )\n\n    if config.sigma_out:\n        saveoutput(""sigma_eh_equi_cond.dat"", (xaxis, result.ro_result))\n    if config.electricfield_out:\n        saveoutput(\n            ""efield_eh_equi_cond.dat"", (xaxis, result.el_field1_result, result.el_field2_result)\n        )\n    if config.potential_out:\n        saveoutput(""potn_eh_equi_cond.dat"", (xaxis * 1e2, result.fitotc / q, result.fitot / q))\n        saveoutput(\n            ""np_data0_equi_cond.dat"",\n            (xaxis * 1e2, result.nf_result * 1e-6, result.pf_result * 1e-6),\n        )\n    if config.states_out:\n        for j in range(1, result.N_wells_virtual - 1):\n            rel_meff_state = [\n                meff / m_e for meff in result.meff_state_general[j]\n            ]  # going to report relative effective mass.\n            columns = (\n                range(model.subnumber_h),\n                result.E_state_general[j],\n                result.N_state_general[j],\n                rel_meff_state,\n            )\n            # header = "" "".join([col.ljust(12) for col in (""State No."",""Energy (meV)"",""N (m**-2)"",""Subband m* (m_e)"")])\n            header = ""State No.    Energy (meV) N (m**-2)    Subband m* (kg)""\n            saveoutput(""states_h_QWR%d_equi_cond.dat"" % j, columns, header=header)\n            if config.probability_out:\n                saveoutput(\n                    ""wavefunctions_h_QWR%d_equi_cond.dat"" % j,\n                    (xaxis, result.wfh_general[j].transpose()),\n                )\n    if config.states_out:\n        for j in range(1, result.N_wells_virtual - 1):\n            rel_meff_statec = [\n                meff / m_e for meff in result.meff_statec_general[j]\n            ]  # going to report relative effective mass.\n            columns = (\n                range(model.subnumber_e),\n                result.E_statec_general[j],\n                result.N_statec_general[j],\n                rel_meff_statec,\n            )\n            # header = "" "".join([col.ljust(12) for col in (""State No."",""Energy (meV)"",""N (m**-2)"",""Subband m* (m_e)"")])\n            header = ""State No.    Energy (meV) N (m**-2)    Subband m* (kg)""\n            saveoutput(""states_e_QWR%d_equi_cond.dat"" % j, columns, header=header)\n            if config.probability_out:\n                saveoutput(\n                    ""wavefunctions_e_QWR%d_equi_cond.dat"" % j,\n                    (xaxis, result.wfe_general[j].transpose()),\n                )\n    # Resultviewer\n    if config.resultviewer:\n        span = np.ones(100000000)\n        fig1 = pl.figure(figsize=(10, 8))\n        pl.suptitle(""Aestimo Results - at Equilibrium Condition"")\n        pl.subplot(1, 1, 1)\n        pl.plot(xaxis, result.fitot * J2meV, ""k"", xaxis, result.fitotc * J2meV, ""k"")\n        for j in range(1, result.N_wells_virtual - 1):\n            I1, I2, I11, I22 = amort_wave(j, result.Well_boundary, model.n_max)\n            i1 = I1 - I1\n            i2 = I2 - I1\n            for levelc, statec in zip(\n                result.E_statec_general[j, :], result.wfe_general[j, :, :]\n            ):\n                # pl.axhline(levelc,0.1,0.9, hold=True,color=\'g\',ls=\'--\')\n                pl.plot(\n                    xaxis[I1:I2],\n                    statec[i1:i2] * config.wavefunction_scalefactor + levelc,\n                    ""b"",\n                )\n                pl.plot(xaxis[I1:I2], levelc * span[I1:I2], ""g"", ls=""--"")\n            for level, state in zip(\n                result.E_state_general[j, :], result.wfh_general[j, :, :]\n            ):\n                # pl.axhline(level,0.1,0.9,color=\'g\',ls=\'--\')\n                pl.plot(\n                    xaxis[I1:I2],\n                    state[i1:i2] * config.wavefunction_scalefactor + level,\n                    ""b"",\n                )\n                pl.plot(xaxis[I1:I2], level * span[I1:I2], ""g"", ls=""--"")\n            # pl.plot(xaxis, state**2*1e-9/dx*200.0+level,\'b\')\n        pl.plot(xaxis, result.EF * span[0 : model.n_max], ""r"", ls=""--"")\n        # pl.axhline(result.E_F,0.1,0.9,color=\'r\',ls=\'--\')\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Energy (meV)"")\n        pl.grid(True)\n\n        fig2 = pl.figure(figsize=(10, 8))\n        pl.suptitle(\n            ""Aestimo Results - at Equilibrium Condition "",\n            fontsize=12,\n        )\n        pl.subplots_adjust(hspace=0.4, wspace=0.4)\n\n        # Plotting Sigma\n        # figure(0)\n        pl.subplot(2, 2, 1)\n        pl.plot(xaxis * 1e6, result.ro_result * 1e-6)\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Total Charge Density [C/cm^3]"")\n        pl.title(""Total Charge Density vs Position "", fontsize=10)\n        pl.grid(True)\n\n        # Plotting Efield\n        # figure(1)\n        pl.subplot(2, 2, 2)\n        pl.plot(\n            xaxis * 1e6,\n            result.el_field1_result * 1e-8,\n            ""r"",\n            xaxis * 1e6,\n            result.el_field2_result * 1e-8,\n            ""b"",\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Electric Field  [MV/cm]"")\n        pl.title(""Field Profile 1(red) & 2 (bleu) vs Position "", fontsize=10)\n        pl.grid(True)\n\n        # Plotting Potential\n        # figure(2)\n        pl.subplot(2, 2, 3)\n        pl.plot(xaxis * 1e6, Vt * result.fi_result)\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Potential [V]"")\n        pl.title(""Potential vs Position"", fontsize=12)\n        pl.legend((""fi""), loc=""best"", fontsize=12)\n        pl.grid(True)\n\n        pl.subplot(2, 2, 4)\n        pl.plot(\n            xaxis * 1e6,\n            result.nf_result * 1e-6,\n            ""r"",\n            xaxis * 1e6,\n            result.pf_result * 1e-6,\n            ""b"",\n        )\n        pl.xlabel(""x [um]"")\n        pl.ylabel(""Electron  & Hole  Densities [1/cm^3]"")\n        pl.title(""Electron (red)& Hole (bleu) Densities vs Position "", fontsize=10)\n        pl.grid(True)\n        pl.show()\n    return [fig1, fig2]\n\n\ndef run_aestimo(input_obj):\n    """"""A utility function that performs the standard simulation run\n    for \'normal\' input files. Input_obj can be a dict, class, named tuple or \n    module with the attributes needed to create the StructureFrom class, see \n    the class implementation or some of the sample-*.py files for details.""""""\n    if not (config.messagesoff):\n        logger.info(""Aestimo_eh is starting..."")\n    # Initialise structure class\n    model = StructureFrom(input_obj, database)\n\n    # Perform the calculation\n    \n    if model.comp_scheme == 10:\n        result = Poisson_Schrodinger_new(model)\n    else:\n        result = Poisson_Schrodinger(model)\n    if model.comp_scheme == 7:\n        result_dd = Poisson_Schrodinger_DD(result, model)\n    if model.comp_scheme == 8:\n        result_dd = Poisson_Schrodinger_DD_test(result, model)\n    if model.comp_scheme == 9:\n        result_dd = Poisson_Schrodinger_DD_test_2(result, model)\n    time4 = time.time()  # timing audit\n    if not (config.messagesoff):\n\n        logger.info(""total running time (inc. loading libraries) %g s"", (time4 - time0))\n        logger.info(""total running time (exc. loading libraries) %g s"", (time4 - time1))\n    # Write the simulation results in files\n    if model.comp_scheme == 7 or model.comp_scheme == 8 or model.comp_scheme == 2 or model.comp_scheme == 10:\n        save_and_plot(result, model)\n    if model.comp_scheme == 7 or model.comp_scheme == 8 or model.comp_scheme == 9:\n        save_and_plot2(result_dd, model)\n    if not (config.messagesoff):\n        logger.info(\n            """"""Simulation is finished. All files are closed. Please control the related files.\n                    -----------------------------------------------------------------""""""\n        )\n    return input_obj, model, result\n\n\nif __name__ == ""__main__"":\n    import optparse\n\n    parser = optparse.OptionParser()\n    parser.add_option(\n        ""-i"",\n        ""--inputfile"",\n        action=""store"",\n        dest=""inputfile"",\n        default=config.inputfilename,\n        help=""chose input file to override default in config.py"",\n    )\n    (options, args) = parser.parse_args()\n\n    # Import from config file\n    inputfile = __import__(options.inputfile)\n    \n    if not (config.messagesoff):\n        logger.info(""inputfile is %s"", options.inputfile)\n    run_aestimo(inputfile)\n'"
aestimo_poisson1d.py,261,"b'# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2020 Aestimo Group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS \n\nFile Information:\n-----------------\nMost of the code in this file are converted from Matlab to python and adapted to fit aestimo\'s\nneeds from this book:\nComputational electronics : semiclassical and quantum device modeling and simulation. by:\n    [Dragica Vasileska; Stephen M Goodnick; Gerhard Klimeck]\n""""""\nimport numpy as np\nimport matplotlib.pyplot as pl\nfrom math import exp, log, sqrt\n\nif __package__:  # explicit relative imports for using aestimo as a package (in python3)\n    from . import config\nelse:\n    import config\n\n# Defining constants and material parameters\nq = 1.602176e-19  # C\nkb = 1.3806504e-23  # J/K\nnii = 0.0\nhbar = 1.054588757e-34  # m2 kg / s\nm_e = 9.1093826e-31  # kg\npi = np.pi\neps0 = 8.8541878176e-12  # F/m\n# TEMPERATURE\nT = 300.0  # Kelvin\nVt = kb * T / q  # [eV]\nJ2meV = 1e3 / q  # Joules to meV\nmeV2J = 1e-3 * q  # meV to Joules\n\n\ndef Poisson_equi2(\n    ns,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    n,\n    p,\n    dx,\n    Ldi,\n    dop,\n    Ppz_Psp,\n    pol_surf_char,\n    ni,\n    n_max,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    surface,\n    fi_stat,\n):\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    Ppz_Psp_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi_old\n    dop_out = dop / (ns * ni)\n    Ppz_Psp_out = Ppz_Psp / (ns * ni)\n    delta_acc = 1.0e-5\n    dx2 = dx * dx\n    Ldi2 = Ldi * Ldi\n    iteration0 = 1\n\n    if iteration == iteration0:\n        # Determination of the Fermi Level\n        EF = 0.0\n        fi_out = np.zeros(n_max)\n        n, p, fi_out = equi_np_fi(\n            iteration, dop, Ppz_Psp, n_max, ni, model, Vt, surface\n        )\n        fi_stat = fi_out\n    else:\n        n, p, fi_non, EF = equi_np_fi3(\n            fi_out,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            n_max,\n            ni,\n        )\n    for i in range(1, n_max - 1):\n        a[i] = Ldi2[i] / (dx2)\n        c[i] = Ldi2[i] / (dx2)\n        b[i] = -(2 * Ldi2[i] / (dx2) + n[i] / ns + p[i] / ns)\n        f[i] = (\n            n[i] / ns\n            - p[i] / ns\n            - dop_out[i]\n            - Ppz_Psp_out[i]\n            - (fi_out[i] * (n[i] / ns + p[i] / ns))\n        )\n    # (B) Define the elements of the coefficient matrix and initialize the forcing\n    # function at the ohmic contacts\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    # (C) Start the iterative procedure for the solution of the linearized Poisson\n    # equation using LU decomposition method:\n    flag_conv = True  # convergence of the Poisson loop\n    k_iter = 0\n    while flag_conv:\n        k_iter = k_iter + 1\n        d[0] = b[0]\n        for i in range(1, n_max):\n            d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n        # Solution of Lv=f:\n        v[0] = f[0]\n        for i in range(1, n_max):\n            v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n        # Solution of U*fi=v:\n        temp = v[n_max - 1] / d[n_max - 1]\n        delta[n_max - 1] = temp - fi_out[n_max - 1]\n        fi_out[n_max - 1] = temp\n        for i in range(n_max - 2, -1, -1):\n            temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n            delta[i] = temp - fi_out[i]\n            fi_out[i] = temp\n        # Test update in the outer iteration loop:\n        delta_max = 0.0\n        delta_max = max(abs(delta[:]))\n        # print (\'k_iter=\',k_iter, \'delta_max=\',delta_max)\n        # Test convergence and recalculate forcing function and\n        # central coefficient b if necessary:\n        if delta_max < delta_acc:\n            flag_conv = False\n        else:\n            if iteration == iteration0:\n                n = np.exp(fi_out)\n                p = np.exp(-fi_out)\n            else:\n                n, p, fi_non, EF = equi_np_fi3(\n                    fi_out,\n                    wfh_general,\n                    wfe_general,\n                    model,\n                    E_state_general,\n                    E_statec_general,\n                    meff_state_general,\n                    meff_statec_general,\n                    n_max,\n                    ni,\n                )\n            for i in range(1, n_max - 1):\n                b[i] = -(2 * Ldi2[i] / (dx2) + n[i] / ns + p[i] / ns)\n                f[i] = (\n                    n[i] / ns\n                    - p[i] / ns\n                    - dop_out[i]\n                    - Ppz_Psp_out[i]\n                    - (fi_out[i] * (n[i] / ns + p[i] / ns))\n                )\n    return n, p, fi_out, EF, fi_stat\n\n\ndef Poisson_equi_non_2(\n    vindex,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    n,\n    p,\n    dx,\n    Ldi,\n    dop,\n    Ppz_Psp,\n    pol_surf_char,\n    ni,\n    n_max,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    surface,\n    fi_stat,\n):\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    Ppz_Psp_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi_old\n    dop_out = dop / ni\n    Ppz_Psp_out = Ppz_Psp / ni\n    delta_acc = 1.0e-5\n    dx2 = dx * dx\n    Ldi2 = Ldi * Ldi\n    if config.predic_correc:  # (check high concentrations)\n        n = np.zeros(n_max)\n        p = np.zeros(n_max)\n        n, p, fi_non, EF = equi_np_fi3(\n            fi_out,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            n_max,\n            ni,\n        )\n    else:\n        n, p, fi_non = equi_np_fi22(\n            vindex,\n            fitotc,\n            fitot,\n            Nc,\n            Nv,\n            fi_e,\n            fi_h,\n            iteration,\n            fi_out,\n            Vt,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            dop,\n            Ppz_Psp,\n            n_max,\n            ni,\n            n,\n            p,\n        )\n    for i in range(0, n_max):\n        a[i] = Ldi2[i] / (dx2)\n        c[i] = Ldi2[i] / (dx2)\n        b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n        f[i] = n[i] - p[i] - dop_out[i] - Ppz_Psp_out[i] - fi_out[i] * (n[i] + p[i])\n    # (B) Define the elements of the coefficient matrix and initialize the forcing\n    # function at the ohmic contacts\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    # (C) Start the iterative procedure for the solution of the linearized Poisson\n    # equation using LU decomposition method:\n    flag_conv = True  # convergence of the Poisson loop\n    k_iter = 0\n    while flag_conv:\n        k_iter = k_iter + 1\n        d[0] = b[0]\n        for i in range(1, n_max):\n            d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n        # Solution of Lv=f:\n        v[0] = f[0]\n        for i in range(1, n_max):\n            v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n        # Solution of U*fi=v:\n        temp = v[n_max - 1] / d[n_max - 1]\n        delta[n_max - 1] = temp - fi_out[n_max - 1]\n        fi_out[n_max - 1] = temp\n        for i in range(n_max - 2, -1, -1):\n            temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n            delta[i] = temp - fi_out[i]\n            fi_out[i] = temp\n        # Test update in the outer iteration loop:\n        delta_max = 0.0\n        delta_max = max(abs(delta[:]))\n        # print (\'k_iter=\',k_iter, \'delta_max=\',delta_max)\n        # Test convergence and recalculate forcing function and\n        # central coefficient b if necessary:\n        if delta_max < delta_acc:\n            flag_conv = False\n        else:\n            if config.predic_correc:\n                n = np.zeros(n_max)\n                p = np.zeros(n_max)\n                n, p, fi_non, EF = equi_np_fi3(\n                    fi_out,\n                    wfh_general,\n                    wfe_general,\n                    model,\n                    E_state_general,\n                    E_statec_general,\n                    meff_state_general,\n                    meff_statec_general,\n                    n_max,\n                    ni,\n                )\n            else:\n                n, p, fi_non = equi_np_fi22(\n                    vindex,\n                    fitotc,\n                    fitot,\n                    Nc,\n                    Nv,\n                    fi_e,\n                    fi_h,\n                    iteration,\n                    fi_out,\n                    Vt,\n                    wfh_general,\n                    wfe_general,\n                    model,\n                    E_state_general,\n                    E_statec_general,\n                    meff_state_general,\n                    meff_statec_general,\n                    dop,\n                    Ppz_Psp,\n                    n_max,\n                    ni,\n                    n,\n                    p,\n                )\n            for i in range(1, n_max - 1):\n                b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n                f[i] = (\n                    n[i]\n                    - p[i]\n                    - dop_out[i]\n                    - Ppz_Psp_out[i]\n                    - fi_out[i] * (n[i] + p[i])\n                )\n    return n, p, fi_out, fi_stat\n\n\ndef fd1(Ei, Ef, model):  # use\n    """"""integral of Fermi Dirac Equation for energy independent density of states.\n    Ei [meV], Ef [meV], T [K]""""""\n    T = model.T\n    return kb * T * log(exp(meV2J * (Ei - Ef) / (kb * T)) + 1)\n\n\ndef fd2(Ei, Ef, model):\n    """"""integral of Fermi Dirac Equation for energy independent density of states.\n    Ei [meV], Ef [meV], T [K]""""""\n    T = model.T\n    return kb * T * log(exp(meV2J * (Ef - Ei) / (kb * T)) + 1)\n\n\ndef fd3(x):\n    """"""\n    Approximation used for the Fermi integral by:\n    D. Bednarczyk and J. Bednarczyk, The approximation of the Fermi-Dirac\n    integral f1/2(\xce\xb7), Phys. Lett., vol. 64A, pp. 409\xe2\x80\x93410, 1978.\n    """"""\n    return 1 / (\n        exp(-x)\n        + 3\n        / 4\n        * sqrt(pi)\n        * (x ** 4 + 50 + 33.6 * x * (1 - 0.68 * exp(-0.17 * (x + 1) ** 2))) ** (-3 / 8)\n    )\n\n\ndef fd4(x):\n    """"""\n    Approximation used for the Fermi integral by:\n    Ehrenberg W (1950) The electric conductivity of simple semiconductors. Proc Phys Soc A 63:75\n    """"""\n    return 2 * sqrt(pi) * (exp(x)) / (4 + exp(x))\n\n\ndef fd5(x):\n    """"""\n    Approximation used for the Fermi integral by:\n    Shun_Lien_Chuang Physics of Photonic Devices, 2009 by John Wiley & Sons, p 36.\n    """"""\n    return 4 / 3 * sqrt(abs(x) ** 3 / pi)\n\n\ndef fd6(x):\n    x = abs(x)\n    """"""\n    Approximation used for the Fermi integral by:\n\n    """"""\n    return (\n        log(x) / (x ** 2 - 1)\n        + (3 * sqrt(pi) * x / 4) ** (2 / 3)\n        + (2 * 3 * sqrt(pi) * x / 4) / (3 + 3 * sqrt(pi) * x / 4) ** 2\n    )\n\n\ndef fd7(x):\n    """"""\n    Approximation used for the Fermi integral by:\n    D. Bednarczyk and J. Bednarczyk, The approximation of the Fermi-Dirac\n    integral f1/2(\xce\xb7), Phys. Lett., vol. 64A, pp. 409\xe2\x80\x93410, 1978.\n    """"""\n    return exp(-x) + 3 / 4 * sqrt(pi) * (\n        x ** 4 + 50 + 33.6 * x * (1 - 0.68 * exp(-0.17 * (x + 1) ** 2))\n    ) ** (-3 / 8)\n\n\ndef amort_wave(j, Well_boundary, n_max):\n    import config\n\n    I11 = Well_boundary[j, 0]\n    I22 = Well_boundary[j, 1]\n    amort_wave_0 = int(\n        config.amort_wave_0 * (Well_boundary[j, 1] - Well_boundary[j, 0]) / 2\n    )\n    amort_wave_1 = int(\n        config.amort_wave_1 * (Well_boundary[j, 1] - Well_boundary[j, 0]) / 2\n    )\n\n    I1 = I11 - amort_wave_0  # n_max-70#\n    I2 = I22 + amort_wave_1  # n_max-5#\n    return I1, I2, I11, I22\n\n\ndef equi_np_fi2(\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    dop,\n    Ppz_Psp,\n    n_max,\n    ni,\n):  # use\n    n = np.zeros(n_max)\n    n_cl = np.zeros(n_max)\n    n_qw = np.zeros(n_max)\n    p = np.zeros(n_max)\n    p_cl = np.zeros(n_max)\n    p_qw = np.zeros(n_max)\n    Ef_Ec = np.zeros(n_max)\n    Ev_Ef = np.zeros(n_max)\n    E3kbT = np.zeros(n_max)\n    # Determination of the Fermi Level\n    ###################################################\n    """"""\n    nn=20000\n    n1=np.zeros(2*nn)\n    n2=np.zeros(2*nn)\n    p2=np.zeros(2*nn)    \n    n3=np.zeros(2*nn)\n    n7=np.zeros(2*nn)\n    p1=np.zeros(2*nn)        \n    for i5 in range(-nn,nn):\n        p1[i5+nn]=-(i5)/(0.0001*nn)#*meV2J/(kb*T)#Nv[i1]*fd3((fi_h[i1]-Vt*q*fi_old[i1])/(kb*T))/ni[i1]\n        p2[i5+nn]=-(i5)/(0.0001*nn)/1000\n        n1[i5+nn]=fd3(p1[i5+nn]*meV2J/(kb*T))#Nc[i1]*fd3(-(fi_e[i1]-Vt*q*fi_old[i1])/(kb*T))/ni[i1]\n        n2[i5+nn]=fd4(p1[i5+nn]*meV2J/(kb*T))\n        n3[i5+nn]=exp(p1[i5+nn]*meV2J/(kb*T))\n        \n        #n7[i5+nn]=fd7(p1[i5+nn]*meV2J/(kb*T))\n        \n        #print(n1[i5+nn])\n\n    xaxis = np.arange(0,n_max)*model.dx\n    #pl.plot(p1, n7)\n    pl.plot(p2, n1,\'r\',p2,n2,\'b\',p2,n3,\'k\')\n    #pl.plot(xaxis, Ef_Ec,\'r\',xaxis,E3kbT,\'b\')\n    pl.xlabel(\'Ef-Ec (meV)\')\n    pl.ylabel(\'Fermi integral F1/2\' )\n    pl.title(\'\')\n    pl.grid(True)\n    pl.legend((\'fd3\',\'fd4\',\'exp\'),loc=\'best\',fontsize=12)    \n    pl.show()     \n    sssss\n    """"""\n    #######################################################\n    EF = 0.0\n    for i1 in range(0, n_max):\n        Ef_Ec[i1] = (EF - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T)  # *J2meV\n        Ev_Ef[i1] = ((fi_h[i1] - Vt * q * fi_old[i1]) - EF) / (kb * T)  # *J2meV\n        E3kbT[i1] = -3 * kb * T / (kb * T)  # *J2meV\n        # print(\'Ef_Ec[%d]=\'%i1,Ef_Ec[i1]*J2meV*(kb*T),\'meV\')\n        # print(\'Eg[%d]=\'%i1,abs(Ef_Ec[i1]*J2meV*(kb*T)+Ev_Ef[i1]*J2meV*(kb*T)),\'meV\')\n        if Ef_Ec[i1] * J2meV * (kb * T) > 1000000000000:\n            print(""Ef_Ec[%d]="" % i1, Ef_Ec[i1] * J2meV * (kb * T), ""meV"")\n            print(""fi_old="", fi_old[i1] * J2meV, ""meV"")\n            exit()\n        if EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1]) > -3 * kb * T:  # -3*kb*T\n            n_cl[i1] = (\n                Nc[i1]\n                * fd3((EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T))\n                / ni[i1]\n            )\n        else:\n            n_cl[i1] = (\n                Nc[i1]\n                * exp((EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T))\n                / ni[i1]\n            )\n            # print(n[i1])\n        if (fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J > -3 * kb * T:  # -3*kb*T\n            p_cl[i1] = (\n                Nv[i1]\n                * fd3(((fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J) / (kb * T))\n                / ni[i1]\n            )\n        else:\n            p_cl[i1] = (\n                Nv[i1]\n                * exp(((fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J) / (kb * T))\n                / ni[i1]\n            )\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        i1 = I1 - I1\n        # See C. de Faco et al. / Journal of Computational Physics 204 (2005) page 538 for\n        # the jump discontinuity in the electron density n across the interface\n        n_cl[I1:I2] = 0.0\n        p_cl[I1:I2] = 0.0\n        # couter=0\n        for j in range(0, model.subnumber_e, 1):\n            for i in range(I1, I2):\n                n_qw[i] += (\n                    (\n                        fd2(E_statec_general[k, j], EF, model)\n                        * meff_statec_general[k, j]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfe_general[k, j, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n        for jj in range(0, model.subnumber_h, 1):\n            for ii in range(I1, I2):\n                p_qw[ii] += (\n                    (\n                        fd1(E_state_general[k, jj], EF, model)\n                        * meff_state_general[k, jj]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfh_general[k, jj, ii - I1]) ** 2\n                    / (ni[ii] * model.dx)\n                )\n    n = n_cl + n_qw\n    p = p_cl + p_qw\n    return n, p, fi_old, EF  # density of carriers\n\n\ndef equi_np_fi4(\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    dop,\n    Ppz_Psp,\n    n_max,\n    ni,\n):  # use\n    n = np.zeros(n_max)\n    n_cl = np.zeros(n_max)\n    n_qw = np.zeros(n_max)\n    p = np.zeros(n_max)\n    p_cl = np.zeros(n_max)\n    p_qw = np.zeros(n_max)\n    Ef_Ec = np.zeros(n_max)\n    Ev_Ef = np.zeros(n_max)\n    E3kbT = np.zeros(n_max)\n    # Determination of the Fermi Level\n    EF = 0.0\n    for i1 in range(0, n_max):\n        Ef_Ec[i1] = (EF - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T)  # *J2meV\n        Ev_Ef[i1] = ((fi_h[i1] - Vt * q * fi_old[i1]) - EF) / (kb * T)  # *J2meV\n        E3kbT[i1] = -3 * kb * T / (kb * T)  # *J2meV\n        if EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1]) > -3 * kb * T:  # -3*kb*T\n            n_cl[i1] = (\n                Nc[i1]\n                * fd3((EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T))\n                / ni[i1]\n            )\n        else:\n            n_cl[i1] = (\n                Nc[i1]\n                * exp((EF * meV2J - (fi_e[i1] - Vt * q * fi_old[i1])) / (kb * T))\n                / ni[i1]\n            )\n            # print(n[i1])\n        if (fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J > -3 * kb * T:  # -3*kb*T\n            p_cl[i1] = (\n                Nv[i1]\n                * fd3(((fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J) / (kb * T))\n                / ni[i1]\n            )\n        else:\n            p_cl[i1] = (\n                Nv[i1]\n                * exp(((fi_h[i1] - Vt * q * fi_old[i1]) - EF * meV2J) / (kb * T))\n                / ni[i1]\n            )\n    if config.quantum_effect:\n\n        for k in range(1, model.N_wells_virtual - 1):\n            I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n            i1 = I1 - I1\n            """"""\n            See C. de Faco et al. / Journal of Computational Physics 204 (2005) page 538 for \n            the jump discontinuity in the electron density n across the interface\n            """"""\n            n_cl[I1:I2] = 0.0\n            p_cl[I1:I2] = 0.0\n\n            # couter=0\n            for j in range(0, model.subnumber_e, 1):\n                for i in range(I1, I2):\n                    n_qw[i] += (\n                        (\n                            fd2(E_statec_general[k, j], EF, model)\n                            * meff_statec_general[k, j]\n                            / (hbar ** 2 * pi)\n                        )\n                        * (wfe_general[k, j, i - I1]) ** 2\n                        / (ni[i] * model.dx)\n                    )\n                    """"""\n                    if (fi_e[i]-Vt*q*fi_old[i])*J2meV<E_statec_general[k,j] and couter==0:                    \n                        n_cl[i]+=Nc[i]*fd4((EF*meV2J-(fi_e[i]-Vt*q*fi_old[i]))/(kb*T))*(max(wfe_general[k,j,0:I2])**2)/ni[i]\n                        couter+=1\n                    elif couter!=0:\n                        if (fi_e[i]-Vt*q*fi_old[i])*J2meV<E_statec_general[k,j] and (fi_e[i]-Vt*q*fi_old[i])*J2meV>E_statec_general[k,j-1]:\n                            n_cl[i]+=Nc[i]*fd4((EF*meV2J-(fi_e[i]-Vt*q*fi_old[i]))/(kb*T))*(max(wfe_general[k,j,0:I2])**2)/ni[i]\n                    """"""\n            for jj in range(0, model.subnumber_h, 1):\n                for ii in range(I1, I2):\n                    p_qw[ii] += (\n                        (\n                            fd1(E_state_general[k, jj], EF, model)\n                            * meff_state_general[k, jj]\n                            / (hbar ** 2 * pi)\n                        )\n                        * (wfh_general[k, jj, ii - I1]) ** 2\n                        / (ni[ii] * model.dx)\n                    )\n    n = n_cl + n_qw\n    p = p_cl + p_qw\n    return n, p, fi_old, EF  # density of carriers\n\n\ndef equi_np_fi3(\n    fi_old,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    n_max,\n    ni,\n):  # use\n    n = np.exp(fi_old)\n    p = np.exp(-fi_old)\n    fi_stat = np.zeros(n_max)\n    Delta_fi = np.zeros(n_max)\n    if not (config.predic_correc):\n        fi_stat = fi_old\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        n[I1:I2] = 0.0\n        p[I1:I2] = 0.0\n        for i in range(I1, I2):\n            Delta_fi[i] = -Vt * q * fi_stat[i] - (-Vt * q * fi_old[i])\n            for j in range(0, model.subnumber_e, 1):\n                #print(""E_statec_general="",(E_statec_general[k, j] - Delta_fi[i] * J2meV))\n                n[i] += (\n                    (\n                        fd2(\n                            E_statec_general[k, j] - Delta_fi[i] * J2meV,\n                            0.0,\n                            model,\n                        )\n                        * meff_statec_general[k, j]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfe_general[k, j, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n            for jj in range(0, model.subnumber_h, 1):\n                p[i] += (\n                    (\n                        fd1(\n                            E_state_general[k, jj] - Delta_fi[i] * J2meV,\n                            0.0,\n                            model,\n                        )\n                        * meff_state_general[k, jj]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfh_general[k, jj, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n    return n, p, fi_old, 0.0\n\n\ndef Ber(x):\n    flag_sum = True\n    if x > 0.01:\n        Ber_1 = x * exp(-x) / (1.0 - exp(-x))\n    elif x < 0 and abs(x) > 0.01:\n        Ber_1 = x / (exp(x) - 1.0)\n    elif x == 0:\n        Ber_1 = 1.0\n    else:\n        temp_term = 1.0\n        sum_1 = temp_term\n        j = 0.0\n        while flag_sum:\n            j = j + 1\n            temp_term = temp_term * x / (j + 1)\n            # print sum_1+temp_term,\'=\',sum_1\n            if sum_1 + temp_term == sum_1:\n                flag_sum = False\n            sum_1 = sum_1 + temp_term\n        Ber_1 = 1.0 / sum_1\n    return Ber_1\n\n\ndef Ber2(x):\n    if np.abs(x) < 1e-12:\n        return 1.0\n    else:\n        return x / np.expm1(x)\n\n\ndef Ber3(x):\n    if x < -0.7:\n        return -x\n    elif x < 0.009 and x > -0.009:\n        return 1 - x / 2\n    else:\n        return x / (exp(x) + 1)\n\n\ndef Poisson_equi1(dx, dop, fi, n_max):\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi\n    dop_out = dop\n    delta_acc = 1.0e-5\n    dx2 = dx * dx\n    for i in range(0, n_max):\n        a[i] = 1.0 / (dx2)\n        c[i] = 1.0 / (dx2)\n        b[i] = -(2.0 / (dx2) + exp(fi_out[i]) + exp(-fi_out[i]))\n        f[i] = (\n            exp(fi_out[i])\n            - exp(-fi_out[i])\n            - dop_out[i]\n            - fi_out[i] * (exp(fi_out[i]) + exp(-fi_out[i]))\n        )\n    # (B) Define the elements of the coefficient matrix and initialize the forcing\n    # function at the ohmic contacts\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    # (C) Start the iterative procedure for the solution of the linearized Poisson\n    # equation using LU decomposition method:\n    flag_conv = True  # convergence of the Poisson loop\n    k_iter = 0\n    while flag_conv:\n        k_iter = k_iter + 1\n        d[0] = b[0]\n        for i in range(1, n_max):\n            d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n        # Solution of Lv=f:\n        v[0] = f[0]\n        for i in range(1, n_max):\n            v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n        # Solution of U*fi=v:\n        temp = v[n_max - 1] / d[n_max - 1]\n        delta[n_max - 1] = temp - fi_out[n_max - 1]\n        fi_out[n_max - 1] = temp\n        for i in range(n_max - 2, -1, -1):\n            temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n            delta[i] = temp - fi_out[i]\n            fi_out[i] = temp\n        # Test update in the outer iteration loop:\n        delta_max = 0.0\n        delta_max = max(abs(delta[:]))\n        print(""k_iter="", k_iter, ""delta_max="", delta_max)\n        # Test convergence and recalculate forcing function and\n        # central coefficient b if necessary:\n        if delta_max < delta_acc:\n            flag_conv = False\n        else:\n            for i in range(1, n_max - 1):\n                b[i] = -(2.0 / (dx2) + exp(fi_out[i]) + exp(-fi_out[i]))\n                f[i] = (\n                    exp(fi_out[i])\n                    - exp(-fi_out[i])\n                    - dop_out[i]\n                    - fi_out[i] * (exp(fi_out[i]) + exp(-fi_out[i]))\n                )\n    return fi_out, a, b, c, d, f, v\n\n\ndef Mobility1(mun0, mup0, fi, Vt, Ldi, VSATN, VSATP, BETAN, BETAP, n_max, dx):\n    #######################################################################\n    #% 3.1 . Calculate Field Dependant Mobility for each value of \'fi\'   ##\n    #%       at each node point of the PN diode.                         ##\n    #######################################################################\n    Ef = np.zeros(n_max)\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n\n    """"""\n    ### To test with Constant Mobility without field dependancy.        \n    for i in range(0,n_max):           # Start Loop for Field Dep Mobility \n        mup[i] = mup0\n        mun[i] = mun0\n    # #           \n    """"""\n    # [0] Solution of electron current continuity equation:\n    # .................\n    # (1a) Define the elements of the coefficient matrix and\n    # initialize the forcing function:\n    ## Calculate the Electric Field at each Node\n    for i in range(0, n_max - 1):\n        Ef[i] = abs(fi[i] - fi[i + 1]) * Vt / (dx * Ldi)\n    Ef[0] = Ef[1]\n    Ef[n_max - 1] = Ef[n_max - 2]\n    ## Calculate the Field Dependant Mobility at each Node\n    for i in range(0, n_max):\n        pdeno = (mup0 * Ef[i] / VSATP) ** BETAP\n        mup[i] = mup0 * ((1 / (1 + pdeno)) ** (1 / BETAP))\n        ndeno = (mun0 * Ef[i] / VSATN) ** BETAN\n        mun[i] = mun0 * ((1 / (1 + ndeno)) ** (1 / BETAN))\n    mup[0] = mup[1]\n    mup[n_max - 1] = mup[n_max - 2]\n    mun[0] = mun[1]\n    mun[n_max - 1] = mun[n_max - 2]\n    return mun, mup\n\n\ndef Continuity1(n, p, mun, mup, fi, Vt, Ldi, n_max, dx, TAUN0, TAUP0):\n    #################################################################################\n    ## 3.2 Solve Continuity Equation for Electron and Holes using LU Decomposition ##\n    #################################################################################\n    # (A) Define the elements of the coefficient matrix and initialize the forcing\n    #    function at the ohmic contacts for ELECTRON and HOLE Continuity\n    vp = np.zeros(n_max)\n    dp = np.zeros(n_max)\n    vn = np.zeros(n_max)\n    fp = np.zeros(n_max)\n    cp = np.zeros(n_max)\n    bp = np.zeros(n_max)\n    ap = np.zeros(n_max)\n    fn = np.zeros(n_max)\n    cn = np.zeros(n_max)\n    bn = np.zeros(n_max)\n    dn = np.zeros(n_max)\n    an = np.zeros(n_max)\n    betan = np.zeros(n_max)\n    betap = np.zeros(n_max)\n    dx2 = dx * dx\n    an[0] = 0  # Co-ef for electron at Anode\n    bn[0] = 1  # Co-ef for electron at Anode\n    cn[0] = 0  # Co-ef for electron at Anode\n    ap[0] = 0  # Co-ef for hole     at Anode\n    bp[0] = 1  # Co-ef for hole     at Anode\n    cp[0] = 0  # Co-ef for hole     at Anode\n    # fnp[0] = (Ldi*Ldi*dx2/Vt) * ( p[0]*n[0] - 1 ) / ( TAUP0*(n[0] + 1 ) + TAUN0*(p[0] + 1 ) )\n    fn[0] = n[0]\n    fp[0] = p[0]\n    an[n_max - 1] = 0  # Co-ef for electron at Cathode\n    bn[n_max - 1] = 1  # Co-ef for electron at Cathode\n    cn[n_max - 1] = 0  # Co-ef for electron at Cathode\n    ap[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    bp[n_max - 1] = 1  # Co-ef for hole     at Cathode\n    cp[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    # fnp[n_max-1] = (Ldi*Ldi*dx2/Vt) * ( p[n_max-1]*n[n_max-1] - 1 ) / ( TAUP0*(n[n_max-1] + 1) + TAUN0*(p[n_max-1] + 1) )\n    fn[n_max - 1] = n[n_max - 1]\n    fp[n_max - 1] = p[n_max - 1]\n    # (B) Define the elements of the coefficient matrix for the internal nodes and\n    #    initialize the forcing function\n    for i in range(1, n_max - 1):\n        munim1by2 = (mun[i - 1] + mun[i]) / 2\n        munip1by2 = (mun[i] + mun[i + 1]) / 2\n        mupim1by2 = (mup[i - 1] + mup[i]) / 2\n        mupip1by2 = (mup[i] + mup[i + 1]) / 2\n        ## Co-efficients for HOLE Continuity eqn\n        ap[i] = mupim1by2 * Ber((fi[i] - fi[i - 1]))\n        cp[i] = mupip1by2 * Ber((fi[i] - fi[i + 1]))\n        bp[i] = -(\n            mupim1by2 * Ber((fi[i - 1] - fi[i])) + mupip1by2 * Ber((fi[i + 1] - fi[i]))\n        )\n        ## Co-efficients for ELECTRON Continuity eqn\n        an[i] = munim1by2 * Ber((fi[i - 1] - fi[i]))\n        cn[i] = munip1by2 * Ber((fi[i + 1] - fi[i]))\n        bn[i] = -(\n            munim1by2 * Ber((fi[i] - fi[i - 1])) + munip1by2 * Ber(fi[i] - fi[i + 1])\n        )\n        ## Forcing Function for ELECTRON and HOLE Continuity eqns\n        fn[i] = (\n            (Ldi * Ldi * dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0 * (n[i] + 1) + TAUN0 * (p[i] + 1))\n        )\n        fp[i] = (\n            (Ldi * Ldi * dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0 * (n[i] + 1) + TAUN0 * (p[i] + 1))\n        )\n    # (C)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""ELECTRONS"" using LU decomposition method:\n    dn[0] = bn[0]\n    for i in range(1, n_max):\n        betan[i] = an[i] / dn[i - 1]\n        dn[i] = bn[i] - betan[i] * cn[i - 1]\n    # Solution of Lv = f #\n    vn[0] = fn[0]\n    for i in range(1, n_max):\n        vn[i] = fn[i] - betan[i] * vn[i - 1]\n    # Solution of U*fi = v #\n    tempn = vn[n_max - 1] / dn[n_max - 1]\n    # deltan[n_max-1] = tempn - n[n_max-1]\n    n[n_max - 1] = tempn\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempn = (vn[i] - cn[i] * n[i + 1]) / dn[i]\n        #  deltan[i] = tempn - n[i]\n        n[i] = tempn\n    ####################### END of ELECTRON Continuty Solver ###########\n    # (D)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""HOLES"" using LU decomposition method:\n    dp[0] = bp[0]\n    for i in range(1, n_max):\n        betap[i] = ap[i] / dp[i - 1]\n        dp[i] = bp[i] - betap[i] * cp[i - 1]\n    # Solution of Lv = f #\n    vp[0] = fp[0]\n    for i in range(1, n_max):\n        vp[i] = fp[i] - betap[i] * vp[i - 1]\n    # Solution of U*fi = v #\n    tempp = vp[n_max - 1] / dp[n_max - 1]\n    # deltap[n_max-1] = tempp - p[n_max-1]\n    p[n_max - 1] = tempp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempp = (vp[i] - cp[i] * p[i + 1]) / dp[i]\n        #   deltap[i] = tempp - p[i]\n        p[i] = tempp\n    ####################### END of HOLE Continuty Solver ###########\n    return n, p\n\n\ndef Poisson_non_equi1(n, p, dop, n_max, dx, fi, flag_conv_2):\n    ####################################################################\n    ## 3.3 Calculate potential fi again with new values of ""n"" and ""p""##\n    ##     and check for convergence                                  ##\n    ####################################################################\n    # Recalculate forcing function and central coefficient b for fi\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi\n    dop_out = dop\n    dx2 = dx * dx\n    delta_acc = 1.0e-5\n    for i in range(1, n_max - 1):\n        a[i] = 1.0 / (dx2)\n        c[i] = 1.0 / (dx2)\n        b[i] = -(2 / (dx2) + n[i] + p[i])\n        f[i] = n[i] - p[i] - dop_out[i] - (fi_out[i] * (n[i] + p[i]))\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    ## here values of n[i] and p[i] are used in place of exp(fi[i])\n    # Solve for Updated potential given the new value of Forcing\n    # Function using LU decomposition\n    d[0] = b[0]\n    for i in range(1, n_max):\n        d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n    # Solution of Lv = f #\n    v[0] = f[0]\n    for i in range(1, n_max):\n        v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n    # Solution of U*fi = v #\n    temp = v[n_max - 1] / d[n_max - 1]\n    delta[n_max - 1] = temp - fi_out[n_max - 1]\n    fi_out[n_max - 1] = temp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n        delta[i] = temp - fi_out[i]\n        fi_out[i] = temp\n    delta_max = 0\n    delta_max = max(abs(delta[:]))\n    # Test convergence and start the loop if necessary else increase\n    # the applied potential\n    print(""delta_max= "", delta_max)\n    if delta_max < delta_acc:\n        flag_conv_2 = False\n    else:\n        for i in range(1, n_max - 1):\n            b[i] = -(2 / (dx2) + n[i] + p[i])\n            f[i] = n[i] - p[i] - dop_out[i] - (fi_out[i] * (n[i] + p[i]))\n    return fi_out, flag_conv_2\n\n\ndef Current1(\n    vindex,\n    n,\n    p,\n    mun,\n    mup,\n    fi,\n    Vt,\n    n_max,\n    Total_Steps,\n    q,\n    dx,\n    ni,\n    Ldi,\n    Jnip1by2,\n    Jnim1by2,\n    Jelec,\n    Jpip1by2,\n    Jpim1by2,\n    Jhole,\n):\n    ##########################################################################\n    ##                        CALCULATE CURRENT                             ##\n    ##########################################################################\n    for i in range(1, n_max - 1):\n\n        # Electron Current\n        Jnip1by2[vindex, i] = (\n            (q * mun[i] * Vt / (dx * Ldi))\n            * ni\n            * (n[i + 1] * Ber((fi[i + 1] - fi[i])) - n[i] * Ber((fi[i] - fi[i + 1])))\n        )\n        Jnim1by2[vindex, i] = (\n            (q * mun[i] * Vt / (dx * Ldi))\n            * ni\n            * (n[i] * Ber((fi[i] - fi[i - 1])) - n[i - 1] * Ber((fi[i - 1] - fi[i])))\n        )\n        Jelec[vindex, i] = (Jnip1by2[vindex, i] + Jnim1by2[vindex, i]) / 2\n        # Hole Current\n        Jpip1by2[vindex, i] = (\n            (q * mup[i] * Vt / (dx * Ldi))\n            * ni\n            * (p[i + 1] * Ber((fi[i] - fi[i + 1])) - p[i] * Ber((fi[i + 1] - fi[i])))\n        )\n        Jpim1by2[vindex, i] = (\n            (q * mup[i] * Vt / (dx * Ldi))\n            * ni\n            * (p[i] * Ber((fi[i - 1] - fi[i])) - p[i - 1] * Ber((fi[i] - fi[i - 1])))\n        )\n        Jhole[vindex, i] = (Jpip1by2[vindex, i] + Jpim1by2[vindex, i]) / 2\n    ##         Jtotal(vindex) = Jelec\n    return Jnip1by2, Jnim1by2, Jelec, Jpip1by2, Jpim1by2, Jhole\n\n\ndef Write_results_equi1(dEc, Vt, q, ni, n, p, dop, dx, Ldi, fi, n_max):\n    ro = np.zeros(n_max)\n    el_field1 = np.zeros(n_max)\n    el_field2 = np.zeros(n_max)\n    Ec = np.zeros(n_max)\n    for i in range(1, n_max - 1):\n        Ec[i] = dEc - Vt * fi[i]\n        ro[i] = -q * ni * (exp(fi[i]) - exp(-fi[i]) - dop[i])\n        el_field1[i] = -(fi[i + 1] - fi[i]) * Vt / (dx * Ldi)\n        el_field2[i] = -(fi[i + 1] - fi[i - 1]) * Vt / (2.0 * dx * Ldi)\n        n[i] = exp(fi[i])\n        p[i] = exp(-fi[i])\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    ro[0] = ro[1]\n    ro[n_max - 1] = ro[n_max - 2]\n    el_field1[0] = el_field1[1]\n    el_field1[n_max - 1] = el_field1[n_max - 2]\n    el_field2[0] = el_field2[1]\n    el_field2[n_max - 1] = el_field2[n_max - 2]\n    n[0] = n[1]\n    n[n_max - 1] = n[n_max - 2]\n    p[0] = p[1]\n    p[n_max - 1] = p[n_max - 2]\n    """"""\n    fi[0]=fi[1]\n    fi[n_max-1] = fi[n_max-2] \n    """"""\n    Ec_result = np.zeros(n_max)\n    ro_result = np.zeros(n_max)\n    el_field1_result = np.zeros(n_max)\n    el_field2_result = np.zeros(n_max)\n    nf_result = np.zeros(n_max)\n    pf_result = np.zeros(n_max)\n    fi_result = np.zeros(n_max)\n    Ec_result = Ec[0:n_max]\n    ro_result = ro[0:n_max]\n    el_field1_result = el_field1[0:n_max]\n    el_field2_result = el_field2[0:n_max]\n    nf_result = n[0:n_max] * ni\n    pf_result = p[0:n_max] * ni\n    fi_result = fi[0:n_max]\n    return (\n        Ec_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        fi_result,\n    )\n\n\ndef Write_results_equi2(ns, fitotc, fitot, Vt, q, ni, n, p, dop, dx, Ldi, fi, n_max):\n    ro = np.zeros(n_max)\n    el_field1 = np.zeros(n_max)\n    el_field2 = np.zeros(n_max)\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    for i in range(1, n_max - 1):\n        Ec[i] = fitotc[i]\n        Ev[i] = fitot[i]\n        ro[i] = -q * (ni[i] * n[i] - ni[i] * p[i] - dop[i])\n        el_field1[i] = -(fi[i + 1] - fi[i]) * Vt / (dx)\n        el_field2[i] = -(fi[i + 1] - fi[i - 1]) * Vt / (2.0 * dx)\n        n[i] = n[i]  # exp(fi[i])\n        p[i] = p[i]  # exp(-fi[i])\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    Ev[0] = Ev[1]\n    Ev[n_max - 1] = Ev[n_max - 2]\n    ro[0] = ro[1]\n    ro[n_max - 1] = ro[n_max - 2]\n    el_field1[0] = el_field1[1]\n    el_field1[n_max - 1] = el_field1[n_max - 2]\n    el_field2[0] = el_field2[1]\n    el_field2[n_max - 1] = el_field2[n_max - 2]\n    n[0] = n[1]\n    n[n_max - 1] = n[n_max - 2]\n    p[0] = p[1]\n    p[n_max - 1] = p[n_max - 2]\n\n    fi[0] = fi[1]\n    fi[n_max - 1] = fi[n_max - 2]\n    Ec_result = np.zeros(n_max)\n    Ev_result = np.zeros(n_max)\n    ro_result = np.zeros(n_max)\n    el_field1_result = np.zeros(n_max)\n    el_field2_result = np.zeros(n_max)\n    nf_result = np.zeros(n_max)\n    pf_result = np.zeros(n_max)\n    fi_result = np.zeros(n_max)\n    Ec_result = Ec[0:n_max]\n    Ev_result = Ev[0:n_max]\n    ro_result = ro[0:n_max]\n    el_field1_result = el_field1[0:n_max]\n    el_field2_result = el_field2[0:n_max]\n    nf_result = n[0:n_max] * ni[0:n_max]\n    pf_result = p[0:n_max] * ni[0:n_max]\n    fi_result = fi[0:n_max]\n    return (\n        Ec_result,\n        Ev_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        fi_result,\n    )\n\n\ndef Write_results_non_equi1(\n    dEc,\n    Vt,\n    q,\n    ni,\n    n,\n    p,\n    dop,\n    dx,\n    Ldi,\n    fi,\n    n_max,\n    Jnip1by2,\n    Jnim1by2,\n    Jelec,\n    Jpip1by2,\n    Jpim1by2,\n    Jhole,\n    Jtotal,\n    Total_Steps,\n):\n\n    axis = np.zeros(n_max)\n    ro = np.zeros(n_max)\n    el_field1 = np.zeros(n_max)\n    el_field2 = np.zeros(n_max)\n\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    Ei = np.zeros(n_max)\n    Efn = np.zeros(n_max)\n    Efp = np.zeros(n_max)\n    av_curr = np.zeros(Total_Steps)\n    axis[0] = dx * 1e4\n    for i in range(1, n_max - 1):\n        Ec[i] = dEc - Vt * fi[i]  # Values from the second Node%\n        ro[i] = -q * ni * (n[i] - p[i] - dop[i])\n        el_field1[i] = -(fi[i + 1] - fi[i]) * Vt / (dx * Ldi)\n        el_field2[i] = -(fi[i + 1] - fi[i - 1]) * Vt / (2 * dx * Ldi)\n        axis[i] = axis[i - 1] + dx * Ldi * 1e4\n    Jtotal[:, 0] = Jtotal[:, 1]\n    Jelec[:, 0] = Jelec[:, 1]\n    Jhole[:, 0] = Jhole[:, 1]\n    Jtotal[:, n_max - 1] = Jtotal[:, n_max - 2]\n    Jelec[:, n_max - 1] = Jelec[:, n_max - 2]\n    Jhole[:, n_max - 1] = Jhole[:, n_max - 2]\n\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    axis[n_max - 1] = axis[n_max - 2] + dx * Ldi * 1e4\n    el_field1[0] = el_field1[1]\n    el_field2[0] = el_field2[1]\n    el_field1[n_max - 1] = el_field1[n_max - 2]\n    el_field2[n_max - 1] = el_field2[n_max - 2]\n    ro[0] = ro[1]\n    ro[n_max - 1] = ro[n_max - 2]\n    n[0] = n[1]\n    n[n_max - 1] = n[n_max - 2]\n    p[0] = p[1]\n    p[n_max - 1] = p[n_max - 2]\n    nf = n * ni\n    pf = p * ni\n    Ev = Ec - 1.12\n    ## Calculate Quasi Fermi Level - Efn Efp\n    for i in range(0, n_max):\n        Ei[i] = Ec[i] - 0.56\n        Efn[i] = Ei[i] + Vt * log(nf[i] / ni)\n        Efp[i] = Ei[i] - Vt * log(pf[i] / ni)\n    Efn[0] = Efn[1]\n    Efn[n_max - 1] = Efn[n_max - 2]\n    Efp[0] = Efp[1]\n    Efp[n_max - 1] = Efp[n_max - 2]\n    for j in range(0, Total_Steps):\n        av_curr[j] = Jtotal[j, 0]\n    Ec_result = np.zeros(n_max)\n    Ev_result = np.zeros(n_max)\n    Ei_result = np.zeros(n_max)\n    Efp_result = np.zeros(n_max)\n    Efn_result = np.zeros(n_max)\n    fi_result = np.zeros(n_max)\n    fi_result = fi[0:n_max]\n    Efn_result = Efn[0:n_max]\n    Efp_result = Efp[0:n_max]\n    ro_result = np.zeros(n_max)\n    el_field1_result = np.zeros(n_max)\n    el_field2_result = np.zeros(n_max)\n    nf_result = np.zeros(n_max)\n    pf_result = np.zeros(n_max)\n    Ec_result = Ec[0:n_max]\n    Ev_result = Ev[0:n_max]\n    Ei_result = Ei[0:n_max]\n    ro_result = ro[0:n_max]\n    el_field1_result = el_field1[0:n_max]\n    el_field2_result = el_field2[0:n_max]\n    nf_result = n[0:n_max] * ni\n    pf_result = p[0:n_max] * ni\n    return (\n        fi_result,\n        Efn_result,\n        Efp_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        Ec_result,\n        Ev_result,\n        Ei_result,\n        axis,\n        av_curr,\n    )\n\n\ndef equi_np_fi(iteration, dop, Ppz_Psp, n_max, ni, model, Vt, surface):\n    n = np.zeros(n_max)\n    p = np.zeros(n_max)\n    fi_old = np.zeros(n_max)\n    for i2 in range(0, n_max):\n        nn, pp = np_cal(dop[i2] + Ppz_Psp[i2], ni[i2])\n        n[i2] = nn / ni[i2]\n        p[i2] = pp / ni[i2]\n        fi_old[i2] = log(n[i2])\n    fi_old[0] = fi_old[1]\n    fi_old[n_max - 1] = fi_old[n_max - 2]\n\n    fi_old[0] -= surface[0] / Vt\n    fi_old[n_max - 1] -= surface[1] / Vt\n    n = np.exp(fi_old)\n    p = np.exp(-fi_old)\n    return n, p, fi_old\n\n\ndef np_cal(dop, ni):\n    ni2 = ni ** 2\n    dop2 = dop ** 2\n    if dop > 0:\n        tmp = dop + sqrt(dop2 + 4 * ni2)\n        n = tmp / 2.0\n        p = ni2 / n\n    else:\n        dop = -1 * dop\n        tmp = dop + sqrt(dop2 + 4 * ni2)\n        p = tmp / 2.0\n        n = ni2 / p\n    return n, p\n\n\ndef Mobility2(mun0, mup0, fi, Vt, Ldi, VSATN, VSATP, BETAN, BETAP, n_max, dx):\n    #######################################################################\n    #% 3.1 . Calculate Field Dependant Mobility for each value of \'fi\'   ##\n    #%       at each node point of the PN diode.                         ##\n    #######################################################################\n    Efield = np.zeros(n_max)\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n\n    """"""\n    ### To test with Constant Mobility without field dependancy.        \n    for i in range(0,n_max):           # Start Loop for Field Dep Mobility \n        mup[i] = mup0[i]\n        mun[i] = mun0[i]\n    # #           \n    """"""\n    # [0] Solution of electron current continuity equation:\n    # .................\n    # (1a) Define the elements of the coefficient matrix and\n    # initialize the forcing function:\n    ## Calculate the Electric Field at each Node\n    for i in range(0, n_max - 1):\n        Efield[i] = abs(fi[i] - fi[i + 1]) * Vt / (dx)\n    Efield[0] = Efield[1]\n    Efield[n_max - 1] = Efield[n_max - 2]\n    ## Calculate the Field Dependant Mobility at each Node\n    for i in range(0, n_max):\n        pdeno = (mup0[i] * Efield[i] / VSATP[i]) ** BETAP[i]\n        mup[i] = mup0[i] * ((1 / (1 + pdeno)) ** (1 / BETAP[i]))\n        ndeno = (mun0[i] * Efield[i] / VSATN[i]) ** BETAN[i]\n        mun[i] = mun0[i] * ((1 / (1 + ndeno)) ** (1 / BETAN[i]))\n    mup[0] = mup[1]\n    mup[n_max - 1] = mup[n_max - 2]\n    mun[0] = mun[1]\n    mun[n_max - 1] = mun[n_max - 2]\n\n    return mun, mup\n\n\ndef Continuity2(n, p, mun, mup, fi, Vt, Ldi, n_max, dx, TAUN0, TAUP0):\n    #################################################################################\n    ## 3.2 Solve Continuity Equation for Electron and Holes using LU Decomposition ##\n    #################################################################################\n    # (A) Define the elements of the coefficient matrix and initialize the forcing\n    #    function at the ohmic contacts for ELECTRON and HOLE Continuity\n    vp = np.zeros(n_max)\n    dp = np.zeros(n_max)\n    vn = np.zeros(n_max)\n    fp = np.zeros(n_max)\n    cp = np.zeros(n_max)\n    bp = np.zeros(n_max)\n    ap = np.zeros(n_max)\n    fn = np.zeros(n_max)\n    cn = np.zeros(n_max)\n    bn = np.zeros(n_max)\n    dn = np.zeros(n_max)\n    an = np.zeros(n_max)\n    betan = np.zeros(n_max)\n    betap = np.zeros(n_max)\n    fnp = np.zeros(n_max)\n    dx2 = dx * dx\n    an[0] = 0  # Co-ef for electron at Anode\n    bn[0] = 1  # Co-ef for electron at Anode\n    cn[0] = 0  # Co-ef for electron at Anode\n    ap[0] = 0  # Co-ef for hole     at Anode\n    bp[0] = 1  # Co-ef for hole     at Anode\n    cp[0] = 0  # Co-ef for hole     at Anode\n    fnp[0] = (\n        (dx2 / Vt) * (p[0] * n[0] - 1) / (TAUP0[0] * (n[0] + 1) + TAUN0[0] * (p[0] + 1))\n    )\n    fn[0] = n[0]\n    fp[0] = p[0]\n    an[n_max - 1] = 0  # Co-ef for electron at Cathode\n    bn[n_max - 1] = 1  # Co-ef for electron at Cathode\n    cn[n_max - 1] = 0  # Co-ef for electron at Cathode\n    ap[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    bp[n_max - 1] = 1  # Co-ef for hole     at Cathode\n    cp[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    fnp[n_max - 1] = (\n        (dx2 / Vt)\n        * (p[n_max - 1] * n[n_max - 1] - 1)\n        / (\n            TAUP0[n_max - 1] * (n[n_max - 1] + 1)\n            + TAUN0[n_max - 1] * (p[n_max - 1] + 1)\n        )\n    )\n    fn[n_max - 1] = n[n_max - 1]\n    fp[n_max - 1] = p[n_max - 1]\n    # (B) Define the elements of the coefficient matrix for the internal nodes and\n    #    initialize the forcing function\n    for i in range(1, n_max - 1):\n        munim1by2 = (mun[i - 1] + mun[i]) / 2\n        munip1by2 = (mun[i] + mun[i + 1]) / 2\n        mupim1by2 = (mup[i - 1] + mup[i]) / 2\n        mupip1by2 = (mup[i] + mup[i + 1]) / 2\n        ## Co-efficients for HOLE Continuity eqn\n        ap[i] = mupim1by2 * Ber((fi[i] - fi[i - 1]))\n        cp[i] = mupip1by2 * Ber((fi[i] - fi[i + 1]))\n        bp[i] = -(\n            mupim1by2 * Ber((fi[i - 1] - fi[i])) + mupip1by2 * Ber((fi[i + 1] - fi[i]))\n        )\n        ## Co-efficients for ELECTRON Continuity eqn\n        an[i] = munim1by2 * Ber((fi[i - 1] - fi[i]))\n        cn[i] = munip1by2 * Ber((fi[i + 1] - fi[i]))\n        bn[i] = -(\n            munim1by2 * Ber((fi[i] - fi[i - 1])) + munip1by2 * Ber(fi[i] - fi[i + 1])\n        )\n        ## Forcing Function for ELECTRON and HOLE Continuity eqns\n        fn[i] = (\n            (dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0[i] * (n[i] + 1) + TAUN0[i] * (p[i] + 1))\n        )\n        fp[i] = (\n            (dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0[i] * (n[i] + 1) + TAUN0[i] * (p[i] + 1))\n        )\n    # (C)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""ELECTRONS"" using LU decomposition method:\n    dn[0] = bn[0]\n    for i in range(1, n_max):\n        betan[i] = an[i] / dn[i - 1]\n        dn[i] = bn[i] - betan[i] * cn[i - 1]\n    # Solution of Lv = f #\n    vn[0] = fn[0]\n    for i in range(1, n_max):\n        vn[i] = fn[i] - betan[i] * vn[i - 1]\n    # Solution of U*fi = v #\n    tempn = vn[n_max - 1] / dn[n_max - 1]\n    # deltan[n_max-1] = tempn - n[n_max-1]\n    n[n_max - 1] = tempn\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempn = (vn[i] - cn[i] * n[i + 1]) / dn[i]\n        #  deltan[i] = tempn - n[i]\n        n[i] = tempn\n    ####################### END of ELECTRON Continuty Solver ###########\n    # (D)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""HOLES"" using LU decomposition method:\n    # print(max(n[:]))\n    dp[0] = bp[0]\n    for i in range(1, n_max):\n        betap[i] = ap[i] / dp[i - 1]\n        dp[i] = bp[i] - betap[i] * cp[i - 1]\n    # Solution of Lv = f #\n    vp[0] = fp[0]\n    for i in range(1, n_max):\n        vp[i] = fp[i] - betap[i] * vp[i - 1]\n    # Solution of U*fi = v #\n    tempp = vp[n_max - 1] / dp[n_max - 1]\n    # deltap[n_max-1] = tempp - p[n_max-1]\n    p[n_max - 1] = tempp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempp = (vp[i] - cp[i] * p[i + 1]) / dp[i]\n        #   deltap[i] = tempp - p[i]\n        p[i] = tempp\n    ####################### END of HOLE Continuty Solver ###########\n    return n, p\n\n\ndef Mobility3(\n    mun0, mup0, fi, fi_n, fi_p, Vt, Ldi, VSATN, VSATP, BETAN, BETAP, n_max, dx\n):\n    #######################################################################\n    #% 3.1 . Calculate Field Dependant Mobility for each value of \'fi\'   ##\n    #%       at each node point of the PN diode.                         ##\n    #######################################################################\n    Efield = np.zeros(n_max)\n    mup = np.zeros(n_max)\n    mun = np.zeros(n_max)\n\n    """"""\n    ### To test with Constant Mobility without field dependancy.        \n    for i in range(0,n_max):           # Start Loop for Field Dep Mobility \n        mup[i] = mup0\n        mun[i] = mun0\n    # #           \n    """"""\n    # [0] Solution of electron current continuity equation:\n    # .................\n    # (1a) Define the elements of the coefficient matrix and\n    # initialize the forcing function:\n    ## Calculate the Electric Field at each Node\n    for i in range(0, n_max - 1):\n        Efield[i] = abs(fi[i] - fi[i + 1]) * Vt / (dx)\n    Efield[0] = Efield[1]\n    Efield[n_max - 1] = Efield[n_max - 2]\n    ## Calculate the Field Dependant Mobility at each Node\n    for i in range(0, n_max):\n        pdeno = (mup0[i] * Efield[i] / VSATP[i]) ** BETAP[i]\n        mup[i] = mup0[i] * ((1 / (1 + pdeno)) ** (1 / BETAP[i]))\n        ndeno = (mun0[i] * Efield[i] / VSATN[i]) ** BETAN[i]\n        mun[i] = mun0[i] * ((1 / (1 + ndeno)) ** (1 / BETAN[i]))\n    mup[0] = mup[1]\n    mup[n_max - 1] = mup[n_max - 2]\n    mun[0] = mun[1]\n    mun[n_max - 1] = mun[n_max - 2]\n    return mun, mup\n\n\ndef Continuity3(n, p, mun, mup, fi, fi_n, fi_p, Vt, Ldi, n_max, dx, TAUN0, TAUP0):\n    #################################################################################\n    ## 3.2 Solve Continuity Equation for Electron and Holes using LU Decomposition ##\n    #################################################################################\n    # (A) Define the elements of the coefficient matrix and initialize the forcing\n    #    function at the ohmic contacts for ELECTRON and HOLE Continuity\n    vp = np.zeros(n_max)\n    dp = np.zeros(n_max)\n    vn = np.zeros(n_max)\n    fp = np.zeros(n_max)\n    cp = np.zeros(n_max)\n    bp = np.zeros(n_max)\n    ap = np.zeros(n_max)\n    fn = np.zeros(n_max)\n    cn = np.zeros(n_max)\n    bn = np.zeros(n_max)\n    dn = np.zeros(n_max)\n    an = np.zeros(n_max)\n    betan = np.zeros(n_max)\n    betap = np.zeros(n_max)\n    dx2 = dx * dx\n    an[0] = 0  # Co-ef for electron at Anode\n    bn[0] = 1  # Co-ef for electron at Anode\n    cn[0] = 0  # Co-ef for electron at Anode\n    ap[0] = 0  # Co-ef for hole     at Anode\n    bp[0] = 1  # Co-ef for hole     at Anode\n    cp[0] = 0  # Co-ef for hole     at Anode\n    # fnp[0] = (Ldi*Ldi*dx2/Vt) * ( p[0]*n[0] - 1 ) / ( TAUP0*(n[0] + 1 ) + TAUN0*(p[0] + 1 ) )\n    fn[0] = n[0]\n    fp[0] = p[0]\n    an[n_max - 1] = 0  # Co-ef for electron at Cathode\n    bn[n_max - 1] = 1  # Co-ef for electron at Cathode\n    cn[n_max - 1] = 0  # Co-ef for electron at Cathode\n    ap[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    bp[n_max - 1] = 1  # Co-ef for hole     at Cathode\n    cp[n_max - 1] = 0  # Co-ef for hole     at Cathode\n    # fnp[n_max-1] = (Ldi*Ldi*dx2/Vt) * ( p[n_max-1]*n[n_max-1] - 1 ) / ( TAUP0*(n[n_max-1] + 1) + TAUN0*(p[n_max-1] + 1) )\n    fn[n_max - 1] = n[n_max - 1]\n    fp[n_max - 1] = p[n_max - 1]\n    # (B) Define the elements of the coefficient matrix for the internal nodes and\n    #    initialize the forcing function\n    for i in range(1, n_max - 1):\n        munim1by2 = (mun[i - 1] + mun[i]) / 2\n        munip1by2 = (mun[i] + mun[i + 1]) / 2\n        mupim1by2 = (mup[i - 1] + mup[i]) / 2\n        mupip1by2 = (mup[i] + mup[i + 1]) / 2\n        ## Co-efficients for HOLE Continuity eqn\n        ap[i] = mupim1by2 * Ber((fi[i] - fi[i - 1]) + (fi_p[i] - fi_p[i - 1]))\n        cp[i] = mupip1by2 * Ber((fi[i] - fi[i + 1]) + (fi_p[i] - fi_p[i + 1]))\n        bp[i] = -(\n            mupim1by2 * Ber((fi[i - 1] - fi[i]) + (fi_p[i - 1] - fi_p[i]))\n            + mupip1by2 * Ber((fi[i + 1] - fi[i]) + (fi_p[i + 1] - fi_p[i]))\n        )\n        ## Co-efficients for ELECTRON Continuity eqn\n        an[i] = munim1by2 * Ber((fi[i - 1] - fi[i]) + (fi_n[i - 1] - fi_n[i]))\n        cn[i] = munip1by2 * Ber((fi[i + 1] - fi[i]) + (fi_n[i + 1] - fi_n[i]))\n        bn[i] = -(\n            munim1by2 * Ber((fi[i] - fi[i - 1]) + (fi_n[i] - fi_n[i - 1]))\n            + munip1by2 * Ber((fi[i] - fi[i + 1]) + (fi_n[i] - fi_n[i + 1]))\n        )\n        ## Forcing Function for ELECTRON and HOLE Continuity eqns\n        fn[i] = (\n            (dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0[i] * (n[i] + 1) + TAUN0[i] * (p[i] + 1))\n        )\n        fp[i] = (\n            (dx2 / Vt)\n            * (p[i] * n[i] - 1)\n            / (TAUP0[i] * (n[i] + 1) + TAUN0[i] * (p[i] + 1))\n        )\n    # (C)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""ELECTRONS"" using LU decomposition method:\n    dn[0] = bn[0]\n    for i in range(1, n_max):\n        betan[i] = an[i] / dn[i - 1]\n        dn[i] = bn[i] - betan[i] * cn[i - 1]\n    # Solution of Lv = f #\n    vn[0] = fn[0]\n    for i in range(1, n_max):\n        vn[i] = fn[i] - betan[i] * vn[i - 1]\n    # Solution of U*fi = v #\n    tempn = vn[n_max - 1] / dn[n_max - 1]\n    # deltan[n_max-1] = tempn - n[n_max-1]\n    n[n_max - 1] = tempn\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempn = (vn[i] - cn[i] * n[i + 1]) / dn[i]\n        #  deltan[i] = tempn - n[i]\n        n[i] = tempn\n    ####################### END of ELECTRON Continuty Solver ###########\n    # (D)  Start the iterative procedure for the solution of the linearized Continuity\n    #     equation for ""HOLES"" using LU decomposition method:\n    dp[0] = bp[0]\n    for i in range(1, n_max):\n        betap[i] = ap[i] / dp[i - 1]\n        dp[i] = bp[i] - betap[i] * cp[i - 1]\n    # Solution of Lv = f #\n    vp[0] = fp[0]\n    for i in range(1, n_max):\n        vp[i] = fp[i] - betap[i] * vp[i - 1]\n    # Solution of U*fi = v #\n    tempp = vp[n_max - 1] / dp[n_max - 1]\n    # deltap[n_max-1] = tempp - p[n_max-1]\n    p[n_max - 1] = tempp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        tempp = (vp[i] - cp[i] * p[i + 1]) / dp[i]\n        #   deltap[i] = tempp - p[i]\n        p[i] = tempp\n    ####################### END of HOLE Continuty Solver ###########\n    return n, p\n\n\ndef Poisson_non_equi2(\n    fi_stat,\n    n,\n    p,\n    dop,\n    Ppz_Psp,\n    pol_surf_char,\n    n_max,\n    dx,\n    fi,\n    flag_conv_2,\n    Ldi,\n    ni,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n):\n    ####################################################################\n    ## 3.3 Calculate potential fi again with new values of ""n"" and ""p""##\n    ##     and check for convergence                                  ##\n    ####################################################################\n    # Recalculate forcing function and central coefficient b for fi\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    Ppz_Psp_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi\n    dop_out = dop / ni\n    Ppz_Psp_out = Ppz_Psp / ni\n    pol_surf_char_out = pol_surf_char / ni\n    dx2 = dx * dx\n    Ldi2 = Ldi * Ldi\n    delta_acc = 1.0e-4\n    if model.N_wells_virtual - 2 != 0 and 1 == 2:\n        n, p, fi_non, EF = equi_np_fi3(\n            fi_out,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            n_max,\n            ni,\n        )\n    for i in range(1, n_max - 1):\n        a[i] = Ldi2[i] / (dx2)\n        c[i] = Ldi2[i] / (dx2)\n        b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n        f[i] = n[i] - p[i] - dop_out[i] - Ppz_Psp_out[i] - (fi_out[i] * (n[i] + p[i]))\n        # f[i] = n[i] - p[i] - dop_out[i]-(pol_surf_char_out[i+1]-pol_surf_char_out[i-1])/(2*dx) - (fi_out[i]*(n[i] + p[i]))\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    ## here values of n[i] and p[i] are used in place of exp(fi[i])\n    # Solve for Updated potential given the new value of Forcing\n    # Function using LU decomposition\n    d[0] = b[0]\n    for i in range(1, n_max):\n        d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n    # Solution of Lv = f #\n    v[0] = f[0]\n    for i in range(1, n_max):\n        v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n    # Solution of U*fi = v #\n    temp = v[n_max - 1] / d[n_max - 1]\n    delta[n_max - 1] = temp - fi_out[n_max - 1]\n    fi_out[n_max - 1] = temp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n        delta[i] = temp - fi_out[i]\n        fi_out[i] = temp\n    delta_max = 0\n    delta_max = max(abs(delta[:]))\n    # Test convergence and start the loop if necessary else increase\n    # the applied potential\n    # print (\'delta_max= \',delta_max)\n    if delta_max < delta_acc:\n        flag_conv_2 = False\n    else:\n        fi_out0 = fi_out\n        fi_out0 += 0.15 * delta\n        fi_out = fi_out0\n        """"""""""""\n        if model.N_wells_virtual - 2 != 0 and 1 == 2:\n            n, p, fi_non, EF = equi_np_fi3(\n                fi_out,\n                wfh_general,\n                wfe_general,\n                model,\n                E_state_general,\n                E_statec_general,\n                meff_state_general,\n                meff_statec_general,\n                n_max,\n                ni,\n            )\n        for i in range(1, n_max - 1):\n            b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n            f[i] = (\n                n[i] - p[i] - dop_out[i] - Ppz_Psp_out[i] - (fi_out[i] * (n[i] + p[i]))\n            )\n            # f[i] = n[i] - p[i] - dop_out[i]-(pol_surf_char_out[i+1]-pol_surf_char_out[i-1])/(2*dx) - (fi_out[i]*(n[i] + p[i]))\n    return fi_out, flag_conv_2\n\n\ndef equi_np_fi31(\n    g,\n    fi_stat31,\n    n,\n    p,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    dop,\n    Ppz_Psp,\n    n_max,\n    ni,\n):  # use\n    EF = 0.0\n    nf = n * ni\n    pf = p * ni\n    E_statec_general_pc = E_statec_general\n    E_state_general_pc = E_state_general\n    ## Calculate Quasi Fermi Level - Efn Efp\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    Ei = np.zeros(n_max)\n    Efn = np.zeros(n_max)\n    Efp = np.zeros(n_max)\n    for i in range(1, n_max - 1):\n        Ec[i] = fi_e[i] / q - Vt * fi_old[i]  # Values from the second Node%\n        Ev[i] = fi_h[i] / q - Vt * fi_old[i]  # Values from the second Node%\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    Ev[0] = Ev[1]\n    Ev[n_max - 1] = Ev[n_max - 2]\n    """"""\n    if not(config.quantum_effect) and 1==2:\n        Ef_Ec=np.zeros(n_max)\n        Ev_Ef=np.zeros(n_max)\n        E3kbT=np.zeros(n_max)\n        #Determination of the Fermi Level\n        EF=0.0\n        for i1 in range(0,n_max):\n            Ef_Ec[i1]=(EF-(fi_e[i1]-Vt*q*fi_old[i1]))/(kb*T)#*J2meV\n            Ev_Ef[i1]=((fi_h[i1]-Vt*q*fi_old[i1])-EF)/(kb*T)#*J2meV\n            E3kbT[i1]=-3*kb*T/(kb*T)#*J2meV\n            if (EF*meV2J-(fi_e[i1]-Vt*q*fi_old[i1])>-3*kb*T  ) :#-3*kb*T \n                n[i1]=Nc[i1]*fd3((EF*meV2J-(fi_e[i1]-Vt*q*fi_old[i1]))/(kb*T))/ni[i1]\n            else:\n                n[i1]=Nc[i1]*exp((EF*meV2J-(fi_e[i1]-Vt*q*fi_old[i1]))/(kb*T))/ni[i1]\n                #print(n[i1])\n            if ((fi_h[i1]-Vt*q*fi_old[i1])-EF*meV2J>-3*kb*T ):#-3*kb*T \n                \n                p[i1]=Nv[i1]*fd3(((fi_h[i1]-Vt*q*fi_old[i1])-EF*meV2J)/(kb*T))/ni[i1]\n            else:\n                p[i1]=Nv[i1]*exp(((fi_h[i1]-Vt*q*fi_old[i1])-EF*meV2J)/(kb*T))/ni[i1]        \n        #fi_stat31=Ei=Efn=Efp\n        \n    else:    \n        for i in range(0,n_max):\n    """"""\n    Ei[i] = Ec[i] - ((fi_e[i] - fi_h[i]) / (2 * q))\n    Delta_fi = np.zeros(n_max)\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        n[I1:I2] = 0.0\n        p[I1:I2] = 0.0\n        for j in range(0, model.subnumber_e, 1):\n            for i in range(I1, I2):\n                Efn[i] = Ei[i] + Vt * log(abs((nf[i] + 1e-1) / ni[i]))\n                Delta_fi[i] = -Vt * q * fi_stat31[i] - (-Vt * q * fi_old[i])\n                n[i] += (\n                    (\n                        fd2(\n                            E_statec_general[k, j] - Delta_fi[i] * J2meV,\n                            Efn[i] * q * J2meV,\n                            model,\n                        )\n                        * meff_statec_general[k, j]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfe_general[k, j, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n        for jj in range(0, model.subnumber_h, 1):\n            for ii in range(I1, I2):\n                # print(Ei[ii],\' -\', Vt,\'*log(abs(\',pf[ii],\'/\',ni[ii],\'))\')\n                Efp[ii] = Ei[ii] - Vt * log(abs((pf[ii] + 1e-1) / ni[ii]))\n                Delta_fi[ii] = -Vt * q * fi_stat31[ii] - (\n                    -Vt * q * fi_old[ii]\n                )  # predictor-corrector-type approach.\n                # print(Delta_fi[ii],\'=\', -Vt*q*fi_stat31[ii],\'-\',(-Vt*q*fi_old[ii]))\n                p[ii] += (\n                    (\n                        fd1(\n                            E_state_general[k, jj] - Delta_fi[ii] * J2meV,\n                            Efp[ii] * q * J2meV,\n                            model,\n                        )\n                        * meff_state_general[k, jj]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfh_general[k, jj, ii - I1]) ** 2\n                    / (ni[ii] * model.dx)\n                )\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        for j in range(0, model.subnumber_e, 1):\n            E_statec_general_pc[k, j] = (\n                E_statec_general[k, j] - Delta_fi[I1:I2].mean() * J2meV\n            )\n        for jj in range(0, model.subnumber_h, 1):\n            E_state_general_pc[k, jj] = (\n                E_state_general[k, jj] - Delta_fi[I1:I2].mean() * J2meV\n            )\n        # print(Delta_fi[I1:I2])\n        # print(fi_old[I1:I2])\n    xaxis = np.arange(0, n_max) * model.dx\n    span = np.ones(100000000)\n    pl.plot(\n        xaxis, Ev * 1e3, ""k"", xaxis, Ec * 1e3, ""k""\n    )  # ,xaxis,Efn*1e3,\'r\',xaxis,Efp*1e3,\'b\')\n    for j in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(j, model.Well_boundary, model.n_max)\n        i1 = I1 - I1\n        i2 = I2 - I1\n        for levelc, statec in zip(E_statec_general_pc[j, :], wfe_general[j, :, :]):\n            # pl.axhline(levelc,0.1,0.9, hold=True,color=\'g\',ls=\'--\')\n            pl.plot(\n                xaxis[I1:I2],\n                statec[i1:i2] * config.wavefunction_scalefactor + levelc,\n                ""b"",\n            )\n            pl.plot(xaxis[I1:I2], levelc * span[I1:I2], ""g"", ls=""--"")\n        for level, state in zip(E_state_general_pc[j, :], wfh_general[j, :, :]):\n            # pl.axhline(level,0.1,0.9,color=\'g\',ls=\'--\')\n            pl.plot(\n                xaxis[I1:I2],\n                state[i1:i2] * config.wavefunction_scalefactor + level,\n                ""b"",\n            )\n            pl.plot(xaxis[I1:I2], level * span[I1:I2], ""g"", ls=""--"")\n        # pl.plot(xaxis, state**2*1e-9/dx*200.0+level,\'b\')\n    # pl.plot(xaxis,EF*span[0:model.n_max],\'r\',ls=\'--\')\n    # pl.axhline(E_F,0.1,0.9,color=\'r\',ls=\'--\')\n    pl.xlabel(""Position (m)"")\n    pl.ylabel(""Energy (meV)"")\n    pl.grid(True)\n    """"""""""""\n    return n, p, fi_old, EF  # density of carriers\n\n\ndef equi_np_fi22(\n    vindex,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    dop,\n    Ppz_Psp,\n    n_max,\n    ni,\n    n,\n    p,\n):  # use\n    n_q = np.zeros(n_max)\n    p_q = np.zeros(n_max)\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    Ei = np.zeros(n_max)\n    Efn = np.zeros(n_max)\n    Efp = np.zeros(n_max)\n    fi_n = np.zeros(n_max)\n    fi_p = np.zeros(n_max)\n    for i in range(1, n_max - 1):\n        Ec[i] = fi_e[i] / q - Vt * fi_old[i]  # Values from the second Node%\n        Ev[i] = fi_h[i] / q - Vt * fi_old[i]  # Values from the second Node%\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    Ev[0] = Ev[1]\n    Ev[n_max - 1] = Ev[n_max - 2]\n    for i in range(0, n_max):\n        Ei[i] = Ec[i] - ((fi_e[i] - fi_h[i]) / (2 * q))\n    #######################################################\n    # EF=0.0\n\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        # n[I1:I2]=0.0\n        # p[I1:I2]=0.0\n        # couter=0\n        for j in range(0, model.subnumber_e, 1):\n            for i in range(I11, I22):\n                Efn[i] = Ei[i] + Vt * log(abs(n[i] + 1))\n                n_q[i] += (\n                    (\n                        fd2(E_statec_general[k, j], Efn[i] * q * J2meV, model)\n                        * meff_statec_general[k, j]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfe_general[k, j, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n        for jj in range(0, model.subnumber_h, 1):\n            for ii in range(I11, I22):\n                Efp[ii] = Ei[ii] - Vt * log(abs(p[ii] + 1))\n                p_q[ii] += (\n                    (\n                        fd1(E_state_general[k, jj], Efp[ii] * q * J2meV, model)\n                        * meff_state_general[k, jj]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfh_general[k, jj, ii - I1]) ** 2\n                    / (ni[ii] * model.dx)\n                )\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        for i in range(I11, I22):\n            fi_n[i] = Vt * log(abs((n_q[i] + 1) / (n[i] + 1)))\n            fi_p[i] = -Vt * log(abs((p_q[i] + 1) / (p[i] + 1)))\n    if vindex == 1000000:\n        # print(max(n[:])/1e18,max(p[:])/1e18)\n        xaxis = np.arange(0, n_max) * model.dx\n        span = np.ones(100000000)\n        pl.plot(\n            xaxis,\n            Ev * 1e3,\n            ""k"",\n            xaxis,\n            Ec * 1e3,\n            ""k"",\n            xaxis,\n            Efn * 1e3,\n            ""r"",\n            xaxis,\n            Efp * 1e3,\n            ""b"",\n        )\n        for j in range(1, model.N_wells_virtual - 1):\n            I1, I2, I11, I22 = amort_wave(j, model.Well_boundary, model.n_max)\n            i1 = I1 - I1\n            i2 = I2 - I1\n            for levelc, statec in zip(E_statec_general[j, :], wfe_general[j, :, :]):\n                # pl.axhline(levelc,0.1,0.9, hold=True,color=\'g\',ls=\'--\')\n                pl.plot(\n                    xaxis[I1:I2],\n                    statec[i1:i2] * config.wavefunction_scalefactor + levelc,\n                    ""b"",\n                )\n                pl.plot(xaxis[I1:I2], levelc * span[I1:I2], ""g"", ls=""--"")\n            for level, state in zip(E_state_general[j, :], wfh_general[j, :, :]):\n                # pl.axhline(level,0.1,0.9,color=\'g\',ls=\'--\')\n                pl.plot(\n                    xaxis[I1:I2],\n                    state[i1:i2] * config.wavefunction_scalefactor + level,\n                    ""b"",\n                )\n                pl.plot(xaxis[I1:I2], level * span[I1:I2], ""g"", ls=""--"")\n            # pl.plot(xaxis, state**2*1e-9/dx*200.0+level,\'b\')\n        # pl.plot(xaxis,EF*span[0:model.n_max],\'r\',ls=\'--\')\n        # pl.axhline(E_F,0.1,0.9,color=\'r\',ls=\'--\')\n        pl.xlabel(""Position (m)"")\n        pl.ylabel(""Energy (meV)"")\n        pl.grid(True)\n    return n_q, p_q, fi_n, fi_p  # density of carriers\n\n\ndef equi_np_fi222(\n    ni,\n    idata,\n    fi_e,\n    fi_h,\n    fi_old,\n    Vt,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n    n_max,\n    n,\n    p,\n):  # use\n    n_q = np.zeros(n_max)\n    p_q = np.zeros(n_max)\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    Ei = np.zeros(n_max)\n    Efn = np.zeros(n_max)\n    Efp = np.zeros(n_max)\n    fi_n = np.zeros(n_max)\n    fi_p = np.zeros(n_max)\n    for i in range(1, n_max - 1):\n        Ec[i] = fi_e[i] / q - Vt * fi_old[i]  # Values from the second Node%\n        Ev[i] = fi_h[i] / q - Vt * fi_old[i]  # Values from the second Node%\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    Ev[0] = Ev[1]\n    Ev[n_max - 1] = Ev[n_max - 2]\n    for i in range(0, n_max):\n        Ei[i] = Ec[i] - ((fi_e[i] - fi_h[i]) / (2 * q))\n    #######################################################\n    # EF=0.0\n\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        # n[I1:I2]=0.0\n        # p[I1:I2]=0.0\n        # couter=0\n        for j in range(0, model.subnumber_e, 1):\n            for i in range(I11, I22):\n                Efn[i] = Ei[i] + Vt * log(abs(n[i] + 1))\n                n_q[i] += (\n                    (\n                        fd2(E_statec_general[k, j], Efn[i] * q * J2meV, model)\n                        * meff_statec_general[k, j]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfe_general[k, j, i - I1]) ** 2\n                    / (ni[i] * model.dx)\n                )\n        for jj in range(0, model.subnumber_h, 1):\n            for ii in range(I11, I22):\n                Efp[ii] = Ei[ii] - Vt * log(abs(p[ii] + 1))\n                p_q[ii] += (\n                    (\n                        fd1(E_state_general[k, jj], Efp[ii] * q * J2meV, model)\n                        * meff_state_general[k, jj]\n                        / (hbar ** 2 * pi)\n                    )\n                    * (wfh_general[k, jj, ii - I1]) ** 2\n                    / (ni[ii] * model.dx)\n                )\n    for k in range(1, model.N_wells_virtual - 1):\n        I1, I2, I11, I22 = amort_wave(k, model.Well_boundary, n_max)\n        for i in range(I11, I22):\n            fi_n[i] = Vt * log(abs((n_q[i] + 1) / (n[i] + 1)))\n            fi_p[i] = -Vt * log(abs((p_q[i] + 1) / (p[i] + 1)))\n    return fi_n, fi_p  # density of carriers\n\n\ndef Poisson_non_equi3(\n    vindex,\n    fi_stat3,\n    n,\n    p,\n    dop,\n    Ppz_Psp,\n    pol_surf_char,\n    n_max,\n    dx,\n    fi,\n    flag_conv_2,\n    Ldi,\n    ni,\n    fitotc,\n    fitot,\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    iteration,\n    wfh_general,\n    wfe_general,\n    model,\n    E_state_general,\n    E_statec_general,\n    meff_state_general,\n    meff_statec_general,\n):\n    ####################################################################\n    ## 3.3 Calculate potential fi again with new values of ""n"" and ""p""##\n    ##     and check for convergence                                  ##\n    ####################################################################\n    # Recalculate forcing function and central coefficient b for fi\n    d = np.zeros(n_max)\n    v = np.zeros(n_max)\n    f = np.zeros(n_max)\n    c = np.zeros(n_max)\n    b = np.zeros(n_max)\n    a = np.zeros(n_max)\n    n_q = np.zeros(n_max)\n    p_q = np.zeros(n_max)\n    fi_n = np.zeros(n_max)\n    fi_p = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = np.zeros(n_max)\n    dop_out = np.zeros(n_max)\n    Ppz_Psp_out = np.zeros(n_max)\n    d = np.zeros(n_max)\n    delta = np.zeros(n_max)\n    fi_out = fi\n    fi_stat30 = np.zeros(n_max)\n    fi_stat30 = fi_stat3\n    dop_out = dop / ni\n    Ppz_Psp_out = Ppz_Psp / ni\n    pol_surf_char_out = pol_surf_char / ni\n    dx2 = dx * dx\n    Ldi2 = Ldi * Ldi\n    delta_acc = 1.0e-4\n    if model.N_wells_virtual - 2 != 0 and config.quantum_effect:\n        n_q, p_q, fi_n, fi_p = equi_np_fi22(\n            vindex,\n            fitotc,\n            fitot,\n            Nc,\n            Nv,\n            fi_e,\n            fi_h,\n            iteration,\n            fi_out,\n            Vt,\n            wfh_general,\n            wfe_general,\n            model,\n            E_state_general,\n            E_statec_general,\n            meff_state_general,\n            meff_statec_general,\n            dop,\n            Ppz_Psp,\n            n_max,\n            ni,\n            n,\n            p,\n        )\n    # n,p,fi_non,EF =equi_np_fi31(g,fi_stat30,n,p,fitotc,fitot,Nc,Nv,fi_e,fi_h,iteration,fi_out,Vt,wfh_general,wfe_general,model,E_state_general,E_statec_general,meff_state_general,meff_statec_general,dop,Ppz_Psp,n_max,ni)\n    for i in range(1, n_max - 1):\n        a[i] = Ldi2[i] / (dx2)\n        c[i] = Ldi2[i] / (dx2)\n        b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n        f[i] = n[i] - p[i] - dop_out[i] - Ppz_Psp_out[i] - (fi_out[i] * (n[i] + p[i]))\n        # f[i] = n[i] - p[i] - dop_out[i]-(pol_surf_char_out[i+1]-pol_surf_char_out[i-1])/(2*dx) - (fi_out[i]*(n[i] + p[i]))\n    a[0] = 0.0\n    c[0] = 0.0\n    b[0] = 1.0\n    f[0] = fi_out[0]\n    a[n_max - 1] = 0.0\n    c[n_max - 1] = 0.0\n    b[n_max - 1] = 1.0\n    f[n_max - 1] = fi_out[n_max - 1]\n    ## here values of n[i] and p[i] are used in place of exp(fi[i])\n    # Solve for Updated potential given the new value of Forcing\n    # Function using LU decomposition\n    # flag_conv =True  # convergence of the Poisson loop\n    k_iter = 0\n    # while flag_conv:\n    k_iter = k_iter + 1\n    d[0] = b[0]\n    for i in range(1, n_max):\n        d[i] = b[i] - a[i] * c[i - 1] / d[i - 1]\n    # Solution of Lv = f #\n    v[0] = f[0]\n    for i in range(1, n_max):\n        v[i] = f[i] - a[i] * v[i - 1] / d[i - 1]\n    # Solution of U*fi = v #\n    temp = v[n_max - 1] / d[n_max - 1]\n    delta[n_max - 1] = temp - fi_out[n_max - 1]\n    fi_out[n_max - 1] = temp\n    for i in range(n_max - 2, -1, -1):  # delta#\n        temp = (v[i] - c[i] * fi_out[i + 1]) / d[i]\n        delta[i] = temp - fi_out[i]\n        fi_out[i] = temp\n    delta_max = 0\n    delta_max = max(abs(delta[:]))\n    # Test convergence and start the loop if necessary else increase\n    # the applied potential\n    print(""delta_max= "", delta_max)\n    # print(fi_stat30)\n    if delta_max < delta_acc:\n        flag_conv_2 = False\n    else:\n        if model.N_wells_virtual - 2 != 0 and config.quantum_effect:\n            n_q, p_q, fi_n, fi_p = equi_np_fi22(\n                vindex,\n                fitotc,\n                fitot,\n                Nc,\n                Nv,\n                fi_e,\n                fi_h,\n                iteration,\n                fi_out,\n                Vt,\n                wfh_general,\n                wfe_general,\n                model,\n                E_state_general,\n                E_statec_general,\n                meff_state_general,\n                meff_statec_general,\n                dop,\n                Ppz_Psp,\n                n_max,\n                ni,\n                n,\n                p,\n            )\n        # n,p,fi_non,EF =equi_np_fi31(g,fi_stat30,n,p,fitotc,fitot,Nc,Nv,fi_e,fi_h,iteration,fi_out,Vt,wfh_general,wfe_general,model,E_state_general,E_statec_general,meff_state_general,meff_statec_general,dop,Ppz_Psp,n_max,ni)\n        for i in range(1, n_max - 1):\n            b[i] = -(2 * Ldi2[i] / (dx2) + n[i] + p[i])\n            f[i] = (\n                n[i] - p[i] - dop_out[i] - Ppz_Psp_out[i] - (fi_out[i] * (n[i] + p[i]))\n            )\n            # f[i] = n[i] - p[i] - dop_out[i+1]-(pol_surf_char_out[i+1]-pol_surf_char_out[i-1])/(2*dx) - (fi_out[i]*(n[i] + p[i]))\n    return fi_out, flag_conv_2, n_q, p_q, fi_n, fi_p\n\n\ndef Current2(\n    vindex,\n    n,\n    p,\n    mun,\n    mup,\n    fi,\n    Vt,\n    n_max,\n    Total_Steps,\n    q,\n    dx,\n    ni,\n    Ldi,\n    Jnip1by2,\n    Jnim1by2,\n    Jelec,\n    Jpip1by2,\n    Jpim1by2,\n    Jhole,\n):\n    ##########################################################################\n    ##                        CALCULATE CURRENT                             ##\n    ##########################################################################\n    for i in range(1, n_max - 1):\n\n        # Electron Current\n        Jnip1by2[vindex, i] = (\n            (q * mun[i] * Vt / (dx))\n            * ni[i]\n            * (n[i + 1] * Ber((fi[i + 1] - fi[i])) - n[i] * Ber((fi[i] - fi[i + 1])))\n        )\n        Jnim1by2[vindex, i] = (\n            (q * mun[i] * Vt / (dx))\n            * ni[i]\n            * (n[i] * Ber((fi[i] - fi[i - 1])) - n[i - 1] * Ber((fi[i - 1] - fi[i])))\n        )\n        Jelec[vindex, i] = (Jnip1by2[vindex, i] + Jnim1by2[vindex, i]) / 2\n        # Hole Current\n        Jpip1by2[vindex, i] = (\n            (q * mup[i] * Vt / (dx))\n            * ni[i]\n            * (p[i + 1] * Ber((fi[i] - fi[i + 1])) - p[i] * Ber((fi[i + 1] - fi[i])))\n        )\n        Jpim1by2[vindex, i] = (\n            (q * mup[i] * Vt / (dx))\n            * ni[i]\n            * (p[i] * Ber((fi[i - 1] - fi[i])) - p[i - 1] * Ber((fi[i] - fi[i - 1])))\n        )\n        Jhole[vindex, i] = (Jpip1by2[vindex, i] + Jpim1by2[vindex, i]) / 2\n    ##         Jtotal(vindex) = Jelec\n    return Jnip1by2, Jnim1by2, Jelec, Jpip1by2, Jpim1by2, Jhole\n\n\ndef Write_results_non_equi2(\n    Nc,\n    Nv,\n    fi_e,\n    fi_h,\n    Vt,\n    q,\n    ni,\n    n,\n    p,\n    dop,\n    dx,\n    Ldi,\n    fi,\n    n_max,\n    Jnip1by2,\n    Jnim1by2,\n    Jelec,\n    Jpip1by2,\n    Jpim1by2,\n    Jhole,\n    Jtotal,\n    Total_Steps,\n):\n\n    ro = np.zeros(n_max)\n    el_field1 = np.zeros(n_max)\n    el_field2 = np.zeros(n_max)\n\n    Ec = np.zeros(n_max)\n    Ev = np.zeros(n_max)\n    Ei = np.zeros(n_max)\n    Efn = np.zeros(n_max)\n    Efp = np.zeros(n_max)\n    av_curr = np.zeros(Total_Steps)\n    for i in range(1, n_max - 1):\n        Ec[i] = fi_e[i] / q - Vt * fi[i]  # Values from the second Node%\n        Ev[i] = fi_h[i] / q - Vt * fi[i]  # Values from the second Node%\n        ro[i] = -q * (ni[i] * n[i] - ni[i] * p[i] - dop[i])\n        el_field1[i] = -(fi[i + 1] - fi[i]) * Vt / (dx)\n        el_field2[i] = -(fi[i + 1] - fi[i - 1]) * Vt / (2 * dx)\n    Jtotal[:, 0] = Jtotal[:, 1]\n    Jelec[:, 0] = Jelec[:, 1]\n    Jhole[:, 0] = Jhole[:, 1]\n    Jtotal[:, n_max - 1] = Jtotal[:, n_max - 2]\n    Jelec[:, n_max - 1] = Jelec[:, n_max - 2]\n    Jhole[:, n_max - 1] = Jhole[:, n_max - 2]\n\n    Ec[0] = Ec[1]\n    Ec[n_max - 1] = Ec[n_max - 2]\n    Ev[0] = Ev[1]\n    Ev[n_max - 1] = Ev[n_max - 2]\n    el_field1[0] = el_field1[1]\n    el_field2[0] = el_field2[1]\n    el_field1[n_max - 1] = el_field1[n_max - 2]\n    el_field2[n_max - 1] = el_field2[n_max - 2]\n    ro[0] = ro[1]\n    ro[n_max - 1] = ro[n_max - 2]\n    n[0] = n[1]\n    n[n_max - 1] = n[n_max - 2]\n    p[0] = p[1]\n    p[n_max - 1] = p[n_max - 2]\n    nf = n * ni\n    pf = p * ni\n    ## Calculate Quasi Fermi Level - Efn Efp\n    for i in range(0, n_max):\n        Ei[i] = Ec[i] - ((fi_e[i] - fi_h[i]) / (2 * q))\n        Efn[i] = Ei[i] + Vt * log(nf[i] / ni[i] + 1)\n        Efp[i] = Ei[i] - Vt * log(pf[i] / ni[i] + 1)\n    Efn[0] = Efn[1]\n    Efn[n_max - 1] = Efn[n_max - 2]\n    Efp[0] = Efp[1]\n    Efp[n_max - 1] = Efp[n_max - 2]\n    for j in range(0, Total_Steps):\n        av_curr[j] = Jtotal[j, 0]\n    Ec_result = np.zeros(n_max)\n    Ev_result = np.zeros(n_max)\n    Ei_result = np.zeros(n_max)\n    Efp_result = np.zeros(n_max)\n    Efn_result = np.zeros(n_max)\n    fi_result = np.zeros(n_max)\n    fi_result = fi[0:n_max]\n    Efn_result = Efn[0:n_max]\n    Efp_result = Efp[0:n_max]\n    ro_result = np.zeros(n_max)\n    el_field1_result = np.zeros(n_max)\n    el_field2_result = np.zeros(n_max)\n    nf_result = np.zeros(n_max)\n    pf_result = np.zeros(n_max)\n    Ec_result = Ec[0:n_max]\n    Ev_result = Ev[0:n_max]\n    Ei_result = Ei[0:n_max]\n    ro_result = ro[0:n_max]\n    el_field1_result = el_field1[0:n_max]\n    el_field2_result = el_field2[0:n_max]\n    nf_result = n[0:n_max] * ni[0:n_max]\n    pf_result = p[0:n_max] * ni[0:n_max]\n    return (\n        fi_result,\n        Efn_result,\n        Efp_result,\n        ro_result,\n        el_field1_result,\n        el_field2_result,\n        nf_result,\n        pf_result,\n        Ec_result,\n        Ev_result,\n        Ei_result,\n        av_curr,\n    )\n'"
config.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""This module contains aestimo\'s global configuration settings for aestimo.py\nand aestimo_eh.py. It contains parameters for controlling the algorithms that are \nused to calculate the bandstructures. \n\nThe \'inputfilename\' variable defines the default input file used when aestimo.py\nor main.py is run directly as a script. There are also parameters that define the\ndefaults for saving and presenting results; as well as for logging messages.\n""""""\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2016 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS \n""""""\nq = 1.602176e-19 #C\nmeV2J=1e-3*q #meV to Joules\n\n# CONFIGURATION \n\n# Default Input File(s)\n# -------------\n#inputfilename = ""sample_qw_barrierdope""\n#inputfilename = ""sample_qw_qwdope""\n#inputfilename = ""sample_moddop""\n#inputfilename = ""sample_qw_HarrisonCh3_3""\n#inputfilename = ""sample_qw_barrierdope_p""\n#inputfilename = ""sample_multi_qw_barrierdope_p""\n#inputfilename = ""sample_double_qw""\n#inputfilename = ""sample_qw_barrierdope_p_ingan""\n#inputfilename = ""sample_qw_barrierdope_ingaas""\n#inputfilename = ""sample_mqw_barrierdope_p_ingan""\n#inputfilename = ""sample_qw_barrierdope_p_cdzno""\n#inputfilename = ""sample_multi_qw_barrierdope_p_ingan""\n#inputfilename = ""sample_qw_wide_isbt""\n#inputfilename = ""sample_qw_barrierdope_p_InGaAsP""\n#inputfilename = ""sample_qw_barrierdope_p_AlGaInN""\n#inputfilename = ""sample_qw_barrierdope_p_AlGaInN_2""\ninputfilename = ""sample_pn""\n#inputfilename = ""sample_2qw_barrierdope_ingaas""\n# Calculation\n# -----------\n# Aestimo\nuse_cython = True #provides a speed up for aestimo\n# Shooting method parameters for Schr\xc3\xb6dinger Equation solution\ndelta_E = 0.5*meV2J #Energy step (Joules) for initial search. Initial delta_E is 1 meV. \nd_E = 1e-5*meV2J #Energy step (Joules) within Newton-Raphson method when improving the precision of the energy of a found level.\nE_start = 0.0    #Energy to start shooting method from (if E_start = 0.0 uses minimum of energy of bandstructure)\nEstate_convergence_test = 1e-9*meV2J\n# FermiDirac\nFD_d_E = 1e-9 #Initial and minimum Energy step (meV) for derivative calculation for Newton-Raphson method to find E_F\nFD_convergence_test = 1e-6 #meV\nnp_d_E = 1.0 # Energy step (meV) for dispersion calculations\n# Poisson Loop\n""""""damping:An adjustable parameter  (0 < damping < 1) is typically set to 0.5 at low carrier densities. With increasing\ncarrier densities, a smaller value of it is needed for rapid convergence.""""""\ndamping = 0.5    #averaging factor between iterations to smooth convergence.\nStern_damping=True#the extrapolated-convergence-factor method instead of the fixed-convergence-factor method\nmax_iterations=80 #maximum number of iterations.\nconvergence_test=1e-4 #convergence is reached when the ground state energy (meV) is stable to within this number between iterations.\n\n# Aestimo_numpy_h\npredic_correc=True#predictor corrector method\nanti_crossing_length=0.0001 # the lower lenght limit to consider anti-crossing (nm), works with old versions\namort_wave_0=1.5#ratio of half well\'s width for wavefunction  to penetration into the the left adjacent barrier\namort_wave_1=1.5#ratio of half well\'s width for wavefunction to penetration into the the right adjacent barrier\nstrain =True # for aestimo_numpy_eh\npiezo=False # directly calculationg the induced electric field,for old poisson solver, works with old versions\npiezo1=True #indirectly using interface charges.\nquantum_effect=True#temporary\n#--------------\nparameters=False\n\n# Output Files\n# ------------\noutput_directory = ""output_""+inputfilename\nparameters = True\nelectricfield_out = True\npotential_out = True\nsigma_out = True\nprobability_out = True\nstates_out = True\nDrift_Diffusion_out=True\n\n# Result Viewer\n# -------------\nresultviewer = True\nwavefunction_scalefactor = 400 # scales wavefunctions when plotting QW diagrams\n# Messages\n# --------\nmessagesoff = True\nlogfile = ""aestimo.log""\n\n'"
database.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""Aestimo\'s database module. Contains a materialproperty dict containing \nsub-dicts of values for each material and similar alloyproperty dict for the\nalloys of the materials. See the source for details on the required keys for\neach material or alloy.\n\n References:\n  - GaAs,AlAs parameters:\n    Properties of Semiconductor Alloys: Group-IV, III-V and II-VI Semiconductors Sadao AdAchi?2009 John Wiley & Sons, Ltd.\n    Basic Semiconductor Physics Second Edition,Prof. Chihiro Hamaguchi 2010 Springer\n    Physics of Optoelectronic Devices ,S-L.CHUANG ,1995 by John Wiley & Sons. Inc\n  \n""""""\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2016 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n""""""\n\n# MATERIAL PROPERTIES\n# materialproperties| Material : m_e | m_hh | epsilonStatic | Eg | Bowing_param | m_e_alpha |  Luttinger Parameters \xce\xb31,2 & 3 |Elastic constants C11,12|Lattice constant a0| Deformation potentials ac,av & b| delta splitt off|\nmaterialproperty = {\n\'GaAs\':{\n\'m_e\':0.067, #conduction band effective mass (relative to electron mass)\n\'m_hh\':0.45, #heavy hole band effective mass (used by aestimo_numpy_h)\n\'m_lh\':0.087, #light hole band effective mass (used by aetsimo_numpy_h)\n\'epsilonStatic\':12.90, #dielectric constant\n\'Eg\':1.4223,#1.42 # (ev) band gap\n\'Ep\':28.8, # (eV) k.p matrix element (used for non-parabolicity calculation (Vurgaftman2001)\n\'F\':-1.94, # Kane parameter (used for non-parabolicity calculation (Vurgaftman2001)\n\'Band_offset\':0.65, # conduction band/valence band offset ratio for GaAs - AlGaAs heterojunctions\n\'m_e_alpha\':5.3782e18, # conduction band non-parabolicity variable for linear relation (Nelson approach)\n# Valence band constants \n\'delta\':0.28, # (eV) Spin split-off energy gap\n# below used by aestimo_numpy_h\n\'GA1\':6.8, #luttinger parameter\n\'GA2\':1.9, #luttinger parameter\n\'GA3\':2.73, #luttinger parameter\n\'C11\':11.879, # (GPa) Elastic Constants\n\'C12\':5.376, # (GPa) Elastic Constants\n\'a0\':5.6533, # (A)Lattice constant\n\'Ac\':-7.17, # (eV) deformation potentials (Van de Walle formalism)\n\'Av\':1.16, # (eV) deformation potentials (Van de Walle formalism)\n\'B\':-1.7, # (eV) shear deformation potential (Van de Walle formalism)\n\'TAUN0\':0.1E-7,# Electron SRH life time\n\'TAUP0\':0.1E-7,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s\n\'mup0\':0.02,# Electron Mobility in m2/V-s\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5, # Saturation Velocity of Holes\n\'AVb_E\':-6.92#Average Valence Band Energy or the absolute energy level\n},\n\'AlAs\':{\n\'m_e\':0.15,\n\'m_hh\':0.51,\n\'m_lh\':0.18,\n\'epsilonStatic\':10.06,\n\'Eg\':3.0,#2.980,\n\'Ep\':21.1,\n\'F\':-0.48,\n\'Band_offset\':0.53,\n\'m_e_alpha\':0.0,\n\'GA1\':3.45,\n\'GA2\':0.68,\n\'GA3\':1.29, \n\'C11\':11.879,\n\'C12\':5.376,\n\'a0\':5.66, \n\'Ac\':-5.64,\n\'Av\':2.47,\n\'B\':-1.5,\n\'delta\':0.28,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5, # Saturation Velocity of Holes\n\'AVb_E\':-7.49#Average Valence Band Energy or the absolute energy level\n},\n\'InAs\':{\n\'m_e\':0.4,\n\'m_hh\':0.26,\n\'m_lh\':0.027,\n\'epsilonStatic\':15.15,\n\'Eg\':0.4,\n\'Ep\':21.5,\n\'F\':-2.90,\n\'Band_offset\':0.63,\n\'m_e_alpha\':0.0,\n\'GA1\':20.4,\n\'GA2\':8.3,\n\'GA3\':9.1,\n\'C11\':8.329,\n\'C12\':4.526,\n\'a0\':6.0584,\n\'Ac\':-5.08,\n\'Av\':1.0,\n\'B\':-1.8,\n\'delta\':0.38,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-6.67#Average Valence Band Energy or the absolute energy level\n},\n\'InP\':{\n\'m_e\':0.073,\n\'m_hh\':0.46,\n\'m_lh\':0.12,\n\'epsilonStatic\':12.50,\n\'Eg\':1.35,\n\'Ep\':20.7,\n\'F\':-1.31,\n\'Band_offset\':0.38,\n\'m_e_alpha\':0.0,\n\'GA1\':5.33,\n\'GA2\':1.57,\n\'GA3\':2.11,\n\'C11\':8.329,\n\'C12\':4.526,\n\'a0\':5.8688,\n\'Ac\':-5.04,\n\'Av\':1.27,\n\'B\':-1.7,\n\'delta\':0.11,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.04#Average Valence Band Energy or the absolute energy level\n},\n\'GaP\':{\n\'m_e\':0.82,\n\'m_hh\':0.6,\n\'m_lh\':0.6,\n\'epsilonStatic\':11.1,\n\'Eg\':2.261,\n\'Ep\':31.4,\n\'F\':-2.04,\n\'Band_offset\':0.55,\n\'m_e_alpha\':0.0,\n\'GA1\':4.04,\n\'GA2\':0.53,\n\'GA3\':1.26,\n\'C11\':14.05,\n\'C12\':6.203,\n\'a0\':5.4505,\n\'Ac\':-7.14,\n\'Av\':1.70,\n\'B\':-1.8,\n\'delta\':0.08,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.4#Average Valence Band Energy or the absolute energy level\n},\n\'AlP\':{\n\'m_e\':0.22,\n\'m_hh\':0.63,\n\'m_lh\':0.2,\n\'epsilonStatic\':10.464,\n\'Eg\':2.48,\n\'Ep\':17.7,\n\'F\':-0.65,\n\'Band_offset\':0.55,\n\'m_e_alpha\':0.0,\n\'GA1\':3.47,\n\'GA2\':0.06,\n\'GA3\':1.15,\n\'C11\':15.0,\n\'C12\':6.42,\n\'a0\':5.4635,\n\'Ac\':-5.54,\n\'Av\':3.15,\n\'B\':-1.5,\n\'delta\':0.04,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-8.09#Average Valence Band Energy or the absolute energy level\n},\n\'GaN\':{ \n\'m_e\':0.21,#\xe2\x98\xbb.22\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.87,#1.1 1\n\'m_lh\':0.14,#1.1\n\'m_so\':0.5,#0.15\n\'epsilonStatic\':9.5,\n\'Eg\':3.5,# 3.44 Madelung (1991) 3.437\n\'Bowing_param\':3.2,\n\'Band_offset\':0.63,\n\'A1\':-6.4,#-6.56 -0.91 5.65 -2.83 -3.13 -4.86\n\'A2\':-0.5,\n\'A3\':5.9,\n\'A4\':-2.95,\n\'A5\':-2.56,\n\'A6\':-3.06,\n\'D1\':-1.7,#-3.7 4.5 8.2 -4.1 -4.0 -5.5\n\'D2\':6.3,\n\'D3\':8.2,\n\'D4\':-4.1,\n\'D5\':-4,\n\'D6\':-5.65,\n\'Ac\':-4.60,\n\'a0_wz\':3.189,#3.189 5.185\n\'C11\':37.,\n\'C12\':14.5,\n\'C13\':10.3,\n\'C33\':39.0,#40.4\n\'C44\':9.5,\n\'C66\':12.3,\n\'D15\':-1.579e-12,#-1.579e-12      -1.7e-12\n\'D31\':-1.253e-12,#-1.253e-12      -1.6e-12 \n\'D33\':2.291e-12,# 2.291e-12     2.291e-12\n\'Psp\':-0.029,#-0.029 -0.034 \n\'delta_so\':0.015,#15.5mev\n\'delta_cr\':0.022,#72.9mev\n\'a0_sub\':3.189,\n\'TAUN0\':0.1E-6,# Electron SRH life time\n\'TAUP0\':0.1E-6,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s 0.1 0.2\n\'mup0\':0.02,# Electron Mobility in m2/V-s 0.03 0.02\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':2,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,#3e5 Saturation Velocity of Electrons 1.5e5 2.5e5 2.7e5 2e5\n\'VSATP\': 6e5, # Saturation Velocity of Holes\n\'AVb_E\':-2.64#Average Valence Band Energy or the absolute energy level\n},\n\'InN\':{#now\n\'m_e\':0.07,#0.11\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.61,#1.61\n\'m_lh\':0.11,#1.61\n\'m_so\':0.5,#0.1\n\'epsilonStatic\':15.3,\n\'Eg\':0.608,#0.76 0.608\n\'Bowing_param\':3.2,\n\'Band_offset\':0.63,#\n\'A1\':-9.09,#-9.28 -0.60 8.68 -4.34 -4.32 -6.08\n\'A2\':-0.63,\n\'A3\':8.46,\n\'A4\':-4.23,\n\'A5\':-4.36,\n\'A6\':-6.34,\n\'D1\':-1.76,#-3.7 4.5 8.2 -4.1 -4.0 -5.5\n\'D2\':3.43,\n\'D3\':5.19,\n\'D4\':-2.595,\n\'D5\':-2.33,\n\'D6\':-5.5,\n\'Ac\':-1.4,\n\'a0_wz\':3.53,#3.548\n\'C11\':22.3,\n\'C12\':11.5,\n\'C13\':9.2,\n\'C33\':20.5,\n\'C44\':9.5,\n\'C66\':7.4,\n\'D15\':-2.292e-12,#-2.292e-12 -1.1e-12\n\'D31\':-3.147e-12,#-3.147e-12 -3.5e-12\n\'D33\':6.201e-12,#6.201e-12\n\'Psp\':-0.032,#-0.032 -0.042 \n\'delta_so\':0.001,#5mev\n\'delta_cr\':0.041,#40mev\n\'a0_sub\':3.189,\n\'TAUN0\':5.1e-8,# Electron SRH life time\n\'TAUP0\':5.1e-8,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s 0.1 0.2\n\'mup0\':0.02,# Electron Mobility in m2/V-s 0.03 0.02\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':1,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,#3e5 Saturation Velocity of Electrons 1.5e5\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-1.59#Average Valence Band Energy or the absolute energy level\n},\n\'AlN\':{\n\'m_e\':0.22,\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.2,\n\'m_lh\':0.8,\n\'m_so\':0.5,\n\'epsilonStatic\':10.464,\n\'Eg\':6.28,\n\'Bowing_param\':0.0,\n\'Band_offset\':0.55,\n\'A1\':-3.95,\n\'A2\':-0.27,\n\'A3\':3.68,\n\'A4\':-1.84,\n\'A5\':-1.92,\n\'A6\':-2.91,\n\'D1\':-0.89,\n\'D2\':4.27,\n\'D3\':5.18,\n\'D4\':-2.59,\n\'D5\':-4,\n\'D6\':3.4,\n\'Ac\':-7.17,\n\'a0_wz\':3.112,\n\'C11\':39.6,\n\'C12\':14,\n\'C13\':10.8,\n\'C33\':37.7,\n\'C44\':11.6,\n\'D15\':-2.0e-12,#\xe2\x88\x922.069e-12      \xe2\x88\x924.08e-12\n\'D31\':-2.650e-12,#\xe2\x88\x922.298e-12    \xe2\x88\x922.65e-12\n\'D33\':5.53e-12,#5.352e-12        5.53e-12\n\'Psp\':-0.081,#-0.081 \xe2\x88\x920.09\n\'delta_so\':0.019,#20.4mev\n\'delta_cr\':-0.164,#\xe2\x88\x9258.5mev\n\'a0_sub\':3.189,\n\'TAUN0\':0.1E-7,# Electron SRH life time\n\'TAUP0\':0.1E-7,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s\n\'mup0\':0.02,# Electron Mobility in m2/V-s\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':0.45,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':0.45,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons 1.5e5\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-3.44#Average Valence Band Energy or the absolute energy level 1.5e5\n},\n\'CdO\':{\n\'m_e\':0.12,\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.2,\n\'m_lh\':0.8,\n\'m_so\':0.5,\n\'epsilonStatic\':10.464,\n\'Eg\':1.89,\n\'Bowing_param\':0.0,\n\'Band_offset\':0.65,\n\'A1\':-3.78,\n\'A2\':-0.44,\n\'A3\':3.45,\n\'A4\':-1.63,\n\'A5\':-1.68,\n\'A6\':-2.23,\n\'D1\':-3.90,\n\'D2\':-4.13,\n\'D3\':-1.15,\n\'D4\':1.22,\n\'D5\':-1.53,\n\'D6\':2.83,\n\'Ac\':-1.4,\n\'a0_wz\':3.45,#3.66\n\'C11\':20.97,\n\'C12\':12.11,\n\'C13\':10.51,\n\'C33\':21.09,\n\'C44\':4.247,\n\'D15\':-1.1e-12,\n\'D31\':-1.1e-12,\n\'D33\':0.22e-12,\n\'Psp\':-0.099,\n\'delta_so\':0.0126,\n\'delta_cr\':0.0305,\n\'a0_sub\':3.250,\n\'TAUN0\':0.1E-7,# Electron SRH life time\n\'TAUP0\':0.1E-7,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s\n\'mup0\':0.02,# Electron Mobility in m2/V-s\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.52#Average Valence Band Energy or the absolute energy level\n},\n\'MgO\':{\n\'m_e\':0.24,\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.2,\n\'m_lh\':0.8,\n\'m_so\':0.5,\n\'epsilonStatic\':9.6,\n\'Eg\':5.289,\n\'Bowing_param\':0.1,\n\'Band_offset\':0.65,\n\'A1\':-3.78,\n\'A2\':-0.44,\n\'A3\':3.45,\n\'A4\':-1.63,\n\'A5\':-1.684,\n\'A6\':-2.23,\n\'D1\':-3.90,\n\'D2\':-4.13,\n\'D3\':1.15,\n\'D4\':-1.22,\n\'D5\':-1.53,\n\'D6\':2.83,\n\'Ac\':-7.17,\n\'a0_wz\':3.199,\n\'C11\':22.0,\n\'C12\':9.42,\n\'C13\':5.4,\n\'C33\':21.6,\n\'C44\':10.5,\n\'D15\':-1.7e-12,\n\'D31\':-7.887e-12,\n\'D33\':0.34e-12,\n\'Psp\':-0.068,\n\'delta_so\':0.032,\n\'delta_cr\':0.3172,\n\'a0_sub\':3.250,\n\'TAUN0\':0.1E-7,# Electron SRH life time\n\'TAUP0\':0.1E-7,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s\n\'mup0\':0.02,# Electron Mobility in m2/V-s\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.52#Average Valence Band Energy or the absolute energy level\n},\n\'ZnO\':{\n\'m_e\':0.24,\n\'m_e_alpha\':5.3782e18,\n\'m_hh\':1.2,\n\'m_lh\':0.8,\n\'m_so\':0.5,\n\'epsilonStatic\':8.1,\n\'Eg\':3.37,\n\'Bowing_param\':0.0,\n\'Band_offset\':0.65,\n\'A1\':-3.78,\n\'A2\':-0.44,\n\'A3\':3.45,\n\'A4\':-4.32,\n\'A5\':-3.13,\n\'A6\':-2.23,\n\'D1\':-3.90,\n\'D2\':-4.13,\n\'D3\':-1.15,\n\'D4\':1.22,\n\'D5\':-1.53,\n\'D6\':2.83,\n\'Ac\':-6.05,\n\'a0_wz\':3.250,\n\'C11\':20.97,\n\'C12\':12.11,\n\'C13\':10.51,\n\'C33\':21.09,\n\'C44\':4.247,\n\'D15\':-5e-12,\n\'D31\':-5e-12,\n\'D33\':1e-12,\n\'Psp\':-0.05,\n\'delta_so\':0.0126,#16mev\n\'delta_cr\':0.0305,#43mev\n\'a0_sub\':3.250,\n\'TAUN0\':0.1E-7,# Electron SRH life time\n\'TAUP0\':0.1E-7,# Hole SRH life time\n\'mun0\':0.1,# Electron Mobility in m2/V-s\n\'mup0\':0.02,# Electron Mobility in m2/V-s\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,# Parameter in calculatation of the Field Dependant Mobility\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.52#Average Valence Band Energy or the absolute energy level\n},\n\'Si\':{#http://www.ioffe.ru/SVA/NSM/Semicond/Si/basic.html\n\'m_e\':1.18,\n\'m_hh\':0.49,\n\'m_lh\':0.16,\n\'epsilonStatic\':11.7,\n\'Eg\':1.12,\n\'Ep\':21.1,#?\n\'F\':-0.48,#?\n\'Band_offset\':0.53,\n\'m_e_alpha\':0.0,\n\'GA1\':3.45,\n\'GA2\':0.68,\n\'GA3\':1.29, \n\'C11\':16.6,\n\'C12\':6.4,\n\'C44\':7.96,\n\'a0\':5.431, \n\'Ac\':-5.64,\n\'Av\':2.47,\n\'B\':-1.5,\n\'delta\':0.28,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-7.03#Average Valence Band Energy or the absolute energy level\n},\n\'Ge\':{\n\'m_e\':0.22,\n\'m_hh\':0.33,\n\'m_lh\':0.043,\n\'epsilonStatic\':10.06,\n\'Eg\':0.661,\n\'Ep\':21.1,\n\'F\':-0.48,\n\'Band_offset\':0.53,\n\'m_e_alpha\':0.0,\n\'GA1\':3.45,\n\'GA2\':0.68,\n\'GA3\':1.29, \n\'C11\':12.60,\n\'C12\':4.4,\n\'C44\':6.77,\n\'a0\':5.658, \n\'Ac\':-5.64,\n\'Av\':2.47,\n\'B\':-1.5,\n\'delta\':0.28,\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-6.35#Average Valence Band Energy or the absolute energy level\n}\n}\n\n# ALLOY PROPERTIES\n# alloyproperties| Alloy : m_e_x=0 | m_e_b  | eps_x=0 | eps_b | Eg | Bowing_param | m_e_alpha\nalloyproperty = {\n\'AlGaAs\':{\n\'Bowing_param\':0.37,\n\'Band_offset\':0.65,\n\'m_e_alpha\':5.3782e18,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'AlAs\',\n\'Material2\':\'GaAs\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'InGaAs\':{\n\'Bowing_param\':0.58,\n\'Band_offset\':0.63,\n\'m_e_alpha\':0.0,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'InAs\',\n\'Material2\':\'GaAs\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'InAsP\':{\n\'Bowing_param\':0.58,\n\'Band_offset\':0.63,\n\'m_e_alpha\':0.0,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'InAs\',\n\'Material2\':\'InP\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'GaAsP\':{\n\'Bowing_param\':0.58,\n\'Band_offset\':0.63,\n\'m_e_alpha\':0.0,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'GaP\',\n\'Material2\':\'GaAs\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'InGaP\':{\n\'Bowing_param\':0.65,\n\'Band_offset\':0.33,\n\'m_e_alpha\':0.0,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'InP\',\n\'Material2\':\'GaP\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'AlInP\':{\n\'Bowing_param\':0.13,\n\'Band_offset\':0.52,\n\'m_e_alpha\':0.0,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.6533,\n\'Material1\':\'AlP\',\n\'Material2\':\'InP\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'AlGaN\':{\n\'Bowing_param\':0.7,#0.7 1.3 1 1.3\n\'Band_offset\':0.63,\n\'m_e_alpha\':5.3782e18,\n\'a0_sub\':3.189,\n\'c0_sub\':4.982,\n\'Material1\':\'AlN\',\n\'Material2\':\'GaN\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,#0.1 0.015\n\'mup0\':0.1,#0.03 0.1\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'InGaN\':{\n\'Bowing_param\':1.4,#1.4 3.8 3\n\'Band_offset\':0.63,#0.677 0.63\n\'m_e_alpha\':0.0,\n\'a0_sub\':3.189,\n\'c0_sub\':4.982,\n\'Material1\':\'InN\',\n\'Material2\':\'GaN\',\n\'TAUN0\':5.2e-8,\n\'TAUP0\':5.2e-8,\n\'mun0\':0.1,#0.1 0.015\n\'mup0\':0.02,#0.03 0.1\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# 3e5Saturation Velocity of Electrons 1.5e5\n\'VSATP\':6e5 #6e5 Saturation Velocity of Holes 1.5e5\n},\n\'AlInN\':{\n\'Bowing_param\':3.6,#2.5\n\'Band_offset\':0.677,\n\'m_e_alpha\':0.0,\n\'a0_sub\':3.189,\n\'c0_sub\':4.982,\n\'Material1\':\'AlN\',\n\'Material2\':\'InN\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'MgZnO\':{\n\'Bowing_param\':0.87,\n\'Band_offset\':0.65,\n\'m_e_alpha\':5.3782e18,\n\'a0_sub\':3.250,\n\'c0_sub\':4.982,\n\'Material1\':\'MgO\',\n\'Material2\':\'ZnO\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'CdZnO\':{\n\'Bowing_param\':3.8,\n\'Band_offset\':0.65,\n\'m_e_alpha\':5.3782e18,\n\'a0_sub\':3.250,\n\'c0_sub\':4.982,\n\'Material1\':\'CdO\',\n\'Material2\':\'ZnO\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n}\n}\n# ALLOY PROPERTIES\n# alloyproperties| Alloy : m_e_x=0 | m_e_b  | eps_x=0 | eps_b | Eg | Bowing_param | m_e_alpha\nalloyproperty4 = {\n#AxB(1-x)CyD(1-y)=InxGa(1-x)AsyP(1-y)\n\'InGaAsP\':{\n\'Bowing_param_ABC\':0.58,\n\'Bowing_param_ABD\':0.65,\n\'Bowing_param_ACD\':0.58,\n\'Bowing_param_BCD\':0.58,\n\'Band_offset\':0.4,\n\'m_e_alpha\':5.3782e18,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':5.8688,\n\'Material1\':\'InAs\',\n\'Material2\':\'GaAs\',\n\'Material3\':\'InP\',\n\'Material4\':\'GaP\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n},\n\'AlGaInN\':{#BxCyD1-x-yA=AlxInyGa1-x-yN\n\'Bowing_param_ABC\':3.6,#AlInN\n\'Bowing_param_ABD\':1.3,#AlGaN\n\'Bowing_param_ACD\':3.2,#InGaN\n\'Band_offset\':0.7,\n\'m_e_alpha\':5.3782e18,\n\'delta_bowing_param\':0.0,\n\'a0_sub\':3.189,\n\'c0_sub\':4.982,\n\'Material1\':\'GaN\',\n\'Material2\':\'InN\',\n\'Material3\':\'AlN\',\n\'TAUN0\':0.1E-6,\n\'TAUP0\':0.1E-6,\n\'mun0\':0.15,\n\'mup0\':0.1,\n\'Cn0\':2.8e-31,# generation recombination model parameters [cm**6/s]\n\'Cp0\':2.8e-32,# generation recombination model parameters [cm**6/s]\n\'BETAN\':2.0,\n\'BETAP\':1.0,# Parameter in calculatation of the Field Dependant Mobility\n\'VSATN\':3e5,# Saturation Velocity of Electrons\n\'VSATP\':6e5 , # Saturation Velocity of Holes\n\'AVb_E\':-2.1#Average Valence Band Energy or the absolute energy level\n}\n}\n\n\n\n'"
database1.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sun Oct 20 21:13:17 2019\n""""""\n\nmaterialproperty ={\n##########################################################################################\n##########################################################################################\n#          ZINCBLENDE\n##########################################################################################\n##########################################################################################\n\n\n##########################################################################################\n##########################################################################################\n#          I N S U L A T O R S    A N D    M E T A L S\n##########################################################################################\n##########################################################################################\n\n######### air #############################################\n\n\'Air\':{                                                   \n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'IV_IV\'   \n    ,\'lattice_consts\':{\n        \'a\'           :5.5\n        ,\'a_expansion\' :0.0\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :1.0                                        # vacuum value\n        ,\'optical_a\' :1.0                                        # vacuum value\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :0.01 ,\'c12\' :0.01 ,\'c44\' :0.01                       # zero elastic energy\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.0                                              # no piezoelectric effect\n    }                                                \n                                                                      \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.156                        # Si value\n          ,\'bandgap\'               :15.0                         # high barrier\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.420                        # Si value\n          ,\'mass_t\'                :0.130                        # Si value\n          ,\'bandgap\'               :15.0                         # high barrier\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n          ,\'defpot_uniaxial\'       :0\n       }\n       ,\'Delta\':{ \n          \'mass_l\'                :0.5                          # SiO2 value\n          ,\'mass_t\'                :0.5                          # SiO2 value\n          ,\'bandgap\'               :15.0                         # high barrier\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n          ,\'defpot_uniaxial\'       :0\n          ,\'position\'              :0.85                         # Si value\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-5.0                               # high barrier\n        \n        ,\'HH\':{ \'mass\'          :0.537 }                            # Si value\n        ,\'LH\':{ \'mass\'          :0.153 }                            # Si value\n        ,\'SO\':{ \'mass\'          :0.234 }                            # Si value\n        \n        ,\'defpot_absolute\'   :0\n        ,\'defpot_uniaxial_b\' :0   ,\'defpot_uniaxial_d\' :0\n       \n        ,\'delta_SO\'          :0.044                              # Si value\n       \n    }\n\n    ,\'kp_6_bands\':{\n        \'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56   ,\'kappa\' :-0.42      # Si values\n    }\n \n    ,\'kp_8_bands\':{                                                # No useful model for indirect ,\'bandgap\' materials!\n        \'S\' :6.41                                               # inverse effective mass\n        ,\'E_P\' :0                                                # decoupled bands\n        ,\'B\' :0                                                  # This value is zero in group IV semiconductors (inversion symmetry).\n        ,\'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56   ,\'kappa\' :-0.42      # 6-band parameters\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :142    ,\'exponent\' :2.5  }           # 1/10 constant Si value \n        ,\'holes\':{      \'mumax\' :47     ,\'exponent\' :2.2  }           # 1/10 constant Si value \n    }\n\n    ,\'mobility_masetti\':{\n        \'electrons\':{  \'mumax\'  :142   ,\'exponent\' :2.5              # 1/10 constant Si value \n                    ,\'mumin1\' :0     ,\'mumin2\'   :0       ,\'mu1\' :0  # dummy\n                    ,\'pc\'     :0     ,\'cr\'       :1e100    ,\'cs\' :0   # dummy\n                    ,\'alpha\'  :1     ,\'beta\'     :1                # dummy\n        }\n        ,\'holes\':{      \'mumax\'  :47    ,\'exponent\' :2.2              # 1/10 constant Si value\n                    ,\'mumin1\' :0     ,\'mumin2\'   :0       ,\'mu1\' :0  # dummy\n                    ,\'pc\'     :0     ,\'cr\'       :1e100   ,\'cs\' :0   # dummy\n                    ,\'alpha\'  :1     ,\'beta\'     :1                # dummy\n        }\n    }\n\n    ,\'mobility_arora\':{\n        \'electrons\':{  \'mumin\' :142    ,\'alm\' :-2.5                  # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'mud\' :0        ,\'ald\' :0                     # dummy\n                    ,\'n0\'  :1e20     ,\'aln\' :1                     # dummy\n                    ,\'a\'     :1      ,\'ala\' :1                     # dummy\n        }\n        ,\'holes\':{      \'mumin\' :47     ,\'alm\' :-2.2                  # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'mud\' :0        ,\'ald\' :0                     # dummy\n                    ,\'n0\'  :1e20     ,\'aln\' :0                     # dummy\n                    ,\'a\'   :1        ,\'ala\' :0                     # dummy\n        }\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :142       ,\'muLexpT\'  :-2.5     # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'muLImin300\' :0         ,\'TSwitch\'    :200    # dummy\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0   # dummy\n                    ,\'Cref300\'    :1e100     ,\'CrefexpT\'      :0   # dummy\n                    ,\'alpha300\'   :1         ,\'alphaexpT\'     :0   # dummy\n        }\n        ,\'holes\':{      \'muL300\'     :47        ,\'muLexpT\'  :-2.2     # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'muLImin300\' :0         ,\'TSwitch\'  :200      # dummy\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0   # dummy\n                    ,\'Cref300\'    :1e100     ,\'CrefexpT\'      :0   # dummy\n                    ,\'alpha300\'   :1         ,\'alphaexpT\'     :0   # dummy\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :4.26e-4     ,\'nref_n\' :7.1e15         # Si values\n                   ,\'tau_p\' :3.95e-4     ,\'nref_p\' :7.1e15         # Si values\n        }\n        ,\'Auger\':{     \'c_n\' :2.8e-31       ,\'c_p\' :9.9e-31           # Si values\n        }\n    }\n}  \n#\n\n\n######### silicon dioxide #############################################\n\n#######################################################################\n# E_gap is 9 eV.\n# Conduction band offset SiO2/Si :3.1 eV\n# Conduction band offset SiO2/Si :3.2 eV (M. Fischetti, JAP 83, 270 (1998))\n# Note: SiO2 is hexagonal (wurtzite) and not cubic (zincblende)!!\n#######################################################################\n\n,\'SiO2\':{                                                   \n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'IV_IV\'                                            # Si value\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.4304                                   # Si value\n        ,\'a_expansion\' :1.8138e-5                                # Si value\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :3.9                                        # PhD thesis R. Oberhuber\n      # \'static_a\'  :4.34                                       # www.crystran.co.uk/qutzdata.htm  4.34 (parallel) 4.27 (perpendicular) at 30MHz\n        ,\'optical_a\' :3.5                                        # guess\n    }\n\n    ,\'elastic_consts\':{\n      # \'c11\' :87.0   ,\'c12\' :7.0   ,\'c13\' :13.0   ,\'c33\' :18.0   ,\'c44\' :58.0  # wurtzite, www.crystran.co.uk/qutzdata.htm\n        \'c11\' :87.0   ,\'c12\' :7.0                             ,\'c44\' :58.0\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.000                                            # Si value\n    }                                                \n                                                                      \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.156                        # Si value\n          ,\'bandgap\'               :11.25                        # guess (0 K)\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.420                        # Si value\n          ,\'mass_t\'                :0.130                        # Si value\n          ,\'bandgap\'               :9.5                          # guess (0 K)\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n          ,\'defpot_uniaxial\'       :0\n       }\n       ,\'Delta\':{ \n          \'mass_l\'                :0.5                          # M. Fischetti, JAP 83, 270 (1998)\n          ,\'mass_t\'                :0.5                          # M. Fischetti, JAP 83, 270 (1998)\n          ,\'bandgap\'               :9.0                          # (0 K)\n          ,\'bandgap_alpha\'         :0\n          ,\'bandgap_beta\'          :0\n          ,\'defpot_absolute\'       :0\n          ,\'defpot_uniaxial\'       :0\n          ,\'position\'              :0.85                         # Si value\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-3.66                              # conduction band offset SiO2/Si :3.1 eV\n                                                               # conduction band offset SiO2/Si :3.2 eV (M. Fischetti, JAP 83, 270 (1998))\n        \n        ,\'HH\':{ \'mass\'          :0.537 }                            # Si value\n        ,\'LH\':{ \'mass\'          :0.153 }                            # Si value\n        ,\'SO\':{ \'mass\'          :0.234 }                            # Si value\n        \n        ,\'defpot_absolute\'   :0\n        ,\'defpot_uniaxial_b\' :0   ,\'defpot_uniaxial_d\' :0\n       \n        ,\'delta_SO\'          :0.044                              # Si value\n       \n    }\n\n    ,\'kp_6_bands\':{\n        \'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56  ,\'kappa\' :-0.42       # Si values\n    }\n \n    ,\'kp_8_bands\':{                                                # No useful model for indirect ,\'bandgap\' materials!\n        \'S\' :6.41                                               # inverse effective mass\n        ,\'E_P\' :0                                                # decoupled bands\n        ,\'B\' :0                                                  # This value is zero in group IV semiconductors (inversion symmetry).\n        ,\'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56  ,\'kappa\' :-0.42       # 6-band parameters\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :142    ,\'exponent\' :2.5  }           # 1/10 constant Si value \n        ,\'holes\':{      \'mumax\' :47     ,\'exponent\' :2.2  }           # 1/10 constant Si value \n    }\n\n    ,\'mobility_masetti\':{\n        \'electrons\':{  \'mumax\'  :142   ,\'exponent\' :2.5              # 1/10 constant Si value \n                    ,\'mumin1\' :0     ,\'mumin2\'   :0       ,\'mu1\' :0  # dummy\n                    ,\'pc\'     :0     ,\'cr\'       :1e100   ,\'cs\' :0   # dummy\n                    ,\'alpha\'  :1     ,\'beta\'     :1                # dummy\n        }\n        ,\'holes\':{      \'mumax\'  :47    ,\'exponent\' :2.2              # 1/10 constant Si value\n                    ,\'mumin1\' :0     ,\'mumin2\'   :0       ,\'mu1\' :0  # dummy\n                    ,\'pc\'     :0     ,\'cr\'       :1e100   ,\'cs\' :0   # dummy\n                    ,\'alpha\'  :1     ,\'beta\'     :1                # dummy\n        }\n    }\n\n    ,\'mobility_arora\':{\n        \'electrons\':{  \'mumin\' :142    ,\'alm\' :-2.5                  # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'mud\' :0        ,\'ald\' :0                     # dummy\n                    ,\'n0\'  :1e20     ,\'aln\' :1                     # dummy\n                    ,\'a\'     :1      ,\'ala\' :1                     # dummy\n        }\n        ,\'holes\':{      \'mumin\' :47     ,\'alm\' :-2.2                  # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'mud\' :0        ,\'ald\' :0                     # dummy\n                    ,\'n0\'  :1e20     ,\'aln\' :0                     # dummy\n                    ,\'a\'   :1        ,\'ala\' :0                     # dummy\n        }\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :142       ,\'muLexpT\'  :-2.5     # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'muLImin300\' :0         ,\'TSwitch\'    :200    # dummy\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0   # dummy\n                    ,\'Cref300\'    :1e100     ,\'CrefexpT\'      :0   # dummy\n                    ,\'alpha300\'   :1         ,\'alphaexpT\'     :0   # dummy\n        }\n        ,\'holes\':{      \'muL300\'     :47        ,\'muLexpT\'  :-2.2     # 1/10 constant Si value, but opposite ,\'exponent\' sign\n                    ,\'muLImin300\' :0         ,\'TSwitch\'  :200      # dummy\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0   # dummy\n                    ,\'Cref300\'    :1e100     ,\'CrefexpT\'      :0   # dummy\n                    ,\'alpha300\'   :1         ,\'alphaexpT\'     :0   # dummy\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :4.26e-4     ,\'nref_n\' :7.1e15         # Si values\n                   ,\'tau_p\' :3.95e-4     ,\'nref_p\' :7.1e15         # Si values\n        }\n        ,\'Auger\':{     \'c_n\' :2.8e-31       ,\'c_p\' :9.9e-31           # Si values\n        }\n    }\n}  \n#\n\n\n\n\n##########################################################################################\n##########################################################################################\n#          B I N A R I E S     --    IV - IV       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### diamond ###################################################\n,\'C\':{                                                   \n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'IV_IV\'   \n\n    ,\'lattice_consts\':{\n        \'a\'           :3.56683                                  # (300 K)\n        ,\'a_expansion\' :0                                        # ???\n    }\n      \n    ,\'dielectric_consts\':{\n        \'static_a\'  :5.68                                       # http://www.kobelco.co.jp/showroom/np0802e/np08022e.htm\n        ,\'optical_a\' :4                                          # ???\n    }\n\n    ,\'elastic_consts\':{ \n        \'c11\' :1079.0   ,\'c12\' :124.0   ,\'c44\' :578.0               #\n      # \'c11\' :1076.4   ,\'c12\' :125.2   ,\'c44\' :577.4               # Landolt-Boernstein, 298 K\n    }     \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # Piezoelectricity only occurs in III-V materials but not in group IV.\n    }\n  \n# band gap 5.47 at 300 K (indirect)   5.46-5.6  E(Gamma)=7.3-7.4\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \n          \'mass\'                  :1.9\n          ,\'bandgap\'               :5.47                         # 300 K\n          ,\'bandgap_alpha\'         :2.33e-4                      # \n          ,\'bandgap_beta\'          :1000                         # \n          ,\'defpot_absolute\'       :-10.41                       # ??? Ge value\n        }\n        ,\'L\':{ \n          \'mass_l\'                :1.57                         # ??? Ge value\n          ,\'mass_t\'                :0.0807                       # ??? Ge value\n          ,\'bandgap\'               :7                            # ???\n          ,\'bandgap_alpha\'         :2.33e-4                      # \n          ,\'bandgap_beta\'          :1000                         # \n          ,\'defpot_absolute\'       :-4.35                        # ??? Ge value\n          ,\'defpot_uniaxial\'       :15.13                        # ??? Ge value\n        }\n        ,\'Delta\':{\n          \'mass_l\'                :1.40                         #  85   K \n          ,\'mass_t\'                :0.36                         #  85   K \n          ,\'bandgap\'               :7                            # ???\n          ,\'bandgap_alpha\'         :2.33e-4                      # \n          ,\'bandgap_beta\'          :1000                         # \n          ,\'defpot_absolute\'       :0.14                         # ??? Ge value\n          ,\'defpot_uniaxial\'       :9.42                         # ??? Ge value\n          ,\'position\'              :0.85                         # ??? Ge value 0.85 for DELTA instead of 1.0 for X valley\n          ,\'g_l\'                   :0.82                         # ??? Ge value\n          ,\'g_t\'                   :1.93                         # ??? Ge value\n        }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.09                               # ??? Si value\n                                   \n        ,\'HH\':{ \'mass\'          :2.18 }                             # Landolt-Boernstein, cyclotron resonance at 1.2 K, value along [111]\n      # ,\'HH\':{ \'mass\'          :2.12 }                             # http://www.ioffe.ru/SVA/NSM/Semicond/Diamond/bandstr.html\n        ,\'LH\':{ \'mass\'          :0.70 }                             # Landolt-Boernstein, cyclotron resonance at 1.2 K, value along [111]\n      # ,\'LH\':{ \'mass\'          :0.7  }                             # http://www.ioffe.ru/SVA/NSM/Semicond/Diamond/bandstr.html\n        ,\'SO\':{ \'mass\'          :1.06 }                             # http://www.ioffe.ru/SVA/NSM/Semicond/Diamond/bandstr.html, Landolt-Boernstein, cyclotron resonance at 1.2 K, value along [111]\n                                   \n        ,\'defpot_absolute\'   :-0.35                              # ??? Ge value\n        ,\'defpot_uniaxial_b\' :-2.86   ,\'defpot_uniaxial_d\' :-5.28  # ??? Ge value\n\n        ,\'delta_SO\'          :0.006                              #\n\n    }\n    ,\'kp_6_bands\':{\n      # gamma1 :2.54   gamma2 :-0.10   gamma3 :0.63         # M. Willatzen, M. Cardona, N.E. Christensen PRB 50, 18054 (1994)\n        \'L\' :-3.140      ,\'M\' :-3.740       ,\'N\' :-3.780            # \n        ,\'kappa\' :-0.63                                          # P. Lawaetz, PRB 4, 3460 (1971)\n    }                                   \n                                       \n    ,\'kp_8_bands\':{                                                # No useful model for indirect ,\'bandgap\' materials!\n        \'S\' :1                                                  # ??? inverse effective mass\n        ,\'E_P\' :49.8                                             # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'B\' :0                                                  # This value is zero in group IV semiconductors (inversion symmetry).\n        ,\'L\' :-3.140      ,\'M\' :-3.740       ,\'N\' :-3.780            # 6-band parameters\n        ,\'kappa\' :-0.63                                          # 6-band parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :3800     ,\'exponent\' :1.66 }         # ??? Ge value\n        ,\'holes\':{      \'mumax\' :1800     ,\'exponent\' :2.33 }         # ??? Ge value\n    }\n\n}\n#\n\n######### silicon #####################################################\n,\'Si\':{                                                   \n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'IV_IV\'   \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.4304                                   # Landolt-Boernstein  298.15 K\n        ,\'a_expansion\' :1.8138e-5                                # Landolt-Boernstein\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :11.7                                       # Silvaco\n      # \'static_a\'  :11.9                                       # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990)\n        ,\'optical_a\' :11.85                                      # Landolt-Boernstein\n      # ,\'optical_a\' :13                                         # Dielectric constant at 10GHz  www.crystran.co.uk/sidata.htm\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :165.77   ,\'c12\' :63.93   ,\'c44\' :79.62               # 298 K  Landolt-Boernstein\n      # \'c11\' :167.7    ,\'c12\' :64.98   ,\'c44\' :80.35               #  77 K  A. Dargys, J. Kundrotas: Handbook on Physical Properties of Ge,Si,GaAs and InP\n      # \'c11\' :167      ,\'c12\' :65      ,\'c44\' :80                  #        www.crystran.co.uk/sidata.htm\n    }\n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # Piezoelectricity only occurs in III-V materials but not in group IV.\n    }                                                \n                                                                      \n    ,\'conduction_bands\':{\n        \'Gamma\':{ \n          \'mass\'                  :0.156\n          ,\'bandgap\'               :3.385                        # 0 K\n          ,\'bandgap_alpha\'         :0.4730e-3                    # This is ,\'a\' guess! (DELTA valley value was taken.)\n          ,\'bandgap_beta\'          :636                          # This is ,\'a\' guess! (DELTA valley value was taken.)\n          ,\'defpot_absolute\'       :-10.39                       # A. Zunger: a_c :a_v + a_gap :2.05 - 12.44 :-10.39\n        }\n        ,\'L\':{ \n          \'mass_l\'                :1.420\n          ,\'mass_t\'                :0.130\n          ,\'bandgap\'               :2.01                         # 0 K [J. Weber et al., PRB 40, 5683 (1989)]\n          ,\'bandgap_alpha\'         :0.4730e-3                    # This is ,\'a\' guess! (DELTA valley value was taken.)\n          ,\'bandgap_beta\'          :636                          # This is ,\'a\' guess! (DELTA valley value was taken.)\n          ,\'defpot_absolute\'       :-2.02                        # A. Zunger: a_c :a_v + a_gap :2.05 - 4.07 :-2.02\n        # ,\'defpot_absolute\'       :-0.66                        # C. van de Walle et al., PRB 34, 5621 (1986)\n          ,\'defpot_uniaxial\'       :16.14                        # C. van de Walle et al., PRB 34, 5621 (1986) - Xi_u(at minimum), theoretical value\n        }\n        ,\'Delta\':{                          \n          \'mass_l\'                :0.916                        # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990)\n          ,\'mass_t\'                :0.190                        # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990)\n          ,\'bandgap\'               :1.17                         #   0 K: 1.17 eV  www.ioffe.rssi.ru/SVA/NSM/Semicond/Si/bandstr.html\n        # ,\'bandgap\'               :1.12                         # 300 K: 1.12 eV  www.ioffe.rssi.ru/SVA/NSM/Semicond/Si/bandstr.html\n        # ,\'bandgap_alpha\'         :0.5367e-3                    # R. Hull: Prop. of Cryst. Si\n        # ,\'bandgap_beta\'          :745.8                        # R. Hull: Prop. of Cryst. Si\n          ,\'bandgap_alpha\'         :0.4730e-3                    # S.M. Sze (1981) and DESSIS\n          ,\'bandgap_beta\'          :636                          # S.M. Sze (1981) and DESSIS\n          ,\'defpot_absolute\'       :3.40                         # A. Zunger: a_c :a_v + a_gap :2.05 + 1.35 :3.40\n        # ,\'defpot_absolute\'       :3.3                          # experimental value of Cargill et al., PRL 61, 1748 (1988)\n        # ,\'defpot_absolute\'       :4.18                         # C. van de Walle et al., PRB 34, 5621 (1986)\n          ,\'defpot_uniaxial\'       :9.16                         # C. van de Walle et al., PRB 34, 5621 (1986) - Xi_u(at minimum), theoretical value\n        # ,\'defpot_uniaxial\'       :8.6                          # 8.6+-0.4 is experimental value, Laude et al., PRB 3, 2623 (1971)\n          ,\'position\'              :0.85                         # 0.85 for DELTA instead of 1.0 for X valley\n          ,\'g_l\'                   :2.00232                      # C. Tahan et al., PRB 71, 075315 (2005)\n          ,\'g_t\'                   :2.00232                      # C. Tahan et al., PRB 71, 075315 (2005)\n        }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.090                              # take Qteish value of -6.93 and shift it by 8.02 to align it with Zunger\'s average ,\'valence\' band energy (van der Walle model)\n        \n        ,\'HH\':{ \'mass\'          :0.537 }                            # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990)\n        ,\'LH\':{ \'mass\'          :0.153 }                            # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990)\n        ,\'SO\':{ \'mass\'          :0.234 }                            # K.W. Boer, Survey of Semiconductor Physics, Vol. 2 (1990) \n        \n        ,\'defpot_absolute\'   : 2.05                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 2.46                              # C. van de Walle, PRB 39, 1871 (1989), theoretical value\n      # ,\'defpot_absolute\'   : 1.80                              # calculated by van de Walle from experimental values of Laude et al. PRB 3, 2623 (1971) and Bardeen et al. PR 80, 72 (1950)\n      # ,\'defpot_uniaxial_b\' :-2.35   ,\'defpot_uniaxial_d\' :-5.32  # C. van de Walle et al., PRB 34, 5621 (1986), theoretical value\n        ,\'defpot_uniaxial_b\' :-2.10   ,\'defpot_uniaxial_d\' :-4.85  # Laude et al., PRB 3, 2623 (1971), experimental value (-2.10+-0.10, -4.85+-0.15)\n\n        ,\'delta_SO\'          :0.044\n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :   gamma2 :   gamma3 :\n        \'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56                      # M. Rieger, P. Vogl, PRB 48, 14276 (1993) - theoretical value\n      # \'L\' :-6.64   ,\'M\' :-4.60   ,\'N\' :-8.68                      # M. Rieger, P. Vogl, PRB 48, 14276 (1993) - calculated from experimental Luttinger parameters of O. Madelung (Landolt-Boernstein)\n      #  ,\'kappa\' :-0.26                                          # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'kappa\' :-0.42                                          # Landolt-B\xc3\xb6rnstein\n    }\n \n    ,\'kp_8_bands\':{                                                # No useful model for indirect ,\'bandgap\' materials!\n        \'S\' :6.41                                               # inverse effective mass\n        ,\'E_P\' :0                                                # decoupled bands\n        ,\'B\' :0                                                  # This value is zero in group IV semiconductors (inversion symmetry).\n        ,\'L\' :-6.69   ,\'M\' :-4.62   ,\'N\' :-8.56                      # 6-band parameters\n        ,\'kappa\' :-0.42                                          # 6-band parameter\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\'  :1417.0   ,\'exponent\' :2.5  }                 # DESSIS\n      # \'electrons\':{  \'mumax\'  :1430     ,\'exponent\' :2    }                 # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\'  :470.5    ,\'exponent\' :2.2  }                 # DESSIS\n      # ,\'holes\':{      \'mumax\'  :460      ,\'exponent\' :2.18 }                 # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n    \n    ,\'mobility_masetti\':{\n        \'electrons\':{  \'mumax\'  :1417.0   ,\'exponent\' :2.5                    # DESSIS (same as ,\'mobility_constant\':{})\n                    ,\'mumin1\' :52.2     ,\'mumin2\'   :52.2     ,\'mu1\' :43.4    # DESSIS\n                    ,\'pc\'     :0        ,\'cr\'       :9.68e16  ,\'cs\' :3.34e20  # DESSIS\n                    ,\'alpha\'  :0.680    ,\'beta\'     :2.0                    # DESSIS\n        }\n        ,\'holes\':{      \'mumax\'  :470.5    ,\'exponent\' :2.2                    # DESSIS (same as ,\'mobility_constant\':{})\n                    ,\'mumin1\' :44.9     ,\'mumin2\'   :0        ,\'mu1\' :29.0    # DESSIS\n                    ,\'pc\'     :9.23e16  ,\'cr\'       :2.23e17  ,\'cs\' :6.10e20  # DESSIS\n                    ,\'alpha\'  :0.719    ,\'beta\'     :2.0                    # DESSIS\n        }\n    }\n\n    ,\'mobility_arora\':{\n        \'electrons\':{  \'mumin\' :88        ,\'alm\' :-0.57                       # DESSIS\n                    ,\'mud\'   :1252      ,\'ald\' :-2.33                       # DESSIS\n                    ,\'n0\'    :1.25e17   ,\'aln\' : 2.4                        # DESSIS\n                    ,\'a\'     :0.88      ,\'ala\' :-0.146                      # DESSIS\n        }\n        ,\'holes\':{      \'mumin\' :54.3      ,\'alm\' :-0.57                       # DESSIS\n                    ,\'mud\'   :407       ,\'ald\' :-2.23                       # DESSIS\n                    ,\'n0\'    :2.35e17   ,\'aln\' : 2.4                        # DESSIS\n                    ,\'a\'     :0.88      ,\'ala\' :-0.146                      # DESSIS\n        }\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :1430      ,\'muLexpT\'       :-2           # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n                    ,\'muLImin300\' :80        ,\'TSwitch\'    :200             # PhD thesis V. Palankovski\n                    ,\'muLIexpTabove\' :-0.45  ,\'muLIexpTbelow\' :-0.15        # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :1.12e17   ,\'CrefexpT\'      :3.2          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.72      ,\'alphaexpT\'     :0.065        # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :460       ,\'muLexpT\'       :-2.18        # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n                    ,\'muLImin300\' :45        ,\'TSwitch\'    :200             # PhD thesis V. Palankovski\n                    ,\'muLIexpTabove\' :-0.45  ,\'muLIexpTbelow\' :-0.15        # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.23e17   ,\'CrefexpT\'      :3.2          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.72      ,\'alphaexpT\'     :0.065        # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :4.26e-4     ,\'nref_n\' :7.1e15                  # SIMBA\n                   ,\'tau_p\' :3.95e-4     ,\'nref_p\' :7.1e15                  # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :2.8e-31       ,\'c_p\' :9.9e-31                    # SIMBA\n        }\n    }\n}  \n#\n   \n######### germanium ###################################################\n,\'Ge\':{                                                   \n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'IV_IV\'   \n\n    ,\'lattice_consts\':{\n        \'a\'           :5.6579                                   # Landolt-Boernstein\n        ,\'a_expansion\' :5.8e-5                                   # [1/K?] ? S.M. Sze, Physics of Semiconductor Devices (1981)\n    }\n      \n    ,\'dielectric_consts\':{\n        \'static_a\'  :16.2                                       # Landolt-Boernstein\n      # \'static_a\'  :16.6                                       # at 9.37GHz at 300K   www.crystran.co.uk/germdata.htm\n        ,\'optical_a\' :10.10                                      # reference? GaAs value?\n    }\n\n    ,\'elastic_consts\':{ \n        \'c11\' :128.53   ,\'c12\' :48.26   ,\'c44\' :66.80               # Landolt-Boernstein\n      # \'c11\' :129      ,\'c12\' :48.3    ,\'c44\' :67.1                # www.crystran.co.uk/germdata.htm\n    }     \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # Piezoelectricity only occurs in III-V materials but not in group IV.\n    }\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \n          \'mass\'                  :0.038\n        # ,\'bandgap\'               :0.80                         # 300 K (F. Schaeffler, Semicond. Sci. Technol. 12, 1515 (1997))\n          ,\'bandgap\'               :0.9                          #   0 K (guess for 0 K, any reference available?)\n          ,\'bandgap_alpha\'         :0.4774e-3                    # This is ,\'a\' guess! (L valley value was taken.)\n          ,\'bandgap_beta\'          :235                          # This is ,\'a\' guess! (L valley value was taken.)\n          ,\'defpot_absolute\'       :-10.41                       # A. Zunger: a_c :a_v + a_gap :-0.35 - 10.06 :-10.41\n        }\n        ,\'L\':{ \n          \'mass_l\'                :1.57\n          ,\'mass_t\'                :0.0807\n          ,\'bandgap\'               :0.74                         # 0 K [4.2 K, F. Schaeffler, Semicond. Sci. Technol. 12 (1997)]\n        # ,\'bandgap\'               :0.664                        # 300 K, H. Grahn, Semiconductor Physics\n          ,\'bandgap_alpha\'         :0.4774e-3                    # S.M. Sze, Physics of Semiconductor Devices (1981)\n          ,\'bandgap_beta\'          :235                          # S.M. Sze, Physics of Semiconductor Devices (1981)\n          ,\'defpot_absolute\'       :-4.35                        # A. Zunger: a_c :a_v + a_gap :-0.35 - 4.00 :-4.35\n        # ,\'defpot_absolute\'       :-1.54                        # C. van de Walle et al., PRB 34, 5621 (1986)\n          ,\'defpot_uniaxial\'       :15.13                        # C. van de Walle et al., PRB 34, 5621 (1986)\n        # ,\'defpot_uniaxial\'       :10.4                         # M. Fischetti\n        }\n        ,\'Delta\':{\n          \'mass_l\'                :1.350\n          ,\'mass_t\'                :0.290 \n        # ,\'bandgap\'               :1.094                        #   0   K\n          ,\'bandgap\'               :0.931                        #   4.2 K, J. Weber et al., PRB 40, 5683 (1989) (X or DELTA?)\n        # ,\'bandgap\'               :1.254                        # 300   K\n          ,\'bandgap_alpha\'         :0.4774e-3                    # This is ,\'a\' guess! (L valley value was taken.)\n          ,\'bandgap_beta\'          :235                          # This is ,\'a\' guess! (L valley value was taken.)\n          ,\'defpot_absolute\'       :0.14                         # A. Zunger: a_c :a_v + a_gap :-0.35 + 0.49 :0.14\n        # ,\'defpot_absolute\'       :2.55                         # C. van de Walle et al., PRB 34, 5621 (1986)\n          ,\'defpot_uniaxial\'       :9.42                         # C. van de Walle et al., PRB 34, 5621 (1986)\n        # ,\'defpot_uniaxial\'       :9.75                         # M. Fischetti\n          ,\'position\'              :0.85                         # 0.85 for DELTA instead of 1.0 for X valley\n          ,\'g_l\'                   :0.82                         # F.A. Baron et al., PRB 68, 195306 (2003)\n          ,\'g_t\'                   :1.93                         # F.A. Baron et al., PRB 68, 195306 (2003)\n        }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.67                               # see comments at beginning of Si database entry\n      # \'bandoffset\'        :1.830                              # take Qteish value of -6.19 and shift it by 8.02 to align it with A. Zunger\'s average ,\'valence\' band energy (van der Walle model)\n                                   \n      # ,\'HH\':{ \'mass\'          :0.316  }                           # (Reference?)\n      # ,\'LH\':{ \'mass\'          :0.0424 }                           # (Reference?)\n      # ,\'SO\':{ \'mass\'          :0.095  }                           # (Reference?)\n        ,\'HH\':{ \'mass\'          :0.33   }                           # http://www.ioffe.ru/SVA/NSM/Semicond/Ge/bandstr.html\n        ,\'LH\':{ \'mass\'          :0.043  }                           # http://www.ioffe.ru/SVA/NSM/Semicond/Ge/bandstr.html\n        ,\'SO\':{ \'mass\'          :0.084  }                           # http://www.ioffe.ru/SVA/NSM/Semicond/Ge/bandstr.html\n                                   \n        ,\'defpot_absolute\'   :-0.35                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 1.24                              # C. van de Walle, PRB 39, 1871 (1989), theoretical value\n      # ,\'defpot_uniaxial_b\' :-2.55   ,\'defpot_uniaxial_d\' :-5.5   # C. van de Walle et al., PRB 34, 5621 (1986), theoretical value\n        ,\'defpot_uniaxial_b\' :-2.86   ,\'defpot_uniaxial_d\' :-5.28  # M. Chandrasekhar et al., PRB 15, 2127 (1977), experimental value (-2.86+-0.15,-5.28+-0.50)\n\n        ,\'delta_SO\'          :0.30                               # M. Cardona et al. in Landolt-Boernstein\n\n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :13.38   gamma2 :4.24   gamma3 :5.69         # J.C. Hensel, K. Suzuki PRB 9, 4219 (1974)\n        \'L\' :-31.34       ,\'M\' :-5.90       ,\'N\' :-34.14            # M. Rieger Diploma thesis - experimental value, calculated from experimental Luttinger parameters of J.C. Hensel, K. Suzuki PRB 9, 4219 (1974)\n      # \'L\' :-21.65       ,\'M\' :-5.02       ,\'N\' :-23.48            # M. Rieger, P. Vogl, PRB 48, 14276 (1993) - theoretical value\n        ,\'kappa\' :3.41                                           # P. Lawaetz, PRB 4, 3460 (1971) + Landolt-B\xc3\xb6rnstein\n    }                                   \n                                       \n    ,\'kp_8_bands\':{                                                # No useful model for indirect ,\'bandgap\' materials!\n        \'S\' :26.32                                              # inverse effective mass\n        ,\'E_P\' :0                                                # decoupled bands\n        ,\'B\' :0                                                  # This value is zero in group IV semiconductors (inversion symmetry).\n        ,\'L\' :-31.34       ,\'M\' :-5.90       ,\'N\' :-34.14            # 6-band parameters\n        ,\'kappa\' :3.41                                           # 6-band parameter\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :3800     ,\'exponent\' :1.66 }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :1800     ,\'exponent\' :2.33 }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :3800      ,\'muLexpT\'       :-1.66        # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n                    ,\'muLImin300\' :850       ,\'TSwitch\'    :200             # PhD thesis V. Palankovski\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.6e17    ,\'CrefexpT\'      :0            # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.56      ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :1800      ,\'muLexpT\'       :-2.33        # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n                    ,\'muLImin300\' :300       ,\'TSwitch\'    :200             # PhD thesis V. Palankovski\n                    ,\'muLIexpTabove\' :0      ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :1.0e17    ,\'CrefexpT\'      :0            # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :4.26e-4     ,\'nref_n\' :7.1e15                  # SIMBA\n                   ,\'tau_p\' :3.95e-4     ,\'nref_p\' :7.1e15                  # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31                    # SIMBA\n        }\n    }\n}\n#\n\n\n\n\n\n\n\n\n\n##########################################################################################\n##########################################################################################\n#          B I N A R I E S     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### gallium arsenide ############################################\n,\'GaAs\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.65325                                  # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :3.88e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :12.93\n        ,\'optical_a\' :10.10\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :122.1   ,\'c12\' :56.6   ,\'c44\' :60.0                  # Vurgaftman1\n    }                    \n\n    ,\'piezoelectric_consts\':{\n     #  \'e14\' :-0.175                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n        \'e14\' :-0.160                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.067                        # Vurgaftman1\n          ,\'bandgap\'               :1.519                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.5405e-3                    # Vurgaftman1\n          ,\'bandgap_beta\'          :204                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-9.36                        # A. Zunger: a_c :a_v + a_gap :-1.21 - 8.15 :-9.36\n        # ,\'defpot_absolute\'       :-7.17                        # Vurgaftman1\n        # ,\'g\'                     :-0.44                        #   4 K, M. Oestreich et al., PRB 53, 7911 (1996)\n          ,\'g\'                     :-0.30                        # 280 K, M. Oestreich et al., PRB 53, 7911 (1996)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.9                          # Vurgaftman1\n          ,\'mass_t\'                :0.0754                       # Vurgaftman1\n          ,\'bandgap\'               :1.815                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.605e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :204                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-4.91                        # A. Zunger: a_c :a_v + a_gap :-1.21 - 3.70 :-4.91\n          ,\'defpot_uniaxial\'       :14.26                        # C. van de Walle\n       }\n       ,\'X\':{ \n          \'mass_l\'                :1.3                          # Vurgaftman1\n          ,\'mass_t\'                :0.23                         # Vurgaftman1\n          ,\'bandgap\'               :1.981                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.460e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :204                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-0.16                        # A. Zunger: a_c :a_v + a_gap :-1.21 + 1.05 :-0.16\n          ,\'defpot_uniaxial\'       :8.61                         # C. van de Walle\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.346                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.51  ,\'g\' :-7.86 }                  # m_hh :http://www.ioffe.ru/SVA/NSM/Semicond/GaAs/bandstr.html\n        ,\'LH\':{ \'mass\'          :0.082 ,\'g\' :-2.62 }                  # m_lh :http://www.ioffe.ru/SVA/NSM/Semicond/GaAs/bandstr.html\n#       ,\'SO\':{ \'mass\'          :0.15  }                            # m_so :http://www.ioffe.ru/SVA/NSM/Semicond/GaAs/bandstr.html\n        ,\'SO\':{ \'mass\'          :0.172 }                            # Vurgaftman1\n\n        ,\'defpot_absolute\'   :-1.21                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 1.16                              # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -1.16\n        ,\'defpot_uniaxial_b\' :-2.0   ,\'defpot_uniaxial_d\' :-4.8\n       \n        ,\'delta_SO\'          :0.341                              # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :6.98   gamma2 :2.06   gamma3 :2.93          # Vurgaftman1\n        \'L\' :-16.22      ,\'M\' : -3.86      ,\'N\' :-17.58                \n        ,\'kappa\' :1.2                                            # Kiselev, PRB 64, 125303 (2001)\n      # ,\'kappa\' :1.72                                           # P. Lawaetz, PRB 4, 3460 (1971)\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :1.519\n        \'S\' :-2.88                                              # S :1 + 2F :1 + 2 (-1.94) :-2.88 (Vurgaftman1)\n        ,\'E_P\' :28.8                                             # Vurgaftman1\n        ,\'B\' : 0                     \n        ,\'L\' : 1.420   ,\'M\' :-3.86    ,\'N\' : 0.056\n        ,\'kappa\' :-1.74                                          # Kiselev\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :8500     ,\'exponent\' :2.2  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :800      ,\'exponent\' :0.9  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :8500      ,\'muLexpT\'       :-2.2         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :800       ,\'muLIexpTabove\' :-0.9         # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :-0.9         # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :1.0e17    ,\'CrefexpT\'      :6.2          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.5       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :800       ,\'muLexpT\'       :-0.9         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :40        ,\'muLIexpTabove\' :0            # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :1.0e17    ,\'CrefexpT\'      :0.5          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19                  # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18                  # SIMBA\n        }\n      # ,\'Auger\':{     \'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31                    # SIMBA\n        ,\'Auger\':{     \'c_n\' :1.0e-30       ,\'c_p\' :1.0e-30                    # 300 K, http://www.ioffe.ru/SVA/NSM/Semicond/GaAs/electric.html#Recombination\n        }\n      # ,\'radiative\':{ \'c\' :2.0e-10                                          # DESSIS\n        ,\'radiative\':{ \'c\' :7.2e-10                                          # Ioffe, 300 K, V. P. Varshni, Phys. Status Solidi 19, 459 (1967); 20, 9 (1967), http://www.ioffe.ru/SVA/NSM/Semicond/GaAs/electric.html#Recombination\n        }\n    }\n}\n#\n   \n######### aluminum arsenide ###########################################\n,\'AlAs\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.6611                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.90e-5                                  # Vurgaftman1\n    }\n   \n    ,\'dielectric_consts\':{\n        \'static_a\'  :10.064                                     # Landolt-Boernstein\n        ,\'optical_a\' :8.162                                      # Landolt-Boernstein\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :125.0   ,\'c12\' :53.4   ,\'c44\' :54.2                  # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n      # \'e14\' :-0.22                                            # guess from ,\'a\' picture http://nina.ecse.rpi.edu/shur/Tutorial/GaNtutorial1/sld036.htm\n        \'e14\' :-0.015                                           # calculated by S. Gironcoli et al., PRL 62(24), 2853 (1989)\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.15                         # Vurgaftman1\n          ,\'bandgap\'               :3.099                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.885e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :530                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-7.40                        # A. Zunger: a_c :a_v + a_gap :1.53 - 8.93 :-7.40\n        # ,\'defpot_absolute\'       :-5.64                        # Vurgaftman1\n          ,\'g\'                     :1.52                         # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.32                         # Vurgaftman1\n          ,\'mass_t\'                :0.15                         # Vurgaftman1\n          ,\'bandgap\'               :2.46                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.605e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :204                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-3.07                        # A. Zunger: a_c :a_v + a_gap :1.53 - 4.60 :-3.07\n          ,\'defpot_uniaxial\'       :11.35                        # InAs value !!!\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.97                         # Vurgaftman1\n          ,\'mass_t\'                :0.22                         # Vurgaftman1\n          ,\'bandgap\'               :2.24                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.70e-3                      # Vurgaftman1\n          ,\'bandgap_beta\'          :530                          # Vurgaftman1\n          ,\'defpot_absolute\'       :2.54                         # A. Zunger: a_c :a_v + a_gap :1.53 + 1.01 :2.54\n          ,\'defpot_uniaxial\'       :6.11                         # Munoz\n          ,\'g_l\'                   :1.9                          # J.D. Caldwell et al., PRB 72, 115339 (2005)\n          ,\'g_t\'                   :1.9                          # J.D. Caldwell et al., PRB 72, 115339 (2005)\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.857                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.5   }                            # Landolt-Boernstein\n        ,\'LH\':{ \'mass\'          :0.26  }                            # Landolt-Boernstein\n        ,\'SO\':{ \'mass\'          :0.28  }                            # Vurgaftman1\n        \n        ,\'defpot_absolute\'   :1.53                               # A. Zunger: a_v\n      # ,\'defpot_absolute\'   :2.47                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -2.47\n        ,\'defpot_uniaxial_b\' :-2.3   ,\'defpot_uniaxial_d\' :-3.4    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.28                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :3.76   gamma2 :0.82   gamma3 :1.42          # Vurgaftman1\n        \'L\' :-8.04       ,\'M\' :-3.12       ,\'N\' :-8.52               \n        ,\'kappa\' :0.12                                           # P. Lawaetz, PRB 4, 3460 (1971) \n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.099\n        \'S\' : 0.04                                              # S :1 + 2F :1 + 2 (-0.48) :0.04 (Vurgaftman1)\n        ,\'E_P\' :21.1                                             # Vurgaftman1\n        ,\'B\' : 0                       \n        ,\'L\' :-1.430   ,\'M\' :-3.12   ,\'N\' :-1.910\n        ,\'kappa\' :-0.982                \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :410      ,\'exponent\' :2.1  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :130      ,\'exponent\' :2.2  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :410       ,\'muLexpT\'       :-2.1         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :10        ,\'muLIexpTabove\' :0            # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :1.0e17    ,\'CrefexpT\'      :0            # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.5       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :130       ,\'muLexpT\'       :-2.2         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :5         ,\'muLIexpTabove\' :0            # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.9e17    ,\'CrefexpT\'      :0.5          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19                  # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18                  # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                          # SIMBA\n        }\n        ,\'radiative\':{ \'c\' :0                                                # ?\n        }\n    }\n}\n#\n\n######### indium arsenide #############################################\n,\'InAs\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.0583                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.74e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :15.15                                      # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' :12.25                                      # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :83.29   ,\'c12\' :45.26   ,\'c44\' :39.59                # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n      # \'e14\' :-0.035                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n        \'e14\' :-0.044                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.0459                                          # Landolt-Boernstein\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.026                        # Vurgaftman1\n          ,\'bandgap\'               :0.417                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.276e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :93                           # Vurgaftman1\n        # ,\'defpot_absolute\'       :-5.08                        # Vurgaftman1\n          ,\'defpot_absolute\'       :-6.66                        # A. Zunger: a_c :a_v + a_gap :-1.00 - 5.66 :-6.66\n        # ,\'g\'                     :-15.6                        # PhD thesis S. Hackenbuchner, p. 104\n          ,\'g\'                     :-14.9                        # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.64                         # Vurgaftman1\n          ,\'mass_t\'                :0.05                         # Vurgaftman1\n          ,\'bandgap\'               :1.133                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.276e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :93                           # Vurgaftman1\n          ,\'defpot_absolute\'       :-3.89                        # A. Zunger: a_c :a_v + a_gap :-1.00 - 2.89 :-3.89\n          ,\'defpot_uniaxial\'       :11.35                        # C. van de Walle\n       }\n       ,\'X\':{ \n          \'mass_l\'                :1.13                         # Vurgaftman1\n          ,\'mass_t\'                :0.16                         # Vurgaftman1\n          ,\'bandgap\'               :1.433                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.276e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :93                           # Vurgaftman1\n          ,\'defpot_absolute\'       :-0.08                        # A. Zunger: a_c :a_v + a_gap :-1.00 + 0.92 :-0.08\n          ,\'defpot_uniaxial\'       :3.7                          # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.390                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.41  ,\'g\' :-45.2 }                  # http://www.ioffe.ru/SVA/NSM/Semicond/InAs/bandstr.html\n        ,\'LH\':{ \'mass\'          :0.026 ,\'g\' :-15.1 }                  # Yu, Cardona, Fundamentals of Semiconductors, p. 70, http://www.ioffe.ru/SVA/NSM/Semicond/InAs/bandstr.html\n      # ,\'LH\':{ \'mass\'          :0.025 }                            # Landolt-Boernstein\n      # ,\'SO\':{ \'mass\'          :0.016 }                            # http://www.ioffe.ru/SVA/NSM/Semicond/InAs/bandstr.html\n        ,\'SO\':{ \'mass\'          :0.014 }                            # Vurgaftman1\n        \n        ,\'defpot_absolute\'   :-1.00                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 1.00                              # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -1.00\n        ,\'defpot_uniaxial_b\' :-1.8   ,\'defpot_uniaxial_d\' :-3.6    # Vurgaftman1 - N.E. Christensen et al., PRB 36 (2), 1032 (1987) suggest to revise experimental value of d=-3.6.\n       \n        ,\'delta_SO\'          :0.39                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :20.0   gamma2 :8.5   gamma3 :9.2            # Vurgaftman1\n        \'L\' :-55.0       ,\'M\' :-4.0       ,\'N\' :-55.2        \n        ,\'kappa\' :7.68                                            # Kiselev, PRB 64, 125303 (2001) + P. Lawaetz, PRB 4, 3460 (1971)       \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.417\n        \'S\' : -4.80                                             # S :1 + 2F :1 + 2 (-2.90) :-4.80 (Vurgaftman1)\n        ,\'E_P\' :21.5                                             # Vurgaftman1\n        ,\'B\' :  0                   \n        ,\'L\' :-15.695   ,\'M\' :-4.0   ,\'N\' :-15.895\n        ,\'kappa\' :1.129               \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :32500    ,\'exponent\' :1.7  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :510      ,\'exponent\' :2.3  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :32500     ,\'muLexpT\'       :-1.7         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :11700     ,\'muLIexpTabove\' :-0.33        # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :-0.33        # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :4.4e16    ,\'CrefexpT\'      : 3.6         # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.5       ,\'alphaexpT\'     : 0           # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :510       ,\'muLexpT\'       :-2.3         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :48        ,\'muLIexpTabove\' :0            # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.55e17   ,\'CrefexpT\'      :0.5          # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19                  # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18                  # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31                    # SIMBA\n        }\n        ,\'radiative\':{ \'c\' :0                                                # ?\n        }\n    }\n}\n#\n\n######### gallium phosphide ###########################################\n,\'GaP\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.4505                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.92e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :11.1                                       # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' : 9.075                                     # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :140.5   ,\'c12\' :62.03   ,\'c44\' :70.33                # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n      # \'e14\' :-0.097                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n        \'e14\' :-0.097                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.1                                             # Landolt-Boernstein - was already negative in Landolt-Boernstein\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.13                         # Vurgaftman1\n          ,\'bandgap\'               :2.886                        # Vurgaftman1 (0 K) 2.886 + 0.1081 [1 - coth(164/T)]\n          ,\'bandgap_alpha\'         :0.5771e-3                    # L and X valley ??? => see formula above\n          ,\'bandgap_beta\'          :372                          # L and X valley ??? => see formula above\n        # ,\'defpot_absolute\'       :-8.2                         # Vurgaftman1\n          ,\'defpot_absolute\'       :-9.41                        # A. Zunger: a_c :a_v + a_gap :-0.58 - 8.83 :-9.41\n          ,\'g\'                     :1.9                          # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.2                          # Vurgaftman1\n          ,\'mass_t\'                :0.15                         # Vurgaftman1\n          ,\'bandgap\'               :2.72                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.5771e-3                    # Vurgaftman1\n          ,\'bandgap_beta\'          :372                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-4.41                        # A. Zunger: a_c :a_v + a_gap :-0.58 - 3.83 :-4.41\n          ,\'defpot_uniaxial\'       :11.35                        # InAs value\n       }\n     # ,\'Delta\':{                                                  # GaP has DELTA vallye (and not X valley)\n       ,\'X\':{\n          \'mass_l\'                :2.0                          # Vurgaftman1\n          ,\'mass_t\'                :0.253                        # Vurgaftman1\n          ,\'bandgap\'               :2.35                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.5771e-3                    # Vurgaftman1\n          ,\'bandgap_beta\'          :372                          # Vurgaftman1\n          ,\'defpot_absolute\'       :0.69                         # A. Zunger: a_c :a_v + a_gap :-0.58 + 1.27 :0.69\n          ,\'defpot_uniaxial\'       :5.65                         # Munoz\n        # ,\'position\'              :0.95                         # 0.95 for DELTA instead of 1.0 for X valley\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.963                              # A. Zunger\n        \n      # ,\'HH\':{ \'mass\'          :0.57  }                            # Yu, Cardona, Fundamentals of Semiconductors, p. 70\n        ,\'HH\':{ \'mass\'          :0.79  }                            # Landolt-Boernstein (m_p,h), http://www.ioffe.ru/SVA/NSM/Semicond/GaP/bandstr.html\n        ,\'LH\':{ \'mass\'          :0.14  }                            # Landolt-Boernstein (m_p,l), http://www.ioffe.ru/SVA/NSM/Semicond/GaP/bandstr.html\n        ,\'SO\':{ \'mass\'          :0.25  }                            # Vurgaftman1\n        \n        ,\'defpot_absolute\'   :-0.58                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 1.7                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -1.7\n        ,\'defpot_uniaxial_b\' :-1.6   ,\'defpot_uniaxial_d\' :-4.6    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.08                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.05   gamma2 :0.49   gamma3 :1.25          # (ERROR in Vurgaftman1 paper!!!)\n        \'L\' :-7.01       ,\'M\' :-4.07       ,\'N\' :-7.50   \n        ,\'kappa\' :0.34                                           # Kiselev, PRB 64, 125303 (2001)+ P. Lawaetz, PRB 4, 3460 (1971)            \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.886\n        \'S\' :-3.08                                              # S :1 + 2F :1 + 2 (-2.04) :-3.08 (Vurgaftman1)\n        ,\'E_P\' :31.4                                             # Vurgaftman1\n        ,\'B\' : 0                   \n        ,\'L\' : 5.7705   ,\'M\' :-4.07   ,\'N\' :3.280  \n        ,\'kappa\' :-1.457             \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :210      ,\'exponent\' :1.94 }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :160      ,\'exponent\' :2.0  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :210       ,\'muLexpT\'       :-1.94        # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :76        ,\'muLIexpTabove\' :-1.07        # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :-1.07        # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.85e17   ,\'CrefexpT\'      : 1.8         # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.5       ,\'alphaexpT\'     : 0           # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :160       ,\'muLexpT\'       :-2.0         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :27        ,\'muLIexpTabove\' :0            # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' :0            # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.33e17   ,\'CrefexpT\'      :0            # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     :0            # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19                  # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18                  # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                          # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :0                                                # ?\n        }\n    }\n}\n#\n\n######### aluminium phosphide #########################################\n,\'AlP\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.4672                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.92e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :9.8                                        # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' :7.5385                                     # Landolt-Boernstein epsilon(infinity) => epsilon(0) / epsilon(infinity) :1.3\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :133.0   ,\'c12\' :63.0   ,\'c44\' :61.5                  # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.059                                            # POSITIVE value - calculated by S. Gironcoli et al., PRL 62(24), 2853 (1989)\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.22                         # Vurgaftman1\n          ,\'bandgap\'               :3.63                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.5771e-3                    # Vurgaftman1\n          ,\'bandgap_beta\'          :372                          # Vurgaftman1\n        # ,\'defpot_absolute\'       :-5.7                         # Vurgaftman1\n          ,\'defpot_absolute\'       :-6.88                        # A. Zunger: a_c :a_v + a_gap :2.64 - 9.52 :-6.88\n          ,\'g\'                     :1.92                         # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1                            # Vurgaftman1\n          ,\'mass_t\'                :0.1                          # ???\n          ,\'bandgap\'               :3.57                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.318e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :588                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-1.74                        # A. Zunger: a_c :a_v + a_gap :2.64 - 4.38 :-1.74\n          ,\'defpot_uniaxial\'       :11.35                        # InAs value\n       }\n       ,\'X\':{\n          \'mass_l\'                :2.68                         # Vurgaftman1\n          ,\'mass_t\'                :0.155                        # Vurgaftman1\n          ,\'bandgap\'               :2.52                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.318e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :588                          # Vurgaftman1\n          ,\'defpot_absolute\'       :3.98                         # A. Zunger: a_c :a_v + a_gap :2.64 + 1.34 :3.98\n          ,\'defpot_uniaxial\'       :6.75                         # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.427                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.63  }                            # Landolt-Boernstein (m_p,h)\n        ,\'LH\':{ \'mass\'          :0.20  }                            # Landolt-Boernstein (m_p,l)\n        ,\'SO\':{ \'mass\'          :0.30  }                            # Vurgaftman1\n        \n        ,\'defpot_absolute\'   : 2.64                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 3.0                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -3.0\n        ,\'defpot_uniaxial_b\' :-1.5   ,\'defpot_uniaxial_d\' :-4.6    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.07                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :3.35   gamma2 :0.71   gamma3 :1.23          # Vurgaftman1\n        \'L\' :-7.19       ,\'M\' :-2.93       ,\'N\' :-7.38  \n        ,\'kappa\' :-0.54                                          # P. Lawaetz, PRB 4, 3460 (1971)             \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.52\n        \'S\' :-0.30                                              # S :1 + 2F :1 + 2 (-0.65) :-0.30 (Vurgaftman1)\n        ,\'E_P\' :17.7                                             # Vurgaftman1\n        ,\'B\' : 0                   \n        ,\'L\' :-2.345   ,\'M\' :-2.93   ,\'N\' :-2.535  \n        ,\'kappa\' :-1.347             \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :210      ,\'exponent\' :1.94 }         # GaP values\n        ,\'holes\':{      \'mumax\' :160      ,\'exponent\' :2.0  }         # GaP values\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :0                                       # ?\n        }\n    }\n}\n#\n\n######### indium phosphide ############################################\n,\'InP\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.8697                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.79e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :12.61                                      # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' : 9.61                                      # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :101.1   ,\'c12\' :56.1   ,\'c44\' :45.6                  # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' : 0.056                                           # POSITIVE value - calculated by S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.042                                           #             experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.0795                       # Vurgaftman1\n          ,\'bandgap\'               :1.4236                       # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.363e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :162                          # Vurgaftman1\n        # ,\'defpot_absolute\'       :-6.0                         # Vurgaftman1\n          ,\'defpot_absolute\'       :-6.34                        # A. Zunger: a_c :a_v + a_gap :-0.41 - 5.93 :-6.34\n          ,\'g\'                     :1.20                         # 4 K (up to 160 K), M. Oestreich et al., PRB 53, 7911 (1996) (small temperature dependence)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.47                         # Vurgaftman1 - m_DOS(L)\n          ,\'mass_t\'                :0.47                         # Vurgaftman1 - m_DOS(L)\n          ,\'bandgap\'               :2.014                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.363e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :162                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-3.41                        # A. Zunger: a_c :a_v + a_gap :-0.41 - 3.00 :-3.41\n          ,\'defpot_uniaxial\'       :11.35                        # InAs value\n       }\n       ,\'X\':{\n          \'mass_l\'                :0.88                         # Vurgaftman1 - m_DOS(X)\n          ,\'mass_t\'                :0.88                         # Vurgaftman1 - m_DOS(X)\n          ,\'bandgap\'               :2.384                        # Vurgaftman1 (0 K)        ,\'bandgap\' : 2.384 - 3.7e-4 * T\n          ,\'bandgap_alpha\'         :0.363e-3                     # GAMMA and L values !!!\n          ,\'bandgap_beta\'          :162                          # GAMMA and L values !!!\n          ,\'defpot_absolute\'       :0.59                         # A. Zunger: a_c :a_v + a_gap :-0.41 + 1.00 :0.59\n          ,\'defpot_uniaxial\'       :3.3                          # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.064                              # A. Zunger\n        \n      # ,\'HH\':{ \'mass\'          :0.58  }                            # Yu, Cardona, Fundamentals of Semiconductors, p. 70\n      # ,\'HH\':{ \'mass\'          :0.6   }                            # http://www.ioffe.ru/SVA/NSM/Semicond/InP/bandstr.html\n        ,\'HH\':{ \'mass\'          :0.85  }                            # Landolt-Boernstein (m_p,h)\n        ,\'LH\':{ \'mass\'          :0.089 }                            # Landolt-Boernstein (m_p,l), http://www.ioffe.ru/SVA/NSM/Semicond/InP/bandstr.html\n        ,\'SO\':{ \'mass\'          :0.21  }                            # Vurgaftman1\n      # ,\'SO\':{ \'mass\'          :0.17  }                            # http://www.ioffe.ru/SVA/NSM/Semicond/InP/bandstr.html\n\n        ,\'defpot_absolute\'   :-0.41                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 0.6                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -0.6\n        ,\'defpot_uniaxial_b\' :-2.0   ,\'defpot_uniaxial_d\' :-5.0    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.108                              # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :5.08   gamma2 :1.60   gamma3 :2.10          # Vurgaftman1\n        \'L\' :-12.48      ,\'M\' :-2.88       ,\'N\' :-12.60    \n        ,\'kappa\' :0.97                                           # Kiselev, PRB 64, 125303 (2001)\n      # ,\'kappa\' :1.47                                           # P. Lawaetz, PRB 4, 3460 (1971)           \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :1.4236\n        \'S\' :-1.62                                              # S :1 + 2F :1 + 2 (-1.31) :-1.62 (Vurgaftman1)\n        ,\'E_P\' :20.7                                             # Vurgaftman1\n        ,\'B\' : 0                   \n        ,\'L\' : 1.7020   ,\'M\' :-2.88   ,\'N\' :1.5820 \n        ,\'kappa\' :-1.394                                         # Kiselev              \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :5300     ,\'exponent\' :1.9  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n        ,\'holes\':{      \'mumax\' :200      ,\'exponent\' :1.2  }         # PhD thesis V. Palankovski but opposite sign for ,\'exponent\'\n    }\n\n    ,\'mobility_minimos\':{\n        \'electrons\':{  \'muL300\'     :5300      ,\'muLexpT\'       :-1.9         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :1520      ,\'muLIexpTabove\' : 2.0         # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' : 2.0         # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :6.4e16    ,\'CrefexpT\'      : 3.7         # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :0.5       ,\'alphaexpT\'     : 0           # PhD thesis V. Palankovski\n        }\n        ,\'holes\':{      \'muL300\'     :200       ,\'muLexpT\'       :-1.2         # PhD thesis V. Palankovski (same as ,\'mobility_constant\':{} but opposite sign for ,\'exponent\')\n\n                    ,\'muLImin300\' :24        ,\'muLIexpTabove\' : 1.2         # PhD thesis V. Palankovski\n                                           ,\'muLIexpTbelow\' : 1.2         # PhD thesis V. Palankovski\n                    ,\'TSwitch\'    :200                                    # PhD thesis V. Palankovski\n                    ,\'Cref300\'    :2.5e17    ,\'CrefexpT\'      : 0.47        # PhD thesis V. Palankovski\n                    ,\'alpha300\'   :1.0       ,\'alphaexpT\'     : 0           # PhD thesis V. Palankovski\n        }\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19                  # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18                  # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                          # SIMBA\n        }\n        ,\'radiative\':{ \'c\' :0                                                # ?\n        }\n    }\n}\n#\n\n######### gallium antimonide ##########################################\n,\'GaSb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.0959                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :4.72e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :15.69                                      # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' :14.44                                      # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :88.42   ,\'c12\' :40.26   ,\'c44\' :43.22                 # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :-0.172                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.168                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.126                                           # Landolt-Boernstein\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.039                        # Vurgaftman1\n          ,\'bandgap\'               :0.812                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.417e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :140                          # Vurgaftman1\n        # ,\'defpot_absolute\'       :-7.5                         # Vurgaftman1\n          ,\'defpot_absolute\'       :-9.33                        # A. Zunger: a_c :a_v + a_gap :-1.32 - 8.01 :-9.33\n          ,\'g\'                     :-9.2                         # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.3                          # Vurgaftman1\n          ,\'mass_t\'                :0.10                         # Vurgaftman1\n          ,\'bandgap\'               :0.875                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.597e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :140                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-4.38                        # A. Zunger: a_c :a_v + a_gap :-1.32 - 3.06 :-4.38\n          ,\'defpot_uniaxial\'       :15.0                         # Landolt-Boernstein\n       }\n       ,\'X\':{\n          \'mass_l\'                :1.51                         # Vurgaftman1\n          ,\'mass_t\'                :0.22                         # Vurgaftman1\n          ,\'bandgap\'               :1.141                        # Vurgaftman1 (0 K)        ,\'bandgap\' : 2.384 - 3.7e-4 * T\n          ,\'bandgap_alpha\'         :0.475e-3                     # Vurgaftman1\n          ,\'bandgap_beta\'          :94                           # Vurgaftman1\n          ,\'defpot_absolute\'       :-0.20                        # A. Zunger: a_c :a_v + a_gap :-1.32 + 1.12 :-0.20\n          ,\'defpot_uniaxial\'       :6.46                         # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.777                              # A. Zunger\n        \n      # ,\'HH\':{ \'mass\'          :0.8    }                           # Yu, Cardona, Fundamentals of Semiconductors, p. 70\n        ,\'HH\':{ \'mass\'          :0.34   }                           # Landolt-Boernstein (m_p,h)\n        ,\'LH\':{ \'mass\'          :0.0447 }                           # Landolt-Boernstein (m_p,l)\n        ,\'SO\':{ \'mass\'          :0.12   }                           # Vurgaftman1\n\n      # ,\'HH\':{ \'mass\'          :0.4    }                           # http://www.ioffe.ru/SVA/NSM/Semicond/GaSb/bandstr.html\n      # ,\'LH\':{ \'mass\'          :0.05   }                           # http://www.ioffe.ru/SVA/NSM/Semicond/GaSb/bandstr.html\n      # ,\'SO\':{ \'mass\'          :0.14   }                           # http://www.ioffe.ru/SVA/NSM/Semicond/GaSb/bandstr.html\n       \n        ,\'defpot_absolute\'   :-1.32                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 0.8                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -0.8\n        ,\'defpot_uniaxial_b\' :-2.0   ,\'defpot_uniaxial_d\' :-4.7    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.76                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :13.4   gamma2 :4.7   gamma3 :6.0            # Vurgaftman1\n        \'L\' :-33.2       ,\'M\' :-5.0       ,\'N\' :-36.0  \n        ,\'kappa\' :3.18                                           # P. Lawaetz, PRB 4, 3460 (1971)             \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.812\n        \'S\' :-2.26                                              # S :1 + 2F :1 + 2 (-1.63) :-2.26 (Vurgaftman1)\n        ,\'E_P\' :27.0                                             # Vurgaftman1\n        ,\'B\' : 0                   \n        ,\'L\' :-7.856   ,\'M\' :-5.0   ,\'N\' :-10.656  \n        ,\'kappa\' :-1.044             \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :5300     ,\'exponent\' :1.9  }         # D.Martin & C.Algora - Temperature-depent GaSb material parameters for reliable thermophotovoltaic cell modelling (,\'exponent\' from InP)\n        ,\'holes\':{      \'mumax\' :1000     ,\'exponent\' :1.2  }        # D.Martin & C.Algora - Temperature-depent GaSb material parameters for reliable thermophotovoltaic cell modelling (,\'exponent\' from InP)\n\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # SIMBA\n        }\n        ,\'Auger\':{     #\'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31          # SIMBA\n                   \'c_n\' :5.0e-30       ,\'c_p\' :5.0e-30           # Stollwerck et. al. - Characterization an Simulation of GaSb Device-Related Properties\n        }\n        ,\'radiative\':{ #\'c\' :8.0e-11                                # Stollwerck et. al. - Characterization an Simulation of GaSb Device-Related Properties\n                   \'c\' :1.0e-9                                  # ?\n        }\n    }\n}\n#\n\n######### aluminium antimonide ########################################\n,\'AlSb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.1355                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :2.60e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :12.04                                      # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' :10.24                                      # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :87.69   ,\'c12\' :43.41   ,\'c44\' :40.76                # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :-0.055                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.068                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989) & Landolt-Boernstein\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.14                         # Vurgaftman1\n          ,\'bandgap\'               :2.386                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.42e-3                      # Vurgaftman1\n          ,\'bandgap_beta\'          :140                          # Vurgaftman1\n        # ,\'defpot_absolute\'       :-4.5                         # Vurgaftman1\n          ,\'defpot_absolute\'       :-8.12                        # A. Zunger: a_c :a_v + a_gap :0.73 - 8.85 :-8.12\n          ,\'g\'                     :0.84                         # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :1.64                         # Vurgaftman1\n          ,\'mass_t\'                :0.23                         # Vurgaftman1\n          ,\'bandgap\'               :2.329                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.58e-3                      # Vurgaftman1\n          ,\'bandgap_beta\'          :140                          # Vurgaftman1\n          ,\'defpot_absolute\'       :-2.91                        # A. Zunger: a_c :a_v + a_gap :0.73 - 3.64 :-2.91\n          ,\'defpot_uniaxial\'       :15.0                         # GaSb value\n       }\n       ,\'X\':{\n          \'mass_l\'                :1.357                        # Vurgaftman1\n          ,\'mass_t\'                :0.123                        # Vurgaftman1\n          ,\'bandgap\'               :1.696                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.39e-3                      # Vurgaftman1\n          ,\'bandgap_beta\'          :140                          # Vurgaftman1\n          ,\'defpot_absolute\'       :1.91                         # A. Zunger: a_c :a_v + a_gap :0.73 + 1.18 :1.91\n          ,\'defpot_uniaxial\'       :6.0                          # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.385                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.8   }                            # Landolt-Boernstein (m_p,h)\n        ,\'LH\':{ \'mass\'          :0.13  }                            # Landolt-Boernstein (m_p,l)\n        ,\'SO\':{ \'mass\'          :0.22  }                            # Vurgaftman1\n        \n        ,\'defpot_absolute\'   : 0.73                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 1.4                               # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -1.4\n        ,\'defpot_uniaxial_b\' :-1.35   ,\'defpot_uniaxial_d\' :-4.3   # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.676                              # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :5.18   gamma2 :1.19   gamma3 :1.97          # Vurgaftman1\n        \'L\' :-10.94      ,\'M\' :-3.80       ,\'N\' :-11.82     \n        ,\'kappa\' :0.31                                           # P. Lawaetz, PRB 4, 3460 (1971)          \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.386\n        \'S\' :-0.12                                              # S :1 + 2F :1 + 2 (-0.56) :-0.12 (Vurgaftman1)\n        ,\'E_P\' :18.7                                             # Vurgaftman1\n        ,\'B\' : 0                   \n        ,\'L\' :-3.779   ,\'M\' :-3.80   ,\'N\' :-4.659    \n        ,\'kappa\' :-0.884           \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :250  ,\'exponent\' :1.9 }               # R.J.Stirn & W.M.Becker - Electron Mobility in Aluminum Antimonide (,\'exponent\' from InP)\n        ,\'holes\':{      \'mumax\' :375  ,\'exponent\' :1.2 }               # D.Shaw & H.D. McKell - Tantalum doping and high resistivity in aluminium antimonide (,\'exponent\' from InP)\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # SIMBA\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # SIMBA\n        }\n        ,\'Auger\':{     \'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31           # SIMBA\n        }\n        ,\'radiative\':{ \'c\' :0                                       # ?\n        }\n    }\n}\n#\n\n######### indium antimonide ###########################################\n,\'InSb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.4794                                   # Vurgaftman1 (300 K)\n        ,\'a_expansion\' :3.48e-5                                  # Vurgaftman1\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :17.5                                       # Landolt-Boernstein epsilon(0)\n        ,\'optical_a\' :15.68                                      # Landolt-Boernstein epsilon(infinity)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :68.47   ,\'c12\' :37.35   ,\'c44\' :31.11                # Vurgaftman1\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :-0.076                                           # calculated by      S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.069                                           # experimental value S. Gironcoli et al., PRL 62(24), 2853 (1989)\n      # \'e14\' :-0.0717                                          # Landolt-Boernstein\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.0135                       # Vurgaftman1\n          ,\'bandgap\'               :0.235                        # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.32e-3                      # Vurgaftman1\n          ,\'bandgap_beta\'          :170                          # Vurgaftman1\n        # ,\'defpot_absolute\'       :-6.94                        # Vurgaftman1\n          ,\'defpot_absolute\'       :-6.04                        # Qteish / A. Zunger: a_c :a_v + a_gap :0.31 - 6.35 :-6.04\n        #  ,\'g\'                     :-50                          # R.A. Isaacson: Phys. Rev. 169, 312 (1968)\n          ,\'g\'                     :-51.6                        # J.-M. Jancu, R. Scholz, PRB 72, 193201 (2005)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.25                         # Vurgaftman1 m_DOS\n          ,\'mass_t\'                :0.25                         # Vurgaftman1 m_DOS\n          ,\'bandgap\'               :0.93                         # Vurgaftman1 (0 K)\n          ,\'bandgap_alpha\'         :0.32e-3                      # GAMMA value\n          ,\'bandgap_beta\'          :170                          # GAMMA value\n          ,\'defpot_absolute\'       :-2.20                        # Qteish / A. Zunger: a_c :a_v + a_gap :0.31 - 2.51 :-2.20\n          ,\'defpot_uniaxial\'       :15.0                         # GaSb value\n       }\n       ,\'X\':{\n          \'mass_l\'                :1.51                         # GaSb value\n          ,\'mass_t\'                :0.22                         # GaSb value\n          ,\'bandgap\'               :1.63                         # Vurgaftman1 (0 K): 0.63 eV but private communication I. Vurgaftman (0 K): 1.63 eV\n          ,\'bandgap_alpha\'         :0.32e-3                      # GAMMA value\n          ,\'bandgap_beta\'          :170                          # GAMMA value\n          ,\'defpot_absolute\'       :1.41                         # Qteish / A. Zunger: a_c :a_v + a_gap :0.31 + 1.10 :1.41\n          ,\'defpot_uniaxial\'       :4.53                         # Munoz\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :1.750                              # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.405  }                           # Landolt-Boernstein (m_p,h)\n        ,\'LH\':{ \'mass\'          :0.0162 }                           # Landolt-Boernstein (m_p,l)\n        ,\'SO\':{ \'mass\'          :0.11   }                           # Vurgaftman1\n\n      # ,\'HH\':{ \'mass\'          :0.43   }                           # http://www.ioffe.ru/SVA/NSM/Semicond/InSb/bandstr.html\n      # ,\'LH\':{ \'mass\'          :0.015  }                           # http://www.ioffe.ru/SVA/NSM/Semicond/InSb/bandstr.html\n      # ,\'SO\':{ \'mass\'          :0.19   }                           # http://www.ioffe.ru/SVA/NSM/Semicond/InSb/bandstr.html\n        \n        ,\'defpot_absolute\'   : 0.31                              # Qteish value, no Zunger value available: a_v\n      # ,\'defpot_absolute\'   : 0.36                              # Vurgaftman1 - Note that Vurgaftman1 has different sign convention. => -0.36\n        ,\'defpot_uniaxial_b\' :-2.0   ,\'defpot_uniaxial_d\' :-4.7    # Vurgaftman1\n       \n        ,\'delta_SO\'          :0.81                               # Vurgaftman1\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :34.8   gamma2 :15.5   gamma3 :16.5          # Vurgaftman1\n        \'L\' :-97.8       ,\'M\' :-4.8        ,\'N\' :-99.0   \n        #,\'kappa\' :14.76                                          # P. Lawaetz, PRB 4, 3460 (1971) \n        ,\'kappa\' :15.6                                           # Landolt-B\xc3\xb6rnstein           \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.235\n        \'S\' :  0.54                                             # S :1 + 2F :1 + 2 (-0.23) :-0.54 (Vurgaftman1)\n        ,\'E_P\' :23.3                                             # Vurgaftman1\n        ,\'B\' :  0                   \n        ,\'L\' :-51.661   ,\'M\' :-4.8   ,\'N\' :-52.861   \n        ,\'kappa\' :7.91            \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :70400 ,\'exponent\' :1.9 }             # D.L.Rode - Electron Transport in InSb, InAs and InP (,\'exponent\' from InP)\n        ,\'holes\':{      \'mumax\' :750   ,\'exponent\' :1.2 }             # R.K.Willardson & A.C.Beer - Semiconductors and Semimetals (,\'exponent\' from InP)\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # GaSb value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # GaSb value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :1.0e-31       ,\'c_p\' :1.0e-31           # GaSb value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.0e-9                                  # GaSb value !!!\n        }\n    }\n}\n#\n\n######### gallium nitride (zincblende) ################################\n,\'GaN_zb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :4.50                                     # Vurgaftman1/Vurgaftman2 (300 K)\n        ,\'a_expansion\' :0                                        # ?\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :9.7                                        # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/optic.html  Bougrov et al. (2001)  (300 K)\n        ,\'optical_a\' :5.3                                        # high frequency (300 K)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :293   ,\'c12\' :159   ,\'c44\' :155                      # Vurgaftman1/Vurgaftman2\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.56                                             # taken from M. Shur http://nina.ecse.rpi.edu/shur/Tutorial/GaNtutorial1/sld038.htm\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.15                         # Vurgaftman1/Vurgaftman2\n          ,\'bandgap\'               :3.299                        # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n        # ,\'defpot_absolute\'       :-6.71                        # Vurgaftman2\n          ,\'defpot_absolute\'       :-6.68                        # A. Zunger: a_c :a_v + a_gap :0.69 - 7.37 :-6.68\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.2                          # ?\n          ,\'mass_t\'                :0.2                          # ?\n          ,\'bandgap\'               :5.59                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n          ,\'defpot_absolute\'       :-7.46                        # A. Zunger: a_c :a_v + a_gap :0.69 - 8.15 :-7.46\n          ,\'defpot_uniaxial\'       :14.26                        # GaAs value\n       }\n       ,\'X\':{\n          \'mass_l\'                :0.5                          # Vurgaftman1/Vurgaftman2\n          ,\'mass_t\'                :0.3                          # Vurgaftman1/Vurgaftman2\n          ,\'bandgap\'               :4.52                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n          ,\'defpot_absolute\'       :-0.52                        # A. Zunger: a_c :a_v + a_gap :0.69 - 1.21 :-0.52\n          ,\'defpot_uniaxial\'       :6.5                          # GaAs value\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.726                             # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :1.3   }                            # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html Leszczynski et al. (1996), Fan et al. (1996)\n        ,\'LH\':{ \'mass\'          :0.19  }                            # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html Leszczynski et al. (1996), Fan et al. (1996)\n        ,\'SO\':{ \'mass\'          :0.29  }                            # Vurgaftman1/Vurgaftman2\n        \n        ,\'defpot_absolute\'   : 0.69                              # A. Zunger/Vurgaftman2: a_v  -  Note that Vurgaftman1/Vurgaftman2 has different sign convention. => -0.69\n        ,\'defpot_uniaxial_b\' :-2.0   ,\'defpot_uniaxial_d\' :-3.7    # Vurgaftman2\n       \n        ,\'delta_SO\'          :0.017                              # Vurgaftman1/Vurgaftman2\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :2.70   gamma2 :0.76   gamma3 :1.11          # Vurgaftman2\n        \'L\' :-6.74       ,\'M\' :-2.18       ,\'N\' :-6.66              \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.299\n        \'S\' :-0.90                                              # S :1 + 2F :1 + 2 (-0.95) :-0.90 (Vurgaftman2)\n        ,\'E_P\' :25.0                                             # Vurgaftman1/Vurgaftman2\n        ,\'B\' : 0                   \n        ,\'L\' : 0.825   ,\'M\' :-2.18   ,\'N\' :0.905               \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :0                                       # ?\n        }\n    }\n}\n#\n\n######### aluminum nitride (zincblende) ###############################\n,\'AlN_zb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :4.38                                     # Vurgaftman1/Vurgaftman2 (300 K)\n        ,\'a_expansion\' :0                                        # ?\n    }\n    \n     ,\'dielectric_consts\':{\n        \'static_a\'  :9.14                                       # ? Landolt-Boernstein epsilon(0) wurtzite, Collins et al. (1967)\n        ,\'optical_a\' :4.84                                       # ? Landolt-Boernstein epsilon(infinity) wurtzite, Collins et al. (1967)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :304   ,\'c12\' :160   ,\'c44\' :193                      # Vurgaftman1/Vurgaftman2\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.92                                             # ? taken from M. Shur http://nina.ecse.rpi.edu/shur/Tutorial/GaNtutorial1/sld038.htm (wurtzite)\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.25                         # Vurgaftman1/Vurgaftman2\n          ,\'bandgap\'               :5.4                          # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n        # ,\'defpot_absolute\'       :-4.5                         # Vurgaftman2\n          ,\'defpot_absolute\'       :-5.22                        # A. Zunger: a_c :a_v + a_gap :4.94 - 10.16 :-5.22\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.2                          # ?\n          ,\'mass_t\'                :0.2                          # ?\n          ,\'bandgap\'               :9.3                          # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n          ,\'defpot_absolute\'       :-4.95                        # A. Zunger: a_c :a_v + a_gap :4.94 - 9.89 :-4.95\n          ,\'defpot_uniaxial\'       :14.26                        # GaAs value\n       }\n       ,\'X\':{\n          \'mass_l\'                :0.53                         # Vurgaftman1/Vurgaftman2\n          ,\'mass_t\'                :0.31                         # Vurgaftman1/Vurgaftman2\n          ,\'bandgap\'               :4.9                          # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.593e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :600                          # Vurgaftman2\n          ,\'defpot_absolute\'       :3.81                         # A. Zunger: a_c :a_v + a_gap :4.94 - 1.13 :-3.81\n          ,\'defpot_uniaxial\'       :6.5                          # GaAs value\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-1.526                             # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.3   }                            # ?\n        ,\'LH\':{ \'mass\'          :0.3   }                            # ?\n        ,\'SO\':{ \'mass\'          :0.47  }                            # Vurgaftman1/Vurgaftman2\n        \n        ,\'defpot_absolute\'   : 4.94                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 4.9                               # Vurgaftman2 - Note that Vurgaftman1/Vurgaftman2 has different sign convention. => -4.9\n        ,\'defpot_uniaxial_b\' :-1.7   ,\'defpot_uniaxial_d\' :-5.5    # Vurgaftman2\n       \n        ,\'delta_SO\'          :0.019                              # Vurgaftman1/Vurgaftman2\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :1.92   gamma2 :0.47   gamma3 :0.85          # Vurgaftman1/Vurgaftman2\n        \'L\' :-4.80       ,\'M\' :-1.98       ,\'N\' :-5.10              \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :5.4 (Vurgaftman2)\n        \'S\' :-1.02                                              # S :1 + 2F :1 + 2 (-1.01) :-1.02 (Vurgaftman2)\n        ,\'E_P\' :27.1                                             # Vurgaftman1/Vurgaftman2\n        ,\'B\' : 0                   \n        ,\'L\' : 0.213   ,\'M\' :-1.98   ,\'N\' :-0.087               \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :0                                       # ?\n        }\n    }\n}\n#\n\n######### indium nitride (zincblende) #################################\n,\'InN_zb\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :4.98                                     # Vurgaftman1/Vurgaftman2 (300 K)\n        ,\'a_expansion\' :0                                        # ?\n    }\n    \n     ,\'dielectric_consts\':{\n        \'static_a\'  :15.3                                       # ? wurtzite Zubrilov (2001)\n        ,\'optical_a\' : 9.3                                       # ? Landolt-Boernstein epsilon(infinity) wurtzite\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :187   ,\'c12\' :125   ,\'c44\' :86                       # Vurgaftman1/Vurgaftman2\n    }                    \n                                             \n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.37                                             # taken from M. Shur http://nina.ecse.rpi.edu/shur/Tutorial/GaNtutorial1/sld038.htm\n    }                                                \n   \n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.07                         # Vurgaftman2\n          ,\'bandgap\'               :0.78                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.245e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :624                          # Vurgaftman2\n        # ,\'defpot_absolute\'       :-2.65                        # Vurgaftman2\n          ,\'defpot_absolute\'       :-2.93                        # A. Zunger: a_c :a_v + a_gap :0.73 - 3.66 :-2.93\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.2                          # ?\n          ,\'mass_t\'                :0.2                          # ?\n          ,\'bandgap\'               :5.82                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.245e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :624                          # Vurgaftman2\n          ,\'defpot_absolute\'       :-4.50                        # A. Zunger: a_c :a_v + a_gap :0.73 - 5.23 :-4.50\n          ,\'defpot_uniaxial\'       :14.26                        # GaAs value\n       }\n       ,\'X\':{\n          \'mass_l\'                :0.48                         # Vurgaftman1/Vurgaftman2\n          ,\'mass_t\'                :0.27                         # Vurgaftman1/Vurgaftman2\n          ,\'bandgap\'               :2.51                          # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.245e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :624                          # Vurgaftman2\n          ,\'defpot_absolute\'       :-0.62                        # A. Zunger: a_c :a_v + a_gap :0.73 - 1.35 :-0.62\n          ,\'defpot_uniaxial\'       :6.5                          # GaAs value\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.462                             # A. Zunger\n        \n        ,\'HH\':{ \'mass\'          :0.2   }                            # ?\n        ,\'LH\':{ \'mass\'          :0.2   }                            # ?\n        ,\'SO\':{ \'mass\'          :0.3   }                            # Vurgaftman1/Vurgaftman2\n        \n        ,\'defpot_absolute\'   : 0.73                              # A. Zunger: a_v\n      # ,\'defpot_absolute\'   : 0.7                               # Vurgaftman2 - Note that Vurgaftman2 has different sign convention. => -0.7\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-9.3    # Vurgaftman1/Vurgaftman2\n       \n        ,\'delta_SO\'          :0.005                              # Vurgaftman2\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :3.72   gamma2 :1.26   gamma3 :1.63          # Vurgaftman1/Vurgaftman2\n        \'L\' :-9.76       ,\'M\' :-2.20       ,\'N\' :-9.78              \n    }                    \n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.78 (Vurgaftman2)\n        \'S\' :-7.72                                              # S :1 + 2F :1 + 2 (-4.36) :-7.72 (Vurgaftman2)\n        ,\'E_P\' :17.2                                             # Vurgaftman2\n        ,\'B\' : 0                   \n        ,\'L\' : 12.24   ,\'M\' :-2.20   ,\'N\' :12.224               \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :0                                       # ?\n        }\n    }\n}\n#\n\n######### zinc selenide ############################################\n,\'ZnSe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.6674                                   # [Angstrom]    300 K, H. Karzel et al., PRB 53, 11425 (1996)\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  LB\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.6                                       # S. Adachi et al., PRB 43, 9569 (1995)\n        ,\'optical_a\' : 5.73                                      # S. Adachi et al., PRB 43, 9569 (1995), R.T. Senger et al., phys. stat. sol. (b) 241, 1896 (2004)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :82.6   ,\'c12\' :49.8   ,\'c44\' :40.0                   # C. Van de Walle, PRB 39, 1871 (1989)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.049                                            # LB\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.145                        # Isshiki, Journal of Crystal Growth 86, 615 (1988)\n#         ,\'bandgap\'               :2.71                         # 300 K, J. Piprek\n          ,\'bandgap\'               :2.825                        #   0 K, J. Piprek\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n#         ,\'defpot_absolute\'       :-6.96                        # A. Zunger: a_c :a_v + a_gap :... + ... :-6.96, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_absolute\'       :-5.93                        # S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.89                        # A. Zunger: a_c :a_v + a_gap :... + ... :-4.89, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.61                        # A. Zunger: a_c :a_v + a_gap :... + ... :-0.61, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.39                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :1.04  ,\'g\' :0 }                      # Isshiki, Journal of Crystal Growth 86, 615 (1988)\n        ,\'LH\':{ \'mass\'          :0.16  ,\'g\' :0 }                      # from Luttinger parameters in Venghaus 1979\n        ,\'SO\':{ \'mass\'          :0.30  }                            # P. Lawaetz, PRB 4, 3460 (1971)\n\n        ,\'defpot_absolute\'   :-1.97                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-4.3    # b (van de Walle and Cardona), d (Cardona) [eV]\n       \n        ,\'delta_SO\'          :0.45                               # Chelikowski\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.3    gamma2 :1.14   gamma3 :1.84          # J. Piprek\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # Venghaus 1979\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # calculated from J. Piprek parameters  gamma1 :4.3, gamma2 :1.14, gamma3 :1.84\n        ,\'kappa\' :0.64                                           # P. Lawaetz, PRB 4, 3460 (1971)\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.825\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :24.2                                             # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### zinc telluride ############################################\n,\'ZnTe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.07                                     # [Angstrom]    300 K (?), T. Magalingham et al., Cryst. Res. Technol. 37, 329 (2002)\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  ZnSe\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 9.67                                      # D. L. Rode, PRB 2, 4036 (1970)\n        ,\'optical_a\' : 7.23                                      # D. L. Rode, PRB 2, 4036 (1970)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :72.2   ,\'c12\' :40.9   ,\'c44\' :30.8                   # M. Yamada et al., J. Phys. D: Appl. Phys. 10, 1309 (1977)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # ???\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.21                         # M. L. Cohen et al., PR 141, 789 (1966)\n          ,\'bandgap\'               :2.34                         #   0 K (?), D. L. Rode, PRB 2, 4036 (1970)\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-7.88                        # A. Zunger: a_c :a_v + a_gap :... + ... :-7.88, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # R. Brazis et al., phys. stat. sol. (b) 244 1662 (2007)\n          ,\'mass_t\'                :0.5                          # R. Brazis et al., phys. stat. sol. (b) 244 1662 (2007)\n          ,\'bandgap\'               :3.6                          # calculated from Gamma-L valley separation energy (R. Brazis)\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.68                        # A. Zunger: a_c :a_v + a_gap :... + ... :-4.68, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.56                        # A. Zunger: a_c :a_v + a_gap :... + ... :-0.56, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.96                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :0.2   ,\'g\' :0 }                      # Singh, p. 840 (1993)\n        ,\'LH\':{ \'mass\'          :0.16  ,\'g\' :0 }                      # ZnSe\n        ,\'SO\':{ \'mass\'          :0.33  }                            # P. Lawaetz, PRB 4, 3460 (1971)\n\n        ,\'defpot_absolute\'   :-2.28                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.26  ,\'defpot_uniaxial_d\' :-4.6    # b (van de Walle), d (experiment) [eV]\n       \n        ,\'delta_SO\'          :0.91                               # Qteish/Needs\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.00   gamma2 :1.15   gamma3 :1.29          # R. L. Hollis, PRB 15, 932 (1977) (calculations)\n        \'L\' :-9.60       ,\'M\' :-2.70       ,\'N\' :-7.74              # calculated from Luttinger parameters of R. L. Hollis, PRB 15, 932 (1977)\n        ,\'kappa\' :0.42                                           # P. Lawaetz, PRB 4, 3460 (1971)\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.34\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :19.1                                             # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-2.70       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### magnesium selenide ############################################\n,\'MgSe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.91                                     # [Angstrom]    300 K, B. Jobst et al., APL 69, 97 (1996)\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  ??? ZnSe\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.6                                       # ??? ZnSe\n        ,\'optical_a\' : 4.86                                      # S. Saib et al., Eur. Phys. J. B 73, 185 (2010)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :61.8   ,\'c12\' :45.1   ,\'c44\' :22.8                   # S. Saib et al., Eur. Phys. J. B 73, 185 (2010)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.68955                                          # S. Saib et al., Eur. Phys. J. B 73, 185 (2010)\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.145                        # ??? ZnSe\n          ,\'bandgap\'               :4.0                          # 300 K, B. Jobst et al., APL 69, 97 (1996)\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-5.93                        # ??? ZnSe S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.89                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.61                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0          # should be adjusted!!!  # ??? A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :1.04  ,\'g\' :0 }                      # ??? ZnSe\n        ,\'LH\':{ \'mass\'          :0.16  ,\'g\' :0 }                      # ??? ZnSe\n        ,\'SO\':{ \'mass\'          :0.30  }                            # ??? ZnSe\n\n        ,\'defpot_absolute\'   :-1.97                              # ??? ZnSe\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-4.3    # ??? ZnSe\n       \n        ,\'delta_SO\'          :0.45                               # ??? ZnSe\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # ??? ZnSe\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # ??? ZnSe\n        ,\'kappa\' :0.64                                           # ??? ZnSe\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :4.0\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :24.2                                             # ??? ZnSe\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### cadmium selenide ############################################\n,\'CdSe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.052                                    # [Angstrom]    300 K, Wei and Zunger\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  ??? ZnSe\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 9.7                                       # LB\n        ,\'optical_a\' : 5.8                                       # LB\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :74.6   ,\'c12\' :46.1   ,\'c44\' :13.0                   # LB\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.049                                            # ZnSe value ?\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.12                         # Furdyna PRB 49\n#         ,\'bandgap\'               :1.766                        # 300 K, Furdyna PRB 49 (theory)\n          ,\'bandgap\'               :1.846                        #   0 K, J. Piprek\n          ,\'bandgap_alpha\'         :6.96e-4                      # Furdyna PRB 50\n          ,\'bandgap_beta\'          :281                          # Furdyna PRB 50\n          ,\'defpot_absolute\'       :-3.77                        # A. Zunger: a_c :a_v + a_gap :... + ... :-3.77, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3.7                          # Furdyna PRB 50\n          ,\'bandgap_alpha\'         :6.96e-4                      # Furdyna PRB 50\n          ,\'bandgap_beta\'          :281                          # Furdyna PRB 50\n          ,\'defpot_absolute\'       :-4.89                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :-4.89, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :4.8                          # Furdyna PRB 50\n          ,\'bandgap_alpha\'         :6.96e-4                      # Furdyna PRB 50\n          ,\'bandgap_beta\'          :281                          # Furdyna PRB 50\n          ,\'defpot_absolute\'       :-0.61                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :-0.61, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.7162                             # 30 % VBO to ZnSe, Egap :1.766 eV, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :0.9   ,\'g\' :0 }                      # Furdyna PRB 49\n        ,\'LH\':{ \'mass\'          :0.18  ,\'g\' :0 }                      # Furdyna PRB 49\n        ,\'SO\':{ \'mass\'          :0.34  }                            # Furdyna PRB 49\n\n        ,\'defpot_absolute\'   :-1.81                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-4.3    # ??? ZnSe\n       \n        ,\'delta_SO\'          :0.42                               # Furdyna PRB 50\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # ??? ZnSe\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # ??? ZnSe\n        ,\'kappa\' :0                                              # ???\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :1.776\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :24.2                                             # ???\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### beryllium selenide ############################################\n,\'BeSe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.139                                    # [Angstrom]    300 K (?) epitaxy dp\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  ??? ZnSe\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.6                                       # ??? ZnSe\n        ,\'optical_a\' : 5.73                                      # ??? ZnSe\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :82.6   ,\'c12\' :49.8   ,\'c44\' :40.0                   # ??? ZnSe\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.049                                            # ??? ZnSe\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.145                        # ???\n#         ,\'bandgap\'               :...                          # 300 K\n          ,\'bandgap\'               :5.15                         #   0 K\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-5.93                        # ??? ZnSe\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :6                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.89                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :-4.89, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :6                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.61                        # ??? ZnSe A. Zunger: a_c :a_v + a_gap :... + ... :-0.61, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.45                              # average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :1.04  ,\'g\' :0 }                      # ??? ZnSe\n        ,\'LH\':{ \'mass\'          :0.16  ,\'g\' :0 }                      # ??? ZnSe\n        ,\'SO\':{ \'mass\'          :0.30  }                            # ??? ZnSe\n\n        ,\'defpot_absolute\'   :-1.97                              # ??? ZnSe\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-4.3    # ??? ZnSe\n       \n        ,\'delta_SO\'          :0.45                               # ??? ZnSe\n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # ??? ZnSe\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # ??? ZnSe\n        ,\'kappa\' :0.64                                           # ??? ZnSe\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :5.15\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :24.2                                             # ??? ZnSe\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### cadmium telluride ############################################\n,\'CdTe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.486                                    # [Angstrom] 300 K - Book: J. Piprek\n        ,\'a_expansion\' :3.11e-5                                  # [Angstrom/K]       Book: J. Piprek - [see also R.D. Greenough et al., J. Phys. D: Appl. Phys. 6, 587 (1973) for ,\'a\' discussion of the temperature dependence)\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :10.6                                       #                  V. Borsari, C. Jacoboni, phys. stat. sol. (b) 54, 649 (1972)\n        ,\'optical_a\' : 7.13                                      # high frequency - V. Borsari, C. Jacoboni, phys. stat. sol. (b) 54, 649 (1972)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :53.8   ,\'c12\' :37.4   ,\'c44\' :20.18                  # [GPa] R.D. Greenough et al., J. Phys. D: Appl. Phys. 6, 587 (1973) at 298 K\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # ???\n    }                                                \n\n# E_gap :1.528 eV (300 K)\n# E_gap :1.606 eV (4.2 K)\n# E_gap :1.43  eV (Gamma, direct semiconductor, T :300 K) J. Piprek\n# E_gap :1.606 eV (Gamma, direct semiconductor, T :  0 K) J. Piprek\n# E_gap :1.425 eV (Gamma, direct semiconductor, T :300 K) J. Reno et al., APL 49, 106 (1986)\n# E_gap :1.550 eV (Gamma, direct semiconductor, T : 77 K)\n# E_gap :1.600 eV (Gamma, direct semiconductor, T :  4 K) J. Reno et al., APL 49, 106 (1986)\n# E_gap :1.54  eV (Gamma, direct semiconductor, T :?   K) D.L. Rode, PRB 2, 4036 (1970)\n# E_gap :3.04  eV (L                          , T :?   K) calculated from Gamma-L valley separation energy (R. Brazis)\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n#         \'mass\'                  :0.0963                       # V. Borsari, C. Jacoboni, phys. stat. sol. (b) 54, 649 (1972)\n          \'mass\'                  :0.08992                      # calculated from Novik parameters\n          ,\'bandgap\'               :1.606                        # 4.2 K\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-5.84                        # A. Zunger: a_c :a_v + a_gap :-2.14 + ... :-5.84\n          ,\'g\'                     :-0.30                        # 280 K, M. Oestreich et al., PRB 53, 7911 (1996)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # V. Borsari, C. Jacoboni, phys. stat. sol. (b) 54, 649 (1972)\n          ,\'mass_t\'                :0.5                          # V. Borsari, C. Jacoboni, phys. stat. sol. (b) 54, 649 (1972)\n          ,\'bandgap\'               :3.04                         # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.02                        # A. Zunger: a_c :a_v + a_gap :-2.14 + ... :-4.02\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3.5                          # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.70                        # A. Zunger: a_c :a_v + a_gap :-2.14 + ... :-0.70\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n      # \'bandoffset\'        :0.86                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n      # \'bandoffset\'        :0.86 - 1.430328571                 # VBO HgTe :570 meV\n      # \'bandoffset\'        :      -0.570328571                 # VBO HgTe :570 meV\n      #  \'bandoffset\'       :-0.570 + 0.91/3 - 1.08/3\n      #                     -0.570 + 0.056666666               # VBO HgTe :570 meV\n        \'bandoffset\'        :-0.513333333                       # VBO HgTe :570 meV\n        \n        ,\'HH\':{ \'mass\'          :0.72  ,\'g\' :0 }                      # J. Piprek, p. 21   ,\'g\' :???\n        ,\'LH\':{ \'mass\'          :0.13  ,\'g\' :0 }                      # J. Piprek, p. 21   ,\'g\' :???\n        ,\'SO\':{ \'mass\'          :0.28  }                            # [LawaetzPRB1971]\n\n        ,\'defpot_absolute\'   :-2.14                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.1   ,\'defpot_uniaxial_d\' :-2.8    # b (van de Walle), d (experiment) [eV]\n       \n      # ,\'delta_SO\'          :0.93                               # J. Piprek\n        ,\'delta_SO\'          :0.91                               # Novik\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :5.3     gamma2 :1.7     gamma3 :2.0         # J. Piprek\n      # gamma1 :5.37203 gamma2 :1.67102 gamma3 :1.98102     # calculated from Novik parameters\n        \'L\' :-13.0561    ,\'M\' : -3.03      ,\'N\' :-11.8861           # calculated from Novik parameters\n      # ,\'kappa\' :1.27                                           # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'kappa\' :0.641017                                       # calculated from Novik parameters\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :1.519\n        \'S\' :0.82                                               # S :1 + 2F   Novik: F :-0.09\n      # ,\'E_P\' :18.0                                             # Ref. E_P: J. Reno et al., APL 49, 106 (1986)\n        ,\'E_P\' :18.8                                             # Novik\n        ,\'B\' : 0                     \n      # gamma1 :1.47   gamma2 :-0.28  gamma3 :0.03          # Novik\n        ,\'L\' :-1.35       ,\'M\' : -3.03      ,\'N\' :-0.18              # calculated from Novik parameters\n      # ,\'kappa\' :1.27                                           # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'kappa\' :-1.31                                          # Novik\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n\n}\n#\n\n######### mercury telluride ############################################\n,\'HgTe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.486                                    # [Angstrom]     CdTe value\n        ,\'a_expansion\' :3.11e-5                                  # [Angstrom/K]   CdTe value\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :10.6                                       # CdTe value\n        ,\'optical_a\' : 7.13                                      # CdTe value\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :53.8   ,\'c12\' :37.4   ,\'c44\' :20.18                  # CdTe value\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # ???\n    }                                                \n\n# E_gap :-0.122 eV (Gamma, semimetal, T :300 K) J. Reno et al., APL 49, 106 (1986)\n# E_gap :-0.261 eV (Gamma, semimetal, T : 77 K)\n# E_gap :-0.302 eV (Gamma, semimetal, T :  4 K) J. Reno et al., APL 49, 106 (1986)\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n#         \'mass\'                  :-0.031                       # [LawaetzPRB1971]\n          \'mass\'                  :-0.03096                     # calculated from Novik parameters\n#         ,\'bandgap\'               :-0.302                       # 4 K   J. Reno et al., APL 49, 106 (1986)\n          ,\'bandgap\'               :-0.303                       # 4 K   Novik\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-6.64                        # A. Zunger: a_c :a_v + a_gap :-3.45 + ... :-6.64\n          ,\'g\'                     :-0.30                        # 280 K, M. Oestreich et al., PRB 53, 7911 (1996)\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.19                        # A. Zunger: a_c :a_v + a_gap :-3.45 + ... :-4.19\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3.5                          # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-1.48                        # A. Zunger: a_c :a_v + a_gap :-3.45 + ... :-1.48\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n      # \'bandoffset\'        :1.18                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \'bandoffset\'        :0.0                                #\n        \n        ,\'HH\':{ \'mass\'          :1.12  ,\'g\' :0 }                      # [LawaetzPRB1971]\n        ,\'LH\':{ \'mass\'          :-0.026 ,\'g\' :0 }                      # [LawaetzPRB1971]\n        ,\'SO\':{ \'mass\'          :0.102 }                            # [LawaetzPRB1971]\n\n        ,\'defpot_absolute\'   :-3.45                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.15  ,\'defpot_uniaxial_d\' :-2.8    # b (van de Walle), d (CdTe) [eV]\n       \n      # ,\'delta_SO\'          :1.05                               # Qteish/Needs\n        ,\'delta_SO\'          :1.08                               # Novik\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :-15.5  gamma2 :-8.9   gamma3 :-8.9          #   4 K -  J. Reno et al., APL 49, 106 (1986): gamma2 :gamma3\n      # gamma1 :-44.8  gamma2 :-23.55 gamma3 :-23.55        # 300 K -  J. Reno et al., APL 49, 106 (1986): gamma2 :gamma3\n      # gamma1 =-16.5821 gamma2 =-9.84103 gamma3 =-9.04103     # calculated from Novik parameters\n      # \'L\' :50.1        ,\'M\' :-3.3        ,\'N\' :53.4               #   4 K -  J. Reno et al., APL 49, 106 (1986): gamma2 :gamma3\n        \'L\' :54.9462\t,\'M\' :-4.1        ,\'N\' :54.2462            # calculated from Novik parameters\n#       ,\'kappa\' :-10.85                                         # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'kappa\' :-10.741                                        # calculated from Novik parameters\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :1.519\n        \'S\' :1.0                                                # S :1 + 2F   Novik: F :0\n      # ,\'E_P\' :18.0                                             # Ref. E_P: J. Reno et al., APL 49, 106 (1986)\n        ,\'E_P\' :18.8                                             # Novik\n        ,\'B\' : 0                     \n      # gamma1 :4.1    gamma2 :0.5    gamma3 :1.3           # Novik\n        ,\'L\' :-7.1        ,\'M\' :-4.1        ,\'N\' :-7.8               # calculated from Novik parameters\n        ,\'kappa\' :-0.4                                           # Novik\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n\n}\n#\n\n######### magnesium telluride ############################################\n# MgTe has normally wurtzite crystal structure! ==> This set of parameters is for Cd(1-x)Mg(x)Te alloys.\n,\'MgTe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.435                                    # [Angstrom] 300 K\n        ,\'a_expansion\' :3.11e-5                                  # ??? CdTe [Angstrom/K]\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :10.6                                       # ??? CdTe\n        ,\'optical_a\' : 7.13                                      # ??? CdTe\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :53.8   ,\'c12\' :37.4   ,\'c44\' :20.18                  # [GPa] CdTe\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # ??? CdTe\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.08992                      # ??? CdTe\n#         ,\'bandgap\'               :3.49                         # 300 K\n          ,\'bandgap\'               :3.2                          # 4.2 K\n          ,\'bandgap_alpha\'         :0                            # ??? CdTe\n          ,\'bandgap_beta\'          :0                            # ??? CdTe\n          ,\'defpot_absolute\'       :-5.84                        # ??? CdTe A. Zunger: a_c :a_v + a_gap :...\n          ,\'g\'                     :-0.30                        # ??? CdTe\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          #\n          ,\'mass_t\'                :0.5                          #\n          ,\'bandgap\'               :3.04                         # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.02                        # ??? A. Zunger: a_c :a_v + a_gap :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3.5                          # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.70                        #  ??? A. Zunger: a_c :a_v + a_gap :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.513333333                       # ???\n        \n        ,\'HH\':{ \'mass\'          :0.72  ,\'g\' :0 }                      # ???\n        ,\'LH\':{ \'mass\'          :0.13  ,\'g\' :0 }                      # ???\n        ,\'SO\':{ \'mass\'          :0.28  }                            # ???\n\n        ,\'defpot_absolute\'   :-2.14                              # ???\n        ,\'defpot_uniaxial_b\' :-1.1   ,\'defpot_uniaxial_d\' :-2.8    # ???\n       \n        ,\'delta_SO\'          :0.91                               # ???\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :5.3    gamma2 :1.7    gamma3 :2.0           # ???\n        \'L\' :-13.05      ,\'M\' : -3.03      ,\'N\' :-11.88             # ???\n        ,\'kappa\' :1.27                                           # ???\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.49\n        \'S\' :0.82                                               # ??? S :1 + 2F\n        ,\'E_P\' :18.8                                             # ???\n        ,\'B\' : 0                     \n      # gamma1 :1.47   gamma2 :-0.28  gamma3 :0.03          # ???\n        ,\'L\' :-13.05      ,\'M\' : -3.03      ,\'N\' :-11.88             # ???\n        ,\'kappa\' :-1.31                                          # ???\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n\n}\n#\n\n######### manganese selenide ############################################\n# So far, everything is taken from ZnSe. Please add appropriate values and add proper references!!!\n,\'MnSe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.6674                                   # [Angstrom]    300 K, H. Karzel et al., PRB 53, 11425 (1996)\n        ,\'a_expansion\' :7.7e-5                                   # [Angstrom/K]  LB\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.6                                       # S. Adachi et al., PRB 43, 9569 (1995)\n        ,\'optical_a\' : 5.73                                      # S. Adachi et al., PRB 43, 9569 (1995), R.T. Senger et al., phys. stat. sol. (b) 241, 1896 (2004)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :82.6   ,\'c12\' :49.8   ,\'c44\' :40.0                   # C. Van de Walle, PRB 39, 1871 (1989)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.049                                            # LB\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.145                        # Isshiki, Journal of Crystal Growth 86, 615 (1988)\n#         ,\'bandgap\'               :2.71                         # 300 K, J. Piprek\n          ,\'bandgap\'               :2.825                        #   0 K, J. Piprek\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n#         ,\'defpot_absolute\'       :-6.96                        # A. Zunger: a_c :a_v + a_gap :... + ... :-6.96, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_absolute\'       :-5.93                        # S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.89                        # A. Zunger: a_c :a_v + a_gap :... + ... :-4.89, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.61                        # A. Zunger: a_c :a_v + a_gap :... + ... :-0.61, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.39                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :1.04  ,\'g\' :0 }                      # Isshiki, Journal of Crystal Growth 86, 615 (1988)\n        ,\'LH\':{ \'mass\'          :0.16  ,\'g\' :0 }                      # from Luttinger parameters in Venghaus 1979\n        ,\'SO\':{ \'mass\'          :0.30  }                            # P. Lawaetz, PRB 4, 3460 (1971)\n\n        ,\'defpot_absolute\'   :-1.97                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.2   ,\'defpot_uniaxial_d\' :-4.3    # b (van de Walle and Cardona), d (Cardona) [eV]\n       \n        ,\'delta_SO\'          :0.45                               # Chelikowski\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.3    gamma2 :1.14   gamma3 :1.84          # J. Piprek\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # Venghaus 1979\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # calculated from J. Piprek parameters  gamma1 :4.3, gamma2 :1.14, gamma3 :1.84\n        ,\'kappa\' :0.64                                           # P. Lawaetz, PRB 4, 3460 (1971)\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.825\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :24.2                                             # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### manganese telluride ############################################\n# MnTe has NiAs crystal structure! ==> This set of parameters is for Cd(1-x)Mn(x)Te alloys.\n,\'MnTe\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :6.33                                     # [Angstrom] 300 K (?), MnTe zincblende, J. Kossut, Acta Phys. Pol. A 100, 111 (2001)\n        ,\'a_expansion\' :3.11e-5                                  # ??? CdTe [Angstrom/K]\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  :10.6                                       # ??? CdTe\n        ,\'optical_a\' : 7.13                                      # ??? CdTe\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :53.8   ,\'c12\' :37.4   ,\'c44\' :20.18                  # [GPa] CdTe\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0                                                # ??? CdTe\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.08992                      # ??? CdTe\n#         ,\'bandgap\'               :2.9                          # 300 K\n          ,\'bandgap\'               :3.2                          # 4.2 K\n          ,\'bandgap_alpha\'         :0                            # ??? CdTe\n          ,\'bandgap_beta\'          :0                            # ??? CdTe\n          ,\'defpot_absolute\'       :-5.84                        # ??? CdTe A. Zunger: a_c :a_v + a_gap :...\n          ,\'g\'                     :-0.30                        # ??? CdTe\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          #\n          ,\'mass_t\'                :0.5                          #\n          ,\'bandgap\'               :3.04                         # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.02                        # ??? A. Zunger: a_c :a_v + a_gap :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :3.5                          # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.70                        #  ??? A. Zunger: a_c :a_v + a_gap :...\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.513333333                       # ???\n        \n        ,\'HH\':{ \'mass\'          :0.72  ,\'g\' :0 }                      # ???\n        ,\'LH\':{ \'mass\'          :0.13  ,\'g\' :0 }                      # ???\n        ,\'SO\':{ \'mass\'          :0.28  }                            # ???\n\n        ,\'defpot_absolute\'   :-2.14                              # ???\n        ,\'defpot_uniaxial_b\' :-1.1   ,\'defpot_uniaxial_d\' :-2.8    # ???\n       \n        ,\'delta_SO\'          :0.91                               # ???\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :5.3    gamma2 :1.7    gamma3 :2.0           # ???\n        \'L\' :-13.05      ,\'M\' : -3.03      ,\'N\' :-11.88             # ???\n        ,\'kappa\' :1.27                                           # ???\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.49\n        \'S\' :0.82                                               # ??? S :1 + 2F\n        ,\'E_P\' :18.8                                             # ???\n        ,\'B\' : 0                     \n      # gamma1 :1.47   gamma2 :-0.28  gamma3 :0.03          # ???\n        ,\'L\' :-13.05      ,\'M\' : -3.03      ,\'N\' :-11.88             # ???\n        ,\'kappa\' :-1.31                                          # ???\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n\n}\n#\n\n######### zinc sulfide ############################################\n,\'ZnS\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.4102                                   # [Angstrom]    300 K, J. Piprek\n        ,\'a_expansion\' :3.68e-5                                  # [Angstrom/K]         J. Piprek\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.9                                       # R. T. Senger et al., phys. stat. sol. (b) 241, 1896 (2004)\n        ,\'optical_a\' : 5.10                                      # R. T. Senger et al., phys. stat. sol. (b) 241, 1896 (2004)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :106.7  ,\'c12\' :66.6   ,\'c44\' :45.6                   # G. Martino et al., phys. stat. sol. (,\'a\') 152, 249 (1995)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.0                                              # ???\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.20                         # R. T. Senger et al., phys. stat. sol. (b) 241, 1896 (2004)\n#         ,\'bandgap\'               :3.68                         # 300 K\n          ,\'bandgap\'               :3.841                        #   0 K\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-6.9                         # A. Zunger: a_c :a_v + a_gap :-1.74 + (-5.16) :-6.9, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.83                        # A. Zunger: a_c :a_v + a_gap :-1.74 + (-3.09) :-4.83, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.65                        # A. Zunger: a_c :a_v + a_gap :-1.74 + 1.09 :-0.65, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.02                              # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :1.76  ,\'g\' :0 }                      # J. Piprek\n        ,\'LH\':{ \'mass\'          :0.17  ,\'g\' :0 }                      # J. Piprek\n        ,\'SO\':{ \'mass\'          :0.40  }                            # P. Lawaetz, PRB 4, 3460 (1971)\n\n        ,\'defpot_absolute\'   :-1.74                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-0.8   ,\'defpot_uniaxial_d\' :-3.7    # b (J. Piprek), d (experiment, A. Blacha et al., phys. stat. sol. (b) 126, 11 (1984)) [eV]\n       \n        ,\'delta_SO\'          :0.07                               # Qteish/Needs\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # ???\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # ???\n        ,\'kappa\' :0.17                                           # P. Lawaetz, PRB 4, 3460 (1971)\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.841\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :20.4                                             # P. Lawaetz, PRB 4, 3460 (1971)\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n\n######### cadmium sulfide ############################################\n,\'CdS\':{\n    \'mat_crys_strc\'    :\'Zincblende\'\n    ,\'valence\' :\'II_VI\'\n   \n    ,\'lattice_consts\':{\n        \'a\'           :5.818                                    # [Angstrom]    300 K, J. Piprek\n        ,\'a_expansion\' :3.68e-5                                  # [Angstrom/K] ??? ZnS\n    }\n    \n    ,\'dielectric_consts\':{\n        \'static_a\'  : 8.9                                       # ???\n        ,\'optical_a\' : 5.10                                      # ???\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :83.1  ,\'c12\' :50.4   ,\'c44\' :45.6                   # J. Piprek, (,\'c44\' ??? ZnS value)\n    }                    \n\n    ,\'piezoelectric_consts\':{\n        \'e14\' :0.0                                              # ???\n    }                                                \n\n    ,\'conduction_bands\':{\n       \'Gamma\':{ \n          \'mass\'                  :0.21                         # J. Piprek\n#         ,\'bandgap\'               :2.48                         # 300 K\n          ,\'bandgap\'               :2.583                        #   0 K\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-4.45                         # A. Zunger: a_c :a_v + a_gap :-1.51 + (-2.94) :-4.45, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'g\'                     :0                            # ???\n       }\n       ,\'L\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-3.74                        # A. Zunger: a_c :a_v + a_gap :-1.51 + (-2.23) :-3.74, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }\n       ,\'X\':{ \n          \'mass_l\'                :0.5                          # ???\n          ,\'mass_t\'                :0.5                          # ???\n          ,\'bandgap\'               :5                            # ???\n          ,\'bandgap_alpha\'         :0                            # ???\n          ,\'bandgap_beta\'          :0                            # ???\n          ,\'defpot_absolute\'       :-0.63                        # A. Zunger: a_c :a_v + a_gap :-1.51 + 0.88 :-0.63, S.-H. Wei and A. Zunger, APL 72, 2011 (1998)\n          ,\'defpot_uniaxial\'       :0                            # ???\n       }      \n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.16                               # A. Zunger, average ,\'valence\' band energy E_v,av [eV]\n        \n        ,\'HH\':{ \'mass\'          :0.64  ,\'g\' :0 }                      # J. Piprek\n        ,\'LH\':{ \'mass\'          :0.64  ,\'g\' :0 }                      # J. Piprek\n        ,\'SO\':{ \'mass\'          :0.40  }                            # ???\n\n        ,\'defpot_absolute\'   :-1.51                              # A. Zunger: a_v\n        ,\'defpot_uniaxial_b\' :-1.18   ,\'defpot_uniaxial_d\' :-3.7   # b (Qteish, +1.6 eV (exp.)?), d (??? ZnS) [eV]\n       \n        ,\'delta_SO\'          :0.064                              # J. Piprek\n       \n    }\n\n    ,\'kp_6_bands\':{\n      # gamma1 :4.8    gamma2 :0.67   gamma3 :1.53          # ???\n        \'L\' :-9.86       ,\'M\' :-3.02       ,\'N\' :-11.04             # ???\n        ,\'kappa\' :0                                              # ???\n    }                    \n\n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :2.583\n        \'S\' :1.0                                                # S :1 + 2F\n        ,\'E_P\' :20.4                                             # ???\n        ,\'B\' : 0                     \n      # gamma1 :0.0    gamma2 :0.0    gamma3 :0.0           # ??? can be calculated from 6x6 k.p parameters\n        ,\'L\' :0           ,\'M\' :-3.02       ,\'N\' :0                  # ??? can be calculated from 6x6 k.p parameters\n        ,\'kappa\' :0                                              # ??? can be calculated from 6x6 k.p parameters\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n}\n#\n    \n,\'Air_wz\':{                                                   \n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'III_V\'                                            # III_VI\n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.189                                    \n        ,\'a_expansion\' :0                                        \n        ,\'c\'           :5.185                                    \n        ,\'c_expansion\' :0                                        \n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :1.0     ,\'static_c\'  :1.0                            ,\'optical_a\' :1.0    ,\'optical_c\' :1.0                   \n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :0.01       ,\'c12\' :0.01       ,\'c13\' :0.01              \n        ,\'c33\' :0.01       ,\'c44\' :0.01 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :0.0     ,\'e33\' :0.0                             \n        ,\'e15\' :0.0                                            \n    }  \n    \n    ,\'pyroelectric_const\' :0.0                                   \n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.202                         \n          ,\'mass_t\'                :0.206                         \n          ,\'bandgap\'               :8.0                        \n          ,\'bandgap_alpha\'         :0.0  \n          ,\'bandgap_beta\'          :0    \n          ,\'defpot_absolute_l\'     :0                         \n          ,\'defpot_absolute_t\'     :0                        \n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-3.0                            \n        \n        ,\'HH\':{ \'mass_l\' :1.6      ,\'mass_t\' :1.1 }                \n        ,\'LH\':{ \'mass_l\' :0.15     ,\'mass_t\' :0.11  }               \n        ,\'SO\':{ \'mass_l\' :1.1      ,\'mass_t\' :0.15  }               \n        ,\'defpotentials\' :{\'D1\':-3.90,\n                            \'D2\':-4.13,\n                            \'D3\':1.15,\n                            \'D4\':-1.22,\n                            \'D5\':-1.53,\n                            \'D6\':2.83}                   \n       \n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}    \n                  \n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-7.21     ,\'A2\' :-0.44      ,\'A3\' : 6.68              \n        ,\'A4\' :-3.46     ,\'A5\' :-3.40      ,\'A6\' :-4.90              \n    }\n \n    ,\'kp_8_bands\':{                                                \n        \'S1\'   : 1.0   ,\'S2\'   : 1.0                        \n        ,\'E_P1\' :0.0      ,\'E_P2\' :0.0                           \n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0            \n        ,\'A1\'   :-7.21    ,\'A2\'   :-0.44      ,\'A3\' : 6.68         \n        ,\'A4\'   :-3.46    ,\'A5\'   :-3.40     ,\'A6\' : -4.90         \n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }        \n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }        \n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         \n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         \n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 \n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  \n        }\n    }\n} \n#\n\n\n######### sapphire #####################################################\n,\'Al2O3\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'III_V\'                                            # III_VI\n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.112                                    # AlN value\n        ,\'a_expansion\' :0                                        # ?\n        ,\'c\'           :4.982                                    # AlN value\n        ,\'c_expansion\' :0                                        # ?\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :9.4     ,\'static_c\'  :11.5                   # www.crystran.co.uk/sappdata.htm  11.5 (para) 9.4 (perp) at 1MHz\n        ,\'optical_a\' :4.68    ,\'optical_c\' :4.68                   # AlN value\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :496       ,\'c12\' :164       ,\'c13\' :115              # www.crystran.co.uk/sappdata.htm\n        ,\'c33\' :498       ,\'c44\' :148 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.50     ,\'e33\' :1.79                             # AlN value\n        ,\'e15\' :-0.48                                            # AlN value\n    }  \n    \n    ,\'pyroelectric_const\' :0.0                                   #\n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.32                         # AlN value\n          ,\'mass_t\'                :0.30                         # AlN value\n          ,\'bandgap\'               :6.25                         # AlN value\n          ,\'bandgap_alpha\'         :0.0                          # ?\n          ,\'bandgap_beta\'          :0                            # ?\n          ,\'defpot_absolute_l\'     :-3.4                         # AlN value  along c axis\n          ,\'defpot_absolute_t\'     :-11.8                        # AlN value  perpendicular to c axis\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-1.526                             # AlN value\n        \n        ,\'HH\':{ \'mass_l\' :3.53      ,\'mass_t\' :10.42 }                # AlN value\n        ,\'LH\':{ \'mass_l\' :3.53      ,\'mass_t\' :0.24  }                # AlN value\n        ,\'SO\':{ \'mass_l\' :0.25      ,\'mass_t\' :3.81  }                # AlN value\n        \n        ,\'defpotentials\' :{\'D1\':-3.90,\n                            \'D2\':-4.13,\n                            \'D3\':1.15,\n                            \'D4\':-1.22,\n                            \'D5\':-1.53,\n                            \'D6\':2.83}                   # ?\n       \n        ,\'delta\':{\'delta_\': -0.169,\'delta_so\':0.00633,\'delta_cr\':0.00633}# AlN value    \n\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-3.86     ,\'A2\' :-0.25      ,\'A3\' : 3.58              # AlN value\n        ,\'A4\' :-1.32     ,\'A5\' :-1.47      ,\'A6\' :-1.64              # AlN value\n    }\n \n    ,\'kp_8_bands\':{                                                #\n        \'S1\'   : 0.805    ,\'S2\'   : 1.013                         # AlN value\n        ,\'E_P1\' :14.5      ,\'E_P2\' :14.5                           # AlN value\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # AlN value\n        ,\'A1\'   :-1.540    ,\'A2\'   :-0.25      ,\'A3\' : 1.260         # AlN value\n        ,\'A4\'   :-0.160    ,\'A5\'   :-0.310     ,\'A6\' : 4.877         # AlN value\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # AlN value\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # AlN value\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#\n\n\n\n\n##########################################################################################\n##########################################################################################\n#          BINARIES     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n######### gallium nitride #############################################\n,\'GaN\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.189                                    # Vurgaftman1/Vurgaftman2 (300 K) and O. Ambacher, Review\n        ,\'a_expansion\' :0                                        # \n      # ,\'a_expansion\' :5.59e-5                                  # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/thermal.html Qian W. et al., MRS Symposium Proceedings, Pittsburgh, 475-486 (1996)\n        ,\'c\'           :5.185                                    # Vurgaftman1/Vurgaftman2 (300 K) and O. Ambacher, Review\n        ,\'c_expansion\' :0                                        # \n      # ,\'c_expansion\' :3.17e-5                                  # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/thermal.html Qian W. et al., MRS Symposium Proceedings, Pittsburgh, 475-486 (1996)\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :9.28    ,\'static_c\'  :10.10                  # Tsai et al., JAP 85, 1475 (1999)\n        ,\'optical_a\' :5.29    ,\'optical_c\' :5.29                   # S.M. Komirenko et al., PRB 59, 5013 (1999) (value  taken from paper of V.A. Fonoberov et al., JAP 94, 7178 (2003)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :390       ,\'c12\' :145       ,\'c13\' :106              # Vurgaftman1/Vurgaftman2\n        ,\'c33\' :398       ,\'c44\' :105 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.35     ,\'e33\' :1.27                             # Vurgaftman1 (Vurgaftman2 lists d_ij (/:e_ij !) parameters.)\n        ,\'e15\' :-0.30                                            # O. Ambacher\n    }  \n    \n    ,\'pyroelectric_const\' :-0.034                                # Vurgaftman2 and O. Ambacher\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.206                        # m_perp=0.202, m_perp=0.202, m_par=0.206 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html\n          ,\'mass_t\'                :0.202                        # m_perp=0.202, m_perp=0.202, m_par=0.206 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html\n          ,\'bandgap\'               :3.510                        # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.909e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :830                          # Vurgaftman2\n          #-----------------------------------------------------------------------------------------------\n          # Note that I. Vurgaftman et al., JAP 94, 3675 (2003) lists a_1 and a_2 parameters.\n          # They refer to the interband deformation potentials, i.e. to the deformation of the band gaps.\n          # Thus we have to add the deformation potentials of the ,\'valence\' bands\n          # to get the deformation potentials for the conduction band edge.\n          # a_c,,\'a\' :a_2 + D2 :-11.3 +   4.5  :-6.8    [Vurgaftman2]\n          # a_c,c :a_1 + D1 : -4.9 + (-3.7) :-8.6    [Vurgaftman2]\n          #-----------------------------------------------------------------------------------------------\n          ,\'defpot_absolute_l\'     :-8.6                         # Vurgaftman2 (a1) along c axis\n          ,\'defpot_absolute_t\'     :-6.8                         # Vurgaftman2 (a2) perpendicular to c axis\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.726                             # A. Zunger\n        \n        ,\'HH\':{ \'mass_l\' :1.1       ,\'mass_t\' :1.6   }                # m_perp=1.6 , m_perp=1.6 , m_par=1.1  (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html\n        ,\'LH\':{ \'mass_l\' :1.1       ,\'mass_t\' :0.15  }                # m_perp=0.15, m_perp=0.15, m_par=1.1  (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html\n        ,\'SO\':{ \'mass_l\' :0.15      ,\'mass_t\' :1.1   }                # m_perp=1.1 , m_perp=1.1 , m_par=0.15 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/GaN/bandstr.html\n        \n        ,\'defpotentials\' :{\'D1\':-3.7,\n                            \'D2\':4.5,\n                            \'D3\':8.2,\n                            \'D4\':-4.1,\n                            \'D5\':-4.0,\n                            \'D6\':-5.5\n    }\n        \n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}    \n      # ,\'delta\' :{[ 0.0108, 0.00703, 0.00703 ]}                   # Ren et al.\n    }\n\n    # Note: The GaN values \'A1\',,\'A2\',,\'A3\',,\'A4\',,\'A5\',,\'A6\' are taken from Vurgaftman2. He took the values of Ren et al.\n    #       To be consistent with Ren\'s values one should use Ren\'s values for the delta splittings.\n    #       Delta_1(,\'cr\')=0.0108d0 and Delta_2=Delta_3=0.0211/3=Delta_so/3=0.00703d0\n    ,\'kp_6_bands\':{  \n        \'A1\' :-7.21     ,\'A2\' :-0.44      ,\'A3\' : 6.68              # Vurgaftman2\n        ,\'A4\' :-3.46     ,\'A5\' :-3.40      ,\'A6\' :-4.90              # Vurgaftman2\n    }\n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :3.510 eV  (Vurgaftman2)\n        \'S1\'   : 0.866    ,\'S2\'   : 0.962\n      # \'S1\'   : 1        ,\'S2\'   : 1                             # S :1 + 2F :1 + 2 (0) :1 (Vurgaftman1)\n        ,\'E_P1\' : 14.0     ,\'E_P2\' : 14.0                          # Vurgaftman1\n        ,\'B1\'   : 0.0937   ,\'B2\'   : 0.0937    ,\'B3\' : 0.0937        # Vurgaftman2 A7 :0.0937\n        ,\'A1\'   :-3.221    ,\'A2\'   :-0.44      ,\'A3\' : 2.691         # based on Vurgaftman2\n        ,\'A4\'   :-1.466    ,\'A5\'   :-1.406     ,\'A6\' :-2.080         # based on Vurgaftman2\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # radiative constant :1.1d-8 [cm^3/s] - J.F.Muth APL 71 (18) 2572 (1997)\n        }\n    }\n}\n#\n\n######### aluminum nitride ############################################\n,\'AlN\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'III_V\'   \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.112                                    # Vurgaftman1/Vurgaftman2 (300 K) and O. Ambacher, Review\n        ,\'a_expansion\' :0                                        # \n      # ,\'a_expansion\' :4.15e-5                                  # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/AlN/basic.html Sirota, N.N., Golodushko, V.Z., Tezisy Dokl., Vses Konf. Khi., Svyazi Poluprovdn. Polumetallakh 5th (1974) 98\n        ,\'c\'           :4.982                                    # Vurgaftman1/Vurgaftman2 (300 K) and O. Ambacher, Review\n        ,\'c_expansion\' :0                                        # \n      # ,\'c_expansion\' :5.27e-5                                  # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/AlN/basic.html Sirota, N.N., Golodushko, V.Z., Tezisy Dokl., Vses Konf. Khi., Svyazi Poluprovdn. Polumetallakh 5th (1974) 98\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :8.67    ,\'static_c\'  :8.57                   # (values taken from paper of V.A. Fonoberov et al., JAP 94, 7178 (2003)\n        ,\'optical_a\' :4.68    ,\'optical_c\' :4.68                   # S.M. Komirenko et al., PRB 59, 5013 (1999) (value  taken from paper of V.A. Fonoberov et al., JAP 94, 7178 (2003)\n    }\n\n    ,\'elastic_consts\':{\n        \'c11\' :396       ,\'c12\' :137       ,\'c13\' :108              # Vurgaftman1/Vurgaftman2\n        ,\'c33\' :373       ,\'c44\' :116 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.50     ,\'e33\' :1.79                             # Vurgaftman1 (Vurgaftman2 lists d_ij (/:e_ij !) parameters.)\n        ,\'e15\' :-0.48                                            # O. Ambacher\n    }  \n    \n    ,\'pyroelectric_const\' :-0.090                                # Vurgaftman2 and O. Ambacher\n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.32                         # Vurgaftman2  m_perp=0.30, m_perp=0.30, m_par=0.32 (with respect to c-axis)\n          ,\'mass_t\'                :0.30                         # Vurgaftman2  m_perp=0.30, m_perp=0.30, m_par=0.32 (with respect to c-axis)\n          ,\'bandgap\'               :6.25                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :1.799e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :1462                         # Vurgaftman2\n          #-----------------------------------------------------------------------------------------------\n          # Note that I. Vurgaftman et al., JAP 94, 3675 (2003) lists a_1 and a_2 parameters.\n          # They refer to the interband deformation potentials, i.e. to the deformation of the band gaps.\n          # Thus we have to add the deformation potentials of the ,\'valence\' bands\n          # to get the deformation potentials for the conduction band edge.\n          # a_c,,\'a\' :a_2 + D2 :-11.8 +    7.9  :-3.9    [Vurgaftman2]\n          # a_c,c :a_1 + D1 : -3.4 + (-17.1) :-20.5   [Vurgaftman2]\n          #-----------------------------------------------------------------------------------------------\n          ,\'defpot_absolute_l\'     :-20.5                        # Vurgaftman2 (a1) along c axis\n          ,\'defpot_absolute_t\'     : -3.9                        # Vurgaftman2 (a2) perpendicular to c axis\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-1.526                             # A. Zunger\n        \n        ,\'HH\':{ \'mass_l\' :3.53      ,\'mass_t\' :10.42 }                # m_perp=10.42, m_perp=10.42, m_par=3.53 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/AlN/bandstr.html\n        ,\'LH\':{ \'mass_l\' :3.53      ,\'mass_t\' :0.24  }                # m_perp=0.24 , m_perp=0.24 , m_par=3.53 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/AlN/bandstr.html\n        ,\'SO\':{ \'mass_l\' :0.25      ,\'mass_t\' :3.81  }                # m_perp=3.81 , m_perp=3.81 , m_par=0.25 (with respect to c-axis) - http://www.ioffe.rssi.ru/SVA/NSM/Semicond/AlN/bandstr.html\n        \n        # Vurgaftman2\n        ,\'defpotentials\' :{\'D1\':-17.1,\n                            \'D2\':7.9,\n                            \'D3\':8.8,\n                            \'D4\':-3.9,\n                            \'D5\':-3.4,\n                            \'D6\':-3.4 }        \n        #,\'delta\' :{[-0.169 , 0.00633, 0.00633 ]}                   # Vurgaftman2\n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-3.86     ,\'A2\' :-0.25      ,\'A3\' : 3.58              # Vurgaftman2\n        ,\'A4\' :-1.32     ,\'A5\' :-1.47      ,\'A6\' :-1.64              # Vurgaftman2\n    }\n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :6.25 eV   (Vurgaftman2)\n        \'S1\'   : 0.805    ,\'S2\'   : 1.013\n      # \'S1\'   : 1        ,\'S2\'   : 1                             # S :1 + 2F :1 + 2 (0) :1 (Vurgaftman1)\n        ,\'E_P1\' :14.5      ,\'E_P2\' :14.5                           # Vurgaftman1\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # Vurgaftman2 A7 :0\n        ,\'A1\'   :-1.540    ,\'A2\'   :-0.25      ,\'A3\' : 1.260         # based on Vurgaftman2\n        ,\'A4\'   :-0.160    ,\'A5\'   :-0.310     ,\'A6\' : 4.877         # based on Vurgaftman2\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#\n\n######### indium nitride ##############################################\n,\'InN\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'III_V\'    \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.545                                    # Vurgaftman1/Vurgaftman2 (300 K)\n        ,\'a_expansion\' :0                                        # \n      # ,\'a_expansion\' :3.8e-5                                   # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/thermal.html\n        ,\'c\'           :5.703                                    # Vurgaftman1/Vurgaftman2 (300 K)\n        ,\'c_expansion\' :0                                        # \n      # ,\'c_expansion\' :2.9e-5                                   # This value corresponds to ,\'a\' different equation! http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/thermal.html\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :13.1    ,\'static_c\'  :14.4                   # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/optic.html\n        ,\'optical_a\' :6.7     ,\'optical_c\' :6.7                    # A. Kasic PRB 65, 115206 (2002)\n    }\n\n     ,\'elastic_consts\':{\n        \'c11\' :223       ,\'c12\' :115       ,\'c13\' :92               # Vurgaftman1/Vurgaftman2\n        ,\'c33\' :224       ,\'c44\' :48 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.57     ,\'e33\' :0.97                             # Vurgaftman1 (Vurgaftman2 lists d_ij (/:e_ij !) parameters.)\n        ,\'e15\' :-0.48                                            # AlN value\n    }  \n    \n    ,\'pyroelectric_const\' :-0.042                                # Vurgaftman2 and O. Ambacher\n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.07                         # J. Wu, PRB 66, 201403, Vurgaftman1/Vurgaftman2 m_perp=0.07, m_perp=0.07, m_par=0.07 (with respect to c-axis)\n          ,\'mass_t\'                :0.07                         # J. Wu, PRB 66, 201403, Vurgaftman1/Vurgaftman2 m_perp=0.07, m_perp=0.07, m_par=0.07 (with respect to c-axis)\n          ,\'bandgap\'               :0.78                         # Vurgaftman2 (0 K)\n          ,\'bandgap_alpha\'         :0.245e-3                     # Vurgaftman2\n          ,\'bandgap_beta\'          :624                          # Vurgaftman2\n          #-----------------------------------------------------------------------------------------------\n          # Note that I. Vurgaftman et al., JAP 94, 3675 (2003) lists a_1 and a_2 parameters.\n          # They refer to the interband deformation potentials, i.e. to the deformation of the band gaps.\n          # Thus we have to add the deformation potentials of the ,\'valence\' bands\n          # to get the deformation potentials for the conduction band edge.\n          # a_c,,\'a\' :a_2 + D2 :-3.5 +   4.5  : 1.0    [Vurgaftman2]\n          # a_c,c :a_1 + D1 :-3.5 + (-3.7) :-7.2    [Vurgaftman2]\n          #-----------------------------------------------------------------------------------------------\n          ,\'defpot_absolute_l\'     :-7.2                         # Vurgaftman2 (a1) along c axis\n          ,\'defpot_absolute_t\'     : 1.0                         # Vurgaftman2 (a2) perpendicular to c axis\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.462                             # A. Zunger\n        \n        ,\'HH\':{ \'mass_l\' :1.63      ,\'mass_t\' :1.63  }                # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/bandstr.html, Xu & Ching (1993), Yeo et al. (1998), Pugh et al. (1999)\n        ,\'LH\':{ \'mass_l\' :0.27      ,\'mass_t\' :0.27  }                # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/bandstr.html, Xu & Ching (1993), Yeo et al. (1998), Pugh et al. (1999)\n        ,\'SO\':{ \'mass_l\' :0.65      ,\'mass_t\' :0.65  }                # http://www.ioffe.rssi.ru/SVA/NSM/Semicond/InN/bandstr.html, Xu & Ching (1993), Yeo et al. (1998), Pugh et al. (1999)\n        \n        # Vurgaftman2\n        ,\'defpotentials\' :{\'D1\':-3.7,\n                            \'D2\':4.5,\n                            \'D3\':8.2,\n                            \'D4\':-4.1,\n                            \'D5\':-4.0,\n                            \'D6\':-5.5 }         \n        #,\'delta\' :{[ 0.040 , 0.00167, 0.00167 ]}                   # Vurgaftman2\n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-8.21     ,\'A2\' :-0.68      ,\'A3\' : 7.57              # Vurgaftman2\n        ,\'A4\' :-5.23     ,\'A5\' :-5.11      ,\'A6\' :-5.96              # Vurgaftman2\n    }\n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.78 eV   (Vurgaftman2)\n        \'S1\'   :-4.432    ,\'S2\'   :-4.432\n      # \'S1\'   : 1        ,\'S2\'   : 1                             # S :1 + 2F :1 + 2 (0) :1 (Vurgaftman1)\n        ,\'E_P1\' :14.6      ,\'E_P2\' :14.6                           # Vurgaftman1\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # Vurgaftman2 A7 :0\n        ,\'A1\'   :10.508    ,\'A2\'   :-0.68      ,\'A3\' :-11.148        # based on Vurgaftman2\n        ,\'A4\'   : 4.129    ,\'A5\'   : 4.249     ,\'A6\' :  7.276        # based on Vurgaftman2\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         #\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         #\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#\n\n######### zinc oxide ##############################################\n# [W.R.L. Lambrecht et al., MRS Internet J. Nitride Semicond. Res. 4S1, G6.8 (1999)]\n,\'ZnO\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'II_VI\'   \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.250                                    # (300 K) http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n        ,\'a_expansion\' :6.51e-5                                  # (300 K) http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n        ,\'c\'           :5.205                                    # (300 K) http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n        ,\'c_expansion\' :3.02e-5                                  # (300 K) http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :7.77    ,\'static_c\'  :8.91                   # N. Ashkenov et al., JAP 93, 126 (2003)\n        ,\'optical_a\' :3.70    ,\'optical_c\' :3.75                   # http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n    }\n\n     ,\'elastic_consts\':{\n      # \'c11 :190       ,\'c12\' :110       ,\'c13\' :90               # http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n      # ,\'c33\' :196       ,\'c44\' :39 \n        \'c11\' :206       ,\'c12\' :118       ,\'c13\' :118              # experiment of G. Carlotti et al., J. Phys.: Condens. Matter 7, 9147 (1995) - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'c33\' :211       ,\'c44\' :44 \n      # \'c11\' :217       ,\'c12\' :117       ,\'c13\' :121              # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n      # ,\'c33\' :225       ,\'c44\' :50 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.57     ,\'e33\' :1.34                             # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'e15\' :-0.30                                            # GaN value\n    }  \n    \n    ,\'pyroelectric_const\' :-0.0220                               # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n  # ,\'pyroelectric_const\' :-0.0340                               # K. Shimada et al., PRB 88, 075203 (2013) (theory)\n  # ,\'pyroelectric_const\' :-0.050                                # S.-H. Park, D. Ahn, APL 87, 253509 (2007)\n  # ,\'pyroelectric_const\' :-0.03220                              # A. Malashevich, D. Vanderbilt, PRB 75, 045106 (2007) (theory, extrapolation)\n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.24                         # [Lambrecht] polaronic mass\n          ,\'mass_t\'                :0.28                         # [Lambrecht] polaronic mass\n          ,\'bandgap\'               :3.436                        # (0 K) [Zhang, 4 K]\n          ,\'bandgap_alpha\'         :0.8e-3                       # http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n          ,\'bandgap_beta\'          :0                            # \n          ,\'defpot_absolute_l\'     :-2.30                        # assumption of isotropic deformation potential (Janotti et al., PRB 74, 045202 (2006)\n          ,\'defpot_absolute_t\'     :-2.30                        # assumption of isotropic deformation potential (Janotti et al., PRB 74, 045202 (2006)\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.03783                           # \n        \n        ,\'HH\':{ \'mass_l\' :0.54      ,\'mass_t\' :2.74  }                # [Lambrecht]\n        ,\'LH\':{ \'mass_l\' :0.55      ,\'mass_t\' :3.03  }                # [Lambrecht]\n        ,\'SO\':{ \'mass_l\' :1.12      ,\'mass_t\' :0.27  }                # [Lambrecht]\n        \n        # (5 K, Landoldt-B\xc3\xb6rnstein, II-VI compounds)\n        ,\'defpotentials\' :{\'D1\':-3.90,\n                            \'D2\':-4.13,\n                            \'D3\':-1.15,\n                            \'D4\':-1.22,\n                            \'D5\':-1.53,\n                            \'D6\':-2.88 }         \n        #,\'delta\' :{[ 0.050 , 0.0016666, 0.0016666 ]}               # Delta_so :0.005 eV (Claus Klingshirn et al., Physik Journal, Vol. 1, 37 (2006))\n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # W.J. Fan, J. of Crystal Growth 287, 28 (2006)\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # W.J. Fan, J. of Crystal Growth 287, 28 (2006)\n    }\n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.78 eV   (Vurgaftman2)\n        \'S1\'   : 1        ,\'S2\'   : 1                             # ??? S :1 + 2F :1 + 2 (0) :1 (Vurgaftman1)\n        ,\'E_P1\' :14.0      ,\'E_P2\' :14.0                           # GaN value\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # \n        ,\'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # kp_6_bands value!!!\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # kp_6_bands value!!!\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#\n\n######### magnesium oxide ##############################################\n# [W.R.L. Lambrecht et al., MRS Internet J. Nitride Semicond. Res. 4S1, G6.8 (1999)]\n,\'MgO\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'II_VI\'   \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.413                                    # (300 K) W.R.L. Lambrecht et al., MRS Internet J. Nitride Semicond. Res. 4S1, G6.8 (1999)\n        ,\'a_expansion\' :11.2e-5                                  # (300 K) rocksalt value !!! units ? Angstrom? [nm/K] ,\'a\',,\'a\',c at 300 K  -  Thermal expansion coefficient: 11.2 x 10-6/\xc2\xb0C [http://www.mtberlin.com/frames_cryst/descriptions/substrates.htm]\n        ,\'c\'           :4.109252                                 # (300 K) W.R.L. Lambrecht et al., MRS Internet J. Nitride Semicond. Res. 4S1, G6.8 (1999)\n        ,\'c_expansion\' :11.2e-5                                  # (300 K) http://www.onr.navy.mil/sci_tech/31/312/ncsr/materials/zno.asp\n    }\n    \n    ,\'dielectric_consts\':{    \n        \'static_a\'  :7.77    ,\'static_c\'  :8.91                   # ZnO value\n        ,\'optical_a\' :2.95    ,\'optical_c\' :2.95                   # rocksalt - A.R. Oganov et al., J. of Chem. Phys. 118, 10174 (2003)\n    }\n\n     ,\'elastic_consts\':{\n        \'c11\' :222       ,\'c12\' :90        ,\'c13\' :58               # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'c33\' :109       ,\'c44\' :105 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.58     ,\'e33\' :1.64                             # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'e15\' :-0.30                                            # GaN value\n    }  \n    \n    ,\'pyroelectric_const\' :-0.060                                # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n  # ,\'pyroelectric_const\' :-0.135                                # theory - K. Shimada et al., PRB 88, 075203 (2013)\n  # ,\'pyroelectric_const\' :-0.111                                # theory - A. Malashevich, D. Vanderbilt, PRB 75, 045106 (2007) (extrapolation, assuming no bowing factor between ZnO and MgO)\n  # ,\'pyroelectric_const\' :-0.070                                # S.-H. Park, D. Ahn, APL 87, 253509 (2007)\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.24                         # ZnO value\n          ,\'mass_t\'                :0.28                         # ZnO value\n          ,\'bandgap\'               :5.076                        # (0 K) [Zhang]\n          ,\'bandgap_alpha\'         :0.8e-3                       # ZnO value\n          ,\'bandgap_beta\'          :0                            # ZnO value\n          ,\'defpot_absolute_l\'     :-2.30                        # ZnO value\n          ,\'defpot_absolute_t\'     :-2.30                        # ZnO value\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :0.61183                            # VBO :-0.574 [Zhang], shift so that VBO(ZnO/MgO) :0.364 eV  (35 % of band offset)\n                                                               # E_v,av(MgO) : 1.6793     VBO :-0.03783 - (-1.75783) :1.72 eV\n                                                               # \'bandoffset\' MgO/ZnO: CBO(MgO-ZnO) :2.68 eV [Kilic and Zunger, Appl. Phys. Lett. 81, 73 (2002)]\n                                                               #                     VBO(MgO-ZnO) :1.72 eV [Kilic and Zunger, Appl. Phys. Lett. 81, 73 (2002)]\n        \n        ,\'HH\':{ \'mass_l\' :2.77      ,\'mass_t\' :1.6   }                # Y.-N. Xu et al., PRB 43, 4461 (1991)\n        ,\'LH\':{ \'mass_l\' :0.31      ,\'mass_t\' :0.32  }                # Y.-N. Xu et al., PRB 43, 4461 (1991)\n        ,\'SO\':{ \'mass_l\' :1.12      ,\'mass_t\' :0.27  }                # ZnO value\n        \n        # ZnO values\n        ,\'defpotentials\' :{\'D1\':-3.90,\n                            \'D2\':-4.13,\n                            \'D3\':-1.15,\n                            \'D4\':-1.22,\n                            \'D5\':-1.53,\n                            \'D6\':-2.88 }         \n        #,\'delta\' :{[ 0.050 , 0.0016666, 0.0016666 ]}               # ZnO values\n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # ZnO values\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # ZnO values\n    }\n \n    ,\'kp_8_bands\':{                                                # ,\'bandgap\'(Gamma) :0.78 eV   (Vurgaftman2)\n        \'S1\'   : 1        ,\'S2\'   : 1                             # ??? S :1 + 2F :1 + 2 (0) :1 (Vurgaftman1)\n        ,\'E_P1\' :14.0      ,\'E_P2\' :14.0                           # GaN value\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # \n        ,\'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # kp_6_bands value!!!\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # kp_6_bands value!!!\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#\n\n######### cadmium oxide ##############################################\n# Note: Usually CdO has the rocksalt crystal structure:\n#       (cubic Fm3m, rocksalt ,\'B1\')\n#       However, it is possible to grow Cd(x)Zn(1-x)O alloys with the wurtzite structure.\n,\'CdO\':{\n    \'mat_crys_strc\'    :\'Wurtzite\'\n    ,\'valence\' :\'II_VI\'   \n   \n    ,\'lattice_consts\':{\n        \'a\'           :3.60                                     # (300 K) P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'a_expansion\' :6.51e-5                                  # ZnO value\n        ,\'c\'           :5.58                                     # (300 K) P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'c_expansion\' :3.02e-5                                  # ZnO value\n    }\n\n    ,\'dielectric_consts\':{    \n        \'static_a\'  :9.65    ,\'static_c\'  :9.65                   # MgO value\n        ,\'optical_a\' :2.95    ,\'optical_c\' :2.95                   # MgO value\n    }\n\n     ,\'elastic_consts\':{\n        \'c11\' :150       ,\'c12\' :108       ,\'c13\' :61               # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'c33\' :105       ,\'c44\' :47 \n    }\n                                             \n    ,\'piezoelectric_consts\':{ \n        \'e31\' :-0.48     ,\'e33\' :1.67                             # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006)\n        ,\'e15\' :-0.30                                            # GaN value\n    }  \n    \n  # ,\'pyroelectric_const\' :-0.106                               # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006) (Table II)\n    ,\'pyroelectric_const\' :-0.10                                # theory - P. Gopal, N.A. Spaldin, Journal of Electronic Materials 35, 538 (2006) (Abstract)\n       \n    ,\'conduction_bands\':{\n        \'Gamma\':{\n          \'mass_l\'                :0.24                         # ZnO value\n          ,\'mass_t\'                :0.28                         # ZnO value\n          ,\'bandgap\'               :3.436                        # ZnO value\n          ,\'bandgap_alpha\'         :0.8e-3                       # ZnO value\n          ,\'bandgap_beta\'          :0                            # \n          ,\'defpot_absolute_l\'     :-2.30                        # ZnO value\n          ,\'defpot_absolute_t\'     :-2.30                        # ZnO value\n       }\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'        :-0.03783                           # ZnO value\n        \n        ,\'HH\':{ \'mass_l\' :0.54      ,\'mass_t\' :2.74  }                # ZnO value\n        ,\'LH\':{ \'mass_l\' :0.55      ,\'mass_t\' :3.03  }                # ZnO value\n        ,\'SO\':{ \'mass_l\' :1.12      ,\'mass_t\' :0.27  }                # ZnO value\n        \n   \n        ,\'defpotentials\' :{\'D1\':-3.90,# ZnO value\n                            \'D2\':-4.13,\n                            \'D3\':-1.15,\n                            \'D4\':-1.22,\n                            \'D5\':-1.53,\n                            \'D6\':-2.88 }        \n        #,\'delta\' :{[ 0.050 , 0.0016666, 0.0016666 ]}               # ZnO value\n        ,\'delta\':{\'delta_\': 0.010,\'delta_so\':0.00567,\'delta_cr\':0.00567}\n    }\n\n    ,\'kp_6_bands\':{  \n        \'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # ZnO value\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # ZnO value\n    }\n \n    ,\'kp_8_bands\':{                                                # ZnO value\n        \'S1\'   : 1        ,\'S2\'   : 1                             # ZnO value\n        ,\'E_P1\' :14.0      ,\'E_P2\' :14.0                           # ZnO value\n        ,\'B1\'   : 0        ,\'B2\'   : 0         ,\'B3\' : 0             # \n        ,\'A1\' :-6.68036     ,\'A2\' :-0.45388     ,\'A3\' : 6.1275       # ZnO value\n        ,\'A4\' :-2.70374     ,\'A5\' :-2.7669      ,\'A6\' :-4.62566      # ZnO value\n    }\n\n    ,\'mobility_constant\':{\n        \'electrons\':{  \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n        ,\'holes\':{      \'mumax\' :100      ,\'exponent\' :1.0  }         # ???\n    }\n\n    ,\'recombination\':{  \n        \'SRH\':{       \'tau_n\' :1.0e-9      ,\'nref_n\' :1.0e19         # InP value !!!\n                   ,\'tau_p\' :1.0e-9      ,\'nref_p\' :1.0e18         # InP value !!!\n        }\n        ,\'Auger\':{     \'c_n\' :0             ,\'c_p\' :0                 # InP value !!!\n        }\n        ,\'radiative\':{ \'c\' :1.1e-8                                  # GaN value !!!\n        }\n    }\n}\n#    \n}\n\nalloyproperty ={\n\n        ##########################################################################################\n##########################################################################################\n#          T E R N A R Y     A L L O Y S     --    IV - IV       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### silicon-germanium (SiGe) ####################################\n\'SiGe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'IV_IV\'\n    ,\'binary_x\'   :\'Ge\'\n    ,\'binary_1_x\' :\'Si\'    \n\n    ,\'conduction_bands\':{\n        \'Delta\':{\n          \'bandgap\' :0.206                                      #   4.2 K, J. Weber et al., PRB 40, 5683 (1989)\n        }\n    }\n\n    ,\'kp_6_bands\':{  \n        \'L\' :0   ,\'M\' :0   ,\'N\' :0              # !!! L,N !!!       # M varies linearly with x - M. Rieger, P. Vogl, PRB 48, 14276 (1993) - for L,N see eq. (35) in this paper\n    }                                   \n\n}\n#\n##########################################################################################\n##########################################################################################\n#          T E R N A R Y     A L L O Y S     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### aluminum gallium arsenide (AlGaAs) ##########################\n#                                                ,\'g\' :0.4       # (g factor of Al0.3Ga0.7As)\n,\'AlGaAs_Bowing_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'    \n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :-0.127 + 1.310 * 1 }                  # Vurgaftman1: -0.127 + 1.310 * x\n        ,\'L\':    { \'bandgap\' : 0     }                              # Vurgaftman1\n        ,\'X\':    { \'bandgap\' : 0.055 }                              # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0                                           # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :14000 }    \t                       # http://www.ioffe.ru/SVA/NSM/Semicond/AlGaAs/hall.html\n        ,\'holes\':{ \'mumax\' : 1000 }\t                           # gesch\xc3\xa4tzt S. Ziegler (E26)\n    }\n}\n#\n\n\n,\'AlGaAs_Bowing_1_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :-0.127 + 1.310 * 0 }                  # Vurgaftman1: -0.127 + 1.310 * x\n        ,\'L\':    { \'bandgap\' : 0     }                              # Vurgaftman1\n        ,\'X\':    { \'bandgap\' : 0.055 }                              # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0                                           # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :-1000 }\t\t\t                   # http://www.ioffe.ru/SVA/NSM/Semicond/AlGaAs/hall.html\n        ,\'holes\':{ \'mumax\' : 1000 }\t    \t\t               # gesch\xc3\xa4tzt S. Ziegler (E26)\n    }\n}\n#\n\n\n,\'AlGaAs\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'binary_x\'   :\'AlAs\'\n    ,\'binary_1_x\' :\'GaAs\' \n    ,\'bowing_x\'   :\'AlGaAs_Bowing_x\'\n    ,\'bowing_1_x\' :\'AlGaAs_Bowing_1_x\'\n}\n#\n\n######### indium gallium arsenide (InGaAs) ############################\n,\'InGaAs\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InAs\'\n    ,\'binary_1_x\' :\'GaAs\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'            :0.0091                        # Vurgaftman1\n               ,\'bandgap\'         :0.477                         # Vurgaftman1\n               ,\'defpot_absolute\' :2.61 }                        # Vurgaftman1\n        ,\'L\':    { \'bandgap\'         :0.33 }                        # Vurgaftman1\n        ,\'X\':    { \'bandgap\'         :1.4  }                        # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\' :-0.38                                     # Vurgaftman1 (Does this value refer to the ,\'valence\' band edge or to the average ,\'valence\' band edge?)\n        ,\'HH\':{ \'mass\'   :-0.145  }                                 # Vurgaftman1: hh along [001]\n        ,\'LH\':{ \'mass\'   : 0.0202 }                                 # Vurgaftman1: lh along [001]\n        ,\'delta_SO\'   : 0.15                                     # Vurgaftman1\n    }\n                                                               # gamma1 (In0.53Ga0.47As) :11.01  ==>  ,\'L\' :-28.73\n                                                               # gamma2 (In0.53Ga0.47As) : 4.18  ==>  ,\'M\' :-3.65\n                                                               # gamma3 (In0.53Ga0.47As) : 4.84  ==>  ,\'N\' :-29.04\n    ,\'kp_6_bands\':{                                                # ? gamma3 - gamma2 :0.481 (Vurgaftman1)\n      # gamma1 :   gamma2 :   gamma3 : \n        \'L\' :-32.28984344                                       # => ,\'L\' :-28.73 (for In0.53Ga0.47As)\n        ,\'M\' :-1.140907266                                       # => ,\'M\' :-3.65  (for In0.53Ga0.47As)\n        ,\'N\' :-34.03693296                                       # => ,\'N\' :-29.04 (for In0.53Ga0.47As)\n        ,\'kappa\' :4.96                                           # approximation ,\'kappa\' :-N/6+M/3-1/3\n      # ,\'kappa\' :4.0                                            # Traynor, PRB 51, 7361 (1995) <- uses kappa=1.1 for GaAs \n    }\n    ,\'kp_8_bands\':{\n        \'S\' :3.54                                               # S :2 * F :2 * 1.77 (Vurgaftman1)\n        ,\'E_P\' :-1.48                                            # Vurgaftman1\n        ,\'L\' :-25.063                                            # consistent to 6-band (for In0.53Ga0.47As)\n        ,\'M\' :-1.141                                             # consistent to 6-band (for In0.53Ga0.47As)\n        ,\'N\' :-26.809                                            # consistent to 6-band (for In0.53Ga0.47As)\n        ,\'kappa\' :3.75                                           # approximation ,\'kappa\' :-N/6+M/3-1/3\n      # ,\'kappa\' :4.47                                           # consistent to 6-band (Traynor)\n                                                               # ? gamma3 - gamma2 :0.481 (Vurgaftman1)                         \n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :41000 }\t\t\t                   # http://www.ioffe.ru/SVA/NSM/Semicond/GaInAs/hall.html\n        ,\'holes\':{ \'mumax\' :    0 }\t\t\t                   # ?\n    }\n}\n#\n\n######### indium aluminium arsenide (InAlAs) ##########################\n,\'InAlAs\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InAs\'\n    ,\'binary_1_x\' :\'AlAs\' \n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'            : 0.049                        # Vurgaftman1\n               ,\'bandgap\'         : 0.70                         # Vurgaftman1\n               ,\'defpot_absolute\' :-1.4 }                        # Vurgaftman1\n        ,\'X\':    { \'bandgap\'         : 0   }                        # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\' :-0.64                                     # Vurgaftman1 (Does this value refer to the ,\'valence\' band edge or to the average ,\'valence\' band edge?)\n        ,\'delta_SO\'   : 0.15                                     # Vurgaftman1\n    }\n\n    ,\'kp_8_bands\':{\n        \'S\'   :-8.88                                            # S :2 * F :2 * (-4.44) (Vurgaftman1)\n        ,\'E_P\' :-4.81                                            # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' : 0 }\t\t\t                       # \n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       #  \n    }\n}\n#\n\n######### gallium indium phosphide (GaInP) ############################\n,\'GaInP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaP\'\n    ,\'binary_1_x\' :\'InP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'       : 0.051                             # Vurgaftman1\n               ,\'bandgap\'    : 0.65 }                            # Vurgaftman1\n        ,\'L\':    { \'bandgap\'    : 1.03 }                            # Vurgaftman1\n        ,\'X\':    { \'bandgap\'    : 0.20 }                            # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'defpot_uniaxial_d\' : 0                                 # Vurgaftman1\n        ,\'delta_SO\'          : 0                                 # Vurgaftman1\n    }\n\n    ,\'kp_8_bands\':{\n        \'S\' :1.56                                               # S :2 * F :2 * 0.78 (Vurgaftman1)\n    }\n}\n#\n\n######### aluminium indium phosphide (AlInP) ##########################\n,\'AlInP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlP\'\n    ,\'binary_1_x\' :\'InP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'    : 0.22                                 # Vurgaftman1\n               ,\'bandgap\' :-0.48 }                               # Vurgaftman1\n        ,\'X\':    { \'bandgap\' : 0.38 }                               # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\'       :-0.19                                 # Vurgaftman1\n    }\n}\n#\n\n######### aluminium gallium phosphide (AlGaP) #########################\n,\'AlGaP\':{\n    \'mat_crys_strc\'       :\'Zincblende\' \n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlP\'\n    ,\'binary_1_x\' :\'GaP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' : 0    }                               # Vurgaftman1\n        ,\'X\':    { \'bandgap\' : 0.13 }                               # Vurgaftman1\n    }\n}\n#\n\n######### gallium indium antimonide (GaInSb) ##########################\n,\'GaInSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaSb\'\n    ,\'binary_1_x\' :\'InSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'    :0.0092                                # Vurgaftman1\n               ,\'bandgap\' :0.415 }                               # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.4   }                               # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.33  }                               # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'LH\':{ \'mass\'       :0.011 }                               # Vurgaftman1: lh along [001]\n        ,\'delta_SO\'       :0.1                                   # Vurgaftman1\n    }\n\n    ,\'kp_8_bands\':{\n        \'S\' :-13.68                                             # S :2 * F :2 * (-6.84) (Vurgaftman1)\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' : 60000 }\t\t\t                   # http://www.ioffe.ru/SVA/NSM/Semicond/GaInSb/electric.html\n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       # \n    }\n}\n#\n\n######### aluminum indium antimonide (AlInSb) #########################\n,\'AlInSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlSb\'\n    ,\'binary_1_x\' :\'InSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.43 }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0.25                                        # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' : 0 }\t\t\t                       #  \n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       #  \n    }\n}\n#\n\n######### aluminum gallium antimonide (AlGaSb) ########################\n\n,\'AlGaSb_Bowing_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :-0.044 + 1.22 * 1 }                   # Vurgaftman1: -0.044 + 1.22 * x\n        ,\'L\':    { \'bandgap\' :0    }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0    }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0.3                                         # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :0 }\t\t\t                       #  \n        ,\'holes\':{ \'mumax\' : 1200 }\t\t\t                   # A.H. Ramelan & E.M. Goldys - Hole mobility in Al(x)Ga(1-x)Sb grown by metalorganic chemical vapor deposition\n    }\n}\n#\n\n\n,\'AlGaSb_Bowing_1_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :-0.044 + 1.22 * 0 }                   # Vurgaftman1\n        ,\'L\':    { \'bandgap\' : 0    }                               # Vurgaftman1\n        ,\'X\':    { \'bandgap\' : 0    }                               # Vurgaftman1\n    }\n    ,\'valence_bands\':{\n        \'delta_SO\' :0.3                                         # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :0 }\t\t\t                       #  \n        ,\'holes\':{ \'mumax\' : 2000 }\t\t\t                   # A.H. Ramelan & E.M. Goldys - Hole mobility in AlxGa(1-x)Sb grown by metalorganic chemical vapor deposition\n    }\n}\n#\n\n\n,\'AlGaSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlSb\'\n    ,\'binary_1_x\' :\'GaSb\'\n    ,\'bowing_x\'   :\'AlGaSb_Bowing_x\'\n    ,\'bowing_1_x\' :\'AlGaSb_Bowing_1_x\'\n}\n#\n\n######### gallium arsenide antimonide (GaAsSb) ########################\n,\'GaAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaSb\'\n    ,\'binary_1_x\' :\'GaAs\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :1.43 }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :1.2  }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :1.2  }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\' :-1.06                                     # Vurgaftman1 (Does this value refer to the ,\'valence\' band edge or to the average ,\'valence\' band edge?)\n        ,\'delta_SO\'   : 0.6                                      # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :0 }\t\t\t                       #  \n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       #  \n    }\n}\n#\n\n######### indium arsenide antimonide (InAsSb) #########################\n,\'InAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InAs\'\n    ,\'binary_1_x\' :\'InSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'mass\'    :0.035                                 # Vurgaftman1\n               ,\'bandgap\' :0.67 }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.6  }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.6  }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :1.2                                         # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :-80000 }\t\t\t                   # http://www.ioffe.ru/SVA/NSM/Semicond/InAsSb/electric.html\n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       # \n    }\n}\n#\n\n######### aluminum arsenide antimonide (AlAsSb) #######################\n,\'AlAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlAs\'\n    ,\'binary_1_x\' :\'AlSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.8  }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.28 }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.28 }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\' :-1.71                                     # Vurgaftman1 (Does this value refer to the ,\'valence\' band edge or to the average ,\'valence\' band edge?)\n        ,\'delta_SO\'   : 0.15                                     # Vurgaftman1\n    }\n    \n    ,\'mobility_constant\':{\n        \'electrons\':{ \'mumax\' :0 }\t\t\t                       # \n        ,\'holes\':{ \'mumax\' : 0 }\t\t\t                       # \n    }\n}\n#\n\n######### gallium arsenide phosphide (GaAsP) ##########################\n,\'GaAsP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaP\'\n    ,\'binary_1_x\' :\'GaAs\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.19 }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.16 }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.24 }                                # Vurgaftman1\n    }\n}\n#\n\n######### indium arsenide phosphide (InAsP) ###########################\n,\'InAsP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InAs\'\n    ,\'binary_1_x\' :\'InP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.10 }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.27 }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.27 }                                # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0.16                                        # Vurgaftman1\n    }\n}\n#\n\n######### aluminium arsenide phosphide (AlAsP) ########################\n,\'AlAsP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlAs\'\n    ,\'binary_1_x\' :\'AlP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.22 }                                # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :0.22 }                                # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :0.22 }                                # Vurgaftman1\n    }\n}\n#\n\n######### gallium phosphide antimonide (GaPSb) ########################\n,\'GaPSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaP\'\n    ,\'binary_1_x\' :\'GaSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :2.7 }                                 # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :1.7 }                                 # Note: Error in Vurgaftman1, see note in Ref. 10 of Vurgaftman2.\n        ,\'X\':    { \'bandgap\' :1.7 }                                 # Note: Error in Vurgaftman1, see note in Ref. 10 of Vurgaftman2.\n    }\n}\n#\n\n######### indium phosphide antimonide (InPSb) #########################\n,\'InPSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InP\'\n    ,\'binary_1_x\' :\'InSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :1.9 }                                 # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :1.9 }                                 # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :1.9 }                                 # Vurgaftman1\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0.75                                        # Vurgaftman1\n    }\n}\n#\n\n######### aluminium phosphide antimonide (AlPSb) ######################\n,\'AlPSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlP\'\n    ,\'binary_1_x\' :\'AlSb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :2.7 }                                 # Vurgaftman1\n        ,\'L\':    { \'bandgap\' :2.7 }                                 # Vurgaftman1\n        ,\'X\':    { \'bandgap\' :2.7 }                                 # Vurgaftman1\n    }\n}\n#\n\n######### indium gallium nitride (InGaN) (zincblende) #################\n,\'InGaN_zb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InN_zb\'\n    ,\'binary_1_x\' :\'GaN_zb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :1.4 }                                 # Vurgaftman2\n        ,\'L\':    { \'bandgap\' :1.84 }                                # Vurgaftman2\n        ,\'X\':    { \'bandgap\' :0.69 }                                # Vurgaftman2\n    }\n}\n#\n\n######### aluminum gallium nitride (AlGaN) (zincblende) ###############\n,\'AlGaN_zb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlN_zb\'\n    ,\'binary_1_x\' :\'GaN_zb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.7 }                                 # Vurgaftman2\n        ,\'L\':    { \'bandgap\' :0.80 }                                # Vurgaftman2\n        ,\'X\':    { \'bandgap\' :0.61 }                                # Vurgaftman2\n    }\n}\n#\n\n######### aluminum indium nitride (AlInN) (zincblende) ################\n,\'AlInN_zb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlN_zb\'\n    ,\'binary_1_x\' :\'InN_zb\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :2.5 }                                 # Vurgaftman2\n        ,\'L\':    { \'bandgap\' :0.80 }                                # Vurgaftman2\n        ,\'X\':    { \'bandgap\' :0.61 }                                # Vurgaftman2\n    }\n}\n#\n\n######### gallium arsenide nitride (GaAsN) ############################\n\n,\'GaAsN_Bowing_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{                                          # The bowing factor for zinc blende GaAsN reads 20.4-100x [Vurgaftman2] rather than 120.4-100x [Vurgaftman1] (Table XXX).\n        \'Gamma\':{ \'bandgap\' :20.4 - 100 * 1 }                      # Vurgaftman2: 20.4 - 100 * x  ==> only valid for x < 0.15\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0                                           # Vurgaftman1\n    }\n}\n#\n\n\n,\'GaAsN_Bowing_1_x\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n\n    ,\'conduction_bands\':{                                          # The bowing factor for zinc blende GaAsN reads 20.4-100x [Vurgaftman2] rather than 120.4-100x [Vurgaftman1] (Table XXX).\n        \'Gamma\':{ \'bandgap\' :20.4 - 100 * 0 }                      # Vurgaftman2: 20.4 - 100 * x  ==> only valid for x < 0.15\n    }\n\n    ,\'valence_bands\':{\n        \'delta_SO\' :0                                           # Vurgaftman1\n    }\n}\n#\n\n\n,\'GaAsN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaN_zb\'\n    ,\'binary_1_x\' :\'GaAs\'\n    ,\'bowing_x\'   :\'GaAsN_Bowing_x\'\n    ,\'bowing_1_x\' :\'GaAsN_Bowing_1_x\'\n}\n#\n\n######### indium arsenide nitride (InAsN) #############################\n,\'InAsN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InN_zb\'\n    ,\'binary_1_x\' :\'InAs\'\n}\n#\n\n######### indium phosphide nitride (InPN) #############################\n,\'InPN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InN_zb\'\n    ,\'binary_1_x\' :\'InP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :15 }                                # Vurgaftman1\n    }\n}\n#\n\n######### gallium phosphide nitride (GaPN) ############################\n,\'GaPN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'GaN_zb\'\n    ,\'binary_1_x\' :\'GaP\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :3.9 }                               # Vurgaftman1\n    }\n}\n#\n\n######### indium antimonide nitride (InSbN) ###########################\n,\'InSbN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InN_zb\'\n    ,\'binary_1_x\' :\'InSb\'\n}\n#\n\n\n\n######### zinc beryllium selenide (ZnBeSe) ##########################\n,\'ZnBeSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'BeSe\'\n    ,\'binary_1_x\' :\'ZnSe\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.679 }                               # 0.679 corresponds to b=0.97 in Egap and 70 % CBO\n        ,\'L\':    { \'bandgap\' :0.679 }                               # 0.679 corresponds to b=0.97 in Egap and 70 % CBO\n        ,\'X\':    { \'bandgap\' :0.679 }                               # 0.679 corresponds to b=0.97 in Egap and 70 % CBO\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'  :-0.291                                   # -0.291 corresponds to b=0.97 in Egap and 70 % CBO\n    }\n}\n#\n\n######### zinc sulfide selenide (ZnSSe) ##########################\n,\'ZnSSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'ZnS\'\n    ,\'binary_1_x\' :\'ZnSe\'\n}\n#\n\n######### zinc magnesium selenide (ZnMgSe) ##########################\n,\'ZnMgSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MgSe\'\n    ,\'binary_1_x\' :\'ZnSe\'\n\n    ,\'lattice_consts\':{\n        \'a\'           :-0.7                                   # [Angstrom]    B. Jobst et al., APL 69, 97 (1996)\n    }\n    \n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.4 }                               # B. Jobst et al., APL 69, 97 (1996)\n    }\n}\n#\n\n######### cadmium zinc selenide (CdZnSe) ##########################\n,\'CdZnSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'CdSe\'\n    ,\'binary_1_x\' :\'ZnSe\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.245 }                            # ???\n        ,\'L\':    { \'bandgap\' :0.245 }                            # ???\n        ,\'X\':    { \'bandgap\' :0.245 }                            # ???\n    }\n\n    ,\'valence_bands\':{\n        \'bandoffset\'  :-0.105                                # ???\n    }\n\n}\n#\n\n######### cadmium zinc telluride (CdZnTe) ##########################\n,\'CdZnTe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'CdTe\'\n    ,\'binary_1_x\' :\'ZnTe\'\n}\n#\n\n######### mercury cadmium telluride (HgCdTe) ##########################\n,\'HgCdTe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'CdTe\'\n    ,\'binary_1_x\' :\'HgTe\'\n}\n#\n\n######### cadmium magnesium telluride (CdMgTe) ##########################\n,\'CdMgTe\':{\n    \'mat_crys_strc\'       :\'Cd(1-x)Mg(x)Te\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MgTe\'\n    ,\'binary_1_x\' :\'CdTe\'\n}\n#\n\n######### cadmium manganese telluride (CdMnTe) ##########################\n,\'CdMnTe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MnTe\'\n    ,\'binary_1_x\' :\'CdTe\'\n}\n#\n\n######### cadmium manganese selenide (CdMnSe) ##########################\n,\'CdMnSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MnSe\'\n    ,\'binary_1_x\' :\'CdSe\'\n}\n#\n######### zinc manganese telluride (ZnMnTe) ##########################\n,\'ZnMnTe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MnTe\'\n    ,\'binary_1_x\' :\'ZnTe\'\n}\n#\n\n######### zinc manganese selenide (ZnMnSe) ##########################\n,\'ZnMnSe\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MnSe\'\n    ,\'binary_1_x\' :\'ZnSe\'\n}\n#\n\n######### zinc cadmium sulfide (ZnCdS) ##########################\n,\'ZnCdS\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'ZnS\'\n    ,\'binary_1_x\' :\'CdS\'\n}\n#\n\n##########################################################################################\n##########################################################################################\n#          WURTZITE\n##########################################################################################\n##########################################################################################\n\n\n##########################################################################################\n##########################################################################################\n#          I N S U L A T O R S    A N D    M E T A L S\n##########################################################################################\n##########################################################################################\n\n######### air #############################################\n\n\n\n##########################################################################################\n##########################################################################################\n#          T E R N A R Y     A L L O Y S     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### indium gallium nitride (InGaN) ##############################\n,\'InGaN\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'InN\'\n    ,\'binary_1_x\' :\'GaN\'\n\n    ,\'pyroelectric_const\' :-0.037                                # Vurgaftman2 and O. Ambacher (Ambacher has different sign in bowing formula and bowing parameter which is okay.)\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :1.4 }                                 # Vurgaftman2\n    }\n}\n#\n\n######### aluminum gallium nitride (AlGaN) ############################\n,\'AlGaN\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlN\'\n    ,\'binary_1_x\' :\'GaN\'\n\n    ,\'pyroelectric_const\' :-0.021                                # Vurgaftman2 and O. Ambacher (Ambacher has different sign in bowing formula and bowing parameter which is okay.)\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.7 }                                 # Vurgaftman2\n    }\n}\n#\n\n######### aluminum indium nitride (AlInN) #############################\n,\'AlInN\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary_x\'   :\'AlN\'\n    ,\'binary_1_x\' :\'InN\'\n\n    ,\'pyroelectric_const\' :-0.070                                # Vurgaftman2 and O. Ambacher (Ambacher has different sign in bowing formula and bowing parameter which is okay.)\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :2.5 }                                 # Vurgaftman2\n    }\n}\n#\n\n######### magnesium zinc oxide (MgZnO) #############################\n,\'MgZnO\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'MgO\'\n    ,\'binary_1_x\' :\'ZnO\'\n\n    ,\'conduction_bands\':{\n        \'Gamma\':{ \'bandgap\' :0.56 }                                 # W.R.L. Lambrecht et al., MRS Internet J. Nitride Semicond. Res. 4S1, G6.8 (1999)\n    }\n\n}\n#\n\n######### cadmium zinc oxide (CdZnO) #############################\n,\'CdZnO\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'II_VI\'\n    ,\'binary_x\'   :\'CdO\'\n    ,\'binary_1_x\' :\'ZnO\'\n}\n#\n\n}\n\nalloyproperty4 ={\n##########################################################################################\n##########################################################################################\n#          Q U A T E R N A R Y     A L L O Y S     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n######### aluminum gallium indium nitride (AlGaInN) ###################\n\'AlGaInN_zb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlN_zb\'\n    ,\'binary2\'    :\'GaN_zb\'\n    ,\'binary3\'    :\'InN_zb\'\n    ,\'ternary12\'  :\'AlGaN_zb\'\n    ,\'ternary13\'  :\'AlInN_zb\'\n    ,\'ternary23\'  :\'InGaN_zb\'\n}\n#\n\n######### aluminum gallium indium phosphide (AlGaInP) #################\n,\'AlGaInP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlP\'\n    ,\'binary2\'    :\'GaP\'\n    ,\'binary3\'    :\'InP\'\n    ,\'ternary12\'  :\'AlGaP\'\n    ,\'ternary13\'  :\'AlInP\'\n    ,\'ternary23\'  :\'GaInP\'\n}\n#\n\n######### aluminum gallium indium arsenide (AlGaInAs) #################\n,\'AlGaInAs\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlAs\'\n    ,\'binary2\'    :\'GaAs\'\n    ,\'binary3\'    :\'InAs\'\n    ,\'ternary12\'  :\'AlGaAs\'\n    ,\'ternary13\'  :\'InAlAs\'\n    ,\'ternary23\'  :\'InGaAs\'\n}\n#\n\n######### aluminum gallium indium antimonide (AlGaInSb) ###############\n,\'AlGaInSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlSb\'\n    ,\'binary2\'    :\'GaSb\'\n    ,\'binary3\'    :\'InSb\'\n    ,\'ternary12\'  :\'AlGaSb\'\n    ,\'ternary13\'  :\'AlInSb\'\n    ,\'ternary23\'  :\'GaInSb\'\n}\n#\n\n######### aluminum arsenide antimonide phosphide (AlAsSbP) ############\n,\'AlAsSbP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlAs\'\n    ,\'binary2\'    :\'AlSb\'\n    ,\'binary3\'    :\'AlP\'\n    ,\'ternary12\'  :\'AlAsSb\'\n    ,\'ternary13\'  :\'AlAsP\'\n    ,\'ternary23\'  :\'AlPSb\'\n}\n#\n\n######### gallium arsenide antimonide phosphide (GaAsSbP) #############\n,\'GaAsSbP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'GaAs\'\n    ,\'binary2\'    :\'GaSb\'\n    ,\'binary3\'    :\'GaP\'\n    ,\'ternary12\'  :\'GaAsSb\'\n    ,\'ternary13\'  :\'GaAsP\'\n    ,\'ternary23\'  :\'GaPSb\'\n}\n#\n\n######### indium arsenide antimonide phosphide (InAsSbP) ##############\n,\'InAsSbP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'InAs\'\n    ,\'binary2\'    :\'InSb\'\n    ,\'binary3\'    :\'InP\'\n    ,\'ternary12\'  :\'InAsSb\'\n    ,\'ternary13\'  :\'InAsP\'\n    ,\'ternary23\'  :\'InPSb\'\n}\n#\n\n######### gallium indium arsenide phosphide (GaInAsP) #################\n,\'GaInAsP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'GaAs\'\n    ,\'binary2\'    :\'InAs\'\n    ,\'binary3\'    :\'InP\'\n    ,\'binary4\'    :\'GaP\'\n    ,\'ternary12\'  :\'InGaAs\'\n    ,\'ternary23\'  :\'InAsP\'\n    ,\'ternary34\'  :\'GaInP\'\n    ,\'ternary14\'  :\'GaAsP\'\n}\n#\n\n######### indium gallium arsenide nitride (InGaAsN) ###################\n,\'InGaAsN\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'InAs\'\n    ,\'binary2\'    :\'GaAs\'\n    ,\'binary3\'    :\'GaN_zb\'\n    ,\'binary4\'    :\'InN_zb\'\n    ,\'ternary12\'  :\'InGaAs\'\n    ,\'ternary23\'  :\'GaAsN\'\n    ,\'ternary34\'  :\'InGaN_zb\'\n    ,\'ternary14\'  :\'InAsN\'\n}\n#\n\n######### gallium indium arsenide antimonide (GaInAsSb) ###############\n,\'GaInAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'GaAs\'\n    ,\'binary2\'    :\'InAs\'\n    ,\'binary3\'    :\'InSb\'\n    ,\'binary4\'    :\'GaSb\'\n    ,\'ternary12\'  :\'InGaAs\'\n    ,\'ternary23\'  :\'InAsSb\'\n    ,\'ternary34\'  :\'GaInSb\'\n    ,\'ternary14\'  :\'GaAsSb\'\n}\n#\n\n######### aluminum gallium arsenide antimonide (AlGaAsSb) #############\n,\'AlGaAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlAs\'\n    ,\'binary2\'    :\'GaAs\'\n    ,\'binary3\'    :\'GaSb\'\n    ,\'binary4\'    :\'AlSb\'\n    ,\'ternary12\'  :\'AlGaAs\'\n    ,\'ternary23\'  :\'GaAsSb\'\n    ,\'ternary34\'  :\'AlGaSb\'\n    ,\'ternary14\'  :\'AlAsSb\'\n}\n#\n\n######### indium aluminum arsenide antimonide (InAlAsSb) ##############\n,\'InAlAsSb\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'InAs\'\n    ,\'binary2\'    :\'AlAs\'\n    ,\'binary3\'    :\'AlSb\'\n    ,\'binary4\'    :\'InSb\'\n    ,\'ternary12\'  :\'InAlAs\'\n    ,\'ternary23\'  :\'AlAsSb\'\n    ,\'ternary34\'  :\'AlInSb\'\n    ,\'ternary14\'  :\'InAsSb\'\n}\n#\n\n######### aluminum gallium arsenide phosphide (AlGaAsP) ##############\n,\'AlGaAsP\':{\n    \'mat_crys_strc\'       :\'Zincblende\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlAs\'\n    ,\'binary2\'    :\'GaAs\'\n    ,\'binary3\'    :\'GaP\'\n    ,\'binary4\'    :\'AlP\'\n    ,\'ternary12\'  :\'AlGaAs\'\n    ,\'ternary23\'  :\'GaAsP\'\n    ,\'ternary34\'  :\'AlGaP\'\n    ,\'ternary14\'  :\'AlAsP\'\n}\n#\n\n\n\n\n##########################################################################################\n##########################################################################################\n#          Q U A T E R N A R Y     A L L O Y S     --    III - V       V A L E N C E\n##########################################################################################\n##########################################################################################\n\n\n\n\n######### aluminum gallium indium nitride (AlGaInN) ###################\n,\'AlGaInN\':{\n    \'mat_crys_strc\'       :\'Wurtzite\'\n    ,\'valence\'    :\'III_V\'\n    ,\'binary1\'    :\'AlN\'\n    ,\'binary2\'    :\'GaN\'\n    ,\'binary3\'    :\'InN\'\n    ,\'ternary12\'  :\'AlGaN\'\n    ,\'ternary13\'  :\'AlInN\'\n    ,\'ternary23\'  :\'InGaN\'\n}\n#\n}\n\n'"
func_lib.py,17,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Aug 19 15:09:15 2019\n\n\n""""""\nimport numpy as np\nfrom math import*\nfrom scipy import sparse as sp\n\ndef DDGphin2n (V,phin,n):\n    """"""\n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{n}} = DDGphin2n(@var{V},@var{phin})\n    ##\n    ## Compute the electron density using Maxwell-Boltzmann statistics\n    ##\n    ## @end deftypefn\n    """"""\n    nmin = 0\n    n=  np.exp ((V-phin))\n    #n = n * (n>nmin) + nmin * (n<=nmin)\n    return n\n\ndef DDGphip2p (V,phip,p):\n    """"""\n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{p}} = DDGphip2p(@var{V},@var{phip})\n    ##\n    ## Compute the hole density using Maxwell-Boltzmann statistic\n    ##\n    ## @end deftypefn\n    """"""\n    ## Load constants\n    pmin = 0\n    p=  np.exp ((phip-V))\n    #p = p * (p>pmin) + pmin * (p<=pmin) \n    return p\n\ndef DDGn2phin (V,n):\n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n    ##\n    ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n    ##\n    ##  SECS1D is free software; you can redistribute it and/or modify\n    ##  it under the terms of the GNU General Public License as published by\n    ##  the Free Software Foundation; either version 2 of the License, or\n    ##  (at your option) any later version.\n    ##\n    ##  SECS1D is distributed in the hope that it will be useful,\n    ##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n    ##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    ##  GNU General Public License for more details.\n    ##\n    ##  You should have received a copy of the GNU General Public License\n    ##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n      \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{phin}} = DDGn2phin(@var{V},@var{n})\n    ##\n    ## Compute the qfl for electrons using Maxwell-Boltzmann statistics.\n    ##\n    ## @end deftypefn\n    """"""\n    ## Load constants\n    nmin = 0\n    #n    = n * (n>nmin) + nmin * (n<=nmin)\n    phin = V - np.log(abs(n))\n    \n    return phin\n\ndef DDGp2phip (V,p):\n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n    ##\n    ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n    ##\n    ## SECS1D is free software; you can redistribute it and/or modify\n    ## it under the terms of the GNU General Public License as published by\n    ## the Free Software Foundation; either version 2 of the License, or\n    ## (at your option) any later version.\n    ##\n    ## SECS1D is distributed in the hope that it will be useful,\n    ## but WITHOUT ANY WARRANTY; without even the implied warranty of\n    ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    ## GNU General Public License for more details.\n    ##\n    ## You should have received a copy of the GNU General Public License\n    ## along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n    \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{phip}} = DDGn2phin(@var{V},@var{p})\n    ##\n    ## Compute the qfl for holes using Maxwell-Boltzmann statistics\n    ##\n    ## @end deftypefn\n    """"""\n    ## Load constants\n    pmin = 0\n    #p    = p * (p>pmin) + pmin * (p<=pmin)\n    phip = V + np.log(abs(p)) \n      \n    return phip\n\ndef Ucompmass (nodes,n_max,elements,Nelements,Bvect,Cvect):\n    """"""\n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{R}} = Ucompmass(@var{nodes},@var{n_max},@var{elements},@var{Nelements},@var{Bvect},@var{Cvect})\n    ##\n    ## Compute P1 finite element mass-matrix:\n    ##\n    ## @itemize @minus\n    ## @item @var{nodes}: list of mesh nodes\n    ## @item @var{n_max}: number of mesh nodes\n    ## @item @var{elements}: list of mesh elements \n    ## @item @var{Nelements}: number of mesh elements\n    ## @item @var{Bvect}: piecewise linear reaction coefficient\n    ## @item @var{Cvect}: piecewise constant reaction coefficient\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """"""\n    h \t= (nodes[1:len(nodes)]-nodes[0:len(nodes)-1])*Cvect  \n    d0=np.zeros(n_max)\n    d0[0]=Bvect[0]*h[0]/2\n    d0[n_max-1]=Bvect[n_max-1]*h[len(h)-1]/2\n    d0[1:n_max-1]=Bvect[1:n_max-1]*(h[0:len(h)-1]+h[1:len(h)])/2\n    Bmat  = sp.spdiags(d0, [0], n_max,n_max).todense()      \n    return Bmat\n\ndef Ucomplap (nodes,n_max,elements,Nelements,coeff):\n    """"""\n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{R}} = Ucomplap(@var{nodes},@var{n_max},@var{elements},@var{Nelements},@var{coeff})\n    ##\n    ## Compute P1 finite element approximation of the differential operator:\n    ## \n    ##  - d ( coeff d (.)\\dx)\\dx\n    ##\n    ## @itemize @minus\n    ## @item @var{nodes}: list of mesh nodes\n    ## @item @var{n_max}: number of mesh nodes\n    ## @item @var{elements}: list of mesh elements \n    ## @item @var{Nelements}: number of mesh elements\n    ## @item @var{coeff}: piecewise linear reaction coefficient\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """"""\n    h \t= nodes[1:len(nodes)]-nodes[0:len(nodes)-1]\n    d0=np.zeros(n_max)\n    d0[0]=coeff[0]/h[0]\n    d0[n_max-1]=coeff[len(coeff)-1]/h[len(h)-1]\n    d0[1:n_max-1]=(coeff[0:len(coeff)-1]/h[0:len(h)-1])+(coeff[1:len(coeff)]/h[1:len(h)])\n    d1\t= np.zeros(n_max)\n    d1[0]=n_max\n    d1[1:n_max]=-coeff/h\n    dm1\t= np.zeros(n_max)\n    dm1[n_max-1]=n_max\n    dm1[0:n_max-1]=-coeff/h\n    L\t= sp.spdiags([dm1, d0, d1],np.array([-1,0,1]),n_max,n_max).todense()      \n    return L\n\ndef Ucompconst (nodes,n_max,elements,Nelements,D,C):\n    """"""\n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{R}} = Ucompconst(@var{nodes},@var{n_max},@var{elements},@var{Nelements},@var{D},@var{C})\n    ##\n    ## Compute P1 finite element rhs:\n    ##\n    ## @itemize @minus\n    ## @item @var{nodes}: list of mesh nodes\n    ## @item @var{n_max}: number of mesh nodes\n    ## @item @var{elements}: list of mesh elements \n    ## @item @var{Nelements}: number of mesh elements\n    ## @item @var{D}: piecewise linear reaction coefficient\n    ## @item @var{C}: piecewise constant reaction coefficient\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """""" \n    h = (nodes[1:len(nodes)]-nodes[0:len(nodes)-1])*C\n    R=np.zeros(n_max)\n    R[0]=D[0]*h[0]/2\n    R[n_max-1]=D[n_max-1]*h[len(h)-1]/2\n    R [1:n_max-1]=D[1:n_max-1]*(h[0:len(h)-1]+h[1:len(h)])/2\n    return R\n\n\ndef Ubernoulli(x,sg):\n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n      ##\n      ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n      ##\n      ##  SECS1D is free software; you can redistribute it and/or modify\n      ##  it under the terms of the GNU General Public License as published by\n      ##  the Free Software Foundation; either version 2 of the License, or\n      ##  (at your option) any later version.\n      ##\n      ##  SECS1D is distributed in the hope that it will be useful,\n      ##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n      ##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n      ##  GNU General Public License for more details.\n      ##\n      ##  You should have received a copy of the GNU General Public License\n      ##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n    \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File} {@var{b}} = Ubernoulli(@var{x},@var{sg})\n    ##\n    ## Compute Bernoulli function for vector x:\n    ##\n    ## @itemize @minus\n    ## @item @var{b} = @var{x}/(exp(@var{x})-1) if @var{sg} == 1\n    ## @item @var{b} = @var{x} + B( @var{x} ) if @var{sg} == 0\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """"""\n    bernp=np.zeros(len(x))\n    bernn=np.zeros(len(x))\n    \n    for count in range (len(x)):\n        [bp,bn] = Ubern(x[count])\n        \n        bernp[count]=bp\n        bernn[count]=bn\n      \n    if (sg ==1):\n        b=bernp\n    elif (sg ==0):\n        b=bernn\n    return b\n\n\ndef Ubern(x):\n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n      ##\n      ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n      ##\n      ##  SECS1D is free software; you can redistribute it and/or modify\n      ##  it under the terms of the GNU General Public License as published by\n      ##  the Free Software Foundation; either version 2 of the License, or\n      ##  (at your option) any later version.\n      ##\n      ##  SECS1D is distributed in the hope that it will be useful,\n      ##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n      ##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n      ##  GNU General Public License for more details.\n      ##\n      ##  You should have received a copy of the GNU General Public License\n      ##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n    \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File} {@var{bp},@var{bn}} = Ubern(@var{x})\n    ##\n    ## Compute Bernoulli function for scalar x:\n    ##\n    ## @itemize @minus\n    ## @item @var{bp} = @var{x}/(exp(@var{x})-1)\n    ## @item @var{bn} = @var{x} + B( @var{x} )\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """"""      \n    xlim=1e-2\n    ax=abs(x)\n    ## Compute Bernoulli function for x = 0\n    if (ax == 0):\n      bp=1.\n      bn=1.\n      return [bp,bn]    \n    ## Compute Bernoulli function for asymptotic values    \n    if (ax > 80):\n        if (x > 0):\n          bp=0.\n          bn=x\n          return [bp,bn]\n        else:\n          bp=-x\n          bn=0.\n          return [bp,bn]    \n    ## Compute Bernoulli function for intermediate values    \n    if (ax > xlim):\n       bp=x/(exp(x)-1)\n       bn=x+bp\n       return [bp,bn]\n    else:\n       ## Compute Bernoulli function for small x\n       ## via Taylor expansion    \n       ii=1\n       fp=1.\n       fn=1.\n       df=1.\n       segno=1.\n       while (abs(df) >np.finfo(np.float).eps):#eps on octave 2.220446049250313e-16\n         ii=ii+1\n         segno=-segno\n         df=df*x/ii\n         fp=fp+df\n         fn=fn+segno*df\n         bp=1/fp\n         bn=1/fn\n       return [bp,bn]    \n    return [bp,bn]\n\n\ndef Uscharfettergummel(nodes,n_max,elements,Nelements,acoeff,bcoeff,v):\n    \n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n      ##\n      ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n      ##\n    ## SECS1D is free software; you can redistribute it and/or modify\n      ##  it under the terms of the GNU General Public License as published by\n      ##  the Free Software Foundation; either version 2 of the License, or\n      ##  (at your option) any later version.\n      ##\n    ## SECS1D is distributed in the hope that it will be useful,\n      ##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n      ##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n      ##  GNU General Public License for more details.\n      ##\n      ##  You should have received a copy of the GNU General Public License\n    ## along with SECS1D; If not, see <http://www.gnu.org/licenses/>.\n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n    \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{R}} = Uscharfettergummel(@var{nodes},@var{n_max},@var{elements},@var{Nelements},@var{acoeff},@var{bcoeff},@var{v})\n    ##\n    ## Build the Scharfetter-Gummel matrix for the the discretization of\n    ## the LHS of the Drift-Diffusion equation:\n    ##\n    ##  -(a(x) (u\' - b v\'(x) u))\'= f\n    ##\n    ## @itemize @minus\n    ## @item @var{nodes}: list of mesh nodes\n    ## @item @var{n_max}: number of mesh nodes\n    ## @item @var{elements}: list of mesh elements \n    ## @item @var{Nelements}: number of mesh elements\n    ## @item @var{acoeff}: piecewise linear diffusion coefficient\n    ## @item @var{bcoeff}: piecewise constant drift constant coefficient\n    ## @item @var{v}: piecewise linear drift potential\n    ## @end itemize\n    ##\n    ## @end deftypefn\n    """"""     \n    h=nodes[1:n_max]-nodes[0:n_max-1]     \n    c=acoeff[0:n_max-1]/h\n    \n    Bneg=Ubernoulli(-(v[1:n_max]-v[0:n_max-1])*bcoeff,1)\n    Bpos=Ubernoulli( (v[1:n_max]-v[0:n_max-1])*bcoeff,1)\n    \n    d0=np.zeros(n_max)\n    d0[0]=c[0]*Bneg[0]\n    d0[n_max-1]=c[len(c)-1]*Bpos[len(Bpos)-1]\n    d0[1:n_max-1]=c[0:len(c)-1]*Bpos[0:len(Bpos)-1]+c[1:len(c)]*Bneg[1:len(Bneg)]\n    \n    d1\t= np.zeros(n_max)\n    d1[0]=n_max\n    d1[1:n_max]=-c* Bpos \n    \n    dm1\t= np.zeros(n_max)\n    dm1[n_max-1]=n_max\n    dm1[0:n_max-1]=-c* Bneg \n    A = sp.spdiags([dm1, d0, d1],np.array([-1,0,1]),n_max,n_max).todense()\n    return A\n\n\ndef Umediaarmonica(w):\n    """"""\n    ## Copyright (C) 2004-2008  Carlo de Falco\n      ##\n      ## SECS1D - A 1-D Drift--Diffusion Semiconductor Device Simulator\n      ##\n      ##  SECS1D is free software; you can redistribute it and/or modify\n      ##  it under the terms of the GNU General Public License as published by\n      ##  the Free Software Foundation; either version 2 of the License, or\n      ##  (at your option) any later version.\n      ##\n      ##  SECS1D is distributed in the hope that it will be useful,\n      ##  but WITHOUT ANY WARRANTY; without even the implied warranty of\n      ##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n      ##  GNU General Public License for more details.\n      ##\n      ##  You should have received a copy of the GNU General Public License\n      ##  along with SECS1D; If not, see <http://www.gnu.org/licenses/>.     \n    ##\n    ## author: Carlo de Falco <cdf _AT_ users.sourceforge.net>\n        \n    ## -*- texinfo -*-\n    ##\n    ## @deftypefn {Function File}@\n    ## {@var{m}} = Umediarmonica(@var{w})\n    ##\n    ## Return the harmonic mean value of @var{w}\n    ##\n    ## @end deftypefn\n    """"""     \n    dw = (1/w[0:len(w)-1])+(1/w[1:len(w)])\n    m  = 2 / dw\n    return m\n'"
intersubband_optical_transitions.py,74,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2018 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n\nFile Information:\n-----------------\nThis module calculates the optical intersubband transitions (ISBTs) for the \nconduction band levels.\n\nThe module can be run as a script, it will calculate the ISBTs for the inputfile\ndefined in the config.py module.\n\nTo learn how to apply the module to your needs, it is best to study the code for\nthe plotting_absorption() function and the code within the \'if __name__==""main""\'\nsection at the bottom of the module. The module consists of a collection of \nfunctions, each of which is commented and so it should be relatively easy to work\nout what each function does.\n\nIf you just want to calculate the intersubband absorption though, this is some \nexample code:\n\n    results = aestimo.Poisson_Schrodinger(model) \n    #see aestimo.py for defining the model object or the code at the bottom of this module\n    \n    transitions_table,(hdr,units)=transitions(results,Lperiod,eps_z,linewidths)\n    \n    wya,Ry2a = calc_wR_multiplasmon(results,transitions_table,eps_z)\n    #print \'matrix method results\'; print_multiplasmon_transitions(wya,Ry2a)\n    \n    inv_eps_zz = inv_eps_zz_multiplasmon(wya,Ry2a,transitions_table,linewidth,freqaxis,eps_z)\n    #linewidth can be a value or a function dependent upon the transition frequency.\n    eps_ratio = eps_b*inv_eps_zz\n    absorption = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio,nk,d)\n\n\n\nTheory Notes:\n\nIntersubband transitions (ISBTs) in a quantum well occur between the well\'s \ndifferent levels but stay within a single band. This is in contrast to\ninterband transitions between the valence and conduction bands, those transitions\nmostly occur in the visible and near-infrared and are used for LEDs, lasers and \ndetectors. Intersubband transitions occur in the mid- to far- infrared and are \nused for quantum cascade lasers and mid-infrared detectors etc.\n\nThe strongest transitions are electric dipole transitions and so we need to\ncalculate the dipole matrix elements of the transitions. However, ISBTs have some\nadditional complications to a standard dipole transition. Firstly, they are \npolarisation sensitive in that they can only couple to light polarised perpendicular\nto the quantum well plane. Secondly, there are complications since there are \nmany electrons in the quantum well layers; one such complication is that we can\nconsider the transition as a plasma and the effect of the depolarisation field\ninduced within the plasma when interacting with an electric field leads to a \nshift of the peak\'s position (called the depolarisation shift). The plasma \nbehaviour of the transition is also referred to as the collective excitation of \nthe electrons since it the effect of the electrons on each other. \n\nThere are even some more advanced effects that can often be ignored (and have been \nin the models implemented here). So there is another frequency shift due to the exchange \ninteraction between the electrons but this is much smaller that the depolarisation \nshift. We may also need to account for the non-parabolicity of the subbands and \nthe different effective masses of the different layers (and so would need to integrate \nover k-space). Finally, we may need to consider the free electron absorption from \nelectrons moving within the plane of the well (for instance using a Drude model). \nVery rarely we may need to include weaker transitions such as the magnetic dipole, \nelectric quadrupole.\n\nFor the collective excitation, we need to calculate of the plasma density of the \ntransition. This is not as simple as it first appears, since we shouldn\'t just use\nthe width of the well to define the density but calculate an effective length\nusing the two level\'s wavefunctions. The equation is a little complicated but can\nbe found in ?? and is given below.\n\nLeff_ij = hbar**2/(2*S_ijij*meff*hbar*w_ij)\n\nwhere meff is the effective mass and w_ij is the transition frequency (natural) and\n\nS_ijij = integral_0_inf( Psi_i(z).Psi_j(z).integral_0_z( integral_0_z\'( Psi_i(z\'\').Psi_j(z\'\') )dz\'\' )dz\' )dz\n\nWe can account for the collective excitation effect as it is included automatically \nif we calculate the absorption of an anisotropic absorbing layer (where I mean\nabsorbing like an ISBT absorbs). This can be done using classical electromagnetism\nand we find that the absorption is given by\n\nabs ~ (epsilon_b/epsilon_zz).imag . n_b.(w/c).(sin(theta)**2/cos(theta))*d\n\nwhen there is nothing absorbing in-plane and the dielectric constants apart from\nthe ISBTs are all epsilon_b. So we see that the absorption depends upon the inverse\nof the dielectric constant rather than proportionally like usual. \n\nFor a QW containing a single dominant ISBT transition, the dielectric constant\ncan be given by an effective medium approach. This means that we calculate the\neffective dielectric constant for the QW + its barriers ie. one period of the\nstructure. Since the wavefunctions of the QW penetrate the barriers, this approach\nseems more appropriate than considering the QW and the barriers separately. Assuming\nthat the QW amd the barriers have the same dielectric constants:\n\neps_b/eps_z01 = 1 - (Leff/LSQW).w_p01**2.f01 / ( w01**2 +w_p01**2 - w**2 + 2j.y01.w01 )\n\nwhere\nw01 - transition frequency (natural) from difference in energy levels\nf01 - oscillator strength = 2.meff.w01.mu01 / (q**2.hbar**2 )\nmu01 - dipole matrix element = integral_0_inf( Psi_0(z).z.Psi_1(z) )dz\nw_p01 - plasma frequency = dN.q**2/(meff.eps_b.eps_0)\ndN - population difference between subbands (m**-2)\ny01 - transition broadening (same units as w01)\n\nSince the effective mass of each level is different in aestimo, it is not immediately clear\nwhat value to use when calculating the parameters above that characterise the transition. \nHowever, in the more advanced models it turns out not to be important for the final transition\nsince all of the effective mass terms cancel out in the final expression.\n\nNote on Dielectric Constants\neps_z - array of dielectric constants wrt. z for layers withing the effective medium (excluding ISBTs)\neps_b - dielectric constant of media surrounding the effective medium/QW structure\n      - or sometimes just the background dielectric constant.\neps_w - dielectric constant for well layer or rather an weighted average of the dielectric\n        constants seen by the ground state.\n\nImportant:\nTo use the results from aestimo with these functions, we need to normalise the wavefunctions\n    dx = results.dx #m\n    wfe = results.wfe*dx**-0.5\n    \nImportant:\nKeep track of whether you are dealing with real or natural frequencies.\n\n""""""\n\nimport numpy as np\nfrom scipy.integrate import simps\nimport matplotlib.pyplot as pl\nfrom itertools import combinations,permutations\nimport types\nfrom scipy.linalg import eigh,eig\n\nif __package__: #explicit relative imports for using aestimo as a package (in python3)\n    from .aestimo import round2int,logger\nelse:\n    from aestimo import round2int,logger\n\nsin,cos,log,exp = np.sin,np.cos,np.log,np.exp\n\n#Defining constants and material parameters\nq = 1.602176e-19 #C\nkb = 1.3806504e-23 #J/K\nh = 6.62606957e-34 #m2kg/s\nhbar = 1.054588757e-34\nm_e = 9.1093826E-31 #kg\npi = np.pi\neps0 = 8.8541878176e-12 #F/m\nc = 299792458 #m/s\n\nJ2meV=1e3/q #Joules to meV\nmeV2J=1e-3*q #meV to Joules\nf2w = 1e12*2*pi #THz to Hz (natural)\n\ndef eig_sorted(A):\n    """"""returns the results from scipy.eig eigenvalue solver sorted in\n    ascending eigenvalue order""""""\n    Adiag,U = eig(A,right=True)\n    order = np.argsort(Adiag)\n    return Adiag[order],U[:,order]    \n\n\n# Electromagnetism\n# -------------------------\n\n# Standard absorption coefficient for a transition\n\ndef absorption_standard(w,epsilon,d):\n    """"""Calculates the absorption for a material from its dielectric \n    \'constant\'. However, this is not really suitable for modelling\n    the absorption of intersubband transitions in quantum wells.\n    w - natural frequency (Hz)\n    epsilon - dielectric constant\n    d - distance (m)\n    """"""\n    return 2*w*np.sqrt(epsilon).imag*d/c\n\n# Absorption of uniaxial absorbing layer\n\ndef uniaxial_layer_absorption(theta,w,eps_ratio,nk,d):\n    """"""Approximately calculates the absorption of a uniaxial layer\n    which absorbs along its extraordinary axis which is perpendicular\n    to the plane of the layer. Basically, this is the situation for \n    an intersubband transition of a quantum well. More accurate modelling\n    requires a transfer matrix model that can account for these uniaxial\n    layers (i.e. see pyLuminous/pyFresnel module).\n    theta - angle (rad)\n    w - natural frequency(ies)\n    eps_ratio  = eps_b/eps_zz = eps_background/eps_layer(out of plane component)\n    nk - refractive index of media surrounding uniaxial layer\n    d - thickness of layer (m).\n    """"""\n    return -eps_ratio.imag*nk*w/c*sin(theta)**2/cos(theta)*d\n\n# Lorentzian oscillator model\n\ndef susceptibility_Losc(w,w0,f,w_p,y0,eps_b=1.0):\n    """"""Dielectric Susceptibility for the Lorentzian oscillator model\n    f - oscillator strength (unitless)\n    The following should all use the same units i.e Hz or meV, natural frequency\n    or real frequency ...\n    w_p - plasma frequency \n    w - frequency axis\n    w0 - transition frequency\n    y0 - transition broadening\n    \n    eps_b is the background dielectric constant, it is included because w_p usually\n    includes eps_b in its definition and so it is necessary to include this factor\n    for this formula to calculate the susceptibility. Only really interesting when using\n    a frequency dependent background dielectric constant, as it slightly affects \n    how we calculate the \'total\' dielectric constant. It\'s the difference between \n    having to using the result from this function as \n    eps_b = eps_b0.(1 + Xi + Xi2...) \n    or (by including eps_b!=1.0 here) as\n    eps_b = epsb0 + Xi + Xi2 +...  \n    """"""\n    chi = (eps_b*w_p**2)*f / ( w0**2 - w**2 - 2j*y0*w )\n    return chi\n\n# Effective medium\n\ndef eff_eps_z(layer_list,isbt_term=0.0):\n    """"""calculates the effective dielectric constant for a stack\n    of thin layers for the direction perpendicular to the plane\n    of the layers, the layers\' thicknesses should be less than\n    the wavelengths of the light spectrum considered for this to\n    work effectively.\n    layer_list - list of (eps_z,f) tuples where f is the fraction\n    of the total thickness filled by that dielectric constant.\n    isbt_term - is the contribution of the intersubband transitions\n    to the effective medium (see Zaluzny PRB1999, Ando1977 and Ando1982)\n    """"""\n    eps_z = 1.0/sum([f/eps_z for eps_z,f in layer_list],isbt_term)\n    return eps_z\n    \ndef eff_eps_z2(eps_z,isbt_term=0.0):\n    """"""calculates the effective dielectric constant for a stack\n    of thin layers for the direction perpendicular to the plane\n    of the layers, the layers\' thicknesses should be less than\n    the wavelengths of the light spectrum considered for this to\n    work effectively.\n    eps_z - an array of values wrt z (uniformly spaced)\n          - or a 2d array of values wrt z and w (frequency axis).\n    isbt_term - is the contribution of the intersubband transitions\n    to the effective medium (see Zaluzny PRB1999, Ando1977 and Ando1982)\n    """"""\n    eps = 1.0/sum(np.mean(np.atleast_1d(1.0/eps_z),axis=0),isbt_term)\n    return eps\n    \ndef eff_eps_x(layer_list):\n    """"""calculates the effective dielectric constant for a stack\n    of thin layers for the direction parallel to the plane of\n    the layers, the layers\' thicknesses should be less than\n    the wavelengths of the light spectrum considered for this to\n    work effectively.\n    layer_list - list of (eps_x,f) tuples where f is the fraction\n    of the total thickness filled by that dielectric constant.\n    """"""\n    eps_x = sum([f*eps_x for eps_x,f in layer_list])\n    return eps_x\n    \ndef eff_eps_x2(eps_x):\n    """"""calculates the effective dielectric constant for a stack\n    of thin layers for the direction parallel to the plane of\n    the layers, the layers\' thicknesses should be less than\n    the wavelengths of the light spectrum considered for this to\n    work effectively.\n    eps_z - an array of values wrt z (uniformly spaced)\n          - or a 2d array of values wrt z and w (frequency axis).\n    layer_list - list of (eps_x,f) tuples where f is the fraction\n    of the total thickness filled by that dielectric constant.\n    """"""\n    eps = np.mean(np.atleast_1d(eps_x),axis=0)\n    return eps\n\n\n# Singular Electric Dipole Transitions (each transition is treated separately)\n# ------------------------------------\n\ndef dipole_matrix(z,wfe1,wfe2):\n    """"""Calculates dipole matrix element numerically. Returns values in metres\n    (electron charge is not included in calculation)""""""\n    return simps(z*wfe1*wfe2,z)\n\ndef oscStr(z_if,w_if,cb_meff):\n    """"""Calculates oscillator strength. \n    w_if - frequency of transition (meV),\n    cb_meff - relative effective electron mass in well layer, \n    z_if - dipole matrix element for position operator (m).""""""\n    return 2*cb_meff*(w_if*meV2J)*z_if**2/hbar**2\n\ndef calc_S(Psi0,Psi1,Psi2,Psi3,dz):\n    """"""Calculates S, a quantity used to calculate the effective thickness of an\n    intersubband transition of a quantum well.\n    Psi0 - Psi3 are arrays describing the wavefunctions.\n    dz is the step-size (metres) for the arrays (assumed to be constant).\n    """"""\n    i1=0.0; i2=0.0; i3=0.0\n    for p0,p1,p2,p3 in zip(Psi0,Psi1,Psi2,Psi3):\n        delta = p0*p1\n        i1+=delta\n        i2+=i1\n        i3+=p2*p3*i2\n    i3*=dz**3\n    return -i3\n\ndef calc_S_b(Psi0,Psi1,Psi2,Psi3,zaxis):\n    """"""Calculates S, a quantity used to calculate the effective thickness of an\n    intersubband transition of a quantum well.\n    Psi0 - Psi3 are arrays describing the wavefunctions.\n    zaxis is an array of z-values for the wavefunctions (needn\'t be uniform) (metres)\n    """"""\n    dz_axis = zaxis[1:]-zaxis[:-1]\n    dz_axis = np.hstack((dz_axis[0],dz_axis)) #preprend a value so that all values get used in calculation\n    i1=0.0; i2=0.0; i3=0.0\n    for p0,p1,p2,p3,z,dz in zip(Psi0,Psi1,Psi2,Psi3,zaxis,dz_axis):\n        delta = p0*p1\n        i1+=delta\n        i2+=z*delta\n        i3+=p2*p3*(z*i1 - i2)*dz**2\n    return -i3\n\ndef L_eff(w_if,S_if,cb_meff):\n    """"""Calculates the effective thickness of an intersubband transition of a quantum well.\n    w_if is the transitions frequency in meV, \n    cb_meff is the relative effective electron mass in well layer, \n    S is a dimensionless quantity calculated via an integral. \n    Returns a value in metres""""""\n    return hbar**2/(2*abs(S_if)*cb_meff*w_if*meV2J)\n\ndef calc_w_p(dn_if,cb_meff,eps_w):\n    """"""Calculates the plasma frequency of a transition. returns real Hz.\n    dn_ij - (m**-3) population density difference between the initial and final levels\n    cb_meff - effective electron mass for transition\n    eps_w - background dielectric constant in well layer(approximately)\n    """"""\n    return np.sqrt(dn_if*q**2/(cb_meff*eps_w*eps0))/(2*pi) #real Hz\n    \ndef calc_R2(w_if,z_if,dn_if,eps_w,Lperiod):\n    """"""R**2 = f*Leff*w_p**2/Lperiod (oscillator strength * plasma frequency squared)\n    This is more useful for quicky seeing the strength of a transition\n    than either the plasma frequency or the oscillator strength alone.\n    Also we see that there is no need to know the effective mass for this expression.\n    Units of R are Hz (real).\n    w_if - frequency of transition (meV)\n    z_if - dipole matrix element for position operator (m)\n    dn_if - (m**-3) population density difference between the initial and final levels\n    eps_w - background dielectric constant in well layer (approximately)\n    Lperiod - thickness of effective medium, this is the QW plus some barrier each side\n            (normally this is the period length in a multiple QW stack). Whatever you use\n            for Lperiod, you should use for \'d\' when calculating the ISBT absorptions.\n    """"""\n    return 2*dn_if*(w_if*meV2J)*(q*z_if)**2/(hbar**2*(eps_w*eps0)*eps_w*Lperiod*(2*pi)**2) \n\n# Summary of Transitions\n\ndef transition_generator(seq):\n    """"""returns the possible pairs in the input sequence. Each pair is\n    only returned once and the ordering found in the input is maintained""""""\n    return combinations(seq,2)\n\ndef transitions(results,Lperiod,eps_z,linewidths):\n    """"""Calculates the parameters needed to describe the intersubband transitions.\n    Returns a list of dictionaries (one for each transition) with the following \n    keys:\n    \'ilevel\',\'flevel\',\'dE\',\'freq\',\'lambda\',\'wavno\',\'dN\',\'z_if\',\'f\',\'Leff\',\'S_if\',\'S_if_b\',\'wp\'\n    \n    results - object created by aestimo containing results of the bandstructure simulation\n    Lperiod - (m) length (m), thickness of effective medium containing heterostructure \n              i.e. should be equal or larger than extent of the structures wavefunctions.\n    eps_z   - (unitless) dielectric constant array wrt position. Giving dielectric constant \n              of the structure\'s materials at the optical frequencies of interest.\n    linewidths - (THz) a number or function that gives/returns the transition linewidths. If\n              using a function, it should take the transition frequency (THz) as a parameter.\n    """"""\n    E_state = results.E_state #list of energy levels (meV)\n    N_state = results.N_state #occupation of energy levels (m**-2)\n    meff_state = results.meff_state #effective mass of each state\n    T = results.T #K\n    dx = results.dx #m\n    xaxis = results.xaxis #m\n    wfe = results.wfe*dx**-0.5 # normalising wavefunctions to be m**-0.5\n    #reversethepolarities = np.ones(wfe.shape[0])\n    #reversethepolarities[1::2]*=-1\n    #for j,p in enumerate(reversethepolarities):wfe[j]*=p\n    \n    #calculate the mean dielectric constant as for the heterostructure\n    #using the lowest subband of the system.\n    eps_w = 1.0/(np.sum(wfe[0]**2/eps_z,axis=0)*dx)\n    \n    #create linewidth function\n    if type(linewidths) is types.FunctionType:\n        lw = linewidths\n    else:\n        lw = lambda freq: linewidths\n    \n    \n    def transition(j,i,f): #Doing it this way would let me create a dielectric function for each transition using a function closure.\n        """"""j - transition number (useful later)\n           i - initial level\n           f - final level\n        """"""\n        # Most of the standard transition parameters include effective mass in their\n        # formulae, Should we use the effective mass of the initial or final state, \n        # or some combination? However, currently, in the more advanced version of \n        # the dielectric constant calculation it seems that all effective mass terms \n        # cancel out. Therefore, I will use the effective mass for lowest subband for\n        # all my calculations.\n        cb_meff= meff_state[0] # kg\n        # Likewise, many quantities include a dielectric constant in their calculation,\n        # but what value should we use when a wavefunction extends over many different\n        # layers. To keep things simple, we will use the mean dielectric constant as\n        # calculated using the lowest subband of the system.\n        eps_wi = eps_w #= sum(eps_b*wfe[0]**2)*dx\n        \n        dE = E_state[f]-E_state[i] #meV\n        dN = N_state[i]-N_state[f] #m**2\n        z_if = dipole_matrix(xaxis,wfe[i],wfe[f]) #m\n        S_if = calc_S(wfe[i],wfe[f],wfe[i],wfe[f],dx) #m\n        S_if_b = calc_S_b(wfe[i],wfe[f],wfe[i],wfe[f],xaxis) #m\n        L_if = L_eff(dE,S_if,cb_meff) #m\n        \n        col = {\'j\':j,\n               \'ilevel\':i,\n               \'flevel\':f,\n               \'dE\':dE, #meV\n               \'freq\':dE*1e-3*q/h/1e12, #THz (real)\n               \'lambda\':1e6*h*c/(dE*1e-3*q), #(um)\n               \'wavno\':dE*1e-3*q/h/c*1e-2, #(cm**-1)\n               \'dN\':dN*10**(-4-11), #dN (m-2)\n               \'z_if\':z_if*1e9, # z (dipole matrix element) (nm)\n               \'f\':oscStr(z_if,dE,cb_meff), #f (oscillator strength)\n               \'Leff\':L_if*1e9, #nm\n               \'S_if\':S_if*1e9,  #nm\n               \'S_if_b\':S_if_b*1e9,\n               \'wp\':calc_w_p(dN/L_if,cb_meff,eps_wi)*1e-12, #real THz\n               \'R\':np.sqrt(calc_R2(dE,z_if,dN,eps_wi,Lperiod))*1e-12, #real THz\n               \'Lperiod\':Lperiod*1e9, #nm\n               \'eps_w\':eps_wi,\n               }\n        col[\'y_if\'] = lw(col[\'freq\']) #(THz real) transition broadening\n        return col\n    \n    transitions_table = []\n    for j,(i,f) in enumerate(transition_generator(np.arange(len(E_state)))):\n        col = transition(j,i,f)\n        transitions_table.append(col)\n    \n    hdr=[\'j\',\'ilevel\',\'flevel\',\'dE\',\'freq\',\'lambda\',\'wavno\',\'dN\',\'z_if\',\'f\',\'Leff\',\'S_if\',\'S_if_b\',\'wp\',\'R\',\'Lperiod\',\'y_if\',\'eps_w\']\n    units=[\'\',\'\',\'\',\'meV\',\'THz\',\'um\',\'cm-1\',\'1e11cm-2 @%gK\'%T,\'nm\',\'\',\'nm\',\'nm\',\'nm\',\'THz\',\'THz\',\'nm\',\'THz\',\'\']\n    \n    return transitions_table,(hdr,units)\n\n\ndef print_levels(results):\n    """"""prints out energy levels and their populations to the log. Also\n    print out their gaps""""""\n    logger.info(\'the energy levels\\population are (meV)\\t(m**-2):\')\n    for Ei,Ni in zip(results.E_state,results.N_state): logger.info(\'%.5g\\t%.5g\',Ei,Ni)\n    logger.info(\'T = %gK\' %results.T)\n    logger.info(\'the energy levels gaps are\')\n    logger.info(\'\\t\'.join((\'(meV)\',\'(THz)\',\'(um)\',\'(wavno)\')))\n    for leveli,levelj in transition_generator(results.E_state):\n        gap=levelj-leveli\n        freq=gap*1e-3*q/h/1e12\n        wav=1e6*h*c/(gap*1e-3*q)\n        wavno=gap*1e-3*q/h/c*1e-2\n        logger.info(\'\\t\'.join(\'%.3g\' %i for i in (gap,freq,wav,wavno)))\n    \ndef print_transitions(transitions_table,hdr,units):\n    """"""print out summary of transition values to the log"""""" \n    printwidth = np.get_printoptions()[\'linewidth\']\n    var_w = 8 #print width for variable names\n    unit_w = 14 #print width for units\n    data_w = 11 #print width for data\n    # find number of repeats needed\n    cols_per_repeat = (printwidth - var_w - unit_w)//data_w\n    \n    def repeat_generator(n,cols_per_repeat):\n        startindex = 0\n        while startindex < n:\n            yield slice(startindex,startindex+cols_per_repeat)\n            startindex += cols_per_repeat\n    \n    logger.info( ""Summary of Intersubband Transitions"")\n    for selection in repeat_generator(len(transitions_table),cols_per_repeat):\n        data = transitions_table[selection]\n        for var,unit in zip(hdr,units):\n            row = [var.rjust(var_w),unit.rjust(unit_w)]\n            row += [(\'%.3g\' %tr[var].real).rjust(data_w) for tr in data]\n            logger.info( \'\'.join(row))\n\ndef get_Leff_est(transitions_table):\n    """"""gets a value of Leff for the QW that will be applied to all transitions.\n    We will use the Leff of the transition with the highest oscillator strength.""""""\n    j = np.argmax([tra[\'R\'] for tra in transitions_table])\n    return transitions_table[j][\'Leff\']\n    \n## Calculating Dielectric Constants\n# Below we have some different models for intersubband transitions\n\ndef inv_eps_zz_1(transitions_table,freqaxis,eps_z):\n    """"""calculates eps_b/eps_zz using the analytically correct result for a single transition.\n    If there are several active transitions that are close together then this will\n    become increasingly incorrect. The dielectric constant is calculated for the \n    effective medium of QW + barrier. However, there is an assumption here that\n    eps_background = eps_barrier = eps_well_layer""""""\n    isbt_term = 0.0\n    for trn in transitions_table: #nb. first row of table describes the units of each variable\n        w_if = np.sqrt(trn[\'freq\']**2 + trn[\'wp\']**2) #depolarisation shifted frequency\n        Xi = susceptibility_Losc(freqaxis,w0=w_if,f=1.0,w_p=trn[\'R\'],y0=trn[\'y_if\'])\n        #print trn[\'R\'],np.sqrt(trn[\'f\']*trn[\'wp\']**2*trn[\'Leff\']/trn[\'Lperiod\'])\n        isbt_term -= Xi\n    inv_eps_zz = np.mean(np.atleast_1d(1.0/eps_z),axis=0) + isbt_term\n    return inv_eps_zz\n\ndef eps_classical(transitions_table,freqaxis,eps_b=1.0):\n    """"""Approximately calculates total dielectric constant epszz for QW by summing Lorentz \n    oscillator susceptibilities for each transition. This assumes that all transitions \n    share the same effective Length (which wasn\'t assumed when calculating the plasma \n    frequency values (wp) contained in the transitions_table). The average effective length \n    for all of the ISBTs of the QW will have to be used as a fitting parameter in order to\n    get the best fit.\n    \n    If you leave eps_b=1.0 then the result should be multiplied by eps_b, if you use eps_b\n    then you shouldn\'t need to do anything. In either case it should match the values used \n    for calculating the transition plasma frequencies.\n        \n    warning - This shouldn\'t be used on its own for modelling ISBTs using absorption_standard()\n    to calculate the absorption since this doesn\'t take into account the anisotropic nature\n    of the ISBTs and the resulting depolarisation shift.\n    \n    """"""\n    eps = eps_b\n    for trn in transitions_table: #nb. first row of table describes the units of each variable\n        Xi = susceptibility_Losc(freqaxis,w0=trn[\'freq\'],f=trn[\'f\'],w_p=trn[\'wp\'],y0=trn[\'y_if\'],eps_b=eps_b)\n        eps+=Xi\n    return eps\n\ndef inv_eps_zz_classical(transitions_table,freqaxis,eps_z):\n    """"""Calculates the dielectric constant for an effective medium containing \n    intersubband transitions using a classical approach (Lorentz oscillators &\n    formula for effective medium).\n    Slab model?\n    """"""\n    eps_w = transitions_table[0][\'eps_w\']\n    if True:        \n        eps_qw = eps_w*eps_classical(transitions_table,freqaxis) \n    else: \n        eps_qw = eps_classical(transitions_table,freqaxis,eps_b=eps_w) #?? what\'s the point??\n    \n    Lperiod = transitions_table[0][\'Lperiod\'] #nm\n    Lqw = get_Leff_est(transitions_table) #(nm) \n    #using the effective length for the first transition as an estimate of the thickness of the 2d electron gas contained within the QW\n    ff = Lqw/Lperiod\n    #inv_eps_zz = ((1.0-ff)/eps_bb + ff/eps_qw) \n    inveps_bb_term = np.mean(np.atleast_1d(1.0/eps_z),axis=0) - ff/eps_w\n    inv_eps_zz = inveps_bb_term + ff/eps_qw\n    #eff_eps_z(layer_list,isbt_term=0.0)\n    return inv_eps_zz\n\n## Advanced Multilevel Model #################\n## frequency independent dielectric constant\n\ndef dipole_matrix_b(z,wfe1,wfe2,eps_z):\n    """"""Calculates something similar to the dipole matrix element numerically. \n    Returns values in metres(electron charge is not included in calculation)""""""\n    return simps(z*wfe1*wfe2/eps_z,z)\n\ndef calc_S_c(Psi0,Psi1,Psi2,Psi3,eps_z,zaxis):\n    """"""Calculates S, a quantity used to calculate the effective thickness of an\n    intersubband transition of a quantum well.\n    Psi0 - Psi3 are arrays describing the wavefunctions.\n    zaxis is an array of z-values for the wavefunctions (needn\'t be uniform) (metres)\n    """"""\n    eps_z = eps_z*np.ones_like(zaxis)\n    dz_axis = zaxis[1:]-zaxis[:-1]\n    dz_axis = np.hstack((dz_axis[0],dz_axis)) #preprend a value so that all values get used in calculation\n    i1=0.0; i2=0.0; i3=0.0\n    for p0,p1,p2,p3,eps,dz in zip(Psi0,Psi1,Psi2,Psi3,eps_z,dz_axis):\n        delta = p0*p1\n        i1+=delta\n        i2+=i1/eps\n        i3+=p2*p3*i2\n    i3*=dz**3\n    return -i3\n\ndef calc_interaction_matrix(results,transitions_table,eps_z):\n    """"""calculates the matrix of describing collective interactions between the transitions\n    and also the d vector""""""\n    #number of transitions\n    ntr = len(transitions_table) #or n*(n-1)/2 where n is the number of energy levels\n    # Note that following arrays are indexed by transition rather than energy level.\n    #So [0,0] is the transition for levels 0->1\n    #construct transition matrix S & B\n    dx = results.dx #m\n    wfe = results.wfe*dx**-0.5\n    zaxis = results.xaxis #m\n    # S matrix\n    S = np.zeros((ntr,ntr),np.complex)\n    for tra in transitions_table:\n        a = tra[\'j\']\n        S[a,a] = calc_S_c(wfe[tra[\'ilevel\']],wfe[tra[\'flevel\']],wfe[tra[\'ilevel\']],wfe[tra[\'flevel\']],eps_z,zaxis)\n    for tra,trb in combinations(transitions_table,2):\n        a = tra[\'j\']\n        b = trb[\'j\']\n        S[a,b] = S[b,a] = calc_S_c(wfe[tra[\'ilevel\']],wfe[tra[\'flevel\']],wfe[trb[\'ilevel\']],wfe[trb[\'flevel\']],eps_z,zaxis)\n    #print \'S\';print S\n    # T matrix\n    const = 2*q**2/eps0*meV2J*1e15 # 1e15 converts dN values into carriers/m**2\n    R = np.zeros((ntr,ntr),np.complex)\n    for tra in transitions_table:\n        a = tra[\'j\']\n        R[a,a] = const*S[a,a]*np.sqrt(tra[\'dN\']*tra[\'dE\']*tra[\'dN\']*tra[\'dE\'])\n    for tra,trb in combinations(transitions_table,2):\n        a = tra[\'j\']\n        b = trb[\'j\']\n        R[a,b] = R[b,a] = const*S[a,b]*np.sqrt(tra[\'dN\']*tra[\'dE\']*trb[\'dN\']*trb[\'dE\']) \n    # d vector\n    d = np.zeros(ntr,np.complex)\n    for tra in transitions_table:\n        a = tra[\'j\'] #find correct index\n        i = tra[\'ilevel\']\n        f = tra[\'flevel\']\n        x_if = dipole_matrix_b(zaxis,wfe[i],wfe[f],eps_z)\n        d[a] = np.sqrt(tra[\'dN\']*1e15*tra[\'dE\']*meV2J)*q*x_if\n    return R,d\n\ndef calc_wR_multiplasmon(results,transitions_table,eps_z):\n    """"""Uses a multilevel version of the mathematical formalism given in Ando 1977\n    A matrix is constucted describing the transitions and the interactions between\n    them which can be diagonalised to give a description of the system as a simple\n    sequence of Lorentzian oscillators.\n    eps_z is an array of the dielectric constant wrt z for the media in the barrier+QW+barrier\n    structure.\n    returns (w,R-squared) - (real frequency (THz), related to transition oscillator strength)\n    """"""\n    #Calculate transitions interactions matrix + rhs of system equation\n    R,d = calc_interaction_matrix(results,transitions_table,eps_z)\n    #Add transition energies to Transition interaction matrix\n    B = R\n    for tra in transitions_table:\n        a = tra[\'j\']\n        B[a,a] += (tra[\'dE\']*meV2J)**2\n    \n    #diagonalise\n    if np.iscomplex(eps_z).any():\n        logger.info(\'calc_wR_multiplasmon: using eig() solver for complex symmetric or general matrix\')\n        Bdiag,U = eig_sorted(B) #matrix will be complex symmetric but not Hermitian, this may be a problem with the theory...\n    else:\n        logger.info(\'calc_wR_multiplasmon: using eigh() solver for Hermitian matrix\')\n        Bdiag,U = eigh(B, lower=True, eigvals_only=False, turbo=True, type=1) #otherwise we can be sure that B is real symmetric\n    #final values of R,w0\n    Ry2a = np.dot(U.transpose(),d)**2 * 2.0/(eps0*tra[\'Lperiod\']*1e-9)*(1e-12/h)**2#THz**2 (real)\n    wya = np.sqrt(Bdiag)/h*1e-12 #THz (real)\n    return wya,Ry2a\n\ndef print_multiplasmon_transitions(wya,Ry2a):\n    """"""display the results from the multiplasmon matrix model of the intersubband\n    transitions. These results are \'more accurate\' than the transition table results.\n        wya - transition frequencies (THz)\n        Ry2a - R-squared - related to transition strength - numerator of a Lorentz \n               oscillator model of the transitions. \n    \n    Ry2a = f*wp**2/(eps_b)*L_eff/L\n        f - oscillator strength\n        wp - plasma frequency\n        eps_b - background frequency\n        L_eff - effective width of the transition\n        L - width of QW / effective medium period.\n    """"""\n    col_width = 10\n    logger.info( ""Optical transitions from multiplasmon matrix model"")\n    logger.info( ""R^2 - related to oscillator strength of each transition (THz^2)."")\n    logger.info( ""Other columns give the transition frequencies in various units."")\n    logger.info( \'\'.join(s.rjust(col_width) for s in (\'R\',\'(meV)\',\'(THz)\',\'(um)\',\'(wavno - cm^-1)\')))\n    for wy,Ry2 in zip(wya,Ry2a):\n        gap=wy*1e12*h*J2meV\n        freq=wy\n        wav=c/(wy*1e12)*1e6\n        wavno=wy*1e12/c*1e-2\n        logger.info( \'\'.join((\'%.4g\' %i).rjust(col_width) for i in (np.sqrt(Ry2.real),gap,freq,wav,wavno)))\n\ndef inv_eps_zz_multiplasmon(wya,Ry2a,transitions_table,linewidth,freqaxis,eps_z):\n    """"""calculate dielectric constant ratio - 1.0/eps_ISBT for results of matrix calculation.\n    linewidth is either a function depending upon a transition frequency or a constant value (THz?).\n    linewidths are calculated in an empirical fashion, currently using the undepolarisation shifted\n    frequency if linewidth is a function.""""""\n    inveps = np.mean(1.0/eps_z)\n    ff0 = transitions_table[0][\'Leff\']/transitions_table[0][\'Lperiod\']\n    w_if = np.sort([tra[\'dE\'] for tra in transitions_table])*meV2J/h*1e-12 #(THz) initial transition frequencies\n    #w_if = np.zeros(len(transitions_table))\n    #for tra in transitions_table:\n    #    w_if[tra[\'j\']] = tra[\'dE\']*meV2J/h*1e-12 #(THz) initial transition frequencies\n    for wy,Ry2,wi in zip(wya,Ry2a,w_if):\n        y_y = linewidth(wi) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n        #y_y = linewidth(np.sqrt(wy**2-Ry2/ff0)) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n        Xi = susceptibility_Losc(freqaxis,w0=wy,f=Ry2,w_p=1.0,y0=y_y)\n        inveps-= Xi\n    return inveps\n\ndef inv_eps_zz_multiplasmon_helper(results,transitions_table,linewidth,freqaxis,eps_z):\n    """"""this calculates the dielectric constant ratio - 1.0/eps_ISBT for the ISBTs for a frequency independent\n    dielectric constant.\n    """"""\n    wya,Ry2a = calc_wR_multiplasmon(results,transitions_table,eps_z)\n    return inv_eps_zz_multiplasmon(wya,Ry2a,transitions_table,linewdith,freqaxis,eps_z)\n\n## frequency dependent dielectric constant (but separable from position)\n\ndef inv_eps_zz_multiplasmon2(results,transitions_table,linewidth,freqaxis,eps_z,eps_w):\n    """"""Uses a multilevel version of the mathematical formalism given in Ando 1977\n    A matrix is constucted describing the transitions and the interactions between\n    them which can be diagonalised to give a description of the system as a simple\n    sequence of Lorentzian oscillators.\n    \n    This calculates the dielectric constant ratio - 1.0/eps_ISBT for the ISBTs for\n    a background dielectric constant given by eps_z * eps_w where we can separate\n    out the frequency dependent part, eps_w, which is an array wrt the frequency axis.\n    eps_z is an array wrt z for the media in the barrier+QW+barrier structure.\n    \n    linewidth - either a function of the transition frequency or a value (THz)\n    freqaxis is an array of frequencies (THz) to calculate the dielectric constant for.\n    eps_zw is an array of dielectric constant values (exluding eps_0) for the frequencies\n        corresponding to freqaxis. It has no z-dependence, the dielectric constants of\n        the barrier and well layers are assumed to be the same\n    """"""\n    #Calculate transitions interactions matrix + rhs of system equation\n    R,d = calc_interaction_matrix(results,transitions_table,eps_z)\n    \n    #Calculate the inverse dielectric constant ############\n    \n    #background inverse dielectric constant\n    inveps_b = np.mean(1.0/eps_z)/eps_w + 0j\n    \n    #choose appropriate solver\n    if np.iscomplex(eps_z).any() or np.iscomplex(eps_w).any():\n        logger.info(\'calc_wR_multiplasmon2: using eig() solver for complex symmetric or general matrix\')\n        eigen = lambda B: eig_sorted(B) #matrix will be complex symmetric but not Hermitian, this may be a problem with the theory...\n    else:\n        logger.info(\'calc_wR_multiplasmon2: using eigh() solver for Hermitian matrix\')\n        eigen = lambda B: eigh(B, lower=True, eigvals_only=False, turbo=True, type=1) #otherwise we can be sure that B is real symmetric\n    \n    #transition energies\n    E_if = np.zeros(len(transitions_table))\n    for tra in transitions_table:\n        E_if[tra[\'j\']] = tra[\'dE\']*meV2J\n    E2_if = E_if**2 #transition energies squared\n    \n    diag_indices = np.diag_indices_from(R) # indices to access the diagonal of the transitions interaction matrix\n    \n    #linewidth\n    #ff0 = transitions_table[0][\'Leff\']/transitions_table[0][\'Lperiod\']\n    w_if = np.sort([tra[\'dE\'] for tra in transitions_table])*meV2J/h*1e-12 #(THz) initial transition frequencies\n    #w_if = E_if/h*1e-12 #(THz) initial transition frequencies\n    y_y = linewidth(w_if) if callable(linewidth) else linewidth*np.ones_like(w_if)\n    #y_y = linewidth(w_i) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n    #y_y = linewidth(np.sqrt(wy**2-Ry2/ff0)) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n    \n    Lperiod = transitions_table[0][\'Lperiod\']\n    const_factor = 2.0/(eps0*Lperiod*1e-9)*(1e-12/h)**2\n    \n    for i,(freq,eps_w_i) in enumerate(zip(freqaxis,eps_w)):\n        inv_eps_w_i = 1.0/eps_w_i\n        \n        #Add transition energies to Transition interaction matrix\n        B = R.copy()\n        B[diag_indices] += eps_w_i*E2_if\n            \n        #diagonalise\n        Bdiag,U = eigen(B)\n        \n        #final values of R,w0\n        Ry2a = np.dot(U.transpose(),d)**2 * const_factor #THz**2 (real)\n        wya = np.sqrt(inv_eps_w_i*Bdiag)/h*1e-12 #THz (real)\n        \n        #calculate the dielectric constant at this frequency\n        Xi = susceptibility_Losc(freq,w0=wya,f=Ry2a,w_p=1.0,y0=y_y)\n        inveps_b[i]-= np.sum(Xi)*inv_eps_w_i**2\n        \n    #import ipdb; ipdb.set_trace()\n        \n    return inveps_b\n\n## frequency dependent dielectric constant by splitting structure into pieces\n\n\ndef inv_eps_zz_multiplasmon3(results,transitions_table,linewidth,freqaxis,dielectric_masks):\n    """"""Uses a multilevel version of the mathematical formalism given in Ando 1977\n    A matrix is constucted describing the transitions and the interactions between\n    them which can be diagonalised to give a description of the system as a simple\n    sequence of Lorentzian oscillators.\n    \n    This calculates the dielectric constant ratio - 1.0/eps_ISBT for the ISBTs for\n    a background dielectric constant given by\n    \n    dielectric_masks - a sequence of (eps,mask_array) where\n        eps - an array or function of dielectric constants wrt the frequency axis. If it is\n              a function, it should accept an arguement for frequency in THz.\n        mask_array - a bool or integer array wrt the z axis indicating were the eps applies.\n    \n    linewidth - either a function of the transition frequency or a value (THz)\n    freqaxis is an array of frequencies (THz) to calculate the dielectric constant for.\n    """"""\n    #check dielectric_mask for completeness\n    mask_check = np.zeros_like(results.xaxis,dtype=int)\n    mask_check = np.sum((mask for eps,mask in dielectric_masks),mask_check)\n    if not all(mask_check == 1): \n        logger.error(\'masks in dielectric_masks either overlap or do not cover entire structure\')\n    \n    #split the model up in to pieced by material type\n    Rs = []\n    ds = []\n    Epsilons = []\n    for eps,mask in dielectric_masks:\n        with np.errstate(divide=\'ignore\'):\n            maskB = 1.0/mask #infinite where mask==0 and unity where mask==1\n        #Calculate transitions interactions matrix + rhs of system equation\n        R,d = calc_interaction_matrix(results,transitions_table,eps_z=maskB)\n        epsilon = eps(freqaxis) if callable(eps) else eps*np.ones_like(freqaxis)\n        Rs.append(R)\n        ds.append(d)\n        Epsilons.append(epsilon)\n    Epsilons = np.column_stack(Epsilons) #array of freqaxis vs structure-pieces-wrt-eps_b\n    \n    #Calculate the inverse dielectric constant ############\n        \n    #choose appropriate solver\n    if np.iscomplex(Epsilons).any():\n        logger.info(\'calc_wR_multiplasmon3: using eig() solver for complex symmetric or general matrix\')\n        eigen = lambda B: eig_sorted(B) #matrix will be complex symmetric but not Hermitian, this may be a problem with the theory...\n    else:\n        logger.info(\'calc_wR_multiplasmon3: using eigh() solver for Hermitian matrix\')\n        eigen = lambda B: eigh(B, lower=True, eigvals_only=False, turbo=True, type=1) #otherwise we can be sure that B is real symmetric\n    \n    #transition energies\n    E_if = np.zeros(len(transitions_table))\n    for tra in transitions_table:\n        E_if[tra[\'j\']] = tra[\'dE\']*meV2J\n    E2_if = E_if**2 #transition energies squared\n    \n    diag_indices = np.diag_indices_from(R) # indices to access the diagonal of the transitions interaction matrix\n\n    #linewidth\n    #ff0 = transitions_table[0][\'Leff\']/transitions_table[0][\'Lperiod\']\n    w_if = np.sort([tra[\'dE\'] for tra in transitions_table])*meV2J/h*1e-12 #(THz) initial transition frequencies\n    #w_if = E_if/h*1e-12 #(THz) initial transition frequencies\n    y_y = linewidth(w_if) if callable(linewidth) else linewidth*np.ones_like(w_if)\n    #y_y = linewidth(w_i) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n    #y_y = linewidth(np.sqrt(wy**2-Ry2/ff0)) if callable(linewidth) else linewidth #(THz real?) guesstimate of transition broadening (written to get result as close as possible to other models)\n    \n    const_factor = 2.0/(eps0*tra[\'Lperiod\']*1e-9)*(1e-12/h)**2\n    \n    inveps_b = np.zeros_like(freqaxis) + 0j\n    \n    for i,freq in enumerate(freqaxis):\n        #find dielectric constants for each subsection of the structure\n        inv_eps_w_i = 1.0/Epsilons[i]\n        #background inverse dielectric constant\n        inveps_b[i] = np.mean(np.sum(mask*inve for inve,(_,mask) in zip(inv_eps_w_i,dielectric_masks)))\n        #Add the pieces of B together\n        B = np.sum(a*r for a,r in zip(inv_eps_w_i,Rs))\n        #Add the pieces of d together\n        d = np.sum(a*dl for a,dl in zip(inv_eps_w_i,ds))\n        \n        #Add transition energies to Transition interaction matrix\n        B[diag_indices] += E2_if\n            \n        #diagonalise\n        Bdiag,U = eigen(B)\n        \n        #final values of R,w0\n        Ry2a = np.dot(U.transpose(),d)**2 * const_factor #THz**2 (real)\n        wya = np.sqrt(Bdiag)/h*1e-12 #THz (real)\n        \n        #calculate the dielectric constant at this frequency\n        Xi = susceptibility_Losc(freq,w0=wya,f=Ry2a,w_p=1.0,y0=y_y)\n        inveps_b[i]-= np.sum(Xi)\n        \n    #import ipdb; ipdb.set_trace()\n    \n    return inveps_b\n\n\n## Making plots of absorption\n\ndef plotting_absorption(model,results,transitions_table,eps_b,eps_z,linewidth):\n    """"""plots an approximation to the ISBT absorptions of a QW.\n    This is really a demo function, add a customised version to your\n    script.""""""    \n    f1 = pl.figure()\n    ax1 = f1.add_subplot(111)\n    ax1.set_xlabel(\'frequency (THz)\')\n    transitionfreq = [trn[\'freq\'] for trn in transitions_table]\n    frange = max(transitionfreq) - min(transitionfreq)\n    freqaxis = np.linspace(0.5*min(transitionfreq),1.5*max(transitionfreq),800)\n    \n    for trn in transitions_table: #nb. first row of table describes the units of each variable\n        #vertical lines for original transition energies\n        ax1.axvline(trn[\'freq\'])\n    \n    theta =pi/4\n    nk = np.sqrt(np.mean(np.atleast_1d(eps_z),axis=0)) # should be eps_xx really\n    d = transitions_table[0][\'Lperiod\']*1e-9\n    f2w = 1e12*2*pi\n    eps_z = np.real_if_close(eps_z)\n    \n    #model 0 # the slightly niave model usng the \'standard\' absorption calculation and Lorentz oscillator model\n    # this is only for comparison.\n    eps_simple = eps_classical(transitions_table,freqaxis,np.mean(eps_z))#.conjugate()\n    Leff0 = get_Leff_est(transitions_table)*1e-9\n    absorption_simple = absorption_standard(freqaxis*f2w,eps_simple,Leff0).real\n    #eps_b=1.0\n    #ff = transitions_table[0][\'Leff\']/Lperiod\n    #absorption_simple = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_b/eps_simple,nk,ff*d)\n    ax1.plot(freqaxis,absorption_simple,label=\'Naive Model\')\n    \n    #model 1 # Uses the analytically correct result for a single transition but can be incorrect for multiple transitions\n    eps_ratio1 = eps_b*inv_eps_zz_1(transitions_table,freqaxis,eps_z)\n    absorption1 = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio1,nk,d).real\n    ax1.plot(freqaxis,absorption1,label=\'Independent Transitions Model\')\n    \n    #model 2 # A classical approach to modelling multiple transitions. Not exact but accounts for coupling between transitions in a physically intuitive way.\n    #eps_ratio2 = eps_b*inv_eps_zz_classical(transitions_table,freqaxis,eps_z)\n    #absorption2 = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio2,nk,d)\n    #ax1.plot(freqaxis,absorption2,label=\'Classical Transitions Model\')\n    \n    #model 3 # An accurate model for multiple transitions (neglecting non-parabolicity).  \n    wya,Ry2a = calc_wR_multiplasmon(results,transitions_table,eps_z)\n    #print \'matrix method results\'; print_multiplasmon_transitions(wya,Ry2a)\n    inv_eps_zz3 = inv_eps_zz_multiplasmon(wya,Ry2a,transitions_table,linewidth,freqaxis,eps_z)\n    eps_ratio3 = eps_b*inv_eps_zz3\n    absorption3 = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio3,nk,d).real\n    ax1.plot(freqaxis,absorption3,label=\'Matrix Model\')\n    \n    #model 4 # An accurate model for multiple transitions with frequency dependant dielectric constant\n    #the frequency dependence is defined relative to the normal eps_z but needs to be the same for the\n    #whole structure.\n    eps_w = np.ones_like(freqaxis) #no actual frequency dependence here, this is just a demo.\n    inv_eps_zz4 = inv_eps_zz_multiplasmon2(results,transitions_table,linewidth,freqaxis,eps_z,eps_w)\n    eps_ratio4 = eps_b*inv_eps_zz4\n    absorption4 = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio4,nk,d).real\n    ax1.plot(freqaxis,absorption4,label=\'Matrix Model with eps(w)\')\n\n    #model 5 # An accurate model for multiple transitions with frequency dependant dielectric constant\n    #The structure is divided up into a few pieces with respect to shared background dielectric constants\n    #this enables a more rapid calculation of the relevant matrices at each frequency by appropriately\n    #summing the pieces together.\n    \n    #eps_z -> pieces \n    eps_values = set(eps_z*np.ones(model.n_max))\n    if len(eps_values) > 30: logger.warning(\'plotting_absorption:model5 eps_z has been than 10 pieces, calculation may be slow\')\n    dielectric_masks = [(eps,(eps_z*np.ones(model.n_max)==eps)) for eps in eps_values]\n    \n    #normally might calculate the dielectric_masks sequence manually via\n    #dielectric_masks = [(eps_w_AlGaAs,np.sum(model.layer_mask(i) for i in [0,1,2,5,6])),\n    #                    (eps_w_GaAs,np.sum(model.layer_mask(i) for i in [3,4])),\n    #                    ...]\n    #where eps_w_AlGaAs could be a number, an array (wrt freq_axis) or a function (that takes freq_axis \n    #as a parameter)\n    inv_eps_zz5 = inv_eps_zz_multiplasmon3(results,transitions_table,linewidth,freqaxis,dielectric_masks)\n    eps_ratio5 = eps_b*inv_eps_zz5\n    absorption5 = uniaxial_layer_absorption(theta,freqaxis*f2w,eps_ratio5,nk,d).real\n    ax1.plot(freqaxis,absorption5,label=\'Matrix Model with eps(z,w)\')\n        \n    ax1.legend()\n    if not pl.isinteractive(): pl.show()\n    \n    #import ipdb; ipdb.set_trace()\n    \n    return f1\n    \n\n\ndef eps_background_GaAs(model,eps_gaas,eps_algaas):\n    """"""Helper function for calculating background dielectric constant\n    array for GaAs/AlGaAs structures""""""\n    eps_z = np.zeros(model.n_max,np.complex)\n    \n    position = 0.0 # keeping in nanometres (to minimise errors)\n    for layer in model.material:\n        startindex = round2int(position*1e-9/model.dx)\n        position += layer[0] # update position to end of the layer\n        finishindex = round2int(position*1e-9/model.dx)\n        #\n        matType = layer[1]\n        if matType == \'GaAs\':\n            eps_z[startindex:finishindex] = eps_gaas\n        elif matType == \'AlGaAs\':\n            eps_z[startindex:finishindex] = eps_algaas\n\n    return eps_z    \n\n\n\nif __name__ == ""__main__"":\n    import config\n    import database\n    import aestimo\n    import os\n    import time\n    \n    np.set_printoptions(precision=3,linewidth=180)\n    \n    logger = aestimo.logger\n    \n    # Import from config file\n    inputfile = __import__(config.inputfilename)\n    logger.info(""inputfile is %s"",config.inputfilename)\n    \n    # Initialise structure class\n    model = aestimo.StructureFrom(inputfile,database)\n    \n    if False: #recalculate QW states\n        # Perform the calculation\n        result = aestimo.Poisson_Schrodinger(model)\n        \n        time4 = time.time() #timing audit\n        logger.info(""total running time (inc. loading libraries) %g s"",(time4 - aestimo.time0))\n        logger.info(""total running time (exc. loading libraries) %g s"",(time4 - aestimo.time1))\n        \n        # Write the simulation results in files\n        aestimo.save_and_plot(result,model)\n        logger.info(""Simulation is finished."")\n    else: #load previously calculated results from output directory\n        result = aestimo.load_results()\n    \n    #Set thickness of effective medium\n    Lperiod = sum([layer[0] for layer in model.material])*1e-9 #m\n    \n    # set dielectric constants\n    case = 2\n    if case==1: #scalar dielectric constants\n        eps_b = 12.90\n        eps_z = 12.90 #+ 0.0j\n    \n    elif case==2: #z-dependent dielectric constants\n        eps_b = 10.364\n        eps_gaas = 10.364 # @ 16um\n        eps_algaas = 8.2067\n        eps_z = eps_background_GaAs(model,eps_gaas,eps_algaas)\n        eps_z = np.real_if_close(eps_z)\n    \n    elif case==3: #w-dependent dielectric constants\n        #because the zeroth axis is assumed to be the z-axis, our eps_z array must be 2d\n        pass\n        #currently the matrix model doesn\'t cope with frequency dependent dielectric constants\n        #therefore the classical model would be the best approach (model2) although it seems\n        #to over-estimate the coupling between the transitions.\n        #Alternatively, we could resolve the matrix at each frequency (for each value of the\n        #background dielectric constant which would be accurate but may be quite computationally\n        #intensive.\n    \n    elif case==4: #z-dependent and w-dependent dielectric constants\n        pass\n        #currently the matrix model doesn\'t cope with frequency dependent dielectric constants\n        #therefore the classical model is the best approach (model2) although it seems\n        #to over-estimate the coupling between the transitions.\n        #Alternatively, we could resolve the matrix at each frequency (for each value of the\n        #background dielectric constant which would be accurate but may be quite computationally\n        #intensive.\n    \n    # Linewidth\n    def linewidth(freq): return 0.1*freq #define linewidth in THz\n\n    #linewidth = 1.0 #THz\n    \n    # Optical Intersubband Transitions\n    transitions_table,(hdr,units) = transitions(result,Lperiod,eps_z,linewidth)\n    \n    print_levels(result)\n    print_transitions(transitions_table,hdr,units)\n    \n    plotting_absorption(model,result,transitions_table,eps_b,eps_z,linewidth)\n    \n""""""\nTO DO:\nsolve eps_b wrt freq issue\nmake compatible with pyLuminous/pyFresnel\nchang\nwarburton\n""""""\n'"
main.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2018 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n\nFile Information:\n-----------------\nThis file is one method of running aestimo. Simply define the input file in \nthe config.py module and run this script. We could also run aestimo.py directly\nto achieve the same effect. \n\nAlternatively, many of the example input files show how we can transform them\ninto scripts that can be run directly to perform the simulations. That approach\nalso allows us to tailor each simulation even more to our needs.\n""""""\n#import matplotlib.pyplot as pl\n#import numpy as np\n#import time\n#import sys \n\nimport config\n\n#import aestimo_eh as aestimo\nimport aestimo\n    \n\n# Import from config file\ninputfile = __import__(config.inputfilename)\naestimo.logger.info(""inputfile is %s"" %config.inputfilename)\n\nif __name__==""__main__"":\n    aestimo.run_aestimo(inputfile)\n\n\n'"
main_iterating.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2018 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n\nFile Information:\n-----------------\nThis script shows how we can simulate a design several times while varying a\nparameter over a range of values.\n""""""\nimport matplotlib.pyplot as pl\nimport numpy as np\nimport os\n\n# aestimo modules\nimport aestimo\nimport config\ninputfile = __import__(config.inputfilename) \nimport database\n\n### Example: Parameter to loop over.\n#thickness of first layer of structure\nthicknesses = [8,12,14,16,20] #nm\n        \n# Initialise structure class\nmodel = aestimo.StructureFrom(inputfile,database)\n\n# Looping over the parameter\n""""""In order to write the code correctly, it is necessary to have \nunderstood the Structure class and it\'s attributes. Some of the \ninput file variables and the class\'s attribute use different names\nbut they are normally easy to match up. Alternatively, we could vary the \n(runtime values of the) variables within inputfile module\'s namespace\nand then create a fresh Structure class instance.\n\nEqually, we can vary the values in the database module if we want to.""""""\n\nresults = []\noutput_directory = config.output_directory+\'-numpy\' # will be our local copy of the original value\n\nfor thickness in thicknesses:\n    model.material[0][0] = thickness\n    #other examples -\n    #model.Fapp = ... #equivalent to Fapplied\n    #model.subnumber_e = ...\n    #model.dx = gridfactor*1e-9\n    #database.materialproperty[\'GaAs\'][\'epsilonStatic\']= ...\n    \n    model.create_structure_arrays() # update the instance\'s internals\n    \n    # Perform the calculation\n    result= aestimo.Poisson_Schrodinger(model)\n    \n    results.append(result) #all the results can be stored for further analysis. \n    \n    # Set output directory \n    # aestimo_numpy reads the output directory from the config module, so\n    config.output_directory = os.path.join(output_directory,\'dz0_%dnm\' %thickness)\n\n    # Write the simulation results in files\n    aestimo.save_and_plot(result,model)\n    \n    #Plot QW representation\n    #aestimo.QWplot(result)#,figno=None) # an alternative to save_and_plot function\n                                            # which only plots the QW diagram and doesn\'t\n                                            # save anything.\n\nprint(""Simulation is finished. All files are closed."")\nprint(""Please control the related files."")\n'"
profile.py,0,"b'#!/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2018 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n\nFile Information:\n-----------------\nSimple script for profiling aestimo using the cProfile module.\n""""""\n\nimport cProfile\ncommand = """"""import main""""""\ncProfile.runctx( command, globals(),locals(),filename=""aestimo_numpy-0.8.3.profile"")\n\n#command = """"""import aestimo""""""\n#cProfile.runctx( command, globals(), locals(), filename=""aestimo_t8.profile"" )\n\n#command = """"""import main""""""\n#cProfile.runctx( command, globals(), locals(), filename=""aestimo_numpy.profile"" )\n'"
sample_double_qw.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ------------------------------------------------------------------------\n# Input File Description:  Double Quantum well doped AlGaAs/GaAs heterostructure.\n# ------------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\nsubnumber_h = 3\n# APPLIED ELECTRIC FIELD\nFapplied = 0.0 # (V/m)\nvmax= 1.7\nvmin= 0.0\nEach_Step=0.05\nmat_type=\'Zincblende\'\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm)  | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |       250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |       250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\n\nmaterial =[[ 300.0, \'AlGaAs\', 0.3, 0.3, 1e17, \'p\',\'b\'],\n            [3.0, \'GaAs\', 0, 0.3, 0.0, \'i\',\'w\'],\n            [20.0, \'AlGaAs\', 0.3, 0.3, 0.0, \'i\',\'b\'],\n            [3.0, \'GaAs\', 0, 0.3, 0.0, \'i\',\'w\'],\n            [20.0, \'AlGaAs\', 0.3, 0.3, 0.0, \'i\',\'b\'],\n            [300.0, \'AlGaAs\', 0.3, 0.3, 1e17, \'n\',\'b\']]\n\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    #dop_profile[i]=dop_n[i]+dop_p[i] \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
setup.py,0,"b'#!/bin/env python\n# -*- coding: utf-8 -*-\n""""""\nFile Information:\n-----------------\nsetuptools script for aestimo project\n""""""\nfrom setuptools import setup\nimport os, sys\n\ndef read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\n\n## cython stuff ################################################################\nfrom setuptools.extension import Extension\n\ncmdclass = { }\next_modules = [ ]\n\n# making sure that the compile Cython files in the distribution are up-to-date\nfrom setuptools.command.sdist import sdist as _sdist\n\nclass sdist(_sdist):\n    def run(self):\n        # Make sure the compiled Cython files in the distribution are up-to-date\n        from Cython.Build import cythonize\n        cythonize([\'psi_at_inf_cython.pyx\'])\n        cythonize([\'aestimo_dd_lib.pyx\'])\n        _sdist.run(self)\n        #print(\'compiling cython module into c source\')\n\ncmdclass[\'sdist\'] = sdist\n\n# using cython if it is installed on the users distribution.\ntry:\n    from Cython.Distutils import build_ext as _build_ext\n    #raise ImportError\n    use_cython = True\n    ext = \'.pyx\'\nexcept ImportError:\n    from setuptools.command.build_ext import build_ext as _build_ext\n    use_cython = False\n    ext = \'.c\' \n    \next_modules += [\n    Extension(""aestimo.psi_at_inf_cython"", [ ""psi_at_inf_cython"" +ext ]),\n    Extension(""aestimo.aestimo_dd_lib"", [ ""aestimo_dd_lib"" +ext])\n    ]\n\n# if numpy needed to be installed to as a dependency of aestimo, this might enable\n# the compilation of the cython extension to continue successfully\n\nclass build_ext(_build_ext):\n    def finalize_options(self):\n        _build_ext.finalize_options(self)\n        # Prevent numpy from thinking it is still in its setup process:\n        __builtins__.__NUMPY_SETUP__ = False\n        try:\n            import numpy\n        except ImportError:\n            #guess\n            site_packages = [p for p in sys.path if sys.prefix in p and \'-packages\' in p][0]\n            include_dir = os.path.join(site_packages,\'numpy\',\'core\',\'include\')\n            #still see an error since bdist_wheel is attempted be built before numpy is installed.\n            #this would all work except that \'setup_requires\' parameter doesn\'t seem to work with pip.\n        else:\n            include_dir = numpy.get_include()\n        self.include_dirs.append(include_dir)\n\ncmdclass.update({ \'build_ext\': build_ext })\n\n################################################################################\n\n\nsetup(  name=\'aestimo\',\n        version=\'2.0.2\',\n        description=\'A bandstructure simulator of semiconductor nanostructures called quantum wells.\',\n        long_description= read(\'README.md\'),\n        classifiers=[\n          ""License :: OSI Approved :: GNU General Public License v3 (GPLv3)"",\n          ""Programming Language :: Python :: 2"",\n          ""Development Status :: 5 - Production/Stable"",\n          ""Intended Audience :: Science/Research"",\n          ""Natural Language :: English"",\n          ""Operating System :: OS Independent"",\n          ""Topic :: Scientific/Engineering :: Physics"",\n          ""Topic :: Scientific/Engineering""\n           ],\n        author=\'robochat\',\n        author_email=\'rjsteed@talk21.com\',\n        url=\'http://www.aestimosolver.org\',\n        license=\'GPLv3\',\n        keywords=\'quantum well semiconductor nanostructure optical transitions\',\n        package_dir = {\'aestimo\': \'\'},\n        packages=[\'aestimo\'],\n        package_data={\'aestimo\':[\'README.md\',\'AUTHORS.md\',\'COPYING.md\',\'CHANGELOG.md\',\n                                 \'psi_at_inf_cython.pyx\',\'psi_at_inf_cython.c\',\n                                 \'aestimo_dd_lib.pyx\',\'aestimo_dd_lib.c\',\'aestimo_dd_lib.pyd\',\n                                 \'tutorials/*\',\'examples/*.py\']},\n        scripts=[\'scripts/aestimo\',\'scripts/aestimo_eh\'],\n        install_requires=[\'numpy>1.7.0\',\'matplotlib\',\'scipy\'],\n        zip_safe=False, #we want users to be able to easily see and edit the scripts\n        #setup_requires=[\'numpy\'], #causes problems with pip?\n        cmdclass = cmdclass,\n        ext_modules=ext_modules,\n        )\n'"
setup_cython.py,0,"b'#!/bin/env python\n# -*- coding: utf-8 -*-\n""""""\n Aestimo 1D Schrodinger-Poisson Solver\n Copyright (C) 2013-2018 Sefer Bora Lisesivdin and Aestimo group\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. See ~/COPYING file or http://www.gnu.org/copyleft/gpl.txt .\n\n    For the list of contributors, see ~/AUTHORS\n\nFile Information:\n-----------------\nThis module compiles the cythonised version of the psi_at_inf function used\nby the aestimo.py shooting method (but not by aestimo_eh.py). See \npsi_at_inf_cython.pyx\n\nCompile the cythonised function with the command:\n   python setup_cython.py build_ext --inplace\nor on windows:\n   python setup_cython.py build_ext --inplace --compiler=mingw32\n\naestimo.py will then automatically use this faster version as long as the \nconfig.py module contains `use_cython = True`.\n""""""\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\nimport numpy\n\next_modules = [Extension(""psi_at_inf_cython"", [""psi_at_inf_cython.pyx""])]\n\nsetup(\n  name = \'psi_at_inf\',\n  cmdclass = {\'build_ext\': build_ext},\n  ext_modules = ext_modules,\n  include_dirs=[numpy.get_include()]\n)\n'"
examples/sample_1qw_barrierdope_ingaas.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 3\nsubnumber_e = 3\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 1.79\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\nmaterial =[[ 250.0, \'AlGaAs\', 0.3, 0.0, 0.8e17, \'p\',\'b\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'n\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'n\',\'w\'],\n           [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0,\'n\',\'b\'],\n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 0.8e18,\'n\',\'b\'],           \n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.8e18, \'n\',\'b\']]\n\n\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6#n_max-1-i\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    dop_profile[i]=dop_n[i]+dop_p[i]\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2)\nsurface[0]=  0.0\nsurface[1]=  0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_ingaas""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)'"
examples/sample_2qw_InGaAS_GaAs.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\nimport time\ntime0 = time.time() # timing audit\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)-20e8\nvmax= 1.3\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\ncontact=0.0\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\n\n\nmaterial=[[ 200.0, \'GaAs\',  0.0, 0.0, 2e19, \'p\',\'b\'],\n            [ 3.0, \'InGaAs\', 0.2, 0.0, 0.0e17, \'n\',\'w\'],\n            [ 15.0, \'GaAs\',  0.0, 0.0, 0.0e17, \'n\',\'b\'],\n            [ 3.0, \'InGaAs\', 0.2, 0.0, 0.0e17, \'n\',\'w\'],\n            [ 300.0, \'GaAs\', 0.0, 0.0, 5e18, \'n\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((1,2))\nQuantum_Regions_boundary[0,0]=25\nQuantum_Regions_boundary[0,1]=70\n#----------------------------------------\nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_2qw_InGaAS_GaAs""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n\ntime1 = time.time()\nprint(""total running time="",time1-time0)\n'"
examples/sample_2qw_InGaN_GaN_vs_1ddcc.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\nimport time\ntime0 = time.time() # timing audit\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\n# 10: Schrodinger-Poisson under testing using Newton iteration (will replace scheme 2)\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)-20e8\nvmax= 3.3\nvmin= 3.0\nEach_Step=0.15\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\ncontact=0.0\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.25#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\n\nmaterial  =[[ 200.0, \'GaN\',  0.0, 0.0, 2e19, \'p\',\'b\'],\n            [ 3.0, \'InGaN\', 0.2, 0.0, 0.0e17, \'n\',\'w\'],\n            [ 15.0, \'GaN\',  0.0, 0.0, 0.0e17, \'n\',\'b\'],\n            [ 3.0, \'InGaN\', 0.2, 0.0, 0.0e17, \'n\',\'w\'],\n            [ 300.0, \'GaN\', 0.0, 0.0, 5e18, \'n\',\'b\']]\n\n\nmaterial1  =[[ 15.0, \'GaN\',  0.0, 0.0, 2e19, \'p\',\'b\'],\n            [ 3.0, \'InGaN\', 0.2, 0.0, 0.01e17, \'n\',\'w\'],\n            [ 14.0, \'GaN\',  0.0, 0.0, 0.01e17, \'n\',\'b\'],\n            [ 3.0, \'InGaN\', 0.2, 0.0, 0.01e17, \'n\',\'w\'],\n            [ 15.0, \'GaN\', 0.0, 0.0, 5e18, \'n\',\'b\']]\n\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\nQuantum_Regions_boundary[0,0]=10\nQuantum_Regions_boundary[0,1]=25\nQuantum_Regions_boundary[1,0]=26\nQuantum_Regions_boundary[1,1]=38\n#----------------------------------------\nsurface=np.zeros(2)\nsurface[0]=0.0\nsurface[1]=0.0\n#----------------------------------------\ninputfilename = ""sample_2qw_InGaN_GaN_vs_1ddcc""\n#this code allows you to run the input file directly\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n\ntime1 = time.time()\nprint(""total running time="",time1-time0)\n'"
examples/sample_2qw_barrierdope_ingaas.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 3\nsubnumber_e = 3\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 1.6\nvmin= 0.0\nEach_Step=0.1# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\nmaterial =[[ 250.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'n\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'n\',\'w\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'n\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'n\',\'w\'],\n           [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0,\'n\',\'b\'],\n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 1e18,\'n\',\'b\'],           \n           [ 15.0, \'GaAs\', 0.3, 0.0, 1e18, \'n\',\'b\']]\n\n\n\nmaterial2 =[[ 15.0, \'GaAs\', 0.0, 0.0, 1e18, \'n\',\'b\'],\n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 1e18,\'n\',\'b\'],\n           [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0,\'i\',\'b\'],\n           [ 15.0, \'GaAs\', 0.0, 0.0, 0.0,\'i\',\'w\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'i\',\'b\'],           \n           [ 250.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\']]\n\n\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6#n_max-1-i\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    dop_profile[i]=dop_n[i]+dop_p[i]\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nsurface=np.zeros(2)\nsurface[1]=0.6\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\ninputfilename = ""sample_2qw_barrierdope_ingaas""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_double_qw.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ------------------------------------------------------------------------\n# Input File Description:  Double Quantum well doped AlGaAs/GaAs heterostructure.\n# ------------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\nsubnumber_h = 3\n# APPLIED ELECTRIC FIELD\nFapplied = 0.0 # (V/m)\nvmax= 1.7\nvmin= 0.0\nEach_Step=0.05\nmat_type=\'Zincblende\'\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm)  | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |       250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |       250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\n\nmaterial =[[ 300.0, \'AlGaAs\', 0.3, 0.3, 1e17, \'p\',\'b\'],\n            [3.0, \'GaAs\', 0, 0.3, 0.0, \'i\',\'w\'],\n            [20.0, \'AlGaAs\', 0.3, 0.3, 0.0, \'i\',\'b\'],\n            [3.0, \'GaAs\', 0, 0.3, 0.0, \'i\',\'w\'],\n            [20.0, \'AlGaAs\', 0.3, 0.3, 0.0, \'i\',\'b\'],\n            [300.0, \'AlGaAs\', 0.3, 0.3, 1e17, \'n\',\'b\']]\n\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    #dop_profile[i]=dop_n[i]+dop_p[i] \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_double_qw""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_double_qw_isbt.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 60.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ncomputation_scheme = 6\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 4\n# Total subband number to be calculated for electrons (for aestimo_numpy_h)\nsubnumber_h = 1\n\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00/50e-9 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\n\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 1e18, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 15.0, \'GaAs\', 0, 0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'GaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 1e18, \'n\'],\n            [ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\']]\n \n\n\nif __name__==""__main__"":\n    import config\n    import database\n    import aestimo\n    import intersubband_optical_transitions as isbt\n    import os\n    import time\n    \n    logger = aestimo.logger\n    \n    # Initialise structure class\n    model = aestimo.StructureFrom(vars(),database)\n    \n    if True: #recalculate QW states\n        # Perform the calculation\n        result = aestimo.Poisson_Schrodinger(model)\n        \n        time4 = time.time() #timing audit\n        logger.info(""total running time (inc. loading libraries) %g s"",(time4 - aestimo.time0))\n        logger.info(""total running time (exc. loading libraries) %g s"",(time4 - aestimo.time1))\n        \n        # Write the simulation results in files\n        fig1,fig2,fig3 = aestimo.save_and_plot(result,model)\n        logger.info(""Simulation is finished."")\n    else: #load previously calculated results from output directory\n        result = aestimo.load_results()\n    \n    #Set thickness of effective medium\n    Lperiod = sum([layer[0] for layer in model.material])*1e-9 #m\n    \n    # set dielectric constants\n    case = 1\n    if case==1: #scalar dielectric constants\n        eps_b = 12.90\n        eps_z = 12.90\n    \n    elif case==2: #z-dependent dielectric constants\n        eps_b = 10.364\n        eps_gaas = 10.364 # @ 16um\n        eps_algaas = 8.2067\n        eps_z = isbt.eps_background_GaAs(model,eps_gaas,eps_algaas) \n\n    # Linewidth\n    def linewidth(freq): return 0.1*freq #define linewidth in THz\n    \n    #linewidth = 1.0 #THz\n    \n    # Optical Intersubband Transitions\n    transitions_table,(hdr,units) = isbt.transitions(result,Lperiod,eps_z,linewidth)\n    \n    isbt.print_levels(result)\n    isbt.print_transitions(transitions_table,hdr,units)\n    isbt.print_multiplasmon_transitions(*isbt.calc_wR_multiplasmon(result,transitions_table,eps_z))\n    \n    fig4 = isbt.plotting_absorption(model,result,transitions_table,eps_b,eps_z,linewidth)\n\n'"
examples/sample_moddop.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------------------------------\n# Input File Description:  Modulation doped AlGaAs/GaAs heterostructure.\n# ----------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\nsubnumber_h = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.0 # (V/m)\nvmax= 1.5\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 20.0, \'AlGaN\', 0.3, 0.3,0, \'n\',\'i\'],\n           [ 50.0, \'GaN\', 0,0.3, 0, \'n\',\'i\']]\n \ncontact=0.0\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=True\nQuantum_Regions_boundary=np.zeros((1,2))\nQuantum_Regions_boundary[0,0]=10\nQuantum_Regions_boundary[0,1]=30\n#----------------------------------------  \nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_moddop""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)'"
examples/sample_mqw_barrierdope_p_ingan.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 2\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)2.5e7/50e-9\nvmax= 3.2\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.2 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 100.0, \'GaN\', 0.05, 0.0, 1.5e18, \'p\',\'b\'],\n            [ 2.0, \'InGaN\', 0.05, 0.0, 0,\'n\',\'w\'],\n            [ 2.0, \'GaN\', 0.0, 0.0, 0.0, \'n\',\'b\'],\n            [ 2.0, \'InGaN\', 0.05, 0.0, 0,\'n\',\'w\'],\n            [ 100.0, \'GaN\', 0.05, 0.0, 1.5e18, \'n\',\'b\']]\n\nmaterial2 =[ [ 20.0, \'AlGaN\', 0.05, 0.0, 0.0, \'n\',\'b\'],\n            [ 2.0, \'InGaN\', 0.2, 0.0, 0,\'n\',\'w\'],\n            [ 5.0, \'GaN\', 0.0, 0.0, 0.0, \'n\',\'b\'],\n            [ 2.0, \'InGaN\', 0.1, 0.0, 0,\'n\',\'w\'],\n            [ 20.0, \'GaN\', 0.05, 0.0, 0.0, \'n\',\'b\']]\n\nmaterial1 =[ [ 500.0, \'GaN\', 0.0, 0.0, 3e18, \'n\',\'b\'],\n            [ 3.5, \'InGaN\', 0.2, 0.0, 0.0,\'i\',\'w\'],\n            [ 100.0, \'AlGaN\', 0.1, 0.0, 7e19, \'p\',\'b\'],\n            [ 200.0, \'GaN\', 0.0, 0.0, 7e19, \'p\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)     \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_mqw_barrierdope_p_ingan""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_mqw_barrierdope_p_ingan_2.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 7\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)2.5e7/50e-9\nvmax= 3.2\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.2#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 300.0, \'AlGaN\', 0.05, 0.0, 5e18, \'p\',\'b\'],\n            [ 2.0, \'InGaN\', 0.2, 0.0, 1e-10,\'n\',\'w\'],\n            [ 5.0, \'GaN\', 0.0, 0.0, 1e-10, \'n\',\'b\'],\n            [ 2.0, \'InGaN\', 0.2, 0.0, 1e-10,\'n\',\'w\'],\n            [ 200.0, \'AlGaN\', 0.05, 0.0, 5e18, \'n\',\'b\']]\n\nmaterial1 =[[ 20.0, \'AlGaN\', 0.3, 0.0, 5e16, \'p\',\'b\'],\n            [ 10.0, \'GaN\', 0.2, 0.0, 1e18,\'p\',\'w\'],\n            [ 20.0, \'AlGaN\', 0.3, 0.0, 5e16, \'p\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\n#----------------------------------------\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\ndop_profile=np.zeros(n_max)  \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_mqw_barrierdope_p_ingan_2""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_multi_qw_barrierdope_p.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 1.8\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[ [ 200.0, \'AlGaAs\', 0.3, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'AlGaAs\', 0.3, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaAs\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaAs\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaAs\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaAs\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 2.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 2.0, \'AlGaAs\', 0.3, 0.0, 5e17, \'n\',\'b\'],\n            [ 200.0, \'AlGaAs\', 0.3, 0.0, 5e17, \'n\',\'b\']]\n \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_multi_qw_barrierdope_p""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_multi_qw_barrierdope_p2.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 4\nsubnumber_e = 2\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 1.8\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.2 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 200.0, \'AlGaN\', 0.3, 0.0, 5e18, \'p\',\'b\'],\n            [ 2.0, \'AlGaN\', 0.3, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'AlGaN\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaN\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaN\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaN\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaN\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaN\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 8.0, \'AlGaN\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'GaN\', 0.0, 0.0, 0.0, \'p\',\'w\'],\n            [ 2.0, \'AlGaN\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 2.0, \'AlGaN\', 0.3, 0.0, 5e17, \'n\',\'b\'],\n            [ 200.0, \'AlGaN\', 0.3, 0.0, 5e17, \'n\',\'b\']]\n#---------------------------------------- \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_multi_qw_barrierdope_p2""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_multi_qw_barrierdope_p_ingan.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 2\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.0 # (V/m)\nvmax= 3.1\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 200.0, \'GaN\', 0.0, 0.0, 5e18, \'p\',\'b\'],\n            [ 2.0, \'GaN\', 0.0, 0.0, 5e18, \'p\',\'b\'],\n            [ 2.0, \'GaN\', 0.0, 0.0, 5e18, \'p\',\'b\'],\n            [ 3.0, \'InGaN\', 0.15, 0.0, 0.0,\'p\',\'w\'],\n            [ 3.0, \'GaN\', 0.0,0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'InGaN\', 0.15, 0.0, 0.0,\'p\',\'w\'],\n            [ 5.0, \'GaN\', 0.0,0.0, 0.0, \'p\',\'b\'],\n            [ 3.0, \'InGaN\', 0.15, 0.0, 0.0,\'p\',\'w\'],\n            [ 2.0, \'GaN\', 0.0, 0.0, 5e18,\'n\',\'b\'],                           \n            [ 2.0, \'GaN\', 0.0, 0.0, 5e18, \'n\',\'b\'],\n            [ 200.0, \'GaN\', 0.0, 0.0, 5e18, \'n\',\'b\']]\n\nmaterial1 =[[ 20.0, \'GaN\', 0.0, 0.0, 5e18, \'p\',\'b\'],\n            [ 20.0, \'AlGaN\', 0.18, 0.0, 5e18, \'p\',\'b\'],\n            [ 8.0, \'InGaN\', 0.035, 0.0, 5e18, \'p\',\'b\'],\n            [ 4.0, \'InGaN\', 0.1, 0.0, 0.0,\'p\',\'w\'],\n            [ 8.0, \'InGaN\', 0.035,0.0, 0.0, \'p\',\'b\'],\n            [ 4.0, \'InGaN\', 0.1, 0.0, 0.0,\'p\',\'w\'],\n            [ 8.0, \'InGaN\', 0.035,0.0, 0.0, \'p\',\'b\'],\n            [ 4.0, \'InGaN\', 0.1, 0.0, 0.0,\'p\',\'w\'],\n            [ 8.0, \'InGaN\', 0.035, 0.0, 5e18,\'p\',\'b\'],                           \n            [ 20.0, \'AlGaN\', 0.18, 0.0, 5e18, \'p\',\'b\'],\n            [ 20.0, \'GaN\', 0.0, 0.0, 5e18, \'p\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_multi_qw_barrierdope_p_ingan""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_pn.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------------------------------\n# Input File Description:  Si p/n junction.\n# ----------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel map\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\n#meff_method = 0\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\nsubnumber_h = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)2.5e7/50e-9\nvmax= 1.2\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\nT     = 300              # [K]\n# For 1D, z-axis is choosen\ngridfactor = 1\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial1 =[[3140.5, \'Si\', 0.0, 0.0, 0.7e+17, \'p\',\'b\'],          \n            [3140.5, \'Si\', 0.0, 0.0, 0.7e+16, \'n\',\'b\']]\nmaterial =[[500, \'Si\', 0.0, 0.0, 1e+19, \'p\',\'b\'],          \n            [500, \'Si\', 0.0, 0.0,1e+19, \'n\',\'b\']]\n#---------------------------------------- \ninputfilename = ""sample_pn""\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#---------------------------------------- \nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)'"
examples/sample_pn2.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------------------------------\n# Input File Description:  Si p/n junction.\n# ----------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\n# 10: Schrodinger-Poisson under testing using Newton iteration (will replace scheme 2)\ncomputation_scheme = 2\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\n#meff_method = 0\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\nsubnumber_h = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)2.5e7/50e-9\nvmax= 2.0\nvmin= 0.0\nEach_Step=0.05# For 1D, z-axis is choosen\ngridfactor = 1\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[500, \'Si\', 0.1, 0.0, 1e+19, \'p\',\'b\'],\n            [500, \'Si\', 0.1, 0.0, 1e+19, \'n\',\'b\']]\n\n\nmaterial1 =[[350, \'InGaAs\', 0.1, 0.0, 1e+16, \'p\',\'b\'],\n            [15, \'InAs\', 0.0, 0.0, 1e+16, \'n\',\'w\'],\n            [600, \'InGaAs\', 0.1, 0.0, 1e+17, \'n\',\'b\']] \n#---------------------------------------- \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_pn2""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)'"
examples/sample_pn3.py,3,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sun May  6 00:14:09 2018\n\n@author: GAMING\n""""""\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 2\nsubnumber_e = 2\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 0.6\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 10 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction x|Alloy fraction y| Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |      0         |      1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |      0         |      1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 2500.0, \'Si\', 0.0, 0.0, 1e18, \'p\',\'b\'],\n            [ 2500.0, \'Si\', 0.0, 0.0, 1e18, \'n\',\'b\']]\n#---------------------------------------- \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#---------------------------------------- \ninputfilename = ""sample_pn3""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_HarrisonCh3_3.py,2,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Trying to replicate some results given in sec. 3.3 \n#               of Paul Harrison\'s book ""Quantum Well\'s Wires and Dots"".\n# -------------------------------------------------------------------\n\n# ----------------\n# HARRISON\'S MATERIAL VALUES\n# ----------------\nimport database\n\n# Nb. Harrison\'s initial examples don\'t take account of different effective masses\n# in the different materials.\n\ndatabase.materialproperty = {\n    \'GaAs\':{\n        \'m_e\':0.067,\n        \'m_e_alpha\':0.0,\n        \'epsilonStatic\':12.90,\n        \'Eg\':0.0, #1.426, # set the energy scale origin to be at the GaAs condution band\n        \'Band_offset\':0.67,\n        },\n    \'AlAs\':{\n        \'m_e\':0.067, # normally Harrison would be using 0.15\n        \'m_e_alpha\':0.0,\n        \'epsilonStatic\':10.06,\n        \'Eg\':2.673-1.426, #2.673, # set the energy scale origin to be at the GaAs condution band\n        \'Band_offset\':0.67,\n        },\n    }\n\ndatabase.alloyproperty = {\n    \'AlGaAs\':{\n        \'Bowing_param\':0.0,\n        \'Band_offset\':0.67,\n        \'Material1\':\'AlAs\',\n        \'Material2\':\'GaAs\',\n        \'m_e_alpha\':0.0,\n        },\n    }\n\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ncomputation_scheme = 0\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 0\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 1\n\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n\n# The two structures defined in the text:\nmaterial =[[ 15.0, \'AlGaAs\', 0.2, 0.0, \'n\'],\n            [ 10.0, \'GaAs\',     0, 1e10, \'n\'],\n            [ 15.0, \'AlGaAs\', 0.2, 0.0, \'n\']]\n\n\n\n\nif __name__==""__main__"":\n    import matplotlib.pyplot as pl\n    import numpy as np\n    #import config\n    import aestimo\n    import database\n    \n    logger = aestimo.logger\n    \n    # Initialise structure class\n    model = aestimo.StructureFrom(globals(),database)\n    model.create_structure_arrays()\n    \n    result= aestimo.Poisson_Schrodinger(model)\n    \n    # Perform the calculation using different gridfactors\n    results = []\n    gridfactors = [0.2,0.1,0.05,0.02,0.01] #nm\n    for gridfactor in gridfactors:\n        model.dx = gridfactor*1e-9\n        model.create_structure_arrays() #updates our structure object\n        result= aestimo.Poisson_Schrodinger(model)\n        results.append(result.E_state[0]) #-np.min(model.fi)*aestimo.J2meV)\n    \n    logger.info(\'gridfactor (nm),E[0]\')\n    for gridfactor,E in zip(gridfactors,results): logger.info(\'%g,%g\',gridfactor,E)\n    \n    # Perform the calculation using different barrier widths\n    results2 = []\n    barrier_widths = [5,6,7,8,9,10,11,12,13,14,15,16,18,20,25,30,35] #nm\n    for barrier in barrier_widths:\n        material[0][0]=barrier;material[2][0]=barrier\n        model = aestimo.StructureFrom(globals(),database)\n        model.create_structure_arrays()\n        result= aestimo.Poisson_Schrodinger(model)\n        results2.append(result.E_state[0]) #-np.min(model.fi)*aestimo.J2meV)\n    \n    logger.info(\'barrier (nm),E[0]\')\n    for barrier,E in zip(barrier_widths,results2): logger.info(\'%g,%g\',barrier,E)\n        \n    f1 = pl.figure()\n    ax1 = f1.add_subplot(111)\n    ax1.set_xlim(0,40)\n    ax1.plot(barrier_widths,results2,\'-o\')\n    \n    # Write the simulation results in files\n    #aestimo.save_and_plot(result,model)\n    \n    #Plot QW representation\n    aestimo.QWplot(result)#,figno=None)\n    \n'"
examples/sample_qw_HarrisonCh3_5.py,6,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Trying to replicate some results given in sec.3.5 \n#               of Paul Harrison\'s book ""Quantum Well\'s Wires and Dots"".\n#               Modelling a parabolic quantum well.\n# -------------------------------------------------------------------\n\n# ----------------\n# HARRISON\'S MATERIAL VALUES\n# ----------------\nimport database\nimport config\nimport numpy as np\nimport aestimo\n#import database\nmeV2J = aestimo.meV2J # conversion factor\nq = aestimo.q # electron charge\n\nlogger=aestimo.logger\n\n# Nb. Harrison\'s initial examples don\'t take account of different effective masses\n# in the different materials.\n\nmaterialproperty = {\n    \'GaAs\':{\n        \'m_e\':0.067,\n        \'m_e_alpha\':0.0,\n        \'epsilonStatic\':12.90,\n        \'Eg\':0.0, #1.426, # set the energy scale origin to be at the GaAs condution band\n        \'Band_offset\':0.67,\n        },\n    \'AlAs\':{\n        \'m_e\':0.067, # normally Harrison would be using 0.15\n        \'m_e_alpha\':0.0,\n        \'epsilonStatic\':10.06,\n        \'Eg\':2.673-1.426, #2.673, # set the energy scale origin to be at the GaAs condution band\n        \'Band_offset\':0.67,\n        },\n    }\n\nalloyproperty = {\n    \'AlGaAs\':{\n        \'Bowing_param\':0.0,\n        \'Band_offset\':0.67,\n        \'Material1\':\'AlAs\',\n        \'Material2\':\'GaAs\',\n        \'m_e_alpha\':0.0,\n        },\n    }\n\n# ----------------\n# GENERAL SETTINGS\n# ----------------\ns0 = {}\n\n\n# TEMPERATURE\ns0[\'T\'] = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ns0[\'comp_scheme\']= 0\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\ns0[\'meff_method\']= 0\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\ns0[\'fermi_np_scheme\'] = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\ns0[\'subnumber_e\'] = 10\n\n# APPLIED ELECTRIC FIELD\ns0[\'Fapp\'] = 0.00 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.01 #nm\ns0[\'dx\'] = gridfactor*1e-9\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblind\'\n## Create structure arrays -----------------------------------------------------\n\n# We can\'t declare our structure in the usual way using the StructureFrom class\n# instead we will have to create and the structure arrays ourselves and work with\n# the parent Structure class.\n\n# STRUCTURE\n# a finite parabolic well between two barriers\na = 10.0 #nm #maximum width of parabolic well (at the barrier\'s energy level)\nb = 10.0 #nm #width of the first barrier layer\nb2 = 5.0 #nm #width of the first barrier layer\nxmin = 0.0 #minimum Al alloy in structure\nxmax = 10.0 #maximum Al alloy in structure\n\n\ndef alloy_profile(z):\n    """"""function of alloy profile for finite parabolic well""""""\n    well = xmin + (z - (b+a/2.0))**2 / (a/2.0)**2 * (xmax - xmin)    \n    return np.where(well<xmax,well,xmax) #cuts off parabolic well at barrier height\n\ndef bandstructure_profile(x):\n    mat1 = materialproperty[\'AlAs\']\n    mat2 = materialproperty[\'GaAs\']\n    alloy = alloyproperty[\'AlGaAs\']\n    return alloy[\'Band_offset\']*(x*mat1[\'Eg\'] + (1-x)* mat2[\'Eg\']-alloy[\'Bowing_param\']*x*(1-x))*aestimo.q # for electron. Joule\n    #return alloy[\'Band_offset\']*(x*mat1[\'Eg\'] + (1-x)* mat2[\'Eg\'])*aestimo.q # for electron. Joule\n\n# Calculate the required number of grid points\ns0[\'x_max\'] = sum([b,a,b2])*1e-9 #total thickness (m)\ns0[\'n_max\'] = n_max = int(s0[\'x_max\']/s0[\'dx\'])\n# Check on n_max\nif s0[\'n_max\']> maxgridpoints:\n    aestimo.logger("" Grid number is exceeding the max number of %d"", maxgridpoints)\n    exit()\n#\nmeff = materialproperty[\'GaAs\'][\'m_e\']*aestimo.m_e\nepsGaAs = materialproperty[\'GaAs\'][\'epsilonStatic\']\n\nz = np.arange(0.0,s0[\'x_max\'],s0[\'dx\'])*1e9 #nm\n\ns0[\'cb_meff\'] = np.ones(n_max)*meff\t#conduction band effective mass\n#s0[\'cb_meff_alpha\'] = np.zeros(n_max)   #non-parabolicity constant.\ns0[\'eps\'] = np.ones(n_max)*epsGaAs\t#dielectric constant\ns0[\'dop\'] = np.ones(n_max)*0.0          #doping\ns0[\'fi\'] = bandstructure_profile(alloy_profile(z))   #Bandstructure potential\n\n#logger.info(s0.items())\n#model = aestimo.Structure(T,Fapp,subnumber_e,dx,n_max, #parameters\n                 #fi,eps,dop,cb_meff, #arrays\n                 #comp_scheme,meff_scheme,fermi_np_scheme, #model choices\n                 #cb_meff_alpha=None,Eg=None,Ep=None,F=None,delta_S0=None, #optional arrays\n                 #**kwargs)\nmodel = aestimo.Structure(**s0)\n\n## -----------------------------------------------------------------------------\n\nif __name__ == ""__main__"":\n    #config.d_E = 1e-5*meV2J\n    #config.Estate_convergence_test = 3e-10*meV2J\n    result= aestimo.Poisson_Schrodinger(model)\n\n    #Plot QW representation\n    config.wavefunction_scalefactor = 5000\n    fig = aestimo.QWplot(result)#,figno=None)\n\n'"
examples/sample_qw_barrierdope.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 7\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 3\nsubnumber_e = 3\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 1.8\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\n\nmaterial =[[ 180.0, \'AlGaAs\', 0.3, 0.0, 0.95e18, \'p\',\'b\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'p\',\'b\'],\n            [ 10.0, \'AlGaAs\', 0.3, 0.0, 1e15, \'n\',\'b\'],\n            [ 10.0, \'GaAs\', 0.0, 0.0, 1e15, \'n\',\'w\'],\n            [ 10.0, \'AlGaAs\', 0.3, 0.0, 1e15, \'n\',\'b\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0 , \'n\',\'b\'],\n            [ 180.0, \'AlGaAs\', 0.3, 0.0, 0.95e18, \'n\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#Doping profiles based on the LSS theory (ion implantation).\n#----------------------------------------\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\n""""""\nsurface[1]=-0.6\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6#n_max-1-i\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    dop_profile[i]=dop_n[i]+dop_p[i]\n""""""\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope"" \nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_ingaas.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\n# 10: Schrodinger-Poisson under testing using Newton iteration (will replace scheme 2)\ncomputation_scheme = 10\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 0.6\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\nmaterial =[[ 245.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'i\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'i\',\'w\'],\n           [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0,\'i\',\'b\'],\n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 0.8e18,\'n\',\'b\'],           \n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.8e18, \'n\',\'b\']]\n\nmaterial2 =[[ 15.0, \'GaAs\', 0.0, 0.0, 1e18, \'n\',\'b\'],\n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 1e18,\'n\',\'b\'],\n           [ 5.0, \'AlGaAs\', 0.3, 0.0, 0.0,\'i\',\'b\'],\n           [ 15.0, \'GaAs\', 0.0, 0.0, 0.0,\'i\',\'w\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'i\',\'b\'],           \n           [ 245.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\nxaxis = np.arange(0,n_max)*gridfactor#[nm]\nQ_n=2e12#implant dose [1/cm2]\nRp_n=86#projected range Rp [nm]\nDelta_Rp_n=44#projected straggle Delta Rp [nm]\nQ_p=1e11#implant dose [1/cm2]\nRp_p=75#projected range Rp [nm]\nDelta_Rp_p=20#projected straggle Delta Rp [nm]\nfrom math import sqrt, exp\ndef Lss_profile_dop(x,Q,Delta_Rp,Rp):   \n    return Q/(sqrt(2*np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(2*Delta_Rp**2))\ndef Lss_profile_dop_diff(x,Q,Delta_Rp,Rp):   \n    return Q/(2*sqrt(np.pi)*Delta_Rp*1e-7)*exp(-(x-Rp)**2/(4*Delta_Rp**2))\nfor i in range(n_max):   \n    dop_n[i]=Lss_profile_dop(xaxis[n_max-1-i],Q_n,Delta_Rp_n,Rp_n)*1e6#n_max-1-i\n    dop_p[i]=-Lss_profile_dop(xaxis[n_max-1-i],Q_p,Delta_Rp_p,Rp_p)*1e6\n    dop_profile[i]=dop_n[i]+dop_p[i]\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\nsurface[1]=0.6\nsurface[0]=0.0\n#---------------------------------------- \ninputfilename = ""sample_qw_barrierdope_ingaas""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_ingan.py,5,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 2\nsubnumber_e = 2\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 3.1\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5#nm\nmaxgridpoints = 200000 #for controlling the size\n#mat_type=\'Zincblende\'\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\n\nmaterial =[[ 30.0  , \'GaN\'  , 0.3 , 0.0, 2e20, \'p\',\'b\'],           \n           [ 100.0 , \'AlGaN\', 0.14, 0.0, 1e20, \'p\',\'b\'],                      \n           [ 50.0  , \'GaN\'  , 0.3 , 0.0, 5e18, \'p\',\'b\'],\n           [ 20.0  , \'AlGaN\', 0.2 , 0.0, 1e19, \'p\',\'b\'],           \n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 50.0  , \'GaN\'  , 0.3 , 0.0, 7e17, \'n\',\'b\'],\n           [ 100.0 , \'AlGaN\', 0.14, 0.0, 3e18, \'n\',\'b\'],\n           [ 50.0  , \'InGaN\', 0.1 , 0.0, 3e18, \'n\',\'b\'],\n           [ 100.0 , \'GaN\'  , 0.3 , 0.0, 3e18, \'n\',\'b\']]\n\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_ingan""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_ingan_2.py,5,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.#0.41348e8 (V/m)\nvmax= 3.1\nvmin= 0.0\nEach_Step=0.5\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5#nm\nmaxgridpoints = 200000 #for controlling the size\n#mat_type=\'Zincblende\'\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\n\n\n\nmaterial =[[ 30.0  , \'GaN\'  , 0.3 , 0.0, 2e20, \'p\',\'b\'],           \n           [ 100.0 , \'AlGaN\', 0.14, 0.0, 1e20, \'p\',\'b\'],                      \n           [ 50.0  , \'GaN\'  , 0.3 , 0.0, 5e18, \'p\',\'b\'],\n           [ 20.0  , \'AlGaN\', 0.2 , 0.0, 1e19, \'p\',\'b\'],           \n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 4.0   , \'InGaN\', 0.02, 0.0, 7e16, \'n\',\'w\'],\n           [ 10.0  , \'AlGaN\', 0.2 , 0.0, 7e16, \'n\',\'b\'],\n           [ 50.0  , \'GaN\'  , 0.3 , 0.0, 7e17, \'n\',\'b\'],\n           [ 100.0 , \'AlGaN\', 0.14, 0.0, 3e18, \'n\',\'b\'],\n           [ 50.0  , \'InGaN\', 0.1 , 0.0, 3e18, \'n\',\'b\'],\n           [ 100.0 , \'GaN\'  , 0.3 , 0.0, 3e18, \'n\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\n#Doping profiles based on the LSS theory (ion implantation).\ndop_n=np.zeros(n_max)\ndop_p=np.zeros(n_max)\ndop_profile=np.zeros(n_max)\n\n""""""   \nimport matplotlib.pyplot as pl\npl.plot(xaxis, dop_n*1e-6,\'r\',xaxis,dop_p*1e-6,\'b\')\n#pl.plot(xaxis, dop_profile*1e-6,\'k\')\npl.xlabel(\'Position (m)\')\npl.ylabel(\'electrons  and and holes concentrations (cm-3)\' )\npl.title(\'electrons (red) and holes (blue)\')\npl.grid(True)\nkhkhk\n""""""\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_ingan_2""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 2\nsubnumber_e = 2\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 1.4\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\ndopp=5e17\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 100.0, \'AlGaAs\', 0.3, 0.0, dopp, \'p\',\'b\'],\n            [ 40.0, \'AlGaAs\', 0.3, 0.0, dopp, \'p\',\'b\'],\n            [ 20.0, \'GaAs\', 0.0, 0.0, 0.0,\'n\',\'w\'],\n            [ 40.0, \'AlGaAs\', 0.3, 0.0, dopp, \'n\',\'b\'],\n            [ 100.0, \'AlGaAs\', 0.3, 0.0, dopp, \'n\',\'b\']]\n#---------------------------------------- \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\nn_max=int(x_max/gridfactor)\n#---------------------------------------- \ndop_profile=np.zeros(n_max) \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_p""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p_AlGaInN.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 2.9\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction x|Alloy fraction y| Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |      0         |      1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |      0         |      1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 200.0, \'AlGaN\', 0.1, 0.0, 1e17, \'p\',\'b\'],\n            [ 2.0, \'AlGaInN\', 0.48, 0.23, 1e17, \'p\',\'b\'],\n            [ 2.0, \'InGaN\', 0.25, 0.0, 0.0, \'i\',\'w\'],\n            [ 3.0, \'AlGaInN\', 0.48, 0.23, 0.0, \'i\',\'b\'],\n            [ 2.0, \'InGaN\', 0.25, 0.0, 0.0, \'i\',\'w\'],\n            [ 2.0, \'AlGaInN\', 0.48, 0.23, 1e17, \'n\',\'b\'],\n            [ 200.0, \'AlGaN\', 0.1, 0.0, 1e17, \'n\',\'b\']]\n \n#This is accourding to interpolated Vegard\xe2\x80\x99s law for quaternary ABxCyD1-x-y=NGaxAlyIn1-x-y\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)  \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#---------------------------------------- \ninputfilename = ""sample_qw_barrierdope_p_AlGaInN""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p_AlGaInN_2.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 2.9\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction x|Alloy fraction y| Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |      0         |      1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |      0         |      1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 100., \'GaN\', 0.0, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'AlGaInN\', 0.46, 0.38, 5e17, \'p\',\'w\'],\n            [ 5.0, \'AlGaInN\', 0.48, 0.23, 5e17, \'p\',\'b\'],\n            [ 2.0, \'InGaN\', 0.23, 0.0, 0.0, \'p\',\'w\'],\n            [ 2.0, \'AlGaInN\', 0.48, 0.23, 0.0, \'p\',\'b\'],\n            [ 2.0, \'InGaN\', 0.23, 0.0, 0.0, \'p\',\'w\'],\n            [ 5.0, \'AlGaInN\', 0.48, 0.23, 5e17, \'n\',\'b\'],\n            [ 100., \'GaN\', 0.0, 0.0, 5e17, \'n\',\'b\']]\n#This is accourding to interpolated Vegard\xe2\x80\x99s law for quaternary ABxCyD1-x-y=NGaxAlyIn1-x-y\n#---------------------------------------- \nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)  \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_p_AlGaInN_2""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p_InGaAsP.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.7#/50e-9 # (V/m)\nvmax= 1.9\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction x|Alloy fraction y| Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |      0         |      1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |      0         |      1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial1 =[[ 200.0, \'InP\', 0.0, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.923, 0.325, 5e17, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.485, 0.979, 0.0, \'p\',\'w\'],\n            [ 3.8, \'InGaAsP\', 0.923, 0.325, 0.0, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.485, 0.979, 0.0, \'n\',\'w\'],\n            [ 2.0, \'InGaAsP\', 0.923, 0.325, 5e17, \'n\',\'b\'],\n            [ 200.0, \'InP\', 0.0, 0.0, 5e17, \'n\',\'b\']]\nmaterial =[[ 200.0, \'InP\', 0.0, 0.0, 5e17, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.923, 0.325, 5e17, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.485, 0.979, 0.0, \'p\',\'w\'],\n            [ 3.8, \'InGaAsP\', 0.923, 0.325, 0.0, \'p\',\'b\'],\n            [ 2.0, \'InGaAsP\', 0.485, 0.979, 0.0, \'n\',\'w\'],\n            [ 2.0, \'InGaAsP\', 0.923, 0.325, 5e17, \'n\',\'b\'],\n            [ 100.0, \'InP\', 0.0, 0.0, 5e17, \'n\',\'b\']]\n #----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2) \n#----------------------------------------\n#This is accourding to interpolated Vegard\xe2\x80\x99s law for quaternary AxB(1-x)CyD(1-y)=InxGa(1-x)AsyP(1-y)\n#---------------------\ninputfilename = ""sample_qw_barrierdope_p_InGaAsP""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p_algan_gan_heterojunction.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\nimport numpy as np\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)-20e8\nvmax= 0.1\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\ncontact=0.0\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\n\n\nmaterial =[[ 14.0, \'GaN\', 0.0, 0.0,0.0, \'i\',\'NA\'],\n           [ 30.0, \'AlGaN\', 0.3, 0.0,0.0, \'i\',\'NA\'],\n            [ 40.0, \'GaN\', 0.0, 0.0,  0.0, \'i\',\'NA\']]\n\nmaterial1 =[[ 100.0, \'GaN\', 0.0, 0.0,0.0, \'i\',\'NA\'],\n           [ 17.0, \'AlGaN\', 0.3, 0.0,0.0, \'i\',\'NA\'],\n            [ 100.0, \'GaN\', 0.0, 0.0,  0.0, \'i\',\'NA\']]\n\nmaterial2 =[[ 30.0, \'AlGaN\', 0.3, 0.0,0.0, \'i\',\'NA\'],\n            [ 40.0, \'GaN\', 0.0, 0.0,  0.0, \'i\',\'NA\']]\n#----------------------------------------\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=True\n#--------------------------------\nQuantum_Regions_boundary=np.zeros((1,2))\nQuantum_Regions_boundary[0,0]=2\nQuantum_Regions_boundary[0,1]=55\n#----------------------------------\n#Quantum_Regions_boundary[0,0]=90\n#Quantum_Regions_boundary[0,1]=127\n#---------------------------------\n#Quantum_Regions_boundary[0,0]=28\n#Quantum_Regions_boundary[0,1]=50\n\n#----------------------------------------\nsurface=np.zeros(2)\nsurface[0]=-0.2\nsurface[1]=-1.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_p_algan_gan_heterojunction""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_barrierdope_p_cdzno.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\ncontact=0.0\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 2\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 1\nsubnumber_e = 1\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00#/50e-9 # (V/m)\nvmax= 2.9\nvmin= 0.0\nEach_Step=0.05\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.5 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Wurtzite\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\nmaterial =[[ 50.0, \'CdZnO\', 0.05, 0.0, 5e17, \'p\',\'b\'],\n            [ 3.0, \'CdZnO\', 0.2, 0.0, 0, \'p\',\'w\'],\n            [ 50.0, \'CdZnO\', 0.05, 0.0, 5e17, \'n\',\'b\']]\n\nmaterial1 =[[ 300.0, \'ZnO\', 0.0, 0.0, 5e19, \'p\',\'b\'],\n            [ 20.0, \'ZnO\', 0.0, 0.0, 0.0, \'p\',\'b\'],\n            [ 5.0, \'CdZnO\', 0.2, 0.0, 0, \'p\',\'w\'],\n            [ 20.0, \'ZnO\', 0.0, 0.0, 0.0, \'p\',\'b\'],\n            [ 200.0, \'ZnO\', 0.0, 0.0, 5e19, \'n\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((1,2))\nQuantum_Regions_boundary[0,0]=45\nQuantum_Regions_boundary[0,1]=58\n#----------------------------------------\nsurface=np.zeros(2)\n#surface[0]=-0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_p_cdzno""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)'"
examples/sample_qw_barrierdope_p_ingaas.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\n# 7: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson then  poisson and DD)\n# 8: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD)\n# 9: Schrodinger-Poisson-Drift_Diffusion (Schrodinger solved with poisson and DD) using Gummel & Newton map\ncomputation_scheme = 9\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_h = 3\nsubnumber_e = 3\n# APPLIED ELECTRIC FIELD\nFapplied =  0.0# (V/m)-20e8\nvmax= 1.5\nvmin= 0.0\nEach_Step=0.05# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1#nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n# To input this list in Gallium, we use lists N:\nmaterial =[[ 150.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\'],\n           [ 10.0, \'AlGaAs\', 0.3, 0.0, 1e17, \'p\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'n\',\'w\'],\n           [ 50.0, \'AlGaAs\', 0.3, 0.0, 0.0, \'n\',\'b\'],\n           [ 15.0, \'GaAs\', 0.3, 0.0, 0.0,\'n\',\'w\'],           \n           [ 20.0, \'AlGaAs\', 0.3, 0.0, 1e18, \'n\',\'b\'],\n           [ 30.0, \'GaAs\', 0.3, 0.0, 1e18, \'n\',\'b\']]\n#----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)\n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------  \nsurface=np.zeros(2)\nsurface[1]=-0.6\n#----------------------------------------\ninputfilename = ""sample_qw_barrierdope_p_ingaas""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_periodic_potential.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 60.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ncomputation_scheme = 6\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# (optional) Dopant Poisson field boundary condition\n# (only applies to electric field from dopants)\n# 0: Efield = 0 at boundaries\n# 1: Periodic Potential \nboundary_scheme = 1\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 3\n# Total subband number to be calculated for electrons (for aestimo_numpy_h)\nsubnumber_h = 1\n\n# APPLIED ELECTRIC FIELD\nFapplied = 0.0/50e-9 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 5e17, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 11.0, \'GaAs\', 0, 0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0e17, \'n\'],\n            [ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\']]\n \n\ninputfilename = ""sample_qw_periodic_potential""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo\n    aestimo.run_aestimo(input_obj)\n    \n'"
examples/sample_qw_qwdope.py,3,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ------------------------------------------------------------------------\n# Input File Description:  Quantum well doped AlGaAs/GaAs heterostructure.\n# ------------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 300.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ncomputation_scheme = 9\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 2\nsubnumber_h = 2\n# APPLIED ELECTRIC FIELD\nFapplied = 0.7 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 1 #nm\nmaxgridpoints = 200000 #for controlling the size\nmat_type=\'Zincblende\'\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm)  | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |       250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |       250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 200.0, \'AlGaAs\', 0.2,0.2,  0, \'n\',\'b\'],\n            [10.0, \'GaAs\', 0,0.2,  2e18, \'n\',\'w\'],\n            [200.0, \'AlGaAs\', 0.2,0.2,  0, \'n\',\'b\']]\n #----------------------------------------\nimport numpy as np\nx_max = sum([layer[0] for layer in material])\ndef round2int(x):\n    return int(x+0.5)\nn_max=round2int(x_max/gridfactor)\n#----------------------------------------\ndop_profile=np.zeros(n_max)  \n#----------------------------------------\nQuantum_Regions=False\nQuantum_Regions_boundary=np.zeros((2,2))\n#----------------------------------------\nsurface=np.zeros(2)\n#surface[0]=-0.6\n#---------------------------------------- \ninputfilename = ""sample_qw_qwdope""\nfrom os import path\nif __name__ == ""__main__"": #this code allows you to run the input file directly\n    input_obj = vars()\n    import sys\n    sys.path.append(path.join(path.dirname(__file__), \'..\'))\n    import aestimo_eh\n    aestimo_eh.run_aestimo(input_obj)\n'"
examples/sample_qw_wide_isbt.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------\n# Input File Description:  Barrier doped AlGaAs/GaAs heterostructure.\n# -------------------------------------------------------------------\n# ----------------\n# GENERAL SETTINGS\n# ----------------\n\n# TEMPERATURE\nT = 60.0 #Kelvin\n\n# COMPUTATIONAL SCHEME\n# 0: Schrodinger\n# 1: Schrodinger + nonparabolicity\n# 2: Schrodinger-Poisson\n# 3: Schrodinger-Poisson with nonparabolicity\n# 4: Schrodinger-Exchange interaction\n# 5: Schrodinger-Poisson + Exchange interaction\n# 6: Schrodinger-Poisson + Exchange interaction with nonparabolicity\ncomputation_scheme = 2\n\n# Non-parabolic effective mass function\n# 0: no energy dependence\n# 1: Nelson\'s effective 2-band model\n# 2: k.p model from Vurgaftman\'s 2001 paper\nmeff_method = 2\n\n# Non-parabolic Dispersion Calculations for Fermi-Dirac\nfermi_np_scheme = True\n\n# QUANTUM\n# Total subband number to be calculated for electrons\nsubnumber_e = 6\n# Total subband number to be calculated for electrons (for aestimo_numpy_h)\nsubnumber_h = 1\n\n# APPLIED ELECTRIC FIELD\nFapplied = 0.00/50e-9 # (V/m)\n\n# --------------------------------\n# REGIONAL SETTINGS FOR SIMULATION\n# --------------------------------\n\n# GRID\n# For 1D, z-axis is choosen\ngridfactor = 0.1 #nm\nmaxgridpoints = 200000 #for controlling the size\n\n# DOPING\nNd = 2e18\n\n# REGIONS\n# Region input is a two-dimensional list input.\n# An example:\n# Si p-n diode. Firstly lets picturize the regional input.\n#         | Thickness (nm) | Material | Alloy fraction | Doping(cm^-3) | n or p type |\n# Layer 0 |      250.0     |   Si     |      0         |     1e16      |     n       |\n# Layer 1 |      250.0     |   Si     |      0         |     1e16      |     p       |\n#\n# To input this list in Gallium, we use lists as:\nmaterial =[[ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, Nd/2.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 30.0, \'GaAs\', 0, 0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, 0.0, \'n\'],\n            [ 5.0, \'AlGaAs\', 0.3, Nd/2.0, \'n\'],\n            [ 10.0, \'AlGaAs\', 0.3, 0.0, \'n\']]\n \n\n\nif __name__==""__main__"":\n    import config\n    import database\n    import aestimo\n    import intersubband_optical_transitions as isbt\n    import numpy as np\n    import os\n    import time\n    \n    logger = aestimo.logger\n    \n    # Initialise structure class\n    model = aestimo.StructureFrom(vars(),database)\n    \n    if True: #recalculate QW states\n        # Perform the calculation\n        result = aestimo.Poisson_Schrodinger(model)\n        \n        time4 = time.time() #timing audit\n        logger.info(""total running time (inc. loading libraries) %g s"",(time4 - aestimo.time0))\n        logger.info(""total running time (exc. loading libraries) %g s"",(time4 - aestimo.time1))\n        \n        # Write the simulation results in files\n        fig1,fig2,fig3 = aestimo.save_and_plot(result,model)\n        logger.info(""Simulation is finished."")\n    else: #load previously calculated results from output directory\n        result = aestimo.load_results()\n    \n    #Set thickness of effective medium\n    Lperiod = sum([layer[0] for layer in model.material])*1e-9 #m\n    \n    # set dielectric constants\n    case = 2\n    if case==1: #scalar dielectric constants\n        eps_b = 12.90\n        eps_z = 12.90\n    \n    elif case==2: #z-dependent dielectric constants\n        eps_b = 10.364\n        eps_gaas = 10.364 # @ 16um\n        eps_algaas = 8.2067\n        eps_z = isbt.eps_background_GaAs(model,eps_gaas,eps_algaas)\n    \n    # Linewidth\n    def linewidth(freq): return 0.1*freq #define linewidth in THz\n    \n    # Optical Intersubband Transitions\n    transitions_table,(hdr,units) = isbt.transitions(result,Lperiod,eps_z,linewidth)\n    \n    isbt.print_levels(result)\n    isbt.print_transitions(transitions_table,hdr,units)\n    isbt.print_multiplasmon_transitions(*isbt.calc_wR_multiplasmon(result,transitions_table,eps_z))\n    \n    fig4 = isbt.plotting_absorption(model,result,transitions_table,eps_b,eps_z,linewidth)\n\n'"
examples/samples.py,0,b'# -*- coding: utf-8 -*-\n\nimport sample_double_qw_isbt\nimport sample_double_qw_isbt\nimport sample_moddop\nimport sample_multi_qw_barrierdope_p\nimport sample_multi_qw_barrierdope_p_ingan\nimport sample_pn\nimport sample_qw_HarrisonCh3_3\nimport sample_qw_HarrisonCh3_5\nimport sample_qw_barrierdope_p_cdzno\nimport sample_qw_barrierdope_p_ingan\nimport sample_qw_barrierdope\nimport sample_qw_qwdope\nimport sample_qw_wide_isbt\nimport sample_qw_periodic_potential\n'
