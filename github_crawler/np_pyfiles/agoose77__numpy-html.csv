file_path,api_count,code
numpy_html/__init__.py,2,"b'from .formatter import array_to_html\nimport numpy as np\n\n\ndef install_jupyter_hook(cls=np.ndarray):\n    """"""Install Jupyter display hook for a given array class\n\n    :param cls: numpy-like array which is compatible with np.printoptions and np.array2string\n    :return:\n    """"""\n    from IPython import get_ipython\n    ipython = get_ipython()\n    if ipython is None:\n        raise RuntimeError(""Must be running inside IPython environment"")\n    html_formatter = ipython.display_formatter.formatters[""text/html""]\n    return html_formatter.for_type(cls, array_to_html)\n\n\ntry:\n    install_jupyter_hook()\nexcept (ImportError, RuntimeError):\n    pass\n'"
numpy_html/formatter.py,4,"b'import typing\nfrom contextlib import contextmanager\n\nimport numpy as np\n\nfrom .renderer import render_table, ITEM_TYPE, INDEX_TYPE, TemplateItem\n\n# Type of elements or templates\nITEMS_TYPE = typing.Iterable[ITEM_TYPE]\n\n\ndef format_index(index: INDEX_TYPE) -> typing.Union[INDEX_TYPE, int]:\n    """"""Format the index tuple corresponding to a particular array element. Return the\n\n    :param index: tuple of integers representing the array index\n    :return: sole entry of `index` if a tuple of length 1, otherwise `index`\n    """"""\n    if len(index) == 1:\n        return index[0]\n    return index\n\n\ndef format_items(items: ITEMS_TYPE, format_element: typing.Callable[..., str], **format_kwargs) -> typing.Iterator[str]:\n    """"""Yield the formatted strings for the given items. Those items which are not templates are yielded directly.\n\n    :param items: iterable of templates or strings\n    :param format_element: array element formatter\n    :param format_kwargs: additional keyword arguments for element formatter\n    :return: Iterator of formatted strings\n    """"""\n    for item in items:\n        if isinstance(item, str):\n            yield item\n        else:\n            # We have a string template element, yield formatted string (using formatter and template)\n            template, index, element = item\n            yield template.format(format_index(index), format_element(element, **format_kwargs))\n\n\ndef fixed_format_element_npy(x, max_width: int = None) -> str:\n    """"""Fixed with formatter using numpy.array2string. If `max_width` is None, then return the formatted element\n    directly, otherwise left pad such that the final string has length `max_width`.\n\n    :param x: element to render\n    :param max_width: width of maximum element (predetermined)\n    :return: formatted string\n    """"""\n    # Use numpy to format element\n    x_str = np.array2string(x)\n    if max_width is None:\n        return x_str\n\n    # Return padded left-aligned string\n    return f""{x_str:{max_width}}""\n\n\ndef fixed_format_items(items: ITEMS_TYPE) -> typing.List[str]:\n    """"""Format items using a fixed with formatter.\n\n    :param items: iterable of templates or strings\n    :return: formatted string\n    """"""\n    items = list(items)\n\n    with np.printoptions(floatmode=""maxprec""):\n        template_lengths = [len(fixed_format_element_npy(t.item)) for t in items if isinstance(t, TemplateItem)]\n        try:\n            max_width = max(template_lengths)\n        except ValueError:\n            max_width = None\n        return [*format_items(items, fixed_format_element_npy, max_width=max_width)]\n\n\ndef array_to_html(\n    array: np.ndarray, formatter: typing.Callable[..., typing.List[str]] = fixed_format_items, **formatter_kwargs\n) -> str:\n    """"""Render NumPy array as an HTML table.\n\n    :param array: ndarray object\n    :param formatter: items formatter\n    :param formatter_kwargs: keyword arguments for items formatter\n    :return: HTML string\n    """"""\n    print_options = np.get_printoptions()\n    edge_items = print_options[""edgeitems""]\n    threshold = print_options[""threshold""]\n\n    if array.size < threshold:\n        edge_items = 0\n\n    items = render_table((), array, edge_items)\n    return ""\\n"".join(formatter(items, **formatter_kwargs))\n'"
numpy_html/renderer.py,12,"b'import typing\n\nimport numpy as np\n\n\nTD_ITEM_HTML_TEMPLATE = \'<td style=""font-family:monospace;white-space: pre;"" title=""{}""><center>{}</center></td>\'\n\nELLIPSIS_CELL_HTML_HORIZONTAL = TD_ITEM_HTML_TEMPLATE.format(""element(s) elided"", ""\\u2026"")\nELLIPSIS_CELL_HTML_VERTICAL = TD_ITEM_HTML_TEMPLATE.format(""element(s) elided"", ""\\u22EE"")\nELLIPSIS_CELL_HTML_DIAGONAL = TD_ITEM_HTML_TEMPLATE.format(""element(s) elided"", ""\\u22F1"")\nEMPTY_CELL_HTML = TD_ITEM_HTML_TEMPLATE.format(""empty array"", ""\\u2800"")\n\nINDEX_TYPE = typing.Tuple[int, ...]\n\n\nclass TemplateItem(typing.NamedTuple):\n    template: str\n    index: INDEX_TYPE\n    item: typing.Any\n\n\nITEM_TYPE = typing.Union[TemplateItem, str]\nITEM_GENERATOR_TYPE = typing.Iterator[ITEM_TYPE]\nSUMMARY_RENDERER_TYPE = typing.Callable[\n    [INDEX_TYPE, np.ndarray, int], typing.Iterator[str]\n]\nITEM_RENDERER_TYPE = typing.Callable[[INDEX_TYPE, np.ndarray, int], ITEM_GENERATOR_TYPE]\n\n\ndef make_constant_renderer(const: str) -> SUMMARY_RENDERER_TYPE:\n    """"""Factory function for a single ellipsis renderer.\n\n    :param const: constant string\n    :return: generator which produces string\n    """"""\n\n    def wrapper(\n        index: INDEX_TYPE, array: np.ndarray, edge_items: int\n    ) -> typing.Iterator[str]:\n        yield const\n\n    return wrapper\n\n\ndef ellipsis_renderer_2d(\n    index: INDEX_TYPE, array: np.ndarray, edge_items: int\n) -> typing.Iterator[str]:\n    n, m = array.shape\n    yield ""<tr>""\n    if m > 2 * edge_items:\n        for i in range(edge_items):\n            yield ELLIPSIS_CELL_HTML_VERTICAL\n\n        yield ELLIPSIS_CELL_HTML_DIAGONAL\n\n        for i in range(edge_items):\n            yield ELLIPSIS_CELL_HTML_VERTICAL\n    else:\n        for i in range(m):\n            yield ELLIPSIS_CELL_HTML_VERTICAL\n    yield ""</tr>""\n\n\ndef extend_index(index: INDEX_TYPE, coordinate: int) -> INDEX_TYPE:\n    return (*index, coordinate)\n\n\ndef render_array_items_summarized(\n    item_renderer: ITEM_RENDERER_TYPE,\n    summary_renderer: ITEM_RENDERER_TYPE,\n    index: INDEX_TYPE,\n    array: np.ndarray,\n    edge_items: int,\n) -> ITEM_GENERATOR_TYPE:\n    """"""Render array, summarising the inner items that have indices between `edge_items` and `len(array)-edge_items`.\n\n    :param item_renderer: item renderer\n    :param summary_renderer: summary item renderer\n    :param index: index\n    :param array: array to render\n    :param edge_items: number of edge items when summarising\n    :return:\n    """"""\n    for i, item in enumerate(array[:edge_items]):\n        yield from item_renderer(extend_index(index, i), item, edge_items)\n\n    yield from summary_renderer(index, array, edge_items)\n\n    for i, item in enumerate(array[-edge_items:], start=len(array) - edge_items):\n        yield from item_renderer(extend_index(index, i), item, edge_items)\n\n\ndef render_array_items(\n    item_renderer: ITEM_RENDERER_TYPE,\n    summary_renderer: ITEM_RENDERER_TYPE,\n    index: INDEX_TYPE,\n    array: np.ndarray,\n    edge_items: int,\n) -> ITEM_GENERATOR_TYPE:\n    """"""Render array, dispatching to `render_array_summarised` if required.\n\n    :param item_renderer: item renderer\n    :param summary_renderer: summary item renderer\n    :param index: index\n    :param array: array to render\n    :param edge_items: number of edge items when summarising\n    :return:\n    """"""\n    if edge_items and len(array) > 2 * edge_items:\n        yield from render_array_items_summarized(\n            item_renderer, summary_renderer, index, array, edge_items\n        )\n    else:\n        for i, item in enumerate(array):\n            yield from item_renderer(extend_index(index, i), item, edge_items)\n\n\ndef render_array_0d(index: INDEX_TYPE, item, edge_items: int) -> ITEM_GENERATOR_TYPE:\n    yield TemplateItem(f""<tr>{TD_ITEM_HTML_TEMPLATE}</tr>"", index, item)\n\n\ndef render_row_1d(index: INDEX_TYPE, row, edge_items: int) -> ITEM_GENERATOR_TYPE:\n    yield TemplateItem(f""<tr>{TD_ITEM_HTML_TEMPLATE}</tr>"", index, row)\n\n\ndef render_array_1d(\n    index: INDEX_TYPE, array: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    # Special case empty 1D arrays\n    if not array.shape[0]:\n        renderer = make_constant_renderer(EMPTY_CELL_HTML)\n        return renderer(index, array, edge_items)\n\n    return render_array_items(\n        render_row_1d,\n        make_constant_renderer(f""<tr>{ELLIPSIS_CELL_HTML_VERTICAL}</tr>""),\n        index,\n        array,\n        edge_items,\n    )\n\n\ndef render_elem_2d(index: INDEX_TYPE, item, edge_items: int) -> ITEM_GENERATOR_TYPE:\n    yield TemplateItem(TD_ITEM_HTML_TEMPLATE, index, item)\n\n\ndef render_row_2d(\n    index: INDEX_TYPE, row: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    yield ""<tr>""\n    yield from render_array_items(\n        render_elem_2d,\n        make_constant_renderer(ELLIPSIS_CELL_HTML_HORIZONTAL),\n        index,\n        row,\n        edge_items,\n    )\n    yield ""</tr>""\n\n\ndef render_array_2d(\n    index: INDEX_TYPE, array: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    yield from render_array_items(\n        render_row_2d, ellipsis_renderer_2d, index, array, edge_items\n    )\n\n\ndef render_row_nd(\n    index: INDEX_TYPE, row: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    yield ""<tr><td>""\n    yield from render_table(index, row, edge_items)\n    yield ""</td></tr>""\n\n\ndef render_array_nd(\n    index: INDEX_TYPE, array: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    yield from render_array_items(\n        render_row_nd,\n        make_constant_renderer(ELLIPSIS_CELL_HTML_VERTICAL),\n        index,\n        array,\n        edge_items,\n    )\n\n\n_shape_length_to_renderer = {0: render_array_0d, 1: render_array_1d, 2: render_array_2d}\n\n\ndef render_array(\n    index: INDEX_TYPE, array: np.ndarray, edge_items: int\n) -> ITEM_GENERATOR_TYPE:\n    renderer = _shape_length_to_renderer.get(len(array.shape), render_array_nd)\n    return renderer(index, array, edge_items)\n\n\ndef render_table(index: INDEX_TYPE, array, edge_items: int) -> ITEM_GENERATOR_TYPE:\n    yield ""<table style=\'border-style:solid;border-width:1px;\'>""\n    yield from render_array(index, array, edge_items)\n    yield ""</table>""\n'"
