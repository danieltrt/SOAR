file_path,api_count,code
ga.py,0,"b'import numpy\r\n\r\ndef select_mating_pool(pop, fitness, num_parents):\r\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\r\n    parents = numpy.empty((num_parents, pop.shape[1]))\r\n    for parent_num in range(num_parents):\r\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\r\n        max_fitness_idx = max_fitness_idx[0][0]\r\n        parents[parent_num, :] = pop[max_fitness_idx, :]\r\n        fitness[max_fitness_idx] = -99999999999\r\n    return parents\r\n\r\ndef crossover(parents, offspring_size):\r\n    offspring = numpy.empty(offspring_size)\r\n    # The point at which crossover takes place between two parents. Usually, it is at the center.\r\n    crossover_point = numpy.uint8(offspring_size[1]/2)\r\n\r\n    for k in range(offspring_size[0]):\r\n        # Index of the first parent to mate.\r\n        parent1_idx = k%parents.shape[0]\r\n        # Index of the second parent to mate.\r\n        parent2_idx = (k+1)%parents.shape[0]\r\n        # The new offspring will have its first half of its genes taken from the first parent.\r\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\r\n        # The new offspring will have its second half of its genes taken from the second parent.\r\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\r\n    return offspring\r\n\r\ndef mutation(offspring_crossover, num_mutations):\r\n    mutations_counter = numpy.uint8(offspring_crossover.shape[1]/num_mutations)\r\n    # Mutation changes a single gene in each offspring randomly.\r\n    for idx in range(offspring_crossover.shape[0]):\r\n        gene_idx = mutations_counter-1\r\n        for mutation_num in range(num_mutations):\r\n            # The random value to be added to the gene.\r\n            random_value = numpy.random.randint(low=0, high=8, size=None)\r\n            offspring_crossover[idx, gene_idx] = random_value\r\n            gene_idx = gene_idx + mutations_counter\r\n\r\n    return offspring_crossover\r\n\r\n'"
main.py,0,"b'import kivy.app\r\nimport kivy.uix.gridlayout\r\nimport kivy.uix.boxlayout\r\nimport kivy.uix.button\r\nimport kivy.uix.textinput\r\nimport kivy.uix.label\r\nimport kivy.graphics\r\nimport numpy\r\nimport ga\r\n\r\nclass BuzzleApp(kivy.app.App):\r\n    pop_created = 0 # 0 means a population is not yet created.\r\n\r\n    def start_ga(self, *args):\r\n        best_outputs = []\r\n        best_outputs_fitness = []\r\n        if (self.pop_created == 0):\r\n            print(""No Population Created Yet. Create the initial Population by Pressing the \\""Initial Population\\"" ""\r\n                  ""Button in Order to Call the initialize_population() Method At First."")\r\n            self.num_attacks_Label.text = ""Press \\""Initial Population\\""""\r\n            return\r\n\r\n        num_generations = numpy.uint16(self.num_generations_TextInput.text)\r\n        num_parents_mating = numpy.uint8(self.num_solutions/2)\r\n#        print(""Number of Parents Mating : "", num_parents_mating)\r\n\r\n        for generation in range(num_generations):\r\n            print(""\\n**  Generation # = "", generation, ""  **\\n"")\r\n\r\n#            print(""\\nOld 1D Population : \\n"", self.population_1D_vector)\r\n\r\n            # Measuring the fitness of each chromosome in the population.\r\n            population_fitness, total_num_attacks = self.fitness(self.population)\r\n            print(""\\nFitness : \\n"", population_fitness)\r\n\r\n            max_fitness = numpy.max(population_fitness)\r\n            max_fitness_idx = numpy.where(population_fitness == max_fitness)[0][0]\r\n            print(""\\nMax Fitness = "", max_fitness)\r\n\r\n            best_outputs_fitness.append(max_fitness)\r\n            best_outputs.append(self.population_1D_vector[max_fitness_idx, :])\r\n            # The best result in the current iteration.\r\n#            print(""\\nBest Outputs/Interations : \\n"", best_outputs)\r\n\r\n            if (max_fitness == float(""inf"")):\r\n                print(""Best solution found"")\r\n                self.num_attacks_Label.text = ""Best Solution Found""\r\n                print(""\\n1D Population : \\n"", self.population_1D_vector)\r\n                print(""\\n**  Best soltuion IDX = "", max_fitness_idx, ""  **\\n"")\r\n\r\n                best_outputs_fitness_array = numpy.array(best_outputs_fitness)\r\n                best_outputs_array = numpy.array(best_outputs)\r\n\r\n                numpy.save(""best_outputs_fitness.npy"", best_outputs_fitness)\r\n                numpy.save(""best_outputs.npy"", best_outputs)\r\n                print(""\\n**  Data Saved Successfully  **\\n"")\r\n\r\n                break\r\n\r\n            # Selecting the best parents in the population for mating.\r\n            parents = ga.select_mating_pool(self.population_1D_vector, population_fitness, num_parents_mating)\r\n#            print(""\\nSelected Parents : \\n"", parents)\r\n\r\n            # Generating next generation using crossover.\r\n            offspring_crossover = ga.crossover(parents, offspring_size=(self.num_solutions-parents.shape[0], 8))\r\n#            print(""\\nCrossover : \\n"", offspring_crossover)\r\n\r\n            # Adding some variations to the offspring using mutation.\r\n            offspring_mutation = ga.mutation(offspring_crossover, num_mutations=numpy.uint8(self.num_mutations_TextInput.text))\r\n#            print(""\\nMutation : \\n"", offspring_mutation)\r\n\r\n            # Creating the new population based on the parents and offspring.\r\n            self.population_1D_vector[0:parents.shape[0], :] = parents\r\n            self.population_1D_vector[parents.shape[0]:, :] = offspring_mutation\r\n\r\n            # Convert the 1D vector population into a 2D matrix form in order to calculate the fitness values of the new population.\r\n#            print(""\\n**********************************\\n"")\r\n            self.vector_to_matrix()\r\n\r\n#            print(""\\nNew 1D Population : \\n"", self.population_1D_vector)\r\n\r\n    def initialize_population(self, *args):\r\n        self.num_solutions = numpy.uint8(self.num_solutions_TextInput.text)\r\n#        print(""Number of Solutions within the Population : "", self.num_solutions)\r\n\r\n        self.reset_board_text()\r\n\r\n        self.population_1D_vector = numpy.zeros(shape=(self.num_solutions, 8)) # Each solution is represented as a row in this array. If there are 5 rows, then there are 5 solutions.\r\n\r\n        # Creating the initial population RANDOMLY as a set of 1D vectors.\r\n        for solution_idx in range(self.num_solutions):\r\n            initial_queens_y_indices = numpy.random.rand(8)*8\r\n            initial_queens_y_indices = initial_queens_y_indices.astype(numpy.uint8)\r\n            self.population_1D_vector[solution_idx, :] = initial_queens_y_indices\r\n\r\n        self.vector_to_matrix()\r\n\r\n#        print(""Population 1D Vectors : "", self.population_1D_vector)\r\n#        print(""Population 2D Matrices : "", self.population)\r\n\r\n        self.pop_created = 1 # indicates that the initial population is created in order to enable drawing solutions on GUI.\r\n        self.num_attacks_Label.text = ""Initial Population Created.""\r\n\r\n    def vector_to_matrix(self):\r\n        # Converts the 1D vector solutions into a 2D matrix solutions represrnting the board, where 1 means a queen exists. The matrix form of the solutions makes calculating the fitness value much easier.\r\n\r\n        self.population = numpy.zeros(shape=(self.num_solutions, 8, 8))\r\n\r\n        solution_idx = 0\r\n        for current_solution in self.population_1D_vector:\r\n#            print(self.population_1D_vector[solution_idx, :])\r\n            current_solution = numpy.uint8(current_solution)\r\n            row_idx = 0\r\n            for col_idx in current_solution:\r\n                self.population[solution_idx, row_idx, col_idx] = 1\r\n                row_idx = row_idx + 1\r\n#            print(self.population[solution_idx, :])\r\n            solution_idx = solution_idx + 1\r\n\r\n    def reset_board_text(self):\r\n        # Reset board on GUI.\r\n        for row_idx in range(self.all_widgets.shape[0]):\r\n            for col_idx in range(self.all_widgets.shape[1]):\r\n                self.all_widgets[row_idx, col_idx].text=""[color=ffffff]""+str(row_idx)+"", ""+str(col_idx)+""[/color]""\r\n                with self.all_widgets[row_idx, col_idx].canvas.before:\r\n                    kivy.graphics.Color(0, 0, 0, 1)  # green; colors range from 0-1 not 0-255\r\n                    self.rect = kivy.graphics.Rectangle(size=self.all_widgets[row_idx, col_idx].size, pos=self.all_widgets[row_idx, col_idx].pos)\r\n\r\n    def update_board_UI(self, *args):\r\n        if (self.pop_created == 0):\r\n            print(""No Population Created Yet. Create the initial Population by Pressing the \\""Initial Population\\"" Button in Order to Call the initialize_population() Method At First."")\r\n            self.num_attacks_Label.text = ""Press \\""Initial Population\\""""\r\n            return\r\n\r\n        self.reset_board_text()\r\n\r\n        population_fitness, total_num_attacks = self.fitness(self.population)\r\n#        print(""Fitness Values of the Entire Population : "", population_fitness)\r\n\r\n        max_fitness = numpy.max(population_fitness)\r\n        max_fitness_idx = numpy.where(population_fitness == max_fitness)[0][0]\r\n#        print(""Index of Maximum Fitness : "", max_fitness_index)\r\n        best_solution = self.population[max_fitness_idx, :]\r\n\r\n        self.num_attacks_Label.text = ""Max Fitness = "" + str(numpy.round(max_fitness, 4)) + ""\\n# Attacks = "" + str(total_num_attacks[max_fitness_idx])\r\n\r\n        for row_idx in range(8):\r\n            for col_idx in range(8):\r\n                if (best_solution[row_idx, col_idx] == 1):\r\n                    self.all_widgets[row_idx, col_idx].text = ""[color=22ff22]Queen[/color]""\r\n                    with self.all_widgets[row_idx, col_idx].canvas.before:\r\n                        kivy.graphics.Color(0, 1, 0, 1)  # green; colors range from 0-1 not 0-255\r\n                        self.rect = kivy.graphics.Rectangle(size=self.all_widgets[row_idx, col_idx].size, pos=self.all_widgets[row_idx, col_idx].pos)\r\n\r\n    def fitness(self, population):\r\n        total_num_attacks_column = self.attacks_column(self.population)\r\n#        print(""Number of Attacks (Column) : "", total_num_attacks_column)\r\n\r\n        total_num_attacks_diagonal = self.attacks_diagonal(self.population)\r\n#        print(""Number of Attacks (Diagonal) : "", total_num_attacks_diagonal)\r\n\r\n        total_num_attacks = total_num_attacks_column + total_num_attacks_diagonal\r\n\r\n        # GA fitness is increasng (higher value is favorable) but the total number of attacks (total_num_attacks) is decreasing. An increasing fitness value could be created by dividng 1.0 by the number of attacks. For example, if number of attacks is 5.0, then the fitness is 1.0/5.0=0.2\r\n        population_fitness = numpy.copy(total_num_attacks) # Direct assignment makes both variables refer to the same array. Use numpy.copy() for creating a new independent copy.\r\n\r\n#        print(""Number of Attacks (Column + Diagonal) : "", total_num_attacks)\r\n\r\n        for solution_idx in range(population.shape[0]):\r\n            if population_fitness[solution_idx] == 0:\r\n                population_fitness[solution_idx] = float(""inf"")\r\n            else:\r\n                population_fitness[solution_idx] = 1.0/population_fitness[solution_idx]\r\n\r\n#        print(""Population Fitness (Column + Diagonal) : "", population_fitness)\r\n\r\n        return population_fitness, total_num_attacks\r\n\r\n    def attacks_diagonal(self, population):\r\n        # For a given queen, how many queens sharing the same coulmn? This is how the fitness value is calculated.\r\n\r\n        total_num_attacks = numpy.zeros(population.shape[0]) # Number of attacks for all solutions (diagonal only).\r\n\r\n        for solution_idx in range(population.shape[0]):\r\n#            print(""DIAGONAL Solution Index : "", solution_idx)\r\n            ga_solution = population[solution_idx, :]\r\n#            print(""Current Solution Board : "", ga_solution)\r\n\r\n#            print(""Matrix Diagonal : "", ga_solution.diagonal())\r\n\r\n            # Badding zeros around the solution board for being able to index the boundaries (leftmost/rightmost coumns & top/bottom rows). # This is by adding 2 rows (1 at the top and another at the bottom) and adding 2 columns (1 left and another right).\r\n            temp = numpy.zeros(shape=(10, 10))\r\n            # Copying the solution board inside the badded array.\r\n            temp[1:9, 1:9] = ga_solution\r\n#            print(""Solution Board after Badding : "", temp)\r\n\r\n            # Returning the indices (rows and columns) of the 8 queeens.\r\n            row_indices, col_indices = numpy.where(ga_solution == 1)\r\n            # Adding 1 to the indices because the badded array is 1 row/column far from the original array.\r\n            row_indices = row_indices + 1\r\n            col_indices = col_indices + 1\r\n\r\n#            print(""Column indices of the queens : "", col_indices)\r\n            total = 0 # total number of attacking pairs diagonally for each solution.\r\n\r\n            for element_idx in range(8):\r\n                x = row_indices[element_idx]\r\n                y = col_indices[element_idx]\r\n#                print(""ROW index of the current queen : "", x)\r\n#                print(""COL index of the current queen : "", y)\r\n\r\n                mat_bottom_right = temp[x:, y:]\r\n                total = total + self.diagonal_attacks(mat_bottom_right)\r\n#                print(""Bottom Right : "", total)\r\n\r\n                mat_bottom_left = temp[x:, y:0:-1]\r\n                total = total + self.diagonal_attacks(mat_bottom_left)\r\n#                print(""Bottom Left : "", total)\r\n\r\n                mat_top_right = temp[x:0:-1, y:]\r\n                total = total + self.diagonal_attacks(mat_top_right)\r\n#                print(""Top Right : "", total)\r\n\r\n                mat_top_left = temp[x:0:-1, y:0:-1]\r\n                total = total + self.diagonal_attacks(mat_top_left)\r\n#                print(""Top Left : "", total)\r\n\r\n#                print(""\\n**********************\\n"")\r\n            # Dividing the total by 2 because it counts the solution as attacking itself diagonally.\r\n\r\n            total_num_attacks[solution_idx] = total_num_attacks[solution_idx] + total /2\r\n\r\n        return total_num_attacks\r\n\r\n    def diagonal_attacks(self, mat):\r\n        if (mat.shape[0] < 2 or mat.shape[1] < 2):\r\n#            print(""LESS than 2x2."")\r\n            return 0\r\n        num_attacks = mat.diagonal().sum()-1\r\n        return num_attacks\r\n\r\n    def attacks_column(self, population):\r\n        # For a given queen, how many queens sharing the same coulmn? This is how the fitness value is calculated.\r\n\r\n        total_num_attacks = numpy.zeros(population.shape[0]) # Number of attacks for all solutions (column only).\r\n\r\n        for solution_idx in range(population.shape[0]):\r\n#            print(""COLUMN Solution Index : "", solution_idx)\r\n            ga_solution = population[solution_idx, :]\r\n#            print(""Current Solution : "", ga_solution)\r\n\r\n            for queen_y_pos in range(8):\r\n                # Vertical\r\n                col_sum = numpy.sum(ga_solution[:, queen_y_pos])\r\n                if (col_sum == 0 or col_sum == 1):\r\n                    col_sum = 0\r\n                else:\r\n                    col_sum = col_sum - 1 # To avoid regarding a queen attacking itself.\r\n\r\n#                print(col_sum)\r\n\r\n                total_num_attacks[solution_idx] = total_num_attacks[solution_idx] + col_sum\r\n\r\n#            print(""Number of Attacking Pairs : "", total_num_attacks[solution_idx])\r\n\r\n        return total_num_attacks\r\n\r\n    def build(self):\r\n        boxLayout = kivy.uix.boxlayout.BoxLayout(orientation=""vertical"")\r\n\r\n        gridLayout = kivy.uix.gridlayout.GridLayout(rows=8, size_hint_y=9)\r\n        boxLayout_buttons = kivy.uix.boxlayout.BoxLayout(orientation=""horizontal"")\r\n\r\n        boxLayout.add_widget(gridLayout)\r\n        boxLayout.add_widget(boxLayout_buttons)\r\n\r\n        # Preparing the 8x8 board.\r\n        self.all_widgets = numpy.zeros(shape=(8,8), dtype=""O"")\r\n\r\n        for row_idx in range(self.all_widgets.shape[0]):\r\n            for col_idx in range(self.all_widgets.shape[1]):\r\n                self.all_widgets[row_idx, col_idx] = kivy.uix.button.Button(text=str(row_idx)+"", ""+str(col_idx), font_size=25)\r\n                self.all_widgets[row_idx, col_idx].markup = True\r\n                gridLayout.add_widget(self.all_widgets[row_idx, col_idx])\r\n\r\n        # Preparing buttons inside the child BoxLayout.\r\n        initial_button = kivy.uix.button.Button(text=""Initial Population"", font_size=15, size_hint_x=2)\r\n        initial_button.bind(on_press=self.initialize_population)\r\n\r\n        ga_solution_button = kivy.uix.button.Button(text=""Show Best Solution"", font_size=15, size_hint_x=2)\r\n        ga_solution_button.bind(on_press=self.update_board_UI)\r\n\r\n        start_ga_button = kivy.uix.button.Button(text=""Start GA"", font_size=15, size_hint_x=2)\r\n        start_ga_button.bind(on_press=self.start_ga)\r\n\r\n        self.num_solutions_TextInput = kivy.uix.textinput.TextInput(text=""8"", font_size=20, size_hint_x=1)\r\n        self.num_generations_TextInput = kivy.uix.textinput.TextInput(text=""10000"", font_size=20, size_hint_x=1)\r\n        self.num_mutations_TextInput = kivy.uix.textinput.TextInput(text=""5"", font_size=20, size_hint_x=1)\r\n\r\n        self.num_attacks_Label = kivy.uix.label.Label(text=""# Attacks/Best Solution"", font_size=15, size_hint_x=2)\r\n\r\n        boxLayout_buttons.add_widget(initial_button)\r\n        boxLayout_buttons.add_widget(ga_solution_button)\r\n        boxLayout_buttons.add_widget(start_ga_button)\r\n        boxLayout_buttons.add_widget(self.num_solutions_TextInput)\r\n        boxLayout_buttons.add_widget(self.num_generations_TextInput)\r\n        boxLayout_buttons.add_widget(self.num_mutations_TextInput)\r\n        boxLayout_buttons.add_widget(self.num_attacks_Label)\r\n\r\n        return boxLayout\r\n\r\nfrom kivy.config import Config\r\nConfig.set(\'graphics\', \'width\', \'1000\')\r\nConfig.set(\'graphics\', \'height\', \'600\')\r\n\r\nbuzzleApp = BuzzleApp()\r\nbuzzleApp.run()\r\n'"
