file_path,api_count,code
example.py,0,"b'import pygad\r\nimport numpy\r\n\r\n""""""\r\nGiven the following function:\r\n    y = f(w1:w6) = w1x1 + w2x2 + w3x3 + w4x4 + w5x5 + 6wx6\r\n    where (x1,x2,x3,x4,x5,x6)=(4,-2,3.5,5,-11,-4.7) and y=44\r\nWhat are the best values for the 6 weights (w1 to w6)? We are going to use the genetic algorithm to optimize this function.\r\n""""""\r\n\r\nfunction_inputs = [4,-2,3.5,5,-11,-4.7] # Function inputs.\r\ndesired_output = 44 # Function output.\r\n\r\ndef fitness_func(solution, solution_idx):\r\n    # Calculating the fitness value of each solution in the current population.\r\n    # The fitness function calulates the sum of products between each input and its corresponding weight.\r\n    output = numpy.sum(solution*function_inputs)\r\n    fitness = 1.0 / numpy.abs(output - desired_output)\r\n    return fitness\r\n\r\nfitness_function = fitness_func\r\n\r\nnum_generations = 100 # Number of generations.\r\nnum_parents_mating = 7 # Number of solutions to be selected as parents in the mating pool.\r\n\r\n# To prepare the initial population, there are 2 ways:\r\n# 1) Prepare it yourself and pass it to the initial_population parameter. This way is useful when the user wants to start the genetic algorithm with a custom initial population.\r\n# 2) Assign valid integer values to the sol_per_pop and num_genes parameters. If the initial_population parameter exists, then the sol_per_pop and num_genes parameters are useless.\r\nsol_per_pop = 50 # Number of solutions in the population.\r\nnum_genes = len(function_inputs)\r\n\r\ninit_range_low = -2\r\ninit_range_high = 5\r\n\r\nparent_selection_type = ""sss"" # Type of parent selection.\r\nkeep_parents = 7 # Number of parents to keep in the next population. -1 means keep all parents and 0 means keep nothing.\r\n\r\ncrossover_type = ""single_point"" # Type of the crossover operator.\r\n\r\n# Parameters of the mutation operation.\r\nmutation_type = ""random"" # Type of the mutation operator.\r\nmutation_percent_genes = 10 # Percentage of genes to mutate. This parameter has no action if the parameter mutation_num_genes exists or when mutation_type is None.\r\n\r\nlast_fitness = 0\r\ndef callback_generation(ga_instance):\r\n    global last_fitness\r\n    print(""Generation = {generation}"".format(generation=ga_instance.generations_completed))\r\n    print(""Fitness    = {fitness}"".format(fitness=ga_instance.best_solution()[1]))\r\n    print(""Change     = {change}"".format(change=ga_instance.best_solution()[1] - last_fitness))\r\n\r\n# Creating an instance of the GA class inside the ga module. Some parameters are initialized within the constructor.\r\nga_instance = pygad.GA(num_generations=num_generations,\r\n                       num_parents_mating=num_parents_mating, \r\n                       fitness_func=fitness_function,\r\n                       sol_per_pop=sol_per_pop, \r\n                       num_genes=num_genes,\r\n                       init_range_low=init_range_low,\r\n                       init_range_high=init_range_high,\r\n                       parent_selection_type=parent_selection_type,\r\n                       keep_parents=keep_parents,\r\n                       crossover_type=crossover_type,\r\n                       mutation_type=mutation_type,\r\n                       mutation_percent_genes=mutation_percent_genes,\r\n                       callback_generation=callback_generation)\r\n\r\n# Running the GA to optimize the parameters of the function.\r\nga_instance.run()\r\n\r\n# After the generations complete, some plots are showed that summarize the how the outputs/fitenss values evolve over generations.\r\nga_instance.plot_result()\r\n\r\n# Returning the details of the best solution.\r\nsolution, solution_fitness, solution_idx = ga_instance.best_solution()\r\nprint(""Parameters of the best solution : {solution}"".format(solution=solution))\r\nprint(""Fitness value of the best solution = {solution_fitness}"".format(solution_fitness=solution_fitness))\r\nprint(""Index of the best solution : {solution_idx}"".format(solution_idx=solution_idx))\r\n\r\nprediction = numpy.sum(numpy.array(function_inputs)*solution)\r\nprint(""Predicted output based on the best solution : {prediction}"".format(prediction=prediction))\r\n\r\nif ga_instance.best_solution_generation != -1:\r\n    print(""Best fitness value reached after {best_solution_generation} generations."".format(best_solution_generation=ga_instance.best_solution_generation))\r\n\r\n# Saving the GA instance.\r\nfilename = \'genetic\' # The filename to which the instance is saved. The name is without extension.\r\nga_instance.save(filename=filename)\r\n\r\n# Loading the saved GA instance.\r\nloaded_ga_instance = pygad.load(filename=filename)\r\nloaded_ga_instance.plot_result()\r\n'"
pygad.py,0,"b'import numpy\r\nimport random\r\nimport matplotlib.pyplot\r\nimport pickle\r\n\r\nclass GA:\r\n    def __init__(self, \r\n                 num_generations, \r\n                 num_parents_mating, \r\n                 fitness_func,\r\n                 initial_population=None,\r\n                 sol_per_pop=None, \r\n                 num_genes=None,\r\n                 init_range_low=-4,\r\n                 init_range_high=4,\r\n                 parent_selection_type=""sss"",\r\n                 keep_parents=-1,\r\n                 K_tournament=3,\r\n                 crossover_type=""single_point"",\r\n                 mutation_type=""random"",\r\n                 mutation_by_replacement=False,\r\n                 mutation_percent_genes=10,\r\n                 mutation_num_genes=None,\r\n                 random_mutation_min_val=-1.0,\r\n                 random_mutation_max_val=1.0,\r\n                 callback_generation=None):\r\n\r\n        """"""\r\n        The constructor of the GA class accepts all parameters required to create an instance of the GA class. It validates such parameters.\r\n\r\n        num_generations: Number of generations.\r\n        num_parents_mating: Number of solutions to be selected as parents in the mating pool.\r\n\r\n        fitness_func: Accepts a function that must accept 2 parameters (a single solution and its index in the population) and return the fitness value of the solution. Available starting from PyGAD 1.0.17 until 1.0.20 with a single parameter representing the solution. Changed in PyGAD 2.0.0 and higher to include the second parameter representing the solution index.\r\n\r\n        initial_population: A user-defined initial population. It is useful when the user wants to start the generations with a custom initial population. It defaults to None which means no initial population is specified by the user. In this case, PyGAD creates an initial population using the \'sol_per_pop\' and \'num_genes\' parameters. An exception is raised if the \'initial_population\' is None while any of the 2 parameters (\'sol_per_pop\' or \'num_genes\') is also None.\r\n        sol_per_pop: Number of solutions in the population. \r\n        num_genes: Number of parameters in the function.\r\n\r\n        init_range_low: The lower value of the random range from which the gene values in the initial population are selected. It defaults to -4. Available in PyGAD 1.0.20 and higher.\r\n        init_range_high: The upper value of the random range from which the gene values in the initial population are selected. It defaults to -4. Available in PyGAD 1.0.20.\r\n        # It is OK to set the value of any of the 2 parameters (\'init_range_high\' and \'init_range_high\') to be equal, higher or lower than the other parameter (i.e. init_range_low is not needed to be lower than init_range_high).\r\n\r\n        parent_selection_type: Type of parent selection.\r\n        keep_parents: If 0, this means the parents of the current populaiton will not be used at all in the next population. If -1, this means all parents in the current population will be used in the next population. If set to a value > 0, then the specified value refers to the number of parents in the current population to be used in the next population. In some cases, the parents are of high quality and thus we do not want to loose such some high quality solutions. If some parent selection operators like roulette wheel selection (RWS), the parents may not be of high quality and thus keeping the parents might degarde the quality of the population.\r\n        K_tournament: When the value of \'parent_selection_type\' is \'tournament\', the \'K_tournament\' parameter specifies the number of solutions from which a parent is selected randomly.\r\n\r\n        crossover_type: Type of the crossover opreator. If  crossover_type=None, then the crossover step is bypassed which means no crossover is applied and thus no offspring will be created in the next generations. The next generation will use the solutions in the current population.\r\n        mutation_type: Type of the mutation opreator. If mutation_type=None, then the mutation step is bypassed which means no mutation is applied and thus no changes are applied to the offspring created using the crossover operation. The offspring will be used unchanged in the next generation.\r\n\r\n        mutation_by_replacement: An optional bool parameter. It works only when the selected type of mutation is random (mutation_type=""random""). In this case, setting mutation_by_replacement=True means replace the gene by the randomly generated value. If False, then it has no effect and random mutation works by adding the random value to the gene.\r\n\r\n        mutation_percent_genes: Percentage of genes to mutate which defaults to 10%. This parameter has no action if the parameter mutation_num_genes exists.\r\n        mutation_num_genes: Number of genes to mutate which defaults to None. If the parameter mutation_num_genes exists, then no need for the parameter mutation_percent_genes.\r\n        random_mutation_min_val: The minimum value of the range from which a random value is selected to be added to the selected gene(s) to mutate. It defaults to -1.0.\r\n        random_mutation_max_val: The maximum value of the range from which a random value is selected to be added to the selected gene(s) to mutate. It defaults to 1.0.\r\n\r\n        callback_generation: If not None, then it accepts a function to be called after each generation. This function must accept a single parameter representing the instance of the genetic algorithm.\r\n        """"""\r\n\r\n        self.init_range_low = init_range_low\r\n        self.init_range_high = init_range_high\r\n\r\n        if initial_population is None:\r\n            if (sol_per_pop is None) or (num_genes is None):\r\n                raise ValueError(""Error creating the initail population\\n\\nWhen the parameter initial_population is None, then neither of the 2 parameters sol_per_pop and num_genes can be None at the same time.\\nThere are 2 options to prepare the initial population:\\n1) Create an initial population and assign it to the initial_population parameter. In this case, the values of the 2 parameters sol_per_pop and num_genes will be deduced.\\n2) Allow the genetic algorithm to create the initial population automatically by passing valid integer values to the sol_per_pop and num_genes parameters."")\r\n            elif (type(sol_per_pop) is int) and (type(num_genes) is int):\r\n                # Validating the number of solutions in the population (sol_per_pop)\r\n                if sol_per_pop <= 0:\r\n                    self.valid_parameters = False\r\n                    raise ValueError(""The number of solutions in the population (sol_per_pop) must be > 0 but {sol_per_pop} found. \\nThe following parameters must be > 0: \\n1) Population size (i.e. number of solutions per population) (sol_per_pop).\\n2) Number of selected parents in the mating pool (num_parents_mating).\\n"".format(sol_per_pop=sol_per_pop))\r\n                # Validating the number of gene.\r\n                if (num_genes <= 0):\r\n                    self.valid_parameters = False\r\n                    raise ValueError(""Number of genes cannot be <= 0 but {num_genes} found.\\n"".format(num_genes=num_genes))\r\n                # When initial_population=None and the 2 parameters sol_per_pop and num_genes have valid integer values, then the initial population is created.\r\n                # Inside the initialize_population() method, the initial_population attribute is assigned to keep the initial population accessible.\r\n                self.num_genes = num_genes # Number of genes in the solution.\r\n                self.sol_per_pop = sol_per_pop # Number of solutions in the population.\r\n                self.initialize_population(self.init_range_low, self.init_range_high)\r\n            else:\r\n                raise TypeError(""The expected type of both the sol_per_pop and num_genes parameters is int but {sol_per_pop_type} and {num_genes_type} found."".format(sol_per_pop_type=type(sol_per_pop), num_genes_type=type(num_genes)))\r\n        elif numpy.array(initial_population).ndim != 2:\r\n            raise ValueError(""A 2D list is expected to the initail_population parameter but a {initial_population_ndim}-D list found."".format(initial_population_ndim=numpy.array(initial_population).ndim))\r\n        else:\r\n            self.initial_population = numpy.array(initial_population)\r\n            self.population = self.initial_population # A NumPy array holding the initial population.\r\n            self.num_genes = self.initial_population.shape[1] # Number of genes in the solution.\r\n            self.sol_per_pop = self.initial_population.shape[0]  # Number of solutions in the population.\r\n            self.pop_size = (self.sol_per_pop,self.num_genes) # The population size.\r\n\r\n        # Validating the number of parents to be selected for mating (num_parents_mating)\r\n        if num_parents_mating <= 0:\r\n            self.valid_parameters = False\r\n            raise ValueError(""The number of parents mating (num_parents_mating) parameter must be > 0 but {num_parents_mating} found. \\nThe following parameters must be > 0: \\n1) Population size (i.e. number of solutions per population) (sol_per_pop).\\n2) Number of selected parents in the mating pool (num_parents_mating).\\n"".format(num_parents_mating=num_parents_mating))\r\n\r\n        # Validating the number of parents to be selected for mating: num_parents_mating\r\n        if (num_parents_mating > self.sol_per_pop):\r\n            self.valid_parameters = False\r\n            raise ValueError(""The number of parents to select for mating ({num_parents_mating}) cannot be greater than the number of solutions in the population ({sol_per_pop}) (i.e., num_parents_mating must always be <= sol_per_pop).\\n"".format(num_parents_mating=num_parents_mating, sol_per_pop=self.sol_per_pop))\r\n\r\n        self.num_parents_mating = num_parents_mating\r\n\r\n        # crossover: Refers to the method that applies the crossover operator based on the selected type of crossover in the crossover_type property.\r\n        # Validating the crossover type: crossover_type\r\n        if (crossover_type == ""single_point""):\r\n            self.crossover = self.single_point_crossover\r\n        elif (crossover_type == ""two_points""):\r\n            self.crossover = self.two_points_crossover\r\n        elif (crossover_type == ""uniform""):\r\n            self.crossover = self.uniform_crossover\r\n        elif (crossover_type is None):\r\n            self.crossover = None\r\n        else:\r\n            self.valid_parameters = False\r\n            raise ValueError(""Undefined crossover type. \\nThe assigned value to the crossover_type ({crossover_type}) argument does not refer to one of the supported crossover types which are: \\n-single_point (for single point crossover)\\n-two_points (for two points crossover)\\n-uniform (for uniform crossover).\\n"".format(crossover_type=crossover_type))\r\n\r\n        self.crossover_type = crossover_type\r\n\r\n        # mutation: Refers to the method that applies the mutation operator based on the selected type of mutation in the mutation_type property.\r\n        # Validating the mutation type: mutation_type\r\n        if (mutation_type == ""random""):\r\n            self.mutation = self.random_mutation\r\n        elif (mutation_type == ""swap""):\r\n            self.mutation = self.swap_mutation\r\n        elif (mutation_type == ""scramble""):\r\n            self.mutation = self.scramble_mutation\r\n        elif (mutation_type == ""inversion""):\r\n            self.mutation = self.inversion_mutation\r\n        elif (mutation_type is None):\r\n            self.mutation = None\r\n        else:\r\n            self.valid_parameters = False\r\n            raise ValueError(""Undefined mutation type. \\nThe assigned value to the mutation_type argument ({mutation_type}) does not refer to one of the supported mutation types which are: \\n-random (for random mutation)\\n-swap (for swap mutation)\\n-inversion (for inversion mutation)\\n-scramble (for scramble mutation).\\n"".format(mutation_type=mutation_type))\r\n\r\n        self.mutation_type = mutation_type\r\n\r\n        if not (self.mutation_type is None):\r\n            if (mutation_num_genes == None):\r\n                if (mutation_percent_genes < 0 or mutation_percent_genes > 100):\r\n                    self.valid_parameters = False\r\n                    raise ValueError(""The percentage of selected genes for mutation (mutation_percent_genes) must be >= 0 and <= 100 inclusive but {mutation_percent_genes=mutation_percent_genes} found.\\n"".format(mutation_percent_genes=mutation_percent_genes))\r\n            elif (mutation_num_genes <= 0 ):\r\n                self.valid_parameters = False\r\n                raise ValueError(""The number of selected genes for mutation (mutation_num_genes) cannot be <= 0 but {mutation_num_genes} found.\\n"".format(mutation_num_genes=mutation_num_genes))\r\n            elif (mutation_num_genes > self.num_genes):\r\n                self.valid_parameters = False\r\n                raise ValueError(""The number of selected genes for mutation (mutation_num_genes) ({mutation_num_genes}) cannot be greater than the number of genes ({num_genes}).\\n"".format(mutation_num_genes=mutation_num_genes, num_genes=self.num_genes))\r\n            elif (type(mutation_num_genes) is not int):\r\n                self.valid_parameters = False\r\n                raise ValueError(""The number of selected genes for mutation (mutation_num_genes) must be a positive integer >= 1 but {mutation_num_genes} found.\\n"".format(mutation_num_genes=mutation_num_genes))\r\n        else:\r\n            pass\r\n\r\n        if not (type(mutation_by_replacement) is bool):\r\n            self.valid_parameters = False\r\n            raise TypeError(""The expected type of the \'mutation_by_replacement\' parameter is bool but {mutation_by_replacement_type} found."".format(mutation_by_replacement_type=type(mutation_by_replacement)))\r\n\r\n        self.mutation_by_replacement = mutation_by_replacement\r\n        \r\n        if self.mutation_type != ""random"" and self.mutation_by_replacement:\r\n            print(""Warning: The mutation_by_replacement parameter is set to True while the mutation_type parameter is not set to random but {mut_type}. Note that the mutation_by_replacement parameter has an effect only when mutation_type=\'random\'."".format(mut_type=mutation_type))\r\n\r\n        if (self.mutation_type is None) and (self.crossover_type is None):\r\n            print(""Warning: the 2 parameters mutation_type and crossover_type are None. This disables any type of evolution the genetic algorithm can make. As a result, the genetic algorithm cannot find a better solution that the best solution in the initial population."")\r\n\r\n        # select_parents: Refers to a method that selects the parents based on the parent selection type specified in the parent_selection_type attribute.\r\n        # Validating the selected type of parent selection: parent_selection_type\r\n        if (parent_selection_type == ""sss""):\r\n            self.select_parents = self.steady_state_selection\r\n        elif (parent_selection_type == ""rws""):\r\n            self.select_parents = self.roulette_wheel_selection\r\n        elif (parent_selection_type == ""sus""):\r\n            self.select_parents = self.stochastic_universal_selection\r\n        elif (parent_selection_type == ""random""):\r\n            self.select_parents = self.random_selection\r\n        elif (parent_selection_type == ""tournament""):\r\n            self.select_parents = self.tournament_selection\r\n        elif (parent_selection_type == ""rank""):\r\n            self.select_parents = self.rank_selection\r\n        else:\r\n            self.valid_parameters = False\r\n            raise ValueError(""Undefined parent selection type: {parent_selection_type}. \\nThe assigned value to the parent_selection_type argument does not refer to one of the supported parent selection techniques which are: \\n-sss (for steady state selection)\\n-rws (for roulette wheel selection)\\n-sus (for stochastic universal selection)\\n-rank (for rank selection)\\n-random (for random selection)\\n-tournament (for tournament selection).\\n"".format(parent_selection_type))\r\n\r\n        if(parent_selection_type == ""tournament""):\r\n            if (K_tournament > self.sol_per_pop):\r\n                K_tournament = self.sol_per_pop\r\n                print(""Warining: K of the tournament selection ({K_tournament}) should not be greater than the number of solutions within the population ({sol_per_pop}).\\nK will be clipped to be equal to the number of solutions in the population (sol_per_pop).\\n"".format(K_tournament=K_tournament, sol_per_pop=self.sol_per_pop))\r\n            elif (K_tournament <= 0):\r\n                self.valid_parameters = False\r\n                raise ValueError(""K of the tournament selection cannot be <=0 but {K_tournament} found.\\n"".format(K_tournament=K_tournament))\r\n\r\n        self.K_tournament = K_tournament\r\n\r\n        # Validating the number of parents to keep in the next population: keep_parents\r\n        if (keep_parents > self.sol_per_pop or keep_parents > self.num_parents_mating or keep_parents < -1):\r\n            self.valid_parameters = False\r\n            raise ValueError(""Incorrect value to the keep_parents parameter: {keep_parents}. \\nThe assigned value to the keep_parent parameter must satisfy the following conditions: \\n1) Less than or equal to sol_per_pop\\n2) Less than or equal to num_parents_mating\\n3) Greater than or equal to -1."".format(keep_parents=keep_parents))\r\n\r\n        self.keep_parents = keep_parents\r\n\r\n        if (self.keep_parents == -1): # Keep all parents in the next population.\r\n            self.num_offspring = self.sol_per_pop - self.num_parents_mating\r\n        elif (self.keep_parents == 0): # Keep no parents in the next population.\r\n            self.num_offspring = self.sol_per_pop\r\n        elif (self.keep_parents > 0): # Keep the specified number of parents in the next population.\r\n            self.num_offspring = self.sol_per_pop - self.keep_parents\r\n\r\n        # Check if the fitness_func is a function.\r\n        if callable(fitness_func):\r\n            # Check if the fitness function accepts 2 paramaters.\r\n            if (fitness_func.__code__.co_argcount == 2):\r\n                self.fitness_func = fitness_func\r\n            else:\r\n                self.valid_parameters = False\r\n                raise ValueError(""The fitness function must accept 2 parameters representing the solution to which the fitness value is calculated and the solution index within the population.\\nThe passed fitness function named \'{funcname}\' accepts {argcount} argument(s)."".format(funcname=fitness_func.__code__.co_name, argcount=fitness_func.__code__.co_argcount))\r\n        else:\r\n            self.valid_parameters = False\r\n            raise ValueError(""The value assigned to the \'fitness_func\' parameter is expected to be of type function by {fitness_func_type} found."".format(fitness_func_type=type(fitness_func)))\r\n\r\n        # Check if the callback_generation exists.\r\n        if not (callback_generation is None):\r\n            # Check if the callback_generation is a function.\r\n            if callable(callback_generation):\r\n                # Check if the callback_generation function accepts only a single paramater.\r\n                if (callback_generation.__code__.co_argcount == 1):\r\n                    self.callback_generation = callback_generation\r\n                else:\r\n                    self.valid_parameters = False\r\n                    raise ValueError(""The callback_generation function must accept only 1 parameter representing the instance of the genetic algorithm.\\nThe passed callback_generation function named \'{funcname}\' accepts {argcount} argument(s)."".format(funcname=callback_generation.__code__.co_name, argcount=callback_generation.__code__.co_argcount))\r\n            else:\r\n                self.valid_parameters = False\r\n                raise ValueError(""The value assigned to the \'callback_generation\' parameter is expected to be of type function by {callback_generation_type} found."".format(callback_generation_type=type(callback_generation)))\r\n        else:\r\n            self.callback_generation = None\r\n\r\n        # The number of completed generations.\r\n        self.generations_completed = 0\r\n\r\n        # At this point, all necessary parameters validation is done successfully and we are sure that the parameters are valid.\r\n        self.valid_parameters = True # Set to True when all the parameters passed in the GA class constructor are valid.\r\n\r\n        # Parameters of the genetic algorithm.\r\n        self.num_generations = abs(num_generations)\r\n        self.parent_selection_type = parent_selection_type\r\n\r\n        # Parameters of the mutation operation.\r\n        self.mutation_percent_genes = mutation_percent_genes\r\n        self.mutation_num_genes = mutation_num_genes\r\n        self.random_mutation_min_val = random_mutation_min_val\r\n        self.random_mutation_max_val = random_mutation_max_val\r\n\r\n        # Even such this parameter is declared in the class header, it is assigned to the object here to access it after saving the object.\r\n        self.best_solutions_fitness = [] # A list holding the fitness value of the best solution for each generation.\r\n\r\n        self.best_solution_generation = -1 # The generation number at which the best fitness value is reached. It is only assigned the generation number after the `run()` method completes. Otherwise, its value is -1.\r\n\r\n    def initialize_population(self, low, high):\r\n\r\n        """"""\r\n        Creates an initial population randomly as a NumPy array. The array is saved in the instance attribute named \'population\'.\r\n\r\n        low: The lower value of the random range from which the gene values in the initial population are selected. It defaults to -4. Available in PyGAD 1.0.20 and higher.\r\n        high: The upper value of the random range from which the gene values in the initial population are selected. It defaults to -4. Available in PyGAD 1.0.20.\r\n        \r\n        This method assigns the values of the following 3 instance attributes:\r\n            1. pop_size: Size of the population.\r\n            2. population: Initially, holds the initial population and later updated after each generation.\r\n            3. init_population: Keeping the initial population.\r\n        """"""\r\n\r\n        # Population size = (number of chromosomes, number of genes per chromosome)\r\n        self.pop_size = (self.sol_per_pop,self.num_genes) # The population will have sol_per_pop chromosome where each chromosome has num_genes genes.\r\n        # Creating the initial population randomly.\r\n        self.population = numpy.random.uniform(low=low, \r\n                                               high=high, \r\n                                               size=self.pop_size) # A NumPy array holding the initial population.\r\n        \r\n        # Keeping the initial population in the initial_population attribute.\r\n        self.initial_population = self.population.copy()\r\n\r\n    def cal_pop_fitness(self):\r\n\r\n        """"""\r\n        Calculating the fitness values of all solutions in the current population. \r\n        It returns:\r\n            -fitness: An array of the calculated fitness values.\r\n        """"""\r\n\r\n        if self.valid_parameters == False:\r\n            raise ValueError(""ERROR calling the cal_pop_fitness() method: \\nPlease check the parameters passed while creating an instance of the GA class.\\n"")\r\n\r\n        pop_fitness = []\r\n        # Calculating the fitness value of each solution in the current population.\r\n        for sol_idx, sol in enumerate(self.population):\r\n            fitness = self.fitness_func(sol, sol_idx)\r\n            pop_fitness.append(fitness)\r\n\r\n        pop_fitness = numpy.array(pop_fitness)\r\n\r\n        return pop_fitness\r\n\r\n    def run(self):\r\n\r\n        """"""\r\n        Runs the genetic algorithm. This is the main method in which the genetic algorithm is evolved through a number of generations.\r\n        """"""\r\n\r\n        if self.valid_parameters == False:\r\n            raise ValueError(""ERROR calling the run() method: \\nThe run() method cannot be executed with invalid parameters. Please check the parameters passed while creating an instance of the GA class.\\n"")\r\n\r\n        for generation in range(self.num_generations):\r\n            # Measuring the fitness of each chromosome in the population.\r\n            fitness = self.cal_pop_fitness()\r\n\r\n            # Appending the fitness value of the best solution in the current generation to the best_solutions_fitness attribute.\r\n            self.best_solutions_fitness.append(numpy.max(fitness))\r\n\r\n            # Selecting the best parents in the population for mating.\r\n            parents = self.select_parents(fitness, num_parents=self.num_parents_mating)\r\n\r\n            # If self.crossover_type=None, then no crossover is applied and thus no offspring will be created in the next generations. The next generation will use the solutions in the current population.\r\n            if self.crossover_type is None:\r\n                if self.num_offspring <= self.keep_parents:\r\n                    offspring_crossover = parents[0:self.num_offspring]\r\n                else:\r\n                    offspring_crossover = numpy.concatenate((parents, self.population[0:(self.num_offspring - parents.shape[0])]))\r\n            else:\r\n                # Generating offspring using crossover.\r\n                offspring_crossover = self.crossover(parents,\r\n                                                     offspring_size=(self.num_offspring, self.num_genes))\r\n\r\n            # If self.mutation_type=None, then no mutation is applied and thus no changes are applied to the offspring created using the crossover operation. The offspring will be used unchanged in the next generation.\r\n            if self.mutation_type is None:\r\n                offspring_mutation = offspring_crossover\r\n            else:\r\n                # Adding some variations to the offspring using mutation.\r\n                offspring_mutation = self.mutation(offspring_crossover)\r\n\r\n            if (self.keep_parents == 0):\r\n                self.population = offspring_mutation\r\n            elif (self.keep_parents == -1):\r\n                # Creating the new population based on the parents and offspring.\r\n                self.population[0:parents.shape[0], :] = parents\r\n                self.population[parents.shape[0]:, :] = offspring_mutation\r\n            elif (self.keep_parents > 0):\r\n                parents_to_keep = self.steady_state_selection(fitness, num_parents=self.keep_parents)\r\n                self.population[0:parents_to_keep.shape[0], :] = parents_to_keep\r\n                self.population[parents_to_keep.shape[0]:, :] = offspring_mutation\r\n\r\n            self.generations_completed = generation + 1 # The generations_completed attribute holds the number of the last completed generation.\r\n\r\n            # If the callback_generation attribute is not None, then cal the callback function after the generation.\r\n            if not (self.callback_generation is None):\r\n                self.callback_generation(self)\r\n\r\n        self.best_solution_generation = numpy.where(numpy.array(self.best_solutions_fitness) == numpy.max(numpy.array(self.best_solutions_fitness)))[0][0]\r\n        # After the run() method completes, the run_completed flag is changed from False to True.\r\n        self.run_completed = True # Set to True only after the run() method completes gracefully.\r\n\r\n    def steady_state_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents using the steady-state selection technique. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        fitness_sorted = sorted(range(len(fitness)), key=lambda k: fitness[k])\r\n        fitness_sorted.reverse()\r\n        # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n        for parent_num in range(num_parents):\r\n            parents[parent_num, :] = self.population[fitness_sorted[parent_num], :]\r\n        return parents\r\n\r\n    def rank_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents using the rank selection technique. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        fitness_sorted = sorted(range(len(fitness)), key=lambda k: fitness[k])\r\n        fitness_sorted.reverse()\r\n        # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n        for parent_num in range(num_parents):\r\n            parents[parent_num, :] = self.population[fitness_sorted[parent_num], :]\r\n        return parents\r\n\r\n    def random_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents randomly. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n\r\n        rand_indices = numpy.random.randint(low=0.0, high=fitness.shape[0], size=num_parents)\r\n\r\n        for parent_num in range(num_parents):\r\n            parents[parent_num, :] = self.population[rand_indices[parent_num], :]\r\n        return parents\r\n\r\n    def tournament_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents using the tournament selection technique. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n        for parent_num in range(num_parents):\r\n            rand_indices = numpy.random.randint(low=0.0, high=len(fitness), size=self.K_tournament)\r\n            K_fitnesses = fitness[rand_indices]\r\n            selected_parent_idx = numpy.where(K_fitnesses == numpy.max(K_fitnesses))[0][0]\r\n            parents[parent_num, :] = self.population[rand_indices[selected_parent_idx], :]\r\n        return parents\r\n\r\n    def roulette_wheel_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents using the roulette wheel selection technique. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        fitness_sum = numpy.sum(fitness)\r\n        probs = fitness / fitness_sum\r\n        probs_start = numpy.zeros(probs.shape, dtype=numpy.float) # An array holding the start values of the ranges of probabilities.\r\n        probs_end = numpy.zeros(probs.shape, dtype=numpy.float) # An array holding the end values of the ranges of probabilities.\r\n\r\n        curr = 0.0\r\n\r\n        # Calculating the probabilities of the solutions to form a roulette wheel.\r\n        for _ in range(probs.shape[0]):\r\n            min_probs_idx = numpy.where(probs == numpy.min(probs))[0][0]\r\n            probs_start[min_probs_idx] = curr\r\n            curr = curr + probs[min_probs_idx]\r\n            probs_end[min_probs_idx] = curr\r\n            probs[min_probs_idx] = 99999999999\r\n\r\n        # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n        for parent_num in range(num_parents):\r\n            rand_prob = numpy.random.rand()\r\n            for idx in range(probs.shape[0]):\r\n                if (rand_prob >= probs_start[idx] and rand_prob < probs_end[idx]):\r\n                    parents[parent_num, :] = self.population[idx, :]\r\n                    break\r\n        return parents\r\n\r\n    def stochastic_universal_selection(self, fitness, num_parents):\r\n\r\n        """"""\r\n        Selects the parents using the stochastic universal selection technique. Later, these parents will mate to produce the offspring.\r\n        It accepts 2 parameters:\r\n            -fitness: The fitness values of the solutions in the current population.\r\n            -num_parents: The number of parents to be selected.\r\n        It returns an array of the selected parents.\r\n        """"""\r\n\r\n        fitness_sum = numpy.sum(fitness)\r\n        probs = fitness / fitness_sum\r\n        probs_start = numpy.zeros(probs.shape, dtype=numpy.float) # An array holding the start values of the ranges of probabilities.\r\n        probs_end = numpy.zeros(probs.shape, dtype=numpy.float) # An array holding the end values of the ranges of probabilities.\r\n\r\n        curr = 0.0\r\n\r\n        # Calculating the probabilities of the solutions to form a roulette wheel.\r\n        for _ in range(probs.shape[0]):\r\n            min_probs_idx = numpy.where(probs == numpy.min(probs))[0][0]\r\n            probs_start[min_probs_idx] = curr\r\n            curr = curr + probs[min_probs_idx]\r\n            probs_end[min_probs_idx] = curr\r\n            probs[min_probs_idx] = 99999999999\r\n\r\n        pointers_distance = 1.0 / self.num_parents_mating # Distance between different pointers.\r\n        first_pointer = numpy.random.uniform(low=0.0, high=pointers_distance, size=1) # Location of the first pointer.\r\n\r\n        # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\r\n        parents = numpy.empty((num_parents, self.population.shape[1]))\r\n        for parent_num in range(num_parents):\r\n            rand_pointer = first_pointer + parent_num*pointers_distance\r\n            for idx in range(probs.shape[0]):\r\n                if (rand_pointer >= probs_start[idx] and rand_pointer < probs_end[idx]):\r\n                    parents[parent_num, :] = self.population[idx, :]\r\n                    break\r\n        return parents\r\n\r\n    def single_point_crossover(self, parents, offspring_size):\r\n\r\n        """"""\r\n        Applies the single-point crossover. It selects a point randomly at which crossover takes place between the pairs of parents.\r\n        It accepts 2 parameters:\r\n            -parents: The parents to mate for producing the offspring.\r\n            -offspring_size: The size of the offspring to produce.\r\n        It returns an array the produced offspring.\r\n        """"""\r\n\r\n        offspring = numpy.empty(offspring_size)\r\n        # The point at which crossover takes place between two parents. Usually, it is at the center.\r\n        crossover_point = numpy.random.randint(low=0, high=parents.shape[1], size=1)[0]\r\n\r\n        for k in range(offspring_size[0]):\r\n            # Index of the first parent to mate.\r\n            parent1_idx = k % parents.shape[0]\r\n            # Index of the second parent to mate.\r\n            parent2_idx = (k+1) % parents.shape[0]\r\n            # The new offspring will have its first half of its genes taken from the first parent.\r\n            offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\r\n            # The new offspring will have its second half of its genes taken from the second parent.\r\n            offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\r\n        return offspring\r\n\r\n    def two_points_crossover(self, parents, offspring_size):\r\n\r\n        """"""\r\n        Applies the 2 points crossover. It selects the 2 points randomly at which crossover takes place between the pairs of parents.\r\n        It accepts 2 parameters:\r\n            -parents: The parents to mate for producing the offspring.\r\n            -offspring_size: The size of the offspring to produce.\r\n        It returns an array the produced offspring.\r\n        """"""\r\n\r\n        offspring = numpy.empty(offspring_size)\r\n        if (parents.shape[1] == 1): # If the chromosome has only a single gene. In this case, this gene is copied from the second parent.\r\n            crossover_point1 = 0\r\n        else:\r\n            crossover_point1 = numpy.random.randint(low=0, high=numpy.ceil(parents.shape[1]/2 + 1), size=1)[0]\r\n\r\n        crossover_point2 = crossover_point1 + int(parents.shape[1]/2) # The second point must always be greater than the first point.\r\n\r\n        for k in range(offspring_size[0]):\r\n            # Index of the first parent to mate.\r\n            parent1_idx = k % parents.shape[0]\r\n            # Index of the second parent to mate.\r\n            parent2_idx = (k+1) % parents.shape[0]\r\n            # The genes from the beginning of the chromosome up to the first point are copied from the first parent.\r\n            offspring[k, 0:crossover_point1] = parents[parent1_idx, 0:crossover_point1]\r\n            # The genes from the second point up to the end of the chromosome are copied from the first parent.\r\n            offspring[k, crossover_point2:] = parents[parent1_idx, crossover_point2:]\r\n            # The genes between the 2 points are copied from the second parent.\r\n            offspring[k, crossover_point1:crossover_point2] = parents[parent2_idx, crossover_point1:crossover_point2]\r\n        return offspring\r\n\r\n    def uniform_crossover(self, parents, offspring_size):\r\n\r\n        """"""\r\n        Applies the uniform crossover. For each gene, a parent out of the 2 mating parents is selected randomly and the gene is copied from it.\r\n        It accepts 2 parameters:\r\n            -parents: The parents to mate for producing the offspring.\r\n            -offspring_size: The size of the offspring to produce.\r\n        It returns an array the produced offspring.\r\n        """"""\r\n\r\n        offspring = numpy.empty(offspring_size)\r\n\r\n        for k in range(offspring_size[0]):\r\n            # Index of the first parent to mate.\r\n            parent1_idx = k % parents.shape[0]\r\n            # Index of the second parent to mate.\r\n            parent2_idx = (k+1) % parents.shape[0]\r\n\r\n            genes_source = numpy.random.randint(low=0, high=2, size=offspring_size[1])\r\n            for gene_idx in range(offspring_size[1]):\r\n                if (genes_source[gene_idx] == 0):\r\n                    # The gene will be copied from the first parent if the current gene index is 0.\r\n                    offspring[k, gene_idx] = parents[parent1_idx, gene_idx]\r\n                elif (genes_source[gene_idx] == 1):\r\n                    # The gene will be copied from the second parent if the current gene index is 1.\r\n                    offspring[k, gene_idx] = parents[parent2_idx, gene_idx]\r\n        return offspring\r\n\r\n    def random_mutation(self, offspring):\r\n\r\n        """"""\r\n        Applies the random mutation which changes the values of a number of genes randomly by selecting a random value between random_mutation_min_val and random_mutation_max_val to be added to the selected genes.\r\n        It accepts a single parameter:\r\n            -offspring: The offspring to mutate.\r\n        It returns an array of the mutated offspring.\r\n        """"""\r\n\r\n        if self.mutation_num_genes == None:\r\n            self.mutation_num_genes = numpy.uint32((self.mutation_percent_genes*offspring.shape[1])/100)\r\n            # Based on the percentage of genes, if the number of selected genes for mutation is less than the least possible value which is 1, then the number will be set to 1.\r\n            if self.mutation_num_genes == 0:\r\n                self.mutation_num_genes = 1\r\n        mutation_indices = numpy.array(random.sample(range(0, offspring.shape[1]), self.mutation_num_genes))\r\n        # Random mutation changes a single gene in each offspring randomly.\r\n        for offspring_idx in range(offspring.shape[0]):\r\n            for gene_idx in mutation_indices:\r\n                # Generating a random value.\r\n                random_value = numpy.random.uniform(self.random_mutation_min_val, self.random_mutation_max_val, 1)\r\n                # If the mutation_by_replacement attribute is True, then the random value replaces the current gene value.\r\n                if self.mutation_by_replacement:\r\n                    offspring[offspring_idx, gene_idx] = random_value\r\n                # If the mutation_by_replacement attribute is False, then the random value is added to the gene value.\r\n                else:\r\n                    offspring[offspring_idx, gene_idx] = offspring[offspring_idx, gene_idx] + random_value\r\n        return offspring\r\n\r\n    def swap_mutation(self, offspring):\r\n\r\n        """"""\r\n        Applies the swap mutation which interchanges the values of 2 randomly selected genes.\r\n        It accepts a single parameter:\r\n            -offspring: The offspring to mutate.\r\n        It returns an array of the mutated offspring.\r\n        """"""\r\n\r\n        for idx in range(offspring.shape[0]):\r\n            mutation_gene1 = numpy.random.randint(low=0, high=offspring.shape[1]/2, size=1)[0]\r\n            mutation_gene2 = mutation_gene1 + int(offspring.shape[1]/2)\r\n\r\n            temp = offspring[idx, mutation_gene1]\r\n            offspring[idx, mutation_gene1] = offspring[idx, mutation_gene2]\r\n            offspring[idx, mutation_gene2] = temp\r\n        return offspring\r\n\r\n    def inversion_mutation(self, offspring):\r\n\r\n        """"""\r\n        Applies the inversion mutation which selects a subset of genes and invert them.\r\n        It accepts a single parameter:\r\n            -offspring: The offspring to mutate.\r\n        It returns an array of the mutated offspring.\r\n        """"""\r\n\r\n        for idx in range(offspring.shape[0]):\r\n            mutation_gene1 = numpy.random.randint(low=0, high=numpy.ceil(offspring.shape[1]/2 + 1), size=1)[0]\r\n            mutation_gene2 = mutation_gene1 + int(offspring.shape[1]/2)\r\n\r\n            genes_to_scramble = numpy.flip(offspring[idx, mutation_gene1:mutation_gene2])\r\n            offspring[idx, mutation_gene1:mutation_gene2] = genes_to_scramble\r\n        return offspring\r\n\r\n    def scramble_mutation(self, offspring):\r\n\r\n        """"""\r\n        Applies the scramble mutation which selects a subset of genes and shuffles their order randomly.\r\n        It accepts a single parameter:\r\n            -offspring: The offspring to mutate.\r\n        It returns an array of the mutated offspring.\r\n        """"""\r\n\r\n        for idx in range(offspring.shape[0]):\r\n            mutation_gene1 = numpy.random.randint(low=0, high=numpy.ceil(offspring.shape[1]/2 + 1), size=1)[0]\r\n            mutation_gene2 = mutation_gene1 + int(offspring.shape[1]/2)\r\n            genes_range = numpy.arange(start=mutation_gene1, stop=mutation_gene2)\r\n            numpy.random.shuffle(genes_range)\r\n            \r\n            genes_to_scramble = numpy.flip(offspring[idx, genes_range])\r\n            offspring[idx, genes_range] = genes_to_scramble\r\n        return offspring\r\n\r\n    def best_solution(self):\r\n\r\n        """"""\r\n        Returns information about the best solution found by the genetic algorithm. Can only be called after completing at least 1 generation.\r\n        If no generation is completed (at least 1), an exception is raised. Otherwise, the following is returned:\r\n            -best_solution: Best solution in the current population.\r\n            -best_solution_fitness: Fitness value of the best solution.\r\n            -best_match_idx: Index of the best solution in the current population.\r\n        """"""\r\n        \r\n        if self.generations_completed < 1:\r\n            raise RuntimeError(""The best_solution() method can only be called after completing at least 1 generation but {generations_completed} is completed."".format(generations_completed=self.generations_completed))\r\n\r\n#        if self.run_completed == False:\r\n#            raise ValueError(""Warning calling the best_solution() method: \\nThe run() method is not yet called and thus the GA did not evolve the solutions. Thus, the best solution is retireved from the initial random population without being evolved.\\n"")\r\n\r\n        # Getting the best solution after finishing all generations.\r\n        # At first, the fitness is calculated for each solution in the final generation.\r\n        fitness = self.cal_pop_fitness()\r\n        # Then return the index of that solution corresponding to the best fitness.\r\n        best_match_idx = numpy.where(fitness == numpy.max(fitness))[0][0]\r\n\r\n        best_solution = self.population[best_match_idx, :]\r\n        best_solution_fitness = fitness[best_match_idx]\r\n\r\n        return best_solution, best_solution_fitness, best_match_idx\r\n\r\n    def plot_result(self, title=""PyGAD - Iteration vs. Fitness"", xlabel=""Generation"", ylabel=""Fitness""):\r\n\r\n        """"""\r\n        Creates and shows a plot that summarizes how the fitness value evolved by generation. Can only be called after completing at least 1 generation.\r\n        If no generation is completed, an exception is raised.\r\n        """"""\r\n\r\n        if self.generations_completed < 1:\r\n            raise RuntimeError(""The plot_result() method can only be called after completing at least 1 generation but {generations_completed} is completed."".format(generations_completed=self.generations_completed))\r\n\r\n#        if self.run_completed == False:\r\n#            print(""Warning calling the plot_result() method: \\nGA is not executed yet and there are no results to display. Please call the run() method before calling the plot_result() method.\\n"")\r\n\r\n        matplotlib.pyplot.figure()\r\n        matplotlib.pyplot.plot(self.best_solutions_fitness)\r\n        matplotlib.pyplot.title(title)\r\n        matplotlib.pyplot.xlabel(xlabel)\r\n        matplotlib.pyplot.ylabel(ylabel)\r\n        matplotlib.pyplot.show()\r\n\r\n    def save(self, filename):\r\n\r\n        """"""\r\n        Saves the genetic algorithm instance:\r\n            -filename: Name of the file to save the instance. No extension is needed.\r\n        """"""\r\n\r\n        with open(filename + "".pkl"", \'wb\') as file:\r\n            pickle.dump(self, file)\r\n\r\ndef load(filename):\r\n\r\n    """"""\r\n    Reads a saved instance of the genetic algorithm:\r\n        -filename: Name of the file to read the instance. No extension is needed.\r\n    Returns the genetic algorithm instance.\r\n    """"""\r\n\r\n    try:\r\n        with open(filename + "".pkl"", \'rb\') as file:\r\n            ga_in = pickle.load(file)\r\n    except FileNotFoundError:\r\n        raise FileNotFoundError(""Error reading the file {filename}. Please check your inputs."".format(filename=filename))\r\n    except:\r\n        raise BaseException(""Error loading the file. Please check if the file exists."")\r\n    return ga_in'"
Tutorial Project/Example_GeneticAlgorithm.py,0,"b'import numpy\nimport ga\n\n""""""\nThe y=target is to maximize this equation ASAP:\n    y = w1x1+w2x2+w3x3+w4x4+w5x5+6wx6\n    where (x1,x2,x3,x4,x5,x6)=(4,-2,3.5,5,-11,-4.7)\n    What are the best values for the 6 weights w1 to w6?\n    We are going to use the genetic algorithm for the best possible values after a number of generations.\n""""""\n\n# Inputs of the equation.\nequation_inputs = [4,-2,3.5,5,-11,-4.7]\n\n# Number of the weights we are looking to optimize.\nnum_weights = len(equation_inputs)\n\n""""""\nGenetic algorithm parameters:\n    Mating pool size\n    Population size\n""""""\nsol_per_pop = 8\nnum_parents_mating = 4\n\n# Defining the population size.\npop_size = (sol_per_pop,num_weights) # The population will have sol_per_pop chromosome where each chromosome has num_weights genes.\n#Creating the initial population.\nnew_population = numpy.random.uniform(low=-4.0, high=4.0, size=pop_size)\nprint(new_population)\n\n""""""\nnew_population[0, :] = [2.4,  0.7, 8, -2,   5,   1.1]\nnew_population[1, :] = [-0.4, 2.7, 5, -1,   7,   0.1]\nnew_population[2, :] = [-1,   2,   2, -3,   2,   0.9]\nnew_population[3, :] = [4,    7,   12, 6.1, 1.4, -4]\nnew_population[4, :] = [3.1,  4,   0,  2.4, 4.8,  0]\nnew_population[5, :] = [-2,   3,   -7, 6,   3,    3]\n""""""\n\nbest_outputs = []\nnum_generations = 1000\nfor generation in range(num_generations):\n    print(""Generation : "", generation)\n    # Measuring the fitness of each chromosome in the population.\n    fitness = ga.cal_pop_fitness(equation_inputs, new_population)\n    print(""Fitness"")\n    print(fitness)\n\n    best_outputs.append(numpy.max(numpy.sum(new_population*equation_inputs, axis=1)))\n    # The best result in the current iteration.\n    print(""Best result : "", numpy.max(numpy.sum(new_population*equation_inputs, axis=1)))\n    \n    # Selecting the best parents in the population for mating.\n    parents = ga.select_mating_pool(new_population, fitness, \n                                      num_parents_mating)\n    print(""Parents"")\n    print(parents)\n\n    # Generating next generation using crossover.\n    offspring_crossover = ga.crossover(parents,\n                                       offspring_size=(pop_size[0]-parents.shape[0], num_weights))\n    print(""Crossover"")\n    print(offspring_crossover)\n\n    # Adding some variations to the offspring using mutation.\n    offspring_mutation = ga.mutation(offspring_crossover, num_mutations=2)\n    print(""Mutation"")\n    print(offspring_mutation)\n\n    # Creating the new population based on the parents and offspring.\n    new_population[0:parents.shape[0], :] = parents\n    new_population[parents.shape[0]:, :] = offspring_mutation\n    \n# Getting the best solution after iterating finishing all generations.\n#At first, the fitness is calculated for each solution in the final generation.\nfitness = ga.cal_pop_fitness(equation_inputs, new_population)\n# Then return the index of that solution corresponding to the best fitness.\nbest_match_idx = numpy.where(fitness == numpy.max(fitness))\n\nprint(""Best solution : "", new_population[best_match_idx, :])\nprint(""Best solution fitness : "", fitness[best_match_idx])\n\n\nimport matplotlib.pyplot\nmatplotlib.pyplot.plot(best_outputs)\nmatplotlib.pyplot.xlabel(""Iteration"")\nmatplotlib.pyplot.ylabel(""Fitness"")\nmatplotlib.pyplot.show()\n'"
Tutorial Project/ga.py,0,"b'import numpy\n\ndef cal_pop_fitness(equation_inputs, pop):\n    # Calculating the fitness value of each solution in the current population.\n    # The fitness function calulates the sum of products between each input and its corresponding weight.\n    fitness = numpy.sum(pop*equation_inputs, axis=1)\n    return fitness\n\ndef select_mating_pool(pop, fitness, num_parents):\n    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.\n    parents = numpy.empty((num_parents, pop.shape[1]))\n    for parent_num in range(num_parents):\n        max_fitness_idx = numpy.where(fitness == numpy.max(fitness))\n        max_fitness_idx = max_fitness_idx[0][0]\n        parents[parent_num, :] = pop[max_fitness_idx, :]\n        fitness[max_fitness_idx] = -99999999999\n    return parents\n\ndef crossover(parents, offspring_size):\n    offspring = numpy.empty(offspring_size)\n    # The point at which crossover takes place between two parents. Usually, it is at the center.\n    crossover_point = numpy.uint8(offspring_size[1]/2)\n\n    for k in range(offspring_size[0]):\n        # Index of the first parent to mate.\n        parent1_idx = k%parents.shape[0]\n        # Index of the second parent to mate.\n        parent2_idx = (k+1)%parents.shape[0]\n        # The new offspring will have its first half of its genes taken from the first parent.\n        offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]\n        # The new offspring will have its second half of its genes taken from the second parent.\n        offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]\n    return offspring\n\ndef mutation(offspring_crossover, num_mutations=1):\n    mutations_counter = numpy.uint8(offspring_crossover.shape[1] / num_mutations)\n    # Mutation changes a number of genes as defined by the num_mutations argument. The changes are random.\n    for idx in range(offspring_crossover.shape[0]):\n        gene_idx = mutations_counter - 1\n        for mutation_num in range(num_mutations):\n            # The random value to be added to the gene.\n            random_value = numpy.random.uniform(-1.0, 1.0, 1)\n            offspring_crossover[idx, gene_idx] = offspring_crossover[idx, gene_idx] + random_value\n            gene_idx = gene_idx + mutations_counter\n    return offspring_crossover\n'"
docs/source/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\r\n#\r\n# This file only contains a selection of the most common options. For a full\r\n# list see the documentation:\r\n# http://www.sphinx-doc.org/en/master/config\r\n\r\n# -- Path setup --------------------------------------------------------------\r\n\r\n# If extensions (or modules to document with autodoc) are in another directory,\r\n# add these directories to sys.path here. If the directory is relative to the\r\n# documentation root, use os.path.abspath to make it absolute, like shown here.\r\n#\r\n# import os\r\n# import sys\r\n# sys.path.insert(0, os.path.abspath(\'.\'))\r\n\r\n\r\n# -- Project information -----------------------------------------------------\r\n\r\nproject = \'PyGAD\'\r\ncopyright = \'2020, Ahmed Fawzy Gad\'\r\nauthor = \'Ahmed Fawzy Gad\'\r\n\r\n# The full version, including alpha/beta/rc tags\r\nrelease = \'2.3.2\'\r\n\r\nmaster_doc = \'index\'\r\n\r\n# -- General configuration ---------------------------------------------------\r\n\r\n# Add any Sphinx extension module names here, as strings. They can be\r\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\r\n# ones.\r\nextensions = [] # Add \'sphinx.ext.autodoc\' to enabe creeate modindex and enable automodule\r\n\r\n# Add any paths that contain templates here, relative to this directory.\r\ntemplates_path = [\'_templates\']\r\n\r\n# List of patterns, relative to source directory, that match files and\r\n# directories to ignore when looking for source files.\r\n# This pattern also affects html_static_path and html_extra_path.\r\nexclude_patterns = []\r\n\r\n\r\n# -- Options for HTML output -------------------------------------------------\r\n\r\n# The theme to use for HTML and HTML Help pages.  See the documentation for\r\n# a list of builtin themes.\r\n#\r\nhtml_theme = \'alabaster\'\r\n\r\n# Add any paths that contain custom static files (such as style sheets) here,\r\n# relative to this directory. They are copied after the builtin static files,\r\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\r\nhtml_static_path = [\'_static\']\r\n'"
