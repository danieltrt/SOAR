file_path,api_count,code
src/__init__.py,0,b''
src/color_classification_image.py,0,"b""#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# -------------------------------------------------------------------------\n# --- Author         : Ahmet Ozlu\n# --- Mail           : ahmetozlu93@gmail.com\n# --- Date           : 8th July 2018 - before Google inside look 2018 :)\n# -------------------------------------------------------------------------\n\nimport cv2\nfrom color_recognition_api import color_histogram_feature_extraction\nfrom color_recognition_api import knn_classifier\nimport os\nimport os.path\nimport sys\n\n# read the test image\ntry:\n    source_image = cv2.imread(sys.argv[1])\nexcept:\n    source_image = cv2.imread('black_cat.jpg')\nprediction = 'n.a.'\n\n# checking whether the training data is ready\nPATH = './training.data'\n\nif os.path.isfile(PATH) and os.access(PATH, os.R_OK):\n    print ('training data is ready, classifier is loading...')\nelse:\n    print ('training data is being created...')\n    open('training.data', 'w')\n    color_histogram_feature_extraction.training()\n    print ('training data is ready, classifier is loading...')\n\n# get the prediction\ncolor_histogram_feature_extraction.color_histogram_of_test_image(source_image)\nprediction = knn_classifier.main('training.data', 'test.data')\nprint('Detected color is:', prediction)\ncv2.putText(\n    source_image,\n    'Prediction: ' + prediction,\n    (15, 45),\n    cv2.FONT_HERSHEY_PLAIN,\n    3,\n    200,\n    )\n\n# Display the resulting frame\ncv2.imshow('color classifier', source_image)\ncv2.waitKey(0)\t\t\n"""
src/color_classification_webcam.py,0,"b""#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------\n# --- Author         : Ahmet Ozlu\n# --- Mail           : ahmetozlu93@gmail.com\n# --- Date           : 31st December 2017 - new year eve :)\n# ----------------------------------------------\n\nimport cv2\nfrom color_recognition_api import color_histogram_feature_extraction\nfrom color_recognition_api import knn_classifier\nimport os\nimport os.path\n\ncap = cv2.VideoCapture(1)\n(ret, frame) = cap.read()\nprediction = 'n.a.'\n\n# checking whether the training data is ready\nPATH = './training.data'\n\nif os.path.isfile(PATH) and os.access(PATH, os.R_OK):\n    print ('training data is ready, classifier is loading...')\nelse:\n    print ('training data is being created...')\n    open('training.data', 'w')\n    color_histogram_feature_extraction.training()\n    print ('training data is ready, classifier is loading...')\n\nwhile True:\n\n    # Capture frame-by-frame\n    (ret, frame) = cap.read()\n\n    cv2.putText(\n        frame,\n        'Prediction: ' + prediction,\n        (15, 45),\n        cv2.FONT_HERSHEY_PLAIN,\n        3,\n        200,\n        )\n\n    # Display the resulting frame\n    cv2.imshow('color classifier', frame)\n\n    color_histogram_feature_extraction.color_histogram_of_test_image(frame)\n\n    prediction = knn_classifier.main('training.data', 'test.data')\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\n# When everything done, release the capture\ncap.release()\ncv2.destroyAllWindows()\t\t\n"""
src/color_recognition_api/__init__.py,0,b''
src/color_recognition_api/color_histogram_feature_extraction.py,2,"b""#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------\n# --- Author         : Ahmet Ozlu\n# --- Mail           : ahmetozlu93@gmail.com\n# --- Date           : 31st December 2017 - new year eve :)\n# ----------------------------------------------\n\nfrom PIL import Image\nimport os\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import itemfreq\nfrom color_recognition_api import knn_classifier as knn_classifier\n\n\ndef color_histogram_of_test_image(test_src_image):\n\n    # load the image\n    image = test_src_image\n\n    chans = cv2.split(image)\n    colors = ('b', 'g', 'r')\n    features = []\n    feature_data = ''\n    counter = 0\n    for (chan, color) in zip(chans, colors):\n        counter = counter + 1\n\n        hist = cv2.calcHist([chan], [0], None, [256], [0, 256])\n        features.extend(hist)\n\n        # find the peak pixel values for R, G, and B\n        elem = np.argmax(hist)\n\n        if counter == 1:\n            blue = str(elem)\n        elif counter == 2:\n            green = str(elem)\n        elif counter == 3:\n            red = str(elem)\n            feature_data = red + ',' + green + ',' + blue\n            # print(feature_data)\n\n    with open('test.data', 'w') as myfile:\n        myfile.write(feature_data)\n\n\ndef color_histogram_of_training_image(img_name):\n\n    # detect image color by using image file name to label training data\n    if 'red' in img_name:\n        data_source = 'red'\n    elif 'yellow' in img_name:\n        data_source = 'yellow'\n    elif 'green' in img_name:\n        data_source = 'green'\n    elif 'orange' in img_name:\n        data_source = 'orange'\n    elif 'white' in img_name:\n        data_source = 'white'\n    elif 'black' in img_name:\n        data_source = 'black'\n    elif 'blue' in img_name:\n        data_source = 'blue'\n    elif 'violet' in img_name:\n        data_source = 'violet'\n\n    # load the image\n    image = cv2.imread(img_name)\n\n    chans = cv2.split(image)\n    colors = ('b', 'g', 'r')\n    features = []\n    feature_data = ''\n    counter = 0\n    for (chan, color) in zip(chans, colors):\n        counter = counter + 1\n\n        hist = cv2.calcHist([chan], [0], None, [256], [0, 256])\n        features.extend(hist)\n\n        # find the peak pixel values for R, G, and B\n        elem = np.argmax(hist)\n\n        if counter == 1:\n            blue = str(elem)\n        elif counter == 2:\n            green = str(elem)\n        elif counter == 3:\n            red = str(elem)\n            feature_data = red + ',' + green + ',' + blue\n\n    with open('training.data', 'a') as myfile:\n        myfile.write(feature_data + ',' + data_source + '\\n')\n\n\ndef training():\n\n    # red color training images\n    for f in os.listdir('./training_dataset/red'):\n        color_histogram_of_training_image('./training_dataset/red/' + f)\n\n    # yellow color training images\n    for f in os.listdir('./training_dataset/yellow'):\n        color_histogram_of_training_image('./training_dataset/yellow/' + f)\n\n    # green color training images\n    for f in os.listdir('./training_dataset/green'):\n        color_histogram_of_training_image('./training_dataset/green/' + f)\n\n    # orange color training images\n    for f in os.listdir('./training_dataset/orange'):\n        color_histogram_of_training_image('./training_dataset/orange/' + f)\n\n    # white color training images\n    for f in os.listdir('./training_dataset/white'):\n        color_histogram_of_training_image('./training_dataset/white/' + f)\n\n    # black color training images\n    for f in os.listdir('./training_dataset/black'):\n        color_histogram_of_training_image('./training_dataset/black/' + f)\n\n    # blue color training images\n    for f in os.listdir('./training_dataset/blue'):\n        color_histogram_of_training_image('./training_dataset/blue/' + f)\t\t\n"""
src/color_recognition_api/knn_classifier.py,0,"b'#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# ----------------------------------------------\n# --- Author         : Ahmet Ozlu\n# --- Mail           : ahmetozlu93@gmail.com\n# --- Date           : 31st December 2017 - new year eve :)\n# ----------------------------------------------\n\nimport csv\nimport random\nimport math\nimport operator\nimport cv2\n\n\n# calculation of euclidead distance\ndef calculateEuclideanDistance(variable1, variable2, length):\n    distance = 0\n    for x in range(length):\n        distance += pow(variable1[x] - variable2[x], 2)\n    return math.sqrt(distance)\n\n\n# get k nearest neigbors\ndef kNearestNeighbors(training_feature_vector, testInstance, k):\n    distances = []\n    length = len(testInstance)\n    for x in range(len(training_feature_vector)):\n        dist = calculateEuclideanDistance(testInstance,\n                training_feature_vector[x], length)\n        distances.append((training_feature_vector[x], dist))\n    distances.sort(key=operator.itemgetter(1))\n    neighbors = []\n    for x in range(k):\n        neighbors.append(distances[x][0])\n    return neighbors\n\n\n# votes of neighbors\ndef responseOfNeighbors(neighbors):\n    all_possible_neighbors = {}\n    for x in range(len(neighbors)):\n        response = neighbors[x][-1]\n        if response in all_possible_neighbors:\n            all_possible_neighbors[response] += 1\n        else:\n            all_possible_neighbors[response] = 1\n    sortedVotes = sorted(all_possible_neighbors.items(),\n                         key=operator.itemgetter(1), reverse=True)\n    return sortedVotes[0][0]\n\n\n# Load image feature data to training feature vectors and test feature vector\ndef loadDataset(\n    filename,\n    filename2,\n    training_feature_vector=[],\n    test_feature_vector=[],\n    ):\n    with open(filename) as csvfile:\n        lines = csv.reader(csvfile)\n        dataset = list(lines)\n        for x in range(len(dataset)):\n            for y in range(3):\n                dataset[x][y] = float(dataset[x][y])\n            training_feature_vector.append(dataset[x])\n\n    with open(filename2) as csvfile:\n        lines = csv.reader(csvfile)\n        dataset = list(lines)\n        for x in range(len(dataset)):\n            for y in range(3):\n                dataset[x][y] = float(dataset[x][y])\n            test_feature_vector.append(dataset[x])\n\n\ndef main(training_data, test_data):\n    training_feature_vector = []  # training feature vector\n    test_feature_vector = []  # test feature vector\n    loadDataset(training_data, test_data, training_feature_vector, test_feature_vector)\n    classifier_prediction = []  # predictions\n    k = 3  # K value of k nearest neighbor\n    for x in range(len(test_feature_vector)):\n        neighbors = kNearestNeighbors(training_feature_vector, test_feature_vector[x], k)\n        result = responseOfNeighbors(neighbors)\n        classifier_prediction.append(result)\n    return classifier_prediction[0]\t\t\n'"
