file_path,api_count,code
setup.py,0,"b'""""""The setup script.""""""\n\nfrom setuptools import setup, find_packages\n\nwith open(\'README.rst\') as file_readme:\n    readme = file_readme.read()\n\n\nsetup(\n    author=""Andrew Hynes"",\n    author_email=\'andrewjhynes@gmail.com\',\n    classifiers=[\n        \'Development Status :: 3 - Alpha\',\n        \'Intended Audience :: Science/Research\',\n        \'License :: OSI Approved :: BSD License\',\n        \'Natural Language :: English\',\n        \'Programming Language :: Python :: 3.7\',\n        \'Programming Language :: Python :: 3.8\',\n        \'Topic :: Scientific/Engineering\',\n    ],\n\n    description=""Spatial objects and computations based on NumPy arrays."",\n    long_description=readme,\n\n    name=\'scikit-spatial\',\n    keywords=\'scikit-spatial\',\n\n    packages=find_packages(exclude=[\'tests*\']),\n\n    package_data={\n        \'skspatial\': [\'py.typed\'],  # Needed for distributing type annotations.\n    },\n\n    install_requires=[\n        \'matplotlib\',\n        \'numpy\',\n    ],\n\n    setup_requires=[\'pytest-runner\', \'wheel\'],\n    tests_require=[\'pytest\'],\n    test_suite=\'tests\',\n\n    include_package_data=True,\n    license=""BSD license"",\n    url=\'https://github.com/ajhynes7/scikit-spatial\',\n    version=\'4.0.1\',\n    zip_safe=False,\n)\n'"
skspatial/__init__.py,0,"b'""""""Top-level package for scikit-spatial.""""""\n\n__author__ = ""Andrew Hynes""\n__email__ = \'andrewjhynes@gmail.com\'\n__version__ = \'4.0.1\'\n'"
skspatial/_functions.py,9,"b'""""""Private functions for some spatial computations.""""""\n\nimport math\nfrom functools import wraps\nfrom typing import Any, Callable\n\nimport numpy as np\n\nfrom skspatial.typing import array_like\n\n\ndef _contains_point(obj: Any, point: array_like, **kwargs: float) -> bool:\n    """"""\n    Check if the object contains a point.\n\n    Returns True if the distance from the point to the object is close to zero.\n\n    Parameters\n    ----------\n    obj: Object\n        Spatial object (e.g. Line).\n    point : array_like\n        Input point.\n    kwargs : dict, optional\n        Additional keywords passed to :func:`math.isclose`.\n\n    Returns\n    -------\n    bool\n        True if the spatial object contains the input point.\n\n    Notes\n    -----\n    Setting an absolute tolerance is useful when comparing a value to zero.\n\n    """"""\n    distance = obj.distance_point(point)\n\n    return math.isclose(distance, 0, **kwargs)\n\n\ndef _sum_squares(obj: Any, points: array_like) -> np.float64:\n    """"""Return the sum of squared distances from points to a spatial object.""""""\n    distances_squared = np.apply_along_axis(obj.distance_point, 1, points) ** 2\n\n    return distances_squared.sum()\n\n\ndef _mesh_to_points(X: array_like, Y: array_like, Z: array_like) -> np.ndarray:\n    """"""Convert a mesh into an (N, 3) array of N points.""""""\n    return np.vstack([*map(np.ravel, [X, Y, Z])]).T\n\n\ndef np_float(func: Callable) -> Callable[..., np.float64]:\n    """"""\n    Cast the output type as np.float64.\n\n    Outputs with type np.float64 have a useful round() method.\n\n    """"""\n    # wraps() is needed so that sphinx generates\n    # the docstring of functions with this decorator.\n    @wraps(func)\n    def wrapper(*args):\n        return np.float64(func(*args))\n\n    return wrapper\n\n\n_allclose = np.vectorize(math.isclose)\n'"
skspatial/measurement.py,4,"b'""""""Measurements using spatial objects.""""""\n\nimport numpy as np\n\nfrom skspatial.objects import Vector\nfrom skspatial.typing import array_like\n\n\ndef area_triangle(point_a: array_like, point_b: array_like, point_c: array_like) -> np.float64:\n    """"""\n    Return the area of a triangle defined by three points.\n\n    The points are the vertices of the triangle. They must be 3D or less.\n\n    Parameters\n    ----------\n    point_a, point_b, point_c : array_like\n        The three vertices of the triangle.\n\n    Returns\n    -------\n    np.float64\n        The area of the triangle.\n\n    References\n    ----------\n    http://mathworld.wolfram.com/TriangleArea.html\n\n    Examples\n    --------\n    >>> from skspatial.measurement import area_triangle\n\n    >>> area_triangle([0, 0], [0, 1], [1, 0])\n    0.5\n\n    >>> area_triangle([0, 0], [0, 2], [1, 1])\n    1.0\n\n    >>> area_triangle([3, -5, 1], [5, 2, 1], [9, 4, 2]).round(2)\n    12.54\n\n    """"""\n    vector_ab = Vector.from_points(point_a, point_b)\n    vector_ac = Vector.from_points(point_a, point_c)\n\n    # Normal vector of plane defined by the three points.\n    vector_normal = vector_ab.cross(vector_ac)\n\n    return 0.5 * vector_normal.norm()\n\n\ndef volume_tetrahedron(\n    point_a: array_like, point_b: array_like, point_c: array_like, point_d: array_like\n) -> np.float64:\n    """"""\n    Return the volume of a tetrahedron defined by four points.\n\n    The points are the vertices of the tetrahedron. They must be 3D or less.\n\n    Parameters\n    ----------\n    point_a, point_b, point_c, point_d : array_like\n        The four vertices of the tetrahedron.\n\n    Returns\n    -------\n    np.float64\n        The volume of the tetrahedron.\n\n    References\n    ----------\n    http://mathworld.wolfram.com/Tetrahedron.html\n\n    Examples\n    --------\n    >>> from skspatial.measurement import volume_tetrahedron\n\n    >>> volume_tetrahedron([0, 0], [3, 2], [-3, 5], [1, 8])\n    0.0\n\n    >>> volume_tetrahedron([0, 0, 0], [2, 0, 0], [1, 1, 0], [0, 0, 1]).round(3)\n    0.333\n\n    >>> volume_tetrahedron([0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]).round(3)\n    0.167\n\n    """"""\n    vector_ab = Vector.from_points(point_a, point_b)\n    vector_ac = Vector.from_points(point_a, point_c)\n    vector_ad = Vector.from_points(point_a, point_d)\n\n    vector_cross = vector_ac.cross(vector_ad)\n\n    # Set the dimension to 3 so it matches the cross product.\n    vector_ab = vector_ab.set_dimension(3)\n\n    return 1 / 6 * abs(vector_ab.dot(vector_cross))\n'"
skspatial/plotting.py,2,"b'""""""Private functions used for plotting spatial objects with Matplotlib.""""""\n\nfrom typing import Any, Callable, Tuple, Union\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial.typing import array_like\n\n\ndef _scatter_2d(ax_2d: Axes, points: array_like, **kwargs) -> None:\n    """"""\n    Plot points on a 2D scatter plot.\n\n    Parameters\n    ----------\n    ax_2d : Axes\n        Instance of :class:`~matplotlib.axes.Axes`.\n    points : array_like\n        2D points.\n    kwargs : dict, optional\n        Additional keywords passed to :meth:`~matplotlib.axes.Axes.scatter`.\n\n    """"""\n    array = np.array(points)\n    ax_2d.scatter(array[:, 0], array[:, 1], **kwargs)\n\n\ndef _scatter_3d(ax_3d: Axes3D, points: array_like, **kwargs) -> None:\n    """"""\n    Plot points on a 3D scatter plot.\n\n    Parameters\n    ----------\n    ax_3d : Axes3D\n        Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n    points : array_like\n        3D points.\n    kwargs : dict, optional\n        Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.scatter`.\n\n    Raises\n    ------\n    ValueError\n        If the axis is not an instance of Axes3D.\n\n    """"""\n    if not isinstance(ax_3d, Axes3D):\n        raise ValueError(""Axis must be instance of class Axes3D."")\n\n    array = np.array(points)\n    ax_3d.scatter(array[:, 0], array[:, 1], array[:, 2], **kwargs)\n\n\ndef _connect_points_2d(ax_2d: Axes, point_a: array_like, point_b: array_like, **kwargs) -> None:\n    """"""\n    Plot a line between two 2D points.\n\n    Parameters\n    ----------\n    ax_2d : Axes\n        Instance of :class:`~matplotlib.axes.Axes`.\n    point_a, point_b : array_like\n        The two 2D points to be connected.\n    kwargs : dict, optional\n        Additional keywords passed to :meth:`~matplotlib.axes.Axes.plot`.\n\n    """"""\n    xs = [point_a[0], point_b[0]]\n    ys = [point_a[1], point_b[1]]\n\n    ax_2d.plot(xs, ys, **kwargs)\n\n\ndef _connect_points_3d(ax_3d: Axes3D, point_a: array_like, point_b: array_like, **kwargs) -> None:\n    """"""\n    Plot a line between two 3D points.\n\n    Parameters\n    ----------\n    ax_3d : Axes3D\n        Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n    point_a, point_b : array_like\n        The two 3D points to be connected.\n    kwargs : dict, optional\n        Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.plot`.\n\n    Raises\n    ------\n    ValueError\n        If the axis is not an instance of Axes3D.\n\n    """"""\n    if not isinstance(ax_3d, Axes3D):\n        raise ValueError(""Axis must be instance of class Axes3D."")\n\n    xs = [point_a[0], point_b[0]]\n    ys = [point_a[1], point_b[1]]\n    zs = [point_a[2], point_b[2]]\n\n    ax_3d.plot(xs, ys, zs, **kwargs)\n\n\ndef _plotter(obj: Any, **kwargs) -> Union[Callable[[Axes], None], Callable[[Axes3D], None]]:\n    """"""Return a function that plots the object when passed a matplotlib axes.""""""\n    if obj.dimension == 2:\n\n        if not hasattr(obj, \'plot_2d\'):\n            raise ValueError(""The object cannot be plotted in 2D."")\n\n        return lambda ax: obj.plot_2d(ax, **kwargs)\n\n    if obj.dimension == 3:\n\n        if not hasattr(obj, \'plot_3d\'):\n            raise ValueError(""The object cannot be plotted in 3D."")\n\n        return lambda ax: obj.plot_3d(ax, **kwargs)\n\n    raise ValueError(""The dimension must be 2 or 3."")\n\n\ndef plot_2d(*plotters: Callable) -> Tuple:\n    """"""Plot multiple spatial objects in 2D.""""""\n    fig, ax = plt.subplots()\n\n    for plotter in plotters:\n        plotter(ax)\n\n    return fig, ax\n\n\ndef plot_3d(*plotters: Callable) -> Tuple:\n    """"""Plot multiple spatial objects in 3D.""""""\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\'3d\')\n\n    for plotter in plotters:\n        plotter(ax)\n\n    return fig, ax\n'"
skspatial/transformation.py,3,"b'""""""Spatial transformations.""""""\n\nfrom typing import Sequence\n\nimport numpy as np\n\nfrom skspatial.typing import array_like\n\n\ndef transform_coordinates(points: array_like, point_origin: array_like, vectors_basis: Sequence) -> np.ndarray:\n    """"""\n    Transform points into a new coordinate system.\n\n    Parameters\n    ----------\n    points : (N, D) array_like\n        Array of N points with dimension D.\n    point_origin : (D,) array_like\n        Origin of the new coordinate system.\n        Array for one point with dimension D.\n    vectors_basis : sequence\n        Basis vectors of the new coordinate system.\n        Sequence of N_bases vectors.\n        Each vector is an array_like with D elements.\n\n    Returns\n    -------\n    ndarray\n        Coordinates in the new coordinate system.\n        (N, N_bases) array.\n\n    Examples\n    --------\n    >>> from skspatial.transformation import transform_coordinates\n\n    >>> points = [[1, 2], [3, 4], [5, 6]]\n    >>> vectors_basis = [[1, 0], [1, 1]]\n\n    >>> transform_coordinates(points, [0, 0], vectors_basis)\n    array([[ 1,  3],\n           [ 3,  7],\n           [ 5, 11]])\n\n    >>> points = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> vectors_basis = [[1, 0, 0], [-1, 1, 0]]\n\n    >>> transform_coordinates(points, [0, 0, 0], vectors_basis)\n    array([[1, 1],\n           [4, 1],\n           [7, 1]])\n\n    """"""\n    vectors_to_points = np.subtract(points, point_origin)\n\n    return np.matmul(vectors_to_points, np.transpose(vectors_basis))\n'"
skspatial/typing.py,1,"b'""""""Custom types for annotations.""""""\n\nfrom typing import Sequence, Union\n\nimport numpy as np\n\n\narray_like = Union[np.ndarray, Sequence]\n'"
doc/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nimport sphinx_bootstrap_theme\nfrom sphinx_gallery.sorting import ExplicitOrder\n\nsys.path.insert(0, os.path.abspath(os.path.join(\'..\', \'..\')))\n\nimport skspatial\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'scikit-spatial\'\ncopyright = \'2019, Andrew Hynes\'\nauthor = \'Andrew Hynes\'\n\n# The short X.Y version\nversion = skspatial.__version__\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'matplotlib.sphinxext.plot_directive\',\n    \'numpydoc\',\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.autosummary\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.doctest\',\n    \'sphinx.ext.githubpages\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx_gallery.gen_gallery\',\n]\n\nintersphinx_mapping = {\n    \'numpy\': (\'http://docs.scipy.org/doc/numpy/\', None),\n    \'matplotlib\': (\'http://matplotlib.org/\', None),\n}\n\nsphinx_gallery_conf = {\n    \'examples_dirs\': \'../../examples\',   # Path to example scripts\n    \'gallery_dirs\': \'gallery\',  # Path to save generated examples\n    \'download_all_examples\': False,\n    \'subsection_order\': ExplicitOrder([\n        \'../../examples/projection\',\n       \'../../examples/intersection\',\n       \'../../examples/fitting\',\n       \'../../examples/triangle\',\n    ]),\n}\n\nautosummary_generate = True\n\n# Prevent warnings about nonexisting documents\nnumpydoc_show_class_members = False\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = None\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'bootstrap\'\nhtml_theme_path = sphinx_bootstrap_theme.get_html_theme_path()\n\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nhtml_theme_options = {\n    \'bootswatch_theme\': \'cosmo\',\n    \'globaltoc_depth\': -1,\n    \'navbar_links\': [\n        (\'Objects\', \'objects/toc\'),\n        (\'Computations\', \'computations/toc\'),\n        (\'Plotting\', \'plotting\'),\n        (\'Gallery\', \'gallery/index\'),\n        (\'API\', \'api_reference/toc\'),\n    ],\n    \'navbar_pagenav\': False,\n    \'navbar_sidebarrel\': False,\n    \'source_link_position\': None,\n}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = []\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'scikit-spatialdoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'scikit-spatial.tex\', \'scikit-spatial Documentation\',\n     \'Andrew Hynes\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'scikit-spatial\', \'scikit-spatial Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'scikit-spatial\', \'scikit-spatial Documentation\',\n     author, \'scikit-spatial\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\'search.html\']\n\n\n# -- Extension configuration -------------------------------------------------\n'"
examples/fitting/plot_line_2d.py,0,"b'""""""\n2D Line of Best Fit\n===================\n\nFit a line to multiple 2D points.\n\n""""""\nfrom skspatial.objects import Points, Line\nfrom skspatial.plotting import plot_2d\n\n\npoints = Points([\n    [0, 0],\n    [0, 1],\n    [1, 2],\n    [3, 3],\n    [4, 3],\n    [6, 5],\n    [5, 6],\n    [7, 8],\n])\n\nline_fit = Line.best_fit(points)\n\n\nplot_2d(\n    line_fit.plotter(t_1=-7, t_2=7, c=\'k\'),\n    points.plotter(c=\'k\'),\n)\n'"
examples/fitting/plot_line_3d.py,0,"b'""""""\n3D Line of Best Fit\n===================\n\nFit a line to multiple 3D points.\n\n""""""\nfrom skspatial.objects import Points, Line\nfrom skspatial.plotting import plot_3d\n\n\npoints = Points([\n    [0, 0, 0],\n    [1, 1, 0],\n    [2, 3, 2],\n    [3, 2, 3],\n    [4, 5, 4],\n    [6, 5, 5],\n    [6, 6, 5],\n    [7, 6, 7],\n])\n\nline_fit = Line.best_fit(points)\n\n\nplot_3d(\n    line_fit.plotter(t_1=-7, t_2=7, c=\'k\'),\n    points.plotter(c=\'b\', depthshade=False),\n)\n'"
examples/fitting/plot_plane.py,0,"b'""""""\n3D Plane of Best Fit\n====================\n\nFit a plane to multiple 3D points.\n\n""""""\nfrom skspatial.objects import Points, Plane\nfrom skspatial.plotting import plot_3d\n\n\npoints = Points([[0, 0, 0], [1, 3, 5], [-5, 6, 3], [3, 6, 7], [-2, 6, 7]])\n\nplane = Plane.best_fit(points)\n\n\nplot_3d(\n    points.plotter(c=\'k\', s=50, depthshade=False),\n    plane.plotter(alpha=0.2, lims_x=(-5, 5), lims_y=(-5, 5)),\n)\n'"
examples/intersection/plot_line_circle.py,0,"b'""""""\nCircle-Line Intersection\n========================\n\n""""""\nfrom skspatial.objects import Circle, Line\nfrom skspatial.plotting import plot_2d\n\n\ncircle = Circle([0, 0], 5)\nline = Line([0, 0], [1, 1])\n\npoint_a, point_b = circle.intersect_line(line)\n\n\n_, ax = plot_2d(\n    circle.plotter(fill=False),\n    line.plotter(t_1=-5, t_2=5, c=\'k\'),\n    point_a.plotter(c=\'r\', s=100, edgecolor=\'k\', zorder=3),\n    point_b.plotter(c=\'r\', s=100, edgecolor=\'k\', zorder=3),\n)\n\nax.axis(\'equal\')\n'"
examples/intersection/plot_line_line_2d.py,0,"b'""""""\n2D Line-Line Intersection\n=========================\n\n""""""\nfrom skspatial.objects import Line\nfrom skspatial.plotting import plot_2d\n\n\nline_a = Line(point=[0, 0], direction=[1, 1.5])\nline_b = Line(point=[5, 0], direction=[-1, 1])\n\npoint_intersection = line_a.intersect_line(line_b)\n\n\nplot_2d(\n    line_a.plotter(t_1=3),\n    line_b.plotter(t_1=4),\n    point_intersection.plotter(c=\'k\', s=75, zorder=3),\n)\n'"
examples/intersection/plot_line_line_3d.py,0,"b'""""""\n3D Line-Line Intersection\n=========================\n\n""""""\nfrom skspatial.objects import Line\nfrom skspatial.plotting import plot_3d\n\n\nline_a = Line(point=[0, 0, 0], direction=[1, 1, 1])\nline_b = Line(point=[1, 1, 0], direction=[-1, -1, 1])\n\npoint_intersection = line_a.intersect_line(line_b)\n\n\nplot_3d(\n    line_a.plotter(),\n    line_b.plotter(),\n    point_intersection.plotter(c=\'k\', s=75),\n)\n'"
examples/intersection/plot_line_plane.py,0,"b'""""""\nPlane-Line Intersection\n=======================\n\n""""""\nfrom skspatial.objects import Line, Plane\nfrom skspatial.plotting import plot_3d\n\n\nplane = Plane(point=[0, 0, 0], normal=[1, 1, 1])\nline = Line(point=[-1, -1, 0], direction=[0, 0, 1])\n\npoint_intersection = plane.intersect_line(line)\n\n\nplot_3d(\n    plane.plotter(lims_x=[-2, 2], lims_y=[-2, 2], alpha=0.2),\n    line.plotter(t_2=5),\n    point_intersection.plotter(c=\'k\', s=75),\n)\n'"
examples/intersection/plot_plane_plane.py,0,"b'""""""\nPlane-Plane Intersection\n========================\n\n""""""\nfrom skspatial.objects import Plane\nfrom skspatial.plotting import plot_3d\n\n\nplane_a = Plane([0, 0, 0], [1, 0, 0])\nplane_b = Plane([0, 0, 0], [1, 0, 1])\n\nline_intersection = plane_a.intersect_plane(plane_b)\n\n\nplot_3d(\n    plane_a.plotter(alpha=0.2),\n    plane_b.plotter(alpha=0.2),\n    line_intersection.plotter(t_1=-1, c=\'k\'),\n)\n'"
examples/intersection/plot_sphere_line.py,0,"b'""""""\nSphere-Line Intersection\n========================\n\n""""""\nfrom skspatial.objects import Sphere, Line\nfrom skspatial.plotting import plot_3d\n\n\nsphere = Sphere([0, 0, 0], 1)\nline = Line([0, 0, 0], [1, 1, 1])\n\npoint_a, point_b = sphere.intersect_line(line)\n\n\nplot_3d(\n    line.plotter(t_1=-1, c=\'k\'),\n    sphere.plotter(alpha=0.2),\n    point_a.plotter(c=\'r\', s=100),\n    point_b.plotter(c=\'r\', s=100),\n)\n'"
examples/projection/plot_point_line.py,0,"b'""""""\n2D Point-Line Projection\n========================\n\nProject a point onto a line.\n\n""""""\nfrom skspatial.objects import Point, Line\nfrom skspatial.plotting import plot_2d\n\n\nline = Line(point=[0, 0], direction=[1, 1])\npoint = Point([1, 4])\n\npoint_projected = line.project_point(point)\nline_projection = Line.from_points(point, point_projected)\n\n_, ax = plot_2d(\n    line.plotter(t_2=5, c=\'k\'),\n    line_projection.plotter(c=\'k\', linestyle=\'--\'),\n    point.plotter(s=75, c=\'k\'),\n    point_projected.plotter(c=\'r\', s=75, zorder=3),\n)\n\nax.axis(\'equal\')\n'"
examples/projection/plot_point_plane.py,0,"b'""""""\nPoint-Plane Projection\n======================\n\nProject a point onto a plane.\n\n""""""\nfrom skspatial.objects import Point, Vector, Plane\nfrom skspatial.plotting import plot_3d\n\n\nplane = Plane(point=[0, 0, 2], normal=[1, 0, 2])\npoint = Point([5, 9, 3])\n\npoint_projected = plane.project_point(point)\nvector_projection = Vector.from_points(point, point_projected)\n\n\nplot_3d(\n    plane.plotter(lims_x=(0, 10), lims_y=(0, 15), alpha=0.3),\n    point.plotter(s=75, c=\'k\'),\n    point_projected.plotter(c=\'r\', s=75, zorder=3),\n    vector_projection.plotter(point=point, c=\'k\', linestyle=\'--\'),\n)\n'"
examples/projection/plot_vector_line.py,0,"b'""""""\n3D Vector-Line Projection\n=========================\n\nProject a vector onto a line.\n\n""""""\nfrom skspatial.objects import Vector, Line\nfrom skspatial.plotting import plot_3d\n\n\nline = Line([0, 0, 0], [1, 1, 2])\nvector = Vector([1, 1, 0.1])\n\nvector_projected = line.project_vector(vector)\n\n\nplot_3d(\n    line.plotter(t_1=-1, c=\'k\', linestyle=\'--\'),\n    vector.plotter(point=line.point, color=\'k\'),\n    vector_projected.plotter(point=line.point, color=\'r\', linewidth=2, zorder=3),\n)\n'"
examples/projection/plot_vector_plane.py,0,"b'""""""\nVector-Plane Projection\n=======================\n\nProject a vector onto a plane.\n\n""""""\nfrom skspatial.objects import Vector, Plane\nfrom skspatial.plotting import plot_3d\n\n\nplane = Plane([0, 0, 0], [0, 0, 1])\nvector = Vector([1, 1, 1])\n\nvector_projected = plane.project_vector(vector)\n\n\n_, ax = plot_3d(\n    plane.plotter(lims_x=(-5, 5), lims_y=(-5, 5), alpha=0.3),\n    vector.plotter(point=plane.point, color=\'k\'),\n    vector_projected.plotter(point=plane.point, color=\'r\', linewidth=2, zorder=3),\n)\n\nax.set_zlim([-1, 1])\n'"
examples/projection/plot_vector_vector.py,0,"b'""""""\n2D Vector-Vector Projection\n===========================\n\nProject a vector onto another vector.\n\n""""""\nfrom skspatial.objects import Vector\nfrom skspatial.plotting import plot_2d\n\n\nvector_a = Vector([1, 1])\nvector_b = Vector([2, 0])\n\nvector_projected = vector_b.project_vector(vector_a)\n\n\n_, ax = plot_2d(\n    vector_a.plotter(color=\'k\', head_width=0.1),\n    vector_b.plotter(color=\'k\', head_width=0.1),\n    vector_projected.plotter(color=\'r\', head_width=0.1),\n)\n\nax.axis([-0.5, 2.5, -0.5, 1.5])\n'"
examples/triangle/plot_normal.py,0,"b'""""""\nTriangle with Normal Vector\n===========================\n\nPlotting a triangle with its normal vector. The tail of the vector is set to be the triangle centroid.\n\n""""""\nfrom skspatial.objects import Triangle\nfrom skspatial.plotting import plot_3d\n\n\ntriangle = Triangle([0, 0, 1], [1, 1, 0], [0, 2, 1])\n\ncentroid = triangle.centroid()\n\nplot_3d(\n    triangle.plotter(c=\'k\', zorder=3),\n    centroid.plotter(c=\'r\'),\n    triangle.normal().plotter(point=centroid, scalar=0.2, c=\'r\'),\n    *[x.plotter(c=\'k\', zorder=3) for x in triangle.multiple(\'line\', \'abc\')],\n)\n'"
examples/triangle/plot_orthocenter.py,0,"b'""""""\nTriangle with Altitudes and Orthocenter\n=======================================\n\nPlotting a triangle with its three altitudes and their intersection point, the orthocenter.\n\n""""""\nfrom skspatial.objects import Triangle\nfrom skspatial.plotting import plot_2d\n\n\ntriangle = Triangle([0, 0], [2, 0], [1, 2])\n\nplot_2d(\n    triangle.plotter(c=\'k\', zorder=3),\n    triangle.orthocenter().plotter(c=\'r\', edgecolor=\'k\', s=100, zorder=3),\n    *[x.plotter(c=\'k\', zorder=3) for x in triangle.multiple(\'line\', \'abc\')],\n    *[x.plotter() for x in triangle.multiple(\'altitude\', \'ABC\')],\n)\n'"
skspatial/objects/__init__.py,0,"b'""""""Package containing spatial objects.""""""\n\nfrom skspatial.objects.circle import Circle\nfrom skspatial.objects.line import Line\nfrom skspatial.objects.plane import Plane\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.points import Points\nfrom skspatial.objects.sphere import Sphere\nfrom skspatial.objects.triangle import Triangle\nfrom skspatial.objects.vector import Vector\n\n__all__ = [\'Circle\', \'Line\', \'Plane\', \'Point\', \'Points\', \'Sphere\', \'Triangle\', \'Vector\']\n'"
skspatial/objects/_base_array.py,12,"b'""""""Private base classes for arrays.""""""\n\nfrom typing import Callable, TypeVar, Type\n\nimport numpy as np\n\nfrom skspatial._functions import _allclose\nfrom skspatial.plotting import _plotter\nfrom skspatial.typing import array_like\n\n\n# Create generic variables that can be \'Parent\' or any subclass.\nArray = TypeVar(\'Array\', bound=\'_BaseArray\')\n\nArray1D = TypeVar(\'Array1D\', bound=\'_BaseArray1D\')\n\nArray2D = TypeVar(\'Array2D\', bound=\'_BaseArray2D\')\n\n\nclass _BaseArray(np.ndarray):\n    """"""Private base class for spatial objects based on a single NumPy array.""""""\n\n    def __new__(cls: Type[Array], array: array_like) -> Array:\n\n        if np.size(array) == 0:\n            raise ValueError(""The array must not be empty."")\n\n        if not np.isfinite(array).all():\n            raise ValueError(""The values must all be finite."")\n\n        # We cast the input array to be our class type.\n        obj = np.asarray(array).view(cls)\n\n        return obj\n\n    def __array_finalize__(self, obj: array_like) -> None:\n        """"""\n        Finalize creation of the array.\n\n        This function is required for adding extra attributes to a subclass of ndarray.\n        Without it, an array constructed from another may not have the extra attributes\n        (e.g., a projection of a vector onto another vector).\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector, Points\n\n        >>> vector_a = Vector([1, 0])\n        >>> vector_b = vector_a.project_vector([1, 1])\n\n        Without __array_finalize__, this vector will not have the dimension attribute.\n\n        >>> vector_a.dimension == vector_b.dimension\n        True\n\n        The same applies for 2D arrays.\n\n        >>> points = Points([[1, 2, 3], [4, 5, 6]])\n        >>> points_centered = points.mean_center()\n\n        >>> points.dimension == points_centered.dimension\n        True\n\n        """"""\n        self.dimension = getattr(obj, \'dimension\', None)\n\n    def to_array(self) -> np.ndarray:\n        """"""\n        Convert the object to a regular NumPy ndarray.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Point\n\n        >>> point = Point([1, 2, 3])\n\n        >>> point.to_array()\n        array([1, 2, 3])\n\n        """"""\n        return np.array(self)\n\n    def round(self: Array, decimals: int = 0, out: np.ndarray = None) -> Array:  # noqa A003\n        """"""\n        Round the array to the given number of decimals.\n\n        Refer to :func:`np.around` for the full documentation.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 1, 1]).unit().round(3)\n        Vector([0.577, 0.577, 0.577])\n\n        """"""\n        array_rounded = np.array(self).round(decimals, out)\n\n        return self.__class__(array_rounded)\n\n    def is_close(self, other: array_like, **kwargs: float) -> bool:\n        """"""\n        Check if the array is close to another.\n\n        Parameters\n        ----------\n        other : array_like\n            Other array.\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if the arrays are close; false otherwise.\n\n        """"""\n        return bool(_allclose(self, other, **kwargs).all())\n\n    def is_equal(self, other: array_like) -> bool:\n        """"""\n        Check if the array is equal to another.\n\n        Parameters\n        ----------\n        other : array_like\n            Other array.\n\n        Returns\n        -------\n        bool\n            True if the arrays are equal; false otherwise.\n\n        """"""\n        return np.array_equal(self, other)\n\n    def plotter(self, **kwargs) -> Callable:\n\n        return _plotter(self, **kwargs)\n\n\nclass _BaseArray1D(_BaseArray):\n    """"""Private base class for spatial objects based on a single 1D NumPy array.""""""\n\n    def __new__(cls: Type[Array1D], array: array_like) -> Array1D:\n\n        obj = super().__new__(cls, array)\n\n        if obj.ndim != 1:\n            raise ValueError(""The array must be 1D."")\n\n        obj.dimension = obj.size\n\n        return obj\n\n    def set_dimension(self: Array1D, dim: int) -> Array1D:\n        """"""\n        Set the dimension (length) of the 1D array.\n\n        Parameters\n        ----------\n        dim : int\n            Desired dimension.\n            Must be greater than or equal to the current dimension.\n\n        Returns\n        -------\n        ndarray\n            (dim,) array.\n\n        Raises\n        ------\n        ValueError\n            If the desired dimension is less than the current dimension.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Point\n\n        >>> Point([1]).set_dimension(2)\n        Point([1, 0])\n\n        >>> Point([1, 2]).set_dimension(4)\n        Point([1, 2, 0, 0])\n\n        >>> Point([1, 2, 3]).set_dimension(2)\n        Traceback (most recent call last):\n        ...\n        ValueError: The desired dimension cannot be less than the current dimension.\n\n        """"""\n        if dim < self.dimension:\n            raise ValueError(""The desired dimension cannot be less than the current dimension."")\n\n        n_zeros = dim - self.size\n        array_padded = np.pad(self, (0, n_zeros), \'constant\')\n\n        return self.__class__(array_padded)\n\n\nclass _BaseArray2D(_BaseArray):\n    """"""Private base class for spatial objects based on a single 2D NumPy array.""""""\n\n    def __new__(cls: Type[Array2D], array: array_like) -> Array2D:\n\n        obj = super().__new__(cls, array)\n\n        if obj.ndim != 2:\n            raise ValueError(""The array must be 2D."")\n\n        obj.dimension = obj.shape[1]\n\n        return obj\n\n    def set_dimension(self: Array2D, dim: int) -> Array2D:\n        """"""\n        Set the dimension (width) of the 2D array.\n\n        E.g., each row of the array represents a point in space.\n        The width of the array is the dimension of the points.\n\n        Parameters\n        ----------\n        dim : int\n            Desired dimension.\n            Must be greater than or equal to the current dimension.\n\n        Returns\n        -------\n        ndarray\n            (N, dim) array.\n\n        Raises\n        ------\n        ValueError\n            If the desired dimension is less than the current dimension.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> points = Points([[1, 0], [2, 3]])\n\n        >>> points.set_dimension(3)\n        Points([[1, 0, 0],\n                [2, 3, 0]])\n\n        >>> points.set_dimension(5)\n        Points([[1, 0, 0, 0, 0],\n                [2, 3, 0, 0, 0]])\n\n        >>> Points([[1, 2, 3], [4, 5, 6]]).set_dimension(2)\n        Traceback (most recent call last):\n        ...\n        ValueError: The desired dimension cannot be less than the current dimension.\n\n        """"""\n        if dim < self.dimension:\n            raise ValueError(""The desired dimension cannot be less than the current dimension."")\n\n        array_padded = np.pad(self, ((0, 0), (0, dim - self.dimension)), \'constant\')\n\n        return self.__class__(array_padded)\n'"
skspatial/objects/_base_line_plane.py,3,"b'""""""Module for private parent class of Line and Plane.""""""\n\nimport inspect\nfrom typing import Callable, Union\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import _contains_point, _sum_squares\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.vector import Vector\nfrom skspatial.plotting import _plotter\nfrom skspatial.typing import array_like\n\n\nclass _BaseLinePlane:\n    """"""Private parent class for Line and Plane.""""""\n\n    def __init__(self, point: array_like, vector: array_like):\n\n        self.point = Point(point)\n        self.vector = Vector(vector)\n\n        if self.point.dimension != self.vector.dimension:\n            raise ValueError(""The point and vector must have the same dimension."")\n\n        if self.vector.is_zero(rel_tol=0, abs_tol=0):\n            raise ValueError(""The vector must not be the zero vector."")\n\n        self.dimension = self.point.dimension\n\n    def __repr__(self) -> str:\n\n        name_class = type(self).__name__\n        name_vector = inspect.getfullargspec(type(self)).args[-1]\n\n        repr_point = np.array_repr(self.point)\n        repr_vector = np.array_repr(self.vector)\n\n        return f""{name_class}(point={repr_point}, {name_vector}={repr_vector})""\n\n    def contains_point(self, point: array_like, **kwargs: float) -> bool:\n        """"""Check if the line/plane contains a point.""""""\n        return _contains_point(self, point, **kwargs)\n\n    def is_close(self, other: array_like, **kwargs: float) -> bool:\n        """"""\n        Check if the line/plane is almost equivalent to another line/plane.\n\n        The points must be close and the vectors must be parallel.\n\n        Parameters\n        ----------\n        other : object\n             Line or Plane.\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if the objects are almost equivalent; false otherwise.\n\n        Raises\n        ------\n        TypeError\n            If the input doesn\'t have the same type as the object.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line, Plane\n\n        >>> line_a = Line(point=[0, 0], direction=[1, 0])\n        >>> line_b = Line(point=[0, 0], direction=[-2, 0])\n        >>> line_a.is_close(line_b)\n        True\n\n        >>> line_b = Line(point=[50, 0], direction=[-4, 0])\n        >>> line_a.is_close(line_b)\n        True\n\n        >>> line_b = Line(point=[50, 29], direction=[-4, 0])\n        >>> line_a.is_close(line_b)\n        False\n\n        >>> plane_a = Plane(point=[0, 0, 0], normal=[0, 0, 5])\n        >>> plane_b = Plane(point=[23, 45, 0], normal=[0, 0, -20])\n        >>> plane_a.is_close(plane_b)\n        True\n\n        >>> line_a.is_close(plane_a)\n        Traceback (most recent call last):\n        ...\n        TypeError: The input must have the same type as the object.\n\n        """"""\n        if not isinstance(other, type(self)):\n            raise TypeError(""The input must have the same type as the object."")\n\n        contains_point = self.contains_point(other.point, **kwargs)\n        is_parallel = self.vector.is_parallel(other.vector, **kwargs)\n\n        return contains_point and is_parallel\n\n    def sum_squares(self, points: array_like) -> np.float64:\n\n        return _sum_squares(self, points)\n\n    def plotter(self, **kwargs) -> Union[Callable[[Axes], None], Callable[[Axes3D], None]]:\n\n        return _plotter(self, **kwargs)\n'"
skspatial/objects/_base_sphere.py,2,"b'""""""Module for base class of Circle and Sphere.""""""\n\nfrom typing import Callable, Union\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import _contains_point\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.vector import Vector\nfrom skspatial.plotting import _plotter\nfrom skspatial.typing import array_like\n\n\nclass _BaseSphere:\n    """"""Private parent class for Circle and Sphere.""""""\n\n    def __init__(self, point: array_like, radius: float):\n\n        if radius <= 0:\n            raise ValueError(""The radius must be positive."")\n\n        self.point = Point(point)\n        self.radius = radius\n\n        self.dimension = self.point.dimension\n\n    def __repr__(self) -> str:\n\n        name_class = type(self).__name__\n\n        repr_point = np.array_repr(self.point)\n\n        return f""{name_class}(point={repr_point}, radius={self.radius})""\n\n    def distance_point(self, point: array_like) -> np.float64:\n        """"""Return the distance from a point to the circle/sphere.""""""\n        distance_to_center = self.point.distance_point(point)\n\n        return abs(distance_to_center - self.radius)\n\n    def contains_point(self, point: array_like, **kwargs: float) -> bool:\n        """"""Check if the line/plane contains a point.""""""\n        return _contains_point(self, point, **kwargs)\n\n    def project_point(self, point: array_like) -> Point:\n        """"""\n        Project a point onto the circle or sphere.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        Point\n            Point projected onto the circle or sphere.\n\n        Raises\n        ------\n        ValueError\n            If the input point is the center of the circle or sphere.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Circle\n\n        >>> circle = Circle([0, 0], 1)\n\n        >>> circle.project_point([1, 1]).round(3)\n        Point([0.707, 0.707])\n\n        >>> circle.project_point([-6, 3]).round(3)\n        Point([-0.894,  0.447])\n\n        >>> circle.project_point([0, 0])\n        Traceback (most recent call last):\n        ...\n        ValueError: The point must not be the center of the circle or sphere.\n\n        >>> from skspatial.objects import Sphere\n\n        >>> Sphere([0, 0, 0], 2).project_point([1, 2, 3]).round(3)\n        Point([0.535, 1.069, 1.604])\n\n        """"""\n        if self.point.is_equal(point):\n            raise ValueError(""The point must not be the center of the circle or sphere."")\n\n        vector_to_point = Vector.from_points(self.point, point)\n\n        return self.point + self.radius * vector_to_point.unit()\n\n    def plotter(self, **kwargs) -> Union[Callable[[Axes], None], Callable[[Axes3D], None]]:\n\n        return _plotter(self, **kwargs)\n'"
skspatial/objects/circle.py,8,"b'""""""Module for the Circle class.""""""\n\nimport math\nfrom typing import Tuple\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.axes import Axes\n\nfrom skspatial._functions import np_float\nfrom skspatial.objects._base_sphere import _BaseSphere\nfrom skspatial.objects.line import Line\nfrom skspatial.objects.point import Point\nfrom skspatial.typing import array_like\n\n\nclass Circle(_BaseSphere):\n    """"""\n    A circle in 2D space.\n\n    The circle is defined by a 2D point and a radius.\n\n    Parameters\n    ----------\n    point : (2,) array_like\n        Center of the circle.\n    radius : {int, float}\n        Radius of the circle/\n\n    Attributes\n    ----------\n    point : (2,) Point\n        Center of the circle.\n    radius : {int, float}\n        Radius of the circle.\n    dimension : int\n        Dimension of the circle.\n\n    Raises\n    ------\n    ValueError\n        If the radius is not positive, or if the point is not 2D.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Circle\n\n    >>> circle = Circle([2, 5], 3)\n\n    >>> circle\n    Circle(point=Point([2, 5]), radius=3)\n\n    >>> circle.dimension\n    2\n\n    >>> circle.area().round(2)\n    28.27\n\n    >>> Circle([0, 0, 0], 1)\n    Traceback (most recent call last):\n    ...\n    ValueError: The point must be 2D.\n\n    >>> Circle([0, 0], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: The radius must be positive.\n\n    """"""\n\n    def __init__(self, point: array_like, radius: float):\n\n        super().__init__(point, radius)\n\n        if self.point.dimension != 2:\n            raise ValueError(""The point must be 2D."")\n\n    @np_float\n    def circumference(self) -> np.float64:\n        r""""""\n        Return the circumference of the circle.\n\n        The circumference :math:`C` of a circle with radius :math:`r` is\n\n        .. math:: C = 2 \\pi r\n\n        Returns\n        -------\n        np.float64\n            Circumference of the circle.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Circle\n\n        >>> Circle([0, 0], 1).area().round(2)\n        3.14\n\n        >>> Circle([0, 0], 2).area().round(2)\n        12.57\n\n        """"""\n        return 2 * np.pi * self.radius\n\n    @np_float\n    def area(self) -> np.float64:\n        r""""""\n        Return the area of the circle.\n\n        The area :math:`A` of a circle with radius :math:`r` is\n\n        .. math:: A = \\pi r ^ 2\n\n        Returns\n        -------\n        np.float64\n            Area of the circle.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Circle\n\n        >>> Circle([0, 0], 1).area().round(2)\n        3.14\n\n        >>> Circle([0, 0], 2).area().round(2)\n        12.57\n\n        """"""\n        return np.pi * self.radius ** 2\n\n    def intersect_line(self, line: Line) -> Tuple[Point, Point]:\n        """"""\n        Intersect the circle with a line.\n\n        A line intersects a circle at two points.\n\n        Parameters\n        ----------\n        line : Line\n            Input line.\n\n        Returns\n        -------\n        point_a, point_b : Point\n            The two points of intersection.\n\n        Raises\n        ------\n        ValueError\n            If the line does not intersect the circle.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Circle-LineIntersection.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Circle, Line\n\n        >>> circle = Circle([0, 0], 1)\n\n        >>> circle.intersect_line(Line(point=[0, 0], direction=[1, 0]))\n        (Point([-1.,  0.]), Point([1., 0.]))\n\n        >>> point_a, point_b = circle.intersect_line(Line(point=[0, 0], direction=[1, 1]))\n\n        >>> point_a.round(3)\n        Point([-0.707, -0.707])\n\n        >>> point_b.round(3)\n        Point([0.707, 0.707])\n\n        >>> circle.intersect_line(Line(point=[1, 2], direction=[1, 1]))\n        (Point([-1.,  0.]), Point([0., 1.]))\n\n        If the line is tangent to the circle, the two intersection points are the same.\n\n        >>> circle.intersect_line(Line(point=[1, 0], direction=[0, 1]))\n        (Point([1., 0.]), Point([1., 0.]))\n\n        The circle does not have to be centered on the origin.\n\n        >>> point_a, point_b = Circle([2, 3], 5).intersect_line(Line([1, 1], [2, 3]))\n\n        >>> point_a.round(3)\n        Point([-0.538, -1.308])\n\n        >>> point_b.round(3)\n        Point([5., 7.])\n\n        >>> circle.intersect_line(Line(point=[5, 0], direction=[1, 1]))\n        Traceback (most recent call last):\n        ...\n        ValueError: The line does not intersect the circle.\n\n        """"""\n        # Two points on the line.\n        # Copy the line point to avoid changing the line itself.\n        point_1 = np.copy(line.point)\n        point_2 = point_1 + line.direction.unit()\n\n        # Translate the points on the line to mimic the circle being centered on the origin.\n        point_1 -= self.point\n        point_2 -= self.point\n\n        x_1, y_1 = point_1\n        x_2, y_2 = point_2\n\n        d_x = x_2 - x_1\n        d_y = y_2 - y_1\n\n        # Pre-compute variables common to x and y equations.\n        d_r_squared = d_x ** 2 + d_y ** 2\n        determinant = x_1 * y_2 - x_2 * y_1\n        discriminant = self.radius ** 2 * d_r_squared - determinant ** 2\n\n        if discriminant < 0:\n            raise ValueError(""The line does not intersect the circle."")\n\n        root = math.sqrt(discriminant)\n\n        pm = np.array([-1, 1])  # Array to compute plus/minus.\n        sign = -1 if d_y < 0 else 1\n\n        coords_x = (determinant * d_y + pm * sign * d_x * root) / d_r_squared\n        coords_y = (-determinant * d_x + pm * abs(d_y) * root) / d_r_squared\n\n        point_a = Point([coords_x[0], coords_y[0]])\n        point_b = Point([coords_x[1], coords_y[1]])\n\n        # Translate the intersection points back from origin circle to real circle.\n        point_a += self.point\n        point_b += self.point\n\n        return point_a, point_b\n\n    def plot_2d(self, ax_2d: Axes, **kwargs) -> None:\n        """"""\n        Plot the circle in 2D.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        kwargs : dict, optional\n            Additional keywords passed to :Class:`matplotlib.patches.Circle`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n\n            >>> from skspatial.objects import Circle\n\n            >>> circle = Circle([-2, 3], 3)\n\n            >>> fig, ax = plt.subplots()\n            >>> circle.plot_2d(ax, fill=False)\n            >>> circle.point.plot_2d(ax)\n            >>> limits = plt.axis([-10, 10, -10, 10])\n\n        """"""\n        circle = plt.Circle(self.point, self.radius, **kwargs)\n\n        ax_2d.add_artist(circle)\n'"
skspatial/objects/line.py,8,"b'""""""Module for the Line class.""""""\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial.objects._base_line_plane import _BaseLinePlane\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.points import Points\nfrom skspatial.objects.vector import Vector\nfrom skspatial.plotting import _connect_points_2d, _connect_points_3d\nfrom skspatial.transformation import transform_coordinates\nfrom skspatial.typing import array_like\n\n\nclass Line(_BaseLinePlane):\n    """"""\n    A line in space.\n\n    The line is defined by a point and a direction vector.\n\n    Parameters\n    ----------\n    point : array_like\n        Point on the line.\n    direction : array_like\n        Direction vector of the line.\n\n    Attributes\n    ----------\n    point : Point\n        Point on the line.\n    direction : Vector\n        Unit direction vector.\n    vector : Vector\n        Same as the direction.\n    dimension : int\n        Dimension of the line.\n\n    Raises\n    ------\n    ValueError\n        If the point and vector have different dimensions,\n        or if the vector is all zeros.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Line\n\n    >>> line = Line(point=[0, 0], direction=[3, 0])\n\n    >>> line\n    Line(point=Point([0, 0]), direction=Vector([3, 0]))\n\n    >>> line.direction\n    Vector([3, 0])\n\n    The direction can also be accessed with the ``vector`` attribute.\n\n    >>> line.vector\n    Vector([3, 0])\n\n    The line dimension is the dimension of the point and vector.\n\n    >>> line.dimension\n    2\n\n    >>> Line([0, 0], [1, 0, 0])\n    Traceback (most recent call last):\n    ...\n    ValueError: The point and vector must have the same dimension.\n\n    >>> Line([1, 1], [0, 0])\n    Traceback (most recent call last):\n    ...\n    ValueError: The vector must not be the zero vector.\n\n    """"""\n\n    def __init__(self, point: array_like, direction: array_like):\n\n        super().__init__(point, direction)\n\n        self.direction = self.vector\n\n    @classmethod\n    def from_points(cls, point_a: array_like, point_b: array_like) -> Line:\n        """"""\n        Instantiate a line from two points.\n\n        Parameters\n        ----------\n        point_a, point_b : array_like\n            Two points defining the line.\n\n        Returns\n        -------\n        Line\n            Line containing the two input points.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> Line.from_points([0, 0], [1, 0])\n        Line(point=Point([0, 0]), direction=Vector([1, 0]))\n\n        The order of the points affects the line point and direction vector.\n\n        >>> Line.from_points([1, 0], [0, 0])\n        Line(point=Point([1, 0]), direction=Vector([-1,  0]))\n\n        """"""\n        vector_ab = Vector.from_points(point_a, point_b)\n\n        return cls(point_a, vector_ab)\n\n    @classmethod\n    def from_slope(cls, slope: float, y_intercept: float) -> Line:\n        r""""""\n        Instantiate a 2D line from a slope and Y-intercept.\n\n        A 2D line can be represented by the equation\n\n        .. math:: y = mx + b\n\n        where :math:`m` is the slope and :math:`p` is the Y-intercept.\n\n        Parameters\n        ----------\n        slope : {int, float}\n            Slope of the 2D line.\n        y_intercept : {int, float}\n            Y coordinate of the point where the line intersects the Y axis.\n\n        Returns\n        -------\n        Line\n            A 2D Line object.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> Line.from_slope(2, 0)\n        Line(point=Point([0, 0]), direction=Vector([1, 2]))\n\n        >>> Line.from_slope(-3, 5)\n        Line(point=Point([0, 5]), direction=Vector([ 1, -3]))\n\n        >>> line_a = Line.from_slope(1, 0)\n        >>> line_b = Line.from_slope(0, 5)\n\n        >>> line_a.intersect_line(line_b)\n        Point([5., 5.])\n\n        """"""\n        point = [0, y_intercept]\n        direction = [1, slope]\n\n        return cls(point, direction)\n\n    def is_coplanar(self, other: Line, **kwargs: float) -> bool:\n        """"""\n        Check if the line is coplanar with another.\n\n        Parameters\n        ----------\n        other : Line\n            Other line.\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.matrix_rank`\n\n        Returns\n        -------\n        bool\n            True if the line is coplanar; false otherwise.\n\n        Raises\n        ------\n        TypeError\n            If the input is not a line.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Coplanar.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> line_a = Line(point=[0, 0, 0], direction=[1, 0, 0])\n        >>> line_b = Line([-5, 3, 0], [7, 1, 0])\n        >>> line_c = Line([0, 0, 0], [0, 0, 1])\n\n        >>> line_a.is_coplanar(line_b)\n        True\n\n        >>> line_a.is_coplanar(line_c)\n        True\n\n        >>> line_b.is_coplanar(line_c)\n        False\n\n        The input must be another line.\n\n        >>> from skspatial.objects import Plane\n\n        >>> line_a.is_coplanar(Plane(line_a.point, line_a.vector))\n        Traceback (most recent call last):\n        ...\n        TypeError: The input must also be a line.\n\n        """"""\n        if not isinstance(other, type(self)):\n            raise TypeError(""The input must also be a line."")\n\n        point_1 = self.point\n        point_2 = self.to_point()\n        point_3 = other.point\n        point_4 = other.to_point()\n\n        points = Points([point_1, point_2, point_3, point_4])\n\n        return points.are_coplanar(**kwargs)\n\n    def to_point(self, t: float = 1) -> Point:\n        r""""""\n        Return a point along the line using a parameter `t`.\n\n        Parameters\n        ----------\n        t : {int, float}\n            Parameter that defines the new point along the line.\n\n        Returns\n        -------\n        Point\n            New point along the line.\n\n        Notes\n        -----\n        The new point :math:`p` is computed as:\n\n        .. math:: p = \\mathtt{line.point} + t \\cdot \\mathtt{line.direction}\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> line = Line(point=[0, 0], direction=[2, 0])\n\n        >>> line.to_point()\n        Point([2, 0])\n\n        >>> line.to_point(t=2)\n        Point([4, 0])\n\n        """"""\n        vector_along_line = t * self.direction\n\n        return self.point + vector_along_line\n\n    def project_point(self, point: array_like) -> Point:\n        """"""\n        Project a point onto the line.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        Point\n            Projection of the point onto the line.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> Line(point=[0, 0], direction=[8, 0]).project_point([5, 5])\n        Point([5., 0.])\n\n        >>> Line(point=[0, 0, 0], direction=[1, 1, 0]).project_point([5, 5, 3])\n        Point([5., 5., 0.])\n\n        """"""\n        # Vector from the point on the line to the point in space.\n        vector_to_point = Vector.from_points(self.point, point)\n\n        # Project the vector onto the line.\n        vector_projected = self.direction.project_vector(vector_to_point)\n\n        # Add the projected vector to the point on the line.\n        return self.point + vector_projected\n\n    def project_vector(self, vector: array_like) -> Vector:\n        """"""\n        Project a vector onto the line.\n\n        Parameters\n        ----------\n        vector : array_like\n            Input vector.\n\n        Returns\n        -------\n        Vector\n            Projection of the vector onto the line.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> line = Line([-1, 5, 3], [3, 4, 5])\n\n        >>> line.project_vector([1, 1, 1])\n        Vector([0.72, 0.96, 1.2 ])\n\n        """"""\n        return self.direction.project_vector(vector)\n\n    def side_point(self, point: array_like) -> np.int64:\n        """"""\n        Find the side of the line where a point lies.\n\n        The line and point must be 2D.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        np.int64\n            -1 if the point is left of the line.\n            0 if the point is on the line.\n            1 if the point is right of the line.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> line = Line([0, 0], [1, 1])\n\n        The point is on the line.\n\n        >>> line.side_point([2, 2])\n        0\n\n        The point is to the right of the line.\n\n        >>> line.side_point([5, 3])\n        1\n\n        The point is to the left of the line.\n\n        >>> line.side_point([5, 10])\n        -1\n\n        """"""\n        vector_to_point = Vector.from_points(self.point, point)\n\n        return self.direction.side_vector(vector_to_point)\n\n    def distance_point(self, point: array_like) -> np.float64:\n        """"""Return the distance from a point to the line.""""""\n        point_projected = self.project_point(point)\n\n        return point_projected.distance_point(point)\n\n    def distance_line(self, other: Line) -> np.float64:\n        """"""\n        Return the shortest distance from the line to another.\n\n        Parameters\n        ----------\n        other : Line\n            Other line.\n\n        Returns\n        -------\n        np.float64\n            Distance between the lines.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Line-LineDistance.html\n\n        Examples\n        --------\n        There are three cases:\n\n        1. The lines intersect (i.e., they are coplanar and not parallel).\n\n        >>> from skspatial.objects import Line\n        >>> line_a = Line([1, 2], [4, 3])\n        >>> line_b = Line([-4, 1], [7, 23])\n\n        >>> line_a.distance_line(line_b)\n        0.0\n\n        2. The lines are parallel.\n\n        >>> line_a = Line([0, 0], [1, 0])\n        >>> line_b = Line([0, 5], [-1, 0])\n\n        >>> line_a.distance_line(line_b)\n        5.0\n\n        3. The lines are skew.\n\n        >>> line_a = Line([0, 0, 0], [1, 0, 1])\n        >>> line_b = Line([1, 0, 0], [1, 1, 1])\n\n        >>> line_a.distance_line(line_b).round(3)\n        0.707\n\n        """"""\n        if self.direction.is_parallel(other.direction):\n            # The lines are parallel.\n            # The distance between the lines is the distance from line point B to line A.\n            distance = self.distance_point(other.point)\n\n        elif self.is_coplanar(other):\n            # The lines must intersect, since they are coplanar and not parallel.\n            distance = np.float64(0)\n\n        else:\n            # The lines are skew.\n            vector_ab = Vector.from_points(self.point, other.point)\n            vector_perpendicular = self.direction.cross(other.direction)\n\n            distance = abs(vector_ab.dot(vector_perpendicular)) / vector_perpendicular.norm()\n\n        return distance\n\n    def intersect_line(self, other: Line) -> Point:\n        """"""\n        Intersect the line with another.\n\n        The lines must be coplanar and not parallel.\n\n        Parameters\n        ----------\n        other : Line\n            Other line.\n\n        Returns\n        -------\n        Point\n            The point at the intersection.\n\n        Raises\n        ------\n        ValueError\n            If the lines are parallel or are not coplanar.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Line-LineIntersection.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> line_a = Line([0, 0], [1, 0])\n        >>> line_b = Line([5, 5], [0, 1])\n\n        >>> line_a.intersect_line(line_b)\n        Point([5., 0.])\n\n        >>> line_b = Line([0, 1], [2, 0])\n        >>> line_a.intersect_line(line_b)\n        Traceback (most recent call last):\n        ...\n        ValueError: The lines must not be parallel.\n\n        >>> line_a = Line([1, 2, 3], [-4, 1, 1])\n        >>> line_b = Line([4, 5, 6], [3, 1, 5])\n\n        >>> line_a.intersect_line(line_b)\n        Traceback (most recent call last):\n        ...\n        ValueError: The lines must be coplanar.\n\n        >>> line_a = Line([0, 0, 0], [1, 1, 1])\n        >>> line_b = Line([5, 5, 0], [0, 0, -8])\n\n        >>> line_a.intersect_line(line_b)\n        Point([5., 5., 5.])\n\n        """"""\n        if self.direction.is_parallel(other.direction, rel_tol=0, abs_tol=0):\n            raise ValueError(""The lines must not be parallel."")\n\n        if not self.is_coplanar(other):\n            raise ValueError(""The lines must be coplanar."")\n\n        # Vector from line A to line B.\n        vector_ab = Vector.from_points(self.point, other.point)\n\n        # Vector perpendicular to both lines.\n        vector_perpendicular = self.direction.cross(other.direction)\n\n        num = vector_ab.cross(other.direction).dot(vector_perpendicular)\n        denom = vector_perpendicular.norm() ** 2\n\n        # Vector along line A to the intersection point.\n        vector_a_scaled = num / denom * self.direction\n\n        return self.point + vector_a_scaled\n\n    @classmethod\n    def best_fit(cls, points: array_like) -> Line:\n        """"""\n        Return the line of best fit for a set of points.\n\n        Parameters\n        ----------\n        points : array_like\n             Input points.\n\n        Returns\n        -------\n        Line\n            The line of best fit.\n\n        Raises\n        ------\n        ValueError\n            If the points are concurrent.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> points = [[0, 0], [1, 2], [2, 1], [2, 3], [3, 2]]\n        >>> line = Line.best_fit(points)\n\n        The point on the line is the centroid of the points.\n\n        >>> line.point\n        Point([1.6, 1.6])\n\n        The line direction is a unit vector.\n\n        >>> line.direction.round(3)\n        Vector([0.707, 0.707])\n\n        """"""\n        points_spatial = Points(points)\n\n        if points_spatial.are_concurrent(tol=0):\n            raise ValueError(""The points must not be concurrent."")\n\n        points_centered, centroid = points_spatial.mean_center(return_centroid=True)\n\n        _, _, vh = np.linalg.svd(points_centered)\n        direction = vh[0, :]\n\n        return cls(centroid, direction)\n\n    def transform_points(self, points: array_like) -> np.ndarray:\n        """"""\n        Transform points to a one-dimensional coordinate system defined by the line.\n\n        The point on the line acts as the origin of the coordinate system.\n\n        This is analogous is projecting the points onto the line,\n        then computing the signed distance from the line point to the projections.\n\n        Parameters\n        ----------\n        points : (N, D) array_like\n            Array of N points with dimension D.\n\n        Returns\n        -------\n        ndarray\n            (N,) array of N coordinates.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line\n\n        >>> points = [[-1, 1], [0, 1], [1, 1], [2, 1]]\n\n        >>> Line([0, 0], [1, 0]).transform_points(points)\n        array([-1.,  0.,  1.,  2.])\n\n        The point on the line acts as the origin of the coordinates.\n\n        >>> Line([1, 0], [1, 0]).transform_points(points)\n        array([-2., -1.,  0.,  1.])\n\n        The sign of the coordinates depends on the direction of the line.\n\n        >>> Line([0, 0], [-1, 0]).transform_points(points)\n        array([ 1.,  0., -1., -2.])\n\n        The magnitude of the direction vector is irrelevant.\n\n        >>> Line([0, 0], [5, 0]).transform_points(points)\n        array([-1.,  0.,  1.,  2.])\n\n        """"""\n        # Basis vector of the subspace (the line).\n        vectors_basis = [self.direction.unit()]\n\n        column = transform_coordinates(points, self.point.to_array(), vectors_basis)\n\n        return column.flatten()\n\n    def plot_2d(self, ax_2d: Axes, t_1: float = 0, t_2: float = 1, **kwargs) -> None:\n        """"""\n        Plot a 2D line.\n\n        The line is plotted by connecting two 2D points.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        t_1, t_2 : {int, float}\n            Parameters to determine points 1 and 2 along the line.\n            These are passed to :meth:`Line.to_point`.\n            Defaults are 0 and 1.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~matplotlib.axes.Axes.plot`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from skspatial.objects import Line\n\n            >>> _, ax = plt.subplots()\n\n            >>> line = Line([1, 2], [3, 4])\n\n            >>> line.plot_2d(ax, t_1=-2, t_2=3, c=\'k\')\n            >>> line.point.plot_2d(ax, c=\'r\', s=100, zorder=3)\n            >>> grid = ax.grid()\n\n        """"""\n        point_1 = self.to_point(t_1)\n        point_2 = self.to_point(t_2)\n\n        _connect_points_2d(ax_2d, point_1, point_2, **kwargs)\n\n    def plot_3d(self, ax_3d: Axes3D, t_1: float = 0, t_2: float = 1, **kwargs) -> None:\n        """"""\n        Plot a 3D line.\n\n        The line is plotted by connecting two 3D points.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        t_1, t_2 : {int, float}\n            Parameters to determine points 1 and 2 along the line.\n            These are passed to :meth:`Line.to_point`.\n            Defaults are 0 and 1.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.plot`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Line\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> line = Line([1, 2, 3], [0, 1, 1])\n\n            >>> line.plot_3d(ax, c=\'k\')\n            >>> line.point.plot_3d(ax, s=100)\n\n        """"""\n        point_1 = self.to_point(t_1)\n        point_2 = self.to_point(t_2)\n\n        _connect_points_3d(ax_3d, point_1, point_2, **kwargs)\n'"
skspatial/objects/plane.py,19,"b'""""""Module for the Plane class.""""""\n\nfrom __future__ import annotations\n\nfrom typing import Tuple\n\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import _mesh_to_points\nfrom skspatial.objects._base_line_plane import _BaseLinePlane\nfrom skspatial.objects.line import Line\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.points import Points\nfrom skspatial.objects.vector import Vector\nfrom skspatial.typing import array_like\n\n\nclass Plane(_BaseLinePlane):\n    """"""\n    A plane in space.\n\n    The plane is defined by a point and a normal vector.\n\n    Parameters\n    ----------\n    point : array_like\n        Point on the plane.\n    direction : array_like\n        Normal vector of the plane.\n\n    Attributes\n    ----------\n    point : Point\n        Point on the plane.\n    normal : Vector\n        Unit normal vector.\n    vector : Vector\n        Same as the normal.\n    dimension : int\n        Dimension of the plane.\n\n    Raises\n    ------\n    ValueError\n        If the point and vector have different dimensions,\n        or if the vector is all zeros.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Plane\n\n    >>> plane = Plane(point=[0, 0, 0], normal=[0, 0, 5])\n\n    >>> plane\n    Plane(point=Point([0, 0, 0]), normal=Vector([0, 0, 5]))\n\n    >>> plane.normal\n    Vector([0, 0, 5])\n\n    The normal can also be accessed with the ``vector`` attribute.\n\n    >>> plane.vector\n    Vector([0, 0, 5])\n\n    The plane dimension is the dimension of the point and vector.\n\n    >>> plane.dimension\n    3\n\n    >>> Plane([0, 0], [1, 0, 0])\n    Traceback (most recent call last):\n    ...\n    ValueError: The point and vector must have the same dimension.\n\n    >>> Plane([1, 1], [0, 0])\n    Traceback (most recent call last):\n    ...\n    ValueError: The vector must not be the zero vector.\n\n    """"""\n\n    def __init__(self, point: array_like, normal: array_like):\n\n        super().__init__(point, normal)\n        self.normal = self.vector\n\n    @classmethod\n    def from_vectors(cls, point: array_like, vector_a: array_like, vector_b: array_like) -> Plane:\n        """"""\n        Instantiate a plane from a point and two vectors.\n\n        The two vectors span the plane.\n\n        Parameters\n        ----------\n        point : array_like\n            Point on the plane.\n        vector_a, vector_b : array_like\n            Input vectors.\n\n        Returns\n        -------\n        Plane\n            Plane containing input point and spanned by the two input vectors.\n\n        Raises\n        ------\n        ValueError\n            If the vectors are parallel.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> Plane.from_vectors([0, 0], [1, 0], [0, 1])\n        Plane(point=Point([0, 0, 0]), normal=Vector([0, 0, 1]))\n\n        >>> Plane.from_vectors([0, 0], [1, 0], [2, 0])\n        Traceback (most recent call last):\n        ...\n        ValueError: The vectors must not be parallel.\n\n        """"""\n        vector_a = Vector(vector_a)\n\n        if vector_a.is_parallel(vector_b, rel_tol=0, abs_tol=0):\n            raise ValueError(""The vectors must not be parallel."")\n\n        # The cross product returns a 3D vector.\n        vector_normal = vector_a.cross(vector_b)\n\n        # Convert the point to 3D so that it matches the vector dimension.\n        point = Point(point).set_dimension(3)\n\n        return cls(point, vector_normal)\n\n    @classmethod\n    def from_points(cls, point_a: array_like, point_b: array_like, point_c: array_like) -> Plane:\n        """"""\n        Instantiate a plane from three points.\n\n        The three points lie on the plane.\n\n        Parameters\n        ----------\n        point_a, point_b, point_c: array_like\n            Three points defining the plane.\n\n        Returns\n        -------\n        Plane\n            Plane containing the three input points.\n\n        Raises\n        ------\n        ValueError\n            If the points are collinear.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> Plane.from_points([0, 0], [1, 0], [3, 3])\n        Plane(point=Point([0, 0, 0]), normal=Vector([0, 0, 3]))\n\n        The order of the points affects the direction of the normal vector.\n\n        >>> Plane.from_points([0, 0], [3, 3], [1, 0])\n        Plane(point=Point([0, 0, 0]), normal=Vector([ 0,  0, -3]))\n\n        >>> Plane.from_points([0, 0], [0, 1], [0, 3])\n        Traceback (most recent call last):\n        ...\n        ValueError: The points must not be collinear.\n\n        """"""\n        if Points([point_a, point_b, point_c]).are_collinear(tol=0):\n            raise ValueError(""The points must not be collinear."")\n\n        vector_ab = Vector.from_points(point_a, point_b)\n        vector_ac = Vector.from_points(point_a, point_c)\n\n        return Plane.from_vectors(point_a, vector_ab, vector_ac)\n\n    def cartesian(self) -> Tuple[np.number, np.number, np.number, np.number]:\n        """"""\n        Return the coefficients of the Cartesian equation of the plane.\n\n        The equation has the form ax + by + cz + d = 0.\n\n        Returns\n        -------\n        tuple\n            Coefficients a, b, c, d.\n\n        Raises\n        ------\n        ValueError\n            If the plane dimension is higher than 3.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> Plane(point=[1, 1], normal=[1, 0]).cartesian()\n        (1, 0, 0, -1)\n\n        >>> Plane(point=[1, 2, 0], normal=[0, 0, 1]).cartesian()\n        (0, 0, 1, 0)\n\n        >>> Plane(point=[1, 2, 8], normal=[0, 0, 5]).cartesian()\n        (0, 0, 5, -40)\n\n        >>> Plane(point=[4, 9, -1], normal=[10, 2, 4]).cartesian()\n        (10, 2, 4, -54)\n\n        >>> Plane([0, 0, 0, 0], [1, 0, 0, 0]).cartesian()\n        Traceback (most recent call last):\n        ...\n        ValueError: The plane dimension must be <= 3.\n\n        """"""\n        if self.dimension > 3:\n            raise ValueError(""The plane dimension must be <= 3."")\n\n        # The normal must be 3D to extract the coefficients.\n        a, b, c = self.normal.set_dimension(3)\n\n        d = -self.normal.dot(self.point)\n\n        return a, b, c, d\n\n    def project_point(self, point: array_like) -> Point:\n        """"""\n        Project a point onto the plane.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        Point\n            Projection of the point onto the plane.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> plane = Plane(point=[0, 0, 0], normal=[0, 0, 2])\n\n        >>> plane.project_point([10, 2, 5])\n        Point([10.,  2.,  0.])\n\n        >>> plane.project_point([5, 9, -3])\n        Point([5., 9., 0.])\n\n        """"""\n        # Vector from the point in space to the point on the plane.\n        vector_to_plane = Vector.from_points(point, self.point)\n\n        # Perpendicular vector from the point in space to the plane.\n        vector_projected = self.normal.project_vector(vector_to_plane)\n\n        return Point(point) + vector_projected\n\n    def project_vector(self, vector: array_like) -> Vector:\n        """"""\n        Project a vector onto the plane.\n\n        Parameters\n        ----------\n        vector : array_like\n            Input vector.\n\n        Returns\n        -------\n        Vector\n            Projection of the vector onto the plane.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> plane = Plane([0, 4, 0], [0, 1, 1])\n\n        >>> plane.project_vector([2, 4, 8])\n        Vector([ 2., -2.,  2.])\n\n        """"""\n        point_in_space = self.point + vector\n        point_on_plane = self.project_point(point_in_space)\n\n        return Vector.from_points(self.point, point_on_plane)\n\n    def distance_point_signed(self, point: array_like) -> np.float64:\n        """"""\n        Return the signed distance from a point to the plane.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        np.float64\n            Signed distance from the point to the plane.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Point-PlaneDistance.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> plane = Plane([0, 0, 0], [0, 0, 1])\n\n        >>> plane.distance_point_signed([5, 2, 0])\n        0.0\n\n        >>> plane.distance_point_signed([5, 2, 1])\n        1.0\n\n        >>> plane.distance_point([5, 2, -4])\n        4.0\n        >>> plane.distance_point_signed([5, 2, -4])\n        -4.0\n\n        """"""\n        vector_to_point = Vector.from_points(self.point, point)\n\n        return self.normal.scalar_projection(vector_to_point)\n\n    def distance_point(self, point: array_like) -> np.float64:\n        """"""\n        Return the distance from a point to the plane.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        np.float64\n            Distance from the point to the plane.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/Point-PlaneDistance.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> plane = Plane([0, 0, 0], [0, 0, 1])\n\n        >>> plane.distance_point([5, 2, 0])\n        0.0\n\n        >>> plane.distance_point([5, 2, 1])\n        1.0\n\n        >>> plane.distance_point([5, 2, -4])\n        4.0\n\n        """"""\n        return abs(self.distance_point_signed(point))\n\n    def side_point(self, point: array_like) -> np.float64:\n        """"""\n        Find the side of the plane where a point lies.\n\n        Parameters\n        ----------\n        point : array_like\n            Input point.\n\n        Returns\n        -------\n        np.int64\n            -1 if the point is behind the plane.\n            0 if the point is on the plane.\n            1 if the point is in front of the plane.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n        >>> plane = Plane([0, 0, 0], [0, 0, 1])\n\n        The point is in on the plane.\n\n        >>> plane.side_point([2, 5, 0])\n        0\n\n        The point is in front of the plane.\n\n        >>> plane.side_point([1, -5, 6])\n        1\n\n        The point is behind the plane.\n\n        >>> plane.side_point([5, 8, -4])\n        -1\n\n        Higher dimensions are supported.\n\n        >>> plane = Plane([0, 0, 0, 0], [0, 1, 0, 1])\n        >>> plane.side_point([0, -10, 4, 1])\n        -1\n\n        """"""\n        return np.sign(self.distance_point_signed(point)).astype(int)\n\n    def intersect_line(self, line: Line) -> Plane:\n        """"""\n        Intersect the plane with a line.\n\n        The line and plane must not be parallel.\n\n        Parameters\n        ----------\n        line : Line\n            Input line.\n\n        Returns\n        -------\n        Point\n            The point of intersection.\n\n        Raises\n        ------\n        ValueError\n            If the line and plane are parallel.\n\n        References\n        ----------\n        http://geomalgorithms.com/a05-_intersect-1.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Line, Plane\n\n        >>> line = Line([0, 0, 0], [0, 0, 1])\n        >>> plane = Plane([0, 0, 0], [0, 0, 1])\n\n        >>> plane.intersect_line(line)\n        Point([0., 0., 0.])\n\n        >>> plane = Plane([2, -53, -7], [0, 0, 1])\n        >>> plane.intersect_line(line)\n        Point([ 0.,  0., -7.])\n\n        >>> line = Line([0, 1, 0], [1, 0, 0])\n        >>> plane.intersect_line(line)\n        Traceback (most recent call last):\n        ...\n        ValueError: The line and plane must not be parallel.\n\n        """"""\n        if self.normal.is_perpendicular(line.direction, rel_tol=0, abs_tol=0):\n            raise ValueError(""The line and plane must not be parallel."")\n\n        vector_plane_line = Vector.from_points(self.point, line.point)\n\n        num = -self.normal.dot(vector_plane_line)\n        denom = self.normal.dot(line.direction)\n\n        # Vector along the line to the intersection point.\n        vector_line_scaled = num / denom * line.direction\n\n        return line.point + vector_line_scaled\n\n    def intersect_plane(self, other: Plane) -> Line:\n        """"""\n        Intersect the plane with another.\n\n        The planes must not be parallel.\n\n        Parameters\n        ----------\n        other : Plane\n            Other plane.\n\n        Returns\n        -------\n        Line\n            The line of intersection.\n\n        Raises\n        ------\n        ValueError\n            If the planes are parallel.\n\n        References\n        ----------\n        http://tbirdal.blogspot.com/2016/10/a-better-approach-to-plane-intersection.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> plane_a = Plane([0, 0, 0], [0, 0, 1])\n        >>> plane_b = Plane([0, 0, 0], [1, 0, 0])\n\n        >>> plane_a.intersect_plane(plane_b)\n        Line(point=Point([0., 0., 0.]), direction=Vector([0, 1, 0]))\n\n        >>> plane_b = Plane([5, 16, -94], [1, 0, 0])\n        >>> plane_a.intersect_plane(plane_b)\n        Line(point=Point([5., 0., 0.]), direction=Vector([0, 1, 0]))\n\n        >>> plane_b = Plane([0, 0, 1], [1, 0, 1])\n        >>> plane_a.intersect_plane(plane_b)\n        Line(point=Point([1., 0., 0.]), direction=Vector([0, 1, 0]))\n\n        >>> plane_b = Plane([0, 0, 5], [0, 0, -8])\n        >>> plane_a.intersect_plane(plane_b)\n        Traceback (most recent call last):\n        ...\n        ValueError: The planes must not be parallel.\n\n        """"""\n        if self.normal.is_parallel(other.normal, rel_tol=0, abs_tol=0):\n            raise ValueError(""The planes must not be parallel."")\n\n        array_normals_stacked = np.vstack((self.normal, other.normal))\n\n        # Construct a matrix for a linear system.\n        array_00 = 2 * np.eye(3)\n        array_01 = array_normals_stacked.T\n        array_10 = array_normals_stacked\n        array_11 = np.zeros((2, 2))\n        matrix = np.block([[array_00, array_01], [array_10, array_11]])\n\n        dot_a = np.dot(self.point, self.normal)\n        dot_b = np.dot(other.point, other.normal)\n        array_y = np.array([0, 0, 0, dot_a, dot_b])\n\n        # Solve the linear system.\n        solution = np.linalg.solve(matrix, array_y)\n\n        point_line = Point(solution[:3])\n        direction_line = self.normal.cross(other.normal)\n\n        return Line(point_line, direction_line)\n\n    @classmethod\n    def best_fit(cls, points: array_like) -> Plane:\n        """"""\n        Return the plane of best fit for a set of 3D points.\n\n        Parameters\n        ----------\n        points : array_like\n             Input 3D points.\n\n        Returns\n        -------\n        Plane\n            The plane of best fit.\n\n        Raises\n        ------\n        ValueError\n            If the points are collinear or are not 3D.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> points = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        >>> plane = Plane.best_fit(points)\n\n        The point on the plane is the centroid of the points.\n\n        >>> plane.point\n        Point([0.25, 0.25, 0.25])\n\n        The plane normal is a unit vector.\n\n        >>> plane.normal.round(3)\n        Vector([-0.577, -0.577, -0.577])\n\n        >>> Plane.best_fit([[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]])\n        Plane(point=Point([0.5, 0.5, 0. ]), normal=Vector([0., 0., 1.]))\n\n        """"""\n        points = Points(points)\n\n        if points.dimension != 3:\n            raise ValueError(""The points must be 3D."")\n\n        if points.are_collinear(tol=0):\n            raise ValueError(""The points must not be collinear."")\n\n        points_centered, centroid = points.mean_center(return_centroid=True)\n\n        u, _, _ = np.linalg.svd(points_centered.T)\n        normal = Vector(u[:, -1])\n\n        return cls(centroid, normal)\n\n    def to_mesh(\n        self, lims_x: array_like = (-1, 1), lims_y: array_like = (-1, 1)\n    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        """"""\n        Return coordinate matrices for the 3D surface of the plane.\n\n        Parameters\n        ----------\n        lims_x, lims_y : (2,) tuple\n            x and y limits of the plane.\n            Tuple of form (min, max). The default is (-1, 1).\n            The point on the plane is used as the origin.\n\n        Returns\n        -------\n        X, Y, Z: ndarray\n            Coordinate matrices.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> X, Y, Z = Plane([0, 0, 0], [0, 0, 1]).to_mesh()\n\n        >>> X\n        array([[-1,  1],\n               [-1,  1]])\n\n        >>> Y\n        array([[-1, -1],\n               [ 1,  1]])\n\n        >>> Z\n        array([[0., 0.],\n               [0., 0.]])\n\n        """"""\n        a, b, c, d = self.cartesian()\n        x_center, y_center = self.point[:2]\n\n        values_x = x_center + lims_x\n        values_y = y_center + lims_y\n\n        X, Y = np.meshgrid(values_x, values_y)\n\n        if c != 0:\n            Z = -(a * X + b * Y + d) / c\n\n        elif b != 0:\n            Z = -(a * X + c * Y + d) / b\n            X, Y, Z = X, Z, Y\n\n        else:\n            Z = -(b * X + c * Y + d) / a\n            X, Y, Z = Z, X, Y\n\n        return X, Y, Z\n\n    def to_points(self, lims_x: array_like = (-1, 1), lims_y: array_like = (-1, 1)) -> Points:\n        """"""\n        Return four points on the plane.\n\n        The coordinate matrices used for 3D plotting are converted to points.\n\n        Parameters\n        ----------\n        lims_x, lims_y : (2,) tuple\n            x and y limits of the plane.\n            Tuple of form (min, max). The default is (-1, 1).\n            The point on the plane is used as the origin.\n\n        Returns\n        -------\n        Points\n            Four 3D points on the plane.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Plane\n\n        >>> Plane([0, 0, 0], [0, 0, 1]).to_points()\n        Points([[-1., -1.,  0.],\n                [ 1., -1.,  0.],\n                [-1.,  1.,  0.],\n                [ 1.,  1.,  0.]])\n\n        """"""\n        X, Y, Z = self.to_mesh(lims_x, lims_y)\n\n        points = _mesh_to_points(X, Y, Z)\n\n        return Points(points)\n\n    def plot_3d(self, ax_3d: Axes3D, lims_x: array_like = (-1, 1), lims_y: array_like = (-1, 1), **kwargs) -> None:\n        """"""\n        Plot a 3D plane.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        lims_x, lims_y : (2,) tuple\n            x and y limits of the plane.\n            Tuple of form (min, max). The default is (-1, 1).\n            The point on the plane is used as the origin.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Plane\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> plane = Plane([5, 3, 1], [1, 0, 1])\n\n            >>> plane.plot_3d(ax, alpha=0.2)\n            >>> plane.point.plot_3d(ax, s=100)\n\n        """"""\n        X, Y, Z = self.to_mesh(lims_x, lims_y)\n\n        ax_3d.plot_surface(X, Y, Z, **kwargs)\n'"
skspatial/objects/point.py,3,"b'""""""Module for the Point class.""""""\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial.objects._base_array import _BaseArray1D\nfrom skspatial.objects.vector import Vector\nfrom skspatial.plotting import _scatter_2d, _scatter_3d\nfrom skspatial.typing import array_like\n\n\nclass Point(_BaseArray1D):\n    """"""\n    A point in space implemented as a 1D array.\n\n    The array is a subclass of :class:`numpy.ndarray`.\n\n    Parameters\n    ----------\n    array : array_like\n        Input array.\n\n    Attributes\n    ----------\n    dimension : int\n        Dimension of the point.\n\n    Raises\n    ------\n    ValueError\n        If the array is empty, the values are not finite,\n        or the dimension is not one.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Point\n\n    >>> point = Point([1, 2, 3])\n\n    >>> point.dimension\n    3\n\n    The object inherits methods from :class:`numpy.ndarray`.\n\n    >>> point.mean()\n    Point(2.)\n\n    >>> Point([])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must not be empty.\n\n    >>> import numpy as np\n\n    >>> Point([1, 2, np.nan])\n    Traceback (most recent call last):\n    ...\n    ValueError: The values must all be finite.\n\n    >>> Point([[1, 2], [3, 4]])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must be 1D.\n\n    """"""\n\n    def distance_point(self, other: array_like) -> np.float64:\n        """"""\n        Return the distance to another point.\n\n        Parameters\n        ----------\n        other : array_like\n            Other point.\n\n        Returns\n        -------\n        np.float64\n            Distance between the points.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Point\n\n        >>> point = Point([1, 2])\n        >>> point.distance_point([1, 2])\n        0.0\n\n        >>> point.distance_point([-1, 2])\n        2.0\n\n        >>> Point([1, 2, 0]).distance_point([1, 2, 3])\n        3.0\n\n        """"""\n        vector = Vector.from_points(self, other)\n\n        return vector.norm()\n\n    def plot_2d(self, ax_2d: Axes, **kwargs) -> None:\n        """"""\n        Plot the point on a 2D scatter plot.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~matplotlib.axes.Axes.scatter`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from skspatial.objects import Point\n\n            >>> _, ax = plt.subplots()\n\n            >>> Point([1, 2]).plot_2d(ax, c=\'k\', s=100)\n\n        """"""\n        _scatter_2d(ax_2d, self.reshape(1, -1), **kwargs)\n\n    def plot_3d(self, ax_3d: Axes3D, **kwargs) -> None:\n        """"""\n        Plot the point on a 3D scatter plot.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.scatter`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Point\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> Point([1, 2, 3]).plot_3d(ax, c=\'k\', s=100)\n\n        """"""\n        _scatter_3d(ax_3d, self.reshape(1, -1), **kwargs)\n'"
skspatial/objects/points.py,5,"b'""""""Module for the Points class.""""""\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom numpy.linalg import matrix_rank\n\nfrom skspatial.objects._base_array import _BaseArray2D\nfrom skspatial.objects.point import Point\nfrom skspatial.plotting import _scatter_2d, _scatter_3d\n\n\nclass Points(_BaseArray2D):\n    """"""\n    Multiple points in space implemented as a 2D array.\n\n    The array is a subclass of :class:`numpy.ndarray`.\n    Each row in the array represents a point in space.\n\n    Parameters\n    ----------\n    points : array_like\n        (N, D) array representing N points with dimension D.\n\n    Raises\n    ------\n    ValueError\n        If the array is empty, the values are not finite,\n        or the dimension is not two.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Points\n\n    >>> points = Points([[1, 2, 0], [5, 4, 3]])\n\n    >>> points\n    Points([[1, 2, 0],\n            [5, 4, 3]])\n\n    >>> points.dimension\n    3\n\n    The object inherits methods from :class:`numpy.ndarray`.\n\n    >>> points.mean(axis=0)\n    Points([3. , 3. , 1.5])\n\n    >>> Points([])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must not be empty.\n\n    >>> import numpy as np\n\n    >>> Points([[1, 2], [1, np.nan]])\n    Traceback (most recent call last):\n    ...\n    ValueError: The values must all be finite.\n\n    >>> Points([1, 2, 3])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must be 2D.\n\n    """"""\n\n    def unique(self) -> Points:\n        """"""\n        Return unique points.\n\n        The output contains the unique rows of the original array.\n\n        Returns\n        -------\n        Points\n            (N, D) array of N unique points with dimension D.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> points = Points([[1, 2, 3], [2, 3, 4], [1, 2, 3]])\n\n        >>> points.unique()\n        Points([[1, 2, 3],\n                [2, 3, 4]])\n\n        """"""\n        return Points(np.unique(self, axis=0))\n\n    def centroid(self) -> Point:\n        """"""\n        Return the centroid of the points.\n\n        Returns\n        -------\n        Point\n            Centroid of the points.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> Points([[1, 2, 3], [2, 2, 3]]).centroid()\n        Point([1.5, 2. , 3. ])\n\n        """"""\n        return Point(self.mean(axis=0))\n\n    def mean_center(self, return_centroid: bool = False):\n        """"""\n        Mean-center the points by subtracting the centroid.\n\n        Parameters\n        ----------\n        return_centroid : bool, optional\n            If True, also return the original centroid of the points.\n\n        Returns\n        -------\n        points_centered : (N, D) Points\n            Array of N mean-centered points with dimension D.\n        centroid : (D,) Point, optional\n            Original centroid of the points. Only provided if `return_centroid` is True.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> points_centered, centroid = Points([[4, 4, 4], [2, 2, 2]]).mean_center(return_centroid=True)\n        >>> points_centered\n        Points([[ 1.,  1.,  1.],\n                [-1., -1., -1.]])\n\n        >>> centroid\n        Point([3., 3., 3.])\n\n        The centroid of the centered points is the origin.\n\n        >>> points_centered.centroid()\n        Point([0., 0., 0.])\n\n        """"""\n        centroid = self.centroid()\n        points_centered = self - centroid\n\n        if return_centroid:\n            return points_centered, centroid\n\n        return points_centered\n\n    def normalize_distance(self) -> Points:\n        """"""\n        Normalize the distances of the points from the origin.\n\n        The normalized points lie within a unit sphere centered on the origin.\n\n        Returns\n        -------\n        Points\n            Normalized points.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> points = Points([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        >>> points.normalize_distance().round(3)\n        Points([[0.072, 0.144, 0.215],\n                [0.287, 0.359, 0.431],\n                [0.503, 0.574, 0.646]])\n\n        The transformation can be chained with mean centering.\n\n        >>> points.mean_center().normalize_distance().round(3)\n        Points([[-0.577, -0.577, -0.577],\n                [ 0.   ,  0.   ,  0.   ],\n                [ 0.577,  0.577,  0.577]])\n\n        """"""\n        distances_to_points = np.linalg.norm(self, axis=1)\n\n        return self / distances_to_points.max()\n\n    def affine_rank(self, **kwargs) -> np.int64:\n        """"""\n        Return the affine rank of the points.\n\n        The affine rank is the dimension of the smallest affine space that contains the points.\n        A rank of 1 means the points are collinear, and a rank of 2 means they are coplanar.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.matrix_rank`\n\n        Returns\n        -------\n        np.int64\n            Affine rank of the points.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> Points([[5, 5], [5, 5]]).affine_rank()\n        0\n\n        >>> Points([[5, 3], [-6, 20]]).affine_rank()\n        1\n\n        >>> Points([[0, 0], [1, 1], [2, 2]]).affine_rank()\n        1\n\n        >>> Points([[0, 0], [1, 0], [2, 2]]).affine_rank()\n        2\n\n        >>> Points([[0, 1, 0], [1, 1, 0], [2, 2, 2]]).affine_rank()\n        2\n\n        >>> Points([[0, 0], [0, 1], [1, 0], [1, 1]]).affine_rank()\n        2\n\n        >>> Points([[1, 3, 2], [3, 4, 5], [2, 1, 5], [5, 9, 8]]).affine_rank()\n        3\n\n        """"""\n        # Remove duplicate points so they do not affect the centroid.\n        points_centered = self.unique().mean_center()\n\n        return matrix_rank(points_centered, **kwargs)\n\n    def are_concurrent(self, **kwargs) -> bool:\n        """"""\n        Check if the points are all contained in one point.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.matrix_rank`\n\n        Returns\n        -------\n        bool\n            True if points are concurrent; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> Points([[0, 0], [1, 1], [1, 1]]).are_concurrent()\n        False\n\n        >>> Points([[1, 1], [1, 1], [1, 1]]).are_concurrent()\n        True\n\n        """"""\n        return self.affine_rank(**kwargs) == 0\n\n    def are_collinear(self, **kwargs) -> bool:\n        """"""\n        Check if the points are all contained in one line.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.matrix_rank`\n\n        Returns\n        -------\n        bool\n            True if points are collinear; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> Points(([0, 0, 0], [1, 2, 3], [2, 4, 6])).are_collinear()\n        True\n\n        >>> Points(([0, 0, 0], [1, 2, 3], [5, 2, 0])).are_collinear()\n        False\n\n        >>> Points(([0, 0], [1, 2], [5, 2], [6, 3])).are_collinear()\n        False\n\n        """"""\n        return self.affine_rank(**kwargs) <= 1\n\n    def are_coplanar(self, **kwargs) -> bool:\n        """"""\n        Check if the points are all contained in one plane.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.matrix_rank`\n\n        Returns\n        -------\n        bool\n            True if points are coplanar; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Points\n\n        >>> Points([[1, 2], [9, -18], [12, 4], [2, 1]]).are_coplanar()\n        True\n\n        >>> Points([[1, 2], [9, -18], [12, 4], [2, 2]]).are_coplanar()\n        True\n\n        >>> Points([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]]).are_coplanar()\n        False\n\n        """"""\n        return self.affine_rank(**kwargs) <= 2\n\n    def plot_2d(self, ax_2d: Axes, **kwargs) -> None:\n        """"""\n        Plot the points on a 2D scatter plot.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~matplotlib.axes.Axes.scatter`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n\n            >>> from skspatial.objects import Points\n\n            >>> fig, ax = plt.subplots()\n            >>> points = Points([[1, 2], [3, 4], [-4, 2], [-2, 3]])\n            >>> points.plot_2d(ax, c=\'k\')\n\n        """"""\n        _scatter_2d(ax_2d, self, **kwargs)\n\n    def plot_3d(self, ax_3d: Axes3D, **kwargs) -> None:\n        """"""\n        Plot the points on a 3D scatter plot.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.scatter`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Points\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> points = Points([[1, 2, 1], [3, 2, -7], [-4, 2, 2], [-2, 3, 1]])\n            >>> points.plot_3d(ax, s=75, depthshade=False)\n\n        """"""\n        _scatter_3d(ax_3d, self, **kwargs)\n'"
skspatial/objects/sphere.py,17,"b'""""""Module for the Sphere class.""""""\n\nimport math\nfrom typing import Tuple\n\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import _mesh_to_points, np_float\nfrom skspatial.objects._base_sphere import _BaseSphere\nfrom skspatial.objects.line import Line\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.points import Points\nfrom skspatial.objects.vector import Vector\nfrom skspatial.typing import array_like\n\n\nclass Sphere(_BaseSphere):\n    """"""\n    A sphere in 3D space.\n\n    The sphere is defined by a 3D point and a radius.\n\n    Parameters\n    ----------\n    point : (3,) array_like\n        Center of the sphere.\n    radius : {int, float}\n        Radius of the sphere.\n\n    Attributes\n    ----------\n    point : (3,) Point\n        Center of the circle.\n    radius : {int, float}\n        Radius of the sphere.\n    dimension : int\n        Dimension of the sphere.\n\n    Raises\n    ------\n    ValueError\n        If the radius is not positive, or if the point is not 3D.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Sphere\n\n    >>> sphere = Sphere([1, 2, 3], 5)\n\n    >>> sphere\n    Sphere(point=Point([1, 2, 3]), radius=5)\n\n    >>> sphere.dimension\n    3\n\n    >>> sphere.surface_area().round(2)\n    314.16\n\n    >>> Sphere([0, 0], 0)\n    Traceback (most recent call last):\n    ...\n    ValueError: The radius must be positive.\n\n    >>> Sphere([0, 0, 0, 0], 1)\n    Traceback (most recent call last):\n    ...\n    ValueError: The point must be 3D.\n\n    """"""\n\n    def __init__(self, point: array_like, radius: float):\n\n        super().__init__(point, radius)\n\n        if self.point.dimension != 3:\n            raise ValueError(""The point must be 3D."")\n\n    @np_float\n    def surface_area(self) -> np.float64:\n        r""""""\n        Return the surface area of the sphere.\n\n        The surface area :math:`A` of a sphere with radius :math:`r` is\n\n        .. math:: A = 4 \\pi r ^ 2\n\n        Returns\n        -------\n        np.float64\n            Surface area of the sphere.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Sphere\n\n        >>> Sphere([0, 0, 0], 1).surface_area().round(2)\n        12.57\n\n        >>> Sphere([0, 0, 0], 2).surface_area().round(2)\n        50.27\n\n        """"""\n        return 4 * np.pi * self.radius ** 2\n\n    @np_float\n    def volume(self) -> np.float64:\n        r""""""\n        Return the volume of the sphere.\n\n        The volume :math:`V` of a sphere with radius :math:`r` is\n\n        .. math:: V = \\frac{4}{3} \\pi r ^ 3\n\n        Returns\n        -------\n        np.float64\n            Volume of the sphere.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Sphere\n\n        >>> Sphere([0, 0, 0], 1).volume().round(2)\n        4.19\n\n        >>> Sphere([0, 0, 0], 2).volume().round(2)\n        33.51\n\n        """"""\n        return 4 / 3 * np.pi * self.radius ** 3\n\n    def intersect_line(self, line: Line) -> Tuple[Point, Point]:\n        """"""\n        Intersect the sphere with a line.\n\n        A line intersects a sphere at two points.\n\n        Parameters\n        ----------\n        line : Line\n            Input line.\n\n        Returns\n        -------\n        point_a, point_b : Point\n            The two points of intersection.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Sphere, Line\n\n        >>> sphere = Sphere([0, 0, 0], 1)\n\n        >>> sphere.intersect_line(Line([0, 0, 0], [1, 0, 0]))\n        (Point([-1.,  0.,  0.]), Point([1., 0., 0.]))\n\n        >>> sphere.intersect_line(Line([0, 0, 1], [1, 0, 0]))\n        (Point([0., 0., 1.]), Point([0., 0., 1.]))\n\n        >>> sphere.intersect_line(Line([0, 0, 2], [1, 0, 0]))\n        Traceback (most recent call last):\n        ...\n        ValueError: The line does not intersect the sphere.\n\n        """"""\n        vector_to_line = Vector.from_points(self.point, line.point)\n        vector_unit = line.direction.unit()\n\n        dot = vector_unit.dot(vector_to_line)\n\n        discriminant = dot ** 2 - (vector_to_line.norm() ** 2 - self.radius ** 2)\n\n        if discriminant < 0:\n            raise ValueError(""The line does not intersect the sphere."")\n\n        pm = np.array([-1, 1])  # Array to compute plus/minus.\n        distances = -dot + pm * math.sqrt(discriminant)\n\n        point_a, point_b = line.point + distances.reshape(-1, 1) * vector_unit\n\n        return point_a, point_b\n\n    def to_mesh(self, n_angles: int = 30) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        """"""\n        Return coordinate matrices for the 3D surface of the sphere.\n\n        Parameters\n        ----------\n        n_angles: int\n            Number of angles used to generate the coordinate matrices.\n\n        Returns\n        -------\n        X, Y, Z: (n_angles, n_angles) ndarray\n            Coordinate matrices.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Sphere\n\n        >>> X, Y, Z = Sphere([0, 0, 0], 1).to_mesh(5)\n\n        >>> X.round(3)\n        array([[ 0.   ,  0.   ,  0.   ,  0.   ,  0.   ],\n               [ 0.   ,  0.707,  0.   , -0.707, -0.   ],\n               [ 0.   ,  1.   ,  0.   , -1.   , -0.   ],\n               [ 0.   ,  0.707,  0.   , -0.707, -0.   ],\n               [ 0.   ,  0.   ,  0.   , -0.   , -0.   ]])\n\n        >>> Y.round(3)\n        array([[ 0.   ,  0.   ,  0.   ,  0.   ,  0.   ],\n               [ 0.707,  0.   , -0.707, -0.   ,  0.707],\n               [ 1.   ,  0.   , -1.   , -0.   ,  1.   ],\n               [ 0.707,  0.   , -0.707, -0.   ,  0.707],\n               [ 0.   ,  0.   , -0.   , -0.   ,  0.   ]])\n\n        >>> Z.round(3)\n        array([[ 1.   ,  1.   ,  1.   ,  1.   ,  1.   ],\n               [ 0.707,  0.707,  0.707,  0.707,  0.707],\n               [ 0.   ,  0.   ,  0.   ,  0.   ,  0.   ],\n               [-0.707, -0.707, -0.707, -0.707, -0.707],\n               [-1.   , -1.   , -1.   , -1.   , -1.   ]])\n\n        """"""\n        angles_a = np.linspace(0, np.pi, n_angles)\n        angles_b = np.linspace(0, 2 * np.pi, n_angles)\n\n        sin_angles_a = np.sin(angles_a)\n        cos_angles_a = np.cos(angles_a)\n\n        sin_angles_b = np.sin(angles_b)\n        cos_angles_b = np.cos(angles_b)\n\n        X = self.point[0] + self.radius * np.outer(sin_angles_a, sin_angles_b)\n        Y = self.point[1] + self.radius * np.outer(sin_angles_a, cos_angles_b)\n        Z = self.point[2] + self.radius * np.outer(cos_angles_a, np.ones_like(angles_b))\n\n        return X, Y, Z\n\n    def to_points(self, n_angles: int = 30) -> Points:\n        """"""\n        Return points on the surface of the sphere.\n\n        Parameters\n        ----------\n        n_angles: int\n            Number of angles used to generate the points.\n\n        Returns\n        -------\n        Points\n            Points on the surface of the sphere.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Sphere\n\n        >>> sphere = Sphere([0, 0, 0], 1)\n\n        >>> sphere.to_points(n_angles=3).round().unique()\n        Points([[ 0., -1.,  0.],\n                [ 0.,  0., -1.],\n                [ 0.,  0.,  1.],\n                [ 0.,  1.,  0.]])\n\n        >>> sphere.to_points(n_angles=4).round(3).unique()\n        Points([[-0.75 , -0.433, -0.5  ],\n                [-0.75 , -0.433,  0.5  ],\n                [ 0.   ,  0.   , -1.   ],\n                [ 0.   ,  0.   ,  1.   ],\n                [ 0.   ,  0.866, -0.5  ],\n                [ 0.   ,  0.866,  0.5  ],\n                [ 0.75 , -0.433, -0.5  ],\n                [ 0.75 , -0.433,  0.5  ]])\n\n        """"""\n        X, Y, Z = self.to_mesh(n_angles)\n\n        points = _mesh_to_points(X, Y, Z)\n\n        return Points(points)\n\n    def plot_3d(self, ax_3d: Axes3D, n_angles: int = 30, **kwargs) -> None:\n        """"""\n        Plot the sphere in 3D.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Sphere\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> sphere = Sphere([1, 2, 3], 2)\n\n            >>> sphere.plot_3d(ax, alpha=0.2)\n            >>> sphere.point.plot_3d(ax, s=100)\n\n        """"""\n        X, Y, Z = self.to_mesh(n_angles)\n\n        ax_3d.plot_surface(X, Y, Z, **kwargs)\n'"
skspatial/objects/triangle.py,11,"b'""""""Module for the Triangle class.""""""\n\nimport math\nfrom itertools import combinations\nfrom typing import Sequence\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import np_float\nfrom skspatial.objects.line import Line\nfrom skspatial.objects.point import Point\nfrom skspatial.objects.points import Points\nfrom skspatial.objects.vector import Vector\nfrom skspatial.plotting import _plotter\nfrom skspatial.typing import array_like\n\n\nclass Triangle:\n    """"""\n    A triangle represented by three points in space.\n\n    Parameters\n    ----------\n    point_a, point_b, point_c : array_like\n        The three vertices of the triangle.\n\n    Attributes\n    ----------\n    point_a, point_b, point_c : Point\n        The three vertices of the triangle.\n    dimension : int\n        Dimension of the triangle.\n\n    Raises\n    ------\n    ValueError\n        If the points do not have the same dimension, or if they are collinear.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Triangle\n\n    >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n    >>> triangle\n    Triangle(point_a=Point([0, 0]), point_b=Point([1, 0]), point_c=Point([0, 1]))\n\n    >>> triangle.dimension\n    2\n\n    >>> Triangle([0, 0, 0], [1, 0], [0, 1])\n    Traceback (most recent call last):\n    ...\n    ValueError: The points must have the same dimension.\n\n    >>> Triangle([0, 0], [0, 1], [0, 2])\n    Traceback (most recent call last):\n    ...\n    ValueError: The points must not be collinear.\n\n    """"""\n\n    def __init__(self, point_a: array_like, point_b: array_like, point_c: array_like):\n\n        self.point_a = Point(point_a)\n        self.point_b = Point(point_b)\n        self.point_c = Point(point_c)\n\n        if not (self.point_a.dimension == self.point_b.dimension == self.point_c.dimension):\n            raise ValueError(""The points must have the same dimension."")\n\n        if Points([self.point_a, self.point_b, self.point_c]).are_collinear():\n            raise ValueError(""The points must not be collinear."")\n\n        self.dimension = self.point_a.dimension\n\n    def __repr__(self) -> str:\n\n        repr_a = np.array_repr(self.point_a)\n        repr_b = np.array_repr(self.point_b)\n        repr_c = np.array_repr(self.point_c)\n\n        return f""Triangle(point_a={repr_a}, point_b={repr_b}, point_c={repr_c})""\n\n    def multiple(self, name_method: str, inputs: Sequence) -> tuple:\n        """"""\n        Return multiple properties of the triangle.\n\n        Parameters\n        ----------\n        name_method : str\n            Name of the triangle method.\n        inputs : Sequence\n            Sequence of different inputs to the method.\n\n        Returns\n        -------\n        tuple\n            Multiple outputs from the triangle method.\n\n        Examples\n        --------\n        >>> from math import degrees\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [0, 1], [1, 0])\n\n        >>> lengths = triangle.multiple(\'length\', \'abc\')\n        >>> [round(x, 3) for x in lengths]\n        [1.414, 1.0, 1.0]\n\n        >>> angles = triangle.multiple(\'angle\', \'ABC\')\n        >>> [round(degrees(x), 3) for x in angles]\n        [90.0, 45.0, 45.0]\n\n        """"""\n        method = getattr(self, name_method)\n\n        return tuple(method(x) for x in inputs)\n\n    def normal(self) -> Vector:\n        r""""""\n        Return a vector normal to the triangle.\n\n        The normal vector is calculated as\n\n        .. math::\n            v_{AB} \\times v_{AC}\n\n        where :math:`v_{AB}` is the vector from vertex A to vertex B.\n\n        Returns\n        -------\n        Vector\n            Normal vector.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [1, 0], [0, 1]).normal()\n        Vector([0, 0, 1])\n\n        The normal vector is not necessarily a unit vector.\n\n        >>> Triangle([0, 0], [2, 0], [0, 2]).normal()\n        Vector([0, 0, 4])\n\n        The direction of the normal vector is dependent on the order of the vertices.\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).normal()\n        Vector([ 0,  0, -1])\n\n        """"""\n        vector_ab = Vector.from_points(self.point_a, self.point_b)\n        vector_ac = Vector.from_points(self.point_a, self.point_c)\n\n        return vector_ab.cross(vector_ac)\n\n    def area(self) -> np.float64:\n        """"""\n        Return the area of the triangle.\n\n        The points are the vertices of the triangle. They must be 3D or less.\n\n        Returns\n        -------\n        np.float64\n            The area of the triangle.\n\n        References\n        ----------\n        http://mathworld.wolfram.com/TriangleArea.html\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).area()\n        0.5\n\n        >>> Triangle([0, 0], [0, 2], [1, 1]).area()\n        1.0\n\n        >>> Triangle([3, -5, 1], [5, 2, 1], [9, 4, 2]).area().round(2)\n        12.54\n\n        """"""\n        return 0.5 * self.normal().norm()\n\n    def perimeter(self) -> np.float64:\n        """"""\n        Return the perimeter of the triangle.\n\n        Returns\n        -------\n        np.float64\n            The perimeter of the triangle.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).perimeter().round(3)\n        3.414\n\n        >>> Triangle([0, 1], [1, 1], [2, 0]).perimeter().round(3)\n        4.65\n\n        """"""\n        return np.sum(self.multiple(\'length\', \'abc\'))\n\n    def point(self, vertex: str) -> Point:\n        """"""\n        Return a point (vertex) of the triangle.\n\n        Parameters\n        ----------\n        vertex: str\n            \'A\', \'B\', or \'C\'.\n\n        Returns\n        -------\n        Point\n            A vertex of the triangle.\n\n        Raises\n        ------\n        ValueError\n            If the vertex is not \'A\', \'B\', or \'C\'.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n        >>> triangle.point(\'A\')\n        Point([0, 0])\n\n        >>> triangle.point(\'B\')\n        Point([1, 0])\n\n        >>> triangle.point(\'C\')\n        Point([0, 1])\n\n        >>> triangle.point(\'D\')\n        Traceback (most recent call last):\n        ...\n        ValueError: The vertex must be \'A\', \'B\', or \'C\'.\n\n        """"""\n        if vertex == \'A\':\n            return self.point_a\n\n        if vertex == \'B\':\n            return self.point_b\n\n        if vertex == \'C\':\n            return self.point_c\n\n        raise ValueError(""The vertex must be \'A\', \'B\', or \'C\'."")\n\n    def line(self, side: str) -> Line:\n        """"""\n        Return the line along a side of the triangle.\n\n        Parameters\n        ----------\n        side: str\n            \'a\', \'b\', or \'c\'.\n            Side \'a\' is the side across from vertex \'A\'.\n\n        Returns\n        -------\n        Line\n            Line along the side.\n\n        Raises\n        ------\n        ValueError\n            If the side is not \'a\', \'b\', or \'c\'.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n        >>> triangle.line(\'a\')\n        Line(point=Point([1, 0]), direction=Vector([-1,  1]))\n\n        >>> triangle.line(\'b\')\n        Line(point=Point([0, 1]), direction=Vector([ 0, -1]))\n\n        >>> triangle.line(\'c\')\n        Line(point=Point([0, 0]), direction=Vector([1, 0]))\n\n        >>> triangle.line(\'d\')\n        Traceback (most recent call last):\n        ...\n        ValueError: The side must be \'a\', \'b\', or \'c\'.\n\n        """"""\n        if side == \'a\':\n            point_1, point_2 = self.point_b, self.point_c\n\n        elif side == \'b\':\n            point_1, point_2 = self.point_c, self.point_a\n\n        elif side == \'c\':\n            point_1, point_2 = self.point_a, self.point_b\n\n        else:\n            raise ValueError(""The side must be \'a\', \'b\', or \'c\'."")\n\n        return Line.from_points(point_1, point_2)\n\n    def length(self, side: str) -> np.float64:\n        """"""\n        Return a side length of the triangle.\n\n        Side \'a\' is the side across from vertex \'A\'.\n        The side length is the distance between vertices \'B\' and \'C\'.\n\n        Parameters\n        ----------\n        side: str\n            \'a\', \'b\', or \'c\'.\n\n        Returns\n        -------\n        np.float64\n            Side length.\n\n        Raises\n        ------\n        ValueError\n            If the side is not \'a\', \'b\', or \'c\'.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n        >>> triangle.length(\'a\').round(3)\n        1.414\n        >>> triangle.length(\'b\')\n        1.0\n        >>> triangle.length(\'c\')\n        1.0\n\n        >>> triangle.length(\'d\')\n        Traceback (most recent call last):\n        ...\n        ValueError: The side must be \'a\', \'b\', or \'c\'.\n\n        """"""\n        return self.line(side).direction.norm()\n\n    @np_float\n    def angle(self, vertex: str) -> float:\n        """"""\n        Return an interior angle of the triangle.\n\n        The angle is in radians.\n\n        Parameters\n        ----------\n        vertex: str\n            \'A\', \'B\', or \'C\'.\n\n        Returns\n        -------\n        np.float64\n            Interior angle.\n\n        Raises\n        ------\n        ValueError\n            If the vertex is not \'A\', \'B\', or \'C\'.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n        >>> triangle.angle(\'A\').round(3)\n        1.571\n        >>> triangle.angle(\'B\').round(3)\n        0.785\n        >>> triangle.angle(\'C\').round(3)\n        0.785\n\n        >>> triangle.angle(\'D\')\n        Traceback (most recent call last):\n        ...\n        ValueError: The vertex must be \'A\', \'B\', or \'C\'.\n\n        """"""\n        a, b, c = self.multiple(\'length\', \'abc\')\n\n        if vertex == \'A\':\n            arg = (b ** 2 + c ** 2 - a ** 2) / (2 * b * c)\n\n        elif vertex == \'B\':\n            arg = (a ** 2 + c ** 2 - b ** 2) / (2 * a * c)\n\n        elif vertex == \'C\':\n            arg = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)\n\n        else:\n            raise ValueError(""The vertex must be \'A\', \'B\', or \'C\'."")\n\n        return math.acos(arg)\n\n    def centroid(self) -> Point:\n        """"""\n        Return the centroid of the triangle.\n\n        Returns\n        -------\n        Point\n            Centroid of the triangle.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).centroid().round(3)\n        Point([0.333, 0.333])\n\n        >>> Triangle([0, 0, 0], [1, 2, 3], [4, 5, 6]).centroid().round(3)\n        Point([1.667, 2.333, 3.   ])\n\n        """"""\n        return Points([self.point_a, self.point_b, self.point_c]).centroid()\n\n    def altitude(self, vertex: str) -> Line:\n        """"""\n        Return the line of an altitude of the triangle.\n\n        An altitude is a line segment through a vertex and perpendicular to the opposite side.\n\n        Parameters\n        ----------\n        vertex: str\n            \'A\', \'B\', or \'C\'.\n\n        Returns\n        -------\n        Line\n            Altitude line.\n\n        Raises\n        ------\n        ValueError\n            If the vertex is not \'A\', \'B\', or \'C\'.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> triangle = Triangle([0, 0], [1, 1], [2, 0])\n\n        >>> triangle.altitude(\'A\')\n        Line(point=Point([0, 0]), direction=Vector([1., 1.]))\n\n        >>> triangle.altitude(\'B\')\n        Line(point=Point([1, 1]), direction=Vector([ 0., -1.]))\n\n        >>> triangle.altitude(\'C\')\n        Line(point=Point([2, 0]), direction=Vector([-1.,  1.]))\n\n        >>> triangle.altitude(\'D\')\n        Traceback (most recent call last):\n        ...\n        ValueError: The vertex must be \'A\', \'B\', or \'C\'.\n\n        """"""\n        if vertex == \'A\':\n            point_proj = self.line(\'a\').project_point(self.point_a)\n            return Line.from_points(self.point_a, point_proj)\n\n        if vertex == \'B\':\n            point_proj = self.line(\'b\').project_point(self.point_b)\n            return Line.from_points(self.point_b, point_proj)\n\n        if vertex == \'C\':\n            point_proj = self.line(\'c\').project_point(self.point_c)\n            return Line.from_points(self.point_c, point_proj)\n\n        raise ValueError(""The vertex must be \'A\', \'B\', or \'C\'."")\n\n    def orthocenter(self) -> Point:\n        """"""\n        Return the orthocenter of the triangle.\n\n        The orthocenter is the intersection point of the three altitudes.\n\n        Returns\n        -------\n        Point\n            Orthocenter of the triangle.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).orthocenter()\n        Point([0., 0.])\n\n        >>> Triangle([0, 0], [1, 2], [2, 0]).orthocenter()\n        Point([1. , 0.5])\n\n        """"""\n        line_alt_a = self.altitude(\'A\')\n        line_alt_b = self.altitude(\'B\')\n\n        return line_alt_a.intersect_line(line_alt_b)\n\n    def classify(self, **kwargs: float) -> str:\n        """"""\n        Classify the triangle as equilateral, isosceles, or scalene.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        str\n            \'equilateral\', \'isosceles\', or \'scalene\'.\n\n        Examples\n        --------\n        >>> import math\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [1, 0], [1, 1]).classify()\n        \'isosceles\'\n\n        >>> Triangle([0, 0], [1, 0], [0, 1]).classify()\n        \'isosceles\'\n\n        >>> Triangle([0, 0], [1, 0], [0, 2]).classify()\n        \'scalene\'\n\n        >>> Triangle([0, 0], [1, 0], [0.5, math.sin(math.pi / 3)]).classify()\n        \'equilateral\'\n\n        This triangle is approximately equilateral.\n\n        >>> triangle = Triangle([0, 0], [1, 0], [0.5, 0.866])\n\n        >>> triangle.classify()\n        \'isosceles\'\n\n        >>> triangle.classify(rel_tol=1e-3)\n        \'equilateral\'\n\n        """"""\n        lengths = self.multiple(\'length\', \'abc\')\n\n        pairs = combinations(lengths, 2)\n        n_pairs_close = sum(math.isclose(a, b, **kwargs) for a, b in pairs)\n\n        if n_pairs_close == 3:\n            return \'equilateral\'\n\n        if n_pairs_close == 1:\n            return \'isosceles\'\n\n        return \'scalene\'\n\n    def is_right(self, **kwargs: float) -> bool:\n        """"""\n        Check if the triangle is a right triangle.\n\n        A right triangle with sides :math:`abc`, satisfies the Pythagorean theorem\n\n        .. math::\n            a^2 + b^2 = c^2\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if the triangle is a right triangle; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Triangle\n\n        >>> Triangle([0, 0], [0, 1], [1, 0]).is_right()\n        True\n\n        >>> Triangle([0, 0], [0, 1], [1, 1]).is_right()\n        True\n\n        >>> Triangle([0, 0], [1, 2], [2, 0]).is_right()\n        False\n\n        This triangle is approximately a right triangle.\n\n        >>> triangle = Triangle([0, 0], [100, 0], [101, 100])\n\n        >>> triangle.is_right()\n        False\n\n        >>> triangle.is_right(rel_tol=1e-2)\n        True\n\n        """"""\n        a, b, c = sorted(self.multiple(\'length\', \'abc\'))\n\n        return math.isclose(a ** 2 + b ** 2, c ** 2, **kwargs)\n\n    def plot_2d(self, ax_2d: Axes, part: str = \'points\', **kwargs: str) -> None:\n        """"""\n        Plot a triangle in 2D.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        part : str, optional\n            Part of the triangle to plot.\n            Either \'points\' or \'lines\' (default \'points\').\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~skspatial.objects.point.plot_2d` or\n            :meth:`~skspatial.objects.line.plot_2d`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from skspatial.objects import Triangle\n\n            >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n            >>> _, ax = plt.subplots()\n\n            >>> triangle.plot_2d(ax, part=\'points\', s=100, zorder=3)\n            >>> triangle.plot_2d(ax, part=\'lines\', c=\'k\')\n\n        """"""\n        if part == \'points\':\n            for point in self.multiple(\'point\', \'ABC\'):\n                point.plot_2d(ax_2d, **kwargs)\n\n        elif part == \'lines\':\n            for line in self.multiple(\'line\', \'abc\'):\n                line.plot_2d(ax_2d, **kwargs)\n\n    def plot_3d(self, ax_3d: Axes3D, part: str = \'points\', **kwargs: str) -> None:\n        """"""\n        Plot a triangle in 3D.\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        part : str, optional\n            Part of the triangle to plot.\n            Either \'points\' or \'lines\' (default \'points\').\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~skspatial.objects.Point.plot_3d` or\n            :meth:`~skspatial.objects.Line.plot_3d`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from skspatial.objects import Triangle\n\n            >>> triangle = Triangle([0, 0], [1, 0], [0, 1])\n\n            >>> _, ax = plt.subplots()\n\n            >>> triangle.plot_2d(ax, part=\'points\', s=100, zorder=3)\n            >>> triangle.plot_2d(ax, part=\'lines\', c=\'k\')\n\n        """"""\n        if part == \'points\':\n            for point in self.multiple(\'point\', \'ABC\'):\n                point.plot_3d(ax_3d, **kwargs)\n\n        elif part == \'lines\':\n            for line in self.multiple(\'line\', \'abc\'):\n                line.plot_3d(ax_3d, **kwargs)\n\n    def plotter(self, **kwargs):\n        """"""Plot the object with keyword arguments.""""""\n        return _plotter(self, **kwargs)\n'"
skspatial/objects/vector.py,25,"b'""""""Module for the Vector class.""""""\n\nfrom __future__ import annotations\n\nimport math\n\nimport numpy as np\nfrom matplotlib.axes import Axes\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfrom skspatial._functions import np_float\nfrom skspatial.objects._base_array import _BaseArray1D\nfrom skspatial.plotting import _connect_points_3d\nfrom skspatial.typing import array_like\n\n\nclass Vector(_BaseArray1D):\n    """"""\n    A vector implemented as a 1D array.\n\n    The array is a subclass of :class:`numpy.ndarray`.\n\n    Parameters\n    ----------\n    array : array_like\n        Input array.\n\n    Attributes\n    ----------\n    dimension : int\n        Dimension of the vector.\n\n    Raises\n    ------\n    ValueError\n        If the array is empty, the values are not finite,\n        or the dimension is not one.\n\n    Examples\n    --------\n    >>> from skspatial.objects import Vector\n\n    >>> vector = Vector([1, 2, 3])\n\n    >>> vector.dimension\n    3\n\n    The object inherits methods from :class:`numpy.ndarray`.\n\n    >>> vector.mean()\n    Vector(2.)\n\n    >>> Vector([])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must not be empty.\n\n    >>> import numpy as np\n\n    >>> Vector([1, 2, np.nan])\n    Traceback (most recent call last):\n    ...\n    ValueError: The values must all be finite.\n\n    >>> Vector([[1, 2], [3, 4]])\n    Traceback (most recent call last):\n    ...\n    ValueError: The array must be 1D.\n\n    """"""\n\n    @classmethod\n    def from_points(cls, point_a: array_like, point_b: array_like) -> Vector:\n        """"""\n        Instantiate a vector from point A to point B.\n\n        Parameters\n        ----------\n        point_a, point_b : array_like\n            Points defining the vector.\n\n        Returns\n        -------\n        Vector\n            Vector from point A to point B.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector.from_points([0, 0], [1, 0])\n        Vector([1, 0])\n\n        >>> Vector.from_points([5, 2], [-2, 8])\n        Vector([-7,  6])\n\n        >>> Vector.from_points([3, 1, 1], [7, 7, 0])\n        Vector([ 4,  6, -1])\n\n        """"""\n        return cls(np.subtract(point_b, point_a))\n\n    def norm(self, **kwargs) -> np.float64:\n        """"""\n        Return the norm of the vector.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`numpy.linalg.norm`.\n\n        Returns\n        -------\n        np.float64\n            Norm of the vector.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> vector = Vector([1, 2, 3])\n\n        >>> vector.norm().round(3)\n        3.742\n\n        >>> vector.norm(ord=1)\n        6.0\n\n        >>> vector.norm(ord=0)\n        3.0\n\n        """"""\n        return np.linalg.norm(self, **kwargs)\n\n    def unit(self) -> Vector:\n        """"""\n        Return the unit vector in the same direction as the vector.\n\n        A unit vector is a vector with a magnitude of one.\n\n        Returns\n        -------\n        Vector\n            Unit vector.\n\n        Raises\n        ------\n        ValueError\n            If the magnitude of the vector is zero.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).unit()\n        Vector([1., 0.])\n\n        >>> Vector([-20, 0]).unit()\n        Vector([-1.,  0.])\n\n        >>> Vector([1, 1]).unit().round(3)\n        Vector([0.707, 0.707])\n\n        >>> Vector([1, 1, 1]).unit().round(3)\n        Vector([0.577, 0.577, 0.577])\n\n        >>> Vector([0, 0]).unit()\n        Traceback (most recent call last):\n        ...\n        ValueError: The magnitude must not be zero.\n\n        """"""\n        magnitude = self.norm()\n\n        if magnitude == 0:\n            raise ValueError(""The magnitude must not be zero."")\n\n        return self / magnitude\n\n    def is_zero(self, **kwargs: float) -> bool:\n        """"""\n        Check if the vector is the zero vector.\n\n        The zero vector in n dimensions is the vector containing n zeros.\n\n        Parameters\n        ----------\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if vector is the zero vector; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([0, 0]).is_zero()\n        True\n        >>> Vector([1, 0]).is_zero()\n        False\n\n        >>> Vector([0, 0, 1e-4]).is_zero()\n        False\n        >>> Vector([0, 0, 1e-4]).is_zero(abs_tol=1e-3)\n        True\n\n        """"""\n        return math.isclose(self.dot(self), 0, **kwargs)\n\n    def dot(self, other: array_like) -> np.float64:\n        """"""\n        Return the dot product with another vector.\n\n        Parameters\n        ----------\n        other : array_like\n             Other vector.\n\n        Returns\n        -------\n        {int, float}\n            Dot product of the vectors.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).dot([0, 1])\n        0\n\n        >>> Vector([1, 0]).dot([1, 1])\n        1\n\n        >>> Vector([1.5, 5.3, 3]).dot([-10, 8, 2])\n        33.4\n\n        >>> Vector([1, 2, 3, 4, 5]).dot([-1, -2, -3, -4, -5])\n        -55\n\n        """"""\n        return np.dot(self, other)\n\n    def cross(self, other: array_like) -> Vector:\n        """"""\n        Compute the cross product with another vector.\n\n        Parameters\n        ----------\n        other : array_like\n             Other vector.\n\n        Returns\n        -------\n        Vector\n            3D vector perpendicular to both inputs.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).cross([0, 1])\n        Vector([0, 0, 1])\n\n        >>> Vector([2, 5]).cross([1, 1])\n        Vector([ 0,  0, -3])\n\n        >>> Vector([1, 0]).cross([0, 1])\n        Vector([0, 0, 1])\n\n        >>> Vector([1, 1, 1]).cross([0, 1, 0])\n        Vector([-1,  0,  1])\n\n        """"""\n        # Convert to 3D vectors so that cross product is also 3D.\n        vector_a = self.set_dimension(3)\n        vector_b = Vector(other).set_dimension(3)\n\n        return Vector(np.cross(vector_a, vector_b))\n\n    def cosine_similarity(self, other: array_like) -> np.float64:\n        """"""\n        Return the cosine similarity of the vector with another.\n\n        This is the cosine of the angle between the vectors.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n\n        Returns\n        -------\n        np.float64\n            Cosine similarity.\n\n        Raises\n        ------\n        ValueError\n            If either vector has a magnitude of zero.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).cosine_similarity([0, 1])\n        0.0\n\n        >>> Vector([30, 0]).cosine_similarity([0, 20])\n        0.0\n\n        >>> Vector([1, 0]).cosine_similarity([-1, 0])\n        -1.0\n\n        >>> Vector([1, 0]).cosine_similarity([1, 1]).round(3)\n        0.707\n\n        >>> Vector([0, 0]).cosine_similarity([1, 1])\n        Traceback (most recent call last):\n        ...\n        ValueError: The vectors must have non-zero magnitudes.\n\n        """"""\n        denom = self.norm() * Vector(other).norm()\n\n        if denom == 0:\n            raise ValueError(""The vectors must have non-zero magnitudes."")\n\n        cos_theta = self.dot(other) / denom\n\n        # Ensure that the output is in the range [-1, 1],\n        # so that the angle theta is defined.\n        return np.clip(cos_theta, -1, 1)\n\n    @np_float\n    def angle_between(self, other: array_like) -> float:\n        """"""\n        Return the angle in radians between the vector and another.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n\n        Returns\n        -------\n        np.float64\n            Angle between vectors in radians.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).angle_between([1, 0])\n        0.0\n\n        >>> Vector([1, 1, 1]).angle_between([1, 1, 1])\n        0.0\n\n        >>> angle = Vector([1, 0]).angle_between([1, 1])\n        >>> np.degrees(angle).round()\n        45.0\n\n        >>> angle = Vector([1, 0]).angle_between([-2, 0])\n        >>> np.degrees(angle).round()\n        180.0\n\n        """"""\n        cos_theta = self.cosine_similarity(other)\n\n        return math.acos(cos_theta)\n\n    @np_float\n    def angle_signed(self, other: array_like) -> float:\n        """"""\n        Return the signed angle in radians between the vector and another.\n\n        The vectors must be 2D.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n\n        Returns\n        -------\n        np.float64\n            Signed angle between vectors in radians.\n\n        Raises\n        ------\n        ValueError\n            If the vectors are not 2D.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([1, 0]).angle_signed([1, 0])\n        0.0\n\n        >>> np.degrees(Vector([1, 0]).angle_signed([0, 1]))\n        90.0\n\n        >>> np.degrees(Vector([1, 0]).angle_signed([0, -1]))\n        -90.0\n\n        >>> Vector([1, 0, 0]).angle_signed([0, -1, 0])\n        Traceback (most recent call last):\n        ...\n        ValueError: The vectors must be 2D.\n\n        """"""\n        if not (self.dimension == 2 and Vector(other).dimension == 2):\n            raise ValueError(""The vectors must be 2D."")\n\n        dot = self.dot(other)\n        det = np.linalg.det([self, other])\n\n        return math.atan2(det, dot)\n\n    def is_perpendicular(self, other: array_like, **kwargs: float) -> bool:\n        r""""""\n        Check if the vector is perpendicular to another.\n\n        Two vectors :math:`u` and :math:`v` are perpendicular if\n\n        .. math::\n            u \\cdot v = 0\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if the vector is perpendicular; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([0, 1]).is_perpendicular([1, 0])\n        True\n\n        >>> Vector([-1, 5]).is_perpendicular([3, 4])\n        False\n\n        >>> Vector([2, 0, 0]).is_perpendicular([0, 0, 2])\n        True\n\n        The zero vector is perpendicular to all vectors.\n\n        >>> Vector([0, 0, 0]).is_perpendicular([1, 2, 3])\n        True\n\n        """"""\n        return math.isclose(self.dot(other), 0, **kwargs)\n\n    def is_parallel(self, other: array_like, **kwargs: float) -> bool:\n        r""""""\n        Check if the vector is parallel to another.\n\n        Two nonzero vectors :math:`u` and :math:`v` are parallel if\n\n        .. math::\n            \\texttt{abs}(\\texttt{cosine_similarity}(u, v)) = 1\n\n        The zero vector is parallel to all vectors.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n        kwargs : dict, optional\n            Additional keywords passed to :func:`math.isclose`.\n\n        Returns\n        -------\n        bool\n            True if the vector is parallel; false otherwise.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([0, 1]).is_parallel([1, 0])\n        False\n\n        >>> Vector([1, 1]).is_parallel([1, 1])\n        True\n\n        >>> Vector([-1, 5]).is_parallel([2, -10])\n        True\n\n        >>> Vector([1, 2, 3]).is_parallel([3, 6, 9])\n        True\n\n        >>> Vector([1, 2, 3, 4]).is_parallel([-2, -4, -6, -8])\n        True\n\n        The zero vector is parallel to all vectors.\n\n        >>> Vector([1, 2, 3]).is_parallel([0, 0, 0])\n        True\n\n        """"""\n        if self.is_zero(**kwargs) or Vector(other).is_zero(**kwargs):\n            # The zero vector is perpendicular to all vectors.\n            return True\n\n        similarity = self.cosine_similarity(other)\n\n        return math.isclose(abs(similarity), 1, **kwargs)\n\n    def side_vector(self, other: array_like) -> np.int64:\n        """"""\n        Find the side of the vector where another vector is directed.\n\n        Both vectors must be 2D.\n\n        Parameters\n        ----------\n        other : array_like\n            Other 2D vector.\n\n        Returns\n        -------\n        np.int64\n            1 if the other vector is to the right.\n            0 if the other is parallel.\n            -1 if the other is to the left.\n\n        Raises\n        ------\n        ValueError\n            If the vectors are not 2D.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> vector_target = Vector([0, 1])\n\n        The vector is parallel to the target vector.\n\n        >>> vector_target.side_vector([0, 2])\n        0\n        >>> vector_target.side_vector([0, -5])\n        0\n\n        The vector is to the right of the target vector.\n\n        >>> vector_target.side_vector([1, 1])\n        1\n        >>> vector_target.side_vector([1, -10])\n        1\n\n        The vector is to the left of the target vector.\n\n        >>> vector_target.side_vector([-3, 4])\n        -1\n\n        The vectors are not 2D.\n\n        >>> Vector([1, 0, 0]).side_vector([1, 2, 3])\n        Traceback (most recent call last):\n        ...\n        ValueError: The vectors must be 2D.\n\n        """"""\n        value_cross = np.cross(other, self)\n\n        if value_cross.ndim != 0:\n            raise ValueError(""The vectors must be 2D."")\n\n        return np.sign(value_cross).astype(int)\n\n    def scalar_projection(self, other: array_like) -> np.float64:\n        """"""\n        Return the scalar projection of an other vector onto the vector.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n\n        Returns\n        -------\n        np.float64\n            Scalar projection.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([0, 1]).scalar_projection([2, 1])\n        1.0\n\n        >>> Vector([-1, -1]).scalar_projection([1, 0]).round(3)\n        -0.707\n\n        >>> Vector([0, 100]).scalar_projection([9, 5])\n        5.0\n\n        >>> Vector([5, 0]).scalar_projection([-10, 3])\n        -10.0\n\n        """"""\n        return self.unit().dot(other)\n\n    def project_vector(self, other: array_like) -> Vector:\n        """"""\n        Project an other vector onto the vector.\n\n        Parameters\n        ----------\n        other : array_like\n            Other vector.\n\n        Returns\n        -------\n        Vector\n            Vector projection.\n\n        Examples\n        --------\n        >>> from skspatial.objects import Vector\n\n        >>> Vector([0, 1]).project_vector([2, 1])\n        Vector([0., 1.])\n\n        >>> Vector([0, 100]).project_vector([2, 1])\n        Vector([0., 1.])\n\n        >>> Vector([0, 1]).project_vector([9, 5])\n        Vector([0., 5.])\n\n        >>> Vector([0, 100]).project_vector([9, 5])\n        Vector([0., 5.])\n\n        """"""\n        return self.dot(other) / self.dot(self) * self\n\n    def plot_2d(self, ax_2d: Axes, point: array_like = (0, 0), scalar: float = 1, **kwargs) -> None:\n        """"""\n        Plot a 2D vector.\n\n        The vector is plotted as an arrow.\n\n        Parameters\n        ----------\n        ax_2d : Axes\n            Instance of :class:`~matplotlib.axes.Axes`.\n        point : array_like, optional\n            Position of the vector tail (default is origin).\n        scalar : {int, float}, optional\n            Value used to scale the vector (default 1).\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~matplotlib.axes.Axes.arrow`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from skspatial.objects import Vector\n\n            >>> _, ax = plt.subplots()\n\n            >>> Vector([1, 1]).plot_2d(ax, point=(-3, 5), scalar=2, head_width=0.5)\n\n            >>> limits = ax.axis([-5, 5, 0, 10])\n\n        """"""\n        x, y = point\n        dx, dy = scalar * self\n\n        ax_2d.arrow(x, y, dx, dy, **kwargs)\n\n    def plot_3d(self, ax_3d: Axes3D, point: array_like = (0, 0, 0), scalar: float = 1, **kwargs) -> None:\n        """"""\n        Plot a 3D vector.\n\n        The vector is plotted by connecting two 3D points\n        (the head and tail of the vector).\n\n        Parameters\n        ----------\n        ax_3d : Axes3D\n            Instance of :class:`~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n        point : array_like, optional\n            Position of the vector tail (default is origin).\n        scalar : {int, float}, optional\n            Value used to scale the vector (default 1).\n        kwargs : dict, optional\n            Additional keywords passed to :meth:`~mpl_toolkits.mplot3d.axes3d.Axes3D.plot`.\n\n        Examples\n        --------\n        .. plot::\n            :include-source:\n\n            >>> import matplotlib.pyplot as plt\n            >>> from mpl_toolkits.mplot3d import Axes3D\n\n            >>> from skspatial.objects import Vector\n\n            >>> fig = plt.figure()\n            >>> ax = fig.add_subplot(111, projection=\'3d\')\n\n            >>> Vector([-1, 1, 1]).plot_3d(ax, point=(1, 2, 3), c=\'r\')\n\n        """"""\n        point_2 = np.array(point) + scalar * self\n\n        _connect_points_3d(ax_3d, point, point_2, **kwargs)\n'"
skspatial/tests/__init__.py,0,b''
skspatial/tests/property/__init__.py,0,b''
skspatial/tests/property/constants.py,0,"b'""""""Constants used for property tests.""""""\n\n# Minimum absolute value of floats.\nFLOAT_MIN = 1e-3\n\n# Absolute tolerance for math.isclose.\nATOL = 1e-6\n\n# Min and max dimensions of arrays.\nDIM_MIN, DIM_MAX = 2, 10\n'"
skspatial/tests/property/strategies.py,0,"b'""""""Custom strategies for property tests.""""""\n\nimport hypothesis.strategies as st\nfrom hypothesis import assume\n\nfrom skspatial.objects import Point, Points, Vector, Line, Plane, Circle, Sphere, Triangle\nfrom .constants import DIM_MIN, DIM_MAX, FLOAT_MIN\n\n\nfloats = st.floats(min_value=-1e4, max_value=1e4).filter(lambda x: x == 0 or abs(x) > FLOAT_MIN)\n\narrays = st.lists(floats, min_size=DIM_MIN, max_size=DIM_MAX)\narrays_nonzero = arrays.filter(lambda array: any(array))\n\nradii = floats.filter(lambda x: x > 0)\n\n\n@st.composite\ndef arrays_fixed(draw, dim=2):\n    """"""\n    Return a strategy which generates 1D arrays with a fixed length.\n\n    Parameters\n    ----------\n    dim : int, optional\n        Dimension (length) of the array (default is 2).\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import arrays_fixed\n\n    >>> find(arrays_fixed(2), lambda x: True)\n    [0.0, 0.0]\n\n    >>> find(arrays_fixed(5), lambda x: True)\n    [0.0, 0.0, 0.0, 0.0, 0.0]\n\n    """"""\n    return draw(st.lists(floats, min_size=dim, max_size=dim))\n\n\n@st.composite\ndef arrays_fixed_nonzero(draw, dim=2):\n    """"""\n    Return a strategy which generates nonzero 1D arrays with a fixed length.\n\n    Parameters\n    ----------\n    dim : int, optional\n        Dimension (length) of the array (default is 2).\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    """"""\n    return draw(arrays_fixed(dim).filter(lambda x: any(x)))\n\n\n@st.composite\ndef points(draw, dim):\n    """"""\n    Return a strategy which generates Point objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import points\n\n    >>> find(points(3), lambda x: True)\n    Point([0., 0., 0.])\n\n    """"""\n    return Point(draw(arrays_fixed(dim)))\n\n\n@st.composite\ndef vectors(draw, dim):\n    """"""\n    Return a strategy which generates Vector objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import vectors\n\n    >>> find(vectors(2), lambda x: True)\n    Vector([0., 0.])\n\n    """"""\n    return Vector(draw(arrays_fixed(dim)))\n\n\n@st.composite\ndef vectors_nonzero(draw, dim):\n    """"""\n    Return a strategy which generates nonzero Vector objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    """"""\n    return Vector(draw(arrays_fixed_nonzero(dim)))\n\n\n@st.composite\ndef multi_points(draw, dim):\n    """"""\n    Return a strategy which generates Points objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import multi_points\n\n    >>> find(multi_points(2), lambda x: len(x) == 3)\n    Points([[0., 0.],\n            [0., 0.],\n            [0., 0.]])\n\n    """"""\n    n_points = draw(st.integers(min_value=1, max_value=50))\n    array_like_2d = [draw(arrays_fixed(dim)) for _ in range(n_points)]\n\n    return Points(array_like_2d)\n\n\n@st.composite\ndef lines_or_planes(draw, LineOrPlane, dim):\n    """"""\n    Return a strategy which generates Line or Plane objects.\n\n    Parameters\n    ----------\n    LineOrPlane : class\n        Line or Plane class.\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import lines_or_planes\n\n    >>> find(lines_or_planes(Line, 2), lambda x: True)\n    Line(point=Point([0., 0.]), direction=Vector([0.   , 0.001]))\n\n    >>> find(lines_or_planes(Plane, 3), lambda x: True)\n    Plane(point=Point([0., 0., 0.]), normal=Vector([0.   , 0.   , 0.001]))\n\n    """"""\n    array_point = draw(arrays_fixed(dim))\n    array_vector = draw(arrays_fixed_nonzero(dim))\n\n    return LineOrPlane(array_point, array_vector)\n\n\n@st.composite\ndef lines(draw, dim):\n    """"""\n    Return a strategy which generates Line objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import lines\n\n    >>> find(lines(dim=4), lambda x: x.direction.min() <= -1)\n    Line(point=Point([0., 0., 0., 0.]), direction=Vector([ 0.,  0.,  0., -1.]))\n\n    """"""\n    return draw(lines_or_planes(Line, dim))\n\n\n@st.composite\ndef planes(draw, dim):\n    """"""\n    Return a strategy which generates Plane objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import planes\n\n    >>> find(planes(dim=3), lambda x: x.normal.norm() >= 5)\n    Plane(point=Point([0., 0., 0.]), normal=Vector([0., 0., 5.]))\n\n    """"""\n    return draw(lines_or_planes(Plane, dim))\n\n\n@st.composite\ndef circles(draw):\n    """"""\n    Return a strategy which generates circles.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import circles\n\n    >>> circle = find(circles(), lambda x: x.radius >= 1)\n    >>> round(circle.radius)\n    1\n\n    """"""\n    return Circle(draw(arrays_fixed(2)), draw(radii))\n\n\n@st.composite\ndef spheres(draw):\n    """"""\n    Return a strategy which generates Circle objects.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import spheres\n\n    >>> sphere = find(spheres(), lambda x: x.radius >= 1)\n    >>> round(sphere.radius)\n    1\n\n    """"""\n    return Sphere(draw(arrays_fixed(3)), draw(radii))\n\n\n@st.composite\ndef triangles(draw, dim):\n    """"""\n    Return a strategy which generates Triangle objects.\n\n    Parameters\n    ----------\n    dim : int\n        Dimension of the object.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import triangles\n\n    >>> find(triangles(dim=2), lambda x: True)\n    Triangle(point_a=Point([0., 0.]), point_b=Point([0.   , 0.001]), point_c=Point([0.001, 0.   ]))\n\n    """"""\n    point_a = draw(arrays_fixed(dim))\n    point_b = draw(arrays_fixed(dim))\n    point_c = draw(arrays_fixed(dim))\n\n    assume(not Points([point_a, point_b, point_c]).are_collinear(tol=0.1))\n\n    return Triangle(point_a, point_b, point_c)\n\n\n@st.composite\ndef consistent_dim(draw, strategies, min_dim=DIM_MIN, max_dim=DIM_MAX):\n    """"""\n    Return a strategy which generates multiple spatial objects with the same dimension.\n\n    Parameters\n    ----------\n    strategies: sequence\n        Sequence of functions that return strategies for spatial objects.\n        The functions must take a dimension argument.\n    min_dim, max_dim: int\n        Min and max dimension of the spatial objects.\n\n    Returns\n    -------\n    LazyStrategy\n        Hypothesis strategy.\n\n    Examples\n    --------\n    >>> from hypothesis import find\n    >>> from .strategies import vectors, lines, planes, consistent_dim\n\n    >>> find(consistent_dim([vectors, planes], min_dim=3), lambda x: True)\n    [Vector([0., 0., 0.]), Plane(point=Point([0., 0., 0.]), normal=Vector([0.   , 0.   , 0.001]))]\n\n    >>> find(consistent_dim(3 * [vectors], min_dim=3), lambda x: True)\n    [Vector([0., 0., 0.]), Vector([0., 0., 0.]), Vector([0., 0., 0.])]\n\n    """"""\n    dim = draw(st.integers(min_value=min_dim, max_value=max_dim))\n\n    return [draw(strategy(dim)) for strategy in strategies]\n'"
skspatial/tests/property/test_comparison.py,0,"b'from hypothesis import given\n\nfrom skspatial.objects import Point, Points, Line\nfrom .constants import ATOL\nfrom .strategies import consistent_dim, arrays_fixed\n\n\n@given(consistent_dim(3 * [arrays_fixed]))\ndef test_are_collinear(arrays):\n\n    array_a, array_b, array_c = arrays\n\n    assert Points([array_a, array_a, array_a]).are_collinear(tol=ATOL)\n    assert Points([array_a, array_a, array_b]).are_collinear(tol=ATOL)\n\n    all_different = not (\n        Point(array_a).is_close(array_b, abs_tol=ATOL) or Point(array_b).is_close(array_c, abs_tol=ATOL)\n    )\n\n    if Points([array_a, array_b, array_c]).are_collinear() and all_different:\n\n        line_ab = Line.from_points(array_a, array_b)\n        line_bc = Line.from_points(array_b, array_c)\n\n        assert line_ab.contains_point(array_c, abs_tol=ATOL)\n        assert line_bc.contains_point(array_a, abs_tol=ATOL)\n\n        assert line_ab.is_coplanar(line_bc)\n'"
skspatial/tests/property/test_fitting.py,0,"b'import hypothesis.strategies as st\nfrom hypothesis import assume, given\n\nfrom skspatial.objects import Points, Line, Plane\nfrom .constants import ATOL\nfrom .strategies import arrays_fixed, lines, planes\n\n\n@given(st.data())\ndef test_best_fit_line(data):\n\n    n_points = data.draw(st.integers(min_value=2, max_value=5))\n    dim = data.draw(st.integers(min_value=2, max_value=4))\n\n    points = Points([data.draw(arrays_fixed(dim)) for _ in range(n_points)])\n    assume(not points.are_concurrent(tol=ATOL))\n\n    line = data.draw(lines(dim))\n    line_fit = Line.best_fit(points)\n\n    error_line = line.sum_squares(points)\n    error_fit = line_fit.sum_squares(points)\n\n    assert error_fit <= error_line + ATOL\n\n\n@given(st.data())\ndef test_best_fit_plane(data):\n\n    n_points = data.draw(st.integers(min_value=3, max_value=5))\n\n    points = Points([data.draw(arrays_fixed(3)) for _ in range(n_points)])\n    assume(not points.are_collinear(tol=ATOL))\n\n    plane_fit = Plane.best_fit(points)\n\n    # The best fit plane could have a higher dimension than the points\n    # (e.g., 2D points have a 3D plane of best fit).\n    # So, we convert the points dimension to that of the best fit plane.\n    dim_fit = plane_fit.dimension\n    points = points.set_dimension(dim_fit)\n\n    plane = data.draw(planes(dim_fit))\n\n    error_plane = plane.sum_squares(points)\n    error_fit = plane_fit.sum_squares(points)\n\n    assert error_fit <= error_plane + ATOL\n'"
skspatial/tests/property/test_measurement.py,0,"b'import math\n\nfrom hypothesis import given\n\nfrom skspatial.measurement import area_triangle, volume_tetrahedron\nfrom skspatial.objects import Points\nfrom .constants import ATOL\nfrom .strategies import consistent_dim, arrays_fixed\n\n\n@given(consistent_dim(3 * [arrays_fixed], max_dim=3))\ndef test_area_triangle(arrays):\n\n    area = area_triangle(*arrays)\n\n    if math.isclose(area, 0):\n        assert Points(arrays).are_collinear(tol=ATOL)\n\n\n@given(consistent_dim(4 * [arrays_fixed], max_dim=3))\ndef test_volume_tetrahedron(arrays):\n\n    volume = volume_tetrahedron(*arrays)\n\n    if math.isclose(volume, 0):\n        assert Points(arrays).are_coplanar(tol=ATOL)\n'"
skspatial/tests/property/test_plotting.py,0,"b'from hypothesis import given\nfrom hypothesis.strategies import integers, tuples\n\nfrom .constants import ATOL\nfrom .strategies import planes, spheres\n\n\nlimits = tuples(integers(-10, 10), integers(-10, 10))\n\n\n@given(planes(dim=3), limits, limits)\ndef test_plane_points(plane, lims_x, lims_y):\n\n    points = plane.to_points(lims_x, lims_y)\n\n    # Test that all the points are on the plane.\n    assert all(plane.contains_point(point, abs_tol=ATOL) for point in points)\n\n\n@given(spheres(), integers(1, 30))\ndef test_sphere_points(sphere, n_angles):\n\n    points = sphere.to_points(n_angles)\n\n    # Test that all the points are on the plane.\n    assert all(sphere.contains_point(point, abs_tol=ATOL) for point in points)\n'"
skspatial/tests/property/test_projection.py,0,"b'import math\n\nimport hypothesis.strategies as st\nimport pytest\nfrom hypothesis import assume, given\n\nfrom skspatial.objects import Vector\nfrom .constants import ATOL, DIM_MIN, DIM_MAX\nfrom .strategies import arrays_fixed, circles, lines, planes, spheres\n\n\n@pytest.mark.parametrize(\'lines_or_planes\', [lines, planes])\n@given(data=st.data())\ndef test_project_point(lines_or_planes, data):\n    """"""Test projecting a point onto a line or plane.""""""\n\n    dim = data.draw(st.integers(min_value=DIM_MIN, max_value=DIM_MAX))\n\n    array = data.draw(arrays_fixed(dim))\n    line_or_plane = data.draw(lines_or_planes(dim))\n\n    point_projected = line_or_plane.project_point(array)\n\n    # The projected point should lie on the line/plane.\n    assert line_or_plane.contains_point(point_projected, abs_tol=ATOL)\n\n    # The vector from the point to its projection\n    # should be perpendicular to the line/plane.\n    vector_projection = Vector.from_points(array, point_projected)\n\n    # The distance from the point to its projection\n    # should equal the distance to the line/plane.\n    distance_projection = vector_projection.norm()\n    distance_to_object = abs(line_or_plane.distance_point(array))\n    assert math.isclose(distance_to_object, distance_projection, rel_tol=1e-6)\n\n    # The distance of the projection should be the\n    # shortest distance from the point to the object.\n    distance_points = line_or_plane.point.distance_point(array)\n    assert distance_projection < distance_points or math.isclose(distance_projection, distance_points)\n\n\n@pytest.mark.parametrize(\'circles_or_spheres\', [circles, spheres])\n@given(data=st.data())\ndef test_project_point_circle_sphere(circles_or_spheres, data):\n\n    circle_or_sphere = data.draw(circles_or_spheres())\n    array_point = data.draw(arrays_fixed(circle_or_sphere.dimension))\n\n    assume(not circle_or_sphere.point.is_close(array_point))\n\n    point_projected = circle_or_sphere.project_point(array_point)\n\n    assert math.isclose(circle_or_sphere.point.distance_point(point_projected), circle_or_sphere.radius)\n'"
skspatial/tests/property/test_transformation.py,6,"b'import hypothesis.strategies as st\nimport numpy as np\nfrom hypothesis import assume, given\nfrom numpy.testing import assert_array_almost_equal\n\nfrom .constants import ATOL\nfrom .strategies import lines, multi_points\n\n\n@given(st.data())\ndef test_mean_center(data):\n\n    dim = data.draw(st.integers(min_value=2, max_value=5))\n    points = data.draw(multi_points(dim))\n\n    points_centered = points.mean_center()\n\n    # The centroid of the centered points should be the origin.\n    centroid_new = points_centered.centroid()\n    origin = np.zeros(points.dimension)\n\n    assert_array_almost_equal(centroid_new, origin)\n\n\n@given(st.data())\ndef test_normalize_distance(data):\n\n    dim = data.draw(st.integers(min_value=2, max_value=5))\n    points = data.draw(multi_points(dim))\n\n    assume(not np.all(points == 0))\n\n    points_transformed = points.normalize_distance()\n    distances_to_points = np.linalg.norm(points_transformed, axis=1)\n\n    assert np.logical_and(distances_to_points >= 0, distances_to_points <= 1 + ATOL).all()\n\n\n@given(st.data())\ndef test_transform_points_line(data):\n\n    dim = data.draw(st.integers(min_value=2, max_value=5))\n    points = data.draw(multi_points(dim))\n\n    line = data.draw(lines(dim))\n\n    # Transform the points into 1D coordinates.\n    coordinates = line.transform_points(points)\n\n    # Project the points onto the line.\n    points_projected = np.apply_along_axis(line.project_point, 1, points)\n\n    # Find the signed distances from the line point to the projected points.\n    vectors_to_projections = points_projected - line.point\n    direction_unit = line.direction.unit()\n    distances_signed = np.apply_along_axis(direction_unit.dot, 1, vectors_to_projections)\n\n    # The coordinates from the transformation should be equal to the signed distances.\n    assert_array_almost_equal(distances_signed, coordinates)\n'"
skspatial/tests/unit/__init__.py,0,b''
skspatial/tests/unit/test_comparison.py,0,"b'import math\n\nimport pytest\n\nfrom skspatial.objects import Points, Vector, Line, Plane, Circle, Sphere\n\n\n@pytest.mark.parametrize(\n    ""array_u, array_v, bool_expected"",\n    [\n        ([1, 0], [0, 1], True),\n        ([0, 1], [-1, 0], True),\n        ([0, 1], [-1, 0], True),\n        ([-1, 0], [0, -1], True),\n        ([1, 1], [-1, -1], False),\n        ([1, 1], [1, 1], False),\n        # The zero vector is perpendicular to all vectors.\n        ([0, 0], [-1, 5], True),\n        ([0, 0, 0], [1, 1, 1], True),\n    ],\n)\ndef test_is_perpendicular(array_u, array_v, bool_expected):\n    """"""Test checking if vector u is perpendicular to vector v.""""""\n    vector_u = Vector(array_u)\n\n    assert vector_u.is_perpendicular(array_v) == bool_expected\n\n\n@pytest.mark.parametrize(\n    ""array_u, array_v, bool_expected"",\n    [\n        ([0, 1], [0, 1], True),\n        ([1, 0], [0, 1], False),\n        ([0, 1], [4, 0], False),\n        ([0, 1], [0, 5], True),\n        ([1, 1], [-1, -1], True),\n        ([1, 1], [-5, -5], True),\n        ([0, 1], [0, -1], True),\n        ([0.1, 5, 4], [3, 2, 0], False),\n        ([1, 1, 1, 1], [-2, -2, -2, 4], False),\n        ([1, 1, 1, 1], [-2, -2, -2, -2], True),\n        ([5, 0, -6, 7], [0, 1, 6, 3], False),\n        ([6, 0, 1, 0], [-12, 0, -2, 0], True),\n        # The zero vector is parallel to all vectors.\n        ([0, 0], [1, 1], True),\n        ([5, 2], [0, 0], True),\n        ([5, -3, 2, 6], [0, 0, 0, 0], True),\n    ],\n)\ndef test_is_parallel(array_u, array_v, bool_expected):\n    """"""Test checking if vector u is parallel to vector v.""""""\n    vector_u = Vector(array_u)\n\n    assert vector_u.is_parallel(array_v) == bool_expected\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, value_expected"",\n    [\n        ([0, 1], [0, 1], 0),\n        ([0, 1], [0, 9], 0),\n        ([0, 1], [0, -20], 0),\n        ([0, 1], [1, 1], 1),\n        ([0, 1], [38, 29], 1),\n        ([0, 1], [1, 0], 1),\n        ([0, 1], [1, -100], 1),\n        ([0, 1], [1, -100], 1),\n        ([0, 1], [-1, 1], -1),\n        ([0, 1], [-1, 20], -1),\n        ([0, 1], [-1, -20], -1),\n        ([0, 1], [-5, 50], -1),\n        ([0], [1], None),\n        ([0, 0, 0], [1, 1, 1], None),\n        ([0, 0, 0, 0], [1, 1, 1, 1], None),\n    ],\n)\ndef test_side_vector(array_a, array_b, value_expected):\n\n    if value_expected is None:\n        with pytest.raises(ValueError):\n            Vector(array_a).side_vector(array_b)\n\n    else:\n        assert Vector(array_a).side_vector(array_b) == value_expected\n\n\n@pytest.mark.parametrize(\n    ""line, point, value_expected"",\n    [\n        (Line([0, 0], [0, 1]), [0, 0], 0),\n        (Line([0, 0], [0, 1]), [1, 0], 1),\n        (Line([0, 0], [0, 1]), [1, 1], 1),\n        (Line([0, 0], [0, 1]), [1, 10], 1),\n        (Line([0, 0], [0, 1]), [1, -10], 1),\n        (Line([0, 0], [0, 1]), [-1, 0], -1),\n        (Line([0, 0], [0, 1]), [-1, 1], -1),\n        (Line([0, 0], [0, 1]), [-1, -25], -1),\n    ],\n)\ndef test_side_point_line(line, point, value_expected):\n\n    assert line.side_point(point) == value_expected\n\n\n@pytest.mark.parametrize(\n    ""plane, point, value_expected"",\n    [\n        (Plane([0, 0], [1, 1]), [2, 2], 1),\n        (Plane([0, 0], [1, 1]), [0, 0], 0),\n        (Plane([0, 1], [1, 1]), [0, 0], -1),\n        (Plane([0, 0, 0], [1, 0, 0]), [0, 0, 0], 0),\n        (Plane([0, 0, 0], [1, 0, 0]), [1, 0, 0], 1),\n        (Plane([0, 0, 0], [1, 0, 0]), [-1, 0, 0], -1),\n        (Plane([0, 0, 0], [1, 0, 0]), [25, 53, -105], 1),\n        (Plane([0, 0, 0], [1, 0, 0]), [-2, 53, -105], -1),\n        (Plane([0, 0, 0], [1, 0, 0]), [0, 38, 19], 0),\n        (Plane([0, 0, 0], [1, 0, 0]), [0, 101, -45], 0),\n        (Plane([0, 0, 0], [-1, 0, 0]), [1, 0, 0], -1),\n        (Plane([5, 0, 0], [1, 0, 0]), [1, 0, 0], -1),\n    ],\n)\ndef test_side_point_plane(plane, point, value_expected):\n\n    assert plane.side_point(point) == value_expected\n\n\n@pytest.mark.parametrize(\n    ""points, bool_expected"",\n    [\n        ([[0, 0], [0, 0], [0, 0]], True),\n        ([[1, 0], [1, 0], [1, 0]], True),\n        ([[0, 0], [0, 1], [0, 2]], True),\n        ([[0, 0], [0, 1], [1, 2]], False),\n        ([[0, 1], [0, 0], [0, 2]], True),\n        ([[0, 0], [-1, 0], [10, 0]], True),\n        ([[0, 0], [1, 1], [2, 2], [-4, -4], [5, 5]], True),\n        ([[0, 0, 0], [1, 1, 1], [2, 2, 2]], True),\n        ([[0, 0, 0], [1, 1, 1], [2, 2, 2.5]], False),\n        ([[0, 0, 0], [1, 1, 0], [2, 2, 0], [-4, -4, 10], [5, 5, 0]], False),\n    ],\n)\ndef test_are_collinear(points, bool_expected):\n    """"""Test checking if multiple points are collinear.""""""\n\n    assert Points(points).are_collinear() == bool_expected\n\n\n@pytest.mark.parametrize(\n    ""line_a, line_b, bool_expected"",\n    [\n        (Line([0, 0], [1, 1]), Line([0, 0], [0, 1]), True),\n        (Line([-6, 7], [5, 90]), Line([1, 4], [-4, 5]), True),\n        (Line([0, 0, 1], [1, 1, 0]), Line([0, 0, 0], [0, 1, 0]), False),\n        (Line([0, 0, 1], [1, 1, 0]), Line([0, 0, 1], [0, 1, 0]), True),\n        (Line([0, 0, 1], [1, 0, 1]), Line([0, 0, 1], [2, 0, 2]), True),\n        (Line([0, 0, 1], [1, 0, 1]), Plane([0, 0, 1], [2, 0, 2]), None),\n    ],\n)\ndef test_is_coplanar(line_a, line_b, bool_expected):\n    """"""Test checking if two lines are coplanar.""""""\n\n    if bool_expected is None:\n        with pytest.raises(TypeError, match=""The input must also be a line.""):\n            line_a.is_coplanar(line_b)\n\n    else:\n        assert line_a.is_coplanar(line_b) == bool_expected\n\n\n@pytest.mark.parametrize(\n    ""circle, point, bool_expected"",\n    [\n        (Circle([0, 0], 1), [1, 0], True),\n        (Circle([0, 0], 1), [0, 1], True),\n        (Circle([0, 0], 1), [-1, 0], True),\n        (Circle([0, 0], 1), [0, -1], True),\n        (Circle([0, 0], 1), [0, 0], False),\n        (Circle([0, 0], 1), [1, 1], False),\n        (Circle([0, 0], 2), [1, 0], False),\n        (Circle([1, 0], 1), [1, 0], False),\n        (Circle([0, 0], math.sqrt(2)), [1, 1], True),\n    ],\n)\ndef test_circle_contains_point(circle, point, bool_expected):\n\n    assert circle.contains_point(point) == bool_expected\n\n\n@pytest.mark.parametrize(\n    ""sphere, point, bool_expected"",\n    [\n        (Sphere([0, 0, 0], 1), [1, 0, 0], True),\n        (Sphere([0, 0, 0], 1), [0, 1, 0], True),\n        (Sphere([0, 0, 0], 1), [0, 0, 1], True),\n        (Sphere([0, 0, 0], 1), [-1, 0, 0], True),\n        (Sphere([0, 0, 0], 1), [0, -1, 0], True),\n        (Sphere([0, 0, 0], 1), [0, 0, -1], True),\n        (Sphere([0, 0, 0], 1), [1, 1, 0], False),\n        (Sphere([1, 0, 0], 1), [1, 0, 0], False),\n        (Sphere([1, 0, 0], 1), [2, 0, 0], True),\n        (Sphere([0, 0, 0], 2), [0, 2, 0], True),\n        (Sphere([0, 0, 0], math.sqrt(3)), [1, 1, 1], True),\n    ],\n)\ndef test_sphere_contains_point(sphere, point, bool_expected):\n\n    assert sphere.contains_point(point) == bool_expected\n'"
skspatial/tests/unit/test_fitting.py,1,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.objects import Line, Plane, Points\n\n\n@pytest.mark.parametrize(\n    ""line, points, error_expected"",\n    [\n        (Line([0, 0], [1, 0]), [[0, 0], [10, 0]], 0),\n        (Line([0, 0], [5, 0]), [[0, 0], [0, 1]], 1),\n        (Line([0, 0], [1, 0]), [[0, 1], [0, -1]], 2),\n        (Line([0, 0], [1, 0]), [[0, 5]], 25),\n        (Line([0, 0], [1, 0]), [[0, 3], [0, -2]], 13),\n        (Line([0, 0], [-20, 0]), [[1, 3], [2, -2], [3, -5]], 38),\n    ],\n)\ndef test_sum_squares_line(line, points, error_expected):\n\n    error = line.sum_squares(points)\n    assert math.isclose(error, error_expected)\n\n\n@pytest.mark.parametrize(\n    ""plane, points, error_expected"",\n    [\n        (Plane([0, 0, 0], [0, 0, 1]), [[25, 3, 0], [-6, 5, 0]], 0),\n        (Plane([25, 9, 0], [0, 0, 1]), [[25, 3, 0], [-6, 5, 0]], 0),\n        (Plane([25, 9, -2], [0, 0, 1]), [[25, 3, 0], [-6, 5, 0]], 8),\n        (Plane([0, 0, 0], [0, 0, 1]), [[25, 3, 2], [-6, 5, 0]], 4),\n        (Plane([0, 0, 0], [0, 0, 5]), [[25, 3, 2], [-6, 5, 0]], 4),\n        (Plane([0, 0, 0], [0, 0, -5]), [[25, 3, 2], [-6, 5, 0]], 4),\n    ],\n)\ndef test_sum_squares_plane(plane, points, error_expected):\n\n    error = plane.sum_squares(points)\n    assert math.isclose(error, error_expected)\n\n\n@pytest.mark.parametrize(\n    ""points, line_expected"",\n    [\n        ([[0, 0], [1, 0]], Line([0.5, 0], [1, 0])),\n        ([[1, 0], [0, 0]], Line([0.5, 0], [-1, 0])),\n        ([[0, 0], [10, 0]], Line([5, 0], [1, 0])),\n        ([[0, 0], [-10, 0]], Line([-5, 0], [-1, 0])),\n        ([[0, 0], [1, 1], [2, 2]], Line([1, 1], [1, 1])),\n        ([[2, 2], [1, 1], [0, 0]], Line([1, 1], [-1, -1])),\n        ([[0, 0], [0, 1], [1, 0], [1, 1]], Line([0.5, 0.5], [1, 0])),\n    ],\n)\ndef test_best_fit_line(points, line_expected):\n\n    line_fit = Line.best_fit(np.array(points))\n\n    assert line_fit.is_close(line_expected)\n    assert line_fit.point.is_close(line_expected.point)\n\n\n@pytest.mark.parametrize(\n    ""points, plane_expected"",\n    [\n        # The points are coplanar.\n        ([[0, 0], [1, 1], [0, 2]], Plane([1 / 3, 1, 0], [0, 0, 1])),\n        ([[0, 0], [0, 1], [1, 0], [1, 1]], Plane([0.5, 0.5, 0], [0, 0, 1])),\n        ([[0, 0, 0], [1, 0, 0], [0, 0, 1]], Plane([1 / 3, 0, 1 / 3], [0, 1, 0])),\n        ([[1, 0, 0], [-1, 0, 0], [1, 1, 1], [-1, 1, 1]], Plane([0, 0.5, 0.5], [0, 1, -1])),\n        ([[1, 0, 1], [1, 1, 1], [-1, 0, -1], [-1, 1, -1]], Plane([0, 0.5, 0], [1, 0, -1])),\n        ([[1, 0, 1], [1, 1, 1], [-1, 0, -1], [-1, 1, -1], [0, 0, 0]], Plane([0, 0.4, 0], [1, 0, -1])),\n        # The points are not coplanar.\n        ([[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]], Plane([0.25, 0.25, 0.25], [1, 1, 1])),\n        (\n            [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]],\n            Plane([0.5, 0.5, 0.5], [0, 1, 0]),\n        ),\n    ],\n)\ndef test_best_fit_plane(points, plane_expected):\n\n    points = Points(points).set_dimension(3)\n    plane_fit = Plane.best_fit(points)\n\n    assert plane_fit.is_close(plane_expected)\n    assert plane_fit.point.is_close(plane_expected.point)\n\n\n@pytest.mark.parametrize(\n    ""points"",\n    [\n        # There are fewer than two points.\n        [[]],\n        [[0, 0]],\n        [[0, 0, 0]],\n    ],\n)\ndef test_best_fit_line_failure(points):\n\n    with pytest.raises(Exception):\n        Line.best_fit(points)\n\n\n@pytest.mark.parametrize(\n    ""points"",\n    [\n        # The points are collinear.\n        [[0, 0], [1, 0]],\n        [[0, 0], [2, 5]],\n        [[0, 0], [1, 0], [1, 0]],\n        [[0, 0], [1, 1], [2, 2]],\n        [[0, 0, 0], [1, 1, 1], [-10, -10, -10]],\n    ],\n)\ndef test_best_fit_plane_failure(points):\n\n    with pytest.raises(Exception):\n        Plane.best_fit(points)\n'"
skspatial/tests/unit/test_intersection.py,4,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.objects import Line, Plane, Circle, Sphere\n\n\n@pytest.mark.parametrize(\n    ""line_a, line_b, array_expected"",\n    [\n        (Line([0, 0], [1, 0]), Line([0, 0], [1, 1]), [0, 0]),\n        (Line([0, 0], [1, 0]), Line([5, 5], [1, 1]), [0, 0]),\n        (Line([0, 0], [1, 0]), Line([9, 0], [1, 1]), [9, 0]),\n        (Line([0, 0], [1, 1]), Line([4, 0], [1, -1]), [2, 2]),\n        (Line([0, 0, 0], [1, 1, 1]), Line([4, 4, 0], [-1, -1, 1]), [2, 2, 2]),\n    ],\n)\ndef test_intersect_lines(line_a, line_b, array_expected):\n\n    point_intersection = line_a.intersect_line(line_b)\n    assert point_intersection.is_close(array_expected)\n\n\n@pytest.mark.parametrize(\n    ""line_a, line_b"",\n    [\n        (Line([0, 0], [1, 0]), Line([0, 0], [1, 0])),\n        (Line([0, 0], [1, 0]), Line([5, 5], [1, 0])),\n        (Line([0, 0], [0, 1]), Line([0, 0], [0, 5])),\n        (Line([0, 0], [1, 0]), Line([0, 0], [-1, 0])),\n        (Line([0, 0], [1, 0]), Line([5, 5], [-1, 0])),\n        (Line([0, 0, 0], [1, 1, 1]), Line([0, 1, 0], [-1, 0, 0])),\n    ],\n)\ndef test_intersect_lines_failure(line_a, line_b):\n\n    with pytest.raises(Exception):\n        line_a.intersect_line(line_b)\n\n\n@pytest.mark.parametrize(\n    ""line, plane, array_expected"",\n    [\n        (Line([0, 0, 0], [1, 0, 0]), Plane([0, 0, 0], [1, 0, 0]), [0, 0, 0]),\n        (Line([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 0, 1]), [0, 0, 0]),\n        (Line([5, -3, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 0, 1]), [5, -3, 0]),\n    ],\n)\ndef test_intersect_line_plane(line, plane, array_expected):\n\n    point_intersection = plane.intersect_line(line)\n    assert point_intersection.is_close(array_expected)\n\n\n@pytest.mark.parametrize(\n    ""line, plane"",\n    [\n        (Line([0, 0, 0], [1, 0, 0]), Plane([0, 0, 0], [0, 0, 1])),\n        (Line([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [1, 0, 0])),\n        (Line([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 1, 0])),\n    ],\n)\ndef test_intersect_line_plane_failure(line, plane):\n\n    with pytest.raises(Exception):\n        plane.intersect_line(line)\n\n\n@pytest.mark.parametrize(\n    ""plane_a, plane_b, line_expected"",\n    [\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [1, 0, 0]), Line([0, 0, 0], [0, 1, 0])),\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 1], [1, 0, 1]), Line([1, 0, 0], [0, 1, 0])),\n        (Plane([0, 0, 0], [-1, 1, 0]), Plane([8, 0, 0], [1, 1, 0]), Line([4, 4, 0], [0, 0, -1])),\n    ],\n)\ndef test_intersect_planes(plane_a, plane_b, line_expected):\n\n    line_intersection = plane_a.intersect_plane(plane_b)\n    assert line_intersection.is_close(line_expected)\n\n\n@pytest.mark.parametrize(\n    ""plane_a, plane_b"",\n    [\n        (Plane([0, 0, 0], [1, 0, 0]), Plane([0, 0, 0], [1, 0, 0])),\n        (Plane([1, 0, 0], [1, 0, 0]), Plane([0, 0, 0], [1, 0, 0])),\n        (Plane([0, 0, 5], [0, 0, 1]), Plane([4, 2, 4], [0, 0, 3])),\n        (Plane([0, 0, -5], [0, 0, 1]), Plane([4, 2, 4], [0, 0, 3])),\n    ],\n)\ndef test_intersect_planes_failure(plane_a, plane_b):\n\n    with pytest.raises(Exception):\n        plane_a.intersect_plane(plane_b)\n\n\n@pytest.mark.parametrize(\n    ""circle, line, point_a_expected, point_b_expected"",\n    [\n        (Circle([0, 0], 1), Line([0, 0], [1, 0]), [-1, 0], [1, 0]),\n        (Circle([0, 0], 1), Line([0, 0], [0, 1]), [0, -1], [0, 1]),\n        (Circle([0, 0], 1), Line([0, 1], [1, 0]), [0, 1], [0, 1]),\n        (Circle([0, 0], 1), Line([0, 0.5], [1, 0]), [-math.sqrt(3) / 2, 0.5], [math.sqrt(3) / 2, 0.5]),\n        (Circle([1, 0], 1), Line([0, 0], [1, 0]), [0, 0], [2, 0]),\n    ],\n)\ndef test_intersect_circle_line(circle, line, point_a_expected, point_b_expected):\n\n    point_a, point_b = circle.intersect_line(line)\n\n    assert point_a.is_close(point_a_expected)\n    assert point_b.is_close(point_b_expected)\n\n\n@pytest.mark.parametrize(\n    ""circle, line"",\n    [\n        # The circle does not intersect the line.\n        (Circle([0, 0], 1), Line([0, 2], [1, 0])),\n        (Circle([0, 0], 1), Line([0, -2], [1, 0])),\n        (Circle([0, 0], 1), Line([2, 0], [0, 1])),\n        (Circle([0, 0], 1), Line([3, 0], [1, 1])),\n        (Circle([1.5, 0], 1), Line([0, 0], [1, 0])),\n    ],\n)\ndef test_intersect_circle_line_failure(circle, line):\n\n    with pytest.raises(Exception):\n        circle.intersect_line(line)\n\n\n@pytest.mark.parametrize(\n    ""sphere, line, point_a_expected, point_b_expected"",\n    [\n        (Sphere([0, 0, 0], 1), Line([0, 0, 0], [1, 0, 0]), [-1, 0, 0], [1, 0, 0]),\n        (\n            Sphere([0, 0, 0], 1),\n            Line([0, 0, 0], [1, 1, 0]),\n            -math.sqrt(2) / 2 * np.array([1, 1, 0]),\n            math.sqrt(2) / 2 * np.array([1, 1, 0]),\n        ),\n        (\n            Sphere([0, 0, 0], 1),\n            Line([0, 0, 0], [1, 1, 1]),\n            -math.sqrt(3) / 3 * np.ones(3),\n            math.sqrt(3) / 3 * np.ones(3),\n        ),\n        (Sphere([1, 0, 0], 1), Line([0, 0, 0], [1, 0, 0]), [0, 0, 0], [2, 0, 0]),\n        (Sphere([0, 0, 0], 1), Line([1, 0, 0], [0, 0, 1]), [1, 0, 0], [1, 0, 0]),\n    ],\n)\ndef test_intersect_sphere_line(sphere, line, point_a_expected, point_b_expected):\n\n    point_a, point_b = sphere.intersect_line(line)\n\n    assert point_a.is_close(point_a_expected)\n    assert point_b.is_close(point_b_expected)\n\n\n@pytest.mark.parametrize(\n    ""sphere, line"",\n    [\n        (Sphere([0, 0, 0], 1), Line([0, 0, 2], [1, 0, 0])),\n        (Sphere([0, 0, 0], 1), Line([0, 0, -2], [1, 0, 0])),\n        (Sphere([0, 2, 0], 1), Line([0, 0, 0], [1, 0, 0])),\n        (Sphere([0, -2, 0], 1), Line([0, 0, 0], [1, 0, 0])),\n        (Sphere([5, 0, 0], 1), Line([0, 0, 0], [1, 1, 1])),\n    ],\n)\ndef test_intersect_sphere_line_failure(sphere, line):\n\n    with pytest.raises(Exception):\n        sphere.intersect_line(line)\n'"
skspatial/tests/unit/test_measurement.py,18,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.measurement import area_triangle, volume_tetrahedron\nfrom skspatial.objects import Point, Vector, Line, Plane, Circle, Sphere\n\n\n@pytest.mark.parametrize(\n    ""array_u, array_v, similarity_expected"",\n    [\n        ([1, 0], [1, 0], 1),\n        ([1, 0], [0, 1], 0),\n        ([1, 0], [-1, 0], -1),\n        ([1, 0], [0, -1], 0),\n        ([1, 0], [1, 1], math.sqrt(2) / 2),\n        ([1, 0], [-1, 1], -math.sqrt(2) / 2),\n        ([1, 0], [-1, -1], -math.sqrt(2) / 2),\n        ([1, 0], [1, -1], math.sqrt(2) / 2),\n        ([1, 0], [0.5, math.sqrt(3) / 2], 0.5),\n        ([1, 0], [math.sqrt(3) / 2, 0.5], math.sqrt(3) / 2),\n        ([1, 1], [0, 0], None),\n        ([0, 0], [1, 1], None),\n    ],\n)\ndef test_cosine_similarity(array_u, array_v, similarity_expected):\n\n    if similarity_expected is None:\n        with pytest.raises(ValueError, match=""The vectors must have non-zero magnitudes.""):\n            Vector(array_u).cosine_similarity(array_v)\n\n    else:\n        similarity = Vector(array_u).cosine_similarity(array_v)\n        assert math.isclose(similarity, similarity_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_u, array_v, angle_expected"",\n    [\n        ([1, 0], [1, 0], 0),\n        ([1, 0], [math.sqrt(3) / 2, 0.5], np.pi / 6),\n        ([1, 0], [1, 1], np.pi / 4),\n        ([1, 0], [0, 1], np.pi / 2),\n        ([1, 0], [0, -1], np.pi / 2),\n        ([1, 0], [-1, 0], np.pi),\n        ([1, 0, 0], [0, 1, 0], np.pi / 2),\n    ],\n)\ndef test_angle_between(array_u, array_v, angle_expected):\n    """"""Test finding the angle between vectors u and v.""""""\n\n    angle = Vector(array_u).angle_between(array_v)\n    assert math.isclose(angle, angle_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_u, array_v, angle_expected"",\n    [\n        ([1, 0], [1, 0], 0),\n        ([1, 0], [1, 1], np.pi / 4),\n        ([1, 0], [0, 1], np.pi / 2),\n        ([1, 0], [-1, 1], 3 * np.pi / 4),\n        ([1, 0], [-1, 0], np.pi),\n        ([1, 0], [-1, -1], -3 * np.pi / 4),\n        ([1, 0], [0, -1], -np.pi / 2),\n        ([1, 0], [1, -1], -np.pi / 4),\n        ([1, 1], [0, 1], np.pi / 4),\n        ([1, 1], [1, 0], -np.pi / 4),\n        ([0], [0], None),\n        ([1, 1, 1], [1, 0, 0], None),\n        (np.ones(4), np.ones(4), None),\n    ],\n)\ndef test_angle_signed(array_u, array_v, angle_expected):\n\n    if angle_expected is None:\n        with pytest.raises(ValueError, match=""The vectors must be 2D.""):\n            Vector(array_u).angle_signed(array_v)\n\n    else:\n        angle = Vector(array_u).angle_signed(array_v)\n        assert math.isclose(angle, angle_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, dist_expected"",\n    [\n        ([0, 0], [0, 0], 0),\n        ([0, 0], [1, 0], 1),\n        ([0, 0], [-1, 0], 1),\n        ([0, 0], [1, 1], math.sqrt(2)),\n        ([0, 0], [5, 5], 5 * math.sqrt(2)),\n        ([0, 0], [-5, 5], 5 * math.sqrt(2)),\n        ([1, 5, 3], [1, 5, 4], 1),\n    ],\n)\ndef test_distance_points(array_a, array_b, dist_expected):\n\n    point_a = Point(array_a)\n    assert math.isclose(point_a.distance_point(array_b), dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_point, line, dist_expected"",\n    [\n        ([0, 0], Line([0, 0], [1, 0]), 0),\n        ([8, 7], Line([0, 0], [1, 0]), 7),\n        ([20, -3], Line([0, 0], [1, 0]), 3),\n        ([20, -3, 1], Line([0, 0, 0], [1, 0, 0]), math.sqrt(10)),\n    ],\n)\ndef test_distance_point_line(array_point, line, dist_expected):\n\n    assert math.isclose(line.distance_point(array_point), dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""point, plane, dist_signed_expected"",\n    [\n        ([0, 0, 0], Plane([0, 0, 0], [0, 0, 1]), 0),\n        ([50, -67, 0], Plane([0, 0, 0], [0, 0, 1]), 0),\n        ([50, -67, 0], Plane([0, 0, 1], [0, 0, 1]), -1),\n        ([5, 3, 8], Plane([0, 0, 0], [0, 0, 1]), 8),\n        ([5, 3, 7], Plane([0, 0, 0], [0, 0, -50]), -7),\n        ([5, 3, -8], Plane([0, 0, 0], [0, 0, 1]), -8),\n    ],\n)\ndef test_distance_point_plane(point, plane, dist_signed_expected):\n\n    assert math.isclose(plane.distance_point_signed(point), dist_signed_expected)\n    assert math.isclose(plane.distance_point(point), abs(dist_signed_expected))\n\n\n@pytest.mark.parametrize(\n    ""line_a, line_b, dist_expected"",\n    [\n        # The lines intersect.\n        (Line([10, 2], [1, 1]), Line([5, -3], [-1, 0]), 0),\n        (Line([0, 0], [1, 1]), Line([1, 0], [1, 2]), 0),\n        # The lines are parallel.\n        (Line([0, 0], [1, 0]), Line([0, 0], [-1, 0]), 0),\n        (Line([0, 0], [1, 0]), Line([0, 0], [1, 0]), 0),\n        (Line([24, 0], [0, 1]), Line([3, 0], [0, -5]), 21),\n        (Line([0, 0], [1, 1]), Line([1, 0], [1, 1]), math.sqrt(2) / 2),\n        # The lines are skew.\n        (Line([0, 0, 0], [0, 1, 0]), Line([1, 0, 0], [0, -4, 13]), 1),\n    ],\n)\ndef test_distance_lines(line_a, line_b, dist_expected):\n\n    assert math.isclose(line_a.distance_line(line_b), dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""circle, point, dist_expected"",\n    [\n        (Circle([0, 0], 1), [0, 0], 1),\n        (Circle([0, 0], 1), [0.5, 0], 0.5),\n        (Circle([0, 0], 1), [1, 0], 0),\n        (Circle([0, 0], 1), [0, 1], 0),\n        (Circle([0, 0], 1), [-1, 0], 0),\n        (Circle([0, 0], 1), [0, -1], 0),\n        (Circle([0, 0], 1), [2, 0], 1),\n        (Circle([0, 0], 1), [1, 1], math.sqrt(2) - 1),\n        (Circle([1, 1], 1), [0, 0], math.sqrt(2) - 1),\n        (Circle([0, 0], 2), [0, 5], 3),\n    ],\n)\ndef test_distance_circle_point(circle, point, dist_expected):\n\n    assert math.isclose(circle.distance_point(point), dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""sphere, point, dist_expected"",\n    [\n        (Sphere([0, 0, 0], 1), [0, 0, 0], 1),\n        (Sphere([0, 0, 0], 1), [1, 0, 0], 0),\n        (Sphere([0, 0, 0], 1), [0, -1, 0], 0),\n        (Sphere([0, 0, 0], 2), [0, 0, 0], 2),\n        (Sphere([0, 0, 0], 1), [1, 1, 1], math.sqrt(3) - 1),\n        (Sphere([0, 0, 0], 2), [1, 1, 1], 2 - math.sqrt(3)),\n        (Sphere([1, 0, 0], 2), [0, 0, 0], 1),\n    ],\n)\ndef test_distance_plane_point(sphere, point, dist_expected):\n\n    assert math.isclose(sphere.distance_point(point), dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, array_c, area_expected"",\n    [\n        ([0, 0], [1, 0], [0, 1], 0.5),\n        ([0, 0], [1, 1], [2, 0], 1),\n        ([0, 0], [1, 10], [2, 0], 10),\n        ([0, 0], [1, 0], [2, 0], 0),\n        ([0, 0], [-5, -2], [5, 2], 0),\n        ([1, 0, 0], [0, 1, 0], [0, 0, 1], math.sin(np.pi / 3)),\n        ([2, 0, 0], [0, 2, 0], [0, 0, 2], 4 * math.sin(np.pi / 3)),\n    ],\n)\ndef test_area_triangle(array_a, array_b, array_c, area_expected):\n\n    area = area_triangle(array_a, array_b, array_c)\n    assert math.isclose(area, area_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, array_c, array_d, volume_expected"",\n    [\n        ([0, 0], [2, 0], [1, 1], [10, -7], 0),\n        ([0, 0, 0], [2, 0, 0], [1, 1, 0], [0, 0, 1], 1 / 3),\n        ([0, 0, 0], [2, 0, 0], [1, 1, 0], [0, 0, -1], 1 / 3),\n        ([0, 0, 0], [2, 0, 0], [1, 1, 0], [0, 0, 2], 2 / 3),\n        ([0, 0, 0], [2, 0, 0], [1, 1, 0], [0, 0, 3], 1),\n        ([0, 0, 0], [2, 0, 0], [1, 1, 0], [-56, 10, 3], 1),\n        ([0, 1, 1], [0, 1, 5], [0, -5, 7], [0, 5, 2], 0),\n    ],\n)\ndef test_volume_tetrahedron(array_a, array_b, array_c, array_d, volume_expected):\n\n    volume = volume_tetrahedron(array_a, array_b, array_c, array_d)\n    assert math.isclose(volume, volume_expected)\n'"
skspatial/tests/unit/test_plotting.py,0,"b'import pytest\n\nfrom skspatial.objects import Plane, Sphere\n\n\n@pytest.mark.parametrize(\n    ""plane, points_expected"",\n    [\n        (Plane([0, 0, 0], [0, 0, 1]), [[-1, -1, 0], [1, -1, 0], [-1, 1, 0], [1, 1, 0]]),\n        (Plane([1, 0, 0], [0, 0, 1]), [[0, -1, 0], [2, -1, 0], [0, 1, 0], [2, 1, 0]]),\n        (Plane([0, 0, 0], [0, 0, -1]), [[-1, -1, 0], [1, -1, 0], [-1, 1, 0], [1, 1, 0]]),\n        (Plane([0, 0, 0], [0, 0, 5]), [[-1, -1, 0], [1, -1, 0], [-1, 1, 0], [1, 1, 0]]),\n        (Plane([0, 0, 0], [0, 1, 0]), [[-1, 0, -1], [1, 0, -1], [-1, 0, 1], [1, 0, 1]]),\n        (Plane([0, 0, 0], [1, 0, 0]), [[0, -1, -1], [0, 1, -1], [0, -1, 1], [0, 1, 1]]),\n        (Plane([0, 0, 0], [1, 1, 0]), [[-1, 1, -1], [1, -1, -1], [-1, 1, 1], [1, -1, 1]]),\n    ],\n)\ndef test_plane_points(plane, points_expected):\n\n    points = plane.to_points()\n\n    assert points.is_close(points_expected)\n\n\n@pytest.mark.parametrize(\n    ""sphere, n_angles, points_expected"",\n    [\n        (Sphere([0, 0, 0], 1), 1, [[0, 0, 1]]),\n        (Sphere([0, 0, 0], 1), 2, [[0, 0, -1], [0, 0, 1]]),\n        (Sphere([0, 0, 0], 1), 3, [[0, -1, 0], [0, 0, -1], [0, 0, 1], [0, 1, 0]]),\n        (Sphere([0, 0, 0], 2), 3, [[0, -2, 0], [0, 0, -2], [0, 0, 2], [0, 2, 0]]),\n        (Sphere([1, 0, 0], 1), 3, [[1, -1, 0], [1, 0, -1], [1, 0, 1], [1, 1, 0]]),\n        (Sphere([1, 1, 1], 1), 3, [[1, 0, 1], [1, 1, 0], [1, 1, 2], [1, 2, 1]]),\n    ],\n)\ndef test_sphere_points(sphere, n_angles, points_expected):\n\n    points = sphere.to_points(n_angles).round(3).unique()\n\n    assert points.is_close(points_expected)\n'"
skspatial/tests/unit/test_projection.py,4,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.objects import Vector, Line, Plane, Circle, Sphere\n\n\n@pytest.mark.parametrize(\n    ""point, point_line, vector_line, point_expected, dist_expected"",\n    [\n        ([0, 5], [0, 0], [0, 1], [0, 5], 0),\n        ([0, 5], [0, 0], [0, 100], [0, 5], 0),\n        ([1, 5], [0, 0], [0, 100], [0, 5], 1),\n        ([0, 1], [0, 0], [1, 1], [0.5, 0.5], math.sqrt(2) / 2),\n        ([1, 0], [0, 0], [1, 1], [0.5, 0.5], math.sqrt(2) / 2),\n        ([0, 2], [0, 0], [1, 1], [1, 1], math.sqrt(2)),\n        ([-15, 5], [0, 0], [0, 100], [0, 5], 15),\n        ([50, 10], [1, -5], [0, 3], [1, 10], 49),\n    ],\n)\ndef test_project_point_line(point, point_line, vector_line, point_expected, dist_expected):\n    line = Line(point_line, vector_line)\n\n    point_projected = line.project_point(point)\n    distance = line.distance_point(point)\n\n    assert point_projected.is_close(point_expected)\n    assert math.isclose(distance, dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""point, point_plane, normal_plane, point_expected, dist_expected"",\n    [\n        ([0, 0, 0], [0, 0, 0], [0, 0, 1], [0, 0, 0], 0),\n        ([0, 0, 0], [0, 0, 0], [0, 0, -1], [0, 0, 0], 0),\n        ([0, 0, 1], [0, 0, 0], [0, 0, 1], [0, 0, 0], 1),\n        ([0, 0, 1], [0, 0, 0], [0, 0, -1], [0, 0, 0], -1),\n        ([0, 0, 1], [0, 0, 0], [0, 0, 50], [0, 0, 0], 1),\n        ([0, 0, 1], [0, 0, 0], [0, 0, -50], [0, 0, 0], -1),\n        ([0, 0, 5], [0, 0, 0], [0, 0, 50], [0, 0, 0], 5),\n        ([0, 0, 5], [0, 0, 0], [0, 0, -50], [0, 0, 0], -5),\n        ([5, -4, 1], [0, 0, 0], [0, 0, 1], [5, -4, 0], 1),\n    ],\n)\ndef test_project_point_plane(point, point_plane, normal_plane, point_expected, dist_expected):\n    plane = Plane(point_plane, normal_plane)\n\n    point_projected = plane.project_point(point)\n    distance_signed = plane.distance_point_signed(point)\n\n    assert point_projected.is_close(point_expected)\n    assert math.isclose(distance_signed, dist_expected)\n\n\n@pytest.mark.parametrize(\n    ""vector_u, vector_v, vector_expected"",\n    [\n        ([1, 1], [1, 0], [1, 0]),\n        ([1, 5], [1, 0], [1, 0]),\n        ([5, 5], [1, 0], [5, 0]),\n        # Scaling v by a non-zero scalar doesn\'t change the projection.\n        ([0, 1], [0, 1], [0, 1]),\n        ([0, 1], [0, -5], [0, 1]),\n        ([0, 1], [0, 15], [0, 1]),\n        # The projection is the zero vector if u and v are perpendicular.\n        ([1, 0], [0, 1], [0, 0]),\n        ([5, 0], [0, 9], [0, 0]),\n        # The projection of the zero vector onto v is the zero vector.\n        ([0, 0], [0, 1], [0, 0]),\n    ],\n)\ndef test_project_vector(vector_u, vector_v, vector_expected):\n    """"""Test projecting vector u onto vector v.""""""\n\n    vector_u_projected = Vector(vector_v).project_vector(vector_u)\n\n    assert vector_u_projected.is_close(vector_expected)\n\n\n@pytest.mark.parametrize(\n    ""line, vector, vector_expected"",\n    [\n        (Line([0, 0], [1, 0]), [1, 1], [1, 0]),\n        (Line([-56, 72], [1, 0]), [1, 1], [1, 0]),\n        (Line([-56, 72], [200, 0]), [5, 9], [5, 0]),\n        (Line([-56, 72], [200, 0]), [-5, 9], [-5, 0]),\n    ],\n)\ndef test_project_vector_line(line, vector, vector_expected):\n\n    vector_projected = line.project_vector(vector)\n    assert vector_projected.is_close(vector_expected)\n\n\n@pytest.mark.parametrize(\n    ""plane, vector, vector_expected"",\n    [\n        (Plane([0, 0, 0], [0, 0, 1]), [1, 1, 0], [1, 1, 0]),\n        (Plane([0, 0, 0], [0, 0, 1]), [1, 1, 1], [1, 1, 0]),\n        (Plane([0, 0, 0], [0, 0, 1]), [7, -5, 20], [7, -5, 0]),\n        (Plane([0, 0, 0], [0, 0, -10]), [7, -5, 20], [7, -5, 0]),\n    ],\n)\ndef test_project_vector_plane(plane, vector, vector_expected):\n\n    vector_projected = plane.project_vector(vector)\n    assert vector_projected.is_close(vector_expected)\n\n\n@pytest.mark.parametrize(\n    ""circle, point, point_expected"",\n    [\n        (Circle([0, 0], 1), [1, 0], [1, 0]),\n        (Circle([0, 0], 1), [2, 0], [1, 0]),\n        (Circle([0, 0], 1), [-2, 0], [-1, 0]),\n        (Circle([0, 0], 1), [0, 2], [0, 1]),\n        (Circle([0, 0], 1), [0, -2], [0, -1]),\n        (Circle([0, 0], 5), [0, -2], [0, -5]),\n        (Circle([0, 1], 5), [0, -2], [0, -4]),\n        (Circle([0, 0], 1), [1, 1], math.sqrt(2) / 2 * np.ones(2)),\n        (Circle([0, 0], 2), [1, 1], math.sqrt(2) * np.ones(2)),\n    ],\n)\ndef test_project_point_circle(circle, point, point_expected):\n\n    point_projected = circle.project_point(point)\n    assert point_projected.is_close(point_expected)\n\n\n@pytest.mark.parametrize(\n    ""sphere, point, point_expected"",\n    [\n        (Sphere([0, 0, 0], 1), [1, 0, 0], [1, 0, 0]),\n        (Sphere([0, 0, 0], 2), [1, 0, 0], [2, 0, 0]),\n        (Sphere([0, 0, 0], 0.1), [1, 0, 0], [0.1, 0, 0]),\n        (Sphere([-1, 0, 0], 1), [1, 0, 0], [0, 0, 0]),\n        (Sphere([0, 0, 0], 1), [1, 1, 1], math.sqrt(3) / 3 * np.ones(3)),\n        (Sphere([0, 0, 0], 3), [1, 1, 1], math.sqrt(3) * np.ones(3)),\n    ],\n)\ndef test_project_point_sphere(sphere, point, point_expected):\n\n    point_projected = sphere.project_point(point)\n    assert point_projected.is_close(point_expected)\n\n\n@pytest.mark.parametrize(\n    ""circle_or_sphere, point"",\n    [\n        # The point to project cannot be the center of the circle/sphere.\n        (Circle([0, 0], 1), [0, 0]),\n        (Circle([0, 0], 5), [0, 0]),\n        (Circle([7, -1], 5), [7, -1]),\n        (Sphere([0, 0, 0], 1), [0, 0, 0]),\n        (Sphere([0, 0, 0], 5), [0, 0, 0]),\n        (Sphere([5, 2, -6], 5), [5, 2, -6]),\n    ],\n)\ndef test_project_point_circle_sphere_failure(circle_or_sphere, point):\n\n    with pytest.raises(Exception):\n        circle_or_sphere.project_point(point)\n'"
skspatial/tests/unit/test_repr.py,1,"b'import numpy as np\nimport pytest\n\nfrom skspatial.objects import Point, Vector, Points, Line, Plane, Circle, Sphere, Triangle\n\n\n@pytest.mark.parametrize(\n    ""obj_spatial, repr_expected"",\n    [\n        (Point([0]), ""Point([0])""),\n        (Point([0, 0]), ""Point([0, 0])""),\n        (Point([0, 0]), ""Point([0, 0])""),\n        (Point([0.5, 0]), ""Point([0.5, 0. ])""),\n        (Point([-11, 0]), ""Point([-11,   0])""),\n        (Vector([-11, 0]), ""Vector([-11,   0])""),\n        (Vector([-11.0, 0.0]), ""Vector([-11.,   0.])""),\n        (Vector([0, 0]), ""Vector([0, 0])""),\n        (Vector([0.5, 0]), ""Vector([0.5, 0. ])""),\n        (Points([[1.5, 2], [5, 3]]), ""Points([[1.5, 2. ],\\n        [5. , 3. ]])""),\n        (Line([0, 0], [1, 0]), ""Line(point=Point([0, 0]), direction=Vector([1, 0]))""),\n        (Line([-1, 2, 3], [5, 4, 2]), ""Line(point=Point([-1,  2,  3]), direction=Vector([5, 4, 2]))""),\n        (Line(np.zeros(2), [1, 0]), ""Line(point=Point([0., 0.]), direction=Vector([1, 0]))""),\n        (Plane([0, 0], [1, 0]), ""Plane(point=Point([0, 0]), normal=Vector([1, 0]))""),\n        (Plane([-1, 2, 3], [5, 4, 2]), ""Plane(point=Point([-1,  2,  3]), normal=Vector([5, 4, 2]))""),\n        (Circle([0, 0], 1), ""Circle(point=Point([0, 0]), radius=1)""),\n        (Circle([0, 0], 2.5), ""Circle(point=Point([0, 0]), radius=2.5)""),\n        (Sphere([0, 0, 0], 1), ""Sphere(point=Point([0, 0, 0]), radius=1)""),\n        (\n            Triangle([0, 0], [0, 1], [1, 0]),\n            ""Triangle(point_a=Point([0, 0]), point_b=Point([0, 1]), point_c=Point([1, 0]))"",\n        ),\n    ],\n)\ndef test_repr(obj_spatial, repr_expected):\n\n    assert repr(obj_spatial) == repr_expected\n'"
skspatial/tests/unit/test_transformation.py,4,"b'import math\n\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\n\nfrom skspatial.objects import Points, Line\n\n\n@pytest.mark.parametrize(\n    ""array_points, array_centered_expected, centroid_expected"",\n    [\n        ([[0, 1]], [[0, 0]], [0, 1]),\n        ([[1, 1], [2, 2]], [[-0.5, -0.5], [0.5, 0.5]], [1.5, 1.5]),\n        ([[0, 0], [2, 2]], [[-1, -1], [1, 1]], [1, 1]),\n        (\n            [[1, 2], [-1.3, 11], [24, 5], [7, 3]],\n            [[-6.675, -3.25], [-8.975, 5.75], [16.325, -0.25], [-0.675, -2.25]],\n            [7.675, 5.25],\n        ),\n        ([[-2, 0, 2, 5], [4, 1, -3, 2.1]], [[-3, -0.5, 2.5, 1.45], [3, 0.5, -2.5, -1.45]], [1, 0.5, -0.5, 3.55]),\n    ],\n)\ndef test_mean_center(array_points, array_centered_expected, centroid_expected):\n\n    points = Points(array_points)\n    points_centered, centroid = points.mean_center(return_centroid=True)\n\n    assert_array_almost_equal(points_centered, array_centered_expected)\n    assert_array_almost_equal(centroid, centroid_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_points, array_points_expected"",\n    [\n        ([[0, 0], [1, 0]], [[0, 0], [1, 0]]),\n        ([[0, 0], [1, 1]], [[0, 0], np.sqrt(2) / 2 * np.ones(2)]),\n        ([[0, 0], [5, 0], [-1, 0]], [[0, 0], [1, 0], [-0.2, 0]]),\n        (9 * np.ones((3, 3)), np.sqrt(3) / 3 * np.ones((3, 3))),\n    ],\n)\ndef test_normalize_distance(array_points, array_points_expected):\n\n    points_normalized = Points(array_points).normalize_distance()\n\n    assert_array_almost_equal(points_normalized, array_points_expected)\n\n\n@pytest.mark.parametrize(\n    ""line, points, coords_expected"",\n    [\n        (Line([0, 0], [1, 0]), [[1, 0], [2, 0], [3, 0], [4, 0]], [1, 2, 3, 4]),\n        # The point on the line acts as the origin.\n        (Line([3, 0], [1, 0]), [[1, 0], [2, 0], [3, 0], [4, 0]], [-2, -1, 0, 1]),\n        (\n            Line([0, 0], [1, 1]),\n            [[1, 0], [2, 0], [3, 0], [0, 1], [0, 2], [0, 3]],\n            math.sqrt(2) * np.array([0.5, 1, 1.5, 0.5, 1, 1.5]),\n        ),\n        # The magnitude of the direction vector is irrelevant.\n        (\n            Line([0, 0], [3, 3]),\n            [[1, 0], [2, 0], [3, 0], [0, 1], [0, 2], [0, 3]],\n            math.sqrt(2) * np.array([0.5, 1, 1.5, 0.5, 1, 1.5]),\n        ),\n        (Line([0, 0, 0], [1, 0, 0]), [[1, 20, 3], [2, -5, 8], [3, 59, 100], [4, 0, 14]], [1, 2, 3, 4]),\n        (Line([0, 0, 0], [0, 1, 0]), [[1, 20, 3], [2, -5, 8], [3, 59, 100], [4, 0, 14]], [20, -5, 59, 0]),\n    ],\n)\ndef test_transform_points_line(line, points, coords_expected):\n\n    coordinates = line.transform_points(points)\n    assert_array_almost_equal(coordinates, coords_expected)\n'"
skspatial/tests/property/objects/__init__.py,0,b''
skspatial/tests/property/objects/test_array_1d.py,0,"b'""""""Test behaviour of points with vectors.""""""\n\nfrom hypothesis import given\n\nfrom skspatial.objects import Point, Vector\nfrom ..strategies import consistent_dim, arrays_fixed, arrays\n\n\n@given(consistent_dim(2 * [arrays_fixed]))\ndef test_add(arrays):\n\n    array_a, array_b = arrays\n\n    # Add and subtract the array to obtain the same point.\n    assert (Point(array_a) + array_b - array_b).is_close(array_a)\n\n\n@given(arrays)\ndef test_is_close(array):\n\n    vector = Vector(array)\n    point = Point(array)\n\n    assert point.size == vector.size\n\n    assert point.is_close(vector)\n    assert vector.is_close(point)\n\n    assert point.is_close(array)\n    assert vector.is_close(array)\n'"
skspatial/tests/property/objects/test_line.py,0,"b'import math\n\nfrom hypothesis import given\n\nfrom skspatial.objects import Line\nfrom ..constants import ATOL\nfrom ..strategies import consistent_dim, lines, points, vectors_nonzero\n\n\n@given(consistent_dim([points, vectors_nonzero]))\ndef test_from_points(objs):\n\n    point_a, vector = objs\n    point_b = point_a + vector\n\n    line = Line(point_a, vector)\n    line_from_points = Line.from_points(point_a, point_b)\n\n    assert line.is_close(line_from_points, abs_tol=ATOL)\n\n    # The line of best fit should be the same\n    # as the line from two points.\n    line_fit = Line.best_fit([point_a, point_b])\n    assert line_fit.is_close(line_from_points, abs_tol=ATOL)\n\n\n@given(consistent_dim(2 * [lines]))\ndef test_two_lines(lines):\n\n    line_a, line_b = lines\n\n    if line_a.direction.is_parallel(line_b.direction, rel_tol=0, abs_tol=0):\n        # The lines are parallel, so they must be coplanar.\n        assert line_a.is_coplanar(line_b)\n\n    if line_a.is_coplanar(line_b, tol=0) and not line_a.direction.is_parallel(line_b.direction):\n        # The lines are coplanar but not parallel, so they must intersect.\n        distance = line_a.distance_line(line_b)\n        assert math.isclose(distance, 0, abs_tol=ATOL)\n'"
skspatial/tests/property/objects/test_plane.py,0,"b'from hypothesis import assume, given\n\nfrom skspatial.objects import Points, Plane\nfrom ..constants import ATOL\nfrom ..strategies import consistent_dim, arrays_fixed\n\n\n@given(consistent_dim(3 * [arrays_fixed], max_dim=3))\ndef test_from_points(arrays):\n\n    points = Points(arrays)\n    assume(not points.are_collinear(tol=ATOL))\n\n    # The plane must contain each point.\n    plane = Plane.from_points(*points)\n\n    points = points.set_dimension(plane.dimension)\n\n    for point in points:\n        assert plane.contains_point(point, abs_tol=ATOL)\n\n    # The plane of best fit should be the same\n    # as the plane from three points.\n    plane_fit = Plane.best_fit(points)\n    assert plane_fit.is_close(plane, abs_tol=ATOL)\n'"
skspatial/tests/property/objects/test_point.py,0,"b'import math\n\nfrom hypothesis import given\n\nfrom skspatial.objects import Point, Vector\nfrom ..strategies import consistent_dim, arrays_fixed\n\n\n@given(consistent_dim(2 * [arrays_fixed]))\ndef test_add_subtract(arrays):\n\n    array_point, array_vector = arrays\n\n    point = Point(array_point)\n    vector = Vector(array_vector)\n\n    point_2 = point + array_vector\n    assert math.isclose(point.distance_point(point_2), vector.norm())\n\n    point_3 = point_2 - array_vector\n    assert point.is_close(point_3)\n'"
skspatial/tests/property/objects/test_triangle.py,0,"b""from hypothesis import given\n\nfrom ..strategies import triangles\n\n\n@given(triangles(2))\ndef test_orthocenter(triangle):\n\n    point_orthocenter = triangle.orthocenter()\n\n    alt_a = triangle.altitude('A')\n    alt_b = triangle.altitude('B')\n    alt_c = triangle.altitude('C')\n\n    assert all(alt.contains_point(point_orthocenter, abs_tol=0.1) for alt in [alt_a, alt_b, alt_c])\n"""
skspatial/tests/property/objects/test_vector.py,4,"b'import math\n\nimport numpy as np\nimport pytest\nfrom hypothesis import assume, given\n\nfrom skspatial.objects import Point, Vector\nfrom ..constants import ATOL\nfrom ..strategies import consistent_dim, arrays_fixed, arrays_fixed_nonzero, arrays, arrays_nonzero, floats\n\n\n@given(consistent_dim(2 * [arrays_fixed]))\ndef test_from_points(arrays):\n\n    array_a, array_b = arrays\n\n    point_a = Point(array_a)\n    vector_ab = Vector.from_points(array_a, array_b)\n\n    assert (point_a + vector_ab).is_close(array_b)\n\n\n@given(arrays_nonzero)\ndef test_unit(array):\n\n    vector = Vector(array)\n    vector_unit = vector.unit()\n\n    assert math.isclose(vector_unit.norm(), 1)\n    assert (vector.norm() * vector_unit).is_close(array)\n\n    assert vector_unit.is_parallel(vector)\n\n    angle = vector.angle_between(vector_unit)\n    assert math.isclose(angle, 0, abs_tol=ATOL)\n\n\n@given(arrays)\ndef test_add_subtract(array):\n    vector = Vector(array)\n    assert (vector + array - array).is_close(array)\n\n\n@given(arrays_nonzero, floats)\ndef test_scale(array, scalar):\n\n    assume(abs(scalar) > ATOL)\n\n    vector = Vector(array)\n    vector_scaled = scalar * vector\n\n    assert vector_scaled.is_parallel(array)\n\n    angle = vector_scaled.angle_between(array)\n\n    if scalar > 0:\n        assert math.isclose(angle, 0, abs_tol=ATOL)\n    else:\n        assert math.isclose(angle, np.pi, rel_tol=1e-6)\n\n\n@given(consistent_dim(2 * [arrays_fixed_nonzero]))\ndef test_two_vectors(arrays):\n\n    array_a, array_b = arrays\n    vector_a = Vector(array_a)\n\n    is_perpendicular = vector_a.is_perpendicular(array_b)\n    is_parallel = vector_a.is_parallel(array_b)\n\n    # Two non-zero vectors cannot be both perpendicular and parallel.\n    assert not (is_perpendicular and is_parallel)\n\n    angle = vector_a.angle_between(array_b)\n\n    if is_perpendicular:\n        assert math.isclose(angle, np.pi / 2)\n\n    if is_parallel:\n        assert math.isclose(angle, 0, abs_tol=ATOL) or math.isclose(angle, np.pi, rel_tol=1e-6)\n\n    # The zero vector is perpendicular and parallel to any other vector.\n    vector_zero = np.zeros(vector_a.size)\n    assert vector_a.is_perpendicular(vector_zero)\n    assert vector_a.is_parallel(vector_zero)\n\n    # The angle with the zero vector is undefined.\n    with pytest.raises(Exception):\n        vector_a.angle_between(vector_zero)\n\n    # The projection of vector B onto A is parallel to A.\n    vector_b_projected = vector_a.project_vector(array_b)\n    assert vector_a.is_parallel(vector_b_projected)\n\n    # The projection is zero if vectors A and B are perpendicular.\n    if is_perpendicular:\n        assert vector_b_projected.is_zero(abs_tol=ATOL)\n'"
skspatial/tests/unit/objects/__init__.py,0,b''
skspatial/tests/unit/objects/test_array_1d.py,2,"b'""""""Test functionality of objects based on a single 1D NumPy array (Point and Vector).""""""\n\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\n\nfrom skspatial.objects import Point, Vector\n\n\n@pytest.mark.parametrize(""array"", [[1, 0], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]])\ndef test_equality(array):\n\n    assert_array_equal(array, Point(array))\n    assert_array_equal(array, Vector(array))\n    assert_array_equal(array, np.array(array))\n\n\n@pytest.mark.parametrize(""class_spatial"", [Point, Vector])\n@pytest.mark.parametrize(""array"", [[], [np.nan, 0], [1, 1, np.nan], [1, 1, np.inf], [[1], [1]], [[1, 2], [1, 2]]])\ndef test_failure(class_spatial, array):\n\n    with pytest.raises(Exception):\n        class_spatial(array)\n\n\n@pytest.mark.parametrize(""class_spatial"", [Point, Vector])\n@pytest.mark.parametrize(""array, dim_expected"", [([0, 0], 2), ([0, 0, 0], 3), ([0, 0, 0, 0], 4), ([-6, 3, 8, 9], 4)])\ndef test_dimension(class_spatial, array, dim_expected):\n\n    object_spatial = class_spatial(array)\n    assert object_spatial.dimension == dim_expected\n\n\n@pytest.mark.parametrize(""class_spatial"", [Point, Vector])\n@pytest.mark.parametrize(\n    ""array, dim, array_expected"",\n    [\n        ([0, 0], 2, [0, 0]),\n        ([0, 0], 3, [0, 0, 0]),\n        ([0, 0], 5, [0, 0, 0, 0, 0]),\n        ([6, 3, 7], 4, [6, 3, 7, 0]),\n        ([0], 0, None),\n        ([0, 0], 1, None),\n        ([6, 3, 7], 2, None),\n    ],\n)\ndef test_set_dimension(class_spatial, array, dim, array_expected):\n\n    if array_expected is None:\n        with pytest.raises(ValueError, match=""The desired dimension cannot be less than the current dimension.""):\n            class_spatial(array).set_dimension(dim)\n\n    else:\n        object_spatial = class_spatial(array).set_dimension(dim)\n        assert object_spatial.is_close(array_expected)\n'"
skspatial/tests/unit/objects/test_base_line_plane.py,0,"b'import pytest\n\nfrom skspatial.objects import Line, Plane\n\n\n@pytest.mark.parametrize(""class_spatial"", [Line, Plane])\n@pytest.mark.parametrize(\n    ""point, vector, dim_expected"", [([0, 0], [1, 0], 2), ([0, 0, 0], [1, 0, 0], 3), ([0, 0, 0, 0], [1, 0, 0, 0], 4)]\n)\ndef test_dimension(class_spatial, point, vector, dim_expected):\n\n    object_spatial = class_spatial(point, vector)\n    assert object_spatial.dimension == dim_expected\n'"
skspatial/tests/unit/objects/test_circle.py,5,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.objects import Circle\n\n\n@pytest.mark.parametrize(\n    ""point, radius"",\n    [\n        # The point must be 2D.\n        ([0], 1),\n        ([0, 0, 0], 1),\n        ([1, 2, 3], 1),\n        ([0, 0, 0, 0], 1),\n        # The radius must be positive.\n        ([0, 0], 0),\n        ([0, 0], -1),\n        ([0, 0], -5),\n    ],\n)\ndef test_failure(point, radius):\n\n    with pytest.raises(Exception):\n        Circle(point, radius)\n\n\n@pytest.mark.parametrize(\n    ""radius, circumference_expected, area_expected"",\n    [\n        (1, 2 * np.pi, np.pi),\n        (2, 4 * np.pi, 4 * np.pi),\n        (3, 6 * np.pi, 9 * np.pi),\n        (4.5, 9 * np.pi, 20.25 * np.pi),\n        (10, 20 * np.pi, 100 * np.pi),\n    ],\n)\ndef test_circumference_area(radius, circumference_expected, area_expected):\n\n    circle = Circle([0, 0], radius)\n\n    assert math.isclose(circle.circumference(), circumference_expected)\n    assert math.isclose(circle.area(), area_expected)\n'"
skspatial/tests/unit/objects/test_line.py,0,"b'import pytest\nfrom numpy.testing import assert_array_equal\n\nfrom skspatial.objects import Line\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, line_expected"",\n    [\n        ([0, 0], [1, 0], Line([0, 0], [1, 0])),\n        ([0, 0], [1, 1], Line([0, 0], [1, 1])),\n        ([5, 2], [9, 2], Line([5, 2], [4, 0])),\n        ([1, 1], [0, 0], Line([1, 1], [-1, -1])),\n        ([0, 0], [5, 0], Line([0, 0], [5, 0])),\n        ([0, 5, 9, 2], [4, 0, 0, 0], Line([0, 5, 9, 2], [4, -5, -9, -2])),\n    ],\n)\ndef test_from_points(array_a, array_b, line_expected):\n\n    assert Line.from_points(array_a, array_b).is_close(line_expected)\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b"",\n    [\n        # The zero vector cannot be used.\n        ([0, 0], [0, 0]),\n        ([1, 2], [1, 2]),\n        ([-1, 5], [-1, 5]),\n        ([5, 2, 9, 3], [5, 2, 9, 3]),\n    ],\n)\ndef test_from_points_failure(array_a, array_b):\n\n    with pytest.raises(Exception):\n        Line.from_points(array_a, array_b)\n\n\n@pytest.mark.parametrize(\n    ""slope, y_intercept, line_expected"",\n    [\n        (0, 0, Line([0, 0], [1, 0])),\n        (0, 1, Line([0, 1], [1, 0])),\n        (0, 5, Line([0, 5], [1, 0])),\n        (1, 0, Line([0, 0], [1, 1])),\n        (-5, 0, Line([0, 0], [1, -5])),\n        # The slope has the form rise / run.\n        (-2 / 7, 0, Line([0, 0], [7, -2])),\n        (3 / 4, 0, Line([0, 0], [4, 3])),\n        (5 / 4, 0, Line([0, 0], [4, 5])),\n    ],\n)\ndef test_from_slope(slope, y_intercept, line_expected):\n\n    assert Line.from_slope(slope, y_intercept).is_close(line_expected)\n\n\n@pytest.mark.parametrize(\n    ""line, param, array_expected"",\n    [\n        (Line([0, 0], [1, 0]), 0, [0, 0]),\n        (Line([0, 0], [1, 0]), 1, [1, 0]),\n        (Line([0, 0], [1, 0]), 5, [5, 0]),\n        (Line([0, 0], [1, 0]), -8, [-8, 0]),\n        (Line([5, 2, 1], [0, 2, 0]), 0, [5, 2, 1]),\n        (Line([5, 2, 1], [0, 9, 0]), 1, [5, 11, 1]),\n        (Line([5, 2, 1], [0, -9, 0]), 1, [5, -7, 1]),\n        (Line([6, -3, 7, 8], [0, 8, 0, 0]), 1, [6, 5, 7, 8]),\n        (Line([6, -3, 7, 8], [0, 8, 0, 0]), -2, [6, -19, 7, 8]),\n    ],\n)\ndef test_to_point(line, param, array_expected):\n\n    point = line.to_point(t=param)\n\n    assert_array_equal(point, array_expected)\n'"
skspatial/tests/unit/objects/test_line_plane.py,0,"b'""""""Test features related to both the Line and Plane.""""""\n\nimport pytest\n\nfrom skspatial.objects import Line, Plane\n\n\n@pytest.mark.parametrize(""class_spatial"", [Line, Plane])\n@pytest.mark.parametrize(\n    ""point, vector"", [([0, 0], [0, 0]), ([1, 1], [0, 0]), ([1, 1, 1], [0, 0, 0]), ([4, 5, 2, 3], [0, 0, 0, 0])]\n)\ndef test_zero_vector_failure(class_spatial, point, vector):\n\n    with pytest.raises(ValueError, match=""The vector must not be the zero vector.""):\n        class_spatial(point, vector)\n\n\n@pytest.mark.parametrize(""class_spatial"", [Line, Plane])\n@pytest.mark.parametrize(""point, vector"", [([0, 0, 1], [1, 1]), ([0, 0], [1]), ([1], [0, 1])])\ndef test_dimension_failure(class_spatial, point, vector):\n\n    with pytest.raises(ValueError, match=""The point and vector must have the same dimension.""):\n        class_spatial(point, vector)\n\n\n@pytest.mark.parametrize(\n    ""obj_1, obj_2, bool_expected"",\n    [\n        (Line([0, 0], [1, 0]), Line([0, 0], [1, 0]), True),\n        (Line([0, 0], [1, 0]), Line([1, 0], [1, 0]), True),\n        (Line([0, 0], [1, 0]), Line([-5, 0], [1, 0]), True),\n        (Line([0, 0], [1, 0]), Line([-5, 0], [7, 0]), True),\n        (Line([0, 0], [1, 0]), Line([-5, 0], [-20, 0]), True),\n        (Line([0, 0], [1, 0]), Line([-5, 1], [1, 0]), False),\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 0, 1]), True),\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 0, 2]), True),\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [0, 0, -10]), True),\n        (Plane([0, 0, 0], [0, 0, 1]), Plane([0, 0, 0], [1, 0, -10]), False),\n        (Line([0, 0], [1, 0]), Plane([0, 0], [1, 0]), None),\n        (Plane([0, 0], [1, 0]), Line([0, 0], [1, 0]), None),\n    ],\n)\ndef test_is_close(obj_1, obj_2, bool_expected):\n\n    if bool_expected is None:\n        with pytest.raises(TypeError, match=""The input must have the same type as the object.""):\n            obj_1.is_close(obj_2)\n\n    else:\n        assert obj_1.is_close(obj_2) == bool_expected\n'"
skspatial/tests/unit/objects/test_plane.py,0,"b'import pytest\n\nfrom skspatial._functions import _allclose\nfrom skspatial.objects import Plane\n\n\n@pytest.mark.parametrize(\n    ""point_a, point_b, point_c, plane_expected"",\n    [\n        ([0, 0], [1, 0], [0, 1], Plane([0, 0, 0], [0, 0, 1])),\n        # The spacing between the points is irrelevant.\n        ([0, 0], [9, 0], [0, 9], Plane([0, 0, 0], [0, 0, 1])),\n        # The first point is used as the plane point.\n        ([0, 0.1], [1, 0], [0, 1], Plane([0, 0.1, 0], [0, 0, 1])),\n        # The order of points is relevant.\n        ([0, 0], [0, 1], [1, 0], Plane([0, 0, 0], [0, 0, -1])),\n    ],\n)\ndef test_from_points(point_a, point_b, point_c, plane_expected):\n\n    plane = Plane.from_points(point_a, point_b, point_c)\n\n    assert plane.point.is_close(plane_expected.point)\n    assert plane.is_close(plane_expected)\n\n\n@pytest.mark.parametrize(\n    ""point_a, point_b, point_c"",\n    [\n        # The points cannot be collinear.\n        ([0, 0], [0, 0], [0, 0]),\n        ([0, 0], [0, 1], [0, 2]),\n        ([-2, 1], [0, 2], [2, 3]),\n        ([0, 0, 0], [1, 1, 1], [-2, -2, -2]),\n        ([0, 1, 2], [1, 2, 3], [4, 5, 6]),\n    ],\n)\ndef test_from_points_failure(point_a, point_b, point_c):\n\n    with pytest.raises(Exception):\n        Plane.from_points(point_a, point_b, point_c)\n\n\n@pytest.mark.parametrize(\n    ""plane, coeffs_expected"",\n    [\n        (Plane([-1, 2], [22, -3]), [22, -3, 0, 28]),\n        (Plane([0, 0, 0], [0, 0, 1]), [0, 0, 1, 0]),\n        (Plane([0, 0, 0], [0, 0, 25]), [0, 0, 25, 0]),\n        (Plane([0, 0, 0], [0, 0, 25]), [0, 0, 25, 0]),\n        (Plane([1, 2, 0], [5, 4, 6]), [5, 4, 6, -13]),\n        (Plane([-4, 5, 8], [22, -3, 6]), [22, -3, 6, 55]),\n        (Plane([0, 0, 0, 0], [1, 2, 3, 4]), None),\n    ],\n)\ndef test_cartesian(plane, coeffs_expected):\n    """"""Test the coefficients of the Cartesian plane equation.""""""\n\n    if coeffs_expected is None:\n        with pytest.raises(ValueError, match=""The plane dimension must be <= 3.""):\n            plane.cartesian()\n\n    else:\n        assert _allclose(plane.cartesian(), coeffs_expected).all()\n'"
skspatial/tests/unit/objects/test_points.py,3,"b'import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\n\nfrom skspatial.objects import Points\n\n\n@pytest.mark.parametrize(\n    ""array"",\n    [\n        # The array cannot be empty.\n        [],\n        [[]],\n        [[], []],\n        # The array cannot be 1D.\n        [0],\n        [5],\n        [0, 1],\n        [0, 1, 2],\n        # The points cannot have different lengths.\n        [[0, 1], [0, 1, 0]],\n    ],\n)\ndef test_failure(array):\n\n    with pytest.raises(Exception):\n        Points(array)\n\n\n@pytest.mark.parametrize(\n    ""points, dim_expected"",\n    [\n        (Points([[0, 0], [1, 1]]), 2),\n        (Points([[0, 0], [0, 0], [0, 0]]), 2),\n        (Points([[0, 0, 1], [1, 2, 1]]), 3),\n        (Points([[4, 3, 9, 1], [3, 7, 8, 1]]), 4),\n    ],\n)\ndef test_dimension(points, dim_expected):\n\n    assert points.dimension == dim_expected\n\n\n@pytest.mark.parametrize(\n    ""points, dim, points_expected"",\n    [\n        (Points([[0, 0], [1, 1]]), 3, Points([[0, 0, 0], [1, 1, 0]])),\n        (Points([[0, 0], [1, 1]]), 4, Points([[0, 0, 0, 0], [1, 1, 0, 0]])),\n        # The same dimension is allowed (nothing is changed).\n        (Points([[0, 0, 0], [1, 1, 1]]), 3, Points([[0, 0, 0], [1, 1, 1]])),\n        # The dimension cannot be lower than the current one.\n        (Points(np.zeros((3, 1))), 0, None),\n        (Points(np.zeros((3, 2))), 1, None),\n        (Points(np.zeros((3, 3))), 2, None),\n    ],\n)\ndef test_set_dimension(points, dim, points_expected):\n\n    if points_expected is None:\n        with pytest.raises(ValueError, match=""The desired dimension cannot be less than the current dimension.""):\n            points.set_dimension(dim)\n\n    else:\n        assert_array_equal(points.set_dimension(dim), points_expected)\n'"
skspatial/tests/unit/objects/test_sphere.py,5,"b'import math\n\nimport numpy as np\nimport pytest\n\nfrom skspatial.objects import Sphere\n\n\n@pytest.mark.parametrize(\n    ""point, radius"",\n    [\n        # The point must be 3D.\n        ([0], 1),\n        ([0, 0], 1),\n        ([0, 0, 0, 0], 1),\n        ([1, 2, 3, 4], 1),\n        # The radius must be positive.\n        ([0, 0, 0], 0),\n        ([0, 0, 0], -1),\n        ([0, 0, 0], -5),\n    ],\n)\ndef test_failure(point, radius):\n\n    with pytest.raises(Exception):\n        Sphere(point, radius)\n\n\n@pytest.mark.parametrize(\n    ""radius, surface_area_expected, volume_expected"",\n    [\n        (1, 4 * np.pi, 4 / 3 * np.pi),\n        (2, 16 * np.pi, 32 / 3 * np.pi),\n        (3, 36 * np.pi, 36 * np.pi),\n        (4.5, 81 * np.pi, 121.5 * np.pi),\n        (10, 400 * np.pi, 4000 / 3 * np.pi),\n    ],\n)\ndef test_surface_area_volume(radius, surface_area_expected, volume_expected):\n\n    sphere = Sphere([0, 0, 0], radius)\n\n    assert math.isclose(sphere.surface_area(), surface_area_expected)\n    assert math.isclose(sphere.volume(), volume_expected)\n'"
skspatial/tests/unit/objects/test_triangle.py,0,"b'from dataclasses import dataclass\nfrom math import atan, degrees, isclose, radians, sqrt\n\nimport pytest\n\nfrom skspatial.objects import Line, Triangle\nfrom skspatial.typing import array_like\n\n\n@dataclass\nclass TriangleTester:\n    """"""Triangle object for unit testing.""""""\n\n    points: tuple\n\n    area: float\n    perimeter: float\n\n    lengths: tuple\n    angles: tuple\n    altitudes: tuple\n\n    normal: array_like\n    centroid: array_like\n    orthocenter: array_like\n\n    classification: str\n    is_right: bool\n\n\nlist_test_cases = [\n    TriangleTester(\n        points=[[0, 0], [1, 0], [0, 1]],\n        area=0.5,\n        perimeter=2 + sqrt(2),\n        lengths=(sqrt(2), 1, 1),\n        angles=(90, 45, 45),\n        centroid=[1 / 3, 1 / 3],\n        orthocenter=[0, 0],\n        normal=[0, 0, 1],\n        classification=\'isosceles\',\n        is_right=True,\n        altitudes=(Line([0, 0], [0.5, 0.5]), Line([1, 0], [-1, 0]), Line([0, 1], [0, -1])),\n    ),\n    TriangleTester(\n        points=[[0, 0], [1, 1], [2, 0]],\n        area=1,\n        perimeter=2 + 2 * sqrt(2),\n        lengths=(sqrt(2), 2, sqrt(2)),\n        angles=(45, 90, 45),\n        centroid=[1, 1 / 3],\n        orthocenter=[1, 1],\n        normal=[0, 0, -2],\n        classification=\'isosceles\',\n        is_right=True,\n        altitudes=(Line([0, 0], [1, 1]), Line([1, 1], [0, -1]), Line([2, 0], [-1, 1])),\n    ),\n    TriangleTester(\n        points=[[0, 0], [1, 0], [0.5, sqrt(3) / 2]],\n        area=sqrt(3) / 4,\n        perimeter=3,\n        lengths=(1, 1, 1),\n        angles=(60, 60, 60),\n        centroid=[0.5, sqrt(3) / 6],\n        orthocenter=[0.5, sqrt(3) / 6],\n        normal=[0, 0, sqrt(3) / 2],\n        classification=\'equilateral\',\n        is_right=False,\n        altitudes=(\n            Line([0, 0], [0.75, sqrt(3) / 4]),\n            Line([1, 0], [-0.75, sqrt(3) / 4]),\n            Line([0.5, sqrt(3) / 2], [0, -sqrt(3) / 2]),\n        ),\n    ),\n    TriangleTester(\n        points=[[0, 0], [1, 0], [0, 2]],\n        area=1,\n        perimeter=3 + sqrt(5),\n        lengths=(sqrt(5), 2, 1),\n        angles=(90, degrees(atan(2)), degrees(atan(1 / 2))),\n        centroid=[1 / 3, 2 / 3],\n        orthocenter=[0, 0],\n        normal=[0, 0, 2],\n        classification=\'scalene\',\n        is_right=True,\n        altitudes=(Line([0, 0], [0.8, 0.4]), Line([1, 0], [-1, 0]), Line([0, 2], [0, -2])),\n    ),\n    TriangleTester(\n        points=[[0, 0], [3, 0], [0, 4]],\n        area=6,\n        perimeter=12,\n        lengths=(5, 4, 3),\n        angles=(90, degrees(atan(4 / 3)), degrees(atan(3 / 4))),\n        centroid=[1, 4 / 3],\n        orthocenter=[0, 0],\n        normal=[0, 0, 12],\n        classification=\'scalene\',\n        is_right=True,\n        altitudes=(Line([0, 0], [1.92, 1.44]), Line([3, 0], [-3, 0]), Line([0, 4], [0, -4])),\n    ),\n]\n\n\n@pytest.mark.parametrize(\'test_case\', list_test_cases)\ndef test_triangle(test_case):\n\n    triangle = Triangle(*test_case.points)\n\n    assert triangle.area() == test_case.area\n    assert triangle.perimeter() == test_case.perimeter\n\n    points_a = triangle.multiple(\'point\', \'ABC\')\n    points_b = test_case.points\n    assert all(a.is_equal(b) for a, b in zip(points_a, points_b))\n\n    lengths_a = triangle.multiple(\'length\', \'abc\')\n    lengths_b = test_case.lengths\n    assert all([isclose(a, b) for a, b in zip(lengths_a, lengths_b)])\n\n    angles_a = triangle.multiple(\'angle\', \'ABC\')\n    angles_b = tuple(map(radians, test_case.angles))\n    assert all(isclose(a, b, abs_tol=1e-3) for a, b in zip(angles_a, angles_b))\n\n    assert triangle.normal().is_close(test_case.normal)\n    assert triangle.centroid().is_close(test_case.centroid)\n    assert triangle.orthocenter().is_close(test_case.orthocenter)\n\n    altitudes_a = triangle.multiple(\'altitude\', \'ABC\')\n    altitudes_b = test_case.altitudes\n    print(altitudes_a, altitudes_b)\n    assert all(a.is_close(b, abs_tol=1e-3) for a, b in zip(altitudes_a, altitudes_b))\n\n    assert triangle.classify() == test_case.classification\n    assert triangle.is_right() == test_case.is_right\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, array_c"",\n    [([1], [1, 0], [1, 0]), ([1, 0, 0], [1, 0], [1, 0]), ([1, 0], [1, 0], [1, 0, 0]), ([1, 0, 0], [1, 0], [1, 0, 0])],\n)\ndef test_failure_different_dimensions(array_a, array_b, array_c):\n\n    with pytest.raises(ValueError, match=""The points must have the same dimension.""):\n        Triangle(array_a, array_b, array_c)\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, array_c"",\n    [\n        ([1], [2], [3]),\n        ([1, 0], [1, 0], [1, 0]),\n        ([1, 2, 3], [1, 2, 3], [1, 2, 3]),\n        ([1, 2, 3], [1, 2, 3], [2, 3, -10]),  # Two points are the same.\n        ([1, 2, 3], [4, 5, 6], [7, 8, 9]),\n        ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]),\n    ],\n)\ndef test_failure_collinear_points(array_a, array_b, array_c):\n\n    with pytest.raises(ValueError, match=""The points must not be collinear.""):\n        Triangle(array_a, array_b, array_c)\n\n\n@pytest.fixture\ndef basic_triangle():\n\n    return Triangle([0, 0], [0, 1], [1, 0])\n\n\n@pytest.mark.parametrize(""string"", [\'a\', \'b\', \'c\', \'d\', \'D\'])\ndef test_failure_point(basic_triangle, string):\n\n    message = ""The vertex must be \'A\', \'B\', or \'C\'.""\n\n    with pytest.raises(ValueError, match=message):\n        basic_triangle.point(string)\n\n    with pytest.raises(ValueError, match=message):\n        basic_triangle.angle(string)\n\n    with pytest.raises(ValueError, match=message):\n        basic_triangle.altitude(string)\n\n\n@pytest.mark.parametrize(""string"", [\'A\', \'B\', \'C\', \'D\'])\ndef test_failure_line(basic_triangle, string):\n\n    message = ""The side must be \'a\', \'b\', or \'c\'.""\n\n    with pytest.raises(ValueError, match=message):\n        basic_triangle.line(string)\n\n    with pytest.raises(ValueError, match=message):\n        basic_triangle.length(string)\n'"
skspatial/tests/unit/objects/test_vector.py,0,"b'import math\n\nimport pytest\nfrom numpy.testing import assert_array_equal\n\nfrom skspatial.objects import Vector\n\n\n@pytest.mark.parametrize(\n    ""array_a, array_b, vector_expected"",\n    [\n        ([0, 0], [1, 0], Vector([1, 0])),\n        ([1, 0], [1, 0], Vector([0, 0])),\n        ([1, 0], [2, 0], Vector([1, 0])),\n        ([8, 3, -5], [3, 7, 1], Vector([-5, 4, 6])),\n        ([5, 7, 8, 9], [2, 5, 3, -4], Vector([-3, -2, -5, -13])),\n    ],\n)\ndef test_from_points(array_a, array_b, vector_expected):\n\n    assert_array_equal(Vector.from_points(array_a, array_b), vector_expected)\n\n\n@pytest.mark.parametrize(\n    ""array, array_unit_expected"",\n    [\n        ([1, 0], [1, 0]),\n        ([2, 0], [1, 0]),\n        ([-1, 0], [-1, 0]),\n        ([0, 0, 5], [0, 0, 1]),\n        ([1, 1], [math.sqrt(2) / 2, math.sqrt(2) / 2]),\n        ([1, 1, 1], [math.sqrt(3) / 3, math.sqrt(3) / 3, math.sqrt(3) / 3]),\n        ([2, 0, 0, 0], [1, 0, 0, 0]),\n        ([3, 3, 0, 0], [math.sqrt(2) / 2, math.sqrt(2) / 2, 0, 0]),\n        ([0], None),\n        ([0, 0], None),\n        ([0, 0, 0], None),\n    ],\n)\ndef test_unit(array, array_unit_expected):\n\n    if array_unit_expected is None:\n        with pytest.raises(ValueError, match=""The magnitude must not be zero.""):\n            Vector(array).unit()\n\n    else:\n        assert Vector(array).unit().is_close(array_unit_expected)\n\n\n@pytest.mark.parametrize(\n    ""array, kwargs, bool_expected"",\n    [\n        ([0, 0], {}, True),\n        ([0, 0, 0], {}, True),\n        ([0, 1], {}, False),\n        # The tolerance affects the output.\n        ([0, 0, 1e-4], {}, False),\n        ([0, 0, 1e-4], {\'abs_tol\': 1e-3}, True),\n        ([0, 0, 0, 0], {}, True),\n        ([7, 0, 2, 0], {}, False),\n    ],\n)\ndef test_is_zero(array, kwargs, bool_expected):\n\n    assert Vector(array).is_zero(**kwargs) == bool_expected\n'"
