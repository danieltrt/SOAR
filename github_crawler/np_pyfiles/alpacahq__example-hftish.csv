file_path,api_count,code
tick_taker.py,1,"b'import argparse\nimport pandas as pd\nimport numpy as np\nimport alpaca_trade_api as tradeapi\n\n\nclass Quote():\n    """"""\n    We use Quote objects to represent the bid/ask spread. When we encounter a\n    \'level change\', a move of exactly 1 penny, we may attempt to make one\n    trade. Whether or not the trade is successfully filled, we do not submit\n    another trade until we see another level change.\n\n    Note: Only moves of 1 penny are considered eligible because larger moves\n    could potentially indicate some newsworthy event for the stock, which this\n    algorithm is not tuned to trade.\n    """"""\n\n    def __init__(self):\n        self.prev_bid = 0\n        self.prev_ask = 0\n        self.prev_spread = 0\n        self.bid = 0\n        self.ask = 0\n        self.bid_size = 0\n        self.ask_size = 0\n        self.spread = 0\n        self.traded = True\n        self.level_ct = 1\n        self.time = 0\n\n    def reset(self):\n        # Called when a level change happens\n        self.traded = False\n        self.level_ct += 1\n\n    def update(self, data):\n        # Update bid and ask sizes and timestamp\n        self.bid_size = data.bidsize\n        self.ask_size = data.asksize\n\n        # Check if there has been a level change\n        if (\n            self.bid != data.bidprice\n            and self.ask != data.askprice\n            and round(data.askprice - data.bidprice, 2) == .01\n        ):\n            # Update bids and asks and time of level change\n            self.prev_bid = self.bid\n            self.prev_ask = self.ask\n            self.bid = data.bidprice\n            self.ask = data.askprice\n            self.time = data.timestamp\n            # Update spreads\n            self.prev_spread = round(self.prev_ask - self.prev_bid, 3)\n            self.spread = round(self.ask - self.bid, 3)\n            print(\n                \'Level change:\', self.prev_bid, self.prev_ask,\n                self.prev_spread, self.bid, self.ask, self.spread, flush=True\n            )\n            # If change is from one penny spread level to a different penny\n            # spread level, then initialize for new level (reset stale vars)\n            if self.prev_spread == 0.01:\n                self.reset()\n\n\nclass Position():\n    """"""\n    The position object is used to track how many shares we have. We need to\n    keep track of this so our position size doesn\'t inflate beyond the level\n    we\'re willing to trade with. Because orders may sometimes be partially\n    filled, we need to keep track of how many shares are ""pending"" a buy or\n    sell as well as how many have been filled into our account.\n    """"""\n\n    def __init__(self):\n        self.orders_filled_amount = {}\n        self.pending_buy_shares = 0\n        self.pending_sell_shares = 0\n        self.total_shares = 0\n\n    def update_pending_buy_shares(self, quantity):\n        self.pending_buy_shares += quantity\n\n    def update_pending_sell_shares(self, quantity):\n        self.pending_sell_shares += quantity\n\n    def update_filled_amount(self, order_id, new_amount, side):\n        old_amount = self.orders_filled_amount[order_id]\n        if new_amount > old_amount:\n            if side == \'buy\':\n                self.update_pending_buy_shares(old_amount - new_amount)\n                self.update_total_shares(new_amount - old_amount)\n            else:\n                self.update_pending_sell_shares(old_amount - new_amount)\n                self.update_total_shares(old_amount - new_amount)\n            self.orders_filled_amount[order_id] = new_amount\n\n    def remove_pending_order(self, order_id, side):\n        old_amount = self.orders_filled_amount[order_id]\n        if side == \'buy\':\n            self.update_pending_buy_shares(old_amount - 100)\n        else:\n            self.update_pending_sell_shares(old_amount - 100)\n        del self.orders_filled_amount[order_id]\n\n    def update_total_shares(self, quantity):\n        self.total_shares += quantity\n\n\ndef run(args):\n    symbol = args.symbol\n    max_shares = args.quantity\n    opts = {}\n    if args.key_id:\n        opts[\'key_id\'] = args.key_id\n    if args.secret_key:\n        opts[\'secret_key\'] = args.secret_key\n    if args.base_url:\n        opts[\'base_url\'] = args.base_url\n    elif \'key_id\' in opts and opts[\'key_id\'].startswith(\'PK\'):\n        opts[\'base_url\'] = \'https://paper-api.alpaca.markets\'\n    # Create an API object which can be used to submit orders, etc.\n    api = tradeapi.REST(**opts)\n\n    symbol = symbol.upper()\n    quote = Quote()\n    qc = \'Q.%s\' % symbol\n    tc = \'T.%s\' % symbol\n    position = Position()\n\n    # Establish streaming connection\n    conn = tradeapi.StreamConn(**opts)\n\n    # Define our message handling\n    @conn.on(r\'Q$\')\n    async def on_quote(conn, channel, data):\n        # Quote update received\n        quote.update(data)\n\n    @conn.on(r\'T$\')\n    async def on_trade(conn, channel, data):\n        if quote.traded:\n            return\n        # We\'ve received a trade and might be ready to follow it\n        if (\n            data.timestamp <= (\n                quote.time + pd.Timedelta(np.timedelta64(50, \'ms\'))\n            )\n        ):\n            # The trade came too close to the quote update\n            # and may have been for the previous level\n            return\n        if data.size >= 100:\n            # The trade was large enough to follow, so we check to see if\n            # we\'re ready to trade. We also check to see that the\n            # bid vs ask quantities (order book imbalance) indicate\n            # a movement in that direction. We also want to be sure that\n            # we\'re not buying or selling more than we should.\n            if (\n                data.price == quote.ask\n                and quote.bid_size > (quote.ask_size * 1.8)\n                and (\n                    position.total_shares + position.pending_buy_shares\n                ) < max_shares - 100\n            ):\n                # Everything looks right, so we submit our buy at the ask\n                try:\n                    o = api.submit_order(\n                        symbol=symbol, qty=\'100\', side=\'buy\',\n                        type=\'limit\', time_in_force=\'day\',\n                        limit_price=str(quote.ask)\n                    )\n                    # Approximate an IOC order by immediately cancelling\n                    api.cancel_order(o.id)\n                    position.update_pending_buy_shares(100)\n                    position.orders_filled_amount[o.id] = 0\n                    print(\'Buy at\', quote.ask, flush=True)\n                    quote.traded = True\n                except Exception as e:\n                    print(e)\n            elif (\n                data.price == quote.bid\n                and quote.ask_size > (quote.bid_size * 1.8)\n                and (\n                    position.total_shares - position.pending_sell_shares\n                ) >= 100\n            ):\n                # Everything looks right, so we submit our sell at the bid\n                try:\n                    o = api.submit_order(\n                        symbol=symbol, qty=\'100\', side=\'sell\',\n                        type=\'limit\', time_in_force=\'day\',\n                        limit_price=str(quote.bid)\n                    )\n                    # Approximate an IOC order by immediately cancelling\n                    api.cancel_order(o.id)\n                    position.update_pending_sell_shares(100)\n                    position.orders_filled_amount[o.id] = 0\n                    print(\'Sell at\', quote.bid, flush=True)\n                    quote.traded = True\n                except Exception as e:\n                    print(e)\n\n    @conn.on(r\'trade_updates\')\n    async def on_trade_updates(conn, channel, data):\n        # We got an update on one of the orders we submitted. We need to\n        # update our position with the new information.\n        event = data.event\n        if event == \'fill\':\n            if data.order[\'side\'] == \'buy\':\n                position.update_total_shares(\n                    int(data.order[\'filled_qty\'])\n                )\n            else:\n                position.update_total_shares(\n                    -1 * int(data.order[\'filled_qty\'])\n                )\n            position.remove_pending_order(\n                data.order[\'id\'], data.order[\'side\']\n            )\n        elif event == \'partial_fill\':\n            position.update_filled_amount(\n                data.order[\'id\'], int(data.order[\'filled_qty\']),\n                data.order[\'side\']\n            )\n        elif event == \'canceled\' or event == \'rejected\':\n            position.remove_pending_order(\n                data.order[\'id\'], data.order[\'side\']\n            )\n\n    conn.run(\n        [\'trade_updates\', tc, qc]\n    )\n\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \'--symbol\', type=str, default=\'SNAP\',\n        help=\'Symbol you want to trade.\'\n    )\n    parser.add_argument(\n        \'--quantity\', type=int, default=500,\n        help=\'Maximum number of shares to hold at once. Minimum 100.\'\n    )\n    parser.add_argument(\n        \'--key-id\', type=str, default=None,\n        help=\'API key ID\',\n    )\n    parser.add_argument(\n        \'--secret-key\', type=str, default=None,\n        help=\'API secret key\',\n    )\n    parser.add_argument(\n        \'--base-url\', type=str, default=None,\n        help=\'set https://paper-api.alpaca.markets if paper trading\',\n    )\n    args = parser.parse_args()\n    assert args.quantity >= 100\n    run(args)\n'"
