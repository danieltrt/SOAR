file_path,api_count,code
examples.py,0,"b'from __future__ import print_function\nfrom mnist_sequence_api import MNIST_Sequence_API\n\n\napi_object = MNIST_Sequence_API()\n\napi_object.save_image(api_object.generate_mnist_sequence(range(8), (0, 10), 224), range(8))\napi_object.save_image(api_object.generate_mnist_sequence(range(9), (0, 10), 292), range(9))\napi_object.save_image(api_object.generate_mnist_sequence(range(10), (0, 10), 280), range(10))\n'"
examples_generate_dataset.py,0,"b'from mnist_sequence_api import MNIST_Sequence_API\n\napi_object = MNIST_Sequence_API()\n\nseq_len = 5 # generate sequences of this length\nn_train = 50\ninputs, labels = api_object.generate_data(n_train, seq_len)\napi_object.save_array(inputs, ""dataset/train_inputs.bc"")\napi_object.save_array(labels, ""dataset/train_labels.bc"")\n\nn_validation = 25\ninputs, labels = api_object.generate_data(n_validation, seq_len)\napi_object.save_array(inputs, ""dataset/test_inputs.bc"")\napi_object.save_array(labels, ""dataset/test_labels.bc"")'"
load.py,1,"b'from __future__ import print_function\nimport os\nimport struct\nfrom array import array\nimport numpy as np\n\n\nclass MNIST(object):\n\n    def __init__(self, path=\'data\', name_img=\'t10k-images.idx3-ubyte\',\n                 name_lbl=\'t10k-labels.idx1-ubyte\'):\n        self.path = path\n        self.name_img = name_img\n        self.name_lbl = name_lbl\n\n    def load(self):\n        path_img = os.path.join(os.getcwd(), self.path, self.name_img)\n        path_lbl = os.path.join(os.getcwd(), self.path, self.name_lbl)\n\n        with open(path_lbl, \'rb\') as f:\n            magic, size = struct.unpack("">II"", f.read(8))\n\n            if magic != 2049:\n                print(\'Magic number mismatch, expected 2049,\'\'got {}\'.format(magic))\n                exit()\n\n            labels = array(""B"", f.read())\n\n        with open(path_img, \'rb\') as f:\n            magic, size, rows, cols = struct.unpack("">IIII"", f.read(16))\n\n            if magic != 2051:\n                print(\'Magic number mismatch, expected 2051,\'\'got {}\'.format(magic))\n                exit()\n\n            image_data = list(map(lambda pixel: (255 - pixel) / 255.0, array(""B"", f.read())))\n            # Converting data to 32 bit floating point range from 0 (black) to 1 (white)\n\n            images = np.asarray(image_data, dtype=np.float32).reshape(size, rows, cols)\n\n        return images, labels\n'"
mnist_sequence.py,3,"b'from __future__ import print_function\nimport numpy as np\nfrom load import MNIST\nfrom random import choice\n\n\nclass MNIST_Sequence(object):\n\n    def __init__(self, path=\'data\', name_img=\'t10k-images.idx3-ubyte\',\n                 name_lbl=\'t10k-labels.idx1-ubyte\'):\n        self.dataset = MNIST(path, name_img, name_lbl)\n        self.images, self.labels = self.dataset.load()\n        self.label_map = [[] for i in range(10)]\n        self.__generate_label_map()\n\n    def __calculate_uniform_spacing(self, size_sequence, minimum_spacing, maximum_spacing,\n                                    total_width, image_width=28):\n        if size_sequence <= 1:\n            return 0\n        allowed_spacing = (total_width - size_sequence * image_width) / ((size_sequence - 1) * 1.0)\n        if not allowed_spacing.is_integer() or allowed_spacing < minimum_spacing \\\n                or allowed_spacing > maximum_spacing:\n            print(""Uniform spacing is not possible for the given set of values, "" +\n                  ""please provide suitable values."")\n            print(""For example, try with sequence [0, 1] with minimum spacing 0, "" +\n                  ""maximum_spacing 10 and image_width 66."")\n            exit()\n        return int(allowed_spacing)\n\n    def __generate_label_map(self):\n        num_labels = len(self.labels)\n        for i in range(num_labels):\n            self.label_map[self.labels[i]].append(i)\n\n    def __select_random_label(self, label):\n        if len(self.label_map[label]) > 0:\n            return choice(self.label_map[label])\n        else:\n            print(""No images for the number "" + str(label) +\n                  "" is available. Please try with a different number."")\n            exit()\n\n    def generate_image_sequence(self, sequence, minimum_spacing, maximum_spacing,\n                                total_width, image_height=28):\n        sequence_length = len(sequence)\n        allowed_spacing = self.__calculate_uniform_spacing(sequence_length, minimum_spacing,\n                                                           maximum_spacing, total_width)\n        spacing = np.ones(image_height * allowed_spacing,\n                          dtype=\'float32\').reshape(image_height, allowed_spacing)\n        random_label_number = self.__select_random_label(sequence[0])\n        image = self.images[random_label_number]\n        for i in range(1, sequence_length):\n            if i < sequence_length:\n                image = np.hstack((image, spacing))\n            random_label_number = self.__select_random_label(sequence[i])\n            image = np.hstack((image, self.images[random_label_number]))\n        return image\n'"
mnist_sequence_api.py,3,"b'from __future__ import print_function\nfrom mnist_sequence import MNIST_Sequence\nimport numpy as np\nfrom PIL import Image\nimport bcolz\n\nclass MNIST_Sequence_API(object):\n\n    def __init__(self):\n        self.sequence_object = MNIST_Sequence(\n            \'data\', \'t10k-images.idx3-ubyte\', \'t10k-labels.idx1-ubyte\')\n\n    def generate_mnist_sequence(self, digits, spacing_range, image_width):\n        img_data = (self.sequence_object.generate_image_sequence(digits, spacing_range[\n                    0], spacing_range[1], image_width) * 255.0).astype(np.uint8)\n        return img_data\n\n    def generate_data(self, num_samples, seq_len, spacing_range=(0,0)):\n        inputs = []\n        labels = []\n        for i in range(num_samples):\n            seq_values = np.random.randint(0, 10, seq_len)\n            seq = self.generate_mnist_sequence(seq_values, spacing_range, \n                                                     28 * seq_len)\n            inputs.append(seq)\n            labels.append(seq_values)\n        print(""MNIST sequence image dataset of size "" + str(num_samples) +\n              "" has been generated."")\n        return np.array(inputs), np.array(labels)\n\n    def save_image(self, img_data, sequence):\n        sequence_image = Image.fromarray(img_data)\n        img_name = ""-"".join(list(map(str, sequence)))\n        sequence_image.save(img_name + "".png"")\n        print(""Image for the sequence "" + img_name +\n              "" is generated and saved as "" + img_name + "".png."")\n\n    def save_array(self, data, fname):\n        print(""Saving image dataset at the location "" + str(fname) + ""."")\n        c = bcolz.carray(data, rootdir=fname, mode=\'w\')\n        c.flush()\n\n    def load_array(self, fname):\n        print(""Loading image dataset from the location "" + str(fname) + ""."")\n        return bcolz.open(fname)[:]\n'"
mnist_sequence_cli.py,0,"b'from __future__ import print_function\nfrom mnist_sequence_api import MNIST_Sequence_API\nimport sys\n\n\ndef main():\n    arguments = list(sys.argv[1:])\n    if len(arguments) == 4:\n        sequence, min_spacing = list(map(int, list(arguments[0]))), int(arguments[1])\n        max_spacing, image_width = int(arguments[2]), int(arguments[3])\n        api_object = MNIST_Sequence_API()\n        img_data = api_object.generate_mnist_sequence(sequence, (min_spacing, max_spacing), image_width)\n        api_object.save_image(img_data, sequence)\n    else:\n        print(""Incorrect number of arguments."")\n        print(""Usage: python mnist_sequence_cli.py <sequence(no spaces) "" +\n              ""min_spacing max_spacing image_width>"")\n\nif __name__ == ""__main__"":\n    main()\n'"
tests.py,2,"b'from __future__ import print_function\nfrom load import MNIST\nfrom mnist_sequence import MNIST_Sequence\nfrom mnist_sequence_api import MNIST_Sequence_API\nimport numpy as np\nimport os\n\n\nclass Tests(object):\n\n    def __init__(self):\n        self.mnist = MNIST()\n        self.mnist_sequence = MNIST_Sequence()\n        self.mnist_sequence_api = MNIST_Sequence_API()\n\n    def load_test(self):\n        images, labels = self.mnist.load()\n        size, rows, cols = images.shape\n        return (rows == cols == 28 and size == len(labels))\n\n    def generate_image_sequence_test(self):\n        img = self.mnist_sequence.generate_image_sequence([0, 1], 0, 10, 66)\n        rows, cols = img.shape\n        return (rows == 28 and cols == 66 and np.amax(img) == 1.0 and np.amin(img) == 0.0)\n\n    def mnist_sequence_api_test(self):\n        img = self.mnist_sequence_api.generate_mnist_sequence([0, 1], (0, 10), 66)\n        rows, cols = img.shape\n        return (rows == 28 and cols == 66 and np.amax(img) == 255 and np.amin(img) == 0)\n    \n    def save_image_test(self):\n        self.mnist_sequence_api.save_image(self.mnist_sequence_api.generate_mnist_sequence([0, 1], (0, 10), 66), [0, 1])\n        return os.path.isfile(""0-1.png"")\n\n\ndef run_tests():\n    tests = Tests()\n    total_tests, test_count = 4, 0\n    if tests.load_test():\n        test_count += 1\n    else:\n        print(""Load test failed."")\n    if tests.generate_image_sequence_test():\n        test_count += 1\n    else:\n        print(""Generate MNIST sequence test failed."")\n    if tests.mnist_sequence_api_test():\n        test_count += 1\n    else:\n        print(""MNIST sequence API test failed."")\n    if tests.save_image_test():\n        test_count += 1\n    else:\n        print(""Save image test failed."")\n    print(str(test_count) + "" / "" + str(total_tests) + "" were passed."")\n\nif __name__ == ""__main__"":\n    run_tests()\n'"
