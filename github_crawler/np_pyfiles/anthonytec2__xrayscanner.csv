file_path,api_count,code
x-ray-cuda-numba.py,25,"b""'''\nCode developed by Anthony Bisulco\nAugust 28th, 2018\nThis is a script to run an imaging scenario on a given imaging volume\nwith an arbitrary sized detector. Currently, the file that loads is\na brain scan which is imaged. This code uses Numba acceleration in order\nto obtain reasonable imaging times. Right now the ray tracing is off by 4 pixels\nin a 300x300 image, possibly due to GPU IEEE floating point errors.\n'''\nimport h5py  # library used for data import\nimport numpy as np  # library used for data manipulation\nimport numba  # library used to speed up code\nfrom numba import cuda  # helper cuda for cuda functions\nimport math  # math library to perform in kernel\nimport matplotlib.pyplot as plt  # plotting library\n\n\n@cuda.jit(device=True)  # CUDA Device function must be called from GPU kernel\ndef onemove_in_cube_true_numba(p0, v):\n    '''\n    This is a function that moves from a given position p0 in direction v to another cube in a 1x1x1mm setup\n    Args:\n        p0: np.array 1x3 start position (X,Y,Z)\n        v: np.array 1x3 normalized(1) direction vector (X,Y,Z)\n\n    Returns:\n        htime: np.array 1x3 next cube position (X,Y,Z)\n        dist: float distance to the next cube position\n\n    '''\n    htime = cuda.local.array((3), dtype=numba.float32) #Create local CUDA array to each thread to store next position\n    for i in range(3): #loop through dim to calc time to next pos\n        if v[i] > 0: #if positive need to add 1 to reverse negative result\n            htime[i] = abs((math.floor(p0[i]) - p0[i] + 1) / v[i])\n        else: #if negative, perform calc as usual, *CUDA requires the 1e-4 for some reason, code will not return without possibly floating pt issues\n            htime[i] = abs((math.floor(p0[i]) - p0[i] - 1e-4) / v[i])\n    min_loc = 0 # min location in array\n    min_time = htime[0] # min value in array\n    for i in range(1, 3): #loop through elem in time array\n        if min_time > htime[i]: # check if smaller val\n            min_loc = i # reset min loc\n            min_time = htime[i] # set min val#\n\n    for i in range(3): # loop through dim and calc next post\n        htime[i] = p0[i] + min_time * v[i]\n\n    if v[min_loc] < 0: # add incremental amount for next iter, to no get stuck in endless loop\n        htime[min_loc] = round(htime[min_loc]) + 1.5e-4 * -1\n    else:\n        htime[min_loc] = round(htime[min_loc]) + 1.5e-4\n    return htime, min_time # return next position and min distance/time\n\n@cuda.jit # GPU Kernel must be executed from host\ndef main_loop(h_image_params, mu, detector):\n    '''\n    Ray tracing from end point to all pixels, calculates energy at every pixels\n    Args:\n        h_image_params:\n            Nx: uint imaging volume length in x direction\n            Ny: uint imaging volume length in y direction\n            Nz: uint imaging volume length in z direction\n            Mx: uint number of pixels in x direction\n            My: uint number of pixels in y direction\n            D: uint pixel length\n            h: uint distance from detector to bottom of imaging volume\n            orginOffset: np.array 1x2 offset origin for detector position start (X,Y)\n            ep: np.array 1x3 location of the x-ray source (X,Y,Z)\n        mu: np.array 1x3 normalized linear attenuation coefficient matrix (Nx,Ny,Nz)\n        detector: np.array 1x3 next cube position (X,Y,Z)\n    '''\n\n    i, j = cuda.grid(2) # Create thread indices i, j\n    if i < detector.shape[0] and j < detector.shape[1]: # check thread indices within detector, o.w. return\n        pos = cuda.local.array((3), dtype=numba.float32) # create local thread storage for current ray position\n        direction = cuda.local.array((3), dtype=numba.float32) # create local thread storage for current direction\n        pos[0] = h_image_params[8] + h_image_params[3] * numba.float32(i) # X Calc ray start pos with origin offset and x pixel offset\n        pos[1] = h_image_params[9] + h_image_params[3] * numba.float32(j) # Y Calc ray start pos with origin offset and y pixel offset\n        pos[2] = 0 # start ray at detector Z=0\n        norm = 0 # Calculate normalization for direction vector\n        for k in range(3): # loop through dim\n            norm += math.pow(h_image_params[5+k]-pos[k], 2) # calc squared diff bettween source loc to current pos\n        norm = math.sqrt(norm) # take squareroot for normalization factor\n        for k in range(3): # loop through direction dim\n            direction[k] = (h_image_params[5+k]-pos[k])/norm # direction = source loc -position over norm\n            if direction[k] == 0: # Dont want any divide by 0 errors, therefore set to small val\n                direction[k] = 1e-16\n        L = 0 # Start energy at source location\n        h_z = h_image_params[4] + h_image_params[2] # highest Z location \n        while pos[2] < h_z: # loop until the ray exits the highest Z location, after that ray doesent attenuate\n            if -.0001 < pos[0] < .0001: # CUDA needs this, tested in sim without algo works, need some incremental update around 0 to not get stuck\n                pos[0] += .0001\n            if -.0001 < pos[1] < .0001: # CUDA needs this, tested in sim without algo works, need some incremental update around 0 to not get stuck\n                pos[1] += .0001\n            p1, dist = onemove_in_cube_true_numba(pos, direction) # move from current pos in direction to new cube in mu grid\n            for k in range(3): # need to copy over data for some reason in Numba or else array doesent get updated\n                pos[k] = p1[k]\n            if 0 <= pos[0] < h_image_params[0] and 0 <= pos[1] < h_image_params[1] and h_image_params[4] <= pos[2] < h_z: # if in imaging volume\n                # calculate energy using mu\n                L += mu[int(math.floor(pos[0])), int(math.floor(pos[1])),\n                        int(math.floor(pos[2] - h_image_params[4]))] * dist\n        detector[i][j] = L # detector pixel location equals lasting energy\n\ndef main():\n    # HDF5 file containing Headct array of linear attenuation\n    # coefficient(Nx,Ny,Nz)\n    f = h5py.File('headct.h5', 'r')\n    headct = np.array(f.get('ct'))\n    headct = np.transpose(headct)  # linear attenuation coefficient matrix\n    Nx = np.size(headct, 0)  # Imaging x dimension length in mm\n    Ny = np.size(headct, 1)  # Imaging y dimension length in mm\n    Nz = np.size(headct, 2)  # Imaging z dimension length in mm\n    Mx = 128  # Number of pixels in x direction\n    My = 128  # Number of pixels in y direction\n    h = 2  # distance(Z) bettween bottom of imaging volume and detector\n    H = h + Nz + 600  # distance(Z) bettween detector and x-ray source\n    dx = (H * Nx) / ((H - Nz - h) * Mx)  # distance x direction for each pixel\n    dy = (H * Ny) / ((H - Nz - h) * My)  # distance y direction for each pixel\n    D = max(dx, dy)  # Size of each pixel in mm\n    muBone = 0.573  # linear attenuation coefficient bone cm^-1\n    muFat = 0.193  # linear attenuation coefficient fat cm^-1\n    # offset from origin to detector start (X,Y,Z)\n    orginOffset = np.array(\n        [(-Mx * D) / 2 + (Nx / 2), (-My * D) / 2 + (Ny / 2), 0], dtype=np.float32)\n    # location of x-ray soruce\n    ep = np.array([Nx / 2, Ny / 2, H], dtype=np.float32)\n    # offset from origin to detector start\n    orginOffset = np.array(\n        [(-Mx * D) / 2 + (Nx / 2), (-My * D) / 2 + (Ny / 2), 0], dtype=np.float32)\n    # (Nx,Ny,Nz) linear attenuation coefficient matrix\n    mu = np.zeros((Nx, Ny, Nz), dtype=np.float32)\n    mu[np.nonzero(headct > 0)] = ((headct[np.nonzero(headct > 0)] - 0.3) / (0.7)) * \\\n        (muBone - muFat) + muFat  # Normalization of givens mus of linear attenuation matrix\n    stream = cuda.stream() # Create CUDA stream for async transfer to GPU\n    h_image_params = np.array([Nx, Ny, Nz, D, h, ep[0], ep[1], ep[2],\n                            orginOffset[0], orginOffset[1], orginOffset[2]], dtype=np.float32) # Create an array withing imaging params \n    d_detector = cuda.device_array((Mx, My), dtype=np.float32, stream=stream) # Create a device error on GPU for detector results\n    d_mu = cuda.to_device(mu, stream) # Transfer the linear attenuation coefficients to GPU\n    d_image_params = cuda.to_device(h_image_params, stream) # Transfer imaging params to GPU\n    stream.synchronize() # Force all memory transfer to occur before starting func\n    main_loop[(int(np.ceil(Mx/25)), int(np.ceil(My/25))),\n            (25, 25), stream](h_image_params, d_mu, d_detector) # start main loop function and create x-ray image\n    stream.synchronize() # Force main loop to finish before memory transferback\n    res = d_detector.copy_to_host() # Transfer detector image to host\n    det2 = np.exp(res * -10, dtype=np.float64) # Perform necessary rescaling \n    plt.imshow(np.log(det2)) # Plot result\n    plt.title('Detector Log Image Python')\n    plt.xlabel('X Pixel')\n    plt.ylabel('Y Pixel')\n    plt.colorbar()\n    plt.savefig('x-ray.png') # Save Figure\n    print('Done') # print finshed\n\nif __name__ == '__main__':\n    main()\n"""
x-ray-numba.py,29,"b""'''\nCode developed by Anthony Bisulco\nFebruary 26th, 2018\nThis is a script to run an imaging scenario on a given imaging volume\nwith an arbitrary sized detector. Currently, the file that loads is\na brain scan which is imaged. This code uses Numba acceleration in order\nto obtain reasonable imaging times.\n'''\n\nimport h5py\nimport numpy as np\nimport math\nimport numba\nimport matplotlib\nmatplotlib.use('Agg')\nfrom matplotlib.pyplot import figure, colorbar, savefig, title, xlabel, ylabel, imshow\n\n\n@numba.jit(nopython=True, nogil=True, cache=True)\ndef onemove_in_cube_true_numba(p0, v):\n    '''\n    This is a function that moves from a given position p0 in direction v to another cube in a 1x1x1mm setup\n    Args:\n        p0: np.array 1x3 start position (X,Y,Z)\n        v: np.array 1x3 normalized(1) direction vector (X,Y,Z)\n\n    Returns:\n        htime: np.array 1x3 next cube position (X,Y,Z)\n        dist: float distance to the next cube position\n\n    '''\n\n    # find distance vector to new position\n    htime = np.abs((np.floor(p0) - p0 + (v > 0)) / v)\n    minLoc = np.argmin(htime)  # find min distance location in htime\n    dist = htime[minLoc]  # find min distance\n    htime = p0 + dist * v  # calculate new position estimate htime\n    # Need this for rounding to next position\n    htime[minLoc] = round(htime[minLoc]) + \\\n        np.spacing(abs(htime[minLoc])) * np.sign(v[minLoc])\n    return htime, dist\n\n\n@numba.jit(nopython=True, nogil=True, cache=True)\ndef main_loop(Nx, Ny, Nz, Mx, My, D, h, orginOffset, ep, mu):\n    '''\n    Ray tracing from end point to all pixels, calculates energy at every pixels\n    Args:\n        Nx: uint imaging volume length in x direction\n        Ny: uint imaging volume length in y direction\n        Nz: uint imaging volume length in z direction\n        Mx: uint number of pixels in x direction\n        My: uint number of pixels in y direction\n        D: uint pixel length\n        h: uint distance from detector to bottom of imaging volume\n        orginOffset: np.array 1x2 offset origin for detector position start (X,Y)\n        ep: np.array 1x3 location of the x-ray source (X,Y,Z)\n        mu: np.array 1x3 normalized linear attenuation coefficient matrix (Nx,Ny,Nz)\n    Returns:\n        detector: np.array 1x3 next cube position (X,Y,Z)\n    '''\n    detector = np.zeros(\n        (Mx, My), dtype=np.float32)  # detector Mx x pixels and My y pixels\n    for z in range(0, Mx * My):  # loop for all pixels\n        j = z % Mx  # y direction pixel\n        i = int(z / Mx)  # x direction pixel\n        pos = np.array([orginOffset[0] + i * D, orginOffset[1] + D * j,\n                        0], dtype=np.float32)  # pixel location\n        # normalized direction vector to source\n        dir = ((ep - pos) / np.linalg.norm(ep - pos)).astype(np.float32)\n        # need this for floating point division errors in Numba\n        dir[dir == 0] = 1e-16\n        L = 0  # initial energy\n        h_z = h + Nz\n        while pos[2] < h_z:  # loop until the end of imaging volume\n            pos, dist = onemove_in_cube_true_numba(\n                pos, dir)  # move to next cube\n            if 0 <= pos[0] < Nx and 0 <= pos[1] < Ny and h <= pos[2] < h_z:  # if in imaging volume\n                # calculate energy using mu\n                L += mu[math.floor(pos[0]), math.floor(pos[1]),\n                        math.floor(pos[2] - h)] * dist\n        detector[i][j] = L  # detector pixel location equals lasting energy\n    return detector\n\n\ndef main():\n    # HDF5 file containing Headct array of linear attenuation\n    # coefficient(Nx,Ny,Nz)\n    f = h5py.File('headct.h5', 'r')\n    headct = np.array(f.get('ct'))\n    headct = np.transpose(headct)  # linear attenuation coefficient matrix\n    Nx = np.size(headct, 0)  # Imaging x dimension length in mm\n    Ny = np.size(headct, 1)  # Imaging y dimension length in mm\n    Nz = np.size(headct, 2)  # Imaging z dimension length in mm\n    Mx = 128  # Number of pixels in x direction\n    My = 128  # Number of pixels in y direction\n    h = 2  # distance(Z) bettween bottom of imaging volume and detector\n    H = h + Nz + 600  # distance(Z) bettween detector and x-ray source\n    dx = (H * Nx) / ((H - Nz - h) * Mx)  # distance x direction for each pixel\n    dy = (H * Ny) / ((H - Nz - h) * My)  # distance y direction for each pixel\n    D = max(dx, dy)  # Size of each pixel in mm\n    muBone = 0.573  # linear attenuation coefficient bone cm^-1\n    muFat = 0.193  # linear attenuation coefficient fat cm^-1\n    # offset from origin to detector start (X,Y,Z)\n    orginOffset = np.array(\n        [(-Mx * D) / 2 + (Nx / 2), (-My * D) / 2 + (Ny / 2), 0], dtype=np.float32)\n    # location of x-ray soruce\n    ep = np.array([Nx / 2, Ny / 2, H], dtype=np.float32)\n    # offset from origin to detector start\n    orginOffset = np.array(\n        [(-Mx * D) / 2 + (Nx / 2), (-My * D) / 2 + (Ny / 2), 0], dtype=np.float32)\n    # (Nx,Ny,Nz) linear attenuation coefficient matrix\n    mu = np.zeros((Nx, Ny, Nz), dtype=np.float32)\n    mu[np.nonzero(headct > 0)] = ((headct[np.nonzero(headct > 0)] - 0.3) / (0.7)) * \\\n        (muBone - muFat) + \\\n        muFat  # Normalization of givens mus of linear attenuation matrix\n    detA = main_loop(Nx, Ny, Nz, Mx, My, D, h, orginOffset, ep, mu)\n    detector = np.exp(detA * -10, dtype=np.float64)\n    fig = figure()\n    imshow(np.log(detector), extent=[0, Mx, 0, My], cmap='viridis')\n    title('Detector Log Image Python')\n    xlabel('X Pixel')\n    ylabel('Y Pixel')\n    colorbar()\n    savefig('plot.png')\n\n\nif __name__ == '__main__':\n    main()\n"""
