file_path,api_count,code
Car-Parrinello.py,20,"b'#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nimport math as m\nimport numpy as np\nimport matplotlib.pyplot as plt\nget_ipython().run_line_magic(\'matplotlib\', \'inline\')\n\n\n# ### References\n# \n# The referenced chapters, formulae and problems are from the book [Computational Physics, by Jos Thijssen](https://www.cambridge.org/core/books/computational-physics/BEE73B0139D4A9993193B57CDC62096E#fndtn-information).\n# I also added some info on the blog: https://compphys.go.ro/car-parrinello-quantum-molecular-dynamics/\n# \n# What follows is copied directly from hatree-fock.ipynb, check that one for details. The interesting new part is after this portion. If you already looked over the Hartree-Fock, you can skip it.\n\n# In[2]:\n\n\n# 3.26, 4.16\ndef Gaussian(alpha, r):\n    return m.exp(-alpha*r*r)\n\n\n# In[3]:\n\n\nalpha=(13.00773, 1.962079, 0.444529, 0.1219492)\n\n\n# In[4]:\n\n\n# see 4.114 and 4.116\ndef F0(t):\n    if t==0:\n        return 1.\n    p = m.sqrt(t)\n    a = 1. / p\n    return a * m.sqrt(m.pi) / 2. * m.erf(p)\n\n\n# In[5]:\n\n\n# 4.98\ndef Rp(alpha, beta, Ra, Rb):\n    return (alpha*Ra + beta*Rb) / (alpha + beta)\n\n\n# In[6]:\n\n\n# 4.100\ndef OverlapTwoCenters(alpha, beta, Ra, Rb):\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    return m.pow(m.pi / aplusb, 3./2.) * m.exp(-ab * len2)\n\n\n# In[7]:\n\n\n# 4.103\ndef KineticTwoCenters(alpha, beta, Ra, Rb):\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    O = m.pow(m.pi/aplusb, 3./2.) * m.exp(-ab * len2) # it\'s actually the overlap, check the OverlapTwoCenters\n    return ab * (3. - 2. * ab * len2) * O #this can be optimized with already computed overlap, see above\n\n\n# In[8]:\n\n\n# 4.115\ndef Nuclear(alpha, beta, Ra, Rb, Rc, Z = 1.):\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    difRc = Rp(alpha, beta, Ra, Rb) - Rc\n    len2c = difRc.dot(difRc)\n    K = m.exp(-ab*len2)\n    return -2. * m.pi * Z / aplusb * K * F0(aplusb*len2c)\n\n\n# In[9]:\n\n\n# 4.123\ndef TwoElectronTwoCenter(alpha, beta, gamma, delta, Ra, Rb, Rc, Rd):\n    RP = Rp(alpha, gamma, Ra, Rc)\n    RQ = Rp(beta, delta, Rb, Rd)\n    alphaplusgamma = alpha + gamma\n    betaplusdelta = beta + delta\n    Rac = Ra - Rc\n    Rbd = Rb - Rd\n    Rpq = RP - RQ\n    Racl2 = Rac.dot(Rac)\n    Rbdl2 = Rbd.dot(Rbd)\n    Rpql2 = Rpq.dot(Rpq)\n    return 2. * m.pow(m.pi, 5./2.) / (alphaplusgamma * betaplusdelta * m.sqrt(alphaplusgamma+betaplusdelta)) *            m.exp(-alpha*gamma/alphaplusgamma*Racl2 - beta*delta/betaplusdelta*Rbdl2) *           F0(alphaplusgamma*betaplusdelta / (alphaplusgamma+betaplusdelta) * Rpql2)\n\n\n# In[10]:\n\n\nbasisSize = 4 # for each atom\n\nX = 1. # distance between atoms\n\nR0 = np.array([0, 0, 0])\nR1 = np.array([X, 0, 0])\n\n\n# In[11]:\n\n\nH = np.zeros((basisSize * 2, basisSize * 2))\nO = np.zeros((basisSize * 2, basisSize * 2))\n\nfor i in range(basisSize):\n    a = alpha[i]\n    for j in range(basisSize):\n        b = alpha[j]\n        \n        O[i, j] = OverlapTwoCenters(a, b, R0, R0)\n        O[i, 4 + j] = OverlapTwoCenters(a, b, R0, R1)\n        O[4 + i, j] = O[i, 4 + j]\n        O[4 + i, 4 + j] = O[i, j]   \n        \n        H[i, j] = KineticTwoCenters(a, b, R0, R0) + Nuclear(a, b, R0, R0, R0) + Nuclear(a, b, R0, R0, R1)\n        H[i, 4 + j] = KineticTwoCenters(a, b, R0, R1) + Nuclear(a, b, R0, R1, R0) + Nuclear(a, b, R0, R1, R1)\n        H[4 + i, j] =  H[i, 4 + j]\n        H[4 + i, 4 + j] = H[i, j]\n\n\n# In[12]:\n\n\nQ = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\n\nfor i in range(basisSize):\n    a = alpha[i]\n    basisSizei = basisSize + i\n    for j in range(basisSize):\n        b = alpha[j]\n        basisSizej = basisSize + j\n        for k in range(basisSize):\n            c = alpha[k]\n            basisSizek = basisSize + k\n            for l in range(basisSize):\n                basisSizel = basisSize + l\n                d = alpha[l]        \n                \n                Q[i, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R0)\n                Q[i, j, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R1)\n                Q[i, j, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R0)\n                Q[i, j, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R1)\n                Q[i, basisSizej, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R0)\n                Q[i, basisSizej, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R1)\n                Q[i, basisSizej, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R0)\n                Q[i, basisSizej, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R1)\n                Q[basisSizei, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R0)\n                Q[basisSizei, j, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R1)\n                Q[basisSizei, j, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R0)\n                Q[basisSizei, j, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R1)\n                Q[basisSizei, basisSizej, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R0)\n                Q[basisSizei, basisSizej, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R1)\n                Q[basisSizei, basisSizej, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R0)\n                Q[basisSizei, basisSizej, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R1)  \n\n\n# In[13]:\n\n\nQt = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\nfor p in range(2*basisSize):\n    for q in range(2*basisSize):\n        for r in range(2*basisSize):\n            for s in range(2*basisSize):\n                Qt[p, q, r, s] = 2. * Q[p, q, r, s] - Q[p, r, s, q]\n\n\n# ### Car-Parrinello\n# \n# From here is the new part, specific to Car-Parrinello method.\n# \n# #### First, the part from 9.3.1, Car-Parrinello only for the electronic part.\n# \n# The computation can take a while, maybe it\'s not a good idea to launch it in binder.\n\n# In[14]:\n\n\nv = 0\nfor i in range(2 * basisSize):\n    for j in range(2 * basisSize):\n        v += O[i, j]\nv = 1. / m.sqrt(v)\n\nC = np.array([v, v, v, v, v, v, v, v])\nCprev = C.copy()\n\ndt = 0.1 # time step\ndt2 = dt * dt\ndt4 = dt2 * dt2\ngamma = 1. # frictional constant\n\nmass = 1\nmassMinusGamma = mass - 0.5*gamma*dt\nmassPlusGamma = mass + 0.5*gamma*dt\n\nnumPoints = 50\nenergies = np.zeros((numPoints))\n\n\n# In[15]:\n\n\nF = np.zeros((2*basisSize, 2*basisSize))\noldE = 100\n\nfor cycle in range(numPoints):\n\n    # Fock matrix computation\n    for i in range(2*basisSize):\n        for j in range(2*basisSize):\n            F[i, j] = H[i, j]\n            for k in range(2*basisSize):\n                for l in range(2*basisSize):\n                    F[i, j] += Qt[i, k, j, l] * C[k] * C[l]\n        \n    # compute energy\n    Eg = C.dot(H + F).dot(C) + 1. / X\n\n    #print(Eg)\n    \n    energies[cycle] = Eg\n    if abs(oldE-Eg) < 1E-12:\n        break    \n        \n    # Verlet\n                    \n    # compute Ct - 9.31, but with friction force added\n    \n    Ct = (2. * mass * C - massMinusGamma * Cprev - 4. * F.dot(C) * dt2) / massPlusGamma\n                \n    # determine lambda - see 9.32 - but be careful, it\'s wrong! Get it from 9.28 by replacing C[r] = Ct[r] - lambda * h^2 * sum(S[r, s]*C[s]), h^4 and h^2 are missing (here h is dt)\n     \n    OC = O.dot(C)\n    OCt = O.dot(Ct)\n    OOC = O.dot(OC)\n    \n    a = OOC.dot(OC) * dt4\n    b = -2. * OC.dot(OCt) * dt2\n    c = OCt.dot(Ct) - 1.\n    \n    delta = b*b - 4.*a*c\n    if delta < 0:\n        print(""Delta negative!"")\n        break\n        \n    sdelta = m.sqrt(delta)\n    lam1 = (-b-sdelta) / (2. * a)\n    lam2 = (-b+sdelta) / (2. * a)\n\n    if lam1 < 0:\n        lam = lam2\n    else:\n        lam = lam1\n    \n    # now adjust the newly computed Cs    \n    \n    Ct -= lam * dt2 * OC\n        \n    # switch to the next step\n    Cprev = C\n    C = Ct            \n    oldE = Eg\n\n\n# In[16]:\n\n\nprint(Eg)\n\n\n# In[17]:\n\n\nx = np.linspace(0, numPoints, numPoints)\nplt.plot(x, energies)\nplt.show()\n\n\n# In[18]:\n\n\nprint(C)\n\n\n# #### Now, the nuclear motion from 9.3.2\n# \n# Now some derivatives for the nuclear motion molecular dynamics. Again, those could be optimized by passing overlap and so on. For example a lot of things are computed here and also re-computed in the calls of the functions inside. \n# Also the computation would benefit from using symmetries to avoid computing many of the electron-electron integrals and also their derivative (it offers a roughly 8x speed improvement from this).\n# I\'m not going to bother, this is done in the C++ Hartree-Fock project, check that out for the details.\n\n# In[19]:\n\n\n# 9.39\ndef F0Deriv(t):\n    if t == 0:\n        return -1./3.\n    return (m.exp(-t) - F0(t))/(2. * t)\n\n\n# In[20]:\n\n\n# 9.34\ndef OverlapTwoCentersDeriv(alpha, beta, Ra, Rb, X):\n    difR = Ra - Rb\n    X2 = difR.dot(difR)\n    if X2 == 0:\n        return 0        \n    return -2. * alpha * beta / (alpha + beta) * X * OverlapTwoCenters(alpha, beta, Ra, Rb)\n\n\n# In[21]:\n\n\n# 9.36\ndef KineticTwoCentersDeriv(alpha, beta, Ra, Rb, X):\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    if len2 == 0:\n        return 0\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb # sigma in the book\n    ab2 = ab * ab\n    return -4. * ab2 * X * OverlapTwoCenters(alpha, beta, Ra, Rb) + (3 * ab - 2 * ab2 * X * X) * OverlapTwoCentersDeriv(alpha, beta, Ra, Rb, X)\n\n\n# In[22]:\n\n\n# 9.40 and 9.41\ndef NuclearDeriv(alpha, beta, Ra, Rb, X, Z = 1.):\n    aplusb = alpha + beta\n    theta = 2. * m.sqrt(aplusb/m.pi)\n    X2 = X * X\n    \n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    if len2 == 0:\n        return -2. * Z * theta * OverlapTwoCenters(alpha, beta, Ra, Rb) * F0Deriv(aplusb * X2) * X * aplusb # 9.40\n\n    alpha2 = alpha * alpha\n    beta2 = beta * beta\n    \n    t1 = alpha2 * X2 / aplusb # 9.42a\n    t2 = beta2 * X2 / aplusb  # 9.42b\n    \n    # 9.41\n    return -Z * theta * (OverlapTwoCentersDeriv(alpha, beta, Ra, Rb, X) * (F0(t1) + F0(t2)) + 2. / aplusb * X * OverlapTwoCenters(alpha, beta, Ra, Rb) * (F0Deriv(t1) * alpha2 + F0Deriv(t2) * beta2))\n\n\n# In[23]:\n\n\n# 9.47 - there is some renaming to have the same names as in TwoElectronTwoCenter\ndef TwoElectronTwoCenterDeriv(alpha, beta, gamma, delta, Ra, Rb, Rc, Rd, X):   \n    RP = Rp(alpha, gamma, Ra, Rc) # 9.38\n    RQ = Rp(beta, delta, Rb, Rd) # 9.45        \n    alphaplusgamma = alpha + gamma\n    betaplusdelta = beta + delta\n    PQ = RP - RQ\n    PQ2 = PQ.dot(PQ)\n    cdiv = alphaplusgamma * betaplusdelta / (alphaplusgamma+betaplusdelta)\n\n    t = cdiv * PQ2 # 9.44\n    rho = 2. * m.sqrt(cdiv / m.pi) # 9.46\n    F0t = F0(t)\n        \n    return rho * (\n        (OverlapTwoCentersDeriv(alpha, gamma, Ra, Rc, X) * OverlapTwoCenters(beta, delta, Rb, Rd) + \n        OverlapTwoCenters(alpha, gamma, Ra, Rc) * OverlapTwoCentersDeriv(beta, delta, Rb, Rd, X)) * F0t +\n        OverlapTwoCenters(alpha, gamma, Ra, Rc) * OverlapTwoCenters(beta, delta, Rb, Rd) * F0Deriv(t) * cdiv * 2 * PQ2 / X\n    )\n\n\n# In[24]:\n\n\nHDeriv = np.zeros((basisSize * 2, basisSize * 2))\nODeriv = np.zeros((basisSize * 2, basisSize * 2))\nQDeriv = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\nQtDeriv = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\nFDeriv = np.zeros((2*basisSize, 2*basisSize))\n\n\n# Here is the interesting part:\n\n# In[25]:\n\n\nX = 1.35\nXprev = X\nR1 = np.array([X, 0, 0])\n\nfor i in range(basisSize):\n    a = alpha[i]\n    for j in range(basisSize):        \n        b = alpha[j]\n        O[i, j] = OverlapTwoCenters(a, b, R0, R0)\n        O[i, 4 + j] = OverlapTwoCenters(a, b, R0, R1)\n        O[4 + i, j] = O[i, 4 + j]\n        O[4 + i, 4 + j] = O[i, j]  \n            \n# reinitialize Cs\nv = 0\nfor i in range(2 * basisSize):\n    for j in range(2 * basisSize):\n        v += O[i, j]\nv = 1. / m.sqrt(v)\n\nC = np.array([v, v, v, v, v, v, v, v])\nCprev = C.copy()    \n\nM = 1836.5 * mass\n\nnumPoints = 43\n\nNucleardt = numPoints * dt # 4.3 (atomic units)\nNucleardt2 = Nucleardt * Nucleardt\n\nnumNuclearPoints = 300\ndistances = np.zeros((numNuclearPoints))\n\n# friction stuff for nuclei\n\nNucleargamma = 15. # set it to zero if you want no \'friction\'\n\nMassMinusGamma = M - 0.5 * Nucleargamma * Nucleardt\nMassPlusGamma = M + 0.5 * Nucleargamma * Nucleardt\n\n\n# In[26]:\n\n\nfor nuclearCycle in range(numNuclearPoints):\n       \n    # recompute each time since the atoms positions change each nuclear cycle\n        \n    for i in range(basisSize):\n        a = alpha[i]\n        for j in range(basisSize):        \n            b = alpha[j]\n            O[i, j] = OverlapTwoCenters(a, b, R0, R0)\n            O[i, 4 + j] = OverlapTwoCenters(a, b, R0, R1)\n            O[4 + i, j] = O[i, 4 + j]\n            O[4 + i, 4 + j] = O[i, j]  \n        \n            H[i, j] = KineticTwoCenters(a, b, R0, R0) + Nuclear(a, b, R0, R0, R0) + Nuclear(a, b, R0, R0, R1)\n            H[i, 4 + j] = KineticTwoCenters(a, b, R0, R1) + Nuclear(a, b, R0, R1, R0) + Nuclear(a, b, R0, R1, R1)\n            H[4 + i, j] =  H[i, 4 + j]\n            H[4 + i, 4 + j] = H[i, j] \n            \n            for k in range(basisSize):\n                c = alpha[k]\n                for l in range(basisSize):\n                    d = alpha[l]                                    \n                    Q[i, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R0)\n                    Q[i, j, k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R1)\n                    Q[i, j, basisSize+k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R0)\n                    Q[i, j, basisSize+k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R1)\n                    Q[i, basisSize+j, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R0)\n                    Q[i, basisSize+j, k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R1)\n                    Q[i, basisSize+j, basisSize+k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R0)\n                    Q[i, basisSize+j, basisSize+k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R1)\n                    Q[basisSize+i, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R0)\n                    Q[basisSize+i, j, k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R1)\n                    Q[basisSize+i, j, basisSize+k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R0)\n                    Q[basisSize+i, j, basisSize+k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R1)\n                    Q[basisSize+i, basisSize+j, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R0)\n                    Q[basisSize+i, basisSize+j, k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R1)\n                    Q[basisSize+i, basisSize+j, basisSize+k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R0)\n                    Q[basisSize+i, basisSize+j, basisSize+k, basisSize+l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R1)       \n    \n    \n    for p in range(2*basisSize):\n        for q in range(2*basisSize):\n            for r in range(2*basisSize):\n                for s in range(2*basisSize):\n                    Qt[p, q, r, s] = 2. * Q[p, q, r, s] - Q[p, r, s, q]                    \n                    \n                 \n    # compute derivatives, similar for the other ones, but with removed computations for the same center for overlap and h derivatives, for the values that are zero\n    \n    for i in range(basisSize):        \n        a = alpha[i]\n        for j in range(basisSize):        \n            b = alpha[j]\n            ODeriv[i, 4 + j] = OverlapTwoCentersDeriv(a, b, R0, R1, X)\n            ODeriv[4 + i, j] = ODeriv[i, 4 + j]\n            \n            HDeriv[i, j] = NuclearDeriv(a, b, R0, R0, X)            \n            HDeriv[i, 4 + j] = NuclearDeriv(a, b, R0, R1, X) + KineticTwoCentersDeriv(a, b, R0, R1, X)\n            HDeriv[4 + i, j] = HDeriv[i, 4 + j]\n            HDeriv[4 + i, 4 + j] = HDeriv[i, j] \n    \n            for k in range(basisSize):\n                c = alpha[k]\n                for l in range(basisSize):\n                    d = alpha[l]                                    \n                    QDeriv[i, j, k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R0, R0, R0, X)\n                    QDeriv[i, j, k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R0, R0, R1, X)\n                    QDeriv[i, j, basisSize+k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R0, R1, R0, X)\n                    QDeriv[i, j, basisSize+k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R0, R1, R1, X)\n                    QDeriv[i, basisSize+j, k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R1, R0, R0, X)\n                    QDeriv[i, basisSize+j, k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R1, R0, R1, X)\n                    QDeriv[i, basisSize+j, basisSize+k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R1, R1, R0, X)\n                    QDeriv[i, basisSize+j, basisSize+k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R0, R1, R1, R1, X)\n                    QDeriv[basisSize+i, j, k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R0, R0, R0, X)\n                    QDeriv[basisSize+i, j, k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R0, R0, R1, X)\n                    QDeriv[basisSize+i, j, basisSize+k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R0, R1, R0, X)\n                    QDeriv[basisSize+i, j, basisSize+k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R0, R1, R1, X)\n                    QDeriv[basisSize+i, basisSize+j, k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R1, R0, R0, X)\n                    QDeriv[basisSize+i, basisSize+j, k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R1, R0, R1, X)\n                    QDeriv[basisSize+i, basisSize+j, basisSize+k, l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R1, R1, R0, X)\n                    QDeriv[basisSize+i, basisSize+j, basisSize+k, basisSize+l]=TwoElectronTwoCenterDeriv(a, b, c, d, R1, R1, R1, R1, X)       \n     \n    \n    for p in range(2*basisSize):\n        for q in range(2*basisSize):\n            for r in range(2*basisSize):\n                for s in range(2*basisSize):\n                    QtDeriv[p, q, r, s] = 2. * QDeriv[p, q, r, s] - QDeriv[p, r, s, q]\n\n                    \n    # the electronic loop - it\'s identical with the one above that\'s done only for electronic part, with the energy computation moved out of it\n\n    for cycle in range(numPoints):\n\n        # Fock matrix computation\n        for i in range(2*basisSize):\n            for j in range(2*basisSize):\n                F[i, j] = H[i, j]\n                for k in range(2*basisSize):\n                    for l in range(2*basisSize):\n                        F[i, j] += Qt[i, k, j, l] * C[k] * C[l]\n                \n        # Verlet for electrons\n                    \n        # compute Ct - 9.31, but with friction force added\n            \n        Ct = (2. * mass * C - massMinusGamma * Cprev - 4. * F.dot(C) * dt2) / massPlusGamma\n                \n        # determine lambda - see 9.32 - but be careful, it\'s wrong! Get it from 9.28 by replacing C[r] = Ct[r] - lambda * h^2 * sum(S[r, s]*C[s]), h^4 and h^2 are missing (here h is dt)\n     \n        OC = O.dot(C)\n        OCt = O.dot(Ct)\n        OOC = O.dot(OC)\n    \n        a = OOC.dot(OC) * dt4\n        b = -2. * OC.dot(OCt) * dt2\n        c = OCt.dot(Ct) - 1.\n        \n        delta = b*b - 4.*a*c\n        if delta < 0:\n            print(""Delta negative!"")\n            break\n        \n        sdelta = m.sqrt(delta)\n        lam1 = (-b-sdelta) / (2. * a)\n        lam2 = (-b+sdelta) / (2. * a)\n\n        if lam1 < 0:\n            lam = lam2\n        else:\n            lam = lam1\n    \n        # now adjust the newly computed Cs    \n    \n        Ct -= lam * dt2 * OC\n        \n        # switch to the next step\n        Cprev = C\n        C = Ct            \n                        \n        # end electronic loop\n        \n\n    # compute energy\n    #Eg = C.dot(H + F).dot(C) + 1. / X\n    #print(Eg)\n                        \n    # verlet for nuclear\n                     \n    for i in range(2*basisSize):\n        for j in range(2*basisSize):\n            FDeriv[i, j] = HDeriv[i, j]\n            for k in range(2*basisSize):\n                for l in range(2*basisSize):\n                    FDeriv[i, j] += QtDeriv[i, k, j, l] * C[k] * C[l]\n    \n    lam *= massPlusGamma * 0.5 # correction - there is a 2 factor in the lambda, also needs to be adjusted because of the massPlusGamma division\n                \n    # C.dot(ODeriv).dot(C) can be reduced to a quarter, knowing that diagonal sectors are zero\n    LambdaFactor = 0\n    for i in range(basisSize):\n        for j in range(basisSize):\n            LambdaFactor += ODeriv[basisSize + i, j] * C[basisSize + i] * C[j]\n            LambdaFactor += ODeriv[i, basisSize + j] * C[i] * C[basisSize + j]\n        \n    FNuclear = C.dot(HDeriv + FDeriv).dot(C) - 1. / (X * X) + lam * LambdaFactor\n    \n    Xnew = (2. * M * X - MassMinusGamma * Xprev - 2. * FNuclear * Nucleardt2) / MassPlusGamma\n        \n    # switch to the next step\n    Xprev = X\n    X = Xnew\n    \n    # also update the nuclei position\n    R1 = np.array([X, 0, 0]) \n    \n    distances[nuclearCycle] = X\n\n\n# In[27]:\n\n\nx = np.linspace(0, numNuclearPoints, numNuclearPoints)\n\nplt.rcParams[""figure.figsize""] = (20,5)\nplt.plot(x, distances)\n\n\n# In[28]:\n\n\nprint(X) # the experimental value given in the book is 1.401, the equilibrium with Hartree-Fock using only s-type orbitals is 1.3881\n\n\n# In[ ]:\n\n\n\n\n'"
hartree-fock.py,24,"b""#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nimport math as m\nimport numpy as np\nfrom scipy.linalg import eigh\nimport matplotlib.pyplot as plt\nget_ipython().run_line_magic('matplotlib', 'inline')\n\n\n# ### References\n# \n# The referenced chapters, formulae and problems are from the book [Computational Physics, by Jos Thijssen](https://www.cambridge.org/core/books/computational-physics/BEE73B0139D4A9993193B57CDC62096E#fndtn-information).\n# \n# This is only introductory material for more advanced topics/code presented on the [Computational Physics Blog](https://compphys.go.ro).\n# \n# Related with Hartree-Fock I would recommend visiting:\n# [How to solve a quantum many body problem](https://compphys.go.ro/how-to-solve-a-quantum-many-body-problem/) - on Born-Oppenheimer approximation, diagonalization and variational primciple (on this one you may find several other topics on the blog).\n# \n# [The Hartree-Fock program](https://compphys.go.ro/the-hartree-fock-program/) - describes a C++ project I have on GitHub: [HartreeFock](https://github.com/aromanro/HartreeFock) which goes way beyond the following simple issues.\n# \n# \n\n# ### From here, the variational Hydrogen computation, chapter 3\n# \n# We're starting using Gaussians as basis functions. Here only $\\Phi(r)=e^{-\\alpha r^2}$. For the more complex ones and the details on the many centers cases, please check out the blog and the C++ Hartree-Fock project.\n\n# In[2]:\n\n\n# 3.26, 4.16\ndef Gaussian(alpha, r):\n    return m.exp(-alpha*r*r)\n\n\n# In[3]:\n\n\nalpha=(13.00773, 1.962079, 0.444529, 0.1219492) # from 3.27\n#alpha=(14, 2, 0.5, 0.1) # try something different here to see how it affects the results\n\n\n# Let's see how they look like:\n\n# In[4]:\n\n\nf = np.zeros((100, 4))\nr = np.linspace(0, 4, 100)\nfor i in range(100):\n    for j in range(4):\n        f[i, j] = Gaussian(alpha[j], r[i])\n        \nplt.plot(r, f)\nplt.show()\n\n\n# Integrals are very simple, the gaussians are centered in the same point (the nucleus), see eqn 3.29:\n\n# In[5]:\n\n\ndef Overlap(alpha, ind1, ind2):\n    return m.pow(m.pi/(alpha[ind1] + alpha[ind2]), 3./2.)\n\n\n# In[6]:\n\n\ndef Kinetic(alpha, ind1, ind2):\n    return 3*alpha[ind1]*alpha[ind2]*m.pow(m.pi, 3./2.)/m.pow(alpha[ind1] + alpha[ind2],5./2.)\n\n\n# In[7]:\n\n\ndef Coulomb(alpha, ind1, ind2):\n    return -2 * m.pi / (alpha[ind1] + alpha[ind2])\n\n\n# The basis functions are not orthogonal, so we have to solve the generalized eigenvalue problem, using the overlap:\n\n# In[8]:\n\n\nbasisSize = 4\n\n\n# In[9]:\n\n\nH = np.zeros((basisSize, basisSize))\nO = np.zeros((basisSize, basisSize))\nfor i in range(basisSize):\n    H[i, i] = Kinetic(alpha, i, i) + Coulomb(alpha, i, i)\n    O[i, i] = Overlap(alpha, i, i)\n    for j in range(i):\n        H[i, j] = Kinetic(alpha, i, j) + Coulomb(alpha, i, j)\n        O[i, j] = Overlap(alpha, i, j)\n        H[j, i] = H[i, j]\n        O[j, i] = O[i, j]\n\n\n# In[10]:\n\n\neigvals, eigvecs = eigh(H, O, eigvals_only=False)\n\n\n# In[11]:\n\n\nprint(eigvals[0])\n\n\n# The exact result is -0.5 (here we use atomic units, the energy is in Hartrees).\n# \n# The result here is quite good (you can often do that if you know the exact result in advance). DFTAtom gets -0.445 (that's the expected result for LDA, check out [NIST](https://www.nist.gov/pml/atomic-reference-data-electronic-structure-calculations/atomic-reference-data-electronic-7-0)) and HartreeFock (unrestricted) with STO6G gets -0.471. With the Variational Quantum Monte Carlo project with STO6G I also got -0.471. As the problem is analytically solvable and one knows the result, it's no surprise that the result is so good. One just has to ensure that the space spanned by the basis vectors includes as much as possible of the real solution.\n# \n# Now let's look at the computed wavefunction together with the exact solution:\n\n# In[12]:\n\n\ndef Wavefunction(alpha, eigenvecs, r, ind = 0):\n    v = 0.\n    for i in range(basisSize):\n        v += eigenvecs[i, ind] * Gaussian(alpha[i], r)\n    return v\n\n\n# In[13]:\n\n\nr = np.linspace(0, 2, 100)\nw = np.zeros((100, 2))\nfor i in range(100):\n    w[i, 0] = np.abs(Wavefunction(alpha, eigvecs, r[i]))\n    w[i, 1] = 1. / np.sqrt(np.pi) * np.exp(-r[i])\n\n\n# In[14]:\n\n\nplt.plot(r, w)\nplt.show()\n\n\n# ### Chap 4, Helium computation\n\n# In[15]:\n\n\nalpha = (0.298073, 1.242567, 5.782948, 38.47497)\n\n\n# In[16]:\n\n\n# 4.11\ndef TwoElectronSingleCenter(alpha, p, r, q, s):\n    return 2. * m.pow(m.pi, 5. / 2.) / ((alpha[p]+alpha[q])*(alpha[r]+alpha[s])*m.sqrt(alpha[p]+alpha[q]+alpha[r]+alpha[s]))\n\n\n# In[17]:\n\n\nH = np.zeros((basisSize, basisSize))\nO = np.zeros((basisSize, basisSize))\nQ = np.zeros((basisSize, basisSize, basisSize, basisSize))\n\nfor i in range(basisSize):\n    for j in range(basisSize):\n        H[i, j] = Kinetic(alpha, i, j) + 2. * Coulomb(alpha, i, j) #the 2 is due of Z=2 for Helium\n        O[i, j] = Overlap(alpha, i, j)\n        for k in range(basisSize):\n            for l in range(basisSize):\n                Q[i, j, k, l]=TwoElectronSingleCenter(alpha, i, j, k, l)\n\n\n# In[18]:\n\n\nv = 0\nfor i in range(basisSize):\n    for j in range(basisSize):\n        v += O[i, j]\nv = 1. / m.sqrt(v)\n\nC = np.array([v, v, v, v]) # a choice for C to start with. Check the commented one instead\n#C = np.array([1, 1, 1, 1])\n\n\n# In[19]:\n\n\nF = np.zeros((basisSize, basisSize))\noldE = 100\n\nfor cycle in range(100):\n    \n    # 4.18\n    for i in range(basisSize):\n        for j in range(basisSize):\n            F[i, j] = H[i, j]\n            for k in range(basisSize):\n                for l in range(basisSize):\n                    F[i, j] += Q[i, k, j, l] * C[k] * C[l]\n\n    # 4.20\n    eigvals, eigvecs = eigh(F, O, eigvals_only=False)\n\n    C = eigvecs[:,0]\n\n    # 4.21\n    Eg = 0\n    for i in range(basisSize):\n        for j in range(basisSize):\n            Eg += 2 * C[i] * C[j] * H[i, j]\n            for k in range(basisSize):\n                for l in range(basisSize):\n                    Eg += Q[i, k, j, l] * C[i] * C[j] * C[k] * C[l]\n    \n    if abs(oldE-Eg) < 1E-10:\n        break\n    \n    oldE = Eg\n\n\n# In[20]:\n\n\nprint(Eg)\n\n\n# HartreeFock with STO6G gets here -2.846 (but with a basis set with more Gaussians, you certainly can get better results), DFTAtom -2.8348 (again, that's normal for LDA: [NIST](https://www.nist.gov/pml/atomic-reference-data-electronic-structure-calculations/atomic-reference-data-electronic-7-1)) and the Variational Quantum Monte Carlo, -2.8759. The later 'beats' the result obtained here. \n\n# ### The first problem, H2+ (problem 4.8)\n# \n# Now we have two centers so intergrals get more complex. You may simplify some integrals computation by using the already computed overlap, such optimizations are left out from here, they exist in the C++ project. For the H2+, as there is a single electron, we don't need a self-consistency loop.\n\n# In[21]:\n\n\n# see 4.114 and 4.116\ndef F0(t):\n    if t==0:\n        return 1.\n    p = m.sqrt(t)\n    a = 1. / p\n    return a * m.sqrt(m.pi) / 2. * m.erf(p)\n\n\n# In[22]:\n\n\n# 4.98\ndef Rp(alpha, beta, Ra, Rb):\n    return (alpha*Ra + beta*Rb) / (alpha + beta)\n\n\n# In[23]:\n\n\n# 4.100\ndef OverlapTwoCenters(alpha, beta, Ra, Rb):\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    return m.pow(m.pi / aplusb, 3./2.) * m.exp(-ab * len2)\n\n\n# In[24]:\n\n\n# 4.103\ndef KineticTwoCenters(alpha, beta, Ra, Rb):\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    O = m.pow(m.pi/aplusb, 3./2.) * m.exp(-ab * len2) # it's actually the overlap, check the OverlapTwoCenters\n    return ab * (3. - 2. * ab * len2) * O #this can be optimized with already computed overlap, see above\n\n\n# In[25]:\n\n\n# 4.115\ndef Nuclear(alpha, beta, Ra, Rb, Rc, Z = 1.):\n    aplusb = alpha + beta\n    ab = alpha * beta / aplusb\n    difR = Ra - Rb\n    len2 = difR.dot(difR)\n    difRc = Rp(alpha, beta, Ra, Rb) - Rc\n    len2c = difRc.dot(difRc)\n    K = m.exp(-ab*len2)\n    return -2. * m.pi * Z / aplusb * K * F0(aplusb*len2c)\n\n\n# In[26]:\n\n\n# 4.123\ndef TwoElectronTwoCenter(alpha, beta, gamma, delta, Ra, Rb, Rc, Rd):\n    RP = Rp(alpha, gamma, Ra, Rc)\n    RQ = Rp(beta, delta, Rb, Rd)\n    alphaplusgamma = alpha + gamma\n    betaplusdelta = beta + delta\n    Rac = Ra - Rc\n    Rbd = Rb - Rd\n    Rpq = RP - RQ\n    Racl2 = Rac.dot(Rac)\n    Rbdl2 = Rbd.dot(Rbd)\n    Rpql2 = Rpq.dot(Rpq)\n    return 2. * m.pow(m.pi, 5./2.) / (alphaplusgamma * betaplusdelta * m.sqrt(alphaplusgamma+betaplusdelta)) *            m.exp(-alpha*gamma/alphaplusgamma*Racl2 - beta*delta/betaplusdelta*Rbdl2) *           F0(alphaplusgamma*betaplusdelta / (alphaplusgamma+betaplusdelta) * Rpql2)\n\n\n# In[27]:\n\n\nalpha=(13.00773, 1.962079, 0.444529, 0.1219492)\n\n\n# In[28]:\n\n\nbasisSize = 4 # for each atom\n\n\n# In[29]:\n\n\nH = np.zeros((basisSize * 2, basisSize * 2))\nO = np.zeros((basisSize * 2, basisSize * 2))\nR0 = np.array([0, 0, 0])\nR1 = np.array([1, 0, 0])\nfor i in range(basisSize):\n    a = alpha[i]    \n    basisSizei = basisSize + i\n    for j in range(basisSize):        \n        b = alpha[j]        \n        basisSizej = basisSize + j\n        O[i, j] = OverlapTwoCenters(a, b, R0, R0)\n        O[basisSizei, j] = OverlapTwoCenters(a, b, R1, R0)\n        O[i, basisSizej] = OverlapTwoCenters(a, b, R0, R1)\n        O[basisSizei, basisSizej] = OverlapTwoCenters(a, b, R1, R1)\n        H[i, j] = KineticTwoCenters(a, b, R0, R0) + Nuclear(a, b, R0, R0, R0) + Nuclear(a, b, R0, R0, R1)\n        H[basisSizei, j] = KineticTwoCenters(a, b, R1, R0) + Nuclear(a, b, R1, R0, R0) + Nuclear(a, b, R1, R0, R1)\n        H[i, basisSizej] = KineticTwoCenters(a, b, R0, R1) + Nuclear(a, b, R0, R1, R0) + Nuclear(a, b, R0, R1, R1)\n        H[basisSizei, basisSizej] = KineticTwoCenters(a, b, R1, R1) + Nuclear(a, b, R1, R1, R0) + Nuclear(a, b, R1, R1, R1)\n\n\n# In[30]:\n\n\neigvals, eigvecs = eigh(H, O, eigvals_only=False)\n\n\n# In[31]:\n\n\nprint(eigvals)\n\n\n# ### Now the next problem, for H2 (problem 4.9) - here only the Hartree equation is solved\n# \n# Filling the Q tensor looks ugly but I think it's better to leave it like that. If you want, you may make it prettier by observing that you can count from 0 to 0xF and use the proper bit to select to pass R0 or R1 and to select the proper sector of the tensor.\n\n# In[32]:\n\n\nQ = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\nfor i in range(basisSize):\n    a = alpha[i]\n    basisSizei = basisSize + i\n    for j in range(basisSize):\n        b = alpha[j]\n        basisSizej = basisSize + j\n        for k in range(basisSize):\n            c = alpha[k]\n            basisSizek = basisSize + k\n            for l in range(basisSize):\n                basisSizel = basisSize + l\n                d = alpha[l]                \n                Q[i, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R0)\n                Q[i, j, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R0, R1)\n                Q[i, j, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R0)\n                Q[i, j, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R0, R1, R1)\n                Q[i, basisSizej, k, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R0)\n                Q[i, basisSizej, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R0, R1)\n                Q[i, basisSizej, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R0)\n                Q[i, basisSizej, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R0, R1, R1, R1)\n                Q[basisSizei, j, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R0)\n                Q[basisSizei, j, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R0, R1)\n                Q[basisSizei, j, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R0)\n                Q[basisSizei, j, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R0, R1, R1)\n                Q[basisSizei, basisSizej, k, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R0)\n                Q[basisSizei, basisSizej, k, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R0, R1)\n                Q[basisSizei, basisSizej, basisSizek, l]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R0)\n                Q[basisSizei, basisSizej, basisSizek, basisSizel]=TwoElectronTwoCenter(a, b, c, d, R1, R1, R1, R1)              \n\n\n# In[33]:\n\n\nv = 0\nfor i in range(2 * basisSize):\n    for j in range(2 * basisSize):\n        v += O[i, j]\nv = 1. / m.sqrt(v)\n\nC = np.array([v, v, v, v, v, v, v, v])\n\n\n# In[34]:\n\n\nF = np.zeros((2*basisSize, 2*basisSize))\noldE = 100\n\nfor cycle in range(100):\n\n    for i in range(2*basisSize):\n        for j in range(2*basisSize):\n            F[i, j] = H[i, j]\n            for k in range(2*basisSize):\n                for l in range(2*basisSize):\n                    F[i, j] += Q[i, k, j, l] * C[k] * C[l]\n\n    eigvals, eigvecs = eigh(F, O, eigvals_only=False)\n\n    C = eigvecs[:,0]\n\n#    Eg = 0\n#    for i in range(2*basisSize):\n#        for j in range(2*basisSize):\n#            Eg += 2 * C[i] * C[j] * H[i, j]\n#            for k in range(2*basisSize):\n#                for l in range(2*basisSize):\n#                    Eg += Q[i, k, j, l] * C[i] * C[j] * C[k] * C[l]\n\n    Eg = C.dot(H + F).dot(C)\n     \n    if abs(oldE-Eg) < 1E-10:\n        break\n    \n    oldE = Eg\n\n\n# In[35]:\n\n\nprint(Eg + 1) # +1 for nuclear repulsion energy\n\n\n# In[36]:\n\n\nprint(C)\n\n\n# ### Now the next problem, for H2 (problem 4.12) - but now with Hartree-Fock\n# \n# Here there are a lot of optimizations suggested in the book - for the electron-electron integrals, one can reduce roughly to 1/8 the number of computed integrals using symmetry. Instead of solving the general eigenvalue problem each selfconsistency step you can go with solving only the regular eigenvalue problem, for details please check the book and the C++ HartreeFock project. I didn't want to go with those here.\n\n# In[37]:\n\n\nQt = np.zeros((basisSize*2, basisSize*2, basisSize*2, basisSize*2))\nfor p in range(2*basisSize):\n    for q in range(2*basisSize):\n        for r in range(2*basisSize):\n            for s in range(2*basisSize):\n                Qt[p, q, r, s] = 2. * Q[p, q, r, s] - Q[p, r, s, q]\n\n\n# In[38]:\n\n\nC = np.array([v, v, v, v, v, v, v, v]) #reinitialize C\n\n\n# In[39]:\n\n\n# as above, but Hartree-Fock with Qt instead of Q\nF = np.zeros((2*basisSize, 2*basisSize))\noldE = 100\n\nfor cycle in range(100):\n\n    for i in range(2*basisSize):\n        for j in range(2*basisSize):\n            F[i, j] = H[i, j]\n            for k in range(2*basisSize):\n                for l in range(2*basisSize):\n                    F[i, j] += Qt[i, k, j, l] * C[k] * C[l]\n\n    eigvals, eigvecs = eigh(F, O, eigvals_only=False)\n\n    C = eigvecs[:,0]\n    \n    Eg = C.dot(H + F).dot(C)\n       \n    if abs(oldE-Eg) < 1E-10:\n        break\n    \n    oldE = Eg\n\n\n# In[40]:\n\n\nprint(Eg + 1) # +1 for nuclear repulsion energy\n\n\n# We obtain the same result as above, despite using Hartree-Fock, because we have only two electrons, one with spin up, one with down, so no spin-exchange.\n# \n# With the C++ Hartree-Fock project, restricted method with STO6G, the result is -1.0758. Again, with a better basis set the result could be much better. With the Variational Quantum Monte Carlo method I got -1.092, again, better than the result above.\n\n# In[41]:\n\n\nprint(C)\n\n\n# In[ ]:\n\n\n\n\n"""
