file_path,api_count,code
setup.py,0,"b""#from distutils.core import setup\nfrom setuptools import setup\n\ndef readme():\n    with open('README.rst') as f:\n        return f.read()\n\nsetup(\n    name = 'mementor',\n    packages = ['mementor'], # this must be the same as the name above\n    version = '1.0.4',\n    description = 'A library to fetch images from directory to fix orientation and pull OCR from the images along with editing the text inside images, primarily focusing on memes',\n    long_description = readme(),\n    author = 'Sunim Acharya',\n    author_email = 'sunim.54@gmail.com',\n    url = 'https://github.com/aryaminus/memento', # use the URL to the github repo\n    keywords = ['ocr', 'image', 'opencv', 'tesseract', 'orientation'], # arbitrary keywords\n    classifiers = [],\n    install_requires=[\n        'pillow', 'pyocr', 'numpy', 'tesseract'\n    ],\n    include_package_data=True,\n    zip_safe=False,\n    entry_points={\n    'console_scripts': [\n        'memento = mementor.memento:start'\n    ]},\n)"""
mementor/__init__.py,0,"b""from memento.memento import start\nif __name__ == '__main__': #Execute all code before reading source file, ie. execute import, evaluate def to equal name to main\n    start()"""
mementor/image_crop.py,0,"b'import numpy\nimport PIL.Image as Im\nfrom PIL import Image as Im\n\nimport cv2\n\n\n# Selects the image coords for the Twitter pic\ndef getContourCoords(pic_contour):\n\ty0 = min(pic_contour[0][0][1],pic_contour[1][0][1],pic_contour[2][0][1],pic_contour[3][0][1])\n\ty1 = max(pic_contour[0][0][1],pic_contour[1][0][1],pic_contour[2][0][1],pic_contour[3][0][1])\n\tx0 = min(pic_contour[0][0][0],pic_contour[1][0][0],pic_contour[2][0][0],pic_contour[3][0][0])\n\tx1 = max(pic_contour[0][0][0],pic_contour[1][0][0],pic_contour[2][0][0],pic_contour[3][0][0])\n\treturn (y0,y1,x0,x1)\n\nclass croper(object):\n    \n    def __init__(self):\n        print(\'Cropping in process\')\n\n    # Add a white border to every image\n    def addWhiteBorder(self, filename):\n        im_naked = Im.open(filename)\n        naked_size = im_naked.size\n        bordered_size = (int(naked_size[0]*1.1), int(naked_size[1]*1.1))\n        im_bordered = Im.new(""RGB"", bordered_size, color = (255,255,255))\n        im_bordered.paste(im_naked, ((bordered_size[0]-naked_size[0])//2,(bordered_size[1]-naked_size[1])//2))\n        return im_bordered\n\n    # Converts PIL image format to OpenCV format\n    def convertPILtoOpenCV(self, border):\n        open_cv_image = numpy.array(border)[:, :, ::-1].copy()\n        return open_cv_image\n\n    # Use OpenCV to find the contours of the input image\n    def getContours(self, im):\n        im_gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)\n        im_gray = cv2.bilateralFilter(im_gray, 11, 17, 17)\n        ret, thresh = cv2.threshold(im_gray, 240, 240, 0)\n        im2, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n        return contours\n\n    # Select the second largest rectangular contour\n    def getPicContour(self, contours):\n        # sort the contours by area, of these, take the top ten largest contours\n        contours = sorted(contours, key = cv2.contourArea, reverse = True)[:10]\n        pic_contour = None\n        count = 0\n        for contour in contours:\n            # approximate the shape of the contour\n            peri = cv2.arcLength(contour, True)\n            approx = cv2.approxPolyDP(contour, 0.02 * peri, True)\n            if len(approx) == 4:\n                pic_contour = approx\n                count = count + 1\n                if count == 2:\n                    break\n        return pic_contour\n\n    # Crop the input image around the pic coords, and save the cropped image\n    # also crops the input image around the text, and saves the cropped text\n    def saveCroppedImages(self, im, pic_contour, filename, directory_path_text, directory_path_pic, ext):\n        (y0,y1,x0,x1) = getContourCoords(pic_contour)\n        text_cropped = im[0:y0,:]\n        text_img_name = filename + \'_text\' + ext\n        text_img_name = directory_path_text + text_img_name\n        cv2.imwrite(text_img_name,text_cropped)\n        # print ""Text component saved as: "" + str(text_img_name)\n        im_cropped = im[y0:y1, x0:x1]\n        pic_img_name = \'Mem_\' + filename + ext\n        pic_img_name = directory_path_pic + pic_img_name\n        cv2.imwrite(pic_img_name,im_cropped)\n\n    def main(self, image_file_name, filename, directory_path_text, directory_path_pic, ext):\n                \n        border = self.addWhiteBorder(image_file_name)\n        im = self.convertPILtoOpenCV(border)\n        contour = self.getContours(im)\n        pic_contour = self.getPicContour(contour)\n        self.saveCroppedImages(im, pic_contour, filename, directory_path_text, directory_path_pic, ext)\n\ndef image_crop_main(image_file_name, filename, directory_path_text, directory_path_pic, ext):\n    #print(path)\n    s = croper()\n    s.main(image_file_name, filename, directory_path_text, directory_path_pic, ext) # Def main to path\n'"
mementor/image_join.py,0,"b'import math\nimport os\nimport textwrap\n\nimport PIL\nfrom PIL import Image, ImageDraw, ImageFont\n\n\n## calculates the bounding area needed for the text-box\ndef calculate_text_bbox(text):\n\tchars_per_line = float(36)\n\tline_height = 72\n\tnumber_of_lines = int(math.ceil(len(text)/chars_per_line))\n\ttext_box_height = number_of_lines*line_height\n\treturn (1000, text_box_height)\n\n## calculates the dimensions of the pic after resizing to match text-box width\n## TODO: hardcoded 1000px\ndef get_new_pic_dim(pic):\n\tbbox = pic.getbbox()\n\twidth  = bbox[2]\n\theight = bbox[3]\n\taspect_ratio = float(width)/float(height)\n\tnew_height = int(1000 / aspect_ratio)\n\treturn (1000, new_height)\n\n## calculates the bounding area needed for the content-box, i.e. the area taken\n## up by the text-box and pic with appropriate spacing included\ndef calculate_content_bbox(text_bbox, pic_bbox, spacing):\n\tpx_between_text_and_pic = spacing[0]\n\tmargin = spacing[1]\n\toffset = spacing[2]\n\tcontent_bbox_width  = offset + pic_bbox[0] + offset\n\tcontent_bbox_height = margin + text_bbox[1] + px_between_text_and_pic + pic_bbox[1] + margin\n\tcontent_bbox = (content_bbox_width, content_bbox_height)\n\treturn content_bbox\n\n## places the given text string onto the given image with the correct spacing\ndef place_text(img, text, spacing):\n\tdraw = ImageDraw.Draw(img)\n\tmargin = spacing[1]\n\toffset = spacing[2]\n\tfont = ImageFont.truetype(""arial.ttf"",60)\n\tchars_per_line = float(36)\n\tfor line in textwrap.wrap(text, width=chars_per_line):\n\t\tdraw.text((margin, offset), line, font=font, fill=""black"")\n\t\toffset += font.getsize(line)[1]\n\n## resizes the given image according to the given width, maintaining aspect ratio\n## TODO: redundant code here with get_new_pic_dim()\ndef resize_img(image, new_width):\n\tbbox = image.getbbox()\n\twidth  = bbox[2]\n\theight = bbox[3]\n\taspect_ratio = float(width)/float(height)\n\tnew_height = int(new_width / aspect_ratio)\n\timage = image.resize((new_width,new_height))\n\treturn image\n\n## pastes the given pic onto the canvas with the appropriate spacing\ndef paste_pic(pic, canvas, spacing):\n\tpx_between_text_and_pic = spacing[0]\n\tmargin = spacing[1]\n\ttext_bbox_width = spacing[3]\n\ttext_bbox_height = spacing[4]\n\tpic = resize_img(pic, text_bbox_width)\n\tbox = (margin, margin + text_bbox_height + px_between_text_and_pic)\n\tcanvas.paste(pic, box=box, mask=None)\n\nclass ijoin(object):\n    \n    def __init__(self):\n        print(\'Joining in process\')\n\n    def main(self, text, image_path, path, new_img_name):\n        width = height = 1080\n        margin = offset = 40\n        px_between_text_and_pic = 57\n        spacing = [px_between_text_and_pic, margin, offset]\n        pic = Image.open(image_path)\n        text_bbox = calculate_text_bbox(text)\n        text_bbox_width = text_bbox[0]\n        text_bbox_height = text_bbox[1]\n        spacing.append(text_bbox_width)\n        spacing.append(text_bbox_height)\n        pic_bbox = get_new_pic_dim(pic)\n        content_bbox = calculate_content_bbox(text_bbox, pic_bbox, spacing)\n        canvas = Image.new(""RGB"", (content_bbox[0], content_bbox[1]), (255,255,255))\n        place_text(canvas, text, spacing)\n        paste_pic(pic, canvas, spacing)\n        max_demision = max(content_bbox)\n        background = Image.new(""RGB"", (max_demision, max_demision), (255,255,255))\n        box = [abs((content_bbox[0] - max_demision))//2, abs((content_bbox[1] - max_demision)//2)]\n        background.paste(canvas, box=box, mask=None)\n        background.resize((width,height)) \n        \n        os.chmod(path, 0o777) \n        background.save(new_img_name)\n                \ndef image_join_main(new_text, pic_img_name, path, new_img_name):\n    #print(path)\n    s = ijoin()\n    s.main(new_text, pic_img_name, path, new_img_name) # Def main to path\n'"
mementor/image_make.py,0,"b'import os\nimport shutil\nimport sys\n\nfrom .image_crop import image_crop_main\nfrom .image_join import image_join_main\nfrom .image_ocr import image_ocr_main\n\nVALIDITY = ["".jpg"","".gif"","".png"","".tga"","".tif"","".bmp""]\n\nclass maker(object):\n    \n    def __init__(self):\n        print(\'Edit Initialization \\n\')\n    \n    def create_directory(self, directory_path_text,directory_path_pic):\n        if not os.path.exists(directory_path_text): #No path\n\t        os.makedirs(directory_path_text) #Create path\n        if not os.path.exists(directory_path_pic): #No path\n\t        os.makedirs(directory_path_pic) #Create path\n\n    def editext(self, text):\n        while True:\n            print(\'\\nCurrent text: \\n\' + text)\n            prompt = "" [1/2/3]: ""\n            sys.stdout.write(\' \\n 1) Edit text \\n 2) Replace word \\n 3) Change complete \' + prompt)\n            choice = input()\n            if choice[0] == \'1\':\n                print (\'\\nEnter new text:\')\n                text = input()\n            elif choice[0] == \'2\':\n                print(\'\\n Enter word to replace:\')\n                orig = input()\n                print(\'\\n Enter the new word:\')\n                new = input()\n                text = text.replace(orig, new)\n            elif choice[0] == \'3\':\n                print(\'\\nGot the new word!\\n\')\n                break\n            else:\n                sys.stdout.write(""Invalid Choice \\n"")\n        return text\n\n    def main(self, path):\n        directory_path_text = path + \'/text/\' #Create text_conversion folder\n        directory_path_pic = path + \'/Memento/\' #Create text_conversion folder\n        count = 0\n        other_files = 0\n\n        for f in os.listdir(path): #Return list of files in path directory\n\n            ext = os.path.splitext(f)[1] #Split the pathname path into a pair i.e take .png/ .jpg etc\n            image_file_name = path + \'/\' + f #Full /dir/path/filename.extension\n            filename = os.path.splitext(f)[0] #Filename without extension\n            #filename = \'\'.join(e for e in filename if e.isalnum() or e == \'-\') #Join string of filename if it contains alphanumeric characters or -\n\n            if ext.lower() not in VALIDITY: #Convert to lowercase and check in validity list          \n                other_files += 1 #Increment if other than validity extension found\n                continue\n\n            else:\n                if count == 0: #No directory created\n                    self.create_directory(directory_path_text,directory_path_pic) #function to create directory\n\n                count += 1\n\n                image_crop_main(image_file_name, filename, directory_path_text, directory_path_pic, ext)\n                \n                text_img_name = filename + \'_text\' + ext\n                text_img_name = directory_path_text + text_img_name                \n                text = image_ocr_main(text_img_name)\n                \n                new_text = self.editext(text)\n\n                pic_img_name = \'Mem_\' + filename + ext\n                pic_img_name = directory_path_pic + pic_img_name\n\n                new_img_name = directory_path_pic + new_text + ext\n\n                image_join_main(new_text, pic_img_name, path, new_img_name)\n\n                print(str(count) + ("" file"" if count == 1 else "" files"") + "" processed"")\n\n        if count + other_files == 0:\n            print(""No files found"") #No files found\n        else :\n            print(str(count) + "" / "" + str(count + other_files) + "" files converted"")\n            shutil.rmtree(path + \'/text/\')\n            for f in os.listdir(directory_path_pic):\n                if f.startswith(""Mem_""):\n                    os.remove(os.path.join(directory_path_pic, f))\n\ndef image_make_main(path):\n    print(path)\n    s = maker()\n    s.main(path) # Def main to path\n'"
mementor/image_ocr.py,0,"b'import os\nimport sys\n\nimport PIL.Image as Im\nimport pyocr\nimport pyocr.builders\nfrom PIL import Image as Im\nfrom pyocr import tesseract as tool\n\n\nclass iocr(object):\n    \n    def __init__(self):\n        ocr_language = \'eng\'\n        \n        tools = pyocr.get_available_tools()\n        if len(tools) == 0:\n            print(""No OCR tool found"")\n            sys.exit(1)\n        self.tool = tools[0]\n        print(""OCR tool: %s"" % self.tool)\n\n        try:\n            langs = self.tool.get_available_languages()\n            self.lang = langs[0]\n            if ocr_language in langs:\n                self.lang = ocr_language\n            print(""OCR selected language: %s (available: %s)"" % (self.lang.upper(), "", "".join(langs)))\n        except Exception as e:\n            print(""{}"".format(e))\n\n    def main(self, text_img_name):\n        \n        txt = tool.image_to_string(\n            Im.open(text_img_name), lang=self.lang,\n            builder=pyocr.builders.TextBuilder()\n        )\n\n        return txt\n                \ndef image_ocr_main(text_img_name):\n    #print(path)\n    s = iocr()\n    txt = s.main(text_img_name) # Def main to path\n    return txt\n'"
mementor/memento.py,0,"b'import os\nimport sys\nfrom subprocess import call\n\nfrom .image_make import image_make_main\nfrom .ocr_orientation import ocr_orientation_main\nfrom .ocr_rename import ocr_rename_main\nfrom .ocr_save import ocr_save_main\n\n\nclass ArgumentMissingException(Exception):\n    def __init__(self):\n        print(""usage: {} <dirname>"".format(sys.argv[0]))\n        sys.exit(1)\n    \ndef check_path(path):\n    \treturn bool(os.path.exists(path)) #Checkif path exists\n\ndef main(path):\n    call([\'clear\'])\n    i = 0\n    if call([\'which\', \'tesseract\']): #Run the command described by args\n        print(""tesseract-ocr missing"") #No tesseract installed\n    while(True):\n        sys.stdout.write(""\\t\\t\\t Memento: Meme Organizer \\t \\n"")\n        if check_path(path):\n            prompt = "" [1/2/3/4/5]: ""\n            sys.stdout.write(""\\n"")\n            sys.stdout.write(\' 1) Orientation Check \\n 2) Rename file \\n 3) Save OCR \\n 4) Edit text \\n 5) Exit \\n (Can you multiple inputs)\' + prompt)\n            choice = input()\n            while (i != len(choice)):\n                print (\'\\n\\t\\t\\t Current Choice: \' + choice[i] + \'\\n\')\n                if choice[i] == \'1\':\n                    ocr_orientation_main(path)\n                    print("" Orientation Check DONE!! \\n"")\n                elif choice[i] == \'2\':\n                    ocr_rename_main(path)\n                    print(""Rename to identified text DONE!! \\n"")\n                elif choice[i] == \'3\':\n                    ocr_save_main(path)\n                    print(""Save the OCR to /OCR-text/ DONE!! \\n"")\n                elif choice[i] == \'4\':\n                    image_make_main(path)\n                    print(""Edit the text in image DONE!! \\n"")\n                elif choice[i] == \'5\':\n                    call([\'clear\'])\n                    print(""\\t\\t\\t Thank you for using Memento!"")\n                    sys.exit(1)\n                elif choice[i] == \' \':\n                    print(""Chosing Next! \\n"")\n                else:\n                    sys.stdout.write(""Invalid Choice \\n"")\n                i += 1\n        else :\n            print(""No directory : "" + format(path))\n\ndef start():\n    if len(sys.argv) != 2: # Count number of arguments which contains the command-line arguments passed to the script if it is not equal to 2 ie for (py main.py 1_arg 2_arg)\n        raise ArgumentMissingException\n    path = sys.argv[1] #python main.py ""path_to/img_dir"" ie the argv[1] value\n    path = os.path.abspath(path) #Accesing filesystem for Return a normalized absolutized version of the pathname path\n    main(path)\n    #s = memento(path)\n    #s.main(path) # Def main to path\n'"
mementor/memento_all.py,0,"b'import os\nimport sys\nfrom subprocess import call\n\nfrom image_make import image_make_main\nfrom .tess_ocr.ocr_orientation import ocr_orientation_main\nfrom .tess_ocr.ocr_rename import ocr_rename_main\nfrom .tess_ocr.ocr_save import ocr_save_main\n\nVALIDITY = ["".jpg"","".gif"","".png"","".tga"","".tif"","".bmp""]\n\nclass ArgumentMissingException(Exception):\n    def __init__(self):\n        print(""usage: {} <dirname>"".format(sys.argv[0]))\n        sys.exit(1)\n    \ndef check_path(path):\n    \treturn bool(os.path.exists(path)) #Checkif path exists\n\ndef main(path):\n    call([\'clear\'])\n    j = 1\n    i = 0\n    if call([\'which\', \'tesseract\']): #Run the command described by args\n        print(""tesseract-ocr missing"") #No tesseract installed\n    while(True):\n        sys.stdout.write(""\\t\\t\\t Memento: Meme Organizer \\t \\n\\n"")\n        sys.stdout.write(""Files in Directory: \\t \\n\\n"")\n\n        if check_path(path):\n            arr = os.listdir(path)\n            for f in arr:\n                ext = os.path.splitext(f)[1]\n                if ext.lower() in VALIDITY:\n                    print(\'[\' + str(j) + \']\' + \' \' + f ) \n                    j +=1\n                                 \n        else :\n            print(""No directory : "" + format(path))\n\n        print(\'\\nChoose one or all: \')\n        file = input()\n        if file == \'all\':\n            prompt = "" [1/2/3/4/5]: ""\n            sys.stdout.write(""\\n"")\n            sys.stdout.write(\' 1) Orientation Check \\n 2) Rename file \\n 3) Save OCR \\n 4) Edit text \\n 5) Exit \\n (Can you multiple inputs)\' + prompt)\n            choice = input()\n            while (i != len(choice)):\n                print (\'\\n\\t\\t\\t Current Choice: \' + choice[i] + \'\\n\')\n                if choice[i] == \'1\':\n                    ocr_orientation_main(path)\n                    print("" Orientation Check DONE!! \\n"")\n                elif choice[i] == \'2\':\n                    ocr_rename_main(path)\n                    print(""Rename to identified text DONE!! \\n"")\n                elif choice[i] == \'3\':\n                    ocr_save_main(path)\n                    print(""Save the OCR to /OCR-text/ DONE!! \\n"")\n                elif choice[i] == \'4\':\n                    image_make_main(path)\n                    print(""Edit the text in image DONE!! \\n"")\n                elif choice[i] == \'5\':\n                    print(""\\t\\t\\t Thank you for using Memento!"")\n                    sys.exit(1)\n                elif choice[i] == \' \':\n                    print(""Chosing Next! \\n"")\n                else:\n                    sys.stdout.write(""Invalid Choice \\n"")\n            i += 1\n\nif __name__ == \'__main__\': #Execute all code before reading source file, ie. execute import, evaluate def to equal name to main\n    if len(sys.argv) != 2: # Count number of arguments which contains the command-line arguments passed to the script if it is not equal to 2 ie for (py main.py 1_arg 2_arg)\n        raise ArgumentMissingException\n    path = sys.argv[1] #python main.py ""path_to/img_dir"" ie the argv[1] value\n    path = os.path.abspath(path) #Accesing filesystem for Return a normalized absolutized version of the pathname path\n    main(path)\n    #s = memento(path)\n    #s.main(path) # Def main to path'"
mementor/ocr_orientation.py,0,"b'import os\nimport subprocess\n\nimport PIL.Image as Im\nfrom PIL import Image as Im\n\nVALIDITY = ["".jpg"","".gif"","".png"","".tga"","".tif"","".bmp""]\n\nclass orientation(object):\n    \n    def __init__(self):\n        print(\'Orientation check in process\')\n    \n    def get_rotation_info(self, filename):\n        arguments = \' %s - -psm 0\'\n        filename = ""\'"" + filename + ""\'"" #Needed as filename need to be in quotes having spaces which is not accepted direct in  subprocess\n        # /to/dir = \'/to/dir\'\n        stdoutdata = subprocess.getoutput(\'tesseract\' + arguments % filename)\n        degrees = None\n\n        for line in stdoutdata.splitlines():\n            print(line)\n            info = \'Orientation in degrees: \'\n            if info in line:\n                degrees = -float(line.replace(info, \'\').strip())\n        return degrees\n\n    def fix_dpi_and_rotation(self, filename, degrees, ext):\n        im1 = Im.open(filename)\n        print(\'Fixing rotation %.2f in %s...\' % (degrees, filename))\n        im1.rotate(degrees).save(filename)\n        \n    def main(self, path):\n\n        count = 0\n        other_files = 0\n\n        for f in os.listdir(path): #Return list of files in path directory\n\n            ext = os.path.splitext(f)[1] #Split the pathname path into a pair i.e take .png/ .jpg etc\n\n            if ext.lower() not in VALIDITY: #Convert to lowercase and check in validity list          \n                other_files += 1 #Increment if other than validity extension found\n                continue\n\n            else:\n\n                count += 1\n                c=0\n                while c!=2:\n                    image_file_name = path + \'/\' + f #Full /dir/path/filename.extension\n                    degrees = self.get_rotation_info(image_file_name)\n                    print(degrees)\n                    if degrees:\n                        self.fix_dpi_and_rotation(image_file_name, degrees, ext)\n                    c += 1\n\n                print(str(count) + ("" file"" if count == 1 else "" files"") + "" processed"")\n\n        if count + other_files == 0:\n            print(""No files found"") #No files found\n        else :\n            print(str(count) + "" / "" + str(count + other_files) + "" files converted"")\n\ndef ocr_orientation_main(path):\n    print(path)\n    s = orientation()\n    s.main(path) # Def main to path\n'"
mementor/ocr_rename.py,0,"b'import io\nimport os\nimport subprocess\nimport sys\n\nimport PIL.Image as Im\nimport pyocr\nimport pyocr.builders\nfrom PIL import Image as Im\nfrom pyocr import tesseract as tool\n\nVALIDITY = ["".jpg"","".gif"","".png"","".tga"","".tif"","".bmp""]\n\nclass rename(object):\n    \n    def __init__(self):\n        \n        ocr_language = \'eng\'\n        \n        tools = pyocr.get_available_tools()\n        if len(tools) == 0:\n            print(""No OCR tool found"")\n            sys.exit(1)\n        self.tool = tools[0]\n        print(""OCR tool: %s"" % self.tool)\n\n        try:\n            langs = self.tool.get_available_languages()\n            self.lang = langs[0]\n            if ocr_language in langs:\n                self.lang = ocr_language\n            print(""OCR selected language: %s (available: %s)"" % (self.lang.upper(), "", "".join(langs)))\n        except Exception as e:\n            print(""{}"".format(e))\n            \n    def main(self, path):\n\n        count = 0\n        other_files = 0\n\n        for f in os.listdir(path): #Return list of files in path directory\n\n            ext = os.path.splitext(f)[1] #Split the pathname path into a pair i.e take .png/ .jpg etc\n\n            if ext.lower() not in VALIDITY: #Convert to lowercase and check in validity list          \n                other_files += 1 #Increment if other than validity extension found\n                #sys.stdout.write(""Extension other than image is not supported. \\n"")\n                continue\n\n            else:\n\n                count += 1\n\n                image_file_name = path + \'/\' + f #Full /dir/path/filename.extension\n\n                txt = tool.image_to_string(\n                    Im.open(image_file_name), lang=self.lang,\n                    builder=pyocr.builders.TextBuilder()\n                )\n                \n                initial = txt.replace(\'\\a\', \' \').replace(\'\\b\', \' \').replace(\'\\f\', \' \').replace(\'\\n\',\' \').replace(\'\\r\', \'\').replace(\'\\t\',\' \').replace(\'\\v\',\' \') #.replace(\' \',\'_\') #.replace(\'.\',\'_\') #Replace \\n and \\t with space\n                initial = initial[:60] #Take 1st 100 words\n                print(\'Filename:\' + initial + \'\\n\')\n\n                os.chmod(path, 0o777)\n                os.rename(image_file_name, path + \'/\' + initial + ext)\n\n                print(str(count) + ("" file"" if count == 1 else "" files"") + "" processed"")\n\n        if count + other_files == 0:\n            print(""No files found"") #No files found\n        else :\n            print(str(count) + "" / "" + str(count + other_files) + "" files converted"")\n\ndef ocr_rename_main(path):\n    print(path)\n    s = rename()\n    s.main(path) # Def main to path\n'"
mementor/ocr_save.py,0,"b'import os\nimport sys\n\nimport PIL.Image as Im\nimport pyocr\nimport pyocr.builders\nfrom PIL import Image as Im\nfrom pyocr import tesseract as tool\n\nVALIDITY = ["".jpg"","".gif"","".png"","".tga"","".tif"","".bmp""]\n\nclass save(object):\n    \n    def __init__(self):\n        \n        ocr_language = \'eng\'\n        \n        tools = pyocr.get_available_tools()\n        if len(tools) == 0:\n            print(""No OCR tool found"")\n            sys.exit(1)\n        self.tool = tools[0]\n        print(""OCR tool: %s"" % self.tool)\n\n        try:\n            langs = self.tool.get_available_languages()\n            self.lang = langs[0]\n            if ocr_language in langs:\n                self.lang = ocr_language\n            print(""OCR selected language: %s (available: %s)"" % (self.lang.upper(), "", "".join(langs)))\n        except Exception as e:\n            print(""{}"".format(e))\n    \n    def create_directory(self, path):\n        if not os.path.exists(path): #No path\n\t        os.makedirs(path) #Create path\n\n    def savefile(self,initial, txt, directory_path):\n        \n        if (bool(os.path.exists(directory_path)) == False): #No directory created\n            self.create_directory(directory_path) #function to create directory\n        fw = open(directory_path + ""/"" + initial + "".txt"" , ""w+"")\n        fw.write(txt)\n        fw.close()\n\n        \n    def main(self, path):\n\n        directory_path = path + \'/OCR-text/\' #Create text_conversion folder\n        count = 0\n        other_files = 0\n\n        for f in os.listdir(path): #Return list of files in path directory\n\n            ext = os.path.splitext(f)[1] #Split the pathname path into a pair i.e take .png/ .jpg etc\n\n            if ext.lower() not in VALIDITY: #Convert to lowercase and check in validity list          \n                other_files += 1 #Increment if other than validity extension found\n                continue\n\n            else:\n\n                count += 1\n                image_file_name = path + \'/\' + f #Full /dir/path/filename.extension\n\n                txt = tool.image_to_string(\n                    Im.open(image_file_name), lang=self.lang,\n                    builder=pyocr.builders.TextBuilder()\n                )\n                \n                #txt = txt.split()[:5]\n                initial = txt.replace(\'\\a\', \' \').replace(\'\\b\', \' \').replace(\'\\f\', \' \').replace(\'\\n\',\' \').replace(\'\\r\', \'\').replace(\'\\t\',\' \').replace(\'\\v\',\' \') #.replace(\' \',\'_\') #.replace(\'.\',\'_\') #Replace \\n and \\t with space\n                initial = initial[:60] #Take 1st 100 words\n                print(\'Filename:\' + initial + \'\\n\')\n\n                os.chmod(path, 0o777)\n                self.savefile(initial, txt, directory_path)\n\n                print(str(count) + ("" file"" if count == 1 else "" files"") + "" processed"")\n\n        if count + other_files == 0:\n            print(""No files found"") #No files found\n        else :\n            print(str(count) + "" / "" + str(count + other_files) + "" files converted"")\n\ndef ocr_save_main(path):\n    print(path)\n    s = save()\n    s.main(path) # Def main to path\n'"
