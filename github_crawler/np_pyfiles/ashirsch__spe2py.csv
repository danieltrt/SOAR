file_path,api_count,code
setup.py,0,"b""from setuptools import setup\n\nsetup(\n    name='spe2py',\n    version='1.0.0a',\n    description='This module imports a Princeton Instruments LightField (SPE 3.0) file into a python environment.',\n    author='Alex Hirsch (Zia Lab)',\n    author_email='alexander_hirsch@brown.edu',\n    url='https://github.com/ashirsch/spe2py',\n    license='MIT',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python 3'\n    ],\n    keywords='spectroscopy optics imaging data analysis',\n    py_modules=['spe2py'],\n    install_requires=[\n        'numpy',\n        'matplotlib',\n        'untangle'\n    ]\n)\n"""
spe2py.py,18,"b'#!/usr/bin/env python3\r\n""""""\r\nThis module imports a Princeton Instruments LightField (SPE 3.0) file into a python environment.\r\n""""""\r\nimport numpy as np\r\nimport untangle\r\nimport tkinter as tk\r\nfrom tkinter import filedialog as fdialog\r\nfrom io import StringIO\r\n#import matplotlib\r\n#matplotlib.use(""TkAgg"")\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib import cm\r\n\r\n\r\ndef get_files(mult=False):\r\n    """"""\r\n    Uses tkinter to allow UI source file selection\r\n    Adapted from: http://stackoverflow.com/a/7090747\r\n    """"""\r\n    root = tk.Tk()\r\n    root.withdraw()\r\n    root.overrideredirect(True)\r\n    root.geometry(\'0x0+0+0\')\r\n    root.deiconify()\r\n    root.lift()\r\n    root.focus_force()\r\n    filepaths = fdialog.askopenfilenames()\r\n    if not mult:\r\n        filepaths = filepaths[0]\r\n    root.destroy()\r\n    return filepaths\r\n\r\n\r\nclass SpeFile:\r\n    def __init__(self, filepath=None):\r\n        if filepath is not None:\r\n            assert isinstance(filepath, str), \'Filepath must be a single string\'\r\n            self.filepath = filepath\r\n        else:\r\n            self.filepath = get_files()\r\n\r\n        with open(self.filepath) as file:\r\n            self.header_version = read_at(file, 1992, 3, np.float32)[0]\r\n            assert self.header_version >= 3.0, \\\r\n                \'This version of spe2py cannot load filetype SPE v. %.1f\' % self.header_version\r\n\r\n            self.nframes = read_at(file, 1446, 2, np.uint16)[0]\r\n\r\n            self.footer = self._read_footer(file)\r\n            self.dtype = self._get_dtype(file)\r\n\r\n            # Note: these methods depend on self.footer\r\n            self.xdim, self.ydim = self._get_dims()\r\n            self.roi, self.nroi = self._get_roi_info()\r\n            self.wavelength = self._get_wavelength()\r\n\r\n            self.xcoord, self.ycoord = self._get_coords()\r\n\r\n            self.data, self.metadata, self.metanames = self._read_data(file)\r\n        file.close()\r\n\r\n    @staticmethod\r\n    def _read_footer(file):\r\n        """"""\r\n        Loads and parses the source file\'s xml footer metadata to an \'untangle\' object.\r\n        """"""\r\n        footer_pos = read_at(file, 678, 8, np.uint64)[0]\r\n\r\n        file.seek(footer_pos)\r\n        xmltext = file.read()\r\n\r\n        parser = untangle.make_parser()\r\n        sax_handler = untangle.Handler()\r\n        parser.setContentHandler(sax_handler)\r\n\r\n        parser.parse(StringIO(xmltext))\r\n\r\n        loaded_footer = sax_handler.root\r\n\r\n        return loaded_footer\r\n\r\n    @staticmethod\r\n    def _get_dtype(file):\r\n        """"""\r\n        Returns the numpy data type used to encode the image data by reading the numerical code in the binary header.\r\n        Reference: Princeton Instruments File Specification pdf\r\n        """"""\r\n        dtype_code = read_at(file, 108, 2, np.uint16)[0]\r\n\r\n        if dtype_code == 0:\r\n            dtype = np.float32\r\n        elif dtype_code == 1:\r\n            dtype = np.int32\r\n        elif dtype_code == 2:\r\n            dtype = np.int16\r\n        elif dtype_code == 3:\r\n            dtype = np.uint16\r\n        elif dtype_code == 8:\r\n            dtype = np.uint32\r\n        else:\r\n            raise ValueError(""Unrecognized data type code: %.2f. Value should be one of {0, 1, 2, 3, 8}"" % dtype_code)\r\n\r\n        return dtype\r\n\r\n    def _get_meta_dtype(self):\r\n        meta_types = []\r\n        meta_names = []\r\n        prev_item = None\r\n        for item in dir(self.footer.SpeFormat.MetaFormat.MetaBlock):\r\n            if item == \'TimeStamp\' and prev_item != \'TimeStamp\':  # Specify ExposureStarted vs. ExposureEnded\r\n                for element in self.footer.SpeFormat.MetaFormat.MetaBlock.TimeStamp:\r\n                    meta_names.append(element[\'event\'])\r\n                    meta_types.append(element[\'type\'])\r\n                prev_item = \'TimeStamp\'\r\n            elif item == \'GateTracking\' and prev_item != \'GateTracking\':  # Specify Delay vs. Width\r\n                for element in self.footer.SpeFormat.MetaFormat.MetaBlock.GateTracking:\r\n                    meta_names.append(element[\'component\'])\r\n                    meta_types.append(element[\'type\'])\r\n                prev_item = \'GateTracking\'\r\n            elif prev_item != item:  # All other metablock names only have one possible value\r\n                meta_names.append(item)\r\n                meta_types.append(getattr(self.footer.SpeFormat.MetaFormat.MetaBlock, item)[\'type\'])\r\n                prev_item = item\r\n\r\n        for index, type_str in enumerate(meta_types):\r\n            if type_str == \'Int64\':\r\n                meta_types[index] = np.int64\r\n            else:\r\n                meta_types[index] = np.float64\r\n\r\n        return meta_types, meta_names\r\n\r\n    def _get_roi_info(self):\r\n        """"""\r\n        Returns region of interest attributes and numbers of regions of interest\r\n        """"""\r\n        try:\r\n            camerasettings = self.footer.SpeFormat.DataHistories.DataHistory.Origin.Experiment.Devices.Cameras.Camera\r\n            regionofinterest = camerasettings.ReadoutControl.RegionsOfInterest.CustomRegions.RegionOfInterest\r\n        except AttributeError:\r\n            print(""XML Footer was not loaded prior to calling _get_roi_info"")\r\n            raise\r\n\r\n        if isinstance(regionofinterest, list):\r\n            nroi = len(regionofinterest)\r\n            roi = regionofinterest\r\n        else:\r\n            nroi = 1\r\n            roi = [regionofinterest]\r\n\r\n        return roi, nroi\r\n\r\n    def _get_wavelength(self):\r\n        """"""\r\n        Returns wavelength-to-pixel map as stored in XML footer\r\n        """"""\r\n        try:\r\n            wavelength_string = StringIO(self.footer.SpeFormat.Calibrations.WavelengthMapping.Wavelength.cdata)\r\n        except AttributeError:\r\n            print(""XML Footer was not loaded prior to calling _get_wavelength"")\r\n            raise\r\n        except IndexError:\r\n            print(""XML Footer does not contain Wavelength Mapping information"")\r\n            return\r\n\r\n        wavelength = np.loadtxt(wavelength_string, delimiter=\',\')\r\n\r\n        return wavelength\r\n\r\n    def _get_dims(self):\r\n        """"""\r\n        Returns the x and y dimensions for each region as stored in the XML footer\r\n        """"""\r\n        xdim = [int(block[""width""]) for block in self.footer.SpeFormat.DataFormat.DataBlock.DataBlock]\r\n        ydim = [int(block[""height""]) for block in self.footer.SpeFormat.DataFormat.DataBlock.DataBlock]\r\n\r\n        return xdim, ydim\r\n\r\n    def _get_coords(self):\r\n        """"""\r\n        Returns x and y pixel coordinates. Used in cases where xdim and ydim do not reflect image dimensions\r\n        (e.g. files containing frames with multiple regions of interest)\r\n        """"""\r\n        xcoord = [[] for _ in range(0, self.nroi)]\r\n        ycoord = [[] for _ in range(0, self.nroi)]\r\n\r\n        for roi_ind in range(0, self.nroi):\r\n            working_roi = self.roi[roi_ind]\r\n            ystart = int(working_roi[\'y\'])\r\n            ybinning = int(working_roi[\'yBinning\'])\r\n            yheight = int(working_roi[\'height\'])\r\n            ycoord[roi_ind] = range(ystart, (ystart + yheight), ybinning)\r\n\r\n        for roi_ind in range(0, self.nroi):\r\n            working_roi = self.roi[roi_ind]\r\n            xstart = int(working_roi[\'x\'])\r\n            xbinning = int(working_roi[\'xBinning\'])\r\n            xwidth = int(working_roi[\'width\'])\r\n            xcoord[roi_ind] = range(xstart, (xstart + xwidth), xbinning)\r\n\r\n        return xcoord, ycoord\r\n\r\n    def _read_data(self, file):\r\n        """"""\r\n        Loads raw image data into an nframes X nroi list of arrays.\r\n        """"""\r\n        file.seek(4100)\r\n\r\n        frame_stride = int(self.footer.SpeFormat.DataFormat.DataBlock[\'stride\'])\r\n        frame_size = int(self.footer.SpeFormat.DataFormat.DataBlock[\'size\'])\r\n        metadata_size = frame_stride - frame_size\r\n        if metadata_size != 0:\r\n            metadata_dtypes, metadata_names = self._get_meta_dtype()\r\n            metadata = np.zeros((self.nframes, len(metadata_dtypes)))\r\n        else:\r\n            metadata_dtypes, metadata_names = None, None\r\n            metadata = None\r\n\r\n        data = [[0 for _ in range(self.nroi)] for _ in range(self.nframes)]\r\n        for frame in range(0, self.nframes):\r\n            for region in range(0, self.nroi):\r\n                if self.nroi > 1:\r\n                    data_xdim = len(self.xcoord[region])\r\n                    data_ydim = len(self.ycoord[region])\r\n                else:\r\n                    data_xdim = np.asarray(self.xdim[region], np.uint32)\r\n                    data_ydim = np.asarray(self.ydim[region], np.uint32)\r\n                data[frame][region] = np.fromfile(file, self.dtype, data_xdim * data_ydim).reshape(data_ydim, data_xdim)\r\n            if metadata_dtypes is not None:\r\n                for meta_block in range(len(metadata_dtypes)):\r\n                    metadata[frame, meta_block] = np.fromfile(file, dtype=metadata_dtypes[meta_block], count=1)\r\n\r\n        return data, metadata, metadata_names\r\n\r\n    def image(self, frame=0, roi=0):\r\n        """"""\r\n        Images loaded data for a specific frame and region of interest.\r\n        """"""\r\n        img = plt.imshow(self.data[frame][roi], cmap=cm.get_cmap(\'hot\'))\r\n        plt.title(self.filepath)\r\n        return img\r\n\r\n    def specplot(self, frame=0, roi=0):\r\n        """"""\r\n        Plots loaded data for a specific frame, assuming the data is a one dimensional spectrum.\r\n        """"""\r\n        spectrum = plt.plot(self.wavelength.transpose(), self.data[frame][roi].transpose())\r\n        plt.grid()\r\n        return spectrum\r\n\r\n    def xmltree(self, footer, ind=-1):\r\n        """"""\r\n        Prints the untangle footer object in tree form to easily view metadata fields. Ignores object elements that\r\n        contain lists (e.g. ..Spectrometer.Turrets.Turret).\r\n        """"""\r\n        if dir(footer):\r\n            ind += 1\r\n            for item in dir(footer):\r\n                if isinstance(getattr(footer, item), list):\r\n                    continue\r\n                else:\r\n                    print(ind * \' -->\', item)\r\n                    self.xmltree(getattr(footer, item), ind)\r\n\r\n\r\ndef load(filepaths=None):\r\n    """"""\r\n    Allows user to load multiple files at once. Each file is stored as an SpeFile object in the list batch.\r\n    """"""\r\n    if filepaths is None:\r\n        filepaths = get_files(mult=True)\r\n    batch = [[] for _ in range(0, len(filepaths))]\r\n    for file in range(0, len(filepaths)):\r\n        batch[file] = SpeFile(filepaths[file])\r\n    return_type = ""list of SpeFile objects""\r\n    if len(batch) == 1:\r\n        batch = batch[0]\r\n        return_type = ""SpeFile object""\r\n    print(\'Successfully loaded %i file(s) in a %s\' % (len(filepaths), return_type))\r\n    return batch\r\n\r\n\r\ndef read_at(file, pos, size, ntype):\r\n    """"""\r\n    Reads SPE source file at specific byte position.\r\n    Adapted from https://scipy.github.io/old-wiki/pages/Cookbook/Reading_SPE_files.html\r\n    """"""\r\n    file.seek(pos)\r\n    return np.fromfile(file, ntype, size)\r\n\r\n\r\ndef imgobject(speobject, frame=0, roi=0):\r\n    """"""\r\n    Unbound function for imaging loaded data\r\n    """"""\r\n    img = plt.imshow(getattr(speobject, \'data\')[frame][roi], cmap=cm.get_cmap(\'hot\'))\r\n    return img\r\n\r\n\r\nif __name__ == ""__main__"":\r\n    obj = load()\r\n    if isinstance(obj, list):\r\n        for i in range(len(obj)):\r\n            plt.figure()\r\n            obj[i].image()\r\n    else:\r\n        plt.figure()\r\n        obj.image()\r\n    plt.show()\r\n'"
tests/tests.py,0,"b'#!/usr/bin/env python\nimport os\nimport unittest\nimport spe2py as spe\n\n\nclass BasicFileLoading(unittest.TestCase):\n    """""" Loading different files individually """"""\n    def test_load_full_sensor(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/full_sensor_image.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (1024, 1024), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assert_(obj.nframes == 1)\n        self.assert_(obj.nroi == 1)\n\n    def test_load_small_roi(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/small_roi.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (638, 705), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assertEqual(obj.nframes, 1)\n        self.assertEqual(obj.nroi, 1)\n\n    def test_load_mult_roi(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__),\n                                       ""test_files/two_rectangular_rois_different_binning.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (638, 705), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assert_(obj.data[0][1].shape == (55, 80), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assertEqual(obj.roi[0][\'xBinning\'], \'1\')\n        self.assertEqual(obj.roi[1][\'xBinning\'], \'4\')\n        self.assertEqual(obj.roi[1][\'yBinning\'], \'2\')\n\n    def test_load_one_dim(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/one_dimensional_spectrum.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (1, 1024), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n\n    def test_load_complex_file(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__),\n                                       ""test_files/ten_frames_two_rois_different_binning.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (177, 626), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assert_(obj.data[0][1].shape == (46, 256), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assertEqual(obj.nframes, 10)\n        self.assertEqual(obj.nroi, 2)\n\n    def test_load_step_and_glue(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/step_and_glue.spe""))\n        self.assert_(obj is not None)\n        self.assert_(obj.data is not None)\n        self.assert_(obj.data[0][0].shape == (1024, 1567), ""Shape read as: {0}"".format(obj.data[0][0].shape))\n        self.assert_(obj.nframes == 1)\n        self.assert_(obj.nroi == 1)\n\n\nclass ImagingFunctionality(unittest.TestCase):\n    """"""Test two imaging methods (specplot and image)""""""\n    def test_default_image_method(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/full_sensor_image.spe""))\n        img = obj.image()\n        self.assert_(img is not None)\n\n    def test_image_method_with_args(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__),\n                                       ""test_files/ten_frames_two_rois_different_binning.spe""))\n        img1 = obj.image(1, 0)\n        img2 = obj.image(2, 0)\n        self.assert_(img1 is not None and img2 is not None)\n        self.assertNotEqual(img1, img2)\n        img3 = obj.image(1, 1)\n        self.assertNotEqual(img1, img3)\n\n    def test_spectrum_method(self):\n        obj = spe.SpeFile(os.path.join(os.path.dirname(__file__), ""test_files/one_dimensional_spectrum.spe""))\n        spec = obj.specplot()\n        self.assert_(spec is not None)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
