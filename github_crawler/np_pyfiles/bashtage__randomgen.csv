file_path,api_count,code
benchmark.py,8,"b'import os\nimport struct\nimport timeit\n\nimport numpy as np\nfrom numpy.random import RandomState\nimport pandas as pd\n\nrs = RandomState()\n\nSETUP = """"""\nimport numpy as np\nif \'{bitgen}\' == \'numpy\':\n    import numpy.random\n    rg = numpy.random.RandomState()\n    rg.random_sample()\nelse:\n    from randomgen import Generator, {bitgen}\n    rg = Generator({bitgen}())\n    rg.random()\n""""""\n\nscale_32 = scale_64 = 1\nif struct.calcsize(""P"") == 8 and os.name != ""nt"":\n    # 64 bit\n    scale_32 = 0.5\nelse:\n    scale_64 = 2\n\nPRNGS = [\n    ""DSFMT"",\n    ""PCG64"",\n    ""PCG32"",\n    ""MT19937"",\n    ""MT64"",\n    ""Xoroshiro128"",\n    ""Xorshift1024"",\n    ""Xoshiro256"",\n    ""Xoshiro512"",\n    ""Philox"",\n    ""ThreeFry"",\n    ""numpy"",\n    ""SFMT"",\n    ""AESCounter"",\n    ""ChaCha"",\n    ""HC128"",\n    ""SPECK128"",\n    ""JSF"",\n]\n\n\ndef timer(code, setup):\n    return 1000 * min(timeit.Timer(code, setup=setup).repeat(10, 10)) / 10.0\n\n\ndef print_legend(legend):\n    print(""\\n"" + legend + ""\\n"" + ""*"" * max(60, len(legend)))\n\n\ndef add_color(val):\n    color = str(2) if val > 0 else str(1)\n    return ""\\33[38;5;"" + color + ""m"" + ""{0:0.1f}%"".format(val) + ""\\33[0m""\n\n\ndef run_timer(command, numpy_command=None, setup="""", random_type=""""):\n    print(""-"" * 80)\n    if numpy_command is None:\n        numpy_command = command\n\n    res = {}\n    for bitgen in PRNGS:\n        cmd = numpy_command if bitgen == ""numpy"" else command\n        res[bitgen] = timer(cmd, setup=setup.format(bitgen=bitgen))\n\n    s = pd.Series(res).sort_index()\n    t = s.apply(lambda x: ""{0:0.2f} ms"".format(x))\n    print_legend(""Time to produce 1,000,000 "" + random_type)\n    print(t)\n\n    p = 1000.0 / s\n    p = p.apply(lambda x: ""{0:0.2f} million"".format(x))\n    print_legend(random_type + "" per second"")\n    print(p)\n\n    baseline = [k for k in p.index if ""numpy"" in k][0]\n    p = 1000.0 / s\n    p = p / p[baseline] * 100 - 100\n    p = p.drop(baseline, 0)\n    p = p.apply(add_color)\n    print_legend(""Speed-up relative to NumPy"")\n    print(p)\n    print(""-"" * 80)\n\n\ndef timer_raw():\n    command = ""rg._bit_generator.random_raw(size=1000000, output=False)""\n    info = np.iinfo(np.int32)\n    command_numpy = ""rg.random_integers({max},size=1000000)""\n    command_numpy = command_numpy.format(max=info.max)\n    run_timer(command, command_numpy, SETUP, ""Raw Values"")\n\n\ndef timer_uniform():\n    command = ""rg.random(1000000)""\n    command_numpy = ""rg.random_sample(1000000)""\n    run_timer(command, command_numpy, SETUP, ""Uniforms"")\n\n\ndef timer_bounded(bits=8, max=95, use_masked=True):\n    """"""\n    Timer for 8-bit bounded values.\n\n    Parameters\n    ----------\n    bits : {8, 16, 32, 64}\n        Bit width of unsigned output type\n    max : int\n        Upper bound for range. Lower is always 0.  Must be <= 2**bits.\n    use_masked: bool\n        If True, masking and rejection sampling is used to generate a random\n        number in an interval. If False, Lemire\'s algorithm is used if\n        available to generate a random number in an interval.\n\n    Notes\n    -----\n    Lemire\'s algorithm has improved performance when {max}+1 is not a\n    power of two.\n    """"""\n    if bits not in (8, 16, 32, 64):\n        raise ValueError(""bits must be one of 8, 16, 32, 64."")\n    minimum = 0\n\n    if use_masked:  # Use masking & rejection.\n        command = (\n            ""rg.randint({min}, {max}+1, 1000000, dtype=np.uint{bits},""\n            "" use_masked=True)""\n        )\n    else:  # Use Lemire\'s algo.\n        command = (\n            ""rg.randint({min}, {max}+1, 1000000, dtype=np.uint{bits},""\n            "" use_masked=False)""\n        )\n\n    command = command.format(min=minimum, max=max, bits=bits)\n\n    command_numpy = ""rg.randint({min}, {max}+1, 1000000, dtype=np.uint{bits})""\n    command_numpy = command_numpy.format(min=minimum, max=max, bits=bits)\n\n    run_timer(\n        command,\n        command_numpy,\n        SETUP,\n        ""{bits}-bit bounded unsigned integers (max={max}, ""\n        ""use_masked={use_masked})"".format(max=max, use_masked=use_masked, bits=bits),\n    )\n\n\ndef timer_32bit():\n    info = np.iinfo(np.uint32)\n    minimum, maximum = info.min, info.max\n    command = ""rg.randint(2**32, size=1000000, dtype=\'uint32\')""\n    command_numpy = ""rg.randint({min}, {max}+1, 1000000, dtype=np.uint32)""\n    command_numpy = command_numpy.format(min=minimum, max=maximum)\n    run_timer(command, command_numpy, SETUP, ""32-bit unsigned integers"")\n\n\ndef timer_64bit():\n    info = np.iinfo(np.uint64)\n    minimum, maximum = info.min, info.max\n    command = ""rg.randint(2**64, size=1000000, dtype=\'uint64\')""\n    command_numpy = ""rg.randint({min}, {max}+1, 1000000, dtype=np.uint64)""\n    command_numpy = command_numpy.format(min=minimum, max=maximum)\n    run_timer(command, command_numpy, SETUP, ""64-bit unsigned integers"")\n\n\ndef timer_normal_zig():\n    command = ""rg.standard_normal(1000000)""\n    command_numpy = ""rg.standard_normal(1000000)""\n    run_timer(command, command_numpy, SETUP, ""Standard normals (Ziggurat)"")\n\n\nif __name__ == ""__main__"":\n    import argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        ""-f"",\n        ""--full"",\n        help=""Run benchmarks for a wide range of ""\n        ""distributions. If not provided, only tests the ""\n        ""production of uniform values."",\n        dest=""full"",\n        action=""store_true"",\n    )\n    parser.add_argument(\n        ""-bi"",\n        ""--bounded-ints"",\n        help=""Included benchmark coverage of the bounded ""\n        ""integer generators in a full run."",\n        dest=""bounded_ints"",\n        action=""store_true"",\n    )\n    args = parser.parse_args()\n\n    timer_uniform()\n    if args.full:\n        timer_raw()\n        timer_32bit()\n        timer_64bit()\n        timer_normal_zig()\n\n        if args.bounded_ints:\n            timer_bounded(use_masked=True)\n            # Worst case for Numpy.\n            timer_bounded(max=64, use_masked=False)\n            # Typ. avrg. case for Numpy.\n            timer_bounded(max=95, use_masked=False)\n            # Best case for Numpy.\n            timer_bounded(max=127, use_masked=False)\n\n            timer_bounded(16, use_masked=True)\n            # Worst case for Numpy.\n            timer_bounded(16, max=1024, use_masked=False)\n            # Typ. avrg. case for Numpy.\n            timer_bounded(16, max=1535, use_masked=False)\n            # Best case for Numpy.\n            timer_bounded(16, max=2047, use_masked=False)\n\n            timer_bounded(32, use_masked=True)\n            # Worst case for Numpy.\n            timer_bounded(32, max=1024, use_masked=False)\n            # Typ. avrg. case for Numpy.\n            timer_bounded(32, max=1535, use_masked=False)\n            # Best case for Numpy.\n            timer_bounded(32, max=2047, use_masked=False)\n\n            timer_bounded(64, use_masked=True)\n            # Worst case for Numpy.\n            timer_bounded(64, max=1024, use_masked=False)\n            # Typ. avrg. case for Numpy.\n            timer_bounded(64, max=1535, use_masked=False)\n            # Best case for Numpy.\n            timer_bounded(64, max=2047, use_masked=False)\n'"
setup.py,1,"b'from distutils.version import LooseVersion\nimport glob\nimport io\nimport os\nfrom os.path import exists, join, splitext\nimport platform\nimport struct\nimport sys\n\nfrom Cython.Build import cythonize\nimport Cython.Compiler.Options\nimport numpy as np\nfrom setuptools import Distribution, find_packages, setup\nfrom setuptools.extension import Extension\n\nimport versioneer\n\ntry:\n    import Cython.Tempita as tempita\nexcept ImportError:\n    try:\n        import tempita\n    except ImportError:\n        raise ImportError(""tempita required to install, use pip install tempita"")\n\nwith open(""requirements.txt"") as f:\n    required = f.read().splitlines()\n\nCYTHON_COVERAGE = os.environ.get(""RANDOMGEN_CYTHON_COVERAGE"", ""0"") in (\n    ""true"",\n    ""1"",\n    ""True"",\n)\nif CYTHON_COVERAGE:\n    print(\n        ""Building with coverage for cython modules, ""\n        ""RANDOMGEN_CYTHON_COVERAGE="" + os.environ[""RANDOMGEN_CYTHON_COVERAGE""]\n    )\n\nLONG_DESCRIPTION = io.open(""README.md"", encoding=""utf-8"").read()\nCython.Compiler.Options.annotate = True\n\n# Make a guess as to whether SSE2 is present for now, TODO: Improve\nINTEL_LIKE = any(\n    [\n        val in k.lower()\n        for k in platform.uname()\n        for val in (""x86"", ""i686"", ""i386"", ""amd64"")\n    ]\n)\nUSE_SSE2 = INTEL_LIKE\nprint(""Building with SSE?: {0}"".format(USE_SSE2))\nif ""--no-sse2"" in sys.argv:\n    USE_SSE2 = False\n    sys.argv.remove(""--no-sse2"")\n\nMOD_DIR = ""./randomgen""\n\n\ndef src_join(*fname):\n    return join(MOD_DIR, ""src"", join(*fname))\n\n\nDEBUG = os.environ.get(""RANDOMGEN_DEBUG"", False) in (1, ""1"", ""True"", ""true"")\nif DEBUG:\n    print(""Debug build, RANDOMGEN_DEBUG="" + os.environ[""RANDOMGEN_DEBUG""])\n\nEXTRA_INCLUDE_DIRS = [np.get_include()]\nEXTRA_LINK_ARGS = [] if os.name == ""nt"" else []\nEXTRA_LIBRARIES = [""m""] if os.name != ""nt"" else []\n# Undef for manylinux\nEXTRA_COMPILE_ARGS = (\n    [""/Zp16""] if os.name == ""nt"" else [""-std=c99"", ""-U__GNUC_GNU_INLINE__""]\n)\nUNDEF_MACROS = []\nif os.name == ""nt"":\n    EXTRA_LINK_ARGS = [""/LTCG"", ""/OPT:REF"", ""Advapi32.lib"", ""Kernel32.lib""]\n    if DEBUG:\n        EXTRA_LINK_ARGS += [""-debug""]\n        EXTRA_COMPILE_ARGS += [""-Zi"", ""/Od""]\n        UNDEF_MACROS += [""NDEBUG""]\n    if sys.version_info < (3, 0):\n        EXTRA_INCLUDE_DIRS += [src_join(""common"")]\nelif DEBUG:\n    EXTRA_COMPILE_ARGS += [""-g"", ""-O0""]\n    EXTRA_LINK_ARGS += [""-g""]\n    UNDEF_MACROS += [""NDEBUG""]\n\nif Cython.__version__ >= LooseVersion(""0.29""):\n    DEFS = [(""NPY_NO_DEPRECATED_API"", ""NPY_1_7_API_VERSION"")]\nelse:\n    DEFS = [(""NPY_NO_DEPRECATED_API"", ""0"")]\n\nif CYTHON_COVERAGE:\n    DEFS += [(""CYTHON_TRACE"", ""1""), (""CYTHON_TRACE_NOGIL"", ""1"")]\n\nPCG64_DEFS = DEFS[:]\nif sys.maxsize < 2 ** 32 or os.name == ""nt"":\n    # Force emulated mode here\n    PCG64_DEFS += [(""PCG_FORCE_EMULATED_128BIT_MATH"", ""1"")]\n\nDSFMT_DEFS = DEFS[:] + [(""DSFMT_MEXP"", ""19937"")]\nSFMT_DEFS = DEFS[:] + [(""SFMT_MEXP"", ""19937"")]\nPHILOX_DEFS = DEFS[:] + [(""R123_USE_PHILOX_64BIT"", ""1"")]\nRDRAND_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:]\nSSSE3_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:]\nAES_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:]\n\nif USE_SSE2:\n    if os.name == ""nt"":\n        EXTRA_COMPILE_ARGS += [""/wd4146"", ""/GL""]\n        if struct.calcsize(""P"") < 8:\n            EXTRA_COMPILE_ARGS += [""/arch:SSE2""]\n            SSSE3_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:]\n    else:\n        EXTRA_COMPILE_ARGS += [""-msse2""]\n        RDRAND_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:] + [""-mrdrnd""]\n        SSSE3_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:] + [""-mssse3""]\n        AES_COMPILE_ARGS = EXTRA_COMPILE_ARGS[:] + [""-maes""]\n    DSFMT_DEFS += [(""HAVE_SSE2"", ""1"")]\n    SFMT_DEFS += [(""HAVE_SSE2"", ""1"")]\n\nfiles = glob.glob(""./randomgen/*.in"") + glob.glob(""./randomgen/legacy/*.in"")\nfor templated_file in files:\n    output_file_name = splitext(templated_file)[0]\n    with open(templated_file, ""r"") as source_file:\n        template = tempita.Template(source_file.read())\n    processed = template.substitute().replace(""\\r\\n"", ""\\n"")\n    contents = """"\n    if exists(output_file_name):\n        with open(output_file_name, ""r"") as output_file:\n            contents = output_file.read()\n    if contents != processed:\n        print(""Processing {0} to {1}"".format(templated_file, output_file_name))\n        with open(output_file_name, ""w"", newline=""\\n"") as output_file:\n            output_file.write(processed)\n\nextensions = []\nfor name in (\n    ""bounded_integers"",\n    ""common"",\n    ""entropy"",\n    ""generator"",\n    ""legacy.bounded_integers"",\n    ""mtrand"",\n    ""_seed_sequence"",\n):\n    extra_source = []\n    extra_macros = []\n    extra_incl = []\n\n    source = [""randomgen/{0}.pyx"".format(name.replace(""."", ""/""))]\n\n    legacy = name in (""legacy.bounded_integers"", ""mtrand"")\n    if name in (""bounded_integers"", ""generator"") or legacy:\n        extra_source = [src_join(""distributions"", ""distributions.c"")]\n        if name == ""generator"":\n            extra_source += [\n                src_join(""distributions"", ""logfactorial.c""),\n                src_join(""distributions"", ""hypergeometric.c""),\n            ]\n        if legacy:\n            extra_source += [src_join(""legacy"", ""legacy-distributions.c"")]\n            extra_macros = [(""RANDOMGEN_LEGACY"", ""1"")]\n    elif name == ""entropy"":\n        extra_source = [src_join(""entropy"", ""entropy.c"")]\n        extra_incl = [src_join(""entropy"")]\n\n    ext = Extension(\n        ""randomgen.{0}"".format(name),\n        source + extra_source,\n        libraries=EXTRA_LIBRARIES,\n        include_dirs=EXTRA_INCLUDE_DIRS + extra_incl,\n        extra_compile_args=EXTRA_COMPILE_ARGS,\n        extra_link_args=EXTRA_LINK_ARGS,\n        define_macros=DEFS + extra_macros,\n        undef_macros=UNDEF_MACROS,\n    )\n    extensions.append(ext)\n\nCPU_FEATURES = [src_join(""common"", ""cpu_features.c"")]\nALIGNED_MALLOC = [src_join(""aligned_malloc"", ""aligned_malloc.c"")]\n\n\ndef bit_generator(\n    name,\n    c_name=None,\n    aligned=False,\n    cpu_features=False,\n    defs=None,\n    compile_args=None,\n    extra_source=None,\n):\n    c_name = name if c_name is None else c_name\n    defs = DEFS if defs is None else defs\n\n    sources = [""randomgen/{0}.pyx"".format(name), src_join(c_name, c_name + "".c"")]\n    if cpu_features:\n        sources += CPU_FEATURES\n    if aligned:\n        sources += ALIGNED_MALLOC\n    if extra_source is not None:\n        sources += [extra_source]\n    compile_args = EXTRA_COMPILE_ARGS if compile_args is None else compile_args\n\n    ext = Extension(\n        ""randomgen.{0}"".format(name),\n        sources,\n        include_dirs=EXTRA_INCLUDE_DIRS,\n        libraries=EXTRA_LIBRARIES,\n        extra_compile_args=compile_args,\n        extra_link_args=EXTRA_LINK_ARGS,\n        define_macros=defs,\n        undef_macros=UNDEF_MACROS,\n    )\n    extensions.append(ext)\n\n\nbit_generator(\n    ""aes"",\n    c_name=""aesctr"",\n    cpu_features=True,\n    aligned=True,\n    compile_args=AES_COMPILE_ARGS,\n)\nbit_generator(\n    ""chacha"", cpu_features=True, aligned=True, compile_args=SSSE3_COMPILE_ARGS\n)\nbit_generator(\n    ""dsfmt"",\n    aligned=True,\n    defs=DSFMT_DEFS,\n    extra_source=src_join(""dsfmt"", ""dSFMT-jump.c""),\n)\nbit_generator(""hc128"", c_name=""hc-128"")\nbit_generator(""jsf"")\nbit_generator(""mt19937"", extra_source=src_join(""mt19937"", ""mt19937-jump.c""))\nbit_generator(""mt64"")\nbit_generator(""pcg32"")\nbit_generator(""pcg64"")\nbit_generator(""philox"", defs=PHILOX_DEFS)\nbit_generator(""rdrand"", cpu_features=True, compile_args=RDRAND_COMPILE_ARGS)\nbit_generator(\n    ""sfmt"", aligned=True, defs=SFMT_DEFS, extra_source=src_join(""sfmt"", ""sfmt-jump.c"")\n)\nbit_generator(\n    ""speck128"",\n    c_name=""speck-128"",\n    cpu_features=True,\n    aligned=True,\n    compile_args=SSSE3_COMPILE_ARGS,\n)\nbit_generator(""threefry"")\nbit_generator(""xoroshiro128"")\nbit_generator(""xorshift1024"")\nbit_generator(""xoshiro256"")\nbit_generator(""xoshiro512"")\nbit_generator(""lxm"")\nextensions.append(\n    Extension(\n        ""randomgen.wrapper"",\n        [""randomgen/wrapper.pyx""],\n        include_dirs=EXTRA_INCLUDE_DIRS,\n        libraries=EXTRA_LIBRARIES,\n        extra_compile_args=EXTRA_COMPILE_ARGS,\n        extra_link_args=EXTRA_LINK_ARGS,\n        define_macros=DEFS,\n        undef_macros=UNDEF_MACROS,\n    )\n)\nextensions.append(\n    Extension(\n        ""randomgen.tests._shims"",\n        [""randomgen/tests/_shims.pyx""],\n        include_dirs=EXTRA_INCLUDE_DIRS,\n        libraries=EXTRA_LIBRARIES,\n        extra_compile_args=EXTRA_COMPILE_ARGS,\n        extra_link_args=EXTRA_LINK_ARGS,\n        define_macros=DEFS,\n        undef_macros=UNDEF_MACROS,\n    )\n)\n\nclassifiers = [\n    ""Development Status :: 5 - Production/Stable"",\n    ""Environment :: Console"",\n    ""Intended Audience :: End Users/Desktop"",\n    ""Intended Audience :: Financial and Insurance Industry"",\n    ""Intended Audience :: Information Technology"",\n    ""Intended Audience :: Science/Research"",\n    ""License :: OSI Approved"",\n    ""Operating System :: MacOS :: MacOS X"",\n    ""Operating System :: Microsoft :: Windows"",\n    ""Operating System :: POSIX :: Linux"",\n    ""Operating System :: Unix"",\n    ""Programming Language :: C"",\n    ""Programming Language :: Cython"",\n    ""Programming Language :: Python :: 2.7"",\n    ""Programming Language :: Python :: 3.5"",\n    ""Programming Language :: Python :: 3.6"",\n    ""Programming Language :: Python :: 3.7"",\n    ""Topic :: Adaptive Technologies"",\n    ""Topic :: Artistic Software"",\n    ""Topic :: Office/Business :: Financial"",\n    ""Topic :: Scientific/Engineering"",\n    ""Topic :: Security :: Cryptography"",\n]\n\n\nclass BinaryDistribution(Distribution):\n    def is_pure(self):\n        return False\n\n\nsetup(\n    name=""randomgen"",\n    version=versioneer.get_version(),\n    classifiers=classifiers,\n    cmdclass=versioneer.get_cmdclass(),\n    ext_modules=cythonize(\n        extensions,\n        compiler_directives={""language_level"": ""3"", ""linetrace"": CYTHON_COVERAGE},\n        force=CYTHON_COVERAGE or DEBUG,\n        gdb_debug=DEBUG,\n    ),\n    packages=find_packages(),\n    package_dir={""randomgen"": ""./randomgen""},\n    package_data={\n        """": [""*.h"", ""*.pxi"", ""*.pyx"", ""*.pxd"", ""*.in""],\n        ""randomgen.tests.data"": [""*.csv""],\n    },\n    include_package_data=True,\n    license=""NCSA"",\n    author=""Kevin Sheppard"",\n    author_email=""kevin.k.sheppard@gmail.com"",\n    distclass=BinaryDistribution,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=""text/markdown"",\n    description=""Random generator supporting multiple PRNGs"",\n    url=""https://github.com/bashtage/randomgen"",\n    keywords=[\n        ""pseudo random numbers"",\n        ""PRNG"",\n        ""RNG"",\n        ""RandomState"",\n        ""random"",\n        ""random numbers"",\n        ""parallel random numbers"",\n        ""PCG"",\n        ""XorShift"",\n        ""dSFMT"",\n        ""MT19937"",\n        ""Random123"",\n        ""ThreeFry"",\n        ""Philox"",\n        ""ChaCha"",\n        ""AES"",\n        ""SPECK"",\n        ""RDRAND"",\n    ],\n    zip_safe=False,\n    install_requires=required,\n)\n'"
versioneer.py,0,"b'# Version: 0.18\n\n""""""The Versioneer - like a rocketeer, but for versions.\n\nThe Versioneer\n==============\n\n* like a rocketeer, but for versions!\n* https://github.com/warner/python-versioneer\n* Brian Warner\n* License: Public Domain\n* Compatible With: python2.6, 2.7, 3.2, 3.3, 3.4, 3.5, 3.6, and pypy\n* [![Latest Version]\n(https://pypip.in/version/versioneer/badge.svg?style=flat)\n](https://pypi.python.org/pypi/versioneer/)\n* [![Build Status]\n(https://travis-ci.org/warner/python-versioneer.png?branch=master)\n](https://travis-ci.org/warner/python-versioneer)\n\nThis is a tool for managing a recorded version number in distutils-based\npython projects. The goal is to remove the tedious and error-prone ""update\nthe embedded version string"" step from your release process. Making a new\nrelease should be as easy as recording a new tag in your version-control\nsystem, and maybe making new tarballs.\n\n\n## Quick Install\n\n* `pip install versioneer` to somewhere to your $PATH\n* add a `[versioneer]` section to your setup.cfg (see below)\n* run `versioneer install` in your source tree, commit the results\n\n## Version Identifiers\n\nSource trees come from a variety of places:\n\n* a version-control system checkout (mostly used by developers)\n* a nightly tarball, produced by build automation\n* a snapshot tarball, produced by a web-based VCS browser, like github\'s\n  ""tarball from tag"" feature\n* a release tarball, produced by ""setup.py sdist"", distributed through PyPI\n\nWithin each source tree, the version identifier (either a string or a number,\nthis tool is format-agnostic) can come from a variety of places:\n\n* ask the VCS tool itself, e.g. ""git describe"" (for checkouts), which knows\n  about recent ""tags"" and an absolute revision-id\n* the name of the directory into which the tarball was unpacked\n* an expanded VCS keyword ($Id$, etc)\n* a `_version.py` created by some earlier build step\n\nFor released software, the version identifier is closely related to a VCS\ntag. Some projects use tag names that include more than just the version\nstring (e.g. ""myproject-1.2"" instead of just ""1.2""), in which case the tool\nneeds to strip the tag prefix to extract the version identifier. For\nunreleased software (between tags), the version identifier should provide\nenough information to help developers recreate the same tree, while also\ngiving them an idea of roughly how old the tree is (after version 1.2, before\nversion 1.3). Many VCS systems can report a description that captures this,\nfor example `git describe --tags --dirty --always` reports things like\n""0.7-1-g574ab98-dirty"" to indicate that the checkout is one revision past the\n0.7 tag, has a unique revision id of ""574ab98"", and is ""dirty"" (it has\nuncommitted changes.\n\nThe version identifier is used for multiple purposes:\n\n* to allow the module to self-identify its version: `myproject.__version__`\n* to choose a name and prefix for a \'setup.py sdist\' tarball\n\n## Theory of Operation\n\nVersioneer works by adding a special `_version.py` file into your source\ntree, where your `__init__.py` can import it. This `_version.py` knows how to\ndynamically ask the VCS tool for version information at import time.\n\n`_version.py` also contains `$Revision$` markers, and the installation\nprocess marks `_version.py` to have this marker rewritten with a tag name\nduring the `git archive` command. As a result, generated tarballs will\ncontain enough information to get the proper version.\n\nTo allow `setup.py` to compute a version too, a `versioneer.py` is added to\nthe top level of your source tree, next to `setup.py` and the `setup.cfg`\nthat configures it. This overrides several distutils/setuptools commands to\ncompute the version when invoked, and changes `setup.py build` and `setup.py\nsdist` to replace `_version.py` with a small static file that contains just\nthe generated version data.\n\n## Installation\n\nSee [INSTALL.md](./INSTALL.md) for detailed installation instructions.\n\n## Version-String Flavors\n\nCode which uses Versioneer can learn about its version string at runtime by\nimporting `_version` from your main `__init__.py` file and running the\n`get_versions()` function. From the ""outside"" (e.g. in `setup.py`), you can\nimport the top-level `versioneer.py` and run `get_versions()`.\n\nBoth functions return a dictionary with different flavors of version\ninformation:\n\n* `[\'version\']`: A condensed version string, rendered using the selected\n  style. This is the most commonly used value for the project\'s version\n  string. The default ""pep440"" style yields strings like `0.11`,\n  `0.11+2.g1076c97`, or `0.11+2.g1076c97.dirty`. See the ""Styles"" section\n  below for alternative styles.\n\n* `[\'full-revisionid\']`: detailed revision identifier. For Git, this is the\n  full SHA1 commit id, e.g. ""1076c978a8d3cfc70f408fe5974aa6c092c949ac"".\n\n* `[\'date\']`: Date and time of the latest `HEAD` commit. For Git, it is the\n  commit date in ISO 8601 format. This will be None if the date is not\n  available.\n\n* `[\'dirty\']`: a boolean, True if the tree has uncommitted changes. Note that\n  this is only accurate if run in a VCS checkout, otherwise it is likely to\n  be False or None\n\n* `[\'error\']`: if the version string could not be computed, this will be set\n  to a string describing the problem, otherwise it will be None. It may be\n  useful to throw an exception in setup.py if this is set, to avoid e.g.\n  creating tarballs with a version string of ""unknown"".\n\nSome variants are more useful than others. Including `full-revisionid` in a\nbug report should allow developers to reconstruct the exact code being tested\n(or indicate the presence of local changes that should be shared with the\ndevelopers). `version` is suitable for display in an ""about"" box or a CLI\n`--version` output: it can be easily compared against release notes and lists\nof bugs fixed in various releases.\n\nThe installer adds the following text to your `__init__.py` to place a basic\nversion in `YOURPROJECT.__version__`:\n\n    from ._version import get_versions\n    __version__ = get_versions()[\'version\']\n    del get_versions\n\n## Styles\n\nThe setup.cfg `style=` configuration controls how the VCS information is\nrendered into a version string.\n\nThe default style, ""pep440"", produces a PEP440-compliant string, equal to the\nun-prefixed tag name for actual releases, and containing an additional ""local\nversion"" section with more detail for in-between builds. For Git, this is\nTAG[+DISTANCE.gHEX[.dirty]] , using information from `git describe --tags\n--dirty --always`. For example ""0.11+2.g1076c97.dirty"" indicates that the\ntree is like the ""1076c97"" commit but has uncommitted changes ("".dirty""), and\nthat this commit is two revisions (""+2"") beyond the ""0.11"" tag. For released\nsoftware (exactly equal to a known tag), the identifier will only contain the\nstripped tag, e.g. ""0.11"".\n\nOther styles are available. See [details.md](details.md) in the Versioneer\nsource tree for descriptions.\n\n## Debugging\n\nVersioneer tries to avoid fatal errors: if something goes wrong, it will tend\nto return a version of ""0+unknown"". To investigate the problem, run `setup.py\nversion`, which will run the version-lookup code in a verbose mode, and will\ndisplay the full contents of `get_versions()` (including the `error` string,\nwhich may help identify what went wrong).\n\n## Known Limitations\n\nSome situations are known to cause problems for Versioneer. This details the\nmost significant ones. More can be found on Github\n[issues page](https://github.com/warner/python-versioneer/issues).\n\n### Subprojects\n\nVersioneer has limited support for source trees in which `setup.py` is not in\nthe root directory (e.g. `setup.py` and `.git/` are *not* siblings). The are\ntwo common reasons why `setup.py` might not be in the root:\n\n* Source trees which contain multiple subprojects, such as\n  [Buildbot](https://github.com/buildbot/buildbot), which contains both\n  ""master"" and ""slave"" subprojects, each with their own `setup.py`,\n  `setup.cfg`, and `tox.ini`. Projects like these produce multiple PyPI\n  distributions (and upload multiple independently-installable tarballs).\n* Source trees whose main purpose is to contain a C library, but which also\n  provide bindings to Python (and perhaps other langauges) in subdirectories.\n\nVersioneer will look for `.git` in parent directories, and most operations\nshould get the right version string. However `pip` and `setuptools` have bugs\nand implementation details which frequently cause `pip install .` from a\nsubproject directory to fail to find a correct version string (so it usually\ndefaults to `0+unknown`).\n\n`pip install --editable .` should work correctly. `setup.py install` might\nwork too.\n\nPip-8.1.1 is known to have this problem, but hopefully it will get fixed in\nsome later version.\n\n[Bug #38](https://github.com/warner/python-versioneer/issues/38) is tracking\nthis issue. The discussion in\n[PR #61](https://github.com/warner/python-versioneer/pull/61) describes the\nissue from the Versioneer side in more detail.\n[pip PR#3176](https://github.com/pypa/pip/pull/3176) and\n[pip PR#3615](https://github.com/pypa/pip/pull/3615) contain work to improve\npip to let Versioneer work correctly.\n\nVersioneer-0.16 and earlier only looked for a `.git` directory next to the\n`setup.cfg`, so subprojects were completely unsupported with those releases.\n\n### Editable installs with setuptools <= 18.5\n\n`setup.py develop` and `pip install --editable .` allow you to install a\nproject into a virtualenv once, then continue editing the source code (and\ntest) without re-installing after every change.\n\n""Entry-point scripts"" (`setup(entry_points={""console_scripts"": ..})`) are a\nconvenient way to specify executable scripts that should be installed along\nwith the python package.\n\nThese both work as expected when using modern setuptools. When using\nsetuptools-18.5 or earlier, however, certain operations will cause\n`pkg_resources.DistributionNotFound` errors when running the entrypoint\nscript, which must be resolved by re-installing the package. This happens\nwhen the install happens with one version, then the egg_info data is\nregenerated while a different version is checked out. Many setup.py commands\ncause egg_info to be rebuilt (including `sdist`, `wheel`, and installing into\na different virtualenv), so this can be surprising.\n\n[Bug #83](https://github.com/warner/python-versioneer/issues/83) describes\nthis one, but upgrading to a newer version of setuptools should probably\nresolve it.\n\n### Unicode version strings\n\nWhile Versioneer works (and is continually tested) with both Python 2 and\nPython 3, it is not entirely consistent with bytes-vs-unicode distinctions.\nNewer releases probably generate unicode version strings on py2. It\'s not\nclear that this is wrong, but it may be surprising for applications when then\nwrite these strings to a network connection or include them in bytes-oriented\nAPIs like cryptographic checksums.\n\n[Bug #71](https://github.com/warner/python-versioneer/issues/71) investigates\nthis question.\n\n\n## Updating Versioneer\n\nTo upgrade your project to a new release of Versioneer, do the following:\n\n* install the new Versioneer (`pip install -U versioneer` or equivalent)\n* edit `setup.cfg`, if necessary, to include any new configuration settings\n  indicated by the release notes. See [UPGRADING](./UPGRADING.md) for details.\n* re-run `versioneer install` in your source tree, to replace\n  `SRC/_version.py`\n* commit any changed files\n\n## Future Directions\n\nThis tool is designed to make it easily extended to other version-control\nsystems: all VCS-specific components are in separate directories like\nsrc/git/ . The top-level `versioneer.py` script is assembled from these\ncomponents by running make-versioneer.py . In the future, make-versioneer.py\nwill take a VCS name as an argument, and will construct a version of\n`versioneer.py` that is specific to the given VCS. It might also take the\nconfiguration arguments that are currently provided manually during\ninstallation by editing setup.py . Alternatively, it might go the other\ndirection and include code from all supported VCS systems, reducing the\nnumber of intermediate scripts.\n\n\n## License\n\nTo make Versioneer easier to embed, all its code is dedicated to the public\ndomain. The `_version.py` that it creates is also in the public domain.\nSpecifically, both are released under the Creative Commons ""Public Domain\nDedication"" license (CC0-1.0), as described in\nhttps://creativecommons.org/publicdomain/zero/1.0/ .\n\n""""""\n\nfrom __future__ import print_function\n\nimport errno\nimport json\nimport os\nimport re\nimport subprocess\nimport sys\n\ntry:\n    import configparser\nexcept ImportError:\n    import ConfigParser as configparser\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_root():\n    """"""Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    """"""\n    root = os.path.realpath(os.path.abspath(os.getcwd()))\n    setup_py = os.path.join(root, ""setup.py"")\n    versioneer_py = os.path.join(root, ""versioneer.py"")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        # allow \'python path/to/setup.py COMMAND\'\n        root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n        setup_py = os.path.join(root, ""setup.py"")\n        versioneer_py = os.path.join(root, ""versioneer.py"")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        err = (\n            ""Versioneer was unable to run the project root directory. ""\n            ""Versioneer requires setup.py to be executed from ""\n            ""its immediate directory (like \'python setup.py COMMAND\'), ""\n            ""or in a way that lets it use sys.argv[0] to find the root ""\n            ""(like \'python path/to/setup.py COMMAND\').""\n        )\n        raise VersioneerBadRootError(err)\n    try:\n        # Certain runtime workflows (setup.py install/develop in a setuptools\n        # tree) execute all dependencies in a single python process, so\n        # ""versioneer"" may be imported multiple times, and python\'s shared\n        # module-import table will cache the first one. So we can\'t use\n        # os.path.dirname(__file__), as that will find whichever\n        # versioneer.py was first imported, even in later projects.\n        me = os.path.realpath(os.path.abspath(__file__))\n        me_dir = os.path.normcase(os.path.splitext(me)[0])\n        vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n        if me_dir != vsr_dir:\n            print(\n                ""Warning: build in %s is using versioneer.py from %s""\n                % (os.path.dirname(me), versioneer_py)\n            )\n    except NameError:\n        pass\n    return root\n\n\ndef get_config_from_root(root):\n    """"""Read the project setup.cfg file to determine Versioneer config.""""""\n    # This might raise EnvironmentError (if setup.cfg is missing), or\n    # configparser.NoSectionError (if it lacks a [versioneer] section), or\n    # configparser.NoOptionError (if it lacks ""VCS=""). See the docstring at\n    # the top of versioneer.py for instructions on writing your setup.cfg .\n    setup_cfg = os.path.join(root, ""setup.cfg"")\n    parser = configparser.SafeConfigParser()\n    with open(setup_cfg, ""r"") as f:\n        parser.readfp(f)\n    VCS = parser.get(""versioneer"", ""VCS"")  # mandatory\n\n    def get(parser, name):\n        if parser.has_option(""versioneer"", name):\n            return parser.get(""versioneer"", name)\n        return None\n\n    cfg = VersioneerConfig()\n    cfg.VCS = VCS\n    cfg.style = get(parser, ""style"") or """"\n    cfg.versionfile_source = get(parser, ""versionfile_source"")\n    cfg.versionfile_build = get(parser, ""versionfile_build"")\n    cfg.tag_prefix = get(parser, ""tag_prefix"")\n    if cfg.tag_prefix in (""\'\'"", \'""""\'):\n        cfg.tag_prefix = """"\n    cfg.parentdir_prefix = get(parser, ""parentdir_prefix"")\n    cfg.verbose = get(parser, ""verbose"")\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\n# these dictionaries contain VCS-specific tools\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen(\n                [c] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n            )\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %s"" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %s"" % (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %s (error)"" % dispcmd)\n            print(""stdout was %s"" % stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\nLONG_VERSION_PY[\n    ""git""\n] = r\'\'\'\n# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.18 (https://github.com/warner/python-versioneer)\n\n""""""Git implementation of _version.py.""""""\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\n\n\ndef get_keywords():\n    """"""Get the keywords needed to look up the version information.""""""\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = ""%(DOLLAR)sFormat:%%d%(DOLLAR)s""\n    git_full = ""%(DOLLAR)sFormat:%%H%(DOLLAR)s""\n    git_date = ""%(DOLLAR)sFormat:%%ci%(DOLLAR)s""\n    keywords = {""refnames"": git_refnames, ""full"": git_full, ""date"": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_config():\n    """"""Create, populate and return the VersioneerConfig() object.""""""\n    # these strings are filled in when \'setup.py versioneer\' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = ""git""\n    cfg.style = ""%(STYLE)s""\n    cfg.tag_prefix = ""%(TAG_PREFIX)s""\n    cfg.parentdir_prefix = ""%(PARENTDIR_PREFIX)s""\n    cfg.versionfile_source = ""%(VERSIONFILE_SOURCE)s""\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen([c] + args, cwd=cwd, env=env,\n                                 stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %%s"" %% dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %%s"" %% (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %%s (error)"" %% dispcmd)\n            print(""stdout was %%s"" %% stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {""version"": dirname[len(parentdir_prefix):],\n                    ""full-revisionid"": None,\n                    ""dirty"": False, ""error"": None, ""date"": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(""Tried directories %%s but none started with prefix %%s"" %%\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %%d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r\'\\d\', r)])\n        if verbose:\n            print(""discarding \'%%s\', no digits"" %% "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %%s"" %% "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(""picking %%s"" %% r)\n            return {""version"": r,\n                    ""full-revisionid"": keywords[""full""].strip(),\n                    ""dirty"": False, ""error"": None,\n                    ""date"": date}\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {""version"": ""0+unknown"",\n            ""full-revisionid"": keywords[""full""].strip(),\n            ""dirty"": False, ""error"": ""no suitable tags"", ""date"": None}\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root,\n                          hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %%s not under git control"" %% root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(GITS, [""describe"", ""--tags"", ""--dirty"",\n                                          ""--always"", ""--long"",\n                                          ""--match"", ""%%s*"" %% tag_prefix],\n                                   cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\'^(.+)-(\\d+)-g([0-9a-f]+)$\', git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = (""unable to parse git-describe output: \'%%s\'""\n                               %% describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%%s\' doesn\'t start with prefix \'%%s\'""\n                print(fmt %% (full_tag, tag_prefix))\n            pieces[""error""] = (""tag \'%%s\' doesn\'t start with prefix \'%%s\'""\n                               %% (full_tag, tag_prefix))\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""],\n                                    cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%%ci"", ""HEAD""],\n                       cwd=root)[0].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%%d.g%%s"" %% (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%%d.g%%s"" %% (pieces[""distance""],\n                                          pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%%d"" %% pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%%d"" %% pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%%d"" %% pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%%s"" %% pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%%d"" %% pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%%s"" %% pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%%d"" %% pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%%d"" %% pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%%d-g%%s"" %% (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%%d-g%%s"" %% (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {""version"": ""unknown"",\n                ""full-revisionid"": pieces.get(""long""),\n                ""dirty"": None,\n                ""error"": pieces[""error""],\n                ""date"": None}\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%%s\'"" %% style)\n\n    return {""version"": rendered, ""full-revisionid"": pieces[""long""],\n            ""dirty"": pieces[""dirty""], ""error"": None,\n            ""date"": pieces.get(""date"")}\n\n\ndef get_versions():\n    """"""Get version information or return default if unable to do so.""""""\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don\'t do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,\n                                          verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for i in cfg.versionfile_source.split(\'/\'):\n            root = os.path.dirname(root)\n    except NameError:\n        return {""version"": ""0+unknown"", ""full-revisionid"": None,\n                ""dirty"": None,\n                ""error"": ""unable to find root of source tree"",\n                ""date"": None}\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {""version"": ""0+unknown"", ""full-revisionid"": None,\n            ""dirty"": None,\n            ""error"": ""unable to compute version"", ""date"": None}\n\'\'\'\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG) :] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r""\\d"", r)])\n        if verbose:\n            print(""discarding \'%s\', no digits"" % "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %s"" % "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            if verbose:\n                print(""picking %s"" % r)\n            return {\n                ""version"": r,\n                ""full-revisionid"": keywords[""full""].strip(),\n                ""dirty"": False,\n                ""error"": None,\n                ""date"": date,\n            }\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {\n        ""version"": ""0+unknown"",\n        ""full-revisionid"": keywords[""full""].strip(),\n        ""dirty"": False,\n        ""error"": ""no suitable tags"",\n        ""date"": None,\n    }\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root, hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %s not under git control"" % root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(\n        GITS,\n        [\n            ""describe"",\n            ""--tags"",\n            ""--dirty"",\n            ""--always"",\n            ""--long"",\n            ""--match"",\n            ""%s*"" % tag_prefix,\n        ],\n        cwd=root,\n    )\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[: git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r""^(.+)-(\\d+)-g([0-9a-f]+)$"", git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = ""unable to parse git-describe output: \'%s\'"" % describe_out\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                print(fmt % (full_tag, tag_prefix))\n            pieces[""error""] = ""tag \'%s\' doesn\'t start with prefix \'%s\'"" % (\n                full_tag,\n                tag_prefix,\n            )\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix) :]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""], cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%ci"", ""HEAD""], cwd=root)[\n        0\n    ].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef do_vcs_install(manifest_in, versionfile_source, ipy):\n    """"""Git-specific installation logic for Versioneer.\n\n    For Git, this means creating/changing .gitattributes to mark _version.py\n    for export-subst keyword substitution.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n    files = [manifest_in, versionfile_source]\n    if ipy:\n        files.append(ipy)\n    try:\n        me = __file__\n        if me.endswith("".pyc"") or me.endswith("".pyo""):\n            me = os.path.splitext(me)[0] + "".py""\n        versioneer_file = os.path.relpath(me)\n    except NameError:\n        versioneer_file = ""versioneer.py""\n    files.append(versioneer_file)\n    present = False\n    try:\n        f = open("".gitattributes"", ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(versionfile_source):\n                if ""export-subst"" in line.strip().split()[1:]:\n                    present = True\n        f.close()\n    except EnvironmentError:\n        pass\n    if not present:\n        f = open("".gitattributes"", ""a+"")\n        f.write(""%s export-subst\\n"" % versionfile_source)\n        f.close()\n        files.append("".gitattributes"")\n    run_command(GITS, [""add"", ""--""] + files)\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                ""version"": dirname[len(parentdir_prefix) :],\n                ""full-revisionid"": None,\n                ""dirty"": False,\n                ""error"": None,\n                ""date"": None,\n            }\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\n            ""Tried directories %s but none started with prefix %s""\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\nSHORT_VERSION_PY = """"""\n# This file was generated by \'versioneer.py\' (0.18) from\n# revision-control system data, or from the parent directory name of an\n# unpacked source archive. Distribution tarballs contain a pre-generated copy\n# of this file.\n\nimport json\n\nversion_json = \'\'\'\n%s\n\'\'\'  # END VERSION_JSON\n\n\ndef get_versions():\n    return json.loads(version_json)\n""""""\n\n\ndef versions_from_file(filename):\n    """"""Try to determine the version from _version.py if present.""""""\n    try:\n        with open(filename) as f:\n            contents = f.read()\n    except EnvironmentError:\n        raise NotThisMethod(""unable to read _version.py"")\n    mo = re.search(\n        r""version_json = \'\'\'\\n(.*)\'\'\'  # END VERSION_JSON"", contents, re.M | re.S\n    )\n    if not mo:\n        mo = re.search(\n            r""version_json = \'\'\'\\r\\n(.*)\'\'\'  # END VERSION_JSON"", contents, re.M | re.S\n        )\n    if not mo:\n        raise NotThisMethod(""no version_json in _version.py"")\n    return json.loads(mo.group(1))\n\n\ndef write_to_version_file(filename, versions):\n    """"""Write the given version number to the given _version.py file.""""""\n    os.unlink(filename)\n    contents = json.dumps(versions, sort_keys=True, indent=1, separators=("","", "": ""))\n    with open(filename, ""w"") as f:\n        f.write(SHORT_VERSION_PY % contents)\n\n    print(""set %s to \'%s\'"" % (filename, versions[""version""]))\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%d.g%s"" % (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%d.g%s"" % (pieces[""distance""], pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%d"" % pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%d"" % pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%s"" % pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%s"" % pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {\n            ""version"": ""unknown"",\n            ""full-revisionid"": pieces.get(""long""),\n            ""dirty"": None,\n            ""error"": pieces[""error""],\n            ""date"": None,\n        }\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%s\'"" % style)\n\n    return {\n        ""version"": rendered,\n        ""full-revisionid"": pieces[""long""],\n        ""dirty"": pieces[""dirty""],\n        ""error"": None,\n        ""date"": pieces.get(""date""),\n    }\n\n\nclass VersioneerBadRootError(Exception):\n    """"""The project root directory is unknown or missing key files.""""""\n\n\ndef get_versions(verbose=False):\n    """"""Get the project version from whatever source is available.\n\n    Returns dict with two keys: \'version\' and \'full\'.\n    """"""\n    if ""versioneer"" in sys.modules:\n        # see the discussion in cmdclass.py:get_cmdclass()\n        del sys.modules[""versioneer""]\n\n    root = get_root()\n    cfg = get_config_from_root(root)\n\n    assert cfg.VCS is not None, ""please set [versioneer]VCS= in setup.cfg""\n    handlers = HANDLERS.get(cfg.VCS)\n    assert handlers, ""unrecognized VCS \'%s\'"" % cfg.VCS\n    verbose = verbose or cfg.verbose\n    assert (\n        cfg.versionfile_source is not None\n    ), ""please set versioneer.versionfile_source""\n    assert cfg.tag_prefix is not None, ""please set versioneer.tag_prefix""\n\n    versionfile_abs = os.path.join(root, cfg.versionfile_source)\n\n    # extract version from first of: _version.py, VCS command (e.g. \'git\n    # describe\'), parentdir. This is meant to work for developers using a\n    # source checkout, for users of a tarball created by \'setup.py sdist\',\n    # and for users of a tarball/zipball created by \'git archive\' or github\'s\n    # download-from-tag feature or the equivalent in other VCSes.\n\n    get_keywords_f = handlers.get(""get_keywords"")\n    from_keywords_f = handlers.get(""keywords"")\n    if get_keywords_f and from_keywords_f:\n        try:\n            keywords = get_keywords_f(versionfile_abs)\n            ver = from_keywords_f(keywords, cfg.tag_prefix, verbose)\n            if verbose:\n                print(""got version from expanded keyword %s"" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        ver = versions_from_file(versionfile_abs)\n        if verbose:\n            print(""got version from file %s %s"" % (versionfile_abs, ver))\n        return ver\n    except NotThisMethod:\n        pass\n\n    from_vcs_f = handlers.get(""pieces_from_vcs"")\n    if from_vcs_f:\n        try:\n            pieces = from_vcs_f(cfg.tag_prefix, root, verbose)\n            ver = render(pieces, cfg.style)\n            if verbose:\n                print(""got version from VCS %s"" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        if cfg.parentdir_prefix:\n            ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n            if verbose:\n                print(""got version from parentdir %s"" % ver)\n            return ver\n    except NotThisMethod:\n        pass\n\n    if verbose:\n        print(""unable to compute version"")\n\n    return {\n        ""version"": ""0+unknown"",\n        ""full-revisionid"": None,\n        ""dirty"": None,\n        ""error"": ""unable to compute version"",\n        ""date"": None,\n    }\n\n\ndef get_version():\n    """"""Get the short version string for this project.""""""\n    return get_versions()[""version""]\n\n\ndef get_cmdclass():\n    """"""Get the custom setuptools/distutils subclasses used by Versioneer.""""""\n    if ""versioneer"" in sys.modules:\n        del sys.modules[""versioneer""]\n        # this fixes the ""python setup.py develop"" case (also \'install\' and\n        # \'easy_install .\'), in which subdependencies of the main project are\n        # built (using setup.py bdist_egg) in the same python process. Assume\n        # a main project A and a dependency B, which use different versions\n        # of Versioneer. A\'s setup.py imports A\'s Versioneer, leaving it in\n        # sys.modules by the time B\'s setup.py is executed, causing B to run\n        # with the wrong versioneer. Setuptools wraps the sub-dep builds in a\n        # sandbox that restores sys.modules to it\'s pre-build state, so the\n        # parent is protected against the child\'s ""import versioneer"". By\n        # removing ourselves from sys.modules here, before the child build\n        # happens, we protect the child from the parent\'s versioneer too.\n        # Also see https://github.com/warner/python-versioneer/issues/52\n\n    cmds = {}\n\n    # we add ""version"" to both distutils and setuptools\n    from distutils.core import Command\n\n    class cmd_version(Command):\n        description = ""report generated version string""\n        user_options = []\n        boolean_options = []\n\n        def initialize_options(self):\n            pass\n\n        def finalize_options(self):\n            pass\n\n        def run(self):\n            vers = get_versions(verbose=True)\n            print(""Version: %s"" % vers[""version""])\n            print("" full-revisionid: %s"" % vers.get(""full-revisionid""))\n            print("" dirty: %s"" % vers.get(""dirty""))\n            print("" date: %s"" % vers.get(""date""))\n            if vers[""error""]:\n                print("" error: %s"" % vers[""error""])\n\n    cmds[""version""] = cmd_version\n\n    # we override ""build_py"" in both distutils and setuptools\n    #\n    # most invocation pathways end up running build_py:\n    #  distutils/build -> build_py\n    #  distutils/install -> distutils/build ->..\n    #  setuptools/bdist_wheel -> distutils/install ->..\n    #  setuptools/bdist_egg -> distutils/install_lib -> build_py\n    #  setuptools/install -> bdist_egg ->..\n    #  setuptools/develop -> ?\n    #  pip install:\n    #   copies source tree to a tempdir before running egg_info/etc\n    #   if .git isn\'t copied too, \'git describe\' will fail\n    #   then does setup.py bdist_wheel, or sometimes setup.py install\n    #  setup.py egg_info -> ?\n\n    # we override different ""build_py"" commands for both environments\n    if ""setuptools"" in sys.modules:\n        from setuptools.command.build_py import build_py as _build_py\n    else:\n        from distutils.command.build_py import build_py as _build_py\n\n    class cmd_build_py(_build_py):\n        def run(self):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            versions = get_versions()\n            _build_py.run(self)\n            # now locate _version.py in the new build/ directory and replace\n            # it with an updated value\n            if cfg.versionfile_build:\n                target_versionfile = os.path.join(self.build_lib, cfg.versionfile_build)\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n    cmds[""build_py""] = cmd_build_py\n\n    if ""cx_Freeze"" in sys.modules:  # cx_freeze enabled?\n        from cx_Freeze.dist import build_exe as _build_exe\n\n        # nczeczulin reports that py2exe won\'t like the pep440-style string\n        # as FILEVERSION, but it can be used for PRODUCTVERSION, e.g.\n        # setup(console=[{\n        #   ""version"": versioneer.get_version().split(""+"", 1)[0], # FILEVERSION\n        #   ""product_version"": versioneer.get_version(),\n        #   ...\n\n        class cmd_build_exe(_build_exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _build_exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, ""w"") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(\n                        LONG\n                        % {\n                            ""DOLLAR"": ""$"",\n                            ""STYLE"": cfg.style,\n                            ""TAG_PREFIX"": cfg.tag_prefix,\n                            ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                            ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n                        }\n                    )\n\n        cmds[""build_exe""] = cmd_build_exe\n        del cmds[""build_py""]\n\n    if ""py2exe"" in sys.modules:  # py2exe enabled?\n        try:\n            from py2exe.distutils_buildexe import py2exe as _py2exe  # py3\n        except ImportError:\n            from py2exe.build_exe import py2exe as _py2exe  # py2\n\n        class cmd_py2exe(_py2exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _py2exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, ""w"") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(\n                        LONG\n                        % {\n                            ""DOLLAR"": ""$"",\n                            ""STYLE"": cfg.style,\n                            ""TAG_PREFIX"": cfg.tag_prefix,\n                            ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                            ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n                        }\n                    )\n\n        cmds[""py2exe""] = cmd_py2exe\n\n    # we override different ""sdist"" commands for both environments\n    if ""setuptools"" in sys.modules:\n        from setuptools.command.sdist import sdist as _sdist\n    else:\n        from distutils.command.sdist import sdist as _sdist\n\n    class cmd_sdist(_sdist):\n        def run(self):\n            versions = get_versions()\n            self._versioneer_generated_versions = versions\n            # unless we update this, the command will keep using the old\n            # version\n            self.distribution.metadata.version = versions[""version""]\n            return _sdist.run(self)\n\n        def make_release_tree(self, base_dir, files):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            _sdist.make_release_tree(self, base_dir, files)\n            # now locate _version.py in the new base_dir directory\n            # (remembering that it may be a hardlink) and replace it with an\n            # updated value\n            target_versionfile = os.path.join(base_dir, cfg.versionfile_source)\n            print(""UPDATING %s"" % target_versionfile)\n            write_to_version_file(\n                target_versionfile, self._versioneer_generated_versions\n            )\n\n    cmds[""sdist""] = cmd_sdist\n\n    return cmds\n\n\nCONFIG_ERROR = """"""\nsetup.cfg is missing the necessary Versioneer configuration. You need\na section like:\n\n [versioneer]\n VCS = git\n style = pep440\n versionfile_source = src/myproject/_version.py\n versionfile_build = myproject/_version.py\n tag_prefix =\n parentdir_prefix = myproject-\n\nYou will also need to edit your setup.py to use the results:\n\n import versioneer\n setup(version=versioneer.get_version(),\n       cmdclass=versioneer.get_cmdclass(), ...)\n\nPlease read the docstring in ./versioneer.py for configuration instructions,\nedit setup.cfg, and re-run the installer or \'python versioneer.py setup\'.\n""""""\n\nSAMPLE_CONFIG = """"""\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run \'versioneer.py setup\' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\n#VCS = git\n#style = pep440\n#versionfile_source =\n#versionfile_build =\n#tag_prefix =\n#parentdir_prefix =\n\n""""""\n\nINIT_PY_SNIPPET = """"""\nfrom ._version import get_versions\n__version__ = get_versions()[\'version\']\ndel get_versions\n""""""\n\n\ndef do_setup():\n    """"""Main VCS-independent setup function for installing Versioneer.""""""\n    root = get_root()\n    try:\n        cfg = get_config_from_root(root)\n    except (\n        EnvironmentError,\n        configparser.NoSectionError,\n        configparser.NoOptionError,\n    ) as e:\n        if isinstance(e, (EnvironmentError, configparser.NoSectionError)):\n            print(""Adding sample versioneer config to setup.cfg"", file=sys.stderr)\n            with open(os.path.join(root, ""setup.cfg""), ""a"") as f:\n                f.write(SAMPLE_CONFIG)\n        print(CONFIG_ERROR, file=sys.stderr)\n        return 1\n\n    print("" creating %s"" % cfg.versionfile_source)\n    with open(cfg.versionfile_source, ""w"") as f:\n        LONG = LONG_VERSION_PY[cfg.VCS]\n        f.write(\n            LONG\n            % {\n                ""DOLLAR"": ""$"",\n                ""STYLE"": cfg.style,\n                ""TAG_PREFIX"": cfg.tag_prefix,\n                ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n            }\n        )\n\n    ipy = os.path.join(os.path.dirname(cfg.versionfile_source), ""__init__.py"")\n    if os.path.exists(ipy):\n        try:\n            with open(ipy, ""r"") as f:\n                old = f.read()\n        except EnvironmentError:\n            old = """"\n        if INIT_PY_SNIPPET not in old:\n            print("" appending to %s"" % ipy)\n            with open(ipy, ""a"") as f:\n                f.write(INIT_PY_SNIPPET)\n        else:\n            print("" %s unmodified"" % ipy)\n    else:\n        print("" %s doesn\'t exist, ok"" % ipy)\n        ipy = None\n\n    # Make sure both the top-level ""versioneer.py"" and versionfile_source\n    # (PKG/_version.py, used by runtime code) are in MANIFEST.in, so\n    # they\'ll be copied into source distributions. Pip won\'t be able to\n    # install the package without this.\n    manifest_in = os.path.join(root, ""MANIFEST.in"")\n    simple_includes = set()\n    try:\n        with open(manifest_in, ""r"") as f:\n            for line in f:\n                if line.startswith(""include ""):\n                    for include in line.split()[1:]:\n                        simple_includes.add(include)\n    except EnvironmentError:\n        pass\n    # That doesn\'t cover everything MANIFEST.in can do\n    # (http://docs.python.org/2/distutils/sourcedist.html#commands), so\n    # it might give some false negatives. Appending redundant \'include\'\n    # lines is safe, though.\n    if ""versioneer.py"" not in simple_includes:\n        print("" appending \'versioneer.py\' to MANIFEST.in"")\n        with open(manifest_in, ""a"") as f:\n            f.write(""include versioneer.py\\n"")\n    else:\n        print("" \'versioneer.py\' already in MANIFEST.in"")\n    if cfg.versionfile_source not in simple_includes:\n        print(\n            "" appending versionfile_source (\'%s\') to MANIFEST.in""\n            % cfg.versionfile_source\n        )\n        with open(manifest_in, ""a"") as f:\n            f.write(""include %s\\n"" % cfg.versionfile_source)\n    else:\n        print("" versionfile_source already in MANIFEST.in"")\n\n    # Make VCS-specific changes. For git, this means creating/changing\n    # .gitattributes to mark _version.py for export-subst keyword\n    # substitution.\n    do_vcs_install(manifest_in, cfg.versionfile_source, ipy)\n    return 0\n\n\ndef scan_setup_py():\n    """"""Validate the contents of setup.py against Versioneer\'s expectations.""""""\n    found = set()\n    setters = False\n    errors = 0\n    with open(""setup.py"", ""r"") as f:\n        for line in f.readlines():\n            if ""import versioneer"" in line:\n                found.add(""import"")\n            if ""versioneer.get_cmdclass()"" in line:\n                found.add(""cmdclass"")\n            if ""versioneer.get_version()"" in line:\n                found.add(""get_version"")\n            if ""versioneer.VCS"" in line:\n                setters = True\n            if ""versioneer.versionfile_source"" in line:\n                setters = True\n    if len(found) != 3:\n        print("""")\n        print(""Your setup.py appears to be missing some important items"")\n        print(""(but I might be wrong). Please make sure it has something"")\n        print(""roughly like the following:"")\n        print("""")\n        print("" import versioneer"")\n        print("" setup( version=versioneer.get_version(),"")\n        print(""        cmdclass=versioneer.get_cmdclass(),  ...)"")\n        print("""")\n        errors += 1\n    if setters:\n        print(""You should remove lines like \'versioneer.VCS = \' and"")\n        print(""\'versioneer.versionfile_source = \' . This configuration"")\n        print(""now lives in setup.cfg, and should be removed from setup.py"")\n        print("""")\n        errors += 1\n    return errors\n\n\nif __name__ == ""__main__"":\n    cmd = sys.argv[1]\n    if cmd == ""setup"":\n        errors = do_setup()\n        errors += scan_setup_py()\n        if errors:\n            sys.exit(1)\n'"
randomgen/__init__.py,0,"b'from randomgen.aes import AESCounter\nfrom randomgen.chacha import ChaCha\nfrom randomgen.dsfmt import DSFMT\nfrom randomgen.entropy import random_entropy\nfrom randomgen.generator import ExtendedGenerator, Generator\nfrom randomgen.hc128 import HC128\nfrom randomgen.jsf import JSF\nfrom randomgen.lxm import LXM\nfrom randomgen.mt64 import MT64\nfrom randomgen.mt19937 import MT19937\nfrom randomgen.mtrand import RandomState\nfrom randomgen.pcg32 import PCG32\nfrom randomgen.pcg64 import PCG64\nfrom randomgen.philox import Philox\nfrom randomgen.rdrand import RDRAND\nfrom randomgen.seed_sequence import SeedlessSeedSequence, SeedSequence\nfrom randomgen.sfmt import SFMT\nfrom randomgen.speck128 import SPECK128\nfrom randomgen.threefry import ThreeFry\nfrom randomgen.wrapper import UserBitGenerator\nfrom randomgen.xoroshiro128 import Xoroshiro128\nfrom randomgen.xorshift1024 import Xorshift1024\nfrom randomgen.xoshiro256 import Xoshiro256\nfrom randomgen.xoshiro512 import Xoshiro512\n\nfrom ._version import get_versions\n\n__all__ = [\n    ""DSFMT"",\n    ""Generator"",\n    ""ExtendedGenerator"",\n    ""HC128"",\n    ""JSF"",\n    ""LXM"",\n    ""MT19937"",\n    ""MT64"",\n    ""PCG32"",\n    ""PCG64"",\n    ""Philox"",\n    ""RDRAND"",\n    ""RandomState"",\n    ""SFMT"",\n    ""SPECK128"",\n    ""ThreeFry"",\n    ""Xoroshiro128"",\n    ""Xorshift1024"",\n    ""Xoshiro256"",\n    ""Xoshiro512"",\n    ""AESCounter"",\n    ""ChaCha"",\n    ""random_entropy"",\n    ""SeedSequence"",\n    ""SeedlessSeedSequence"",\n    ""UserBitGenerator"",\n]\n\n__version__ = get_versions()[""version""]\ndel get_versions\n'"
randomgen/_pickle.py,0,"b'import warnings\n\nfrom randomgen.aes import AESCounter\nfrom randomgen.chacha import ChaCha\nfrom randomgen.dsfmt import DSFMT\nfrom randomgen.generator import ExtendedGenerator, Generator\nfrom randomgen.hc128 import HC128\nfrom randomgen.jsf import JSF\nfrom randomgen.lxm import LXM\nfrom randomgen.mt64 import MT64\nfrom randomgen.mt19937 import MT19937\nfrom randomgen.mtrand import RandomState\nfrom randomgen.pcg32 import PCG32\nfrom randomgen.pcg64 import PCG64\nfrom randomgen.philox import Philox\nfrom randomgen.rdrand import RDRAND\nfrom randomgen.sfmt import SFMT\nfrom randomgen.speck128 import SPECK128\nfrom randomgen.threefry import ThreeFry\nfrom randomgen.xoroshiro128 import Xoroshiro128\nfrom randomgen.xorshift1024 import Xorshift1024\nfrom randomgen.xoshiro256 import Xoshiro256\nfrom randomgen.xoshiro512 import Xoshiro512\n\nBitGenerators = {\n    ""AESCounter"": AESCounter,\n    ""ChaCha"": ChaCha,\n    ""DSFMT"": DSFMT,\n    ""HC128"": HC128,\n    ""JSF"": JSF,\n    ""LXM"": LXM,\n    ""MT19937"": MT19937,\n    ""MT64"": MT64,\n    ""PCG32"": PCG32,\n    ""PCG64"": PCG64,\n    ""Philox"": Philox,\n    ""ThreeFry"": ThreeFry,\n    ""Xorshift1024"": Xorshift1024,\n    ""Xoroshiro128"": Xoroshiro128,\n    ""Xoshiro256"": Xoshiro256,\n    ""Xoshiro512"": Xoshiro512,\n    ""SPECK128"": SPECK128,\n    ""SFMT"": SFMT,\n    ""RDRAND"": RDRAND,\n}\n\n\ndef _get_bitgenerator(bit_generator_name):\n    """"""\n    Bit generator look-up with user-friendly errors\n    """"""\n    if bit_generator_name in BitGenerators:\n        bit_generator = BitGenerators[bit_generator_name]\n    else:\n        raise ValueError(\n            str(bit_generator_name) + "" is not a known BitGenerator module.""\n        )\n    return bit_generator\n\n\ndef __generator_ctor(bit_generator_name=""MT19937""):\n    """"""\n    Pickling helper function that returns a Generator object\n\n    Parameters\n    ----------\n    bit_generator_name: str\n        String containing the core BitGenerator\n\n    Returns\n    -------\n    rg: Generator\n        Generator using the named core BitGenerator\n    """"""\n    try:\n        bit_generator_name = bit_generator_name.decode(""ascii"")\n    except AttributeError:\n        pass\n    bit_generator = _get_bitgenerator(bit_generator_name)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(""ignore"", category=FutureWarning)\n        bit_gen = bit_generator()\n    return Generator(bit_gen)\n\n\ndef __extended_generator_ctor(bit_generator_name=""MT19937""):\n    """"""\n    Pickling helper function that returns a Generator object\n\n    Parameters\n    ----------\n    bit_generator_name: str\n        String containing the core BitGenerator\n\n    Returns\n    -------\n    rg: Generator\n        Generator using the named core BitGenerator\n    """"""\n    try:\n        bit_generator_name = bit_generator_name.decode(""ascii"")\n    except AttributeError:\n        pass\n    bit_generator = _get_bitgenerator(bit_generator_name)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(""ignore"", category=FutureWarning)\n        bit_gen = bit_generator()\n    return ExtendedGenerator(bit_gen)\n\n\ndef __bit_generator_ctor(bit_generator_name=""MT19937""):\n    """"""\n    Pickling helper function that returns a bit generator object\n\n    Parameters\n    ----------\n    bit_generator_name: str\n        String containing the name of the bit generator\n\n    Returns\n    -------\n    bit_generator: BitGenerator\n        Bit generator instance\n    """"""\n    try:\n        bit_generator_name = bit_generator_name.decode(""ascii"")\n    except AttributeError:\n        pass\n    bit_generator = _get_bitgenerator(bit_generator_name)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(""ignore"", category=FutureWarning)\n        bit_gen = bit_generator()\n    return bit_gen\n\n\ndef __randomstate_ctor(bit_generator_name=""MT19937""):\n    """"""\n    Pickling helper function that returns a legacy RandomState-like object\n\n    Parameters\n    ----------\n    bit_generator_name: str\n        String containing the core BitGenerator\n\n    Returns\n    -------\n    rs: RandomState\n        Legacy RandomState using the named core BitGenerator\n    """"""\n    try:\n        bit_generator_name = bit_generator_name.decode(""ascii"")\n    except AttributeError:\n        pass\n    bit_generator = _get_bitgenerator(bit_generator_name)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(""ignore"", category=FutureWarning)\n        bit_gen = bit_generator()\n    return RandomState(bit_gen)\n'"
randomgen/_testing.py,3,"b'""""""\nShim for NumPy\'s suppress_warnings\n""""""\n\n\ntry:\n    from numpy.testing import suppress_warnings\nexcept ImportError:\n\n    # The following two classes are copied from python 2.6 warnings module\n    # (context manager)\n    class WarningMessage(object):\n\n        """"""\n        Holds the result of a single showwarning() call.\n        Deprecated in 1.8.0\n        Notes\n        -----\n        `WarningMessage` is copied from the Python 2.6 warnings module,\n        so it can be used in NumPy with older Python versions.\n        """"""\n\n        _WARNING_DETAILS = (""message"", ""category"", ""filename"", ""lineno"", ""file"", ""line"")\n\n        def __init__(self, message, category, filename, lineno, file=None, line=None):\n            local_values = locals()\n            for attr in self._WARNING_DETAILS:\n                setattr(self, attr, local_values[attr])\n            if category:\n                self._category_name = category.__name__\n            else:\n                self._category_name = None\n\n        def __str__(self):\n            return (\n                ""{message : %r, category : %r, ""\n                ""filename : %r, lineno : %s, ""\n                ""line : %r}""\n                % (\n                    self.message,\n                    self._category_name,\n                    self.filename,\n                    self.lineno,\n                    self.line,\n                )\n            )\n\n    import re\n    import warnings\n    from functools import wraps\n\n    class suppress_warnings(object):\n        """"""\n        Context manager and decorator doing much the same as\n        ``warnings.catch_warnings``.\n        However, it also provides a filter mechanism to work around\n        http://bugs.python.org/issue4180.\n        This bug causes Python before 3.4 to not reliably show warnings again\n        after they have been ignored once (even within catch_warnings). It\n        means that no ""ignore"" filter can be used easily, since following\n        tests might need to see the warning. Additionally it allows easier\n        specificity for testing warnings and can be nested.\n        Parameters\n        ----------\n        forwarding_rule : str, optional\n            One of ""always"", ""once"", ""module"", or ""location"". Analogous to\n            the usual warnings module filter mode, it is useful to reduce\n            noise mostly on the outmost level. Unsuppressed and unrecorded\n            warnings will be forwarded based on this rule. Defaults to\n            ""always"". ""location"" is equivalent to the warnings ""default"", match\n            by exact location the warning warning originated from.\n        Notes\n        -----\n        Filters added inside the context manager will be discarded again\n        when leaving it. Upon entering all filters defined outside a\n        context will be applied automatically.\n        When a recording filter is added, matching warnings are stored in the\n        ``log`` attribute as well as in the list returned by ``record``.\n        If filters are added and the ``module`` keyword is given, the\n        warning registry of this module will additionally be cleared when\n        applying it, entering the context, or exiting it. This could cause\n        warnings to appear a second time after leaving the context if they\n        were configured to be printed once (default) and were already\n        printed before the context was entered.\n        Nesting this context manager will work as expected when the\n        forwarding rule is ""always"" (default). Unfiltered and unrecorded\n        warnings will be passed out and be matched by the outer level.\n        On the outmost level they will be printed (or caught by another\n        warnings context). The forwarding rule argument can modify this\n        behaviour.\n        Like ``catch_warnings`` this context manager is not threadsafe.\n        Examples\n        --------\n        >>> with suppress_warnings() as sup:\n        ...     sup.filter(DeprecationWarning, ""Some text"")\n        ...     sup.filter(module=np.ma.core)\n        ...     log = sup.record(FutureWarning, ""Does this occur?"")\n        ...     command_giving_warnings()\n        ...     # The FutureWarning was given once, the filtered warnings were\n        ...     # ignored. All other warnings abide outside settings (may be\n        ...     # printed/error)\n        ...     assert_(len(log) == 1)\n        ...     assert_(len(sup.log) == 1)  # also stored in log attribute\n        Or as a decorator:\n        >>> sup = suppress_warnings()\n        >>> sup.filter(module=np.ma.core)  # module must match exact\n        >>> @sup\n        >>> def some_function():\n        ...     # do something which causes a warning in np.ma.core\n        ...     pass\n        """"""\n\n        def __init__(self, forwarding_rule=""always""):\n            self._entered = False\n\n            # Suppressions are instance or defined inside one with block:\n            self._suppressions = []\n\n            if forwarding_rule not in {""always"", ""module"", ""once"", ""location""}:\n                raise ValueError(""unsupported forwarding rule."")\n            self._forwarding_rule = forwarding_rule\n\n        def _clear_registries(self):\n            if hasattr(warnings, ""_filters_mutated""):\n                # clearing the registry should not be necessary on new pythons,\n                # instead the filters should be mutated.\n                warnings._filters_mutated()\n                return\n            # Simply clear the registry, this should normally be harmless,\n            # note that on new pythons it would be invalidated anyway.\n            for module in self._tmp_modules:\n                if hasattr(module, ""__warningregistry__""):\n                    module.__warningregistry__.clear()\n\n        def _filter(self, category=Warning, message="""", module=None, record=False):\n            if record:\n                record = []  # The log where to store warnings\n            else:\n                record = None\n            if self._entered:\n                if module is None:\n                    warnings.filterwarnings(\n                        ""always"", category=category, message=message\n                    )\n                else:\n                    module_regex = module.__name__.replace(""."", r""\\."") + ""$""\n                    warnings.filterwarnings(\n                        ""always"",\n                        category=category,\n                        message=message,\n                        module=module_regex,\n                    )\n                    self._tmp_modules.add(module)\n                    self._clear_registries()\n\n                self._tmp_suppressions.append(\n                    (category, message, re.compile(message, re.I), module, record)\n                )\n            else:\n                self._suppressions.append(\n                    (category, message, re.compile(message, re.I), module, record)\n                )\n\n            return record\n\n        def filter(self, category=Warning, message="""", module=None):\n            """"""\n            Add a new suppressing filter or apply it if the state is entered.\n            Parameters\n            ----------\n            category : class, optional\n                Warning class to filter\n            message : string, optional\n                Regular expression matching the warning message.\n            module : module, optional\n                Module to filter for. Note that the module (and its file)\n                must match exactly and cannot be a submodule. This may make\n                it unreliable for external modules.\n            Notes\n            -----\n            When added within a context, filters are only added inside\n            the context and will be forgotten when the context is exited.\n            """"""\n            self._filter(\n                category=category, message=message, module=module, record=False\n            )\n\n        def record(self, category=Warning, message="""", module=None):\n            """"""\n            Append a new recording filter or apply it if the state is entered.\n            All warnings matching will be appended to the ``log`` attribute.\n            Parameters\n            ----------\n            category : class, optional\n                Warning class to filter\n            message : string, optional\n                Regular expression matching the warning message.\n            module : module, optional\n                Module to filter for. Note that the module (and its file)\n                must match exactly and cannot be a submodule. This may make\n                it unreliable for external modules.\n            Returns\n            -------\n            log : list\n                A list which will be filled with all matched warnings.\n            Notes\n            -----\n            When added within a context, filters are only added inside\n            the context and will be forgotten when the context is exited.\n            """"""\n            return self._filter(\n                category=category, message=message, module=module, record=True\n            )\n\n        def __enter__(self):\n            if self._entered:\n                raise RuntimeError(""cannot enter suppress_warnings twice."")\n\n            self._orig_show = warnings.showwarning\n            if hasattr(warnings, ""_showwarnmsg""):\n                self._orig_showmsg = warnings._showwarnmsg\n            self._filters = warnings.filters\n            warnings.filters = self._filters[:]\n\n            self._entered = True\n            self._tmp_suppressions = []\n            self._tmp_modules = set()\n            self._forwarded = set()\n\n            self.log = []  # reset global log (no need to keep same list)\n\n            for cat, mess, _, mod, log in self._suppressions:\n                if log is not None:\n                    del log[:]  # clear the log\n                if mod is None:\n                    warnings.filterwarnings(""always"", category=cat, message=mess)\n                else:\n                    module_regex = mod.__name__.replace(""."", r""\\."") + ""$""\n                    warnings.filterwarnings(\n                        ""always"", category=cat, message=mess, module=module_regex\n                    )\n                    self._tmp_modules.add(mod)\n            warnings.showwarning = self._showwarning\n            if hasattr(warnings, ""_showwarnmsg""):\n                warnings._showwarnmsg = self._showwarnmsg\n            self._clear_registries()\n\n            return self\n\n        def __exit__(self, *exc_info):\n            warnings.showwarning = self._orig_show\n            if hasattr(warnings, ""_showwarnmsg""):\n                warnings._showwarnmsg = self._orig_showmsg\n            warnings.filters = self._filters\n            self._clear_registries()\n            self._entered = False\n            del self._orig_show\n            del self._filters\n\n        def _showwarnmsg(self, msg):\n            self._showwarning(\n                msg.message,\n                msg.category,\n                msg.filename,\n                msg.lineno,\n                msg.file,\n                msg.line,\n                use_warnmsg=msg,\n            )\n\n        def _showwarning(self, message, category, filename, lineno, *args, **kwargs):\n            use_warnmsg = kwargs.pop(""use_warnmsg"", None)\n            for cat, _, pattern, mod, rec in (\n                self._suppressions + self._tmp_suppressions\n            )[::-1]:\n                if (\n                    issubclass(category, cat)\n                    and pattern.match(message.args[0]) is not None\n                ):\n                    if mod is None:\n                        # Message and category match, recorded or ignored\n                        if rec is not None:\n                            msg = WarningMessage(\n                                message, category, filename, lineno, **kwargs\n                            )\n                            self.log.append(msg)\n                            rec.append(msg)\n                        return\n                    # Use startswith, because warnings strips the c or o from\n                    # .pyc/.pyo files.\n                    elif mod.__file__.startswith(filename):\n                        # The message and module (filename) match\n                        if rec is not None:\n                            msg = WarningMessage(\n                                message, category, filename, lineno, **kwargs\n                            )\n                            self.log.append(msg)\n                            rec.append(msg)\n                        return\n\n            # There is no filter in place, so pass to the outside handler\n            # unless we should only pass it once\n            if self._forwarding_rule == ""always"":\n                if use_warnmsg is None:\n                    self._orig_show(\n                        message, category, filename, lineno, *args, **kwargs\n                    )\n                else:\n                    self._orig_showmsg(use_warnmsg)\n                return\n\n            if self._forwarding_rule == ""once"":\n                signature = (message.args, category)\n            elif self._forwarding_rule == ""module"":\n                signature = (message.args, category, filename)\n            elif self._forwarding_rule == ""location"":\n                signature = (message.args, category, filename, lineno)\n\n            if signature in self._forwarded:\n                return\n            self._forwarded.add(signature)\n            if use_warnmsg is None:\n                self._orig_show(message, category, filename, lineno, *args, **kwargs)\n            else:\n                self._orig_showmsg(use_warnmsg)\n\n        def __call__(self, func):\n            """"""\n            Function decorator to apply certain suppressions to a whole\n            function.\n            """"""\n\n            @wraps(func)\n            def new_func(*args, **kwargs):\n                with self:\n                    return func(*args, **kwargs)\n\n            return new_func\n'"
randomgen/_version.py,0,"b'# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.18 (https://github.com/warner/python-versioneer)\n\n""""""Git implementation of _version.py.""""""\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\n\n\ndef get_keywords():\n    """"""Get the keywords needed to look up the version information.""""""\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = ""$Format:%d$""\n    git_full = ""$Format:%H$""\n    git_date = ""$Format:%ci$""\n    keywords = {""refnames"": git_refnames, ""full"": git_full, ""date"": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_config():\n    """"""Create, populate and return the VersioneerConfig() object.""""""\n    # these strings are filled in when \'setup.py versioneer\' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = ""git""\n    cfg.style = ""pep440""\n    cfg.tag_prefix = """"\n    cfg.parentdir_prefix = ""randomgen-""\n    cfg.versionfile_source = ""randomgen/_version.py""\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen(\n                [c] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n            )\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %s"" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %s"" % (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %s (error)"" % dispcmd)\n            print(""stdout was %s"" % stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {\n                ""version"": dirname[len(parentdir_prefix) :],\n                ""full-revisionid"": None,\n                ""dirty"": False,\n                ""error"": None,\n                ""date"": None,\n            }\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(\n            ""Tried directories %s but none started with prefix %s""\n            % (str(rootdirs), parentdir_prefix)\n        )\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG) :] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r""\\d"", r)])\n        if verbose:\n            print(""discarding \'%s\', no digits"" % "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %s"" % "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix) :]\n            if verbose:\n                print(""picking %s"" % r)\n            return {\n                ""version"": r,\n                ""full-revisionid"": keywords[""full""].strip(),\n                ""dirty"": False,\n                ""error"": None,\n                ""date"": date,\n            }\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {\n        ""version"": ""0+unknown"",\n        ""full-revisionid"": keywords[""full""].strip(),\n        ""dirty"": False,\n        ""error"": ""no suitable tags"",\n        ""date"": None,\n    }\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root, hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %s not under git control"" % root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(\n        GITS,\n        [\n            ""describe"",\n            ""--tags"",\n            ""--dirty"",\n            ""--always"",\n            ""--long"",\n            ""--match"",\n            ""%s*"" % tag_prefix,\n        ],\n        cwd=root,\n    )\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[: git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r""^(.+)-(\\d+)-g([0-9a-f]+)$"", git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = ""unable to parse git-describe output: \'%s\'"" % describe_out\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                print(fmt % (full_tag, tag_prefix))\n            pieces[""error""] = ""tag \'%s\' doesn\'t start with prefix \'%s\'"" % (\n                full_tag,\n                tag_prefix,\n            )\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix) :]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""], cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%ci"", ""HEAD""], cwd=root)[\n        0\n    ].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%d.g%s"" % (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%d.g%s"" % (pieces[""distance""], pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%d"" % pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%d"" % pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%s"" % pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%s"" % pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {\n            ""version"": ""unknown"",\n            ""full-revisionid"": pieces.get(""long""),\n            ""dirty"": None,\n            ""error"": pieces[""error""],\n            ""date"": None,\n        }\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%s\'"" % style)\n\n    return {\n        ""version"": rendered,\n        ""full-revisionid"": pieces[""long""],\n        ""dirty"": pieces[""dirty""],\n        ""error"": None,\n        ""date"": pieces.get(""date""),\n    }\n\n\ndef get_versions():\n    """"""Get version information or return default if unable to do so.""""""\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don\'t do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for i in cfg.versionfile_source.split(""/""):\n            root = os.path.dirname(root)\n    except NameError:\n        return {\n            ""version"": ""0+unknown"",\n            ""full-revisionid"": None,\n            ""dirty"": None,\n            ""error"": ""unable to find root of source tree"",\n            ""date"": None,\n        }\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {\n        ""version"": ""0+unknown"",\n        ""full-revisionid"": None,\n        ""dirty"": None,\n        ""error"": ""unable to compute version"",\n        ""date"": None,\n    }\n'"
randomgen/seed_sequence.py,0,"b'try:\n    from numpy.random._bit_generator import (\n        SeedSequence,\n        SeedlessSeedSequence,\n        ISeedSequence,\n        ISpawnableSeedSequence,\n    )\nexcept (ImportError, AttributeError):\n    try:\n        from numpy.random.bit_generator import (\n            SeedSequence,\n            SeedlessSeedSequence,\n            ISeedSequence,\n            ISpawnableSeedSequence,\n        )\n    except (ImportError, AttributeError):\n        from randomgen._seed_sequence import (\n            SeedSequence,\n            SeedlessSeedSequence,\n            ISeedSequence,\n            ISpawnableSeedSequence,\n        )\n\n__all__ = [\n    ""SeedSequence"",\n    ""SeedlessSeedSequence"",\n    ""ISeedSequence"",\n    ""ISpawnableSeedSequence"",\n]\n'"
randomgen/xoshiro256starstar.py,0,"b'import warnings\n\nfrom randomgen.xoshiro256 import Xoshiro256\n\n\ndef Xoshiro256StarStar(*args, **kwargs):\n    """"""\n    This is a deprecation shim.  Use Xoshiro256\n    """"""\n    warnings.warn(""Xoshiro256StarStar has been renamed Xoshiro256"", DeprecationWarning)\n    return Xoshiro256(*args, **kwargs)\n'"
randomgen/xoshiro512starstar.py,0,"b'import warnings\n\nfrom randomgen.xoshiro512 import Xoshiro512\n\n\ndef Xoshiro512StarStar(*args, **kwargs):\n    """"""\n    This is a deprecation shim.  Use Xoshiro512\n    """"""\n    warnings.warn(""Xoshiro512StarStar has been renamed Xoshiro512"", DeprecationWarning)\n    return Xoshiro512(*args, **kwargs)\n'"
tools/practrand-driver.py,8,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nExample usage:\n\npython practrand-driver.py --jumped -bg ThreeFry \\\n       -n 8192 | ./RNG_test stdin64 -tlmax 512GB\n\nIt is recommended to use the patched version that increases the buffer size,\ne.g., practrand-0.93-bigbuffer.patch\n\nModified from https://gist.github.com/rkern/6cf67aee7ee4d87e1d868517ba44739c/\n\n""""""\nimport json\nimport logging\nimport sys\n\nimport numpy as np\n\nimport randomgen as rg\n\nCONFIG = {\n    rg.PCG32: {""output"": 32, ""seed"": 64, ""seed_size"": 64},\n    rg.PCG64: {""output"": 64, ""seed"": 128, ""seed_size"": 128},\n    rg.ThreeFry: {""output"": 64, ""seed"": 256, ""seed_size"": 64},\n    rg.Xoshiro256: {""output"": 64, ""seed"": 256, ""seed_size"": 64},\n    rg.Philox: {""output"": 64, ""seed"": 256, ""seed_size"": 64},\n    rg.SFMT: {""output"": 64, ""seed"": 128, ""seed_size"": 32},\n    rg.LXM: {""output"": 64, ""seed"": 128, ""seed_size"": 32},\n}\n\n\ndef gen_interleaved_bytes(bitgens, n_per_gen=1024, output=32):\n    astype = np.uint32 if output == 32 else np.uint64\n    view = np.uint64\n    while True:\n        draws = [g.random_raw(n_per_gen).astype(astype).view(view) for g in bitgens]\n        interleaved = np.column_stack(draws).ravel()\n        bytes_chunk = bytes(interleaved.data)\n        yield bytes_chunk\n\n\ndef bitgen_from_state(state):\n    cls = getattr(rg, state[""bit_generator""])\n    bitgen = cls()\n    bitgen.state = state\n    return bitgen\n\n\ndef jumped_state(bit_generator, n_streams=2, entropy=None):\n    bitgen = getattr(rg, bit_generator)\n    config = CONFIG[bitgen]\n    seed = config[""seed""]\n    if entropy is None:\n        entropy = rg.random_entropy(seed // 32)\n        if config[""seed_size""] == 64:\n            entropy = entropy.view(np.uint64)\n            if config[""seed""] == 64:\n                entropy = entropy[0]\n        elif config[""seed_size""] == 128:\n            entropy = int(entropy[0]) + int(entropy[1]) * 2 ** 64\n        elif config[""seed_size""] == 256:\n            base = int(0)\n            for i in range(4):\n                base += int(entropy[i]) * (2 ** (64 * i))\n            entropy = base\n        elif config[""seed_size""] != 32:\n            raise NotImplementedError\n    else:\n        seed_size = config[""seed_size""]\n        if seed_size in (32, 64):\n            _entropy = []\n            while entropy > 0:\n                low = entropy % 2 ** seed_size\n                _entropy.append(low)\n                entropy = entropy >> seed_size\n            dtype = np.uint32 if seed_size == 32 else np.uint64\n            entropy = np.array(_entropy, dtype=dtype)\n        elif seed_size in (128, 256):\n            entropy = entropy % 2 ** seed_size\n        else:\n            raise NotImplementedError\n\n    bg = bitgen(entropy)\n    bitgens = [bg]\n    for i in range(n_streams - 1):\n        bg = bg.jumped()\n        bitgens.append(bg)\n    return bitgens\n\n\ndef dump_states(bitgens, file=sys.stderr, disp=False):\n    def array_to_list(d):\n        for key in d:\n            if isinstance(d[key], dict):\n                d[key] = array_to_list(d[key])\n            elif isinstance(d[key], np.ndarray):\n                d[key] = d[key].tolist()\n        return d\n\n    text = json.dumps([array_to_list(g.state) for g in bitgens], indent=4)\n    if disp:\n        print(text, file=file)\n    return text\n\n\ndef from_json(filename):\n    with open(filename) as f:\n        states = json.load(f)\n\n    def list_to_array(d):\n        for key in d:\n            if isinstance(d[key], dict):\n                d[key] = list_to_array(d[key])\n            elif isinstance(d[key], list):\n                d[key] = np.array(d[key])\n        return d\n\n    bitgens = [bitgen_from_state(list_to_array(s)) for s in states]\n    return bitgens\n\n\ndef main():\n    logging.basicConfig(level=logging.INFO)\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\n    )\n    parser.add_argument(\n        ""-bg"", ""--bit_generator"", type=str, default=""PCG64"", help=""BitGenerator to use.""\n    )\n    parser.add_argument(\n        ""--load"", action=""store_true"", help=""Load BitGenerators from JSON file.""\n    )\n    parser.add_argument(\n        ""--save"", action=""store_true"", help=""Save BitGenerators to JSON file.""\n    )\n    parser.add_argument(\n        ""-j"", ""--jumped"", action=""store_true"", help=""Use jumped() to get new streams.""\n    )\n    parser.add_argument(""-s"", ""--seed"", type=int, help=""Set a single seed"")\n    parser.add_argument(\n        ""-n"",\n        ""--n-streams"",\n        type=int,\n        default=2,\n        help=""The number of streams to interleave"",\n    )\n    parser.add_argument(\n        ""-f"",\n        ""--filename"",\n        type=str,\n        default="""",\n        help=""JSON filename. Does not save if empty"",\n    )\n\n    args = parser.parse_args()\n    filename = args.filename\n    if not filename:\n        filename = args.bit_generator.lower() + "".json""\n        logging.log(logging.INFO, ""Default filename is "" + filename)\n    if args.load:\n        logging.log(logging.INFO, ""Loading bit generator config from "" + filename)\n        bitgens = from_json(filename)\n    elif args.jumped:\n        msg = ""Creating {n} bit generators of {bg_type}"".format(\n            n=args.n_streams, bg_type=args.bit_generator\n        )\n        logging.log(logging.INFO, msg)\n        bitgens = jumped_state(\n            args.bit_generator, n_streams=args.n_streams, entropy=args.seed\n        )\n    else:\n        logging.log(logging.WARN, ""You are only testing a single stream"")\n        bitgens = jumped_state(args.bit_generator, n_streams=1, entropy=args.seed)\n\n    if args.save:\n        logging.log(logging.INFO, ""Saving bit generator config to "" + filename)\n        dumped = dump_states(bitgens, disp=False)\n        with open(filename, ""w"") as out:\n            out.write(dumped)\n\n    output = CONFIG[bitgens[0].__class__][""output""]\n    logging.log(logging.INFO, ""Output bit size is {0}"".format(output))\n    for chunk in gen_interleaved_bytes(bitgens, output=output):\n        sys.stdout.buffer.write(chunk)\n\n\nif __name__ == ""__main__"":\n    try:\n        main()\n    except (BrokenPipeError, IOError):\n        logging.log(logging.INFO, ""Pipe broken, assuming complete"")\n\n    sys.stderr.close()\n'"
doc/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/stable/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\nimport sphinx_material\n\nimport randomgen\n\n# -- Project information -----------------------------------------------------\n\nproject = ""RandomGen""\ncopyright = ""2018, Kevin Sheppard""\nauthor = ""Kevin Sheppard""\n\n# The short X.Y version.\n\nversion = randomgen.__version__\nif ""+"" in version:\n    version = version.split(""+"")\n    version = """".join((version[0], "" (+"", version[1].split(""."")[0], "")""))\n# The full version, including alpha/beta/rc tags.\nrelease = randomgen.__version__\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    ""sphinx.ext.napoleon"",\n    ""sphinx.ext.autodoc"",\n    ""sphinx.ext.extlinks"",\n    ""sphinx.ext.todo"",\n    ""sphinx.ext.doctest"",\n    ""sphinx.ext.intersphinx"",\n    ""sphinx.ext.autosummary"",\n    ""sphinx.ext.mathjax"",\n    ""sphinx.ext.githubpages"",\n    ""IPython.sphinxext.ipython_console_highlighting"",\n    ""IPython.sphinxext.ipython_directive"",\n    ""sphinx_material"",\n    ""nbsphinx"",\n]\n\ntry:\n    import sphinxcontrib.spelling  # noqa: F401\nexcept ImportError as err:  # noqa: F841\n    pass\nelse:\n    extensions.append(""sphinxcontrib.spelling"")\n\nspelling_word_list_filename = [""spelling_wordlist.txt"", ""names_wordlist.txt""]\nspelling_ignore_pypi_package_names = True\n\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = "".rst""\n\n# The master toctree document.\nmaster_doc = ""index""\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = ""vs""\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\n# html_theme = \'alabaster\'\n# html_theme = \'sphinx_rtd_theme\'\n# html_theme_path = [""_themes"", ]\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\nhtml_theme_path = sphinx_material.html_theme_path()\nhtml_context = sphinx_material.get_html_context()\nhtml_theme = ""sphinx_material""\n\n# sphinx_material theme options (see theme.conf for more information)\nhtml_theme_options = {\n    ""base_url"": ""http://bashtage.github.io/randomgen/"",\n    ""repo_url"": ""https://github.com/bashtage/randomgen/"",\n    ""repo_name"": ""randomgen"",\n    # Set the name of the project to appear in the sidebar\n    ""nav_title"": project + "" "" + version,\n    ""globaltoc_depth"": 2,\n    ""globaltoc_collapse"": True,\n    ""globaltoc_includehidden"": True,\n    ""theme_color"": ""#2196f3"",\n    ""color_primary"": ""red"",\n    ""color_accent"": ""amber"",\n    ""html_minify"": True,\n    ""css_minify"": True,\n    ""master_doc"": False,\n    ""heroes"": {\n        ""index"": ""Additional bit generators and distribution for NumPy ""\n        ""1.17\'s Generator""\n    },\n    ""logo_icon"": ""casino"",\n}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\nhtml_favicon = ""_static/images/favicon.ico""\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\nhtml_show_sourcelink = True\nhtml_sidebars = {\n    ""**"": [""logo-text.html"", ""globaltoc.html"", ""localtoc.html"", ""searchbox.html""]\n}\n\n# If false, no module index is generated.\nhtml_domain_indices = True\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = ""RandomGendoc""\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        ""RandomGen.tex"",\n        ""RandomGen Documentation"",\n        ""Kevin Sheppard"",\n        ""manual"",\n    ),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, ""RandomGen"", ""RandomGen Documentation"", [author], 1)]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        ""RandomGen"",\n        ""RandomGen Documentation"",\n        author,\n        ""RandomGen"",\n        ""Alternative random number generators for Python."",\n        ""Miscellaneous"",\n    ),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\n    ""statsmodels"": (""https://www.statsmodels.org/dev/"", None),\n    ""matplotlib"": (""https://matplotlib.org"", None),\n    ""scipy"": (""https://docs.scipy.org/doc/scipy/reference/"", None),\n    ""python"": (""https://docs.python.org/3"", None),\n    ""numpy"": (""https://numpy.org/devdocs/"", None),\n    ""np"": (""https://numpy.org/devdocs/"", None),\n    ""pandas"": (""https://pandas.pydata.org/pandas-docs/stable/"", None),\n    ""pd"": (""https://pandas.pydata.org/pandas-docs/stable/"", None),\n}\n\nautosummary_generate = True\n\ndoctest_global_setup = """"""\nimport numpy as np\n\nimport randomgen\n\nimport matplotlib.pyplot\n\ndef show(*args, **kwargs):\n    return\n\nmatplotlib.pyplot.show = show\n""""""\n'"
doc/source/performance.py,4,"b'from collections import OrderedDict\nfrom timeit import repeat\n\nimport numpy as np\nimport pandas as pd\n\nfrom randomgen import (\n    DSFMT,\n    HC128,\n    JSF,\n    LXM,\n    MT64,\n    MT19937,\n    PCG64,\n    RDRAND,\n    SFMT,\n    SPECK128,\n    AESCounter,\n    ChaCha,\n    Philox,\n    ThreeFry,\n    Xoshiro256,\n    Xoshiro512,\n)\n\n\nclass ChaCha8(ChaCha):\n    def __init__(self, *args, **kwargs):\n        if ""rounds"" in kwargs:\n            del kwargs[""rounds""]\n        super().__init__(*args, rounds=8, **kwargs)\n\n\nclass JSF32(JSF):\n    def __init__(self, *args, **kwargs):\n        if ""size"" in kwargs:\n            del kwargs[""size""]\n        super().__init__(*args, size=32, **kwargs)\n\n\nclass Philox4x32(Philox):\n    def __init__(self, *args, **kwargs):\n        if ""width"" in kwargs:\n            del kwargs[""width""]\n        super().__init__(*args, width=32, **kwargs)\n\n\nclass Philox2x64(Philox):\n    def __init__(self, *args, **kwargs):\n        if ""number"" in kwargs:\n            del kwargs[""number""]\n        super().__init__(*args, number=2, **kwargs)\n\n\nclass ThreeFry4x32(ThreeFry):\n    def __init__(self, *args, **kwargs):\n        if ""width"" in kwargs:\n            del kwargs[""width""]\n        super().__init__(*args, width=32, **kwargs)\n\n\nclass ThreeFry2x64(ThreeFry):\n    def __init__(self, *args, **kwargs):\n        if ""number"" in kwargs:\n            del kwargs[""number""]\n        super().__init__(*args, number=2, **kwargs)\n\n\nclass PCG64DXSM(PCG64):\n    def __init__(self, *args, **kwargs):\n        if ""variant"" in kwargs:\n            del kwargs[""variant""]\n        super().__init__(*args, variant=""dxsm"", **kwargs)\n\n\nclass PCG64CMDXSM(PCG64):\n    def __init__(self, *args, **kwargs):\n        if ""variant"" in kwargs:\n            del kwargs[""variant""]\n        super().__init__(*args, variant=""cm-dxsm"", **kwargs)\n\n\ntry:\n    RDRAND()\n    HAS_RDRND = True\nexcept RuntimeError:\n    HAS_RDRND = False\n\nNUMBER = 100\nREPEAT = 10\nSIZE = 25000\nPRNGS = [\n    ChaCha8,\n    JSF32,\n    Philox4x32,\n    ThreeFry2x64,\n    ThreeFry4x32,\n    Philox2x64,\n    DSFMT,\n    MT64,\n    MT19937,\n    PCG64,\n    PCG64DXSM,\n    PCG64CMDXSM,\n    LXM,\n    SFMT,\n    AESCounter,\n    ChaCha,\n    Philox,\n    ThreeFry,\n    Xoshiro256,\n    Xoshiro512,\n    JSF,\n    HC128,\n    SPECK128,\n]\n\nif HAS_RDRND:\n    PRNGS.append(RDRAND)\n\n\nfuncs = OrderedDict()\nfuncs[""Uint32""] = f\'integers(2**32, dtype=""uint32"", size={SIZE})\'\nfuncs[""Uint64""] = f\'integers(2**64, dtype=""uint64"", size={SIZE})\'\nfuncs[""Uniform""] = f""random(size={SIZE})""\nfuncs[""Expon""] = f""standard_exponential(size={SIZE})""\nfuncs[""Normal""] = f""standard_normal(size={SIZE})""\nfuncs[""Gamma""] = f""standard_gamma(3.0,size={SIZE})""\n\nsetup = """"""\nfrom numpy.random import Generator\nrg = Generator({prng}())\n""""""\n\ntest = ""rg.{func}""\ntable = OrderedDict()\nfor prng in PRNGS:\n    print(prng.__name__)\n    print(""-"" * 40)\n    col = OrderedDict()\n    for key in funcs:\n        print(key)\n        t = repeat(\n            test.format(func=funcs[key]),\n            setup.format(prng=prng().__class__.__name__),\n            number=NUMBER,\n            repeat=REPEAT,\n            globals=globals(),\n        )\n        col[key] = 1000 * min(t)\n    print(""\\n"" * 2)\n    col = pd.Series(col)\n    table[prng().__class__.__name__] = col\n\nnpfuncs = OrderedDict()\nnpfuncs.update(funcs)\nnpfuncs[""Uniform""] = f""random_sample(size={SIZE})""\nnpfuncs[""Uint64""] = f\'randint(2**64, dtype=""uint64"", size={SIZE})\'\nnpfuncs[""Uint32""] = f\'randint(2**32, dtype=""uint32"", size={SIZE})\'\n\n\nsetup = """"""\nfrom numpy.random import RandomState\nrg = RandomState()\n""""""\ncol = {}\nfor key in npfuncs:\n    t = repeat(\n        test.format(func=npfuncs[key]),\n        setup.format(prng=prng().__class__.__name__),\n        number=NUMBER,\n        repeat=REPEAT,\n    )\n    col[key] = 1000 * min(t)\ntable[""NumPy""] = pd.Series(col)\nfinal = table\n\nfunc_list = list(funcs.keys())\ntable = pd.DataFrame(final)\ntable = table.reindex(table.mean(1).sort_values().index)\norder = np.log(table).mean().sort_values().index\ntable = table.T\ntable = table.reindex(order, axis=0)\ntable = table.reindex(func_list, axis=1)\ntable = 1000000 * table / (SIZE * NUMBER)\ntable.index.name = ""Bit Gen""\nprint(table.to_csv(float_format=""%0.1f""))\n\ntry:\n    from tabulate import tabulate\n\n    perf = table.applymap(lambda v: ""{0:0.1f}"".format(v))\n    print(tabulate(perf, headers=""keys"", tablefmt=""rst""))\nexcept ImportError:\n    pass\n\ntable = table.T\nrel = table.loc[:, [""NumPy""]].values @ np.ones((1, table.shape[1])) / table\nrel.pop(""NumPy"")\nrel = rel.T\nrel[""Overall""] = np.exp(np.log(rel).mean(1))\nrel *= 100\nrel = np.round(rel).astype(np.int)\nrel.index.name = ""Bit Gen""\nprint(rel.to_csv(float_format=""%0d""))\n\ntry:\n    from tabulate import tabulate\n\n    rel_perf = rel.applymap(lambda v: ""{0:d}"".format(v))\n    print(tabulate(rel_perf, headers=""keys"", tablefmt=""rst""))\nexcept ImportError:\n    pass\n'"
randomgen/legacy/__init__.py,0,"b'from randomgen.mtrand import RandomState as LegacyGenerator\n\n__all__ = [""LegacyGenerator""]\n'"
randomgen/tests/__init__.py,0,b''
randomgen/tests/test_against_numpy.py,44,"b'from distutils.version import LooseVersion\n\nimport numpy as np\nimport numpy.random\nfrom numpy.testing import assert_allclose, assert_array_equal, assert_equal\nimport pytest\n\nimport randomgen\nfrom randomgen import MT19937, Generator\nfrom randomgen._testing import suppress_warnings\nimport randomgen.generator\nfrom randomgen.mtrand import RandomState\n\nNP_VERSION = LooseVersion(np.__version__)\nNP_118 = LooseVersion(""1.18"") <= NP_VERSION < LooseVersion(""1.19"")\n\n\ndef compare_0_input(f1, f2):\n    inputs = [\n        (tuple([]), {}),\n        (tuple([]), {""size"": 10}),\n        (tuple([]), {""size"": (20, 31)}),\n        (tuple([]), {""size"": (20, 31, 5)}),\n    ]\n\n    for i in inputs:\n        v1 = f1(*i[0], **i[1])\n        v2 = f2(*i[0], **i[1])\n        assert_allclose(v1, v2)\n\n\ndef compare_1_input(f1, f2, is_small=False):\n    a = 0.3 if is_small else 10\n    inputs = [\n        ((a,), {}),\n        ((a,), {""size"": 10}),\n        ((np.array([a] * 10),), {}),\n        ((np.array([a] * 10),), {""size"": 10}),\n        ((np.array([a] * 10),), {""size"": (100, 10)}),\n    ]\n    for i in inputs:\n        v1 = f1(*i[0], **i[1])\n        v2 = f2(*i[0], **i[1])\n        assert_allclose(v1, v2)\n\n\ndef compare_2_input(f1, f2, is_np=False, is_scalar=False):\n    if is_np:\n        a, b = 10, 0.3\n        dtype = np.int\n    else:\n        a, b = 2, 3\n        dtype = np.double\n    inputs = [\n        ((a, b), {}),\n        ((a, b), {""size"": 10}),\n        ((a, b), {""size"": (23, 7)}),\n        ((np.array([a] * 10), b), {}),\n        ((a, np.array([b] * 10)), {}),\n        ((a, np.array([b] * 10)), {""size"": 10}),\n        (\n            (np.reshape(np.array([[a] * 100]), (100, 1)), np.array([b] * 10)),\n            {""size"": (100, 10)},\n        ),\n        ((np.ones((7, 31), dtype=dtype) * a, np.array([b] * 31)), {""size"": (7, 31)}),\n        (\n            (np.ones((7, 31), dtype=dtype) * a, np.array([b] * 31)),\n            {""size"": (10, 7, 31)},\n        ),\n    ]\n\n    if is_scalar:\n        inputs = inputs[:3]\n\n    for i in inputs:\n        v1 = f1(*i[0], **i[1])\n        v2 = f2(*i[0], **i[1])\n        assert_allclose(v1, v2)\n\n\ndef compare_3_input(f1, f2, is_np=False):\n    a, b, c = 10, 20, 25\n    inputs = [\n        ((a, b, c), {}),\n        ((a, b, c), {""size"": 10}),\n        ((a, b, c), {""size"": (23, 7)}),\n        ((np.array([a] * 10), b, c), {}),\n        ((a, np.array([b] * 10), c), {}),\n        ((a, b, np.array([c] * 10)), {}),\n        ((a, np.array([b] * 10), np.array([c] * 10)), {}),\n        ((a, np.array([b] * 10), c), {""size"": 10}),\n        (\n            (\n                np.ones((1, 37), dtype=np.int) * a,\n                np.ones((23, 1), dtype=np.int) * [b],\n                c * np.ones((7, 1, 1), dtype=np.int),\n            ),\n            {},\n        ),\n        (\n            (\n                np.ones((1, 37), dtype=np.int) * a,\n                np.ones((23, 1), dtype=np.int) * [b],\n                c * np.ones((7, 1, 1), dtype=np.int),\n            ),\n            {""size"": (7, 23, 37)},\n        ),\n    ]\n\n    for i in inputs:\n        v1 = f1(*i[0], **i[1])\n        v2 = f2(*i[0], **i[1])\n        assert_allclose(v1, v2)\n\n\nclass TestAgainstNumPy(object):\n    @classmethod\n    def setup_class(cls):\n        cls.np = numpy.random\n        cls.bit_generator = MT19937\n        cls.seed = [2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.rs = RandomState(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.nprs = cls.np.RandomState(*cls.seed)\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._set_common_state()\n\n    @classmethod\n    def _set_common_state(cls):\n        state = cls.rg.bit_generator.state\n        st = [[]] * 5\n        st[0] = ""MT19937""\n        st[1] = state[""state""][""key""]\n        st[2] = state[""state""][""pos""]\n        st[3] = 0\n        st[4] = 0.0\n        cls.nprs.set_state(st)\n\n    @classmethod\n    def _set_common_state_legacy(cls):\n        state = cls.rs.get_state(legacy=False)\n        st = [[]] * 5\n        st[0] = ""MT19937""\n        st[1] = state[""state""][""key""]\n        st[2] = state[""state""][""pos""]\n        st[3] = state[""has_gauss""]\n        st[4] = state[""gauss""]\n        cls.nprs.set_state(st)\n\n    def _is_state_common(self):\n        state = self.nprs.get_state()\n        state2 = self.rg.bit_generator.state\n        assert (state[1] == state2[""state""][""key""]).all()\n        assert state[2] == state2[""state""][""pos""]\n\n    def _is_state_common_legacy(self):\n        state = self.nprs.get_state()\n        state2 = self.rs.get_state(legacy=False)\n        assert (state[1] == state2[""state""][""key""]).all()\n        assert state[2] == state2[""state""][""pos""]\n        assert state[3] == state2[""has_gauss""]\n        assert_allclose(state[4], state2[""gauss""], atol=1e-10)\n\n    def test_common_seed(self):\n        self.rg.bit_generator.seed(1234)\n        self.nprs.seed(1234)\n        self._is_state_common()\n        self.rg.bit_generator.seed(23456)\n        self.nprs.seed(23456)\n        self._is_state_common()\n\n    def test_numpy_state(self):\n        nprs = np.random.RandomState()\n        nprs.standard_normal(99)\n        state = nprs.get_state()\n        self.rg.bit_generator.state = state\n        state2 = self.rg.bit_generator.state\n        assert (state[1] == state2[""state""][""key""]).all()\n        assert state[2] == state2[""state""][""pos""]\n\n    def test_random(self):\n        self._set_common_state()\n        self._is_state_common()\n        v1 = self.nprs.random_sample(10)\n        v2 = self.rg.random(10)\n\n        assert_array_equal(v1, v2)\n\n    def test_standard_normal(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_0_input(self.nprs.standard_normal, self.rs.standard_normal)\n        self._is_state_common_legacy()\n\n    def test_standard_cauchy(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_0_input(self.nprs.standard_cauchy, self.rs.standard_cauchy)\n        self._is_state_common_legacy()\n\n    def test_standard_exponential(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_0_input(self.nprs.standard_exponential, self.rs.standard_exponential)\n        self._is_state_common_legacy()\n\n    @pytest.mark.xfail(reason=""Stream broken for simplicity"", strict=True)\n    def test_tomaxint(self):\n        self._set_common_state()\n        self._is_state_common()\n        with pytest.deprecated_call():\n            compare_0_input(self.nprs.tomaxint, self.rg.tomaxint)\n        self._is_state_common()\n\n    def test_poisson(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_1_input(self.nprs.poisson, self.rg.poisson)\n        self._is_state_common()\n\n    def test_rayleigh(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_1_input(self.nprs.rayleigh, self.rg.rayleigh)\n        self._is_state_common()\n\n    def test_zipf(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_1_input(self.nprs.zipf, self.rg.zipf)\n        self._is_state_common()\n\n    def test_logseries(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_1_input(self.nprs.logseries, self.rg.logseries, is_small=True)\n        self._is_state_common()\n\n    def test_geometric(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_1_input(self.nprs.geometric, self.rg.geometric, is_small=True)\n        self._is_state_common()\n\n    def test_logistic(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.logistic, self.rg.logistic)\n        self._is_state_common()\n\n    def test_gumbel(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.gumbel, self.rg.gumbel)\n        self._is_state_common()\n\n    def test_laplace(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.laplace, self.rg.laplace)\n        self._is_state_common()\n\n    def test_uniform(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.uniform, self.rg.uniform)\n        self._is_state_common()\n\n    def test_vonmises(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.vonmises, self.rg.vonmises)\n        self._is_state_common()\n\n    def test_random_integers(self):\n        self._set_common_state()\n        self._is_state_common()\n        with suppress_warnings() as sup:\n            sup.record(DeprecationWarning)\n            compare_2_input(\n                self.nprs.random_integers, self.rg.random_integers, is_scalar=True\n            )\n        self._is_state_common()\n\n    def test_binomial(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.nprs.binomial, self.rg.binomial, is_np=True)\n        self._is_state_common()\n\n    def test_rand(self):\n        self._set_common_state()\n        self._is_state_common()\n        f = self.rg.rand\n        g = self.nprs.rand\n        with pytest.deprecated_call():\n            assert_allclose(f(10), g(10))\n        with pytest.deprecated_call():\n            assert_allclose(f(3, 4, 5), g(3, 4, 5))\n\n    @pytest.mark.xfail(reason=""poisson_lam_max changed"", strict=True)\n    def test_poisson_lam_max(self):\n        assert_allclose(self.rg.poisson_lam_max, self.nprs.poisson_lam_max)\n\n    def test_triangular(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_3_input(self.nprs.triangular, self.rg.triangular)\n        self._is_state_common()\n\n    @pytest.mark.xfail(reason=""Changes to hypergeometic"", strict=True)\n    def test_hypergeometric(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_3_input(self.nprs.hypergeometric, self.rg.hypergeometric)\n        self._is_state_common()\n\n    def test_bytes(self):\n        self._set_common_state()\n        self._is_state_common()\n        assert_equal(self.rg.bytes(8), self.nprs.bytes(8))\n        self._is_state_common()\n        assert_equal(self.rg.bytes(103), self.nprs.bytes(103))\n        self._is_state_common()\n        assert_equal(self.rg.bytes(8), self.nprs.bytes(8))\n        self._is_state_common()\n\n    def test_multinomial(self):\n        self._set_common_state()\n        self._is_state_common()\n        f = self.rg.multinomial\n        g = self.nprs.multinomial\n        p = [0.1, 0.3, 0.4, 0.2]\n        assert_equal(f(100, p), g(100, p))\n        assert_equal(f(100, np.array(p)), g(100, np.array(p)))\n        assert_equal(\n            f(100, np.array(p), size=(7, 23)), g(100, np.array(p), size=(7, 23))\n        )\n        self._is_state_common()\n\n    @pytest.mark.xfail(reason=""Stream broken for performance"", strict=True)\n    def test_choice(self):\n        self._set_common_state()\n        self._is_state_common()\n        f = self.rg.choice\n        g = self.nprs.choice\n        a = np.arange(100)\n        size = 25\n        for replace in (True, False):\n            assert_equal(f(a, size, replace), g(a, size, replace))\n            assert_equal(f(100, size, replace), g(100, size, replace))\n        self._is_state_common()\n\n    def test_permutation(self):\n        self._set_common_state()\n        self._is_state_common()\n        f = self.rg.permutation\n        g = self.nprs.permutation\n        a = np.arange(100)\n        assert_equal(f(a), g(a))\n        assert_equal(f(23), g(23))\n        self._is_state_common()\n\n    def test_shuffle(self):\n        self._set_common_state()\n        self._is_state_common()\n        f = self.rg.shuffle\n        g = self.nprs.shuffle\n        a = np.arange(100)\n        fa = a.copy()\n        ga = a.copy()\n        g(ga)\n        f(fa)\n        assert_equal(fa, ga)\n        self._is_state_common()\n\n    def test_randint(self):\n        self._set_common_state()\n        self._is_state_common()\n        compare_2_input(self.rg.integers, self.nprs.randint, is_scalar=True)\n        self._is_state_common()\n\n    def test_scalar(self):\n        s = Generator(MT19937(0, mode=""legacy""))\n        assert_equal(s.integers(1000), 684)\n        s1 = np.random.RandomState(0)\n        assert_equal(s1.randint(1000), 684)\n        assert_equal(s1.randint(1000), s.integers(1000))\n\n        s = Generator(MT19937(4294967295, mode=""legacy""))\n        assert_equal(s.integers(1000), 419)\n        s1 = np.random.RandomState(4294967295)\n        assert_equal(s1.randint(1000), 419)\n        assert_equal(s1.randint(1000), s.integers(1000))\n\n        self.rg.bit_generator.seed(4294967295)\n        self.nprs.seed(4294967295)\n        self._is_state_common()\n\n    def test_array(self):\n        s = Generator(MT19937(range(10), mode=""legacy""))\n        assert_equal(s.integers(1000), 468)\n        s = np.random.RandomState(range(10))\n        assert_equal(s.randint(1000), 468)\n\n        s = Generator(MT19937(np.arange(10), mode=""legacy""))\n        assert_equal(s.integers(1000), 468)\n        s = Generator(MT19937([0], mode=""legacy""))\n        assert_equal(s.integers(1000), 973)\n        s = Generator(MT19937([4294967295], mode=""legacy""))\n        assert_equal(s.integers(1000), 265)\n\n    @pytest.mark.skipif(not NP_118, reason=""Only value for NumPy 1.18"")\n    def test_dir(self):\n        nprs_d = set(dir(self.nprs))\n        rs_d = dir(self.rg)\n        excluded = {""get_state"", ""set_state"", ""poisson_lam_max""}\n        nprs_d.difference_update(excluded)\n        assert len(nprs_d.difference(rs_d)) == 0\n\n        npmod = dir(numpy.random)\n        mod = dir(randomgen.generator)\n        known_exlcuded = [\n            ""BitGenerator"",\n            ""MT19937"",\n            ""PCG64"",\n            ""Philox"",\n            ""RandomState"",\n            ""SFC64"",\n            ""SeedSequence"",\n            ""__RandomState_ctor"",\n            ""__cached__"",\n            ""__path__"",\n            ""_bit_generator"",\n            ""_bounded_integers"",\n            ""_common"",\n            ""_generator"",\n            ""_mt19937"",\n            ""_pcg64"",\n            ""_philox"",\n            ""_pickle"",\n            ""_sfc64"",\n            ""absolute_import"",\n            ""default_rng"",\n            ""division"",\n            ""get_state"",\n            ""mtrand"",\n            ""print_function"",\n            ""ranf"",\n            ""sample"",\n            ""seed"",\n            ""set_state"",\n            ""test"",\n        ]\n        mod += known_exlcuded\n        diff = set(npmod).difference(mod)\n        assert_equal(len(diff), 0)\n\n    # Tests using legacy generator\n    def test_chisquare(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.chisquare, self.rs.chisquare)\n        self._is_state_common_legacy()\n\n    def test_standard_gamma(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.standard_gamma, self.rs.standard_gamma)\n        self._is_state_common_legacy()\n\n    def test_standard_t(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.standard_t, self.rs.standard_t)\n        self._is_state_common_legacy()\n\n    def test_pareto(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.pareto, self.rs.pareto)\n        self._is_state_common_legacy()\n\n    def test_power(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.power, self.rs.power)\n        self._is_state_common_legacy()\n\n    def test_weibull(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.weibull, self.rs.weibull)\n        self._is_state_common_legacy()\n\n    def test_beta(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.beta, self.rs.beta)\n        self._is_state_common_legacy()\n\n    def test_exponential(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_1_input(self.nprs.exponential, self.rs.exponential)\n        self._is_state_common_legacy()\n\n    def test_f(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.f, self.rs.f)\n        self._is_state_common_legacy()\n\n    def test_gamma(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.gamma, self.rs.gamma)\n        self._is_state_common_legacy()\n\n    def test_lognormal(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.lognormal, self.rs.lognormal)\n        self._is_state_common_legacy()\n\n    def test_noncentral_chisquare(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.noncentral_chisquare, self.rs.noncentral_chisquare)\n        self._is_state_common_legacy()\n\n    def test_normal(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.normal, self.rs.normal)\n        self._is_state_common_legacy()\n\n    def test_wald(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(self.nprs.wald, self.rs.wald)\n        self._is_state_common_legacy()\n\n    def test_negative_binomial(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_2_input(\n            self.nprs.negative_binomial, self.rs.negative_binomial, is_np=True\n        )\n        self._is_state_common_legacy()\n\n    def test_randn(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        f = self.rs.randn\n        g = self.nprs.randn\n        assert_allclose(f(10), g(10))\n        assert_allclose(f(3, 4, 5), g(3, 4, 5))\n        self._is_state_common_legacy()\n\n    def test_dirichlet(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        f = self.rs.dirichlet\n        g = self.nprs.dirichlet\n        a = [3, 4, 5, 6, 7, 10]\n        assert_allclose(f(a), g(a))\n        assert_allclose(f(np.array(a), 10), g(np.array(a), 10))\n        assert_allclose(f(np.array(a), (3, 37)), g(np.array(a), (3, 37)))\n        self._is_state_common_legacy()\n\n    def test_noncentral_f(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        compare_3_input(self.nprs.noncentral_f, self.rs.noncentral_f)\n        self._is_state_common_legacy()\n\n    def test_multivariate_normal(self):\n        self._set_common_state_legacy()\n        self._is_state_common_legacy()\n        mu = [1, 2, 3]\n        cov = [[1, 0.2, 0.3], [0.2, 4, 1], [0.3, 1, 10]]\n        f = self.rs.multivariate_normal\n        g = self.nprs.multivariate_normal\n        assert_allclose(f(mu, cov), g(mu, cov))\n        assert_allclose(f(np.array(mu), cov), g(np.array(mu), cov))\n        assert_allclose(f(np.array(mu), np.array(cov)), g(np.array(mu), np.array(cov)))\n        assert_allclose(\n            f(np.array(mu), np.array(cov), size=(7, 31)),\n            g(np.array(mu), np.array(cov), size=(7, 31)),\n        )\n        self._is_state_common_legacy()\n\n\nfuncs = [\n    randomgen.generator.zipf,\n    randomgen.generator.logseries,\n    randomgen.generator.poisson,\n]\nids = [f.__name__ for f in funcs]\n\n\n@pytest.mark.filterwarnings(""ignore:invalid value encountered:RuntimeWarning"")\n@pytest.mark.parametrize(""func"", funcs, ids=ids)\ndef test_nan_guard(func):\n    with pytest.raises(ValueError):\n        func([np.nan])\n    with pytest.raises(ValueError):\n        func(np.nan)\n\n\ndef test_cons_gte1_nan_guard():\n    with pytest.raises(ValueError):\n        randomgen.generator.hypergeometric(10, 10, [np.nan])\n    with pytest.raises(ValueError):\n        randomgen.generator.hypergeometric(10, 10, np.nan)\n'"
randomgen/tests/test_common.py,32,"b'import numpy as np\nimport pytest\n\nfrom randomgen.entropy import seed_by_array\nfrom randomgen.tests._shims import (\n    byteswap_little_endian_shim,\n    int_to_array_shim,\n    view_little_endian_shim,\n)\n\n\ndef test_view_little_endian():\n    a = np.uint64([2 ** 63])\n    b = view_little_endian_shim(a, np.uint32)\n    expected = np.array([0, 2147483648], dtype=np.uint32)\n    np.testing.assert_equal(b, expected)\n\n    c = view_little_endian_shim(b, np.uint64)\n    np.testing.assert_equal(c, a)\n\n\ndef test_view_little_endian_err():\n    a = np.double([2 ** 51])\n    with pytest.raises(ValueError):\n        view_little_endian_shim(a, np.uint32)\n    a = np.uint64([2 ** 63])\n    with pytest.raises(ValueError):\n        view_little_endian_shim(a, np.uint16)\n    a = np.array([[2 ** 63]], np.uint64)\n    with pytest.raises(ValueError):\n        view_little_endian_shim(a, np.uint32)\n\n\ndef test_int_to_array():\n    seed = 3735928495\n    result = int_to_array_shim(seed, ""seed"", None, 64)\n    expected = np.array([3735928495], dtype=np.uint64)\n    np.testing.assert_equal(result, expected)\n\n    seed = 0\n    for pow in (255, 129, 93, 65, 63, 33, 1, 0):\n        seed += 2 ** pow\n    result = int_to_array_shim(seed, ""seed"", None, 64)\n    expected = np.array(\n        [9223372045444710403, 536870914, 2, 9223372036854775808], dtype=np.uint64\n    )\n    np.testing.assert_equal(result, expected)\n    result = int_to_array_shim(seed, ""seed"", None, 32)\n    expected = np.array(\n        [3, 2147483650, 536870914, 0, 2, 0, 0, 2147483648], dtype=np.uint32\n    )\n    np.testing.assert_equal(result, expected)\n\n\ndef test_seed_array():\n    seed_arr = np.array([3735928495], dtype=np.uint64)\n    result = seed_by_array(seed_arr, 2)\n    expected = np.array([4555448849277713929, 5170625396769938207], dtype=np.uint64)\n    np.testing.assert_equal(result, expected)\n\n    seed_arr = np.array(\n        [9223372045444710403, 536870914, 2, 9223372036854775808], dtype=np.uint64\n    )\n    result = seed_by_array(seed_arr, 4)\n    expected = np.array(\n        [\n            7178927994527075522,\n            9215441430954639631,\n            7276951224970988593,\n            1810038055801910983,\n        ],\n        dtype=np.uint64,\n    )\n    np.testing.assert_equal(result, expected)\n\n\ndef test_byteswap_little_endian():\n    a = np.array([9241421688590303745], dtype=np.uint64)\n    result = byteswap_little_endian_shim(a).view(np.uint8)\n    expected = np.array([1, 2, 4, 8, 16, 32, 64, 128], dtype=np.uint8)\n    np.testing.assert_equal(result, expected)\n'"
randomgen/tests/test_direct.py,165,"b'from functools import partial\nimport os\nfrom os.path import join\n\nimport numpy as np\nfrom numpy.testing import (\n    assert_allclose,\n    assert_array_equal,\n    assert_equal,\n    assert_raises,\n)\nimport pytest\n\nfrom randomgen import (\n    DSFMT,\n    HC128,\n    JSF,\n    LXM,\n    MT64,\n    MT19937,\n    PCG32,\n    PCG64,\n    RDRAND,\n    SFMT,\n    SPECK128,\n    AESCounter,\n    ChaCha,\n    Generator,\n    Philox,\n    RandomState,\n    ThreeFry,\n    Xoroshiro128,\n    Xorshift1024,\n    Xoshiro256,\n    Xoshiro512,\n)\nfrom randomgen.common import interface\nfrom randomgen.seed_sequence import ISeedSequence\n\ntry:\n    from numpy.random import SeedSequence\n\n    NP_SEED_SEQ = True\nexcept ImportError:\n    from randomgen import SeedSequence\n\n    NP_SEED_SEQ = False\n\nMISSING_RDRAND = False\ntry:\n    RDRAND()\nexcept RuntimeError:\n    MISSING_RDRAND = True\n\nHAS_AESNI = False\naes = AESCounter(mode=""sequence"")\nHAS_AESNI = aes.use_aesni\n\nUSE_AESNI = [True, False] if HAS_AESNI else [False]\n\ntry:\n    import cffi  # noqa: F401\n\n    MISSING_CFFI = False\nexcept ImportError:\n    MISSING_CFFI = True\n\ntry:\n    import ctypes  # noqa: F401\n\n    MISSING_CTYPES = False\nexcept ImportError:\n    MISSING_CTYPES = False\n\nISEED_SEQUENCES = (ISeedSequence,)\n# NumPy 1.17\ntry:\n    ISEED_SEQUENCES += (np.random.bit_generator.ISeedSequence,)\nexcept AttributeError:\n    pass\n# NumPy 1.18\ntry:\n    ISEED_SEQUENCES += (np.random._bit_generator.ISeedSequence,)\nexcept AttributeError:\n    pass\n\npwd = os.path.dirname(os.path.abspath(__file__))\n\n\n@pytest.fixture(scope=""module"", params=(True, False))\ndef counter_only(request):\n    return request.param\n\n\n@pytest.fixture(scope=""module"", params=(0, 19813))\ndef warmup(request):\n    return request.param\n\n\n@pytest.fixture(scope=""module"", params=(0, 1, 2, 3, 4, 5, 7, 8, 9, 34159))\ndef step(request):\n    return request.param\n\n\ndef assert_state_equal(actual, target):\n    for key in actual:\n        if isinstance(actual[key], dict):\n            assert_state_equal(actual[key], target[key])\n        elif isinstance(actual[key], np.ndarray):\n            assert_array_equal(actual[key], target[key])\n        else:\n            assert actual[key] == target[key]\n\n\ndef uniform32_from_uint64(x):\n    x = np.uint64(x)\n    upper = np.array(x >> np.uint64(32), dtype=np.uint32)\n    lower = np.uint64(0xFFFFFFFF)\n    lower = np.array(x & lower, dtype=np.uint32)\n    joined = np.column_stack([lower, upper]).ravel()\n    out = (joined >> np.uint32(9)) * (1.0 / 2 ** 23)\n    return out.astype(np.float32)\n\n\ndef uniform32_from_uint53(x):\n    x = np.uint64(x) >> np.uint64(16)\n    x = np.uint32(x & np.uint64(0xFFFFFFFF))\n    out = (x >> np.uint32(9)) * (1.0 / 2 ** 23)\n    return out.astype(np.float32)\n\n\ndef uniform32_from_uint32(x):\n    return (x >> np.uint32(9)) * (1.0 / 2 ** 23)\n\n\ndef uniform32_from_uint(x, bits):\n    if bits == 64:\n        return uniform32_from_uint64(x)\n    elif bits == 53:\n        return uniform32_from_uint53(x)\n    elif bits == 32:\n        return uniform32_from_uint32(x)\n    else:\n        raise NotImplementedError\n\n\ndef uniform_from_uint(x, bits):\n    if bits in (64, 63, 53):\n        return uniform_from_uint64(x)\n    elif bits == 32:\n        return uniform_from_uint32(x)\n\n\ndef uniform_from_uint64(x):\n    return (x >> np.uint64(11)) * (1.0 / 9007199254740992.0)\n\n\ndef uniform_from_uint32(x):\n    out = np.empty(len(x) // 2)\n    for i in range(0, len(x), 2):\n        a = x[i] >> 5\n        b = x[i + 1] >> 6\n        out[i // 2] = (a * 67108864.0 + b) / 9007199254740992.0\n    return out\n\n\ndef uniform_from_dsfmt(x):\n    return x.view(np.double) - 1.0\n\n\ndef gauss_from_uint(x, n, bits):\n    if bits in (64, 63):\n        doubles = uniform_from_uint64(x)\n    elif bits == 32:\n        doubles = uniform_from_uint32(x)\n    elif bits == ""dsfmt"":\n        doubles = uniform_from_dsfmt(x)\n    gauss = []\n    loc = 0\n    x1 = x2 = 0.0\n    while len(gauss) < n:\n        r2 = 2\n        while r2 >= 1.0 or r2 == 0.0:\n            x1 = 2.0 * doubles[loc] - 1.0\n            x2 = 2.0 * doubles[loc + 1] - 1.0\n            r2 = x1 * x1 + x2 * x2\n            loc += 2\n\n        f = np.sqrt(-2.0 * np.log(r2) / r2)\n        gauss.append(f * x2)\n        gauss.append(f * x1)\n\n    return gauss[:n]\n\n\nclass Base(object):\n    dtype = np.uint64\n    data2 = data1 = {}\n\n    @classmethod\n    def setup_class(cls):\n        cls.bit_generator = Xoroshiro128\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = []\n        cls.seed_sequence_only = False\n\n    @classmethod\n    def _read_csv(cls, filename):\n        with open(filename) as csv:\n            seed = csv.readline()\n            seed = seed.split("","")\n            seed = [int(s.strip(), 0) for s in seed[1:]]\n            data = []\n            for line in csv:\n                data.append(int(line.split("","")[-1].strip(), 0))\n            return {""seed"": seed, ""data"": np.array(data, dtype=cls.dtype)}\n\n    def setup_bitgenerator(self, seed, mode=""legacy""):\n        return self.bit_generator(*seed, mode=mode)\n\n    def test_default(self):\n        bg = self.setup_bitgenerator([None])\n        val = bg.random_raw()\n        assert isinstance(val, int)\n        assert self.seed_sequence_only or bg.seed_seq is None\n\n    def test_default_sequence(self):\n        bg = self.setup_bitgenerator([None], mode=""sequence"")\n        val = bg.random_raw()\n        assert isinstance(val, int)\n        assert isinstance(bg.seed_seq, ISEED_SEQUENCES)\n\n    def test_raw(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        uints = bit_generator.random_raw(1000)\n        assert_equal(uints, self.data1[""data""])\n\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        uints = bit_generator.random_raw()\n        assert_equal(uints, self.data1[""data""][0])\n\n        bit_generator = self.setup_bitgenerator(self.data2[""seed""])\n        uints = bit_generator.random_raw(1000)\n        assert_equal(uints, self.data2[""data""])\n\n    def test_random_raw(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        uints = bit_generator.random_raw(output=False)\n        assert uints is None\n        uints = bit_generator.random_raw(1000, output=False)\n        assert uints is None\n\n    def test_gauss_inv(self):\n        n = 25\n        rs = RandomState(self.setup_bitgenerator(self.data1[""seed""]))\n        gauss = rs.standard_normal(n)\n        bits = getattr(self, ""bit_name"", self.bits)\n        assert_allclose(gauss, gauss_from_uint(self.data1[""data""], n, bits), rtol=3e-6)\n\n        rs = RandomState(self.setup_bitgenerator(self.data2[""seed""]))\n        gauss = rs.standard_normal(25)\n        assert_allclose(gauss, gauss_from_uint(self.data2[""data""], n, bits), rtol=3e-6)\n\n    def test_uniform_double(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        bits = getattr(self, ""bit_name"", self.bits)\n        vals = uniform_from_uint(self.data1[""data""], bits)\n        uniforms = rs.random(len(vals))\n        assert_allclose(uniforms, vals, atol=1e-8)\n        assert_equal(uniforms.dtype, np.float64)\n\n        rs = Generator(self.setup_bitgenerator(self.data2[""seed""]))\n        vals = uniform_from_uint(self.data2[""data""], bits)\n        uniforms = rs.random(len(vals))\n        assert_allclose(uniforms, vals, atol=1e-8)\n        assert_equal(uniforms.dtype, np.float64)\n\n    def test_uniform_float(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        vals = uniform32_from_uint(self.data1[""data""], self.bits)\n        uniforms = rs.random(len(vals), dtype=np.float32)\n        assert_allclose(uniforms, vals)\n        assert_equal(uniforms.dtype, np.float32)\n\n        rs = Generator(self.setup_bitgenerator(self.data2[""seed""]))\n        vals = uniform32_from_uint(self.data2[""data""], self.bits)\n        uniforms = rs.random(len(vals), dtype=np.float32)\n        assert_allclose(uniforms, vals)\n        assert_equal(uniforms.dtype, np.float32)\n\n    def test_seed_float(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.pi)\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, -np.pi)\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        with pytest.raises(self.seed_error_type):\n            rs.bit_generator.seed(np.array([np.pi]))\n        with pytest.raises((ValueError, TypeError)):\n            rs.bit_generator.seed(np.array([-np.pi]))\n        with pytest.raises((ValueError, TypeError)):\n            rs.bit_generator.seed(np.array([np.pi, -np.pi]))\n        with pytest.raises((ValueError, TypeError)):\n            rs.bit_generator.seed(np.array([0, np.pi]))\n        with pytest.raises(TypeError):\n            rs.bit_generator.seed([np.pi])\n        with pytest.raises(TypeError):\n            rs.bit_generator.seed([0, np.pi])\n\n    def test_seed_out_of_range(self):\n        # GH #82\n        if self.seed_sequence_only:\n            # Not valid on PRNG that only support seed sequence\n            return\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, 2 ** (4 * self.bits + 1))\n        assert_raises(ValueError, rs.bit_generator.seed, -1)\n\n    def test_seed_out_of_range_array(self):\n        # GH #82\n        if self.seed_sequence_only:\n            # Not valid on PRNG that only support seed sequence\n            return\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, [2 ** (2 * self.bits + 1)])\n        assert_raises(ValueError, rs.bit_generator.seed, [-1])\n\n    def test_repr(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert ""Generator"" in repr(rs)\n        assert type(rs.bit_generator).__name__ in repr(rs)\n\n    def test_str(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert ""Generator"" in str(rs)\n        assert str(type(rs.bit_generator).__name__) in str(rs)\n        assert ""{:#x}"".format(id(rs)).upper().replace(""X"", ""x"")[2:] not in str(rs)\n\n    def test_generator(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        if ""generator"" not in dir(bit_generator):\n            pytest.skip(""generator attribute has been removed"")\n        with pytest.raises(NotImplementedError):\n            bit_generator.generator\n\n    def test_pickle(self):\n        import pickle\n\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        bit_generator_pkl = pickle.dumps(bit_generator)\n        reloaded = pickle.loads(bit_generator_pkl)\n        orig_gen = Generator(bit_generator)\n        reloaded_gen = Generator(reloaded)\n        assert_array_equal(\n            orig_gen.standard_normal(1000), reloaded_gen.standard_normal(1000)\n        )\n        assert bit_generator is not reloaded\n        assert_state_equal(reloaded.state, bit_generator.state)\n\n    def test_invalid_state_type(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        with pytest.raises(TypeError):\n            bit_generator.state = {""1""}\n\n    def test_invalid_state_value(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        state[""bit_generator""] = ""otherBitGenerator""\n        with pytest.raises(ValueError):\n            bit_generator.state = state\n\n    def test_invalid_seed_type(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        for st in self.invalid_seed_types:\n            with pytest.raises(TypeError):\n                bit_generator.seed(*st)\n\n    def test_invalid_seed_values(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        for st in self.invalid_seed_values:\n            with pytest.raises(ValueError):\n                bit_generator.seed(*st)\n\n    def test_benchmark(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        bit_generator._benchmark(1)\n        bit_generator._benchmark(1, ""double"")\n        with pytest.raises(ValueError):\n            bit_generator._benchmark(1, ""int32"")\n\n    @pytest.mark.skipif(MISSING_CFFI, reason=""cffi not available"")\n    def test_cffi(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        cffi_interface = bit_generator.cffi\n        assert isinstance(cffi_interface, interface)\n        other_cffi_interface = bit_generator.cffi\n        assert other_cffi_interface is cffi_interface\n\n    @pytest.mark.skipif(MISSING_CTYPES, reason=""ctypes not available"")\n    def test_ctypes(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        ctypes_interface = bit_generator.ctypes\n        assert isinstance(ctypes_interface, interface)\n        other_ctypes_interface = bit_generator.ctypes\n        assert other_ctypes_interface is ctypes_interface\n\n    def test_getstate(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        alt_state = bit_generator.__getstate__()\n        assert_state_equal(state, alt_state)\n\n    def test_uinteger_reset_seed(self):\n        bg = self.setup_bitgenerator([None])\n        g = Generator(bg)\n        g.integers(0, 2 ** 32, dtype=np.uint32)\n        if ""has_uint32"" not in bg.state or bg.state[""has_uint32""] == 0:\n            name = bg.__class__.__name__\n            pytest.skip(""bit generator does not cache 32-bit value ({0})"".format(name))\n        bg.seed()\n        assert bg.state[""has_uint32""] == 0\n\n    def test_uinteger_reset_jump(self):\n        bg = self.setup_bitgenerator([None])\n        if not hasattr(bg, ""jumped""):\n            pytest.skip(""bit generator does not support jumping"")\n        g = Generator(bg)\n        g.integers(0, 2 ** 32, dtype=np.uint32)\n        jumped = Generator(bg.jumped())\n        if ""has_uint32"" in jumped.bit_generator.state:\n            assert jumped.bit_generator.state[""has_uint32""] == 0\n            return\n        # This next test could fail with prob 1 in 2**32\n        next_g = g.integers(0, 2 ** 32, dtype=np.uint32)\n        next_jumped = jumped.integers(0, 2 ** 32, dtype=np.uint32)\n        assert next_g != next_jumped\n\n    def test_uinteger_reset_advance(self):\n        bg = self.setup_bitgenerator([None])\n        if not hasattr(bg, ""advance""):\n            pytest.skip(""bit generator does not support advancing"")\n        g = Generator(bg)\n        g.integers(0, 2 ** 32, dtype=np.uint32)\n        state = bg.state\n        if isinstance(bg, (Philox, ThreeFry)):\n            bg.advance(1000, False)\n        else:\n            bg.advance(1000)\n        if ""has_uint32"" in bg.state:\n            assert bg.state[""has_uint32""] == 0\n            return\n        # This next test could fail with prob 1 in 2**32\n        next_advanced = g.integers(0, 2 ** 32, dtype=np.uint32)\n        bg.state = state\n        next_g = g.integers(0, 2 ** 32, dtype=np.uint32)\n        assert next_g != next_advanced\n\n    def test_seed_sequence(self):\n        bg = self.setup_bitgenerator([None], mode=""sequence"")\n        typ = (\n            self.bit_generator.func\n            if isinstance(self.bit_generator, partial)\n            else self.bit_generator\n        )\n        assert isinstance(bg, typ)\n        assert isinstance(bg.seed_seq, SeedSequence)\n\n        bg = self.setup_bitgenerator([0], mode=""sequence"")\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(0)\n        bg = self.bit_generator(ss)\n        assert bg.seed_seq.entropy == 0\n\n    def test_seed_sequence_error(self):\n        with pytest.raises(ValueError, match=""seed is a SeedSequence""):\n            self.bit_generator(SeedSequence(0), mode=""legacy"")\n\n    def test_bit_generator_repr(self):\n        bg = self.setup_bitgenerator([None])\n        assert isinstance(repr(bg), str)\n        assert type(bg).__name__ in repr(bg)\n        assert type(bg).__name__ in str(bg)\n\n\nclass Random123(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Philox\n        cls.number = 4\n        cls.width = 64\n\n    def setup_bitgenerator(self, seed, mode=""legacy"", **kwargs):\n        return self.bit_generator(*seed, mode=mode, **kwargs)\n\n    def test_advance(self, step, counter_only, warmup):\n        bg = self.bit_generator(mode=""sequence"")\n        bg.random_raw(warmup)\n        state0 = bg.state\n        n = self.number\n        adj_step = step * n if counter_only else step\n        bg.random_raw(adj_step)\n        state_direct_pre = bg.state\n        direct = bg.random_raw()\n        bg.state = state0\n        bg.advance(step, counter_only)\n        advanced = bg.random_raw()\n        if counter_only and step:\n            bg.state = state_direct_pre\n            window = bg.random_raw(self.number + 1)\n            assert bool(np.isin(advanced, window))\n            return\n\n        # standard case\n        assert direct == advanced\n\n    def test_advance_large(self):\n        dtype = np.uint64 if self.width == 64 else np.uint32\n        bg = self.bit_generator(mode=""legacy"")\n        step = 2 ** self.width\n        bg.advance(step, True)\n        state = bg.state\n        assert_equal(state[""state""][""counter""], np.array([0, 1, 0, 0], dtype=dtype))\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** self.width - 1\n        bg.advance(step, True)\n        state = bg.state\n        size_max = np.iinfo(dtype).max\n        assert_equal(\n            state[""state""][""counter""], np.array([size_max, 0, 0, 0], dtype=dtype)\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** (2 * self.width)\n        bg.advance(step, True)\n        state = bg.state\n        assert_equal(state[""state""][""counter""], np.array([0, 0, 1, 0], dtype=dtype))\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** (2 * self.width) - 1\n        bg.advance(step, True)\n        state = bg.state\n        assert_equal(\n            state[""state""][""counter""], np.array([size_max, size_max, 0, 0], dtype=dtype)\n        )\n\n    def test_advance_deprecated(self):\n        bg = self.bit_generator(mode=""sequence"")\n        with pytest.warns(FutureWarning):\n            bg.advance(1)\n\n    def test_0d_array(self):\n        bg = self.bit_generator(np.array(1, dtype=np.uint64), mode=""legacy"")\n        bg2 = self.bit_generator(1, mode=""legacy"")\n        assert_state_equal(bg.state, bg2.state)\n\n    def test_empty_seed(self):\n        with pytest.raises(ValueError):\n            self.bit_generator(np.array([], dtype=np.uint64), mode=""legacy"")\n\n    def test_seed_key(self):\n        with pytest.raises(ValueError, match=""seed and key""):\n            self.setup_bitgenerator([0], mode=""legacy"", key=0, counter=0)\n\n\nclass TestJSF64(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = JSF\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/jsf64-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/jsf64-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n    def test_bad_init(self):\n        with pytest.raises(ValueError):\n            self.bit_generator(size=self.bits - 1, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(p=-10, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(q=120, mode=""legacy"")\n\n    def test_number_seed(self):\n        bg1 = self.bit_generator(0, seed_size=1, mode=""legacy"")\n        bg2 = self.bit_generator(0, seed_size=2, mode=""legacy"")\n        bg3 = self.bit_generator(0, seed_size=3, mode=""legacy"")\n        state1 = bg1.state[""state""]\n        state2 = bg2.state[""state""]\n        state3 = bg3.state[""state""]\n        assert state1[""c""] != state2[""c""]\n        assert state1[""c""] != state3[""c""]\n        assert state2[""c""] != state3[""c""]\n        assert state1[""d""] != state2[""d""]\n        assert state1[""d""] != state3[""d""]\n        assert state2[""d""] != state3[""d""]\n\n    def test_invalid_seed_size(self):\n        with pytest.raises(ValueError, match=""seed size must be one""):\n            self.bit_generator(seed_size=4, mode=""legacy"")\n        with pytest.raises(ValueError, match=""seed size must be one""):\n            self.bit_generator(seed_size=1.0, mode=""legacy"")\n\n\nclass TestJSF32(TestJSF64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator_base = JSF\n        cls.bit_generator = partial(JSF, size=32)\n        cls.size = 32\n        cls.bits = 32\n        cls.dtype = np.uint32\n        cls.data1 = cls._read_csv(join(pwd, ""./data/jsf32-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/jsf32-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n    def test_seed_sequence(self):\n        bg = self.bit_generator_base(size=self.size, mode=""sequence"")\n        assert isinstance(bg, self.bit_generator_base)\n        assert isinstance(bg.seed_seq, SeedSequence)\n\n        bg = self.bit_generator_base(0, size=self.size, mode=""sequence"")\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(0)\n        bg = self.bit_generator_base(ss)\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(1)\n        bg = self.bit_generator_base(ss, size=self.size)\n        assert bg.seed_seq.entropy == 1\n\n\nclass TestXoroshiro128(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoroshiro128\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/xoroshiro128-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/xoroshiro128-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n\nclass TestXoroshiro128PlusPlus(TestXoroshiro128):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(Xoroshiro128, plusplus=True)\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(\n            join(pwd, ""./data/xoroshiro128plusplus-testset-1.csv"")\n        )\n        cls.data2 = cls._read_csv(\n            join(pwd, ""./data/xoroshiro128plusplus-testset-2.csv"")\n        )\n\n\nclass TestXoshiro256(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoshiro256\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/xoshiro256-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/xoshiro256-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n    def test_old_name(self):\n        from randomgen.xoshiro256starstar import Xoshiro256StarStar\n\n        with pytest.deprecated_call():\n            bitgen = Xoshiro256StarStar()\n            assert isinstance(bitgen, Xoshiro256)\n\n\nclass TestXoshiro512(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoshiro512\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/xoshiro512-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/xoshiro512-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n    def test_old_name(self):\n        from randomgen.xoshiro512starstar import Xoshiro512StarStar\n\n        with pytest.deprecated_call():\n            bitgen = Xoshiro512StarStar()\n            assert isinstance(bitgen, Xoshiro512)\n\n\nclass TestXorshift1024(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xorshift1024\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/xorshift1024-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/xorshift1024-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(""apple"",), (2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), (np.empty((2, 2), dtype=np.int64),)]\n\n\nclass TestThreeFry(Random123):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = ThreeFry\n        cls.number = 4\n        cls.width = 64\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/threefry-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/threefry-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (1, None, 1),\n            (-1,),\n            (2 ** 257 + 1,),\n            (None, None, 2 ** 257 + 1),\n        ]\n\n    def test_set_key(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        keyed = self.bit_generator(\n            counter=state[""state""][""counter""], key=state[""state""][""key""], mode=""legacy""\n        )\n        assert_state_equal(bit_generator.state, keyed.state)\n\n    def test_advance(self):\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        bg.advance(1, True)\n        assert_equal(\n            bg.state[""state""][""counter""], np.array([1, 0, 0, 0], dtype=np.uint64)\n        )\n        bg.advance(1, True)\n        assert_equal(\n            bg.state[""state""][""counter""], np.array([2, 0, 0, 0], dtype=np.uint64)\n        )\n        bg.advance(2 ** 64, True)\n        assert_equal(\n            bg.state[""state""][""counter""], np.array([2, 1, 0, 0], dtype=np.uint64)\n        )\n        bg.state = state0\n        bg.advance(2 ** 128, True)\n        assert_equal(\n            bg.state[""state""][""counter""], np.array([0, 0, 1, 0], dtype=np.uint64)\n        )\n\n\nclass TestPCG64(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = PCG64\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/pcg64-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/pcg64-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(np.array([1, 2]),), (3.2,), (None, np.zeros(1))]\n        cls.invalid_seed_values = [\n            (-1,),\n            (2 ** 129 + 1,),\n            (None, -1),\n            (None, 2 ** 129 + 1),\n        ]\n\n    def test_seed_float_array(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([np.pi]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([-np.pi]))\n        assert_raises(\n            self.seed_error_type, rs.bit_generator.seed, np.array([np.pi, -np.pi])\n        )\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, [np.pi])\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, [0, np.pi])\n\n    def test_seed_out_of_range_array(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(\n            self.seed_error_type, rs.bit_generator.seed, [2 ** (2 * self.bits + 1)]\n        )\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, [-1])\n\n    def test_advance_symmetry(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        state = rs.bit_generator.state\n        step = -0x9E3779B97F4A7C150000000000000000\n        rs.bit_generator.advance(step)\n        val_neg = rs.integers(10)\n        rs.bit_generator.state = state\n        rs.bit_generator.advance(2 ** 128 + step)\n        val_pos = rs.integers(10)\n        rs.bit_generator.state = state\n        rs.bit_generator.advance(10 * 2 ** 128 + step)\n        val_big = rs.integers(10)\n        assert val_neg == val_pos\n        assert val_big == val_pos\n\n    def test_inc_none(self):\n        bg = self.setup_bitgenerator([0, None])\n        assert isinstance(bg.random_raw(), int)\n\n        bg = self.setup_bitgenerator([0, None], mode=""sequence"")\n        assert isinstance(bg.random_raw(), int)\n\n\nclass TestPhilox(Random123):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Philox\n        cls.number = 4\n        cls.width = 64\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/philox-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/philox-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (1, None, 1),\n            (-1,),\n            (2 ** 257 + 1,),\n            (None, None, 2 ** 257 + 1),\n        ]\n\n    def test_set_key(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        keyed = self.bit_generator(\n            counter=state[""state""][""counter""], key=state[""state""][""key""], mode=""legacy""\n        )\n        assert_state_equal(bit_generator.state, keyed.state)\n\n\nclass TestPhilox4x32(Random123):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator_base = Philox\n        cls.bit_generator = partial(Philox, number=4, width=32)\n        cls.number = 4\n        cls.width = 32\n        cls.bits = 32\n        cls.dtype = np.uint32\n        cls.data1 = cls._read_csv(join(pwd, ""./data/philox4x32-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/philox4x32-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (1, None, 1),\n            (-1,),\n            (2 ** 257 + 1,),\n            (None, None, 2 ** 257 + 1),\n        ]\n\n    def test_seed_sequence(self):\n        bg = self.bit_generator_base(\n            number=self.number, width=self.width, mode=""sequence""\n        )\n        assert isinstance(bg, self.bit_generator_base)\n        assert isinstance(bg.seed_seq, SeedSequence)\n\n        bg = self.bit_generator_base(\n            0, number=self.number, width=self.width, mode=""sequence""\n        )\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(0)\n        bg = self.bit_generator_base(ss)\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(1)\n        bg = self.bit_generator_base(ss, number=self.number, width=self.width)\n        assert bg.seed_seq.entropy == 1\n\n\nclass TestAESCounter(TestPhilox):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = AESCounter\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/aesctr-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/aesctr-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (1, None, 1),\n            (-1,),\n            (2 ** 257 + 1,),\n            (None, None, 2 ** 257 + 1),\n        ]\n\n    @pytest.fixture(autouse=True, params=USE_AESNI)\n    def set_use_aesni(self, request):\n        self.use_aesni = request.param\n\n    def setup_bitgenerator(self, seed, mode=""legacy"", **kwargs):\n        bg = self.bit_generator(*seed, mode=mode, **kwargs)\n        bg.use_aesni = self.use_aesni\n        return bg\n\n    def test_set_key(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        key = state[""s""][""seed""][:2]\n        key = int(key[0]) + int(key[1]) * 2 ** 64\n        counter = state[""s""][""counter""][0]\n        keyed = self.bit_generator(counter=counter, key=key, mode=""legacy"")\n        assert_state_equal(bit_generator.state, keyed.state)\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([np.pi]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([-np.pi]))\n        assert_raises(\n            self.seed_error_type, rs.bit_generator.seed, np.array([np.pi, -np.pi])\n        )\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, [np.pi])\n        assert_raises(TypeError, rs.bit_generator.seed, [0, np.pi])\n\n    def test_bad_state(self):\n        bg = self.bit_generator(mode=""sequence"")\n        state = bg.state\n        state[""s""][""seed""] = np.empty((2, 11), dtype=np.uint64)\n        with pytest.raises(ValueError):\n            bg.state = state\n        state = bg.state\n        state[""s""][""counter""] = 4\n        with pytest.raises(ValueError):\n            bg.state = state\n\n    def test_advance(self, step, warmup):\n        bg = self.bit_generator(mode=""sequence"")\n        bg.random_raw(warmup)\n        state0 = bg.state\n        bg.random_raw(step)\n        direct = bg.random_raw()\n        bg.state = state0\n        bg.advance(step)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_one_repeat(self):\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        bg.random_raw(8)\n        direct = bg.random_raw()\n        bg.state = state0\n        for _ in range(8):\n            bg.advance(1)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_large(self):\n        bg = self.bit_generator(mode=""legacy"")\n        step = 2 ** 65\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""s""][""counter""], np.array([4, 1, 5, 1, 6, 1, 7, 1], dtype=np.uint64)\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 65 - 7\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""s""][""counter""], np.array([0, 1, 1, 1, 2, 1, 3, 1], dtype=np.uint64)\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 129 - 16\n        bg.advance(step)\n        state = bg.state\n        m = np.iinfo(np.uint64).max\n        assert_equal(\n            state[""s""][""counter""],\n            np.array([m - 3, m, m - 2, m, m - 1, m, m, m], dtype=np.uint64),\n        )\n        bg.random_raw(9)\n        state = bg.state\n        assert_equal(\n            state[""s""][""counter""], np.array([0, 0, 1, 0, 2, 0, 3, 0], dtype=np.uint64)\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        step = 2 ** 129\n        bg.advance(step)\n        state = bg.state\n        assert_state_equal(state0, state)\n\n    @pytest.mark.skip(reason=""Not applicable to AESCounter"")\n    def test_advance_deprecated(self):\n        pass\n\n    @pytest.mark.skipif(HAS_AESNI, reason=""Not valid when cpu has AESNI"")\n    def test_no_aesni(self):\n        bg = self.bit_generator(mode=""sequence"")\n        with pytest.raises(ValueError, match=""CPU does not support AESNI""):\n            bg.use_aesni = True\n\n    def test_seed_key(self):\n        with pytest.raises(ValueError, match=""seed and key""):\n            self.setup_bitgenerator([0], mode=""legacy"", counter=0, key=0)\n\n\nclass TestMT19937(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = MT19937\n        cls.bits = 32\n        cls.seed_bits = 32\n        cls.dtype = np.uint32\n        cls.data1 = cls._read_csv(join(pwd, ""./data/mt19937-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/mt19937-testset-2.csv""))\n        cls.seed_error_type = ValueError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [(-1,), (np.array([2 ** 33]),)]\n        cls.state_name = ""key""\n\n    def test_seed_out_of_range(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, 2 ** (self.seed_bits + 1))\n        assert_raises(ValueError, rs.bit_generator.seed, -1)\n        assert_raises(ValueError, rs.bit_generator.seed, 2 ** (2 * self.seed_bits + 1))\n\n    def test_seed_out_of_range_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, [2 ** (self.seed_bits + 1)])\n        assert_raises(ValueError, rs.bit_generator.seed, [-1])\n        assert_raises(TypeError, rs.bit_generator.seed, [2 ** (2 * self.seed_bits + 1)])\n\n    def test_seed_float(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.pi)\n        assert_raises(TypeError, rs.bit_generator.seed, -np.pi)\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        bit_generator = rs.bit_generator\n        assert_raises(TypeError, bit_generator.seed, np.array([np.pi]))\n        assert_raises(TypeError, bit_generator.seed, np.array([-np.pi]))\n        assert_raises(TypeError, bit_generator.seed, np.array([np.pi, -np.pi]))\n        assert_raises(TypeError, bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(TypeError, bit_generator.seed, [np.pi])\n        assert_raises(TypeError, bit_generator.seed, [0, np.pi])\n\n    def test_state_tuple(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        bit_generator = rs.bit_generator\n        state = bit_generator.state\n        desired = rs.integers(2 ** 16)\n        tup = (state[""bit_generator""], state[""state""][""key""], state[""state""][""pos""])\n        bit_generator.state = tup\n        actual = rs.integers(2 ** 16)\n        assert_equal(actual, desired)\n        tup = tup + (0, 0.0)\n        bit_generator.state = tup\n        actual = rs.integers(2 ** 16)\n        assert_equal(actual, desired)\n\n    def test_invalid_state(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        state = rs.bit_generator.state\n        state[""state""][self.state_name] = state[""state""][self.state_name][:10]\n        with pytest.raises(ValueError):\n            rs.bit_generator.state = state\n\n    def test_negative_jump(self):\n        bg = self.setup_bitgenerator(self.data1[""seed""])\n        with pytest.raises(ValueError):\n            bg.jumped(-1)\n\n    def test_bad_legacy_state(self):\n        bg = self.setup_bitgenerator(self.data1[""seed""])\n        with pytest.raises(ValueError):\n            bg.state = (""UNKNOWN"",)\n\n\nclass TestSFMT(TestMT19937):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = SFMT\n        cls.bits = 64\n        cls.seed_bits = 32\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/sfmt-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/sfmt-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (-1,),\n            (np.array([2 ** 33]),),\n            (np.array([2 ** 33, 2 ** 33]),),\n        ]\n        cls.state_name = ""state""\n\n    @pytest.mark.skip(reason=""Not applicable to SFMT"")\n    def test_state_tuple(self):\n        pass\n\n    @pytest.mark.skip(reason=""Not applicable to SFMT"")\n    def test_bad_legacy_state(self):\n        pass\n\n\nclass TestDSFMT(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = DSFMT\n        cls.bits = 53\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/dSFMT-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/dSFMT-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (-1,),\n            (np.array([2 ** 33]),),\n            (np.array([2 ** 33, 2 ** 33]),),\n        ]\n\n    def test_uniform_double(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_array_equal(uniform_from_dsfmt(self.data1[""data""]), rs.random(1000))\n\n        rs = Generator(self.setup_bitgenerator(self.data2[""seed""]))\n        assert_equal(uniform_from_dsfmt(self.data2[""data""]), rs.random(1000))\n\n    def test_gauss_inv(self):\n        n = 25\n        rs = RandomState(self.setup_bitgenerator(self.data1[""seed""]))\n        gauss = rs.standard_normal(n)\n        assert_allclose(gauss, gauss_from_uint(self.data1[""data""], n, ""dsfmt""))\n\n        rs = RandomState(self.setup_bitgenerator(self.data2[""seed""]))\n        gauss = rs.standard_normal(25)\n        assert_allclose(gauss, gauss_from_uint(self.data2[""data""], n, ""dsfmt""))\n\n    def test_seed_out_of_range_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, [2 ** (self.bits + 1)])\n        assert_raises(ValueError, rs.bit_generator.seed, [-1])\n        assert_raises(TypeError, rs.bit_generator.seed, [2 ** (2 * self.bits + 1)])\n\n    def test_seed_float(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.pi)\n        assert_raises(TypeError, rs.bit_generator.seed, -np.pi)\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([-np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([np.pi, -np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, [np.pi])\n        assert_raises(TypeError, rs.bit_generator.seed, [0, np.pi])\n\n    def test_uniform_float(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        vals = uniform32_from_uint(self.data1[""data""], self.bits)\n        uniforms = rs.random(len(vals), dtype=np.float32)\n        assert_allclose(uniforms, vals)\n        assert_equal(uniforms.dtype, np.float32)\n\n        rs = Generator(self.setup_bitgenerator(self.data2[""seed""]))\n        vals = uniform32_from_uint(self.data2[""data""], self.bits)\n        uniforms = rs.random(len(vals), dtype=np.float32)\n        assert_allclose(uniforms, vals)\n        assert_equal(uniforms.dtype, np.float32)\n\n    def test_buffer_reset(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        rs.random(1)\n        assert rs.bit_generator.state[""buffer_loc""] != 382\n        rs.bit_generator.seed(*self.data1[""seed""])\n        assert rs.bit_generator.state[""buffer_loc""] == 382\n\n    def test_negative_jump(self):\n        bg = self.bit_generator(mode=""sequence"")\n        with pytest.raises(ValueError, match=""iter must be positive""):\n            bg.jumped(-1)\n\n\nclass TestThreeFry4x32(Random123):\n    @classmethod\n    def setup_class(cls):\n        super(TestThreeFry4x32, cls).setup_class()\n        cls.bit_generator_base = ThreeFry\n        cls.bit_generator = partial(ThreeFry, number=4, width=32)\n        cls.number = 4\n        cls.width = 32\n        cls.bits = 32\n        cls.dtype = np.uint32\n        cls.data1 = cls._read_csv(join(pwd, ""./data/threefry32-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/threefry32-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [\n            (1, None, 1),\n            (-1,),\n            (2 ** 257 + 1,),\n            (None, None, 2 ** 129 + 1),\n        ]\n\n    def test_seed_sequence(self):\n        bg = self.bit_generator_base(\n            number=self.number, width=self.width, mode=""sequence""\n        )\n        assert isinstance(bg, self.bit_generator_base)\n        assert isinstance(bg.seed_seq, SeedSequence)\n\n        bg = self.bit_generator_base(\n            0, number=self.number, width=self.width, mode=""sequence""\n        )\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(0)\n        bg = self.bit_generator_base(ss)\n        assert bg.seed_seq.entropy == 0\n\n        ss = SeedSequence(1)\n        bg = self.bit_generator_base(ss, number=self.number, width=self.width)\n        assert bg.seed_seq.entropy == 1\n\n    def test_set_key(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        state = bit_generator.state\n        key = state[""state""][""key""]\n        power = 32 if key.dtype == np.uint32 else 64\n        key = sum([int(key[i]) * 2 ** (power * i) for i in range(len(key))])\n        counter = state[""state""][""counter""]\n        counter = sum([int(counter[i]) * 2 ** (power * i) for i in range(len(counter))])\n        keyed = self.bit_generator(counter=counter, key=key, mode=""legacy"")\n        assert_state_equal(bit_generator.state, keyed.state)\n\n\nclass TestPCG32(TestPCG64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = PCG32\n        cls.bits = 32\n        cls.dtype = np.uint32\n        cls.data1 = cls._read_csv(join(pwd, ""./data/pcg32-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/pcg32-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(np.array([1, 2]),), (3.2,), (None, np.zeros(1))]\n        cls.invalid_seed_values = [\n            (-1,),\n            (2 ** 129 + 1,),\n            (None, -1),\n            (None, 2 ** 129 + 1),\n        ]\n\n    def test_advance_symmetry(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        state = rs.bit_generator.state\n        step = -0x9E3779B97F4A7C16\n        rs.bit_generator.advance(step)\n        val_neg = rs.integers(10)\n        rs.bit_generator.state = state\n        rs.bit_generator.advance(2 ** 64 + step)\n        val_pos = rs.integers(10)\n        rs.bit_generator.state = state\n        rs.bit_generator.advance(10 * 2 ** 64 + step)\n        val_big = rs.integers(10)\n        assert val_neg == val_pos\n        assert val_big == val_pos\n\n\nclass TestMT64(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = MT64\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/mt64-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/mt64-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.seed_error_type = ValueError\n        cls.invalid_seed_types = []\n        cls.invalid_seed_values = [(-1,), (np.array([2 ** 65]),)]\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        bit_generator = rs.bit_generator\n        assert_raises(ValueError, bit_generator.seed, np.array([np.pi]))\n        assert_raises(ValueError, bit_generator.seed, np.array([-np.pi]))\n        assert_raises(ValueError, bit_generator.seed, np.array([np.pi, -np.pi]))\n        assert_raises(ValueError, bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(ValueError, bit_generator.seed, [np.pi])\n        assert_raises(ValueError, bit_generator.seed, [0, np.pi])\n\n    def test_empty_seed(self):\n        with pytest.raises(ValueError, match=""Seed must be non-empty""):\n            self.bit_generator(np.array([], dtype=np.uint64), mode=""legacy"")\n\n\n@pytest.mark.skipif(MISSING_RDRAND, reason=""RDRAND is not availble"")\nclass TestRDRAND(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = RDRAND\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.seed_error_type = TypeError\n        cls.data1 = {""seed"": [None]}\n        cls.invalid_seed_types = [1, np.array([1])]\n        cls.invalid_seed_values = []\n\n    def setup_bitgenerator(self, seed, mode=None):\n        return self.bit_generator(*seed)\n\n    def test_raw(self):\n        bit_generator = self.bit_generator()\n        raw = bit_generator.random_raw(1000)\n        assert (raw.max() - raw.min()) > 0\n\n    def test_gauss_inv(self):\n        n = 25\n        rs = RandomState(self.setup_bitgenerator(self.data1[""seed""]))\n        gauss = rs.standard_normal(n)\n        assert (gauss.max() - gauss.min()) > 0\n\n    def test_uniform_double(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        uniforms = rs.random(1000)\n        assert_equal(uniforms.dtype, np.float64)\n\n    def test_uniform_float(self):\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        uniforms = rs.random(1000, dtype=np.float32)\n        assert_equal(uniforms.dtype, np.float32)\n\n    @pytest.mark.skip(""Bit generator is missing generator attr"")\n    def test_generator(self):\n        pass\n\n    def test_pickle(self):\n        import pickle\n\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        bit_generator_pkl = pickle.dumps(bit_generator)\n        reloaded = pickle.loads(bit_generator_pkl)\n        assert bit_generator is not reloaded\n        assert_state_equal(reloaded.state, bit_generator.state)\n\n    @pytest.mark.skip(""RDRAND seed accepts only None"")\n    def test_seed_out_of_range_array(self):\n        pass\n\n    @pytest.mark.skip(""RDRAND seed accepts only None"")\n    def test_seed_out_of_range(self):\n        pass\n\n    @pytest.mark.skip(""RDRAND seed accepts only None"")\n    def test_seed_float_array(self):\n        pass\n\n    def test_jumped(self):\n        bg = self.setup_bitgenerator(self.data1[""seed""])\n        new_bg = bg.jumped()\n        assert isinstance(new_bg, type(bg))\n        assert bg is not new_bg\n\n    def test_seed_sequence(self):\n        bg = self.bit_generator()\n        assert isinstance(bg, self.bit_generator)\n        assert bg.seed_seq is None\n\n        with pytest.raises(TypeError):\n            self.bit_generator(0)\n\n        ss = SeedSequence(0)\n        with pytest.raises(TypeError):\n            self.bit_generator(ss)\n\n    def test_default_sequence(self):\n        bg = self.setup_bitgenerator([None])\n        val = bg.random_raw()\n        assert isinstance(val, int)\n        assert bg.seed_seq is None\n\n    def test_seed_sequence_error(self):\n        with pytest.raises(TypeError, match=""seed cannot be set""):\n            self.bit_generator(SeedSequence(0))\n\n\nclass TestChaCha(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = ChaCha\n        cls.bits = 64\n        cls.seed_bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/chacha-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/chacha-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(np.array([2 ** 65]),)]\n        cls.invalid_seed_values = [(-1,), [2 ** 257]]\n        cls.state_name = ""key""\n\n    def setup_bitgenerator(self, seed, mode=""legacy"", **kwargs):\n        stream = 3735928559 * 2 ** 64 + 3735928559 * 2 ** 96\n        seed = [0] if None in seed else seed\n        key = seed[0] + stream + 2 ** 128 * stream\n        if mode == ""legacy"":\n            bg = self.bit_generator(key=key, counter=0, mode=mode)\n        else:\n            bg = self.bit_generator(*seed, mode=mode, **kwargs)\n        return bg\n\n    def test_set_key(self):\n        with pytest.raises(ValueError, match=""seed and key cannot""):\n            self.bit_generator(seed=0, key=0, mode=""legacy"")\n\n    def test_invalid_rounds(self):\n        with pytest.raises(ValueError, match=""rounds must be even and""):\n            self.bit_generator(rounds=3, mode=""legacy"")\n        with pytest.raises(ValueError, match=""rounds must be even and""):\n            self.bit_generator(rounds=-4, mode=""legacy"")\n\n    def test_advance(self, step, warmup):\n        bg = self.bit_generator(mode=""sequence"")\n        bg.random_raw(warmup)\n        state0 = bg.state\n        bg.random_raw(step)\n        direct = bg.random_raw()\n        bg.state = state0\n        # Double step since it is a 32 bit gen, but random_raw is 64 bit\n        bg.advance(2 * step)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_one_repeat(self):\n        steps = 16\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        # Half step since 32 bit gen using 64 bit raw\n        bg.random_raw(steps // 2)\n        direct = bg.random_raw()\n        bg.state = state0\n        for _ in range(steps):\n            bg.advance(1)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_large(self):\n        bg = self.bit_generator(mode=""legacy"")\n        step = 2 ** 64\n        bg.advance(step)\n        state = bg.state\n        assert_equal(state[""state""][""ctr""], np.array([0, 1], dtype=np.uint64))\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 64 - 1\n        bg.advance(step)\n        state = bg.state\n        u64_max = np.iinfo(np.uint64).max\n        assert_equal(state[""state""][""ctr""], np.array([u64_max, 0], dtype=np.uint64))\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 128 - 16\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""state""][""ctr""], np.array([u64_max - 15, u64_max], dtype=np.uint64)\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 128 - 1\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""state""][""ctr""], np.array([u64_max, u64_max], dtype=np.uint64)\n        )\n        bg.advance(1)\n        state = bg.state\n        assert_equal(state[""state""][""ctr""], np.array([0, 0], dtype=np.uint64))\n\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        step = 2 ** 128\n        bg.advance(step)\n        state = bg.state\n        assert_state_equal(state0, state)\n\n    def test_use_simd(self):\n        bg = self.bit_generator(0, mode=""legacy"")\n        if not bg.use_simd:\n            with pytest.raises(ValueError):\n                bg.use_simd = True\n            return\n        bg2 = self.bit_generator(0, mode=""legacy"")\n        bg2.use_simd = not bg.use_simd\n        assert_equal(bg.random_raw(100), bg2.random_raw(100))\n\n    def test_seed_key(self):\n        with pytest.raises(ValueError, match=""seed and key""):\n            self.setup_bitgenerator([0], mode=""sequence"", key=0, counter=0)\n\n\nclass TestHC128(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = HC128\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/hc-128-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/hc-128-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [\n            (""apple"",),\n            (2 + 3j,),\n            (3.1,),\n            (-2,),\n            (np.empty((2, 2), dtype=np.int64),),\n        ]\n        cls.invalid_seed_values = []\n\n    def test_seed_float_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([np.pi]))\n        assert_raises(self.seed_error_type, rs.bit_generator.seed, np.array([-np.pi]))\n        assert_raises(\n            self.seed_error_type, rs.bit_generator.seed, np.array([np.pi, -np.pi])\n        )\n        assert_raises(TypeError, rs.bit_generator.seed, np.array([0, np.pi]))\n        assert_raises(TypeError, rs.bit_generator.seed, [np.pi])\n        assert_raises(TypeError, rs.bit_generator.seed, [0, np.pi])\n\n    def test_seed_out_of_range(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, -1)\n\n    def test_invalid_seed_type(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        for st in self.invalid_seed_types:\n            with pytest.raises((TypeError, ValueError)):\n                bit_generator.seed(*st)\n\n    def test_key_init(self):\n        with pytest.raises(ValueError):\n            self.bit_generator(key=-1, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(key=2 ** 256, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(seed=1, key=1, mode=""legacy"")\n\n\nclass TestSPECK128(TestHC128):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = SPECK128\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/speck-128-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/speck-128-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [\n            (""apple"",),\n            (2 + 3j,),\n            (3.1,),\n            (-2,),\n            (np.empty((2, 2), dtype=np.int64),),\n        ]\n        cls.invalid_seed_values = []\n\n    def test_seed_out_of_range(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, 2 ** 257)\n        assert_raises(ValueError, rs.bit_generator.seed, -1)\n\n    def test_invalid_seed_type(self):\n        bit_generator = self.setup_bitgenerator(self.data1[""seed""])\n        for st in self.invalid_seed_types:\n            with pytest.raises((TypeError, ValueError)):\n                bit_generator.seed(*st)\n\n    def test_key_init(self):\n        with pytest.raises(ValueError):\n            self.bit_generator(key=-1, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(key=2 ** 256, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(seed=1, key=1, mode=""legacy"")\n\n    def test_seed_out_of_range_array(self):\n        # GH #82\n        rs = Generator(self.setup_bitgenerator(self.data1[""seed""]))\n        assert_raises(ValueError, rs.bit_generator.seed, [2 ** (4 * self.bits + 1)])\n        assert_raises(ValueError, rs.bit_generator.seed, [-1])\n\n    def test_advance(self, step, warmup):\n        bg = self.bit_generator(mode=""sequence"")\n        bg.random_raw(warmup)\n        state0 = bg.state\n        bg.random_raw(step)\n        direct = bg.random_raw()\n        bg.state = state0\n        bg.advance(step)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_one_repeat(self):\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        bg.random_raw(8)\n        direct = bg.random_raw()\n        bg.state = state0\n        for _ in range(8):\n            bg.advance(1)\n        advanced = bg.random_raw()\n        assert direct == advanced\n\n    def test_advance_large(self):\n        bg = self.bit_generator(mode=""legacy"")\n        step = 2 ** 65\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""state""][""ctr""],\n            np.array([6, 1, 7, 1, 8, 1, 9, 1, 10, 1, 11, 1], dtype=np.uint64),\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 65 - 11\n        bg.advance(step)\n        state = bg.state\n        assert_equal(\n            state[""state""][""ctr""],\n            np.array([0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1], dtype=np.uint64),\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        step = 2 ** 129 - 24\n        bg.advance(step)\n        state = bg.state\n        m = np.iinfo(np.uint64).max\n        assert_equal(\n            state[""state""][""ctr""],\n            np.array(\n                [m - 5, m, m - 4, m, m - 3, m, m - 2, m, m - 1, m, m, m],\n                dtype=np.uint64,\n            ),\n        )\n        bg.random_raw(13)\n        state = bg.state\n        assert_equal(\n            state[""state""][""ctr""],\n            np.array([0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0], dtype=np.uint64),\n        )\n\n        bg = self.bit_generator(mode=""sequence"")\n        state0 = bg.state\n        step = 2 ** 129\n        bg.advance(step)\n        state = bg.state\n        assert_state_equal(state0, state)\n\n    def test_use_sse41(self):\n        bg = self.bit_generator(0, mode=""legacy"")\n        if not bg.use_sse41:\n            with pytest.raises(ValueError):\n                bg.use_sse41 = True\n            return\n        bg2 = self.bit_generator(0, mode=""legacy"")\n        bg2.use_sse41 = not bg.use_sse41\n        assert_equal(bg.random_raw(100), bg2.random_raw(100))\n\n    def test_invalid_rounds(self):\n        with pytest.raises(ValueError):\n            self.bit_generator(rounds=-1, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(rounds=35, mode=""legacy"")\n        with pytest.raises(ValueError):\n            self.bit_generator(rounds=27.5, mode=""legacy"")\n\n\ndef test_mode():\n    with pytest.warns(FutureWarning, match=""mode is None which currently""):\n        mt19937 = MT19937(0)\n    assert mt19937.seed_seq is None\n    with pytest.raises(ValueError, match=""mode must be one of None""):\n        MT19937(mode=""unknown"")\n\n\nclass TestLXM(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = LXM\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/lxm-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/lxm-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), ([-2],)]\n        if NP_SEED_SEQ:\n            cls.invalid_seed_types += [(""apple"",)]\n        else:\n            cls.invalid_seed_values += [(""apple"",)]\n        cls.seed_sequence_only = True\n\n    def setup_bitgenerator(self, seed, mode=None):\n        return self.bit_generator(*seed)\n\n    def test_seed_sequence_error(self):\n        pass\n\n\nclass TestPCG64DXSM(Base):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(PCG64, mode=""sequence"", variant=""dxsm"")\n        cls.bits = 64\n        cls.dtype = np.uint64\n        cls.data1 = cls._read_csv(join(pwd, ""./data/pcg64-dxsm-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/pcg64-dxsm-testset-2.csv""))\n        cls.seed_error_type = TypeError\n        cls.invalid_seed_types = [(2 + 3j,), (3.1,)]\n        cls.invalid_seed_values = [(-2,), ([-2],)]\n        if NP_SEED_SEQ:\n            cls.invalid_seed_types += [(""apple"",)]\n        else:\n            cls.invalid_seed_values += [(""apple"",)]\n        cls.seed_sequence_only = True\n\n    def setup_bitgenerator(self, seed, mode=None):\n        return self.bit_generator(*seed)\n\n\nclass TestPCG64CMDXSM(TestPCG64DXSM):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(PCG64, mode=""sequence"", variant=""cm-dxsm"")\n        cls.data1 = cls._read_csv(join(pwd, ""./data/pcg64-cm-dxsm-testset-1.csv""))\n        cls.data2 = cls._read_csv(join(pwd, ""./data/pcg64-cm-dxsm-testset-2.csv""))\n'"
randomgen/tests/test_extended_generator.py,29,"b'import copy\nfrom distutils.version import LooseVersion\nimport pickle\n\nimport numpy as np\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import (\n    assert_array_almost_equal,\n    assert_equal,\n    assert_no_warnings,\n    assert_raises,\n    assert_warns,\n)\nimport pytest\n\nfrom randomgen import MT19937, PCG64, ExtendedGenerator\nfrom randomgen._testing import suppress_warnings\n\nSEED = 1234567890\nMV_SEED = 123456789\n\n\n@pytest.fixture(scope=""module"")\ndef seed():\n    return SEED\n\n\n@pytest.fixture(scope=""module"")\ndef mv_seed():\n    return MV_SEED\n\n\n_mt19937 = MT19937(SEED, mode=""legacy"")\nrandom = ExtendedGenerator(_mt19937)\n\nNP_LT_118 = LooseVersion(np.__version__) < LooseVersion(""1.18.0"")\n\n\n@pytest.mark.skipif(NP_LT_118, reason=""Can only test with NumPy >= 1.18"")\n@pytest.mark.parametrize(""method"", [""svd"", ""eigh"", ""cholesky""])\ndef test_multivariate_normal_method(seed, method):\n    from numpy.random import MT19937 as NPMT19937\n\n    random = ExtendedGenerator(NPMT19937(seed))\n    mean = (0.123456789, 10)\n    cov = [[1, 0], [0, 1]]\n    size = (3, 2)\n    actual = random.multivariate_normal(mean, cov, size, method=method)\n    desired = np.array(\n        [\n            [\n                [-1.747478062846581, 11.25613495182354],\n                [-0.9967333370066214, 10.342002097029821],\n            ],\n            [\n                [0.7850019631242964, 11.181113712443013],\n                [0.8901349653255224, 8.873825399642492],\n            ],\n            [\n                [0.7130260107430003, 9.551628690083056],\n                [0.7127098726541128, 11.991709234143173],\n            ],\n        ]\n    )\n\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    # Check for default size, was raising deprecation warning\n    actual = random.multivariate_normal(mean, cov, method=method)\n    desired = np.array([0.233278563284287, 9.424140804347195])\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    # Check path with scalar size works correctly\n    scalar = random.multivariate_normal(mean, cov, 3, method=method)\n    tuple1d = random.multivariate_normal(mean, cov, (3,), method=method)\n    assert scalar.shape == tuple1d.shape == (3, 2)\n\n    # Check that non symmetric covariance input raises exception when\n    # check_valid=\'raises\' if using default svd method.\n    mean = [0, 0]\n    cov = [[1, 2], [1, 2]]\n    assert_raises(\n        ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n    )\n\n    # Check that non positive-semidefinite covariance warns with\n    # RuntimeWarning\n    cov = [[1, 2], [2, 1]]\n    assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)\n    assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov, method=""eigh"")\n    assert_raises(LinAlgError, random.multivariate_normal, mean, cov, method=""cholesky"")\n\n    # and that it doesn\'t warn with RuntimeWarning check_valid=\'ignore\'\n    assert_no_warnings(random.multivariate_normal, mean, cov, check_valid=""ignore"")\n\n    # and that it raises with RuntimeWarning check_valid=\'raises\'\n    assert_raises(\n        ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n    )\n    assert_raises(\n        ValueError,\n        random.multivariate_normal,\n        mean,\n        cov,\n        check_valid=""raise"",\n        method=""eigh"",\n    )\n\n    # check degenerate samples from singular covariance matrix\n    cov = [[1, 1], [1, 1]]\n    if method in (""svd"", ""eigh""):\n        samples = random.multivariate_normal(mean, cov, size=(3, 2), method=method)\n        assert_array_almost_equal(samples[..., 0], samples[..., 1], decimal=6)\n    else:\n        assert_raises(\n            LinAlgError, random.multivariate_normal, mean, cov, method=""cholesky""\n        )\n\n    cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)\n    with suppress_warnings() as sup:\n        random.multivariate_normal(mean, cov, method=method)\n        w = sup.record(RuntimeWarning)\n        assert len(w) == 0\n\n    mu = np.zeros(2)\n    cov = np.eye(2)\n    assert random.multivariate_normal(mu, cov, size=3).shape == (3, 2)\n    assert_raises(\n        ValueError, random.multivariate_normal, mean, cov, check_valid=""other""\n    )\n    assert_raises(ValueError, random.multivariate_normal, np.zeros((2, 1, 1)), cov)\n    assert_raises(ValueError, random.multivariate_normal, mu, np.empty((3, 2)))\n    assert_raises(ValueError, random.multivariate_normal, mu, np.eye(3))\n\n\n@pytest.mark.parametrize(""method"", [""svd"", ""eigh"", ""cholesky""])\ndef test_multivariate_normal_basic_stats(seed, method):\n    random = ExtendedGenerator(MT19937(seed, mode=""sequence""))\n    n_s = 1000\n    mean = np.array([1, 2])\n    cov = np.array([[2, 1], [1, 2]])\n    s = random.multivariate_normal(mean, cov, size=(n_s,), method=method)\n    s_center = s - mean\n    cov_emp = (s_center.T @ s_center) / (n_s - 1)\n    # these are pretty loose and are only designed to detect major errors\n    assert np.all(np.abs(s_center.mean(-2)) < 0.1)\n    assert np.all(np.abs(cov_emp - cov) < 0.2)\n\n\n@pytest.mark.parametrize(""size"", [(4, 3, 2), (5, 4, 3, 2)])\n@pytest.mark.parametrize(""mean"", [np.zeros(2), np.zeros((3, 3))])\ndef test_multivariate_normal_bad_size(mean, size):\n    cov = np.eye(4)\n    with pytest.raises(ValueError):\n        random.multivariate_normal(mean, cov)\n    mean = np.zeros((2, 3, 4))\n    with pytest.raises(ValueError):\n        random.multivariate_normal(mean, cov, size=size)\n\n    with pytest.raises(ValueError):\n        random.multivariate_normal(0, [[1]], size=size)\n    with pytest.raises(ValueError):\n        random.multivariate_normal([0], [1], size=size)\n\n\ndef test_multivariate_normal(seed):\n    random.bit_generator.seed(seed)\n    mean = (0.123456789, 10)\n    cov = [[1, 0], [0, 1]]\n    size = (3, 2)\n    actual = random.multivariate_normal(mean, cov, size)\n    desired = np.array(\n        [\n            [\n                [-3.34929721161096100, 9.891061435770858],\n                [-0.12250896439641100, 9.295898449738300],\n            ],\n            [\n                [0.48355927611635563, 10.127832101772366],\n                [3.11093021424924300, 10.283109168794352],\n            ],\n            [\n                [-0.20332082341774727, 9.868532121697195],\n                [-1.33806889550667330, 9.813657233804179],\n            ],\n        ]\n    )\n\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    # Check for default size, was raising deprecation warning\n    actual = random.multivariate_normal(mean, cov)\n    desired = np.array([-1.097443117192574, 10.535787051184261])\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    # Check that non positive-semidefinite covariance warns with\n    # RuntimeWarning\n    mean = [0, 0]\n    cov = [[1, 2], [2, 1]]\n    assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)\n\n    # and that it doesn""t warn with RuntimeWarning check_valid=""ignore""\n    assert_no_warnings(random.multivariate_normal, mean, cov, check_valid=""ignore"")\n\n    # and that it raises with RuntimeWarning check_valid=""raises""\n    assert_raises(\n        ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n    )\n\n    cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)\n    with suppress_warnings() as sup:\n        random.multivariate_normal(mean, cov)\n        w = sup.record(RuntimeWarning)\n        assert len(w) == 0\n\n    mu = np.zeros(2)\n    cov = np.eye(2)\n    assert_raises(\n        ValueError, random.multivariate_normal, mean, cov, check_valid=""other""\n    )\n    assert_raises(ValueError, random.multivariate_normal, np.zeros((2, 1, 1)), cov)\n    assert_raises(ValueError, random.multivariate_normal, mu, np.empty((3, 2)))\n    assert_raises(ValueError, random.multivariate_normal, mu, np.eye(3))\n\n\ndef test_complex_normal(seed):\n    random.bit_generator.seed(seed)\n    actual = random.complex_normal(loc=1.0, gamma=1.0, relation=0.5, size=(3, 2))\n    desired = np.array(\n        [\n            [\n                -2.007493185623132 - 0.05446928211457126j,\n                0.7869874090977291 - 0.35205077513085050j,\n            ],\n            [\n                1.3118579018087224 + 0.06391605088618339j,\n                3.5872278793967554 + 0.14155458439717636j,\n            ],\n            [\n                0.7170022862582056 - 0.06573393915140235j,\n                -0.26571837106621987 - 0.0931713830979103j,\n            ],\n        ]\n    )\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    random.bit_generator.seed(seed)\n    actual = random.complex_normal(loc=0, gamma=1.0, relation=0.5, size=3)\n    assert_array_almost_equal(actual, desired.flat[:3] - 1.0, decimal=15)\n\n    random.bit_generator.seed(seed)\n    actual = random.complex_normal(loc=2.0, gamma=1.0, relation=0.5)\n    assert_array_almost_equal(actual, 1.0 + desired[0, 0], decimal=15)\n\n\ndef test_complex_normal_invalid():\n    assert_raises(ValueError, random.complex_normal, gamma=1 + 0.5j)\n    assert_raises(ValueError, random.complex_normal, relation=2)\n    assert_raises(ValueError, random.complex_normal, relation=-3)\n    assert_raises(ValueError, random.complex_normal, relation=10j)\n\n    assert_raises(ValueError, random.complex_normal, gamma=[1 + 0.5j])\n    assert_raises(ValueError, random.complex_normal, relation=[2])\n    assert_raises(ValueError, random.complex_normal, relation=[-3])\n    assert_raises(ValueError, random.complex_normal, relation=[10j])\n\n\ndef test_random_uintegers():\n    assert len(random.uintegers(10)) == 10\n    assert len(random.uintegers(10, bits=32)) == 10\n    assert isinstance(random.uintegers(), int)\n    assert isinstance(random.uintegers(bits=32), int)\n    with pytest.raises(ValueError):\n        with pytest.deprecated_call():\n            random.uintegers(bits=128)\n\n\ndef test_str_repr():\n    assert ""ExtendedGenerator"" in str(random)\n    assert ""ExtendedGenerator"" in repr(random)\n    assert ""MT19937"" in str(random)\n\n\ndef test_pickle_and_copy(seed):\n    gen = ExtendedGenerator(MT19937(seed, mode=""legacy""))\n    reloaded = pickle.loads(pickle.dumps(gen))\n    assert isinstance(reloaded, ExtendedGenerator)\n    copied = copy.deepcopy(gen)\n    gen_rv = gen.uintegers(10, bits=64)\n    reloaded_rv = reloaded.uintegers(10, bits=64)\n    copied_rv = copied.uintegers(10, bits=64)\n    assert_equal(gen_rv, reloaded_rv)\n    assert_equal(gen_rv, copied_rv)\n\n\ndef test_set_get_state(seed):\n    state = _mt19937.state\n    gen = ExtendedGenerator(MT19937(seed, mode=""legacy""))\n    gen.state = state\n    assert_equal(gen.state[""state""][""key""], state[""state""][""key""])\n    assert_equal(gen.state[""state""][""pos""], state[""state""][""pos""])\n\n\ndef test_complex_normal_size(mv_seed):\n    random = ExtendedGenerator(MT19937(mv_seed, mode=""legacy""))\n    state = random.state\n    loc = np.ones((1, 2))\n    gamma = np.ones((3, 1))\n    relation = 0.5 * np.ones((3, 2))\n    actual = random.complex_normal(loc=loc, gamma=gamma, relation=relation)\n    desired = np.array(\n        [\n            [\n                1.393937478212015 - 0.31374589731830593j,\n                0.9474905694736895 - 0.16424530802218726j,\n            ],\n            [\n                1.119247463119766 + 0.023956373851168843j,\n                0.8776366291514774 + 0.2865220655803411j,\n            ],\n            [\n                0.5515508326417458 - 0.15986016780453596j,\n                -0.6803993941303332 + 1.1782711493556892j,\n            ],\n        ]\n    )\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n    random.state = state\n    actual = random.complex_normal(loc=loc, gamma=1.0, relation=0.5, size=(3, 2))\n    assert_array_almost_equal(actual, desired, decimal=15)\n\n\ndef test_invalid_capsule():\n    class fake:\n        capsule = ""capsule""\n\n    with pytest.raises(ValueError):\n        ExtendedGenerator(fake())\n\n\ndef test_default_pcg64():\n    eg = ExtendedGenerator()\n    assert isinstance(eg.bit_generator, PCG64)\n    assert eg.bit_generator.variant == ""cm-dxsm""\n'"
randomgen/tests/test_final_release_changes.py,0,"b'import pytest\n\nfrom randomgen import (\n    DSFMT,\n    MT19937,\n    PCG32,\n    PCG64,\n    Generator,\n    Philox,\n    ThreeFry,\n    Xoroshiro128,\n    Xorshift1024,\n    Xoshiro256,\n    Xoshiro512,\n)\n\nrandom_gen = Generator()\n\nbit_generators = [\n    DSFMT,\n    MT19937,\n    PCG32,\n    PCG64,\n    Philox,\n    ThreeFry,\n    Xoroshiro128,\n    Xorshift1024,\n    Xoshiro256,\n    Xoshiro512,\n]\n\n\n@pytest.fixture(scope=""module"", params=bit_generators)\ndef bit_generator(request):\n    return request.param\n\n\n@pytest.fixture(scope=""module"", params=[True, False])\ndef endpoint(request):\n    return request.param\n\n\ndef test_random_sample_deprecated():\n    with pytest.deprecated_call():\n        random_gen.random_sample()\n\n\ndef test_randint_deprecated():\n    with pytest.deprecated_call():\n        random_gen.randint(10)\n\n\ndef test_rand_deprecated():\n    with pytest.deprecated_call():\n        random_gen.rand(10)\n\n\ndef test_randn_deprecated():\n    with pytest.deprecated_call():\n        random_gen.randn(10)\n\n\ndef test_generator_raises(bit_generator):\n    bg = bit_generator(mode=""sequence"")\n    with pytest.raises(NotImplementedError):\n        bg.generator\n\n\ndef test_integers_closed():\n    with pytest.deprecated_call():\n        random_gen.integers(0, 10, closed=True)\n    with pytest.deprecated_call():\n        random_gen.integers(0, 10, closed=False)\n\n\ndef test_integers_use_masked():\n    with pytest.deprecated_call():\n        random_gen.integers(0, 10, use_masked=True)\n\n\ndef test_integers_large_negative_value():\n    with pytest.raises(ValueError):\n        random_gen.integers(0, -(2 ** 65), endpoint=endpoint)\n    with pytest.raises(ValueError):\n        random_gen.integers(0, [-(2 ** 65)], endpoint=endpoint)\n'"
randomgen/tests/test_generator_117.py,21,"b'from distutils.version import LooseVersion\nfrom itertools import product\n\nimport numpy as np\nfrom numpy.testing import assert_allclose, assert_array_equal\nimport pytest\n\nfrom randomgen import Generator\n\ntry:\n    from numpy.random import Generator as NPGenerator\n    from numpy.random import PCG64\n\n    pcg = PCG64()\n    initial_state = pcg.state\n    np_gen = NPGenerator(pcg)\n    gen = Generator(pcg)\nexcept ImportError:\n    pytestmark = pytest.mark.skip\n    from randomgen import PCG64\n\n\nv1174 = LooseVersion(""1.17.4"")\nv118 = LooseVersion(""1.18"")\nNP_LT_1174 = LooseVersion(np.__version__) < v1174\nNP_LT_1174_OR_GT_118 = NP_LT_1174 or LooseVersion(np.__version__) > v118\n\npytestmark = pytest.mark.skipif(NP_LT_1174, reason=""Only test 1.17.4 to 1.18.x"")\n\n\ndef positive_param():\n    base = Generator(PCG64())\n    return [\n        base.chisquare(10),\n        base.chisquare(10, (5, 1, 3)),\n        base.chisquare(10, (6, 5, 4, 3)),\n    ]\n\n\ndef positive(num_args):\n    args = list(product(*[positive_param() for _ in range(num_args)]))\n\n    def param_generator():\n        return args\n\n    return param_generator\n\n\ndef int_prob():\n    base = Generator(PCG64())\n    return (\n        [100, 0.5],\n        [100, 0.5, (6, 5, 4, 3)],\n        [base.integers(10, 100, size=(10, 2)), 0.3],\n        [10, base.random((20, 2, 2))],\n        [base.integers(10, 100, size=(5, 4, 3)), base.random(3)],\n    )\n\n\ndef prob():\n    base = Generator(PCG64())\n    return (\n        [0.5],\n        [0.5, (6, 5, 4, 3)],\n        [0.3],\n        [base.random((20, 2, 2))],\n        [base.random(3)],\n    )\n\n\ndef length():\n    return [(100,), (2500,)]\n\n\ndef input_0():\n    return (tuple([]), (5,), ((5, 4, 3),))\n\n\ndef loc_scale():\n    return positive(2)()\n\n\ndef above_1():\n    return [(1 + val,) for val in positive_param()]\n\n\ndef triangular():\n    out = product(*[positive_param() for _ in range(3)])\n    out = [(lft, lft + mid, lft + mid + rgt) for lft, mid, rgt in out]\n    return out\n\n\ndef uniform():\n    low = positive_param()\n    high = positive_param()\n    scale = positive_param()\n    return [\n        (lo / lo + hi + sc, (lo + hi) / (lo + hi + sc))\n        for lo, hi, sc in zip(low, high, scale)\n    ]\n\n\ndef integers():\n    dtypes = [\n        np.int8,\n        np.int16,\n        np.int32,\n        np.int64,\n        np.uint8,\n        np.uint16,\n        np.uint32,\n        np.uint64,\n    ]\n    base = Generator(PCG64())\n    shape = tuple(base.integers(5, 10, size=2))\n    configs = []\n\n    for dt in dtypes:\n        s1 = np.ones(shape, dtype=dt)\n        s2 = np.ones((1,) + shape, dtype=dt)\n        lo = np.iinfo(dt).min\n        hi = np.iinfo(dt).max\n        configs.extend(\n            [\n                (0, np.iinfo(dt).max, None, dt),\n                (lo, hi // 2, None, dt),\n                (lo, hi, (10, 2), dt),\n                (lo // 2 * s1, hi // 2 * s2, None, dt),\n            ]\n        )\n    return configs\n\n\ndef dirichlet():\n    base = Generator(PCG64())\n    probs = base.random(10)\n    probs = probs / probs.sum()\n    return [(probs,), (probs, (3, 4, 5))]\n\n\ndef hypergeometric():\n    base = Generator(PCG64())\n    good = [10, base.integers(10, 100, size=(3, 4))]\n    bad = [10, base.integers(10, 100, size=(1, 4))]\n    out = []\n    for g, b in product(good, bad):\n        nsample = g + b // 2\n        if isinstance(nsample, int):\n            nsample = max(nsample, 1)\n        else:\n            nsample.flat[nsample.flat < 1] = 1\n        out.append((g, b, nsample))\n    return out\n\n\ndef multinomial():\n    base = Generator(PCG64())\n    probs = base.random(10)\n    probs /= probs.sum()\n    return (10, probs), (base.integers(10, 100, size=(3, 4)), probs)\n\n\ndistributions = {\n    ""beta"": positive(2),\n    ""binomial"": int_prob,\n    ""bytes"": length,\n    ""chisquare"": positive(1),\n    ""dirichlet"": dirichlet,\n    ""exponential"": positive(1),\n    ""f"": positive(2),\n    ""gamma"": positive(2),\n    ""geometric"": prob,\n    ""gumbel"": positive(2),\n    ""laplace"": loc_scale,\n    ""logistic"": loc_scale,\n    ""lognormal"": loc_scale,\n    ""logseries"": prob,\n    ""multinomial"": multinomial,\n    ""multivariate_normal"": """",\n    ""negative_binomial"": int_prob,\n    ""noncentral_chisquare"": positive(2),\n    ""noncentral_f"": positive(3),\n    ""normal"": loc_scale,\n    ""pareto"": positive(1),\n    ""poisson"": positive(1),\n    ""power"": positive(1),\n    ""random"": input_0,\n    ""rayleigh"": positive(1),\n    ""standard_cauchy"": input_0,\n    ""standard_exponential"": input_0,\n    ""standard_gamma"": positive(1),\n    ""standard_normal"": input_0,\n    ""standard_t"": positive(1),\n    ""triangular"": triangular,\n    ""uniform"": uniform,\n    ""vonmises"": loc_scale,\n    ""wald"": positive(2),\n    ""weibull"": positive(1),\n    ""zipf"": above_1,\n}\n\ntests = []\nids = []\nfor key in distributions:\n    if not distributions[key]:\n        continue\n    params = distributions[key]()\n    for i, param in enumerate(params):\n        tests.append((key, param))\n        ids.append(key + ""-config-{0}"".format(i))\n\n\n@pytest.mark.parametrize(""distribution, args"", tests, ids=ids)\ndef test_equivalence(distribution, args):\n    np_gen.bit_generator.state = initial_state\n    np_rvs = getattr(np_gen, distribution)\n    rvs = getattr(gen, distribution)\n    expected = np_rvs(*args)\n\n    gen.bit_generator.state = initial_state\n    result = rvs(*args)\n    if isinstance(result, (np.ndarray, float)):\n        dtype = getattr(result, ""dtype"", None)\n        if isinstance(result, float) or dtype in (np.float32, np.float64):\n            assert_allclose(result, expected)\n        else:\n            assert_array_equal(result, expected)\n    else:\n        assert result == expected\n\n\ndef test_shuffle():\n    np_gen.bit_generator.state = initial_state\n    expected = np.arange(100)\n    np_gen.shuffle(expected)\n\n    gen.bit_generator.state = initial_state\n    result = np.arange(100)\n    gen.shuffle(result)\n    assert_array_equal(result, expected)\n\n\ndef test_permutation():\n    np_gen.bit_generator.state = initial_state\n    expected = np_gen.permutation(100)\n\n    gen.bit_generator.state = initial_state\n    result = gen.permutation(100)\n    assert_array_equal(result, expected)\n\n\n@pytest.mark.parametrize(""replace"", [True, False])\ndef test_choice_with_p(replace):\n    x = np.arange(100)\n    np_gen.bit_generator.state = initial_state\n    p = (x + 1) / (x + 1).sum()\n    expected = np_gen.choice(x, size=10, replace=replace, p=p)\n\n    gen.bit_generator.state = initial_state\n    result = gen.choice(x, size=10, replace=replace, p=p)\n    assert_array_equal(result, expected)\n\n\n@pytest.mark.parametrize(""replace"", [True, False])\ndef test_choice(replace):\n    np_gen.bit_generator.state = initial_state\n    x = np.arange(100)\n    expected = np_gen.choice(x, size=10, replace=replace)\n\n    gen.bit_generator.state = initial_state\n    result = gen.choice(x, size=10, replace=replace)\n    assert_array_equal(result, expected)\n\n\nconfigs = integers()\nids = [list(map(str, c)) for c in configs]\n\n\n@pytest.mark.skipif(NP_LT_1174, reason=""Changes to lemire generators"")\n@pytest.mark.parametrize(""args"", configs)\ndef test_integers(args):\n    np_gen.bit_generator.state = initial_state\n    expected = np_gen.integers(*args)\n\n    gen.bit_generator.state = initial_state\n    result = gen.integers(*args, use_masked=False)\n    assert_array_equal(result, expected)\n\n\n@pytest.mark.parametrize(""args"", hypergeometric())\ndef test_hypergeometric(args):\n    np_gen.bit_generator.state = initial_state\n    expected = np_gen.hypergeometric(*args)\n\n    gen.bit_generator.state = initial_state\n    result = gen.hypergeometric(*args)\n    assert_allclose(result, expected)\n'"
randomgen/tests/test_generator_mt19937.py,320,"b'from distutils.version import LooseVersion\nimport hashlib\nimport sys\nimport warnings\n\nimport numpy as np\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import (\n    assert_,\n    assert_array_almost_equal,\n    assert_array_equal,\n    assert_equal,\n    assert_no_warnings,\n    assert_raises,\n    assert_warns,\n)\nimport pytest\n\nfrom randomgen import MT19937, Generator\nfrom randomgen._testing import suppress_warnings\nfrom randomgen.tests.test_direct import assert_state_equal\n\nrandom = Generator(MT19937(mode=""legacy""))\n\nNP_LT_118 = LooseVersion(np.__version__) < LooseVersion(""1.18.0"")\n\nJUMP_TEST_DATA = {\n    (""_jump_tester"", (0,), 10): {\n        ""initial"": {""key_md5"": ""64eaf265d2203179fb5ffb73380cd589"", ""pos"": 9},\n        ""jumped"": {""key_md5"": ""14e9a7d1e247f0f8565b77784c9a6b83"", ""pos"": 601},\n    },\n    (""_jump_tester"", (384908324,), 312): {\n        ""initial"": {""key_md5"": ""e99708a47b82ff51a2c7b0625b81afb5"", ""pos"": 311},\n        ""jumped"": {""key_md5"": ""8bfd5e1ab46befd06cc54146541f1ce8"", ""pos"": 279},\n    },\n    (""_jump_tester"", (839438204, 980239840, 859048019, 821), 511): {\n        ""initial"": {""key_md5"": ""9fcd6280df9199785e17e93162ce283c"", ""pos"": 510},\n        ""jumped"": {""key_md5"": ""f8ac8f010bd3eabc8afbc8b690220177"", ""pos"": 478},\n    },\n    (""jumped"", (0,), 10): {\n        ""initial"": {""key_md5"": ""64eaf265d2203179fb5ffb73380cd589"", ""pos"": 9},\n        ""jumped"": {""key_md5"": ""8cb7b061136efceef5217a9ce2cc9a5a"", ""pos"": 598},\n    },\n    (""jumped"", (384908324,), 312): {\n        ""initial"": {""key_md5"": ""e99708a47b82ff51a2c7b0625b81afb5"", ""pos"": 311},\n        ""jumped"": {""key_md5"": ""2ecdbfc47a895b253e6e19ccb2e74b90"", ""pos"": 276},\n    },\n    (""jumped"", (839438204, 980239840, 859048019, 821), 511): {\n        ""initial"": {""key_md5"": ""9fcd6280df9199785e17e93162ce283c"", ""pos"": 510},\n        ""jumped"": {""key_md5"": ""433b85229f2ed853cde06cd872818305"", ""pos"": 475},\n    },\n}\n\n\n@pytest.fixture(scope=""module"", params=[True, False])\ndef endpoint(request):\n    return request.param\n\n\nclass TestSeed(object):\n    def test_scalar(self):\n        s = Generator(MT19937(0, mode=""legacy""))\n        assert_equal(s.integers(1000), 684)\n        s = Generator(MT19937(4294967295, mode=""legacy""))\n        assert_equal(s.integers(1000), 419)\n\n    def test_array(self):\n        s = Generator(MT19937(range(10), mode=""legacy""))\n        assert_equal(s.integers(1000), 468)\n        s = Generator(MT19937(np.arange(10), mode=""legacy""))\n        assert_equal(s.integers(1000), 468)\n        s = Generator(MT19937([0], mode=""legacy""))\n        assert_equal(s.integers(1000), 973)\n        s = Generator(MT19937([4294967295], mode=""legacy""))\n        assert_equal(s.integers(1000), 265)\n\n    def test_invalid_scalar(self):\n        # seed must be an unsigned 32 bit integer\n        assert_raises(TypeError, MT19937, -0.5, mode=""legacy"")\n        assert_raises(ValueError, MT19937, -1, mode=""legacy"")\n\n    def test_invalid_array(self):\n        # seed must be an unsigned 32 bit integer\n        assert_raises(TypeError, MT19937, [-0.5], mode=""legacy"")\n        assert_raises(ValueError, MT19937, [-1], mode=""legacy"")\n        assert_raises(ValueError, MT19937, [4294967296], mode=""legacy"")\n        assert_raises(ValueError, MT19937, [1, 2, 4294967296], mode=""legacy"")\n        assert_raises(ValueError, MT19937, [1, -2, 4294967296], mode=""legacy"")\n\n    def test_noninstantized_bitgen(self):\n        assert_raises(ValueError, Generator, MT19937)\n\n\nclass TestBinomial(object):\n    def test_n_zero(self):\n        # Tests the corner case of n == 0 for the binomial distribution.\n        # binomial(0, p) should be zero for any p in [0, 1].\n        # This test addresses issue #3480.\n        zeros = np.zeros(2, dtype=""int"")\n        for p in [0, 0.5, 1]:\n            assert_(random.binomial(0, p) == 0)\n            assert_array_equal(random.binomial(zeros, p), zeros)\n\n    def test_p_is_nan(self):\n        # Issue #4571.\n        assert_raises(ValueError, random.binomial, 1, np.nan)\n\n\nclass TestMultinomial(object):\n    def test_basic(self):\n        random.multinomial(100, [0.2, 0.8])\n\n    def test_zero_probability(self):\n        random.multinomial(100, [0.2, 0.8, 0.0, 0.0, 0.0])\n\n    def test_int_negative_interval(self):\n        assert_(-5 <= random.integers(-5, -1) < -1)\n        x = random.integers(-5, -1, 5)\n        assert_(np.all(-5 <= x))\n        assert_(np.all(x < -1))\n\n    def test_size(self):\n        # gh-3173\n        p = [0.5, 0.5]\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, [2, 2]).shape, (2, 2, 2))\n        assert_equal(random.multinomial(1, p, (2, 2)).shape, (2, 2, 2))\n        assert_equal(random.multinomial(1, p, np.array((2, 2))).shape, (2, 2, 2))\n\n        assert_raises(TypeError, random.multinomial, 1, p, float(1))\n\n    def test_invalid_prob(self):\n        assert_raises(ValueError, random.multinomial, 100, [1.1, 0.2])\n        assert_raises(ValueError, random.multinomial, 100, [-0.1, 0.9])\n\n    def test_invalid_n(self):\n        assert_raises(ValueError, random.multinomial, -1, [0.8, 0.2])\n        assert_raises(ValueError, random.multinomial, [-1] * 10, [0.8, 0.2])\n\n    def test_p_noncontiguous(self):\n        p = np.arange(15.0)\n        p /= np.sum(p[1::3])\n        pvals = p[1::3]\n        random.seed(1432985819)\n        non_contig = random.multinomial(100, pvals=pvals)\n        random.seed(1432985819)\n        contig = random.multinomial(100, pvals=np.ascontiguousarray(pvals))\n        assert_array_equal(non_contig, contig)\n\n    def test_large_p(self):\n        with pytest.raises(ValueError, match=r""sum\\(pvals""):\n            random.multinomial(100, np.array([0.7, 0.6, 0.5, 0]))\n\n\nclass TestSetState(object):\n    def setup(self):\n        self.seed = 1234567890\n        self.rg = Generator(MT19937(self.seed, mode=""legacy""))\n        self.bit_generator = self.rg.bit_generator\n        self.state = self.bit_generator.state\n        self.legacy_state = (\n            self.state[""bit_generator""],\n            self.state[""state""][""key""],\n            self.state[""state""][""pos""],\n        )\n\n    def test_basic(self):\n        with pytest.deprecated_call():\n            old = self.rg.tomaxint(16)\n        self.bit_generator.state = self.state\n        with pytest.deprecated_call():\n            new = self.rg.tomaxint(16)\n        assert_(np.all(old == new))\n\n    def test_gaussian_reset(self):\n        # Make sure the cached every-other-Gaussian is reset.\n        old = self.rg.standard_normal(size=3)\n        self.bit_generator.state = self.state\n        new = self.rg.standard_normal(size=3)\n        assert_(np.all(old == new))\n\n    def test_gaussian_reset_in_media_res(self):\n        # When the state is saved with a cached Gaussian, make sure the\n        # cached Gaussian is restored.\n\n        self.rg.standard_normal()\n        state = self.bit_generator.state\n        old = self.rg.standard_normal(size=3)\n        self.bit_generator.state = state\n        new = self.rg.standard_normal(size=3)\n        assert_(np.all(old == new))\n\n    def test_negative_binomial(self):\n        # Ensure that the negative binomial results take floating point\n        # arguments without truncation.\n        self.rg.negative_binomial(0.5, 0.5)\n\n\nclass TestIntegers(object):\n    rfunc = random.integers\n\n    # valid integer/boolean types\n    itype = [\n        bool,\n        np.int8,\n        np.uint8,\n        np.int16,\n        np.uint16,\n        np.int32,\n        np.uint32,\n        np.int64,\n        np.uint64,\n    ]\n\n    def test_unsupported_type(self, endpoint):\n        assert_raises(TypeError, self.rfunc, 1, endpoint=endpoint, dtype=float)\n\n    def test_bounds_checking(self, endpoint):\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n            assert_raises(\n                ValueError, self.rfunc, lbnd - 1, ubnd, endpoint=endpoint, dtype=dt\n            )\n            assert_raises(\n                ValueError, self.rfunc, lbnd, ubnd + 1, endpoint=endpoint, dtype=dt\n            )\n            assert_raises(\n                ValueError, self.rfunc, ubnd, lbnd, endpoint=endpoint, dtype=dt\n            )\n            assert_raises(ValueError, self.rfunc, 1, 0, endpoint=endpoint, dtype=dt)\n\n            assert_raises(\n                ValueError, self.rfunc, [lbnd - 1], ubnd, endpoint=endpoint, dtype=dt\n            )\n            assert_raises(\n                ValueError, self.rfunc, [lbnd], [ubnd + 1], endpoint=endpoint, dtype=dt\n            )\n            assert_raises(\n                ValueError, self.rfunc, [ubnd], [lbnd], endpoint=endpoint, dtype=dt\n            )\n            assert_raises(ValueError, self.rfunc, 1, [0], endpoint=endpoint, dtype=dt)\n\n    def test_bounds_checking_array(self, endpoint):\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + (not endpoint)\n\n            assert_raises(\n                ValueError,\n                self.rfunc,\n                [lbnd - 1] * 2,\n                [ubnd] * 2,\n                endpoint=endpoint,\n                dtype=dt,\n            )\n            assert_raises(\n                ValueError,\n                self.rfunc,\n                [lbnd] * 2,\n                [ubnd + 1] * 2,\n                endpoint=endpoint,\n                dtype=dt,\n            )\n            assert_raises(\n                ValueError, self.rfunc, ubnd, [lbnd] * 2, endpoint=endpoint, dtype=dt\n            )\n            assert_raises(\n                ValueError, self.rfunc, [1] * 2, 0, endpoint=endpoint, dtype=dt\n            )\n\n    def test_rng_zero_and_extremes(self, endpoint):\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n            is_open = not endpoint\n\n            tgt = ubnd - 1\n            assert_equal(\n                self.rfunc(tgt, tgt + is_open, size=1000, endpoint=endpoint, dtype=dt),\n                tgt,\n            )\n            assert_equal(\n                self.rfunc(\n                    [tgt], tgt + is_open, size=1000, endpoint=endpoint, dtype=dt\n                ),\n                tgt,\n            )\n\n            tgt = lbnd\n            assert_equal(\n                self.rfunc(tgt, tgt + is_open, size=1000, endpoint=endpoint, dtype=dt),\n                tgt,\n            )\n            assert_equal(\n                self.rfunc(\n                    tgt, [tgt + is_open], size=1000, endpoint=endpoint, dtype=dt\n                ),\n                tgt,\n            )\n\n            tgt = (lbnd + ubnd) // 2\n            assert_equal(\n                self.rfunc(tgt, tgt + is_open, size=1000, endpoint=endpoint, dtype=dt),\n                tgt,\n            )\n            assert_equal(\n                self.rfunc(\n                    [tgt], [tgt + is_open], size=1000, endpoint=endpoint, dtype=dt\n                ),\n                tgt,\n            )\n\n    def test_rng_zero_and_extremes_array(self, endpoint):\n        size = 1000\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            tgt = ubnd - 1\n            assert_equal(self.rfunc([tgt], [tgt + 1], size=size, dtype=dt), tgt)\n            assert_equal(self.rfunc([tgt] * size, [tgt + 1] * size, dtype=dt), tgt)\n            assert_equal(\n                self.rfunc([tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt\n            )\n\n            tgt = lbnd\n            assert_equal(self.rfunc([tgt], [tgt + 1], size=size, dtype=dt), tgt)\n            assert_equal(self.rfunc([tgt] * size, [tgt + 1] * size, dtype=dt), tgt)\n            assert_equal(\n                self.rfunc([tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt\n            )\n\n            tgt = (lbnd + ubnd) // 2\n            assert_equal(self.rfunc([tgt], [tgt + 1], size=size, dtype=dt), tgt)\n            assert_equal(self.rfunc([tgt] * size, [tgt + 1] * size, dtype=dt), tgt)\n            assert_equal(\n                self.rfunc([tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt\n            )\n\n    def test_full_range(self, endpoint):\n        # Test for ticket #1690\n\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            try:\n                self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)\n            except Exception as e:\n                raise AssertionError(\n                    ""No error should have been raised, ""\n                    ""but one was with the following ""\n                    ""message:\\n\\n%s"" % str(e)\n                )\n\n    def test_full_range_array(self, endpoint):\n        # Test for ticket #1690\n\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            try:\n                self.rfunc([lbnd] * 2, [ubnd], endpoint=endpoint, dtype=dt)\n            except Exception as e:\n                raise AssertionError(\n                    ""No error should have been raised, ""\n                    ""but one was with the following ""\n                    ""message:\\n\\n%s"" % str(e)\n                )\n\n    def test_in_bounds_fuzz(self, endpoint):\n        # Don""t use fixed seed\n        random.bit_generator.seed()\n\n        for dt in self.itype[1:]:\n            for ubnd in [4, 8, 16]:\n                vals = self.rfunc(\n                    2, ubnd - endpoint, size=2 ** 16, endpoint=endpoint, dtype=dt\n                )\n                assert_(vals.max() < ubnd)\n                assert_(vals.min() >= 2)\n\n        vals = self.rfunc(0, 2 - endpoint, size=2 ** 16, endpoint=endpoint, dtype=bool)\n        assert_(vals.max() < 2)\n        assert_(vals.min() >= 0)\n\n    def test_scalar_array_equiv(self, endpoint):\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            size = 1000\n            random.bit_generator.seed(1234)\n            scalar = self.rfunc(lbnd, ubnd, size=size, endpoint=endpoint, dtype=dt)\n\n            random.bit_generator.seed(1234)\n            scalar_array = self.rfunc(\n                [lbnd], [ubnd], size=size, endpoint=endpoint, dtype=dt\n            )\n\n            random.bit_generator.seed(1234)\n            array = self.rfunc(\n                [lbnd] * size, [ubnd] * size, size=size, endpoint=endpoint, dtype=dt\n            )\n            assert_array_equal(scalar, scalar_array)\n            assert_array_equal(scalar, array)\n\n    def test_repeatability(self, endpoint):\n        import hashlib\n\n        # We use a md5 hash of generated sequences of 1000 samples\n        # in the range [0, 6) for all but bool, where the range\n        # is [0, 2). Hashes are for little endian numbers.\n        tgt = {\n            ""bool"": ""7dd3170d7aa461d201a65f8bcf3944b0"",\n            ""int16"": ""1b7741b80964bb190c50d541dca1cac1"",\n            ""int32"": ""4dc9fcc2b395577ebb51793e58ed1a05"",\n            ""int64"": ""17db902806f448331b5a758d7d2ee672"",\n            ""int8"": ""27dd30c4e08a797063dffac2490b0be6"",\n            ""uint16"": ""1b7741b80964bb190c50d541dca1cac1"",\n            ""uint32"": ""4dc9fcc2b395577ebb51793e58ed1a05"",\n            ""uint64"": ""17db902806f448331b5a758d7d2ee672"",\n            ""uint8"": ""27dd30c4e08a797063dffac2490b0be6"",\n        }\n\n        for dt in self.itype[1:]:\n            random.bit_generator.seed(1234)\n\n            # view as little endian for hash\n            if sys.byteorder == ""little"":\n                val = self.rfunc(\n                    0, 6 - endpoint, size=1000, endpoint=endpoint, dtype=dt\n                )\n            else:\n                val = self.rfunc(\n                    0, 6 - endpoint, size=1000, endpoint=endpoint, dtype=dt\n                ).byteswap()\n\n            res = hashlib.md5(val.view(np.int8)).hexdigest()\n            assert_(tgt[np.dtype(dt).name] == res)\n\n        # bools do not depend on endianness\n        random.bit_generator.seed(1234)\n        val = self.rfunc(\n            0, 2 - endpoint, size=1000, endpoint=endpoint, dtype=bool\n        ).view(np.int8)\n        res = hashlib.md5(val).hexdigest()\n        assert_(tgt[np.dtype(bool).name] == res)\n\n    def test_repeatability_broadcasting(self, endpoint):\n        for dt in self.itype:\n            lbnd = 0 if dt in (np.bool, bool, np.bool_) else np.iinfo(dt).min\n            ubnd = 2 if dt in (np.bool, bool, np.bool_) else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            # view as little endian for hash\n            random.bit_generator.seed(1234)\n            val = self.rfunc(lbnd, ubnd, size=1000, endpoint=endpoint, dtype=dt)\n\n            random.bit_generator.seed(1234)\n            val_bc = self.rfunc([lbnd] * 1000, ubnd, endpoint=endpoint, dtype=dt)\n\n            assert_array_equal(val, val_bc)\n\n            random.bit_generator.seed(1234)\n            val_bc = self.rfunc(\n                [lbnd] * 1000, [ubnd] * 1000, endpoint=endpoint, dtype=dt\n            )\n\n            assert_array_equal(val, val_bc)\n\n    def test_int64_uint64_broadcast_exceptions(self, endpoint):\n        configs = {\n            np.uint64: ((0, 2 ** 65), (-1, 2 ** 62), (10, 9), (0, 0)),\n            np.int64: (\n                (0, 2 ** 64),\n                (-(2 ** 64), 2 ** 62),\n                (10, 9),\n                (0, 0),\n                (-(2 ** 63) - 1, -(2 ** 63) - 1),\n            ),\n        }\n        for dtype in configs:\n            for config in configs[dtype]:\n                low, high = config\n                high = high - endpoint\n                low_a = np.array([[low] * 10])\n                high_a = np.array([high] * 10)\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low,\n                    high,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low_a,\n                    high,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low,\n                    high_a,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low_a,\n                    high_a,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n\n                low_o = np.array([[low] * 10], dtype=np.object)\n                high_o = np.array([high] * 10, dtype=np.object)\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low_o,\n                    high,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low,\n                    high_o,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n                assert_raises(\n                    ValueError,\n                    random.integers,\n                    low_o,\n                    high_o,\n                    endpoint=endpoint,\n                    dtype=dtype,\n                )\n\n    def test_int64_uint64_corner_case(self, endpoint):\n        # When stored in Numpy arrays, `lbnd` is casted\n        # as np.int64, and `ubnd` is casted as np.uint64.\n        # Checking whether `lbnd` >= `ubnd` used to be\n        # done solely via direct comparison, which is incorrect\n        # because when Numpy tries to compare both numbers,\n        # it casts both to np.float64 because there is\n        # no integer superset of np.int64 and np.uint64. However,\n        # `ubnd` is too large to be represented in np.float64,\n        # causing it be round down to np.iinfo(np.int64).max,\n        # leading to a ValueError because `lbnd` now equals\n        # the new `ubnd`.\n\n        dt = np.int64\n        tgt = np.iinfo(np.int64).max\n        lbnd = np.int64(np.iinfo(np.int64).max)\n        ubnd = np.uint64(np.iinfo(np.int64).max + 1 - endpoint)\n\n        # None of these function calls should\n        # generate a ValueError now.\n        actual = random.integers(lbnd, ubnd, endpoint=endpoint, dtype=dt)\n        assert_equal(actual, tgt)\n\n    def test_respect_dtype_singleton(self, endpoint):\n        # See gh-7203\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n            dt = np.bool_ if dt is bool else dt\n\n            sample = self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)\n            assert_equal(sample.dtype, dt)\n\n        for dt in (bool, int, np.long):\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n\n            # gh-7284: Ensure that we get Python data types\n            sample = self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)\n            assert not hasattr(sample, ""dtype"")\n            assert_equal(type(sample), dt)\n\n    def test_respect_dtype_array(self, endpoint):\n        # See gh-7203\n        for dt in self.itype:\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n            ubnd = ubnd - 1 if endpoint else ubnd\n            dt = np.bool_ if dt is bool else dt\n\n            sample = self.rfunc([lbnd], [ubnd], endpoint=endpoint, dtype=dt)\n            assert_equal(sample.dtype, dt)\n            sample = self.rfunc([lbnd] * 2, [ubnd] * 2, endpoint=endpoint, dtype=dt)\n            assert_equal(sample.dtype, dt)\n\n    def test_zero_size(self, endpoint):\n        # See gh-7203\n        for dt in self.itype:\n            sample = self.rfunc(0, 0, (3, 0, 4), endpoint=endpoint, dtype=dt)\n            assert sample.shape == (3, 0, 4)\n            assert sample.dtype == dt\n            assert self.rfunc(0, -10, 0, endpoint=endpoint, dtype=dt).shape == (0,)\n            assert_equal(random.integers(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))\n            assert_equal(random.integers(0, -10, size=0).shape, (0,))\n            assert_equal(random.integers(10, 10, size=0).shape, (0,))\n\n    def test_warns_byteorder(self):\n        other_byteord_dt = ""<i4"" if sys.byteorder == ""big"" else "">i4""\n        with pytest.warns(FutureWarning):\n            random.integers(0, 200, size=10, dtype=other_byteord_dt)\n\n\nclass TestRandomDist(object):\n    # Make sure the random distribution returns the correct value for a\n    # given seed\n\n    def setup(self):\n        self.seed = 1234567890\n\n    def test_rand(self):\n        random.bit_generator.seed(self.seed)\n        with pytest.deprecated_call():\n            actual = random.rand(3, 2)\n        desired = np.array(\n            [\n                [0.61879477158567997, 0.59162362775974664],\n                [0.88868358904449662, 0.89165480011560816],\n                [0.4575674820298663, 0.7781880808593471],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_rand_singleton(self):\n        random.bit_generator.seed(self.seed)\n        with pytest.deprecated_call():\n            actual = random.rand()\n        desired = 0.61879477158567997\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_randn(self):\n        random.bit_generator.seed(self.seed)\n        with pytest.deprecated_call():\n            actual = random.randn(3, 2)\n        desired = np.array(\n            [\n                [-3.472754000610961, -0.108938564229143],\n                [-0.245965753396411, -0.704101550261701],\n                [0.360102487116356, 0.127832101772367],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.bit_generator.seed(self.seed)\n        with pytest.deprecated_call():\n            actual = random.randn()\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_integers(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.integers(-99, 99, size=(3, 2))\n        desired = np.array([[31, 3], [-52, 41], [-48, -66]])\n        assert_array_equal(actual, desired)\n\n    def test_integers_masked(self):\n        # Test masked rejection sampling algorithm to generate array of\n        # uint32 in an interval.\n        random.bit_generator.seed(self.seed)\n        with pytest.deprecated_call():\n            actual = random.integers(\n                0, 99, size=(3, 2), dtype=np.uint32, use_masked=True\n            )\n        desired = np.array([[2, 47], [12, 51], [33, 43]], dtype=np.uint32)\n        assert_array_equal(actual, desired)\n\n    def test_integers_lemire_32(self):\n        # Test lemire algorithm to generate array of uint32 in an interval.\n        random.bit_generator.seed(self.seed)\n        actual = random.integers(0, 99, size=(3, 2), dtype=np.uint32, use_masked=False)\n        desired = np.array([[61, 33], [58, 14], [87, 23]], dtype=np.uint32)\n        assert_array_equal(actual, desired)\n\n    def test_integers_lemire_64(self):\n        # Test lemire algorithm to generate array of uint64 in an interval.\n        random.bit_generator.seed(self.seed)\n        actual = random.integers(\n            0, 99 + 0xFFFFFFFFF, size=(3, 2), dtype=np.uint64, use_masked=False\n        )\n        desired = np.array(\n            [\n                [42523252834, 40656066204],\n                [61069871386, 61274051182],\n                [31443797706, 53476677934],\n            ],\n            dtype=np.uint64,\n        )\n        assert_array_equal(actual, desired)\n\n    def test_random_integers(self):\n        random.bit_generator.seed(self.seed)\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(-99, 99, size=(3, 2))\n            assert_(len(w) == 1)\n        desired = np.array([[31, 3], [-52, 41], [-48, -66]])\n        assert_array_equal(actual, desired)\n        random.bit_generator.seed(self.seed)\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(198, size=(3, 2))\n        assert_array_equal(actual, desired + 100)\n\n    def test_random_integers_max_int(self):\n        # Tests whether random_integers can generate the\n        # maximum allowed Python int that can be converted\n        # into a C long. Previous implementations of this\n        # method have thrown an OverflowError when attempting\n        # to generate this integer.\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(np.iinfo(""l"").max, np.iinfo(""l"").max)\n            assert_(len(w) == 1)\n\n        desired = np.iinfo(""l"").max\n        assert_equal(actual, desired)\n\n    def test_random_integers_deprecated(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter(""error"", DeprecationWarning)\n\n            # DeprecationWarning raised with high == None\n            assert_raises(DeprecationWarning, random.random_integers, np.iinfo(""l"").max)\n\n            # DeprecationWarning raised with high != None\n            assert_raises(\n                DeprecationWarning,\n                random.random_integers,\n                np.iinfo(""l"").max,\n                np.iinfo(""l"").max,\n            )\n\n    def test_random(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.random((3, 2))\n        desired = np.array(\n            [\n                [0.61879477158567997, 0.59162362775974664],\n                [0.88868358904449662, 0.89165480011560816],\n                [0.4575674820298663, 0.7781880808593471],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.random()\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_random_float(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.random((3, 2))\n        desired = np.array(\n            [[0.6187948, 0.5916236], [0.8886836, 0.8916548], [0.4575675, 0.7781881]]\n        )\n        assert_array_almost_equal(actual, desired, decimal=7)\n\n    def test_random_float_scalar(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.random(dtype=np.float32)\n        desired = 0.6187948\n        assert_array_almost_equal(actual, desired, decimal=7)\n\n    def test_random_unsupported_type(self):\n        assert_raises(TypeError, random.random, dtype=""int32"")\n\n    def test_choice_uniform_replace(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice(4, 4)\n        desired = np.array([2, 1, 2, 0], dtype=np.int64)\n        assert_array_equal(actual, desired)\n\n    def test_choice_nonuniform_replace(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice(4, 4, p=[0.4, 0.4, 0.1, 0.1])\n        desired = np.array([1, 1, 2, 2], dtype=np.int64)\n        assert_array_equal(actual, desired)\n\n    def test_choice_uniform_noreplace(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice(4, 3, replace=False)\n        desired = np.array([3, 2, 1], dtype=np.int64)\n        assert_array_equal(actual, desired)\n\n    def test_choice_nonuniform_noreplace(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice(4, 3, replace=False, p=[0.1, 0.3, 0.5, 0.1])\n        desired = np.array([2, 3, 1], dtype=np.int64)\n        assert_array_equal(actual, desired)\n\n    def test_choice_noninteger(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice([""a"", ""b"", ""c"", ""d""], 4)\n        desired = np.array([""c"", ""b"", ""c"", ""a""])\n        assert_array_equal(actual, desired)\n\n    def test_choice_multidimensional_default_axis(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice([[0, 1], [2, 3], [4, 5], [6, 7]], 3)\n        desired = np.array([[4, 5], [2, 3], [4, 5]])\n        assert_array_equal(actual, desired)\n\n    def test_choice_multidimensional_custom_axis(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.choice([[0, 1], [2, 3], [4, 5], [6, 7]], 1, axis=1)\n        desired = np.array([[1], [3], [5], [7]])\n        assert_array_equal(actual, desired)\n\n    def test_choice_exceptions(self):\n        sample = random.choice\n        assert_raises(ValueError, sample, -1, 3)\n        assert_raises(ValueError, sample, 3.0, 3)\n        assert_raises(ValueError, sample, [], 3)\n        assert_raises(\n            ValueError, sample, [1, 2, 3, 4], 3, p=[[0.25, 0.25], [0.25, 0.25]]\n        )\n        assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4, 0.2])\n        assert_raises(ValueError, sample, [1, 2], 3, p=[1.1, -0.1])\n        assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4])\n        assert_raises(ValueError, sample, [1, 2, 3], 4, replace=False)\n        # gh-13087\n        assert_raises(ValueError, sample, [1, 2, 3], -2, replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], (-1,), replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], (-1, 1), replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], 2, replace=False, p=[1, 0, 0])\n\n    def test_choice_return_shape(self):\n        p = [0.1, 0.9]\n        # Check scalar\n        assert_(np.isscalar(random.choice(2, replace=True)))\n        assert_(np.isscalar(random.choice(2, replace=False)))\n        assert_(np.isscalar(random.choice(2, replace=True, p=p)))\n        assert_(np.isscalar(random.choice(2, replace=False, p=p)))\n        assert_(np.isscalar(random.choice([1, 2], replace=True)))\n        assert_(random.choice([None], replace=True) is None)\n        a = np.array([1, 2])\n        arr = np.empty(1, dtype=object)\n        arr[0] = a\n        assert_(random.choice(arr, replace=True) is a)\n\n        # Check 0-d array\n        s = tuple()\n        assert_(not np.isscalar(random.choice(2, s, replace=True)))\n        assert_(not np.isscalar(random.choice(2, s, replace=False)))\n        assert_(not np.isscalar(random.choice(2, s, replace=True, p=p)))\n        assert_(not np.isscalar(random.choice(2, s, replace=False, p=p)))\n        assert_(not np.isscalar(random.choice([1, 2], s, replace=True)))\n        assert_(random.choice([None], s, replace=True).ndim == 0)\n        a = np.array([1, 2])\n        arr = np.empty(1, dtype=object)\n        arr[0] = a\n        assert_(random.choice(arr, s, replace=True).item() is a)\n\n        # Check multi dimensional array\n        s = (2, 3)\n        p = [0.1, 0.1, 0.1, 0.1, 0.4, 0.2]\n        assert_equal(random.choice(6, s, replace=True).shape, s)\n        assert_equal(random.choice(6, s, replace=False).shape, s)\n        assert_equal(random.choice(6, s, replace=True, p=p).shape, s)\n        assert_equal(random.choice(6, s, replace=False, p=p).shape, s)\n        assert_equal(random.choice(np.arange(6), s, replace=True).shape, s)\n\n        # Check zero-size\n        assert_equal(random.integers(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))\n        assert_equal(random.integers(0, -10, size=0).shape, (0,))\n        assert_equal(random.integers(10, 10, size=0).shape, (0,))\n        assert_equal(random.choice(0, size=0).shape, (0,))\n        assert_equal(random.choice([], size=(0,)).shape, (0,))\n        assert_equal(random.choice([""a"", ""b""], size=(3, 0, 4)).shape, (3, 0, 4))\n        assert_raises(ValueError, random.choice, [], 10)\n\n    def test_choice_nan_probabilities(self):\n        a = np.array([42, 1, 2])\n        p = [None, None, None]\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.choice, a, p=p)\n\n    def test_choice_nontintiguous(self):\n        p = np.ones(10) / 5\n        p[1::2] = 3.0\n        random.seed(self.seed)\n        choice1 = random.choice(5, 3, p=p[::2])\n        random.seed(self.seed)\n        choice2 = random.choice(5, 3, p=np.ascontiguousarray(p[::2]))\n        assert_array_equal(choice1, choice2)\n\n    def test_choice_return_type(self):\n        # gh 9867\n        p = np.ones(4) / 4.0\n        actual = random.choice(4, 2)\n        assert actual.dtype == np.int64\n        actual = random.choice(4, 2, replace=False)\n        assert actual.dtype == np.int64\n        actual = random.choice(4, 2, p=p)\n        assert actual.dtype == np.int64\n        actual = random.choice(4, 2, p=p, replace=False)\n        assert actual.dtype == np.int64\n\n    def test_choice_large_sample(self):\n        import hashlib\n\n        choice_hash = ""7d65d45dea0cacb950de86582f37ff74""\n        random.bit_generator.seed(self.seed)\n        actual = random.choice(10000, 5000, replace=False)\n        if sys.byteorder != ""little"":\n            actual = actual.byteswap()\n        res = hashlib.md5(actual.view(np.int8)).hexdigest()\n        assert_(choice_hash == res)\n\n    def test_bytes(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.bytes(10)\n        desired = b""\\x82Ui\\x9e\\xff\\x97+Wf\\xa5""\n        assert_equal(actual, desired)\n\n    def test_shuffle(self):\n        # Test lists, arrays (of various dtypes), and multidimensional versions\n        # of both, c-contiguous or not:\n        for conv in [\n            lambda x: np.array([]),\n            lambda x: x,\n            lambda x: np.asarray(x).astype(np.int8),\n            lambda x: np.asarray(x).astype(np.float32),\n            lambda x: np.asarray(x).astype(np.complex64),\n            lambda x: np.asarray(x).astype(object),\n            lambda x: [(i, i) for i in x],\n            lambda x: np.asarray([[i, i] for i in x]),\n            lambda x: np.vstack([x, x]).T,\n            # gh-11442\n            lambda x: (\n                np.asarray([(i, i) for i in x], [(""a"", int), (""b"", int)]).view(\n                    np.recarray\n                )\n            ),\n            # gh-4270\n            lambda x: np.asarray(\n                [(i, i) for i in x], [(""a"", (object, (1,))), (""b"", (np.int32, (1,)))]\n            ),\n        ]:\n            random.bit_generator.seed(self.seed)\n            alist = conv([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])\n            random.shuffle(alist)\n            actual = alist\n            desired = conv([0, 1, 9, 6, 2, 4, 5, 8, 7, 3])\n            assert_array_equal(actual, desired)\n\n    def test_shuffle_masked(self):\n        # gh-3263\n        a = np.ma.masked_values(np.reshape(range(20), (5, 4)) % 3 - 1, -1)\n        b = np.ma.masked_values(np.arange(20) % 3 - 1, -1)\n        a_orig = a.copy()\n        b_orig = b.copy()\n        for _ in range(50):\n            random.shuffle(a)\n            assert_equal(sorted(a.data[~a.mask]), sorted(a_orig.data[~a_orig.mask]))\n            random.shuffle(b)\n            assert_equal(sorted(b.data[~b.mask]), sorted(b_orig.data[~b_orig.mask]))\n\n    def test_permutation(self):\n        random.bit_generator.seed(self.seed)\n        alist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n        actual = random.permutation(alist)\n        desired = [0, 1, 9, 6, 2, 4, 5, 8, 7, 3]\n        assert_array_equal(actual, desired)\n\n        random.bit_generator.seed(self.seed)\n        arr_2d = np.atleast_2d([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]).T\n        actual = random.permutation(arr_2d)\n        assert_array_equal(actual, np.atleast_2d(desired).T)\n\n    def test_beta(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.beta(0.1, 0.9, size=(3, 2))\n        desired = np.array(\n            [\n                [1.45341850513746058e-02, 5.31297615662868145e-04],\n                [1.85366619058432324e-06, 4.19214516800110563e-03],\n                [1.58405155108498093e-04, 1.26252891949397652e-04],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_binomial(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.binomial(100.123, 0.456, size=(3, 2))\n        desired = np.array([[37, 43], [42, 48], [46, 45]])\n        assert_array_equal(actual, desired)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.binomial(100.123, 0.456)\n        desired = 37\n        assert_array_equal(actual, desired)\n\n    def test_chisquare(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.chisquare(50, size=(3, 2))\n        desired = np.array(\n            [\n                [22.2534560369812, 46.9302393710074],\n                [52.9974164611614, 85.3559029505718],\n                [46.1580841240719, 36.1933148548090],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=13)\n\n    def test_dirichlet(self):\n        random.bit_generator.seed(self.seed)\n        alpha = np.array([51.72840233779265162, 39.74494232180943953])\n        actual = random.dirichlet(alpha, size=(3, 2))\n        desired = np.array(\n            [\n                [\n                    [0.444382290764855, 0.555617709235145],\n                    [0.468440809291970, 0.531559190708030],\n                ],\n                [\n                    [0.613461427360549, 0.386538572639451],\n                    [0.529103072088183, 0.470896927911817],\n                ],\n                [\n                    [0.513490650101800, 0.486509349898200],\n                    [0.558550925712797, 0.441449074287203],\n                ],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n        bad_alpha = np.array([5.4e-01, -1.0e-16])\n        assert_raises(ValueError, random.dirichlet, bad_alpha)\n\n        random.bit_generator.seed(self.seed)\n        alpha = np.array([51.72840233779265162, 39.74494232180943953])\n        actual = random.dirichlet(alpha)\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_dirichlet_size(self):\n        # gh-3173\n        p = np.array([51.72840233779265162, 39.74494232180943953])\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, [2, 2]).shape, (2, 2, 2))\n        assert_equal(random.dirichlet(p, (2, 2)).shape, (2, 2, 2))\n        assert_equal(random.dirichlet(p, np.array((2, 2))).shape, (2, 2, 2))\n\n        assert_raises(TypeError, random.dirichlet, p, float(1))\n\n    def test_dirichlet_bad_alpha(self):\n        # gh-2089\n        alpha = np.array([5.4e-01, -1.0e-16])\n        assert_raises(ValueError, random.dirichlet, alpha)\n\n    def test_dirichlet_non_contiguous_alpha(self):\n        a = np.array([51.72840233779265162, -1.0, 39.74494232180943953])\n        alpha = a[::2]\n        random.bit_generator.seed(self.seed)\n        non_contig = random.dirichlet(alpha, size=(3, 2))\n        random.bit_generator.seed(self.seed)\n        contig = random.dirichlet(np.ascontiguousarray(alpha), size=(3, 2))\n        assert_array_almost_equal(contig, non_contig)\n\n    def test_exponential(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.exponential(1.1234, size=(3, 2))\n        desired = np.array(\n            [\n                [5.350682337747634, 1.152307441755771],\n                [3.867015473358779, 1.538765912839396],\n                [0.347846818048527, 2.715656549872026],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_exponential_0(self):\n        assert_equal(random.exponential(scale=0), 0)\n        assert_raises(ValueError, random.exponential, scale=-0.0)\n\n    def test_f(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.f(12, 77, size=(3, 2))\n        desired = np.array(\n            [\n                [0.809498839488467, 2.867222762455471],\n                [0.588036831639353, 1.012185639664636],\n                [1.147554281917365, 1.150886518432105],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_gamma(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.gamma(5, 3, size=(3, 2))\n        desired = np.array(\n            [\n                [12.46569350177219, 16.46580642087044],\n                [43.65744473309084, 11.98722785682592],\n                [6.50371499559955, 7.48465689751638],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_gamma_0(self):\n        assert_equal(random.gamma(shape=0, scale=0), 0)\n        assert_raises(ValueError, random.gamma, shape=-0.0, scale=-0.0)\n\n    def test_geometric(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.geometric(0.123456789, size=(3, 2))\n        desired = np.array([[8, 7], [17, 17], [5, 12]])\n        assert_array_equal(actual, desired)\n\n    def test_geometric_exceptions(self):\n        assert_raises(ValueError, random.geometric, 1.1)\n        assert_raises(ValueError, random.geometric, [1.1] * 10)\n        assert_raises(ValueError, random.geometric, -0.1)\n        assert_raises(ValueError, random.geometric, [-0.1] * 10)\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.geometric, np.nan)\n            assert_raises(ValueError, random.geometric, [np.nan] * 10)\n\n    def test_gumbel(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.gumbel(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [0.19591898743416816, 0.34405539668096674],\n                [-1.4492522252274278, -1.47374816298446865],\n                [1.10651090478803416, -0.69535848626236174],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_gumbel_0(self):\n        assert_equal(random.gumbel(scale=0), 0)\n        assert_raises(ValueError, random.gumbel, scale=-0.0)\n\n    def test_hypergeometric(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.hypergeometric(10.1, 5.5, 14, size=(3, 2))\n        desired = np.array([[9, 9], [10, 9], [9, 10]])\n        assert_array_equal(actual, desired)\n\n        # Test nbad = 0\n        actual = random.hypergeometric(5, 0, 3, size=4)\n        desired = np.array([3, 3, 3, 3])\n        assert_array_equal(actual, desired)\n\n        actual = random.hypergeometric(15, 0, 12, size=4)\n        desired = np.array([12, 12, 12, 12])\n        assert_array_equal(actual, desired)\n\n        # Test ngood = 0\n        actual = random.hypergeometric(0, 5, 3, size=4)\n        desired = np.array([0, 0, 0, 0])\n        assert_array_equal(actual, desired)\n\n        actual = random.hypergeometric(0, 15, 12, size=4)\n        desired = np.array([0, 0, 0, 0])\n        assert_array_equal(actual, desired)\n\n    def test_laplace(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.laplace(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [0.66599721112760157, 0.52829452552221945],\n                [3.12791959514407125, 3.18202813572992005],\n                [-0.05391065675859356, 1.74901336242837324],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_laplace_0(self):\n        assert_equal(random.laplace(scale=0), 0)\n        assert_raises(ValueError, random.laplace, scale=-0.0)\n\n    def test_logistic(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.logistic(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [1.09232835305011444, 0.8648196662399954],\n                [4.27818590694950185, 4.33897006346929714],\n                [-0.21682183359214885, 2.63373365386060332],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_lognormal(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.lognormal(mean=0.123456789, sigma=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [1.0894838661036e-03, 9.0990021488311e-01],\n                [6.9178869932225e-01, 2.7672077560016e-01],\n                [2.3248645126975e00, 1.4609997951330e00],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=13)\n\n    def test_lognormal_0(self):\n        assert_equal(random.lognormal(sigma=0), 1)\n        assert_raises(ValueError, random.lognormal, sigma=-0.0)\n\n    def test_logseries(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.logseries(p=0.923456789, size=(3, 2))\n        desired = np.array([[2, 2], [6, 17], [3, 6]])\n        assert_array_equal(actual, desired)\n\n    def test_logseries_exceptions(self):\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.logseries, np.nan)\n            assert_raises(ValueError, random.logseries, [np.nan] * 10)\n\n    def test_multinomial(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.multinomial(20, [1 / 6.0] * 6, size=(3, 2))\n        desired = np.array(\n            [\n                [[4, 3, 5, 4, 2, 2], [5, 2, 8, 2, 2, 1]],\n                [[3, 4, 3, 6, 0, 4], [2, 1, 4, 3, 6, 4]],\n                [[4, 4, 2, 5, 2, 3], [4, 3, 4, 2, 3, 4]],\n            ]\n        )\n        assert_array_equal(actual, desired)\n\n    @pytest.mark.skipif(NP_LT_118, reason=""Can only test with NumPy >= 1.18"")\n    @pytest.mark.parametrize(""method"", [""svd"", ""eigh"", ""cholesky""])\n    def test_multivariate_normal_method(self, method):\n        from numpy.random import MT19937 as NPMT19937\n\n        random = Generator(NPMT19937(self.seed))\n        mean = (0.123456789, 10)\n        cov = [[1, 0], [0, 1]]\n        size = (3, 2)\n        actual = random.multivariate_normal(mean, cov, size, method=method)\n        desired = np.array(\n            [\n                [\n                    [-1.747478062846581, 11.25613495182354],\n                    [-0.9967333370066214, 10.342002097029821],\n                ],\n                [\n                    [0.7850019631242964, 11.181113712443013],\n                    [0.8901349653255224, 8.873825399642492],\n                ],\n                [\n                    [0.7130260107430003, 9.551628690083056],\n                    [0.7127098726541128, 11.991709234143173],\n                ],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check for default size, was raising deprecation warning\n        actual = random.multivariate_normal(mean, cov, method=method)\n        desired = np.array([0.233278563284287, 9.424140804347195])\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check path with scalar size works correctly\n        scalar = random.multivariate_normal(mean, cov, 3, method=method)\n        tuple1d = random.multivariate_normal(mean, cov, (3,), method=method)\n        assert scalar.shape == tuple1d.shape == (3, 2)\n\n        # Check that non symmetric covariance input raises exception when\n        # check_valid=\'raises\' if using default svd method.\n        mean = [0, 0]\n        cov = [[1, 2], [1, 2]]\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n        )\n\n        # Check that non positive-semidefinite covariance warns with\n        # RuntimeWarning\n        cov = [[1, 2], [2, 1]]\n        assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)\n        assert_warns(\n            RuntimeWarning, random.multivariate_normal, mean, cov, method=""eigh""\n        )\n        assert_raises(\n            LinAlgError, random.multivariate_normal, mean, cov, method=""cholesky""\n        )\n\n        # and that it doesn\'t warn with RuntimeWarning check_valid=\'ignore\'\n        assert_no_warnings(random.multivariate_normal, mean, cov, check_valid=""ignore"")\n\n        # and that it raises with RuntimeWarning check_valid=\'raises\'\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n        )\n        assert_raises(\n            ValueError,\n            random.multivariate_normal,\n            mean,\n            cov,\n            check_valid=""raise"",\n            method=""eigh"",\n        )\n\n        # check degenerate samples from singular covariance matrix\n        cov = [[1, 1], [1, 1]]\n        if method in (""svd"", ""eigh""):\n            samples = random.multivariate_normal(mean, cov, size=(3, 2), method=method)\n            assert_array_almost_equal(samples[..., 0], samples[..., 1], decimal=6)\n        else:\n            assert_raises(\n                LinAlgError, random.multivariate_normal, mean, cov, method=""cholesky""\n            )\n\n        cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)\n        with suppress_warnings() as sup:\n            random.multivariate_normal(mean, cov, method=method)\n            w = sup.record(RuntimeWarning)\n            assert len(w) == 0\n\n        mu = np.zeros(2)\n        cov = np.eye(2)\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""other""\n        )\n        assert_raises(ValueError, random.multivariate_normal, np.zeros((2, 1, 1)), cov)\n        assert_raises(ValueError, random.multivariate_normal, mu, np.empty((3, 2)))\n        assert_raises(ValueError, random.multivariate_normal, mu, np.eye(3))\n\n    @pytest.mark.parametrize(""method"", [""svd"", ""eigh"", ""cholesky""])\n    def test_multivariate_normal_basic_stats(self, method):\n        random = Generator(MT19937(self.seed, mode=""sequence""))\n        n_s = 1000\n        mean = np.array([1, 2])\n        cov = np.array([[2, 1], [1, 2]])\n        s = random.multivariate_normal(mean, cov, size=(n_s,), method=method)\n        s_center = s - mean\n        cov_emp = (s_center.T @ s_center) / (n_s - 1)\n        # these are pretty loose and are only designed to detect major errors\n        assert np.all(np.abs(s_center.mean(-2)) < 0.1)\n        assert np.all(np.abs(cov_emp - cov) < 0.2)\n\n    @pytest.mark.parametrize(""size"", [(4, 3, 2), (5, 4, 3, 2)])\n    @pytest.mark.parametrize(""mean"", [np.zeros(2), np.zeros((3, 3))])\n    def test_multivariate_normal_bad_size(self, mean, size):\n        cov = np.eye(4)\n        with pytest.raises(ValueError):\n            random.multivariate_normal(mean, cov)\n        mean = np.zeros((2, 3, 4))\n        with pytest.raises(ValueError):\n            random.multivariate_normal(mean, cov, size=size)\n\n        with pytest.raises(ValueError):\n            random.multivariate_normal(0, [[1]], size=size)\n        with pytest.raises(ValueError):\n            random.multivariate_normal([0], [1], size=size)\n\n    def test_multivariate_normal(self):\n        random.bit_generator.seed(self.seed)\n        mean = (0.123456789, 10)\n        cov = [[1, 0], [0, 1]]\n        size = (3, 2)\n        actual = random.multivariate_normal(mean, cov, size)\n        desired = np.array(\n            [\n                [\n                    [-3.34929721161096100, 9.891061435770858],\n                    [-0.12250896439641100, 9.295898449738300],\n                ],\n                [\n                    [0.48355927611635563, 10.127832101772366],\n                    [3.11093021424924300, 10.283109168794352],\n                ],\n                [\n                    [-0.20332082341774727, 9.868532121697195],\n                    [-1.33806889550667330, 9.813657233804179],\n                ],\n            ]\n        )\n\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check for default size, was raising deprecation warning\n        actual = random.multivariate_normal(mean, cov)\n        desired = np.array([-1.097443117192574, 10.535787051184261])\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check that non positive-semidefinite covariance warns with\n        # RuntimeWarning\n        mean = [0, 0]\n        cov = [[1, 2], [2, 1]]\n        assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)\n\n        # and that it doesn""t warn with RuntimeWarning check_valid=""ignore""\n        assert_no_warnings(random.multivariate_normal, mean, cov, check_valid=""ignore"")\n\n        # and that it raises with RuntimeWarning check_valid=""raises""\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n        )\n\n        cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)\n        with suppress_warnings() as sup:\n            random.multivariate_normal(mean, cov)\n            w = sup.record(RuntimeWarning)\n            assert len(w) == 0\n\n        mu = np.zeros(2)\n        cov = np.eye(2)\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""other""\n        )\n        assert_raises(ValueError, random.multivariate_normal, np.zeros((2, 1, 1)), cov)\n        assert_raises(ValueError, random.multivariate_normal, mu, np.empty((3, 2)))\n        assert_raises(ValueError, random.multivariate_normal, mu, np.eye(3))\n\n    def test_negative_binomial(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.negative_binomial(n=100, p=0.12345, size=(3, 2))\n        desired = np.array([[521, 736], [665, 690], [723, 751]])\n        assert_array_equal(actual, desired)\n\n    def test_negative_binomial_exceptions(self):\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.negative_binomial, 100, np.nan)\n            assert_raises(ValueError, random.negative_binomial, 100, [np.nan] * 10)\n\n    def test_noncentral_chisquare(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.noncentral_chisquare(df=5, nonc=5, size=(3, 2))\n        desired = np.array(\n            [\n                [9.47783251920357, 10.02066178260461],\n                [3.15869984192364, 10.5581565031544],\n                [5.01652540543548, 13.7689551218441],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        actual = random.noncentral_chisquare(df=0.5, nonc=0.2, size=(3, 2))\n        desired = np.array(\n            [\n                [0.00145153051285, 0.22432468724778],\n                [0.02956713468556, 0.00207192946898],\n                [1.41985055641800, 0.15451287602753],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.noncentral_chisquare(df=5, nonc=0, size=(3, 2))\n        desired = np.array(\n            [\n                [3.64881368071039, 5.48224544747803],\n                [20.41999842025404, 3.44075915187367],\n                [1.29765160605552, 1.64125033268606],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_noncentral_f(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.noncentral_f(dfnum=5, dfden=2, nonc=1, size=(3, 2))\n        desired = np.array(\n            [\n                [1.22680230963236, 2.56457837623956],\n                [2.7653304499494, 7.4336268865443],\n                [1.16362730891403, 2.54104276581491],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_noncentral_f_nan(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.noncentral_f(dfnum=5, dfden=2, nonc=np.nan)\n        assert np.isnan(actual)\n\n    def test_normal(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.normal(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [-6.822051212221923, -0.094420339458285],\n                [-0.368474717792823, -1.284746311523402],\n                [0.843661763232711, 0.379120992544734],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_normal_0(self):\n        assert_equal(random.normal(scale=0), 0)\n        assert_raises(ValueError, random.normal, scale=-0.0)\n\n    def test_pareto(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.pareto(a=0.123456789, size=(3, 2))\n        desired = np.array(\n            [\n                [5.6883528121891552e16, 4.0569373841667057e03],\n                [1.2854967019379475e12, 6.5833156486851483e04],\n                [1.1281132447159091e01, 3.1895968171107006e08],\n            ]\n        )\n        # For some reason on 32-bit x86 Ubuntu 12.10 the [1, 0] entry in this\n        # matrix differs by 24 nulps. Discussion:\n        #   https://mail.python.org/pipermail/numpy-discussion/2012-September/063801.html\n        # Consensus is that this is probably some gcc quirk that affects\n        # rounding but not in any important way, so we just use a looser\n        # tolerance on this test:\n        np.testing.assert_array_almost_equal_nulp(actual, desired, nulp=30)\n\n    def test_poisson(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.poisson(lam=0.123456789, size=(3, 2))\n        desired = np.array([[0, 0], [1, 0], [0, 0]])\n        assert_array_equal(actual, desired)\n\n    def test_poisson_exceptions(self):\n        lambig = np.iinfo(""int64"").max\n        lamneg = -1\n        assert_raises(ValueError, random.poisson, lamneg)\n        assert_raises(ValueError, random.poisson, [lamneg] * 10)\n        assert_raises(ValueError, random.poisson, lambig)\n        assert_raises(ValueError, random.poisson, [lambig] * 10)\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.poisson, np.nan)\n            assert_raises(ValueError, random.poisson, [np.nan] * 10)\n\n    def test_power(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.power(a=0.123456789, size=(3, 2))\n        desired = np.array(\n            [\n                [9.328833342693975e-01, 2.742250409261003e-02],\n                [7.684513237993961e-01, 9.297548209160028e-02],\n                [2.214811188828573e-05, 4.693448360603472e-01],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_rayleigh(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.rayleigh(scale=10, size=(3, 2))\n        desired = np.array(\n            [\n                [13.8882496494248393, 13.383318339044731],\n                [20.95413364294492098, 21.08285015800712614],\n                [11.06066537006854311, 17.35468505778271009],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_rayleigh_0(self):\n        assert_equal(random.rayleigh(scale=0), 0)\n        assert_raises(ValueError, random.rayleigh, scale=-0.0)\n\n    def test_standard_cauchy(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_cauchy(size=(3, 2))\n        desired = np.array(\n            [\n                [31.87809592667601, 0.349332782046838],\n                [2.816995747731641, 10.552372563459114],\n                [2.485608017991235, 7.843211273201831],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_exponential(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_exponential(size=(3, 2), method=""inv"")\n        desired = np.array(\n            [\n                [0.96441739162374596, 0.89556604882105506],\n                [2.1953785836319808, 2.22243285392490542],\n                [0.6116915921431676, 1.50592546727413201],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_expoential_type_error(self):\n        assert_raises(TypeError, random.standard_exponential, dtype=np.int32)\n\n    def test_standard_gamma(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_gamma(shape=3, size=(3, 2))\n        desired = np.array(\n            [\n                [2.28483515569645, 3.29899524967824],\n                [11.12492298902645, 2.16784417297277],\n                [0.92121813690910, 1.12853552328470],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_standard_gammma_scalar_float(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_gamma(3, dtype=np.float32)\n        desired = 1.3877466\n        assert_array_almost_equal(actual, desired, decimal=6)\n\n    def test_standard_gamma_float(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_gamma(shape=3, size=(3, 2))\n        desired = np.array(\n            [[2.2848352, 3.2989952], [11.124923, 2.1678442], [0.9212181, 1.1285355]]\n        )\n        assert_array_almost_equal(actual, desired, decimal=5)\n\n    def test_standard_gammma_float_out(self):\n        actual = np.zeros((3, 2), dtype=np.float32)\n        random.bit_generator.seed(self.seed)\n        random.standard_gamma(10.0, out=actual, dtype=np.float32)\n        desired = np.array(\n            [[6.9824033, 7.3731737], [14.860578, 7.5327270], [11.767487, 6.2320185]],\n            dtype=np.float32,\n        )\n        assert_array_almost_equal(actual, desired, decimal=5)\n\n        random.bit_generator.seed(self.seed)\n        random.standard_gamma(10.0, out=actual, size=(3, 2), dtype=np.float32)\n        assert_array_almost_equal(actual, desired, decimal=5)\n\n    def test_standard_gamma_unknown_type(self):\n        assert_raises(TypeError, random.standard_gamma, 1.0, dtype=""int32"")\n\n    def test_out_size_mismatch(self):\n        out = np.zeros(10)\n        assert_raises(ValueError, random.standard_gamma, 10.0, size=20, out=out)\n        assert_raises(ValueError, random.standard_gamma, 10.0, size=(10, 1), out=out)\n\n    def test_standard_gamma_0(self):\n        assert_equal(random.standard_gamma(shape=0), 0)\n        assert_raises(ValueError, random.standard_gamma, shape=-0.0)\n\n    def test_standard_normal(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_normal(size=(3, 2))\n        desired = np.array(\n            [\n                [-3.472754000610961, -0.108938564229143],\n                [-0.245965753396411, -0.704101550261701],\n                [0.360102487116356, 0.127832101772367],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_normal_unsupported_type(self):\n        assert_raises(TypeError, random.standard_normal, dtype=np.int32)\n\n    def test_standard_t(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.standard_t(df=10, size=(3, 2))\n        desired = np.array(\n            [\n                [-3.68722108185508, -0.672031186266171],\n                [2.900224996448669, -0.199656996187739],\n                [-1.12179956985969, 1.85668262342106],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_triangular(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.triangular(left=5.12, mode=10.23, right=20.34, size=(3, 2))\n        desired = np.array(\n            [\n                [12.68117178949215784, 12.4129206149193152],\n                [16.20131377335158263, 16.25692138747600524],\n                [11.20400690911820263, 14.4978144835829923],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_uniform(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.uniform(low=1.23, high=10.54, size=(3, 2))\n        desired = np.array(\n            [\n                [6.99097932346268003, 6.73801597444323974],\n                [9.50364421400426274, 9.53130618907631089],\n                [5.48995325769805476, 8.47493103280052118],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_uniform_range_bounds(self):\n        fmin = np.finfo(""float"").min\n        fmax = np.finfo(""float"").max\n\n        func = random.uniform\n        assert_raises(OverflowError, func, -np.inf, 0)\n        assert_raises(OverflowError, func, 0, np.inf)\n        assert_raises(OverflowError, func, fmin, fmax)\n        assert_raises(OverflowError, func, [-np.inf], [0])\n        assert_raises(OverflowError, func, [0], [np.inf])\n\n        # (fmax / 1e17) - fmin is within range, so this should not throw\n        # account for i386 extended precision DBL_MAX / 1e17 + DBL_MAX >\n        # DBL_MAX by increasing fmin a bit\n        random.uniform(low=np.nextafter(fmin, 1), high=fmax / 1e17)\n\n    def test_scalar_exception_propagation(self):\n        # Tests that exceptions are correctly propagated in distributions\n        # when called with objects that throw exceptions when converted to\n        # scalars.\n        #\n        # Regression test for gh: 8865\n\n        class ThrowingFloat(np.ndarray):\n            def __float__(self):\n                raise TypeError\n\n        throwing_float = np.array(1.0).view(ThrowingFloat)\n        assert_raises(TypeError, random.uniform, throwing_float, throwing_float)\n\n        class ThrowingInteger(np.ndarray):\n            def __int__(self):\n                raise TypeError\n\n        throwing_int = np.array(1).view(ThrowingInteger)\n        assert_raises(TypeError, random.hypergeometric, throwing_int, 1, 1)\n\n    def test_vonmises(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.vonmises(mu=1.23, kappa=1.54, size=(3, 2))\n        desired = np.array(\n            [\n                [2.28567572673902042, 2.89163838442285037],\n                [0.38198375564286025, 2.57638023113890746],\n                [1.19153771588353052, 1.83509849681825354],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_vonmises_small(self):\n        # check infinite loop, gh-4720\n        random.bit_generator.seed(self.seed)\n        r = random.vonmises(mu=0.0, kappa=1.1e-8, size=10 ** 6)\n        assert_(np.isfinite(r).all())\n\n    def test_vonmises_nan(self):\n        random.bit_generator.seed(self.seed)\n        r = random.vonmises(mu=0.0, kappa=np.nan)\n        assert_(np.isnan(r))\n\n    def test_wald(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.wald(mean=1.23, scale=1.54, size=(3, 2))\n        desired = np.array(\n            [\n                [0.10653278160339, 0.98771068102461],\n                [0.89276055317879, 0.13640126419923],\n                [0.9194319091599, 0.36037816317472],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_weibull(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.weibull(a=1.23, size=(3, 2))\n        desired = np.array(\n            [\n                [3.557276979846361, 1.020870580998542],\n                [2.731847777612348, 1.29148068905082],\n                [0.385531483942839, 2.049551716717254],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_weibull_0(self):\n        random.bit_generator.seed(self.seed)\n        assert_equal(random.weibull(a=0, size=12), np.zeros(12))\n        assert_raises(ValueError, random.weibull, a=-0.0)\n\n    def test_zipf(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.zipf(a=1.23, size=(3, 2))\n        desired = np.array([[66, 29], [1, 1], [3, 13]])\n        assert_array_equal(actual, desired)\n\n    def test_complex_normal(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.complex_normal(loc=1.0, gamma=1.0, relation=0.5, size=(3, 2))\n        desired = np.array(\n            [\n                [\n                    -2.007493185623132 - 0.05446928211457126j,\n                    0.7869874090977291 - 0.35205077513085050j,\n                ],\n                [\n                    1.3118579018087224 + 0.06391605088618339j,\n                    3.5872278793967554 + 0.14155458439717636j,\n                ],\n                [\n                    0.7170022862582056 - 0.06573393915140235j,\n                    -0.26571837106621987 - 0.0931713830979103j,\n                ],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.complex_normal(loc=0, gamma=1.0, relation=0.5, size=3)\n        assert_array_almost_equal(actual, desired.flat[:3] - 1.0, decimal=15)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.complex_normal(loc=2.0, gamma=1.0, relation=0.5)\n        assert_array_almost_equal(actual, 1.0 + desired[0, 0], decimal=15)\n\n    def test_complex_normal_invalid(self):\n        assert_raises(ValueError, random.complex_normal, gamma=1 + 0.5j)\n        assert_raises(ValueError, random.complex_normal, relation=2)\n        assert_raises(ValueError, random.complex_normal, relation=-3)\n        assert_raises(ValueError, random.complex_normal, relation=10j)\n\n        assert_raises(ValueError, random.complex_normal, gamma=[1 + 0.5j])\n        assert_raises(ValueError, random.complex_normal, relation=[2])\n        assert_raises(ValueError, random.complex_normal, relation=[-3])\n        assert_raises(ValueError, random.complex_normal, relation=[10j])\n\n\nclass TestBroadcast(object):\n    # tests that functions that broadcast behave\n    # correctly when presented with non-scalar arguments\n    def setup(self):\n        self.seed = 123456789\n\n    def set_seed(self):\n        random.bit_generator.seed(self.seed)\n\n    def test_uniform(self):\n        low = [0]\n        high = [1]\n        uniform = random.uniform\n        desired = np.array(\n            [0.53283302478975902, 0.53413660089041659, 0.50955303552646702]\n        )\n\n        self.set_seed()\n        actual = uniform(low * 3, high)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        self.set_seed()\n        actual = uniform(low, high * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_normal(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        normal = random.normal\n        desired = np.array([0.454879818179180, -0.62749179463661, -0.06063266769872])\n\n        self.set_seed()\n        actual = normal(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, normal, loc * 3, bad_scale)\n        assert_raises(ValueError, random.normal, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = normal(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, normal, loc, bad_scale * 3)\n        assert_raises(ValueError, random.normal, loc, bad_scale * 3)\n\n    def test_beta(self):\n        a = [1]\n        b = [2]\n        bad_a = [-1]\n        bad_b = [-2]\n        beta = random.beta\n        desired = np.array([0.63222080311226, 0.33310522220774, 0.64494078460190])\n\n        self.set_seed()\n        actual = beta(a * 3, b)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, beta, bad_a * 3, b)\n        assert_raises(ValueError, beta, a * 3, bad_b)\n\n        self.set_seed()\n        actual = beta(a, b * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_exponential(self):\n        scale = [1]\n        bad_scale = [-1]\n        exponential = random.exponential\n        desired = np.array([1.68591211640990, 3.14186859487914, 0.67717375919228])\n\n        self.set_seed()\n        actual = exponential(scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, exponential, bad_scale * 3)\n\n    def test_standard_gamma(self):\n        shape = [1]\n        bad_shape = [-1]\n        std_gamma = random.standard_gamma\n        desired = np.array([1.68591211640990, 3.14186859487914, 0.67717375919228])\n\n        self.set_seed()\n        actual = std_gamma(shape * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, std_gamma, bad_shape * 3)\n\n    def test_gamma(self):\n        shape = [1]\n        scale = [2]\n        bad_shape = [-1]\n        bad_scale = [-2]\n        gamma = random.gamma\n        desired = np.array([3.37182423281980, 6.28373718975827, 1.35434751838456])\n\n        self.set_seed()\n        actual = gamma(shape * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gamma, bad_shape * 3, scale)\n        assert_raises(ValueError, gamma, shape * 3, bad_scale)\n\n        self.set_seed()\n        actual = gamma(shape, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gamma, bad_shape, scale * 3)\n        assert_raises(ValueError, gamma, shape, bad_scale * 3)\n\n    def test_f(self):\n        dfnum = [1]\n        dfden = [2]\n        bad_dfnum = [-1]\n        bad_dfden = [-2]\n        f = random.f\n        desired = np.array([0.84207044881810, 3.08607209903483, 3.12823105933169])\n\n        self.set_seed()\n        actual = f(dfnum * 3, dfden)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, f, bad_dfnum * 3, dfden)\n        assert_raises(ValueError, f, dfnum * 3, bad_dfden)\n\n        self.set_seed()\n        actual = f(dfnum, dfden * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, f, bad_dfnum, dfden * 3)\n        assert_raises(ValueError, f, dfnum, bad_dfden * 3)\n\n    def test_noncentral_f(self):\n        dfnum = [2]\n        dfden = [3]\n        nonc = [4]\n        bad_dfnum = [0]\n        bad_dfden = [-1]\n        bad_nonc = [-2]\n        nonc_f = random.noncentral_f\n        desired = np.array([3.83710578542563, 8.74926819712029, 0.48892943835401])\n\n        self.set_seed()\n        actual = nonc_f(dfnum * 3, dfden, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert np.all(np.isnan(nonc_f(dfnum, dfden, [np.nan] * 3)))\n\n        assert_raises(ValueError, nonc_f, bad_dfnum * 3, dfden, nonc)\n        assert_raises(ValueError, nonc_f, dfnum * 3, bad_dfden, nonc)\n        assert_raises(ValueError, nonc_f, dfnum * 3, dfden, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_f(dfnum, dfden * 3, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_f, bad_dfnum, dfden * 3, nonc)\n        assert_raises(ValueError, nonc_f, dfnum, bad_dfden * 3, nonc)\n        assert_raises(ValueError, nonc_f, dfnum, dfden * 3, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_f(dfnum, dfden, nonc * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_f, bad_dfnum, dfden, nonc * 3)\n        assert_raises(ValueError, nonc_f, dfnum, bad_dfden, nonc * 3)\n        assert_raises(ValueError, nonc_f, dfnum, dfden, bad_nonc * 3)\n\n    def test_noncentral_f_small_df(self):\n        self.set_seed()\n        desired = np.array([21.57878070681719, 1.17110217503908])\n        actual = random.noncentral_f(0.9, 0.9, 2, size=2)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_chisquare(self):\n        df = [1]\n        bad_df = [-1]\n        chisquare = random.chisquare\n        desired = np.array(\n            [0.57022801133088286, 0.51947702108840776, 0.1320969254923558]\n        )\n\n        self.set_seed()\n        actual = chisquare(df * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, chisquare, bad_df * 3)\n\n    def test_noncentral_chisquare(self):\n        df = [1]\n        nonc = [2]\n        bad_df = [-1]\n        bad_nonc = [-2]\n        nonc_chi = random.noncentral_chisquare\n        desired = np.array([2.20478739452297, 1.45177405755115, 1.00418921695354])\n\n        self.set_seed()\n        actual = nonc_chi(df * 3, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_chi, bad_df * 3, nonc)\n        assert_raises(ValueError, nonc_chi, df * 3, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_chi(df, nonc * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_chi, bad_df, nonc * 3)\n        assert_raises(ValueError, nonc_chi, df, bad_nonc * 3)\n\n    def test_standard_t(self):\n        df = [1]\n        bad_df = [-1]\n        t = random.standard_t\n        desired = np.array([0.60081050724244, -0.90380889829210, -0.64499590504117])\n\n        self.set_seed()\n        actual = t(df * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, t, bad_df * 3)\n        assert_raises(ValueError, random.standard_t, bad_df * 3)\n\n    def test_vonmises(self):\n        mu = [2]\n        kappa = [1]\n        bad_kappa = [-1]\n        vonmises = random.vonmises\n        desired = np.array(\n            [2.9883443664201312, -2.7064099483995943, -1.8672476700665914]\n        )\n\n        self.set_seed()\n        actual = vonmises(mu * 3, kappa)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, vonmises, mu * 3, bad_kappa)\n\n        self.set_seed()\n        actual = vonmises(mu, kappa * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, vonmises, mu, bad_kappa * 3)\n\n    def test_pareto(self):\n        a = [1]\n        bad_a = [-1]\n        pareto = random.pareto\n        desired = np.array([4.397371719158540, 22.14707898642946, 0.968306954322200])\n\n        self.set_seed()\n        actual = pareto(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, pareto, bad_a * 3)\n        assert_raises(ValueError, random.pareto, bad_a * 3)\n\n    def test_weibull(self):\n        a = [1]\n        bad_a = [-1]\n        weibull = random.weibull\n        desired = np.array([1.68591211640990, 3.14186859487914, 0.67717375919228])\n\n        self.set_seed()\n        actual = weibull(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, weibull, bad_a * 3)\n        assert_raises(ValueError, random.weibull, bad_a * 3)\n\n    def test_power(self):\n        a = [1]\n        bad_a = [-1]\n        power = random.power\n        desired = np.array([0.81472463783615, 0.95679800459547, 0.49194916077287])\n\n        self.set_seed()\n        actual = power(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, power, bad_a * 3)\n        assert_raises(ValueError, random.power, bad_a * 3)\n\n    def test_laplace(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        laplace = random.laplace\n        desired = np.array(\n            [0.067921356028507157, 0.070715642226971326, 0.019290950698972624]\n        )\n\n        self.set_seed()\n        actual = laplace(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, laplace, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = laplace(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, laplace, loc, bad_scale * 3)\n\n    def test_gumbel(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        gumbel = random.gumbel\n        desired = np.array(\n            [0.2730318639556768, 0.26936705726291116, 0.33906220393037939]\n        )\n\n        self.set_seed()\n        actual = gumbel(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gumbel, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = gumbel(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gumbel, loc, bad_scale * 3)\n\n    def test_logistic(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        logistic = random.logistic\n        desired = np.array(\n            [0.13152135837586171, 0.13675915696285773, 0.038216792802833396]\n        )\n\n        self.set_seed()\n        actual = logistic(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, logistic, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = logistic(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, logistic, loc, bad_scale * 3)\n        assert_equal(random.logistic(1.0, 0.0), 1.0)\n\n    def test_lognormal(self):\n        mean = [0]\n        sigma = [1]\n        bad_sigma = [-1]\n        lognormal = random.lognormal\n        desired = np.array([1.57598396702930, 0.53392932731280, 0.94116889802361])\n\n        self.set_seed()\n        actual = lognormal(mean * 3, sigma)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, lognormal, mean * 3, bad_sigma)\n        assert_raises(ValueError, random.lognormal, mean * 3, bad_sigma)\n\n        self.set_seed()\n        actual = lognormal(mean, sigma * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, lognormal, mean, bad_sigma * 3)\n        assert_raises(ValueError, random.lognormal, mean, bad_sigma * 3)\n\n    def test_rayleigh(self):\n        scale = [1]\n        bad_scale = [-1]\n        rayleigh = random.rayleigh\n        desired = np.array([1.2337491937897689, 1.2360119924878694, 1.1936818095781789])\n\n        self.set_seed()\n        actual = rayleigh(scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, rayleigh, bad_scale * 3)\n\n    def test_wald(self):\n        mean = [0.5]\n        scale = [1]\n        bad_mean = [0]\n        bad_scale = [-2]\n        wald = random.wald\n        desired = np.array([0.36297361471752, 0.52190135028254, 0.55111022040727])\n\n        self.set_seed()\n        actual = wald(mean * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, wald, bad_mean * 3, scale)\n        assert_raises(ValueError, wald, mean * 3, bad_scale)\n        assert_raises(ValueError, random.wald, bad_mean * 3, scale)\n        assert_raises(ValueError, random.wald, mean * 3, bad_scale)\n\n        self.set_seed()\n        actual = wald(mean, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, wald, bad_mean, scale * 3)\n        assert_raises(ValueError, wald, mean, bad_scale * 3)\n        assert_raises(ValueError, random.wald, bad_mean, scale * 3)\n        assert_raises(ValueError, random.wald, mean, bad_scale * 3)\n\n    def test_triangular(self):\n        left = [1]\n        right = [3]\n        mode = [2]\n        bad_left_one = [3]\n        bad_mode_one = [4]\n        bad_left_two, bad_mode_two = right * 2\n        triangular = random.triangular\n        desired = np.array([2.03339048710429, 2.0347400359389356, 2.0095991069536208])\n\n        self.set_seed()\n        actual = triangular(left * 3, mode, right)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one * 3, mode, right)\n        assert_raises(ValueError, triangular, left * 3, bad_mode_one, right)\n        assert_raises(ValueError, triangular, bad_left_two * 3, bad_mode_two, right)\n\n        self.set_seed()\n        actual = triangular(left, mode * 3, right)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one, mode * 3, right)\n        assert_raises(ValueError, triangular, left, bad_mode_one * 3, right)\n        assert_raises(ValueError, triangular, bad_left_two, bad_mode_two * 3, right)\n\n        self.set_seed()\n        actual = triangular(left, mode, right * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one, mode, right * 3)\n        assert_raises(ValueError, triangular, left, bad_mode_one, right * 3)\n        assert_raises(ValueError, triangular, bad_left_two, bad_mode_two, right * 3)\n\n        assert_raises(ValueError, triangular, 10.0, 0.0, 20.0)\n        assert_raises(ValueError, triangular, 10.0, 25.0, 20.0)\n        assert_raises(ValueError, triangular, 10.0, 10.0, 10.0)\n\n    def test_binomial(self):\n        n = [1]\n        p = [0.5]\n        bad_n = [-1]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        binom = random.binomial\n        desired = np.array([1, 1, 1])\n\n        self.set_seed()\n        actual = binom(n * 3, p)\n        assert_array_equal(actual, desired)\n        self.set_seed()\n        actual = binom(n * 3, p, size=(3,))\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, binom, bad_n * 3, p)\n        assert_raises(ValueError, binom, n * 3, bad_p_one)\n        assert_raises(ValueError, binom, n * 3, bad_p_two)\n\n        self.set_seed()\n        actual = binom(n, p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, binom, bad_n, p * 3)\n        assert_raises(ValueError, binom, n, bad_p_one * 3)\n        assert_raises(ValueError, binom, n, bad_p_two * 3)\n\n    def test_negative_binomial(self):\n        n = [1]\n        p = [0.5]\n        bad_n = [-1]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        neg_binom = random.negative_binomial\n        desired = np.array([3, 1, 2], dtype=np.int64)\n\n        self.set_seed()\n        actual = neg_binom(n * 3, p)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, neg_binom, bad_n * 3, p)\n        assert_raises(ValueError, neg_binom, n * 3, bad_p_one)\n        assert_raises(ValueError, neg_binom, n * 3, bad_p_two)\n\n        self.set_seed()\n        actual = neg_binom(n, p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, neg_binom, bad_n, p * 3)\n        assert_raises(ValueError, neg_binom, n, bad_p_one * 3)\n        assert_raises(ValueError, neg_binom, n, bad_p_two * 3)\n\n    def test_poisson(self):\n        max_lam = random._poisson_lam_max\n\n        lam = [1]\n        bad_lam_one = [-1]\n        bad_lam_two = [max_lam * 2]\n        poisson = random.poisson\n        desired = np.array([1, 1, 0])\n\n        self.set_seed()\n        actual = poisson(lam * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, poisson, bad_lam_one * 3)\n        assert_raises(ValueError, poisson, bad_lam_two * 3)\n\n    def test_zipf(self):\n        a = [2]\n        bad_a = [0]\n        zipf = random.zipf\n        desired = np.array([2, 2, 1])\n\n        self.set_seed()\n        actual = zipf(a * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, zipf, bad_a * 3)\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, zipf, np.nan)\n            assert_raises(ValueError, zipf, [0, 0, np.nan])\n\n    def test_geometric(self):\n        p = [0.5]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        geom = random.geometric\n        desired = np.array([2, 2, 2])\n\n        self.set_seed()\n        actual = geom(p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, geom, bad_p_one * 3)\n        assert_raises(ValueError, geom, bad_p_two * 3)\n\n    def test_hypergeometric(self):\n        ngood = [1]\n        nbad = [2]\n        nsample = [2]\n        bad_ngood = [-1]\n        bad_nbad = [-2]\n        bad_nsample_one = [-1]\n        bad_nsample_two = [4]\n        desired = np.array([0, 0, 1])\n\n        random = Generator(MT19937(self.seed, mode=""legacy""))\n        actual = random.hypergeometric(ngood * 3, nbad, nsample)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, random.hypergeometric, bad_ngood * 3, nbad, nsample)\n        assert_raises(ValueError, random.hypergeometric, ngood * 3, bad_nbad, nsample)\n        assert_raises(\n            ValueError, random.hypergeometric, ngood * 3, nbad, bad_nsample_one\n        )\n        assert_raises(\n            ValueError, random.hypergeometric, ngood * 3, nbad, bad_nsample_two\n        )\n\n        random = Generator(MT19937(self.seed, mode=""legacy""))\n        actual = random.hypergeometric(ngood, nbad * 3, nsample)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, random.hypergeometric, bad_ngood, nbad * 3, nsample)\n        assert_raises(ValueError, random.hypergeometric, ngood, bad_nbad * 3, nsample)\n        assert_raises(\n            ValueError, random.hypergeometric, ngood, nbad * 3, bad_nsample_one\n        )\n        assert_raises(\n            ValueError, random.hypergeometric, ngood, nbad * 3, bad_nsample_two\n        )\n\n        random = Generator(MT19937(self.seed, mode=""legacy""))\n        hypergeom = random.hypergeometric\n        actual = hypergeom(ngood, nbad, nsample * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, hypergeom, bad_ngood, nbad, nsample * 3)\n        assert_raises(ValueError, hypergeom, ngood, bad_nbad, nsample * 3)\n        assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_one * 3)\n        assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_two * 3)\n\n        assert_raises(ValueError, hypergeom, -1, 10, 20)\n        assert_raises(ValueError, hypergeom, 10, -1, 20)\n        assert_raises(ValueError, hypergeom, 10, 10, -1)\n        assert_raises(ValueError, hypergeom, 10, 10, 25)\n\n        # ValueError for arguments that are too big.\n        assert_raises(ValueError, hypergeom, 2 ** 30, 10, 20)\n        assert_raises(ValueError, hypergeom, 999, 2 ** 31, 50)\n        assert_raises(ValueError, hypergeom, 999, [2 ** 29, 2 ** 30], 1000)\n\n    def test_logseries(self):\n        p = [0.5]\n        bad_p_one = [2]\n        bad_p_two = [-1]\n        logseries = random.logseries\n        desired = np.array([1, 1, 1])\n\n        self.set_seed()\n        actual = logseries(p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, logseries, bad_p_one * 3)\n        assert_raises(ValueError, logseries, bad_p_two * 3)\n\n    def test_complex_normal(self):\n        random.bit_generator.seed(self.seed)\n        loc = np.ones((1, 2))\n        gamma = np.ones((3, 1))\n        relation = 0.5 * np.ones((3, 2))\n        actual = random.complex_normal(loc=loc, gamma=gamma, relation=relation)\n        desired = np.array(\n            [\n                [\n                    1.393937478212015 - 0.31374589731830593j,\n                    0.9474905694736895 - 0.16424530802218726j,\n                ],\n                [\n                    1.119247463119766 + 0.023956373851168843j,\n                    0.8776366291514774 + 0.2865220655803411j,\n                ],\n                [\n                    0.5515508326417458 - 0.15986016780453596j,\n                    -0.6803993941303332 + 1.1782711493556892j,\n                ],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.complex_normal(loc=loc, gamma=1.0, relation=0.5, size=(3, 2))\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_multinomial(self):\n        random.bit_generator.seed(self.seed)\n        actual = random.multinomial([5, 20], [1 / 6.0] * 6, size=(3, 2))\n        desired = np.array(\n            [\n                [[1, 1, 1, 1, 0, 1], [4, 5, 1, 4, 3, 3]],\n                [[1, 1, 1, 0, 0, 2], [2, 0, 4, 3, 7, 4]],\n                [[1, 2, 0, 0, 2, 0], [3, 2, 3, 4, 2, 6]],\n            ],\n            dtype=np.int64,\n        )\n        assert_array_equal(actual, desired)\n\n        random.bit_generator.seed(self.seed)\n        actual = random.multinomial([5, 20], [1 / 6.0] * 6)\n        desired = np.array([[1, 1, 1, 1, 0, 1], [4, 5, 1, 4, 3, 3]], dtype=np.int64)\n        assert_array_equal(actual, desired)\n\n\nclass TestThread(object):\n    # make sure each state produces the same sequence even in threads\n    def setup(self):\n        self.seeds = range(4)\n\n    def check_function(self, function, sz):\n        from threading import Thread\n\n        out1 = np.empty((len(self.seeds),) + sz)\n        out2 = np.empty((len(self.seeds),) + sz)\n\n        # threaded generation\n        t = [\n            Thread(target=function, args=(Generator(MT19937(s, mode=""legacy"")), o))\n            for s, o in zip(self.seeds, out1)\n        ]\n        [x.start() for x in t]\n        [x.join() for x in t]\n\n        # the same serial\n        for s, o in zip(self.seeds, out2):\n            function(Generator(MT19937(s, mode=""legacy"")), o)\n\n        # these platforms change x87 fpu precision mode in threads\n        if np.intp().dtype.itemsize == 4 and sys.platform == ""win32"":\n            assert_array_almost_equal(out1, out2)\n        else:\n            assert_array_equal(out1, out2)\n\n    def test_normal(self):\n        def gen_random(state, out):\n            out[...] = state.normal(size=10000)\n\n        self.check_function(gen_random, sz=(10000,))\n\n    def test_exp(self):\n        def gen_random(state, out):\n            out[...] = state.exponential(scale=np.ones((100, 1000)))\n\n        self.check_function(gen_random, sz=(100, 1000))\n\n    def test_multinomial(self):\n        def gen_random(state, out):\n            out[...] = state.multinomial(10, [1 / 6.0] * 6, size=10000)\n\n        self.check_function(gen_random, sz=(10000, 6))\n\n\n# See Issue #4263\nclass TestSingleEltArrayInput(object):\n    def setup(self):\n        self.argOne = np.array([2])\n        self.argTwo = np.array([3])\n        self.argThree = np.array([4])\n        self.tgtShape = (1,)\n\n    def test_one_arg_funcs(self):\n        funcs = (\n            random.exponential,\n            random.standard_gamma,\n            random.chisquare,\n            random.standard_t,\n            random.pareto,\n            random.weibull,\n            random.power,\n            random.rayleigh,\n            random.poisson,\n            random.zipf,\n            random.geometric,\n            random.logseries,\n        )\n\n        probfuncs = (random.geometric, random.logseries)\n\n        for func in funcs:\n            if func in probfuncs:  # p < 1.0\n                out = func(np.array([0.5]))\n\n            else:\n                out = func(self.argOne)\n\n            assert_equal(out.shape, self.tgtShape)\n\n    def test_two_arg_funcs(self):\n        funcs = (\n            random.uniform,\n            random.normal,\n            random.beta,\n            random.gamma,\n            random.f,\n            random.noncentral_chisquare,\n            random.vonmises,\n            random.laplace,\n            random.gumbel,\n            random.logistic,\n            random.lognormal,\n            random.wald,\n            random.binomial,\n            random.negative_binomial,\n        )\n\n        probfuncs = (random.binomial, random.negative_binomial)\n\n        for func in funcs:\n            if func in probfuncs:  # p <= 1\n                argTwo = np.array([0.5])\n\n            else:\n                argTwo = self.argTwo\n\n            out = func(self.argOne, argTwo)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne[0], argTwo)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne, argTwo[0])\n            assert_equal(out.shape, self.tgtShape)\n\n    def test_integers(self, endpoint):\n        itype = [\n            np.bool,\n            np.int8,\n            np.uint8,\n            np.int16,\n            np.uint16,\n            np.int32,\n            np.uint32,\n            np.int64,\n            np.uint64,\n        ]\n        func = random.integers\n        high = np.array([1])\n        low = np.array([0])\n\n        for dt in itype:\n            out = func(low, high, endpoint=endpoint, dtype=dt)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(low[0], high, endpoint=endpoint, dtype=dt)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(low, high[0], endpoint=endpoint, dtype=dt)\n            assert_equal(out.shape, self.tgtShape)\n\n    def test_three_arg_funcs(self):\n        funcs = [random.noncentral_f, random.triangular, random.hypergeometric]\n\n        for func in funcs:\n            out = func(self.argOne, self.argTwo, self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne[0], self.argTwo, self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne, self.argTwo[0], self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n\ndef test_seed_equivalence():\n    random.seed(0)\n    state = random.state\n    random.seed(1)\n    random.bit_generator.seed(0)\n    bit_generator_state = random.bit_generator.state\n    assert_state_equal(state, bit_generator_state)\n    random.seed(1)\n    random.state = state\n    assert_state_equal(state, random.state)\n\n\ndef test_get_state():\n    state = random.state\n    get_state = random.__getstate__()\n    assert state[""state""][""pos""] == get_state[""state""][""pos""]\n    assert np.all(state[""state""][""key""] == get_state[""state""][""key""])\n\n\n@pytest.mark.skipif(NP_LT_118, reason=""Can only test with NumPy >= 1.18"")\n@pytest.mark.parametrize(""config"", list(JUMP_TEST_DATA.keys()))\ndef test_jumped(config):\n    values = JUMP_TEST_DATA[config]\n    typ, seed_tpl, step = config\n\n    seed = seed_tpl[0] if len(seed_tpl) == 1 else list(seed_tpl)\n    initial_state = np.random.MT19937(seed).state\n    mt19937 = MT19937(mode=""sequence"")\n    mt19937.state = initial_state\n    mt19937.random_raw(step)\n    if typ == ""jumped"":\n        jumped = mt19937.jumped()\n    else:\n        jumped = mt19937._jump_tester()\n    key = jumped.state[""state""][""key""]\n    if sys.byteorder == ""big"":\n        key = key.byteswap()\n    md5 = hashlib.md5(key)\n    assert md5.hexdigest() == values[""jumped""][""key_md5""]\n    assert jumped.state[""state""][""pos""] == values[""jumped""][""pos""]\n\n\ndef test_broadcast_size_error():\n    mu = np.ones(3)\n    sigma = np.ones((4, 3))\n    size = (10, 4, 2)\n    assert random.normal(mu, sigma, size=(5, 4, 3)).shape == (5, 4, 3)\n    with pytest.raises(ValueError):\n        random.normal(mu, sigma, size=size)\n    with pytest.raises(ValueError):\n        random.normal(mu, sigma, size=(1, 3))\n    with pytest.raises(ValueError):\n        random.normal(mu, sigma, size=(4, 1, 1))\n    # 1 arg\n    shape = np.ones((4, 3))\n    with pytest.raises(ValueError):\n        random.standard_gamma(shape, size=size)\n    with pytest.raises(ValueError):\n        random.standard_gamma(shape, size=(3,))\n    with pytest.raises(ValueError):\n        random.standard_gamma(shape, size=3)\n    # Check out\n    out = np.empty(size)\n    with pytest.raises(ValueError):\n        random.standard_gamma(shape, out=out)\n\n    # 3 arg\n    a = random.chisquare(5, size=3)\n    b = random.chisquare(5, size=(4, 3))\n    c = random.chisquare(5, size=(5, 4, 3))\n    assert random.noncentral_f(a, b, c).shape == (5, 4, 3)\n    with pytest.raises(ValueError, match=r""Output size \\(6, 5, 1, 1\\) is""):\n        random.noncentral_f(a, b, c, size=(6, 5, 1, 1))\n\n\ndef test_broadcast_size_scalar():\n    mu = np.ones(3)\n    sigma = np.ones(3)\n    random.normal(mu, sigma, size=3)\n    with pytest.raises(ValueError):\n        random.normal(mu, sigma, size=2)\n'"
randomgen/tests/test_generator_mt19937_regressions.py,25,"b'import numpy as np\nfrom numpy.compat import long\nfrom numpy.testing import assert_, assert_array_equal\nimport pytest\n\nfrom randomgen import MT19937, Generator\n\nmt19937 = Generator(MT19937(mode=""legacy""))\n\n\nclass TestRegression(object):\n    def test_VonMises_range(self):\n        # Make sure generated random variables are in [-pi, pi].\n        # Regression test for ticket #986.\n        for mu in np.linspace(-7.0, 7.0, 5):\n            r = mt19937.vonmises(mu, 1, 50)\n            assert_(np.all(r > -np.pi) and np.all(r <= np.pi))\n\n    def test_hypergeometric_range(self):\n        # Test for ticket #921\n        assert_(np.all(mt19937.hypergeometric(3, 18, 11, size=10) < 4))\n        assert_(np.all(mt19937.hypergeometric(18, 3, 11, size=10) > 0))\n\n        # Test for ticket #5623\n        args = (2 ** 20 - 2, 2 ** 20 - 2, 2 ** 20 - 2)  # Check for 32-bit systems\n        assert_(mt19937.hypergeometric(*args) > 0)\n\n    def test_logseries_convergence(self):\n        # Test for ticket #923\n        N = 1000\n        mt19937.bit_generator.seed(0)\n        rvsn = mt19937.logseries(0.8, size=N)\n        # these two frequency counts should be close to theoretical\n        # numbers with this large sample\n        # theoretical large N result is 0.49706795\n        freq = np.sum(rvsn == 1) / float(N)\n        msg = ""Frequency was %f, should be > 0.45"" % freq\n        assert_(freq > 0.45, msg)\n        # theoretical large N result is 0.19882718\n        freq = np.sum(rvsn == 2) / float(N)\n        msg = ""Frequency was %f, should be < 0.23"" % freq\n        assert_(freq < 0.23, msg)\n\n    def test_permutation_longs(self):\n        mt19937.bit_generator.seed(1234)\n        a = mt19937.permutation(12)\n        mt19937.bit_generator.seed(1234)\n        b = mt19937.permutation(long(12))\n        assert_array_equal(a, b)\n\n    def test_shuffle_mixed_dimension(self):\n        # Test for trac ticket #2074\n        for t in [\n            [1, 2, 3, None],\n            [(1, 1), (2, 2), (3, 3), None],\n            [1, (2, 2), (3, 3), None],\n            [(1, 1), 2, 3, None],\n        ]:\n            mt19937.bit_generator.seed(12345)\n            shuffled = np.array(list(t), dtype=np.object)\n            mt19937.shuffle(shuffled)\n            assert_array_equal(\n                shuffled, np.array([t[0], t[3], t[1], t[2]], dtype=np.object)\n            )\n\n    def test_call_within_randomstate(self):\n        # Check that custom RandomState does not call into global state\n        m = Generator(MT19937(mode=""legacy""))  # mt19937.RandomState()\n        res = np.array([0, 8, 7, 2, 1, 9, 4, 7, 0, 3])\n        for i in range(3):\n            mt19937.bit_generator.seed(i)\n            m.bit_generator.seed(4321)\n            # If m.state is not honored, the result will change\n            assert_array_equal(m.choice(10, size=10, p=np.ones(10) / 10.0), res)\n\n    def test_multivariate_normal_size_types(self):\n        # Test for multivariate_normal issue with ""size"" argument.\n        # Check that the multivariate_normal size argument can be a\n        # numpy integer.\n        mt19937.multivariate_normal([0], [[0]], size=1)\n        mt19937.multivariate_normal([0], [[0]], size=np.int_(1))\n        mt19937.multivariate_normal([0], [[0]], size=np.int64(1))\n\n    def test_beta_small_parameters(self):\n        # Test that beta with small a and b parameters does not produce\n        # NaNs due to roundoff errors causing 0 / 0, gh-5851\n        mt19937.bit_generator.seed(1234567890)\n        x = mt19937.beta(0.0001, 0.0001, size=100)\n        assert_(not np.any(np.isnan(x)), ""Nans in mt19937.beta"")\n\n    def test_choice_sum_of_probs_tolerance(self):\n        # The sum of probs should be 1.0 with some tolerance.\n        # For low precision dtypes the tolerance was too tight.\n        # See numpy github issue 6123.\n        mt19937.bit_generator.seed(1234)\n        a = [1, 2, 3]\n        counts = [4, 4, 2]\n        for dt in np.float16, np.float32, np.float64:\n            probs = np.array(counts, dtype=dt) / sum(counts)\n            c = mt19937.choice(a, p=probs)\n            assert_(c in a)\n            with pytest.raises(ValueError):\n                mt19937.choice(a, p=probs * 0.9)\n\n    def test_shuffle_of_array_of_different_length_strings(self):\n        # Test that permuting an array of different length strings\n        # will not cause a segfault on garbage collection\n        # Tests gh-7710\n        mt19937.bit_generator.seed(1234)\n\n        a = np.array([""a"", ""a"" * 1000])\n\n        for _ in range(100):\n            mt19937.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n\n        gc.collect()\n\n    def test_shuffle_of_array_of_objects(self):\n        # Test that permuting an array of objects will not cause\n        # a segfault on garbage collection.\n        # See gh-7719\n        mt19937.bit_generator.seed(1234)\n        a = np.array([np.arange(1), np.arange(4)], dtype=np.object)\n\n        for _ in range(1000):\n            mt19937.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n\n        gc.collect()\n\n    def test_permutation_subclass(self):\n        class N(np.ndarray):\n            pass\n\n        mt19937.bit_generator.seed(1)\n        orig = np.arange(3).view(N)\n        perm = mt19937.permutation(orig)\n        assert_array_equal(perm, np.array([0, 2, 1]))\n        assert_array_equal(orig, np.arange(3).view(N))\n\n        class M(object):\n            a = np.arange(5)\n\n            def __array__(self):\n                return self.a\n\n        mt19937.bit_generator.seed(1)\n        m = M()\n        perm = mt19937.permutation(m)\n        assert_array_equal(perm, np.array([2, 1, 4, 0, 3]))\n        assert_array_equal(m.__array__(), np.arange(5))\n\n    def test_gamma_0(self):\n        assert mt19937.standard_gamma(0.0) == 0.0\n        assert_array_equal(mt19937.standard_gamma([0.0]), 0.0)\n\n        actual = mt19937.standard_gamma([0.0], dtype=""float"")\n        expected = np.array([0.0], dtype=np.float32)\n        assert_array_equal(actual, expected)\n'"
randomgen/tests/test_randomstate.py,245,"b'import hashlib\nimport pickle\nimport sys\nimport warnings\n\nimport numpy as np\nfrom numpy.testing import (\n    assert_,\n    assert_array_almost_equal,\n    assert_array_equal,\n    assert_equal,\n    assert_no_warnings,\n    assert_raises,\n    assert_warns,\n    suppress_warnings,\n)\nimport pytest\n\nfrom randomgen.mt19937 import MT19937\nimport randomgen.mtrand\nfrom randomgen.xoshiro256 import Xoshiro256\n\nrandom = randomgen.mtrand\n\nINT_FUNCS = {\n    ""binomial"": (100.0, 0.6),\n    ""geometric"": (0.5,),\n    ""hypergeometric"": (20, 20, 10),\n    ""logseries"": (0.5,),\n    ""multinomial"": (20, np.ones(6) / 6.0),\n    ""negative_binomial"": (100, 0.5),\n    ""poisson"": (10.0,),\n    ""zipf"": (2,),\n}\n\nif np.iinfo(int).max < 2 ** 32:\n    # Windows and some 32-bit platforms, e.g., ARM\n    INT_FUNC_HASHES = {\n        ""binomial"": ""670e1c04223ffdbab27e08fbbad7bdba"",\n        ""logseries"": ""6bd0183d2f8030c61b0d6e11aaa60caf"",\n        ""geometric"": ""6e9df886f3e1e15a643168568d5280c0"",\n        ""hypergeometric"": ""7964aa611b046aecd33063b90f4dec06"",\n        ""multinomial"": ""68a0b049c16411ed0aa4aff3572431e4"",\n        ""negative_binomial"": ""dc265219eec62b4338d39f849cd36d09"",\n        ""poisson"": ""7b4dce8e43552fc82701c2fa8e94dc6e"",\n        ""zipf"": ""fcd2a2095f34578723ac45e43aca48c5"",\n    }\nelse:\n    INT_FUNC_HASHES = {\n        ""binomial"": ""b5f8dcd74f172836536deb3547257b14"",\n        ""geometric"": ""8814571f45c87c59699d62ccd3d6c350"",\n        ""hypergeometric"": ""bc64ae5976eac452115a16dad2dcf642"",\n        ""logseries"": ""84be924b37485a27c4a98797bc88a7a4"",\n        ""multinomial"": ""ec3c7f9cf9664044bb0c6fb106934200"",\n        ""negative_binomial"": ""210533b2234943591364d0117a552969"",\n        ""poisson"": ""0536a8850c79da0c78defd742dccc3e0"",\n        ""zipf"": ""f2841f504dd2525cd67cdcad7561e532"",\n    }\n\n\n@pytest.fixture(scope=""module"", params=INT_FUNCS)\ndef int_func(request):\n    return (request.param, INT_FUNCS[request.param], INT_FUNC_HASHES[request.param])\n\n\ndef assert_mt19937_state_equal(a, b):\n    assert_equal(a[""bit_generator""], b[""bit_generator""])\n    assert_array_equal(a[""state""][""key""], b[""state""][""key""])\n    assert_array_equal(a[""state""][""pos""], b[""state""][""pos""])\n    assert_equal(a[""has_gauss""], b[""has_gauss""])\n    assert_equal(a[""gauss""], b[""gauss""])\n\n\nclass TestSeed(object):\n    def test_scalar(self):\n        s = random.RandomState(0)\n        assert_equal(s.randint(1000), 684)\n        s = random.RandomState(4294967295)\n        assert_equal(s.randint(1000), 419)\n\n    def test_array(self):\n        s = random.RandomState(range(10))\n        assert_equal(s.randint(1000), 468)\n        s = random.RandomState(np.arange(10))\n        assert_equal(s.randint(1000), 468)\n        s = random.RandomState([0])\n        assert_equal(s.randint(1000), 973)\n        s = random.RandomState([4294967295])\n        assert_equal(s.randint(1000), 265)\n\n    def test_invalid_scalar(self):\n        # seed must be an unsigned 32 bit integer\n        assert_raises(TypeError, random.RandomState, -0.5)\n        assert_raises(ValueError, random.RandomState, -1)\n\n    def test_invalid_array(self):\n        # seed must be an unsigned 32 bit integer\n        assert_raises(TypeError, random.RandomState, [-0.5])\n        assert_raises(ValueError, random.RandomState, [-1])\n        assert_raises(ValueError, random.RandomState, [4294967296])\n        assert_raises(ValueError, random.RandomState, [1, 2, 4294967296])\n        assert_raises(ValueError, random.RandomState, [1, -2, 4294967296])\n\n    def test_invalid_array_shape(self):\n        # gh-9832\n        assert_raises(ValueError, random.RandomState, np.array([], dtype=np.int64))\n        assert_raises(ValueError, random.RandomState, [[1, 2, 3]])\n        assert_raises(ValueError, random.RandomState, [[1, 2, 3], [4, 5, 6]])\n\n    def test_seed_equivalency(self):\n        rs = random.RandomState(0)\n        rs2 = random.RandomState(MT19937(0, mode=""legacy""))\n        assert_mt19937_state_equal(\n            rs.get_state(legacy=False), rs2.get_state(legacy=False)\n        )\n\n    def test_invalid_initialization(self):\n        assert_raises(ValueError, random.RandomState, MT19937)\n\n\nclass TestBinomial(object):\n    def test_n_zero(self):\n        # Tests the corner case of n == 0 for the binomial distribution.\n        # binomial(0, p) should be zero for any p in [0, 1].\n        # This test addresses issue #3480.\n        zeros = np.zeros(2, dtype=""int"")\n        for p in [0, 0.5, 1]:\n            assert_(random.binomial(0, p) == 0)\n            assert_array_equal(random.binomial(zeros, p), zeros)\n\n    def test_p_is_nan(self):\n        # Issue #4571.\n        assert_raises(ValueError, random.binomial, 1, np.nan)\n\n\nclass TestMultinomial(object):\n    def test_basic(self):\n        random.multinomial(100, [0.2, 0.8])\n\n    def test_zero_probability(self):\n        random.multinomial(100, [0.2, 0.8, 0.0, 0.0, 0.0])\n\n    def test_int_negative_interval(self):\n        assert_(-5 <= random.randint(-5, -1) < -1)\n        x = random.randint(-5, -1, 5)\n        assert_(np.all(-5 <= x))\n        assert_(np.all(x < -1))\n\n    def test_size(self):\n        # gh-3173\n        p = [0.5, 0.5]\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.multinomial(1, p, [2, 2]).shape, (2, 2, 2))\n        assert_equal(random.multinomial(1, p, (2, 2)).shape, (2, 2, 2))\n        assert_equal(random.multinomial(1, p, np.array((2, 2))).shape, (2, 2, 2))\n\n        assert_raises(TypeError, random.multinomial, 1, p, float(1))\n\n    def test_invalid_prob(self):\n        assert_raises(ValueError, random.multinomial, 100, [1.1, 0.2])\n        assert_raises(ValueError, random.multinomial, 100, [-0.1, 0.9])\n\n    def test_invalid_n(self):\n        assert_raises(ValueError, random.multinomial, -1, [0.8, 0.2])\n\n    def test_p_noncontiguous(self):\n        p = np.arange(15.0)\n        p /= np.sum(p[1::3])\n        pvals = p[1::3]\n        random.seed(1432985819)\n        non_contig = random.multinomial(100, pvals=pvals)\n        random.seed(1432985819)\n        contig = random.multinomial(100, pvals=np.ascontiguousarray(pvals))\n        assert_array_equal(non_contig, contig)\n\n    def test_large_p(self):\n        with pytest.raises(ValueError, match=r""sum\\(pvals""):\n            random.multinomial(100, np.array([0.7, 0.6, 0.5, 0]))\n\n\nclass TestSetState(object):\n    def setup(self):\n        self.seed = 1234567890\n        self.random_state = random.RandomState(self.seed)\n        self.state = self.random_state.get_state()\n\n    def test_basic(self):\n        old = self.random_state.tomaxint(16)\n        self.random_state.set_state(self.state)\n        new = self.random_state.tomaxint(16)\n        assert_(np.all(old == new))\n\n    def test_gaussian_reset(self):\n        # Make sure the cached every-other-Gaussian is reset.\n        old = self.random_state.standard_normal(size=3)\n        self.random_state.set_state(self.state)\n        new = self.random_state.standard_normal(size=3)\n        assert_(np.all(old == new))\n\n    def test_gaussian_reset_in_media_res(self):\n        # When the state is saved with a cached Gaussian, make sure the\n        # cached Gaussian is restored.\n\n        self.random_state.standard_normal()\n        state = self.random_state.get_state()\n        old = self.random_state.standard_normal(size=3)\n        self.random_state.set_state(state)\n        new = self.random_state.standard_normal(size=3)\n        assert_(np.all(old == new))\n\n    def test_backwards_compatibility(self):\n        # Make sure we can accept old state tuples that do not have the\n        # cached Gaussian value.\n        old_state = self.state[:-2]\n        x1 = self.random_state.standard_normal(size=16)\n        self.random_state.set_state(old_state)\n        x2 = self.random_state.standard_normal(size=16)\n        self.random_state.set_state(self.state)\n        x3 = self.random_state.standard_normal(size=16)\n        assert_(np.all(x1 == x2))\n        assert_(np.all(x1 == x3))\n\n    def test_negative_binomial(self):\n        # Ensure that the negative binomial results take floating point\n        # arguments without truncation.\n        self.random_state.negative_binomial(0.5, 0.5)\n\n    def test_get_state_warning(self):\n        rs = random.RandomState(Xoshiro256(mode=""legacy""))\n        with suppress_warnings() as sup:\n            w = sup.record(RuntimeWarning)\n            state = rs.get_state()\n            assert_(len(w) == 1)\n            assert isinstance(state, dict)\n            assert state[""bit_generator""] == ""Xoshiro256""\n\n    def test_invalid_legacy_state_setting(self):\n        state = self.random_state.get_state()\n        new_state = (""Unknown"",) + state[1:]\n        assert_raises(ValueError, self.random_state.set_state, new_state)\n        assert_raises(\n            TypeError, self.random_state.set_state, np.array(new_state, dtype=np.object)\n        )\n        state = self.random_state.get_state(legacy=False)\n        del state[""bit_generator""]\n        assert_raises(ValueError, self.random_state.set_state, state)\n\n    def test_pickle(self):\n        self.random_state.seed(0)\n        self.random_state.random_sample(100)\n        self.random_state.standard_normal()\n        pickled = self.random_state.get_state(legacy=False)\n        assert_equal(pickled[""has_gauss""], 1)\n        rs_unpick = pickle.loads(pickle.dumps(self.random_state))\n        unpickled = rs_unpick.get_state(legacy=False)\n        assert_mt19937_state_equal(pickled, unpickled)\n\n    def test_state_setting(self):\n        attr_state = self.random_state.__getstate__()\n        self.random_state.standard_normal()\n        self.random_state.__setstate__(attr_state)\n        state = self.random_state.get_state(legacy=False)\n        assert_mt19937_state_equal(attr_state, state)\n\n    def test_repr(self):\n        assert repr(self.random_state).startswith(""RandomState(MT19937)"")\n\n\nclass TestRandint(object):\n\n    rfunc = random.randint\n\n    # valid integer/boolean types\n    itype = [\n        np.bool_,\n        np.int8,\n        np.uint8,\n        np.int16,\n        np.uint16,\n        np.int32,\n        np.uint32,\n        np.int64,\n        np.uint64,\n    ]\n\n    def test_unsupported_type(self):\n        assert_raises(TypeError, self.rfunc, 1, dtype=float)\n\n    def test_bounds_checking(self):\n        for dt in self.itype:\n            lbnd = 0 if dt is np.bool_ else np.iinfo(dt).min\n            ubnd = 2 if dt is np.bool_ else np.iinfo(dt).max + 1\n            assert_raises(ValueError, self.rfunc, lbnd - 1, ubnd, dtype=dt)\n            assert_raises(ValueError, self.rfunc, lbnd, ubnd + 1, dtype=dt)\n            assert_raises(ValueError, self.rfunc, ubnd, lbnd, dtype=dt)\n            assert_raises(ValueError, self.rfunc, 1, 0, dtype=dt)\n\n    def test_rng_zero_and_extremes(self):\n        for dt in self.itype:\n            lbnd = 0 if dt is np.bool_ else np.iinfo(dt).min\n            ubnd = 2 if dt is np.bool_ else np.iinfo(dt).max + 1\n\n            tgt = ubnd - 1\n            assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)\n\n            tgt = lbnd\n            assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)\n\n            tgt = (lbnd + ubnd) // 2\n            assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)\n\n    def test_full_range(self):\n        # Test for ticket #1690\n\n        for dt in self.itype:\n            lbnd = 0 if dt is np.bool_ else np.iinfo(dt).min\n            ubnd = 2 if dt is np.bool_ else np.iinfo(dt).max + 1\n\n            try:\n                self.rfunc(lbnd, ubnd, dtype=dt)\n            except Exception as e:\n                raise AssertionError(\n                    ""No error should have been raised, ""\n                    ""but one was with the following ""\n                    ""message:\\n\\n%s"" % str(e)\n                )\n\n    def test_in_bounds_fuzz(self):\n        # Don""t use fixed seed\n        random.seed()\n\n        for dt in self.itype[1:]:\n            for ubnd in [4, 8, 16]:\n                vals = self.rfunc(2, ubnd, size=2 ** 16, dtype=dt)\n                assert_(vals.max() < ubnd)\n                assert_(vals.min() >= 2)\n\n        vals = self.rfunc(0, 2, size=2 ** 16, dtype=np.bool_)\n\n        assert_(vals.max() < 2)\n        assert_(vals.min() >= 0)\n\n    def test_repeatability(self):\n        # We use a md5 hash of generated sequences of 1000 samples\n        # in the range [0, 6) for all but bool, where the range\n        # is [0, 2). Hashes are for little endian numbers.\n        tgt = {\n            ""bool"": ""7dd3170d7aa461d201a65f8bcf3944b0"",\n            ""int16"": ""1b7741b80964bb190c50d541dca1cac1"",\n            ""int32"": ""4dc9fcc2b395577ebb51793e58ed1a05"",\n            ""int64"": ""17db902806f448331b5a758d7d2ee672"",\n            ""int8"": ""27dd30c4e08a797063dffac2490b0be6"",\n            ""uint16"": ""1b7741b80964bb190c50d541dca1cac1"",\n            ""uint32"": ""4dc9fcc2b395577ebb51793e58ed1a05"",\n            ""uint64"": ""17db902806f448331b5a758d7d2ee672"",\n            ""uint8"": ""27dd30c4e08a797063dffac2490b0be6"",\n        }\n\n        for dt in self.itype[1:]:\n            random.seed(1234)\n\n            # view as little endian for hash\n            if sys.byteorder == ""little"":\n                val = self.rfunc(0, 6, size=1000, dtype=dt)\n            else:\n                val = self.rfunc(0, 6, size=1000, dtype=dt).byteswap()\n\n            res = hashlib.md5(val.view(np.int8)).hexdigest()\n            assert_(tgt[np.dtype(dt).name] == res)\n\n        # bools do not depend on endianness\n        random.seed(1234)\n        val = self.rfunc(0, 2, size=1000, dtype=bool).view(np.int8)\n        res = hashlib.md5(val).hexdigest()\n        assert_(tgt[np.dtype(bool).name] == res)\n\n    def test_int64_uint64_corner_case(self):\n        # When stored in Numpy arrays, `lbnd` is casted\n        # as np.int64, and `ubnd` is casted as np.uint64.\n        # Checking whether `lbnd` >= `ubnd` used to be\n        # done solely via direct comparison, which is incorrect\n        # because when Numpy tries to compare both numbers,\n        # it casts both to np.float64 because there is\n        # no integer superset of np.int64 and np.uint64. However,\n        # `ubnd` is too large to be represented in np.float64,\n        # causing it be round down to np.iinfo(np.int64).max,\n        # leading to a ValueError because `lbnd` now equals\n        # the new `ubnd`.\n\n        dt = np.int64\n        tgt = np.iinfo(np.int64).max\n        lbnd = np.int64(np.iinfo(np.int64).max)\n        ubnd = np.uint64(np.iinfo(np.int64).max + 1)\n\n        # None of these function calls should\n        # generate a ValueError now.\n        actual = random.randint(lbnd, ubnd, dtype=dt)\n        assert_equal(actual, tgt)\n\n    def test_respect_dtype_singleton(self):\n        # See gh-7203\n        for dt in self.itype:\n            lbnd = 0 if dt is np.bool_ else np.iinfo(dt).min\n            ubnd = 2 if dt is np.bool_ else np.iinfo(dt).max + 1\n\n            sample = self.rfunc(lbnd, ubnd, dtype=dt)\n            assert_equal(sample.dtype, np.dtype(dt))\n\n        for dt in (bool, int, np.long):\n            lbnd = 0 if dt is bool else np.iinfo(dt).min\n            ubnd = 2 if dt is bool else np.iinfo(dt).max + 1\n\n            # gh-7284: Ensure that we get Python data types\n            sample = self.rfunc(lbnd, ubnd, dtype=dt)\n            assert_(not hasattr(sample, ""dtype""))\n            assert_equal(type(sample), dt)\n\n\nclass TestRandomDist(object):\n    # Make sure the random distribution returns the correct value for a\n    # given seed\n\n    def setup(self):\n        self.seed = 1234567890\n\n    def test_rand(self):\n        random.seed(self.seed)\n        actual = random.rand(3, 2)\n        desired = np.array(\n            [\n                [0.61879477158567997, 0.59162362775974664],\n                [0.88868358904449662, 0.89165480011560816],\n                [0.4575674820298663, 0.7781880808593471],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_rand_singleton(self):\n        random.seed(self.seed)\n        actual = random.rand()\n        desired = 0.61879477158567997\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_randn(self):\n        random.seed(self.seed)\n        actual = random.randn(3, 2)\n        desired = np.array(\n            [\n                [1.34016345771863121, 1.73759122771936081],\n                [1.498988344300628, -0.2286433324536169],\n                [2.031033998682787, 2.17032494605655257],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.seed(self.seed)\n        actual = random.randn()\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_randint(self):\n        random.seed(self.seed)\n        actual = random.randint(-99, 99, size=(3, 2))\n        desired = np.array([[31, 3], [-52, 41], [-48, -66]])\n        assert_array_equal(actual, desired)\n\n    def test_random_integers(self):\n        random.seed(self.seed)\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(-99, 99, size=(3, 2))\n            assert_(len(w) == 1)\n        desired = np.array([[31, 3], [-52, 41], [-48, -66]])\n        assert_array_equal(actual, desired)\n\n        random.seed(self.seed)\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(198, size=(3, 2))\n            assert_(len(w) == 1)\n        assert_array_equal(actual, desired + 100)\n\n    def test_tomaxint(self):\n        random.seed(self.seed)\n        rs = random.RandomState(self.seed)\n        actual = rs.tomaxint(size=(3, 2))\n        if np.iinfo(np.int).max == 2147483647:\n            desired = np.array(\n                [\n                    [1328851649, 731237375],\n                    [1270502067, 320041495],\n                    [1908433478, 499156889],\n                ],\n                dtype=np.int64,\n            )\n        else:\n            desired = np.array(\n                [\n                    [5707374374421908479, 5456764827585442327],\n                    [8196659375100692377, 8224063923314595285],\n                    [4220315081820346526, 7177518203184491332],\n                ],\n                dtype=np.int64,\n            )\n\n        assert_equal(actual, desired)\n\n        rs.seed(self.seed)\n        actual = rs.tomaxint()\n        assert_equal(actual, desired[0, 0])\n\n    def test_random_integers_max_int(self):\n        # Tests whether random_integers can generate the\n        # maximum allowed Python int that can be converted\n        # into a C long. Previous implementations of this\n        # method have thrown an OverflowError when attempting\n        # to generate this integer.\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            actual = random.random_integers(np.iinfo(""l"").max, np.iinfo(""l"").max)\n            assert_(len(w) == 1)\n\n        desired = np.iinfo(""l"").max\n        assert_equal(actual, desired)\n        with suppress_warnings() as sup:\n            w = sup.record(DeprecationWarning)\n            typer = np.dtype(""l"").type\n            actual = random.random_integers(\n                typer(np.iinfo(""l"").max), typer(np.iinfo(""l"").max)\n            )\n            assert_(len(w) == 1)\n        assert_equal(actual, desired)\n\n    def test_random_integers_deprecated(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter(""error"", DeprecationWarning)\n\n            # DeprecationWarning raised with high == None\n            assert_raises(DeprecationWarning, random.random_integers, np.iinfo(""l"").max)\n\n            # DeprecationWarning raised with high != None\n            assert_raises(\n                DeprecationWarning,\n                random.random_integers,\n                np.iinfo(""l"").max,\n                np.iinfo(""l"").max,\n            )\n\n    def test_random_sample(self):\n        random.seed(self.seed)\n        actual = random.random_sample((3, 2))\n        desired = np.array(\n            [\n                [0.61879477158567997, 0.59162362775974664],\n                [0.88868358904449662, 0.89165480011560816],\n                [0.4575674820298663, 0.7781880808593471],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        random.seed(self.seed)\n        actual = random.random_sample()\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_choice_uniform_replace(self):\n        random.seed(self.seed)\n        actual = random.choice(4, 4)\n        desired = np.array([2, 3, 2, 3])\n        assert_array_equal(actual, desired)\n\n    def test_choice_nonuniform_replace(self):\n        random.seed(self.seed)\n        actual = random.choice(4, 4, p=[0.4, 0.4, 0.1, 0.1])\n        desired = np.array([1, 1, 2, 2])\n        assert_array_equal(actual, desired)\n\n    def test_choice_uniform_noreplace(self):\n        random.seed(self.seed)\n        actual = random.choice(4, 3, replace=False)\n        desired = np.array([0, 1, 3])\n        assert_array_equal(actual, desired)\n\n    def test_choice_nonuniform_noreplace(self):\n        random.seed(self.seed)\n        actual = random.choice(4, 3, replace=False, p=[0.1, 0.3, 0.5, 0.1])\n        desired = np.array([2, 3, 1])\n        assert_array_equal(actual, desired)\n\n    def test_choice_noninteger(self):\n        random.seed(self.seed)\n        actual = random.choice([""a"", ""b"", ""c"", ""d""], 4)\n        desired = np.array([""c"", ""d"", ""c"", ""d""])\n        assert_array_equal(actual, desired)\n\n    def test_choice_exceptions(self):\n        sample = random.choice\n        assert_raises(ValueError, sample, -1, 3)\n        assert_raises(ValueError, sample, 3.0, 3)\n        assert_raises(ValueError, sample, [[1, 2], [3, 4]], 3)\n        assert_raises(ValueError, sample, [], 3)\n        assert_raises(\n            ValueError, sample, [1, 2, 3, 4], 3, p=[[0.25, 0.25], [0.25, 0.25]]\n        )\n        assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4, 0.2])\n        assert_raises(ValueError, sample, [1, 2], 3, p=[1.1, -0.1])\n        assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4])\n        assert_raises(ValueError, sample, [1, 2, 3], 4, replace=False)\n        # gh-13087\n        assert_raises(ValueError, sample, [1, 2, 3], -2, replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], (-1,), replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], (-1, 1), replace=False)\n        assert_raises(ValueError, sample, [1, 2, 3], 2, replace=False, p=[1, 0, 0])\n\n    def test_choice_return_shape(self):\n        p = [0.1, 0.9]\n        # Check scalar\n        assert_(np.isscalar(random.choice(2, replace=True)))\n        assert_(np.isscalar(random.choice(2, replace=False)))\n        assert_(np.isscalar(random.choice(2, replace=True, p=p)))\n        assert_(np.isscalar(random.choice(2, replace=False, p=p)))\n        assert_(np.isscalar(random.choice([1, 2], replace=True)))\n        assert_(random.choice([None], replace=True) is None)\n        a = np.array([1, 2])\n        arr = np.empty(1, dtype=object)\n        arr[0] = a\n        assert_(random.choice(arr, replace=True) is a)\n\n        # Check 0-d array\n        s = tuple()\n        assert_(not np.isscalar(random.choice(2, s, replace=True)))\n        assert_(not np.isscalar(random.choice(2, s, replace=False)))\n        assert_(not np.isscalar(random.choice(2, s, replace=True, p=p)))\n        assert_(not np.isscalar(random.choice(2, s, replace=False, p=p)))\n        assert_(not np.isscalar(random.choice([1, 2], s, replace=True)))\n        assert_(random.choice([None], s, replace=True).ndim == 0)\n        a = np.array([1, 2])\n        arr = np.empty(1, dtype=object)\n        arr[0] = a\n        assert_(random.choice(arr, s, replace=True).item() is a)\n\n        # Check multi dimensional array\n        s = (2, 3)\n        p = [0.1, 0.1, 0.1, 0.1, 0.4, 0.2]\n        assert_equal(random.choice(6, s, replace=True).shape, s)\n        assert_equal(random.choice(6, s, replace=False).shape, s)\n        assert_equal(random.choice(6, s, replace=True, p=p).shape, s)\n        assert_equal(random.choice(6, s, replace=False, p=p).shape, s)\n        assert_equal(random.choice(np.arange(6), s, replace=True).shape, s)\n\n        # Check zero-size\n        assert_equal(random.randint(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))\n        assert_equal(random.randint(0, -10, size=0).shape, (0,))\n        assert_equal(random.randint(10, 10, size=0).shape, (0,))\n        assert_equal(random.choice(0, size=0).shape, (0,))\n        assert_equal(random.choice([], size=(0,)).shape, (0,))\n        assert_equal(random.choice([""a"", ""b""], size=(3, 0, 4)).shape, (3, 0, 4))\n        assert_raises(ValueError, random.choice, [], 10)\n\n    def test_choice_nan_probabilities(self):\n        a = np.array([42, 1, 2])\n        p = [None, None, None]\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, random.choice, a, p=p)\n\n    def test_choice_nontintiguous(self):\n        p = np.ones(10) / 5\n        p[1::2] = 3.0\n        random.seed(self.seed)\n        choice1 = random.choice(5, 3, p=p[::2])\n        random.seed(self.seed)\n        choice2 = random.choice(5, 3, p=np.ascontiguousarray(p[::2]))\n        assert_array_equal(choice1, choice2)\n\n    def test_bytes(self):\n        random.seed(self.seed)\n        actual = random.bytes(10)\n        desired = b""\\x82Ui\\x9e\\xff\\x97+Wf\\xa5""\n        assert_equal(actual, desired)\n\n    def test_shuffle(self):\n        # Test lists, arrays (of various dtypes), and multidimensional versions\n        # of both, c-contiguous or not:\n        for conv in [\n            lambda x: np.array([]),\n            lambda x: x,\n            lambda x: np.asarray(x).astype(np.int8),\n            lambda x: np.asarray(x).astype(np.float32),\n            lambda x: np.asarray(x).astype(np.complex64),\n            lambda x: np.asarray(x).astype(object),\n            lambda x: [(i, i) for i in x],\n            lambda x: np.asarray([[i, i] for i in x]),\n            lambda x: np.vstack([x, x]).T,\n            # gh-11442\n            lambda x: (\n                np.asarray([(i, i) for i in x], [(""a"", int), (""b"", int)]).view(\n                    np.recarray\n                )\n            ),\n            # gh-4270\n            lambda x: np.asarray(\n                [(i, i) for i in x], [(""a"", (object, (1,))), (""b"", (np.int32, (1,)))]\n            ),\n        ]:\n            random.seed(self.seed)\n            alist = conv([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])\n            random.shuffle(alist)\n            actual = alist\n            desired = conv([0, 1, 9, 6, 2, 4, 5, 8, 7, 3])\n            assert_array_equal(actual, desired)\n\n    def test_shuffle_masked(self):\n        # gh-3263\n        a = np.ma.masked_values(np.reshape(range(20), (5, 4)) % 3 - 1, -1)\n        b = np.ma.masked_values(np.arange(20) % 3 - 1, -1)\n        a_orig = a.copy()\n        b_orig = b.copy()\n        for _ in range(50):\n            random.shuffle(a)\n            assert_equal(sorted(a.data[~a.mask]), sorted(a_orig.data[~a_orig.mask]))\n            random.shuffle(b)\n            assert_equal(sorted(b.data[~b.mask]), sorted(b_orig.data[~b_orig.mask]))\n\n    def test_permutation(self):\n        random.seed(self.seed)\n        alist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n        actual = random.permutation(alist)\n        desired = [0, 1, 9, 6, 2, 4, 5, 8, 7, 3]\n        assert_array_equal(actual, desired)\n\n        random.seed(self.seed)\n        arr_2d = np.atleast_2d([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]).T\n        actual = random.permutation(arr_2d)\n        assert_array_equal(actual, np.atleast_2d(desired).T)\n\n    def test_beta(self):\n        random.seed(self.seed)\n        actual = random.beta(0.1, 0.9, size=(3, 2))\n        desired = np.array(\n            [\n                [1.45341850513746058e-02, 5.31297615662868145e-04],\n                [1.85366619058432324e-06, 4.19214516800110563e-03],\n                [1.58405155108498093e-04, 1.26252891949397652e-04],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_binomial(self):\n        random.seed(self.seed)\n        actual = random.binomial(100.123, 0.456, size=(3, 2))\n        desired = np.array([[37, 43], [42, 48], [46, 45]])\n        assert_array_equal(actual, desired)\n\n        random.seed(self.seed)\n        actual = random.binomial(100.123, 0.456)\n        desired = 37\n        assert_array_equal(actual, desired)\n\n    def test_chisquare(self):\n        random.seed(self.seed)\n        actual = random.chisquare(50, size=(3, 2))\n        desired = np.array(\n            [\n                [63.87858175501090585, 68.68407748911370447],\n                [65.77116116901505904, 47.09686762438974483],\n                [72.3828403199695174, 74.18408615260374006],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=13)\n\n    def test_dirichlet(self):\n        random.seed(self.seed)\n        alpha = np.array([51.72840233779265162, 39.74494232180943953])\n        actual = random.dirichlet(alpha, size=(3, 2))\n        desired = np.array(\n            [\n                [\n                    [0.54539444573611562, 0.45460555426388438],\n                    [0.62345816822039413, 0.37654183177960598],\n                ],\n                [\n                    [0.55206000085785778, 0.44793999914214233],\n                    [0.58964023305154301, 0.41035976694845688],\n                ],\n                [\n                    [0.59266909280647828, 0.40733090719352177],\n                    [0.56974431743975207, 0.43025568256024799],\n                ],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n        bad_alpha = np.array([5.4e-01, -1.0e-16])\n        assert_raises(ValueError, random.dirichlet, bad_alpha)\n\n        random.seed(self.seed)\n        alpha = np.array([51.72840233779265162, 39.74494232180943953])\n        actual = random.dirichlet(alpha)\n        assert_array_almost_equal(actual, desired[0, 0], decimal=15)\n\n    def test_dirichlet_size(self):\n        # gh-3173\n        p = np.array([51.72840233779265162, 39.74494232180943953])\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))\n        assert_equal(random.dirichlet(p, [2, 2]).shape, (2, 2, 2))\n        assert_equal(random.dirichlet(p, (2, 2)).shape, (2, 2, 2))\n        assert_equal(random.dirichlet(p, np.array((2, 2))).shape, (2, 2, 2))\n\n        assert_raises(TypeError, random.dirichlet, p, float(1))\n\n    def test_dirichlet_bad_alpha(self):\n        # gh-2089\n        alpha = np.array([5.4e-01, -1.0e-16])\n        assert_raises(ValueError, random.dirichlet, alpha)\n\n    def test_dirichlet_non_contiguous_alpha(self):\n        a = np.array([51.72840233779265162, -1.0, 39.74494232180943953])\n        alpha = a[::2]\n        random.seed(self.seed)\n        non_contig = random.dirichlet(alpha, size=(3, 2))\n        random.seed(self.seed)\n        contig = random.dirichlet(np.ascontiguousarray(alpha), size=(3, 2))\n        assert_array_almost_equal(contig, non_contig)\n\n    def test_exponential(self):\n        random.seed(self.seed)\n        actual = random.exponential(1.1234, size=(3, 2))\n        desired = np.array(\n            [\n                [1.08342649775011624, 1.00607889924557314],\n                [2.46628830085216721, 2.49668106809923884],\n                [0.68717433461363442, 1.69175666993575979],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_exponential_0(self):\n        assert_equal(random.exponential(scale=0), 0)\n        assert_raises(ValueError, random.exponential, scale=-0.0)\n\n    def test_f(self):\n        random.seed(self.seed)\n        actual = random.f(12, 77, size=(3, 2))\n        desired = np.array(\n            [\n                [1.21975394418575878, 1.75135759791559775],\n                [1.44803115017146489, 1.22108959480396262],\n                [1.02176975757740629, 1.34431827623300415],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_gamma(self):\n        random.seed(self.seed)\n        actual = random.gamma(5, 3, size=(3, 2))\n        desired = np.array(\n            [\n                [24.60509188649287182, 28.54993563207210627],\n                [26.13476110204064184, 12.56988482927716078],\n                [31.71863275789960568, 33.30143302795922011],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_gamma_0(self):\n        assert_equal(random.gamma(shape=0, scale=0), 0)\n        assert_raises(ValueError, random.gamma, shape=-0.0, scale=-0.0)\n\n    def test_geometric(self):\n        random.seed(self.seed)\n        actual = random.geometric(0.123456789, size=(3, 2))\n        desired = np.array([[8, 7], [17, 17], [5, 12]])\n        assert_array_equal(actual, desired)\n\n    def test_geometric_exceptions(self):\n        assert_raises(ValueError, random.geometric, 1.1)\n        assert_raises(ValueError, random.geometric, [1.1] * 10)\n        assert_raises(ValueError, random.geometric, -0.1)\n        assert_raises(ValueError, random.geometric, [-0.1] * 10)\n        with suppress_warnings() as sup:\n            sup.record(RuntimeWarning)\n            assert_raises(ValueError, random.geometric, np.nan)\n            assert_raises(ValueError, random.geometric, [np.nan] * 10)\n\n    def test_gumbel(self):\n        random.seed(self.seed)\n        actual = random.gumbel(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [0.19591898743416816, 0.34405539668096674],\n                [-1.4492522252274278, -1.47374816298446865],\n                [1.10651090478803416, -0.69535848626236174],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_gumbel_0(self):\n        assert_equal(random.gumbel(scale=0), 0)\n        assert_raises(ValueError, random.gumbel, scale=-0.0)\n\n    def test_hypergeometric(self):\n        random.seed(self.seed)\n        actual = random.hypergeometric(10.1, 5.5, 14, size=(3, 2))\n        desired = np.array([[10, 10], [10, 10], [9, 9]])\n        assert_array_equal(actual, desired)\n\n        # Test nbad = 0\n        actual = random.hypergeometric(5, 0, 3, size=4)\n        desired = np.array([3, 3, 3, 3])\n        assert_array_equal(actual, desired)\n\n        actual = random.hypergeometric(15, 0, 12, size=4)\n        desired = np.array([12, 12, 12, 12])\n        assert_array_equal(actual, desired)\n\n        # Test ngood = 0\n        actual = random.hypergeometric(0, 5, 3, size=4)\n        desired = np.array([0, 0, 0, 0])\n        assert_array_equal(actual, desired)\n\n        actual = random.hypergeometric(0, 15, 12, size=4)\n        desired = np.array([0, 0, 0, 0])\n        assert_array_equal(actual, desired)\n\n    def test_laplace(self):\n        random.seed(self.seed)\n        actual = random.laplace(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [0.66599721112760157, 0.52829452552221945],\n                [3.12791959514407125, 3.18202813572992005],\n                [-0.05391065675859356, 1.74901336242837324],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_laplace_0(self):\n        assert_equal(random.laplace(scale=0), 0)\n        assert_raises(ValueError, random.laplace, scale=-0.0)\n\n    def test_logistic(self):\n        random.seed(self.seed)\n        actual = random.logistic(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [1.09232835305011444, 0.8648196662399954],\n                [4.27818590694950185, 4.33897006346929714],\n                [-0.21682183359214885, 2.63373365386060332],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_lognormal(self):\n        random.seed(self.seed)\n        actual = random.lognormal(mean=0.123456789, sigma=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [16.50698631688883822, 36.54846706092654784],\n                [22.67886599981281748, 0.71617561058995771],\n                [65.72798501792723869, 86.84341601437161273],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=13)\n\n    def test_lognormal_0(self):\n        assert_equal(random.lognormal(sigma=0), 1)\n        assert_raises(ValueError, random.lognormal, sigma=-0.0)\n\n    def test_logseries(self):\n        random.seed(self.seed)\n        actual = random.logseries(p=0.923456789, size=(3, 2))\n        desired = np.array([[2, 2], [6, 17], [3, 6]])\n        assert_array_equal(actual, desired)\n\n    def test_logseries_exceptions(self):\n        with suppress_warnings() as sup:\n            sup.record(RuntimeWarning)\n            assert_raises(ValueError, random.logseries, np.nan)\n            assert_raises(ValueError, random.logseries, [np.nan] * 10)\n\n    def test_multinomial(self):\n        random.seed(self.seed)\n        actual = random.multinomial(20, [1 / 6.0] * 6, size=(3, 2))\n        desired = np.array(\n            [\n                [[4, 3, 5, 4, 2, 2], [5, 2, 8, 2, 2, 1]],\n                [[3, 4, 3, 6, 0, 4], [2, 1, 4, 3, 6, 4]],\n                [[4, 4, 2, 5, 2, 3], [4, 3, 4, 2, 3, 4]],\n            ]\n        )\n        assert_array_equal(actual, desired)\n\n    def test_multivariate_normal(self):\n        random.seed(self.seed)\n        mean = (0.123456789, 10)\n        cov = [[1, 0], [0, 1]]\n        size = (3, 2)\n        actual = random.multivariate_normal(mean, cov, size)\n        desired = np.array(\n            [\n                [\n                    [1.463620246718631, 11.73759122771936],\n                    [1.622445133300628, 9.771356667546383],\n                ],\n                [\n                    [2.154490787682787, 12.170324946056553],\n                    [1.719909438201865, 9.230548443648306],\n                ],\n                [\n                    [0.689515026297799, 9.880729819607714],\n                    [-0.023054015651998, 9.201096623542879],\n                ],\n            ]\n        )\n\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check for default size, was raising deprecation warning\n        actual = random.multivariate_normal(mean, cov)\n        desired = np.array([0.895289569463708, 9.17180864067987])\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n        # Check that non positive-semidefinite covariance warns with\n        # RuntimeWarning\n        mean = [0, 0]\n        cov = [[1, 2], [2, 1]]\n        assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)\n\n        # and that it doesn""t warn with RuntimeWarning check_valid=""ignore""\n        assert_no_warnings(random.multivariate_normal, mean, cov, check_valid=""ignore"")\n\n        # and that it raises with RuntimeWarning check_valid=""raises""\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""raise""\n        )\n\n        cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)\n        with suppress_warnings() as sup:\n            random.multivariate_normal(mean, cov)\n            w = sup.record(RuntimeWarning)\n            assert len(w) == 0\n\n        mu = np.zeros(2)\n        cov = np.eye(2)\n        assert_raises(\n            ValueError, random.multivariate_normal, mean, cov, check_valid=""other""\n        )\n        assert_raises(ValueError, random.multivariate_normal, np.zeros((2, 1, 1)), cov)\n        assert_raises(ValueError, random.multivariate_normal, mu, np.empty((3, 2)))\n        assert_raises(ValueError, random.multivariate_normal, mu, np.eye(3))\n\n    def test_negative_binomial(self):\n        random.seed(self.seed)\n        actual = random.negative_binomial(n=100, p=0.12345, size=(3, 2))\n        desired = np.array([[848, 841], [892, 611], [779, 647]])\n        assert_array_equal(actual, desired)\n\n    def test_negative_binomial_exceptions(self):\n        with suppress_warnings() as sup:\n            sup.record(RuntimeWarning)\n            assert_raises(ValueError, random.negative_binomial, 100, np.nan)\n            assert_raises(ValueError, random.negative_binomial, 100, [np.nan] * 10)\n\n    def test_noncentral_chisquare(self):\n        random.seed(self.seed)\n        actual = random.noncentral_chisquare(df=5, nonc=5, size=(3, 2))\n        desired = np.array(\n            [\n                [23.91905354498517511, 13.35324692733826346],\n                [31.22452661329736401, 16.60047399466177254],\n                [5.03461598262724586, 17.94973089023519464],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        actual = random.noncentral_chisquare(df=0.5, nonc=0.2, size=(3, 2))\n        desired = np.array(\n            [\n                [1.47145377828516666, 0.15052899268012659],\n                [0.00943803056963588, 1.02647251615666169],\n                [0.332334982684171, 0.15451287602753125],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        random.seed(self.seed)\n        actual = random.noncentral_chisquare(df=5, nonc=0, size=(3, 2))\n        desired = np.array(\n            [\n                [9.597154162763948, 11.725484450296079],\n                [10.413711048138335, 3.694475922923986],\n                [13.484222138963087, 14.377255424602957],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_noncentral_f(self):\n        random.seed(self.seed)\n        actual = random.noncentral_f(dfnum=5, dfden=2, nonc=1, size=(3, 2))\n        desired = np.array(\n            [\n                [1.40598099674926669, 0.34207973179285761],\n                [3.57715069265772545, 7.92632662577829805],\n                [0.43741599463544162, 1.1774208752428319],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_noncentral_f_nan(self):\n        random.seed(self.seed)\n        actual = random.noncentral_f(dfnum=5, dfden=2, nonc=np.nan)\n        assert np.isnan(actual)\n\n    def test_normal(self):\n        random.seed(self.seed)\n        actual = random.normal(loc=0.123456789, scale=2.0, size=(3, 2))\n        desired = np.array(\n            [\n                [2.80378370443726244, 3.59863924443872163],\n                [3.121433477601256, -0.33382987590723379],\n                [4.18552478636557357, 4.46410668111310471],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_normal_0(self):\n        assert_equal(random.normal(scale=0), 0)\n        assert_raises(ValueError, random.normal, scale=-0.0)\n\n    def test_pareto(self):\n        random.seed(self.seed)\n        actual = random.pareto(a=0.123456789, size=(3, 2))\n        desired = np.array(\n            [\n                [2.46852460439034849e03, 1.41286880810518346e03],\n                [5.28287797029485181e07, 6.57720981047328785e07],\n                [1.40840323350391515e02, 1.98390255135251704e05],\n            ]\n        )\n        # For some reason on 32-bit x86 Ubuntu 12.10 the [1, 0] entry in this\n        # matrix differs by 24 nulps. Discussion:\n        #   https://mail.python.org/pipermail/numpy-discussion/2012-September/063801.html\n        # Consensus is that this is probably some gcc quirk that affects\n        # rounding but not in any important way, so we just use a looser\n        # tolerance on this test:\n        np.testing.assert_array_almost_equal_nulp(actual, desired, nulp=30)\n\n    def test_poisson(self):\n        random.seed(self.seed)\n        actual = random.poisson(lam=0.123456789, size=(3, 2))\n        desired = np.array([[0, 0], [1, 0], [0, 0]])\n        assert_array_equal(actual, desired)\n\n    def test_poisson_exceptions(self):\n        lambig = np.iinfo(""l"").max\n        lamneg = -1\n        assert_raises(ValueError, random.poisson, lamneg)\n        assert_raises(ValueError, random.poisson, [lamneg] * 10)\n        assert_raises(ValueError, random.poisson, lambig)\n        assert_raises(ValueError, random.poisson, [lambig] * 10)\n        with suppress_warnings() as sup:\n            sup.record(RuntimeWarning)\n            assert_raises(ValueError, random.poisson, np.nan)\n            assert_raises(ValueError, random.poisson, [np.nan] * 10)\n\n    def test_power(self):\n        random.seed(self.seed)\n        actual = random.power(a=0.123456789, size=(3, 2))\n        desired = np.array(\n            [\n                [0.02048932883240791, 0.01424192241128213],\n                [0.38446073748535298, 0.39499689943484395],\n                [0.00177699707563439, 0.13115505880863756],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_rayleigh(self):\n        random.seed(self.seed)\n        actual = random.rayleigh(scale=10, size=(3, 2))\n        desired = np.array(\n            [\n                [13.8882496494248393, 13.383318339044731],\n                [20.95413364294492098, 21.08285015800712614],\n                [11.06066537006854311, 17.35468505778271009],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_rayleigh_0(self):\n        assert_equal(random.rayleigh(scale=0), 0)\n        assert_raises(ValueError, random.rayleigh, scale=-0.0)\n\n    def test_standard_cauchy(self):\n        random.seed(self.seed)\n        actual = random.standard_cauchy(size=(3, 2))\n        desired = np.array(\n            [\n                [0.77127660196445336, -6.55601161955910605],\n                [0.93582023391158309, -2.07479293013759447],\n                [-4.74601644297011926, 0.18338989290760804],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_exponential(self):\n        random.seed(self.seed)\n        actual = random.standard_exponential(size=(3, 2))\n        desired = np.array(\n            [\n                [0.96441739162374596, 0.89556604882105506],\n                [2.1953785836319808, 2.22243285392490542],\n                [0.6116915921431676, 1.50592546727413201],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_gamma(self):\n        random.seed(self.seed)\n        actual = random.standard_gamma(shape=3, size=(3, 2))\n        desired = np.array(\n            [\n                [5.50841531318455058, 6.62953470301903103],\n                [5.93988484943779227, 2.31044849402133989],\n                [7.54838614231317084, 8.012756093271868],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_standard_gamma_0(self):\n        assert_equal(random.standard_gamma(shape=0), 0)\n        assert_raises(ValueError, random.standard_gamma, shape=-0.0)\n\n    def test_standard_normal(self):\n        random.seed(self.seed)\n        actual = random.standard_normal(size=(3, 2))\n        desired = np.array(\n            [\n                [1.34016345771863121, 1.73759122771936081],\n                [1.498988344300628, -0.2286433324536169],\n                [2.031033998682787, 2.17032494605655257],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_randn_singleton(self):\n        random.seed(self.seed)\n        actual = random.randn()\n        desired = np.array(1.34016345771863121)\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_standard_t(self):\n        random.seed(self.seed)\n        actual = random.standard_t(df=10, size=(3, 2))\n        desired = np.array(\n            [\n                [0.97140611862659965, -0.08830486548450577],\n                [1.36311143689505321, -0.55317463909867071],\n                [-0.18473749069684214, 0.61181537341755321],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_triangular(self):\n        random.seed(self.seed)\n        actual = random.triangular(left=5.12, mode=10.23, right=20.34, size=(3, 2))\n        desired = np.array(\n            [\n                [12.68117178949215784, 12.4129206149193152],\n                [16.20131377335158263, 16.25692138747600524],\n                [11.20400690911820263, 14.4978144835829923],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_uniform(self):\n        random.seed(self.seed)\n        actual = random.uniform(low=1.23, high=10.54, size=(3, 2))\n        desired = np.array(\n            [\n                [6.99097932346268003, 6.73801597444323974],\n                [9.50364421400426274, 9.53130618907631089],\n                [5.48995325769805476, 8.47493103280052118],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_uniform_range_bounds(self):\n        fmin = np.finfo(""float"").min\n        fmax = np.finfo(""float"").max\n\n        func = random.uniform\n        assert_raises(OverflowError, func, -np.inf, 0)\n        assert_raises(OverflowError, func, 0, np.inf)\n        assert_raises(OverflowError, func, fmin, fmax)\n        assert_raises(OverflowError, func, [-np.inf], [0])\n        assert_raises(OverflowError, func, [0], [np.inf])\n\n        # (fmax / 1e17) - fmin is within range, so this should not throw\n        # account for i386 extended precision DBL_MAX / 1e17 + DBL_MAX >\n        # DBL_MAX by increasing fmin a bit\n        random.uniform(low=np.nextafter(fmin, 1), high=fmax / 1e17)\n\n    def test_scalar_exception_propagation(self):\n        # Tests that exceptions are correctly propagated in distributions\n        # when called with objects that throw exceptions when converted to\n        # scalars.\n        #\n        # Regression test for gh: 8865\n\n        class ThrowingFloat(np.ndarray):\n            def __float__(self):\n                raise TypeError\n\n        throwing_float = np.array(1.0).view(ThrowingFloat)\n        assert_raises(TypeError, random.uniform, throwing_float, throwing_float)\n\n        class ThrowingInteger(np.ndarray):\n            def __int__(self):\n                raise TypeError\n\n        throwing_int = np.array(1).view(ThrowingInteger)\n        assert_raises(TypeError, random.hypergeometric, throwing_int, 1, 1)\n\n    def test_vonmises(self):\n        random.seed(self.seed)\n        actual = random.vonmises(mu=1.23, kappa=1.54, size=(3, 2))\n        desired = np.array(\n            [\n                [2.28567572673902042, 2.89163838442285037],\n                [0.38198375564286025, 2.57638023113890746],\n                [1.19153771588353052, 1.83509849681825354],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_vonmises_small(self):\n        # check infinite loop, gh-4720\n        random.seed(self.seed)\n        r = random.vonmises(mu=0.0, kappa=1.1e-8, size=10 ** 6)\n        assert_(np.isfinite(r).all())\n\n    def test_vonmises_nan(self):\n        random.seed(self.seed)\n        r = random.vonmises(mu=0.0, kappa=np.nan)\n        assert_(np.isnan(r))\n\n    def test_wald(self):\n        random.seed(self.seed)\n        actual = random.wald(mean=1.23, scale=1.54, size=(3, 2))\n        desired = np.array(\n            [\n                [3.82935265715889983, 5.13125249184285526],\n                [0.35045403618358717, 1.50832396872003538],\n                [0.24124319895843183, 0.22031101461955038],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_weibull(self):\n        random.seed(self.seed)\n        actual = random.weibull(a=1.23, size=(3, 2))\n        desired = np.array(\n            [\n                [0.97097342648766727, 0.91422896443565516],\n                [1.89517770034962929, 1.91414357960479564],\n                [0.67057783752390987, 1.39494046635066793],\n            ]\n        )\n        assert_array_almost_equal(actual, desired, decimal=15)\n\n    def test_weibull_0(self):\n        random.seed(self.seed)\n        assert_equal(random.weibull(a=0, size=12), np.zeros(12))\n        assert_raises(ValueError, random.weibull, a=-0.0)\n\n    def test_zipf(self):\n        random.seed(self.seed)\n        actual = random.zipf(a=1.23, size=(3, 2))\n        desired = np.array([[66, 29], [1, 1], [3, 13]])\n        assert_array_equal(actual, desired)\n\n\nclass TestBroadcast(object):\n    # tests that functions that broadcast behave\n    # correctly when presented with non-scalar arguments\n    def setup(self):\n        self.seed = 123456789\n\n    def set_seed(self):\n        random.seed(self.seed)\n\n    def test_uniform(self):\n        low = [0]\n        high = [1]\n        uniform = random.uniform\n        desired = np.array(\n            [0.53283302478975902, 0.53413660089041659, 0.50955303552646702]\n        )\n\n        self.set_seed()\n        actual = uniform(low * 3, high)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n        self.set_seed()\n        actual = uniform(low, high * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_normal(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        normal = random.normal\n        desired = np.array([2.2129019979039612, 2.1283977976520019, 1.8417114045748335])\n\n        self.set_seed()\n        actual = normal(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, normal, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = normal(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, normal, loc, bad_scale * 3)\n\n    def test_beta(self):\n        a = [1]\n        b = [2]\n        bad_a = [-1]\n        bad_b = [-2]\n        beta = random.beta\n        desired = np.array(\n            [0.19843558305989056, 0.075230336409423643, 0.24976865978980844]\n        )\n\n        self.set_seed()\n        actual = beta(a * 3, b)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, beta, bad_a * 3, b)\n        assert_raises(ValueError, beta, a * 3, bad_b)\n\n        self.set_seed()\n        actual = beta(a, b * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, beta, bad_a, b * 3)\n        assert_raises(ValueError, beta, a, bad_b * 3)\n\n    def test_exponential(self):\n        scale = [1]\n        bad_scale = [-1]\n        exponential = random.exponential\n        desired = np.array(\n            [0.76106853658845242, 0.76386282278691653, 0.71243813125891797]\n        )\n\n        self.set_seed()\n        actual = exponential(scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, exponential, bad_scale * 3)\n\n    def test_standard_gamma(self):\n        shape = [1]\n        bad_shape = [-1]\n        std_gamma = random.standard_gamma\n        desired = np.array(\n            [0.76106853658845242, 0.76386282278691653, 0.71243813125891797]\n        )\n\n        self.set_seed()\n        actual = std_gamma(shape * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, std_gamma, bad_shape * 3)\n\n    def test_gamma(self):\n        shape = [1]\n        scale = [2]\n        bad_shape = [-1]\n        bad_scale = [-2]\n        gamma = random.gamma\n        desired = np.array([1.5221370731769048, 1.5277256455738331, 1.4248762625178359])\n\n        self.set_seed()\n        actual = gamma(shape * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gamma, bad_shape * 3, scale)\n        assert_raises(ValueError, gamma, shape * 3, bad_scale)\n\n        self.set_seed()\n        actual = gamma(shape, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gamma, bad_shape, scale * 3)\n        assert_raises(ValueError, gamma, shape, bad_scale * 3)\n\n    def test_f(self):\n        dfnum = [1]\n        dfden = [2]\n        bad_dfnum = [-1]\n        bad_dfden = [-2]\n        f = random.f\n        desired = np.array(\n            [0.80038951638264799, 0.86768719635363512, 2.7251095168386801]\n        )\n\n        self.set_seed()\n        actual = f(dfnum * 3, dfden)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, f, bad_dfnum * 3, dfden)\n        assert_raises(ValueError, f, dfnum * 3, bad_dfden)\n\n        self.set_seed()\n        actual = f(dfnum, dfden * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, f, bad_dfnum, dfden * 3)\n        assert_raises(ValueError, f, dfnum, bad_dfden * 3)\n\n    def test_noncentral_f(self):\n        dfnum = [2]\n        dfden = [3]\n        nonc = [4]\n        bad_dfnum = [0]\n        bad_dfden = [-1]\n        bad_nonc = [-2]\n        nonc_f = random.noncentral_f\n        desired = np.array([9.1393943263705211, 13.025456344595602, 8.8018098359100545])\n\n        self.set_seed()\n        actual = nonc_f(dfnum * 3, dfden, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert np.all(np.isnan(nonc_f(dfnum, dfden, [np.nan] * 3)))\n\n        assert_raises(ValueError, nonc_f, bad_dfnum * 3, dfden, nonc)\n        assert_raises(ValueError, nonc_f, dfnum * 3, bad_dfden, nonc)\n        assert_raises(ValueError, nonc_f, dfnum * 3, dfden, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_f(dfnum, dfden * 3, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_f, bad_dfnum, dfden * 3, nonc)\n        assert_raises(ValueError, nonc_f, dfnum, bad_dfden * 3, nonc)\n        assert_raises(ValueError, nonc_f, dfnum, dfden * 3, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_f(dfnum, dfden, nonc * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_f, bad_dfnum, dfden, nonc * 3)\n        assert_raises(ValueError, nonc_f, dfnum, bad_dfden, nonc * 3)\n        assert_raises(ValueError, nonc_f, dfnum, dfden, bad_nonc * 3)\n\n    def test_noncentral_f_small_df(self):\n        self.set_seed()\n        desired = np.array([6.869638627492048, 0.785880199263955])\n        actual = random.noncentral_f(0.9, 0.9, 2, size=2)\n        assert_array_almost_equal(actual, desired, decimal=14)\n\n    def test_chisquare(self):\n        df = [1]\n        bad_df = [-1]\n        chisquare = random.chisquare\n        desired = np.array(\n            [0.57022801133088286, 0.51947702108840776, 0.1320969254923558]\n        )\n\n        self.set_seed()\n        actual = chisquare(df * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, chisquare, bad_df * 3)\n\n    def test_noncentral_chisquare(self):\n        df = [1]\n        nonc = [2]\n        bad_df = [-1]\n        bad_nonc = [-2]\n        nonc_chi = random.noncentral_chisquare\n        desired = np.array([9.0015599467913763, 4.5804135049718742, 6.0872302432834564])\n\n        self.set_seed()\n        actual = nonc_chi(df * 3, nonc)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_chi, bad_df * 3, nonc)\n        assert_raises(ValueError, nonc_chi, df * 3, bad_nonc)\n\n        self.set_seed()\n        actual = nonc_chi(df, nonc * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, nonc_chi, bad_df, nonc * 3)\n        assert_raises(ValueError, nonc_chi, df, bad_nonc * 3)\n\n    def test_standard_t(self):\n        df = [1]\n        bad_df = [-1]\n        t = random.standard_t\n        desired = np.array([3.0702872575217643, 5.8560725167361607, 1.0274791436474273])\n\n        self.set_seed()\n        actual = t(df * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, t, bad_df * 3)\n        assert_raises(ValueError, random.standard_t, bad_df * 3)\n\n    def test_vonmises(self):\n        mu = [2]\n        kappa = [1]\n        bad_kappa = [-1]\n        vonmises = random.vonmises\n        desired = np.array(\n            [2.9883443664201312, -2.7064099483995943, -1.8672476700665914]\n        )\n\n        self.set_seed()\n        actual = vonmises(mu * 3, kappa)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, vonmises, mu * 3, bad_kappa)\n\n        self.set_seed()\n        actual = vonmises(mu, kappa * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, vonmises, mu, bad_kappa * 3)\n\n    def test_pareto(self):\n        a = [1]\n        bad_a = [-1]\n        pareto = random.pareto\n        desired = np.array([1.1405622680198362, 1.1465519762044529, 1.0389564467453547])\n\n        self.set_seed()\n        actual = pareto(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, pareto, bad_a * 3)\n        assert_raises(ValueError, random.pareto, bad_a * 3)\n\n    def test_weibull(self):\n        a = [1]\n        bad_a = [-1]\n        weibull = random.weibull\n        desired = np.array(\n            [0.76106853658845242, 0.76386282278691653, 0.71243813125891797]\n        )\n\n        self.set_seed()\n        actual = weibull(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, weibull, bad_a * 3)\n        assert_raises(ValueError, random.weibull, bad_a * 3)\n\n    def test_power(self):\n        a = [1]\n        bad_a = [-1]\n        power = random.power\n        desired = np.array(\n            [0.53283302478975902, 0.53413660089041659, 0.50955303552646702]\n        )\n\n        self.set_seed()\n        actual = power(a * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, power, bad_a * 3)\n        assert_raises(ValueError, random.power, bad_a * 3)\n\n    def test_laplace(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        laplace = random.laplace\n        desired = np.array(\n            [0.067921356028507157, 0.070715642226971326, 0.019290950698972624]\n        )\n\n        self.set_seed()\n        actual = laplace(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, laplace, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = laplace(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, laplace, loc, bad_scale * 3)\n\n    def test_gumbel(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        gumbel = random.gumbel\n        desired = np.array(\n            [0.2730318639556768, 0.26936705726291116, 0.33906220393037939]\n        )\n\n        self.set_seed()\n        actual = gumbel(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gumbel, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = gumbel(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, gumbel, loc, bad_scale * 3)\n\n    def test_logistic(self):\n        loc = [0]\n        scale = [1]\n        bad_scale = [-1]\n        logistic = random.logistic\n        desired = np.array(\n            [0.13152135837586171, 0.13675915696285773, 0.038216792802833396]\n        )\n\n        self.set_seed()\n        actual = logistic(loc * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, logistic, loc * 3, bad_scale)\n\n        self.set_seed()\n        actual = logistic(loc, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, logistic, loc, bad_scale * 3)\n        assert_equal(random.logistic(1.0, 0.0), 1.0)\n\n    def test_lognormal(self):\n        mean = [0]\n        sigma = [1]\n        bad_sigma = [-1]\n        lognormal = random.lognormal\n        desired = np.array([9.1422086044848427, 8.4013952870126261, 6.3073234116578671])\n\n        self.set_seed()\n        actual = lognormal(mean * 3, sigma)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, lognormal, mean * 3, bad_sigma)\n        assert_raises(ValueError, random.lognormal, mean * 3, bad_sigma)\n\n        self.set_seed()\n        actual = lognormal(mean, sigma * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, lognormal, mean, bad_sigma * 3)\n        assert_raises(ValueError, random.lognormal, mean, bad_sigma * 3)\n\n    def test_rayleigh(self):\n        scale = [1]\n        bad_scale = [-1]\n        rayleigh = random.rayleigh\n        desired = np.array([1.2337491937897689, 1.2360119924878694, 1.1936818095781789])\n\n        self.set_seed()\n        actual = rayleigh(scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, rayleigh, bad_scale * 3)\n\n    def test_wald(self):\n        mean = [0.5]\n        scale = [1]\n        bad_mean = [0]\n        bad_scale = [-2]\n        wald = random.wald\n        desired = np.array(\n            [0.11873681120271318, 0.12450084820795027, 0.9096122728408238]\n        )\n\n        self.set_seed()\n        actual = wald(mean * 3, scale)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, wald, bad_mean * 3, scale)\n        assert_raises(ValueError, wald, mean * 3, bad_scale)\n        assert_raises(ValueError, random.wald, bad_mean * 3, scale)\n        assert_raises(ValueError, random.wald, mean * 3, bad_scale)\n\n        self.set_seed()\n        actual = wald(mean, scale * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, wald, bad_mean, scale * 3)\n        assert_raises(ValueError, wald, mean, bad_scale * 3)\n        assert_raises(ValueError, wald, 0.0, 1)\n        assert_raises(ValueError, wald, 0.5, 0.0)\n\n    def test_triangular(self):\n        left = [1]\n        right = [3]\n        mode = [2]\n        bad_left_one = [3]\n        bad_mode_one = [4]\n        bad_left_two, bad_mode_two = right * 2\n        triangular = random.triangular\n        desired = np.array([2.03339048710429, 2.0347400359389356, 2.0095991069536208])\n\n        self.set_seed()\n        actual = triangular(left * 3, mode, right)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one * 3, mode, right)\n        assert_raises(ValueError, triangular, left * 3, bad_mode_one, right)\n        assert_raises(ValueError, triangular, bad_left_two * 3, bad_mode_two, right)\n\n        self.set_seed()\n        actual = triangular(left, mode * 3, right)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one, mode * 3, right)\n        assert_raises(ValueError, triangular, left, bad_mode_one * 3, right)\n        assert_raises(ValueError, triangular, bad_left_two, bad_mode_two * 3, right)\n\n        self.set_seed()\n        actual = triangular(left, mode, right * 3)\n        assert_array_almost_equal(actual, desired, decimal=14)\n        assert_raises(ValueError, triangular, bad_left_one, mode, right * 3)\n        assert_raises(ValueError, triangular, left, bad_mode_one, right * 3)\n        assert_raises(ValueError, triangular, bad_left_two, bad_mode_two, right * 3)\n\n        assert_raises(ValueError, triangular, 10.0, 0.0, 20.0)\n        assert_raises(ValueError, triangular, 10.0, 25.0, 20.0)\n        assert_raises(ValueError, triangular, 10.0, 10.0, 10.0)\n\n    def test_binomial(self):\n        n = [1]\n        p = [0.5]\n        bad_n = [-1]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        binom = random.binomial\n        desired = np.array([1, 1, 1])\n\n        self.set_seed()\n        actual = binom(n * 3, p)\n        assert_array_equal(actual, desired)\n        self.set_seed()\n        actual = binom(n * 3, p, size=(3,))\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, binom, bad_n * 3, p)\n        assert_raises(ValueError, binom, n * 3, bad_p_one)\n        assert_raises(ValueError, binom, n * 3, bad_p_two)\n\n        self.set_seed()\n        actual = binom(n, p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, binom, bad_n, p * 3)\n        assert_raises(ValueError, binom, n, bad_p_one * 3)\n        assert_raises(ValueError, binom, n, bad_p_two * 3)\n\n    def test_negative_binomial(self):\n        n = [1]\n        p = [0.5]\n        bad_n = [-1]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        neg_binom = random.negative_binomial\n        desired = np.array([1, 0, 1])\n\n        self.set_seed()\n        actual = neg_binom(n * 3, p)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, neg_binom, bad_n * 3, p)\n        assert_raises(ValueError, neg_binom, n * 3, bad_p_one)\n        assert_raises(ValueError, neg_binom, n * 3, bad_p_two)\n\n        self.set_seed()\n        actual = neg_binom(n, p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, neg_binom, bad_n, p * 3)\n        assert_raises(ValueError, neg_binom, n, bad_p_one * 3)\n        assert_raises(ValueError, neg_binom, n, bad_p_two * 3)\n\n    def test_poisson(self):\n        max_lam = random.RandomState()._poisson_lam_max\n\n        lam = [1]\n        bad_lam_one = [-1]\n        bad_lam_two = [max_lam * 2]\n        poisson = random.poisson\n        desired = np.array([1, 1, 0])\n\n        self.set_seed()\n        actual = poisson(lam * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, poisson, bad_lam_one * 3)\n        assert_raises(ValueError, poisson, bad_lam_two * 3)\n\n    def test_zipf(self):\n        a = [2]\n        bad_a = [0]\n        zipf = random.zipf\n        desired = np.array([2, 2, 1])\n\n        self.set_seed()\n        actual = zipf(a * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, zipf, bad_a * 3)\n        with np.errstate(invalid=""ignore""):\n            assert_raises(ValueError, zipf, np.nan)\n            assert_raises(ValueError, zipf, [0, 0, np.nan])\n\n    def test_geometric(self):\n        p = [0.5]\n        bad_p_one = [-1]\n        bad_p_two = [1.5]\n        geom = random.geometric\n        desired = np.array([2, 2, 2])\n\n        self.set_seed()\n        actual = geom(p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, geom, bad_p_one * 3)\n        assert_raises(ValueError, geom, bad_p_two * 3)\n\n    def test_hypergeometric(self):\n        ngood = [1]\n        nbad = [2]\n        nsample = [2]\n        bad_ngood = [-1]\n        bad_nbad = [-2]\n        bad_nsample_one = [0]\n        bad_nsample_two = [4]\n        hypergeom = random.hypergeometric\n        desired = np.array([1, 1, 1])\n\n        self.set_seed()\n        actual = hypergeom(ngood * 3, nbad, nsample)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, hypergeom, bad_ngood * 3, nbad, nsample)\n        assert_raises(ValueError, hypergeom, ngood * 3, bad_nbad, nsample)\n        assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_one)\n        assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_two)\n\n        self.set_seed()\n        actual = hypergeom(ngood, nbad * 3, nsample)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, hypergeom, bad_ngood, nbad * 3, nsample)\n        assert_raises(ValueError, hypergeom, ngood, bad_nbad * 3, nsample)\n        assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_one)\n        assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_two)\n\n        self.set_seed()\n        actual = hypergeom(ngood, nbad, nsample * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, hypergeom, bad_ngood, nbad, nsample * 3)\n        assert_raises(ValueError, hypergeom, ngood, bad_nbad, nsample * 3)\n        assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_one * 3)\n        assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_two * 3)\n\n        assert_raises(ValueError, hypergeom, -1, 10, 20)\n        assert_raises(ValueError, hypergeom, 10, -1, 20)\n        assert_raises(ValueError, hypergeom, 10, 10, 0)\n        assert_raises(ValueError, hypergeom, 10, 10, 25)\n\n    def test_logseries(self):\n        p = [0.5]\n        bad_p_one = [2]\n        bad_p_two = [-1]\n        logseries = random.logseries\n        desired = np.array([1, 1, 1])\n\n        self.set_seed()\n        actual = logseries(p * 3)\n        assert_array_equal(actual, desired)\n        assert_raises(ValueError, logseries, bad_p_one * 3)\n        assert_raises(ValueError, logseries, bad_p_two * 3)\n\n\nclass TestThread(object):\n    # make sure each state produces the same sequence even in threads\n    def setup(self):\n        self.seeds = range(4)\n\n    def check_function(self, function, sz):\n        from threading import Thread\n\n        out1 = np.empty((len(self.seeds),) + sz)\n        out2 = np.empty((len(self.seeds),) + sz)\n\n        # threaded generation\n        t = [\n            Thread(target=function, args=(random.RandomState(s), o))\n            for s, o in zip(self.seeds, out1)\n        ]\n        [x.start() for x in t]\n        [x.join() for x in t]\n\n        # the same serial\n        for s, o in zip(self.seeds, out2):\n            function(random.RandomState(s), o)\n\n        # these platforms change x87 fpu precision mode in threads\n        if np.intp().dtype.itemsize == 4 and sys.platform == ""win32"":\n            assert_array_almost_equal(out1, out2)\n        else:\n            assert_array_equal(out1, out2)\n\n    def test_normal(self):\n        def gen_random(state, out):\n            out[...] = state.normal(size=10000)\n\n        self.check_function(gen_random, sz=(10000,))\n\n    def test_exp(self):\n        def gen_random(state, out):\n            out[...] = state.exponential(scale=np.ones((100, 1000)))\n\n        self.check_function(gen_random, sz=(100, 1000))\n\n    def test_multinomial(self):\n        def gen_random(state, out):\n            out[...] = state.multinomial(10, [1 / 6.0] * 6, size=10000)\n\n        self.check_function(gen_random, sz=(10000, 6))\n\n\n# See Issue #4263\nclass TestSingleEltArrayInput(object):\n    def setup(self):\n        self.argOne = np.array([2])\n        self.argTwo = np.array([3])\n        self.argThree = np.array([4])\n        self.tgtShape = (1,)\n\n    def test_one_arg_funcs(self):\n        funcs = (\n            random.exponential,\n            random.standard_gamma,\n            random.chisquare,\n            random.standard_t,\n            random.pareto,\n            random.weibull,\n            random.power,\n            random.rayleigh,\n            random.poisson,\n            random.zipf,\n            random.geometric,\n            random.logseries,\n        )\n\n        probfuncs = (random.geometric, random.logseries)\n\n        for func in funcs:\n            if func in probfuncs:  # p < 1.0\n                out = func(np.array([0.5]))\n\n            else:\n                out = func(self.argOne)\n\n            assert_equal(out.shape, self.tgtShape)\n\n    def test_two_arg_funcs(self):\n        funcs = (\n            random.uniform,\n            random.normal,\n            random.beta,\n            random.gamma,\n            random.f,\n            random.noncentral_chisquare,\n            random.vonmises,\n            random.laplace,\n            random.gumbel,\n            random.logistic,\n            random.lognormal,\n            random.wald,\n            random.binomial,\n            random.negative_binomial,\n        )\n\n        probfuncs = (random.binomial, random.negative_binomial)\n\n        for func in funcs:\n            if func in probfuncs:  # p <= 1\n                argTwo = np.array([0.5])\n\n            else:\n                argTwo = self.argTwo\n\n            out = func(self.argOne, argTwo)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne[0], argTwo)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne, argTwo[0])\n            assert_equal(out.shape, self.tgtShape)\n\n    def test_three_arg_funcs(self):\n        funcs = [random.noncentral_f, random.triangular, random.hypergeometric]\n\n        for func in funcs:\n            out = func(self.argOne, self.argTwo, self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne[0], self.argTwo, self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n            out = func(self.argOne, self.argTwo[0], self.argThree)\n            assert_equal(out.shape, self.tgtShape)\n\n\n# Ensure returned array dtype is corect for platform\ndef test_integer_dtype(int_func):\n    random.seed(123456789)\n    fname, args, md5 = int_func\n    f = getattr(random, fname)\n    actual = f(*args, size=2)\n    assert_(actual.dtype == np.dtype(""l""))\n\n\ndef test_integer_repeat(int_func):\n    random.seed(123456789)\n    fname, args, md5 = int_func\n    f = getattr(random, fname)\n    val = f(*args, size=1000000)\n    if sys.byteorder != ""little"":\n        val = val.byteswap()\n    res = hashlib.md5(val.view(np.int8)).hexdigest()\n    assert_(res == md5)\n\n\ndef test_aliases():\n    mtrand = randomgen.mtrand\n    assert isinstance(mtrand.random_sample(), float)\n    assert isinstance(mtrand.sample(), float)\n    assert isinstance(mtrand.ranf(), float)\n'"
randomgen/tests/test_randomstate_regression.py,26,"b'import sys\n\nimport numpy as np\nfrom numpy.compat import long\nfrom numpy.testing import assert_, assert_array_equal, assert_raises\nimport pytest\n\nimport randomgen.mtrand as random\n\nHAS_32BIT_CLONG = np.iinfo(""l"").max < 2 ** 32\n\n\nclass TestRegression(object):\n    def test_VonMises_range(self):\n        # Make sure generated random variables are in [-pi, pi].\n        # Regression test for ticket #986.\n        for mu in np.linspace(-7.0, 7.0, 5):\n            r = random.vonmises(mu, 1, 50)\n            assert_(np.all(r > -np.pi) and np.all(r <= np.pi))\n\n    def test_hypergeometric_range(self):\n        # Test for ticket #921\n        assert_(np.all(random.hypergeometric(3, 18, 11, size=10) < 4))\n        assert_(np.all(random.hypergeometric(18, 3, 11, size=10) > 0))\n\n        # Test for ticket #5623\n        args = [\n            (2 ** 20 - 2, 2 ** 20 - 2, 2 ** 20 - 2),  # Check for 32-bit systems\n        ]\n        is_64bits = sys.maxsize > 2 ** 32\n        if is_64bits and sys.platform != ""win32"":\n            # Check for 64-bit systems\n            args.append((2 ** 40 - 2, 2 ** 40 - 2, 2 ** 40 - 2))\n        for arg in args:\n            assert_(random.hypergeometric(*arg) > 0)\n\n    def test_logseries_convergence(self):\n        # Test for ticket #923\n        N = 1000\n        random.seed(0)\n        rvsn = random.logseries(0.8, size=N)\n        # these two frequency counts should be close to theoretical\n        # numbers with this large sample\n        # theoretical large N result is 0.49706795\n        freq = np.sum(rvsn == 1) / float(N)\n        msg = ""Frequency was %f, should be > 0.45"" % freq\n        assert_(freq > 0.45, msg)\n        # theoretical large N result is 0.19882718\n        freq = np.sum(rvsn == 2) / float(N)\n        msg = ""Frequency was %f, should be < 0.23"" % freq\n        assert_(freq < 0.23, msg)\n\n    def test_permutation_longs(self):\n        random.seed(1234)\n        a = random.permutation(12)\n        random.seed(1234)\n        b = random.permutation(long(12))\n        assert_array_equal(a, b)\n\n    def test_shuffle_mixed_dimension(self):\n        # Test for trac ticket #2074\n        for t in [\n            [1, 2, 3, None],\n            [(1, 1), (2, 2), (3, 3), None],\n            [1, (2, 2), (3, 3), None],\n            [(1, 1), 2, 3, None],\n        ]:\n            random.seed(12345)\n            shuffled = np.array(list(t), dtype=np.object)\n            random.shuffle(shuffled)\n            assert_array_equal(\n                shuffled, np.array([t[0], t[3], t[1], t[2]], dtype=np.object)\n            )\n\n    def test_call_within_randomstate(self):\n        # Check that custom RandomState does not call into global state\n        m = random.RandomState()\n        res = np.array([0, 8, 7, 2, 1, 9, 4, 7, 0, 3])\n        for i in range(3):\n            random.seed(i)\n            m.seed(4321)\n            # If m.state is not honored, the result will change\n            assert_array_equal(m.choice(10, size=10, p=np.ones(10) / 10.0), res)\n\n    def test_multivariate_normal_size_types(self):\n        # Test for multivariate_normal issue with ""size"" argument.\n        # Check that the multivariate_normal size argument can be a\n        # numpy integer.\n        random.multivariate_normal([0], [[0]], size=1)\n        random.multivariate_normal([0], [[0]], size=np.int_(1))\n        random.multivariate_normal([0], [[0]], size=np.int64(1))\n\n    def test_beta_small_parameters(self):\n        # Test that beta with small a and b parameters does not produce\n        # NaNs due to roundoff errors causing 0 / 0, gh-5851\n        random.seed(1234567890)\n        x = random.beta(0.0001, 0.0001, size=100)\n        assert_(not np.any(np.isnan(x)), ""Nans in random.beta"")\n\n    def test_choice_sum_of_probs_tolerance(self):\n        # The sum of probs should be 1.0 with some tolerance.\n        # For low precision dtypes the tolerance was too tight.\n        # See numpy github issue 6123.\n        random.seed(1234)\n        a = [1, 2, 3]\n        counts = [4, 4, 2]\n        for dt in np.float16, np.float32, np.float64:\n            probs = np.array(counts, dtype=dt) / sum(counts)\n            c = random.choice(a, p=probs)\n            assert_(c in a)\n            assert_raises(ValueError, random.choice, a, p=probs * 0.9)\n\n    def test_shuffle_of_array_of_different_length_strings(self):\n        # Test that permuting an array of different length strings\n        # will not cause a segfault on garbage collection\n        # Tests gh-7710\n        random.seed(1234)\n\n        a = np.array([""a"", ""a"" * 1000])\n\n        for _ in range(100):\n            random.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n\n        gc.collect()\n\n    def test_shuffle_of_array_of_objects(self):\n        # Test that permuting an array of objects will not cause\n        # a segfault on garbage collection.\n        # See gh-7719\n        random.seed(1234)\n        a = np.array([np.arange(1), np.arange(4)], dtype=np.object)\n\n        for _ in range(1000):\n            random.shuffle(a)\n\n        # Force Garbage Collection - should not segfault.\n        import gc\n\n        gc.collect()\n\n    def test_permutation_subclass(self):\n        class N(np.ndarray):\n            pass\n\n        random.seed(1)\n        orig = np.arange(3).view(N)\n        perm = random.permutation(orig)\n        assert_array_equal(perm, np.array([0, 2, 1]))\n        assert_array_equal(orig, np.arange(3).view(N))\n\n        class M(object):\n            a = np.arange(5)\n\n            def __array__(self):\n                return self.a\n\n        random.seed(1)\n        m = M()\n        perm = random.permutation(m)\n        assert_array_equal(perm, np.array([2, 1, 4, 0, 3]))\n        assert_array_equal(m.__array__(), np.arange(5))\n\n    def test_warns_byteorder(self):\n        other_byteord_dt = ""<i4"" if sys.byteorder == ""big"" else "">i4""\n        with pytest.warns(FutureWarning):\n            random.randint(0, 200, size=10, dtype=other_byteord_dt)\n\n    @pytest.mark.skipif(HAS_32BIT_CLONG, reason=""Cannot test with 32-bit C long"")\n    def test_randint_117(self):\n        random.seed(0)\n        expected = np.array(\n            [\n                2357136044,\n                2546248239,\n                3071714933,\n                3626093760,\n                2588848963,\n                3684848379,\n                2340255427,\n                3638918503,\n                1819583497,\n                2678185683,\n            ],\n            dtype=""int64"",\n        )\n        actual = random.randint(2 ** 32, size=10)\n        assert_array_equal(actual, expected)\n'"
randomgen/tests/test_recent_numpy_changes.py,14,"b'from distutils.version import LooseVersion\nimport warnings\n\nimport numpy as np\nfrom numpy.testing import assert_equal\nimport pytest\n\nfrom randomgen import Generator\n\ntry:\n    from numpy.random import MT19937\nexcept ImportError:\n    from randomgen import MT19937\n\n\nv119 = LooseVersion(""1.19"")\nNP_LT_119 = LooseVersion(np.__version__) < v119\n\n\npytestmark = pytest.mark.skipif(NP_LT_119, reason=""Only test NumPy 1.19+"")\n\n\n# Catch when using internal MT19937\nwith warnings.catch_warnings():\n    warnings.simplefilter(""ignore"")\n    random = Generator(MT19937(1234))\n\n\n@pytest.mark.parametrize(\n    ""bound, expected"",\n    [\n        (\n            2 ** 32 - 1,\n            np.array(\n                [\n                    517043486,\n                    1364798665,\n                    1733884389,\n                    1353720612,\n                    3769704066,\n                    1170797179,\n                    4108474671,\n                ]\n            ),\n        ),\n        (\n            2 ** 32,\n            np.array(\n                [\n                    517043487,\n                    1364798666,\n                    1733884390,\n                    1353720613,\n                    3769704067,\n                    1170797180,\n                    4108474672,\n                ]\n            ),\n        ),\n        (\n            2 ** 32 + 1,\n            np.array(\n                [\n                    517043487,\n                    1733884390,\n                    3769704068,\n                    4108474673,\n                    1831631863,\n                    1215661561,\n                    3869512430,\n                ]\n            ),\n        ),\n    ],\n)\ndef test_repeatability_32bit_boundary(bound, expected):\n    for size in [None, len(expected)]:\n        random = Generator(MT19937(1234))\n        x = random.integers(bound, size=size, use_masked=False)\n        assert_equal(x, expected if size is not None else expected[0])\n\n\ndef test_dirichelet_alpha():\n    # numpy/numpy#15951\n    with pytest.raises(ValueError):\n        random.dirichlet([[5, 1]])\n    with pytest.raises(ValueError):\n        random.dirichlet([[5], [1]])\n    with pytest.raises(ValueError):\n        random.dirichlet([[[5], [1]], [[1], [5]]])\n    with pytest.raises(ValueError):\n        random.dirichlet(np.array([[5, 1], [1, 5]]))\n\n\ndef test_negative_binomial_p0_exception():\n    # numpy/numpy#15913\n    # Verify that p=0 raises an exception.\n    with pytest.raises(ValueError):\n        random.negative_binomial(1, 0)\n\n\ndef test_multivariate_normal_basic_stats():\n    # numpy/numpy#15871\n    random = Generator(MT19937(12345))\n    n_s = 1000\n    mean = np.array([1, 2])\n    cov = np.array([[2, 1], [1, 2]])\n    s = random.multivariate_normal(mean, cov, size=(n_s,))\n    s_center = s - mean\n    cov_emp = (s_center.T @ s_center) / (n_s - 1)\n    # these are pretty loose and are only designed to detect major errors\n    assert np.all(np.abs(s_center.mean(-2)) < 0.1)\n    assert np.all(np.abs(cov_emp - cov) < 0.2)\n\n\n# chi2max is the maximum acceptable chi-squared value.\n@pytest.mark.parametrize(\n    ""sample_size,high,dtype,chi2max"",\n    [\n        (5000000, 5, np.int8, 125.0),  # p-value ~4.6e-25\n        (5000000, 7, np.uint8, 150.0),  # p-value ~7.7e-30\n        (10000000, 2500, np.int16, 3300.0),  # p-value ~3.0e-25\n        (50000000, 5000, np.uint16, 6500.0),  # p-value ~3.5e-25\n    ],\n)\ndef test_integers_small_dtype_chisquared(sample_size, high, dtype, chi2max):\n    # Regression test for gh-14774.\n    samples = random.integers(high, size=sample_size, dtype=dtype)\n\n    values, counts = np.unique(samples, return_counts=True)\n    expected = sample_size / high\n    chi2 = ((counts - expected) ** 2 / expected).sum()\n    assert chi2 < chi2max\n\n\ndef test_bad_permuation():\n    bad_x_str = ""abcd""\n    with pytest.raises(IndexError):\n        random.permutation(bad_x_str)\n\n    bad_x_float = 1.2\n    with pytest.raises(IndexError):\n        random.permutation(bad_x_float)\n'"
randomgen/tests/test_seed_sequence.py,9,"b'import numpy as np\nfrom numpy.testing import assert_array_equal\nimport pytest\n\nfrom randomgen._seed_sequence import SeedlessSeedSequence, SeedSequence\n\nHAS_NP_SEED_SEQUENCE = False\ntry:\n    from numpy.random._bit_generator import SeedSequence as NPSeedSequence\n\n    HAS_NP_SEED_SEQUENCE = True\nexcept (ImportError, AttributeError):\n    try:\n        from numpy.random.bit_generator import SeedSequence as NPSeedSequence\n\n        HAS_NP_SEED_SEQUENCE = True\n    except (ImportError, AttributeError):\n        pass\n\n\ndef test_reference_data():\n    """""" Check that SeedSequence generates data the same as the C++ reference.\n\n    https://gist.github.com/imneme/540829265469e673d045\n    """"""\n    inputs = [\n        [3735928559, 195939070, 229505742, 305419896],\n        [3668361503, 4165561550, 1661411377, 3634257570],\n        [164546577, 4166754639, 1765190214, 1303880213],\n        [446610472, 3941463886, 522937693, 1882353782],\n        [1864922766, 1719732118, 3882010307, 1776744564],\n        [4141682960, 3310988675, 553637289, 902896340],\n        [1134851934, 2352871630, 3699409824, 2648159817],\n        [1240956131, 3107113773, 1283198141, 1924506131],\n        [2669565031, 579818610, 3042504477, 2774880435],\n        [2766103236, 2883057919, 4029656435, 862374500],\n    ]\n    outputs = [\n        [3914649087, 576849849, 3593928901, 2229911004],\n        [2240804226, 3691353228, 1365957195, 2654016646],\n        [3562296087, 3191708229, 1147942216, 3726991905],\n        [1403443605, 3591372999, 1291086759, 441919183],\n        [1086200464, 2191331643, 560336446, 3658716651],\n        [3249937430, 2346751812, 847844327, 2996632307],\n        [2584285912, 4034195531, 3523502488, 169742686],\n        [959045797, 3875435559, 1886309314, 359682705],\n        [3978441347, 432478529, 3223635119, 138903045],\n        [296367413, 4262059219, 13109864, 3283683422],\n    ]\n    outputs64 = [\n        [2477551240072187391, 9577394838764454085],\n        [15854241394484835714, 11398914698975566411],\n        [13708282465491374871, 16007308345579681096],\n        [15424829579845884309, 1898028439751125927],\n        [9411697742461147792, 15714068361935982142],\n        [10079222287618677782, 12870437757549876199],\n        [17326737873898640088, 729039288628699544],\n        [16644868984619524261, 1544825456798124994],\n        [1857481142255628931, 596584038813451439],\n        [18305404959516669237, 14103312907920476776],\n    ]\n    for seed, expected, expected64 in zip(inputs, outputs, outputs64):\n        expected = np.array(expected, dtype=np.uint32)\n        ss = SeedSequence(seed)\n        state = ss.generate_state(len(expected))\n        assert_array_equal(state, expected)\n        state64 = ss.generate_state(len(expected64), dtype=np.uint64)\n        assert_array_equal(state64, expected64)\n\n\ndef test_spawn_equiv():\n    ss = SeedSequence(0)\n    children = ss.spawn(2)\n    direct = [SeedSequence(0, spawn_key=(0,)), SeedSequence(0, spawn_key=(1,))]\n    assert len(children) == 2\n    for c, d in zip(children, direct):\n        assert_array_equal(c.generate_state(4), d.generate_state(4))\n\n\ndef test_bad_spawn_key():\n    with pytest.raises(TypeError, match=""seed must be integer""):\n        SeedSequence(spawn_key=(np.pi,))\n\n\ndef test_invalid_dtype_gen_state():\n    ss = SeedSequence(0)\n    with pytest.raises(ValueError):\n        ss.generate_state(4, dtype=np.uint8)\n\n\ndef test_state():\n    ss = SeedSequence(0)\n    assert ""entropy"" in ss.state\n    assert ss.state[""entropy""] == 0\n    assert ""n_children_spawned"" in ss.state\n    assert ss.state[""n_children_spawned""] == 0\n    assert ""pool_size"" in ss.state\n    assert ss.state[""pool_size""] == 4\n\n    for key in ""spawn_key"":\n        assert key not in ss.state\n    children = ss.spawn(10)\n    assert ss.state[""n_children_spawned""] == 10\n\n    assert ""spawn_key"" in children[0].state\n    assert children[0].state[""spawn_key""] == (0,)\n\n    ss = SeedSequence(0, pool_size=8)\n    assert ""pool_size"" in ss.state\n    assert ss.state[""pool_size""] == 8\n\n\ndef test_repr():\n    ss = SeedSequence(0, pool_size=16, spawn_key=(0, 1, 7))\n    r = ss.__repr__()\n    assert isinstance(r, str)\n    assert ""entropy"" in r\n    assert ""pool_size=16"" in r\n    assert ""spawn_key=(0, 1, 7)"" in r\n    assert ""n_children_spawned"" not in r\n\n    ss.spawn(10)\n    assert ""n_children_spawned=10"" in ss.__repr__()\n\n\ndef test_min_pool_size():\n    with pytest.raises(ValueError, match=""The size of the entropy""):\n        SeedSequence(pool_size=3)\n\n\ndef test_bad_entropy():\n    with pytest.raises((TypeError,), match=""SeedSequence expects int""):\n        SeedSequence(entropy=SeedSequence())\n    with pytest.raises(ValueError, match=""unrecognized seed string""):\n        SeedSequence(entropy=[""apple""])\n\n\ndef test_seedless():\n    sls = SeedlessSeedSequence()\n    with pytest.raises(NotImplementedError):\n        sls.generate_state(10, np.uint32)\n\n    child = sls.spawn(1)[0]\n    assert child is sls\n\n\ndef test_equiv_entropy():\n    ss0 = SeedSequence(0)\n    sss = [\n        SeedSequence(np.array([0], dtype=np.uint32)),\n        SeedSequence(""0""),\n        SeedSequence(""0x0""),\n        SeedSequence([""0""]),\n    ]\n\n    for ss in sss:\n        assert_array_equal(ss.generate_state(4), ss0.generate_state(4))\n\n\ndef test_mixer_smoke():\n    ss = SeedSequence(np.arange(100, dtype=np.uint32))\n    assert_array_equal(ss.entropy, np.arange(100, dtype=np.uint32))\n\n\ndef test_uint_scalar_entropy():\n    ss0 = SeedSequence(0)\n    ss1 = SeedSequence(np.uint32(0))\n    assert_array_equal(ss0.generate_state(4), ss1.generate_state(4))\n\n\ndef test_neg_entropy():\n    with pytest.raises(ValueError, match=""expected non-negative integer""):\n        SeedSequence([-1])\n    with pytest.raises(ValueError, match=""expected non-negative integer""):\n        SeedSequence(-1)\n    with pytest.raises(ValueError, match=""expected non-negative integer""):\n        SeedSequence([3, -1])\n\n\n@pytest.mark.skipif(not HAS_NP_SEED_SEQUENCE, reason=""NumPy too old"")\ndef test_against_numpy():\n    ss = SeedSequence(0)\n    np_ss = NPSeedSequence(0)\n    assert_array_equal(ss.generate_state(10), np_ss.generate_state(10))\n\n\n@pytest.mark.skipif(not HAS_NP_SEED_SEQUENCE, reason=""NumPy too old"")\ndef test_against_numpy_spawn():\n    entropy = [\n        1231854054,\n        2485020620,\n        2472030289,\n        641337343,\n        3981837114,\n        248869471,\n        532471113,\n        949593482,\n        1224833511,\n        2864447214,\n    ]\n    ss = SeedSequence(entropy)\n    np_ss = NPSeedSequence(entropy)\n    ss_children = ss.spawn(2)\n    np_ss_children = np_ss.spawn(2)\n    assert ss.n_children_spawned == np_ss.n_children_spawned\n    for child, np_child in zip(ss_children, np_ss_children):\n        assert_array_equal(child.generate_state(10), np_child.generate_state(10))\n'"
randomgen/tests/test_smoke.py,136,"b'from functools import partial\nimport os\nimport pickle\nimport sys\nimport time\n\nimport numpy as np\nfrom numpy.testing import assert_, assert_almost_equal, assert_array_equal, assert_equal\nimport pytest\n\nfrom randomgen import (\n    DSFMT,\n    HC128,\n    JSF,\n    LXM,\n    MT64,\n    MT19937,\n    PCG32,\n    PCG64,\n    SFMT,\n    SPECK128,\n    AESCounter,\n    ChaCha,\n    Generator,\n    Philox,\n    ThreeFry,\n    Xoroshiro128,\n    Xorshift1024,\n    Xoshiro256,\n    Xoshiro512,\n    entropy,\n)\nfrom randomgen._testing import suppress_warnings\n\n\n@pytest.fixture(\n    scope=""module"",\n    params=(\n        np.bool,\n        np.int8,\n        np.int16,\n        np.int32,\n        np.int64,\n        np.uint8,\n        np.uint16,\n        np.uint32,\n        np.uint64,\n    ),\n)\ndef dtype(request):\n    return request.param\n\n\ndef params_0(f):\n    val = f()\n    assert_(np.isscalar(val))\n    val = f(10)\n    assert_(val.shape == (10,))\n    val = f((10, 10))\n    assert_(val.shape == (10, 10))\n    val = f((10, 10, 10))\n    assert_(val.shape == (10, 10, 10))\n    val = f(size=(5, 5))\n    assert_(val.shape == (5, 5))\n\n\ndef params_1(f, bounded=False):\n    a = 5.0\n    b = np.arange(2.0, 12.0)\n    c = np.arange(2.0, 102.0).reshape(10, 10)\n    d = np.arange(2.0, 1002.0).reshape(10, 10, 10)\n    e = np.array([2.0, 3.0])\n    g = np.arange(2.0, 12.0).reshape(1, 10, 1)\n    if bounded:\n        a = 0.5\n        b = b / (1.5 * b.max())\n        c = c / (1.5 * c.max())\n        d = d / (1.5 * d.max())\n        e = e / (1.5 * e.max())\n        g = g / (1.5 * g.max())\n\n    # Scalar\n    f(a)\n    # Scalar - size\n    f(a, size=(10, 10))\n    # 1d\n    f(b)\n    # 2d\n    f(c)\n    # 3d\n    f(d)\n    # 1d size\n    f(b, size=10)\n    # 2d - size - broadcast\n    f(e, size=(10, 2))\n    # 3d - size\n    f(g, size=(10, 10, 1))\n\n\ndef comp_state(state1, state2):\n    identical = True\n    if isinstance(state1, dict):\n        for key in state1:\n            identical &= comp_state(state1[key], state2[key])\n    elif type(state1) != type(state2):\n        identical &= type(state1) == type(state2)\n    else:\n        if isinstance(state1, (list, tuple, np.ndarray)) and isinstance(\n            state2, (list, tuple, np.ndarray)\n        ):\n            for s1, s2 in zip(state1, state2):\n                identical &= comp_state(s1, s2)\n        else:\n            identical &= state1 == state2\n    return identical\n\n\ndef warmup(rg, n=None):\n    if n is None:\n        n = 11 + np.random.randint(0, 20)\n    rg.standard_normal(n)\n    rg.standard_normal(n)\n    rg.standard_normal(n, dtype=np.float32)\n    rg.standard_normal(n, dtype=np.float32)\n    rg.integers(0, 2 ** 24, n, dtype=np.uint64)\n    rg.integers(0, 2 ** 48, n, dtype=np.uint64)\n    rg.standard_gamma(11.0, n)\n    rg.standard_gamma(11.0, n, dtype=np.float32)\n    rg.random(n, dtype=np.float64)\n    rg.random(n, dtype=np.float32)\n\n\nclass RNG(object):\n    @classmethod\n    def setup_class(cls):\n        # Overridden in test classes. Place holder to silence IDE noise\n        cls.bit_generator = Xoshiro256\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.max_vector_seed_size = 4\n\n    @classmethod\n    def _extra_setup(cls):\n        cls.vec_1d = np.arange(2.0, 102.0)\n        cls.vec_2d = np.arange(2.0, 102.0)[None, :]\n        cls.mat = np.arange(2.0, 102.0, 0.01).reshape((100, 100))\n        cls.seed_error = TypeError\n\n    def init_generator(self, seed=None, mode=""sequence""):\n        if seed is not None:\n            return Generator(self.bit_generator(*seed, mode=mode))\n        else:\n            return Generator(self.bit_generator(seed=seed, mode=mode))\n\n    def _reset_state(self):\n        self.rg.bit_generator.state = self.initial_state\n\n    def test_init(self):\n        rg = self.init_generator()\n        state = rg.bit_generator.state\n        rg.standard_normal(1)\n        rg.standard_normal(1)\n        rg.bit_generator.state = state\n        new_state = rg.bit_generator.state\n        assert_(comp_state(state, new_state))\n\n    def test_advance(self):\n        bg = self.rg.bit_generator\n        state = bg.state\n        if hasattr(self.rg.bit_generator, ""advance""):\n            kwargs = {}\n            if isinstance(bg, (Philox, ThreeFry)):\n                kwargs = {""counter"": True}\n            self.rg.bit_generator.advance(self.advance, **kwargs)\n            assert_(not comp_state(state, self.rg.bit_generator.state))\n        else:\n            bit_gen_name = self.rg.bit_generator.__class__.__name__\n            pytest.skip(""Advance is not supported by {0}"".format(bit_gen_name))\n\n    def test_jump(self):\n        state = self.rg.bit_generator.state\n        if hasattr(self.rg.bit_generator, ""jump""):\n            with pytest.deprecated_call():\n                self.rg.bit_generator.jump()\n            jumped_state = self.rg.bit_generator.state\n            assert_(not comp_state(state, jumped_state))\n            self.rg.random(2 * 3 * 5 * 7 * 11 * 13 * 17)\n            self.rg.bit_generator.state = state\n            with pytest.deprecated_call():\n                self.rg.bit_generator.jump()\n            rejumped_state = self.rg.bit_generator.state\n            assert_(comp_state(jumped_state, rejumped_state))\n        else:\n            bit_gen_name = self.rg.bit_generator.__class__.__name__\n            pytest.skip(""jump is not supported by {0}"".format(bit_gen_name))\n\n    def test_jumped(self):\n        state = self.rg.bit_generator.state\n        if hasattr(self.rg.bit_generator, ""jumped""):\n            new_bit_gen = self.rg.bit_generator.jumped()\n            assert isinstance(new_bit_gen, self.rg.bit_generator.__class__)\n            assert_(comp_state(state, self.rg.bit_generator.state))\n            Generator(new_bit_gen).random(1000000)\n        else:\n            bit_gen_name = self.rg.bit_generator.__class__.__name__\n            pytest.skip(""jumped is not supported by {0}"".format(bit_gen_name))\n\n    def test_jumped_against_jump(self):\n        if hasattr(self.rg.bit_generator, ""jumped"") and hasattr(\n            self.rg.bit_generator, ""jump""\n        ):\n            bg = self.rg.bit_generator\n            state = bg.state\n            new_bg = bg.jumped()\n            with pytest.deprecated_call():\n                bg.jump()\n            assert_(not comp_state(state, bg.state))\n            assert_(not comp_state(state, new_bg.state))\n            assert_(comp_state(bg.state, new_bg.state))\n        else:\n            bit_gen_name = self.rg.bit_generator.__class__.__name__\n            pytest.skip(""jump or jumped is not supported by {0}"".format(bit_gen_name))\n\n    def test_jumped_against_jump_32bit(self):\n        if hasattr(self.rg.bit_generator, ""jumped"") and hasattr(\n            self.rg.bit_generator, ""jump""\n        ):\n            bg = self.rg.bit_generator\n            bg.seed(*self.seed)\n            # Draw large prime number of 32bits to move internal state values\n            self.rg.random(11587, dtype=np.float32)\n            state = bg.state\n            new_bg = bg.jumped()\n            with pytest.deprecated_call():\n                bg.jump()\n            assert_(not comp_state(state, bg.state))\n            assert_(not comp_state(state, new_bg.state))\n            assert_(comp_state(bg.state, new_bg.state))\n        else:\n            bit_gen_name = self.rg.bit_generator.__class__.__name__\n            pytest.skip(""jump or jumped is not supported by {0}"".format(bit_gen_name))\n\n    def test_uniform(self):\n        r = self.rg.uniform(-1.0, 0.0, size=10)\n        assert_(len(r) == 10)\n        assert_((r > -1).all())\n        assert_((r <= 0).all())\n\n    def test_uniform_array(self):\n        r = self.rg.uniform(np.array([-1.0] * 10), 0.0, size=10)\n        assert_(len(r) == 10)\n        assert_((r > -1).all())\n        assert_((r <= 0).all())\n        r = self.rg.uniform(np.array([-1.0] * 10), np.array([0.0] * 10), size=10)\n        assert_(len(r) == 10)\n        assert_((r > -1).all())\n        assert_((r <= 0).all())\n        r = self.rg.uniform(-1.0, np.array([0.0] * 10), size=10)\n        assert_(len(r) == 10)\n        assert_((r > -1).all())\n        assert_((r <= 0).all())\n\n    def test_random(self):\n        assert_(len(self.rg.random(10)) == 10)\n        params_0(self.rg.random)\n\n    def test_standard_normal_zig(self):\n        assert_(len(self.rg.standard_normal(10)) == 10)\n\n    def test_standard_normal(self):\n        assert_(len(self.rg.standard_normal(10)) == 10)\n        params_0(self.rg.standard_normal)\n\n    def test_standard_gamma(self):\n        assert_(len(self.rg.standard_gamma(10, 10)) == 10)\n        assert_(len(self.rg.standard_gamma(np.array([10] * 10), 10)) == 10)\n        params_1(self.rg.standard_gamma)\n\n    def test_standard_exponential(self):\n        assert_(len(self.rg.standard_exponential(10)) == 10)\n        params_0(self.rg.standard_exponential)\n\n    def test_standard_exponential_float(self):\n        randoms = self.rg.standard_exponential(10, dtype=""float32"")\n        assert_(len(randoms) == 10)\n        assert randoms.dtype == np.float32\n        params_0(partial(self.rg.standard_exponential, dtype=""float32""))\n\n    def test_standard_exponential_float_log(self):\n        randoms = self.rg.standard_exponential(10, dtype=""float32"", method=""inv"")\n        assert_(len(randoms) == 10)\n        assert randoms.dtype == np.float32\n        params_0(partial(self.rg.standard_exponential, dtype=""float32"", method=""inv""))\n\n    def test_standard_cauchy(self):\n        assert_(len(self.rg.standard_cauchy(10)) == 10)\n        params_0(self.rg.standard_cauchy)\n\n    def test_standard_t(self):\n        assert_(len(self.rg.standard_t(10, 10)) == 10)\n        params_1(self.rg.standard_t)\n\n    def test_binomial(self):\n        assert_(self.rg.binomial(10, 0.5) >= 0)\n        assert_(self.rg.binomial(1000, 0.5) >= 0)\n\n    def test_reset_state(self):\n        state = self.rg.bit_generator.state\n        int_1 = self.rg.integers(2 ** 31)\n        self.rg.bit_generator.state = state\n        int_2 = self.rg.integers(2 ** 31)\n        assert_(int_1 == int_2)\n\n    def test_entropy_init(self):\n        rg = self.init_generator()\n        rg2 = self.init_generator()\n        assert_(not comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_seed(self):\n        rg = self.init_generator(self.seed, mode=""legacy"")\n        rg2 = self.init_generator(self.seed, mode=""legacy"")\n        rg.random()\n        rg2.random()\n        assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_reset_state_gauss(self):\n        rg = self.init_generator(seed=self.seed, mode=""legacy"")\n        rg.standard_normal()\n        state = rg.bit_generator.state\n        n1 = rg.standard_normal(size=10)\n        rg2 = self.init_generator()\n        rg2.bit_generator.state = state\n        n2 = rg2.standard_normal(size=10)\n        assert_array_equal(n1, n2)\n\n    def test_reset_state_uint32(self):\n        rg = self.init_generator(seed=self.seed, mode=""legacy"")\n        rg.integers(0, 2 ** 24, 120, dtype=np.uint32)\n        state = rg.bit_generator.state\n        n1 = rg.integers(0, 2 ** 24, 10, dtype=np.uint32)\n        rg2 = self.init_generator()\n        rg2.bit_generator.state = state\n        n2 = rg2.integers(0, 2 ** 24, 10, dtype=np.uint32)\n        assert_array_equal(n1, n2)\n\n    def test_reset_state_float(self):\n        rg = self.init_generator(seed=self.seed, mode=""legacy"")\n        rg.random(dtype=""float32"")\n        state = rg.bit_generator.state\n        n1 = rg.random(size=10, dtype=""float32"")\n        rg2 = self.init_generator()\n        rg2.bit_generator.state = state\n        n2 = rg2.random(size=10, dtype=""float32"")\n        assert_((n1 == n2).all())\n\n    def test_shuffle(self):\n        original = np.arange(200, 0, -1)\n        permuted = self.rg.permutation(original)\n        assert_((original != permuted).any())\n\n    def test_permutation(self):\n        original = np.arange(200, 0, -1)\n        permuted = self.rg.permutation(original)\n        assert_((original != permuted).any())\n\n    def test_tomaxint(self):\n        with pytest.deprecated_call():\n            vals = self.rg.tomaxint(size=100000)\n        maxsize = 0\n        if os.name == ""nt"":\n            maxsize = 2 ** 31 - 1\n        else:\n            try:\n                maxsize = sys.maxint\n            except AttributeError:\n                maxsize = sys.maxsize\n        if maxsize < 2 ** 32:\n            assert_((vals < sys.maxsize).all())\n        else:\n            assert_((vals >= 2 ** 32).any())\n\n    def test_beta(self):\n        vals = self.rg.beta(2.0, 2.0, 10)\n        assert_(len(vals) == 10)\n        vals = self.rg.beta(np.array([2.0] * 10), 2.0)\n        assert_(len(vals) == 10)\n        vals = self.rg.beta(2.0, np.array([2.0] * 10))\n        assert_(len(vals) == 10)\n        vals = self.rg.beta(np.array([2.0] * 10), np.array([2.0] * 10))\n        assert_(len(vals) == 10)\n        vals = self.rg.beta(np.array([2.0] * 10), np.array([[2.0]] * 10))\n        assert_(vals.shape == (10, 10))\n\n    def test_bytes(self):\n        vals = self.rg.bytes(10)\n        assert_(len(vals) == 10)\n\n    def test_chisquare(self):\n        vals = self.rg.chisquare(2.0, 10)\n        assert_(len(vals) == 10)\n        params_1(self.rg.chisquare)\n\n    def test_exponential(self):\n        vals = self.rg.exponential(2.0, 10)\n        assert_(len(vals) == 10)\n        params_1(self.rg.exponential)\n\n    def test_f(self):\n        vals = self.rg.f(3, 1000, 10)\n        assert_(len(vals) == 10)\n\n    def test_gamma(self):\n        vals = self.rg.gamma(3, 2, 10)\n        assert_(len(vals) == 10)\n\n    def test_geometric(self):\n        vals = self.rg.geometric(0.5, 10)\n        assert_(len(vals) == 10)\n        params_1(self.rg.exponential, bounded=True)\n\n    def test_gumbel(self):\n        vals = self.rg.gumbel(2.0, 2.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_laplace(self):\n        vals = self.rg.laplace(2.0, 2.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_logitic(self):\n        vals = self.rg.logistic(2.0, 2.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_logseries(self):\n        vals = self.rg.logseries(0.5, 10)\n        assert_(len(vals) == 10)\n\n    def test_negative_binomial(self):\n        vals = self.rg.negative_binomial(10, 0.2, 10)\n        assert_(len(vals) == 10)\n\n    def test_rand(self):\n        state = self.rg.bit_generator.state\n        with pytest.deprecated_call():\n            vals = self.rg.rand(10, 10, 10)\n        self.rg.bit_generator.state = state\n        assert_((vals == self.rg.random((10, 10, 10))).all())\n        assert_(vals.shape == (10, 10, 10))\n        with pytest.deprecated_call():\n            vals = self.rg.rand(10, 10, 10, dtype=np.float32)\n        assert_(vals.shape == (10, 10, 10))\n\n    def test_randn(self):\n        state = self.rg.bit_generator.state\n        with pytest.deprecated_call():\n            vals = self.rg.randn(10, 10, 10)\n        self.rg.bit_generator.state = state\n        vals2 = self.rg.standard_normal((10, 10, 10))\n        assert_equal(vals, vals2)\n        assert_equal(vals.shape, (10, 10, 10))\n\n        state = self.rg.bit_generator.state\n        with pytest.deprecated_call():\n            vals = self.rg.randn(10, 10, 10)\n        self.rg.bit_generator.state = state\n        assert_equal(vals, self.rg.standard_normal((10, 10, 10)))\n\n        state = self.rg.bit_generator.state\n        with pytest.deprecated_call():\n            self.rg.randn(10, 10, 10)\n        self.rg.bit_generator.state = state\n        with pytest.deprecated_call():\n            vals = self.rg.randn(10, 10, 10, dtype=np.float32)\n        assert_(vals.shape == (10, 10, 10))\n\n    def test_noncentral_chisquare(self):\n        vals = self.rg.noncentral_chisquare(10, 2, 10)\n        assert_(len(vals) == 10)\n\n    def test_noncentral_f(self):\n        vals = self.rg.noncentral_f(3, 1000, 2, 10)\n        assert_(len(vals) == 10)\n        vals = self.rg.noncentral_f(np.array([3] * 10), 1000, 2)\n        assert_(len(vals) == 10)\n        vals = self.rg.noncentral_f(3, np.array([1000] * 10), 2)\n        assert_(len(vals) == 10)\n        vals = self.rg.noncentral_f(3, 1000, np.array([2] * 10))\n        assert_(len(vals) == 10)\n\n    def test_normal(self):\n        vals = self.rg.normal(10, 0.2, 10)\n        assert_(len(vals) == 10)\n\n    def test_pareto(self):\n        vals = self.rg.pareto(3.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_poisson(self):\n        vals = self.rg.poisson(10, 10)\n        assert_(len(vals) == 10)\n        vals = self.rg.poisson(np.array([10] * 10))\n        assert_(len(vals) == 10)\n        params_1(self.rg.poisson)\n\n    def test_power(self):\n        vals = self.rg.power(0.2, 10)\n        assert_(len(vals) == 10)\n\n    def test_integers(self):\n        vals = self.rg.integers(10, 20, 10)\n        assert_(len(vals) == 10)\n\n    def test_random_integers(self):\n        with suppress_warnings() as sup:\n            sup.record(DeprecationWarning)\n            vals = self.rg.random_integers(10, 20, 10)\n        assert_(len(vals) == 10)\n\n    def test_rayleigh(self):\n        vals = self.rg.rayleigh(0.2, 10)\n        assert_(len(vals) == 10)\n        params_1(self.rg.rayleigh, bounded=True)\n\n    def test_vonmises(self):\n        vals = self.rg.vonmises(10, 0.2, 10)\n        assert_(len(vals) == 10)\n\n    def test_wald(self):\n        vals = self.rg.wald(1.0, 1.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_weibull(self):\n        vals = self.rg.weibull(1.0, 10)\n        assert_(len(vals) == 10)\n\n    def test_zipf(self):\n        vals = self.rg.zipf(10, 10)\n        assert_(len(vals) == 10)\n        vals = self.rg.zipf(self.vec_1d)\n        assert_(len(vals) == 100)\n        vals = self.rg.zipf(self.vec_2d)\n        assert_(vals.shape == (1, 100))\n        vals = self.rg.zipf(self.mat)\n        assert_(vals.shape == (100, 100))\n\n    def test_hypergeometric(self):\n        vals = self.rg.hypergeometric(25, 25, 20)\n        assert_(np.isscalar(vals))\n        vals = self.rg.hypergeometric(np.array([25] * 10), 25, 20)\n        assert_(vals.shape == (10,))\n\n    def test_triangular(self):\n        vals = self.rg.triangular(-5, 0, 5)\n        assert_(np.isscalar(vals))\n        vals = self.rg.triangular(-5, np.array([0] * 10), 5)\n        assert_(vals.shape == (10,))\n\n    def test_multivariate_normal(self):\n        mean = [0, 0]\n        cov = [[1, 0], [0, 100]]  # diagonal covariance\n        x = self.rg.multivariate_normal(mean, cov, 5000)\n        assert_(x.shape == (5000, 2))\n        x_zig = self.rg.multivariate_normal(mean, cov, 5000)\n        assert_(x.shape == (5000, 2))\n        x_inv = self.rg.multivariate_normal(mean, cov, 5000)\n        assert_(x.shape == (5000, 2))\n        assert_((x_zig != x_inv).any())\n\n    def test_multinomial(self):\n        vals = self.rg.multinomial(100, [1.0 / 3, 2.0 / 3])\n        assert_(vals.shape == (2,))\n        vals = self.rg.multinomial(100, [1.0 / 3, 2.0 / 3], size=10)\n        assert_(vals.shape == (10, 2))\n\n    def test_dirichlet(self):\n        s = self.rg.dirichlet((10, 5, 3), 20)\n        assert_(s.shape == (20, 3))\n\n    def test_pickle(self):\n        pick = pickle.dumps(self.rg)\n        unpick = pickle.loads(pick)\n        assert type(self.rg) == type(unpick)\n        assert comp_state(self.rg.bit_generator.state, unpick.bit_generator.state)\n\n        pick = pickle.dumps(self.rg)\n        unpick = pickle.loads(pick)\n        assert type(self.rg) == type(unpick)\n        assert comp_state(self.rg.bit_generator.state, unpick.bit_generator.state)\n\n    def test_seed_array(self):\n        if self.seed_vector_bits is None:\n            if isinstance(self.bit_generator, partial):\n                bit_gen_name = self.bit_generator.func.__name__\n            else:\n                bit_gen_name = self.bit_generator.__name__\n            pytest.skip(""Vector seeding is not supported by {0}"".format(bit_gen_name))\n\n        dtype = np.uint32 if self.seed_vector_bits == 32 else np.uint64\n        seed = np.array([1], dtype=dtype)\n        self.rg.bit_generator.seed(seed)\n        state1 = self.rg.bit_generator.state\n        self.rg.bit_generator.seed(1)\n        state2 = self.rg.bit_generator.state\n        assert_(comp_state(state1, state2))\n\n    def test_array_scalar_seed_diff(self):\n        if self.max_vector_seed_size == 1:\n            pytest.skip(""Skipping since max_vector_seed_size is 1"")\n        dtype = np.uint32 if self.seed_vector_bits == 32 else np.uint64\n        seed = np.arange(3, 3 + self.max_vector_seed_size, dtype=dtype)\n        self.rg.bit_generator.seed(seed)\n        state1 = self.rg.bit_generator.state\n        self.rg.bit_generator.seed(seed[0])\n        state2 = self.rg.bit_generator.state\n        assert_(not comp_state(state1, state2))\n\n        seed = np.arange(1, 1 + self.max_vector_seed_size, dtype=dtype)\n        self.rg.bit_generator.seed(seed)\n        state1 = self.rg.bit_generator.state\n        self.rg.bit_generator.seed(seed[0])\n        state2 = self.rg.bit_generator.state\n        assert_(not comp_state(state1, state2))\n\n        seed = (\n            2\n            ** np.mod(\n                np.arange(1500, 1500 + self.max_vector_seed_size, dtype=dtype),\n                self.seed_vector_bits - 1,\n            )\n            + 1\n        )\n        self.rg.bit_generator.seed(seed)\n        state1 = self.rg.bit_generator.state\n        self.rg.bit_generator.seed(seed[0])\n        state2 = self.rg.bit_generator.state\n        assert_(not comp_state(state1, state2))\n\n    def test_seed_array_error(self):\n        if self.seed_vector_bits == 32:\n            out_of_bounds = 2 ** 32\n        else:\n            out_of_bounds = 2 ** 64\n\n        seed = -1\n        with pytest.raises(ValueError):\n            self.rg.bit_generator.seed(seed)\n\n        seed = np.array([-1], dtype=np.int32)\n        with pytest.raises((ValueError, TypeError)):\n            self.rg.bit_generator.seed(seed)\n\n        seed = np.array([1, 2, 3, -5], dtype=np.int32)\n        with pytest.raises((ValueError, TypeError)):\n            self.rg.bit_generator.seed(seed)\n\n        if isinstance(self.rg.bit_generator, LXM):\n            return\n        seed = np.array([1, 2, 3, out_of_bounds])\n        with pytest.raises((ValueError, TypeError)):\n            self.rg.bit_generator.seed(seed)\n\n    def test_uniform_float(self):\n        rg = self.init_generator(seed=[12345], mode=""legacy"")\n        warmup(rg)\n        state = rg.bit_generator.state\n        r1 = rg.random(11, dtype=np.float32)\n        rg2 = self.init_generator()\n        warmup(rg2)\n        rg2.bit_generator.state = state\n        r2 = rg2.random(11, dtype=np.float32)\n        assert_array_equal(r1, r2)\n        assert_equal(r1.dtype, np.float32)\n        assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_gamma_floats(self):\n        rg = self.init_generator()\n        warmup(rg)\n        state = rg.bit_generator.state\n        r1 = rg.standard_gamma(4.0, 11, dtype=np.float32)\n        rg2 = self.init_generator(mode=""legacy"")\n        warmup(rg2)\n        rg2.bit_generator.state = state\n        r2 = rg2.standard_gamma(4.0, 11, dtype=np.float32)\n        assert_array_equal(r1, r2)\n        assert_equal(r1.dtype, np.float32)\n        assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_normal_floats(self):\n        rg = self.init_generator(mode=""legacy"")\n        warmup(rg)\n        state = rg.bit_generator.state\n        r1 = rg.standard_normal(11, dtype=np.float32)\n        rg2 = self.init_generator()\n        warmup(rg2)\n        rg2.bit_generator.state = state\n        r2 = rg2.standard_normal(11, dtype=np.float32)\n        assert_array_equal(r1, r2)\n        assert_equal(r1.dtype, np.float32)\n        assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_normal_zig_floats(self):\n        rg = self.init_generator()\n        warmup(rg)\n        state = rg.bit_generator.state\n        r1 = rg.standard_normal(11, dtype=np.float32)\n        rg2 = self.init_generator(mode=""legacy"")\n        warmup(rg2)\n        rg2.bit_generator.state = state\n        r2 = rg2.standard_normal(11, dtype=np.float32)\n        assert_array_equal(r1, r2)\n        assert_equal(r1.dtype, np.float32)\n        assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))\n\n    def test_output_fill(self):\n        rg = self.rg\n        state = rg.bit_generator.state\n        size = (31, 7, 97)\n        existing = np.empty(size)\n        rg.bit_generator.state = state\n        rg.standard_normal(out=existing)\n        rg.bit_generator.state = state\n        direct = rg.standard_normal(size=size)\n        assert_equal(direct, existing)\n\n        sized = np.empty(size)\n        rg.bit_generator.state = state\n        rg.standard_normal(out=sized, size=sized.shape)\n\n        existing = np.empty(size, dtype=np.float32)\n        rg.bit_generator.state = state\n        rg.standard_normal(out=existing, dtype=np.float32)\n        rg.bit_generator.state = state\n        direct = rg.standard_normal(size=size, dtype=np.float32)\n        assert_equal(direct, existing)\n\n    def test_output_filling_uniform(self):\n        rg = self.rg\n        state = rg.bit_generator.state\n        size = (31, 7, 97)\n        existing = np.empty(size)\n        rg.bit_generator.state = state\n        rg.random(out=existing)\n        rg.bit_generator.state = state\n        direct = rg.random(size=size)\n        assert_equal(direct, existing)\n\n        existing = np.empty(size, dtype=np.float32)\n        rg.bit_generator.state = state\n        rg.random(out=existing, dtype=np.float32)\n        rg.bit_generator.state = state\n        direct = rg.random(size=size, dtype=np.float32)\n        assert_equal(direct, existing)\n\n    def test_output_filling_exponential(self):\n        rg = self.rg\n        state = rg.bit_generator.state\n        size = (31, 7, 97)\n        existing = np.empty(size)\n        rg.bit_generator.state = state\n        rg.standard_exponential(out=existing)\n        rg.bit_generator.state = state\n        direct = rg.standard_exponential(size=size)\n        assert_equal(direct, existing)\n\n        existing = np.empty(size, dtype=np.float32)\n        rg.bit_generator.state = state\n        rg.standard_exponential(out=existing, dtype=np.float32)\n        rg.bit_generator.state = state\n        direct = rg.standard_exponential(size=size, dtype=np.float32)\n        assert_equal(direct, existing)\n\n    def test_output_filling_gamma(self):\n        rg = self.rg\n        state = rg.bit_generator.state\n        size = (31, 7, 97)\n        existing = np.zeros(size)\n        rg.bit_generator.state = state\n        rg.standard_gamma(1.0, out=existing)\n        rg.bit_generator.state = state\n        direct = rg.standard_gamma(1.0, size=size)\n        assert_equal(direct, existing)\n\n        existing = np.zeros(size, dtype=np.float32)\n        rg.bit_generator.state = state\n        rg.standard_gamma(1.0, out=existing, dtype=np.float32)\n        rg.bit_generator.state = state\n        direct = rg.standard_gamma(1.0, size=size, dtype=np.float32)\n        assert_equal(direct, existing)\n\n    def test_output_filling_gamma_broadcast(self):\n        rg = self.rg\n        state = rg.bit_generator.state\n        size = (31, 7, 97)\n        mu = np.arange(97.0) + 1.0\n        existing = np.zeros(size)\n        rg.bit_generator.state = state\n        rg.standard_gamma(mu, out=existing)\n        rg.bit_generator.state = state\n        direct = rg.standard_gamma(mu, size=size)\n        assert_equal(direct, existing)\n\n        existing = np.zeros(size, dtype=np.float32)\n        rg.bit_generator.state = state\n        rg.standard_gamma(mu, out=existing, dtype=np.float32)\n        rg.bit_generator.state = state\n        direct = rg.standard_gamma(mu, size=size, dtype=np.float32)\n        assert_equal(direct, existing)\n\n    def test_output_fill_error(self):\n        rg = self.rg\n        size = (31, 7, 97)\n        existing = np.empty(size)\n        with pytest.raises(TypeError):\n            rg.standard_normal(out=existing, dtype=np.float32)\n        with pytest.raises(ValueError):\n            rg.standard_normal(out=existing[::3])\n        existing = np.empty(size, dtype=np.float32)\n        with pytest.raises(TypeError):\n            rg.standard_normal(out=existing, dtype=np.float64)\n\n        existing = np.zeros(size, dtype=np.float32)\n        with pytest.raises(TypeError):\n            rg.standard_gamma(1.0, out=existing, dtype=np.float64)\n        with pytest.raises(ValueError):\n            rg.standard_gamma(1.0, out=existing[::3], dtype=np.float32)\n        existing = np.zeros(size, dtype=np.float64)\n        with pytest.raises(TypeError):\n            rg.standard_gamma(1.0, out=existing, dtype=np.float32)\n        with pytest.raises(ValueError):\n            rg.standard_gamma(1.0, out=existing[::3])\n\n    def test_integers_broadcast(self, dtype):\n        if dtype == np.bool:\n            upper = 2\n            lower = 0\n        else:\n            info = np.iinfo(dtype)\n            upper = int(info.max) + 1\n            lower = info.min\n        self._reset_state()\n        a = self.rg.integers(lower, [upper] * 10, dtype=dtype)\n        self._reset_state()\n        b = self.rg.integers([lower] * 10, upper, dtype=dtype)\n        assert_equal(a, b)\n        self._reset_state()\n        c = self.rg.integers(lower, upper, size=10, dtype=dtype)\n        assert_equal(a, c)\n        self._reset_state()\n        d = self.rg.integers(\n            np.array([lower] * 10),\n            np.array([upper], dtype=np.object),\n            size=10,\n            dtype=dtype,\n        )\n        assert_equal(a, d)\n        self._reset_state()\n        e = self.rg.integers(\n            np.array([lower] * 10), np.array([upper] * 10), size=10, dtype=dtype\n        )\n        assert_equal(a, e)\n\n        self._reset_state()\n        a = self.rg.integers(0, upper, size=10, dtype=dtype)\n        self._reset_state()\n        b = self.rg.integers([upper] * 10, dtype=dtype)\n        assert_equal(a, b)\n\n    def test_integers_numpy(self, dtype):\n        high = np.array([1])\n        low = np.array([0])\n\n        out = self.rg.integers(low, high, dtype=dtype)\n        assert out.shape == (1,)\n\n        out = self.rg.integers(low[0], high, dtype=dtype)\n        assert out.shape == (1,)\n\n        out = self.rg.integers(low, high[0], dtype=dtype)\n        assert out.shape == (1,)\n\n    def test_integers_broadcast_errors(self, dtype):\n        if dtype == np.bool:\n            upper = 2\n            lower = 0\n        else:\n            info = np.iinfo(dtype)\n            upper = int(info.max) + 1\n            lower = info.min\n        with pytest.raises(ValueError):\n            self.rg.integers(lower, [upper + 1] * 10, dtype=dtype)\n        with pytest.raises(ValueError):\n            self.rg.integers(lower - 1, [upper] * 10, dtype=dtype)\n        with pytest.raises(ValueError):\n            self.rg.integers([lower - 1], [upper] * 10, dtype=dtype)\n        with pytest.raises(ValueError):\n            self.rg.integers([0], [0], dtype=dtype)\n\n    def test_complex_normal(self):\n        st = self.rg.bit_generator.state\n        vals = self.rg.complex_normal(2.0 + 7.0j, 10.0, 5.0 - 5.0j, size=10)\n        assert_(len(vals) == 10)\n\n        self.rg.bit_generator.state = st\n        vals2 = [\n            self.rg.complex_normal(2.0 + 7.0j, 10.0, 5.0 - 5.0j) for _ in range(10)\n        ]\n        np.testing.assert_allclose(vals, vals2)\n\n        self.rg.bit_generator.state = st\n        vals3 = self.rg.complex_normal(\n            2.0 + 7.0j * np.ones(10), 10.0 * np.ones(1), 5.0 - 5.0j\n        )\n        np.testing.assert_allclose(vals, vals3)\n\n        self.rg.bit_generator.state = st\n        norms = self.rg.standard_normal(size=20)\n        norms = np.reshape(norms, (10, 2))\n        cov = 0.5 * (-5.0)\n        v_real = 7.5\n        v_imag = 2.5\n        rho = cov / np.sqrt(v_real * v_imag)\n        imag = 7 + np.sqrt(v_imag) * (\n            rho * norms[:, 0] + np.sqrt(1 - rho ** 2) * norms[:, 1]\n        )\n        real = 2 + np.sqrt(v_real) * norms[:, 0]\n        vals4 = [re + im * (0 + 1.0j) for re, im in zip(real, imag)]\n\n        np.testing.assert_allclose(vals4, vals)\n\n    def test_complex_normal_bm(self):\n        st = self.rg.bit_generator.state\n        vals = self.rg.complex_normal(2.0 + 7.0j, 10.0, 5.0 - 5.0j, size=10)\n        assert_(len(vals) == 10)\n\n        self.rg.bit_generator.state = st\n        vals2 = [\n            self.rg.complex_normal(2.0 + 7.0j, 10.0, 5.0 - 5.0j) for _ in range(10)\n        ]\n        np.testing.assert_allclose(vals, vals2)\n\n        self.rg.bit_generator.state = st\n        vals3 = self.rg.complex_normal(\n            2.0 + 7.0j * np.ones(10), 10.0 * np.ones(1), 5.0 - 5.0j\n        )\n        np.testing.assert_allclose(vals, vals3)\n\n    def test_complex_normal_zero_variance(self):\n        st = self.rg.bit_generator.state\n        c = self.rg.complex_normal(0, 1.0, 1.0)\n        assert_almost_equal(c.imag, 0.0)\n        self.rg.bit_generator.state = st\n        n = self.rg.standard_normal()\n        np.testing.assert_allclose(c, n, atol=1e-8)\n\n        st = self.rg.bit_generator.state\n        c = self.rg.complex_normal(0, 1.0, -1.0)\n        assert_almost_equal(c.real, 0.0)\n        self.rg.bit_generator.state = st\n        self.rg.standard_normal()\n        n = self.rg.standard_normal()\n        assert_almost_equal(c.real, 0.0)\n        np.testing.assert_allclose(c.imag, n, atol=1e-8)\n\n    def test_random_uintegers(self):\n        assert len(self.rg.uintegers(10)) == 10\n        assert len(self.rg.uintegers(10, bits=32)) == 10\n        assert isinstance(self.rg.uintegers(), int)\n        assert isinstance(self.rg.uintegers(bits=32), int)\n        with pytest.raises(ValueError):\n            with pytest.deprecated_call():\n                self.rg.random_uintegers(bits=128)\n\n    def test_bit_generator_raw_large(self):\n        bg = self.rg.bit_generator\n        state = bg.state\n        raw = bg.random_raw(100000)\n        bg.state = state\n        assert_equal(raw, bg.random_raw(100000))\n\n    def test_bit_generator_raw(self):\n        bg = self.rg.bit_generator\n        val = bg.random_raw()\n        assert np.isscalar(val)\n        val = bg.random_raw(1)\n        assert val.shape == (1,)\n        val = bg.random_raw(1000)\n        assert val.shape == (1000,)\n        assert val.dtype == np.uint64\n\n    def test_bit_generator_benchmark(self):\n        bg = self.rg.bit_generator\n        state = bg.state\n        bg._benchmark(1000)\n        assert not comp_state(state, bg.state)\n        state = bg.state\n        bg._benchmark(1000, ""double"")\n        assert not comp_state(state, bg.state)\n\n\nclass TestMT19937(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = MT19937\n        cls.advance = None\n        cls.seed = [2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 32\n        cls._extra_setup()\n        cls.seed_error = ValueError\n\n    def test_numpy_state(self):\n        nprg = np.random.RandomState()\n        nprg.standard_normal(99)\n        state = nprg.get_state()\n        self.rg.bit_generator.state = state\n        state2 = self.rg.bit_generator.state\n        assert_((state[1] == state2[""state""][""key""]).all())\n        assert_((state[2] == state2[""state""][""pos""]))\n\n\nclass TestMT64(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = MT64\n        cls.advance = None\n        cls.seed = [2 ** 43 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n\n\nclass TestJSF64(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(JSF, seed_size=3)\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestJSF32(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(JSF, size=32, seed_size=3)\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestPCG64(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = PCG64\n        cls.advance = 2 ** 96 + 2 ** 48 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1\n        cls.seed = [\n            2 ** 96 + 2 ** 48 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1,\n            2 ** 21 + 2 ** 16 + 2 ** 5 + 1,\n        ]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = None\n        cls._extra_setup()\n\n    def test_seed_array_error(self):\n        # GH #82 for error type changes\n        if self.seed_vector_bits == 32:\n            out_of_bounds = 2 ** 32\n        else:\n            out_of_bounds = 2 ** 64\n\n        seed = -1\n        with pytest.raises(ValueError):\n            self.rg.bit_generator.seed(seed)\n\n        error_type = ValueError if self.seed_vector_bits else TypeError\n        seed = np.array([-1], dtype=np.int32)\n        with pytest.raises(error_type):\n            self.rg.bit_generator.seed(seed)\n\n        seed = np.array([1, 2, 3, -5], dtype=np.int32)\n        with pytest.raises(error_type):\n            self.rg.bit_generator.seed(seed)\n\n        seed = np.array([1, 2, 3, out_of_bounds])\n        with pytest.raises(error_type):\n            self.rg.bit_generator.seed(seed)\n\n    def test_array_scalar_seed_diff(self):\n        pass\n\n\nclass TestPCG64DXSM(TestPCG64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(PCG64, variant=""dxsm"")\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._extra_setup()\n\n\nclass TestPCG64CMDXSM(TestPCG64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(PCG64, variant=""cm-dxsm"")\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._extra_setup()\n\n\nclass TestPhilox4x64(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 4\n        cls.width = 64\n        cls.bit_generator_base = Philox\n        cls.bit_generator = partial(Philox, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls.max_vector_seed_size = 1\n        cls._extra_setup()\n\n    def test_repr(self):\n        rpr = repr(self.bit_generator(mode=""sequence""))\n        assert ""{0}x{1}"".format(self.number, self.width) in rpr\n\n    def test_bad_width_number(self):\n        with pytest.raises(ValueError, match=""number must be either 2 or 4""):\n            self.bit_generator_base(number=self.number + 1, mode=""legacy"")\n        with pytest.raises(ValueError, match=""width must be either 32 or 64""):\n            self.bit_generator_base(width=self.width - 1, mode=""legacy"")\n\n\nclass TestPhilox2x64(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 2\n        cls.width = 64\n        cls.bit_generator = partial(Philox, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls.max_vector_seed_size = 1\n        cls._extra_setup()\n\n\nclass TestPhilox2x32(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 2\n        cls.width = 32\n        cls.bit_generator = partial(Philox, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestPhilox4x32(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 4\n        cls.width = 32\n        cls.bit_generator = partial(Philox, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestThreeFry4x64(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 4\n        cls.width = 64\n        cls.bit_generator_base = ThreeFry\n        cls.bit_generator = partial(ThreeFry, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestThreeFry2x64(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 2\n        cls.width = 64\n        cls.bit_generator = partial(ThreeFry, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestThreeFry2x32(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 2\n        cls.width = 32\n        cls.bit_generator = partial(ThreeFry, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestThreeFry4x32(TestPhilox4x64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.number = 4\n        cls.width = 32\n        cls.bit_generator = partial(ThreeFry, number=cls.number, width=cls.width)\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestXoroshiro128(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoroshiro128\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestXoroshiro128PlusPlus(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = partial(Xoroshiro128, plusplus=True)\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._extra_setup()\n\n\nclass TestXoshiro256(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoshiro256\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestXoshiro512(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xoshiro512\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestXorshift1024(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = Xorshift1024\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n\n\nclass TestDSFMT(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = DSFMT\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._extra_setup()\n        cls.seed_vector_bits = 32\n\n\nclass TestSFMT(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = SFMT\n        cls.advance = None\n        cls.seed = [12345]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls._extra_setup()\n        cls.seed_vector_bits = 32\n\n\nclass TestEntropy(object):\n    def test_entropy(self):\n        e1 = entropy.random_entropy()\n        e2 = entropy.random_entropy()\n        assert_((e1 != e2))\n        e1 = entropy.random_entropy(10)\n        e2 = entropy.random_entropy(10)\n        assert_((e1 != e2).all())\n        e1 = entropy.random_entropy(10, source=""system"")\n        e2 = entropy.random_entropy(10, source=""system"")\n        assert_((e1 != e2).all())\n\n    def test_fallback(self):\n        e1 = entropy.random_entropy(source=""fallback"")\n        time.sleep(0.1)\n        e2 = entropy.random_entropy(source=""fallback"")\n        assert_((e1 != e2))\n\n\nclass TestPCG32(TestPCG64):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = PCG32\n        cls.advance = 2 ** 48 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1\n        cls.seed = [\n            2 ** 48 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1,\n            2 ** 21 + 2 ** 16 + 2 ** 5 + 1,\n        ]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = None\n        cls._extra_setup()\n\n\nclass TestAESCounter(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = AESCounter\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n        cls.max_vector_seed_size = 2\n\n\nclass TestChaCha(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = ChaCha\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.seed = [2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n\n\nclass TestHC128(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = HC128\n        cls.seed = [2 ** 231 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n\n\nclass TestSPECK128(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = SPECK128\n        cls.seed = [2 ** 231 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed, mode=""legacy""))\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n\n\nclass TestLXM(RNG):\n    @classmethod\n    def setup_class(cls):\n        super().setup_class()\n        cls.bit_generator = LXM\n        cls.seed = [2 ** 231 + 2 ** 21 + 2 ** 16 + 2 ** 5 + 1]\n        cls.rg = Generator(cls.bit_generator(*cls.seed))\n        cls.advance = 2 ** 63 + 2 ** 31 + 2 ** 15 + 1\n        cls.initial_state = cls.rg.bit_generator.state\n        cls.seed_vector_bits = 64\n        cls._extra_setup()\n        cls.seed_error = ValueError\n        cls.out_of_bounds = 2 ** 192 + 1\n\n    def init_generator(self, seed=None, mode=""sequence""):\n        return Generator(self.bit_generator(seed=seed))\n'"
randomgen/tests/test_wrapper.py,14,"b'import numpy as np\nimport pytest\n\nfrom randomgen.generator import Generator\nfrom randomgen.pcg64 import PCG64\nfrom randomgen.wrapper import UserBitGenerator\n\n\ndef rotr_64(value, rot):\n    value = np.uint64(value)\n    rot = np.uint64(rot)\n    return int((value >> rot) | (value << ((-rot) & np.uint(63))))\n\n\nclass _PCG64:\n    PCG_DEFAULT_MULTIPLIER = (2549297995355413924 << 64) + 4865540595714422341\n    MODULUS = 2 ** 128\n\n    def __init__(self, state, inc):\n        self._state = state\n        self._inc = inc\n        self._has_uint32 = False\n        self._uinteger = 0\n\n    def random_raw(self):\n        state = self._state * self.PCG_DEFAULT_MULTIPLIER + self._inc\n        state = state % self.MODULUS\n        self._state = state\n        return rotr_64((state >> 64) ^ (state & 0xFFFFFFFFFFFFFFFF), state >> 122)\n\n    def next_64(self):\n        def _next_64(void_p):\n            return self.random_raw()\n\n        return _next_64\n\n    def next_32(self):\n        def _next_32(void_p):\n            if self._has_uint32:\n                self._has_uint32 = False\n                return self._uinteger\n            next_value = self.random_raw()\n            self._has_uint32 = True\n            self._uinteger = next_value >> 32\n            return next_value & 0xFFFFFFFF\n\n        return _next_32\n\n\nPCG64_NATIVE = PCG64(0, mode=""sequence"", variant=""xsl-rr"")\nPCG64_INITIAL_STATE = PCG64_NATIVE.state\n\n\n@pytest.fixture(scope=""function"")\ndef python_pcg(request):\n    bit_gen = _PCG64(\n        PCG64_INITIAL_STATE[""state""][""state""], PCG64_INITIAL_STATE[""state""][""inc""]\n    )\n    return bit_gen.next_64()\n\n\n@pytest.fixture(scope=""function"")\ndef pcg_native(request):\n    return PCG64(0, mode=""sequence"", variant=""xsl-rr"")\n\n\n@pytest.fixture(scope=""function"")\ndef pcg_python(request):\n    bit_gen = _PCG64(\n        PCG64_INITIAL_STATE[""state""][""state""], PCG64_INITIAL_STATE[""state""][""inc""]\n    )\n    return UserBitGenerator(bit_gen.next_64(), 64, next_32=bit_gen.next_32())\n\n\ndef test_smoke(python_pcg):\n    bg = UserBitGenerator(python_pcg, 64)\n    gen = Generator(bg)\n    assert isinstance(gen.random(), float)\n    assert isinstance(gen.standard_normal(dtype=np.float32), float)\n    assert isinstance(gen.integers(0, 2 ** 32, dtype=np.uint32), np.integer)\n    assert isinstance(gen.integers(0, 2 ** 64, dtype=np.uint64), np.integer)\n\n\ndef test_random_raw(pcg_python, pcg_native):\n    np.testing.assert_equal(pcg_python.random_raw(1000), pcg_native.random_raw(1000))\n\n\n@pytest.mark.parametrize(\n    ""func"",\n    [\n        lambda bg: bg.random(),\n        lambda bg: bg.random(size=10),\n        lambda bg: bg.standard_normal(),\n        lambda bg: bg.standard_normal(size=(20, 3)),\n        lambda bg: bg.standard_normal(dtype=np.float32),\n        lambda bg: bg.standard_normal(size=(20, 3), dtype=np.float32),\n        lambda bg: bg.integers(0, 2 ** 32, dtype=np.uint32),\n        lambda bg: bg.integers(0, 2 ** 32, dtype=np.uint32, size=(7, 5, 3, 2)),\n        lambda bg: bg.integers(0, 2 ** 64, dtype=np.uint64),\n        lambda bg: bg.integers(0, 2 ** 32, dtype=np.uint64, size=(7, 5, 3, 2)),\n    ],\n)\ndef test_against_ref(func, pcg_python, pcg_native):\n    a = func(Generator(pcg_python))\n    b = func(Generator(pcg_native))\n    np.testing.assert_allclose(a, b)\n'"
randomgen/tests/test_wrapper_numba.py,23,"b'import ctypes\n\nimport numpy as np\nimport pytest\n\nfrom randomgen.generator import Generator\nfrom randomgen.wrapper import UserBitGenerator\n\nHAS_NUMBA = False\ntry:\n    from numba import cfunc, types, carray, jit\n\n    HAS_NUMBA = True\nexcept ImportError:\n    pytestmark = pytest.mark.skip\n\nif HAS_NUMBA:\n    murmur_hash_3_sig = types.uint64(types.uint64)\n\n    @jit(signature_or_function=murmur_hash_3_sig, inline=""always"")\n    def murmur_hash_3(z):\n        z = (z ^ (z >> np.uint64(30))) * np.uint64(0xBF58476D1CE4E5B9)\n        z = (z ^ (z >> np.uint64(27))) * np.uint64(0x94D049BB133111EB)\n        return z ^ (z >> np.uint64(31))\n\n    split_mix_next_sig = types.uint64(types.uint64[:])\n\n    @jit(signature_or_function=split_mix_next_sig, inline=""always"")\n    def splitmix_next(state):\n        state[0] += 0x9E3779B97F4A7C15\n        return murmur_hash_3(state[0])\n\n\nclass NumbaSplitMix64:\n    def __init__(self, state):\n        if not isinstance(state, (int, np.integer)) or not (0 <= state < 2 ** 64):\n            raise ValueError(""state must be a valid uint64"")\n        # state[0] is the splitmix64 state\n        # state[1] contains both the has_uint flag in bit 0\n        #   uinteger in bits 32...63\n        self._state = np.array([state, 0], dtype=np.uint64)\n        self._next_raw = None\n        self._next_64 = None\n        self._next_32 = None\n        self._next_double = None\n\n    @property\n    def state_address(self):\n        return self._state.ctypes.data_as(ctypes.c_void_p)\n\n    @property\n    def next_64(self):\n        # Ensure a reference is held\n        self._next_64 = self.next_raw\n\n        return self.next_raw\n\n    @property\n    def next_32(self):\n        sig = types.uint32(types.CPointer(types.uint64))\n\n        @cfunc(sig)\n        def next_32(st):\n            bit_gen_state = carray(st, (2,), dtype=np.uint64)\n            if bit_gen_state[1] & np.uint64(0x1):\n                out = bit_gen_state[1] >> np.uint64(32)\n                bit_gen_state[1] = 0\n                return out\n            z = splitmix_next(bit_gen_state)\n            bit_gen_state[1] = z | np.uint64(0x1)\n            return z & 0xFFFFFFFF\n\n        # Ensure a reference is held\n        self._next_32 = next_32\n\n        return next_32\n\n    @property\n    def next_double(self):\n        sig = types.double(types.CPointer(types.uint64))\n\n        @cfunc(sig)\n        def next_double(st):\n            bit_gen_state = carray(st, (2,), dtype=np.uint64)\n            return (\n                np.uint64(splitmix_next(bit_gen_state)) >> np.uint64(11)\n            ) / 9007199254740992.0\n\n        # Ensure a reference is held\n        self._next_double = next_double\n\n        return next_double\n\n    @property\n    def next_raw(self):\n        sig = types.uint64(types.CPointer(types.uint64))\n\n        @cfunc(sig)\n        def next_64(st):\n            bit_gen_state = carray(st, (2,), dtype=np.uint64)\n            return splitmix_next(bit_gen_state)\n\n        # Ensure a reference is held\n        self._next_64 = next_64\n\n        return next_64\n\n    @property\n    def state_getter(self):\n        def f() -> dict:\n            return {\n                ""bit_gen"": type(self).__name__,\n                ""state"": self._state[0],\n                ""has_uint"": self._state[1] & np.uint64(0x1),\n                ""uinteger"": self._state[1] >> np.uint64(32),\n            }\n\n        return f\n\n    @property\n    def state_setter(self):\n        def f(value: dict):\n            name = value.get(""bit_gen"", None)\n            if name != type(self).__name__:\n                raise ValueError(f""state must be from a {type(self).__name__}"")\n            self._state[0] = np.uint64(value[""state""])\n            temp = np.uint64(value[""uinteger""]) << np.uint64(32)\n            temp |= np.uint64(value[""has_uint""]) & np.uint64(0x1)\n            self._state[1] = temp\n\n        return f\n\n\n@pytest.fixture(scope=""module"")\ndef split_mix():\n    return NumbaSplitMix64(12345)\n\n\ndef test_ctypes_smoke(split_mix):\n    bgf = UserBitGenerator.from_ctypes(\n        split_mix.next_raw.ctypes,\n        split_mix.next_64.ctypes,\n        split_mix.next_32.ctypes,\n        split_mix.next_double.ctypes,\n        split_mix.state_address,\n        state_getter=split_mix.state_getter,\n        state_setter=split_mix.state_setter,\n    )\n    gen = Generator(bgf)\n    gen.standard_normal(size=10)\n    assert bgf.state == split_mix.state_getter()\n    gen.standard_normal(dtype=np.float32)\n    assert bgf.state == split_mix.state_getter()\n    gen.integers(0, 2 ** 63, dtype=np.uint64, size=10)\n    assert bgf.state == split_mix.state_getter()\n    old_state = bgf.state.copy()\n    old_state[""state""] = 1\n    bgf.state = old_state\n    assert bgf.state == split_mix.state_getter()\n\n\ndef test_cfunc_smoke(split_mix):\n    bgf = UserBitGenerator.from_cfunc(\n        split_mix.next_raw,\n        split_mix.next_64,\n        split_mix.next_32,\n        split_mix.next_double,\n        split_mix.state_address,\n        state_getter=split_mix.state_getter,\n        state_setter=split_mix.state_setter,\n    )\n    gen = Generator(bgf)\n    gen.standard_normal(size=10)\n    assert bgf.state == split_mix.state_getter()\n    gen.standard_normal(dtype=np.float32)\n    assert bgf.state == split_mix.state_getter()\n    gen.integers(0, 2 ** 63, dtype=np.uint64, size=10)\n    assert bgf.state == split_mix.state_getter()\n    old_state = bgf.state.copy()\n    old_state[""state""] = 1\n    bgf.state = old_state\n    assert bgf.state == split_mix.state_getter()\n\n\ndef test_no_setter_getter(split_mix):\n    bgf = UserBitGenerator.from_cfunc(\n        split_mix.next_raw,\n        split_mix.next_64,\n        split_mix.next_32,\n        split_mix.next_double,\n        split_mix.state_address,\n    )\n    gen = Generator(bgf)\n    gen.standard_normal(size=10)\n    gen.standard_normal(size=10, dtype=np.float32)\n    gen.integers(0, 2 ** 63, dtype=np.uint64, size=10)\n    with pytest.raises(NotImplementedError):\n        bgf.state\n    with pytest.raises(NotImplementedError):\n        bgf.state = {""apple""}\n\n    bgf = UserBitGenerator.from_cfunc(\n        split_mix.next_raw,\n        split_mix.next_64,\n        split_mix.next_32,\n        split_mix.next_double,\n        split_mix.state_address,\n        state_getter=split_mix.state_getter,\n    )\n    assert isinstance(bgf.state, dict)\n    with pytest.raises(NotImplementedError):\n        bgf.state = {""apple""}\n\n    bgf = UserBitGenerator.from_cfunc(\n        split_mix.next_raw,\n        split_mix.next_64,\n        split_mix.next_32,\n        split_mix.next_double,\n        split_mix.state_address,\n        state_setter=split_mix.state_setter,\n    )\n    bgf.state = split_mix.state_getter()\n'"
randomgen/examples/cython/setup.py,3,"b'# python setup.py build_ext -i\nfrom distutils.core import setup\nfrom os.path import join\n\nfrom Cython.Build import cythonize\nimport numpy as np\nfrom setuptools.extension import Extension\n\nextending = Extension(\n    ""extending"", sources=[""extending.pyx""], include_dirs=[np.get_include()]\n)\ndistributions = Extension(\n    ""extending_distributions"",\n    sources=[\n        ""extending_distributions.pyx"",\n        join("".."", "".."", "".."", ""randomgen"", ""src"", ""distributions"", ""distributions.c""),\n    ],\n    include_dirs=[np.get_include()],\n)\nlow_level = Extension(\n    ""low_level"", sources=[""low_level.pyx""], include_dirs=[np.get_include()]\n)\n\nextensions = [extending, distributions, low_level]\n\nsetup(ext_modules=cythonize(extensions))\n'"
randomgen/examples/numba/extending.py,4,"b'import datetime as dt\n\nimport numba as nb\nimport numpy as np\n\nfrom randomgen import Xoroshiro128\n\nx = Xoroshiro128()\nf = x.ctypes.next_uint32\ns = x.ctypes.state\n\n\n@nb.jit(nopython=True)\ndef bounded_uint(lb, ub, state):\n    mask = delta = ub - lb\n    mask |= mask >> 1\n    mask |= mask >> 2\n    mask |= mask >> 4\n    mask |= mask >> 8\n    mask |= mask >> 16\n\n    val = f(state) & mask\n    while val > delta:\n        val = f(state) & mask\n\n    return lb + val\n\n\nprint(bounded_uint(323, 2394691, s.value))\n\n\n@nb.jit(nopython=True)\ndef bounded_uints(lb, ub, n, state):\n    out = np.empty(n, dtype=np.uint32)\n    for i in range(n):\n        out[i] = bounded_uint(lb, ub, state)\n\n\nbounded_uints(323, 2394691, 10000000, s.value)\n\ng = x.cffi.next_double\ncffi_state = x.cffi.state\nstate_addr = x.cffi.state_address\n\n\ndef normals(n, state):\n    out = np.empty(n)\n    for i in range((n + 1) // 2):\n        x1 = 2.0 * g(state) - 1.0\n        x2 = 2.0 * g(state) - 1.0\n        r2 = x1 * x1 + x2 * x2\n        while r2 >= 1.0 or r2 == 0.0:\n            x1 = 2.0 * g(state) - 1.0\n            x2 = 2.0 * g(state) - 1.0\n            r2 = x1 * x1 + x2 * x2\n        f = np.sqrt(-2.0 * np.log(r2) / r2)\n        out[2 * i] = f * x1\n        if 2 * i + 1 < n:\n            out[2 * i + 1] = f * x2\n    return out\n\n\nprint(normals(10, cffi_state).var())\n# Warm up\nnormalsj = nb.jit(normals, nopython=True)\nnormalsj(1, state_addr)\n\nstart = dt.datetime.now()\nnormalsj(1000000, state_addr)\nms = 1000 * (dt.datetime.now() - start).total_seconds()\nprint(\n    ""1,000,000 Polar-transform (numba/Xoroshiro128) randoms in ""\n    ""{ms:0.1f}ms"".format(ms=ms)\n)\n\nstart = dt.datetime.now()\nnp.random.standard_normal(1000000)\nms = 1000 * (dt.datetime.now() - start).total_seconds()\nprint(""1,000,000 Polar-transform (NumPy) randoms in {ms:0.1f}ms"".format(ms=ms))\n'"
randomgen/examples/numba/extending_distributions.py,1,"b'r""""""\nOn *nix, execute in randomgen/src/distributions\n\nexport PYTHON_INCLUDE=#path to Python\'s include folder, usually \\\n    ${PYTHON_HOME}/include/python${PYTHON_VERSION}m\nexport NUMPY_INCLUDE=#path to numpy\'s include folder, usually \\\n    ${PYTHON_HOME}/lib/python${PYTHON_VERSION}/site-packages/numpy/core/include\ngcc -shared -o libdistributions.so -fPIC distributions.c -I${NUMPY_INCLUDE} \\\n    -I${PYTHON_INCLUDE}\nmv libdistributions.so ../../examples/numba/\n\nOn Windows\n\nrem PYTHON_HOME is setup dependent, this is an example\nset PYTHON_HOME=c:\\Anaconda\ncl.exe /LD .\\distributions.c -DDLL_EXPORT \\\n    -I%PYTHON_HOME%\\lib\\site-packages\\numpy\\core\\include \\\n    -I%PYTHON_HOME%\\include %PYTHON_HOME%\\libs\\python36.lib\nmove distributions.dll ../../examples/numba/\n""""""\nimport os\n\nfrom cffi import FFI\nimport numba as nb\nimport numpy as np\n\nfrom randomgen import Xoroshiro128\n\nffi = FFI()\nif os.path.exists(""./distributions.dll""):\n    lib = ffi.dlopen(""./distributions.dll"")\nelif os.path.exists(""./libdistributions.so""):\n    lib = ffi.dlopen(""./libdistributions.so"")\nelse:\n    raise RuntimeError(""Required DLL/so file was not found."")\n\nffi.cdef(\n    """"""\ndouble random_gauss_zig(void *bitgen_state);\n""""""\n)\nx = Xoroshiro128()\nxffi = x.cffi\nbit_generator = xffi.bit_generator\n\nrandom_gauss_zig = lib.random_gauss_zig\n\n\ndef normals(n, bit_generator):\n    out = np.empty(n)\n    for i in range(n):\n        out[i] = random_gauss_zig(bit_generator)\n    return out\n\n\nnormalsj = nb.jit(normals, nopython=True)\n\n# Numba requires a memory address for void *\n# Can also get address from x.ctypes.bit_generator.value\nbit_generator_address = int(ffi.cast(""uintptr_t"", bit_generator))\n\nnorm = normalsj(1000, bit_generator_address)\n'"
randomgen/src/mt19937/generate-jump-test.py,1,"b'""""""\nCompile jump_mt19937.c using\n\ngcc jump_mt19937.c -O2 -o jump\n\nor\n\ncl jump_mt19937.c -Ox\n\nGet the state using NumPy\'s state initialization\n\npoly-128 is the 2**128 poly computed using the original author\'s code\nclist_mt19937 is the polynomial shipped by the original author\n""""""\nimport hashlib\nimport os\nimport platform\nimport pprint\nimport shutil\nimport subprocess\n\nimport black\nimport numpy as np\nfrom numpy.random import MT19937 as NP19937\n\nfrom randomgen import MT19937\n\nSEEDS = [0, 384908324, [839438204, 980239840, 859048019, 821]]\nSTEPS = [10, 312, 511]\n\nif platform.platform() == ""linux"":\n    EXECUTABLE = ""./jump""\nelse:\n    EXECUTABLE = ""./jump_mt19937.exe""\n\n\ndef save_state(bit_gen, file_name):\n    state = bit_gen.state\n    key = state[""state""][""key""]\n    pos = state[""state""][""pos""]\n    with open(file_name, ""w"") as f:\n        for k in key:\n            f.write(f""{k}\\n"")\n        f.write(f""{pos}\\n"")\n\n\ndef parse_output(text):\n    lines = text.split(""\\n"")\n\n    state = {""key"": [], ""pos"": -1}\n    states = [state]\n    pf = []\n    for line in lines:\n        parts = line.split("":"")\n        if ""pf["" in parts[0]:\n            pf.append(int(parts[1].strip()))\n        elif ""["" in parts[0]:\n            state[""key""].append(int(parts[1].strip()))\n        elif "".ptr"" in parts[0]:\n            state[""pos""] = int(parts[1].strip())\n        elif ""====="" in line:\n            state[""key""] = np.asarray(state[""key""], dtype=""uint32"")\n            state = {""key"": [], ""pos"": -1}\n            states.append(state)\n    return states[:-1], pf\n\n\nvalues = {}\nfor poly in (""poly-128"", ""clist_mt19937""):\n    shutil.copy(f""{poly}.txt"", ""jump-poly.txt"")\n    fn = ""_jump_tester"" if poly == ""clist_mt19937"" else ""jumped""\n    for seed, step in zip(SEEDS, STEPS):\n        seed_tpl = (seed,) if isinstance(seed, int) else tuple(seed)\n        key = (fn, seed_tpl, step)\n        values[key] = {}\n        np_mt19937 = NP19937(seed)\n        mt19937 = MT19937(mode=""sequence"")\n        mt19937.state = np_mt19937.state\n        mt19937.random_raw(step)\n        file_name = f""state-{seed}-{step}.csv""\n        save_state(mt19937, file_name=file_name)\n        hash = hashlib.md5(mt19937.state[""state""][""key""])\n        values[key][""initial""] = {\n            ""key_md5"": hash.hexdigest(),\n            ""pos"": mt19937.state[""state""][""pos""],\n        }\n        if os.path.exists(""state.txt""):\n            os.unlink(""state.txt"")\n        shutil.copy(file_name, ""state.txt"")\n        out = subprocess.run(EXECUTABLE, stdout=subprocess.PIPE)\n        parsed, pf = parse_output(out.stdout.decode(""utf8""))\n        hash = hashlib.md5(parsed[-1][""key""])\n        values[key][""jumped""] = {""key_md5"": hash.hexdigest(), ""pos"": parsed[-1][""pos""]}\n        with open(f""out-{fn}-{seed}-{step}.txt"", ""w"") as o:\n            o.write(out.stdout.decode(""utf8"").replace(""\\r\\n"", ""\\n""))\n        if ""128"" in poly:\n            jumped = mt19937.jumped()\n        else:\n            jumped = mt19937._jump_tester()\n        hash = hashlib.md5(jumped.state[""state""][""key""])\n        pos = jumped.state[""state""][""pos""]\n        assert values[key][""jumped""] == {""key_md5"": hash.hexdigest(), ""pos"": pos}\n\ntxt = ""JUMP_TEST_DATA="" + pprint.pformat(values)\nfm = black.FileMode(target_versions=black.PY36_VERSIONS)\nwith open(""jump-test-values.txt"", ""w"") as jt:\n    jt.write(black.format_file_contents(txt, fast=False, mode=fm))\n'"
randomgen/tests/data/__init__.py,0,b''
