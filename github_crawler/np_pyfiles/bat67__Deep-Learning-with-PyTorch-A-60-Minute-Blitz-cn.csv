file_path,api_count,code
Autograd_Automatic_Differentiation/Autograd：自动求导.py,0,"b'#%% [markdown]\n# >\xe5\xae\x8c\xe6\x95\xb4\xe9\xa1\xb9\xe7\x9b\xae\xe5\x9c\xb0\xe5\x9d\x80\xef\xbc\x9ahttps://github.com/bat67/Deep-Learning-with-PyTorch-A-60-Minute-Blitz-cn \xef\xbc\x8c \xe5\x98\xa4\xe5\x98\xa4\xe5\x98\xa4\xe6\xb1\x82star~\xef\xbc\x8c\xe6\x9c\x80\xe6\x96\xb0\xe7\x89\x88\xe4\xb9\x9f\xe4\xbc\x9a\xe9\xa6\x96\xe5\x85\x88\xe6\x9b\xb4\xe6\x96\xb0\xe5\x9c\xa8github\xe4\xb8\x8a,\xe6\x9c\x89\xe8\xaf\xaf\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe6\x8b\x9c\xe6\x89\x98\xe5\xa4\xa7\xe5\xae\xb6\xe6\x8c\x87\xe5\x87\xba~\n#%% [markdown]\n# # Autograd\xef\xbc\x9a\xe8\x87\xaa\xe5\x8a\xa8\xe6\xb1\x82\xe5\xaf\xbc\n#%% [markdown]\n# PyTorch\xe4\xb8\xad\xef\xbc\x8c\xe6\x89\x80\xe6\x9c\x89\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\xa0\xb8\xe5\xbf\x83\xe6\x98\xaf`autograd`\xe5\x8c\x85\xe3\x80\x82\xe5\x85\x88\xe7\xae\x80\xe5\x8d\x95\xe4\xbb\x8b\xe7\xbb\x8d\xe4\xb8\x80\xe4\xb8\x8b\xe8\xbf\x99\xe4\xb8\xaa\xe5\x8c\x85\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe8\xae\xad\xe7\xbb\x83\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe7\x9a\x84\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe3\x80\x82\n# \n# `autograd`\xe5\x8c\x85\xe4\xb8\xba\xe5\xbc\xa0\xe9\x87\x8f\xe4\xb8\x8a\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x93\x8d\xe4\xbd\x9c\xe6\x8f\x90\xe4\xbe\x9b\xe4\xba\x86\xe8\x87\xaa\xe5\x8a\xa8\xe6\xb1\x82\xe5\xaf\xbc\xe6\x9c\xba\xe5\x88\xb6\xe3\x80\x82\xe5\xae\x83\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe5\x9c\xa8\xe8\xbf\x90\xe8\xa1\x8c\xe6\x97\xb6\xe5\xae\x9a\xe4\xb9\x89\xef\xbc\x88define-by-run\xef\xbc\x89\xe7\x9a\x84\xe6\xa1\x86\xe6\x9e\xb6\xef\xbc\x8c\xe8\xbf\x99\xe6\x84\x8f\xe5\x91\xb3\xe7\x9d\x80\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe6\x98\xaf\xe6\xa0\xb9\xe6\x8d\xae\xe4\xbb\xa3\xe7\xa0\x81\xe5\xa6\x82\xe4\xbd\x95\xe8\xbf\x90\xe8\xa1\x8c\xe6\x9d\xa5\xe5\x86\xb3\xe5\xae\x9a\xe7\x9a\x84\xef\xbc\x8c\xe5\xb9\xb6\xe4\xb8\x94\xe6\xaf\x8f\xe6\xac\xa1\xe8\xbf\xad\xe4\xbb\xa3\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x98\xaf\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84.\n# \n# \xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe7\x94\xa8\xe4\xb8\x80\xe4\xba\x9b\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84\xe4\xbe\x8b\xe5\xad\x90\xe6\x9d\xa5\xe7\x9c\x8b\xe7\x9c\x8b\xe5\x90\xa7\xe3\x80\x82\n#%% [markdown]\n# ## 1 \xe5\xbc\xa0\xe9\x87\x8f\n#%% [markdown]\n# `torch.Tensor`\xe6\x98\xaf\xe8\xbf\x99\xe4\xb8\xaa\xe5\x8c\x85\xe7\x9a\x84\xe6\xa0\xb8\xe5\xbf\x83\xe7\xb1\xbb\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe8\xae\xbe\xe7\xbd\xae\xe5\xae\x83\xe7\x9a\x84\xe5\xb1\x9e\xe6\x80\xa7 `.requires_grad`\xe4\xb8\xba`True`\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe5\xae\x83\xe5\xb0\x86\xe4\xbc\x9a\xe8\xbf\xbd\xe8\xb8\xaa\xe5\xaf\xb9\xe4\xba\x8e\xe8\xaf\xa5\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\x93\x8d\xe4\xbd\x9c\xe3\x80\x82\xe5\xbd\x93\xe5\xae\x8c\xe6\x88\x90\xe8\xae\xa1\xe7\xae\x97\xe5\x90\x8e\xe5\x8f\xaf\xe4\xbb\xa5\xe9\x80\x9a\xe8\xbf\x87\xe8\xb0\x83\xe7\x94\xa8`.backward()`\xef\xbc\x8c\xe6\x9d\xa5\xe8\x87\xaa\xe5\x8a\xa8\xe8\xae\xa1\xe7\xae\x97\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xe3\x80\x82\xe8\xbf\x99\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe6\xa2\xaf\xe5\xba\xa6\xe5\xb0\x86\xe4\xbc\x9a\xe8\x87\xaa\xe5\x8a\xa8\xe7\xb4\xaf\xe5\x8a\xa0\xe5\x88\xb0`.grad`\xe5\xb1\x9e\xe6\x80\xa7.\n# \n# \xe8\xa6\x81\xe9\x98\xbb\xe6\xad\xa2\xe4\xb8\x80\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe8\xa2\xab\xe8\xb7\x9f\xe8\xb8\xaa\xe5\x8e\x86\xe5\x8f\xb2\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe8\xb0\x83\xe7\x94\xa8`.detach()`\xe6\x96\xb9\xe6\xb3\x95\xe5\xb0\x86\xe5\x85\xb6\xe4\xb8\x8e\xe8\xae\xa1\xe7\xae\x97\xe5\x8e\x86\xe5\x8f\xb2\xe5\x88\x86\xe7\xa6\xbb\xef\xbc\x8c\xe5\xb9\xb6\xe9\x98\xbb\xe6\xad\xa2\xe5\xae\x83\xe6\x9c\xaa\xe6\x9d\xa5\xe7\x9a\x84\xe8\xae\xa1\xe7\xae\x97\xe8\xae\xb0\xe5\xbd\x95\xe8\xa2\xab\xe8\xb7\x9f\xe8\xb8\xaa\xe3\x80\x82\n# \n# \xe4\xb8\xba\xe4\xba\x86\xe9\x98\xb2\xe6\xad\xa2\xe8\xb7\x9f\xe8\xb8\xaa\xe5\x8e\x86\xe5\x8f\xb2\xe8\xae\xb0\xe5\xbd\x95\xef\xbc\x88\xe5\x92\x8c\xe4\xbd\xbf\xe7\x94\xa8\xe5\x86\x85\xe5\xad\x98\xef\xbc\x89\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xb0\x86\xe4\xbb\xa3\xe7\xa0\x81\xe5\x9d\x97\xe5\x8c\x85\xe8\xa3\x85\xe5\x9c\xa8`with torch.no_grad():`\xe4\xb8\xad\xe3\x80\x82\xe5\x9c\xa8\xe8\xaf\x84\xe4\xbc\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x97\xb6\xe7\x89\xb9\xe5\x88\xab\xe6\x9c\x89\xe7\x94\xa8\xef\xbc\x8c\xe5\x9b\xa0\xe4\xb8\xba\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x8f\xaf\xe8\x83\xbd\xe5\x85\xb7\xe6\x9c\x89`requires_grad = True`\xe7\x9a\x84\xe5\x8f\xaf\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe6\x88\x91\xe4\xbb\xac\xe4\xb8\x8d\xe9\x9c\x80\xe8\xa6\x81\xe5\x9c\xa8\xe6\xad\xa4\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\xaf\xb9\xe4\xbb\x96\xe4\xbb\xac\xe8\xbf\x9b\xe8\xa1\x8c\xe6\xa2\xaf\xe5\xba\xa6\xe8\xae\xa1\xe7\xae\x97\xe3\x80\x82\n# \n# \xe8\xbf\x98\xe6\x9c\x89\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb1\xbb\xe5\xaf\xb9\xe4\xba\x8eautograd\xe7\x9a\x84\xe5\xae\x9e\xe7\x8e\xb0\xe9\x9d\x9e\xe5\xb8\xb8\xe9\x87\x8d\xe8\xa6\x81\xef\xbc\x9a`Function`\xe3\x80\x82\n# \n# `Tensor`\xe5\x92\x8c`Function`\xe4\xba\x92\xe7\x9b\xb8\xe8\xbf\x9e\xe6\x8e\xa5\xe7\x94\x9f\xe6\x88\x90\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe9\x9d\x9e\xe5\xbe\xaa\xe7\x8e\xaf\xe5\x9b\xbe\xef\xbc\x8c\xe5\xae\x83\xe7\xbc\x96\xe7\xa0\x81\xe4\xba\x86\xe5\xae\x8c\xe6\x95\xb4\xe7\x9a\x84\xe8\xae\xa1\xe7\xae\x97\xe5\x8e\x86\xe5\x8f\xb2\xe3\x80\x82\xe6\xaf\x8f\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe9\x83\xbd\xe6\x9c\x89\xe4\xb8\x80\xe4\xb8\xaa`.grad_fn`\xe5\xb1\x9e\xe6\x80\xa7\xef\xbc\x8c\xe5\xae\x83\xe5\xbc\x95\xe7\x94\xa8\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe5\x88\x9b\xe5\xbb\xba\xe4\xba\x86\xe8\xbf\x99\xe4\xb8\xaa`Tensor`\xe7\x9a\x84`Function`\xef\xbc\x88\xe9\x99\xa4\xe9\x9d\x9e\xe8\xbf\x99\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe6\x98\xaf\xe7\x94\xa8\xe6\x88\xb7\xe6\x89\x8b\xe5\x8a\xa8\xe5\x88\x9b\xe5\xbb\xba\xe7\x9a\x84\xef\xbc\x8c\xe5\x8d\xb3\xe8\xbf\x99\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84`grad_fn`\xe6\x98\xaf`None`\xef\xbc\x89\xe3\x80\x82\n# \n# \xe5\xa6\x82\xe6\x9e\x9c\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xa1\xe7\xae\x97\xe5\xaf\xbc\xe6\x95\xb0\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8`Tensor`\xe4\xb8\x8a\xe8\xb0\x83\xe7\x94\xa8`.backward()`\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c`Tensor`\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa0\x87\xe9\x87\x8f\xef\xbc\x88\xe5\x8d\xb3\xe5\xae\x83\xe5\x8c\x85\xe5\x90\xab\xe4\xb8\x80\xe4\xb8\xaa\xe5\x85\x83\xe7\xb4\xa0\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x89\xef\xbc\x8c\xe5\x88\x99\xe4\xb8\x8d\xe9\x9c\x80\xe8\xa6\x81\xe4\xb8\xba`backward()`\xe6\x8c\x87\xe5\xae\x9a\xe4\xbb\xbb\xe4\xbd\x95\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe5\xa6\x82\xe6\x9e\x9c\xe5\xae\x83\xe6\x9c\x89\xe6\x9b\xb4\xe5\xa4\x9a\xe7\x9a\x84\xe5\x85\x83\xe7\xb4\xa0\xef\xbc\x8c\xe5\x88\x99\xe9\x9c\x80\xe8\xa6\x81\xe6\x8c\x87\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaa`gradient`\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe5\xae\x83\xe6\x98\xaf\xe5\xbd\xa2\xe7\x8a\xb6\xe5\x8c\xb9\xe9\x85\x8d\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe3\x80\x82\n# \n\n#%%\nimport torch\n\n#%% [markdown]\n# \xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe5\xb9\xb6\xe8\xae\xbe\xe7\xbd\xae`requires_grad=True`\xe7\x94\xa8\xe6\x9d\xa5\xe8\xbf\xbd\xe8\xb8\xaa\xe5\x85\xb6\xe8\xae\xa1\xe7\xae\x97\xe5\x8e\x86\xe5\x8f\xb2\n\n#%%\nx = torch.ones(2, 2, requires_grad=True)\nprint(x)\n\n#%% [markdown]\n# \xe5\xaf\xb9\xe8\xbf\x99\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe5\x81\x9a\xe4\xb8\x80\xe6\xac\xa1\xe8\xbf\x90\xe7\xae\x97\xef\xbc\x9a\n\n#%%\ny = x + 2\nprint(y)\n\n#%% [markdown]\n# `y`\xe6\x98\xaf\xe8\xae\xa1\xe7\xae\x97\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe5\xae\x83\xe6\x9c\x89`grad_fn`\xe5\xb1\x9e\xe6\x80\xa7\xe3\x80\x82\n\n#%%\nprint(y.grad_fn)\n\n#%% [markdown]\n# \xe5\xaf\xb9y\xe8\xbf\x9b\xe8\xa1\x8c\xe6\x9b\xb4\xe5\xa4\x9a\xe6\x93\x8d\xe4\xbd\x9c\n\n#%%\nz = y * y * 3\nout = z.mean()\n\nprint(z, out)\n\n#%% [markdown]\n# `.requires_grad_(...)` \xe5\x8e\x9f\xe5\x9c\xb0\xe6\x94\xb9\xe5\x8f\x98\xe4\xba\x86\xe7\x8e\xb0\xe6\x9c\x89\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84 `requires_grad` \xe6\xa0\x87\xe5\xbf\x97\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe6\xb2\xa1\xe6\x9c\x89\xe6\x8c\x87\xe5\xae\x9a\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe9\xbb\x98\xe8\xae\xa4\xe8\xbe\x93\xe5\x85\xa5\xe7\x9a\x84\xe8\xbf\x99\xe4\xb8\xaa\xe6\xa0\x87\xe5\xbf\x97\xe6\x98\xaf`False`\xe3\x80\x82\n\n#%%\na = torch.randn(2, 2)\na = ((a * 3) / (a - 1))\nprint(a.requires_grad)\na.requires_grad_(True)\nprint(a.requires_grad)\nb = (a * a).sum()\nprint(b.grad_fn)\n\n#%% [markdown]\n# ## 2 \xe6\xa2\xaf\xe5\xba\xa6\n#%% [markdown]\n# \xe5\x9b\xa0\xe4\xb8\xba`out`\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa0\x87\xe9\x87\x8f\xe3\x80\x82\xe6\x89\x80\xe4\xbb\xa5\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe7\x9b\xb4\xe6\x8e\xa5\xe8\xbf\x9b\xe8\xa1\x8c\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xef\xbc\x8c`out.backward()`\xe5\x92\x8c`out.backward(torch.tensor(1.))`\xe7\xad\x89\xe4\xbb\xb7\n\n#%%\nout.backward()\n\n#%% [markdown]\n# \xe8\xbe\x93\xe5\x87\xba\xe5\xaf\xbc\xe6\x95\xb0`d(out)/dx`\n\n#%%\nprint(x.grad)\n\n#%% [markdown]\n# \xe5\xbe\x97\xe5\x88\xb0\xe9\x83\xbd\xe6\x98\xaf`4.5`\xe7\x9a\x84\xe7\x9f\xa9\xe9\x98\xb5\xe3\x80\x82\xe8\xb0\x83\xe7\x94\xa8`out`\xe5\xbc\xa0\xe9\x87\x8f $\xe2\x80\x9co\xe2\x80\x9d$\xe3\x80\x82\n# \n# \xe5\xbe\x97\xe5\x88\xb0 \n# \n# $$o = \\frac{1}{4}\\sum_i z_i$$\n# \n# $$z_i = 3(x_i+2)^2$$\n# \n# \xe5\x92\x8c\n# \n# $$z_i\\bigr\\rvert_{x_i=1} = 27$$\n# \n# \xe5\x9b\xa0\xe6\xad\xa4,\n# \n# $$\\frac{\\partial o}{\\partial x_i} = \\frac{3}{2}(x_i+2)$$\n# \n# \xe6\x89\x80\xe4\xbb\xa5\xef\xbc\x8c\n# \n# $$\\frac{\\partial o}{\\partial x_i}\\bigr\\rvert_{x_i=1} = \\frac{9}{2} = 4.5$$\n# \n# \xe6\x95\xb0\xe5\xad\xa6\xe4\xb8\x8a\xef\xbc\x8c\xe8\x8b\xa5\xe6\x9c\x89\xe5\x90\x91\xe9\x87\x8f\xe5\x80\xbc\xe5\x87\xbd\xe6\x95\xb0 $\\vec{y}=f(\\vec{x})$\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88 $\\vec{y}$ \xe7\x9b\xb8\xe5\xaf\xb9\xe4\xba\x8e $\\vec{x}$ \xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x9a\n# \n# $$\n# J=\\left(\\begin{array}{ccc}\n#    \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{1}}\\\\\n#    \\vdots & \\ddots & \\vdots\\\\\n#    \\frac{\\partial y_{1}}{\\partial x_{n}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n#    \\end{array}\\right)\n# $$\n# \n# \xe9\x80\x9a\xe5\xb8\xb8\xe6\x9d\xa5\xe8\xaf\xb4\xef\xbc\x8c`torch.autograd` \xe6\x98\xaf\xe8\xae\xa1\xe7\xae\x97\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe5\x90\x91\xe9\x87\x8f\xe7\xa7\xaf\xe7\x9a\x84\xe4\xb8\x80\xe4\xb8\xaa\xe2\x80\x9c\xe5\xbc\x95\xe6\x93\x8e\xe2\x80\x9d\xe3\x80\x82\xe4\xb9\x9f\xe5\xb0\xb1\xe6\x98\xaf\xe8\xaf\xb4\xef\xbc\x8c\xe7\xbb\x99\xe5\xae\x9a\xe4\xbb\xbb\xe6\x84\x8f\xe5\x90\x91\xe9\x87\x8f $v=\\left(\\begin{array}{cccc} v_{1} & v_{2} & \\cdots & v_{m}\\end{array}\\right)^{T}$\xef\xbc\x8c\xe8\xae\xa1\xe7\xae\x97\xe4\xb9\x98\xe7\xa7\xaf $J\\cdot v$\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c $v$ \xe6\x81\xb0\xe5\xa5\xbd\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa0\x87\xe9\x87\x8f\xe5\x87\xbd\xe6\x95\xb0 $l=g\\left(\\vec{y}\\right)$ \xe7\x9a\x84\xe5\xaf\xbc\xe6\x95\xb0\xef\xbc\x8c\xe5\x8d\xb3 $v=\\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial y_{1}} & \\cdots & \\frac{\\partial l}{\\partial y_{m}}\\end{array}\\right)^{T}$\xef\xbc\x8c\xe9\x82\xa3\xe4\xb9\x88\xe6\xa0\xb9\xe6\x8d\xae\xe9\x93\xbe\xe5\xbc\x8f\xe6\xb3\x95\xe5\x88\x99\xef\xbc\x8c\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe5\x90\x91\xe9\x87\x8f\xe7\xa7\xaf\xe5\xba\x94\xe8\xaf\xa5\xe6\x98\xaf $l$ \xe5\xaf\xb9 $\\vec{x}$ \xe7\x9a\x84\xe5\xaf\xbc\xe6\x95\xb0\xef\xbc\x9a\n# \n# $$\n# J\\cdot v=\\left(\\begin{array}{ccc}\n#    \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{1}}\\\\\n#    \\vdots & \\ddots & \\vdots\\\\\n#    \\frac{\\partial y_{1}}{\\partial x_{n}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n#    \\end{array}\\right)\\left(\\begin{array}{c}\n#    \\frac{\\partial l}{\\partial y_{1}}\\\\\n#    \\vdots\\\\\n#    \\frac{\\partial l}{\\partial y_{m}}\n#    \\end{array}\\right)=\\left(\\begin{array}{c}\n#    \\frac{\\partial l}{\\partial x_{1}}\\\\\n#    \\vdots\\\\\n#    \\frac{\\partial l}{\\partial x_{n}}\n#    \\end{array}\\right)\n# $$\n# \n# \xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe5\x90\x91\xe9\x87\x8f\xe7\xa7\xaf\xe7\x9a\x84\xe8\xbf\x99\xe4\xb8\x80\xe7\x89\xb9\xe6\x80\xa7\xe4\xbd\xbf\xe5\xbe\x97\xe5\xb0\x86\xe5\xa4\x96\xe9\x83\xa8\xe6\xa2\xaf\xe5\xba\xa6\xe8\xbe\x93\xe5\x85\xa5\xe5\x88\xb0\xe5\x85\xb7\xe6\x9c\x89\xe9\x9d\x9e\xe6\xa0\x87\xe9\x87\x8f\xe8\xbe\x93\xe5\x87\xba\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\xad\xe5\x8f\x98\xe5\xbe\x97\xe9\x9d\x9e\xe5\xb8\xb8\xe6\x96\xb9\xe4\xbe\xbf\xe3\x80\x82\n# \n# \xe7\x8e\xb0\xe5\x9c\xa8\xe6\x88\x91\xe4\xbb\xac\xe6\x9d\xa5\xe7\x9c\x8b\xe4\xb8\x80\xe4\xb8\xaa\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe5\x90\x91\xe9\x87\x8f\xe7\xa7\xaf\xe7\x9a\x84\xe4\xbe\x8b\xe5\xad\x90:\n\n#%%\nx = torch.randn(3, requires_grad=True)\n\ny = x * 2\nwhile y.data.norm() < 1000:\n    y = y * 2\n\nprint(y)\n\n#%% [markdown]\n# \xe5\x9c\xa8\xe8\xbf\x99\xe7\xa7\x8d\xe6\x83\x85\xe5\x86\xb5\xe4\xb8\x8b\xef\xbc\x8c`y`\xe4\xb8\x8d\xe5\x86\x8d\xe6\x98\xaf\xe6\xa0\x87\xe9\x87\x8f\xe3\x80\x82`torch.autograd`\xe4\xb8\x8d\xe8\x83\xbd\xe7\x9b\xb4\xe6\x8e\xa5\xe8\xae\xa1\xe7\xae\x97\xe5\xae\x8c\xe6\x95\xb4\xe7\x9a\x84\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe5\xa6\x82\xe6\x9e\x9c\xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaa\xe6\x83\xb3\xe8\xa6\x81\xe9\x9b\x85\xe5\x8f\xaf\xe6\xaf\x94\xe5\x90\x91\xe9\x87\x8f\xe7\xa7\xaf\xef\xbc\x8c\xe5\x8f\xaa\xe9\x9c\x80\xe5\xb0\x86\xe8\xbf\x99\xe4\xb8\xaa\xe5\x90\x91\xe9\x87\x8f\xe4\xbd\x9c\xe4\xb8\xba\xe5\x8f\x82\xe6\x95\xb0\xe4\xbc\xa0\xe7\xbb\x99`backward`\xef\xbc\x9a\n\n#%%\nv = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)\ny.backward(v)\n\nprint(x.grad)\n\n#%% [markdown]\n# \xe4\xb8\xba\xe4\xba\x86\xe9\x98\xb2\xe6\xad\xa2\xe8\xb7\x9f\xe8\xb8\xaa\xe5\x8e\x86\xe5\x8f\xb2\xe8\xae\xb0\xe5\xbd\x95\xef\xbc\x88\xe5\x92\x8c\xe4\xbd\xbf\xe7\x94\xa8\xe5\x86\x85\xe5\xad\x98\xef\xbc\x89\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xb0\x86\xe4\xbb\xa3\xe7\xa0\x81\xe5\x9d\x97\xe5\x8c\x85\xe8\xa3\x85\xe5\x9c\xa8`with torch.no_grad():`\xe4\xb8\xad\xe3\x80\x82\xe5\x9c\xa8\xe8\xaf\x84\xe4\xbc\xb0\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x97\xb6\xe7\x89\xb9\xe5\x88\xab\xe6\x9c\x89\xe7\x94\xa8\xef\xbc\x8c\xe5\x9b\xa0\xe4\xb8\xba\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x8f\xaf\xe8\x83\xbd\xe5\x85\xb7\xe6\x9c\x89`requires_grad = True`\xe7\x9a\x84\xe5\x8f\xaf\xe8\xae\xad\xe7\xbb\x83\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe6\x88\x91\xe4\xbb\xac\xe4\xb8\x8d\xe9\x9c\x80\xe8\xa6\x81\xe5\x9c\xa8\xe6\xad\xa4\xe8\xbf\x87\xe7\xa8\x8b\xe4\xb8\xad\xe5\xaf\xb9\xe4\xbb\x96\xe4\xbb\xac\xe8\xbf\x9b\xe8\xa1\x8c\xe6\xa2\xaf\xe5\xba\xa6\xe8\xae\xa1\xe7\xae\x97\xe3\x80\x82\n# \n# \xe4\xb9\x9f\xe5\x8f\xaf\xe4\xbb\xa5\xe9\x80\x9a\xe8\xbf\x87\xe5\xb0\x86\xe4\xbb\xa3\xe7\xa0\x81\xe5\x9d\x97\xe5\x8c\x85\xe8\xa3\x85\xe5\x9c\xa8 `with torch.no_grad():` \xe4\xb8\xad\xef\xbc\x8c\xe6\x9d\xa5\xe9\x98\xbb\xe6\xad\xa2autograd\xe8\xb7\x9f\xe8\xb8\xaa\xe8\xae\xbe\xe7\xbd\xae\xe4\xba\x86 `.requires_grad=True` \xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe5\x8e\x86\xe5\x8f\xb2\xe8\xae\xb0\xe5\xbd\x95\xe3\x80\x82\n\n#%%\nprint(x.requires_grad)\nprint((x ** 2).requires_grad)\n\nwith torch.no_grad():\n    print((x ** 2).requires_grad)\n\n#%% [markdown]\n# >\xe5\x90\x8e\xe7\xbb\xad\xe9\x98\x85\xe8\xaf\xbb\xef\xbc\x9a\n# >\n# >`autograd`\xe5\x92\x8c`Function`\xe7\x9a\x84\xe6\x96\x87\xe6\xa1\xa3\xe8\xa7\x81\xef\xbc\x9ahttps://pytorch.org/docs/autograd\n\n#%%\n\n\n\n'"
Autograd_Automatic_Differentiation/autograd_tutorial.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nAutograd: Automatic Differentiation\n===================================\n\nCentral to all neural networks in PyTorch is the ``autograd`` package.\nLet\xe2\x80\x99s first briefly visit this, and we will then go to training our\nfirst neural network.\n\n\nThe ``autograd`` package provides automatic differentiation for all operations\non Tensors. It is a define-by-run framework, which means that your backprop is\ndefined by how your code is run, and that every single iteration can be\ndifferent.\n\nLet us see this in more simple terms with some examples.\n\nTensor\n--------\n\n``torch.Tensor`` is the central class of the package. If you set its attribute\n``.requires_grad`` as ``True``, it starts to track all operations on it. When\nyou finish your computation you can call ``.backward()`` and have all the\ngradients computed automatically. The gradient for this tensor will be\naccumulated into ``.grad`` attribute.\n\nTo stop a tensor from tracking history, you can call ``.detach()`` to detach\nit from the computation history, and to prevent future computation from being\ntracked.\n\nTo prevent tracking history (and using memory), you can also wrap the code block\nin ``with torch.no_grad():``. This can be particularly helpful when evaluating a\nmodel because the model may have trainable parameters with `requires_grad=True`,\nbut for which we don\'t need the gradients.\n\nThere\xe2\x80\x99s one more class which is very important for autograd\nimplementation - a ``Function``.\n\n``Tensor`` and ``Function`` are interconnected and build up an acyclic\ngraph, that encodes a complete history of computation. Each tensor has\na ``.grad_fn`` attribute that references a ``Function`` that has created\nthe ``Tensor`` (except for Tensors created by the user - their\n``grad_fn is None``).\n\nIf you want to compute the derivatives, you can call ``.backward()`` on\na ``Tensor``. If ``Tensor`` is a scalar (i.e. it holds a one element\ndata), you don\xe2\x80\x99t need to specify any arguments to ``backward()``,\nhowever if it has more elements, you need to specify a ``gradient``\nargument that is a tensor of matching shape.\n""""""\n\nimport torch\n\n###############################################################\n# Create a tensor and set requires_grad=True to track computation with it\nx = torch.ones(2, 2, requires_grad=True)\nprint(x)\n\n###############################################################\n# Do an operation of tensor:\ny = x + 2\nprint(y)\n\n###############################################################\n# ``y`` was created as a result of an operation, so it has a ``grad_fn``.\nprint(y.grad_fn)\n\n###############################################################\n# Do more operations on y\nz = y * y * 3\nout = z.mean()\n\nprint(z, out)\n\n################################################################\n# ``.requires_grad_( ... )`` changes an existing Tensor\'s ``requires_grad``\n# flag in-place. The input flag defaults to ``False`` if not given.\na = torch.randn(2, 2)\na = ((a * 3) / (a - 1))\nprint(a.requires_grad)\na.requires_grad_(True)\nprint(a.requires_grad)\nb = (a * a).sum()\nprint(b.grad_fn)\n\n###############################################################\n# Gradients\n# ---------\n# Let\'s backprop now\n# Because ``out`` contains a single scalar, ``out.backward()`` is\n# equivalent to ``out.backward(torch.tensor(1.))``.\n\nout.backward()\n\n###############################################################\n# print gradients d(out)/dx\n#\n\nprint(x.grad)\n\n###############################################################\n# You should have got a matrix of ``4.5``. Let\xe2\x80\x99s call the ``out``\n# *Tensor* \xe2\x80\x9c:math:`o`\xe2\x80\x9d.\n# We have that :math:`o = \\frac{1}{4}\\sum_i z_i`,\n# :math:`z_i = 3(x_i+2)^2` and :math:`z_i\\bigr\\rvert_{x_i=1} = 27`.\n# Therefore,\n# :math:`\\frac{\\partial o}{\\partial x_i} = \\frac{3}{2}(x_i+2)`, hence\n# :math:`\\frac{\\partial o}{\\partial x_i}\\bigr\\rvert_{x_i=1} = \\frac{9}{2} = 4.5`.\n\n###############################################################\n# Mathematically, if you have a vector valued function :math:`\\vec{y}=f(\\vec{x})`,\n# then the gradient of :math:`\\vec{y}` with respect to :math:`\\vec{x}`\n# is a Jacobian matrix:\n#\n# .. math::\n#   J=\\left(\\begin{array}{ccc}\n#    \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{1}}\\\\\n#    \\vdots & \\ddots & \\vdots\\\\\n#    \\frac{\\partial y_{1}}{\\partial x_{n}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n#    \\end{array}\\right)\n#\n# Generally speaking, ``torch.autograd`` is an engine for computing\n# Jacobian-vector product. That is, given any vector\n# :math:`v=\\left(\\begin{array}{cccc} v_{1} & v_{2} & \\cdots & v_{m}\\end{array}\\right)^{T}`,\n# compute the product :math:`J\\cdot v`. If :math:`v` happens to be\n# the gradient of a scalar function :math:`l=g\\left(\\vec{y}\\right)`,\n# that is,\n# :math:`v=\\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial y_{1}} & \\cdots & \\frac{\\partial l}{\\partial y_{m}}\\end{array}\\right)^{T}`,\n# then by the chain rule, the Jacobian-vector product would be the\n# gradient of :math:`l` with respect to :math:`\\vec{x}`:\n#\n# .. math::\n#   J\\cdot v=\\left(\\begin{array}{ccc}\n#    \\frac{\\partial y_{1}}{\\partial x_{1}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{1}}\\\\\n#    \\vdots & \\ddots & \\vdots\\\\\n#    \\frac{\\partial y_{1}}{\\partial x_{n}} & \\cdots & \\frac{\\partial y_{m}}{\\partial x_{n}}\n#    \\end{array}\\right)\\left(\\begin{array}{c}\n#    \\frac{\\partial l}{\\partial y_{1}}\\\\\n#    \\vdots\\\\\n#    \\frac{\\partial l}{\\partial y_{m}}\n#    \\end{array}\\right)=\\left(\\begin{array}{c}\n#    \\frac{\\partial l}{\\partial x_{1}}\\\\\n#    \\vdots\\\\\n#    \\frac{\\partial l}{\\partial x_{n}}\n#    \\end{array}\\right)\n#\n# This characteristic of Jacobian-vector product makes it very\n# convenient to feed external gradients into a model that has\n# non-scalar output.\n\n###############################################################\n# Now let\'s take a look at an example of Jacobian-vector product:\n\nx = torch.randn(3, requires_grad=True)\n\ny = x * 2\nwhile y.data.norm() < 1000:\n    y = y * 2\n\nprint(y)\n\n###############################################################\n# Now in this case ``y`` is no longer a scalar. ``torch.autograd``\n# could not compute the full Jacobian directly, but if we just\n# want the Jacobian-vector product, simply pass the vector to\n# ``backward`` as argument:\nv = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)\ny.backward(v)\n\nprint(x.grad)\n\n###############################################################\n# You can also stop autograd from tracking history on Tensors\n# with ``.requires_grad=True`` by wrapping the code block in\n# ``with torch.no_grad()``:\nprint(x.requires_grad)\nprint((x ** 2).requires_grad)\n\nwith torch.no_grad():\n\tprint((x ** 2).requires_grad)\n\n###############################################################\n# **Read Later:**\n#\n# Documentation of ``autograd`` and ``Function`` is at\n# https://pytorch.org/docs/autograd\n'"
Neural_Networks/neural_networks_tutorial.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nNeural Networks\n===============\n\nNeural networks can be constructed using the ``torch.nn`` package.\n\nNow that you had a glimpse of ``autograd``, ``nn`` depends on\n``autograd`` to define models and differentiate them.\nAn ``nn.Module`` contains layers, and a method ``forward(input)``\\ that\nreturns the ``output``.\n\nFor example, look at this network that classifies digit images:\n\n.. figure:: /_static/img/mnist.png\n   :alt: convnet\n\n   convnet\n\nIt is a simple feed-forward network. It takes the input, feeds it\nthrough several layers one after the other, and then finally gives the\noutput.\n\nA typical training procedure for a neural network is as follows:\n\n- Define the neural network that has some learnable parameters (or\n  weights)\n- Iterate over a dataset of inputs\n- Process input through the network\n- Compute the loss (how far is the output from being correct)\n- Propagate gradients back into the network\xe2\x80\x99s parameters\n- Update the weights of the network, typically using a simple update rule:\n  ``weight = weight - learning_rate * gradient``\n\nDefine the network\n------------------\n\nLet\xe2\x80\x99s define this network:\n""""""\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        # 1 input image channel, 6 output channels, 5x5 square convolution\n        # kernel\n        self.conv1 = nn.Conv2d(1, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        # an affine operation: y = Wx + b\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        # Max pooling over a (2, 2) window\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))\n        # If the size is a square you can only specify a single number\n        x = F.max_pool2d(F.relu(self.conv2(x)), 2)\n        x = x.view(-1, self.num_flat_features(x))\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n    def num_flat_features(self, x):\n        size = x.size()[1:]  # all dimensions except the batch dimension\n        num_features = 1\n        for s in size:\n            num_features *= s\n        return num_features\n\n\nnet = Net()\nprint(net)\n\n########################################################################\n# You just have to define the ``forward`` function, and the ``backward``\n# function (where gradients are computed) is automatically defined for you\n# using ``autograd``.\n# You can use any of the Tensor operations in the ``forward`` function.\n#\n# The learnable parameters of a model are returned by ``net.parameters()``\n\nparams = list(net.parameters())\nprint(len(params))\nprint(params[0].size())  # conv1\'s .weight\n\n########################################################################\n# Let try a random 32x32 input\n# Note: Expected input size to this net(LeNet) is 32x32. To use this net on\n# MNIST dataset, please resize the images from the dataset to 32x32.\n\ninput = torch.randn(1, 1, 32, 32)\nout = net(input)\nprint(out)\n\n########################################################################\n# Zero the gradient buffers of all parameters and backprops with random\n# gradients:\nnet.zero_grad()\nout.backward(torch.randn(1, 10))\n\n########################################################################\n# .. note::\n#\n#     ``torch.nn`` only supports mini-batches. The entire ``torch.nn``\n#     package only supports inputs that are a mini-batch of samples, and not\n#     a single sample.\n#\n#     For example, ``nn.Conv2d`` will take in a 4D Tensor of\n#     ``nSamples x nChannels x Height x Width``.\n#\n#     If you have a single sample, just use ``input.unsqueeze(0)`` to add\n#     a fake batch dimension.\n#\n# Before proceeding further, let\'s recap all the classes you\xe2\x80\x99ve seen so far.\n#\n# **Recap:**\n#   -  ``torch.Tensor`` - A *multi-dimensional array* with support for autograd\n#      operations like ``backward()``. Also *holds the gradient* w.r.t. the\n#      tensor.\n#   -  ``nn.Module`` - Neural network module. *Convenient way of\n#      encapsulating parameters*, with helpers for moving them to GPU,\n#      exporting, loading, etc.\n#   -  ``nn.Parameter`` - A kind of Tensor, that is *automatically\n#      registered as a parameter when assigned as an attribute to a*\n#      ``Module``.\n#   -  ``autograd.Function`` - Implements *forward and backward definitions\n#      of an autograd operation*. Every ``Tensor`` operation, creates at\n#      least a single ``Function`` node, that connects to functions that\n#      created a ``Tensor`` and *encodes its history*.\n#\n# **At this point, we covered:**\n#   -  Defining a neural network\n#   -  Processing inputs and calling backward\n#\n# **Still Left:**\n#   -  Computing the loss\n#   -  Updating the weights of the network\n#\n# Loss Function\n# -------------\n# A loss function takes the (output, target) pair of inputs, and computes a\n# value that estimates how far away the output is from the target.\n#\n# There are several different\n# `loss functions <https://pytorch.org/docs/nn.html#loss-functions>`_ under the\n# nn package .\n# A simple loss is: ``nn.MSELoss`` which computes the mean-squared error\n# between the input and the target.\n#\n# For example:\n\noutput = net(input)\ntarget = torch.randn(10)  # a dummy target, for example\ntarget = target.view(1, -1)  # make it the same shape as output\ncriterion = nn.MSELoss()\n\nloss = criterion(output, target)\nprint(loss)\n\n########################################################################\n# Now, if you follow ``loss`` in the backward direction, using its\n# ``.grad_fn`` attribute, you will see a graph of computations that looks\n# like this:\n#\n# ::\n#\n#     input -> conv2d -> relu -> maxpool2d -> conv2d -> relu -> maxpool2d\n#           -> view -> linear -> relu -> linear -> relu -> linear\n#           -> MSELoss\n#           -> loss\n#\n# So, when we call ``loss.backward()``, the whole graph is differentiated\n# w.r.t. the loss, and all Tensors in the graph that has ``requires_grad=True``\n# will have their ``.grad`` Tensor accumulated with the gradient.\n#\n# For illustration, let us follow a few steps backward:\n\nprint(loss.grad_fn)  # MSELoss\nprint(loss.grad_fn.next_functions[0][0])  # Linear\nprint(loss.grad_fn.next_functions[0][0].next_functions[0][0])  # ReLU\n\n########################################################################\n# Backprop\n# --------\n# To backpropagate the error all we have to do is to ``loss.backward()``.\n# You need to clear the existing gradients though, else gradients will be\n# accumulated to existing gradients.\n#\n#\n# Now we shall call ``loss.backward()``, and have a look at conv1\'s bias\n# gradients before and after the backward.\n\n\nnet.zero_grad()     # zeroes the gradient buffers of all parameters\n\nprint(\'conv1.bias.grad before backward\')\nprint(net.conv1.bias.grad)\n\nloss.backward()\n\nprint(\'conv1.bias.grad after backward\')\nprint(net.conv1.bias.grad)\n\n########################################################################\n# Now, we have seen how to use loss functions.\n#\n# **Read Later:**\n#\n#   The neural network package contains various modules and loss functions\n#   that form the building blocks of deep neural networks. A full list with\n#   documentation is `here <https://pytorch.org/docs/nn>`_.\n#\n# **The only thing left to learn is:**\n#\n#   - Updating the weights of the network\n#\n# Update the weights\n# ------------------\n# The simplest update rule used in practice is the Stochastic Gradient\n# Descent (SGD):\n#\n#      ``weight = weight - learning_rate * gradient``\n#\n# We can implement this using simple python code:\n#\n# .. code:: python\n#\n#     learning_rate = 0.01\n#     for f in net.parameters():\n#         f.data.sub_(f.grad.data * learning_rate)\n#\n# However, as you use neural networks, you want to use various different\n# update rules such as SGD, Nesterov-SGD, Adam, RMSProp, etc.\n# To enable this, we built a small package: ``torch.optim`` that\n# implements all these methods. Using it is very simple:\n\nimport torch.optim as optim\n\n# create your optimizer\noptimizer = optim.SGD(net.parameters(), lr=0.01)\n\n# in your training loop:\noptimizer.zero_grad()   # zero the gradient buffers\noutput = net(input)\nloss = criterion(output, target)\nloss.backward()\noptimizer.step()    # Does the update\n\n\n###############################################################\n# .. Note::\n#\n#       Observe how gradient buffers had to be manually set to zero using\n#       ``optimizer.zero_grad()``. This is because gradients are accumulated\n#       as explained in `Backprop`_ section.\n'"
Neural_Networks/神经网络.py,0,"b""#%% [markdown]\n# # \xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# \xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8`torch.nn`\xe5\x8c\x85\xe6\x9d\xa5\xe6\x9e\x84\xe5\xbb\xba\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c.\n# \n# \xe6\x88\x91\xe4\xbb\xac\xe4\xbb\xa5\xe5\x8f\x8a\xe4\xbb\x8b\xe7\xbb\x8d\xe4\xba\x86`autograd`\xef\xbc\x8c`nn`\xe5\x8c\x85\xe4\xbe\x9d\xe8\xb5\x96\xe4\xba\x8e`autograd`\xe5\x8c\x85\xe6\x9d\xa5\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\xe5\xb9\xb6\xe5\xaf\xb9\xe5\xae\x83\xe4\xbb\xac\xe6\xb1\x82\xe5\xaf\xbc\xe3\x80\x82\xe4\xb8\x80\xe4\xb8\xaa`nn.Module`\xe5\x8c\x85\xe5\x90\xab\xe5\x90\x84\xe4\xb8\xaa\xe5\xb1\x82\xe5\x92\x8c\xe4\xb8\x80\xe4\xb8\xaa`forward(input)`\xe6\x96\xb9\xe6\xb3\x95\xef\xbc\x8c\xe8\xaf\xa5\xe6\x96\xb9\xe6\xb3\x95\xe8\xbf\x94\xe5\x9b\x9e`output`\xe3\x80\x82\n# \n# \xe4\xbe\x8b\xe5\xa6\x82\xef\xbc\x8c\xe4\xb8\x8b\xe9\x9d\xa2\xe8\xbf\x99\xe4\xb8\xaa\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xaf\xb9\xe6\x95\xb0\xe5\xad\x97\xe8\xbf\x9b\xe8\xa1\x8c\xe5\x88\x86\xe7\xb1\xbb\xef\xbc\x9a\n# \n# ![](assets/mnist.png)\n# \n# \xe8\xbf\x99\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84\xe5\x89\x8d\xe9\xa6\x88\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x88feed-forward network\xef\xbc\x89\xe3\x80\x82\xe5\xae\x83\xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\x80\xe4\xb8\xaa\xe8\xbe\x93\xe5\x85\xa5\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe5\xb0\x86\xe5\xae\x83\xe9\x80\x81\xe5\x85\xa5\xe4\xb8\x8b\xe4\xb8\x80\xe5\xb1\x82\xef\xbc\x8c\xe4\xb8\x80\xe5\xb1\x82\xe6\x8e\xa5\xe4\xb8\x80\xe5\xb1\x82\xe7\x9a\x84\xe4\xbc\xa0\xe9\x80\x92\xef\xbc\x8c\xe6\x9c\x80\xe5\x90\x8e\xe7\xbb\x99\xe5\x87\xba\xe8\xbe\x93\xe5\x87\xba\xe3\x80\x82\n# \n# \xe4\xb8\x80\xe4\xb8\xaa\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe5\x85\xb8\xe5\x9e\x8b\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x87\xe7\xa8\x8b\xe5\xa6\x82\xe4\xb8\x8b\xef\xbc\x9a\n# \n# * \xe5\xae\x9a\xe4\xb9\x89\xe5\x8c\x85\xe5\x90\xab\xe4\xb8\x80\xe4\xba\x9b\xe5\x8f\xaf\xe5\xad\xa6\xe4\xb9\xa0\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x88\xe6\x88\x96\xe8\x80\x85\xe5\x8f\xab\xe6\x9d\x83\xe9\x87\x8d\xef\xbc\x89\xe7\x9a\x84\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n# * \xe5\x9c\xa8\xe8\xbe\x93\xe5\x85\xa5\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe4\xb8\x8a\xe8\xbf\xad\xe4\xbb\xa3\n# * \xe9\x80\x9a\xe8\xbf\x87\xe7\xbd\x91\xe7\xbb\x9c\xe5\xa4\x84\xe7\x90\x86\xe8\xbe\x93\xe5\x85\xa5\n# * \xe8\xae\xa1\xe7\xae\x97\xe6\x8d\x9f\xe5\xa4\xb1\xef\xbc\x88\xe8\xbe\x93\xe5\x87\xba\xe5\x92\x8c\xe6\xad\xa3\xe7\xa1\xae\xe7\xad\x94\xe6\xa1\x88\xe7\x9a\x84\xe8\xb7\x9d\xe7\xa6\xbb\xef\xbc\x89\n# * \xe5\xb0\x86\xe6\xa2\xaf\xe5\xba\xa6\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe7\xbb\x99\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\n# * \xe6\x9b\xb4\xe6\x96\xb0\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\x9d\x83\xe9\x87\x8d\xef\xbc\x8c\xe4\xb8\x80\xe8\x88\xac\xe4\xbd\xbf\xe7\x94\xa8\xe4\xb8\x80\xe4\xb8\xaa\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84\xe8\xa7\x84\xe5\x88\x99\xef\xbc\x9a`weight = weight - learning_rate * gradient`\n# \n# \n#%% [markdown]\n# ## \xe5\xae\x9a\xe4\xb9\x89\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# \xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\xae\x9a\xe4\xb9\x89\xe8\xbf\x99\xe6\xa0\xb7\xe4\xb8\x80\xe4\xb8\xaa\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x9a\n\n#%%\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        # 1 input image channel, 6 output channels, 5x5 square convolution\n        # kernel\n        self.conv1 = nn.Conv2d(1, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        # an affine operation: y = Wx + b\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        # Max pooling over a (2, 2) window\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))\n        # If the size is a square you can only specify a single number\n        x = F.max_pool2d(F.relu(self.conv2(x)), 2)\n        x = x.view(-1, self.num_flat_features(x))\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n    def num_flat_features(self, x):\n        size = x.size()[1:]  # all dimensions except the batch dimension\n        num_features = 1\n        for s in size:\n            num_features *= s\n        return num_features\n\n\nnet = Net()\nprint(net)\n\n#%% [markdown]\n# \xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaa\xe9\x9c\x80\xe8\xa6\x81\xe5\xae\x9a\xe4\xb9\x89 `forward` \xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c`backward`\xe5\x87\xbd\xe6\x95\xb0\xe4\xbc\x9a\xe5\x9c\xa8\xe4\xbd\xbf\xe7\x94\xa8`autograd`\xe6\x97\xb6\xe8\x87\xaa\xe5\x8a\xa8\xe5\xae\x9a\xe4\xb9\x89\xef\xbc\x8c`backward`\xe5\x87\xbd\xe6\x95\xb0\xe7\x94\xa8\xe6\x9d\xa5\xe8\xae\xa1\xe7\xae\x97\xe5\xaf\xbc\xe6\x95\xb0\xe3\x80\x82\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8 `forward` \xe5\x87\xbd\xe6\x95\xb0\xe4\xb8\xad\xe4\xbd\xbf\xe7\x94\xa8\xe4\xbb\xbb\xe4\xbd\x95\xe9\x92\x88\xe5\xaf\xb9\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\xe5\x92\x8c\xe8\xae\xa1\xe7\xae\x97\xe3\x80\x82\n# \n# \xe4\xb8\x80\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe7\x9a\x84\xe5\x8f\xaf\xe5\xad\xa6\xe4\xb9\xa0\xe5\x8f\x82\xe6\x95\xb0\xe5\x8f\xaf\xe4\xbb\xa5\xe9\x80\x9a\xe8\xbf\x87`net.parameters()`\xe8\xbf\x94\xe5\x9b\x9e\n\n#%%\nparams = list(net.parameters())\nprint(len(params))\nprint(params[0].size())  # conv1's .weight\n\n#%% [markdown]\n# \xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x9d\xe8\xaf\x95\xe4\xb8\x80\xe4\xb8\xaa\xe9\x9a\x8f\xe6\x9c\xba\xe7\x9a\x8432x32\xe7\x9a\x84\xe8\xbe\x93\xe5\x85\xa5\xe3\x80\x82\xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x8c\xe8\xbf\x99\xe4\xb8\xaa\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x88LeNet\xef\xbc\x89\xe7\x9a\x84\xe6\x9c\x9f\xe5\xbe\x85\xe8\xbe\x93\xe5\x85\xa5\xe6\x98\xaf32x32\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe4\xbd\xbf\xe7\x94\xa8MNIST\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe6\x9d\xa5\xe8\xae\xad\xe7\xbb\x83\xe8\xbf\x99\xe4\xb8\xaa\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x8c\xe8\xa6\x81\xe6\x8a\x8a\xe5\x9b\xbe\xe7\x89\x87\xe5\xa4\xa7\xe5\xb0\x8f\xe9\x87\x8d\xe6\x96\xb0\xe8\xb0\x83\xe6\x95\xb4\xe5\x88\xb032x32\xe3\x80\x82\n\n#%%\ninput = torch.randn(1, 1, 32, 32)\nout = net(input)\nprint(out)\n\n#%% [markdown]\n# \xe6\xb8\x85\xe9\x9b\xb6\xe6\x89\x80\xe6\x9c\x89\xe5\x8f\x82\xe6\x95\xb0\xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xe7\xbc\x93\xe5\xad\x98\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe8\xbf\x9b\xe8\xa1\x8c\xe9\x9a\x8f\xe6\x9c\xba\xe6\xa2\xaf\xe5\xba\xa6\xe7\x9a\x84\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xef\xbc\x9a\n\n#%%\nnet.zero_grad()\nout.backward(torch.randn(1, 10))\n\n#%% [markdown]\n# >\xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a\n# >\n# >`torch.nn`\xe5\x8f\xaa\xe6\x94\xaf\xe6\x8c\x81\xe5\xb0\x8f\xe6\x89\xb9\xe9\x87\x8f\xe5\xa4\x84\xe7\x90\x86\xef\xbc\x88mini-batches\xef\xbc\x89\xe3\x80\x82\xe6\x95\xb4\xe4\xb8\xaa`torch.nn`\xe5\x8c\x85\xe5\x8f\xaa\xe6\x94\xaf\xe6\x8c\x81\xe5\xb0\x8f\xe6\x89\xb9\xe9\x87\x8f\xe6\xa0\xb7\xe6\x9c\xac\xe7\x9a\x84\xe8\xbe\x93\xe5\x85\xa5\xef\xbc\x8c\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xe5\x8d\x95\xe4\xb8\xaa\xe6\xa0\xb7\xe6\x9c\xac\xe3\x80\x82\n# >\n# >\xe6\xaf\x94\xe5\xa6\x82\xef\xbc\x8c`nn.Conv2d` \xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\x80\xe4\xb8\xaa4\xe7\xbb\xb4\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xef\xbc\x8c\xe5\x8d\xb3`nSamples x nChannels x Height x Width`\n# >\n# >\xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8d\x95\xe7\x8b\xac\xe7\x9a\x84\xe6\xa0\xb7\xe6\x9c\xac\xef\xbc\x8c\xe5\x8f\xaa\xe9\x9c\x80\xe8\xa6\x81\xe4\xbd\xbf\xe7\x94\xa8`input.unsqueeze(0)`\xe6\x9d\xa5\xe6\xb7\xbb\xe5\x8a\xa0\xe4\xb8\x80\xe4\xb8\xaa\xe2\x80\x9c\xe5\x81\x87\xe7\x9a\x84\xe2\x80\x9d\xe6\x89\xb9\xe5\xa4\xa7\xe5\xb0\x8f\xe7\xbb\xb4\xe5\xba\xa6\xe3\x80\x82\n# \n#%% [markdown]\n# \xe5\x9c\xa8\xe7\xbb\xa7\xe7\xbb\xad\xe4\xb9\x8b\xe5\x89\x8d\xef\xbc\x8c\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\x9b\x9e\xe9\xa1\xbe\xe4\xb8\x80\xe4\xb8\x8b\xe5\x88\xb0\xe7\x9b\xae\xe5\x89\x8d\xe4\xb8\xba\xe6\xad\xa2\xe7\x9c\x8b\xe5\x88\xb0\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\xb1\xbb\xe3\x80\x82\n# \n# **\xe5\xa4\x8d\xe4\xb9\xa0\xef\xbc\x9a**\n# \n# * `torch.Tensor` - A multi-dimensional array with support for autograd operations like `backward()`. Also holds the gradient w.r.t. the tensor.\n# \n# \n# * `nn.Module` - Neural network module. Convenient way of encapsulating parameters, with helpers for moving them to GPU, exporting, loading, etc.\n# \n# \n# * `nn.Parameter` - A kind of Tensor, that is automatically registered as a parameter when assigned as an attribute to a `Module`.\n# \n# \n# * `autograd.Function` - Implements forward and backward definitions of an autograd operation. Every `Tensor` operation, creates at least a single `Function` node, that connects to functions that created a `Tensor` and encodes its history.\n# \n# \xe7\x9b\xae\xe5\x89\x8d\xe4\xb8\xba\xe6\xad\xa2\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe8\xae\xa8\xe8\xae\xba\xe4\xba\x86\xef\xbc\x9a\n# \n# * \xe5\xae\x9a\xe4\xb9\x89\xe4\xb8\x80\xe4\xb8\xaa\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n# * \xe5\xa4\x84\xe7\x90\x86\xe8\xbe\x93\xe5\x85\xa5\xe8\xb0\x83\xe7\x94\xa8`backward`\n# \n# \xe8\xbf\x98\xe5\x89\xa9\xe4\xb8\x8b\xef\xbc\x9a\n# \n# * \xe8\xae\xa1\xe7\xae\x97\xe6\x8d\x9f\xe5\xa4\xb1\n# * \xe6\x9b\xb4\xe6\x96\xb0\xe7\xbd\x91\xe7\xbb\x9c\xe6\x9d\x83\xe9\x87\x8d\n#%% [markdown]\n# ## \xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\n#%% [markdown]\n# \xe4\xb8\x80\xe4\xb8\xaa\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\x80\xe5\xaf\xb9(output, target)\xe4\xbd\x9c\xe4\xb8\xba\xe8\xbe\x93\xe5\x85\xa5\xef\xbc\x8c\xe8\xae\xa1\xe7\xae\x97\xe4\xb8\x80\xe4\xb8\xaa\xe5\x80\xbc\xe6\x9d\xa5\xe4\xbc\xb0\xe8\xae\xa1\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe8\xbe\x93\xe5\x87\xba\xe5\x92\x8c\xe7\x9b\xae\xe6\xa0\x87\xe5\x80\xbc\xe7\x9b\xb8\xe5\xb7\xae\xe5\xa4\x9a\xe5\xb0\x91\xe3\x80\x82\n# \n# \xe8\xaf\x91\xe8\x80\x85\xe6\xb3\xa8\xef\xbc\x9aoutput\xe4\xb8\xba\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe8\xbe\x93\xe5\x87\xba,target\xe4\xb8\xba\xe5\xae\x9e\xe9\x99\x85\xe5\x80\xbc\n# \n# nn\xe5\x8c\x85\xe4\xb8\xad\xe6\x9c\x89\xe5\xbe\x88\xe5\xa4\x9a\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84[\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0](https://pytorch.org/docs/stable/nn.html)\xe3\x80\x82`nn.MSELoss`\xe6\x98\xaf\xe6\xaf\x94\xe8\xbe\x83\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84\xe4\xb8\x80\xe7\xa7\x8d\xef\xbc\x8c\xe5\xae\x83\xe8\xae\xa1\xe7\xae\x97\xe8\xbe\x93\xe5\x87\xba\xe5\x92\x8c\xe7\x9b\xae\xe6\xa0\x87\xe7\x9a\x84\xe5\x9d\x87\xe6\x96\xb9\xe8\xaf\xaf\xe5\xb7\xae\xef\xbc\x88mean-squared error\xef\xbc\x89\xe3\x80\x82\n# \n# \xe4\xbe\x8b\xe5\xa6\x82\xef\xbc\x9a\n\n#%%\noutput = net(input)\ntarget = torch.randn(10)  # a dummy target, for example\ntarget = target.view(1, -1)  # make it the same shape as output\ncriterion = nn.MSELoss()\n\nloss = criterion(output, target)\nprint(loss)\n\n#%% [markdown]\n# \xe7\x8e\xb0\xe5\x9c\xa8\xef\xbc\x8c\xe5\xa6\x82\xe6\x9e\x9c\xe4\xbd\xbf\xe7\x94\xa8`loss`\xe7\x9a\x84`.grad_fn`\xe5\xb1\x9e\xe6\x80\xa7\xe8\xb7\x9f\xe8\xb8\xaa\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe8\xbf\x87\xe7\xa8\x8b\xef\xbc\x8c\xe4\xbc\x9a\xe7\x9c\x8b\xe5\x88\xb0\xe8\xae\xa1\xe7\xae\x97\xe5\x9b\xbe\xe5\xa6\x82\xe4\xb8\x8b\xef\xbc\x9a\n#%% [markdown]\n# ```\n# input -> conv2d -> relu -> maxpool2d -> conv2d -> relu -> maxpool2d\n#       -> view -> linear -> relu -> linear -> relu -> linear\n#       -> MSELoss\n#       -> loss\n# ```\n#%% [markdown]\n# \xe6\x89\x80\xe4\xbb\xa5\xef\xbc\x8c\xe5\xbd\x93\xe6\x88\x91\xe4\xbb\xac\xe8\xb0\x83\xe7\x94\xa8`loss.backward()`\xef\xbc\x8c\xe6\x95\xb4\xe5\xbc\xa0\xe5\x9b\xbe\xe5\xbc\x80\xe5\xa7\x8b\xe5\x85\xb3\xe4\xba\x8eloss\xe5\xbe\xae\xe5\x88\x86\xef\xbc\x8c\xe5\x9b\xbe\xe4\xb8\xad\xe6\x89\x80\xe6\x9c\x89\xe8\xae\xbe\xe7\xbd\xae\xe4\xba\x86`requires_grad=True`\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84`.grad`\xe5\xb1\x9e\xe6\x80\xa7\xe7\xb4\xaf\xe7\xa7\xaf\xe7\x9d\x80\xe6\xa2\xaf\xe5\xba\xa6\xe5\xbc\xa0\xe9\x87\x8f\xe3\x80\x82\n# \n# \xe4\xb8\xba\xe4\xba\x86\xe8\xaf\xb4\xe6\x98\x8e\xe8\xbf\x99\xe4\xb8\x80\xe7\x82\xb9\xef\xbc\x8c\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\x90\x91\xe5\x90\x8e\xe8\xb7\x9f\xe8\xb8\xaa\xe5\x87\xa0\xe6\xad\xa5\xef\xbc\x9a\n\n#%%\nprint(loss.grad_fn)  # MSELoss\nprint(loss.grad_fn.next_functions[0][0])  # Linear\nprint(loss.grad_fn.next_functions[0][0].next_functions[0][0])  # ReLU\n\n#%% [markdown]\n# ## \xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\n#%% [markdown]\n# \xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaa\xe9\x9c\x80\xe8\xa6\x81\xe8\xb0\x83\xe7\x94\xa8`loss.backward()`\xe6\x9d\xa5\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe6\x9d\x83\xe9\x87\x8d\xe3\x80\x82\xe6\x88\x91\xe4\xbb\xac\xe9\x9c\x80\xe8\xa6\x81\xe6\xb8\x85\xe9\x9b\xb6\xe7\x8e\xb0\xe6\x9c\x89\xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xef\xbc\x8c\xe5\x90\xa6\xe5\x88\x99\xe6\xa2\xaf\xe5\xba\xa6\xe5\xb0\x86\xe4\xbc\x9a\xe4\xb8\x8e\xe5\xb7\xb2\xe6\x9c\x89\xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xe7\xb4\xaf\xe5\x8a\xa0\xe3\x80\x82\n# \n# \xe7\x8e\xb0\xe5\x9c\xa8\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe8\xb0\x83\xe7\x94\xa8`loss.backward()`\xef\xbc\x8c\xe5\xb9\xb6\xe6\x9f\xa5\xe7\x9c\x8bconv1\xe5\xb1\x82\xe7\x9a\x84\xe5\x81\x8f\xe7\xbd\xae\xef\xbc\x88bias\xef\xbc\x89\xe5\x9c\xa8\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe5\x89\x8d\xe5\x90\x8e\xe7\x9a\x84\xe6\xa2\xaf\xe5\xba\xa6\xe3\x80\x82\n\n#%%\nnet.zero_grad()     # zeroes the gradient buffers of all parameters\n\nprint('conv1.bias.grad before backward')\nprint(net.conv1.bias.grad)\n\nloss.backward()\n\nprint('conv1.bias.grad after backward')\nprint(net.conv1.bias.grad)\n\n#%% [markdown]\n# \xe7\x8e\xb0\xe5\x9c\xa8\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb7\xb2\xe7\xbb\x8f\xe8\xa7\x81\xe5\x88\xb0\xe4\xba\x86\xe5\xa6\x82\xe4\xbd\x95\xe4\xbd\xbf\xe7\x94\xa8\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xe3\x80\x82\n#%% [markdown]\n# >\xe7\xa8\x8d\xe5\x90\x8e\xe9\x98\x85\xe8\xaf\xbb\n# >\n# >\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe5\x8c\x85\xe5\x8c\x85\xe5\x90\xab\xe4\xba\x86\xe5\x90\x84\xe7\xa7\x8d\xe6\xa8\xa1\xe5\x9d\x97\xe5\x92\x8c\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xef\xbc\x8c\xe8\xbf\x99\xe4\xba\x9b\xe6\xa8\xa1\xe5\x9d\x97\xe5\x92\x8c\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xe6\x9e\x84\xe6\x88\x90\xe4\xba\x86\xe6\xb7\xb1\xe5\xba\xa6\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\x9e\x84\xe5\xbb\xba\xe6\xa8\xa1\xe5\x9d\x97\xe3\x80\x82\xe5\xae\x8c\xe6\x95\xb4\xe7\x9a\x84\xe6\x96\x87\xe6\xa1\xa3\xe5\x88\x97\xe8\xa1\xa8\xe8\xa7\x81[\xe8\xbf\x99\xe9\x87\x8c](https://pytorch.org/docs/stable/nn.html)\xe3\x80\x82\n# >\n# >\xe7\x8e\xb0\xe5\x9c\xa8\xe5\x94\xaf\xe4\xb8\x80\xe8\xa6\x81\xe5\xad\xa6\xe4\xb9\xa0\xe7\x9a\x84\xe6\x98\xaf\xef\xbc\x9a\n# >* \xe6\x9b\xb4\xe6\x96\xb0\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\x9d\x83\xe9\x87\x8d\n#%% [markdown]\n# ## \xe6\x9b\xb4\xe6\x96\xb0\xe6\x9d\x83\xe9\x87\x8d\n#%% [markdown]\n# \xe6\x9c\x80\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84\xe6\x9b\xb4\xe6\x96\xb0\xe8\xa7\x84\xe5\x88\x99\xe6\x98\xaf\xe9\x9a\x8f\xe6\x9c\xba\xe6\xa2\xaf\xe5\xba\xa6\xe4\xb8\x8b\xe9\x99\x8d\xe6\xb3\x95\xef\xbc\x88SGD\xef\xbc\x89:\n# \n# `weight = weight - learning_rate * gradient`\n# \n# \xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe7\xae\x80\xe5\x8d\x95\xe7\x9a\x84python\xe4\xbb\xa3\xe7\xa0\x81\xe6\x9d\xa5\xe5\xae\x9e\xe7\x8e\xb0:\n\n#%%\nlearning_rate = 0.01\nfor f in net.parameters():\n    f.data.sub_(f.grad.data * learning_rate)\n\n#%% [markdown]\n# \xe7\x84\xb6\xe8\x80\x8c\xef\xbc\x8c\xe5\x9c\xa8\xe4\xbd\xbf\xe7\x94\xa8\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe6\x97\xb6\xef\xbc\x8c\xe5\x8f\xaf\xe8\x83\xbd\xe5\xb8\x8c\xe6\x9c\x9b\xe4\xbd\xbf\xe7\x94\xa8\xe5\x90\x84\xe7\xa7\x8d\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\xe6\x9b\xb4\xe6\x96\xb0\xe8\xa7\x84\xe5\x88\x99\xef\xbc\x8c\xe5\xa6\x82SGD\xe3\x80\x81Nesterov-SGD\xe3\x80\x81Adam\xe3\x80\x81RMSProp\xe7\xad\x89\xe3\x80\x82\xe4\xb8\xba\xe6\xad\xa4\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe6\x9e\x84\xe5\xbb\xba\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe8\xbe\x83\xe5\xb0\x8f\xe7\x9a\x84\xe5\x8c\x85`torch.optim`\xef\xbc\x8c\xe5\xae\x83\xe5\xae\x9e\xe7\x8e\xb0\xe4\xba\x86\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe8\xbf\x99\xe4\xba\x9b\xe6\x96\xb9\xe6\xb3\x95\xe3\x80\x82\xe4\xbd\xbf\xe7\x94\xa8\xe5\xae\x83\xe5\xbe\x88\xe7\xae\x80\xe5\x8d\x95\xef\xbc\x9a\n\n#%%\nimport torch.optim as optim\n\n# create your optimizer\noptimizer = optim.SGD(net.parameters(), lr=0.01)\n\n# in your training loop:\noptimizer.zero_grad()   # zero the gradient buffers\noutput = net(input)\nloss = criterion(output, target)\nloss.backward()\noptimizer.step()    # Does the update\n\n#%% [markdown]\n# >\xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a\n# >\xe8\xa7\x82\xe5\xaf\x9f\xe6\xa2\xaf\xe5\xba\xa6\xe7\xbc\x93\xe5\xad\x98\xe5\x8c\xba\xe6\x98\xaf\xe5\xa6\x82\xe4\xbd\x95\xe4\xbd\xbf\xe7\x94\xa8`optimizer.zero_grad()`\xe6\x89\x8b\xe5\x8a\xa8\xe6\xb8\x85\xe9\x9b\xb6\xe7\x9a\x84\xe3\x80\x82\xe8\xbf\x99\xe6\x98\xaf\xe5\x9b\xa0\xe4\xb8\xba\xe6\xa2\xaf\xe5\xba\xa6\xe6\x98\xaf\xe7\xb4\xaf\xe5\x8a\xa0\xe7\x9a\x84\xef\xbc\x8c\xe6\xad\xa3\xe5\xa6\x82\xe5\x89\x8d\xe9\x9d\xa2[\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe7\xab\xa0\xe8\x8a\x82](#\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad)\xe5\x8f\x99\xe8\xbf\xb0\xe7\x9a\x84\xe9\x82\xa3\xe6\xa0\xb7\xe3\x80\x82\n\n#%%\n\n\n\n"""
Optional_Data_Parallelism/data_parallel_tutorial.py,0,"b'""""""\nOptional: Data Parallelism\n==========================\n**Authors**: `Sung Kim <https://github.com/hunkim>`_ and `Jenny Kang <https://github.com/jennykang>`_\n\nIn this tutorial, we will learn how to use multiple GPUs using ``DataParallel``.\n\nIt\'s very easy to use GPUs with PyTorch. You can put the model on a GPU:\n\n.. code:: python\n\n    device = torch.device(""cuda:0"")\n    model.to(device)\n\nThen, you can copy all your tensors to the GPU:\n\n.. code:: python\n\n    mytensor = my_tensor.to(device)\n\nPlease note that just calling ``my_tensor.to(device)`` returns a new copy of\n``my_tensor`` on GPU instead of rewriting ``my_tensor``. You need to assign it to\na new tensor and use that tensor on the GPU.\n\nIt\'s natural to execute your forward, backward propagations on multiple GPUs.\nHowever, Pytorch will only use one GPU by default. You can easily run your\noperations on multiple GPUs by making your model run parallelly using\n``DataParallel``:\n\n.. code:: python\n\n    model = nn.DataParallel(model)\n\nThat\'s the core behind this tutorial. We will explore it in more detail below.\n""""""\n\n\n######################################################################\n# Imports and parameters\n# ----------------------\n#\n# Import PyTorch modules and define parameters.\n#\n\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import Dataset, DataLoader\n\n# Parameters and DataLoaders\ninput_size = 5\noutput_size = 2\n\nbatch_size = 30\ndata_size = 100\n\n\n######################################################################\n# Device\n#\ndevice = torch.device(""cuda:0"" if torch.cuda.is_available() else ""cpu"")\n\n######################################################################\n# Dummy DataSet\n# -------------\n#\n# Make a dummy (random) dataset. You just need to implement the\n# getitem\n#\n\nclass RandomDataset(Dataset):\n\n    def __init__(self, size, length):\n        self.len = length\n        self.data = torch.randn(length, size)\n\n    def __getitem__(self, index):\n        return self.data[index]\n\n    def __len__(self):\n        return self.len\n\nrand_loader = DataLoader(dataset=RandomDataset(input_size, data_size),\n                         batch_size=batch_size, shuffle=True)\n\n\n######################################################################\n# Simple Model\n# ------------\n#\n# For the demo, our model just gets an input, performs a linear operation, and\n# gives an output. However, you can use ``DataParallel`` on any model (CNN, RNN,\n# Capsule Net etc.)\n#\n# We\'ve placed a print statement inside the model to monitor the size of input\n# and output tensors.\n# Please pay attention to what is printed at batch rank 0.\n#\n\nclass Model(nn.Module):\n    # Our model\n\n    def __init__(self, input_size, output_size):\n        super(Model, self).__init__()\n        self.fc = nn.Linear(input_size, output_size)\n\n    def forward(self, input):\n        output = self.fc(input)\n        print(""\\tIn Model: input size"", input.size(),\n              ""output size"", output.size())\n\n        return output\n\n\n######################################################################\n# Create Model and DataParallel\n# -----------------------------\n#\n# This is the core part of the tutorial. First, we need to make a model instance\n# and check if we have multiple GPUs. If we have multiple GPUs, we can wrap\n# our model using ``nn.DataParallel``. Then we can put our model on GPUs by\n# ``model.to(device)``\n#\n\nmodel = Model(input_size, output_size)\nif torch.cuda.device_count() > 1:\n  print(""Let\'s use"", torch.cuda.device_count(), ""GPUs!"")\n  # dim = 0 [30, xxx] -> [10, ...], [10, ...], [10, ...] on 3 GPUs\n  model = nn.DataParallel(model)\n\nmodel.to(device)\n\n\n######################################################################\n# Run the Model\n# -------------\n#\n# Now we can see the sizes of input and output tensors.\n#\n\nfor data in rand_loader:\n    input = data.to(device)\n    output = model(input)\n    print(""Outside: input size"", input.size(),\n          ""output_size"", output.size())\n\n\n######################################################################\n# Results\n# -------\n#\n# If you have no GPU or one GPU, when we batch 30 inputs and 30 outputs, the model gets 30 and outputs 30 as\n# expected. But if you have multiple GPUs, then you can get results like this.\n#\n# 2 GPUs\n# ~~~~~~\n#\n# If you have 2, you will see:\n#\n# .. code:: bash\n#\n#     # on 2 GPUs\n#     Let\'s use 2 GPUs!\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#         In Model: input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2])\n#         In Model: input size torch.Size([5, 5]) output size torch.Size([5, 2])\n#     Outside: input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n#\n# 3 GPUs\n# ~~~~~~\n#\n# If you have 3 GPUs, you will see:\n#\n# .. code:: bash\n#\n#     Let\'s use 3 GPUs!\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#         In Model: input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     Outside: input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n#\n# 8 GPUs\n# ~~~~~~~~~~~~~~\n#\n# If you have 8, you will see:\n#\n# .. code:: bash\n#\n#     Let\'s use 8 GPUs!\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     Outside: input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#         In Model: input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     Outside: input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n#\n\n\n######################################################################\n# Summary\n# -------\n#\n# DataParallel splits your data automatically and sends job orders to multiple\n# models on several GPUs. After each model finishes their job, DataParallel\n# collects and merges the results before returning it to you.\n#\n# For more information, please check out\n# https://pytorch.org/tutorials/beginner/former\\_torchies/parallelism\\_tutorial.html.\n#\n'"
Optional_Data_Parallelism/选读：数据并行处理.py,0,"b'#%% [markdown]\n# # \xe9\x80\x89\xe8\xaf\xbb\xef\xbc\x9a\xe6\x95\xb0\xe6\x8d\xae\xe5\xb9\xb6\xe8\xa1\x8c\xe5\xa4\x84\xe7\x90\x86\n#%% [markdown]\n# \xe5\x9c\xa8\xe8\xbf\x99\xe4\xb8\xaa\xe6\x95\x99\xe7\xa8\x8b\xe9\x87\x8c\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe5\xad\xa6\xe4\xb9\xa0\xe5\xa6\x82\xe4\xbd\x95\xe4\xbd\xbf\xe7\x94\xa8\xe6\x95\xb0\xe6\x8d\xae\xe5\xb9\xb6\xe8\xa1\x8c\xef\xbc\x88`DataParallel`\xef\xbc\x89\xe6\x9d\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe5\xa4\x9aGPU\xe3\x80\x82\n# \n# PyTorch\xe9\x9d\x9e\xe5\xb8\xb8\xe5\xae\xb9\xe6\x98\x93\xe7\x9a\x84\xe5\xb0\xb1\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8GPU\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe7\x94\xa8\xe5\xa6\x82\xe4\xb8\x8b\xe6\x96\xb9\xe5\xbc\x8f\xe6\x8a\x8a\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x94\xbe\xe5\x88\xb0GPU\xe4\xb8\x8a\xef\xbc\x9a\n\n#%%\ndevice = torch.device(""cuda\xef\xbc\x9a0"")\nmodel.to(device)\n\n#%% [markdown]\n# \xe7\x84\xb6\xe5\x90\x8e\xe5\x8f\xaf\xe4\xbb\xa5\xe5\xa4\x8d\xe5\x88\xb6\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe5\x88\xb0GPU\xe4\xb8\x8a\xef\xbc\x9a\n\n#%%\nmytensor = my_tensor.to(device)\n\n#%% [markdown]\n# `my_tensor.to(device)`\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaaGPU\xe4\xb8\x8a\xe7\x9a\x84`my_tensor`\xe5\x89\xaf\xe6\x9c\xac\xef\xbc\x8c\xe8\x80\x8c\xe4\xb8\x8d\xe6\x98\xaf\xe9\x87\x8d\xe5\x86\x99`my_tensor`\xe3\x80\x82\xe6\x88\x91\xe4\xbb\xac\xe9\x9c\x80\xe8\xa6\x81\xe6\x8a\x8a\xe5\xae\x83\xe8\xb5\x8b\xe5\x80\xbc\xe7\xbb\x99\xe4\xb8\x80\xe4\xb8\xaa\xe6\x96\xb0\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe5\xb9\xb6\xe5\x9c\xa8GPU\xe4\xb8\x8a\xe4\xbd\xbf\xe7\x94\xa8\xe8\xbf\x99\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe3\x80\x82\n# \n# \xe5\x9c\xa8\xe5\xa4\x9aGPU\xe4\xb8\x8a\xe6\x89\xa7\xe8\xa1\x8c\xe5\x89\x8d\xe5\x90\x91\xe5\x92\x8c\xe5\x8f\x8d\xe5\x90\x91\xe4\xbc\xa0\xe6\x92\xad\xe6\x98\xaf\xe8\x87\xaa\xe7\x84\xb6\xe8\x80\x8c\xe7\x84\xb6\xe7\x9a\x84\xe4\xba\x8b\xe3\x80\x82\xe7\x84\xb6\xe8\x80\x8c\xef\xbc\x8cPyTorch\xe9\xbb\x98\xe8\xae\xa4\xe5\xb0\x86\xe5\x8f\xaa\xe6\x98\xaf\xe7\x94\xa8\xe4\xb8\x80\xe4\xb8\xaaGPU\xe3\x80\x82\xe4\xbd\xa0\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8`DataParallel`\xe8\xae\xa9\xe6\xa8\xa1\xe5\x9e\x8b\xe5\xb9\xb6\xe8\xa1\x8c\xe8\xbf\x90\xe8\xa1\x8c\xe6\x9d\xa5\xe8\xbd\xbb\xe6\x98\x93\xe7\x9a\x84\xe8\xae\xa9\xe4\xbd\xa0\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\xe5\x9c\xa8\xe5\xa4\x9a\xe4\xb8\xaaGPU\xe4\xb8\x8a\xe8\xbf\x90\xe8\xa1\x8c\xe3\x80\x82\n\n#%%\nmodel = nn.DataParallel(model)\n\n#%% [markdown]\n# \xe8\xbf\x99\xe6\x98\xaf\xe8\xbf\x99\xe7\xaf\x87\xe6\x95\x99\xe7\xa8\x8b\xe8\x83\x8c\xe5\x90\x8e\xe7\x9a\x84\xe6\xa0\xb8\xe5\xbf\x83\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe6\x8e\xa5\xe4\xb8\x8b\xe6\x9d\xa5\xe5\xb0\x86\xe6\x9b\xb4\xe8\xaf\xa6\xe7\xbb\x86\xe7\x9a\x84\xe4\xbb\x8b\xe7\xbb\x8d\xe5\xae\x83\xe3\x80\x82\n#%% [markdown]\n# ## \xe5\xaf\xbc\xe5\x85\xa5\xe5\x92\x8c\xe5\x8f\x82\xe6\x95\xb0\n#%% [markdown]\n# \xe5\xaf\xbc\xe5\x85\xa5PyTorch\xe6\xa8\xa1\xe5\x9d\x97\xe5\x92\x8c\xe5\xae\x9a\xe4\xb9\x89\xe5\x8f\x82\xe6\x95\xb0\xe3\x80\x82\n\n#%%\nimport torch\nimport torch.nn as nn\nfrom torch.utils.data import Dataset, DataLoader\n\n# Parameters and DataLoaders\ninput_size = 5\noutput_size = 2\n\nbatch_size = 30\ndata_size = 100\n\n#%% [markdown]\n# ## \xe8\x99\x9a\xe6\x8b\x9f\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\n#%% [markdown]\n# \xe8\xa6\x81\xe5\x88\xb6\xe4\xbd\x9c\xe4\xb8\x80\xe4\xb8\xaa\xe8\x99\x9a\xe6\x8b\x9f\xef\xbc\x88\xe9\x9a\x8f\xe6\x9c\xba\xef\xbc\x89\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xef\xbc\x8c\xe5\x8f\xaa\xe9\x9c\x80\xe5\xae\x9e\xe7\x8e\xb0`__getitem__`\xe3\x80\x82\n\n#%%\nclass RandomDataset(Dataset)\xef\xbc\x9a\n\n    def __init__(self, size, length)\xef\xbc\x9a\n        self.len = length\n        self.data = torch.randn(length, size)\n\n    def __getitem__(self, index)\xef\xbc\x9a\n        return self.data[index]\n\n    def __len__(self)\xef\xbc\x9a\n        return self.len\n\nrand_loader = DataLoader(dataset=RandomDataset(input_size, data_size),\n                         batch_size=batch_size, shuffle=True)\n\n#%% [markdown]\n# ## \xe7\xae\x80\xe5\x8d\x95\xe6\xa8\xa1\xe5\x9e\x8b\n#%% [markdown]\n# \xe4\xbd\x9c\xe4\xb8\xba\xe6\xbc\x94\xe7\xa4\xba\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x8f\xaa\xe6\x8e\xa5\xe5\x8f\x97\xe4\xb8\x80\xe4\xb8\xaa\xe8\xbe\x93\xe5\x85\xa5\xef\xbc\x8c\xe6\x89\xa7\xe8\xa1\x8c\xe4\xb8\x80\xe4\xb8\xaa\xe7\xba\xbf\xe6\x80\xa7\xe6\x93\x8d\xe4\xbd\x9c\xef\xbc\x8c\xe7\x84\xb6\xe5\x90\x8e\xe5\xbe\x97\xe5\x88\xb0\xe7\xbb\x93\xe6\x9e\x9c\xe3\x80\x82\xe7\x84\xb6\xe8\x80\x8c\xef\xbc\x8c\xe4\xbd\xa0\xe8\x83\xbd\xe5\x9c\xa8\xe4\xbb\xbb\xe4\xbd\x95\xe6\xa8\xa1\xe5\x9e\x8b\xef\xbc\x88CNN\xef\xbc\x8cRNN\xef\xbc\x8cCapsule Net\xe7\xad\x89\xef\xbc\x89\xe4\xb8\x8a\xe4\xbd\xbf\xe7\x94\xa8`DataParallel`\xe3\x80\x82\n# \n# \xe6\x88\x91\xe4\xbb\xac\xe5\x9c\xa8\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x86\x85\xe9\x83\xa8\xe6\x94\xbe\xe7\xbd\xae\xe4\xba\x86\xe4\xb8\x80\xe6\x9d\xa1\xe6\x89\x93\xe5\x8d\xb0\xe8\xaf\xad\xe5\x8f\xa5\xe6\x9d\xa5\xe6\xa3\x80\xe6\xb5\x8b\xe8\xbe\x93\xe5\x85\xa5\xe5\x92\x8c\xe8\xbe\x93\xe5\x87\xba\xe5\x90\x91\xe9\x87\x8f\xe7\x9a\x84\xe5\xa4\xa7\xe5\xb0\x8f\xe3\x80\x82\xe8\xaf\xb7\xe6\xb3\xa8\xe6\x84\x8f\xe6\x89\xb9\xe7\xad\x89\xe7\xba\xa7\xe4\xb8\xba0\xe6\x97\xb6\xe6\x89\x93\xe5\x8d\xb0\xe7\x9a\x84\xe5\x86\x85\xe5\xae\xb9\xe3\x80\x82\n\n#%%\nclass Model(nn.Module)\xef\xbc\x9a\n    # Our model\n\n    def __init__(self, input_size, output_size)\xef\xbc\x9a\n        super(Model, self).__init__()\n        self.fc = nn.Linear(input_size, output_size)\n\n    def forward(self, input)\xef\xbc\x9a\n        output = self.fc(input)\n        print(""\\tIn Model\xef\xbc\x9a input size"", input.size(),\n              ""output size"", output.size())\n\n        return output\n\n#%% [markdown]\n# ## \xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe5\x92\x8c\xe6\x95\xb0\xe6\x8d\xae\xe5\xb9\xb6\xe8\xa1\x8c\n#%% [markdown]\n# \xe8\xbf\x99\xe6\x98\xaf\xe6\x9c\xac\xe6\x95\x99\xe7\xa8\x8b\xe7\x9a\x84\xe6\xa0\xb8\xe5\xbf\x83\xe9\x83\xa8\xe5\x88\x86\xe3\x80\x82\xe9\xa6\x96\xe5\x85\x88\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe9\x9c\x80\xe8\xa6\x81\xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe5\xae\x9e\xe4\xbe\x8b\xe5\x92\x8c\xe6\xa3\x80\xe6\xb5\x8b\xe6\x88\x91\xe4\xbb\xac\xe6\x98\xaf\xe5\x90\xa6\xe6\x9c\x89\xe5\xa4\x9a\xe4\xb8\xaaGPU\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe6\x88\x91\xe4\xbb\xac\xe6\x9c\x89\xe5\xa4\x9a\xe4\xb8\xaaGPU\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe4\xbd\xbf\xe7\x94\xa8`nn.DataParallel`\xe6\x9d\xa5\xe5\x8c\x85\xe8\xa3\x85\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe6\xa8\xa1\xe5\x9e\x8b\xe3\x80\x82\xe7\x84\xb6\xe5\x90\x8e\xe9\x80\x9a\xe8\xbf\x87`model.to(device)`\xe6\x8a\x8a\xe6\xa8\xa1\xe5\x9e\x8b\xe6\x94\xbe\xe5\x88\xb0GPU\xe4\xb8\x8a\xe3\x80\x82\n\n#%%\nmodel = Model(input_size, output_size)\nif torch.cuda.device_count() > 1\xef\xbc\x9a\n  print(""Let\'s use"", torch.cuda.device_count(), ""GPUs!"")\n  # dim = 0 [30, xxx] -> [10, ...], [10, ...], [10, ...] on 3 GPUs\n  model = nn.DataParallel(model)\n\nmodel.to(device)\n\n#%% [markdown]\n# ## \xe8\xbf\x90\xe8\xa1\x8c\xe6\xa8\xa1\xe5\x9e\x8b\n#%% [markdown]\n# \xe7\x8e\xb0\xe5\x9c\xa8\xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaf\xe4\xbb\xa5\xe7\x9c\x8b\xe8\xbe\x93\xe5\x85\xa5\xe5\x92\x8c\xe8\xbe\x93\xe5\x87\xba\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe5\xa4\xa7\xe5\xb0\x8f\xe3\x80\x82\n\n#%%\nfor data in rand_loader\xef\xbc\x9a\n    input = data.to(device)\n    output = model(input)\n    print(""Outside\xef\xbc\x9a input size"", input.size(),\n          ""output_size"", output.size())\n\n#%% [markdown]\n# ## \xe7\xbb\x93\xe6\x9e\x9c\n#%% [markdown]\n# \xe5\xbd\x93\xe6\x88\x91\xe4\xbb\xac\xe5\xaf\xb930\xe4\xb8\xaa\xe8\xbe\x93\xe5\x85\xa5\xe5\x92\x8c\xe8\xbe\x93\xe5\x87\xba\xe8\xbf\x9b\xe8\xa1\x8c\xe6\x89\xb9\xe5\xa4\x84\xe7\x90\x86\xe6\x97\xb6\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\x92\x8c\xe6\x9c\x9f\xe6\x9c\x9b\xe7\x9a\x84\xe4\xb8\x80\xe6\xa0\xb7\xe5\xbe\x97\xe5\x88\xb030\xe4\xb8\xaa\xe8\xbe\x93\xe5\x85\xa5\xe5\x92\x8c30\xe4\xb8\xaa\xe8\xbe\x93\xe5\x87\xba\xef\xbc\x8c\xe4\xbd\x86\xe6\x98\xaf\xe8\x8b\xa5\xe6\x9c\x89\xe5\xa4\x9a\xe4\xb8\xaaGPU\xef\xbc\x8c\xe4\xbc\x9a\xe5\xbe\x97\xe5\x88\xb0\xe5\xa6\x82\xe4\xb8\x8b\xe7\x9a\x84\xe7\xbb\x93\xe6\x9e\x9c\xe3\x80\x82\n#%% [markdown]\n# ### 2\xe4\xb8\xaaGPU\n#%% [markdown]\n# \xe8\x8b\xa5\xe6\x9c\x892\xe4\xb8\xaaGPU\xef\xbc\x8c\xe5\xb0\x86\xe7\x9c\x8b\xe5\x88\xb0\n#%% [markdown]\n# ```python\n# # on 2 GPUs\n# Let\'s use 2 GPUs!\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([15, 5]) output size torch.Size([15, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([5, 5]) output size torch.Size([5, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([5, 5]) output size torch.Size([5, 2])\n# Outside\xef\xbc\x9a input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n# ```\n#%% [markdown]\n# ### 3\xe4\xb8\xaaGPU\n#%% [markdown]\n# \xe8\x8b\xa5\xe6\x9c\x893\xe4\xb8\xaaGPU\xef\xbc\x8c\xe5\xb0\x86\xe7\x9c\x8b\xe5\x88\xb0\xef\xbc\x9a\n#%% [markdown]\n# ```python\n# Let\'s use 3 GPUs!\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([10, 5]) output size torch.Size([10, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n# Outside\xef\xbc\x9a input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n# ```\n#%% [markdown]\n# ### 8\xe4\xb8\xaaGPU\n#%% [markdown]\n# \xe8\x8b\xa5\xe6\x9c\x898\xe4\xb8\xaaGPU\xef\xbc\x8c\xe5\xb0\x86\xe7\x9c\x8b\xe5\x88\xb0\xef\xbc\x9a\n#%% [markdown]\n# ```python\n# Let\'s use 8 GPUs!\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([4, 5]) output size torch.Size([4, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n# Outside\xef\xbc\x9a input size torch.Size([30, 5]) output_size torch.Size([30, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n#     In Model\xef\xbc\x9a input size torch.Size([2, 5]) output size torch.Size([2, 2])\n# Outside\xef\xbc\x9a input size torch.Size([10, 5]) output_size torch.Size([10, 2])\n# ```\n#%% [markdown]\n# ## \xe6\x80\xbb\xe7\xbb\x93\n#%% [markdown]\n# `DataParallel`\xe8\x87\xaa\xe5\x8a\xa8\xe7\x9a\x84\xe5\x88\x92\xe5\x88\x86\xe6\x95\xb0\xe6\x8d\xae\xef\xbc\x8c\xe5\xb9\xb6\xe5\xb0\x86\xe4\xbd\x9c\xe4\xb8\x9a\xe5\x8f\x91\xe9\x80\x81\xe5\x88\xb0\xe5\xa4\x9a\xe4\xb8\xaaGPU\xe4\xb8\x8a\xe7\x9a\x84\xe5\xa4\x9a\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe3\x80\x82\xe5\x9c\xa8\xe6\xaf\x8f\xe4\xb8\xaa\xe6\xa8\xa1\xe5\x9e\x8b\xe5\xae\x8c\xe6\x88\x90\xe4\xbd\x9c\xe4\xb8\x9a\xe5\x90\x8e\xef\xbc\x8c`DataParallel`\xe6\x94\xb6\xe9\x9b\x86\xe5\xb9\xb6\xe5\x90\x88\xe5\xb9\xb6\xe7\xbb\x93\xe6\x9e\x9c\xe8\xbf\x94\xe5\x9b\x9e\xe7\xbb\x99\xe4\xbd\xa0\xe3\x80\x82\n# \n# \xe6\x9b\xb4\xe5\xa4\x9a\xe4\xbf\xa1\xe6\x81\xaf\xef\xbc\x8c\xe8\xaf\xb7\xe5\x8f\x82\xe8\x80\x83\xef\xbc\x9ahttp://pytorch.org/tutorials/beginner/former_torchies/parallelism_tutorial.html\n\n#%%\n\n\n\n'"
Training_a_Classifier/cifar10_tutorial.py,1,"b'# -*- coding: utf-8 -*-\n""""""\nTraining a Classifier\n=====================\n\nThis is it. You have seen how to define neural networks, compute loss and make\nupdates to the weights of the network.\n\nNow you might be thinking,\n\nWhat about data?\n----------------\n\nGenerally, when you have to deal with image, text, audio or video data,\nyou can use standard python packages that load data into a numpy array.\nThen you can convert this array into a ``torch.*Tensor``.\n\n-  For images, packages such as Pillow, OpenCV are useful\n-  For audio, packages such as scipy and librosa\n-  For text, either raw Python or Cython based loading, or NLTK and\n   SpaCy are useful\n\nSpecifically for vision, we have created a package called\n``torchvision``, that has data loaders for common datasets such as\nImagenet, CIFAR10, MNIST, etc. and data transformers for images, viz.,\n``torchvision.datasets`` and ``torch.utils.data.DataLoader``.\n\nThis provides a huge convenience and avoids writing boilerplate code.\n\nFor this tutorial, we will use the CIFAR10 dataset.\nIt has the classes: \xe2\x80\x98airplane\xe2\x80\x99, \xe2\x80\x98automobile\xe2\x80\x99, \xe2\x80\x98bird\xe2\x80\x99, \xe2\x80\x98cat\xe2\x80\x99, \xe2\x80\x98deer\xe2\x80\x99,\n\xe2\x80\x98dog\xe2\x80\x99, \xe2\x80\x98frog\xe2\x80\x99, \xe2\x80\x98horse\xe2\x80\x99, \xe2\x80\x98ship\xe2\x80\x99, \xe2\x80\x98truck\xe2\x80\x99. The images in CIFAR-10 are of\nsize 3x32x32, i.e. 3-channel color images of 32x32 pixels in size.\n\n.. figure:: /_static/img/cifar10.png\n   :alt: cifar10\n\n   cifar10\n\n\nTraining an image classifier\n----------------------------\n\nWe will do the following steps in order:\n\n1. Load and normalizing the CIFAR10 training and test datasets using\n   ``torchvision``\n2. Define a Convolutional Neural Network\n3. Define a loss function\n4. Train the network on the training data\n5. Test the network on the test data\n\n1. Loading and normalizing CIFAR10\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUsing ``torchvision``, it\xe2\x80\x99s extremely easy to load CIFAR10.\n""""""\nimport torch\nimport torchvision\nimport torchvision.transforms as transforms\n\n########################################################################\n# The output of torchvision datasets are PILImage images of range [0, 1].\n# We transform them to Tensors of normalized range [-1, 1].\n\ntransform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n\ntrainset = torchvision.datasets.CIFAR10(root=\'./data\', train=True,\n                                        download=True, transform=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=4,\n                                          shuffle=True, num_workers=2)\n\ntestset = torchvision.datasets.CIFAR10(root=\'./data\', train=False,\n                                       download=True, transform=transform)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=4,\n                                         shuffle=False, num_workers=2)\n\nclasses = (\'plane\', \'car\', \'bird\', \'cat\',\n           \'deer\', \'dog\', \'frog\', \'horse\', \'ship\', \'truck\')\n\n########################################################################\n# Let us show some of the training images, for fun.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# functions to show an image\n\n\ndef imshow(img):\n    img = img / 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n\n\n# get some random training images\ndataiter = iter(trainloader)\nimages, labels = dataiter.next()\n\n# show images\nimshow(torchvision.utils.make_grid(images))\n# print labels\nprint(\' \'.join(\'%5s\' % classes[labels[j]] for j in range(4)))\n\n\n########################################################################\n# 2. Define a Convolutional Neural Network\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n# Copy the neural network from the Neural Networks section before and modify it to\n# take 3-channel images (instead of 1-channel images as it was defined).\n\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()\n\n########################################################################\n# 3. Define a Loss function and optimizer\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n# Let\'s use a Classification Cross-Entropy loss and SGD with momentum.\n\nimport torch.optim as optim\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)\n\n########################################################################\n# 4. Train the network\n# ^^^^^^^^^^^^^^^^^^^^\n#\n# This is when things start to get interesting.\n# We simply have to loop over our data iterator, and feed the inputs to the\n# network and optimize.\n\nfor epoch in range(2):  # loop over the dataset multiple times\n\n    running_loss = 0.0\n    for i, data in enumerate(trainloader, 0):\n        # get the inputs\n        inputs, labels = data\n\n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # forward + backward + optimize\n        outputs = net(inputs)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n\n        # print statistics\n        running_loss += loss.item()\n        if i % 2000 == 1999:    # print every 2000 mini-batches\n            print(\'[%d, %5d] loss: %.3f\' %\n                  (epoch + 1, i + 1, running_loss / 2000))\n            running_loss = 0.0\n\nprint(\'Finished Training\')\n\n########################################################################\n# 5. Test the network on the test data\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n#\n# We have trained the network for 2 passes over the training dataset.\n# But we need to check if the network has learnt anything at all.\n#\n# We will check this by predicting the class label that the neural network\n# outputs, and checking it against the ground-truth. If the prediction is\n# correct, we add the sample to the list of correct predictions.\n#\n# Okay, first step. Let us display an image from the test set to get familiar.\n\ndataiter = iter(testloader)\nimages, labels = dataiter.next()\n\n# print images\nimshow(torchvision.utils.make_grid(images))\nprint(\'GroundTruth: \', \' \'.join(\'%5s\' % classes[labels[j]] for j in range(4)))\n\n########################################################################\n# Okay, now let us see what the neural network thinks these examples above are:\n\noutputs = net(images)\n\n########################################################################\n# The outputs are energies for the 10 classes.\n# Higher the energy for a class, the more the network\n# thinks that the image is of the particular class.\n# So, let\'s get the index of the highest energy:\n_, predicted = torch.max(outputs, 1)\n\nprint(\'Predicted: \', \' \'.join(\'%5s\' % classes[predicted[j]]\n                              for j in range(4)))\n\n########################################################################\n# The results seem pretty good.\n#\n# Let us look at how the network performs on the whole dataset.\n\ncorrect = 0\ntotal = 0\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net(images)\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n\nprint(\'Accuracy of the network on the 10000 test images: %d %%\' % (\n    100 * correct / total))\n\n########################################################################\n# That looks waaay better than chance, which is 10% accuracy (randomly picking\n# a class out of 10 classes).\n# Seems like the network learnt something.\n#\n# Hmmm, what are the classes that performed well, and the classes that did\n# not perform well:\n\nclass_correct = list(0. for i in range(10))\nclass_total = list(0. for i in range(10))\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net(images)\n        _, predicted = torch.max(outputs, 1)\n        c = (predicted == labels).squeeze()\n        for i in range(4):\n            label = labels[i]\n            class_correct[label] += c[i].item()\n            class_total[label] += 1\n\n\nfor i in range(10):\n    print(\'Accuracy of %5s : %2d %%\' % (\n        classes[i], 100 * class_correct[i] / class_total[i]))\n\n########################################################################\n# Okay, so what next?\n#\n# How do we run these neural networks on the GPU?\n#\n# Training on GPU\n# ----------------\n# Just like how you transfer a Tensor on to the GPU, you transfer the neural\n# net onto the GPU.\n#\n# Let\'s first define our device as the first visible cuda device if we have\n# CUDA available:\n\ndevice = torch.device(""cuda:0"" if torch.cuda.is_available() else ""cpu"")\n\n# Assume that we are on a CUDA machine, then this should print a CUDA device:\n\nprint(device)\n\n########################################################################\n# The rest of this section assumes that `device` is a CUDA device.\n#\n# Then these methods will recursively go over all modules and convert their\n# parameters and buffers to CUDA tensors:\n#\n# .. code:: python\n#\n#     net.to(device)\n#\n#\n# Remember that you will have to send the inputs and targets at every step\n# to the GPU too:\n#\n# .. code:: python\n#\n#         inputs, labels = inputs.to(device), labels.to(device)\n#\n# Why dont I notice MASSIVE speedup compared to CPU? Because your network\n# is realllly small.\n#\n# **Exercise:** Try increasing the width of your network (argument 2 of\n# the first ``nn.Conv2d``, and argument 1 of the second ``nn.Conv2d`` \xe2\x80\x93\n# they need to be the same number), see what kind of speedup you get.\n#\n# **Goals achieved**:\n#\n# - Understanding PyTorch\'s Tensor library and neural networks at a high level.\n# - Train a small neural network to classify images\n#\n# Training on multiple GPUs\n# -------------------------\n# If you want to see even more MASSIVE speedup using all of your GPUs,\n# please check out :doc:`data_parallel_tutorial`.\n#\n# Where do I go next?\n# -------------------\n#\n# -  :doc:`Train neural nets to play video games </intermediate/reinforcement_q_learning>`\n# -  `Train a state-of-the-art ResNet network on imagenet`_\n# -  `Train a face generator using Generative Adversarial Networks`_\n# -  `Train a word-level language model using Recurrent LSTM networks`_\n# -  `More examples`_\n# -  `More tutorials`_\n# -  `Discuss PyTorch on the Forums`_\n# -  `Chat with other users on Slack`_\n#\n# .. _Train a state-of-the-art ResNet network on imagenet: https://github.com/pytorch/examples/tree/master/imagenet\n# .. _Train a face generator using Generative Adversarial Networks: https://github.com/pytorch/examples/tree/master/dcgan\n# .. _Train a word-level language model using Recurrent LSTM networks: https://github.com/pytorch/examples/tree/master/word_language_model\n# .. _More examples: https://github.com/pytorch/examples\n# .. _More tutorials: https://github.com/pytorch/tutorials\n# .. _Discuss PyTorch on the Forums: https://discuss.pytorch.org/\n# .. _Chat with other users on Slack: https://pytorch.slack.com/messages/beginner/\n\n'"
Training_a_Classifier/训练分类器.py,1,"b'#%% [markdown]\n# # \xe8\xae\xad\xe7\xbb\x83\xe5\x88\x86\xe7\xb1\xbb\xe5\x99\xa8\n#%% [markdown]\n# \xe7\x9b\xae\xe5\x89\x8d\xe4\xb8\xba\xe6\xad\xa2\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe4\xbb\xa5\xe5\x8f\x8a\xe7\x9c\x8b\xe5\x88\xb0\xe4\xba\x86\xe5\xa6\x82\xe4\xbd\x95\xe5\xae\x9a\xe4\xb9\x89\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x8c\xe8\xae\xa1\xe7\xae\x97\xe6\x8d\x9f\xe5\xa4\xb1\xef\xbc\x8c\xe5\xb9\xb6\xe6\x9b\xb4\xe6\x96\xb0\xe7\xbd\x91\xe7\xbb\x9c\xe7\x9a\x84\xe6\x9d\x83\xe9\x87\x8d\xe3\x80\x82\n# \n# \xe7\x8e\xb0\xe5\x9c\xa8\xe5\x8f\xaf\xe8\x83\xbd\xe4\xbc\x9a\xe6\x83\xb3\xef\xbc\x8c\n#%% [markdown]\n# ## \xe6\x95\xb0\xe6\x8d\xae\xe5\x91\xa2\xef\xbc\x9f\n#%% [markdown]\n# \xe9\x80\x9a\xe5\xb8\xb8\xe6\x9d\xa5\xe8\xaf\xb4\xef\xbc\x8c\xe5\xbd\x93\xe5\xbf\x85\xe9\xa1\xbb\xe5\xa4\x84\xe7\x90\x86\xe5\x9b\xbe\xe5\x83\x8f\xe3\x80\x81\xe6\x96\x87\xe6\x9c\xac\xe3\x80\x81\xe9\x9f\xb3\xe9\xa2\x91\xe6\x88\x96\xe8\xa7\x86\xe9\xa2\x91\xe6\x95\xb0\xe6\x8d\xae\xe6\x97\xb6\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8python\xe6\xa0\x87\xe5\x87\x86\xe5\xba\x93\xe5\xb0\x86\xe6\x95\xb0\xe6\x8d\xae\xe5\x8a\xa0\xe8\xbd\xbd\xe5\x88\xb0numpy\xe6\x95\xb0\xe7\xbb\x84\xe9\x87\x8c\xe3\x80\x82\xe7\x84\xb6\xe5\x90\x8e\xe5\xb0\x86\xe8\xbf\x99\xe4\xb8\xaa\xe6\x95\xb0\xe7\xbb\x84\xe8\xbd\xac\xe5\x8c\x96\xe6\x88\x90`torch.*Tensor`\xe3\x80\x82\n# \n# * \xe5\xaf\xb9\xe4\xba\x8e\xe5\x9b\xbe\xe7\x89\x87\xef\xbc\x8c\xe6\x9c\x89Pillow\xef\xbc\x8cOpenCV\xe7\xad\x89\xe5\x8c\x85\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\n# * \xe5\xaf\xb9\xe4\xba\x8e\xe9\x9f\xb3\xe9\xa2\x91\xef\xbc\x8c\xe6\x9c\x89scipy\xe5\x92\x8clibrosa\xe7\xad\x89\xe5\x8c\x85\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\n# * \xe5\xaf\xb9\xe4\xba\x8e\xe6\x96\x87\xe6\x9c\xac\xef\xbc\x8c\xe4\xb8\x8d\xe7\xae\xa1\xe6\x98\xaf\xe5\x8e\x9f\xe7\x94\x9fpython\xe7\x9a\x84\xe6\x88\x96\xe8\x80\x85\xe6\x98\xaf\xe5\x9f\xba\xe4\xba\x8eCython\xe7\x9a\x84\xe6\x96\x87\xe6\x9c\xac\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8NLTK\xe5\x92\x8cSpaCy\n# \n# \xe7\x89\xb9\xe5\x88\xab\xe5\xaf\xb9\xe4\xba\x8e\xe8\xa7\x86\xe8\xa7\x89\xe6\x96\xb9\xe9\x9d\xa2\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\x88\x9b\xe5\xbb\xba\xe4\xba\x86\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8c\x85\xef\xbc\x8c\xe5\x90\x8d\xe5\xad\x97\xe5\x8f\xab`torchvision`\xef\xbc\x8c\xe5\x85\xb6\xe4\xb8\xad\xe5\x8c\x85\xe5\x90\xab\xe4\xba\x86\xe9\x92\x88\xe5\xaf\xb9Imagenet\xe3\x80\x81CIFAR10\xe3\x80\x81MNIST\xe7\xad\x89\xe5\xb8\xb8\xe7\x94\xa8\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe5\x8a\xa0\xe8\xbd\xbd\xe5\x99\xa8\xef\xbc\x88data loaders\xef\xbc\x89\xef\xbc\x8c\xe8\xbf\x98\xe6\x9c\x89\xe5\xaf\xb9\xe5\x9b\xbe\xe7\x89\x87\xe6\x95\xb0\xe6\x8d\xae\xe5\x8f\x98\xe5\xbd\xa2\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\xef\xbc\x8c\xe5\x8d\xb3`torchvision.datasets`\xe5\x92\x8c`torch.utils.data.DataLoader`\xe3\x80\x82\n# \n# \xe8\xbf\x99\xe6\x8f\x90\xe4\xbe\x9b\xe4\xba\x86\xe6\x9e\x81\xe5\xa4\xa7\xe7\x9a\x84\xe4\xbe\xbf\xe5\x88\xa9\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe9\x81\xbf\xe5\x85\x8d\xe7\xbc\x96\xe5\x86\x99\xe6\xa0\xb7\xe6\x9d\xbf\xe4\xbb\xa3\xe7\xa0\x81\xe3\x80\x82\n# \n# \xe5\x9c\xa8\xe8\xbf\x99\xe4\xb8\xaa\xe6\x95\x99\xe7\xa8\x8b\xe4\xb8\xad\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe4\xbd\xbf\xe7\x94\xa8CIFAR10\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xef\xbc\x8c\xe5\xae\x83\xe6\x9c\x89\xe5\xa6\x82\xe4\xb8\x8b\xe7\x9a\x84\xe5\x88\x86\xe7\xb1\xbb\xef\xbc\x9a\xe2\x80\x9c\xe9\xa3\x9e\xe6\x9c\xba\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe6\xb1\xbd\xe8\xbd\xa6\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe9\xb8\x9f\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe7\x8c\xab\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe9\xb9\xbf\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe7\x8b\x97\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe9\x9d\x92\xe8\x9b\x99\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe9\xa9\xac\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe8\x88\xb9\xe2\x80\x9d\xef\xbc\x8c\xe2\x80\x9c\xe5\x8d\xa1\xe8\xbd\xa6\xe2\x80\x9d\xe7\xad\x89\xe3\x80\x82\xe5\x9c\xa8CIFAR-10\xe9\x87\x8c\xe9\x9d\xa2\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe6\x95\xb0\xe6\x8d\xae\xe5\xa4\xa7\xe5\xb0\x8f\xe6\x98\xaf3x32x32\xef\xbc\x8c\xe5\x8d\xb3\xe4\xb8\x89\xe9\x80\x9a\xe9\x81\x93\xe5\xbd\xa9\xe8\x89\xb2\xe5\x9b\xbe\xef\xbc\x8c\xe5\x9b\xbe\xe7\x89\x87\xe5\xa4\xa7\xe5\xb0\x8f\xe6\x98\xaf32x32\xe5\x83\x8f\xe7\xb4\xa0\xe3\x80\x82\n# \n# ![](assets/cifar10.png)\n#%% [markdown]\n# ## \xe8\xae\xad\xe7\xbb\x83\xe4\xb8\x80\xe4\xb8\xaa\xe5\x9b\xbe\xe7\x89\x87\xe5\x88\x86\xe7\xb1\xbb\xe5\x99\xa8\n#%% [markdown]\n# \xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe6\x8c\x89\xe9\xa1\xba\xe5\xba\x8f\xe5\x81\x9a\xe4\xbb\xa5\xe4\xb8\x8b\xe6\xad\xa5\xe9\xaa\xa4\xef\xbc\x9a\n# \n# 1. \xe9\x80\x9a\xe8\xbf\x87`torchvision`\xe5\x8a\xa0\xe8\xbd\xbdCIFAR10\xe9\x87\x8c\xe9\x9d\xa2\xe7\x9a\x84\xe8\xae\xad\xe7\xbb\x83\xe5\x92\x8c\xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xef\xbc\x8c\xe5\xb9\xb6\xe5\xaf\xb9\xe6\x95\xb0\xe6\x8d\xae\xe8\xbf\x9b\xe8\xa1\x8c\xe6\xa0\x87\xe5\x87\x86\xe5\x8c\x96\n# 2. \xe5\xae\x9a\xe4\xb9\x89\xe5\x8d\xb7\xe7\xa7\xaf\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n# 3. \xe5\xae\x9a\xe4\xb9\x89\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\n# 4. \xe5\x88\xa9\xe7\x94\xa8\xe8\xae\xad\xe7\xbb\x83\xe6\x95\xb0\xe6\x8d\xae\xe8\xae\xad\xe7\xbb\x83\xe7\xbd\x91\xe7\xbb\x9c\n# 5. \xe5\x88\xa9\xe7\x94\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\xe6\xb5\x8b\xe8\xaf\x95\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# ### 1.\xe5\x8a\xa0\xe8\xbd\xbd\xe5\xb9\xb6\xe6\xa0\x87\xe5\x87\x86\xe5\x8c\x96CIFAR10\n#%% [markdown]\n# \xe4\xbd\xbf\xe7\x94\xa8`torchvision`\xe5\x8a\xa0\xe8\xbd\xbdCIFAR10\xe8\xb6\x85\xe7\xba\xa7\xe7\xae\x80\xe5\x8d\x95\xe3\x80\x82\n\n#%%\nimport torch\nimport torchvision\nimport torchvision.transforms as transforms\n\n#%% [markdown]\n# torchvision\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe5\x8a\xa0\xe8\xbd\xbd\xe5\xae\x8c\xe5\x90\x8e\xe7\x9a\x84\xe8\xbe\x93\xe5\x87\xba\xe6\x98\xaf\xe8\x8c\x83\xe5\x9b\xb4\xe5\x9c\xa8[0, 1]\xe4\xb9\x8b\xe9\x97\xb4\xe7\x9a\x84PILImage\xe3\x80\x82\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe5\x85\xb6\xe6\xa0\x87\xe5\x87\x86\xe5\x8c\x96\xe4\xb8\xba\xe8\x8c\x83\xe5\x9b\xb4\xe5\x9c\xa8[-1, 1]\xe4\xb9\x8b\xe9\x97\xb4\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\xe3\x80\x82\n\n#%%\ntransform = transforms.Compose(\n    [transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])\n\ntrainset = torchvision.datasets.CIFAR10(root=\'./data\', train=True, download=True, transform=transform)\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True, num_workers=2)\n\ntestset = torchvision.datasets.CIFAR10(root=\'./data\', train=False, download=True, transform=transform)\ntestloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False, num_workers=2)\n\nclasses = (\'plane\', \'car\', \'bird\', \'cat\',\n           \'deer\', \'dog\', \'frog\', \'horse\', \'ship\', \'truck\')\n\n#%% [markdown]\n# \xe4\xb8\xba\xe4\xba\x86\xe5\xa5\xbd\xe7\x8e\xa9\xef\xbc\x8c\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\xb1\x95\xe7\xa4\xba\xe4\xb8\x80\xe4\xba\x9b\xe8\xae\xad\xe7\xbb\x83\xe6\x95\xb0\xe6\x8d\xae\xe7\x9a\x84\xe5\x9b\xbe\xe7\x89\x87\xe3\x80\x82\n\n#%%\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# functions to show an image\n\n\ndef imshow(img):\n    img = img / 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n\n\n# get some random training images\ndataiter = iter(trainloader)\nimages, labels = dataiter.next()\n\n# show images\nimshow(torchvision.utils.make_grid(images))\n# print labels\nprint(\' \'.join(\'%5s\' % classes[labels[j]] for j in range(4)))\n\n#%% [markdown]\n# ![](assets/sphx_glr_cifar10_tutorial_001.png)\n#%% [markdown]\n# ### 2.\xe5\xae\x9a\xe4\xb9\x89\xe5\x8d\xb7\xe7\xa7\xaf\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# \xe5\xb0\x86\xe4\xb9\x8b\xe5\x89\x8d\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe7\xab\xa0\xe8\x8a\x82\xe5\xae\x9a\xe4\xb9\x89\xe7\x9a\x84\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe6\x8b\xbf\xe8\xbf\x87\xe6\x9d\xa5\xef\xbc\x8c\xe5\xb9\xb6\xe5\xb0\x86\xe5\x85\xb6\xe4\xbf\xae\xe6\x94\xb9\xe6\x88\x90\xe8\xbe\x93\xe5\x85\xa5\xe4\xb8\xba3\xe9\x80\x9a\xe9\x81\x93\xe5\x9b\xbe\xe5\x83\x8f\xef\xbc\x88\xe6\x9b\xbf\xe4\xbb\xa3\xe5\x8e\x9f\xe6\x9d\xa5\xe5\xae\x9a\xe4\xb9\x89\xe7\x9a\x84\xe5\x8d\x95\xe9\x80\x9a\xe9\x81\x93\xe5\x9b\xbe\xe5\x83\x8f\xef\xbc\x89\xe3\x80\x82\n\n#%%\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = x.view(-1, 16 * 5 * 5)\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n\nnet = Net()\n\n#%% [markdown]\n# ### 3.\xe5\xae\x9a\xe4\xb9\x89\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x87\xbd\xe6\x95\xb0\xe5\x92\x8c\xe4\xbc\x98\xe5\x8c\x96\xe5\x99\xa8\n#%% [markdown]\n# \xe6\x88\x91\xe4\xbb\xac\xe4\xbd\xbf\xe7\x94\xa8\xe5\x88\x86\xe7\xb1\xbb\xe7\x9a\x84\xe4\xba\xa4\xe5\x8f\x89\xe7\x86\xb5\xe6\x8d\x9f\xe5\xa4\xb1\xe5\x92\x8c\xe9\x9a\x8f\xe6\x9c\xba\xe6\xa2\xaf\xe5\xba\xa6\xe4\xb8\x8b\xe9\x99\x8d\xef\xbc\x88\xe4\xbd\xbf\xe7\x94\xa8momentum\xef\xbc\x89\xe3\x80\x82\n\n#%%\nimport torch.optim as optim\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)\n\n#%% [markdown]\n# ### 4.\xe8\xae\xad\xe7\xbb\x83\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# \xe4\xba\x8b\xe6\x83\x85\xe5\xbc\x80\xe5\xa7\x8b\xe5\x8f\x98\xe5\xbe\x97\xe6\x9c\x89\xe8\xb6\xa3\xe4\xba\x86\xe3\x80\x82\xe6\x88\x91\xe4\xbb\xac\xe5\x8f\xaa\xe9\x9c\x80\xe8\xa6\x81\xe9\x81\x8d\xe5\x8e\x86\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe8\xbf\xad\xe4\xbb\xa3\xe5\x99\xa8\xef\xbc\x8c\xe5\xb9\xb6\xe4\xb8\x94\xe8\xbe\x93\xe5\x85\xa5\xe2\x80\x9c\xe5\x96\x82\xe2\x80\x9d\xe7\xbb\x99\xe7\xbd\x91\xe7\xbb\x9c\xe5\x92\x8c\xe4\xbc\x98\xe5\x8c\x96\xe5\x87\xbd\xe6\x95\xb0\xe3\x80\x82\n\n#%%\nfor epoch in range(2):  # loop over the dataset multiple times\n\n    running_loss = 0.0\n    for i, data in enumerate(trainloader, 0):\n        # get the inputs\n        inputs, labels = data\n\n        # zero the parameter gradients\n        optimizer.zero_grad()\n\n        # forward + backward + optimize\n        outputs = net(inputs)\n        loss = criterion(outputs, labels)\n        loss.backward()\n        optimizer.step()\n\n        # print statistics\n        running_loss += loss.item()\n        if i % 2000 == 1999:    # print every 2000 mini-batches\n            print(\'[%d, %5d] loss: %.3f\' % (epoch + 1, i + 1, running_loss / 2000))\n            running_loss = 0.0\n\nprint(\'Finished Training\')\n\n#%% [markdown]\n# ### 5.\xe4\xbd\xbf\xe7\x94\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe6\x95\xb0\xe6\x8d\xae\xe6\xb5\x8b\xe8\xaf\x95\xe7\xbd\x91\xe7\xbb\x9c\n#%% [markdown]\n# \xe6\x88\x91\xe4\xbb\xac\xe5\xb7\xb2\xe7\xbb\x8f\xe5\x9c\xa8\xe8\xae\xad\xe7\xbb\x83\xe9\x9b\x86\xe4\xb8\x8a\xe8\xae\xad\xe7\xbb\x83\xe4\xba\x862\xe9\x81\x8d\xe7\xbd\x91\xe7\xbb\x9c\xe3\x80\x82\xe4\xbd\x86\xe6\x98\xaf\xe6\x88\x91\xe4\xbb\xac\xe9\x9c\x80\xe8\xa6\x81\xe6\xa3\x80\xe6\x9f\xa5\xe7\xbd\x91\xe7\xbb\x9c\xe6\x98\xaf\xe5\x90\xa6\xe5\xad\xa6\xe5\x88\xb0\xe4\xba\x86\xe4\xb8\x80\xe4\xba\x9b\xe4\xb8\x9c\xe8\xa5\xbf\xe3\x80\x82\n# \n# \xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe9\x80\x9a\xe8\xbf\x87\xe9\xa2\x84\xe6\xb5\x8b\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe8\xbe\x93\xe5\x87\xba\xe7\x9a\x84\xe6\xa0\x87\xe7\xad\xbe\xe6\x9d\xa5\xe6\xa3\x80\xe6\x9f\xa5\xe8\xbf\x99\xe4\xb8\xaa\xe9\x97\xae\xe9\xa2\x98\xef\xbc\x8c\xe5\xb9\xb6\xe5\x92\x8c\xe6\xad\xa3\xe7\xa1\xae\xe6\xa0\xb7\xe6\x9c\xac\xe8\xbf\x9b\xe8\xa1\x8c\xef\xbc\x88ground-truth\xef\xbc\x89\xe5\xaf\xb9\xe6\xaf\x94\xe3\x80\x82\xe5\xa6\x82\xe6\x9e\x9c\xe9\xa2\x84\xe6\xb5\x8b\xe6\x98\xaf\xe6\xad\xa3\xe7\xa1\xae\xe7\x9a\x84\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe6\xa0\xb7\xe6\x9c\xac\xe6\xb7\xbb\xe5\x8a\xa0\xe5\x88\xb0\xe6\xad\xa3\xe7\xa1\xae\xe9\xa2\x84\xe6\xb5\x8b\xe7\x9a\x84\xe5\x88\x97\xe8\xa1\xa8\xe4\xb8\xad\xe3\x80\x82\n# \n# ok\xef\xbc\x8c\xe7\xac\xac\xe4\xb8\x80\xe6\xad\xa5\xe3\x80\x82\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe6\x98\xbe\xe7\xa4\xba\xe6\xb5\x8b\xe8\xaf\x95\xe9\x9b\x86\xe4\xb8\xad\xe7\x9a\x84\xe5\x9b\xbe\xe5\x83\x8f\xe6\x9d\xa5\xe7\x86\x9f\xe6\x82\x89\xe4\xb8\x80\xe4\xb8\x8b\xe3\x80\x82\n\n#%%\ndataiter = iter(testloader)\nimages, labels = dataiter.next()\n\n# print images\nimshow(torchvision.utils.make_grid(images))\nprint(\'GroundTruth: \', \' \'.join(\'%5s\' % classes[labels[j]] for j in range(4)))\n\n#%% [markdown]\n# ok\xef\xbc\x8c\xe7\x8e\xb0\xe5\x9c\xa8\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe7\x9c\x8b\xe7\x9c\x8b\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe8\xae\xa4\xe4\xb8\xba\xe4\xb8\x8a\xe9\x9d\xa2\xe7\x9a\x84\xe4\xbe\x8b\xe5\xad\x90\xe6\x98\xaf:\n\n#%%\noutputs = net(images)\n\n#%% [markdown]\n# \xe8\xbe\x93\xe5\x87\xba\xe6\x98\xaf10\xe4\xb8\xaa\xe7\xb1\xbb\xe5\x88\xab\xe7\x9a\x84\xe9\x87\x8f\xe5\x80\xbc\xe3\x80\x82\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb1\xbb\xe7\x9a\x84\xe5\x80\xbc\xe8\xb6\x8a\xe9\xab\x98\xef\xbc\x8c\xe7\xbd\x91\xe7\xbb\x9c\xe5\xb0\xb1\xe8\xb6\x8a\xe8\xae\xa4\xe4\xb8\xba\xe8\xbf\x99\xe4\xb8\xaa\xe5\x9b\xbe\xe5\x83\x8f\xe5\xb1\x9e\xe4\xba\x8e\xe8\xbf\x99\xe4\xb8\xaa\xe7\x89\xb9\xe5\xae\x9a\xe7\x9a\x84\xe7\xb1\xbb\xe3\x80\x82\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe5\xbe\x97\xe5\x88\xb0\xe6\x9c\x80\xe9\xab\x98\xe9\x87\x8f\xe5\x80\xbc\xe7\x9a\x84\xe4\xb8\x8b\xe6\xa0\x87/\xe7\xb4\xa2\xe5\xbc\x95\xef\xbc\x9b\n\n#%%\n_, predicted = torch.max(outputs, 1)\n\nprint(\'Predicted: \', \' \'.join(\'%5s\' % classes[predicted[j]] for j in range(4)))\n\n#%% [markdown]\n# \xe7\xbb\x93\xe6\x9e\x9c\xe8\xbf\x98\xe4\xb8\x8d\xe9\x94\x99\xe3\x80\x82\n# \n# \xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe7\x9c\x8b\xe7\x9c\x8b\xe7\xbd\x91\xe7\xbb\x9c\xe5\x9c\xa8\xe6\x95\xb4\xe4\xb8\xaa\xe6\x95\xb0\xe6\x8d\xae\xe9\x9b\x86\xe4\xb8\x8a\xe8\xa1\xa8\xe7\x8e\xb0\xe7\x9a\x84\xe6\x80\x8e\xe4\xb9\x88\xe6\xa0\xb7\xe3\x80\x82\n\n#%%\ncorrect = 0\ntotal = 0\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net(images)\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n\nprint(\'Accuracy of the network on the 10000 test images: %d %%\' % (\n    100 * correct / total))\n\n#%% [markdown]\n# \xe8\xbf\x99\xe6\xaf\x94\xe9\x9a\x8f\xe6\x9c\xba\xe9\x80\x89\xe5\x8f\x96\xef\xbc\x88\xe5\x8d\xb3\xe4\xbb\x8e10\xe4\xb8\xaa\xe7\xb1\xbb\xe4\xb8\xad\xe9\x9a\x8f\xe6\x9c\xba\xe9\x80\x89\xe6\x8b\xa9\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb1\xbb\xef\xbc\x8c\xe6\xad\xa3\xe7\xa1\xae\xe7\x8e\x87\xe6\x98\xaf10%\xef\xbc\x89\xe8\xa6\x81\xe5\xa5\xbd\xe5\xbe\x88\xe5\xa4\x9a\xe3\x80\x82\xe7\x9c\x8b\xe6\x9d\xa5\xe7\xbd\x91\xe7\xbb\x9c\xe7\xa1\xae\xe5\xae\x9e\xe5\xad\xa6\xe5\x88\xb0\xe4\xba\x86\xe4\xb8\x80\xe4\xba\x9b\xe4\xb8\x9c\xe8\xa5\xbf\xe3\x80\x82\n# \n# \xe9\x82\xa3\xe4\xb9\x88\xe5\x93\xaa\xe4\xba\x9b\xe6\x98\xaf\xe8\xa1\xa8\xe7\x8e\xb0\xe5\xa5\xbd\xe7\x9a\x84\xe7\xb1\xbb\xe5\x91\xa2\xef\xbc\x9f\xe5\x93\xaa\xe4\xba\x9b\xe6\x98\xaf\xe8\xa1\xa8\xe7\x8e\xb0\xe7\x9a\x84\xe5\xb7\xae\xe7\x9a\x84\xe7\xb1\xbb\xe5\x91\xa2\xef\xbc\x9f\n\n#%%\nclass_correct = list(0. for i in range(10))\nclass_total = list(0. for i in range(10))\nwith torch.no_grad():\n    for data in testloader:\n        images, labels = data\n        outputs = net(images)\n        _, predicted = torch.max(outputs, 1)\n        c = (predicted == labels).squeeze()\n        for i in range(4):\n            label = labels[i]\n            class_correct[label] += c[i].item()\n            class_total[label] += 1\n\n\nfor i in range(10):\n    print(\'Accuracy of %5s : %2d %%\' % (\n        classes[i], 100 * class_correct[i] / class_total[i]))\n\n#%% [markdown]\n# ok\xef\xbc\x8c\xe6\x8e\xa5\xe4\xb8\x8b\xe6\x9d\xa5\xe5\x91\xa2\xef\xbc\x9f\n# \n# \xe6\x80\x8e\xe4\xb9\x88\xe5\x9c\xa8GPU\xe4\xb8\x8a\xe8\xbf\x90\xe8\xa1\x8c\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe5\x91\xa2\xef\xbc\x9f\n#%% [markdown]\n# ## \xe5\x9c\xa8GPU\xe4\xb8\x8a\xe8\xae\xad\xe7\xbb\x83\n#%% [markdown]\n# \xe4\xb8\x8e\xe5\xb0\x86\xe4\xb8\x80\xe4\xb8\xaa\xe5\xbc\xa0\xe9\x87\x8f\xe4\xbc\xa0\xe9\x80\x92\xe7\xbb\x99GPU\xe4\xb8\x80\xe6\xa0\xb7\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe8\xbf\x99\xe6\xa0\xb7\xe5\xb0\x86\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe8\xbd\xac\xe7\xa7\xbb\xe5\x88\xb0GPU\xe4\xb8\x8a\xe3\x80\x82 \n# \n# \xe5\xa6\x82\xe6\x9e\x9c\xe6\x88\x91\xe4\xbb\xac\xe6\x9c\x89cuda\xe5\x8f\xaf\xe7\x94\xa8\xe7\x9a\x84\xe8\xaf\x9d\xef\xbc\x8c\xe8\xae\xa9\xe6\x88\x91\xe4\xbb\xac\xe9\xa6\x96\xe5\x85\x88\xe5\xae\x9a\xe4\xb9\x89\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe8\xae\xbe\xe5\xa4\x87\xe4\xb8\xba\xe5\x8f\xaf\xe8\xa7\x81cuda\xe8\xae\xbe\xe5\xa4\x87\xef\xbc\x9a\n\n#%%\ndevice = torch.device(""cuda:0"" if torch.cuda.is_available() else ""cpu"")\n\n# Assuming that we are on a CUDA machine, this should print a CUDA device:\n\nprint(device)\n\n#%% [markdown]\n# \xe6\x9c\xac\xe8\x8a\x82\xe7\x9a\x84\xe5\x85\xb6\xe4\xbd\x99\xe9\x83\xa8\xe5\x88\x86\xe5\x81\x87\xe8\xae\xbe`device`\xe6\x98\xafCUDA\xe3\x80\x82\n# \n# \xe7\x84\xb6\xe5\x90\x8e\xe8\xbf\x99\xe4\xba\x9b\xe6\x96\xb9\xe6\xb3\x95\xe5\xb0\x86\xe9\x80\x92\xe5\xbd\x92\xe9\x81\x8d\xe5\x8e\x86\xe6\x89\x80\xe6\x9c\x89\xe6\xa8\xa1\xe5\x9d\x97\xef\xbc\x8c\xe5\xb9\xb6\xe5\xb0\x86\xe5\xae\x83\xe4\xbb\xac\xe7\x9a\x84\xe5\x8f\x82\xe6\x95\xb0\xe5\x92\x8c\xe7\xbc\x93\xe5\x86\xb2\xe5\x8c\xba\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xbaCUDA\xe5\xbc\xa0\xe9\x87\x8f\xef\xbc\x9a\n\n#%%\nnet.to(device)\n\n#%% [markdown]\n# \xe8\xaf\xb7\xe8\xae\xb0\xe4\xbd\x8f\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe4\xb8\x8d\xe5\xbe\x97\xe4\xb8\x8d\xe5\xb0\x86\xe8\xbe\x93\xe5\x85\xa5\xe5\x92\x8c\xe7\x9b\xae\xe6\xa0\x87\xe5\x9c\xa8\xe6\xaf\x8f\xe4\xb8\x80\xe6\xad\xa5\xe9\x83\xbd\xe9\x80\x81\xe5\x85\xa5GPU\xef\xbc\x9a\n\n#%%\ninputs, labels = inputs.to(device), labels.to(device)\n\n#%% [markdown]\n# \xe4\xb8\xba\xe4\xbb\x80\xe4\xb9\x88\xe6\x88\x91\xe4\xbb\xac\xe6\x84\x9f\xe5\x8f\x97\xe4\xb8\x8d\xe5\x88\xb0\xe4\xb8\x8eCPU\xe7\x9b\xb8\xe6\xaf\x94\xe7\x9a\x84\xe5\xb7\xa8\xe5\xa4\xa7\xe5\x8a\xa0\xe9\x80\x9f\xef\xbc\x9f\xe5\x9b\xa0\xe4\xb8\xba\xe6\x88\x91\xe4\xbb\xac\xe7\x9a\x84\xe7\xbd\x91\xe7\xbb\x9c\xe5\xae\x9e\xe5\x9c\xa8\xe6\x98\xaf\xe5\xa4\xaa\xe5\xb0\x8f\xe4\xba\x86\xe3\x80\x82\n# \n# \xe5\xb0\x9d\xe8\xaf\x95\xe4\xb8\x80\xe4\xb8\x8b\xef\xbc\x9a\xe5\x8a\xa0\xe5\xae\xbd\xe4\xbd\xa0\xe7\x9a\x84\xe7\xbd\x91\xe7\xbb\x9c\xef\xbc\x88\xe6\xb3\xa8\xe6\x84\x8f\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa`nn.Conv2d`\xe7\x9a\x84\xe7\xac\xac\xe4\xba\x8c\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0\xe5\x92\x8c\xe7\xac\xac\xe4\xba\x8c\xe4\xb8\xaa`nn.Conv2d`\xe7\x9a\x84\xe7\xac\xac\xe4\xb8\x80\xe4\xb8\xaa\xe5\x8f\x82\xe6\x95\xb0\xe8\xa6\x81\xe7\x9b\xb8\xe5\x90\x8c\xef\xbc\x89\xef\xbc\x8c\xe7\x9c\x8b\xe7\x9c\x8b\xe8\x83\xbd\xe8\x8e\xb7\xe5\xbe\x97\xe5\xa4\x9a\xe5\xb0\x91\xe5\x8a\xa0\xe9\x80\x9f\xe3\x80\x82\n# \n# \xe5\xb7\xb2\xe5\xae\x9e\xe7\x8e\xb0\xe7\x9a\x84\xe7\x9b\xae\xe6\xa0\x87\xef\xbc\x9a\n# \n# * \xe5\x9c\xa8\xe6\x9b\xb4\xe9\xab\x98\xe5\xb1\x82\xe6\xac\xa1\xe4\xb8\x8a\xe7\x90\x86\xe8\xa7\xa3PyTorch\xe7\x9a\x84Tensor\xe5\xba\x93\xe5\x92\x8c\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\n# * \xe8\xae\xad\xe7\xbb\x83\xe4\xb8\x80\xe4\xb8\xaa\xe5\xb0\x8f\xe7\x9a\x84\xe7\xa5\x9e\xe7\xbb\x8f\xe7\xbd\x91\xe7\xbb\x9c\xe5\x81\x9a\xe5\x9b\xbe\xe7\x89\x87\xe5\x88\x86\xe7\xb1\xbb\n#%% [markdown]\n# ## \xe5\x9c\xa8\xe5\xa4\x9aGPU\xe4\xb8\x8a\xe8\xae\xad\xe7\xbb\x83\n#%% [markdown]\n# \xe5\xa6\x82\xe6\x9e\x9c\xe5\xb8\x8c\xe6\x9c\x9b\xe4\xbd\xbf\xe7\x94\xa8\xe6\x82\xa8\xe6\x89\x80\xe6\x9c\x89GPU\xe8\x8e\xb7\xe5\xbe\x97**\xe6\x9b\xb4\xe5\xa4\xa7\xe7\x9a\x84**\xe5\x8a\xa0\xe9\x80\x9f\xef\xbc\x8c\xe8\xaf\xb7\xe6\x9f\xa5\xe7\x9c\x8b[Optional: Data Parallelism](https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html)\xe3\x80\x82\n#%% [markdown]\n# ## \xe6\x8e\xa5\xe4\xb8\x8b\xe6\x9d\xa5\xe8\xa6\x81\xe5\x81\x9a\xe4\xbb\x80\xe4\xb9\x88\xef\xbc\x9f\n#%% [markdown]\n# * [Train neural nets to play video games](https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html)\n# * [Train a state-of-the-art ResNet network on imagenet](https://github.com/pytorch/examples/tree/master/imagenet)\n# * [Train a face generator using Generative Adversarial Networks](https://github.com/pytorch/examples/tree/master/dcgan)\n# * [Train a word-level language model using Recurrent LSTM networks](https://github.com/pytorch/examples/tree/master/word_language_model)\n# * [More examples](https://github.com/pytorch/examples)\n# * [More tutorials](https://github.com/pytorch/tutorials)\n# * [Discuss PyTorch on the Forums](https://discuss.pytorch.org/)\n# * [Chat with other users on Slack](https://pytorch.slack.com/messages/beginner/)\n\n#%%\n\n\n\n'"
What_is_PyTorch/tensor_tutorial.py,2,"b'# -*- coding: utf-8 -*-\n""""""\nWhat is PyTorch?\n================\n\nIt\xe2\x80\x99s a Python-based scientific computing package targeted at two sets of\naudiences:\n\n-  A replacement for NumPy to use the power of GPUs\n-  a deep learning research platform that provides maximum flexibility\n   and speed\n\nGetting Started\n---------------\n\nTensors\n^^^^^^^\n\nTensors are similar to NumPy\xe2\x80\x99s ndarrays, with the addition being that\nTensors can also be used on a GPU to accelerate computing.\n""""""\n\nfrom __future__ import print_function\nimport torch\n\n###############################################################\n# Construct a 5x3 matrix, uninitialized:\n\nx = torch.empty(5, 3)\nprint(x)\n\n###############################################################\n# Construct a randomly initialized matrix:\n\nx = torch.rand(5, 3)\nprint(x)\n\n###############################################################\n# Construct a matrix filled zeros and of dtype long:\n\nx = torch.zeros(5, 3, dtype=torch.long)\nprint(x)\n\n###############################################################\n# Construct a tensor directly from data:\n\nx = torch.tensor([5.5, 3])\nprint(x)\n\n###############################################################\n# or create a tensor based on an existing tensor. These methods\n# will reuse properties of the input tensor, e.g. dtype, unless\n# new values are provided by user\n\nx = x.new_ones(5, 3, dtype=torch.double)      # new_* methods take in sizes\nprint(x)\n\nx = torch.randn_like(x, dtype=torch.float)    # override dtype!\nprint(x)                                      # result has the same size\n\n###############################################################\n# Get its size:\n\nprint(x.size())\n\n###############################################################\n# .. note::\n#     ``torch.Size`` is in fact a tuple, so it supports all tuple operations.\n#\n# Operations\n# ^^^^^^^^^^\n# There are multiple syntaxes for operations. In the following\n# example, we will take a look at the addition operation.\n#\n# Addition: syntax 1\ny = torch.rand(5, 3)\nprint(x + y)\n\n###############################################################\n# Addition: syntax 2\n\nprint(torch.add(x, y))\n\n###############################################################\n# Addition: providing an output tensor as argument\nresult = torch.empty(5, 3)\ntorch.add(x, y, out=result)\nprint(result)\n\n###############################################################\n# Addition: in-place\n\n# adds x to y\ny.add_(x)\nprint(y)\n\n###############################################################\n# .. note::\n#     Any operation that mutates a tensor in-place is post-fixed with an ``_``.\n#     For example: ``x.copy_(y)``, ``x.t_()``, will change ``x``.\n#\n# You can use standard NumPy-like indexing with all bells and whistles!\n\nprint(x[:, 1])\n\n###############################################################\n# Resizing: If you want to resize/reshape tensor, you can use ``torch.view``:\nx = torch.randn(4, 4)\ny = x.view(16)\nz = x.view(-1, 8)  # the size -1 is inferred from other dimensions\nprint(x.size(), y.size(), z.size())\n\n###############################################################\n# If you have a one element tensor, use ``.item()`` to get the value as a\n# Python number\nx = torch.randn(1)\nprint(x)\nprint(x.item())\n\n###############################################################\n# **Read later:**\n#\n#\n#   100+ Tensor operations, including transposing, indexing, slicing,\n#   mathematical operations, linear algebra, random numbers, etc.,\n#   are described\n#   `here <https://pytorch.org/docs/torch>`_.\n#\n# NumPy Bridge\n# ------------\n#\n# Converting a Torch Tensor to a NumPy array and vice versa is a breeze.\n#\n# The Torch Tensor and NumPy array will share their underlying memory\n# locations, and changing one will change the other.\n#\n# Converting a Torch Tensor to a NumPy Array\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\na = torch.ones(5)\nprint(a)\n\n###############################################################\n#\n\nb = a.numpy()\nprint(b)\n\n###############################################################\n# See how the numpy array changed in value.\n\na.add_(1)\nprint(a)\nprint(b)\n\n###############################################################\n# Converting NumPy Array to Torch Tensor\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n# See how changing the np array changed the Torch Tensor automatically\n\nimport numpy as np\na = np.ones(5)\nb = torch.from_numpy(a)\nnp.add(a, 1, out=a)\nprint(a)\nprint(b)\n\n###############################################################\n# All the Tensors on the CPU except a CharTensor support converting to\n# NumPy and back.\n#\n# CUDA Tensors\n# ------------\n#\n# Tensors can be moved onto any device using the ``.to`` method.\n\n# let us run this cell only if CUDA is available\n# We will use ``torch.device`` objects to move tensors in and out of GPU\nif torch.cuda.is_available():\n    device = torch.device(""cuda"")          # a CUDA device object\n    y = torch.ones_like(x, device=device)  # directly create a tensor on GPU\n    x = x.to(device)                       # or just use strings ``.to(""cuda"")``\n    z = x + y\n    print(z)\n    print(z.to(""cpu"", torch.double))       # ``.to`` can also change dtype together!\n'"
What_is_PyTorch/什么是PyTorch.py,2,"b'#%% [markdown]\n# >\xe5\xae\x8c\xe6\x95\xb4\xe9\xa1\xb9\xe7\x9b\xae\xe5\x9c\xb0\xe5\x9d\x80\xef\xbc\x9ahttps://github.com/bat67/Deep-Learning-with-PyTorch-A-60-Minute-Blitz-cn \xef\xbc\x8c\n# \xe5\x98\xa4\xe5\x98\xa4\xe5\x98\xa4\xe6\xb1\x82star~\xef\xbc\x8c\xe6\x9c\x80\xe6\x96\xb0\xe7\x89\x88\xe4\xb9\x9f\xe4\xbc\x9a\xe9\xa6\x96\xe5\x85\x88\xe6\x9b\xb4\xe6\x96\xb0\xe5\x9c\xa8github\xe4\xb8\x8a\n# \xe6\x9c\x89\xe8\xaf\xaf\xe7\x9a\x84\xe5\x9c\xb0\xe6\x96\xb9\xe6\x8b\x9c\xe6\x89\x98\xe5\xa4\xa7\xe5\xae\xb6\xe6\x8c\x87\xe5\x87\xba~\n#%% [markdown]\n# # \xe4\xbb\x80\xe4\xb9\x88\xe6\x98\xafPyTorch\xef\xbc\x9f\n#%% [markdown]\n# PyTorch\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe5\x9f\xba\xe4\xba\x8epython\xe7\x9a\x84\xe7\xa7\x91\xe5\xad\xa6\xe8\xae\xa1\xe7\xae\x97\xe5\x8c\x85\xef\xbc\x8c\xe4\xb8\xbb\xe8\xa6\x81\xe9\x92\x88\xe5\xaf\xb9\xe4\xb8\xa4\xe7\xb1\xbb\xe4\xba\xba\xe7\xbe\xa4\xef\xbc\x9a\n# \n# * \xe4\xbd\x9c\xe4\xb8\xbaNumPy\xe7\x9a\x84\xe6\x9b\xbf\xe4\xbb\xa3\xe5\x93\x81\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x88\xa9\xe7\x94\xa8GPU\xe7\x9a\x84\xe6\x80\xa7\xe8\x83\xbd\xe8\xbf\x9b\xe8\xa1\x8c\xe8\xae\xa1\xe7\xae\x97\n# * \xe4\xbd\x9c\xe4\xb8\xba\xe4\xb8\x80\xe4\xb8\xaa\xe9\xab\x98\xe7\x81\xb5\xe6\xb4\xbb\xe6\x80\xa7\xe3\x80\x81\xe9\x80\x9f\xe5\xba\xa6\xe5\xbf\xab\xe7\x9a\x84\xe6\xb7\xb1\xe5\xba\xa6\xe5\xad\xa6\xe4\xb9\xa0\xe5\xb9\xb3\xe5\x8f\xb0\n#%% [markdown]\n# ## 1 \xe5\x85\xa5\xe9\x97\xa8\n#%% [markdown]\n# ### 1.1 \xe5\xbc\xa0\xe9\x87\x8f\n#%% [markdown]\n# `Tensor`\xef\xbc\x88\xe5\xbc\xa0\xe9\x87\x8f\xef\xbc\x89\xe7\xb1\xbb\xe4\xbc\xbc\xe4\xba\x8e`NumPy`\xe7\x9a\x84`ndarray`\xef\xbc\x8c\xe4\xbd\x86\xe8\xbf\x98\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x9c\xa8GPU\xe4\xb8\x8a\xe4\xbd\xbf\xe7\x94\xa8\xe6\x9d\xa5\xe5\x8a\xa0\xe9\x80\x9f\xe8\xae\xa1\xe7\xae\x97\xe3\x80\x82\n\n#%%\nfrom __future__ import print_function\nimport torch\n\n#%% [markdown]\n# \xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe6\xb2\xa1\xe6\x9c\x89\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe7\x9a\x845*3\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x9a\n\n#%%\nx = torch.empty(5, 3)\nprint(x)\n\n#%% [markdown]\n# \xe5\x88\x9b\xe5\xbb\xba\xe4\xb8\x80\xe4\xb8\xaa\xe9\x9a\x8f\xe6\x9c\xba\xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe7\x9f\xa9\xe9\x98\xb5\xef\xbc\x9a\n\n#%%\nx = torch.rand(5, 3)\nprint(x)\n\n#%% [markdown]\n# \xe6\x9e\x84\xe9\x80\xa0\xe4\xb8\x80\xe4\xb8\xaa\xe5\xa1\xab\xe6\xbb\xa10\xe4\xb8\x94\xe6\x95\xb0\xe6\x8d\xae\xe7\xb1\xbb\xe5\x9e\x8b\xe4\xb8\xba`long`\xe7\x9a\x84\xe7\x9f\xa9\xe9\x98\xb5:\n\n#%%\nx = torch.zeros(5, 3, dtype=torch.long)\nprint(x)\n\n#%% [markdown]\n# \xe7\x9b\xb4\xe6\x8e\xa5\xe4\xbb\x8e\xe6\x95\xb0\xe6\x8d\xae\xe6\x9e\x84\xe9\x80\xa0\xe5\xbc\xa0\xe9\x87\x8f\xef\xbc\x9a\n\n#%%\nx = torch.tensor([5.5, 3])\nprint(x)\n\n#%% [markdown]\n# \xe6\x88\x96\xe8\x80\x85\xe6\xa0\xb9\xe6\x8d\xae\xe5\xb7\xb2\xe6\x9c\x89\xe7\x9a\x84tensor\xe5\xbb\xba\xe7\xab\x8b\xe6\x96\xb0\xe7\x9a\x84tensor\xe3\x80\x82\xe9\x99\xa4\xe9\x9d\x9e\xe7\x94\xa8\xe6\x88\xb7\xe6\x8f\x90\xe4\xbe\x9b\xe6\x96\xb0\xe7\x9a\x84\xe5\x80\xbc\xef\xbc\x8c\xe5\x90\xa6\xe5\x88\x99\xe8\xbf\x99\xe4\xba\x9b\xe6\x96\xb9\xe6\xb3\x95\xe5\xb0\x86\xe9\x87\x8d\xe7\x94\xa8\xe8\xbe\x93\xe5\x85\xa5\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe5\xb1\x9e\xe6\x80\xa7\xef\xbc\x8c\xe4\xbe\x8b\xe5\xa6\x82dtype\xe7\xad\x89\xef\xbc\x9a\n\n#%%\nx = x.new_ones(5, 3, dtype=torch.double)      # new_* methods take in sizes\nprint(x)\n\nx = torch.randn_like(x, dtype=torch.float)    # override dtype!\nprint(x)                                      # result has the same size\n\n#%% [markdown]\n# \xe8\x8e\xb7\xe5\x8f\x96\xe5\xae\x83\xe7\x9a\x84\xe5\xbd\xa2\xe7\x8a\xb6\xef\xbc\x9a\n\n#%%\nprint(x.size())\n\n#%% [markdown]\n# > **\xe6\xb3\xa8\xe6\x84\x8f**\xef\xbc\x9a\n# >\n# > `torch.Size`\xe6\x9c\xac\xe8\xb4\xa8\xe4\xb8\x8a\xe8\xbf\x98\xe6\x98\xaf`tuple`\xef\xbc\x8c\xe6\x89\x80\xe4\xbb\xa5\xe6\x94\xaf\xe6\x8c\x81tuple\xe7\x9a\x84\xe4\xb8\x80\xe5\x88\x87\xe6\x93\x8d\xe4\xbd\x9c\xe3\x80\x82\n#%% [markdown]\n# ### 1.2 \xe8\xbf\x90\xe7\xae\x97\n#%% [markdown]\n# \xe4\xb8\x80\xe7\xa7\x8d\xe8\xbf\x90\xe7\xae\x97\xe6\x9c\x89\xe5\xa4\x9a\xe7\xa7\x8d\xe8\xaf\xad\xe6\xb3\x95\xe3\x80\x82\xe5\x9c\xa8\xe4\xb8\x8b\xe9\x9d\xa2\xe7\x9a\x84\xe7\xa4\xba\xe4\xbe\x8b\xe4\xb8\xad\xef\xbc\x8c\xe6\x88\x91\xe4\xbb\xac\xe5\xb0\x86\xe7\xa0\x94\xe7\xa9\xb6\xe5\x8a\xa0\xe6\xb3\x95\xe8\xbf\x90\xe7\xae\x97\xe3\x80\x82\n# \n# \xe5\x8a\xa0\xe6\xb3\x95\xef\xbc\x9a\xe5\xbd\xa2\xe5\xbc\x8f\xe4\xb8\x80\n\n#%%\ny = torch.rand(5, 3)\nprint(x + y)\n\n#%% [markdown]\n# \xe5\x8a\xa0\xe6\xb3\x95\xef\xbc\x9a\xe5\xbd\xa2\xe5\xbc\x8f\xe4\xba\x8c\n\n#%%\nprint(torch.add(x, y))\n\n#%% [markdown]\n# \xe5\x8a\xa0\xe6\xb3\x95\xef\xbc\x9a\xe7\xbb\x99\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaa\xe8\xbe\x93\xe5\x87\xba\xe5\xbc\xa0\xe9\x87\x8f\xe4\xbd\x9c\xe4\xb8\xba\xe5\x8f\x82\xe6\x95\xb0\n\n#%%\nresult = torch.empty(5, 3)\ntorch.add(x, y, out=result)\nprint(result)\n\n#%% [markdown]\n# \xe5\x8a\xa0\xe6\xb3\x95\xef\xbc\x9a\xe5\x8e\x9f\xe4\xbd\x8d/\xe5\x8e\x9f\xe5\x9c\xb0\xe6\x93\x8d\xe4\xbd\x9c\xef\xbc\x88in-place\xef\xbc\x89\n\n#%%\n# adds x to y\ny.add_(x)\nprint(y)\n\n#%% [markdown]\n# >\xe6\xb3\xa8\xe6\x84\x8f\xef\xbc\x9a\n# >\n# >\xe4\xbb\xbb\xe4\xbd\x95\xe4\xb8\x80\xe4\xb8\xaain-place\xe6\x94\xb9\xe5\x8f\x98\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\xe5\x90\x8e\xe9\x9d\xa2\xe9\x83\xbd\xe5\x9b\xba\xe5\xae\x9a\xe4\xb8\x80\xe4\xb8\xaa`_`\xe3\x80\x82\xe4\xbe\x8b\xe5\xa6\x82`x.copy_(y)`\xe3\x80\x81`x.t_()`\xe5\xb0\x86\xe6\x9b\xb4\xe6\x94\xb9x\n# \n#%% [markdown]\n# \xe4\xb9\x9f\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8\xe5\x83\x8f\xe6\xa0\x87\xe5\x87\x86\xe7\x9a\x84NumPy\xe4\xb8\x80\xe6\xa0\xb7\xe7\x9a\x84\xe5\x90\x84\xe7\xa7\x8d\xe7\xb4\xa2\xe5\xbc\x95\xe6\x93\x8d\xe4\xbd\x9c\xef\xbc\x9a\n\n#%%\nprint(x[:, 1])\n\n#%% [markdown]\n# \xe6\x94\xb9\xe5\x8f\x98\xe5\xbd\xa2\xe7\x8a\xb6\xef\xbc\x9a\xe5\xa6\x82\xe6\x9e\x9c\xe6\x83\xb3\xe6\x94\xb9\xe5\x8f\x98\xe5\xbd\xa2\xe7\x8a\xb6\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8`torch.view`\n\n#%%\nx = torch.randn(4, 4)\ny = x.view(16)\nz = x.view(-1, 8)  # the size -1 is inferred from other dimensions\nprint(x.size(), y.size(), z.size())\n\n#%% [markdown]\n# \xe5\xa6\x82\xe6\x9e\x9c\xe6\x98\xaf\xe4\xbb\x85\xe5\x8c\x85\xe5\x90\xab\xe4\xb8\x80\xe4\xb8\xaa\xe5\x85\x83\xe7\xb4\xa0\xe7\x9a\x84tensor\xef\xbc\x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8`.item()`\xe6\x9d\xa5\xe5\xbe\x97\xe5\x88\xb0\xe5\xaf\xb9\xe5\xba\x94\xe7\x9a\x84python\xe6\x95\xb0\xe5\x80\xbc\n\n#%%\nx = torch.randn(1)\nprint(x)\nprint(x.item())\n\n#%% [markdown]\n# >\xe5\x90\x8e\xe7\xbb\xad\xe9\x98\x85\xe8\xaf\xbb\xef\xbc\x9a\n# >\n# >\xe8\xb6\x85\xe8\xbf\x87100\xe4\xb8\xadtensor\xe7\x9a\x84\xe8\xbf\x90\xe7\xae\x97\xe6\x93\x8d\xe4\xbd\x9c\xef\xbc\x8c\xe5\x8c\x85\xe6\x8b\xac\xe8\xbd\xac\xe7\xbd\xae\xef\xbc\x8c\xe7\xb4\xa2\xe5\xbc\x95\xef\xbc\x8c\xe5\x88\x87\xe7\x89\x87\xef\xbc\x8c\xe6\x95\xb0\xe5\xad\xa6\xe8\xbf\x90\xe7\xae\x97\xef\xbc\x8c\n# \xe7\xba\xbf\xe6\x80\xa7\xe4\xbb\xa3\xe6\x95\xb0\xef\xbc\x8c\xe9\x9a\x8f\xe6\x9c\xba\xe6\x95\xb0\xe7\xad\x89\xef\xbc\x8c\xe5\x85\xb7\xe4\xbd\x93\xe8\xae\xbf\xe9\x97\xae[\xe8\xbf\x99\xe9\x87\x8c](https://pytorch.org/docs/stable/torch.html)\n#%% [markdown]\n# ## 2 NumPy\xe6\xa1\xa5\n#%% [markdown]\n# \xe5\xb0\x86\xe4\xb8\x80\xe4\xb8\xaaTorch\xe5\xbc\xa0\xe9\x87\x8f\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xba\xe4\xb8\x80\xe4\xb8\xaaNumPy\xe6\x95\xb0\xe7\xbb\x84\xe6\x98\xaf\xe8\xbd\xbb\xe8\x80\x8c\xe6\x98\x93\xe4\xb8\xbe\xe7\x9a\x84\xe4\xba\x8b\xe6\x83\x85\xef\xbc\x8c\xe5\x8f\x8d\xe4\xb9\x8b\xe4\xba\xa6\xe7\x84\xb6\xe3\x80\x82\n# \n# Torch\xe5\xbc\xa0\xe9\x87\x8f\xe5\x92\x8cNumPy\xe6\x95\xb0\xe7\xbb\x84\xe5\xb0\x86\xe5\x85\xb1\xe4\xba\xab\xe5\xae\x83\xe4\xbb\xac\xe7\x9a\x84\xe5\xba\x95\xe5\xb1\x82\xe5\x86\x85\xe5\xad\x98\xe4\xbd\x8d\xe7\xbd\xae\xef\xbc\x8c\xe6\x9b\xb4\xe6\x94\xb9\xe4\xb8\x80\xe4\xb8\xaa\xe5\xb0\x86\xe6\x9b\xb4\xe6\x94\xb9\xe5\x8f\xa6\xe4\xb8\x80\xe4\xb8\xaa\xe3\x80\x82\n# \n#%% [markdown]\n# ### 2.1 \xe5\xb0\x86torch\xe7\x9a\x84Tensor\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xbaNumPy\xe6\x95\xb0\xe7\xbb\x84\n\n#%%\na = torch.ones(5)\nprint(a)\n\n\n#%%\nb = a.numpy()\nprint(b)\n\n#%% [markdown]\n# \xe7\x9c\x8bNumPy\xe6\x95\xb0\xe7\xbb\x84\xe6\x98\xaf\xe5\xa6\x82\xe4\xbd\x95\xe6\x94\xb9\xe5\x8f\x98\xe9\x87\x8c\xe9\x9d\xa2\xe7\x9a\x84\xe5\x80\xbc\xe7\x9a\x84\xef\xbc\x9a\n#%% [markdown]\n# a.add_(1)\n# print(a)\n# print(b)\n#%% [markdown]\n# ### 2.2 \xe5\xb0\x86NumPy\xe6\x95\xb0\xe7\xbb\x84\xe8\xbd\xac\xe5\x8c\x96\xe4\xb8\xbaTorch\xe5\xbc\xa0\xe9\x87\x8f\n#%% [markdown]\n# \xe7\x9c\x8b\xe6\x94\xb9\xe5\x8f\x98NumPy\xe6\x95\xb0\xe7\xbb\x84\xe6\x98\xaf\xe5\xa6\x82\xe4\xbd\x95\xe8\x87\xaa\xe5\x8a\xa8\xe6\x94\xb9\xe5\x8f\x98Torch\xe5\xbc\xa0\xe9\x87\x8f\xe7\x9a\x84\xef\xbc\x9a\n\n#%%\nimport numpy as np\na = np.ones(5)\nb = torch.from_numpy(a)\nnp.add(a, 1, out=a)\nprint(a)\nprint(b)\n\n#%% [markdown]\n# CPU\xe4\xb8\x8a\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\xbc\xa0\xe9\x87\x8f(CharTensor\xe9\x99\xa4\xe5\xa4\x96)\xe9\x83\xbd\xe6\x94\xaf\xe6\x8c\x81\xe8\xbd\xac\xe6\x8d\xa2\xe4\xb8\xbaNumPy\xe4\xbb\xa5\xe5\x8f\x8a\xe7\x94\xb1NumPy\xe8\xbd\xac\xe6\x8d\xa2\xe5\x9b\x9e\xe6\x9d\xa5\xe3\x80\x82\n#%% [markdown]\n# ## 3 CUDA\xe4\xb8\x8a\xe7\x9a\x84\xe5\xbc\xa0\xe9\x87\x8f\n#%% [markdown]\n# \xe5\xbc\xa0\xe9\x87\x8f\xe5\x8f\xaf\xe4\xbb\xa5\xe4\xbd\xbf\xe7\x94\xa8`.to`\xe6\x96\xb9\xe6\xb3\x95\xe7\xa7\xbb\xe5\x8a\xa8\xe5\x88\xb0\xe4\xbb\xbb\xe4\xbd\x95\xe8\xae\xbe\xe5\xa4\x87\xef\xbc\x88device\xef\xbc\x89\xe4\xb8\x8a\xef\xbc\x9a\n\n#%%\n# let us run this cell only if CUDA is available\n# We will use ``torch.device`` objects to move tensors in and out of GPU\nif torch.cuda.is_available():\n    device = torch.device(""cuda"")          # a CUDA device object\n    y = torch.ones_like(x, device=device)  # directly create a tensor on GPU\n    x = x.to(device)                       # or just use strings ``.to(""cuda"")``\n    z = x + y\n    print(z)\n    print(z.to(""cpu"", torch.double))       # ``.to`` can also change dtype together!\n\n\n#%%\n\n\n\n'"
