file_path,api_count,code
src/db.py,0,"b'import sqlite3\nconn = sqlite3.connect(\'audiophile.db\')\nc = conn.cursor()\n\n\ndef create_tables():\n    c.execute(\'\'\'CREATE TABLE if not exists fingerprint\n             (quad UNSIGNED BIG INT PRIMARY KEY ON CONFLICT REPLACE,\n              songid_time INTEGER)\'\'\')\n    c.execute(\'\'\'CREATE TABLE if not exists songs\n              (songid UNSIGNED BIG INT PRIMARY KEY ON CONFLICT REPLACE,\n               song_name TEXT,\n               FOREIGN KEY(songid) REFERENCES fingerprint(songid_time))\'\'\')\n    conn.commit()\n\n\ndef store(addresses, times, song_hash, song_name):\n    create_tables()\n    for i in range(len(addresses)):\n        c.execute(\'INSERT into fingerprint VALUES (?, ?)\',\n                  (addresses[i], (song_hash << 13) + times[i]))\n    c.execute(\'INSERT INTO songs VALUES (?, ?)\', (song_hash, song_name))\n    conn.commit()\n\n\ndef search(addresses, times):\n    results = {}\n    for i in range(len(addresses)):\n        add = addresses[i]\n        c.execute(\'SELECT songid_time FROM fingerprint WHERE quad = ?\', (add,))\n        info = c.fetchone()\n        if info is not None:\n            info = info[0]\n            c.execute(\'SELECT song_name FROM songs WHERE songid = ?\',\n                      (info >> 13,))\n            song_name = c.fetchone()[0]\n            song_time = info & 8191\n            if song_name in results:\n                results[song_name][0] += 1\n                results[song_name][1].append(song_time - times[i])\n            else:\n                results[song_name] = [1, [song_time - times[i]]]\n\n    return filter_results(results)\n\n\ndef filter_results(results):\n    filtered = {}\n    for s in results:\n        dts = {i: results[s][1].count(i) for i in results[s][1]}\n        dts_matched = max(dts.values())\n        if dts_matched > 10:\n            filtered[s] = (results[s][0], dts_matched)\n    return filtered\n\n\ndef show_results(filtered_results, best=10):\n    top_results = sorted(filtered_results.keys(),\n                         key=lambda i: filtered_results[i][1], reverse=True)\n\n    to_print = \'\'\n    for i in top_results[:best]:\n        to_print += ""%s    %d quads    %d coherent quads\\n"" \\\n            % (i, filtered_results[i][0], filtered_results[i][1])\n    return to_print\n'"
src/fingerprint.py,6,"b""import numpy as np\nimport soundfile as sf\nfrom scipy.signal import butter, lfilter, hamming\n\n\ndef lowpass_filter(sig, cutoff=5000, fs=44100, order=6):\n    b, a = butter(order, cutoff / (0.5 * fs), analog=False)\n    return lfilter(b, a, sig)\n\n\ndef truncate(sig, fac):\n    return sig[: fac * (len(sig) // fac)]\n\n\ndef downsample(sig, fac=4):\n    return np.mean(truncate(sig, fac).reshape(-1, fac), 1)\n\n\ndef apply_hamming(sig, ws=1024):\n    window = hamming(ws, sym=False)\n    sig = truncate(sig, ws)\n    return sig * np.tile(window, len(sig) // ws)\n\n\ndef apply_fft(sig, fs=11025, ws=1024):\n    return np.abs(np.fft.rfft(sig.reshape(-1, ws)))\n\n\ndef get_spectrograms(sig):\n    return apply_fft(apply_hamming(downsample(lowpass_filter(sig))))\n\n\ndef get_strongest_bins(spg):\n    band_ranges = [[0, 20],  [21, 50], [51, 90],\n                   [91, 160], [161, 250], [251, 511]]\n    return np.array([(np.argmax(spg[start: end]), np.max(spg[start: end]))\n                     for start, end in band_ranges])\n\n\nget_strongest_bins = np.vectorize(get_strongest_bins, signature='(m)->(n,p)')\n\n\ndef global_strongest_amplitudes_mean(bins):\n    return np.mean(np.max(bins[..., 1], axis=0))\n\n\ndef get_filtered_spectrogram(sig, k=0.1):\n    spgs = get_spectrograms(sig)\n    bins = get_strongest_bins(spgs)\n    mean = global_strongest_amplitudes_mean(bins)\n    return [[int(bins[i, j, 0]) for j in range(6)]\n            for i in range(len(bins))]\n\n\ndef get_addresses(fspgs):\n    ordered_notes = sum(fspgs, [])\n    note_times = sum([[i] * len(fspgs[i]) for i in range(len(fspgs))], [])\n    addresses = []\n    anchored_note_times = []\n    for i in range(0, len(ordered_notes) - 2):\n        anchors_part = (ordered_notes[i] << 18) + \\\n            (ordered_notes[i + 1] << 9) + \\\n            ordered_notes[i + 2]\n\n        j = i + 3\n        while j < i + 12 and j < len(ordered_notes):\n            dt_part = (ordered_notes[j] << 24) + \\\n                (note_times[j] - note_times[i] << 16) + \\\n                (note_times[j] - note_times[i + 1] << 8) + \\\n                note_times[j] - note_times[i + 2]\n\n            addresses.append((anchors_part << 33) + dt_part)\n            anchored_note_times.append(note_times[j])\n            j += 1\n    return addresses, anchored_note_times\n"""
src/fingerprint_test.py,5,"b'import matplotlib.pyplot as plt\nfrom fingerprint import np, lowpass_filter, downsample\n\n\ndef lowpass_filter_test():\n    fs = 30\n    t = np.linspace(0, 5, 5 * fs, endpoint=False)\n    sig = np.sin(1.2 * 2 * np.pi * t) + \\\n        1.5 * np.cos(9 * 2 * np.pi * t) + \\\n        0.5 * np.sin(12.0 * 2 * np.pi * t)\n\n    plt.plot(t, sig, color=\'red\')\n    sig_filtered = lowpass_filter(sig, 3.667, 30, 6)\n    plt.plot(t, sig_filtered, color=\'blue\')\n    plt.show()\n\n\ndef downsample_test():\n    a = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n    print(downsample(a, 3))\n\n\nif __name__ == ""__main__"":\n    downsample_test()\n'"
src/main.py,0,"b'import sound_util as su\nimport sys\n\ntry:\n    if sys.argv[1] == \'learn\':\n        su.learn_song(sys.argv[2])\n    elif sys.argv[1] == \'learnall\':\n        su.learn_songs(sys.argv[2])\n    elif sys.argv[1] == \'search\':\n        print(su.identify_clip(sys.argv[2]))\n    elif sys.argv[1] == \'listen\':\n        print(su.identify_from_mic(int(sys.argv[2]), int(sys.argv[3])))\n    else:\n        raise Exception(""Invalid option"")\nexcept Exception:\n    print(""Usage: \\n"")\n    print(""$ python main.py learn <path to audio file>"")\n    print(""$ python main.py learn <directory containing audio files>"")\n    print(""$ python main.py listen <time in seconds> <sound device index>"")\n    print(""$ python main.py search <path to clip>"")\n\n    raise Exception\n'"
src/sound_util.py,1,"b'import fingerprint as fp\nimport db\n\nimport soundfile as sf\nimport taglib\nimport hashlib\nimport os\nimport glob\nimport sys\n\n\ndef convert_to_mono(sig):\n    if len(sig.shape) > 1:\n        return fp.np.mean(sig, axis=1)\n    return sig\n\n\ndef read_audiofile(filename):\n    # get tags\n    song = taglib.File(filename)\n    print(filename)\n    assert song.length < 800, ""Maximum allowed song length is 13 minutes""\n\n    # get the signal\n    name, ext = os.path.splitext(filename)\n    os.system(\'ffmpeg -loglevel 8 -i ""%s"" ""%s%s""\' % (filename, name, \'.wav\'))\n    _filename = name + \'.wav\'\n    sig, fs = sf.read(_filename)  # extract the signal\n    os.remove(_filename)\n\n    return os.path.basename(filename), song.tags, convert_to_mono(sig)\n\n\ndef hash_metadata(filename, tags, bits=51):\n    basename = os.path.basename(filename).encode(\'utf-8\')\n    m = hashlib.md5(b\'%s\' % basename)\n    return int(\'0x\' + m.hexdigest(), 16) >> (128 - bits)\n\n\ndef learn_song(filename):\n    song_name, tags, sig = read_audiofile(filename)\n    addresses, times = fp.get_addresses(fp.get_filtered_spectrogram(sig))\n\n    basename = os.path.basename(filename)\n    name, ext = os.path.splitext(basename)\n    db.store(addresses, times, hash_metadata(filename, tags), name)\n\n\ndef learn_songs(_dir):\n    for filename in glob.glob(_dir + \'/**/*.[Mm]p3\', recursive=True):\n        song = taglib.File(filename)\n        if song.length < 800:\n            learn_song(filename)\n        else:\n            print(\'Skipping %s (too long)\')\n\n\ndef identify_clip(filename):\n    song_name, tags, sig = read_audiofile(filename)\n    addresses, times = fp.get_addresses(fp.get_filtered_spectrogram(sig))\n    return db.show_results(db.search(addresses, times), 3)\n\n\ndef identify_from_mic(time=20, sound_device=0):\n    print(""Listening..."")\n    filename = os.path.join(sys.path[0] + \'/record.mp3\')\n    os.system(\'ffmpeg -loglevel 8 -ar 44100 -f alsa -i hw:%d -t %d %s\' %\n              (sound_device, time, filename))\n    results = identify_clip(filename)\n    os.remove(filename)\n    return results\n'"
