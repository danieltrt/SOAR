file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\n\nfrom codecs import open\nfrom os import path\n\nhere = path.abspath(path.dirname(__file__))\nwith open(path.join(here, \'README.md\'), encoding=\'utf-8\') as f:\n    long_description = f.read()\n\nsetup(\n    name=\'sharearray\',\n    version=\'0.1\',\n    py_modules=[\'sharearray\'],\n\n    url=\'https://github.com/bshillingford/python-sharearray\',\n    description=(""Share numpy arrays across processes efficiently ""\n\t\t ""(ideal for large, read-only datasets)""),\n    long_description=long_description,\n\n    author=\'Brendan Shillingford\',\n    license=\'Apache Software License 2.0\',\n    install_requires=[\'numpy\'],\n\n    classifiers=[\n        \'Development Status :: 4 - Beta\',\n        \'Intended Audience :: Developers\',\n        \'License :: OSI Approved :: Apache Software License\',\n\n        \'Programming Language :: Python :: 2\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: 3.3\',\n        \'Programming Language :: Python :: 3.4\',\n        \'Programming Language :: Python :: 3.5\',\n    ],\n)\n'"
sharearray.py,6,"b'# Copyright 2017 Brendan Shillingford\n# \n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n# \n#     http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport functools\nimport os\nimport os.path\nimport re\nimport time\nimport sys\n\nimport numpy as np\n\n__all__ = [\'cache\', \'decorator\', \'valid_id\', \'TimeoutException\']\n\n\nif sys.version_info[0] == 2:\n     FileExistsError = OSError\n\n\nclass TimeoutException(Exception):\n    pass\n\n\n_ID_REGEX = re.compile(r""^[A-Za-z0-9=+._-]+$"")\n\n\ndef valid_id(id):\n    if _ID_REGEX.match(id):\n        return True\n    return False\n\n\ndef _memmapped_view(filename):\n    return np.lib.format.open_memmap(filename, mode=\'r\')\n\n\ndef _build_path(id, prefix, shm_path):\n    fn = os.path.join(shm_path, prefix + id + \'.npy\')\n    fn_lock = fn + \'.lock\'\n    return fn, fn_lock\n\n\ndef free(id, shm_path=\'/dev/shm\', prefix=\'sharearray_\'):\n    fn, fn_lock = _build_path(id, prefix=prefix, shm_path=shm_path)\n    fn_exists = os.path.exists(fn)\n    fn_lock_exists = os.path.exists(fn_lock)\n\n    if fn_lock_exists:\n        import warnings\n        warnings.warn(""lock still exists"")\n        os.unlink(fn_lock)\n\n    if fn_exists:\n        os.unlink(fn)\n\n\ndef cache(id, array_or_callback,\n          shm_path=\'/dev/shm\',\n          prefix=\'sharearray_\',\n          timeout=-1,\n          verbose=True,\n          log_func=None):\n    """"""\n    Stores a `numpy` `ndarray` into shared memory, caching subsequent requests\n    (globally, across all processes) to the function so they point to the same\n    memory.\n\n    By default, does this be creating a file at `/dev/shm/shareddataset_<id>`.\n    If:\n\n    1. The file is not created yet, saves `array_or_callback` to the path\n       listed above (see NOTE 1). Then, returns a read-only memmapped view to\n       this numpy array.\n\n    2. The file is already created. We return a read-only memmapped view of it.\n\n    Args:\n        id (str): identifier for shared array, global across system.\n            Must match `[A-Za-z0-9=+._-]+`. You may want to include your\n            program\'s name to prevent name collisions.\n        array_or_callback: either a `numpy.ndarray` containing value types, or\n            a callback function taking no arguments that returns one.\n        shm_path (str, optional): path to the Linux shared memory\n            tmpfs mountpoint. In almost all kernel builds, one lives at\n            `/dev/shm` with size defaulting to half the RAM; sometimes it\'s a\n            symlink to `/run/shm`.\n        timeout (int, optional): number of seconds to wait before timing out\n            waiting for lock to be released, when file is already being created.\n            If -1, waits indefinitely.\n        prefix (str, optional): prefix added to files in `shm_path`.\n        verbose (bool): if True, prints useful information (2-3 lines).\n        log_func (callable): if verbose is True, this is used if specified.\n            Else just uses `print`.\n\n    Returns:\n        A `numpy.ndarray` read-only view into the shared memory, whether it\n        was newly created or previously created.\n\n    Raises:\n        ValueError: `id` is not a valid identifier (must match\n            `[A-Za-z0-9=+._-]+`), or `array_or_callback` is not a callback\n            or returns\n        TimeoutException: if `timeout` is positive, the lock file exists, and\n            we have waited at least `timeout` seconds yet the lock still exists.\n\n    Notes:\n\n        NOTE 1: For concurrency safety, this function creates a lock file at\n        `/dev/shm/shareddataset_<id>.lock` when initially writing the file\n        (lock file is empty, doesn\'t contain PID). File creating is hence\n        checked using the lock, rather than the file\'s existence itself. We\n        don\'t use the standard create-rename method of ensuring atomicity,\n        since `array_or_callback` may be expensive to call or large to write.\n\n        NOTE 2: `id`s are currently global to the system. Include your program\'s\n        name to prevent name collisions.\n\n        NOTE 3: memmapped views are created using\n        `numpy.lib.format.open_memmap`.\n\n        NOTE 4: If the array is very large, to save memory, you may want to\n        immediately remove all references to the original array, then do a full\n        garbage collection (`import gc; gc.collect()`).\n\n    Examples:\n\n        An expensive operation (e.g. data preprocessing) that is the same\n        across all running instances of this program:\n\n            x_times_y = cache(""myprog_x_times_y"", lambda: np.dot(x, y))\n\n        A large (large enough to warrant concern, but small enough to fit in\n        RAM once) training set that we only want one instance of across\n        many training jobs:\n\n            def load_training_set():\n                # load and/or preprocess training_set once here\n                return training_set\n            training_set = cache(""myprog_training_set"", load_training_set)\n\n        Only passing a callback to array_or_callback makes sense here,\n        of course.\n    """"""\n    if not valid_id(id):\n        raise ValueError(\'invalid id: \' + id)\n\n    if not (hasattr(array_or_callback, \'__call__\')\n            or isinstance(array_or_callback, np.ndarray)):\n        raise ValueError(\n            \'array_or_callback should be ndarray or zero-argument callable\')\n\n    if verbose and log_func:\n        print_ = log_func\n    elif verbose:\n        def print_(s):\n            print(s)\n    else:\n        def print_(s):\n            pass\n\n    fn, fn_lock = _build_path(id, prefix=prefix, shm_path=shm_path)\n    fd_lock = -1\n    try:\n        fd_lock = os.open(fn_lock, os.O_CREAT | os.O_EXCL)\n        if fd_lock < 0:\n            raise OSError(""Lock open failure (bug?)"", fn_lock, fd_lock)\n\n    except FileExistsError:\n        if timeout < 0:\n            print_((""\'{}\' is being created by another process. ""\n                    ""Waiting indefinitely... (timeout < 0)"").format(id))\n\n            while os.path.exists(fn_lock):\n                time.sleep(1)\n\n        else:\n            print_((""\'{}\' is being created by another process. ""\n                    ""Waiting up to {} seconds..."").format(id, timeout))\n\n            for _ in range(timeout):\n                time.sleep(1)\n                if not os.path.exists(fn_lock):\n                    break\n            else:\n                raise TimeoutException(\n                    ""timed out waiting for %s to unlock (be created)"" % id)\n    else:\n        if not os.path.exists(fn):\n            print_(""\'%s\' doesn\'t exist yet. Locking and creating..."" % id)\n\n            if isinstance(array_or_callback, np.ndarray):\n                array = array_or_callback\n            else:\n                array = array_or_callback()\n                if not isinstance(array, np.ndarray):\n                    raise ValueError(\n                        \'callback did not return a numpy.ndarray, returned:\',\n                        type(array))\n\n            np.save(fn, array, allow_pickle=False)\n            print_(""\'%s\': written."" % id)\n\n    finally:\n        if fd_lock > 0:\n            os.close(fd_lock)\n            os.unlink(fn_lock)\n\n    print_(""\'%s\': returning memmapped view."" % id)\n    return _memmapped_view(fn)\n\n\ndef decorator(id, **kwargs):\n    """"""\n    Decorator version of `cache`, analogous to a memoization decorator.\n\n    Besides `array_or_callback` which isn\'t needed, arguments are identical to\n    those of `cache`, see there for docs. They must be passed as keyword args\n    except for `id`.\n\n    Note that `id` can\'t depend on the arguments to the decorated function.\n    For that, use `cache` directly.\n\n    Example:\n        Alternative to callback syntax above.\n\n            @decorator(""my_large_array"")\n            def foo():\n                # ...do some expensive computation to generate arr...\n                return arr\n\n            arr = foo()  # first call, in shared memory arr global to system\n            arr2 = foo() # here or another script, returns read-only view\n    """"""\n    if not valid_id(id):\n        raise ValueError(\'invalid id: \' + id)\n\n    def decorate(f):\n        @functools.wraps(f)\n        def wrapped():\n            return cache(id, f, **kwargs)\n\n        return wrapped\n\n    return decorate\n'"
test.py,3,"b'# Copyright 2017 Brendan Shillingford\n# \n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n# \n#     http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nimport os.path\n\nimport numpy as np\n\nimport sharearray\n\n\nclass TestCache(unittest.TestCase):\n    def test_simple(self):\n        identifier = \'testcache_simple\'\n        arr = np.random.normal(size=(5, 6))\n\n        # create from scratch:\n        arr1 = sharearray.cache(identifier,\n                                array_or_callback=arr,\n                                timeout=-1,\n                                verbose=True)\n        self.assertTrue((arr1 == arr).all())\n        # opens view\n        arr2 = sharearray.cache(identifier,\n                                array_or_callback=arr,\n                                timeout=-1,\n                                verbose=True)\n        self.assertTrue((arr2 == arr).all())\n\n        # close views:\n        del arr1\n        del arr2\n\n        # free memory:\n        sharearray.free(identifier)\n\n    def test_callback(self):\n        identifier = \'testcache_callback\'\n\n        # ensure already freed:\n        sharearray.free(identifier)\n        fn, fn_lock = sharearray._build_path(identifier,\n                                             shm_path=\'/dev/shm\',\n                                             prefix=\'sharearray_\')\n        self.assertTrue(not os.path.exists(fn) and not os.path.exists(fn_lock))\n\n        # create from scratch or open view\n        arr = sharearray.cache(identifier,\n                               array_or_callback=lambda: np.ones((5, 6)),\n                               timeout=-1,\n                               verbose=True)\n        self.assertTrue(os.path.exists(fn) and not os.path.exists(fn_lock))\n        del arr\n        # should still exist after removing memmapped view\n        self.assertTrue(os.path.exists(fn) and not os.path.exists(fn_lock))\n\n        # free memory:\n        sharearray.free(identifier)\n        self.assertTrue(not os.path.exists(fn) and not os.path.exists(fn_lock))\n\n    def test_decorator(self):\n        identifier = \'testcache_decorator\'\n\n        @sharearray.decorator(identifier, verbose=False)\n        def data():\n            return np.ones((5, 6))\n\n        # ensure memory is freed; neither lock nor file should exist\n        sharearray.free(identifier)\n        fn, fn_lock = sharearray._build_path(identifier,\n                                             shm_path=\'/dev/shm\',\n                                             prefix=\'sharearray_\')\n        self.assertTrue(not os.path.exists(fn) and not os.path.exists(fn_lock))\n        # 1st call should create item, and lock should be gone\n        data1 = data()\n        self.assertTrue((data1 == 1).all())\n        self.assertTrue(os.path.exists(fn) and not os.path.exists(fn_lock))\n\n        # 2nd call should just view\n        data2 = data()\n        self.assertTrue((data2 == 1).all())\n        self.assertTrue(os.path.exists(fn) and not os.path.exists(fn_lock))\n\n        # free memory:\n        sharearray.free(identifier)\n        self.assertTrue(not os.path.exists(fn) and not os.path.exists(fn_lock))\n\nif __name__ == \'__main__\':\n    unittest.main()\n\n# TODO: test exceptions?\n'"
