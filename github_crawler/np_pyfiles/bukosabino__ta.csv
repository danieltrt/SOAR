file_path,api_count,code
setup.py,0,"b""# -*- coding: utf-8 -*-\nfrom distutils.core import setup\n\nsetup(\n    name='ta',\n    packages=['ta'],\n    version='0.5.25',\n    description='Technical Analysis Library in Python',\n    long_description='It is a Technical Analysis library to financial time series datasets. You can use to do feature engineering. It is builded on Python Pandas library.',\n    author='Dario Lopez Padial (Bukosabino)',\n    author_email='Bukosabino@gmail.com',\n    url='https://github.com/bukosabino/ta',\n    maintainer='Dario Lopez Padial (Bukosabino)',\n    maintainer_email='Bukosabino@gmail.com',\n    install_requires=[\n        'numpy',\n        'pandas',\n    ],\n    download_url='https://github.com/bukosabino/ta/tarball/0.5.25',\n    keywords=['technical analysis', 'python3', 'pandas'],\n    license='The MIT License (MIT)',\n    classifiers=[\n        'Intended Audience :: Financial and Insurance Industry',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'License :: OSI Approved :: MIT License'\n    ],\n    project_urls={\n        'Documentation': 'https://technical-analysis-library-in-python.readthedocs.io/en/latest/',\n        'Bug Reports': 'https://github.com/bukosabino/ta/issues',\n        'Source': 'https://github.com/bukosabino/ta',\n    },\n)\n"""
tests.py,0,"b'from unittest import main\n\n\nif __name__ == ""__main__"":\n    main(module=\'ta.tests\', exit=False)\n'"
dev/adx.py,0,"b'import pandas as pd\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\n# df = pd.read_csv(\'prueba.csv\', sep=\',\')\n\n# Clean nan values\ndf = utils.dropna(df)\n\nprint(df.columns)\n\n# Add adx indicator filling Nans values\ndf[\'adx\'] = adx(df[\'High\'], df[\'Low\'], df[\'Close\'], n=14, fillna=True)\n\nprint(df[\'adx\'])\n\ndf[\'adx_neg\'] = adx_neg(df[\'High\'], df[\'Low\'], df[\'Close\'], n=14, fillna=True)\ndf[\'adx_pos\'] = adx_pos(df[\'High\'], df[\'Low\'], df[\'Close\'], n=14, fillna=True)\n\nprint(df.columns)\nprint(df.tail())\n'"
dev/all_features_example.py,0,"b'""""""This is a example adding all technical analysis features implemented in\nthis library.\n""""""\nimport pandas as pd\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nimport ta\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = ta.utils.dropna(df)\n\nprint(df.columns)\n\n# Add all ta features filling nans values\ndf = ta.add_all_ta_features(df, ""Open"", ""High"", ""Low"", ""Close"", ""Volume_BTC"",\n                                fillna=True)\n\n# Add all ta features not filling nans values\ndf = ta.add_all_ta_features(df, ""Open"", ""High"", ""Low"", ""Close"", ""Volume_BTC"",\n                                fillna=False)\n\nprint(df.columns)\nprint(len(df.columns))\n'"
dev/atr.py,0,"b'import pandas as pd\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = utils.dropna(df)\n\nprint(df.columns)\n\n# Add adx indicator filling Nans values\ndf[\'adx\'] = atr(df[\'High\'], df[\'Low\'], df[\'Close\'], n=14, fillna=True)\n\nimport pdb; pdb.set_trace()\n\nprint(df[\'adx\'])\n\nprint(df.columns)\n'"
dev/bollinger_band_features_example.py,0,"b'""""""This is a example adding bollinger band features.\n""""""\nimport pandas as pd\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = utils.dropna(df)\n\nprint(df.columns)\n\n# Add bollinger band high indicator filling Nans values\ndf[\'bb_high_indicator\'] = bollinger_hband_indicator(df[""Close""], n=20, ndev=2,\n                                                    fillna=True)\n\n# Add bollinger band low indicator filling Nans values\ndf[\'bb_low_indicator\'] = bollinger_lband_indicator(df[""Close""], n=20, ndev=2,\n                                                    fillna=True)\n\nprint(df.columns)\n'"
dev/generate_image_bb.py,0,"b'import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\ndf = utils.dropna(df)\n\n# Add all ta features filling nans values\ndf = add_all_ta_features(df, ""Open"", ""High"", ""Low"", ""Close"", ""Volume_BTC"",\n                            fillna=True)\n\nplt.plot(df[40700:41000].Close)\nplt.plot(df[40700:41000].volatility_bbh, label=\'High BB\')\nplt.plot(df[40700:41000].volatility_bbl, label=\'Low BB\')\nplt.plot(df[40700:41000].volatility_bbm, label=\'EMA BB\')\nplt.title(\'Bollinger Bands\')\nplt.legend()\nplt.savefig(""bb.png"")\n'"
dev/generate_image_macd.py,0,"b'import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\ndf = utils.dropna(df)\n\n# Add all ta features filling nans values\ndf = add_all_ta_features(df, ""Open"", ""High"", ""Low"", ""Close"", ""Volume_BTC"",\n                            fillna=True)\n# Generate macd image\nplt.plot(df[40500:41000].trend_macd, label=\'MACD\')\nplt.plot(df[40500:41000].trend_macd_signal, label=\'MACD Signal\')\nplt.plot(df[40500:41000].trend_macd_diff, label=\'MACD Difference\')\nplt.title(\'MACD, MACD Signal and MACD Difference\')\nplt.legend()\nplt.savefig(""macd.png"")\n'"
dev/ichi.py,0,"b'import pandas as pd\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# Load data\ndf = pd.read_csv(\'../data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = utils.dropna(df)\n\nprint(df.columns)\n\n# Add adx indicator filling Nans values\ndf[\'ichi_a\'] = ichimoku_a(df[\'High\'], df[\'Low\'], fillna=True)\ndf[\'ichi_b\'] = ichimoku_b(df[\'High\'], df[\'Low\'], fillna=True)\n\nimport pdb; pdb.set_trace()\n\nprint(df.head(20))\n\nprint(df.tail(20))\n\nimport pdb; pdb.set_trace()\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/stable/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\n\nimport sys\nsys.path.append("".."") # Adds higher directory to python modules path.\nfrom ta import *\n\n# -- Project information -----------------------------------------------------\n\nproject = \'Technical Analysis Library in Python\'\ncopyright = \'2018, Dario Lopez Padial (Bukosabino)\'\nauthor = \'Dario Lopez Padial (Bukosabino)\'\n\n# The short X.Y version\nversion = \'\'\n# The full version, including alpha/beta/rc tags\nrelease = \'0.1.4\'\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.napoleon\',\n]\n\nnapoleon_google_docstring = True\nnapoleon_use_param = False\nnapoleon_use_ivar = True\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'TechnicalAnalysisLibraryinPythondoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'TechnicalAnalysisLibraryinPython.tex\', \'Technical Analysis Library in Python Documentation\',\n     \'Dario Lopez Padial (Bukosabino)\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'technicalanalysislibraryinpython\', \'Technical Analysis Library in Python Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'TechnicalAnalysisLibraryinPython\', \'Technical Analysis Library in Python Documentation\',\n     author, \'TechnicalAnalysisLibraryinPython\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n'"
examples_to_use/all_features_example.py,0,"b'""""""This is a example adding all technical analysis features implemented in\nthis library.\n""""""\nimport pandas as pd\nimport ta\n\n# Load data\ndf = pd.read_csv(\'../ta/tests/data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = ta.utils.dropna(df)\n\nprint(df.columns)\n\n# Add all ta features filling nans values\ndf = ta.add_all_ta_features(df, ""Open"", ""High"", ""Low"", ""Close"", ""Volume_BTC"", fillna=True)\n\nprint(df.columns)\nprint(len(df.columns))\n'"
examples_to_use/bollinger_band_features_example.py,0,"b'""""""This is a example adding bollinger band features.\n""""""\nimport pandas as pd\nimport ta\n\n# Load data\ndf = pd.read_csv(\'../ta/tests/data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = ta.utils.dropna(df)\n\nprint(df.columns)\n\n# Add bollinger band high indicator filling nans values\ndf[\'bb_high_indicator\'] = ta.volatility.bollinger_hband_indicator(df[""Close""], n=20, ndev=2, fillna=True)\n\n# Add bollinger band low indicator filling nans values\ndf[\'bb_low_indicator\'] = ta.volatility.bollinger_lband_indicator(df[""Close""], n=20, ndev=2, fillna=True)\n\nprint(df.columns)\n'"
examples_to_use/roc.py,0,"b'""""""This is a example adding volume features.\n""""""\nimport pandas as pd\nimport ta\n\n# Load data\ndf = pd.read_csv(\'../ta/tests/data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = ta.utils.dropna(df)\n\nta.momentum.roc(close=df[\'Close\'])\n'"
examples_to_use/volume_features_example.py,0,"b'""""""This is a example adding volume features.\n""""""\nimport pandas as pd\nimport ta\n\n# Load data\ndf = pd.read_csv(\'../ta/tests/data/datas.csv\', sep=\',\')\n\n# Clean nan values\ndf = ta.utils.dropna(df)\n\nprint(df.columns)\n\n# Add all volume features filling nans values\ndf = ta.add_volume_ta(df, ""High"", ""Low"", ""Close"", ""Volume_BTC"", fillna=True)\n\nprint(df.columns)\n'"
ta/__init__.py,0,"b'""""""It is a technical analysis library to financial time series datasets.\nYou can use it to do feature engineering from financial datasets. It is\nbuilded on pandas python library.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\nfrom ta.wrapper import (add_all_ta_features, add_momentum_ta, add_others_ta,\n                        add_trend_ta, add_volatility_ta, add_volume_ta)\n'"
ta/momentum.py,6,"b'""""""\n.. module:: momentum\n   :synopsis: Momentum Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\nimport numpy as np\nimport pandas as pd\n\nfrom ta.utils import IndicatorMixin\n\n\nclass RSIIndicator(IndicatorMixin):\n    """"""Relative Strength Index (RSI)\n\n    Compares the magnitude of recent gains and losses over a specified time\n    period to measure speed and change of price movements of a security. It is\n    primarily used to attempt to identify overbought or oversold conditions in\n    the trading of an asset.\n\n    https://www.investopedia.com/terms/r/rsi.asp\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n    def __init__(self, close: pd.Series, n: int = 14, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        diff = self._close.diff(1)\n        up = diff.where(diff > 0, 0.0)\n        dn = -diff.where(diff < 0, 0.0)\n        min_periods = 0 if self._fillna else self._n\n        emaup = up.ewm(alpha=1/self._n, min_periods=min_periods, adjust=False).mean()\n        emadn = dn.ewm(alpha=1/self._n, min_periods=min_periods, adjust=False).mean()\n        rs = emaup / emadn\n        self._rsi = pd.Series(np.where(emadn == 0, 100, 100-(100/(1+rs))), index=self._close.index)\n\n    def rsi(self) -> pd.Series:\n        """"""Relative Strength Index (RSI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        rsi = self._check_fillna(self._rsi, value=50)\n        return pd.Series(rsi, name=\'rsi\')\n\n\nclass TSIIndicator(IndicatorMixin):\n    """"""True strength index (TSI)\n\n    Shows both trend direction and overbought/oversold conditions.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:true_strength_index\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        r(int): high period.\n        s(int): low period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, r: int = 25, s: int = 13, fillna: bool = False):\n        self._close = close\n        self._r = r\n        self._s = s\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        m = self._close - self._close.shift(1)\n        min_periods_r = 0 if self._fillna else self._r\n        min_periods_s = 0 if self._fillna else self._s\n        m1 = m.ewm(span=self._r, min_periods=min_periods_r, adjust=False).mean().ewm(\n            span=self._s, min_periods=min_periods_s, adjust=False).mean()\n        m2 = abs(m).ewm(span=self._r, min_periods=min_periods_r, adjust=False).mean().ewm(\n            span=self._s, min_periods=min_periods_s, adjust=False).mean()\n        self._tsi = m1 / m2\n        self._tsi *= 100\n\n    def tsi(self) -> pd.Series:\n        """"""True strength index (TSI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        tsi = self._check_fillna(self._tsi, value=0)\n        return pd.Series(tsi, name=\'tsi\')\n\n\nclass UltimateOscillator(IndicatorMixin):\n    """"""Ultimate Oscillator\n\n    Larry Williams\' (1976) signal, a momentum oscillator designed to capture\n    momentum across three different timeframes.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ultimate_oscillator\n\n    BP = Close - Minimum(Low or Prior Close).\n    TR = Maximum(High or Prior Close)  -  Minimum(Low or Prior Close)\n    Average7 = (7-period BP Sum) / (7-period TR Sum)\n    Average14 = (14-period BP Sum) / (14-period TR Sum)\n    Average28 = (28-period BP Sum) / (28-period TR Sum)\n\n    UO = 100 x [(4 x Average7)+(2 x Average14)+Average28]/(4+2+1)\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        s(int): short period.\n        m(int): medium period.\n        len(int): long period.\n        ws(float): weight of short BP average for UO.\n        wm(float): weight of medium BP average for UO.\n        wl(float): weight of long BP average for UO.\n        fillna(bool): if True, fill nan values with 50.\n    """"""\n\n    def __init__(self,\n                 high: pd.Series,\n                 low: pd.Series,\n                 close: pd.Series,\n                 s: int = 7,\n                 m: int = 14,\n                 len: int = 28,\n                 ws: float = 4.0,\n                 wm: float = 2.0,\n                 wl: float = 1.0,\n                 fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._s = s\n        self._m = m\n        self._len = len\n        self._ws = ws\n        self._wm = wm\n        self._wl = wl\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        cs = self._close.shift(1)\n        tr = self._true_range(self._high, self._low, cs)\n        bp = self._close - pd.DataFrame({\'low\': self._low, \'close\': cs}).min(axis=1, skipna=False)\n        min_periods_s = 0 if self._fillna else self._s\n        min_periods_m = 0 if self._fillna else self._m\n        min_periods_len = 0 if self._fillna else self._len\n        avg_s = bp.rolling(\n            self._s, min_periods=min_periods_s).sum() / tr.rolling(self._s, min_periods=min_periods_s).sum()\n        avg_m = bp.rolling(\n            self._m, min_periods=min_periods_m).sum() / tr.rolling(self._m, min_periods=min_periods_m).sum()\n        avg_l = bp.rolling(\n            self._len, min_periods=min_periods_len).sum() / tr.rolling(self._len, min_periods=min_periods_len).sum()\n        self._uo = (100.0 * ((self._ws * avg_s) + (self._wm * avg_m) + (self._wl * avg_l))\n                    / (self._ws + self._wm + self._wl))\n\n    def uo(self) -> pd.Series:\n        """"""Ultimate Oscillator\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        uo = self._check_fillna(self._uo, value=50)\n        return pd.Series(uo, name=\'uo\')\n\n\nclass StochasticOscillator(IndicatorMixin):\n    """"""Stochastic Oscillator\n\n    Developed in the late 1950s by George Lane. The stochastic\n    oscillator presents the location of the closing price of a\n    stock in relation to the high and low range of the price\n    of a stock over a period of time, typically a 14-day period.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:stochastic_oscillator_fast_slow_and_full\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n(int): n period.\n        d_n(int): sma period over stoch_k.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self,\n                 high: pd.Series,\n                 low: pd.Series,\n                 close: pd.Series,\n                 n: int = 14,\n                 d_n: int = 3,\n                 fillna: bool = False):\n        self._close = close\n        self._high = high\n        self._low = low\n        self._n = n\n        self._d_n = d_n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._n\n        smin = self._low.rolling(self._n, min_periods=min_periods).min()\n        smax = self._high.rolling(self._n, min_periods=min_periods).max()\n        self._stoch_k = 100 * (self._close - smin) / (smax - smin)\n\n    def stoch(self) -> pd.Series:\n        """"""Stochastic Oscillator\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        stoch_k = self._check_fillna(self._stoch_k, value=50)\n        return pd.Series(stoch_k, name=\'stoch_k\')\n\n    def stoch_signal(self) -> pd.Series:\n        """"""Signal Stochastic Oscillator\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        min_periods = 0 if self._fillna else self._d_n\n        stoch_d = self._stoch_k.rolling(self._d_n, min_periods=min_periods).mean()\n        stoch_d = self._check_fillna(stoch_d, value=50)\n        return pd.Series(stoch_d, name=\'stoch_k_signal\')\n\n\nclass KAMAIndicator(IndicatorMixin):\n    """"""Kaufman\'s Adaptive Moving Average (KAMA)\n\n    Moving average designed to account for market noise or volatility. KAMA\n    will closely follow prices when the price swings are relatively small and\n    the noise is low. KAMA will adjust when the price swings widen and follow\n    prices from a greater distance. This trend-following indicator can be\n    used to identify the overall trend, time turning points and filter price\n    movements.\n\n    https://www.tradingview.com/ideas/kama/\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        pow1(int): number of periods for the fastest EMA constant.\n        pow2(int): number of periods for the slowest EMA constant.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 10, pow1: int = 2, pow2: int = 30, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._pow1 = pow1\n        self._pow2 = pow2\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        close_values = self._close.values\n        vol = pd.Series(abs(self._close - np.roll(self._close, 1)))\n\n        min_periods = 0 if self._fillna else self._n\n        ER_num = abs(close_values - np.roll(close_values, self._n))\n        ER_den = vol.rolling(self._n, min_periods=min_periods).sum()\n        ER = ER_num / ER_den\n\n        sc = ((ER*(2.0/(self._pow1+1)-2.0/(self._pow2+1.0))+2/(self._pow2+1.0)) ** 2.0).values\n\n        self._kama = np.zeros(sc.size)\n        n = len(self._kama)\n        first_value = True\n\n        for i in range(n):\n            if np.isnan(sc[i]):\n                self._kama[i] = np.nan\n            else:\n                if first_value:\n                    self._kama[i] = close_values[i]\n                    first_value = False\n                else:\n                    self._kama[i] = self._kama[i-1] + sc[i] * (close_values[i] - self._kama[i-1])\n\n    def kama(self) -> pd.Series:\n        """"""Kaufman\'s Adaptive Moving Average (KAMA)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        kama = pd.Series(self._kama, index=self._close.index)\n        kama = self._check_fillna(kama, value=self._close)\n        return pd.Series(kama, name=\'kama\')\n\n\nclass ROCIndicator(IndicatorMixin):\n    """"""Rate of Change (ROC)\n\n    The Rate-of-Change (ROC) indicator, which is also referred to as simply\n    Momentum, is a pure momentum oscillator that measures the percent change in\n    price from one period to the next. The ROC calculation compares the current\n    price with the price \xe2\x80\x9cn\xe2\x80\x9d periods ago. The plot forms an oscillator that\n    fluctuates above and below the zero line as the Rate-of-Change moves from\n    positive to negative. As a momentum oscillator, ROC signals include\n    centerline crossovers, divergences and overbought-oversold readings.\n    Divergences fail to foreshadow reversals more often than not, so this\n    article will forgo a detailed discussion on them. Even though centerline\n    crossovers are prone to whipsaw, especially short-term, these crossovers\n    can be used to identify the overall trend. Identifying overbought or\n    oversold extremes comes naturally to the Rate-of-Change oscillator.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:rate_of_change_roc_and_momentum\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 12, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._roc = ((self._close - self._close.shift(self._n)) / self._close.shift(self._n)) * 100\n\n    def roc(self) -> pd.Series:\n        """"""Rate of Change (ROC)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        roc = self._check_fillna(self._roc)\n        return pd.Series(roc, name=\'roc\')\n\n\nclass AwesomeOscillatorIndicator(IndicatorMixin):\n    """"""Awesome Oscillator\n\n    From: https://www.tradingview.com/wiki/Awesome_Oscillator_(AO)\n\n    The Awesome Oscillator is an indicator used to measure market momentum. AO\n    calculates the difference of a 34 Period and 5 Period Simple Moving\n    Averages. The Simple Moving Averages that are used are not calculated\n    using closing price but rather each bar\'s midpoints. AO is generally used\n    to affirm trends or to anticipate possible reversals.\n\n    From: https://www.ifcm.co.uk/ntx-indicators/awesome-oscillator\n\n    Awesome Oscillator is a 34-period simple moving average, plotted through\n    the central points of the bars (H+L)/2, and subtracted from the 5-period\n    simple moving average, graphed across the central points of the bars\n    (H+L)/2.\n\n    MEDIAN PRICE = (HIGH+LOW)/2\n\n    AO = SMA(MEDIAN PRICE, 5)-SMA(MEDIAN PRICE, 34)\n\n    where\n\n    SMA \xe2\x80\x94 Simple Moving Average.\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        s(int): short period.\n        len(int): long period.\n        fillna(bool): if True, fill nan values with -50.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, s: int = 5, len: int = 34, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._s = s\n        self._len = len\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        mp = 0.5 * (self._high + self._low)\n        min_periods_s = 0 if self._fillna else self._s\n        min_periods_len = 0 if self._fillna else self._len\n        self._ao = mp.rolling(\n            self._s, min_periods=min_periods_s).mean() - mp.rolling(self._len, min_periods=min_periods_len).mean()\n\n    def ao(self) -> pd.Series:\n        """"""Awesome Oscillator\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        ao = self._check_fillna(self._ao, value=0)\n        return pd.Series(ao, name=\'ao\')\n\n\nclass WilliamsRIndicator(IndicatorMixin):\n    """"""Williams %R\n\n    Developed by Larry Williams, Williams %R is a momentum indicator that is\n    the inverse of the Fast Stochastic Oscillator. Also referred to as %R,\n    Williams %R reflects the level of the close relative to the highest high\n    for the look-back period. In contrast, the Stochastic Oscillator reflects\n    the level of the close relative to the lowest low. %R corrects for the\n    inversion by multiplying the raw value by -100. As a result, the Fast\n    Stochastic Oscillator and Williams %R produce the exact same lines, only\n    the scaling is different. Williams %R oscillates from 0 to -100.\n\n    Readings from 0 to -20 are considered overbought. Readings from -80 to -100\n    are considered oversold.\n\n    Unsurprisingly, signals derived from the Stochastic Oscillator are also\n    applicable to Williams %R.\n\n    %R = (Highest High - Close)/(Highest High - Lowest Low) * -100\n\n    Lowest Low = lowest low for the look-back period\n    Highest High = highest high for the look-back period\n    %R is multiplied by -100 correct the inversion and move the decimal.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:williams_r\n\n    The Williams %R oscillates from 0 to -100. When the indicator produces\n    readings from 0 to -20, this indicates overbought market conditions. When\n    readings are -80 to -100, it indicates oversold market conditions.\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        lbp(int): lookback period.\n        fillna(bool): if True, fill nan values with -50.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series, lbp: int = 14, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._lbp = lbp\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._lbp\n        hh = self._high.rolling(self._lbp, min_periods=min_periods).max()  # highest high over lookback period lbp\n        ll = self._low.rolling(self._lbp, min_periods=min_periods).min()  # lowest low over lookback period lbp\n        self._wr = -100 * (hh - self._close) / (hh - ll)\n\n    def wr(self) -> pd.Series:\n        """"""Williams %R\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        wr = self._check_fillna(self._wr, value=-50)\n        return pd.Series(wr, name=\'wr\')\n\n\ndef rsi(close, n=14, fillna=False):\n    """"""Relative Strength Index (RSI)\n\n    Compares the magnitude of recent gains and losses over a specified time\n    period to measure speed and change of price movements of a security. It is\n    primarily used to attempt to identify overbought or oversold conditions in\n    the trading of an asset.\n\n    https://www.investopedia.com/terms/r/rsi.asp\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return RSIIndicator(close=close, n=n, fillna=fillna).rsi()\n\n\ndef tsi(close, r=25, s=13, fillna=False):\n    """"""True strength index (TSI)\n\n    Shows both trend direction and overbought/oversold conditions.\n\n    https://en.wikipedia.org/wiki/True_strength_index\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        r(int): high period.\n        s(int): low period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return TSIIndicator(close=close, r=r, s=s, fillna=fillna).tsi()\n\n\ndef uo(high, low, close, s=7, m=14, len=28, ws=4.0, wm=2.0, wl=1.0, fillna=False):\n    """"""Ultimate Oscillator\n\n    Larry Williams\' (1976) signal, a momentum oscillator designed to capture\n    momentum across three different timeframes.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ultimate_oscillator\n\n    BP = Close - Minimum(Low or Prior Close).\n    TR = Maximum(High or Prior Close)  -  Minimum(Low or Prior Close)\n    Average7 = (7-period BP Sum) / (7-period TR Sum)\n    Average14 = (14-period BP Sum) / (14-period TR Sum)\n    Average28 = (28-period BP Sum) / (28-period TR Sum)\n\n    UO = 100 x [(4 x Average7)+(2 x Average14)+Average28]/(4+2+1)\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        s(int): short period.\n        m(int): medium period.\n        len(int): long period.\n        ws(float): weight of short BP average for UO.\n        wm(float): weight of medium BP average for UO.\n        wl(float): weight of long BP average for UO.\n        fillna(bool): if True, fill nan values with 50.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    return UltimateOscillator(\n        high=high, low=low, close=close, s=s, m=m, len=len, ws=ws, wm=wm, wl=wl, fillna=fillna).uo()\n\n\ndef stoch(high, low, close, n=14, d_n=3, fillna=False):\n    """"""Stochastic Oscillator\n\n    Developed in the late 1950s by George Lane. The stochastic\n    oscillator presents the location of the closing price of a\n    stock in relation to the high and low range of the price\n    of a stock over a period of time, typically a 14-day period.\n\n    https://www.investopedia.com/terms/s/stochasticoscillator.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        d_n(int): sma period over stoch_k\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n\n    return StochasticOscillator(high=high, low=low, close=close, n=n, d_n=d_n, fillna=fillna).stoch()\n\n\ndef stoch_signal(high, low, close, n=14, d_n=3, fillna=False):\n    """"""Stochastic Oscillator Signal\n\n    Shows SMA of Stochastic Oscillator. Typically a 3 day SMA.\n\n    https://www.investopedia.com/terms/s/stochasticoscillator.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        d_n(int): sma period over stoch_k\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return StochasticOscillator(high=high, low=low, close=close, n=n, d_n=d_n, fillna=fillna).stoch_signal()\n\n\ndef wr(high, low, close, lbp=14, fillna=False):\n    """"""Williams %R\n\n    From: http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:williams_r\n\n    Developed by Larry Williams, Williams %R is a momentum indicator that is\n    the inverse of the Fast Stochastic Oscillator. Also referred to as %R,\n    Williams %R reflects the level of the close relative to the highest high\n    for the look-back period. In contrast, the Stochastic Oscillator reflects\n    the level of the close relative to the lowest low. %R corrects for the\n    inversion by multiplying the raw value by -100. As a result, the Fast\n    Stochastic Oscillator and Williams %R produce the exact same lines, only\n    the scaling is different. Williams %R oscillates from 0 to -100.\n\n    Readings from 0 to -20 are considered overbought. Readings from -80 to -100\n    are considered oversold.\n\n    Unsurprisingly, signals derived from the Stochastic Oscillator are also\n    applicable to Williams %R.\n\n    %R = (Highest High - Close)/(Highest High - Lowest Low) * -100\n\n    Lowest Low = lowest low for the look-back period\n    Highest High = highest high for the look-back period\n    %R is multiplied by -100 correct the inversion and move the decimal.\n\n    From: https://www.investopedia.com/terms/w/williamsr.asp\n    The Williams %R oscillates from 0 to -100. When the indicator produces\n    readings from 0 to -20, this indicates overbought market conditions. When\n    readings are -80 to -100, it indicates oversold market conditions.\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        lbp(int): lookback period.\n        fillna(bool): if True, fill nan values with -50.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return WilliamsRIndicator(high=high, low=low, close=close, lbp=lbp, fillna=fillna).wr()\n\n\ndef ao(high, low, s=5, len=34, fillna=False):\n    """"""Awesome Oscillator\n\n    From: https://www.tradingview.com/wiki/Awesome_Oscillator_(AO)\n\n    The Awesome Oscillator is an indicator used to measure market momentum. AO\n    calculates the difference of a 34 Period and 5 Period Simple Moving\n    Averages. The Simple Moving Averages that are used are not calculated\n    using closing price but rather each bar\'s midpoints. AO is generally used\n    to affirm trends or to anticipate possible reversals.\n\n    From: https://www.ifcm.co.uk/ntx-indicators/awesome-oscillator\n\n    Awesome Oscillator is a 34-period simple moving average, plotted through\n    the central points of the bars (H+L)/2, and subtracted from the 5-period\n    simple moving average, graphed across the central points of the bars\n    (H+L)/2.\n\n    MEDIAN PRICE = (HIGH+LOW)/2\n\n    AO = SMA(MEDIAN PRICE, 5)-SMA(MEDIAN PRICE, 34)\n\n    where\n\n    SMA \xe2\x80\x94 Simple Moving Average.\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        s(int): short period.\n        len(int): long period.\n        fillna(bool): if True, fill nan values with -50.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return AwesomeOscillatorIndicator(high=high, low=low, s=s, len=len, fillna=fillna).ao()\n\n\ndef kama(close, n=10, pow1=2, pow2=30, fillna=False):\n    """"""Kaufman\'s Adaptive Moving Average (KAMA)\n\n    Moving average designed to account for market noise or volatility. KAMA\n    will closely follow prices when the price swings are relatively small and\n    the noise is low. KAMA will adjust when the price swings widen and follow\n    prices from a greater distance. This trend-following indicator can be\n    used to identify the overall trend, time turning points and filter price\n    movements.\n\n    https://www.tradingview.com/ideas/kama/\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n number of periods for the efficiency ratio.\n        pow1(int): number of periods for the fastest EMA constant.\n        pow2(int): number of periods for the slowest EMA constant.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return KAMAIndicator(close=close, n=n, pow1=pow1, pow2=pow2, fillna=fillna).kama()\n\n\ndef roc(close, n=12, fillna=False):\n    """"""Rate of Change (ROC)\n\n    The Rate-of-Change (ROC) indicator, which is also referred to as simply\n    Momentum, is a pure momentum oscillator that measures the percent change in\n    price from one period to the next. The ROC calculation compares the current\n    price with the price \xe2\x80\x9cn\xe2\x80\x9d periods ago. The plot forms an oscillator that\n    fluctuates above and below the zero line as the Rate-of-Change moves from\n    positive to negative. As a momentum oscillator, ROC signals include\n    centerline crossovers, divergences and overbought-oversold readings.\n    Divergences fail to foreshadow reversals more often than not, so this\n    article will forgo a detailed discussion on them. Even though centerline\n    crossovers are prone to whipsaw, especially short-term, these crossovers\n    can be used to identify the overall trend. Identifying overbought or\n    oversold extremes comes naturally to the Rate-of-Change oscillator.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:rate_of_change_roc_and_momentum\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n periods.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    return ROCIndicator(close=close, n=n, fillna=fillna).roc()\n'"
ta/others.py,1,"b'""""""\n.. module:: others\n   :synopsis: Others Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\nimport numpy as np\nimport pandas as pd\n\nfrom ta.utils import IndicatorMixin\n\n\nclass DailyReturnIndicator(IndicatorMixin):\n    """"""Daily Return (DR)\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, fillna: bool = False):\n        self._close = close\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._dr = (self._close / self._close.shift(1, fill_value=self._close.mean())) - 1\n        self._dr *= 100\n\n    def daily_return(self) -> pd.Series:\n        """"""Daily Return (DR)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        dr = self._check_fillna(self._dr, value=0)\n        return pd.Series(dr, name=\'d_ret\')\n\n\nclass DailyLogReturnIndicator(IndicatorMixin):\n    """"""Daily Log Return (DLR)\n\n    https://stackoverflow.com/questions/31287552/logarithmic-returns-in-pandas-dataframe\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, fillna: bool = False):\n        self._close = close\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._dr = np.log(self._close).diff()\n        self._dr *= 100\n\n    def daily_log_return(self) -> pd.Series:\n        """"""Daily Log Return (DLR)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        dr = self._check_fillna(self._dr, value=0)\n        return pd.Series(dr, name=\'d_logret\')\n\n\nclass CumulativeReturnIndicator(IndicatorMixin):\n    """"""Cumulative Return (CR)\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, fillna: bool = False):\n        self._close = close\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._cr = (self._close / self._close.iloc[0]) - 1\n        self._cr *= 100\n\n    def cumulative_return(self) -> pd.Series:\n        """"""Cumulative Return (CR)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        cr = self._check_fillna(self._cr, value=-1)\n        return pd.Series(cr, name=\'cum_ret\')\n\n\ndef daily_return(close, fillna=False):\n    """"""Daily Return (DR)\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return DailyReturnIndicator(close=close, fillna=fillna).daily_return()\n\n\ndef daily_log_return(close, fillna=False):\n    """"""Daily Log Return (DLR)\n\n    https://stackoverflow.com/questions/31287552/logarithmic-returns-in-pandas-dataframe\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return DailyLogReturnIndicator(close=close, fillna=fillna).daily_log_return()\n\n\ndef cumulative_return(close, fillna=False):\n    """"""Cumulative Return (CR)\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return CumulativeReturnIndicator(close=close, fillna=fillna).cumulative_return()\n'"
ta/trend.py,16,"b'""""""\n.. module:: trend\n   :synopsis: Trend Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\nimport numpy as np\nimport pandas as pd\n\nfrom ta.utils import IndicatorMixin, ema, get_min_max, sma\n\n\nclass AroonIndicator(IndicatorMixin):\n    """"""Aroon Indicator\n\n    Identify when trends are likely to change direction.\n\n    Aroon Up = ((N - Days Since N-day High) / N) x 100\n    Aroon Down = ((N - Days Since N-day Low) / N) x 100\n    Aroon Indicator = Aroon Up - Aroon Down\n\n    https://www.investopedia.com/terms/a/aroon.asp\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 25, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._n\n        rolling_close = self._close.rolling(self._n, min_periods=min_periods)\n        self._aroon_up = rolling_close.apply(\n            lambda x: float(np.argmax(x) + 1) / self._n * 100, raw=True)\n        self._aroon_down = rolling_close.apply(\n            lambda x: float(np.argmin(x) + 1) / self._n * 100, raw=True)\n\n    def aroon_up(self) -> pd.Series:\n        """"""Aroon Up Channel\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        aroon_up = self._check_fillna(self._aroon_up, value=0)\n        return pd.Series(aroon_up, name=f\'aroon_up_{self._n}\')\n\n    def aroon_down(self) -> pd.Series:\n        """"""Aroon Down Channel\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        aroon_down = self._check_fillna(self._aroon_down, value=0)\n        return pd.Series(aroon_down, name=f\'aroon_down_{self._n}\')\n\n    def aroon_indicator(self) -> pd.Series:\n        """"""Aroon Indicator\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        aroon_diff = self._aroon_up - self._aroon_down\n        aroon_diff = self._check_fillna(aroon_diff, value=0)\n        return pd.Series(aroon_diff, name=f\'aroon_ind_{self._n}\')\n\n\nclass MACD(IndicatorMixin):\n    """"""Moving Average Convergence Divergence (MACD)\n\n    Is a trend-following momentum indicator that shows the relationship between\n    two moving averages of prices.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:moving_average_convergence_divergence_macd\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n_fast(int): n period short-term.\n        n_slow(int): n period long-term.\n        n_sign(int): n period to signal.\n        fillna(bool): if True, fill nan values.\n    """"""\n    def __init__(self,\n                 close: pd.Series,\n                 n_slow: int = 26,\n                 n_fast: int = 12,\n                 n_sign: int = 9,\n                 fillna: bool = False):\n        self._close = close\n        self._n_slow = n_slow\n        self._n_fast = n_fast\n        self._n_sign = n_sign\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._emafast = ema(self._close, self._n_fast, self._fillna)\n        self._emaslow = ema(self._close, self._n_slow, self._fillna)\n        self._macd = self._emafast - self._emaslow\n        self._macd_signal = ema(self._macd, self._n_sign, self._fillna)\n        self._macd_diff = self._macd - self._macd_signal\n\n    def macd(self) -> pd.Series:\n        """"""MACD Line\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        macd = self._check_fillna(self._macd, value=0)\n        return pd.Series(macd, name=f\'MACD_{self._n_fast}_{self._n_slow}\')\n\n    def macd_signal(self) -> pd.Series:\n        """"""Signal Line\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n\n        macd_signal = self._check_fillna(self._macd_signal, value=0)\n        return pd.Series(macd_signal, name=f\'MACD_sign_{self._n_fast}_{self._n_slow}\')\n\n    def macd_diff(self) -> pd.Series:\n        """"""MACD Histogram\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        macd_diff = self._check_fillna(self._macd_diff, value=0)\n        return pd.Series(macd_diff, name=f\'MACD_diff_{self._n_fast}_{self._n_slow}\')\n\n\nclass EMAIndicator(IndicatorMixin):\n    """"""EMA - Exponential Moving Average\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 14, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n\n    def ema_indicator(self) -> pd.Series:\n        """"""Exponential Moving Average (EMA)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        ema_ = ema(self._close, self._n, self._fillna)\n        return pd.Series(ema_, name=f\'ema_{self._n}\')\n\n\nclass SMAIndicator(IndicatorMixin):\n    """"""SMA - Simple Moving Average\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n\n    def sma_indicator(self) -> pd.Series:\n        """"""Simple Moving Average (SMA)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        sma_ = sma(self._close, self._n, self._fillna)\n        return pd.Series(sma_, name=f\'sma_{self._n}\')\n\n\nclass TRIXIndicator(IndicatorMixin):\n    """"""Trix (TRIX)\n\n    Shows the percent rate of change of a triple exponentially smoothed moving\n    average.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:trix\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 15, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        ema1 = ema(self._close, self._n, self._fillna)\n        ema2 = ema(ema1, self._n, self._fillna)\n        ema3 = ema(ema2, self._n, self._fillna)\n        self._trix = (ema3 - ema3.shift(1, fill_value=ema3.mean())) / ema3.shift(1, fill_value=ema3.mean())\n        self._trix *= 100\n\n    def trix(self) -> pd.Series:\n        """"""Trix (TRIX)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        trix = self._check_fillna(self._trix, value=0)\n        return pd.Series(trix, name=f\'trix_{self._n}\')\n\n\nclass MassIndex(IndicatorMixin):\n    """"""Mass Index (MI)\n\n    It uses the high-low range to identify trend reversals based on range\n    expansions. It identifies range bulges that can foreshadow a reversal of\n    the current trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:mass_index\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n(int): n low period.\n        n2(int): n high period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, n: int = 9, n2: int = 25, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._n = n\n        self._n2 = n2\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._n2\n        amplitude = self._high - self._low\n        ema1 = ema(amplitude, self._n, self._fillna)\n        ema2 = ema(ema1, self._n, self._fillna)\n        mass = ema1 / ema2\n        self._mass = mass.rolling(self._n2, min_periods=min_periods).sum()\n\n    def mass_index(self) -> pd.Series:\n        """"""Mass Index (MI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        mass = self._check_fillna(self._mass, value=0)\n        return pd.Series(mass, name=f\'mass_index_{self._n}_{self._n2}\')\n\n\nclass IchimokuIndicator(IndicatorMixin):\n    """"""Ichimoku Kink\xc5\x8d Hy\xc5\x8d (Ichimoku)\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n1(int): n1 low period.\n        n2(int): n2 medium period.\n        n3(int): n3 high period.\n        visual(bool): if True, shift n2 values.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, n1: int = 9, n2: int = 26, n3: int = 52,\n                 visual: bool = False, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._n1 = n1\n        self._n2 = n2\n        self._n3 = n3\n        self._visual = visual\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods_n1 = 0 if self._fillna else self._n1\n        min_periods_n2 = 0 if self._fillna else self._n2\n        self._conv = 0.5 * (\n                self._high.rolling(self._n1, min_periods=min_periods_n1).max() +\n                self._low.rolling(self._n1, min_periods=min_periods_n1).min())\n        self._base = 0.5 * (\n                self._high.rolling(self._n2, min_periods=min_periods_n2).max() +\n                self._low.rolling(self._n2, min_periods=min_periods_n2).min())\n\n    def ichimoku_conversion_line(self) -> pd.Series:\n        """"""Tenkan-sen (Conversion Line)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        conversion = self._check_fillna(self._conv, value=-1)\n        return pd.Series(conversion, name=f\'ichimoku_conv_{self._n1}_{self._n2}\')\n\n    def ichimoku_base_line(self) -> pd.Series:\n        """"""Kijun-sen (Base Line)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        base = self._check_fillna(self._base, value=-1)\n        return pd.Series(base, name=f\'ichimoku_base_{self._n1}_{self._n2}\')\n\n    def ichimoku_a(self) -> pd.Series:\n        """"""Senkou Span A (Leading Span A)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        spana = 0.5 * (self._conv + self._base)\n        spana = spana.shift(self._n2, fill_value=spana.mean()) if self._visual else spana\n        spana = self._check_fillna(spana, value=-1)\n        return pd.Series(spana, name=f\'ichimoku_a_{self._n1}_{self._n2}\')\n\n    def ichimoku_b(self) -> pd.Series:\n        """"""Senkou Span B (Leading Span B)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        spanb = 0.5 * (self._high.rolling(self._n3, min_periods=0).max()\n                       + self._low.rolling(self._n3, min_periods=0).min())\n        spanb = spanb.shift(self._n2, fill_value=spanb.mean()) if self._visual else spanb\n        spanb = self._check_fillna(spanb, value=-1)\n        return pd.Series(spanb, name=f\'ichimoku_b_{self._n1}_{self._n2}\')\n\n\nclass KSTIndicator(IndicatorMixin):\n    """"""KST Oscillator (KST Signal)\n\n    It is useful to identify major stock market cycle junctures because its\n    formula is weighed to be more greatly influenced by the longer and more\n    dominant time spans, in order to better reflect the primary swings of stock\n    market cycle.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:know_sure_thing_kst\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        r1(int): r1 period.\n        r2(int): r2 period.\n        r3(int): r3 period.\n        r4(int): r4 period.\n        n1(int): n1 smoothed period.\n        n2(int): n2 smoothed period.\n        n3(int): n3 smoothed period.\n        n4(int): n4 smoothed period.\n        nsig(int): n period to signal.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, r1: int = 10, r2: int = 15, r3: int = 20, r4: int = 30,\n                 n1: int = 10, n2: int = 10, n3: int = 10, n4: int = 15, nsig: int = 9,\n                 fillna: bool = False):\n        self._close = close\n        self._r1 = r1\n        self._r2 = r2\n        self._r3 = r3\n        self._r4 = r4\n        self._n1 = n1\n        self._n2 = n2\n        self._n3 = n3\n        self._n4 = n4\n        self._nsig = nsig\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods_n1 = 0 if self._fillna else self._n1\n        min_periods_n2 = 0 if self._fillna else self._n2\n        min_periods_n3 = 0 if self._fillna else self._n3\n        min_periods_n4 = 0 if self._fillna else self._n4\n        rocma1 = (\n            (self._close - self._close.shift(self._r1, fill_value=self._close.mean()))\n            / self._close.shift(self._r1, fill_value=self._close.mean())).rolling(\n                self._n1, min_periods=min_periods_n1).mean()\n        rocma2 = (\n            (self._close - self._close.shift(self._r2, fill_value=self._close.mean()))\n            / self._close.shift(self._r2, fill_value=self._close.mean())).rolling(\n                self._n2, min_periods=min_periods_n2).mean()\n        rocma3 = (\n            (self._close - self._close.shift(self._r3, fill_value=self._close.mean()))\n            / self._close.shift(self._r3, fill_value=self._close.mean())).rolling(\n                self._n3, min_periods=min_periods_n3).mean()\n        rocma4 = (\n            (self._close - self._close.shift(self._r4, fill_value=self._close.mean()))\n            / self._close.shift(self._r4, fill_value=self._close.mean())).rolling(\n                self._n4, min_periods=min_periods_n4).mean()\n        self._kst = 100 * (rocma1 + 2 * rocma2 + 3 * rocma3 + 4 * rocma4)\n        self._kst_sig = self._kst.rolling(self._nsig, min_periods=0).mean()\n\n    def kst(self) -> pd.Series:\n        """"""Know Sure Thing (KST)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        kst = self._check_fillna(self._kst, value=0)\n        return pd.Series(kst, name=\'kst\')\n\n    def kst_sig(self) -> pd.Series:\n        """"""Signal Line Know Sure Thing (KST)\n\n        nsig-period SMA of KST\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        kst_sig = self._check_fillna(self._kst_sig, value=0)\n        return pd.Series(kst_sig, name=\'kst_sig\')\n\n    def kst_diff(self) -> pd.Series:\n        """"""Diff Know Sure Thing (KST)\n\n        KST - Signal_KST\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        kst_diff = self._kst - self._kst_sig\n        kst_diff = self._check_fillna(kst_diff, value=0)\n        return pd.Series(kst_diff, name=\'kst_diff\')\n\n\nclass DPOIndicator(IndicatorMixin):\n    """"""Detrended Price Oscillator (DPO)\n\n    Is an indicator designed to remove trend from price and make it easier to\n    identify cycles.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:detrended_price_osci\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n    def __init__(self, close: pd.Series, n: int = 20, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._n\n        self._dpo = (self._close.shift(int((0.5 * self._n) + 1), fill_value=self._close.mean())\n                     - self._close.rolling(self._n, min_periods=min_periods).mean())\n\n    def dpo(self) -> pd.Series:\n        """"""Detrended Price Oscillator (DPO)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        dpo = self._check_fillna(self._dpo, value=0)\n        return pd.Series(dpo, name=\'dpo_\'+str(self._n))\n\n\nclass CCIIndicator(IndicatorMixin):\n    """"""Commodity Channel Index (CCI)\n\n    CCI measures the difference between a security\'s price change and its\n    average price change. High positive readings indicate that prices are well\n    above their average, which is a show of strength. Low negative readings\n    indicate that prices are well below their average, which is a show of\n    weakness.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        c(int): constant.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self,\n                 high: pd.Series,\n                 low: pd.Series,\n                 close: pd.Series,\n                 n: int = 20,\n                 c: float = 0.015,\n                 fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._n = n\n        self._c = c\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n\n        def _mad(x):\n            return np.mean(np.abs(x-np.mean(x)))\n\n        min_periods = 0 if self._fillna else self._n\n        pp = (self._high + self._low + self._close) / 3.0\n        self._cci = ((pp - pp.rolling(self._n, min_periods=min_periods).mean())\n                     / (self._c * pp.rolling(self._n, min_periods=min_periods).apply(_mad, True)))\n\n    def cci(self) -> pd.Series:\n        """"""Commodity Channel Index (CCI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        cci = self._check_fillna(self._cci, value=0)\n        return pd.Series(cci, name=\'cci\')\n\n\nclass ADXIndicator(IndicatorMixin):\n    """"""Average Directional Movement Index (ADX)\n\n    The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI)\n    are derived from smoothed averages of these differences, and measure trend\n    direction over time. These two indicators are often referred to\n    collectively as the Directional Movement Indicator (DMI).\n\n    The Average Directional Index (ADX) is in turn derived from the smoothed\n    averages of the difference between +DI and -DI, and measures the strength\n    of the trend (regardless of direction) over time.\n\n    Using these three indicators together, chartists can determine both the\n    direction and strength of the trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_directional_index_adx\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series, n: int = 14, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        assert self._n != 0, ""N may not be 0 and is %r"" % n\n\n        cs = self._close.shift(1)\n        pdm = get_min_max(self._high, cs, \'max\')\n        pdn = get_min_max(self._low, cs, \'min\')\n        tr = pdm - pdn\n\n        self._trs_initial = np.zeros(self._n-1)\n        self._trs = np.zeros(len(self._close) - (self._n - 1))\n        self._trs[0] = tr.dropna()[0:self._n].sum()\n        tr = tr.reset_index(drop=True)\n\n        for i in range(1, len(self._trs)-1):\n            self._trs[i] = self._trs[i-1] - (self._trs[i-1]/float(self._n)) + tr[self._n+i]\n\n        up = self._high - self._high.shift(1)\n        dn = self._low.shift(1) - self._low\n        pos = abs(((up > dn) & (up > 0)) * up)\n        neg = abs(((dn > up) & (dn > 0)) * dn)\n\n        self._dip = np.zeros(len(self._close) - (self._n - 1))\n        self._dip[0] = pos.dropna()[0:self._n].sum()\n\n        pos = pos.reset_index(drop=True)\n\n        for i in range(1, len(self._dip)-1):\n            self._dip[i] = self._dip[i-1] - (self._dip[i-1]/float(self._n)) + pos[self._n+i]\n\n        self._din = np.zeros(len(self._close) - (self._n - 1))\n        self._din[0] = neg.dropna()[0:self._n].sum()\n\n        neg = neg.reset_index(drop=True)\n\n        for i in range(1, len(self._din)-1):\n            self._din[i] = self._din[i-1] - (self._din[i-1]/float(self._n)) + neg[self._n+i]\n\n    def adx(self) -> pd.Series:\n        """"""Average Directional Index (ADX)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        dip = np.zeros(len(self._trs))\n        for i in range(len(self._trs)):\n            dip[i] = 100 * (self._dip[i]/self._trs[i])\n\n        din = np.zeros(len(self._trs))\n        for i in range(len(self._trs)):\n            din[i] = 100 * (self._din[i]/self._trs[i])\n\n        dx = 100 * np.abs((dip - din) / (dip + din))\n\n        adx = np.zeros(len(self._trs))\n        adx[self._n] = dx[0:self._n].mean()\n\n        for i in range(self._n+1, len(adx)):\n            adx[i] = ((adx[i-1] * (self._n - 1)) + dx[i-1]) / float(self._n)\n\n        adx = np.concatenate((self._trs_initial, adx), axis=0)\n        self._adx = pd.Series(data=adx, index=self._close.index)\n\n        adx = self._check_fillna(self._adx, value=20)\n        return pd.Series(adx, name=\'adx\')\n\n    def adx_pos(self) -> pd.Series:\n        """"""Plus Directional Indicator (+DI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        dip = np.zeros(len(self._close))\n        for i in range(1, len(self._trs)-1):\n            dip[i+self._n] = 100 * (self._dip[i]/self._trs[i])\n\n        adx_pos = self._check_fillna(pd.Series(dip, index=self._close.index), value=20)\n        return pd.Series(adx_pos, name=\'adx_pos\')\n\n    def adx_neg(self) -> pd.Series:\n        """"""Minus Directional Indicator (-DI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        din = np.zeros(len(self._close))\n        for i in range(1, len(self._trs)-1):\n            din[i+self._n] = 100 * (self._din[i]/self._trs[i])\n\n        adx_neg = self._check_fillna(pd.Series(din, index=self._close.index), value=20)\n        return pd.Series(adx_neg, name=\'adx_neg\')\n\n\nclass VortexIndicator(IndicatorMixin):\n    """"""Vortex Indicator (VI)\n\n    It consists of two oscillators that capture positive and negative trend\n    movement. A bullish signal triggers when the positive trend indicator\n    crosses above the negative trend indicator or a key level.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:vortex_indicator\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series, n: int = 14, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        cs = self._close.shift(1, fill_value=self._close.mean())\n        tr = self._true_range(self._high, self._low, cs)\n        min_periods = 0 if self._fillna else self._n\n        trn = tr.rolling(self._n, min_periods=min_periods).sum()\n        vmp = np.abs(self._high - self._low.shift(1))\n        vmm = np.abs(self._low - self._high.shift(1))\n        self._vip = vmp.rolling(self._n, min_periods=min_periods).sum() / trn\n        self._vin = vmm.rolling(self._n, min_periods=min_periods).sum() / trn\n\n    def vortex_indicator_pos(self):\n        """"""+VI\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        vip = self._check_fillna(self._vip, value=1)\n        return pd.Series(vip, name=\'vip\')\n\n    def vortex_indicator_neg(self):\n        """"""-VI\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        vin = self._check_fillna(self._vin, value=1)\n        return pd.Series(vin, name=\'vin\')\n\n    def vortex_indicator_diff(self):\n        """"""Diff VI\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        vid = self._vip - self._vin\n        vid = self._check_fillna(vid, value=0)\n        return pd.Series(vid, name=\'vid\')\n\n\nclass PSARIndicator(IndicatorMixin):\n    """"""Parabolic Stop and Reverse (Parabolic SAR)\n\n    The Parabolic Stop and Reverse, more commonly known as the\n    Parabolic SAR,is a trend-following indicator developed by\n    J. Welles Wilder. The Parabolic SAR is displayed as a single\n    parabolic line (or dots) underneath the price bars in an uptrend,\n    and above the price bars in a downtrend.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        step(float): the Acceleration Factor used to compute the SAR.\n        max_step(float): the maximum value allowed for the Acceleration Factor.\n        fillna(bool): if True, fill nan values.\n    """"""\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series,\n                 step: float = 0.02, max_step: float = 0.20,\n                 fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._step = step\n        self._max_step = max_step\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        up_trend = True\n        af = self._step\n        up_trend_high = self._high.iloc[0]\n        down_trend_low = self._low.iloc[0]\n\n        self._psar = self._close.copy()\n        self._psar_up = pd.Series(index=self._psar.index)\n        self._psar_down = pd.Series(index=self._psar.index)\n\n        for i in range(2, len(self._close)):\n            reversal = False\n\n            max_high = self._high.iloc[i]\n            min_low = self._low.iloc[i]\n\n            if up_trend:\n                self._psar.iloc[i] = self._psar.iloc[i-1] + (\n                    af * (up_trend_high - self._psar.iloc[i-1]))\n\n                if min_low < self._psar.iloc[i]:\n                    reversal = True\n                    self._psar.iloc[i] = up_trend_high\n                    down_trend_low = min_low\n                    af = self._step\n                else:\n                    if max_high > up_trend_high:\n                        up_trend_high = max_high\n                        af = min(af + self._step, self._max_step)\n\n                    l1 = self._low.iloc[i-1]\n                    l2 = self._low.iloc[i-2]\n                    if l2 < self._psar.iloc[i]:\n                        self._psar.iloc[i] = l2\n                    elif l1 < self._psar.iloc[i]:\n                        self._psar.iloc[i] = l1\n            else:\n                self._psar.iloc[i] = self._psar.iloc[i-1] - (\n                    af * (self._psar.iloc[i-1] - down_trend_low))\n\n                if max_high > self._psar.iloc[i]:\n                    reversal = True\n                    self._psar.iloc[i] = down_trend_low\n                    up_trend_high = max_high\n                    af = self._step\n                else:\n                    if min_low < down_trend_low:\n                        down_trend_low = min_low\n                        af = min(af + self._step, self._max_step)\n\n                    h1 = self._high.iloc[i-1]\n                    h2 = self._high.iloc[i-2]\n                    if h2 > self._psar.iloc[i]:\n                        self._psar[i] = h2\n                    elif h1 > self._psar.iloc[i]:\n                        self._psar.iloc[i] = h1\n\n            up_trend = up_trend != reversal  # XOR\n\n            if up_trend:\n                self._psar_up.iloc[i] = self._psar.iloc[i]\n            else:\n                self._psar_down.iloc[i] = self._psar.iloc[i]\n\n    def psar(self) -> pd.Series:\n        """"""PSAR value\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        psar = self._check_fillna(self._psar, value=-1)\n        return pd.Series(psar, name=\'psar\')\n\n    def psar_up(self) -> pd.Series:\n        """"""PSAR up trend value\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        psar_up = self._check_fillna(self._psar_up, value=-1)\n        return pd.Series(psar_up, name=\'psarup\')\n\n    def psar_down(self) -> pd.Series:\n        """"""PSAR down trend value\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        psar_down = self._check_fillna(self._psar_down, value=-1)\n        return pd.Series(psar_down, name=\'psardown\')\n\n    def psar_up_indicator(self) -> pd.Series:\n        """"""PSAR up trend value\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        indicator = self._psar_up.where(self._psar_up.notnull()\n                                        & self._psar_up.shift(1).isnull(), 0)\n        indicator = indicator.where(indicator == 0, 1)\n        return pd.Series(indicator, index=self._close.index, name=\'psariup\')\n\n    def psar_down_indicator(self) -> pd.Series:\n        """"""PSAR down trend value\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        indicator = self._psar_up.where(self._psar_down.notnull()\n                                        & self._psar_down.shift(1).isnull(), 0)\n        indicator = indicator.where(indicator == 0, 1)\n        return pd.Series(indicator, index=self._close.index, name=\'psaridown\')\n\n\ndef ema_indicator(close, n=12, fillna=False):\n    """"""Exponential Moving Average (EMA)\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return EMAIndicator(close=close, n=n, fillna=fillna).ema_indicator()\n\n\ndef sma_indicator(close, n=12, fillna=False):\n    """"""Simple Moving Average (SMA)\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return SMAIndicator(close=close, n=n, fillna=fillna).sma_indicator()\n\n\ndef macd(close, n_slow=26, n_fast=12, fillna=False):\n    """"""Moving Average Convergence Divergence (MACD)\n\n    Is a trend-following momentum indicator that shows the relationship between\n    two moving averages of prices.\n\n    https://en.wikipedia.org/wiki/MACD\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n_fast(int): n period short-term.\n        n_slow(int): n period long-term.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return MACD(close=close, n_slow=n_slow, n_fast=n_fast, n_sign=9, fillna=fillna).macd()\n\n\ndef macd_signal(close, n_slow=26, n_fast=12, n_sign=9, fillna=False):\n    """"""Moving Average Convergence Divergence (MACD Signal)\n\n    Shows EMA of MACD.\n\n    https://en.wikipedia.org/wiki/MACD\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n_fast(int): n period short-term.\n        n_slow(int): n period long-term.\n        n_sign(int): n period to signal.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return MACD(close=close, n_slow=n_slow, n_fast=n_fast, n_sign=n_sign, fillna=fillna).macd_signal()\n\n\ndef macd_diff(close, n_slow=26, n_fast=12, n_sign=9, fillna=False):\n    """"""Moving Average Convergence Divergence (MACD Diff)\n\n    Shows the relationship between MACD and MACD Signal.\n\n    https://en.wikipedia.org/wiki/MACD\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n_fast(int): n period short-term.\n        n_slow(int): n period long-term.\n        n_sign(int): n period to signal.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return MACD(close=close, n_slow=n_slow, n_fast=n_fast, n_sign=n_sign, fillna=fillna).macd_diff()\n\n\ndef adx(high, low, close, n=14, fillna=False):\n    """"""Average Directional Movement Index (ADX)\n\n    The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI)\n    are derived from smoothed averages of these differences, and measure trend\n    direction over time. These two indicators are often referred to\n    collectively as the Directional Movement Indicator (DMI).\n\n    The Average Directional Index (ADX) is in turn derived from the smoothed\n    averages of the difference between +DI and -DI, and measures the strength\n    of the trend (regardless of direction) over time.\n\n    Using these three indicators together, chartists can determine both the\n    direction and strength of the trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_directional_index_adx\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return ADXIndicator(high=high, low=low, close=close, n=n, fillna=fillna).adx()\n\n\ndef adx_pos(high, low, close, n=14, fillna=False):\n    """"""Average Directional Movement Index Positive (ADX)\n\n    The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI)\n    are derived from smoothed averages of these differences, and measure trend\n    direction over time. These two indicators are often referred to\n    collectively as the Directional Movement Indicator (DMI).\n\n    The Average Directional Index (ADX) is in turn derived from the smoothed\n    averages of the difference between +DI and -DI, and measures the strength\n    of the trend (regardless of direction) over time.\n\n    Using these three indicators together, chartists can determine both the\n    direction and strength of the trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_directional_index_adx\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return ADXIndicator(high=high, low=low, close=close, n=n, fillna=fillna).adx_pos()\n\n\ndef adx_neg(high, low, close, n=14, fillna=False):\n    """"""Average Directional Movement Index Negative (ADX)\n\n    The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI)\n    are derived from smoothed averages of these differences, and measure trend\n    direction over time. These two indicators are often referred to\n    collectively as the Directional Movement Indicator (DMI).\n\n    The Average Directional Index (ADX) is in turn derived from the smoothed\n    averages of the difference between +DI and -DI, and measures the strength\n    of the trend (regardless of direction) over time.\n\n    Using these three indicators together, chartists can determine both the\n    direction and strength of the trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_directional_index_adx\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return ADXIndicator(high=high, low=low, close=close, n=n, fillna=fillna).adx_neg()\n\n\ndef vortex_indicator_pos(high, low, close, n=14, fillna=False):\n    """"""Vortex Indicator (VI)\n\n    It consists of two oscillators that capture positive and negative trend\n    movement. A bullish signal triggers when the positive trend indicator\n    crosses above the negative trend indicator or a key level.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:vortex_indicator\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return VortexIndicator(high=high, low=low, close=close, n=n, fillna=fillna).vortex_indicator_pos()\n\n\ndef vortex_indicator_neg(high, low, close, n=14, fillna=False):\n    """"""Vortex Indicator (VI)\n\n    It consists of two oscillators that capture positive and negative trend\n    movement. A bearish signal triggers when the negative trend indicator\n    crosses above the positive trend indicator or a key level.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:vortex_indicator\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return VortexIndicator(high=high, low=low, close=close, n=n, fillna=fillna).vortex_indicator_neg()\n\n\ndef trix(close, n=15, fillna=False):\n    """"""Trix (TRIX)\n\n    Shows the percent rate of change of a triple exponentially smoothed moving\n    average.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:trix\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return TRIXIndicator(close=close, n=n, fillna=fillna).trix()\n\n\ndef mass_index(high, low, n=9, n2=25, fillna=False):\n    """"""Mass Index (MI)\n\n    It uses the high-low range to identify trend reversals based on range\n    expansions. It identifies range bulges that can foreshadow a reversal of\n    the current trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:mass_index\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n(int): n low period.\n        n2(int): n high period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    return MassIndex(high=high, low=low, n=n, n2=n2, fillna=fillna).mass_index()\n\n\ndef cci(high, low, close, n=20, c=0.015, fillna=False):\n    """"""Commodity Channel Index (CCI)\n\n    CCI measures the difference between a security\'s price change and its\n    average price change. High positive readings indicate that prices are well\n    above their average, which is a show of strength. Low negative readings\n    indicate that prices are well below their average, which is a show of\n    weakness.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n periods.\n        c(int): constant.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    return CCIIndicator(high=high, low=low, close=close, n=n, c=c, fillna=fillna).cci()\n\n\ndef dpo(close, n=20, fillna=False):\n    """"""Detrended Price Oscillator (DPO)\n\n    Is an indicator designed to remove trend from price and make it easier to\n    identify cycles.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:detrended_price_osci\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return DPOIndicator(close=close, n=n, fillna=fillna).dpo()\n\n\ndef kst(close, r1=10, r2=15, r3=20, r4=30, n1=10, n2=10, n3=10, n4=15, fillna=False):\n    """"""KST Oscillator (KST)\n\n    It is useful to identify major stock market cycle junctures because its\n    formula is weighed to be more greatly influenced by the longer and more\n    dominant time spans, in order to better reflect the primary swings of stock\n    market cycle.\n\n    https://en.wikipedia.org/wiki/KST_oscillator\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        r1(int): r1 period.\n        r2(int): r2 period.\n        r3(int): r3 period.\n        r4(int): r4 period.\n        n1(int): n1 smoothed period.\n        n2(int): n2 smoothed period.\n        n3(int): n3 smoothed period.\n        n4(int): n4 smoothed period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return KSTIndicator(\n        close=close, r1=r1, r2=r2, r3=r3, r4=r4, n1=n1, n2=n2, n3=n3, n4=n4, nsig=9, fillna=fillna).kst()\n\n\ndef kst_sig(close, r1=10, r2=15, r3=20, r4=30, n1=10, n2=10, n3=10, n4=15, nsig=9, fillna=False):\n    """"""KST Oscillator (KST Signal)\n\n    It is useful to identify major stock market cycle junctures because its\n    formula is weighed to be more greatly influenced by the longer and more\n    dominant time spans, in order to better reflect the primary swings of stock\n    market cycle.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:know_sure_thing_kst\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        r1(int): r1 period.\n        r2(int): r2 period.\n        r3(int): r3 period.\n        r4(int): r4 period.\n        n1(int): n1 smoothed period.\n        n2(int): n2 smoothed period.\n        n3(int): n3 smoothed period.\n        n4(int): n4 smoothed period.\n        nsig(int): n period to signal.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return KSTIndicator(\n        close=close, r1=r1, r2=r2, r3=r3, r4=r4, n1=n1, n2=n2, n3=n3, n4=n4, nsig=nsig, fillna=fillna).kst_sig()\n\n\ndef ichimoku_conversion_line(high, low, n1=9, n2=26, visual=False, fillna=False) -> pd.Series:\n    """"""Tenkan-sen (Conversion Line)\n\n    It identifies the trend and look for potential signals within that trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n1(int): n1 low period.\n        n2(int): n2 medium period.\n        visual(bool): if True, shift n2 values.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return IchimokuIndicator(\n        high=high, low=low, n1=n1, n2=n2, n3=52, visual=visual, fillna=fillna).ichimoku_conversion_line()\n\n\ndef ichimoku_base_line(high, low, n1=9, n2=26, visual=False, fillna=False) -> pd.Series:\n    """"""Kijun-sen (Base Line)\n\n    It identifies the trend and look for potential signals within that trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n1(int): n1 low period.\n        n2(int): n2 medium period.\n        visual(bool): if True, shift n2 values.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return IchimokuIndicator(\n        high=high, low=low, n1=n1, n2=n2, n3=52, visual=visual, fillna=fillna).ichimoku_base_line()\n\n\ndef ichimoku_a(high, low, n1=9, n2=26, visual=False, fillna=False):\n    """"""Ichimoku Kink\xc5\x8d Hy\xc5\x8d (Ichimoku)\n\n    It identifies the trend and look for potential signals within that trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n1(int): n1 low period.\n        n2(int): n2 medium period.\n        visual(bool): if True, shift n2 values.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return IchimokuIndicator(high=high, low=low, n1=n1, n2=n2, n3=52, visual=visual, fillna=fillna).ichimoku_a()\n\n\ndef ichimoku_b(high, low, n2=26, n3=52, visual=False, fillna=False):\n    """"""Ichimoku Kink\xc5\x8d Hy\xc5\x8d (Ichimoku)\n\n    It identifies the trend and look for potential signals within that trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        n2(int): n2 medium period.\n        n3(int): n3 high period.\n        visual(bool): if True, shift n2 values.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return IchimokuIndicator(high=high, low=low, n1=9, n2=n2, n3=n3, visual=visual, fillna=fillna).ichimoku_b()\n\n\ndef aroon_up(close, n=25, fillna=False):\n    """"""Aroon Indicator (AI)\n\n    Identify when trends are likely to change direction (uptrend).\n\n    Aroon Up - ((N - Days Since N-day High) / N) x 100\n\n    https://www.investopedia.com/terms/a/aroon.asp\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    return AroonIndicator(close=close, n=n, fillna=fillna).aroon_up()\n\n\ndef aroon_down(close, n=25, fillna=False):\n    """"""Aroon Indicator (AI)\n\n    Identify when trends are likely to change direction (downtrend).\n\n    Aroon Down - ((N - Days Since N-day Low) / N) x 100\n\n    https://www.investopedia.com/terms/a/aroon.asp\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return AroonIndicator(close=close, n=n, fillna=fillna).aroon_down()\n\n\ndef psar_up(high, low, close, step=0.02, max_step=0.20, fillna=False):\n    """"""Parabolic Stop and Reverse (Parabolic SAR)\n\n    Returns the PSAR series with non-N/A values for upward trends\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        step(float): the Acceleration Factor used to compute the SAR.\n        max_step(float): the maximum value allowed for the Acceleration Factor.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = PSARIndicator(high=high, low=low, close=close, step=step,\n                              max_step=max_step, fillna=fillna)\n    return indicator.psar_up()\n\n\ndef psar_down(high, low, close, step=0.02, max_step=0.20, fillna=False):\n    """"""Parabolic Stop and Reverse (Parabolic SAR)\n\n    Returns the PSAR series with non-N/A values for downward trends\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        step(float): the Acceleration Factor used to compute the SAR.\n        max_step(float): the maximum value allowed for the Acceleration Factor.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = PSARIndicator(high=high, low=low, close=close, step=step,\n                              max_step=max_step, fillna=fillna)\n    return indicator.psar_down()\n\n\ndef psar_up_indicator(high, low, close, step=0.02, max_step=0.20, fillna=False):\n    """"""Parabolic Stop and Reverse (Parabolic SAR) Upward Trend Indicator\n\n    Returns 1, if there is a reversal towards an upward trend. Else, returns 0.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        step(float): the Acceleration Factor used to compute the SAR.\n        max_step(float): the maximum value allowed for the Acceleration Factor.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = PSARIndicator(high=high, low=low, close=close, step=step,\n                              max_step=max_step, fillna=fillna)\n    return indicator.psar_up_indicator()\n\n\ndef psar_down_indicator(high, low, close, step=0.02, max_step=0.20, fillna=False):\n    """"""Parabolic Stop and Reverse (Parabolic SAR) Downward Trend Indicator\n\n    Returns 1, if there is a reversal towards an downward trend. Else, returns 0.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        step(float): the Acceleration Factor used to compute the SAR.\n        max_step(float): the maximum value allowed for the Acceleration Factor.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = PSARIndicator(high=high, low=low, close=close, step=step,\n                              max_step=max_step, fillna=fillna)\n    return indicator.psar_down_indicator()\n'"
ta/utils.py,5,"b'import math\n\nimport numpy as np\nimport pandas as pd\n\n\nclass IndicatorMixin:\n\n    def _check_fillna(self, serie: pd.Series, value: int = 0):\n        """"""Check if fillna flag is True.\n\n        Args:\n            serie(pandas.Series): dataset \'Close\' column.\n            value(int): value to fill gaps; if -1 fill values using \'backfill\' mode.\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        if self._fillna:\n            serie_output = serie.copy(deep=False)\n            serie_output = serie_output.replace([np.inf, -np.inf], np.nan)\n            if isinstance(value, int) and value == -1:\n                return serie_output.fillna(method=\'ffill\').fillna(value=-1)\n            else:\n                return serie_output.fillna(method=\'ffill\').fillna(value)\n        else:\n            return serie\n\n    def _true_range(self, high: pd.Series, low: pd.Series, prev_close: pd.Series):\n        tr1 = high - low\n        tr2 = (high - prev_close).abs()\n        tr3 = (low - prev_close).abs()\n        tr = pd.DataFrame(data={\'tr1\': tr1, \'tr2\': tr2, \'tr3\': tr3}).max(axis=1)\n        return tr\n\n\ndef dropna(df):\n    """"""Drop rows with ""Nans"" values\n    """"""\n    df = df.copy()\n    number_cols = df.select_dtypes(\'number\').columns.to_list()\n    df[number_cols] = df[number_cols][df[number_cols] < math.exp(709)]  # big number\n    df[number_cols] = df[number_cols][df[number_cols] != 0.0]\n    df = df.dropna()\n    return df\n\n\ndef sma(series, periods: int, fillna: bool = False):\n    min_periods = 0 if fillna else periods\n    return series.rolling(window=periods, min_periods=min_periods).mean()\n\n\ndef ema(series, periods, fillna=False):\n    min_periods = 0 if fillna else periods\n    return series.ewm(span=periods, min_periods=min_periods, adjust=False).mean()\n\n\ndef get_min_max(x1, x2, f=\'min\'):\n    """"""Find min or max value between two lists for each index\n    """"""\n    x1 = np.array(x1)\n    x2 = np.array(x2)\n    try:\n        if f == \'min\':\n            return pd.Series(np.amin([x1, x2], axis=0))\n        elif f == \'max\':\n            return pd.Series(np.amax([x1, x2], axis=0))\n        else:\n            raise ValueError(\'""f"" variable value should be ""min"" or ""max""\')\n    except Exception as e:\n        return e\n'"
ta/volatility.py,5,"b'""""""\n.. module:: volatility\n   :synopsis: Volatility Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\nimport numpy as np\nimport pandas as pd\n\nfrom ta.utils import IndicatorMixin, ema\n\n\nclass AverageTrueRange(IndicatorMixin):\n    """"""Average True Range (ATR)\n\n    The indicator provide an indication of the degree of price volatility.\n    Strong moves, in either direction, are often accompanied by large ranges,\n    or large True Ranges.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_true_range_atr\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series, n: int = 14, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        cs = self._close.shift(1)\n        tr = self._true_range(self._high, self._low, cs)\n        atr = np.zeros(len(self._close))\n        atr[self._n-1] = tr[0:self._n].mean()\n        for i in range(self._n, len(atr)):\n            atr[i] = (atr[i-1] * (self._n-1) + tr.iloc[i]) / float(self._n)\n        self._atr = pd.Series(data=atr, index=tr.index)\n\n    def average_true_range(self) -> pd.Series:\n        """"""Average True Range (ATR)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        atr = self._check_fillna(self._atr, value=0)\n        return pd.Series(atr, name=\'atr\')\n\n\nclass BollingerBands(IndicatorMixin):\n    """"""Bollinger Bands\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, n: int = 20, ndev: int = 2, fillna: bool = False):\n        self._close = close\n        self._n = n\n        self._ndev = ndev\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        min_periods = 0 if self._fillna else self._n\n        self._mavg = self._close.rolling(self._n, min_periods=min_periods).mean()\n        self._mstd = self._close.rolling(self._n, min_periods=min_periods).std(ddof=0)\n        self._hband = self._mavg + self._ndev * self._mstd\n        self._lband = self._mavg - self._ndev * self._mstd\n\n    def bollinger_mavg(self) -> pd.Series:\n        """"""Bollinger Channel Middle Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        mavg = self._check_fillna(self._mavg, value=-1)\n        return pd.Series(mavg, name=\'mavg\')\n\n    def bollinger_hband(self) -> pd.Series:\n        """"""Bollinger Channel High Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        hband = self._check_fillna(self._hband, value=-1)\n        return pd.Series(hband, name=\'hband\')\n\n    def bollinger_lband(self) -> pd.Series:\n        """"""Bollinger Channel Low Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        lband = self._check_fillna(self._lband, value=-1)\n        return pd.Series(lband, name=\'lband\')\n\n    def bollinger_wband(self) -> pd.Series:\n        """"""Bollinger Channel Band Width\n\n        From: https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_band_width\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        wband = ((self._hband - self._lband) / self._mavg) * 100\n        wband = self._check_fillna(wband, value=0)\n        return pd.Series(wband, name=\'bbiwband\')\n\n    def bollinger_pband(self) -> pd.Series:\n        """"""Bollinger Channel Percentage Band\n\n        From: https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_band_perce\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        pband = (self._close - self._lband) / (self._hband - self._lband)\n        pband = self._check_fillna(pband, value=0)\n        return pd.Series(pband, name=\'bbipband\')\n\n    def bollinger_hband_indicator(self) -> pd.Series:\n        """"""Bollinger Channel Indicator Crossing High Band (binary).\n\n        It returns 1, if close is higher than bollinger_hband. Else, it returns 0.\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        hband = pd.Series(np.where(self._close > self._hband, 1.0, 0.0), index=self._close.index)\n        hband = self._check_fillna(hband, value=0)\n        return pd.Series(hband, index=self._close.index, name=\'bbihband\')\n\n    def bollinger_lband_indicator(self) -> pd.Series:\n        """"""Bollinger Channel Indicator Crossing Low Band (binary).\n\n        It returns 1, if close is lower than bollinger_lband. Else, it returns 0.\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        lband = pd.Series(np.where(self._close < self._lband, 1.0, 0.0), index=self._close.index)\n        lband = self._check_fillna(lband, value=0)\n        return pd.Series(lband, name=\'bbilband\')\n\n\nclass KeltnerChannel(IndicatorMixin):\n    """"""KeltnerChannel\n\n    Keltner Channels are a trend following indicator used to identify reversals with channel breakouts and\n    channel direction. Channels can also be used to identify overbought and oversold levels when the trend\n    is flat.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n    """"""\n\n    def __init__(\n            self, high: pd.Series, low: pd.Series, close: pd.Series, n: int = 20, n_atr: int = 10,\n            fillna: bool = False, ov: bool = True):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._n = n\n        self._n_atr = n_atr\n        self._fillna = fillna\n        self._ov = ov\n        self._run()\n\n    def _run(self):\n        min_periods = 1 if self._fillna else self._n\n        if self._ov:\n            self._tp = ((self._high + self._low + self._close) / 3.0).rolling(self._n, min_periods=min_periods).mean()\n            self._tp_high = (((4 * self._high) - (2 * self._low) + self._close) / 3.0).rolling(\n                self._n, min_periods=0).mean()\n            self._tp_low = (((-2 * self._high) + (4 * self._low) + self._close) / 3.0).rolling(\n                self._n, min_periods=0).mean()\n        else:\n            self._tp = self._close.ewm(span=self._n, min_periods=min_periods, adjust=False).mean()\n            atr = AverageTrueRange(\n                close=self._close, high=self._high, low=self._low, n=self._n_atr, fillna=self._fillna\n            ).average_true_range()\n            self._tp_high = self._tp + (2*atr)\n            self._tp_low = self._tp - (2*atr)\n\n    def keltner_channel_mband(self) -> pd.Series:\n        """"""Keltner Channel Middle Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        tp = self._check_fillna(self._tp, value=-1)\n        return pd.Series(tp, name=\'mavg\')\n\n    def keltner_channel_hband(self) -> pd.Series:\n        """"""Keltner Channel High Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        tp = self._check_fillna(self._tp_high, value=-1)\n        return pd.Series(tp, name=\'kc_hband\')\n\n    def keltner_channel_lband(self) -> pd.Series:\n        """"""Keltner Channel Low Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        tp_low = self._check_fillna(self._tp_low, value=-1)\n        return pd.Series(tp_low, name=\'kc_lband\')\n\n    def keltner_channel_wband(self) -> pd.Series:\n        """"""Keltner Channel Band Width\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        wband = ((self._tp_high - self._tp_low) / self._tp) * 100\n        wband = self._check_fillna(wband, value=0)\n        return pd.Series(wband, name=\'bbiwband\')\n\n    def keltner_channel_pband(self) -> pd.Series:\n        """"""Keltner Channel Percentage Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        pband = (self._close - self._tp_low) / (self._tp_high - self._tp_low)\n        pband = self._check_fillna(pband, value=0)\n        return pd.Series(pband, name=\'bbipband\')\n\n    def keltner_channel_hband_indicator(self) -> pd.Series:\n        """"""Keltner Channel Indicator Crossing High Band (binary)\n\n        It returns 1, if close is higher than keltner_channel_hband. Else, it returns 0.\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        hband = pd.Series(np.where(self._close > self._tp_high, 1.0, 0.0), index=self._close.index)\n        hband = self._check_fillna(hband, value=0)\n        return pd.Series(hband, name=\'dcihband\')\n\n    def keltner_channel_lband_indicator(self) -> pd.Series:\n        """"""Keltner Channel Indicator Crossing Low Band (binary)\n\n        It returns 1, if close is lower than keltner_channel_lband. Else, it returns 0.\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        lband = pd.Series(np.where(self._close < self._tp_low, 1.0, 0.0), index=self._close.index)\n        lband = self._check_fillna(lband, value=0)\n        return pd.Series(lband, name=\'dcilband\')\n\n\nclass DonchianChannel(IndicatorMixin):\n    """"""Donchian Channel\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(\n            self,\n            high: pd.Series,\n            low: pd.Series,\n            close: pd.Series,\n            n: int = 20,\n            offset: int = 0,\n            fillna: bool = False):\n        self._offset = offset\n        self._close = close\n        self._high = high\n        self._low = low\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._min_periods = 1 if self._fillna else self._n\n        self._hband = self._high.rolling(self._n, min_periods=self._min_periods).max()\n        self._lband = self._low.rolling(self._n, min_periods=self._min_periods).min()\n\n    def donchian_channel_hband(self) -> pd.Series:\n        """"""Donchian Channel High Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        hband = self._check_fillna(self._hband, value=-1)\n        if self._offset != 0:\n            hband = hband.shift(self._offset)\n        return pd.Series(hband, name=\'dchband\')\n\n    def donchian_channel_lband(self) -> pd.Series:\n        """"""Donchian Channel Low Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        lband = self._check_fillna(self._lband, value=-1)\n        if self._offset != 0:\n            lband = lband.shift(self._offset)\n        return pd.Series(lband, name=\'dclband\')\n\n    def donchian_channel_mband(self) -> pd.Series:\n        """"""Donchian Channel Middle Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        mband = ((self._hband - self._lband) / 2.0) + self._lband\n        mband = self._check_fillna(mband, value=-1)\n        if self._offset != 0:\n            mband = mband.shift(self._offset)\n        return pd.Series(mband, name=\'dcmband\')\n\n    def donchian_channel_wband(self) -> pd.Series:\n        """"""Donchian Channel Band Width\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        mavg = self._close.rolling(self._n, min_periods=self._min_periods).mean()\n        wband = ((self._hband - self._lband) / mavg) * 100\n        wband = self._check_fillna(wband, value=0)\n        if self._offset != 0:\n            wband = wband.shift(self._offset)\n        return pd.Series(wband, name=\'dcwband\')\n\n    def donchian_channel_pband(self) -> pd.Series:\n        """"""Donchian Channel Percentage Band\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        pband = (self._close - self._lband) / (self._hband - self._lband)\n        pband = self._check_fillna(pband, value=0)\n        if self._offset != 0:\n            pband = pband.shift(self._offset)\n        return pd.Series(pband, name=\'dcpband\')\n\n\ndef average_true_range(high, low, close, n=14, fillna=False):\n    """"""Average True Range (ATR)\n\n    The indicator provide an indication of the degree of price volatility.\n    Strong moves, in either direction, are often accompanied by large ranges,\n    or large True Ranges.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:average_true_range_atr\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = AverageTrueRange(high=high, low=low, close=close, n=n, fillna=fillna)\n    return indicator.average_true_range()\n\n\ndef bollinger_mavg(close, n=20, fillna=False):\n    """"""Bollinger Bands (BB)\n\n    N-period simple moving average (MA).\n\n    https://en.wikipedia.org/wiki/Bollinger_Bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, fillna=fillna)\n    return indicator.bollinger_mavg()\n\n\ndef bollinger_hband(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger Bands (BB)\n\n    Upper band at K times an N-period standard deviation above the moving\n    average (MA + Kdeviation).\n\n    https://en.wikipedia.org/wiki/Bollinger_Bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_hband()\n\n\ndef bollinger_lband(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger Bands (BB)\n\n    Lower band at K times an N-period standard deviation below the moving\n    average (MA \xe2\x88\x92 Kdeviation).\n\n    https://en.wikipedia.org/wiki/Bollinger_Bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_lband()\n\n\ndef bollinger_wband(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger Channel Band Width\n\n    From: https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_band_width\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_wband()\n\n\ndef bollinger_pband(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger Channel Percentage Band\n\n    From: https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_band_perce\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_pband()\n\n\ndef bollinger_hband_indicator(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger High Band Indicator\n\n    Returns 1, if close is higher than bollinger high band. Else, return 0.\n\n    https://en.wikipedia.org/wiki/Bollinger_Bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_hband_indicator()\n\n\ndef bollinger_lband_indicator(close, n=20, ndev=2, fillna=False):\n    """"""Bollinger Low Band Indicator\n\n    Returns 1, if close is lower than bollinger low band. Else, return 0.\n\n    https://en.wikipedia.org/wiki/Bollinger_Bands\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        ndev(int): n factor standard deviation\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = BollingerBands(close=close, n=n, ndev=ndev, fillna=fillna)\n    return indicator.bollinger_lband_indicator()\n\n\ndef keltner_channel_mband(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner channel (KC)\n\n    Showing a simple moving average line (central) of typical price.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_mband()\n\n\ndef keltner_channel_hband(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner channel (KC)\n\n    Showing a simple moving average line (high) of typical price.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_hband()\n\n\ndef keltner_channel_lband(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner channel (KC)\n\n    Showing a simple moving average line (low) of typical price.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_lband()\n\n\ndef keltner_channel_wband(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner Channel Band Width\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_wband()\n\n\ndef keltner_channel_pband(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner Channel Percentage Band\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_pband()\n\n\ndef keltner_channel_hband_indicator(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner Channel High Band Indicator (KC)\n\n    Returns 1, if close is higher than keltner high band channel. Else,\n    return 0.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_hband_indicator()\n\n\ndef keltner_channel_lband_indicator(high, low, close, n=20, n_atr=10, fillna=False, ov=True):\n    """"""Keltner Channel Low Band Indicator (KC)\n\n    Returns 1, if close is lower than keltner low band channel. Else, return 0.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        n_atr(int): n atr period. Only valid if ov param is False.\n        fillna(bool): if True, fill nan values.\n        ov(bool): if True, use original version as the centerline (SMA of typical price)\n            if False, use EMA of close as the centerline. More info:\n            https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = KeltnerChannel(high=high, low=low, close=close, n=n, n_atr=n_atr, fillna=fillna, ov=ov)\n    return indicator.keltner_channel_lband_indicator()\n\n\ndef donchian_channel_hband(high, low, close, n=20, offset=0, fillna=False):\n    """"""Donchian Channel High Band (DC)\n\n    The upper band marks the highest price of an issue for n periods.\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = DonchianChannel(high=high, low=low, close=close, n=n, offset=offset, fillna=fillna)\n    return indicator.donchian_channel_hband()\n\n\ndef donchian_channel_lband(high, low, close, n=20, offset=0, fillna=False):\n    """"""Donchian Channel Low Band (DC)\n\n    The lower band marks the lowest price for n periods.\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = DonchianChannel(high=high, low=low, close=close, n=n, offset=offset, fillna=fillna)\n    return indicator.donchian_channel_lband()\n\n\ndef donchian_channel_mband(high, low, close, n=10, offset=0, fillna=False):\n    """"""Donchian Channel Middle Band (DC)\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = DonchianChannel(high=high, low=low, close=close, n=n, offset=offset, fillna=fillna)\n    return indicator.donchian_channel_mband()\n\n\ndef donchian_channel_wband(high, low, close, n=10, offset=0, fillna=False):\n    """"""Donchian Channel Band Width (DC)\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = DonchianChannel(high=high, low=low, close=close, n=n, offset=offset, fillna=fillna)\n    return indicator.donchian_channel_wband()\n\n\ndef donchian_channel_pband(high, low, close, n=10, offset=0, fillna=False):\n    """"""Donchian Channel Percentage Band (DC)\n\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    indicator = DonchianChannel(high=high, low=low, close=close, n=n, offset=offset, fillna=fillna)\n    return indicator.donchian_channel_pband()\n'"
ta/volume.py,7,"b'""""""\n.. module:: volume\n   :synopsis: Volume Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n\n""""""\n\nimport numpy as np\nimport pandas as pd\n\nfrom ta.utils import IndicatorMixin, ema\n\n\nclass AccDistIndexIndicator(IndicatorMixin):\n    """"""Accumulation/Distribution Index (ADI)\n\n    Acting as leading indicator of price movements.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:accumulation_distribution_line\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._volume = volume\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        clv = ((self._close - self._low) - (self._high - self._close)) / (self._high - self._low)\n        clv = clv.fillna(0.0)  # float division by zero\n        ad = clv * self._volume\n        self._ad = ad.cumsum()\n\n    def acc_dist_index(self) -> pd.Series:\n        """"""Accumulation/Distribution Index (ADI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        ad = self._check_fillna(self._ad, value=0)\n        return pd.Series(ad, name=\'adi\')\n\n\nclass OnBalanceVolumeIndicator(IndicatorMixin):\n    """"""On-balance volume (OBV)\n\n    It relates price and volume in the stock market. OBV is based on a\n    cumulative total volume.\n\n    https://en.wikipedia.org/wiki/On-balance_volume\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, volume: pd.Series, fillna: bool = False):\n        self._close = close\n        self._volume = volume\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        obv = np.where(self._close < self._close.shift(1), -self._volume, self._volume)\n        self._obv = pd.Series(obv, index=self._close.index).cumsum()\n\n    def on_balance_volume(self) -> pd.Series:\n        """"""On-balance volume (OBV)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        obv = self._check_fillna(self._obv, value=0)\n        return pd.Series(obv, name=\'obv\')\n\n\nclass ChaikinMoneyFlowIndicator(IndicatorMixin):\n    """"""Chaikin Money Flow (CMF)\n\n    It measures the amount of Money Flow Volume over a specific period.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:chaikin_money_flow_cmf\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, close: pd.Series,\n                 volume: pd.Series, n: int = 20, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._volume = volume\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        mfv = ((self._close - self._low) - (self._high - self._close)) / (self._high - self._low)\n        mfv = mfv.fillna(0.0)  # float division by zero\n        mfv *= self._volume\n        min_periods = 0 if self._fillna else self._n\n        self._cmf = (\n                mfv.rolling(self._n, min_periods=min_periods).sum() /\n                self._volume.rolling(self._n, min_periods=min_periods).sum())\n\n    def chaikin_money_flow(self) -> pd.Series:\n        """"""Chaikin Money Flow (CMF)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        cmf = self._check_fillna(self._cmf, value=0)\n        return pd.Series(cmf, name=\'cmf\')\n\n\nclass ForceIndexIndicator(IndicatorMixin):\n    """"""Force Index (FI)\n\n    It illustrates how strong the actual buying or selling pressure is. High\n    positive values mean there is a strong rising trend, and low values signify\n    a strong downward trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:force_index\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, volume: pd.Series, n: int = 13, fillna: bool = False):\n        self._close = close\n        self._volume = volume\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        fi = (self._close - self._close.shift(1)) * self._volume\n        self._fi = ema(fi, self._n, fillna=self._fillna)\n\n    def force_index(self) -> pd.Series:\n        """"""Force Index (FI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        fi = self._check_fillna(self._fi, value=0)\n        return pd.Series(fi, name=f\'fi_{self._n}\')\n\n\nclass EaseOfMovementIndicator(IndicatorMixin):\n    """"""Ease of movement (EoM, EMV)\n\n    It relate an asset\'s price change to its volume and is particularly useful\n    for assessing the strength of a trend.\n\n    https://en.wikipedia.org/wiki/Ease_of_movement\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, high: pd.Series, low: pd.Series, volume: pd.Series, n: int = 14, fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._volume = volume\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        self._emv = (self._high.diff(1) + self._low.diff(1)) * (self._high - self._low) / (2 * self._volume)\n        self._emv *= 100000000\n\n    def ease_of_movement(self) -> pd.Series:\n        """"""Ease of movement (EoM, EMV)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        emv = self._check_fillna(self._emv, value=0)\n        return pd.Series(emv, name=f\'eom_{self._n}\')\n\n    def sma_ease_of_movement(self) -> pd.Series:\n        """"""Signal Ease of movement (EoM, EMV)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        min_periods = 0 if self._fillna else self._n\n        emv = self._emv.rolling(self._n, min_periods=min_periods).mean()\n        emv = self._check_fillna(emv, value=0)\n        return pd.Series(emv, name=f\'sma_eom_{self._n}\')\n\n\nclass VolumePriceTrendIndicator(IndicatorMixin):\n    """"""Volume-price trend (VPT)\n\n    Is based on a running cumulative volume that adds or substracts a multiple\n    of the percentage change in share price trend and current volume, depending\n    upon the investment\'s upward or downward movements.\n\n    https://en.wikipedia.org/wiki/Volume%E2%80%93price_trend\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self, close: pd.Series, volume: pd.Series, fillna: bool = False):\n        self._close = close\n        self._volume = volume\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        vpt = (self._volume * ((self._close - self._close.shift(1, fill_value=self._close.mean()))\n                               / self._close.shift(1, fill_value=self._close.mean())))\n        self._vpt = vpt.shift(1, fill_value=vpt.mean()) + vpt\n\n    def volume_price_trend(self) -> pd.Series:\n        """"""Volume-price trend (VPT)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        vpt = self._check_fillna(self._vpt, value=0)\n        return pd.Series(vpt, name=\'vpt\')\n\n\nclass NegativeVolumeIndexIndicator(IndicatorMixin):\n    """"""Negative Volume Index (NVI)\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:negative_volume_inde\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values with 1000.\n    """"""\n\n    def __init__(self, close: pd.Series, volume: pd.Series, fillna: bool = False):\n        self._close = close\n        self._volume = volume\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        price_change = self._close.pct_change()\n        vol_decrease = (self._volume.shift(1) > self._volume)\n        self._nvi = pd.Series(data=np.nan, index=self._close.index, dtype=\'float64\', name=\'nvi\')\n        self._nvi.iloc[0] = 1000\n        for i in range(1, len(self._nvi)):\n            if vol_decrease.iloc[i]:\n                self._nvi.iloc[i] = self._nvi.iloc[i - 1] * (1.0 + price_change.iloc[i])\n            else:\n                self._nvi.iloc[i] = self._nvi.iloc[i - 1]\n\n    def negative_volume_index(self) -> pd.Series:\n        """"""Negative Volume Index (NVI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        # IDEA: There shouldn\'t be any na; might be better to throw exception\n        nvi = self._check_fillna(self._nvi, value=1000)\n        return pd.Series(nvi, name=\'nvi\')\n\n\nclass MFIIndicator(IndicatorMixin):\n    """"""Money Flow Index (MFI)\n\n    Uses both price and volume to measure buying and selling pressure. It is\n    positive when the typical price rises (buying pressure) and negative when\n    the typical price declines (selling pressure). A ratio of positive and\n    negative money flow is then plugged into an RSI formula to create an\n    oscillator that moves between zero and one hundred.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:money_flow_index_mfi\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n    """"""\n\n    def __init__(self,\n                 high: pd.Series,\n                 low: pd.Series,\n                 close: pd.Series,\n                 volume: pd.Series,\n                 n: int = 14,\n                 fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._volume = volume\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        # 1 typical price\n        tp = (self._high + self._low + self._close) / 3.0\n\n        # 2 up or down column\n        up_down = np.where(tp > tp.shift(1), 1, np.where(tp < tp.shift(1), -1, 0))\n\n        # 3 money flow\n        mf = tp * self._volume * up_down\n\n        # 4 positive and negative money flow with n periods\n        min_periods = 0 if self._fillna else self._n\n        n_positive_mf = mf.rolling(\n            self._n, min_periods=min_periods).apply(lambda x: np.sum(np.where(x >= 0.0, x, 0.0)), raw=True)\n        n_negative_mf = abs(\n            mf.rolling(self._n, min_periods=min_periods).apply(lambda x: np.sum(np.where(x < 0.0, x, 0.0)), raw=True))\n\n        # n_positive_mf = np.where(mf.rolling(self._n).sum() >= 0.0, mf, 0.0)\n        # n_negative_mf = abs(np.where(mf.rolling(self._n).sum() < 0.0, mf, 0.0))\n\n        # 5 money flow index\n        mr = n_positive_mf / n_negative_mf\n        self._mr = (100 - (100 / (1 + mr)))\n\n    def money_flow_index(self) -> pd.Series:\n        """"""Money Flow Index (MFI)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        mr = self._check_fillna(self._mr, value=50)\n        return pd.Series(mr, name=f\'mfi_{self._n}\')\n\n\nclass VolumeWeightedAveragePrice(IndicatorMixin):\n    """"""Volume Weighted Average Price (VWAP)\n\n    VWAP equals the dollar value of all trading periods divided\n    by the total trading volume for the current day.\n    The calculation starts when trading opens and ends when it closes.\n    Because it is good for the current trading day only,\n    intraday periods and data are used in the calculation.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:vwap_intraday\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n\n    def __init__(self,\n                 high: pd.Series,\n                 low: pd.Series,\n                 close: pd.Series,\n                 volume: pd.Series,\n                 n: int = 14,\n                 fillna: bool = False):\n        self._high = high\n        self._low = low\n        self._close = close\n        self._volume = volume\n        self._n = n\n        self._fillna = fillna\n        self._run()\n\n    def _run(self):\n        # 1 typical price\n        tp = (self._high + self._low + self._close) / 3.0\n\n        # 2 typical price * volume\n        pv = (tp * self._volume)\n\n        # 3 total price * volume\n        min_periods = 0 if self._fillna else self._n\n        total_pv = pv.rolling(self._n, min_periods=min_periods).sum()\n\n        # 4 total volume\n        total_volume = self._volume.rolling(self._n, min_periods=min_periods).sum()\n\n        self.vwap = total_pv / total_volume\n\n    def volume_weighted_average_price(self) -> pd.Series:\n        """"""Volume Weighted Average Price (VWAP)\n\n        Returns:\n            pandas.Series: New feature generated.\n        """"""\n        vwap = self._check_fillna(self.vwap)\n        return pd.Series(vwap, name=f\'vwap_{self._n}\')\n\n\ndef acc_dist_index(high, low, close, volume, fillna=False):\n    """"""Accumulation/Distribution Index (ADI)\n\n    Acting as leading indicator of price movements.\n\n    https://en.wikipedia.org/wiki/Accumulation/distribution_index\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return AccDistIndexIndicator(high=high, low=low, close=close, volume=volume, fillna=fillna).acc_dist_index()\n\n\ndef on_balance_volume(close, volume, fillna=False):\n    """"""On-balance volume (OBV)\n\n    It relates price and volume in the stock market. OBV is based on a\n    cumulative total volume.\n\n    https://en.wikipedia.org/wiki/On-balance_volume\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return OnBalanceVolumeIndicator(close=close, volume=volume, fillna=fillna).on_balance_volume()\n\n\ndef chaikin_money_flow(high, low, close, volume, n=20, fillna=False):\n    """"""Chaikin Money Flow (CMF)\n\n    It measures the amount of Money Flow Volume over a specific period.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:chaikin_money_flow_cmf\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return ChaikinMoneyFlowIndicator(\n        high=high, low=low, close=close, volume=volume, n=n, fillna=fillna).chaikin_money_flow()\n\n\ndef force_index(close, volume, n=13, fillna=False):\n    """"""Force Index (FI)\n\n    It illustrates how strong the actual buying or selling pressure is. High\n    positive values mean there is a strong rising trend, and low values signify\n    a strong downward trend.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:force_index\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return ForceIndexIndicator(close=close, volume=volume, n=n, fillna=fillna).force_index()\n\n\ndef ease_of_movement(high, low, volume, n=14, fillna=False):\n    """"""Ease of movement (EoM, EMV)\n\n    It relate an asset\'s price change to its volume and is particularly useful\n    for assessing the strength of a trend.\n\n    https://en.wikipedia.org/wiki/Ease_of_movement\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return EaseOfMovementIndicator(\n        high=high, low=low, volume=volume, n=n, fillna=fillna).ease_of_movement()\n\n\ndef sma_ease_of_movement(high, low, volume, n=14, fillna=False):\n    """"""Ease of movement (EoM, EMV)\n\n    It relate an asset\'s price change to its volume and is particularly useful\n    for assessing the strength of a trend.\n\n    https://en.wikipedia.org/wiki/Ease_of_movement\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return EaseOfMovementIndicator(\n        high=high, low=low, volume=volume, n=n, fillna=fillna).sma_ease_of_movement()\n\n\ndef volume_price_trend(close, volume, fillna=False):\n    """"""Volume-price trend (VPT)\n\n    Is based on a running cumulative volume that adds or substracts a multiple\n    of the percentage change in share price trend and current volume, depending\n    upon the investment\'s upward or downward movements.\n\n    https://en.wikipedia.org/wiki/Volume%E2%80%93price_trend\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n    return VolumePriceTrendIndicator(close=close, volume=volume, fillna=fillna).volume_price_trend()\n\n\ndef negative_volume_index(close, volume, fillna=False):\n    """"""Negative Volume Index (NVI)\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:negative_volume_inde\n\n    The Negative Volume Index (NVI) is a cumulative indicator that uses the\n    change in volume to decide when the smart money is active. Paul Dysart\n    first developed this indicator in the 1930s. [...] Dysart\'s Negative Volume\n    Index works under the assumption that the smart money is active on days\n    when volume decreases and the not-so-smart money is active on days when\n    volume increases.\n\n    The cumulative NVI line was unchanged when volume increased from one\n    period to the other. In other words, nothing was done. Norman Fosback, of\n    Stock Market Logic, adjusted the indicator by substituting the percentage\n    price change for Net Advances.\n\n    This implementation is the Fosback version.\n\n    If today\'s volume is less than yesterday\'s volume then:\n        nvi(t) = nvi(t-1) * ( 1 + (close(t) - close(t-1)) / close(t-1) )\n    Else\n        nvi(t) = nvi(t-1)\n\n    Please note: the ""stockcharts.com"" example calculation just adds the\n    percentange change of price to previous NVI when volumes decline; other\n    sources indicate that the same percentage of the previous NVI value should\n    be added, which is what is implemented here.\n\n    Args:\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        fillna(bool): if True, fill nan values with 1000.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    See also:\n        https://en.wikipedia.org/wiki/Negative_volume_index\n    """"""\n    return NegativeVolumeIndexIndicator(close=close, volume=volume, fillna=fillna).negative_volume_index()\n\n\ndef money_flow_index(high, low, close, volume, n=14, fillna=False):\n    """"""Money Flow Index (MFI)\n\n    Uses both price and volume to measure buying and selling pressure. It is\n    positive when the typical price rises (buying pressure) and negative when\n    the typical price declines (selling pressure). A ratio of positive and\n    negative money flow is then plugged into an RSI formula to create an\n    oscillator that moves between zero and one hundred.\n\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:money_flow_index_mfi\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n\n    """"""\n    indicator = MFIIndicator(high=high, low=low, close=close, volume=volume, n=n, fillna=fillna)\n    return indicator.money_flow_index()\n\n\ndef volume_weighted_average_price(\n        high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series, n: int = 14, fillna: bool = False):\n    """"""Volume Weighted Average Price (VWAP)\n\n    VWAP equals the dollar value of all trading periods divided\n    by the total trading volume for the current day.\n    The calculation starts when trading opens and ends when it closes.\n    Because it is good for the current trading day only,\n    intraday periods and data are used in the calculation.\n\n    https://school.stockcharts.com/doku.php?id=technical_indicators:vwap_intraday\n\n    Args:\n        high(pandas.Series): dataset \'High\' column.\n        low(pandas.Series): dataset \'Low\' column.\n        close(pandas.Series): dataset \'Close\' column.\n        volume(pandas.Series): dataset \'Volume\' column.\n        n(int): n period.\n        fillna(bool): if True, fill nan values.\n\n    Returns:\n        pandas.Series: New feature generated.\n    """"""\n\n    indicator = VolumeWeightedAveragePrice(high=high, low=low, close=close, volume=volume, n=n, fillna=fillna)\n    return indicator.volume_weighted_average_price()\n\n\n# TODO\ndef put_call_ratio():\n    """"""Put/Call ratio (PCR)\n    https://en.wikipedia.org/wiki/Put/call_ratio\n    """"""\n    # TODO\n    pass\n'"
ta/wrapper.py,0,"b'""""""\n.. module:: wrapper\n   :synopsis: Wrapper of Indicators.\n\n.. moduleauthor:: Dario Lopez Padial (Bukosabino)\n""""""\n\nimport pandas as pd\n\nfrom ta.momentum import (AwesomeOscillatorIndicator, KAMAIndicator,\n                         ROCIndicator, RSIIndicator, StochasticOscillator,\n                         TSIIndicator, UltimateOscillator, WilliamsRIndicator)\nfrom ta.others import (CumulativeReturnIndicator, DailyLogReturnIndicator,\n                       DailyReturnIndicator)\nfrom ta.trend import (MACD, ADXIndicator, AroonIndicator, CCIIndicator,\n                      DPOIndicator, EMAIndicator, IchimokuIndicator,\n                      KSTIndicator, MassIndex, PSARIndicator, SMAIndicator,\n                      TRIXIndicator, VortexIndicator)\nfrom ta.volatility import (AverageTrueRange, BollingerBands, DonchianChannel,\n                           KeltnerChannel)\nfrom ta.volume import (AccDistIndexIndicator, ChaikinMoneyFlowIndicator,\n                       EaseOfMovementIndicator, ForceIndexIndicator,\n                       MFIIndicator, NegativeVolumeIndexIndicator,\n                       OnBalanceVolumeIndicator, VolumePriceTrendIndicator,\n                       VolumeWeightedAveragePrice)\n\n\ndef add_volume_ta(df: pd.DataFrame, high: str, low: str, close: str, volume: str,\n                  fillna: bool = False, colprefix: str = """") -> pd.DataFrame:\n    """"""Add volume technical analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        high (str): Name of \'high\' column.\n        low (str): Name of \'low\' column.\n        close (str): Name of \'close\' column.\n        volume (str): Name of \'volume\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n\n    # Accumulation Distribution Index\n    df[f\'{colprefix}volume_adi\'] = AccDistIndexIndicator(\n        high=df[high], low=df[low], close=df[close], volume=df[volume], fillna=fillna).acc_dist_index()\n\n    # On Balance Volume\n    df[f\'{colprefix}volume_obv\'] = OnBalanceVolumeIndicator(\n        close=df[close], volume=df[volume], fillna=fillna).on_balance_volume()\n\n    # Chaikin Money Flow\n    df[f\'{colprefix}volume_cmf\'] = ChaikinMoneyFlowIndicator(\n        high=df[high], low=df[low], close=df[close], volume=df[volume], fillna=fillna).chaikin_money_flow()\n\n    # Force Index\n    df[f\'{colprefix}volume_fi\'] = ForceIndexIndicator(\n        close=df[close], volume=df[volume], n=13, fillna=fillna).force_index()\n\n    # Money Flow Indicator\n    df[f\'{colprefix}momentum_mfi\'] = MFIIndicator(\n        high=df[high], low=df[low], close=df[close], volume=df[volume], n=14, fillna=fillna).money_flow_index()\n\n    # Ease of Movement\n    indicator = EaseOfMovementIndicator(high=df[high], low=df[low], volume=df[volume], n=14, fillna=fillna)\n    df[f\'{colprefix}volume_em\'] = indicator.ease_of_movement()\n    df[f\'{colprefix}volume_sma_em\'] = indicator.sma_ease_of_movement()\n\n    # Volume Price Trend\n    df[f\'{colprefix}volume_vpt\'] = VolumePriceTrendIndicator(\n        close=df[close], volume=df[volume], fillna=fillna).volume_price_trend()\n\n    # Negative Volume Index\n    df[f\'{colprefix}volume_nvi\'] = NegativeVolumeIndexIndicator(\n        close=df[close], volume=df[volume], fillna=fillna).negative_volume_index()\n\n    # Volume Weighted Average Price\n    df[f\'{colprefix}volume_vwap\'] = VolumeWeightedAveragePrice(\n        high=df[high], low=df[low], close=df[close], volume=df[volume], n=14, fillna=fillna\n    ).volume_weighted_average_price()\n\n    return df\n\n\ndef add_volatility_ta(df: pd.DataFrame, high: str, low: str, close: str,\n                      fillna: bool = False, colprefix: str = """") -> pd.DataFrame:\n    """"""Add volatility technical analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        high (str): Name of \'high\' column.\n        low (str): Name of \'low\' column.\n        close (str): Name of \'close\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n\n    # Average True Range\n    df[f\'{colprefix}volatility_atr\'] = AverageTrueRange(\n        close=df[close], high=df[high], low=df[low], n=10, fillna=fillna).average_true_range()\n\n    # Bollinger Bands\n    indicator_bb = BollingerBands(close=df[close], n=20, ndev=2, fillna=fillna)\n    df[f\'{colprefix}volatility_bbm\'] = indicator_bb.bollinger_mavg()\n    df[f\'{colprefix}volatility_bbh\'] = indicator_bb.bollinger_hband()\n    df[f\'{colprefix}volatility_bbl\'] = indicator_bb.bollinger_lband()\n    df[f\'{colprefix}volatility_bbw\'] = indicator_bb.bollinger_wband()\n    df[f\'{colprefix}volatility_bbp\'] = indicator_bb.bollinger_pband()\n    df[f\'{colprefix}volatility_bbhi\'] = indicator_bb.bollinger_hband_indicator()\n    df[f\'{colprefix}volatility_bbli\'] = indicator_bb.bollinger_lband_indicator()\n\n    # Keltner Channel\n    indicator_kc = KeltnerChannel(close=df[close], high=df[high], low=df[low], n=10, fillna=fillna)\n    df[f\'{colprefix}volatility_kcc\'] = indicator_kc.keltner_channel_mband()\n    df[f\'{colprefix}volatility_kch\'] = indicator_kc.keltner_channel_hband()\n    df[f\'{colprefix}volatility_kcl\'] = indicator_kc.keltner_channel_lband()\n    df[f\'{colprefix}volatility_kcw\'] = indicator_kc.keltner_channel_wband()\n    df[f\'{colprefix}volatility_kcp\'] = indicator_kc.keltner_channel_pband()\n    df[f\'{colprefix}volatility_kchi\'] = indicator_kc.keltner_channel_hband_indicator()\n    df[f\'{colprefix}volatility_kcli\'] = indicator_kc.keltner_channel_lband_indicator()\n\n    # Donchian Channel\n    indicator_dc = DonchianChannel(high=df[high], low=df[low], close=df[close], n=20, offset=0, fillna=fillna)\n    df[f\'{colprefix}volatility_dcl\'] = indicator_dc.donchian_channel_lband()\n    df[f\'{colprefix}volatility_dch\'] = indicator_dc.donchian_channel_hband()\n    df[f\'{colprefix}volatility_dcm\'] = indicator_dc.donchian_channel_mband()\n    df[f\'{colprefix}volatility_dcw\'] = indicator_dc.donchian_channel_wband()\n    df[f\'{colprefix}volatility_dcp\'] = indicator_dc.donchian_channel_pband()\n\n    return df\n\n\ndef add_trend_ta(df: pd.DataFrame, high: str, low: str, close: str, fillna: bool = False,\n                 colprefix: str = """") -> pd.DataFrame:\n    """"""Add trend technical analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        high (str): Name of \'high\' column.\n        low (str): Name of \'low\' column.\n        close (str): Name of \'close\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n\n    # MACD\n    indicator_macd = MACD(close=df[close], n_slow=26, n_fast=12, n_sign=9, fillna=fillna)\n    df[f\'{colprefix}trend_macd\'] = indicator_macd.macd()\n    df[f\'{colprefix}trend_macd_signal\'] = indicator_macd.macd_signal()\n    df[f\'{colprefix}trend_macd_diff\'] = indicator_macd.macd_diff()\n\n    # SMAs\n    df[f\'{colprefix}trend_sma_fast\'] = SMAIndicator(\n        close=df[close], n=12, fillna=fillna).sma_indicator()\n    df[f\'{colprefix}trend_sma_slow\'] = SMAIndicator(\n        close=df[close], n=26, fillna=fillna).sma_indicator()\n\n    # EMAs\n    df[f\'{colprefix}trend_ema_fast\'] = EMAIndicator(\n        close=df[close], n=12, fillna=fillna).ema_indicator()\n    df[f\'{colprefix}trend_ema_slow\'] = EMAIndicator(\n        close=df[close], n=26, fillna=fillna).ema_indicator()\n\n    # Average Directional Movement Index (ADX)\n    indicator = ADXIndicator(high=df[high], low=df[low], close=df[close], n=14, fillna=fillna)\n    df[f\'{colprefix}trend_adx\'] = indicator.adx()\n    df[f\'{colprefix}trend_adx_pos\'] = indicator.adx_pos()\n    df[f\'{colprefix}trend_adx_neg\'] = indicator.adx_neg()\n\n    # Vortex Indicator\n    indicator = VortexIndicator(high=df[high], low=df[low], close=df[close], n=14, fillna=fillna)\n    df[f\'{colprefix}trend_vortex_ind_pos\'] = indicator.vortex_indicator_pos()\n    df[f\'{colprefix}trend_vortex_ind_neg\'] = indicator.vortex_indicator_neg()\n    df[f\'{colprefix}trend_vortex_ind_diff\'] = indicator.vortex_indicator_diff()\n\n    # TRIX Indicator\n    indicator = TRIXIndicator(close=df[close], n=15, fillna=fillna)\n    df[f\'{colprefix}trend_trix\'] = indicator.trix()\n\n    # Mass Index\n    indicator = MassIndex(high=df[high], low=df[low], n=9, n2=25, fillna=fillna)\n    df[f\'{colprefix}trend_mass_index\'] = indicator.mass_index()\n\n    # CCI Indicator\n    indicator = CCIIndicator(high=df[high], low=df[low], close=df[close], n=20, c=0.015, fillna=fillna)\n    df[f\'{colprefix}trend_cci\'] = indicator.cci()\n\n    # DPO Indicator\n    indicator = DPOIndicator(close=df[close], n=20, fillna=fillna)\n    df[f\'{colprefix}trend_dpo\'] = indicator.dpo()\n\n    # KST Indicator\n    indicator = KSTIndicator(close=df[close],\n                             r1=10, r2=15, r3=20,\n                             r4=30, n1=10, n2=10, n3=10,\n                             n4=15, nsig=9, fillna=fillna)\n    df[f\'{colprefix}trend_kst\'] = indicator.kst()\n    df[f\'{colprefix}trend_kst_sig\'] = indicator.kst_sig()\n    df[f\'{colprefix}trend_kst_diff\'] = indicator.kst_diff()\n\n    # Ichimoku Indicator\n    indicator = IchimokuIndicator(high=df[high], low=df[low], n1=9, n2=26, n3=52, visual=False, fillna=fillna)\n    df[f\'{colprefix}trend_ichimoku_conv\'] = indicator.ichimoku_conversion_line()\n    df[f\'{colprefix}trend_ichimoku_base\'] = indicator.ichimoku_base_line()\n    df[f\'{colprefix}trend_ichimoku_a\'] = indicator.ichimoku_a()\n    df[f\'{colprefix}trend_ichimoku_b\'] = indicator.ichimoku_b()\n    indicator = IchimokuIndicator(high=df[high], low=df[low], n1=9, n2=26, n3=52, visual=True, fillna=fillna)\n    df[f\'{colprefix}trend_visual_ichimoku_a\'] = indicator.ichimoku_a()\n    df[f\'{colprefix}trend_visual_ichimoku_b\'] = indicator.ichimoku_b()\n\n    # Aroon Indicator\n    indicator = AroonIndicator(close=df[close], n=25, fillna=fillna)\n    df[f\'{colprefix}trend_aroon_up\'] = indicator.aroon_up()\n    df[f\'{colprefix}trend_aroon_down\'] = indicator.aroon_down()\n    df[f\'{colprefix}trend_aroon_ind\'] = indicator.aroon_indicator()\n\n    # PSAR Indicator\n    indicator = PSARIndicator(high=df[high], low=df[low], close=df[close], step=0.02, max_step=0.20, fillna=fillna)\n    # df[f\'{colprefix}trend_psar\'] = indicator.psar()\n    df[f\'{colprefix}trend_psar_up\'] = indicator.psar_up()\n    df[f\'{colprefix}trend_psar_down\'] = indicator.psar_down()\n    df[f\'{colprefix}trend_psar_up_indicator\'] = indicator.psar_up_indicator()\n    df[f\'{colprefix}trend_psar_down_indicator\'] = indicator.psar_down_indicator()\n\n    return df\n\n\ndef add_momentum_ta(df: pd.DataFrame, high: str, low: str, close: str, volume: str,\n                    fillna: bool = False, colprefix: str = """") -> pd.DataFrame:\n    """"""Add trend technical analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        high (str): Name of \'high\' column.\n        low (str): Name of \'low\' column.\n        close (str): Name of \'close\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n\n    # Relative Strength Index (RSI)\n    df[f\'{colprefix}momentum_rsi\'] = RSIIndicator(close=df[close], n=14, fillna=fillna).rsi()\n\n    # TSI Indicator\n    df[f\'{colprefix}momentum_tsi\'] = TSIIndicator(close=df[close], r=25, s=13, fillna=fillna).tsi()\n\n    # Ultimate Oscillator\n    df[f\'{colprefix}momentum_uo\'] = UltimateOscillator(\n        high=df[high], low=df[low], close=df[close], s=7, m=14, len=28, ws=4.0, wm=2.0, wl=1.0,\n        fillna=fillna).uo()\n\n    # Stoch Indicator\n    indicator = StochasticOscillator(high=df[high], low=df[low], close=df[close], n=14, d_n=3, fillna=fillna)\n    df[f\'{colprefix}momentum_stoch\'] = indicator.stoch()\n    df[f\'{colprefix}momentum_stoch_signal\'] = indicator.stoch_signal()\n\n    # Williams R Indicator\n    df[f\'{colprefix}momentum_wr\'] = WilliamsRIndicator(\n        high=df[high], low=df[low], close=df[close], lbp=14, fillna=fillna).wr()\n\n    # Awesome Oscillator\n    df[f\'{colprefix}momentum_ao\'] = AwesomeOscillatorIndicator(\n        high=df[high], low=df[low], s=5, len=34, fillna=fillna).ao()\n\n    # KAMA\n    df[f\'{colprefix}momentum_kama\'] = KAMAIndicator(\n        close=df[close], n=10, pow1=2, pow2=30, fillna=fillna).kama()\n\n    # Rate Of Change\n    df[f\'{colprefix}momentum_roc\'] = ROCIndicator(close=df[close], n=12, fillna=fillna).roc()\n    return df\n\n\ndef add_others_ta(df: pd.DataFrame, close: str, fillna: bool = False, colprefix: str = """") -> pd.DataFrame:\n    """"""Add others analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        close (str): Name of \'close\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n    # Daily Return\n    df[f\'{colprefix}others_dr\'] = DailyReturnIndicator(close=df[close], fillna=fillna).daily_return()\n\n    # Daily Log Return\n    df[f\'{colprefix}others_dlr\'] = DailyLogReturnIndicator(close=df[close], fillna=fillna).daily_log_return()\n\n    # Cumulative Return\n    df[f\'{colprefix}others_cr\'] = CumulativeReturnIndicator(\n        close=df[close], fillna=fillna).cumulative_return()\n\n    return df\n\n\ndef add_all_ta_features(df: pd.DataFrame, open: str, high: str, low: str,\n                        close: str, volume: str, fillna: bool = False, colprefix: str = """") -> pd.DataFrame:\n    """"""Add all technical analysis features to dataframe.\n\n    Args:\n        df (pandas.core.frame.DataFrame): Dataframe base.\n        open (str): Name of \'open\' column.\n        high (str): Name of \'high\' column.\n        low (str): Name of \'low\' column.\n        close (str): Name of \'close\' column.\n        volume (str): Name of \'volume\' column.\n        fillna(bool): if True, fill nan values.\n        colprefix(str): Prefix column names inserted\n\n    Returns:\n        pandas.core.frame.DataFrame: Dataframe with new features.\n    """"""\n    df = add_volume_ta(df=df, high=high, low=low, close=close, volume=volume, fillna=fillna, colprefix=colprefix)\n    df = add_volatility_ta(df=df, high=high, low=low, close=close, fillna=fillna, colprefix=colprefix)\n    df = add_trend_ta(df=df, high=high, low=low, close=close, fillna=fillna, colprefix=colprefix)\n    df = add_momentum_ta(df=df, high=high, low=low, close=close, volume=volume, fillna=fillna, colprefix=colprefix)\n    df = add_others_ta(df=df, close=close, fillna=fillna, colprefix=colprefix)\n    return df\n'"
ta/tests/__init__.py,0,"b'from ta.tests.momentum import (TestKAMAIndicator, TestRateOfChangeIndicator,\n                               TestRSIIndicator, TestStochasticOscillator,\n                               TestTSIIndicator, TestUltimateOscillator,\n                               TestWilliamsRIndicator)\nfrom ta.tests.trend import (TestADXIndicator, TestCCIIndicator,\n                            TestMACDIndicator, TestPSARIndicator,\n                            TestVortexIndicator)\nfrom ta.tests.volatility import (TestAverageTrueRange, TestAverageTrueRange2,\n                                 TestBollingerBands, TestDonchianChannel,\n                                 TestDonchianChannel2, TestKeltnerChannel)\nfrom ta.tests.volume import (TestAccDistIndexIndicator,\n                             TestEaseOfMovementIndicator,\n                             TestForceIndexIndicator, TestMFIIndicator,\n                             TestOnBalanceVolumeIndicator,\n                             TestVolumeWeightedAveragePrice)\nfrom ta.tests.wrapper import TestWrapper\n'"
ta/tests/momentum.py,0,"b'import unittest\n\nimport pandas as pd\n\nfrom ta.momentum import (KAMAIndicator, ROCIndicator, RSIIndicator,\n                         StochasticOscillator, TSIIndicator,\n                         UltimateOscillator, WilliamsRIndicator, kama, roc,\n                         rsi, stoch, stoch_signal, tsi, uo, wr)\n\n\nclass TestRateOfChangeIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:on_balance_volume_obv\n    """"""\n\n    _filename = \'ta/tests/data/cs-roc.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], n=12, fillna=False)\n        cls._indicator = ROCIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_roc(self):\n        target = \'ROC\'\n        result = roc(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_roc2(self):\n        target = \'ROC\'\n        result = self._indicator.roc()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestRSIIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:relative_strength_index_rsi\n    Note: Using a more simple initilization (directly `ewm`; stockcharts uses `sma` + `ewm`)\n    """"""\n\n    _filename = \'ta/tests/data/cs-rsi.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], n=14, fillna=False)\n        cls._indicator = RSIIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_rsi(self):\n        target = \'RSI\'\n        result = self._indicator.rsi()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_rsi2(self):\n        target = \'RSI\'\n        result = rsi(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestUltimateOscillator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:ultimate_oscillator\n    """"""\n\n    _filename = \'ta/tests/data/cs-ultosc.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'],\n            low=cls._df[\'Low\'],\n            close=cls._df[\'Close\'],\n            s=7,\n            m=14,\n            len=28,\n            ws=4.0,\n            wm=2.0,\n            wl=1.0,\n            fillna=False\n        )\n        cls._indicator = UltimateOscillator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_uo(self):\n        target = \'Ult_Osc\'\n        result = self._indicator.uo()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_uo2(self):\n        target = \'Ult_Osc\'\n        result = uo(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestStochasticOscillator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:stochastic_oscillator_fast_slow_and_full\n    """"""\n\n    _filename = \'ta/tests/data/cs-soo.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=14, d_n=3, fillna=False)\n        cls._indicator = StochasticOscillator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_so(self):\n        target = \'SO\'\n        result = self._indicator.stoch()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_so_signal(self):\n        target = \'SO_SIG\'\n        result = self._indicator.stoch_signal()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_so2(self):\n        target = \'SO\'\n        result = stoch(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_so_signal2(self):\n        target = \'SO_SIG\'\n        result = stoch_signal(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestWilliamsRIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:williams_r\n    """"""\n\n    _filename = \'ta/tests/data/cs-percentr.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], lbp=14, fillna=False)\n        cls._indicator = WilliamsRIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_wr(self):\n        target = \'Williams_%R\'\n        result = self._indicator.wr()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wr2(self):\n        target = \'Williams_%R\'\n        result = wr(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestKAMAIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:kaufman_s_adaptive_moving_average\n    """"""\n\n    _filename = \'ta/tests/data/cs-kama.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], n=10, pow1=2, pow2=30, fillna=False)\n        cls._indicator = KAMAIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_kama(self):\n        target = \'KAMA\'\n        result = self._indicator.kama()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_kama2(self):\n        target = \'KAMA\'\n        result = kama(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestTSIIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:true_strength_index\n    """"""\n\n    _filename = \'ta/tests/data/cs-tsi.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], r=25, s=13, fillna=False)\n        cls._indicator = TSIIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_tsi(self):\n        target = \'TSI\'\n        result = self._indicator.tsi()\n        pd.testing.assert_series_equal(\n            self._df[target].tail(), result.tail(), check_names=False, check_less_precise=True)\n\n    def test_tsi2(self):\n        target = \'TSI\'\n        result = tsi(**self._params)\n        pd.testing.assert_series_equal(\n            self._df[target].tail(), result.tail(), check_names=False, check_less_precise=True)\n'"
ta/tests/trend.py,0,"b'import unittest\n\nimport pandas as pd\n\nfrom ta.trend import (MACD, ADXIndicator, CCIIndicator, PSARIndicator,\n                      VortexIndicator, adx, adx_neg, adx_pos, cci, macd,\n                      macd_diff, macd_signal, psar_down, psar_down_indicator,\n                      psar_up, psar_up_indicator, vortex_indicator_neg,\n                      vortex_indicator_pos)\n\n\nclass TestADXIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:average_directional_index_adx\n    """"""\n\n    _filename = \'ta/tests/data/cs-adx.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=14, fillna=False)\n        cls._indicator = ADXIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_adx(self):\n        target = \'ADX\'\n        result = adx(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adx2(self):\n        target = \'ADX\'\n        result = self._indicator.adx()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adx_pos(self):\n        target = \'+DI14\'\n        result = adx_pos(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adx_pos2(self):\n        target = \'+DI14\'\n        result = self._indicator.adx_pos()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adx_neg(self):\n        target = \'-DI14\'\n        result = adx_neg(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adx_neg2(self):\n        target = \'-DI14\'\n        result = self._indicator.adx_neg()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestMACDIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:moving_average_convergence_divergence_macd\n    """"""\n\n    _filename = \'ta/tests/data/cs-macd.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], n_slow=26, n_fast=12, n_sign=9, fillna=False)\n        cls._indicator = MACD(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del (cls._df)\n\n    def test_macd(self):\n        target = \'MACD_line\'\n        result = macd(close=self._df[\'Close\'], n_slow=26, n_fast=12, fillna=False)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_macd2(self):\n        target = \'MACD_line\'\n        result = self._indicator.macd()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_macd_signal(self):\n        target = \'MACD_signal\'\n        result = macd_signal(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_macd_signal2(self):\n        target = \'MACD_signal\'\n        result = MACD(**self._params).macd_signal()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_macd_diff(self):\n        target = \'MACD_diff\'\n        result = macd_diff(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_macd_diff2(self):\n        target = \'MACD_diff\'\n        result = MACD(**self._params).macd_diff()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestCCIIndicator(unittest.TestCase):\n    """"""\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci\n    """"""\n\n    _filename = \'ta/tests/data/cs-cci.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=20, c=0.015, fillna=False)\n        cls._indicator = CCIIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del (cls._df)\n\n    def test_cci(self):\n        target = \'CCI\'\n        result = cci(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_cci2(self):\n        target = \'CCI\'\n        result = self._indicator.cci()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestVortexIndicator(unittest.TestCase):\n    """"""\n    http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:commodity_channel_index_cci\n    """"""\n\n    _filename = \'ta/tests/data/cs-vortex.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=14, fillna=False)\n        cls._indicator = VortexIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del (cls._df)\n\n    def test_vortex_indicator_pos(self):\n        target = \'+VI14\'\n        result = vortex_indicator_pos(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_vortex_indicator_pos2(self):\n        target = \'+VI14\'\n        result = self._indicator.vortex_indicator_pos()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_vortex_indicator_neg(self):\n        target = \'-VI14\'\n        result = vortex_indicator_neg(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_vortex_indicator_neg2(self):\n        target = \'-VI14\'\n        result = self._indicator.vortex_indicator_neg()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestPSARIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:parabolic_sar\n    """"""\n\n    _filename = \'ta/tests/data/cs-psar.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], fillna=False)\n        cls._indicator = PSARIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del (cls._df)\n\n    def test_psar_up(self):\n        target = \'psar_up\'\n        result = self._indicator.psar_up()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_down(self):\n        target = \'psar_down\'\n        result = self._indicator.psar_down()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_up_indicator(self):\n        target = \'psar_up_ind\'\n        result = self._indicator.psar_up_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_down_indicator(self):\n        target = \'psar_down_ind\'\n        result = self._indicator.psar_down_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_up2(self):\n        target = \'psar_up\'\n        result = psar_up(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_down2(self):\n        target = \'psar_down\'\n        result = psar_down(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_up_indicator2(self):\n        target = \'psar_up_ind\'\n        result = psar_up_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_psar_down_indicator2(self):\n        target = \'psar_down_ind\'\n        result = psar_down_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n'"
ta/tests/volatility.py,0,"b'import unittest\n\nimport pandas as pd\n\nfrom ta.volatility import (AverageTrueRange, BollingerBands, DonchianChannel,\n                           KeltnerChannel, average_true_range, bollinger_hband,\n                           bollinger_hband_indicator, bollinger_lband,\n                           bollinger_lband_indicator, bollinger_mavg,\n                           bollinger_pband, bollinger_wband,\n                           donchian_channel_hband, donchian_channel_lband,\n                           donchian_channel_mband, donchian_channel_pband,\n                           donchian_channel_wband, keltner_channel_hband,\n                           keltner_channel_hband_indicator,\n                           keltner_channel_lband,\n                           keltner_channel_lband_indicator,\n                           keltner_channel_mband, keltner_channel_pband,\n                           keltner_channel_wband)\n\n\nclass TestAverageTrueRange(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:average_true_range_atr\n    https://docs.google.com/spreadsheets/d/1DYG5NI_1px30aZ6oJkDIkWsyJW5V8jGbBVKIr9NWtec/edit?usp=sharing\n    """"""\n\n    _filename = \'ta/tests/data/cs-atr.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=14, fillna=False)\n        cls._indicator = AverageTrueRange(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_atr(self):\n        target = \'ATR\'\n        result = average_true_range(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_atr2(self):\n        target = \'ATR\'\n        result = self._indicator.average_true_range()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestAverageTrueRange2(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:average_true_range_atr\n    https://docs.google.com/spreadsheets/d/1IRlmwVmRLAzjIIt2iXBukZyyaSAYB_0iRyAoOowZaBk/edit?usp=sharing\n    """"""\n\n    _filename = \'ta/tests/data/cs-atr2.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=10, fillna=False)\n        cls._indicator = AverageTrueRange(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_atr(self):\n        target = \'ATR\'\n        result = self._indicator.average_true_range()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_atr2(self):\n        target = \'ATR\'\n        result = average_true_range(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestBollingerBands(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:bollinger_bands\n    """"""\n\n    _filename = \'ta/tests/data/cs-bbands.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], n=20, ndev=2, fillna=False)\n        cls._indicator = BollingerBands(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_mavg(self):\n        target = \'MiddleBand\'\n        result = self._indicator.bollinger_mavg()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband(self):\n        target = \'HighBand\'\n        result = self._indicator.bollinger_hband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband(self):\n        target = \'LowBand\'\n        result = self._indicator.bollinger_lband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband(self):\n        target = \'WidthBand\'\n        result = self._indicator.bollinger_wband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband(self):\n        target = \'PercentageBand\'\n        result = self._indicator.bollinger_pband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband_indicator(self):\n        target = \'CrossUp\'\n        result = self._indicator.bollinger_hband_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband_indicator(self):\n        target = \'CrossDown\'\n        result = self._indicator.bollinger_lband_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_mavg2(self):\n        target = \'MiddleBand\'\n        result = bollinger_mavg(close=self._df[\'Close\'], n=20, fillna=False)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband2(self):\n        target = \'HighBand\'\n        result = bollinger_hband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband2(self):\n        target = \'LowBand\'\n        result = bollinger_lband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband2(self):\n        target = \'WidthBand\'\n        result = bollinger_wband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband2(self):\n        target = \'PercentageBand\'\n        result = bollinger_pband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband_indicator2(self):\n        target = \'CrossUp\'\n        result = bollinger_hband_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband_indicator2(self):\n        target = \'CrossDown\'\n        result = bollinger_lband_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestDonchianChannel(unittest.TestCase):\n    """"""\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n    https://docs.google.com/spreadsheets/d/17JWWsxSiAb24BLzncUpccc8hg-03QjVWVXmoRCJ2lME/edit#gid=0\n    """"""\n\n    _filename = \'ta/tests/data/cs-dc.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'high\'], low=cls._df[\'low\'], close=cls._df[\'close\'], n=20, offset=0, fillna=False)\n        cls._indicator = DonchianChannel(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_mavg(self):\n        target = \'middle_band\'\n        result = self._indicator.donchian_channel_mband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband(self):\n        target = \'upper_band\'\n        result = self._indicator.donchian_channel_hband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband(self):\n        target = \'lower_band\'\n        result = self._indicator.donchian_channel_lband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband(self):\n        target = \'dc_band_width\'\n        result = self._indicator.donchian_channel_wband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband(self):\n        target = \'dc_percentage\'\n        result = self._indicator.donchian_channel_pband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_mavg2(self):\n        target = \'middle_band\'\n        result = donchian_channel_mband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband2(self):\n        target = \'upper_band\'\n        result = donchian_channel_hband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband2(self):\n        target = \'lower_band\'\n        result = donchian_channel_lband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband2(self):\n        target = \'dc_band_width\'\n        result = donchian_channel_wband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband2(self):\n        target = \'dc_percentage\'\n        result = donchian_channel_pband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestDonchianChannel2(unittest.TestCase):\n    """"""\n    https://www.investopedia.com/terms/d/donchianchannels.asp\n    https://docs.google.com/spreadsheets/d/17JWWsxSiAb24BLzncUpccc8hg-03QjVWVXmoRCJ2lME/edit#gid=0\n    """"""\n\n    _filename = \'ta/tests/data/cs-dc2.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'high\'], low=cls._df[\'low\'], close=cls._df[\'close\'], n=20, offset=1, fillna=False)\n        cls._indicator = DonchianChannel(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_mavg(self):\n        target = \'middle_band\'\n        result = self._indicator.donchian_channel_mband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband(self):\n        target = \'upper_band\'\n        result = self._indicator.donchian_channel_hband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband(self):\n        target = \'lower_band\'\n        result = self._indicator.donchian_channel_lband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband(self):\n        target = \'dc_band_width\'\n        result = self._indicator.donchian_channel_wband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband(self):\n        target = \'dc_percentage\'\n        result = self._indicator.donchian_channel_pband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_mavg2(self):\n        target = \'middle_band\'\n        result = donchian_channel_mband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband2(self):\n        target = \'upper_band\'\n        result = donchian_channel_hband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband2(self):\n        target = \'lower_band\'\n        result = donchian_channel_lband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband2(self):\n        target = \'dc_band_width\'\n        result = donchian_channel_wband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband2(self):\n        target = \'dc_percentage\'\n        result = donchian_channel_pband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestKeltnerChannel(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n    https://docs.google.com/spreadsheets/d/1qT8JbJ7F13bMV9-TcK-oFHL1F5sKPwakQWf6KrvGI3U/edit?usp=sharing\n    """"""\n\n    _filename = \'ta/tests/data/cs-kc.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], n=20, n_atr=10, fillna=False, ov=False)\n        cls._indicator = KeltnerChannel(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_mavg(self):\n        target = \'middle_band\'\n        result = self._indicator.keltner_channel_mband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband(self):\n        target = \'upper_band\'\n        result = self._indicator.keltner_channel_hband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband(self):\n        target = \'lower_band\'\n        result = self._indicator.keltner_channel_lband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband(self):\n        target = \'kc_band_width\'\n        result = self._indicator.keltner_channel_wband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband(self):\n        target = \'kc_percentage\'\n        result = self._indicator.keltner_channel_pband()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband_indicator(self):\n        target = \'kc_high_indicator\'\n        result = self._indicator.keltner_channel_hband_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband_indicator(self):\n        target = \'kc_low_indicator\'\n        result = self._indicator.keltner_channel_lband_indicator()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_mavg2(self):\n        target = \'middle_band\'\n        result = keltner_channel_mband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband2(self):\n        target = \'upper_band\'\n        result = keltner_channel_hband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband2(self):\n        target = \'lower_band\'\n        result = keltner_channel_lband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_wband2(self):\n        target = \'kc_band_width\'\n        result = keltner_channel_wband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_pband2(self):\n        target = \'kc_percentage\'\n        result = keltner_channel_pband(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_hband_indicator2(self):\n        target = \'kc_high_indicator\'\n        result = keltner_channel_hband_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_lband_indicator2(self):\n        target = \'kc_low_indicator\'\n        result = keltner_channel_lband_indicator(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n'"
ta/tests/volume.py,0,"b'import unittest\n\nimport pandas as pd\n\nfrom ta.volume import (AccDistIndexIndicator, EaseOfMovementIndicator,\n                       ForceIndexIndicator, MFIIndicator,\n                       OnBalanceVolumeIndicator, VolumeWeightedAveragePrice,\n                       acc_dist_index, ease_of_movement, force_index,\n                       money_flow_index, on_balance_volume,\n                       sma_ease_of_movement, volume_weighted_average_price)\n\n\nclass TestOnBalanceVolumeIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:on_balance_volume_obv\n    """"""\n\n    _filename = \'ta/tests/data/cs-obv.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], volume=cls._df[\'Volume\'], fillna=False)\n        cls._indicator = OnBalanceVolumeIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_obv(self):\n        target = \'OBV\'\n        result = on_balance_volume(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_obv2(self):\n        target = \'OBV\'\n        result = self._indicator.on_balance_volume()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestForceIndexIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:force_index\n    """"""\n\n    _filename = \'ta/tests/data/cs-fi.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(close=cls._df[\'Close\'], volume=cls._df[\'Volume\'], n=13, fillna=False)\n        cls._indicator = ForceIndexIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_fi(self):\n        target = \'FI\'\n        result = force_index(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_fi2(self):\n        target = \'FI\'\n        result = self._indicator.force_index()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestEaseOfMovementIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:ease_of_movement_emv\n    """"""\n\n    _filename = \'ta/tests/data/cs-easeofmovement.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(high=cls._df[\'High\'], low=cls._df[\'Low\'], volume=cls._df[\'Volume\'], n=14, fillna=False)\n        cls._indicator = EaseOfMovementIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_ease_of_movement(self):\n        target = \'EMV\'\n        result = ease_of_movement(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_ease_of_movement2(self):\n        target = \'EMV\'\n        result = self._indicator.ease_of_movement()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_sma_ease_of_movement(self):\n        target = \'SMA_EMV\'\n        result = sma_ease_of_movement(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_sma_ease_of_movement2(self):\n        target = \'SMA_EMV\'\n        result = self._indicator.sma_ease_of_movement()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestAccDistIndexIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:accumulation_distribution_line\n    """"""\n\n    _filename = \'ta/tests/data/cs-accum.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], volume=cls._df[\'Volume\'], fillna=False)\n        cls._indicator = AccDistIndexIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_adl(self):\n        target = \'ADLine\'\n        result = acc_dist_index(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_adl2(self):\n        target = \'ADLine\'\n        result = self._indicator.acc_dist_index()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestMFIIndicator(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:money_flow_index_mfi\n    """"""\n\n    _filename = \'ta/tests/data/cs-mfi.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], volume=cls._df[\'Volume\'], n=14,\n            fillna=False)\n        cls._indicator = MFIIndicator(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_mfi(self):\n        target = \'MFI\'\n        result = self._indicator.money_flow_index()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_mfi2(self):\n        target = \'MFI\'\n        result = money_flow_index(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n\nclass TestVolumeWeightedAveragePrice(unittest.TestCase):\n    """"""\n    https://school.stockcharts.com/doku.php?id=technical_indicators:vwap_intraday\n    """"""\n\n    _filename = \'ta/tests/data/cs-vwap.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n        cls._params = dict(\n            high=cls._df[\'High\'], low=cls._df[\'Low\'], close=cls._df[\'Close\'], volume=cls._df[\'Volume\'], fillna=False)\n        cls._indicator = VolumeWeightedAveragePrice(**cls._params)\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_vwap(self):\n        target = \'vwap\'\n        result = volume_weighted_average_price(**self._params)\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n\n    def test_vwap2(self):\n        target = \'vwap\'\n        result = self._indicator.volume_weighted_average_price()\n        pd.testing.assert_series_equal(self._df[target].tail(), result.tail(), check_names=False)\n'"
ta/tests/wrapper.py,0,"b'import unittest\n\nimport pandas as pd\n\nimport ta\n\n\nclass TestWrapper(unittest.TestCase):\n\n    _filename = \'ta/tests/data/datas.csv\'\n\n    @classmethod\n    def setUpClass(cls):\n        cls._df = pd.read_csv(cls._filename, sep=\',\')\n\n    @classmethod\n    def tearDownClass(cls):\n        del(cls._df)\n\n    def test_general(self):\n        # Clean nan values\n        df = ta.utils.dropna(self._df)\n\n        # Add all ta features filling nans values\n        ta.add_all_ta_features(\n            df=df, open=""Open"", high=""High"", low=""Low"", close=""Close"", volume=""Volume_BTC"", fillna=True)\n\n        # Add all ta features not filling nans values\n        ta.add_all_ta_features(\n            df=df, open=""Open"", high=""High"", low=""Low"", close=""Close"", volume=""Volume_BTC"", fillna=False)\n'"
