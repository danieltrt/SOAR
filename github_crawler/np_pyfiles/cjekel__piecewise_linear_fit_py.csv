file_path,api_count,code
setup.py,0,"b'import io\nfrom distutils.core import setup\n\nsetup(\n    name=\'pwlf\',\n    version=\'2.0.2\',\n    author=\'Charles Jekel\',\n    author_email=\'cjekel@gmail.com\',\n    packages=[\'pwlf\'],\n    url=\'https://github.com/cjekel/piecewise_linear_fit_py\',\n    license=\'MIT License\',\n    description=\'fit piecewise linear functions to data\',\n    long_description=io.open(\'README.rst\', encoding=""utf-8"").read(),\n    # long_description_content_type=\'text/markdown\',\n    platforms=[\'any\'],\n    install_requires=[\n        ""numpy >= 1.14.0"",\n        ""scipy >= 1.2.0"",\n        ""pyDOE >= 0.3.8"",\n        \'importlib-metadata ~= 1.0 ; python_version < ""3.8""\',\n    ],\n)\n'"
examples/fitForSpecifiedNumberOfLineSegments.py,9,"b""# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for four line segments\nres = my_pwlf.fit(4)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# Get the slopes\nmy_slopes = my_pwlf.slopes\n\n# Get my model parameters\nbeta = my_pwlf.beta\n\n# calculate the standard errors associated with each beta parameter\nse = my_pwlf.standard_errors()\n\n# calcualte the R^2 value\nRsquared = my_pwlf.r_squared()\n\n# calculate the piecewise R^2 value\nR2values = np.zeros(my_pwlf.n_segments)\nfor i in range(my_pwlf.n_segments):\n    # segregate the data based on break point locations\n    xmin = my_pwlf.fit_breaks[i]\n    xmax = my_pwlf.fit_breaks[i+1]\n    xtemp = my_pwlf.x_data\n    ytemp = my_pwlf.y_data\n    indtemp = np.where(xtemp >= xmin)\n    xtemp = my_pwlf.x_data[indtemp]\n    ytemp = my_pwlf.y_data[indtemp]\n    indtemp = np.where(xtemp <= xmax)\n    xtemp = xtemp[indtemp]\n    ytemp = ytemp[indtemp]\n\n    # predict for the new data\n    yhattemp = my_pwlf.predict(xtemp)\n\n    # calcualte ssr\n    e = yhattemp - ytemp\n    ssr = np.dot(e, e)\n\n    # calculate sst\n    ybar = np.ones(ytemp.size) * np.mean(ytemp)\n    ydiff = ytemp - ybar\n    sst = np.dot(ydiff, ydiff)\n\n    R2values[i] = 1.0 - (ssr/sst)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/fitForSpecifiedNumberOfLineSegments_passDiffEvoKeywords.py,3,"b""# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n# same as fitForSpecifiedNumberOfLineSegments.py, with the exception of\n# passing custom keywords directly to the scipy differential evolution algo\n# see\n# https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for four line segments\n# My differential evolutions keywords are tuned to be very aggressive\n# it's probably overkill for your application\n# so you can pass your custom keywords here\n# for example I'll pass the only keyword that I want differential evolution\n# to print the iterations with disp=True\n# if any keyword is passed, all of my aggressively tuned differential evolution\n# keywords reset to the default\nres = my_pwlf.fit(4, disp=True)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/fitForSpecifiedNumberOfLineSegments_standard_deviation.py,4,"b'# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for four line segments\nres = my_pwlf.fit(4)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# Get the slopes\nmy_slopes = my_pwlf.slopes\n\n# Get my model parameters\nbeta = my_pwlf.beta\n\n# calculate the standard errors associated with each beta parameter\nse = my_pwlf.standard_errors()\n\n# calculate the sum of the square of the residuals\nssr = my_pwlf.fit_with_breaks(my_pwlf.fit_breaks)\n\n# calculate the unbiased standard deviation\nsigma = np.sqrt(ssr / (my_pwlf.n_data - my_pwlf.n_parameters))\n# sigma can be used as a prediction variance\n\n# plot the results\nplt.figure()\nplt.plot(x, y, \'o\')\nplt.plot(xHat, yHat, \'-\')\nplt.fill_between(xHat, yHat - (sigma*1.96), yHat + (sigma*1.96), alpha=0.1,\n                 color=""r"")\nplt.show()\n'"
examples/fitWithKnownLineSegmentLocations.py,4,"b""# fit and predict with known line segment x locations\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# your desired line segment end locations\nx0 = np.array([min(x), 0.039, 0.10, max(x)])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data with the specified break points (ie the x locations of where\n# the line segments should end\nmy_pwlf.fit_with_breaks(x0)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/fit_begin_and_end.py,3,"b""# fit and predict between a known begging and known ending\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom scipy.optimize import differential_evolution\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmyPWLF = pwlf.PiecewiseLinFit(x, y, disp_res=True)\n\n# fit the function with four line segments\n# force the function to go through the data points\n# (0.0, 0.0) and (0.19, 0.16) \n# where the data points are of the form (x, y)\nx_c = [0.0, 0.19]\ny_c = [0.0, 0.2]\nres = myPWLF.fit(4, x_c, y_c)\n\n# predict for the determined points\nxHat = np.linspace(min(x), 0.19, num=10000)\nyHat = myPWLF.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/model_persistence.py,3,"b""# import our libraries\nimport numpy as np\nimport pwlf\n\n# if you use Python 2.x you should import cPickle\n# import cPickle as pickle\n# if you use Python 3.x you can just use pickle\nimport pickle\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# your desired line segment end locations\nx0 = np.array([min(x), 0.039, 0.10, max(x)])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data with the specified break points (ie the x locations of where\n# the line segments should end\nmy_pwlf.fit_with_breaks(x0)\n\n# save the fitted model\nwith open('my_fit.pkl', 'wb') as f:\n    pickle.dump(my_pwlf, f, pickle.HIGHEST_PROTOCOL)\n\n# load the fitted model\nwith open('my_fit.pkl', 'rb') as f:\n    my_pwlf = pickle.load(f)\n"""
examples/model_persistence_prediction.py,4,"b""# import our libraries\nimport numpy as np\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data with for 4 line segments\nmy_pwlf.fit(4)\n\n# save only the parameters necessary to predict for new data\nnp.save('ex_data/saved_parameters.npy', [my_pwlf.beta, my_pwlf.fit_breaks])\n\n# load the parameters necessary for prediction\nmy_prev_model = np.load('ex_data/saved_parameters.npy')\n\n# initialize new object\nmy_pwlf_new = pwlf.PiecewiseLinFit(x, y)\n\n# predict with the saved parameters\ny_hat = my_pwlf_new.predict(x, beta=my_prev_model[0], breaks=my_prev_model[1])\n"""
examples/prediction_variance.py,4,"b'# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for four line segments\nres = my_pwlf.fit(4)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# Get the slopes\nmy_slopes = my_pwlf.slopes\n\n# Get my model parameters\nbeta = my_pwlf.beta\n\n# calculate the prediction variance at the xHat locations\npre_var = my_pwlf.prediction_variance(xHat)\n# turn variance into standard deviation\npre_sigma = np.sqrt(pre_var)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, \'o\')\nplt.plot(xHat, yHat, \'-\')\nplt.fill_between(xHat, yHat - (pre_sigma*1.96), yHat + (pre_sigma*1.96),\n                 alpha=0.1, color=""r"")\nplt.show()\n'"
examples/prediction_variance_degree2.py,4,"b'# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y, degree=2)\n\n# fit the data for four line segments\nres = my_pwlf.fit(4)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# Get the slopes\nmy_slopes = my_pwlf.slopes\n\n# Get my model parameters\nbeta = my_pwlf.beta\n\n# calculate the prediction variance at the xHat locations\npre_var = my_pwlf.prediction_variance(xHat)\n# turn variance into standard deviation\npre_sigma = np.sqrt(pre_var)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, \'o\')\nplt.plot(xHat, yHat, \'-\')\nplt.fill_between(xHat, yHat - (pre_sigma*1.96), yHat + (pre_sigma*1.96),\n                 alpha=0.1, color=""r"")\nplt.show()\n'"
examples/run_opt_to_find_best_number_of_line_segments.py,6,"b""# Running an optimization to find the best number of line segments\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom GPyOpt.methods import BayesianOptimization\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# define your objective function\n\n\ndef my_obj(x):\n    # define some penalty parameter l\n    # you'll have to arbitrarily pick this\n    # it depends upon the noise in your data,\n    # and the value of your sum of square of residuals\n    l = y.mean()*0.001\n    f = np.zeros(x.shape[0])\n    for i, j in enumerate(x):\n        my_pwlf.fit(j[0])\n        f[i] = my_pwlf.ssr + (l*j[0])\n    return f\n\n\n# define the lower and upper bound for the number of line segements\nbounds = [{'name': 'var_1', 'type': 'discrete', 'domain': np.arange(2, 40)}]\n\nnp.random.seed(12121)\n\nmyBopt = BayesianOptimization(my_obj, domain=bounds, model_type='GP',\n                              initial_design_numdata=10,\n                              initial_design_type='latin',\n                              exact_feval=True, verbosity=True,\n                              verbosity_model=False)\nmax_iter = 30\n\n# perform the bayesian optimization to find the optimum number of line segments\nmyBopt.run_optimization(max_iter=max_iter, verbosity=True)\n\nprint('\\n \\n Opt found \\n')\nprint('Optimum number of line segments:', myBopt.x_opt)\nprint('Function value:', myBopt.fx_opt)\nmyBopt.plot_acquisition()\nmyBopt.plot_convergence()\n\n# perform the fit for the optimum\nmy_pwlf.fit(myBopt.x_opt)\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/sineWave.py,4,"b""# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# generate sin wave data\nx = np.linspace(0, 10, num=100)\ny = np.sin(x * np.pi / 2)\n# add noise to the data\ny = np.random.normal(0, 0.05, 100) + y\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for four line segments\nres = my_pwlf.fit(16, disp=True)\n# i'm passing the argument disp=True to see the progress of the differential\n# evolution so you can be sure the program isn't just hanging...\n\n# Be patient! this one takes some time - It's a difficult problem\n# using this differential evolution algo + bfgs can be over 500,000.0 function\n# evaluations\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/sineWave_custom_opt_bounds.py,5,"b""# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# generate sin wave data\nx = np.linspace(0, 10, num=100)\ny = np.sin(x * np.pi / 2)\n# add noise to the data\ny = np.random.normal(0, 0.05, 100) + y\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# define custom bounds for the interior break points\nn_segments = 4\nbounds = np.zeros((n_segments-1, 2))\n# first lower and upper bound\nbounds[0, 0] = 0.0\nbounds[0, 1] = 3.5\n# second lower and upper bound\nbounds[1, 0] = 3.0\nbounds[1, 1] = 7.0\n# third lower and upper bound\nbounds[2, 0] = 6.0\nbounds[2, 1] = 10.0\nres = my_pwlf.fit(n_segments, bounds=bounds)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/sineWave_degrees.py,4,"b""# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# generate sin wave data\nx = np.linspace(0, 10, num=100)\ny = np.sin(x * np.pi / 2)\n# add noise to the data\ny = np.random.normal(0, 0.05, 100) + y\n\n# initialize piecewise linear fit with your x and y data\n# pwlf lets you fit continuous model for many degree polynomials\n# degree=0 constant\n# degree=1 linear (default)\n# degree=2 quadratic\nmy_pwlf_0 = pwlf.PiecewiseLinFit(x, y, degree=0)\nmy_pwlf_1 = pwlf.PiecewiseLinFit(x, y, degree=1)  # default\nmy_pwlf_2 = pwlf.PiecewiseLinFit(x, y, degree=2)\n\n# fit the data for four line segments\nres0 = my_pwlf_0.fitfast(5, pop=50)\nres1 = my_pwlf_1.fitfast(5, pop=50)\nres2 = my_pwlf_2.fitfast(5, pop=50)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat0 = my_pwlf_0.predict(xHat)\nyHat1 = my_pwlf_1.predict(xHat)\nyHat2 = my_pwlf_2.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o', label='Data')\nplt.plot(xHat, yHat0, '-', label='degree=0')\nplt.plot(xHat, yHat1, '--', label='degree=1')\nplt.plot(xHat, yHat2, ':', label='degree=2')\nplt.legend()\nplt.show()\n"""
examples/sineWave_time_compare.py,5,"b""# fit for a specified number of line segments\n# you specify the number of line segments you want, the library does the rest\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom time import time\n\n# generate sin wave data\nx = np.linspace(0, 10, num=100)\ny = np.sin(x * np.pi / 2)\n# add noise to the data\ny = np.random.normal(0, 0.05, 100) + y\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data for sixteen line segments\nt0 = time()\nres1 = my_pwlf.fit(16, disp=True)\nt1 = time()\n# i'm passing the argument disp=True to see the progress of the differential\n# evolution so you can be sure the program isn't just hanging...\n\n# Be patient! this one takes some time - It's a difficult problem\n# using this differential evolution algo + bfgs can be over 500,000.0 function\n# evaluations\n\n# predict for the determined points\nxHat1 = np.linspace(min(x), max(x), num=10000)\nyHat1 = my_pwlf.predict(xHat1)\n\n# fit the data for sixteen line segments\n# using the default 50 number of multi starts\nt2 = time()\nres2 = my_pwlf.fitfast(16)  # this is equivalent to my_pwlf.fitfast(16,50)\nt3 = time()\n\n# predict for the determined points\nxHat2 = np.linspace(min(x), max(x), num=10000)\nyHat2 = my_pwlf.predict(xHat2)\n\nprint('Run time for differential_evolution', t1 - t0, 'seconds')\nprint('Run time for multi-start', t3 - t2, 'seconds')\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat1, yHat1, '-', label='Diff. evolution')\nplt.plot(xHat2, yHat2, '-', label='Multi start')\nplt.legend()\nplt.show()\n"""
examples/stack_overflow_example.py,3,"b""import numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# https://stackoverflow.com/questions/29382903/how-to-apply-piecewise-linear-fit-in-python\n\nx = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\ny = np.array([5, 7, 9, 11, 13, 15, 28.92, 42.81, 56.7, 70.59, 84.47, 98.36, 112.25, 126.14, 140.03])\n\n# pwlf has two approaches to perform your fit:\n# 1. You can fit for a specified number of line segments.\n# 2. You can specify the x locations where the continuous piecewise lines\n# should terminate.\n\n# Approach 1\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n# breaks will return the end location of each line segment\nbreaks = my_pwlf.fit(2)\nprint(breaks)\n# The gradient change point you asked for is at breaks[1]\n\nx_hat = np.linspace(x.min(), x.max(), 100)\ny_hat = my_pwlf.predict(x_hat)\n\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(x_hat, y_hat, '-')\nplt.show()"""
examples/standard_errrors_and_p-values.py,5,"b""# example of how to calculate standard errors and p-values\nfrom __future__ import print_function\nimport numpy as np\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# your desired line segment end locations\nx0 = np.array([min(x), 0.039, 0.10, max(x)])\n\n# fit the data for our specified line segment locations\nres = my_pwlf.fit_with_breaks(x0)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# Get my model parameters\nbeta = my_pwlf.beta\n\n# calculate the standard errors associated with each beta parameter\n# not that these standard errors and p-values are only meaningful if\n# you have specified the specific line segment end locations\n# at least for now...\nse = my_pwlf.standard_errors()\n\n# calculate my t-value\nt = beta / se\n\nk = len(beta) - 1\n\n# calculate the p-values\npvalues = my_pwlf.p_values()\n\n# print the results\nvalues = np.zeros((k, 4))\nvalues[:, 0] = beta\nvalues[:, 1] = se\nvalues[:, 2] = t\nvalues[:, 3] = pvalues\nheader = ['Beta value', 'Standard error', 't', 'P > |t| (p-value)']\nprint(*header, sep=' & ')\nfor row in values:\n    print(*row, sep=' & ')\n"""
examples/standard_errrors_and_p-values_non-linear.py,11,"b""from __future__ import print_function\nimport numpy as np\nimport pwlf\n# import matplotlib.pyplot as plt\n\n# generate a true piecewise linear data\nnp.random.seed(5)\nn_data = 100\nx = np.linspace(0, 1, num=n_data)\ny = np.random.random(n_data)\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\ntrue_beta = np.random.normal(size=5)\ntrue_breaks = np.array([0.0, 0.2, 0.5, 0.75, 1.0])\ny = my_pwlf.predict(x, beta=true_beta, breaks=true_breaks)\n\n# plt.figure()\n# plt.title('True piecewise linear data')\n# plt.plot(x, y)\n# plt.show()\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n# fit the data for our specified line segment locations\nres = my_pwlf.fitfast(4, pop=100)\n\n# calculate the non-linear standard errors\nse = my_pwlf.standard_errors(method='non-linear', step_size=1e-4)\n\n# calculate p-values\np = my_pwlf.p_values(method='non-linear', step_size=1e-4)\n\nparameters = np.concatenate((my_pwlf.beta, my_pwlf.fit_breaks[1:-1]))\n\nheader = ['Parmater type', 'Parameter value', 'Standard error', 't',\n          'P > |t| (p-value)']\nprint(*header, sep=' & ')\nvalues = np.zeros((parameters.size, 5), dtype=np.object_)\nvalues[:, 1] = np.around(parameters, decimals=3)\nvalues[:, 2] = np.around(se, decimals=3)\nvalues[:, 3] = np.around(parameters / se, decimals=3)\nvalues[:, 4] = np.around(p, decimals=3)\n\nfor i, row in enumerate(values):\n    if i < my_pwlf.beta.size:\n        row[0] = 'Beta'\n        print(*row, sep=' & ')\n    else:\n        row[0] = 'Breakpoint'\n        print(*row, sep=' & ')\n"""
examples/test0.py,8,"b""import numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom scipy.optimize import minimize\n\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\nx0 = np.array([min(x), 0.039, 0.10, max(x)])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# fit the data with the specified break points (ie the x locations of where\n# the line segments should end\n# my_pwlf.fit_with_breaks(x0)\n# my_pwlf.seperateData(x0)\n\n# res = my_pwlf.fit(3)\n\n# initialize custom optimization\nnumber_of_line_segments = 3\nmy_pwlf.use_custom_opt(number_of_line_segments)\n\nres = minimize(my_pwlf.fit_with_breaks_opt, np.array([x0[1], x0[2]]))\n\n# set up the break point locations\nx0 = np.zeros(number_of_line_segments + 1)\nx0[0] = np.min(x)\nx0[-1] = np.max(x)\nx0[1:-1] = res.x\n\n# calculate the parameters based on the optimal break point locations\nmy_pwlf.fit_with_breaks(x0)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/test_if_breaks_exact.py,2,"b'import numpy as np\nimport pwlf\n\nx = np.array((0.0, 1.0, 1.5, 2.0))\ny = np.array((0.0, 1.0, 1.1, 1.5))\n\nmy_fit1 = pwlf.PiecewiseLinFit(x, y)\nx0 = x.copy()\n# check that I can fit when break poitns spot on a\nssr = my_fit1.fit_with_breaks(x0)\n\n# check that i can fit when I slightly modify x0\nmy_fit2 = pwlf.PiecewiseLinFit(x, y)\nx0[1] = 1.00001\nx0[2] = 1.50001\nssr2 = my_fit2.fit_with_breaks(x0)\n\n# check if my duplicate is in a different location\nx0 = x.copy()\nmy_fit3 = pwlf.PiecewiseLinFit(x, y)\nx0[1] = 0.9\nssr3 = my_fit3.fit_with_breaks(x0)\n\n# check if my duplicate is in a different location\nx0 = x.copy()\nmy_fit4 = pwlf.PiecewiseLinFit(x, y)\nx0[1] = 1.1\nssr4 = my_fit4.fit_with_breaks(x0)\n\n# check if my duplicate is in a different location\nx0 = x.copy()\nmy_fit5 = pwlf.PiecewiseLinFit(x, y)\nx0[2] = 1.6\nssr5 = my_fit5.fit_with_breaks(x0)\n\n# check if my duplicate is in a different location\nx0 = x.copy()\nmy_fit6 = pwlf.PiecewiseLinFit(x, y)\nx0[2] = 1.4\nssr6 = my_fit6.fit_with_breaks(x0)\n'"
examples/useCustomOptimizationRoutine.py,7,"b""# use your own custom optimization routine to find the optimal location\n# of line segment locations\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n# import custom optimization library\nfrom scipy.optimize import minimize\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# initialize custom optimization\nnumber_of_line_segments = 3\nmy_pwlf.use_custom_opt(number_of_line_segments)\n\n# i have number_of_line_segments - 1 number of variables\n# let's guess the correct location of the two unknown variables\n# (the program defaults to have end segments at x0= min(x) and xn=max(x)\nxGuess = np.zeros(number_of_line_segments - 1)\nxGuess[0] = 0.02\nxGuess[1] = 0.10\n\nres = minimize(my_pwlf.fit_with_breaks_opt, xGuess)\n\n# set up the break point locations\nx0 = np.zeros(number_of_line_segments + 1)\nx0[0] = np.min(x)\nx0[-1] = np.max(x)\nx0[1:-1] = res.x\n\n# calculate the parameters based on the optimal break point locations\nmy_pwlf.fit_with_breaks(x0)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/weighted_least_squares_ex.py,9,"b""from time import time\nimport os\nos.environ['OMP_NUM_THREADS'] = '1'\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nt0 = time()\nnp.random.seed(123)\nn = 100\nn_data_sets = 100\nn_segments = 6\n# generate sine data\nx = np.linspace(0, 10, n)\ny = np.zeros((n_data_sets, n))\nsigma_change = np.linspace(0.001, 0.05, 100)\nfor i in range(n_data_sets):\n    y[i] = np.sin(x * np.pi / 2)\n    # add noise to the data\n    y[i] = np.random.normal(0, sigma_change, 100) + y[i]\nX = np.tile(x, n_data_sets)\n\n# perform an ordinary pwlf fit to the entire data\nmy_pwlf = pwlf.PiecewiseLinFit(X.flatten(), y.flatten())\nmy_pwlf.fit(n_segments)\n\n# compute the standard deviation in y\ny_std = np.std(y, axis=0)\n# set the weights to be one over the standard deviation\nweights = 1.0 / y_std\n\n# perform a weighted least squares to the data\nmy_pwlf_w = pwlf.PiecewiseLinFit(x, y.mean(axis=0), weights=weights)\nmy_pwlf_w.fit(n_segments)\n\n\n# compare the fits\nxhat = np.linspace(0, 10, 1000)\nyhat = my_pwlf.predict(xhat)\nyhat_w = my_pwlf_w.predict(xhat)\nt1 = time()\nprint('Runtime:', t1-t0)\nplt.figure()\nplt.plot(X.flatten(), y.flatten(), '.')\nplt.plot(xhat, yhat, '-', label='Ordinary LS')\nplt.plot(xhat, yhat_w, '-', label='Weighted LS')\nplt.legend()\nplt.show()\n"""
examples/weighted_least_squares_ex_stats.py,9,"b""from time import time\nimport os\nos.environ['OMP_NUM_THREADS'] = '1'\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nt0 = time()\nnp.random.seed(123)\nn = 100\nn_data_sets = 100\nn_segments = 6\n# generate sine data\nx = np.linspace(0, 10, n)\ny = np.zeros((n_data_sets, n))\nsigma_change = np.linspace(0.001, 0.05, 100)\nfor i in range(n_data_sets):\n    y[i] = np.sin(x * np.pi / 2)\n    # add noise to the data\n    y[i] = np.random.normal(0, sigma_change, 100) + y[i]\nX = np.tile(x, n_data_sets)\n\n# perform an ordinary pwlf fit to the entire data\nmy_pwlf = pwlf.PiecewiseLinFit(X.flatten(), y.flatten())\nmy_pwlf.fit(n_segments)\nse = my_pwlf.standard_errors()\npv = my_pwlf.prediction_variance(x)\n\n# compute the standard deviation in y\ny_std = np.std(y, axis=0)\n# set the weights to be one over the standard deviation\nweights = 1.0 / y_std\n\n# perform a weighted least squares to the data\nmy_pwlf_w = pwlf.PiecewiseLinFit(x, y.mean(axis=0), weights=weights)\nmy_pwlf_w.fit(n_segments)\nse_w = my_pwlf_w.standard_errors()\npv_w = my_pwlf_w.prediction_variance(x)\n\nprint('Standard errors', se, se_w)\nprint('Prediction varance', pv, pv_w)\n\n# compare the fits\nxhat = np.linspace(0, 10, 1000)\nyhat = my_pwlf.predict(xhat)\nyhat_w = my_pwlf_w.predict(xhat)\nt1 = time()\nprint('Runtime:', t1-t0)\nplt.figure()\nplt.plot(X.flatten(), y.flatten(), '.')\nplt.plot(xhat, yhat, '-', label='Ordinary LS')\nplt.plot(xhat, yhat_w, '-', label='Weighted LS')\nplt.legend()\nplt.show()\n"""
pwlf/__init__.py,0,b'from .pwlf import PiecewiseLinFit  # noqa F401\nfrom .version import __version__  # noqa F401\n'
pwlf/pwlf.py,134,"b'# -- coding: utf-8 --\n# MIT License\n#\n# Copyright (c) 2017-2019 Charles Jekel\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom __future__ import print_function\n# import libraries\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.optimize import fmin_l_bfgs_b\nfrom scipy import linalg\nfrom scipy import stats\nfrom pyDOE import lhs\n\n# piecewise linear fit library\n\n\nclass PiecewiseLinFit(object):\n\n    def __init__(self, x, y, disp_res=False, lapack_driver=\'gelsd\', degree=1,\n                 weights=None):\n        r""""""\n        An object to fit a continuous piecewise linear function\n        to data.\n\n        Initiate the library with the supplied x and y data.\n        Supply the x and y data of which you\'ll be fitting\n        a continuous piecewise linear model to where y(x).\n        by default pwlf won\'t print the optimization results.;\n\n        Parameters\n        ----------\n        x : array_like\n            The x or independent data point locations as list or 1 dimensional\n            numpy array.\n        y : array_like\n            The y or dependent data point locations as list or 1 dimensional\n            numpy array.\n        disp_res : bool, optional\n            Whether the optimization results should be printed. Default is\n            False.\n        lapack_driver : str, optional\n            Which LAPACK driver is used to solve the least-squares problem.\n            Default lapack_driver=\'gelsd\'. Options are \'gelsd\', \'gelsy\',\n            \'gelss\'. For more see\n            https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html\n            http://www.netlib.org/lapack/lug/node27.html\n        degree : int, optional\n            The degree of polynomial to use. The default is degree=1 for\n            linear models. Use degree=0 for constant models.\n        weights : None, or array_like\n            The individual weights are typically the reciprocal of the\n            standard deviation for each data point, where weights[i]\n            corresponds to one over the standard deviation of the ith data\n            point. Default weights=None.\n\n        Attributes\n        ----------\n        beta : ndarray (1-D)\n            The model parameters for the continuous piecewise linear fit.\n        break_0 : float\n            The smallest x value.\n        break_n : float\n            The largest x value.\n        c_n : int\n            The number of constraint points. This is the same as len(x_c).\n        degree: int\n            The degree of polynomial to use. The default is degree=1 for\n            linear models. Use degree=0 for constant models.\n        fit_breaks : ndarray (1-D)\n            breakpoint locations stored as a 1-D numpy array.\n        intercepts : ndarray (1-D)\n            The y-intercept of each line segment as a 1-D numpy array.\n        lapack_driver : str\n            Which LAPACK driver is used to solve the least-squares problem.\n        print : bool\n            Whether the optimization results should be printed. Default is\n            False.\n        n_data : int\n            The number of data points.\n        n_parameters : int\n            The number of model parameters. This is equivalent to the\n            len(beta).\n        n_segments : int\n            The number of line segments.\n        nVar : int\n            The number of variables in the global optimization problem.\n        se : ndarray (1-D)\n            Standard errors associated with each beta parameter. Specifically\n            se[0] correspounds to the standard error for beta[0], and so forth.\n        slopes : ndarray (1-D)\n            The slope of each ling segment as a 1-D numpy array. This assumes\n            that x[0] <= x[1] <= ... <= x[n]. Thus, slopes[0] is the slope\n            of the first line segment.\n        ssr : float\n            Optimal sum of square error.\n        x_c : ndarray (1-D)\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        y_c : ndarray (1-D)\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        x_data : ndarray (1-D)\n            The inputted parameter x from the 1-D data set.\n        y_data : ndarray (1-D)\n            The inputted parameter y from the 1-D data set.\n        y_w : ndarray (1-D)\n            The weighted y data vector.\n        zeta : ndarray (1-D)\n            The model parameters associated with the constraint function.\n\n        Methods\n        -------\n        fit(n_segments, x_c=None, y_c=None, **kwargs)\n            Fit a continuous piecewise linear function for a specified number\n            of line segments.\n        fitfast(n_segments, pop=2, **kwargs)\n            Fit a continuous piecewise linear function for a specified number\n            of line segments using a specialized optimization routine that\n            should be faster than fit() for large problems. The tradeoff may\n            be that fitfast() results in a lower quality model.\n        fit_with_breaks(breaks)\n            Fit a continuous piecewise linear function where the breakpoint\n            locations are known.\n        fit_with_breaks_force_points(breaks, x_c, y_c)\n            Fit a continuous piecewise linear function where the breakpoint\n            locations are known, and force the fit to go through points at x_c\n            and y_c.\n        predict(x, beta=None, breaks=None)\n            Evaluate the continuous piecewise linear function at new untested\n            points.\n        fit_with_breaks_opt(var)\n            The objective function to perform a continuous piecewise linear\n            fit for a specified number of breakpoints. This is to be used\n            with a custom optimization routine, and after use_custom_opt has\n            been called.\n        fit_force_points_opt(var)\'\n            Same as fit_with_breaks_opt(var), except this allows for points to\n            be forced through x_c and y_c.\n        use_custom_opt(n_segments, x_c=None, y_c=None)\n            Function to initialize the attributes necessary to use a custom\n            optimization routine. Must be used prior to calling\n            fit_with_breaks_opt() or fit_force_points_opt().\n        calc_slopes()\n            Calculate the slopes of the lines after a piecewise linear\n            function has been fitted.\n        standard_errors()\n            Calculate the standard error of each model parameter in the fitted\n            piecewise linear function. Note, this assumes no uncertainty in\n            breakpoint locations.\n        prediction_variance(x)\n            Calculate the prediction variance at x locations for the fitted\n            piecewise linear function. Note, assumes no uncertainty in break\n            point locations.\n        r_squared()\n            Calculate the coefficient of determination, or \'R-squared\' value\n            for a fitted piecewise linear function.\n\n        Examples\n        --------\n        Initialize for x, y data\n\n        >>> import pwlf\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n        Initialize for x,y data and print optimization results\n\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y, disp_res=True)\n\n        """"""\n\n        self.print = disp_res\n        self.lapack_driver = lapack_driver\n        # x and y should be numpy arrays\n        # if they are not convert to numpy array\n        if isinstance(x, np.ndarray) is False:\n            x = np.array(x)\n        if isinstance(y, np.ndarray) is False:\n            y = np.array(y)\n\n        self.x_data = x\n        self.y_data = y\n\n        # calculate the number of data points\n        self.n_data = x.size\n\n        # set the first and last break x values to be the min and max of x\n        self.break_0 = np.min(self.x_data)\n        self.break_n = np.max(self.x_data)\n\n        if degree < 12 and degree >= 0:\n            # I actually don\'t know what the upper degree limit should\n            self.degree = int(degree)\n        else:\n            not_suported = ""degree = "" + str(degree) + "" is not supported.""\n            raise ValueError(not_suported)\n\n        self.y_w = None\n        self.weights = None\n        # self.weights2 = None  # the squared weights vector\n        if weights is not None:\n            if isinstance(weights, np.ndarray) is False:\n                weights = np.array(weights)\n            # self.weights2 = weights*weights\n            self.weights = weights\n            self.y_w = np.dot(self.y_data, np.eye(self.n_data)*self.weights)\n\n        # initialize all empty attributes as None\n        self.fit_breaks = None\n        self.n_segments = None\n        self.n_parameters = None\n        self.beta = None\n        self.ssr = None\n        self.x_c = None\n        self.y_c = None\n        self.c_n = None\n        self.zeta = None\n        self.nVar = None\n        self.slopes = None\n        self.intercepts = None\n        self.se = None\n\n    def assemble_regression_matrix(self, breaks, x):\n        r""""""\n        Assemble the linear regression matrix A\n\n        Parameters\n        ----------\n        breaks : array_like\n            The x locations where each line segment terminates. These are\n            referred to as breakpoints for each line segment. This should be\n            structured as a 1-D numpy array.\n        x : ndarray (1-D)\n            The x locations which the linear regression matrix is assembled on.\n            This must be a numpy array!\n\n        Returns\n        -------\n        A : ndarray (2-D)\n            The assembled linear regression matrix.\n\n        Examples\n        --------\n        Assemble the linear regression matrix on the x data for some set of\n        breakpoints.\n\n        >>> import pwlf\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = [0.0, 0.5, 1.0]\n        >>> A = assemble_regression_matrix(breaks, self.x_data)\n\n        """"""\n        # Check if breaks in ndarray, if not convert to np.array\n        if isinstance(breaks, np.ndarray) is False:\n            breaks = np.array(breaks)\n\n        # Sort the breaks, then store them\n        breaks_order = np.argsort(breaks)\n        self.fit_breaks = breaks[breaks_order]\n        # store the number of parameters and line segments\n        self.n_segments = len(breaks) - 1\n\n        # Assemble the regression matrix\n        A_list = [np.ones_like(x)]\n        if self.degree >= 1:\n            A_list.append(x - self.fit_breaks[0])\n            for i in range(self.n_segments - 1):\n                A_list.append(np.where(x > self.fit_breaks[i+1],\n                                       x - self.fit_breaks[i+1],\n                                       0.0))\n            if self.degree >= 2:\n                for k in range(2, self.degree + 1):\n                    A_list.append((x - self.fit_breaks[0])**k)\n                    for i in range(self.n_segments - 1):\n                        A_list.append(np.where(x > self.fit_breaks[i+1],\n                                               (x - self.fit_breaks[i+1])**k,\n                                               0.0))\n        else:\n            A_list = [np.ones_like(x)]\n            for i in range(self.n_segments - 1):\n                A_list.append(np.where(x > self.fit_breaks[i+1], 1.0, 0.0))\n        A = np.vstack(A_list).T\n        self.n_parameters = A.shape[1]\n        return A\n\n    def fit_with_breaks(self, breaks):\n        r""""""\n        A function which fits a continuous piecewise linear function\n        for specified breakpoint locations.\n\n        The function minimizes the sum of the square of the residuals for the\n        x y data.\n\n        If you want to understand the math behind this read\n        https://jekel.me/2018/Continous-piecewise-linear-regression/\n\n        Other useful resources:\n        http://golovchenko.org/docs/ContinuousPiecewiseLinearFit.pdf\n        https://www.mathworks.com/matlabcentral/fileexchange/40913-piecewise-linear-least-square-fittic\n        http://www.regressionist.com/2018/02/07/continuous-piecewise-linear-fitting/\n\n        Parameters\n        ----------\n        breaks : array_like\n            The x locations where each line segment terminates. These are\n            referred to as breakpoints for each line segment. This should be\n            structured as a 1-D numpy array.\n\n        Returns\n        -------\n        ssr : float\n            Returns the sum of squares of the residuals.\n\n        Raises\n        ------\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Examples\n        --------\n        If your x data exists from 0 <= x <= 1 and you want three\n        piecewise linear lines where the lines terminate at x = 0.0, 0.3, 0.6,\n        and 1.0. This assumes that x is linearly spaced from [0, 1), and y is\n        random.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = [0.0, 0.3, 0.6, 1.0]\n        >>> ssr = my_pwlf.fit_with_breaks(breaks)\n\n        """"""\n\n        # Check if breaks in ndarray, if not convert to np.array\n        if isinstance(breaks, np.ndarray) is False:\n            breaks = np.array(breaks)\n\n        A = self.assemble_regression_matrix(breaks, self.x_data)\n\n        # try to solve the regression problem\n        try:\n            ssr = self.lstsq(A)\n\n        except linalg.LinAlgError:\n            # the computation could not converge!\n            # on an error, return ssr = np.print_function\n            # You might have a singular Matrix!!!\n            ssr = np.inf\n        if ssr is None:\n            ssr = np.inf\n            # something went wrong...\n        self.ssr = ssr\n        return ssr\n\n    def fit_with_breaks_force_points(self, breaks, x_c, y_c):\n        r""""""\n        A function which fits a continuous piecewise linear function\n        for specified breakpoint locations, where you force the\n        fit to go through the data points at x_c and y_c.\n\n        The function minimizes the sum of the square of the residuals for the\n        pair of x, y data points. If you want to understand the math behind\n        this read https://jekel.me/2018/Force-piecwise-linear-fit-through-data/\n\n        Parameters\n        ----------\n        breaks : array_like\n            The x locations where each line segment terminates. These are\n            referred to as breakpoints for each line segment. This should be\n            structured as a 1-D numpy array.\n        x_c : array_like\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        y_c : array_like\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n\n        Returns\n        -------\n        L : float\n            Returns the Lagrangian function value. This is the sum of squares\n            of the residuals plus the constraint penalty.\n\n        Raises\n        ------\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n        ValueError\n            You can\'t specify weights with x_c and y_c.\n\n        Examples\n        --------\n        If your x data exists from 0 <= x <= 1 and you want three\n        piecewise linear lines where the lines terminate at x = 0.0, 0.3, 0.6,\n        and 1.0. This assumes that x is linearly spaced from [0, 1), and y is\n        random. Additionally you desired that the piecewise linear function go\n        through the point (0.0, 0.0)\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> x_c = [0.0]\n        >>> y_c = [0.0]\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = [0.0, 0.3, 0.6, 1.0]\n        >>> L = my_pwlf.fit_with_breaks_force_points(breaks, x_c, y_c)\n\n        """"""\n\n        # check if x_c and y_c are numpy array, if not convert to numpy array\n        if isinstance(x_c, np.ndarray) is False:\n            x_c = np.array(x_c)\n        if isinstance(y_c, np.ndarray) is False:\n            y_c = np.array(y_c)\n        # sort the x_c and y_c data points, then store them\n        x_c_order = np.argsort(x_c)\n        self.x_c = x_c[x_c_order]\n        self.y_c = y_c[x_c_order]\n        # store the number of constraints\n        self.c_n = len(self.x_c)\n\n        if self.weights is not None:\n            raise ValueError(\'Constrained least squares with weights are\'\n                             \' not supported since these have a tendency \'\n                             \'of being numerically instable.\')\n\n        # Check if breaks in ndarray, if not convert to np.array\n        if isinstance(breaks, np.ndarray) is False:\n            breaks = np.array(breaks)\n\n        A = self.assemble_regression_matrix(breaks, self.x_data)\n        L = self.conlstsq(A)\n        return L\n\n    def predict(self, x, beta=None, breaks=None):\n        r""""""\n        Evaluate the fitted continuous piecewise linear function at untested\n        points.\n\n        You can manfully specify the breakpoints and calculated\n        values for beta if you want to quickly predict from different models\n        and the same data set.\n\n        Parameters\n        ----------\n        x : array_like\n            The x locations where you want to predict the output of the fitted\n            continuous piecewise linear function.\n        beta : none or ndarray (1-D), optional\n            The model parameters for the continuous piecewise linear fit.\n            Default is None.\n        breaks : none or array_like, optional\n            The x locations where each line segment terminates. These are\n            referred to as breakpoints for each line segment. This should be\n            structured as a 1-D numpy array. Default is None.\n\n        Returns\n        -------\n        y_hat : ndarray (1-D)\n            The predicted values at x.\n\n        Examples\n        --------\n        Fits a simple model, then predict at x_new locations which are\n        linearly spaced.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = [0.0, 0.3, 0.6, 1.0]\n        >>> ssr = my_pwlf.fit_with_breaks(breaks)\n        >>> x_new = np.linspace(0.0, 1.0, 100)\n        >>> yhat = my_pwlf.predict(x_new)\n\n        """"""\n        if beta is not None and breaks is not None:\n            self.beta = beta\n            # Sort the breaks, then store them\n            breaks_order = np.argsort(breaks)\n            self.fit_breaks = breaks[breaks_order]\n            self.n_parameters = len(self.fit_breaks)\n            self.n_segments = self.n_parameters - 1\n\n        # check if x is numpy array, if not convert to numpy array\n        if isinstance(x, np.ndarray) is False:\n            x = np.array(x)\n\n        A = self.assemble_regression_matrix(self.fit_breaks, x)\n\n        # solve the regression problem\n        y_hat = np.dot(A, self.beta)\n        return y_hat\n\n    def fit_with_breaks_opt(self, var):\n        r""""""\n        The objective function to perform a continuous piecewise linear\n        fit for a specified number of breakpoints. This is to be used\n        with a custom optimization routine, and after use_custom_opt has\n        been called.\n\n        This was intended for advanced users only.\n\n        See the following example\n        https://github.com/cjekel/piecewise_linear_fit_py/blob/master/examples/useCustomOptimizationRoutine.py\n\n        Parameters\n        ----------\n        var : array_like\n            The breakpoint locations, or variable, in a custom\n            optimization routine.\n\n        Returns\n        -------\n        ssr : float\n            The sum of square of the residuals.\n\n        Raises\n        ------\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Notes\n        -----\n        You should run use_custom_opt to initialize necessary object\n        attributes first.\n\n        Unlike fit_with_breaks, fit_with_breaks_opt automatically\n        assumes that the first and last breakpoints occur at the min and max\n        values of x.\n        """"""\n\n        var = np.sort(var)\n        breaks = np.zeros(len(var) + 2)\n        breaks[1:-1] = var.copy()\n        breaks[0] = self.break_0\n        breaks[-1] = self.break_n\n\n        A = self.assemble_regression_matrix(breaks, self.x_data)\n\n        # try to solve the regression problem\n        try:\n            # least squares solver\n            ssr = self.lstsq(A)\n\n        except linalg.LinAlgError:\n            # the computation could not converge!\n            # on an error, return ssr = np.inf\n            # You might have a singular Matrix!!!\n            ssr = np.inf\n        if ssr is None:\n            ssr = np.inf\n            # something went wrong...\n        return ssr\n\n    def fit_force_points_opt(self, var):\n        r""""""\n        The objective function to perform a continuous piecewise linear\n        fit for a specified number of breakpoints. This is to be used\n        with a custom optimization routine, and after use_custom_opt has\n        been called.\n\n        Use this function if you intend to be force the model through\n        x_c and y_c, while performing a custom optimization.\n\n        This was intended for advanced users only.\n        See the following example\n        https://github.com/cjekel/piecewise_linear_fit_py/blob/master/examples/useCustomOptimizationRoutine.py\n\n        Parameters\n        ----------\n        var : array_like\n            The breakpoint locations, or variable, in a custom\n            optimization routine.\n\n        Returns\n        -------\n        ssr : float\n            The sum of square of the residuals.\n\n        Raises\n        ------\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Notes\n        -----\n        You should run use_custom_opt to initialize necessary object\n        attributes first.\n\n        Unlike fit_with_breaks_force_points, fit_force_points_opt\n        automatically assumes that the first and last breakpoints occur\n        at the min and max values of x.\n        """"""\n\n        var = np.sort(var)\n        breaks = np.zeros(len(var) + 2)\n        breaks[1:-1] = var.copy()\n        breaks[0] = self.break_0\n        breaks[-1] = self.break_n\n\n        # Sort the breaks, then store them\n        breaks_order = np.argsort(breaks)\n        breaks = breaks[breaks_order]\n\n        A = self.assemble_regression_matrix(breaks, self.x_data)\n        L = self.conlstsq(A)\n        return L\n\n    def fit(self, n_segments, x_c=None, y_c=None, bounds=None, **kwargs):\n        r""""""\n        Fit a continuous piecewise linear function for a specified number\n        of line segments. Uses differential evolution to finds the optimum\n        location of breakpoints for a given number of line segments by\n        minimizing the sum of the square error.\n\n        Parameters\n        ----------\n        n_segments : int\n            The desired number of line segments.\n        x_c : array_like, optional\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        y_c : array_like, optional\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        bounds : array_like, optional\n            Bounds for each breakpoint location within the optimization. This\n            should have the shape of (n_segments, 2).\n        **kwargs : optional\n            Directly passed into scipy.optimize.differential_evolution(). This\n            will override any pwlf defaults when provided. See Note for more\n            information.\n\n        Returns\n        -------\n        fit_breaks : float\n            breakpoint locations stored as a 1-D numpy array.\n\n        Raises\n        ------\n        ValueError\n            You probably provided x_c without y_c (or vice versa).\n            You must provide both x_c and y_c if you plan to force\n            the model through data point(s).\n        ValueError\n            You can\'t specify weights with x_c and y_c.\n\n        Notes\n        -----\n        All **kwargs are passed into sicpy.optimize.differential_evolution.\n        If any **kwargs is used, it will override my differential_evolution,\n        defaults. This allows advanced users to tweak their own optimization.\n        For me information see:\n        https://github.com/cjekel/piecewise_linear_fit_py/issues/15#issuecomment-434717232\n\n        Examples\n        --------\n        This example shows you how to fit three continuous piecewise lines to\n        a dataset. This assumes that x is linearly spaced from [0, 1), and y is\n        random.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fit(3)\n\n        Additionally you desired that the piecewise linear function go\n        through the point (0.0, 0.0).\n\n        >>> x_c = [0.0]\n        >>> y_c = [0.0]\n        >>> breaks = my_pwlf.fit(3, x_c=x_c, y_c=y_c)\n\n        Additionally you desired that the piecewise linear function go\n        through the points (0.0, 0.0) and (1.0, 1.0).\n\n        >>> x_c = [0.0, 1.0]\n        >>> y_c = [0.0, 1.0]\n        >>> breaks = my_pwlf.fit(3, x_c=x_c, y_c=y_c)\n\n        """"""\n\n        # check to see if you\'ve provided just x_c or y_c\n        logic1 = x_c is not None and y_c is None\n        logic2 = y_c is not None and x_c is None\n        if logic1 or logic2:\n            raise ValueError(\'You must provide both x_c and y_c!\')\n\n        # set the function to minimize\n        min_function = self.fit_with_breaks_opt\n\n        # if you\'ve provided both x_c and y_c\n        if x_c is not None and y_c is not None:\n            # check if x_c and y_c are numpy array\n            # if not convert to numpy array\n            if isinstance(x_c, np.ndarray) is False:\n                x_c = np.array(x_c)\n            if isinstance(y_c, np.ndarray) is False:\n                y_c = np.array(y_c)\n            # sort the x_c and y_c data points, then store them\n            x_c_order = np.argsort(x_c)\n            self.x_c = x_c[x_c_order]\n            self.y_c = y_c[x_c_order]\n            # store the number of constraints\n            self.c_n = len(self.x_c)\n            # Use a different function to minimize\n            min_function = self.fit_force_points_opt\n            if self.weights is not None:\n                raise ValueError(\'Constrained least squares with weights are\'\n                                 \' not supported since these have a tendency \'\n                                 \'of being numerically instable.\')\n\n        # store the number of line segments and number of parameters\n        self.n_segments = int(n_segments)\n        self.n_parameters = self.n_segments + 1\n\n        # calculate the number of variables I have to solve for\n        self.nVar = self.n_segments - 1\n\n        # initiate the bounds of the optimization\n        if bounds is None:\n            bounds = np.zeros([self.nVar, 2])\n            bounds[:, 0] = self.break_0\n            bounds[:, 1] = self.break_n\n\n        # run the optimization\n        if len(kwargs) == 0:\n            res = differential_evolution(min_function, bounds,\n                                         strategy=\'best1bin\', maxiter=1000,\n                                         popsize=50, tol=1e-3,\n                                         mutation=(0.5, 1), recombination=0.7,\n                                         seed=None, callback=None, disp=False,\n                                         polish=True, init=\'latinhypercube\',\n                                         atol=1e-4)\n        else:\n            res = differential_evolution(min_function,\n                                         bounds, **kwargs)\n        if self.print is True:\n            print(res)\n\n        self.ssr = res.fun\n\n        # pull the breaks out of the result\n        var = np.sort(res.x)\n        breaks = np.zeros(len(var) + 2)\n        breaks[1:-1] = var.copy()\n        breaks[0] = self.break_0\n        breaks[-1] = self.break_n\n\n        # assign values\n        if x_c is None and y_c is None:\n            self.fit_with_breaks(breaks)\n        else:\n            self.fit_with_breaks_force_points(breaks, self.x_c, self.y_c)\n\n        return self.fit_breaks\n\n    def fitfast(self, n_segments, pop=2, bounds=None, **kwargs):\n        r""""""\n        Uses multi start LBFGSB optimization to find the location of\n        breakpoints for a given number of line segments by minimizing the sum\n        of the square of the errors.\n\n        The idea is that we generate n random latin hypercube samples\n        and run LBFGSB optimization on each one. This isn\'t guaranteed to\n        find the global optimum. It\'s suppose to be a reasonable compromise\n        between speed and quality of fit. Let me know how it works.\n\n        Since this is based on random sampling, you might want to run it\n        multiple times and save the best version... The best version will\n        have the lowest self.ssr (sum of square of residuals).\n\n        There is no guarantee that this will be faster than fit(), however\n        you may find it much faster sometimes.\n\n        Parameters\n        ----------\n        n_segments : int\n            The desired number of line segments.\n        pop : int, optional\n            The number of latin hypercube samples to generate. Default pop=2.\n        bounds : array_like, optional\n            Bounds for each breakpoint location within the optimization. This\n            should have the shape of (n_segments, 2).\n        **kwargs : optional\n            Directly passed into scipy.optimize.fmin_l_bfgs_b(). This\n            will override any pwlf defaults when provided. See Note for more\n            information.\n\n        Returns\n        -------\n        fit_breaks : float\n            breakpoint locations stored as a 1-D numpy array.\n\n        Notes\n        -----\n        The default number of multi start optimizations is 2.\n            - Decreasing this number will result in a faster run time.\n            - Increasing this number will improve the likelihood of finding\n                good results\n            - You can specify the number of starts using the following call\n            - Minimum value of pop is 2\n\n        All **kwargs are passed into sicpy.optimize.fmin_l_bfgs_b. If any\n        **kwargs is used, it will override my defaults. This allows\n        advanced users to tweak their own optimization. For me information see:\n        https://github.com/cjekel/piecewise_linear_fit_py/issues/15#issuecomment-434717232\n\n        Examples\n        --------\n        This example shows you how to fit three continuous piecewise lines to\n        a dataset. This assumes that x is linearly spaced from [0, 1), and y is\n        random.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fitfast(3)\n\n        You can change the number of latin hypercube samples (or starting\n        point, locations) to use with pop. The following example will use 50\n        samples.\n\n        >>> breaks = my_pwlf.fitfast(3, pop=50)\n\n        """"""\n        pop = int(pop)  # ensure that the population is integer\n\n        self.n_segments = int(n_segments)\n        self.n_parameters = self.n_segments + 1\n\n        # calculate the number of variables I have to solve for\n        self.nVar = self.n_segments - 1\n\n        # initiate the bounds of the optimization\n        if bounds is None:\n            bounds = np.zeros([self.nVar, 2])\n            bounds[:, 0] = self.break_0\n            bounds[:, 1] = self.break_n\n\n        # perform latin hypercube sampling\n        mypop = lhs(self.nVar, samples=pop, criterion=\'maximin\')\n        # scale the sampling to my variable range\n        mypop = mypop * (self.break_n - self.break_0) + self.break_0\n\n        x = np.zeros((pop, self.nVar))\n        f = np.zeros(pop)\n        d = []\n\n        for i, x0 in enumerate(mypop):\n            if len(kwargs) == 0:\n                resx, resf, resd = fmin_l_bfgs_b(self.fit_with_breaks_opt, x0,\n                                                 fprime=None, args=(),\n                                                 approx_grad=True,\n                                                 bounds=bounds, m=10,\n                                                 factr=1e2, pgtol=1e-05,\n                                                 epsilon=1e-08, iprint=-1,\n                                                 maxfun=15000, maxiter=15000,\n                                                 disp=None, callback=None)\n            else:\n                resx, resf, resd = fmin_l_bfgs_b(self.fit_with_breaks_opt, x0,\n                                                 fprime=None, approx_grad=True,\n                                                 bounds=bounds, **kwargs)\n            x[i, :] = resx\n            f[i] = resf\n            d.append(resd)\n            if self.print is True:\n                print(i + 1, \'of \' + str(pop) + \' complete\')\n\n        # find the best result\n        best_ind = np.nanargmin(f)\n        best_val = f[best_ind]\n        best_break = x[best_ind]\n        res = (x[best_ind], f[best_ind], d[best_ind])\n        if self.print is True:\n            print(res)\n\n        self.ssr = best_val\n\n        # obtain the breakpoint locations from the best result\n        var = np.sort(best_break)\n        breaks = np.zeros(len(var) + 2)\n        breaks[1:-1] = var.copy()\n        breaks[0] = self.break_0\n        breaks[-1] = self.break_n\n\n        # assign parameters\n        self.fit_with_breaks(breaks)\n\n        return self.fit_breaks\n\n    def fit_guess(self, guess_breakpoints, bounds=None, **kwargs):\n        r""""""\n        Uses L-BFGS-B optimization to find the location of breakpoints\n        from a guess of where breakpoint locations should be.\n\n        In some cases you may have a good idea where the breakpoint locations\n        occur. It generally won\'t be necessary to run a full global\n        optimization to search the entire domain for the breakpoints when you\n        have a good idea where the breakpoints occur. Here a local optimization\n        is run from a guess of the breakpoint locations.\n\n        Parameters\n        ----------\n        guess_breakpoints : array_like\n            Guess where the breakpoints occur. This should be a list or numpy\n            array containing the locations where it appears breakpoints occur.\n        bounds : array_like, optional\n            Bounds for each breakpoint location within the optimization. This\n            should have the shape of (n_segments, 2).\n        **kwargs : optional\n            Directly passed into scipy.optimize.fmin_l_bfgs_b(). This\n            will override any pwlf defaults when provided. See Note for more\n            information.\n\n        Returns\n        -------\n        fit_breaks : float\n            breakpoint locations stored as a 1-D numpy array.\n\n        Notes\n        -----\n        All **kwargs are passed into sicpy.optimize.fmin_l_bfgs_b. If any\n        **kwargs is used, it will override my defaults. This allows\n        advanced users to tweak their own optimization. For me information see:\n        https://github.com/cjekel/piecewise_linear_fit_py/issues/15#issuecomment-434717232\n\n        You do not need to specify the x.min() or x.max() in geuss_breakpoints!\n\n        Examples\n        --------\n        In this example we see two distinct linear regions, and we believe a\n        breakpoint occurs at 6.0. We\'ll use the fit_guess() function to find\n        the best breakpoint location starting with this guess.\n\n        >>> import pwlf\n        >>> x = np.array([4., 5., 6., 7., 8.])\n        >>> y = np.array([11., 13., 16., 28.92, 42.81])\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fit_guess([6.0])\n\n        Note specifying one breakpoint will result in two line segments.\n        If we wanted three line segments, we\'ll have to specify two\n        breakpoints.\n\n        >>> breaks = my_pwlf.fit_guess([5.5, 6.0])\n\n        """"""\n        # calculate the number of variables I have to solve for\n        self.nVar = len(guess_breakpoints)\n        self.n_segments = self.nVar + 1\n        self.n_parameters = self.n_segments + 1\n\n        # initiate the bounds of the optimization\n        if bounds is None:\n            bounds = np.zeros([self.nVar, 2])\n            bounds[:, 0] = self.break_0\n            bounds[:, 1] = self.break_n\n\n        if len(kwargs) == 0:\n            resx, resf, _ = fmin_l_bfgs_b(self.fit_with_breaks_opt,\n                                          guess_breakpoints,\n                                          fprime=None, args=(),\n                                          approx_grad=True,\n                                          bounds=bounds, m=10,\n                                          factr=1e2, pgtol=1e-05,\n                                          epsilon=1e-08, iprint=-1,\n                                          maxfun=15000, maxiter=15000,\n                                          disp=None, callback=None)\n        else:\n            resx, resf, _ = fmin_l_bfgs_b(self.fit_with_breaks_opt,\n                                          guess_breakpoints,\n                                          fprime=None, approx_grad=True,\n                                          bounds=bounds, **kwargs)\n\n        self.ssr = resf\n\n        # pull the breaks out of the result\n        var = np.sort(resx)\n        breaks = np.zeros(len(var) + 2)\n        breaks[1:-1] = var.copy()\n        breaks[0] = self.break_0\n        breaks[-1] = self.break_n\n\n        # assign values\n        self.fit_with_breaks(breaks)\n\n        return self.fit_breaks\n\n    def use_custom_opt(self, n_segments, x_c=None, y_c=None):\n        r""""""\n        Provide the number of line segments you want to use with your\n        custom optimization routine.\n\n        Run this function first to initialize necessary attributes!!!\n\n        This was intended for advanced users only.\n\n        See the following example\n        https://github.com/cjekel/piecewise_linear_fit_py/blob/master/examples/useCustomOptimizationRoutine.py\n\n        Parameters\n        ----------\n        n_segments : int\n            The x locations where each line segment terminates. These are\n            referred to as breakpoints for each line segment. This should be\n            structured as a 1-D numpy array.\n        x_c : none or array_like, optional\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n        y_c : none or array_like, optional\n            The x locations of the data points that the piecewise linear\n            function will be forced to go through.\n\n        Notes\n        -----\n        Optimize fit_with_breaks_opt(var) where var is a 1D array\n        containing the x locations of your variables\n        var has length n_segments - 1, because the two breakpoints\n        are always defined (1. the min of x, 2. the max of x).\n\n        fit_with_breaks_opt(var) will return the sum of the square of the\n        residuals which you\'ll want to minimize with your optimization\n        routine.\n\n        Raises\n        ------\n        ValueError\n            You can\'t specify weights with x_c and y_c.\n\n        """"""\n\n        self.n_segments = int(n_segments)\n        self.n_parameters = self.n_segments + 1\n\n        # calculate the number of variables I have to solve for\n        self.nVar = self.n_segments - 1\n        if x_c is not None or y_c is not None:\n            # check if x_c and y_c are numpy array\n            # if not convert to numpy array\n            if isinstance(x_c, np.ndarray) is False:\n                x_c = np.array(x_c)\n            if isinstance(y_c, np.ndarray) is False:\n                y_c = np.array(y_c)\n            # sort the x_c and y_c data points, then store them\n            x_c_order = np.argsort(x_c)\n            self.x_c = x_c[x_c_order]\n            self.y_c = y_c[x_c_order]\n            # store the number of constraints\n            self.c_n = len(self.x_c)\n            if self.weights is not None:\n                raise ValueError(\'Constrained least squares with weights are\'\n                                 \' not supported since these have a tendency \'\n                                 \'of being numerically instable.\')\n\n    def calc_slopes(self):\n        r""""""\n        Calculate the slopes of the lines after a piecewise linear\n        function has been fitted.\n\n        This will also calculate the y-intercept from each line in the form\n        y = mx + b. The intercepts are stored at self.intercepts.\n\n        Returns\n        -------\n        slopes : ndarray(1-D)\n            The slope of each ling segment as a 1-D numpy array. This assumes\n            that x[0] <= x[1] <= ... <= x[n]. Thus, slopes[0] is the slope\n            of the first line segment.\n\n        Examples\n        --------\n        Calculate the slopes after performing a simple fit\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fit(3)\n        >>> slopes = my_pwlf.calc_slopes()\n\n        """"""\n        y_hat = self.predict(self.fit_breaks)\n        self.slopes = np.zeros(self.n_segments)\n        for i in range(self.n_segments):\n            self.slopes[i] = (y_hat[i+1]-y_hat[i]) / \\\n                        (self.fit_breaks[i+1]-self.fit_breaks[i])\n        self.intercepts = y_hat[0:-1] - self.slopes*self.fit_breaks[0:-1]\n        return self.slopes\n\n    def standard_errors(self, method=\'linear\', step_size=1e-4):\n        r""""""\n        Calculate the standard errors for each beta parameter determined\n        from the piecewise linear fit. Typically +- 1.96*se will yield the\n        center of a 95% confidence region around your parameters. This\n        assumes the parmaters follow a normal distribution. For more\n        information see:\n        https://en.wikipedia.org/wiki/Standard_error\n\n        This calculation follows the derivation provided in [1]_.\n\n        Parameters\n        ----------\n        method : string, optional\n            Calculate the standard errors for a linear or non-linear\n            regression problem. The default is method=\'linear\'. A taylor-\n            series expansion is performed when method=\'non-linear\' (which is\n            commonly referred to as the Delta method).\n        step_size : float, optional\n            The step size to perform forward differences for the taylor-\n            series expansion when method=\'non-linear\'. Default is\n            step_size=1e-4.\n\n        Returns\n        -------\n        se : ndarray (1-D)\n            Standard errors associated with each beta parameter. Specifically\n            se[0] correspounds to the standard error for beta[0], and so forth.\n\n        Raises\n        ------\n        AttributeError\n            You have probably not performed a fit yet.\n        ValueError\n            You supplied an unsupported method.\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Notes\n        -----\n        The linear regression problem is when you know the breakpoint\n        locations (e.g. when using the fit_with_breaks function).\n\n        The non-linear regression problem is when you don\'t know the\n        breakpoint locations (e.g. when using the fit, fitfast, and fit_guess\n        functions).\n\n        References\n        ----------\n        .. [1] Coppe, A., Haftka, R. T., and Kim, N. H., \xe2\x80\x9cUncertainty\n            Identification of Damage Growth Parameters Using Nonlinear\n            Regression,\xe2\x80\x9d AIAA Journal, Vol. 49, No. 12, dec 2011, pp.\n            2818\xe2\x80\x932821.\n\n        Examples\n        --------\n        Calculate the standard errors after performing a simple fit.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fitfast(3)\n        >>> se = my_pwlf.standard_errors()\n\n        """"""\n        try:\n            nb = self.beta.size\n        except AttributeError:\n            errmsg = \'You do not have any beta parameters. You must perform\' \\\n                     \' a fit before using standard_errors().\'\n            raise AttributeError(errmsg)\n        ny = self.n_data\n        if method == \'linear\':\n            A = self.assemble_regression_matrix(self.fit_breaks, self.x_data)\n            y_hat = np.dot(A, self.beta)\n            e = y_hat - self.y_data\n\n        elif method == \'non-linear\':\n            nb = self.beta.size + self.fit_breaks.size - 2\n            f0 = self.predict(self.x_data)\n            A = np.zeros((ny, nb))\n            orig_beta = self.beta.copy()\n            orig_breaks = self.fit_breaks.copy()\n            # calculate differentials due to betas\n            for i in range(self.beta.size):\n                temp_beta = orig_beta.copy()\n                temp_beta[i] += step_size\n                # vary beta and keep breaks constant\n                f = self.predict(self.x_data, beta=temp_beta,\n                                 breaks=orig_breaks)\n                A[:, i] = (f-f0) / step_size\n            # append differentials due to break points\n            for i in range(self.beta.size, nb):\n                # \'ind\' ignores first and last entry in self.fit_breaks since\n                # these are simply the min/max of self.x_data.\n                ind = i - self.beta.size + 1\n                temp_breaks = orig_breaks.copy()\n                temp_breaks[ind] += step_size\n                # vary break and keep betas constant\n                f = self.predict(self.x_data, beta=orig_beta,\n                                 breaks=temp_breaks)\n                A[:, i] = (f-f0) / step_size\n            e = f0 - self.y_data\n            # reset beta and breaks back to original values\n            self.beta = orig_beta\n            self.fit_breaks = orig_breaks\n\n        else:\n            errmsg = ""Error: method=\'"" + method + ""\' is not supported!""\n            raise ValueError(errmsg)\n        # try to solve for the standard errors\n        try:\n            variance = np.dot(e, e) / (ny - nb)\n            if self.weights is None:\n                # solve for the unbiased estimate of variance\n                A2inv = np.abs(linalg.inv(np.dot(A.T, A)).diagonal())\n                self.se = np.sqrt(variance * A2inv)\n            else:\n                A = (A.T*self.weights).T\n                A2inv = np.abs(linalg.inv(np.dot(A.T, A)).diagonal())\n                self.se = np.sqrt(variance * A2inv)\n            return self.se\n\n        except linalg.LinAlgError:\n            raise linalg.LinAlgError(\'Singular matrix\')\n\n    def prediction_variance(self, x):\n        r""""""\n        Calculate the prediction variance for each specified x location. The\n        prediction variance is the uncertainty of the model due to the lack of\n        data. This can be used to find a 95% confidence interval of possible\n        piecewise linear models based on the current data. This would be\n        done typically as y_hat +- 1.96*np.sqrt(pre_var). The\n        prediction_variance needs to be calculated at various x locations.\n        For more information see:\n        www2.mae.ufl.edu/haftka/vvuq/lectures/Regression-accuracy.pptx\n\n        Parameters\n        ----------\n        x : array_like\n            The x locations where you want the prediction variance from the\n            fitted continuous piecewise linear function.\n\n        Returns\n        -------\n        pre_var : ndarray (1-D)\n            Numpy array (floats) of prediction variance at each x location.\n\n        Raises\n        ------\n        AttributeError\n            You have probably not performed a fit yet.\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Notes\n        -----\n        This assumes that your breakpoint locations are exact! and does\n        not consider the uncertainty with your breakpoint locations.\n\n        Examples\n        --------\n        Calculate the prediction variance at x_new after performing a simple\n        fit.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fitfast(3)\n        >>> x_new = np.linspace(0.0, 1.0, 100)\n        >>> pre_var = my_pwlf.prediction_variance(x_new)\n\n        see also examples/prediction_variance.py\n\n        """"""\n        try:\n            nb = self.beta.size\n        except AttributeError:\n            errmsg = \'You do not have any beta parameters. You must perform\' \\\n                     \' a fit before using standard_errors().\'\n            raise AttributeError(errmsg)\n\n        ny = self.n_data\n\n        # check if x is numpy array, if not convert to numpy array\n        if isinstance(x, np.ndarray) is False:\n            x = np.array(x)\n\n        # Regression matrix on training data\n        Ad = self.assemble_regression_matrix(self.fit_breaks, self.x_data)\n\n        # try to solve for the unbiased variance estimation\n        try:\n\n            y_hat = np.dot(Ad, self.beta)\n            e = y_hat - self.y_data\n            # solve for the unbiased estimate of variance\n            variance = np.dot(e, e) / (ny - nb)\n\n        except linalg.LinAlgError:\n            raise linalg.LinAlgError(\'Singular matrix\')\n\n        # Regression matrix on prediction data\n        A = self.assemble_regression_matrix(self.fit_breaks, x)\n\n        # try to solve for the prediction variance at the x locations\n        try:\n            pre_var = variance * \\\n                np.dot(np.dot(A, linalg.inv(np.dot(Ad.T, Ad))), A.T)\n            return pre_var.diagonal()\n\n        except linalg.LinAlgError:\n            raise linalg.LinAlgError(\'Singular matrix\')\n\n    def r_squared(self):\n        r""""""\n        Calculate the coefficient of determination (""R squared"", R^2) value\n        after a fit has been performed.\n        For more information see:\n        https://en.wikipedia.org/wiki/Coefficient_of_determination\n\n        Returns\n        -------\n        rsq : float\n            Coefficient of determination, or \'R squared\' value.\n\n        Raises\n        ------\n        AttributeError\n            You have probably not performed a fit yet.\n        LinAlgError\n            This typically means your regression problem is ill-conditioned.\n\n        Examples\n        --------\n        Calculate the R squared value after performing a simple fit.\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fitfast(3)\n        >>> rsq = my_pwlf.r_squared()\n\n        """"""\n        if self.fit_breaks is None:\n            errmsg = \'You do not have any beta parameters. You must perform\' \\\n                     \' a fit before using standard_errors().\'\n            raise AttributeError(errmsg)\n        ssr = self.fit_with_breaks(self.fit_breaks)\n        ybar = np.ones(self.n_data) * np.mean(self.y_data)\n        ydiff = self.y_data - ybar\n        try:\n            sst = np.dot(ydiff, ydiff)\n            rsq = 1.0 - (ssr/sst)\n            return rsq\n        except linalg.LinAlgError:\n            raise linalg.LinAlgError(\'Singular matrix\')\n\n    def p_values(self, method=\'linear\', step_size=1e-4):\n        r""""""\n        Calculate the p-values for each beta parameter.\n\n        This calculates the p-values for the beta parameters under the\n        assumption that your breakpoint locations are known. Section 2.4.2 of\n        [2]_ defines how to calculate the p-value of individual parameters.\n        This is really a marginal test since each parameter is dependent upon\n        the other parameters.\n\n        These values are typically compared to some confidence level alpha for\n        significance. A 95% confidence level would have alpha = 0.05.\n\n        Parameters\n        ----------\n        method : string, optional\n            Calculate the standard errors for a linear or non-linear\n            regression problem. The default is method=\'linear\'. A taylor-\n            series expansion is performed when method=\'non-linear\' (which is\n            commonly referred to as the Delta method).\n        step_size : float, optional\n            The step size to perform forward differences for the taylor-\n            series expansion when method=\'non-linear\'. Default is\n            step_size=1e-4.\n\n        Returns\n        -------\n        p : ndarray (1-D)\n            p-values for each beta parameter where p-value[0] corresponds to\n            beta[0] and so forth\n\n        Raises\n        ------\n        AttributeError\n            You have probably not performed a fit yet.\n        ValueError\n            You supplied an unsupported method.\n\n        Notes\n        -----\n        The linear regression problem is when you know the breakpoint\n        locations (e.g. when using the fit_with_breaks function).\n\n        The non-linear regression problem is when you don\'t know the\n        breakpoint locations (e.g. when using the fit, fitfast, and fit_guess\n        functions).\n\n        See https://github.com/cjekel/piecewise_linear_fit_py/issues/14\n\n        References\n        ----------\n        .. [2] Myers RH, Montgomery DC, Anderson-Cook CM. Response surface\n            methodology . Hoboken. New Jersey: John Wiley & Sons, Inc.\n            2009;20:38-44.\n\n        Examples\n        --------\n        After performing a fit, one can calculate the p-value for each beta\n        parameter\n\n        >>> import pwlf\n        >>> x = np.linspace(0.0, 1.0, 10)\n        >>> y = np.random.random(10)\n        >>> my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        >>> breaks = my_pwlf.fitfast(3)\n        >>> x_new = np.linspace(0.0, 1.0, 100)\n        >>> p = my_pwlf.p_values(x_new)\n\n        see also examples/standard_errrors_and_p-values.py\n\n        """"""\n        n = self.n_data\n        # degrees of freedom for t-distribution\n        if self.beta is None:\n            errmsg = \'You do not have any beta parameters. You must perform\' \\\n                     \' a fit before using standard_errors().\'\n            raise AttributeError(errmsg)\n        k = self.beta.size - 1\n\n        if method == \'linear\':\n            self.standard_errors()\n            # calculate my t-value\n            t = self.beta / self.se\n\n        elif method == \'non-linear\':\n            nb = self.beta.size + self.fit_breaks.size - 2\n            k = nb - 1\n            self.standard_errors(method=method, step_size=step_size)\n            # the parameters for a non-linear model include interior breaks\n            parameters = np.concatenate((self.beta, self.fit_breaks[1:-1]))\n            # calculate my t-value\n            t = parameters / self.se\n        else:\n            errmsg = ""Error: method=\'"" + method + ""\' is not supported!""\n            raise ValueError(errmsg)\n        # calculate the p-values\n        p = 2.0 * stats.t.sf(np.abs(t), df=n-k-1)\n        return p\n\n    def lstsq(self, A):\n        r""""""\n        Perform the least squares fit for A matrix.\n        """"""\n        if self.weights is None:\n            beta, ssr, _, _ = linalg.lstsq(A, self.y_data,\n                                           lapack_driver=self.lapack_driver)\n            # ssr is only calculated if self.n_data > self.n_parameters\n            # in this case I\'ll need to calculate ssr manually\n            # where ssr = sum of square of residuals\n            if self.n_data <= self.n_parameters:\n                y_hat = np.dot(A, beta)\n                e = y_hat - self.y_data\n                ssr = np.dot(e, e)\n        else:\n            beta, _, _, _ = linalg.lstsq((A.T*self.weights).T, self.y_w,\n                                         lapack_driver=self.lapack_driver)\n            # calculate the weighted sum of square of residuals\n            y_hat = np.dot(A, beta)\n            e = y_hat - self.y_data\n            r = e * self.weights\n            ssr = np.dot(r, r)\n        if isinstance(ssr, list):\n            ssr = ssr[0]\n        elif isinstance(ssr, np.ndarray):\n            if ssr.size == 0:\n                y_hat = np.dot(A, beta)\n                e = y_hat - self.y_data\n                ssr = np.dot(e, e)\n            else:\n                ssr = ssr[0]\n        # save the beta parameters\n        self.beta = beta\n\n        # save the slopes\n        self.calc_slopes()\n        return ssr\n\n    def conlstsq(self, A):\n        r""""""\n        Perform a constrained least squares fit for A matrix.\n        """"""\n        # Assemble the constraint matrix\n        C_list = [np.ones_like(self.x_c)]\n        if self.degree >= 1:\n            C_list.append(self.x_c - self.fit_breaks[0])\n            for i in range(self.n_segments - 1):\n                C_list.append(np.where(self.x_c > self.fit_breaks[i+1],\n                                       self.x_c - self.fit_breaks[i+1],\n                                       0.0))\n            if self.degree >= 2:\n                for k in range(2, self.degree + 1):\n                    C_list.append((self.x_c - self.fit_breaks[0])**k)\n                    for i in range(self.n_segments - 1):\n                        C_list.append(np.where(self.x_c > self.fit_breaks[i+1],\n                                               (self.x_c\n                                                - self.fit_breaks[i+1])**k,\n                                               0.0))\n        else:\n            for i in range(self.n_segments - 1):\n                C_list.append(np.where(self.x_c > self.fit_breaks[i+1],\n                                       1.0,\n                                       0.0))\n        C = np.vstack(C_list).T\n\n        _, m = A.shape\n        o, _ = C.shape\n\n        K = np.zeros((m + o, m + o))\n\n        K[:m, :m] = 2.0 * np.dot(A.T, A)\n        K[:m, m:] = C.T\n        K[m:, :m] = C\n        # Assemble right hand side vector\n        yt = np.dot(2.0*A.T, self.y_data)\n\n        z = np.zeros(self.n_parameters + self.c_n)\n        z[:self.n_parameters] = yt\n        z[self.n_parameters:] = self.y_c\n\n        # try to solve the regression problem\n        try:\n            # Solve the least squares problem\n            beta_prime = linalg.solve(K, z)\n\n            # save the beta parameters\n            self.beta = beta_prime[0:self.n_parameters]\n            # save the zeta parameters\n            self.zeta = beta_prime[self.n_parameters:]\n\n            # save the slopes\n            self.calc_slopes()\n\n            # Calculate ssr\n            # where ssr = sum of square of residuals\n            y_hat = np.dot(A, self.beta)\n            e = y_hat - self.y_data\n            ssr = np.dot(e, e)\n            self.ssr = ssr\n\n            # Calculate the Lagrangian function\n            # c_x_y = np.dot(C, self.x_c.T) - self.y_c\n            p = np.dot(C.T, self.zeta)\n            L = np.sum(np.abs(p)) + ssr\n\n        except linalg.LinAlgError:\n            # the computation could not converge!\n            # on an error, return L = np.inf\n            # You might have a singular Matrix!!!\n            L = np.inf\n        if L is None:\n            L = np.inf\n            # something went wrong...\n        return L\n'"
pwlf/version.py,0,"b""try:\n    from importlib import metadata\nexcept ImportError:\n    # Running on pre-3.8 Python; use importlib-metadata package\n    import importlib_metadata as metadata\n\n__version__ = metadata.version('pwlf')\n"""
tests/__init__.py,0,b''
tests/tests.py,81,"b""import numpy as np\nimport unittest\nimport pwlf\n\n\nclass TestEverything(unittest.TestCase):\n\n    x_small = np.array((0.0, 1.0, 1.5, 2.0))\n    y_small = np.array((0.0, 1.0, 1.1, 1.5))\n    x_sin = np.linspace(0, 10, num=100)\n    y_sin = np.sin(x_sin * np.pi / 2)\n\n    def test_break_point_spot_on(self):\n        # check that I can fit when break points spot on a\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        ssr = my_fit1.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr, 0.0))\n\n    def test_break_point_spot_on_list(self):\n        # check that I can fit when break points spot on a\n        my_fit1 = pwlf.PiecewiseLinFit(list(self.x_small), list(self.y_small))\n        x0 = self.x_small.copy()\n        ssr = my_fit1.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr, 0.0))\n\n    def test_degree_not_supported(self):\n        try:\n            _ = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                     degree=100)\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def test_x_c_not_supplied(self):\n        try:\n            mf = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                      degree=1)\n            mf.fit(2, x_c=[1.0])\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def test_y_c_not_supplied(self):\n        try:\n            mf = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                      degree=1)\n            mf.fit(2, y_c=[1.0])\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def test_lapack_driver(self):\n        # check that I can fit when break points spot on a\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                       lapack_driver='gelsy')\n        x0 = self.x_small.copy()\n        ssr = my_fit1.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr, 0.0))\n\n    def test_assembly(self):\n        # check that I can fit when break points spot on a\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        A = my_fit.assemble_regression_matrix(x0, my_fit.x_data)\n        Asb = np.array([[1.,  0.,  0.,  0.],\n                        [1.,  x0[1]-x0[0],  0.,  0.],\n                        [1.,  x0[2]-x0[0], x0[2]-x0[1], 0.],\n                        [1.,  x0[3]-x0[0], x0[3]-x0[1], x0[3]-x0[2]]])\n        self.assertTrue(np.allclose(A, Asb))\n\n    def test_assembly_list(self):\n        # check that I can fit when break points spot on a\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        A = my_fit.assemble_regression_matrix(x0, list(my_fit.x_data))\n        Asb = np.array([[1.,  0.,  0.,  0.],\n                        [1.,  x0[1]-x0[0],  0.,  0.],\n                        [1.,  x0[2]-x0[0], x0[2]-x0[1], 0.],\n                        [1.,  x0[3]-x0[0], x0[3]-x0[1], x0[3]-x0[2]]])\n        self.assertTrue(np.allclose(A, Asb))\n\n    def test_break_point_spot_on_r2(self):\n        # test r squared value with known solution\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        my_fit1.fit_with_breaks(x0)\n        rsq = my_fit1.r_squared()\n        self.assertTrue(np.isclose(rsq, 1.0))\n\n    def test_break_point_diff_x0_0(self):\n        # check diff loc\n        my_fit2 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        x0[1] = 1.00001\n        x0[2] = 1.50001\n        ssr2 = my_fit2.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr2, 0.0))\n\n    def test_break_point_diff_x0_1(self):\n        # check if my duplicate is in a different location\n        x0 = self.x_small.copy()\n        my_fit3 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0[1] = 0.9\n        ssr3 = my_fit3.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr3, 0.0))\n\n    def test_break_point_diff_x0_2(self):\n        # check if my duplicate is in a different location\n        x0 = self.x_small.copy()\n        my_fit4 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0[1] = 1.1\n        ssr4 = my_fit4.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr4, 0.0))\n\n    def test_break_point_diff_x0_3(self):\n        # check if my duplicate is in a different location\n        x0 = self.x_small.copy()\n        my_fit5 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0[2] = 1.6\n        ssr5 = my_fit5.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr5, 0.0))\n\n    def test_break_point_diff_x0_4(self):\n        # check if my duplicate is in a different location\n        x0 = self.x_small.copy()\n        my_fit6 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0[2] = 1.4\n        ssr6 = my_fit6.fit_with_breaks(x0)\n        self.assertTrue(np.isclose(ssr6, 0.0))\n\n    def test_diff_evo(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        my_pwlf.fit(4, disp=False)\n        self.assertTrue(np.isclose(my_pwlf.ssr, 0.0))\n\n    def test_custom_bounds1(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        n_segments = 3\n        bounds = np.zeros((n_segments-1, 2))\n        bounds[0, 0] = self.x_small[0]\n        bounds[0, 1] = self.x_small[2]\n        bounds[1, 0] = self.x_small[1]\n        bounds[1, 1] = self.x_small[-1]\n        my_pwlf.fit(n_segments, bounds=bounds)\n        self.assertTrue(np.isclose(my_pwlf.ssr, 0.0))\n\n    def test_custom_bounds2(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        n_segments = 3\n        bounds = np.zeros((n_segments-1, 2))\n        bounds[0, 0] = self.x_small[0]\n        bounds[0, 1] = self.x_small[2]\n        bounds[1, 0] = self.x_small[1]\n        bounds[1, 1] = self.x_small[-1]\n        my_pwlf.fitfast(n_segments, pop=20, bounds=bounds)\n        self.assertTrue(np.isclose(my_pwlf.ssr, 0.0))\n\n    def test_predict(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        xmax = np.max(self.x_small)\n        xmin = np.min(self.x_small)\n        my_pwlf.fit_with_breaks((xmin, xmax))\n        x = np.linspace(xmin, xmax, 10)\n        yHat = my_pwlf.predict(x)\n        self.assertTrue(np.isclose(np.sum(yHat), 8.085714285714287))\n\n    def test_custom_opt(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        my_pwlf.use_custom_opt(3)\n        x_guess = np.array((0.9, 1.1))\n        from scipy.optimize import minimize\n        res = minimize(my_pwlf.fit_with_breaks_opt, x_guess)\n        self.assertTrue(np.isclose(res['fun'], 0.0))\n\n    def test_custom_opt_with_con(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        my_pwlf.use_custom_opt(3, x_c=[0.], y_c=[0.])\n        x_guess = np.array((0.9, 1.1))\n        from scipy.optimize import minimize\n        res = minimize(my_pwlf.fit_with_breaks_opt, x_guess)\n        self.assertTrue(True)\n\n    def test_single_force_break_point1(self):\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x_c = [-0.5]\n        y_c = [-0.5]\n        my_fit.fit_with_breaks_force_points([0.2, 0.7], x_c, y_c)\n        yhat = my_fit.predict(x_c)\n        self.assertTrue(np.isclose(y_c, yhat))\n\n    def test_single_force_break_point2(self):\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x_c = [2.0]\n        y_c = [1.5]\n        my_fit.fit_with_breaks_force_points([0.2, 0.7], x_c, y_c)\n        yhat = my_fit.predict(x_c)\n        self.assertTrue(np.isclose(y_c, yhat))\n\n    def test_single_force_break_point_degree(self):\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small, degree=2)\n        x_c = [2.0]\n        y_c = [1.5]\n        my_fit.fit_with_breaks_force_points([0.2, 0.7], x_c, y_c)\n        yhat = my_fit.predict(x_c)\n        self.assertTrue(np.isclose(y_c, yhat))\n\n    def test_single_force_break_point_degree_zero(self):\n        my_fit = pwlf.PiecewiseLinFit(self.x_small, self.y_small, degree=0)\n        x_c = [2.0]\n        y_c = [1.5]\n        my_fit.fit_with_breaks_force_points([0.2, 0.7], x_c, y_c)\n        yhat = my_fit.predict(x_c)\n        self.assertTrue(np.isclose(y_c, yhat))\n\n    def test_opt_fit_with_force_points(self):\n        # I need more data points to test this function because of\n        # ill conditioning in the least squares problem...\n        x = np.linspace(0.0, 1.0, num=100)\n        y = np.sin(6.0*x)\n        my_fit = pwlf.PiecewiseLinFit(x, y, disp_res=True)\n        x_c = [0.0]\n        y_c = [0.0]\n        my_fit.fit(3, x_c, y_c)\n        yhat = my_fit.predict(x_c)\n        self.assertTrue(np.isclose(y_c, yhat))\n\n    def test_se(self):\n        # check to see if it will let me calculate standard errors\n        my_pwlf = pwlf.PiecewiseLinFit(np.random.random(20),\n                                       np.random.random(20))\n        my_pwlf.fitfast(2)\n        my_pwlf.standard_errors()\n\n    def test_p(self):\n        # check to see if it will let me calculate p-values\n        my_pwlf = pwlf.PiecewiseLinFit(np.random.random(20),\n                                       np.random.random(20))\n        my_pwlf.fitfast(2)\n        my_pwlf.p_values()\n\n    def test_nonlinear_p_and_se(self):\n        # generate a true piecewise linear data\n        np.random.seed(1)\n        n_data = 20\n        x = np.linspace(0, 1, num=n_data)\n        y = np.random.random(n_data)\n        my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        true_beta = np.array((1.0, 0.2, 0.2))\n        true_breaks = np.array((0.0, 0.5, 1.0))\n        y = my_pwlf.predict(x, beta=true_beta, breaks=true_breaks)\n        my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        my_pwlf.fitfast(2)\n        # calculate p-values\n        p = my_pwlf.p_values(method='non-linear', step_size=1e-4)\n        self.assertTrue(p.max() <= 0.05)\n\n    def test_pv(self):\n        # check to see if it will let me calculate prediction variance for\n        # random data\n        my_pwlf = pwlf.PiecewiseLinFit(np.random.random(20),\n                                       np.random.random(20))\n        my_pwlf.fitfast(2)\n        my_pwlf.prediction_variance(np.random.random(20))\n\n    def test_predict_with_custom_param(self):\n        # check to see if predict runs with custom parameters\n        x = np.random.random(20)\n        my_pwlf = pwlf.PiecewiseLinFit(x, np.random.random(20))\n        my_pwlf.predict(x, beta=np.array((1e-4, 1e-2, 1e-3)),\n                        breaks=np.array((0.0, 0.5, 1.0)))\n\n    def test_fit_guess(self):\n        x = np.array([4., 5., 6., 7., 8.])\n        y = np.array([11., 13., 16., 28.92, 42.81])\n        my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        breaks = my_pwlf.fit_guess([6.0])\n        self.assertTrue(np.isclose(breaks[1], 6.0705297))\n\n    def test_fit_guess_kwrds(self):\n        x = np.array([4., 5., 6., 7., 8.])\n        y = np.array([11., 13., 16., 28.92, 42.81])\n        my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        breaks = my_pwlf.fit_guess([6.0], m=10,\n                                   factr=1e2, pgtol=1e-05,\n                                   epsilon=1e-6, iprint=-1,\n                                   maxfun=1500000, maxiter=150000,\n                                   disp=None)\n        self.assertTrue(np.isclose(breaks[1], 6.0705297))\n\n    def test_multi_start_fitfast(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        my_pwlf.fitfast(4, 50)\n        self.assertTrue(np.isclose(my_pwlf.ssr, 0.0))\n\n    # =================================================\n    # Start of degree tests\n    def test_n_parameters_correct(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=0)\n        my_pwlf_1 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=1)\n        my_pwlf_2 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=2)\n        breaks = np.array([0.,  1.03913513,  3.04676334,  4.18647526, 10.])\n\n        A0 = my_pwlf_0.assemble_regression_matrix(breaks, self.x_sin)\n        A1 = my_pwlf_1.assemble_regression_matrix(breaks, self.x_sin)\n        A2 = my_pwlf_2.assemble_regression_matrix(breaks, self.x_sin)\n        self.assertTrue(A0.shape[1] == my_pwlf_0.n_parameters)\n        self.assertTrue(A1.shape[1] == my_pwlf_1.n_parameters)\n        self.assertTrue(A2.shape[1] == my_pwlf_2.n_parameters)\n        # Also check n_segments correct\n        self.assertTrue(4 == my_pwlf_0.n_segments)\n        self.assertTrue(4 == my_pwlf_1.n_segments)\n        self.assertTrue(4 == my_pwlf_2.n_segments)\n\n    def test_force_fits_through_points_other_degrees(self):\n        # generate sin wave data\n        x = np.linspace(0, 10, num=100)\n        y = np.sin(x * np.pi / 2)\n        # add noise to the data\n        y = np.random.normal(0, 0.15, 100) + y\n\n        # linear fit\n        my_pwlf_1 = pwlf.PiecewiseLinFit(x, y, degree=1)\n        my_pwlf_1.fit(n_segments=6, x_c=[0], y_c=[0])\n        y_predict_1 = my_pwlf_1.predict(x)\n\n        # quadratic fit\n        my_pwlf_2 = pwlf.PiecewiseLinFit(x, y, degree=2)\n        my_pwlf_2.fit(n_segments=5, x_c=[0], y_c=[0])\n        y_predict_2 = my_pwlf_2.predict(x)\n        self.assertTrue(np.isclose(0, y_predict_1[0]))\n        self.assertTrue(np.isclose(0, y_predict_2[0]))\n\n    def test_fitfast(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=0)\n        my_pwlf_1 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=1)\n        my_pwlf_2 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=2)\n\n        # fit the data for four line segments\n        np.random.seed(123123123)\n        my_pwlf_0.fitfast(4, pop=10)\n        my_pwlf_1.fitfast(4, pop=10)\n        my_pwlf_2.fitfast(4, pop=10)\n\n        self.assertTrue(my_pwlf_0.ssr <= 30.)\n        self.assertTrue(my_pwlf_1.ssr <= 12.5)\n        self.assertTrue(my_pwlf_2.ssr <= 1.5)\n\n    def test_fit(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=0)\n        my_pwlf_1 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=1)\n        my_pwlf_2 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=2)\n\n        # fit the data for four line segments\n        np.random.seed(123123)\n        my_pwlf_0.fit(5)\n        my_pwlf_1.fit(5)\n        my_pwlf_2.fit(5)\n\n        self.assertTrue(my_pwlf_0.ssr <= 10.)\n        self.assertTrue(my_pwlf_1.ssr <= 7.0)\n        self.assertTrue(my_pwlf_2.ssr <= 0.5)\n\n    def test_se_no_fit(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin)\n        try:\n            my_pwlf_0.standard_errors()\n            self.assertTrue(False)\n        except AttributeError:\n            self.assertTrue(True)\n\n    def test_se_no_method(self):\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        _ = my_fit1.fit_with_breaks(x0)\n        try:\n            my_fit1.standard_errors(method='blah')\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def test_pv_list(self):\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        _ = my_fit1.fit_with_breaks(x0)\n        my_fit1.prediction_variance(list(self.x_small))\n\n    def test_pv_no_fit(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin)\n        try:\n            my_pwlf_0.prediction_variance(self.x_sin)\n            self.assertTrue(False)\n        except AttributeError:\n            self.assertTrue(True)\n\n    def test_r2_no_fit(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin)\n        try:\n            my_pwlf_0.r_squared()\n            self.assertTrue(False)\n        except AttributeError:\n            self.assertTrue(True)\n\n    def test_pvalue_no_fit(self):\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin)\n        try:\n            my_pwlf_0.p_values()\n            self.assertTrue(False)\n        except AttributeError:\n            self.assertTrue(True)\n\n    def test_pvalues_wrong_method(self):\n        my_fit1 = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x0 = self.x_small.copy()\n        _ = my_fit1.fit_with_breaks(x0)\n        try:\n            my_fit1.p_values(method='blah')\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def test_all_stats(self):\n        np.random.seed(121)\n        my_pwlf_0 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=0)\n        my_pwlf_0.fitfast(3)\n        my_pwlf_0.standard_errors()\n        my_pwlf_0.prediction_variance(np.random.random(20))\n        my_pwlf_0.p_values()\n        my_pwlf_0.r_squared()\n        my_pwlf_0.calc_slopes()\n\n        my_pwlf_2 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=2)\n        my_pwlf_2.fitfast(3)\n        my_pwlf_2.standard_errors()\n        my_pwlf_2.prediction_variance(np.random.random(20))\n        my_pwlf_2.p_values()\n        my_pwlf_2.r_squared()\n        my_pwlf_2.calc_slopes()\n\n        my_pwlf_3 = pwlf.PiecewiseLinFit(self.x_sin, self.y_sin, degree=3)\n        my_pwlf_3.fitfast(3)\n        my_pwlf_3.standard_errors()\n        my_pwlf_3.prediction_variance(np.random.random(20))\n        my_pwlf_3.p_values()\n        my_pwlf_3.r_squared()\n        my_pwlf_3.calc_slopes()\n    # End of degree tests\n    # =================================================\n\n    # =================================================\n    # Start weighted least squares tests\n    def test_weighted_same_as_ols(self):\n        # test that weighted least squares is same as OLS\n        # when the weight is equal to 1.0\n        n_segments = 2\n        my = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        x = np.random.random()\n        breaks = my.fit_guess([x])\n        my_w = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                    weights=np.ones_like(self.x_small))\n        breaks_w = my_w.fit_guess([x])\n\n        self.assertTrue(np.isclose(my.ssr, my_w.ssr))\n        for i in range(n_segments+1):\n            self.assertTrue(np.isclose(breaks[i], breaks_w[i]))\n    \n    def test_heteroscedastic_data(self):\n        n_segments = 3\n        weights = self.y_small.copy()\n        weights[0] = 0.01\n        weights = 1.0 / weights\n        my_w = pwlf.PiecewiseLinFit(self.x_small, self.y_small,\n                                    weights=weights)\n        _ = my_w.fit(n_segments)\n        _ = my_w.standard_errors()\n\n    def test_not_supported_fit(self):\n        x = np.linspace(0.0, 1.0, num=100)\n        y = np.sin(6.0*x)\n        w = np.random.random(size=100)\n        my_fit = pwlf.PiecewiseLinFit(x, y, disp_res=True, weights=w)\n        x_c = [0.0]\n        y_c = [0.0]\n        try:\n            my_fit.fit(3, x_c, y_c)\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def not_supported_fit_with_breaks_force_points(self):\n        x = np.linspace(0.0, 1.0, num=100)\n        y = np.sin(6.0*x)\n        w = list(np.random.random(size=100))\n        my_fit = pwlf.PiecewiseLinFit(x, y, disp_res=True, weights=w)\n        x_c = [0.0]\n        y_c = [0.0]\n        try:\n            my_fit.fit_with_breaks_force_points([0.1, 0.2, 0.3], x_c, y_c)\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n    def custom_opt_not_supported(self):\n        my_pwlf = pwlf.PiecewiseLinFit(self.x_small, self.y_small)\n        try:\n            my_pwlf.use_custom_opt(3, x_c=[0], y_c=[0])\n            self.assertTrue(False)\n        except ValueError:\n            self.assertTrue(True)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
examples/tf/fit_begin_and_end.py,3,"b""# fit and predict between a known begging and known ending\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom scipy.optimize import differential_evolution\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFitTF(x, y, disp_res=True)\n\n# fit the function with four line segments\n# force the function to go through the data points\n# (0.0, 0.0) and (0.19, 0.16) \n# where the data points are of the form (x, y)\nx_c = [0.0, 0.19]\ny_c = [0.0, 0.2]\nbreaks = [0.00711605, 0.12014667, 0.1799223]\nL = my_pwlf.fit_with_breaks_force_points(breaks, x_c, y_c)\n\n# predict for the determined points\nxHat = np.linspace(min(x), 0.19, num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/tf/sine_benchmark_fixed_20_break_points.py,9,"b""import numpy as np\nimport pwlf\nfrom time import time\nimport os\n\nbreaks = np.linspace(0.0, 10.0, num=21)\n\nn = np.logspace(3, 7, num=15, dtype=np.int)\nn_repeats = 10\nrun_times = np.zeros((3, n.size, n_repeats))\n\nfor i, n_data in enumerate(n):\n    # set random seed\n    np.random.seed(256)\n    # generate sin wave data\n    x = np.linspace(0, 10, num=n_data)\n    y = np.sin(x * np.pi / 2)\n    # add noise to the data\n    y = np.random.normal(0, 0.05, size=n_data) + y\n    for j in range(n_repeats):\n        # normal PWLF fit\n        t0 = time()\n        my_pwlf = pwlf.PiecewiseLinFit(x, y)\n        ssr = my_pwlf.fit_with_breaks(breaks)\n        t1 = time()\n        # PWLF TF fit\n        t2 = time()\n        my_pwlf = pwlf.PiecewiseLinFitTF(x, y)\n        ssr = my_pwlf.fit_with_breaks(breaks)\n        t3 = time()\n        run_times[0, i, j] = t1 - t0\n        run_times[1, i, j] = t3 - t2\n\nnp.save('bench_run_times/20_break_times.npy', run_times)\nnp.save('bench_run_times/n.npy', n)\n"""
examples/tf/sine_benchmark_six_segments.py,6,"b""import numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\nfrom time import time\n\n# set random seed\nnp.random.seed(256)\nbreaks = np.array((0.0, 0.94, 2.96, 4.93, 7.02, 9.04, 10.0))\n\nn_data = int(1e6)\n\n# generate sin wave data\nx = np.linspace(0, 10, num=n_data)\ny = np.sin(x * np.pi / 2)\n# add noise to the data\ny = np.random.normal(0, 0.05, size=n_data) + y\n\nt0 = time()\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFit(x, y)\n\n# # fit the data for four line segments\n# res = my_pwlf.fit(16)\n# breaks = my_pwlf.fit(6)\n\nssr = my_pwlf.fit_with_breaks(breaks)\nt1 = time()\nprint('run time:', t1 - t0)\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
examples/tf/test_fit.py,4,"b""# fit and predict with known line segment x locations\n\n# import our libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pwlf\n\n# your data\ny = np.array([0.00000000e+00, 9.69801700e-03, 2.94350340e-02,\n              4.39052750e-02, 5.45343950e-02, 6.74104940e-02,\n              8.34831790e-02, 1.02580042e-01, 1.22767939e-01,\n              1.42172312e-01, 0.00000000e+00, 8.58600000e-06,\n              8.31543400e-03, 2.34184100e-02, 3.39709150e-02,\n              4.03581990e-02, 4.53545600e-02, 5.02345260e-02,\n              5.55253360e-02, 6.14750770e-02, 6.82125120e-02,\n              7.55892510e-02, 8.38356810e-02, 9.26413070e-02,\n              1.02039790e-01, 1.11688258e-01, 1.21390666e-01,\n              1.31196948e-01, 0.00000000e+00, 1.56706510e-02,\n              3.54628780e-02, 4.63739040e-02, 5.61442590e-02,\n              6.78542550e-02, 8.16388310e-02, 9.77756110e-02,\n              1.16531753e-01, 1.37038283e-01, 0.00000000e+00,\n              1.16951050e-02, 3.12089850e-02, 4.41776550e-02,\n              5.42877590e-02, 6.63321350e-02, 8.07655920e-02,\n              9.70363280e-02, 1.15706975e-01, 1.36687642e-01,\n              0.00000000e+00, 1.50144640e-02, 3.44519970e-02,\n              4.55907760e-02, 5.59556700e-02, 6.88450940e-02,\n              8.41374060e-02, 1.01254006e-01, 1.20605073e-01,\n              1.41881288e-01, 1.62618058e-01])\nx = np.array([0.00000000e+00, 8.82678000e-03, 3.25615100e-02,\n              5.66106800e-02, 7.95549800e-02, 1.00936330e-01,\n              1.20351520e-01, 1.37442010e-01, 1.51858250e-01,\n              1.64433570e-01, 0.00000000e+00, -2.12600000e-05,\n              7.03872000e-03, 1.85494500e-02, 3.00926700e-02,\n              4.17617000e-02, 5.37279600e-02, 6.54941000e-02,\n              7.68092100e-02, 8.76596300e-02, 9.80525800e-02,\n              1.07961810e-01, 1.17305210e-01, 1.26063930e-01,\n              1.34180360e-01, 1.41725010e-01, 1.48629710e-01,\n              1.55374770e-01, 0.00000000e+00, 1.65610200e-02,\n              3.91016100e-02, 6.18679400e-02, 8.30997400e-02,\n              1.02132890e-01, 1.19011260e-01, 1.34620080e-01,\n              1.49429370e-01, 1.63539960e-01, -0.00000000e+00,\n              1.01980300e-02, 3.28642800e-02, 5.59461900e-02,\n              7.81388400e-02, 9.84458400e-02, 1.16270210e-01,\n              1.31279040e-01, 1.45437090e-01, 1.59627540e-01,\n              0.00000000e+00, 1.63404300e-02, 4.00086000e-02,\n              6.34390200e-02, 8.51085900e-02, 1.04787860e-01,\n              1.22120350e-01, 1.36931660e-01, 1.50958760e-01,\n              1.65299640e-01, 1.79942720e-01])\n\n# your desired line segment end locations\nx0 = np.array([min(x), 0.039, 0.10, max(x)])\n\n# initialize piecewise linear fit with your x and y data\nmy_pwlf = pwlf.PiecewiseLinFitTF(x, y)\n\n# fit the data with the specified break points (ie the x locations of where\n# the line segments should end\nssr = my_pwlf.fit_with_breaks(x0)\n\n# predict for the determined points\nxHat = np.linspace(min(x), max(x), num=10000)\nyHat = my_pwlf.predict(xHat)\n\n# plot the results\nplt.figure()\nplt.plot(x, y, 'o')\nplt.plot(xHat, yHat, '-')\nplt.show()\n"""
sphinxdocs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nimport pwlf\nsys.path.insert(0, os.path.abspath(\'../../pwlf\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'pwlf\'\ncopyright = \'2020, Charles Jekel\'\nauthor = \'Charles Jekel\'\n\n# The short X.Y version\nversion = \'\'\n# The full version, including alpha/beta/rc tags\nrelease = pwlf.__version__\n\n# -- General configuration ---------------------------------------------------\n\n# autoclass_content = \'both\'\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.githubpages\',\n    \'numpydoc\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = None\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\n#html_theme = \'sphinx\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nhtml_theme_options = {\'analytics_id\': \'UA-67542734-2\'}\nhtml_favicon = \'favicon.ico\'\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pwlfdoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'pwlf.tex\', \'pwlf Documentation\',\n     \'Charles Jekel\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pwlf\', \'pwlf Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'pwlf\', \'pwlf Documentation\',\n     author, \'pwlf\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = \'\'\n\n# A unique identification for the text.\n#\n# epub_uid = \'\'\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\'search.html\']\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'https://docs.python.org/\': None}\n'"
