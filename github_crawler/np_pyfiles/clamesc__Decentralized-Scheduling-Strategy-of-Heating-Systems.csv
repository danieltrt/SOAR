file_path,api_count,code
Code/cg_lr_combination.py,3,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 21:39:21 2014\r\n\r\n@author: T_ohne_admin\r\n\r\n        +-------------+\r\n        |Initialize   | \r\n        +-----+-------+ \r\n              V\r\n        +-----+-------+<________        __________+-----------------+\r\n        |Solve Master |        |        |         |Solve Lagrangian |\r\n        +-----+-------+        |        |         |Problem          |\r\n              |                |        |         +------------+----+\r\n              V            +---+----+   |                      |\r\n    ____+-----+-------+    |Add New |   |               +------+----+\r\n   |YES |Check Bound  |    |Columns |   |               |Update LR  |\r\n   |    +-----+-------+    +---+----+   |               |Multipliers|\r\n   |          |NO              |        |               +------+----+\r\n   |          V                |        |                      |NO\r\n   |    +-----+-------+        |________|___________+----------+----+\r\n   |    |Solve Pricing|                 |        YES|Stop Inner Loop|\r\n   |    +-----+-------+                 |           +----------+----+\r\n   |          |                         |                      |\r\n   |          V                         V                      |NO\r\n   |    +-----+----------+_______+------+----+__________+------+----+\r\n   |    |Check Optimality|NO     |Compute LR |          |Check Bound|\r\n   |    +-----+----------+       |Bound      |          +------+----+\r\n   |          |YES               +-----------+                 |YES\r\n   |          V                                                |\r\n   |_____>+---+----+___________________________________________|\r\n          |LB found|\r\n          +--------+\r\n\r\n""""""\r\n\r\nfrom __future__ import division\r\n\r\nimport object_hp\r\nimport object_chp\r\nimport object_master\r\nfrom constants import *\r\nimport numpy as np\r\nimport data\r\nimport h5py\r\nimport time\r\nimport os\r\nfrom IPython.core.debugger import Tracer\r\n\r\ndef lr_cg_algorithm(day=0, t_init_hp=[], t_init_chp=[]):\r\n    #============ Create Optimization model ============================#\r\n    \r\n    GlobVar.overall_count = 0\r\n    GlobVar.inner_count = 0\r\n    GlobVar.outer_count = 0\r\n    GlobVar.final_count = 0\r\n    GlobVar.first_iteration = True\r\n    \r\n    # Get data from input files\r\n    Constants.t = day * 24 * 4\r\n    dat = data.ModelData()\r\n\r\n    # HP objects handle the HP pricing subproblems\r\n    hp = []\r\n    for i in range(len(dat.hps)):\r\n\thp.append(object_hp.HP(dat.hps[i], dat.raw_temperature, i))\r\n\tif t_init_hp:\r\n\t    hp[-1].t_init = t_init_hp[i]\r\n\r\n    # CHP objects handle the CHP pricing subproblems\r\n    chp = []\r\n    for i in range(len(dat.chps)):\r\n\tchp.append(object_chp.CHP(dat.chps[i], dat.raw_temperature, i))\r\n\tif t_init_chp:\r\n\t    chp[-1].t_init = t_init_chp[i]\r\n\r\n    # Master object handles master problem\r\n    mp = object_master.Master(len(chp), len(hp), dat.P_res)\r\n\r\n    # Get initial feasible proposals\r\n    for j in range(mp.number_hp):\r\n\t(mp.initial_costs_hp[j],\r\n\tmp.initial_proposals_hp[j]) = hp[j].compute_proposal(mp.initial_marginals)\r\n    for k in range(mp.number_chp):\r\n\t(mp.initial_costs_chp[k],\r\n\tmp.initial_proposals_chp[k]) = chp[k].compute_proposal(mp.initial_marginals)\r\n\r\n    start_time = time.clock()\r\n\r\n    #============ Initial Column Generation ==================================================#\r\n\r\n    while GlobVar.overall_count < Constants.cg_iterations:\r\n      \r\n\tmp.solve_master()\r\n\t\r\n\tmp.master_time[GlobVar.outer_count] = time.clock() - start_time\r\n\t\r\n\tsum_obj_subs = 0\r\n\tfor j in range(mp.number_hp):\r\n\t    (mp.pricing_costs_hp[GlobVar.overall_count, j],\r\n\t    mp.pricing_proposals_hp[GlobVar.overall_count, j]) = hp[j].compute_proposal(mp.marginals_mu_master[GlobVar.outer_count])\r\n\t    sum_obj_subs += hp[j].pricing_res_obj[GlobVar.overall_count]\r\n\tfor k in range(mp.number_chp):\r\n\t    (mp.pricing_costs_chp[GlobVar.overall_count, k],\r\n\t    mp.pricing_proposals_chp[GlobVar.overall_count, k]) = chp[k].compute_proposal(mp.marginals_mu_master[GlobVar.outer_count])\r\n\t    sum_obj_subs += chp[k].pricing_res_obj[GlobVar.overall_count]\r\n\r\n\tmp.update_lr_bound(sum_obj_subs)\r\n\t\r\n\t# Get computation time\r\n\tmp.sub_time[GlobVar.overall_count] = time.clock() - start_time\r\n\t\r\n\tmp.update_plot_cg()\r\n\t\r\n\tGlobVar.outer_count += 1\r\n\tGlobVar.overall_count += 1\r\n\r\n    #============ Outer Loop =================================================================#\r\n    break_outer_loop = False\r\n    break_inner_loop = False\r\n    while GlobVar.outer_count < Constants.outer_max:\r\n\t\r\n\t#============ Inner Loop ======================================================#\r\n\tGlobVar.inner_count = 0\r\n\twhile GlobVar.inner_count < Constants.inner_loops[GlobVar.outer_count-Constants.cg_iterations]:\r\n\t    \r\n\t    # Compute Sugradient and Stepsize\r\n\t    subgradient = mp.compute_subgradient()\r\n\t    alpha = Constants.alpha\r\n\t    stepsize = alpha * (mp.lin_obj_values[GlobVar.outer_count-1] - mp.lr_bound) / np.sum(np.square(subgradient))\r\n\t    \r\n\t    # Update Langrange Multipliers (Shadowprices)\r\n\t    for t in range(Constants.timesteps):\r\n\t\tif GlobVar.first_iteration:\r\n\t\t    marginal_mu_new = mp.marginals_mu_master[Constants.cg_iterations-1, t] + stepsize * subgradient[t]\r\n\t\telse:\r\n\t\t    marginal_mu_new = mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations-1, t] + stepsize * subgradient[t]\r\n\t\tif marginal_mu_new <= Constants.r_el * Constants.dt:\r\n\t\t    mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations, t] = Constants.r_el * Constants.dt\r\n\t\telif marginal_mu_new >= Constants.k_el * Constants.dt:\r\n\t\t    mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations, t] = Constants.k_el * Constants.dt\r\n\t\telse:\r\n\t\t    mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations, t] = marginal_mu_new\r\n\t    GlobVar.first_iteration = False\r\n\t    # Solve Pricing Problems\r\n\t    sum_obj_subs = 0\r\n\t    for j in range(mp.number_hp):\r\n\t\t(mp.pricing_costs_hp[GlobVar.overall_count, j],\r\n\t\tmp.pricing_proposals_hp[GlobVar.overall_count, j]) = hp[j].compute_proposal(mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations])\r\n\t\tsum_obj_subs += hp[j].pricing_res_obj[GlobVar.overall_count]\r\n\t    for k in range(mp.number_chp):\r\n\t\t(mp.pricing_costs_chp[GlobVar.overall_count, k],\r\n\t\tmp.pricing_proposals_chp[GlobVar.overall_count, k]) = chp[k].compute_proposal(mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations])\r\n\t\tsum_obj_subs += chp[k].pricing_res_obj[GlobVar.overall_count]\r\n\t    \r\n\t    # Check Lagrangian Bound\r\n\t    mp.update_lr_bound(sum_obj_subs)\r\n\t    \r\n\t    # Get computation time\r\n\t    mp.sub_time[GlobVar.overall_count] = time.clock() - start_time\r\n\t    \r\n\t    GlobVar.overall_count += 1\r\n\t    \r\n\t    if (mp.lin_obj_values[GlobVar.outer_count-1] - mp.lr_bound)/mp.lin_obj_values[GlobVar.outer_count-1] < Constants.eps or (time.clock() - start_time) > Constants.pricing_time_limit:\r\n\t\tbreak_inner_loop = True\r\n\t\tbreak\r\n\t    \r\n\t    GlobVar.inner_count += 1\r\n\r\n\t#============ End Inner Loop ==================================================#\r\n\t\r\n\tif break_inner_loop:\r\n\t    break\r\n\t\r\n\tif GlobVar.overall_count == Constants.random_proposals_in_master:\r\n\t    GlobVar.random_proposals_in_master = False\r\n\t\r\n\t# Solve Master\r\n\tmp.solve_master()\r\n\t\r\n\tmp.master_time[GlobVar.outer_count] = time.clock() - start_time\r\n\t\r\n\tmp.update_plot_lr()\r\n\t\r\n\tif (mp.lin_obj_values[GlobVar.outer_count] - mp.lr_bound)/mp.lin_obj_values[GlobVar.outer_count] < Constants.eps or (time.clock() - start_time) > Constants.pricing_time_limit:\r\n\t    break_outer_loop = True\r\n\t    break\r\n\r\n\tGlobVar.outer_count += 1\r\n\t\r\n    #============ End Outer Loop =============================================================#\r\n\r\n    if break_outer_loop:\r\n\tmp.final_marginals = mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations-1]\r\n    elif break_inner_loop:\r\n\tmp.final_marginals = mp.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations-1]\r\n\tmp.update_plot_inner_break()\r\n    else:\r\n\tmp.final_marginals = mp.marginals_mu_subgradient[-1]\r\n\t\r\n    while GlobVar.final_count < Constants.final_max:\r\n\t\r\n\tfor j in range(mp.number_hp):\r\n\t    (mp.final_costs_hp[GlobVar.final_count, j],\r\n\t    mp.final_proposals_hp[GlobVar.final_count, j]) = hp[j].compute_proposal(mp.final_marginals, True)\r\n\tfor k in range(mp.number_chp):\r\n\t    (mp.final_costs_chp[GlobVar.final_count, k],\r\n\t    mp.final_proposals_chp[GlobVar.final_count, k]) = chp[k].compute_proposal(mp.final_marginals, True)\r\n\r\n\t#mp.solve_master(True)\r\n\t\r\n\tmp.update_plot_final(GlobVar.overall_count)\r\n\t\r\n\tmp.final_time[GlobVar.final_count] = time.clock() - start_time\r\n\t\r\n\tGlobVar.final_count += 1\r\n\r\n    GlobVar.final_count -= 1\r\n    mp.solve_master(True)\r\n\r\n    f = h5py.File(Constants.path + ""/lr_"" + str(day) + "".hdf5"", ""w"")\r\n\r\n    for i in range(len(hp)):\r\n\tg = f.create_group(""HP_""+str(i))\r\n\tg.create_dataset(""x_p"", data = hp[i].pricing_res_x)\r\n\tg.create_dataset(""y_p"", data = hp[i].pricing_res_y)\r\n\tg.create_dataset(""T_p"", data = hp[i].pricing_res_T)\r\n\tg.create_dataset(""P_p"", data = hp[i].pricing_res_P)\r\n\tg.create_dataset(""z_p"", data = hp[i].pricing_res_obj)\r\n\tg.create_dataset(""x_f"", data = hp[i].final_res_x)\r\n\tg.create_dataset(""y_f"", data = hp[i].final_res_y)\r\n\tg.create_dataset(""T_f"", data = hp[i].final_res_T)\r\n\tg.create_dataset(""P_f"", data = hp[i].final_res_P)\r\n\tg.create_dataset(""z_f"", data = hp[i].final_res_obj)\r\n    for j in range(len(chp)):\r\n\tg = f.create_group(""CHP_""+str(j))\r\n\tg.create_dataset(""x_p"", data = chp[j].pricing_res_x)\r\n\tg.create_dataset(""y_p"", data = chp[j].pricing_res_y)\r\n\tg.create_dataset(""T_p"", data = chp[j].pricing_res_T)\r\n\tg.create_dataset(""P_p"", data = chp[j].pricing_res_P)\r\n\tg.create_dataset(""Q_p"", data = chp[j].pricing_res_Q)\r\n\tg.create_dataset(""z_p"", data = chp[j].pricing_res_obj)\r\n\tg.create_dataset(""c_p"", data = chp[j].pricing_res_costs)\r\n\tg.create_dataset(""x_f"", data = chp[j].final_res_x)\r\n\tg.create_dataset(""y_f"", data = chp[j].final_res_y)\r\n\tg.create_dataset(""T_f"", data = chp[j].final_res_T)\r\n\tg.create_dataset(""P_f"", data = chp[j].final_res_P)\r\n\tg.create_dataset(""Q_f"", data = chp[j].final_res_Q)\r\n\tg.create_dataset(""z_f"", data = chp[j].final_res_obj)\r\n\tg.create_dataset(""c_f"", data = chp[j].final_res_costs)\r\n\t\r\n    f.create_dataset(""pricing_costs_chp"", data = mp.pricing_costs_chp)\r\n    f.create_dataset(""pricing_costs_hp"", data = mp.pricing_costs_hp)\r\n    f.create_dataset(""pricing_proposals_chp"", data = mp.pricing_proposals_chp)\r\n    f.create_dataset(""pricing_proposals_hp"", data = mp.pricing_proposals_hp)\r\n\r\n    f.create_dataset(""final_costs_chp"", data = mp.final_costs_chp)\r\n    f.create_dataset(""final_costs_hp"", data = mp.final_costs_hp)\r\n    f.create_dataset(""final_proposals_chp"", data = mp.final_proposals_chp)\r\n    f.create_dataset(""final_proposals_hp"", data = mp.final_proposals_hp)\r\n\r\n    f.create_dataset(""initial_costs_chp"", data = mp.initial_costs_chp)\r\n    f.create_dataset(""initial_costs_hp"", data = mp.initial_costs_hp)\r\n    f.create_dataset(""initial_proposals_chp"", data = mp.initial_proposals_chp)\r\n    f.create_dataset(""initial_proposals_hp"", data = mp.initial_proposals_hp)\r\n\r\n    f.create_dataset(""marginals_sigma_chp"", data = mp.marginals_sigma_chp)\r\n    f.create_dataset(""marginals_sigma_hp"", data = mp.marginals_sigma_hp)\r\n    f.create_dataset(""marginals_mu_master"", data = mp.marginals_mu_master)\r\n    f.create_dataset(""marginals_mu_subgradient"", data = mp.marginals_mu_subgradient)\r\n    f.create_dataset(""initial_marginals"", data = mp.initial_marginals)\r\n    f.create_dataset(""final_marginals"", data = mp.final_marginals)\r\n\r\n    f.create_dataset(""lin_obj_values"", data = mp.lin_obj_values)\r\n    f.create_dataset(""int_obj_values"", data = mp.int_obj_values)\r\n\r\n    f.create_dataset(""res_lr_bounds_master"", data = mp.res_lr_bounds_master)\r\n    f.create_dataset(""res_lr_bounds_sugradient"", data = mp.res_lr_bounds_subgradient)\r\n\r\n    f.create_dataset(""sub_time"", data = mp.sub_time)\r\n    f.create_dataset(""master_time"", data = mp.master_time)\r\n    f.create_dataset(""final_time"", data = mp.final_time)\r\n    \r\n    f.create_dataset(""final_hp"", data = mp.final_hp)\r\n    f.create_dataset(""final_chp"", data = mp.final_chp)\r\n\r\n    f.attrs[""max_time_subs""] = Constants.max_time_subs\r\n    f.attrs[""max_time_master""] = Constants.max_time_master\r\n    f.attrs[""timesteps""] = Constants.timesteps\r\n    f.attrs[""t""] = Constants.t\r\n    f.attrs[""cg_iterations""] = Constants.cg_iterations\r\n    f.attrs[""inner_loops""] = Constants.inner_loops\r\n    f.attrs[""final_max""] = Constants.final_max\r\n    f.attrs[""outer_loops""] = Constants.outer_loops\r\n    f.attrs[""outer_max""] = Constants.outer_max\r\n    f.attrs[""overall_max""] = Constants.overall_max\r\n    f.attrs[""subgradient_max""] = Constants.subgradient_max\r\n    f.attrs[""eps""] = Constants.eps\r\n    f.attrs[""alpha""] = Constants.alpha\r\n    f.attrs[""t_bivalent""] = Constants.t_bivalent\r\n    f.attrs[""pricing_MIPGap""] = Constants.pricing_MIPGap\r\n    f.attrs[""final_MIPGap""] = Constants.final_MIPGap\r\n    f.attrs[""initial_in_master""] = Constants.initial_in_master\r\n    f.attrs[""pricing_time_limit""] = Constants.pricing_time_limit\r\n\r\n    f.close()\r\n    \r\n    return [hp[j].final_res_T[mp.final_hp[j],95] for j in range(mp.number_hp)], [chp[j].final_res_T[mp.final_chp[j],95] for j in range(mp.number_chp)]\r\n  \r\nd=55\r\nf = h5py.File(""/home/qwertzuiopu/Data/lr_""+str(d-1)+"".hdf5"")\r\narray = f[""final_hp""]\r\nfhp = np.empty(array.shape)\r\narray.read_direct(fhp)\r\narray = f[""final_chp""]\r\nfchp = np.empty(array.shape)\r\narray.read_direct(fchp)\r\nt_hp = []\r\nt_chp = []\r\nfor i in range(51):\r\n    t_hp.append(f[""HP_""+str(i)+""/T_f""][fhp[i], 95])\r\n    t_chp.append(f[""CHP_""+str(i)+""/T_f""][fchp[i], 95])\r\nwhile d < 56:\r\n    t_hp, t_chp = lr_cg_algorithm(d,t_hp,t_chp)\r\n    d += 1'"
Code/column_generation.py,4,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 21:39:21 2014\r\n\r\n@author: T_ohne_admin\r\n\r\n        +-------------+\r\n        |Initialize   | \r\n        +-----+-------+ \r\n              V\r\n        +-----+-------+<________        __________+-----------------+\r\n        |Solve Master |        |        |         |Solve Lagrangian |\r\n        +-----+-------+        |        |         |Problem          |\r\n              |                |        |         +------------+----+\r\n              V            +---+----+   |                      |\r\n    ____+-----+-------+    |Add New |   |               +------+----+\r\n   |YES |Check Bound  |    |Columns |   |               |Update LR  |\r\n   |    +-----+-------+    +---+----+   |               |Multipliers|\r\n   |          |NO              |        |               +------+----+\r\n   |          V                |        |                      |NO\r\n   |    +-----+-------+        |________|___________+----------+----+\r\n   |    |Solve Pricing|                 |        YES|Stop Inner Loop|\r\n   |    +-----+-------+                 |           +----------+----+\r\n   |          |                         |                      |\r\n   |          V                         V                      |NO\r\n   |    +-----+----------+_______+------+----+__________+------+----+\r\n   |    |Check Optimality|NO     |Compute LR |          |Check Bound|\r\n   |    +-----+----------+       |Bound      |          +------+----+\r\n   |          |YES               +-----------+                 |YES\r\n   |          V                                                |\r\n   |_____>+---+----+___________________________________________|\r\n          |LB found|\r\n          +--------+\r\n\r\n""""""\r\n\r\nfrom __future__ import division\r\n\r\nimport object_hp\r\nimport object_chp\r\nimport object_master\r\nfrom constants import *\r\nimport numpy as np\r\nimport data\r\nimport h5py\r\nimport time\r\nimport os\r\nimport pdb\r\nfrom IPython.core.debugger import Tracer\r\n\r\ndef lr_cg_algorithm(day=0, t_init_hp=[], t_init_chp=[]):\r\n    #============ Create Optimization model ============================#\r\n    \r\n    GlobVar.overall_count = 0\r\n    GlobVar.inner_count = 0\r\n    GlobVar.outer_count = 0\r\n    GlobVar.final_count = 0\r\n    GlobVar.first_iteration = True\r\n    Constants.plot = False\r\n    Constants.cg_iterations = 50\r\n    Constants.inner_loops = []\r\n    Constants.final_max = 0\r\n    Constants.outer_loops = 0    \r\n    Constants.outer_max = Constants.cg_iterations\r\n    Constants.overall_max = Constants.cg_iterations\r\n    Constants.subgradient_max = 0\r\n    \r\n    # Get data from input files\r\n    Constants.t = day * 24 * 4\r\n    dat = data.ModelData()\r\n\r\n    # HP objects handle the HP pricing subproblems\r\n    hp = []\r\n    for i in range(len(dat.hps)):\r\n\thp.append(object_hp.HP(dat.hps[i], dat.raw_temperature, i))\r\n\tif t_init_hp:\r\n\t    hp[-1].t_init = t_init_hp[i]\r\n\r\n    # CHP objects handle the CHP pricing subproblems\r\n    chp = []\r\n    for i in range(len(dat.chps)):\r\n\tchp.append(object_chp.CHP(dat.chps[i], dat.raw_temperature, i))\r\n\tif t_init_chp:\r\n\t    chp[-1].t_init = t_init_chp[i]\r\n\r\n    # Master object handles master problem\r\n    mp = object_master.Master(len(chp), len(hp), dat.P_res)\r\n\r\n    # Get initial feasible proposals\r\n    for j in range(mp.number_hp):\r\n\t(mp.initial_costs_hp[j],\r\n\tmp.initial_proposals_hp[j]) = hp[j].compute_proposal(np.zeros([Constants.timesteps]))\r\n    for k in range(mp.number_chp):\r\n\t(mp.initial_costs_chp[k],\r\n\tmp.initial_proposals_chp[k]) = chp[k].compute_proposal(np.zeros([Constants.timesteps]))\r\n\r\n    start_time = time.clock()\r\n\r\n    #============ Initial Column Generation ==================================================#\r\n\r\n    while GlobVar.overall_count < Constants.cg_iterations and (time.clock() - start_time) < 600:\r\n      \r\n\tmp.solve_master()\r\n\t\r\n\tmp.master_time[GlobVar.outer_count] = time.clock() - start_time\r\n\t\r\n\tsum_obj_subs = 0\r\n\tfor j in range(mp.number_hp):\r\n\t    (mp.pricing_costs_hp[GlobVar.overall_count, j],\r\n\t    mp.pricing_proposals_hp[GlobVar.overall_count, j]) = hp[j].compute_proposal(mp.marginals_mu_master[GlobVar.outer_count])\r\n\t    sum_obj_subs += hp[j].pricing_res_obj[GlobVar.overall_count]\r\n\tfor k in range(mp.number_chp):\r\n\t    (mp.pricing_costs_chp[GlobVar.overall_count, k],\r\n\t    mp.pricing_proposals_chp[GlobVar.overall_count, k]) = chp[k].compute_proposal(mp.marginals_mu_master[GlobVar.outer_count])\r\n\t    sum_obj_subs += chp[k].pricing_res_obj[GlobVar.overall_count]\r\n\r\n\tmp.update_lr_bound(sum_obj_subs)\r\n\t\r\n\t# Get computation time\r\n\tmp.sub_time[GlobVar.overall_count] = time.clock() - start_time\r\n\t\r\n\tmp.update_plot_cg()\r\n\t\r\n\tGlobVar.outer_count += 1\r\n\tGlobVar.overall_count += 1\r\n    \r\n    f = h5py.File(Constants.path + ""/cg_"" + str(day) + "".hdf5"", ""w"")\r\n\r\n    for i in range(len(hp)):\r\n\tg = f.create_group(""HP_""+str(i))\r\n\tg.create_dataset(""x_p"", data = hp[i].pricing_res_x)\r\n\tg.create_dataset(""y_p"", data = hp[i].pricing_res_y)\r\n\tg.create_dataset(""T_p"", data = hp[i].pricing_res_T)\r\n\tg.create_dataset(""P_p"", data = hp[i].pricing_res_P)\r\n\tg.create_dataset(""z_p"", data = hp[i].pricing_res_obj)\r\n    for j in range(len(chp)):\r\n\tg = f.create_group(""CHP_""+str(j))\r\n\tg.create_dataset(""x_p"", data = chp[j].pricing_res_x)\r\n\tg.create_dataset(""y_p"", data = chp[j].pricing_res_y)\r\n\tg.create_dataset(""T_p"", data = chp[j].pricing_res_T)\r\n\tg.create_dataset(""P_p"", data = chp[j].pricing_res_P)\r\n\tg.create_dataset(""Q_p"", data = chp[j].pricing_res_Q)\r\n\tg.create_dataset(""z_p"", data = chp[j].pricing_res_obj)\r\n\tg.create_dataset(""c_p"", data = chp[j].pricing_res_costs)\r\n\t\r\n    f.create_dataset(""pricing_costs_chp"", data = mp.pricing_costs_chp)\r\n    f.create_dataset(""pricing_costs_hp"", data = mp.pricing_costs_hp)\r\n    f.create_dataset(""pricing_proposals_chp"", data = mp.pricing_proposals_chp)\r\n    f.create_dataset(""pricing_proposals_hp"", data = mp.pricing_proposals_hp)\r\n\r\n    f.create_dataset(""marginals_sigma_chp"", data = mp.marginals_sigma_chp)\r\n    f.create_dataset(""marginals_sigma_hp"", data = mp.marginals_sigma_hp)\r\n    f.create_dataset(""marginals_mu_master"", data = mp.marginals_mu_master)\r\n\r\n    f.create_dataset(""lin_obj_values"", data = mp.lin_obj_values)\r\n\r\n    f.create_dataset(""res_lr_bounds_master"", data = mp.res_lr_bounds_master)\r\n\r\n    f.create_dataset(""sub_time"", data = mp.sub_time)\r\n    f.create_dataset(""master_time"", data = mp.master_time)\r\n\r\n    f.attrs[""max_time_subs""] = Constants.max_time_subs\r\n    f.attrs[""max_time_master""] = Constants.max_time_master\r\n    f.attrs[""timesteps""] = Constants.timesteps\r\n    f.attrs[""t""] = Constants.t\r\n    f.attrs[""cg_iterations""] = Constants.cg_iterations\r\n    f.attrs[""inner_loops""] = Constants.inner_loops\r\n    f.attrs[""final_max""] = Constants.final_max\r\n    f.attrs[""outer_loops""] = Constants.outer_loops\r\n    f.attrs[""outer_max""] = Constants.outer_max\r\n    f.attrs[""overall_max""] = Constants.overall_max\r\n    f.attrs[""subgradient_max""] = Constants.subgradient_max\r\n    f.attrs[""eps""] = Constants.eps\r\n    f.attrs[""alpha""] = Constants.alpha\r\n    f.attrs[""t_bivalent""] = Constants.t_bivalent\r\n    f.attrs[""pricing_MIPGap""] = Constants.pricing_MIPGap\r\n    f.attrs[""final_MIPGap""] = Constants.final_MIPGap\r\n    f.attrs[""initial_in_master""] = Constants.initial_in_master\r\n    f.attrs[""pricing_time_limit""] = Constants.pricing_time_limit\r\n\r\n    f.close()\r\n  \r\n#lr_cg_algorithm(0)\r\nd=85\r\nwhile d < 365:\r\n    f = h5py.File(""/home/qwertzuiopu/Data/lr_""+str(d-1)+"".hdf5"")\r\n    array = f[""final_hp""]\r\n    fhp = np.empty(array.shape)\r\n    array.read_direct(fhp)\r\n    array = f[""final_chp""]\r\n    fchp = np.empty(array.shape)\r\n    array.read_direct(fchp)\r\n    t_hp = []\r\n    t_chp = []\r\n    for i in range(51):\r\n\tt_hp.append(f[""HP_""+str(i)+""/T_f""][fhp[i], 95])\r\n\tt_chp.append(f[""CHP_""+str(i)+""/T_f""][fchp[i], 95])\r\n    lr_cg_algorithm(d, t_hp, t_chp)\r\n    d += 1'"
Code/constants.py,0,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Nov 26 21:20:59 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nclass Constants(object):\r\n    """"""\r\n    This class is the standard class that is inherited by all subproblems as \r\n    well as the master problem\r\n    Constants:\r\n        c_w = 4180 J/kgK\r\n        \r\n        dt = 900 s (time step length)\r\n        \r\n        t_amb = 20 \xc2\xb0C (storage\'s surroundings temperature)\r\n        \r\n        k_g --> gas price in \xe2\x82\xac/J\r\n        \r\n        k_el --> electricity price in \xe2\x82\xac/J\r\n        \r\n        r_el --> electricity revenue in \xe2\x82\xac/J\r\n    """"""\r\n    \r\n    c_w = 4180\r\n    dt = 900\r\n    t_amb = 20\r\n    k_g  = 8.00  / (100 * 3600 * 1000) # \xe2\x82\xac/J\r\n    k_el = 29.21 / (100 * 3600 * 1000) # \xe2\x82\xac/J\r\n    r_el = 5.00  / (100 * 3600 * 1000) # \xe2\x82\xac/J\r\n    max_time_subs = 5\r\n    max_time_master = 10\r\n    \r\n    timesteps = 2 * 24 * 4\r\n    t=0\r\n    \r\n    cg_iterations = 1\r\n    inner_loops = [1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\r\n    final_max = 5\r\n    \r\n    outer_loops = len(inner_loops)\r\n    outer_max = cg_iterations + len(inner_loops)\r\n    overall_max = cg_iterations + sum(inner_loops)\r\n    subgradient_max = sum(inner_loops)\r\n    \r\n    eps = 0.0\r\n    alpha = 1.0\r\n    \r\n    \r\n    t_bivalent = -2.0\r\n    \r\n    pricing_MIPGap = 0.01\r\n    \r\n    final_MIPGap = 0.01\r\n    \r\n    initial_in_master = 3\r\n    \r\n    pricing_time_limit = 600\r\n    \r\n    plot = False\r\n    \r\n    path = ""/home/qwertzuiopu/Data""\r\n    \r\n    random_proposals_in_master = 3\r\n        \r\nclass Storage(Constants):\r\n    """"""\r\n    This class adds the storage\'s constants to the Constants class\r\n        sto_m: Water mass inside the storage in kg\r\n        \r\n        sto_UA: U*A in W/m2K\r\n        \r\n        T_init: Starting temperature of the storage in \xc2\xb0C\r\n        \r\n        T_max: Maximal temperature in the storage in \xc2\xb0C\r\n    """"""\r\n    \r\n    t_init = 0\r\n    t_max  = 0\r\n    sto_m  = 0\r\n    sto_UA = 0\r\n    \r\nclass GlobVar():\r\n    \r\n    overall_count = 0\r\n    inner_count = 0\r\n    outer_count = 0\r\n    final_count = 0\r\n    first_iteration = True\r\n    random_proposals_in_master = True'"
Code/data.py,6,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Nov 26 21:20:59 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\nimport constants\r\nimport os\r\nimport numpy as np\r\nimport basic_functions.read_txt as rtxt\r\nimport microgrid_functions.renewables as renewables\r\n\r\nclass ModelData(constants.Constants):\r\n  \r\n    class hp(object):\r\n\tdef __init__(self, hp_nom, \r\n\t\t\t   hp_sec, \r\n\t\t\t   hp_sec_eta, \r\n\t\t\t   hp_sto_m, \r\n\t\t\t   hp_sto_U, \r\n\t\t\t   hp_t_init, \r\n\t\t\t   hp_t_max, \r\n\t\t\t   hp_p_dem, \r\n\t\t\t   hp_q_dem):\r\n\t    \r\n\t    self.Q_nom = hp_nom\r\n\t    self.Q_sec = hp_sec\r\n\t    self.eta_sec = hp_sec_eta\r\n\t    self.m_sto = hp_sto_m\r\n\t    self.U_sto = hp_sto_U\r\n\t    self.T_init = hp_t_init\r\n\t    self.T_max = hp_t_max\r\n\t    self.P_dem = hp_p_dem\r\n\t    self.Q_dem = hp_q_dem\r\n\t    \r\n    class chp(object):\r\n\tdef __init__(self, chp_nom, \r\n\t\t\t   chp_eta, \r\n\t\t\t   chp_sigma, \r\n\t\t\t   chp_sec, \r\n\t\t\t   chp_sec_eta, \r\n\t\t\t   chp_sto_m, \r\n\t\t\t   chp_sto_U, \r\n\t\t\t   chp_t_init, \r\n\t\t\t   chp_t_max, \r\n\t\t\t   chp_p_dem, \r\n\t\t\t   chp_q_dem):\r\n\t    \r\n\t    self.Q_nom = chp_nom\r\n\t    self.eta = chp_eta\r\n\t    self.sigma = chp_sigma\r\n\t    self.Q_sec = chp_sec\r\n\t    self.eta_sec = chp_sec_eta\r\n\t    self.m_sto = chp_sto_m\r\n\t    self.U_sto = chp_sto_U\r\n\t    self.T_init = chp_t_init\r\n\t    self.T_max = chp_t_max\r\n\t    self.P_dem = chp_p_dem\r\n\t    self.Q_dem = chp_q_dem\r\n    \r\n    def __init__(self):\r\n\thp_q_dem  = \t\tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/heat_demand_hp.csv"",  delimiter = "";"")[self.t:self.t+self.timesteps,:])\r\n\thp_p_dem  = \t\tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/el_demand_hp.csv"",  delimiter = "";"")[self.t:self.t+self.timesteps,:])\r\n\tchp_q_dem = \t\tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/heat_demand_chp.csv"", delimiter = "";"")[self.t:self.t+self.timesteps,:])\r\n\tchp_p_dem  = \t\tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/el_demand_chp.csv"",  delimiter = "";"")[self.t:self.t+self.timesteps,:])\r\n\thp_input_data = \tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/input_data_hp.csv"", delimiter = "";""))\r\n\tchp_input_data = \tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/input_data_chp.csv"", delimiter = "";""))\r\n\t#self.raw_slp = \t\trtxt.read_single_indexed_file(os.getcwd() + ""/input_data/standard_load_profile.txt"")[self.t:self.t+self.timesteps]\r\n\tself.raw_temperature = \trtxt.read_single_indexed_file(os.getcwd()  + ""/input_data/temperature.txt"")[self.t:self.t+self.timesteps]\r\n\t\r\n\tself.hps = []\r\n\tself.chps = []\r\n\tfor i in range(len(hp_input_data)):\r\n\t    self.hps.append(self.hp(hp_input_data[i,0], \r\n\t\t\t\t    hp_input_data[i,1], \r\n\t\t\t\t    hp_input_data[i,2], \r\n\t\t\t\t    hp_input_data[i,3], \r\n\t\t\t\t    hp_input_data[i,4], \r\n\t\t\t\t    hp_input_data[i,6], \r\n\t\t\t\t    hp_input_data[i,5], \r\n\t\t\t\t    hp_p_dem[i], \r\n\t\t\t\t    hp_q_dem[i]))\r\n\t\r\n\tfor i in range(len(chp_input_data)):\r\n\t    self.chps.append(self.chp(chp_input_data[i,0], \r\n\t\t\t\t      chp_input_data[i,2], \r\n\t\t\t\t      chp_input_data[i,1], \r\n\t\t\t\t      chp_input_data[i,3], \r\n\t\t\t\t      1, \r\n\t\t\t\t      chp_input_data[i,4], \r\n\t\t\t\t      chp_input_data[i,5], \r\n\t\t\t\t      chp_input_data[i,7], \r\n\t\t\t\t      chp_input_data[i,6], \r\n\t\t\t\t      chp_p_dem[i], \r\n\t\t\t\t      chp_q_dem[i]))\r\n\t\r\n\tself.P_res = \t\trenewables.compute_renewables(rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/wind_speed.txt"")[self.t:self.t+self.timesteps],\r\n\t\t\t\t\t\t\t      rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/sun_direct.txt"")[self.t:self.t+self.timesteps],\r\n\t\t\t\t\t\t\t      len(self.hps), len(self.chps))\r\n\t'"
Code/model_masterproblem.py,22,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 22:00:29 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nfrom gurobipy import *\r\nimport numpy as np\r\nfrom constants import *\r\nimport microgrid_functions.renewables as renewables\r\nimport os\r\nimport basic_functions.read_txt as rtxt\r\n\r\ndef optimize(mp, final_iteration=False):\r\n    """"""\r\n    \r\n    """"""\r\n    timesteps = mp.timesteps\r\n    max_time=Constants.max_time_master\r\n\r\n    chp_number = mp.number_chp\r\n    hp_number  = mp.number_hp\r\n    \r\n    if final_iteration:\r\n\tchp_number_props = GlobVar.final_count +1\r\n\tprop_chp = mp.final_proposals_chp[:chp_number_props]\r\n\tk_chp = mp.final_costs_chp[:chp_number_props]\r\n    else:\r\n\tif GlobVar.overall_count == 0:\r\n\t    chp_number_props = GlobVar.overall_count+1\r\n\t    prop_chp = np.array([mp.initial_proposals_chp])\r\n\t    k_chp = np.array([mp.initial_costs_chp])\r\n\telse:\r\n\t    chp_number_props = GlobVar.overall_count\r\n\t    prop_chp = mp.pricing_proposals_chp[:chp_number_props]\r\n\t    k_chp = mp.pricing_costs_chp[:chp_number_props]\r\n\t    if GlobVar.random_proposals_in_master:\r\n\t\tprop_chp = np.append(prop_chp, [mp.initial_proposals_chp], axis=0)\r\n\t\tk_chp = np.append(k_chp, [mp.initial_costs_chp], axis=0)\r\n\t\tchp_number_props += 1\r\n    \r\n    if final_iteration:\r\n\thp_number_props = GlobVar.final_count + 1\r\n\tprop_hp  = mp.final_proposals_hp[:hp_number_props]\r\n    else:\r\n\tif GlobVar.overall_count == 0:\r\n\t    hp_number_props = GlobVar.overall_count+1\r\n\t    prop_hp  = np.array([mp.initial_proposals_hp])\r\n\telse:\r\n\t    hp_number_props = GlobVar.overall_count\r\n\t    prop_hp  = mp.pricing_proposals_hp[:hp_number_props]\r\n\t    if GlobVar.random_proposals_in_master:\r\n\t\tprop_hp  = np.append(prop_hp, [mp.initial_proposals_hp], axis=0)\r\n\t\thp_number_props += 1\r\n\r\n    \'\'\'\r\n    if chp_number_props == 0:\r\n        bounds_chp = np.ones((1, chp_number))\r\n        bounds_hp = np.ones((1, hp_number))\r\n    else:\r\n        if mp.count_iteration > 2:\r\n            bounds_chp = np.array(mp.bounds_chp)\r\n            bounds_hp  = np.array(mp.bounds_hp)\r\n        else:\r\n            bounds_chp = np.ones((1, chp_number))\r\n            bounds_hp = np.ones((1, hp_number))\r\n    \'\'\'\r\n    \r\n    P_ren = mp.P_renewables\r\n        \r\n    dt = mp.dt\r\n    k_el = mp.k_el\r\n    r_el = mp.r_el\r\n    \r\n    # Gurobi optimization model\r\n    try:\r\n        # Create a new model\r\n        model = Model(""masterproblem"")\r\n        model.Params.OutputFlag = 0\r\n\r\n        # Create variables with one or more sets:\r\n        l_chp = {} # Weighting variables of the CHP proposals\r\n        l_hp  = {} # Weighting variables of the HP proposals\r\n        \r\n        P_imp = {} # Imported electricity\r\n        P_exp = {} # Exported electricity\r\n   \r\n        if final_iteration:\r\n            for p in xrange(hp_number_props):\r\n                for j in xrange(hp_number):\r\n                    l_hp[p,j] = model.addVar(vtype=GRB.BINARY, name=""l_hp_""+str(p)+""_""+str(j))\r\n                    \r\n            for p in xrange(chp_number_props):\r\n                for k in xrange(chp_number):\r\n                    l_chp[p,k] = model.addVar(vtype=GRB.BINARY, name=""l_chp_""+str(p)+""_""+str(k))\r\n        else:\r\n            for p in xrange(hp_number_props):\r\n                for j in xrange(hp_number):\r\n                    l_hp[p,j] = model.addVar(vtype=GRB.CONTINUOUS, name=""l_hp_""+str(p)+""_""+str(j), lb=0.0, ub=1.0)\r\n                    \r\n            for p in xrange(chp_number_props):\r\n                for k in xrange(chp_number):\r\n                    l_chp[p,k] = model.addVar(vtype=GRB.CONTINUOUS, name=""l_chp_""+str(p)+""_""+str(k), lb=0.0, ub=1.0)\r\n\t\r\n        for t in xrange(timesteps):\r\n            P_imp[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_imp_""+str(t), lb=0.0)\r\n            P_exp[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_exp_""+str(t), lb=0.0)\r\n\r\n        # Integrate new variables into the model\r\n        model.update()    \r\n\t\r\n        # Set objective\r\n        costs_electricity = quicksum(P_imp[t]*k_el - P_exp[t]*r_el for t in range(timesteps)) *dt\r\n        costs_gas_chp = quicksum(quicksum(k_chp[p,k] * l_chp[p,k] for p in range(chp_number_props)) for k in range(chp_number))     \r\n        model.setObjective(costs_electricity + costs_gas_chp, GRB.MINIMIZE)\r\n        \r\n        # Add constraints\r\n        # Electricity balance:\r\n        for t in xrange(timesteps):\r\n            hp_proposal  = quicksum(quicksum(prop_hp[p,j,t]  * l_hp[p,j]  for p in range(hp_number_props))  for j in range(hp_number))\r\n            chp_proposal = quicksum(quicksum(prop_chp[p,k,t] * l_chp[p,k] for p in range(chp_number_props)) for k in range(chp_number))\r\n            model.addConstr(hp_proposal + chp_proposal + P_ren[t] + P_imp[t] - P_exp[t] ==  0 , ""ElectricityBalance_""+str(t))\r\n        \r\n        # Convexity constraints\r\n        for j in xrange(hp_number):\r\n            model.addConstr(quicksum(l_hp[p,j] for p in range(hp_number_props)) == 1, ""Convex_hp_""+str(j))\r\n        for k in xrange(chp_number):\r\n            model.addConstr(quicksum(l_chp[p,k] for p in range(chp_number_props)) == 1, ""Convex_chp_""+str(k))\r\n        \r\n        # Set Gurobi parameters\r\n        model.Params.Presolve = 0\r\n#        model.Params.MIPGap = 0.01\r\n\tif not final_iteration:\r\n\t    model.Params.TimeLimit = max_time\r\n\telse:\r\n\t    model.Params.TimeLimit = 15\r\n        \r\n        # Run model\r\n        model.optimize()\r\n        \r\n        # Print final solution\r\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT:\r\n            r_obj = model.ObjVal\r\n            print(""Current objective of the master problem: "" + str(r_obj))\r\n            \r\n            if final_iteration:\r\n                r_hp = np.zeros((hp_number))\r\n                r_chp = np.zeros((chp_number))\r\n                \r\n                for p in xrange(hp_number_props):\r\n                    for j in xrange(hp_number):\r\n                        if round(l_hp[p,j].X)==1:\r\n\t\t\t    r_hp[j] = p\r\n                for p in xrange(chp_number_props):\r\n                    for k in xrange(chp_number):\r\n                        if round(l_chp[p,k].X)==1:\r\n\t\t\t    r_chp[k] = p\r\n            else:\r\n                r_sigma_hp  = np.zeros(hp_number)\r\n                r_sigma_chp = np.zeros(chp_number)\r\n                r_pi = np.zeros(timesteps)\r\n                            \r\n                for t in xrange(timesteps):\r\n                    r_pi[t] = (model.getConstrByName(""ElectricityBalance_""+str(t))).Pi #.getAttr(""Pi"")\r\n    \r\n                for j in xrange(hp_number):\r\n                    r_sigma_hp[j]  = (model.getConstrByName(""Convex_hp_""+str(j))).Pi #.getAttr(""Pi"")\r\n                    \r\n                for k in xrange(chp_number):\r\n                    r_sigma_chp[k] = (model.getConstrByName(""Convex_chp_""+str(k))).Pi #.getAttr(""Pi"")\r\n            \r\n        else: \r\n            model.computeIIS()\r\n            print(\'\\nConstraints:\')        \r\n            for c in model.getConstrs():\r\n                if c.IISConstr:\r\n                    print(\'%s\' % c.constrName)\r\n            print(\'\\nBounds:\')\r\n            for v in model.getVars():\r\n                if v.IISLB > 0 :\r\n                    print(\'Lower bound: %s\' % v.VarName)\r\n                elif v.IISUB > 0:\r\n                    print(\'Upper bound: %s\' % v.VarName)\r\n    except GurobiError:\r\n        print(\'Error in masterproblem\')\r\n        \r\n    if final_iteration:\r\n        return (r_obj, r_hp, r_chp)\r\n    else:\r\n        return (r_obj, r_pi, r_sigma_hp, r_sigma_chp)\r\n      \r\ndef plot_optimize(day, prop_chp, k_chp, prop_hp):\r\n    """"""\r\n    \r\n    """"""\r\n    t = day * 24 * 4\r\n    final_iteration=True\r\n    \r\n    timesteps = Constants.timesteps\r\n    max_time = Constants.max_time_master\r\n    chp_number = len(k_chp[0])\r\n    \r\n    hp_number  = len(prop_hp[0])\r\n    chp_number_props = len(k_chp)\r\n    hp_number_props = len(prop_hp)\r\n    \r\n    P_ren = \trenewables.compute_renewables(rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/wind_speed.txt"")[t:t+timesteps],\r\n\t\t\t\t\t\t      rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/sun_direct.txt"")[t:t+timesteps],\r\n\t\t\t\t\t\t      hp_number, chp_number)\r\n        \r\n    dt = Constants.dt\r\n    k_el = Constants.k_el\r\n    r_el = Constants.r_el\r\n    \r\n    # Gurobi optimization model\r\n    try:\r\n        # Create a new model\r\n        model = Model(""masterproblem"")\r\n        model.Params.OutputFlag = 0\r\n\r\n        # Create variables with one or more sets:\r\n        l_chp = {} # Weighting variables of the CHP proposals\r\n        l_hp  = {} # Weighting variables of the HP proposals\r\n        \r\n        P_imp = {} # Imported electricity\r\n        P_exp = {} # Exported electricity\r\n   \r\n        if final_iteration:\r\n            for p in xrange(hp_number_props):\r\n                for j in xrange(hp_number):\r\n                    l_hp[p,j] = model.addVar(vtype=GRB.BINARY, name=""l_hp_""+str(p)+""_""+str(j))\r\n                    \r\n            for p in xrange(chp_number_props):\r\n                for k in xrange(chp_number):\r\n                    l_chp[p,k] = model.addVar(vtype=GRB.BINARY, name=""l_chp_""+str(p)+""_""+str(k))\r\n        else:\r\n            for p in xrange(hp_number_props):\r\n                for j in xrange(hp_number):\r\n                    l_hp[p,j] = model.addVar(vtype=GRB.CONTINUOUS, name=""l_hp_""+str(p)+""_""+str(j), lb=0.0, ub=1.0)\r\n                    \r\n            for p in xrange(chp_number_props):\r\n                for k in xrange(chp_number):\r\n                    l_chp[p,k] = model.addVar(vtype=GRB.CONTINUOUS, name=""l_chp_""+str(p)+""_""+str(k), lb=0.0, ub=1.0)\r\n\t\r\n        for t in xrange(timesteps):\r\n            P_imp[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_imp_""+str(t), lb=0.0)\r\n            P_exp[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_exp_""+str(t), lb=0.0)\r\n\r\n        # Integrate new variables into the model\r\n        model.update()    \r\n\t\r\n        # Set objective\r\n        costs_electricity = quicksum(P_imp[t]*k_el - P_exp[t]*r_el for t in range(timesteps)) *dt\r\n        costs_gas_chp = quicksum(quicksum(k_chp[p,k] * l_chp[p,k] for p in range(chp_number_props)) for k in range(chp_number))     \r\n        model.setObjective(costs_electricity + costs_gas_chp, GRB.MINIMIZE)\r\n        \r\n        # Add constraints\r\n        # Electricity balance:\r\n        for t in xrange(timesteps):\r\n            hp_proposal  = quicksum(quicksum(prop_hp[p,j,t]  * l_hp[p,j]  for p in range(hp_number_props))  for j in range(hp_number))\r\n            chp_proposal = quicksum(quicksum(prop_chp[p,k,t] * l_chp[p,k] for p in range(chp_number_props)) for k in range(chp_number))\r\n            model.addConstr(hp_proposal + chp_proposal + P_ren[t] + P_imp[t] - P_exp[t] ==  0 , ""ElectricityBalance_""+str(t))\r\n        \r\n        # Convexity constraints\r\n        for j in xrange(hp_number):\r\n            model.addConstr(quicksum(l_hp[p,j] for p in range(hp_number_props)) == 1, ""Convex_hp_""+str(j))\r\n        for k in xrange(chp_number):\r\n            model.addConstr(quicksum(l_chp[p,k] for p in range(chp_number_props)) == 1, ""Convex_chp_""+str(k))\r\n        \r\n        # Set Gurobi parameters\r\n        model.Params.Presolve = 0\r\n#        model.Params.MIPGap = 0.01\r\n\tif not final_iteration:\r\n\t    model.Params.TimeLimit = max_time\r\n\telse:\r\n\t    model.Params.TimeLimit = 15\r\n        \r\n        # Run model\r\n        model.optimize()\r\n        \r\n        # Print final solution\r\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT:\r\n            r_obj = model.ObjVal\r\n            print(""Current objective of the master problem: "" + str(r_obj))\r\n            \r\n            if final_iteration:\r\n                r_hp = np.zeros((hp_number))\r\n                r_chp = np.zeros((chp_number))\r\n                \r\n                for p in xrange(hp_number_props):\r\n                    for j in xrange(hp_number):\r\n                        if round(l_hp[p,j].X)==1:\r\n\t\t\t    r_hp[j] = p\r\n                for p in xrange(chp_number_props):\r\n                    for k in xrange(chp_number):\r\n                        if round(l_chp[p,k].X)==1:\r\n\t\t\t    r_chp[k] = p\r\n            else:\r\n                r_sigma_hp  = np.zeros(hp_number)\r\n                r_sigma_chp = np.zeros(chp_number)\r\n                r_pi = np.zeros(timesteps)\r\n                            \r\n                for t in xrange(timesteps):\r\n                    r_pi[t] = (model.getConstrByName(""ElectricityBalance_""+str(t))).Pi #.getAttr(""Pi"")\r\n    \r\n                for j in xrange(hp_number):\r\n                    r_sigma_hp[j]  = (model.getConstrByName(""Convex_hp_""+str(j))).Pi #.getAttr(""Pi"")\r\n                    \r\n                for k in xrange(chp_number):\r\n                    r_sigma_chp[k] = (model.getConstrByName(""Convex_chp_""+str(k))).Pi #.getAttr(""Pi"")\r\n            \r\n        else: \r\n            model.computeIIS()\r\n            print(\'\\nConstraints:\')        \r\n            for c in model.getConstrs():\r\n                if c.IISConstr:\r\n                    print(\'%s\' % c.constrName)\r\n            print(\'\\nBounds:\')\r\n            for v in model.getVars():\r\n                if v.IISLB > 0 :\r\n                    print(\'Lower bound: %s\' % v.VarName)\r\n                elif v.IISUB > 0:\r\n                    print(\'Upper bound: %s\' % v.VarName)\r\n    except GurobiError:\r\n        print(\'Error in masterproblem\')\r\n        \r\n    if final_iteration:\r\n        return (r_obj, r_hp, r_chp)\r\n    else:\r\n        return (r_obj, r_pi, r_sigma_hp, r_sigma_chp)'"
Code/model_subproblem_chp.py,15,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 22:00:29 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nfrom gurobipy import *\r\nimport numpy as np\r\nfrom constants import *\r\nfrom IPython.core.debugger import Tracer\r\n\r\ndef optimize(pass_chp, marginals, final):\r\n    """"""\r\n    \r\n    """"""\r\n    \r\n    sigma = pass_chp.sigma\r\n    eta   = pass_chp.eta\r\n    Q_nom = pass_chp.Q_nom\r\n    Q_sec_nom = pass_chp.Q_sec_nom\r\n    eta_sec   = pass_chp.eta_sec\r\n    sto_m  = pass_chp.sto_m\r\n    sto_UA = pass_chp.sto_UA\r\n    T_max = pass_chp.t_max\r\n    T_min = pass_chp.t_flow\r\n    t_amb = pass_chp.t_amb\r\n    t_ini = pass_chp.t_init\r\n    q_dem = pass_chp.heatdemand    \r\n    c_w = pass_chp.c_w\r\n    dt  = pass_chp.dt    \r\n    k_g = pass_chp.k_g\r\n    timesteps = pass_chp.timesteps\r\n    P_dem = pass_chp.P_dem\r\n    \r\n    # Gurobi optimization model\r\n    try:\r\n        # Create a new model\r\n        model = Model(""chp_subsystem"")\r\n\tmodel.Params.OutputFlag = 0\r\n\t\r\n        # Create variables with one or more sets:\r\n        x = np.empty([timesteps], dtype=object) # Status CHP (primary heater)\r\n        y = np.empty([timesteps], dtype=object) # Status CHP (secondary heater)\r\n        \r\n        T = np.empty([timesteps], dtype=object) # CHP storage temperature    \r\n        Q = np.empty([timesteps], dtype=object) # Boiler\'s heat output\r\n        #P = {} # Exported electricity\r\n        \r\n        for t in range(timesteps):\r\n            x[t] = model.addVar(vtype=GRB.BINARY, name=""x_chp_""+str(t))\r\n            y[t] = model.addVar(vtype=GRB.BINARY, name=""y_chp_""+str(t))\r\n            T[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""T_chp_""+str(t), lb=T_min[t], ub=T_max)\r\n            Q[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""Q_B_""  +str(t), lb=0.0, ub=Q_sec_nom)\r\n            #P[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_chp_""+str(t))\r\n       \r\n        # Integrate new variables into the model\r\n        model.update()    \r\n    \r\n        # Set objective\r\n        costs = quicksum((Q_nom*sigma/eta*x[t] + Q[t]/eta_sec)*k_g*dt + marginals[t]*(P_dem[t] - x[t] * Q_nom * sigma) for t in range(timesteps))\r\n        model.setObjective(costs, GRB.MINIMIZE)\r\n        \r\n        # Add constraints\r\n        for t in range(timesteps):\r\n            # Electricity balance:\r\n            #model.addConstr(P[t] == P_dem[t] - x[t] *Q_nom*sigma, ""ElectricityBalance_""+str(t))\r\n            \r\n            # Boiler\'s heat output\r\n            model.addConstr(Q[t] >= y[t] * Q_sec_nom * 0.3, ""CHP_Boiler_eq1_""+str(t))\r\n            model.addConstr(Q[t] <= y[t] * Q_sec_nom,       ""CHP_Boiler_eq2_""+str(t))\r\n            #model.addConstr(Q[t] == y[t] * Q_sec_nom, ""CHP_Boiler_eq_""+str(t))\r\n            \r\n            # Storage equations\r\n            if t == 0:\r\n                t_prev = t_ini\r\n            else:\r\n                t_prev = T[t-1]\r\n            model.addConstr(sto_m * c_w / dt * (T[t] - t_prev) == x[t] * Q_nom - q_dem[t] - sto_UA * (T[t] - t_amb) + Q[t], ""Storage_CHP_""+str(t))\r\n        \r\n        \'\'\'if GlobVar.inner_count == 1:\r\n\t    for t in xrange(timesteps):\r\n\t\tx[t].Start = pass_chp.pricing_res_x[GlobVar.overall_count-2, t]\r\n\t\ty[t].Start = pass_chp.pricing_res_y[GlobVar.overall_count-2, t]\r\n\t\tT[t].Start = pass_chp.pricing_res_T[GlobVar.overall_count-2, t]\r\n\t\t#P[t].Start = pass_chp.res_P[GlobVar.outer_count-1, -1, t]\r\n\t\tQ[t].Start = pass_chp.pricing_res_Q[GlobVar.overall_count-2, t]\r\n\tif GlobVar.inner_count > 1:\r\n\t    for t in xrange(timesteps):\r\n\t\tx[t].Start = pass_chp.pricing_res_x[GlobVar.overall_count-1, t]\r\n\t\ty[t].Start = pass_chp.pricing_res_y[GlobVar.overall_count-1, t]\r\n\t\tT[t].Start = pass_chp.pricing_res_T[GlobVar.overall_count-1, t]\r\n\t\t#P[t].Start = pass_chp.res_P[GlobVar.outer_count, GlobVar.inner_count-1, t]\r\n\t\tQ[t].Start = pass_chp.pricing_res_Q[GlobVar.overall_count-1, t]\'\'\'\r\n\t\r\n\tif final and GlobVar.final_count > 0:\r\n\t    for i in range(GlobVar.final_count):\r\n\t\tx_sol = pass_chp.final_res_x[i].astype(bool)\r\n\t\ty_sol = pass_chp.final_res_y[i].astype(bool)\r\n\t\tmodel.addConstr(quicksum(x[x_sol]) - quicksum(x[np.invert(x_sol)]) + quicksum(y[y_sol]) - quicksum(y[np.invert(y_sol)]) <= (len(x[x_sol]) + len(y[y_sol]) - 1), ""Solution_""+str(i))\r\n\t\r\n        # Set Gurobi parameters\r\n        if final:\r\n\t    model.Params.MIPGap = Constants.final_MIPGap\r\n\t    model.Params.TimeLimit = 5\r\n\t    model.Params.Seed = GlobVar.final_count\r\n\telse:\r\n\t    model.Params.MIPGap = Constants.pricing_MIPGap\r\n\t    model.Params.TimeLimit = pass_chp.max_time_subs\r\n        \r\n        # Run model\r\n        model.optimize()\r\n\t    \r\n        # Print final solution\r\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT:\r\n            r_obj = model.ObjVal\r\n    \r\n            r_x = np.zeros(timesteps)\r\n            r_y = np.zeros(timesteps)\r\n            r_T = np.zeros(timesteps)\r\n            r_P = np.zeros(timesteps)\r\n            r_Q = np.zeros(timesteps)\r\n            \r\n            for t in range(timesteps):\r\n                r_x[t] = round(x[t].X)\r\n                r_y[t] = round(y[t].X)\r\n                r_T[t] = T[t].X\r\n                r_P[t] = P_dem[t] - x[t].X * Q_nom * sigma\r\n                r_Q[t] = Q[t].X\r\n                \r\n            # Compute ""costs"" of the proposal:\r\n            k_prop = k_g * dt * np.sum(r_x*Q_nom *sigma/eta + r_Q/eta_sec)\r\n            \r\n            \'\'\'failure = False\r\n            if GlobVar.final_count > 1:\r\n\t\tfor i in range(GlobVar.final_count):\r\n\t\t    for j in range(i+1, GlobVar.final_count):\r\n\t\t\txcomp = np.array_equal(pass_chp.final_res_x[i], pass_chp.final_res_x[j])\r\n\t\t\tycomp = np.array_equal(pass_chp.final_res_y[i], pass_chp.final_res_y[j])\r\n\t\t\tif xcomp and ycomp:\r\n\t\t\t    failure = True\r\n\t\t\t    break\r\n\t\t    if failure:\r\n\t\t\tbreak\r\n            \r\n            if final and GlobVar.final_count > 0 and failure:\r\n\t\tfor i in range(GlobVar.final_count):\r\n\t\t    x_sol = pass_chp.final_res_x[i].astype(bool)\r\n\t\t    y_sol = pass_chp.final_res_y[i].astype(bool)\r\n\t\t    print x_sol\r\n\t\t    print y_sol\r\n\t\t    print LinExpr(quicksum(x[x_sol]) - quicksum(x[np.invert(x_sol)]) + quicksum(y[y_sol]) - quicksum(y[np.invert(y_sol)])).getValue(),(len(x[x_sol]) + len(y[y_sol]))\r\n\t\t    print quicksum(x[x_sol]).getValue(), quicksum(x[np.invert(x_sol)]).getValue(), quicksum(y[y_sol]).getValue(), quicksum(y[np.invert(y_sol)]).getValue(), len(x[x_sol]), len(y[y_sol]), pass_chp.final_res_obj[i]\r\n\t\t    xl = []\r\n\t\t    yl = []\r\n\t\t    for j in range(timesteps):\r\n\t\t\tif r_x[j].astype(bool) != pass_chp.final_res_x[i,j].astype(bool):\r\n\t\t\t    xl.append(j)\r\n\t\t\tif r_y[j].astype(bool) != pass_chp.final_res_y[i,j].astype(bool):\r\n\t\t\t    yl.append(j)\r\n\t\t    print xl\r\n\t\t    print yl\r\n\t\tprint r_x\r\n\t\tprint r_x.astype(int)\r\n\t\tprint r_y\r\n\t\tprint r_y.astype(int)\r\n\t\tTracer()()\'\'\'\r\n        \r\n        else:\r\n            model.computeIIS()\r\n            print(\'\\nConstraints:\')        \r\n            for c in model.getConstrs():\r\n                if c.IISConstr:\r\n                    print(\'%s\' % c.constrName)\r\n            print(\'\\nBounds:\')\r\n            for v in model.getVars():\r\n                if v.IISLB > 0 :\r\n                    print(\'Lower bound: %s\' % v.VarName)\r\n                elif v.IISUB > 0:\r\n                    print(\'Upper bound: %s\' % v.VarName)\r\n    except GurobiError:\r\n        print(\'Error in CHP subproblem \'+ str(pass_chp.nr))\r\n        \r\n    #print r_P\r\n    #print P_dem\r\n    #print r_x\r\n    #print r_y\r\n    #print r_T\r\n    #print T_min\r\n    #print r_Q\r\n    #print k_prop\r\n    #raw_input()\r\n    \r\n    return (r_obj, r_x, r_y, r_T, - r_P, r_Q, k_prop)'"
Code/model_subproblem_hp.py,9,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 20:45:37 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nfrom gurobipy import *\r\nimport numpy as np\r\nfrom constants import *\r\nfrom IPython.core.debugger import Tracer\r\nimport random\r\n\r\ndef optimize(pass_hp, marginals, final):\r\n    """"""\r\n    \r\n    """"""\r\n   \r\n    Q_nom = pass_hp.Q_prim\r\n    P_nom = pass_hp.P_prim\r\n    Q_sec_nom = pass_hp.Q_sec_nom\r\n    eta_sec   = pass_hp.eta_sec\r\n    sto_m  = pass_hp.sto_m\r\n    sto_UA = pass_hp.sto_UA\r\n    T_max = pass_hp.t_max\r\n    T_min = pass_hp.t_flow\r\n    t_amb = pass_hp.t_amb\r\n    t_ini = pass_hp.t_init\r\n    q_dem = pass_hp.heatdemand    \r\n    c_w = pass_hp.c_w\r\n    dt  = pass_hp.dt\r\n    P_dem = pass_hp.P_dem\r\n    \r\n    timesteps = pass_hp.timesteps\r\n   \r\n    # Gurobi optimization model\r\n    try:\r\n        # Create a new model\r\n        model = Model(""hp_subsystem"")\r\n\tmodel.Params.OutputFlag = 0\r\n\t\r\n        # Create variables\r\n        x = np.empty([timesteps], dtype=object) # Status HP (primary heater)\r\n        y = np.empty([timesteps], dtype=object) # Status HP  (secondary heater)\r\n        T = np.empty([timesteps], dtype=object) # HP storage temperature    \r\n        #P = np.empty([timesteps], dtype=object) # Exported electricity\r\n        \r\n        for t in range(timesteps):\r\n            x[t] = model.addVar(vtype=GRB.BINARY, name=""x_hp_""    +str(t))\r\n            y[t] = model.addVar(vtype=GRB.BINARY, name=""y_hp_""    +str(t))\r\n            T[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""T_hp_""+str(t), lb=T_min[t], ub=T_max)\r\n            #P[t] = model.addVar(vtype=GRB.CONTINUOUS, name=""P_hp_"" +str(t), lb=0.0)\r\n       \r\n        # Integrate new variables into the model\r\n        model.update()\r\n    \r\n        # Set objective\r\n        model.setObjective(quicksum((x[t] * P_nom[t] + Q_sec_nom / eta_sec * y[t] + P_dem[t])*marginals[t] for t in range(timesteps)), GRB.MINIMIZE)\r\n        \r\n        # Add constraints\r\n        for t in xrange(timesteps):\r\n            # Electricity balance:\r\n            #model.addConstr(P[t] == x[t] * P_nom[t] + Q_sec_nom / eta_sec * y[t] + P_dem[t], ""ElectricityBalance_""+str(t))\r\n            \r\n            # Storage equations\r\n            if t == 0:\r\n                t_prev = t_ini\r\n            else:\r\n                t_prev = T[t-1]\r\n            model.addConstr(sto_m * c_w / dt * (T[t] - t_prev) == x[t] * Q_nom[t] - q_dem[t] - sto_UA * (T[t] - t_amb) + y[t] * Q_sec_nom, ""Storage_HP_""+str(t))\r\n        \r\n        \'\'\'if GlobVar.inner_count == 1:\r\n\t    for t in xrange(timesteps):\r\n\t\tx[t].Start = pass_hp.pricing_res_x[GlobVar.overall_count-2, t]\r\n\t\ty[t].Start = pass_hp.pricing_res_y[GlobVar.overall_count-2, t]\r\n\t\tT[t].Start = pass_hp.pricing_res_T[GlobVar.overall_count-2, t]\r\n\t\t#P[t].Start = pass_hp.res_P[GlobVar.outer_count-1, -1, t]\r\n\telif GlobVar.inner_count > 1:\r\n\t    for t in xrange(timesteps):\r\n\t\tx[t].Start = pass_hp.pricing_res_x[GlobVar.overall_count-1, t]\r\n\t\ty[t].Start = pass_hp.pricing_res_y[GlobVar.overall_count-1, t]\r\n\t\tT[t].Start = pass_hp.pricing_res_T[GlobVar.overall_count-1, t]\r\n\t\t#P[t].Start = pass_hp.res_P[GlobVar.outer_count-1, -1, t]\'\'\'\r\n\t\r\n\tif final and GlobVar.final_count > 0:\r\n\t    for i in range(GlobVar.final_count):\r\n\t\tx_sol = pass_hp.final_res_x[i].astype(bool)\r\n\t\ty_sol = pass_hp.final_res_y[i].astype(bool)\r\n\t\tmodel.addConstr(quicksum(x[x_sol]) - quicksum(x[np.invert(x_sol)]) + quicksum(y[y_sol]) - quicksum(y[np.invert(y_sol)]) <= len(x[x_sol]) + len(y[y_sol]) -1, ""Solution_""+str(i))\r\n\t\r\n        if final:\r\n\t    model.Params.MIPGap = Constants.final_MIPGap\r\n\t    model.Params.TimeLimit = 5\r\n\t    model.Params.Seed = GlobVar.final_count+1\r\n\telse:\r\n\t    model.Params.MIPGap = Constants.pricing_MIPGap\r\n\t    model.Params.TimeLimit = pass_hp.max_time_subs\r\n        \r\n        \r\n        # Run model\r\n        model.optimize()\r\n    \r\n        # Print final solution\r\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT:\r\n            r_obj = model.ObjVal\r\n    \r\n            r_x = np.zeros(timesteps)\r\n            r_y = np.zeros(timesteps)\r\n            r_T = np.zeros(timesteps)\r\n            r_P = np.zeros(timesteps)\r\n            \r\n            for t in range(timesteps):\r\n                r_x[t] = round(x[t].X)\r\n                r_y[t] = round(y[t].X)\r\n                r_T[t] = T[t].X\r\n                r_P[t] = r_x[t] * P_nom[t] + Q_sec_nom / eta_sec * r_y[t] + P_dem[t]\r\n\r\n        else: \r\n            model.computeIIS()\r\n            print(\'\\nConstraints:\')        \r\n            for c in model.getConstrs():\r\n                if c.IISConstr:\r\n                    print(\'%s\' % c.constrName)\r\n            print(\'\\nBounds:\')\r\n            for v in model.getVars():\r\n                if v.IISLB > 0 :\r\n                    print(\'Lower bound: %s\' % v.VarName)\r\n                elif v.IISUB > 0:\r\n                    print(\'Upper bound: %s\' % v.VarName)\r\n    except GurobiError:\r\n        print(\'Error in HP subproblem \' + str(pass_hp.nr))\r\n        \r\n    #print r_x\r\n    #print r_y\r\n    #print r_T\r\n    #print r_P\r\n    #raw_input()\r\n        \r\n    return r_obj, r_x, r_y, r_T, - r_P'"
Code/object_chp.py,16,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Nov 26 21:44:57 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nfrom  constants import *\r\nimport numpy as np\r\nimport basic_functions.heating_tech\r\nimport model_subproblem_chp\r\nimport basic_functions.read_txt as rtxt\r\nimport os\r\n\r\nclass CHP(Storage):\r\n    """"""\r\n    Overview of all methods and usage of this class\r\n    """"""\r\n    \r\n    def __init__(self, data , t_ambient, i):\r\n        """"""\r\n        """"""\r\n        self.nr = i\r\n        self.sto_m = data.m_sto\r\n        self.sto_UA = data.U_sto\r\n        self.t_init = data.T_init\r\n        self.t_max = data.T_max\r\n        self.Q_nom = data.Q_nom\r\n        self.sigma = data.sigma\r\n        self.eta = data.eta\r\n        self.Q_sec_nom = data.Q_sec\r\n        self.eta_sec = data.eta_sec\r\n        self.heatdemand = self.compute_heatdemand(data.Q_dem)\r\n        self.t_flow = self.compute_t_flow(t_ambient)\r\n        self.P_dem = data.P_dem\r\n        \r\n        self.pricing_res_x = np.zeros([self.overall_max, self.timesteps], dtype=""bool_"")\r\n        self.pricing_res_y = np.zeros([self.overall_max, self.timesteps], dtype=""bool_"")\r\n        self.pricing_res_T = np.zeros([self.overall_max, self.timesteps])\r\n        self.pricing_res_P = np.zeros([self.overall_max, self.timesteps])\r\n        self.pricing_res_Q = np.zeros([self.overall_max, self.timesteps])\r\n        self.pricing_res_obj = np.zeros([self.overall_max])\r\n        self.pricing_res_costs = np.zeros([self.overall_max])\r\n        \r\n        self.final_res_x = np.zeros([self.final_max, self.timesteps], dtype=""bool_"")\r\n        self.final_res_y = np.zeros([self.final_max, self.timesteps], dtype=""bool_"")\r\n        self.final_res_T = np.zeros([self.final_max, self.timesteps])\r\n        self.final_res_P = np.zeros([self.final_max, self.timesteps])\r\n        self.final_res_Q = np.zeros([self.final_max, self.timesteps])\r\n        self.final_res_obj = np.zeros([self.final_max])\r\n        self.final_res_costs = np.zeros([self.final_max])\r\n        \r\n        self.results = np.zeros([self.final_max,2])\r\n        \r\n    def compute_t_flow(self, t_ambient):\r\n        """"""\r\n        Compute the flow temperature based on the ambient temperature (in \xc2\xb0C)\r\n        """"""\r\n        return basic_functions.heating_tech.heatingCurve(t_ambient+273.15) - 273.15\r\n        \r\n    def compute_heatdemand(self, heatdemand):\r\n        """"""\r\n        For testing purposes, this has not really been implemented yet.\r\n        In future works, a heat demand forecast is preferable - now the given\r\n        heat demand is accepted as the house\'s heat demand.\r\n        """"""\r\n        return heatdemand\r\n      \r\n    def compute_el_demand(self, raw_slp, users):\r\n\t""""""\r\n\tCompute the electricity consumption based on the standard load profile\r\n      \r\n\t    Parameters:\r\n                \r\n                slp --> original standard load profile (Array)\r\n                \r\n                users --> inhabitant living in this apartment / building\r\n            \r\n                timestep_length --> length of one time step in seconds\r\n            \r\n            Result:\r\n            \r\n                Electricity consumption in Watt (Array)\r\n        """"""\r\n        average_demand = 872.6 * users + 1497.1\r\n        scaling_factor = average_demand * 3600 / Constants.dt\r\n        return raw_slp * scaling_factor\r\n        \r\n    def compute_proposal(self, marginals, final=False):\r\n        """"""\r\n        This function computes a new proposal (P and k).\r\n        Internally, the results of the subproblem are stored.\r\n        If this is the first time in the current optimization period that new\r\n            proposals have to generated, _iteration_ has to be set to 0\r\n        """"""\r\n        if final:\r\n\t    (self.final_res_obj[GlobVar.final_count],\r\n\t     self.final_res_x[GlobVar.final_count],\r\n\t     self.final_res_y[GlobVar.final_count],\r\n\t     self.final_res_T[GlobVar.final_count],\r\n\t     self.final_res_P[GlobVar.final_count],\r\n\t     self.final_res_Q[GlobVar.final_count],\r\n\t     self.final_res_costs[GlobVar.final_count]) = model_subproblem_chp.optimize(self, marginals, final)\r\n\t    return self.final_res_costs[GlobVar.final_count], self.final_res_P[GlobVar.final_count]\r\n\telse:\r\n\t    (self.pricing_res_obj[GlobVar.overall_count],\r\n\t     self.pricing_res_x[GlobVar.overall_count],\r\n\t     self.pricing_res_y[GlobVar.overall_count],\r\n\t     self.pricing_res_T[GlobVar.overall_count],\r\n\t     self.pricing_res_P[GlobVar.overall_count],\r\n\t     self.pricing_res_Q[GlobVar.overall_count],\r\n\t     self.pricing_res_costs[GlobVar.overall_count]) = model_subproblem_chp.optimize(self, marginals, final)\r\n\t    return self.pricing_res_costs[GlobVar.overall_count], self.pricing_res_P[GlobVar.overall_count]\r\n    \r\n    def get_optimal_schedule(self, lambdas):\r\n        """"""\r\n        This function returns the scheduling of the primary and secondary\r\n        heating device as well as the resulting storage temperature:\r\n        x, y, T, P, Q\r\n        """"""\r\n        index = np.argmax(lambdas)\r\n        return (self.res_x[index], self.res_y[index], self.res_T[index], self.res_P[index], self.res_Q[index])\r\n'"
Code/object_hp.py,11,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sat Nov 29 09:08:31 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nfrom constants import *\r\nimport numpy as np\r\nimport basic_functions.heating_tech\r\nimport model_subproblem_hp\r\nimport heat_pumps.HP_characteristics\r\nimport basic_functions.read_txt as rtxt\r\nimport os\r\n\r\nclass HP(Storage):\r\n    """"""\r\n    Overview of all methods and usage of this class\r\n    """"""\r\n    \r\n    def __init__(self, data, t_ambient, i):\r\n        """"""\r\n        """"""        \r\n        self.nr = i\r\n        self.sto_m = data.m_sto\r\n        self.sto_UA = data.U_sto\r\n        self.t_init = data.T_init\r\n        self.t_max = data.T_max\r\n        self.Q_sec_nom = data.Q_sec\r\n        self.eta_sec = data.eta_sec\r\n        self.t_outside = t_ambient\r\n        self.heatdemand = self.compute_heatdemand(data.Q_dem)\r\n        self.t_flow = self.compute_t_flow(t_ambient)\r\n        self.P_dem = data.P_dem\r\n        \r\n        self.Q_prim, self.P_prim = heat_pumps.HP_characteristics.get_hp_data(data.Q_nom, t_ambient, self.t_flow)\r\n        \r\n        self.pricing_res_x = np.zeros([self.overall_max, self.timesteps], dtype=""bool_"")\r\n        self.pricing_res_y = np.zeros([self.overall_max, self.timesteps], dtype=""bool_"")\r\n        self.pricing_res_T = np.zeros([self.overall_max, self.timesteps])\r\n        self.pricing_res_P = np.zeros([self.overall_max, self.timesteps])\r\n        self.pricing_res_obj = np.zeros([self.overall_max])\r\n        \r\n        self.final_res_x = np.zeros([self.final_max, self.timesteps], dtype=""bool_"")\r\n        self.final_res_y = np.zeros([self.final_max, self.timesteps], dtype=""bool_"")\r\n        self.final_res_T = np.zeros([self.final_max, self.timesteps])\r\n        self.final_res_P = np.zeros([self.final_max, self.timesteps])\r\n        self.final_res_obj = np.zeros([self.final_max])\r\n        \r\n        \r\n    def compute_t_flow(self, t_ambient):\r\n        """"""\r\n        Compute the flow temperature based on the ambient temperature (in \xc2\xb0C)\r\n        """"""\r\n        return basic_functions.heating_tech.heatingCurve(t_ambient+273.15) - 273.15\r\n        \r\n    def compute_heatdemand(self, heatdemand):\r\n        """"""\r\n        For testing purposes, this has not really been implemented yet.\r\n        In future works, a heat demand forecast is preferable - now the given\r\n        heat demand is accepted as the house\'s heat demand.\r\n        """"""\r\n        return heatdemand\r\n    \r\n    def compute_el_demand(self, raw_slp, users):\r\n\t""""""\r\n\tCompute the electricity consumption based on the standard load profile\r\n      \r\n\t    Parameters:\r\n                \r\n                slp --> original standard load profile (Array)\r\n                \r\n                users --> inhabitant living in this apartment / building\r\n            \r\n                timestep_length --> length of one time step in seconds\r\n            \r\n            Result:\r\n            \r\n                Electricity consumption in Watt (Array)\r\n        """"""\r\n        average_demand = 872.6 * users + 1497.1\r\n        scaling_factor = average_demand * 3600 / Constants.dt\r\n        return raw_slp * scaling_factor\r\n    \r\n    def compute_proposal(self, marginals, final=False):\r\n        """"""\r\n        This function computes a new proposal (P and k).\r\n        Internally, the results of the subproblem are stored.\r\n        If this is the first time in the current optimization period that new\r\n            proposals have to generated, _iteration_ has to be set to 0\r\n        """"""\r\n        if final:\r\n\t    (self.final_res_obj[GlobVar.final_count],\r\n\t     self.final_res_x[GlobVar.final_count],\r\n\t     self.final_res_y[GlobVar.final_count],\r\n\t     self.final_res_T[GlobVar.final_count],\r\n\t     self.final_res_P[GlobVar.final_count]) = model_subproblem_hp.optimize(self, marginals, final)\r\n\t    return 0, self.final_res_P[GlobVar.final_count]\r\n\telse:\r\n\t    (self.pricing_res_obj[GlobVar.overall_count],\r\n\t     self.pricing_res_x[GlobVar.overall_count],\r\n\t     self.pricing_res_y[GlobVar.overall_count],\r\n\t     self.pricing_res_T[GlobVar.overall_count],\r\n\t     self.pricing_res_P[GlobVar.overall_count]) = model_subproblem_hp.optimize(self, marginals, final)\r\n\t    return 0, self.pricing_res_P[GlobVar.overall_count]\r\n        \r\n    def get_optimal_schedule(self, lambdas):\r\n        """"""\r\n        This function returns the scheduling of the primary and secondary\r\n        heating device as well as the resulting storage temperature:\r\n        x, y, T, P\r\n        """"""\r\n        index = np.argmax(lambdas)\r\n        return (self.res_x[index], self.res_y[index], self.res_T[index], self.res_P[index])'"
Code/object_master.py,38,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Thu Nov 27 21:45:25 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\n\r\n# http://en.wikipedia.org/wiki/Branch_and_price\r\n\r\nfrom constants import *\r\nimport numpy as np\r\nimport model_masterproblem\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.cm as cm\r\n\r\nclass Master(Constants):\r\n    """"""\r\n    This is the Master class that handles all attributes relevant to the masterproblem\r\n    """"""\r\n    \r\n    def __init__(self, number_chp, number_hp, P_res):\r\n        """"""\r\n        Initialization parameters are:\r\n            number_chp: Number of installed CHP units\r\n            \r\n            number_hp:  Number of installed HP units\r\n        """"""\r\n        \r\n        self.number_chp = number_chp\r\n        self.number_hp  = number_hp\r\n        self.P_renewables = P_res\r\n        \r\n        self.pricing_costs_chp = np.zeros([self.overall_max, number_chp])\r\n        self.pricing_costs_hp  = np.zeros([self.overall_max, number_hp])\r\n        self.pricing_proposals_chp = np.zeros([self.overall_max, number_chp, self.timesteps])\r\n        self.pricing_proposals_hp  = np.zeros([self.overall_max, number_hp, self.timesteps])\r\n        \r\n        self.final_costs_chp = np.zeros([self.final_max, number_chp])\r\n        self.final_costs_hp  = np.zeros([self.final_max, number_hp])\r\n        self.final_proposals_chp = np.zeros([self.final_max, number_chp, self.timesteps])\r\n        self.final_proposals_hp  = np.zeros([self.final_max, number_hp, self.timesteps])\r\n        \r\n        self.initial_costs_chp = np.zeros([number_chp])\r\n        self.initial_costs_hp  = np.zeros([number_hp])\r\n        self.initial_proposals_chp = np.zeros([number_chp, self.timesteps])\r\n        self.initial_proposals_hp  = np.zeros([number_hp, self.timesteps])\r\n        \r\n        self.initial_marginals = np.random.uniform(Constants.r_el*Constants.dt, Constants.k_el*Constants.dt, Constants.timesteps)\r\n        \r\n        self.final_marginals = np.zeros([self.timesteps])\r\n        \r\n        self.marginals_sigma_chp = np.zeros([self.outer_max, number_chp])\r\n        self.marginals_sigma_hp  = np.zeros([self.outer_max, number_hp])\r\n        self.marginals_mu_master = np.zeros([self.outer_max, self.timesteps])\r\n        self.marginals_mu_subgradient = np.zeros([self.subgradient_max, self.timesteps])\r\n        \r\n        self.lin_obj_values = np.zeros([self.outer_max])\r\n        \r\n        self.int_obj_values = np.zeros([self.final_max])\r\n        \r\n        self.lr_bound = 0\r\n        self.res_lr_bounds_master = np.zeros([self.outer_max])\r\n        self.res_lr_bounds_subgradient = np.zeros([self.subgradient_max])\r\n        \r\n        self.sub_time = np.zeros([Constants.overall_max])\r\n        self.master_time = np.zeros([Constants.outer_max])\r\n        self.final_time = np.zeros([Constants.final_max])\r\n        \r\n        self.initialize_plot()\r\n        \r\n        self.final_hp = np.zeros([number_hp])\r\n        self.final_chp = np.zeros([number_chp])\r\n        \r\n        \r\n    def solve_master(self, final = False):\r\n        """"""\r\n        Compute new marginals, based on proposed costs and electricity proposals\r\n        \r\n        In case of initializing Branch&Price with the masterproblem, \r\n            use empty lists as proposals:\r\n        update_proposals([], [], [], [])\r\n        \r\n        This function returns the objective value of the masterproblem as \r\n            well as the marginals of the resource constraint (electricity balance)\r\n        """"""\r\n        \r\n        if final:\r\n\t    (self.int_obj_values[GlobVar.final_count],\r\n\t     self.final_hp,\r\n\t     self.final_chp) = model_masterproblem.optimize(self, final)\r\n\telse:\r\n\t    (self.lin_obj_values[GlobVar.outer_count],\r\n\t     self.marginals_mu_master[GlobVar.outer_count],\r\n\t     self.marginals_sigma_chp[GlobVar.outer_count],\r\n\t     self.marginals_sigma_hp[GlobVar.outer_count]) = model_masterproblem.optimize(self, final)\r\n\t\r\n    def update_lr_bound(self, sum_obj_subs):\r\n\tif GlobVar.overall_count < Constants.cg_iterations:\r\n\t    new_lr_bound = sum_obj_subs - np.sum(self.P_renewables * self.marginals_mu_master[GlobVar.outer_count])\r\n\t    self.lr_bound = max(self.lr_bound, new_lr_bound)\r\n\t    self.res_lr_bounds_master[GlobVar.outer_count] = new_lr_bound\r\n\telse:\r\n\t    new_lr_bound = sum_obj_subs - np.sum(self.P_renewables * self.marginals_mu_subgradient[GlobVar.overall_count-Constants.cg_iterations])\r\n\t    print new_lr_bound\r\n\t    self.lr_bound = max(self.lr_bound, new_lr_bound)\r\n\t    self.res_lr_bounds_subgradient[GlobVar.overall_count-Constants.cg_iterations] = new_lr_bound\r\n    \r\n    def compute_subgradient(self):\r\n\tif GlobVar.first_iteration:\r\n\t    return np.fromiter(( - np.sum(self.pricing_proposals_hp[Constants.cg_iterations-1, :, t])\r\n\t\t\t\t - np.sum(self.pricing_proposals_chp[Constants.cg_iterations-1, :, t]) \r\n\t\t\t\t - self.P_renewables[t] \r\n\t\t\t\t for t in range(self.timesteps)), np.float)\r\n\telse:\r\n\t    return np.fromiter(( - np.sum(self.pricing_proposals_hp[GlobVar.overall_count-1, :, t])\r\n\t\t\t\t - np.sum(self.pricing_proposals_chp[GlobVar.overall_count-1, :, t])\r\n\t\t\t\t - self.P_renewables[t]\r\n\t\t\t\t for t in range(self.timesteps)), np.float)\r\n    \r\n    def finalize(self):\r\n        """"""\r\n        Finalize the Branch&Price process by solving the masterproblem with \r\n            binaries instead of continuous variables\r\n        """"""\r\n        return model_masterproblem.optimize(self, True)\r\n    \r\n    def initialize_plot(self):\r\n\tif Constants.plot:\r\n\t    plt.plot(0, \'-\')\r\n\t    plt.ion()\r\n\t    plt.show()\r\n\t    self.obj_it = np.arange(Constants.cg_iterations)\r\n    \r\n    def update_plot_cg(self):\r\n\tif Constants.plot:\r\n\t    plt.plot(range(1, GlobVar.overall_count+2), self.lin_obj_values[:GlobVar.outer_count+1], \'k-\', range(1, GlobVar.overall_count+2), self.res_lr_bounds_master[:GlobVar.outer_count+1], \'b-\')\r\n\t    plt.title(""Column generation"")\r\n\t    plt.xlabel(""Number of iterations"")\r\n\t    plt.ylabel(""Costs in Euro"")\r\n\t    plt.ylim([min(self.res_lr_bounds_master[:GlobVar.outer_count+1])-250,max(self.lin_obj_values[:GlobVar.outer_count+1])+250])\r\n\t    plt.grid(True)\r\n\t    plt.draw()\r\n\t\r\n    def show_plot(self):\r\n\tif Constants.plot:\r\n\t    plt.ioff()\r\n\t    plt.show()\r\n\t\r\n    def update_plot_lr(self):\r\n\tif Constants.plot:\r\n\t    loops = sum(Constants.inner_loops[:(GlobVar.outer_count - Constants.cg_iterations+1)])\r\n\t    self.obj_it = np.append(self.obj_it, Constants.cg_iterations-1 + loops)\r\n\t    plt.plot([x+1 for x in self.obj_it], \tself.lin_obj_values[:GlobVar.outer_count+1], \t\t\t\t\t\t\t\'k.-\',\r\n\t\t      np.arange(Constants.cg_iterations, Constants.cg_iterations+loops+1), \tnp.append(self.res_lr_bounds_master[Constants.cg_iterations-1], self.res_lr_bounds_subgradient[:loops]), \t\'r-\')\r\n\t    plt.title(""Column generation with subgradient optimization"")\r\n\t    plt.xlabel(""Number of iterations"")\r\n\t    plt.ylabel(""Costs in Euro"")\r\n\t    plt.ylim([self.res_lr_bounds_master[Constants.cg_iterations-1]-250,max(self.lin_obj_values[:GlobVar.outer_count+1])+250])\r\n\t    plt.grid(True)\r\n\t    plt.draw()\r\n\r\n    def update_plot_inner_break(self):\r\n\tif Constants.plot:\r\n\t    plt.plot(range(GlobVar.overall_count-1-GlobVar.inner_count,GlobVar.overall_count+1), self.res_lr_bounds_subgradient[GlobVar.overall_count-2-GlobVar.inner_count-Constants.cg_iterations:GlobVar.overall_count-Constants.cg_iterations], \'r-\')\r\n\t    #plt.axhline(y=self.lin_obj_values[GlobVar.outer_count-1], xmin=0, xmax=1, linewidth=1, color = \'k\')\r\n\t    plt.draw()\r\n\r\n    def update_plot_final(self, pricing_end):\r\n\tif Constants.plot:\r\n\t    plt.plot(range(pricing_end+1, pricing_end+2+GlobVar.final_count), self.int_obj_values[:GlobVar.final_count+1], \'ko\')\r\n\t    plt.ylim([self.res_lr_bounds_master[0]-250,max(self.lin_obj_values[0], self.int_obj_values[0])+250])\r\n\t    plt.draw()'"
Code/plot.py,28,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sun Nov 16 21:39:21 2014\n\n@author: T_ohne_admin \n# Solve masterproblem with binary restrictions\n(obj, lambda_chp, lambda_hp) = mp.finalize()\n\n# Retrieve optimal schedules from each house:\nx_hp = np.zeros((Constants.timesteps, len(data.hp_nom)))\nP_hp = np.zeros((Constants.timesteps, len(data.hp_nom)))\nfor i in xrange(len(data.hp_nom)):\n    (temp_x, temp_y, temp_T, temp_P) = hp[i].get_optimal_schedule(lambda_hp[:,i])\n    x_hp[:,i] = temp_x\n    P_hp[:,i] = temp_P\n\nx_chp = np.zeros((Constants.timesteps, len(data.chp_nom)))    \nP_chp = np.zeros((Constants.timesteps, len(data.chp_nom)))\nfor j in xrange(len(data.chp_nom)):\n    (temp_x, temp_y, temp_T, temp_P, temp_Q) = chp[j].get_optimal_schedule(lambda_chp[:,j])\n    x_chp[:,j] = temp_x\n    P_chp[:,j] = temp_P""""""\n\nimport matplotlib.pyplot as plt\nimport h5py\nimport time\nimport os\nimport numpy as np\nimport matplotlib.cm as cm\nimport matplotlib\nimport matplotlib.colors as mcol\nfrom constants import *\nfrom IPython.core.debugger import Tracer\nimport model_masterproblem\nimport basic_functions.read_txt as rtxt\nimport basic_functions.heating_tech\nimport heat_pumps.HP_characteristics\nimport microgrid_functions.renewables as renewables\nfrom matplotlib.ticker import MaxNLocator\n\ndef read(filename, name, indexed=True):\n    d = filename[name]\n    data = np.zeros(d.shape)\n    d.read_direct(data)\n    if indexed:\n\treturn data[data != 0]\n    else:\n\treturn data\n      \ndef mread(filename, name):\n    d = filename[name]\n    data = np.zeros(d.shape)\n    d.read_direct(data)\n    return data\n  \ndef remove_zeros(arr):\n    i = 0\n    while i < len(arr):\n\tif arr[i].all() == 0:\n\t    arr = np.delete(arr, i, 0)\n\t    i -= 1\n\ti += 1\n    return arr\n\ndef plot1a():\n    values = []\n    for day in range(0,364):\n\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\tint_file = h5py.File(Constants.path + ""/int_obj_value_""+str(day)+"".hdf5"")\n\t\n\tvalues.append([read(lr_file, ""lin_obj_values"")[-1], \n\t\t       np.concatenate((read(lr_file, ""res_lr_bounds_master""),read(lr_file, ""res_lr_bounds_sugradient"")), axis=0)[-1], \n\t\t       read(lr_file, ""int_obj_values"")[-1], \n\t\t       read(cg_file, ""lin_obj_values"")[-1],\n\t\t       read(int_file, ""cg_int_obj_value"", False),\n\t\t       read(int_file, ""lr_int_obj_value"", False),\n\t\t       read(cg_file, ""res_lr_bounds_master"")[-1]])\n\t\n\tlr_file.close()\n\tcg_file.close()\n\tint_file.close()\n\n    values = np.array(values)\n    \n    plt.rc(\'figure\', figsize=(11.69,6))\n    #f, (ax1, ax2) = plt.subplots(2, sharex=True, sharey=True)\n    \n    #l1, = plt.plot(values[:,0], ((values[:,1]-values[:,0])/values[:,0]), \'r.\')\n    ##l1, = plt.plot(values[:,0], (values[:,1]-values[:,0]), \'r.\')\n    #l2, = plt.plot(values[:,0], ((values[:,2]-values[:,0])/values[:,0]), \'k.\')\n    ##l2, = plt.plot(values[:,0], (values[:,2]-values[:,0]), \'k.\')\n    #l3, = ax1.plot(values[:,0], ((values[:,3]-values[:,0])/values[:,0]), \'bo\', markersize=8)\n    ##l3, = plt.plot(values[:,0], (values[:,3]-values[:,0]), \'b.\')\n    l4, = plt.plot(values[:,0], ((values[:,4]-values[:,0])/values[:,0]), \'b^\', markersize = 8)\n    l5, = plt.plot(values[:,0], ((values[:,5]-values[:,0])/values[:,0]), \'rv\', markersize = 8)\n    #l6, = plt.plot(values[:,0], ((values[:,6]-values[:,0])/values[:,0]), \'b.\')\n    \n    plt.yticks(fontsize = 16)\n    plt.xticks(fontsize=16)\n    plt.yticks([0.00, 0.01, 0.02, 0.03])\n    \n    plt.ylim([-0.01,0.04])\n    plt.xlabel(r\'Linear Solution (Combined Algorithm: $z_{LRDW}$) [Euro]\', fontsize = 20)\n    #ax1.set_ylabel(r\'Relative deviation\', fontsize = 20)\n    plt.ylabel(r\'Relative deviation\', fontsize = 20)\n    #ax1.legend([l3], [r\'CG: $z_{LRDW}$\'], frameon = False, fontsize = 20, numpoints=1)\n    #ax2.legend([l4, l5], [r\'CG: $z_{RDW}$\', r\'LR: $z_{RDW}$ (Pricing proposals)\'], frameon = False, fontsize = 20, numpoints=1)\n    plt.legend([l4, l5], [r\'CG: $z_{RDW}$\', r\'CGLR: $z_{RDW}$\'], frameon = False, fontsize = 20, numpoints=1)\n    plt.subplots_adjust(hspace=0, left=0.08, right=0.97)\n    #ax1.grid(True)\n    plt.grid(True)\n    plt.show()\n    \n    # 1 und 6 - LBs\n    # 4 und 5 - CG int\n    # 2 und 5 - LR int\n    \ndef plot1b():\n    values = []\n    for day in range(0,364):\n\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\tint_file = h5py.File(Constants.path + ""/int_obj_value_""+str(day)+"".hdf5"")\n\t\n\tvalues.append([read(lr_file, ""lin_obj_values"")[-1], \n\t\t       np.concatenate((read(lr_file, ""res_lr_bounds_master""),read(lr_file, ""res_lr_bounds_sugradient"")), axis=0)[-1], \n\t\t       read(lr_file, ""int_obj_values"")[-1], \n\t\t       read(cg_file, ""lin_obj_values"")[-1],\n\t\t       read(int_file, ""cg_int_obj_value"", False),\n\t\t       read(int_file, ""lr_int_obj_value"", False),\n\t\t       read(cg_file, ""res_lr_bounds_master"")[-1]])\n\t\n\tlr_file.close()\n\tcg_file.close()\n\tint_file.close()\n\n    plt.rc(\'figure\', figsize=(11.69,3.5))\n\n    \n    values = np.array(values)\n    l1, = plt.plot(values[:,0], ((values[:,1]-values[:,0])/values[:,0]), \'r<\')\n    ##l1, = plt.plot(values[:,0], (values[:,1]-values[:,0]), \'r.\')\n    #l2, = plt.plot(values[:,0], ((values[:,2]-values[:,0])/values[:,0]), \'k.\')\n    ##l2, = plt.plot(values[:,0], (values[:,2]-values[:,0]), \'k.\')\n    #l3, = plt.plot(values[:,0], ((values[:,3]-values[:,0])/values[:,0]), \'b.\')\n    ##l3, = plt.plot(values[:,0], (values[:,3]-values[:,0]), \'b.\')\n    #l4, = plt.plot(values[:,0], ((values[:,4]-values[:,0])/values[:,0]), \'g.\')\n    #l5, = plt.plot(values[:,0], ((values[:,5]-values[:,0])/values[:,0]), \'b.\')\n    l6, = plt.plot(values[:,0], ((values[:,6]-values[:,0])/values[:,0]), \'b>\')\n    \n    plt.xlabel(r\'LR: $z_{LRDW}$ [Euro]\', fontsize = 14)\n    plt.ylabel(r\'Relative deviation\', fontsize = 14)\n    plt.legend([l1, l6], [r\'LR: $z_{LR}$\', r\'CG: $z_{LR}$\'], frameon = False, loc=4, fontsize = 14, numpoints=1)\n    plt.grid(True)\n    plt.yticks(fontsize = 12)\n    plt.xticks(fontsize = 12)\n    plt.subplots_adjust(left=0.08, right=0.97, bottom=0.17)\n    plt.show()\n    \n    # 1 und 6 - LBs\n    # 4 und 5 - CG int\n    # 2 und 5 - LR int\n\ndef plot1c():\n    values = []\n    for day in range(0,364):\n\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\tint_file = h5py.File(Constants.path + ""/int_obj_value_""+str(day)+"".hdf5"")\n\t\n\tvalues.append([read(lr_file, ""lin_obj_values"")[-1], \n\t\t       np.concatenate((read(lr_file, ""res_lr_bounds_master""),read(lr_file, ""res_lr_bounds_sugradient"")), axis=0)[-1], \n\t\t       read(lr_file, ""int_obj_values"")[-1], \n\t\t       read(cg_file, ""lin_obj_values"")[-1],\n\t\t       read(int_file, ""cg_int_obj_value"", False),\n\t\t       read(int_file, ""lr_int_obj_value"", False),\n\t\t       read(cg_file, ""res_lr_bounds_master"")[-1]])\n\t\n\tlr_file.close()\n\tcg_file.close()\n\tint_file.close()\n\n    plt.rc(\'figure\', figsize=(11.69,3.5))\n    \n    values = np.array(values)\n    #l1, = plt.plot(values[:,0], ((values[:,1]-values[:,0])/values[:,0]), \'r<\')\n    ##l1, = plt.plot(values[:,0], (values[:,1]-values[:,0]), \'r.\')\n    l2, = plt.plot(values[:,0], ((values[:,2]-values[:,0])/values[:,0]), \'gD\', markersize=4)\n    ##l2, = plt.plot(values[:,0], (values[:,2]-values[:,0]), \'k.\')\n    #l3, = plt.plot(values[:,0], ((values[:,3]-values[:,0])/values[:,0]), \'b.\')\n    ##l3, = plt.plot(values[:,0], (values[:,3]-values[:,0]), \'b.\')\n    l4, = plt.plot(values[:,0], ((values[:,4]-values[:,0])/values[:,0]), \'b^\', markersize=5)\n    l5, = plt.plot(values[:,0], ((values[:,5]-values[:,0])/values[:,0]), \'rv\', markersize=5)\n    #l6, = plt.plot(values[:,0], ((values[:,6]-values[:,0])/values[:,0]), \'b>\')\n    \n    plt.xlabel(r\'LR: $z_{LRDW}$ [Euro]\', fontsize = 14)\n    plt.ylabel(r\'Relative deviation\', fontsize = 14)\n    plt.legend([l2, l5, l4], [r\'LR: $z_{RDW}$ (Final proposals)\', r\'LR: $z_{RDW}$ (Pricing proposals)\', r\'CG: $z_{RDW}$\'], frameon = False, fontsize = 14, numpoints=1)\n    plt.grid(True)\n    plt.subplots_adjust(left=0.08, right=0.97, bottom=0.17)\n    plt.yticks(fontsize = 12)\n    plt.xticks(fontsize = 12)\n    plt.show()\n    \n    # 1 und 6 - LBs\n    # 4 und 5 - CG int\n    # 2 und 5 - LR int\n\ndef compute2():\n    for day in range(0,366):\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\t\n\tcg_costs_chp = mread(cg_file, ""pricing_costs_chp"")\n\tcg_prop_chp = mread(cg_file, ""pricing_proposals_chp"")\n\tcg_prop_hp = mread(cg_file, ""pricing_proposals_hp"")\n\t\n\tcg_int_obj_value= model_masterproblem.plot_optimize(day, cg_prop_chp, cg_costs_chp, cg_prop_hp)[0]\n\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\n\tlr_p_pro_chp = mread(lr_file, ""pricing_proposals_chp"")\n\tlr_p_costs_chp = mread(lr_file, ""pricing_costs_chp"")\n\tlr_p_pro_hp = mread(lr_file, ""pricing_proposals_hp"")\n\t\n\tlr_int_obj_value = model_masterproblem.plot_optimize(day, lr_p_pro_chp, lr_p_costs_chp, lr_p_pro_hp)[0]\n\t\n\tf = h5py.File(Constants.path + ""/int_obj_value_"" + str(day) + "".hdf5"", ""w"")\n\t\n\tf.create_dataset(""cg_int_obj_value"", data = cg_int_obj_value) \n\tf.create_dataset(""lr_int_obj_value"", data = lr_int_obj_value) \n\t\n\tf.close()\n\t\ndef compute3():\n    for day in range(0,366):\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\t\n\tcg_costs_chp = mread(cg_file, ""pricing_costs_chp"")[-1]\n\tcg_prop_chp = mread(cg_file, ""pricing_proposals_chp"")[-1]\n\tcg_prop_hp = mread(cg_file, ""pricing_proposals_hp"")[-1]\n\t\n\tcg_int_obj_value= model_masterproblem.plot_optimize(day, cg_prop_chp, cg_costs_chp, cg_prop_hp)[0]\n\t\n\tf = h5py.File(Constants.path + ""/int_single_value_"" + str(day) + "".hdf5"", ""w"")\n\t\n\tf.create_dataset(""cg_int_obj_value"", data = cg_int_obj_value) \n\t\n\tf.close()\n\ndef plot2():\n    values=[]\n    for day in range(0,364):\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tvalues.append(read(lr_file, ""lin_obj_values"")[-1])\n    plt.rc(\'figure\', figsize=(11.69,3.5))\n    l1, = plt.plot(range(1,365), values, \'k-\', linewidth = 2.0)\n    plt.xlabel(r\'Time [days]\', fontsize = 14)\n    plt.ylabel(r\'LR: $z_{LRDW}$ [Euro]\', fontsize = 14)\n    plt.grid(True)\n    plt.xlim([1,365])\n    plt.subplots_adjust(left=0.08, right=0.97, bottom=0.17)\n    plt.yticks(fontsize = 12)\n    plt.xticks(fontsize = 12)\n    plt.show()\n    \ndef plot3():\n    values=[]\n    for day in range(0,364):\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tvalues.append([read(cg_file, ""sub_time"")[-1],\n\t\t       read(lr_file, ""lin_obj_values"")[-1],\n\t\t       max(max(read(lr_file, ""sub_time"")),max(read(lr_file,""master_time"")))])\n    values = np.array(values)\n    plt.rc(\'figure\', figsize=(11.69,3.5))\n    l1, = plt.plot(values[:,1], values[:,0], \'b^\', markersize=8)\n    l2, = plt.plot(values[:,1], values[:,2], \'rv\', markersize=8)\n    plt.legend([l1, l2], [r\'CG\', r\'CGLR\'], frameon = True, fontsize = 20, numpoints=1)\n    plt.ylabel(r\'Time [seconds]\', fontsize = 20)\n    plt.xlabel(r\'CGLR: $z_{LRDW}$ [Euro]\', fontsize = 20)\n    plt.subplots_adjust(left=0.08, right=0.97, bottom=0.17)\n    plt.yticks(fontsize = 16)\n    plt.xticks(fontsize = 16)\n    plt.show()\n\ndef plot4(day):\n    lr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n    x_hp = read(lr_file, ""final_hp"", False)\n    x_chp = read(lr_file, ""final_chp"", False)\n    chp_input_data = \tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/input_data_chp.csv"", delimiter = "";""))\n    hp_input_data = \tnp.transpose(rtxt.read_multiple_indexed_file(os.getcwd() + ""/input_data/input_data_hp.csv"", delimiter = "";""))\n    t_ambient = \trtxt.read_single_indexed_file(os.getcwd()  + ""/input_data/temperature.txt"")[(day*24*4):((day*24*4)+192)]\n    t_flow = basic_functions.heating_tech.heatingCurve(t_ambient+273.15) - 273.15\n    p_res = renewables.compute_renewables(rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/wind_speed.txt"")[(day*24*4):((day*24*4)+192)],\n\t\t\t\t\t\t\t      rtxt.read_single_indexed_file(os.getcwd()   + ""/input_data/sun_direct.txt"")[(day*24*4):((day*24*4)+192)],\n\t\t\t\t\t\t\t      51, 51)\n    \n    lr_p_pro_chp = mread(lr_file, ""pricing_proposals_chp"")\n    lr_p_costs_chp = mread(lr_file, ""pricing_costs_chp"")\n    lr_p_pro_hp = mread(lr_file, ""pricing_proposals_hp"")\n    lr_int_obj_value, r_hp, r_chp = model_masterproblem.plot_optimize(day, lr_p_pro_chp, lr_p_costs_chp, lr_p_pro_hp)\n\n    qnom = []\n    sigma = []\n    p_hp = []\n    for i in range(len(chp_input_data)):\n\t    p_hp.append(heat_pumps.HP_characteristics.get_hp_data(hp_input_data[i,0], t_ambient, t_flow)[1])\n\t    qnom.append(chp_input_data[i,0])\n\t    sigma.append(chp_input_data[i,1])\n    values_hp = np.zeros(192)\n    values_chp = np.zeros(192)\n    values_ie = np.zeros(192)\n    values_ie2 = np.zeros(192)\n    for i in range(51):\n\tvalues_hp += [read(lr_file,""HP_""+str(i)+""/x_f"", False)[x_hp[i]][j]*p_hp[i][j] for j in range(192)]\n\tvalues_chp += read(lr_file, ""CHP_""+str(i)+""/x_f"", False)[x_chp[i]]*sigma[i]*qnom[i]\n\tvalues_ie += read(lr_file, ""CHP_""+str(i)+""/P_f"", False)[x_chp[i]]\n\tvalues_ie += read(lr_file, ""HP_""+str(i)+""/P_f"", False)[x_hp[i]]\n\tvalues_ie2 += read(lr_file, ""HP_""+str(i)+""/P_p"", False)[int(r_hp[i])]\n\tvalues_ie2 += read(lr_file, ""CHP_""+str(i)+""/P_p"", False)[int(r_chp[i])]\n    values_ie += p_res\n    values_ie2 += p_res\n    values_ie = [values_ie[i]*0.001 for i in range(len(values_ie))]\n    values_ie2 = [values_ie2[i]*0.001 for i in range(len(values_ie2))]\n    \n    \n    #f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex=\'col\', sharey=\'row\')\n    plt.rc(\'figure\', figsize=(11.69,6))\n    f, (ax1, ax2) = plt.subplots(2, sharex=True, sharey=True)\n    l1, = ax2.step([i*0.25 for i in range(192)], values_ie2, \'k-\', linewidth=2.0)\n    l3, = ax1.step([i*0.25 for i in range(192)], values_ie, \'k-\', linewidth=2.0)\n\n    plt.xticks([0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48], fontsize = 12)\n    plt.xlim([0,47.75])\n    f.subplots_adjust(hspace=0, left=0.11, right=0.97)\n    ax2.set_xlabel(""Time [hours]"", fontsize=14)\n    ax1.grid(True)\n    ax2.grid(True)\n    ax1.set_ylabel(""$\\mathregular{P_{imp/exp}}$ [kW]"", fontsize=14)\n    ax2.set_ylabel(""$\\mathregular{P_{imp/exp}}$ [kW]"", fontsize=14)\n    plt.figtext(0.005,0.7,""(a)"", size = \'large\')\n    plt.figtext(0.005,0.3,""(b)"", size = \'large\')\n    nbins = len(ax1.get_xticklabels())\n    #ax1.yaxis.set_major_locator(MaxNLocator(nbins=nbins, prune=\'lower\'))\n    #ax2.yaxis.set_major_locator(MaxNLocator(nbins=nbins, prune=\'upper\'))\n    #plt.ylim([-175,175])\n    #plt.yticks([-150,-100,-50,0,50,100,150])\n    plt.show()\n\ndef plot5(day):\n    cg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n    lr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n    int_file = h5py.File(Constants.path + ""/int_obj_value_""+str(day)+"".hdf5"")\n    \n    cg_master_time = read(cg_file, ""master_time"")\n    cg_sub_time = read(cg_file, ""sub_time"")\n    cg_res_lr_bounds = read(cg_file, ""res_lr_bounds_master"")\n    cg_prop_chp = mread(cg_file, ""pricing_proposals_chp"")\n    cg_costs_chp = mread(cg_file, ""pricing_costs_chp"")\n    cg_prop_hp = mread(cg_file, ""pricing_proposals_hp"")\n    cg_lin_obj_values = read(cg_file, ""lin_obj_values"")\n    \n    lr_sub_time = read(lr_file, ""sub_time"")\n    lr_master_time = read(lr_file, ""master_time"")\n    lr_final_time = read(lr_file, ""final_time"")\n    lr_final_pro_chp = mread(lr_file, ""final_proposals_chp"")\n    lr_final_costs_chp = mread(lr_file, ""final_costs_chp"")\n    lr_final_pro_hp = mread(lr_file, ""final_proposals_hp"")\n    lr_lin_obj_values = read(lr_file, ""lin_obj_values"")\n    lr_bounds = read(lr_file, ""res_lr_bounds_sugradient"")\n\n    lr_int_obj_values = np.array([model_masterproblem.plot_optimize(day, lr_final_pro_chp[:j], lr_final_costs_chp[:j], lr_final_pro_hp[:j])[0] for j in range(1,6)])\n\n    cg_int_obj_value= read(int_file, ""cg_int_obj_value"", False)\n    lr_int_obj_value = read(int_file, ""lr_int_obj_value"", False)\n\n    #cg_int_single_values = np.array([model_masterproblem.plot_optimize(day, np.array([cg_prop_chp[i,:,:]]), np.array([cg_costs_chp[i,:]]), np.array([cg_prop_hp[i,:,:]]))[0] for i in range(len(cg_lin_obj_values-1))])\n\n    plt.rc(\'figure\', figsize=(11.69,3.5))\n    l1, = plt.plot(lr_master_time, \t\tlr_lin_obj_values, \t\t\'k-\', \tlinewidth = 3.0)\n    l2, = plt.plot(lr_sub_time[:-1], \t\tlr_bounds, \t\t\t\'r-\', \tlinewidth = 3.0)\n    #l3, = plt.plot(lr_final_time, \t\tlr_int_obj_values, \t\t\'gD\', markersize=4)\n    l4, = plt.plot(cg_master_time, \t\tcg_lin_obj_values, \t\t\'k--\', linewidth = 2.0)\n    l5, = plt.plot(cg_sub_time, \t\tcg_res_lr_bounds, \t\t\'b--\', linewidth = 2.0)\n    l6, = plt.plot(cg_master_time[-1], \t\tcg_int_obj_value, \t\t\'b^\', markersize=12)\n    #l7, = plt.plot(cg_master_time[1:], \t\tcg_int_single_values[:-1],\t\'k:\')\n    l8, = plt.plot(lr_master_time[-1], \t\t\tlr_int_obj_value, \t\t\'rv\', markersize=12)\n\n    plt.xlim([0,max(cg_master_time[-1]+15,max(lr_final_time)+15)])\n    plt.xlabel(""Time [seconds]"", fontsize=20)\n    plt.ylabel(""Costs [Euro]"", fontsize=20)\n    plt.ylim([min(cg_res_lr_bounds)-100,lr_lin_obj_values[0]+100])\n    #plt.legend([l1,l2, l3, l8, l4,l5, l6], [""LR: $z_{LRDW}$"",""LR: $z_{LR}$"", ""LR: $z_{RDW}$ (Final proposals)"", ""LR: $z_{RDW}$ (Pricing proposals)"", ""CG: $z_{LRDW}$"",""CG: $z_{LR}$"",""CG: $z_{RDW}$""], loc=\'center left\', fontsize=14, bbox_to_anchor=(1, 0.5), frameon=False, numpoints=1)\n    plt.legend([l1,l2, l8, l4,l5, l6], [""CGLR: $z_{LRDW}$"",""CGLR: $z_{LR}$"", ""CGLR: $z_{RDW}$"", ""CG: $z_{LRDW}$"",""CG: $z_{LR}$"",""CG: $z_{RDW}$""], loc=\'center left\', fontsize=20, bbox_to_anchor=(1, 0.5), frameon=False, numpoints=1)\n    plt.subplots_adjust(left=0.08, right=0.705, bottom=0.17)\n    plt.yticks(fontsize = 16)\n    plt.xticks(fontsize = 16)\n    plt.show()\n\n\ndef plot6(day):\n    cg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n    lr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n    \n    lr_marginals = np.concatenate((remove_zeros(mread(lr_file, ""marginals_mu_master""))[:1], remove_zeros(mread(lr_file, ""marginals_mu_subgradient""))))\n\n    cg_marginals = remove_zeros(mread(cg_file, ""marginals_mu_master""))\n\n    timesteps = lr_marginals.shape[1]\n    step_length = 0.25\n\n    plt.rc(\'figure\', figsize=(11.69,6))\n    f, (ax1, ax2) = plt.subplots(2, sharex=True, sharey=True)\n\n    # First subplot\n    cnorm = mcol.Normalize(vmin=0,vmax=len(cg_marginals)-1)\n    cpick = cm.ScalarMappable(norm=cnorm,cmap=cm.Blues)\n    cpick.set_array([])\n\n    for i in range(len(cg_marginals)):\n\tax1.step([x*step_length for x in range(timesteps)], cg_marginals[i]*100*1000, color=cpick.to_rgba(i))\n\n    plt.xlim([0,47.75])\n    plt.ylim([1,(29.21 / (100 * 3600 * 1000)*900*100*1000 + (5.00  / (100 * 3600 * 1000)*900*100*1000-1))])\n    plt.xticks([0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48])\n    plt.figtext(0.005,0.7,""(a)"", size = \'large\')\n    plt.figtext(0.005,0.3,""(b)"", size = \'large\')\n    ax1.set_title(""Shadow prices"", fontsize=20)\n    ax1.set_ylabel(""$\\mathregular{\\pi}$ [ct/kW]"", fontsize=20)\n\n    # Second Subplot\n    cnorm = mcol.Normalize(vmin=0,vmax=len(lr_marginals)-1)\n    cpick = cm.ScalarMappable(norm=cnorm,cmap=cm.Reds)\n    cpick.set_array([])\n    for i in range(len(lr_marginals)):\n\tax2.step([x*step_length for x in range(timesteps)], lr_marginals[i]*100*1000, color=cpick.to_rgba(i))\n    \n    plt.xlim([0,(timesteps-1)*step_length])\n    plt.ylim([1,(29.21 / (100 * 3600 * 1000)*900*100*1000 + (5.00  / (100 * 3600 * 1000)*900*100*1000-1))])\n    ax2.set_xlabel(""Time [hours]"", fontsize=20)\n    ax2.set_ylabel(""$\\mathregular{\\pi}$ [ct/kW]"", fontsize=20)\n    # Fine-tune figure; make subplots close to each other and hide x ticks for\n    # all but bottom plot.\n    f.subplots_adjust(hspace=0, left=0.08, right=0.97)\n    plt.setp([a.get_xticklabels() for a in f.axes[:-1]], visible=False)\n    plt.yticks(fontsize = 12)\n    plt.xticks(fontsize = 16)\n\n    plt.show()\n    \ndef show_sol():\n    values = []\n    for day in range(0,364):\n\n\tlr_file = h5py.File(Constants.path + ""/lr_""+str(day)+"".hdf5"")\n\tcg_file = h5py.File(Constants.path + ""/cg_""+str(day)+"".hdf5"")\n\tint_file = h5py.File(Constants.path + ""/int_obj_value_""+str(day)+"".hdf5"")\n\t\n\tvalues.append([read(lr_file, ""lin_obj_values"")[-1], \n\t\t       np.concatenate((read(lr_file, ""res_lr_bounds_master""),read(lr_file, ""res_lr_bounds_sugradient"")), axis=0)[-1], \n\t\t       read(lr_file, ""int_obj_values"")[-1], \n\t\t       read(cg_file, ""lin_obj_values"")[-1],\n\t\t       read(int_file, ""cg_int_obj_value"", False),\n\t\t       read(int_file, ""lr_int_obj_value"", False),\n\t\t       read(cg_file, ""res_lr_bounds_master"")[-1]])\n\t\n\tlr_file.close()\n\tcg_file.close()\n\tint_file.close()\n\n    values = np.array(values)\n    values = np.append(values, np.transpose(np.array([range(364)])), 1)\n    values = values[np.argsort(values[:,0])]\n    np.set_printoptions(threshold=np.nan)\n    for i in range(0,365):\n\t  print str(values[i,0])+""\\t""+str(values[i,2])+""\\t""+str(int(values[i,7]))'"
Code/basic_functions/__init__.py,0,b''
Code/basic_functions/heating_tech.py,7,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Mon Jun 30 15:03:32 2014\r\n\r\n@author: tsz\r\n\r\nThis module contains a few handy functions:\r\n    - Computation of the flow temperature according to a given heating curve\r\n    - Interpolation in a given device characteristic curve\r\n""""""\r\n\r\nimport numpy as np\r\nimport mathfunctions as mf\r\n\r\ndef heatingCurve(ambient_temp, m=0.33, set_room=293.15, set_ambient=263.15, set_flow=273.15+55, set_return=273.15+45):\r\n    """""" This function is a straight-forward implementation of the heatingCurve \r\n        algorithm of our Modelica library (Cities.Supply.BaseClasses.heatingCurve)\r\n    The parameters are:\r\n        ambient_temperature: Temperature time series in K \r\n            (Note: ambient_temperature should be a 1-dimensional numpy-array)\r\n            \r\n        m:                   Heater characteristic. Normally: 0.25 <= m <= 0.40 \r\n\r\n        set_room:            Room\'s set temperature in K\r\n\r\n        set_ambient:         Nominal ambient temperature in K\r\n\r\n        set_flow:            Nominal heater flow temperature in K\r\n\r\n        set_return:          Nominal heater return temperature in K\r\n    """"""\r\n\r\n    # Determine design room excess temperature\r\n    dTmN = (set_flow + set_return)/2 - set_room\r\n        \r\n    # Calculate design temperature spread of heating system\r\n    dTN  = set_flow - set_return   \r\n\r\n    # Compute load situation of heating system (parameter phi)\r\n    phi = np.zeros_like(ambient_temp)\r\n    phi[ambient_temp <= set_room] = (set_room - ambient_temp[ambient_temp <= set_room]) / (set_room - set_ambient)\r\n\r\n    # Compute flow temperature according to heating curve    \r\n    flow_temp = np.power(phi, 1/(1 + m))*dTmN + 0.5*phi*dTN + set_room\r\n    \r\n    return flow_temp\r\n    \r\n# How to use this function\r\n#tamb = 273.15 + 30 * (np.random.rand((100))-0.5)\r\n#tflow = heatingCurve(tamb)\r\n\r\ndef interpolateQ(t_amb, t_amb_set, q_set):\r\n    """""" Compute nominal heat outputs for ambient temperature levels that are \r\n        not equal to the ones defined for the device\'s characteristics.\r\n        Example: Heat pump manufacturers publish the heat output at 2 \xc2\xb0C and \r\n                 7 \xc2\xb0C ambient temperature, but the current outside temperature\r\n                 is 4.5 \xc2\xb0C.\r\n    Parameters:\r\n        t_amb:      List/Array holding the outside temperatures in \xc2\xb0C\r\n\r\n        t_amb_set:  List/Array of temperature levels defined in the \r\n                        characteristic curves in \xc2\xb0C\r\n\r\n        q_set:      List/Array with heat output defined in the characteristic\r\n                        curves in W\r\n    """"""\r\n\r\n    # Initialize result array\r\n    q_result = np.zeros_like(t_amb)\r\n    \r\n    for i in range(np.size(t_amb)):\r\n        # Determine the right interval for the interpolation\r\n        j = 1\r\n        while (j < np.size(t_amb_set)-1) and (t_amb[i] > t_amb_set[j]):\r\n            j = j + 1\r\n            \r\n        # Interpolate the heat output at the given ambient temperature\r\n        q_result[i] = mf.interpolation(t_amb[i], [t_amb_set[j-1], t_amb_set[j]], [q_set[j-1], q_set[j]])\r\n    \r\n    return q_result\r\n\r\n# How to use this function    \r\n#t_amb_set = [-20, -15, -7, 2, 7, 10, 12, 20]\r\n#q_set = [4.89, 5.87, 7.60, 9.60, 11.40, 11.70, 12.20, 13.60]\r\n#q = interpolateQ([11, 17.5], t_amb_set, q_set)\r\n\r\ndef heater_nominals(t_flow, val_35, val_55):\r\n    """"""\r\n        Compute the nominal output/consumption at the given flow temperature\r\n        Inputs: (All arrays!)\r\n            t_flow: Flow temperature in \xc2\xb0C\r\n            \r\n            val_35: Q_35 or P_35 for all time steps\r\n            \r\n            val_55: Q_55 or P_55 for all time steps\r\n    """"""\r\n    val_out = np.zeros_like(t_flow)\r\n    val_out[t_flow <= 35] = val_35[t_flow <= 35]\r\n    val_out[t_flow >= 55] = val_55[t_flow >= 55]\r\n    indexes = (t_flow > 35) * (t_flow < 55)\r\n    val_out[indexes] = val_35[indexes] + (val_55[indexes] - val_35[indexes]) * (t_flow[indexes] - 35) / 20\r\n    \r\n    return val_out'"
Code/basic_functions/mathfunctions.py,0,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Aug 06 08:51:04 2014\r\n\r\n@author: tsz\r\n""""""\r\n\r\nimport numpy as np\r\n\r\ndef interpolation(x_set, x, y):\r\n    """""" Interpolate x,y and to compute y_set at a given x_set \r\n        The parameters are:\r\n        x_set:  Set value for the interpolation\r\n        x:      List/Array with two entries. The first is for the lower x-value, the second for the upper x-value\r\n        y:      List/Array with two entries that correspond to the lower x-value and the higher x-value\r\n    """"""\r\n    \r\n    y_set = y[0] + float(x_set - x[0]) / (x[1] - x[0]) * (y[1] - y[0])\r\n    \r\n    return y_set'"
Code/basic_functions/read_txt.py,2,"b'#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Jun 11 09:45:32 2014\r\n\r\n@author: tsz\r\n""""""\r\n\r\n# Imports\r\nimport csv\r\nimport numpy as np\r\n\r\ndef read_single_indexed_file(path, delimiter = \'\\t\'):\r\n    """"""\r\n    This function receives a filename and returns a list with the values of this file\r\n    """"""\r\n     \r\n    with open(path, \'rb\') as input:\r\n        reader = csv.reader(input, delimiter=delimiter)\r\n        result = []\r\n        for row in reader:\r\n            result.append(float(row[len(row)-1]))\r\n            \r\n    return np.array(result)\r\n    \r\ndef read_multiple_indexed_file(path, delimiter = \'\\t\'):\r\n    """"""\r\n    This function receives a filename and returns a list with the values of this file\r\n    """"""\r\n     \r\n    with open(path, \'rb\') as input:\r\n        reader = csv.reader(input, delimiter=delimiter)\r\n        result = []\r\n        for row in reader:\r\n            temp = []\r\n            for i in xrange(0,len(row)):\r\n                temp.append(float(row[i]))\r\n                \r\n            result.append(temp)\r\n            \r\n    return np.array(result)\r\n   \r\ndef write_single_indexed_file(path, data, delimiter = \'\\t\'):\r\n    """"""\r\n    This function writes the given data (array) into the specified path\r\n    """"""\r\n    \r\n    length = len(data)\r\n        \r\n    with open(path, \'wb\') as f:\r\n        writer = csv.writer(f, delimiter = delimiter)\r\n        for i in range(length):\r\n            writer.writerow((i+1, data[i]))'"
Code/heat_pumps/HP_characteristics.py,31,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Wed Aug 06 12:34:23 2014\r\n\r\n@author: tsz\r\n\r\nThis file contains a few characteristic curves of real HP units\r\n""""""\r\n\r\nfrom __future__ import division\r\nimport numpy as np\r\nimport basic_functions.heating_tech\r\nfrom constants import *\r\n\r\nclass LA12TU(): # http://www.dimplex.de/pdf/de/produktattribute/produkt_1725609_extern_egd.pdf\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[4.89, 4.7,   4.5], \r\n                  [5.87, 5.7,   5.5], \r\n                  [7.6,  7.35,  7.17],\r\n                  [9.6,  9.1,   8.8],\r\n                  [11.4, 10.85, 9.8],\r\n                  [11.7, 11.2,  10.6],\r\n                  [12.2, 11.4,  10.9],\r\n                  [13.6, 12.8,  12.39]])\r\n                  \r\n    cop = np.array([[1.91, 1.48, 1.20], \r\n                    [2.28, 1.77, 1.45], \r\n                    [3.00, 2.30, 1.88],\r\n                    [3.70, 2.84, 2.32],\r\n                    [4.30, 3.42, 2.50],\r\n                    [4.60, 3.53, 2.75],\r\n                    [4.78, 3.56, 2.87],\r\n                    [5.33, 4.06, 3.30]])\r\n               \r\n    P = Q / cop\r\n\r\nclass LA9TU(): # http://www.dimplex.de/pdf/de/produktattribute/produkt_1725608_extern_egd.pdf\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[2.96,   2.26,  2.03], \r\n                  [3.73,   3.15,  2.78], \r\n                  [5.50,   4.56,  3.98],\r\n                  [7.50,   6.53,  5.88],\r\n                  [9.20,   8.21,  7.10],\r\n                  [10.20,  8.88,  7.81],\r\n                  [11.45, 10.29,  9.11],\r\n                  [12.70, 11.70, 10.40]])\r\n               \r\n    cop = np.array([[1.86, 1.42, 1.28], \r\n                    [2.16, 1.79, 1.51], \r\n                    [2.80, 2.28, 1.87],\r\n                    [3.70, 2.86, 2.45],\r\n                    [4.20, 3.62, 2.70],\r\n                    [4.50, 3.55, 2.95],\r\n                    [4.77, 4.04, 3.31],\r\n                    [5.29, 4.33, 3.48]])\r\n               \r\n    P = Q / cop\r\n  \r\nclass LA6TU():\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[2.38,   2.28,  1.84], # Q(-20\xc2\xb0C, W55) interpoliert\r\n                  [2.97,   2.83,  2.52], # Q(-15\xc2\xb0C, W55) interpoliert\r\n                  [4.00,   3.76,  3.61],\r\n                  [5.10,   4.84,  4.66],\r\n                  [6.40,   6.10,  5.68],\r\n                  [6.70,   6.30,  6.00],\r\n                  [7.00,   6.40,  6.20],\r\n                  [8.04,   7.67,  7.29]])\r\n               \r\n    cop = np.array([[1.79, 1.44, 1.04], # COP(-20\xc2\xb0C, W55) interpoliert\r\n                    [2.20, 1.75, 1.36], # COP(-15\xc2\xb0C, W55) interpoliert\r\n                    [2.90, 2.22, 1.81],\r\n                    [3.80, 2.84, 2.25],\r\n                    [4.60, 3.50, 2.73],\r\n                    [4.70, 3.62, 2.83],\r\n                    [4.93, 3.66, 2.91],\r\n                    [5.66, 4.41, 3.41]])\r\n               \r\n    P = Q / cop\r\n  \r\nclass LA17TU():\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[4.00,    3.65,   3.30],\r\n                  [4.90,    4.50,   4.00],\r\n                  [5.40,    5.70,   5.35],\r\n                  [8.20,    7.90,   7.60],\r\n                  [10.00,   9.57,   9.20],\r\n                  [10.50,   10.15,  9.80],\r\n                  [11.00,   10.50,  10.10],\r\n                  [13.00,   12.50,  12.00]])\r\n               \r\n    cop = np.array([[1.92, 1.45, 1.09],\r\n                    [2.33, 1.80, 1.31],\r\n                    [3.00, 2.25, 1.76],\r\n                    [3.80, 3.11, 2.49],\r\n                    [4.50, 3.75, 2.80],\r\n                    [4.90, 3.95, 3.18],\r\n                    [5.24, 4.04, 3.26],\r\n                    [6.05, 4.72, 3.81]])\r\n               \r\n    P = Q / cop\r\n  \r\nclass LA25TU():\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[6.20,   5.50,  4.91],\r\n                  [7.50,   7.00,  6.10],\r\n                  [9.10,   8.46,  7.84],\r\n                  [11.30,  10.70, 10.10],\r\n                  [13.90,  13.16, 12.40],\r\n                  [15.00,  14.06, 13.27],\r\n                  [15.80,  15.00, 14.00],\r\n                  [19.20,  18.00, 17.00]])\r\n               \r\n    cop = np.array([[2.07, 1.49, 1.14],\r\n                    [2.50, 1.92, 1.42],\r\n                    [3.00, 2.29, 1.78],\r\n                    [3.80, 2.85, 2.24],\r\n                    [4.50, 3.46, 2.80],\r\n                    [4.90, 3.61, 2.98],\r\n                    [4.86, 3.85, 3.11],\r\n                    [5.82, 4.50, 3.70]])\r\n               \r\n    P = Q / cop\r\n  \r\nclass LA40TU():\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[10.78,  10.09, 9.41],\r\n                  [11.83,  11.11, 10.39],\r\n                  [13.50,  12.73, 11.96],\r\n                  [16.80,  16.00, 15.19],\r\n                  [20.00,  18.80, 17.60],\r\n                  [21.70,  19.75, 18.43],\r\n                  [22.67,  21.17, 19.68],\r\n                  [26.20,  25.00, 23.00]])\r\n               \r\n    cop = np.array([[2.53, 1.84, 4.41],\r\n                    [2.76, 2.03, 1.56],\r\n                    [3.10, 2.33, 1.81],\r\n                    [3.90, 2.94, 2.31],\r\n                    [4.60, 3.47, 2.70],\r\n                    [4.90, 3.59, 2.93],\r\n                    [5.19, 3.88, 3.01],\r\n                    [5.95, 4.55, 3.41]])\r\n               \r\n    P = Q / cop\r\n  \r\nclass LA60TU():\r\n    t_ambient = np.array([-20, -15, -7, 2, 7, 10, 12, 20])\r\n    t_flow = np.array([35, 45, 55])\r\n    Q = np.array([[11.75,   12.56,  14.15], # Q(-20\xc2\xb0C, W35) interpoliert\r\n                  [15.39,   15.12,  13.22], # Q(-15\xc2\xb0C, W35) interpoliert\r\n                  [21.20,   17.84,  17.04],\r\n                  [26.40,  23.90, 23.45],\r\n                  [31.90,  23.79, 28.30],\r\n                  [33.60,  32.50, 30.70],\r\n                  [35.00,  34.60, 32.10],\r\n                  [40.81,  40.11, 36.59]]) # Q(20\xc2\xb0C, W35/45/55) interpoliert\r\n               \r\n    cop = np.array([[2.11, 1.72, 1.72], # COP(-20\xc2\xb0C, W35) interpoliert\r\n                    [2.45, 1.99, 1.57], # COP(-15\xc2\xb0C, W35) interpoliert\r\n                    [3.00, 2.28, 1.92],\r\n                    [3.70, 2.81, 2.44],\r\n                    [4.30, 3.34, 2.9],\r\n                    [4.40, 3.65, 3.04],\r\n                    [4.38, 3.84, 3.15],\r\n                    [4.85, 4.20, 3.60]])\r\n               \r\n    P = Q / cop\r\n    \r\ndef get_hp_data(Q_nom, t_ambient, t_flow):\r\n    \r\n    # Wie HP ausw\xc3\xa4hlen? Kleinste Differenz oder n\xc3\xa4chst gr\xc3\xb6\xc3\x9fere/kleiner?\r\n    # Was genau ist eigentlich Q_nom????\r\n    \r\n    hps = []\r\n    hps.append(LA12TU())\r\n    hps.append(LA9TU())\r\n    hps.append(LA6TU())\r\n    hps.append(LA17TU())\r\n    hps.append(LA25TU())\r\n    hps.append(LA40TU())\r\n    hps.append(LA60TU())\r\n    \r\n    min_diff = 999999\r\n    for data in hps:\r\n\tQ_nom_35 = \t\tbasic_functions.heating_tech.interpolateQ(np.array([Constants.t_bivalent]), data.t_ambient, data.Q[:,0]) *1000\r\n\tQ_nom_55 = \t\tbasic_functions.heating_tech.interpolateQ(np.array([Constants.t_bivalent]), data.t_ambient, data.Q[:,-1]) *1000\r\n\tbivalent_t_flow = \tbasic_functions.heating_tech.heatingCurve(np.array([Constants.t_bivalent])+273.15) - 273.15\r\n\tdiff = \t\t\tabs(basic_functions.heating_tech.heater_nominals(bivalent_t_flow, Q_nom_35, Q_nom_55) - Q_nom)\r\n\t\r\n\tif diff < min_diff:\r\n\t    min_diff = diff\r\n\t    hp = data\r\n\r\n    Q_nom_35 = basic_functions.heating_tech.interpolateQ(t_ambient, hp.t_ambient, hp.Q[:,0]) *1000\r\n    Q_nom_55 = basic_functions.heating_tech.interpolateQ(t_ambient, hp.t_ambient, hp.Q[:,-1]) *1000\r\n    P_nom_35 = basic_functions.heating_tech.interpolateQ(t_ambient, hp.t_ambient, hp.P[:,0]) *1000\r\n    P_nom_55 = basic_functions.heating_tech.interpolateQ(t_ambient, hp.t_ambient, hp.P[:,-1]) *1000\r\n    \r\n    return (basic_functions.heating_tech.heater_nominals(t_flow, Q_nom_35, Q_nom_55),\r\n\t    basic_functions.heating_tech.heater_nominals(t_flow, P_nom_35, P_nom_55))\r\n\r\n\t'"
Code/heat_pumps/__init__.py,0,b''
Code/microgrid_functions/__init__.py,0,b''
Code/microgrid_functions/renewables.py,1,"b'# -*- coding: utf-8 -*-\r\n""""""\r\nCreated on Sun Nov 16 10:47:42 2014\r\n\r\n@author: T_ohne_admin\r\n""""""\r\n\r\nimport math\r\nimport numpy as np\r\n\r\n# Compute the sum of available PV and wind energy\r\n\r\ndef compute_renewables(wind_speed, \t\t# wind_speed --> Array of the current wind speed forecast in Watt\r\n\t\t       solar_irradiation,\t# solar_irradiation --> Array of the current solar_irradiation forecast in Watt\r\n\t\t       hp_number,\r\n\t\t       chp_number):\t\r\n\r\n    wind_cut_in = 2.0\t\t\t#2\t\twind_cut_in  --> Cut in speed in m/s\r\n    wind_cut_out = 25.0\t\t\t#25\t\twind_cut_out --> Cut out speed in m/s\r\n    wind_nominal = 11.0\t\t\t#17\t\twind_nominal --> Nominal wind speed in m/s\r\n    solar_area = 20.0\t\t\t#145\t\tsolar_area   --> Area of installed PV modules in m2 / House\r\n    solar_efficiency = 0.22\t\t#0.22\t\tsolar_efficiency --> Efficiency of the PV modules\r\n    diameter_rotor = 12.0\r\n    A_wind = 0.25 * math.pi * diameter_rotor**2\r\n    number_wind_turbines = 5.0\r\n    eta_wind = 0.42\r\n    \r\n    # PV production\r\n    solar = (hp_number + chp_number) * solar_area * solar_efficiency * solar_irradiation\r\n        \r\n    # Compute wind energy production\r\n    wind = np.zeros_like(wind_speed)\r\n    \r\n    index_nominal = (wind_speed >= wind_nominal) * (wind_speed < wind_cut_out)\r\n    wind[index_nominal] = 0.5 * 1 * wind_nominal**3 * A_wind * eta_wind * number_wind_turbines\r\n    \r\n    index_partial_load = (wind_speed >= wind_cut_in) * (wind_speed < wind_nominal)\r\n    wind[index_partial_load] = 0.5 * 1 * wind_speed[index_partial_load]**3 * A_wind * eta_wind * number_wind_turbines\r\n    \r\n    return solar+wind'"
