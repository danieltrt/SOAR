file_path,api_count,code
assets.py,0,"b'from os.path import join\n\nfrom pygame.image import load\n\nevent_sound = join(""sounds"", ""event.ogg"")\ndisc_drop_1 = join(""sounds"", ""disc_drop_1.wav"")\ndisc_drop_2 = join(""sounds"", ""disc_drop_2.wav"")\nred_coin = load(join(""images"", ""redball90px.png""))\nyellow_coin = load(join(""images"", ""yellowball90px.png""))\nblack_coin = load(join(""images"", ""blackball91px.png""))\n'"
config.py,0,"b'# Colors\nyellow = (255, 255, 0)\nred = (255, 0, 0)\nblue = (0, 0, 255)\nwhite = (255, 255, 255)\nblack = (0, 0, 0)\n'"
connect_game.py,0,"b'import math\nimport os\nimport sys\n\nimport pygame\n\nfrom config import black\nfrom events import GameOver, MouseClickEvent, PieceDropEvent, bus\nfrom game_data import GameData\nfrom game_renderer import GameRenderer\n\n\nclass ConnectGame:\n    """"""\n    Holds all of the game logic and game data.\n    """"""\n\n    game_data: GameData\n    renderer: GameRenderer\n\n    def __init__(self, game_data: GameData, renderer: GameRenderer):\n        """"""\n        Initializes the connect game.\n        :param game_data: A reference to the game data object.\n        :param renderer: A reference to the game renderer.\n        """"""\n        self.game_data = game_data\n        self.renderer = renderer\n\n    def quit(self):\n        """"""\n        Exits the game.\n        """"""\n        sys.exit()\n\n    @bus.on(""mouse:click"")\n    def mouse_click(self, event: MouseClickEvent):\n        """"""\n        Handles a mouse click event.\n        :param event: Data about the mouse click\n        """"""\n        pygame.draw.rect(\n            self.renderer.screen,\n            black,\n            (0, 0, self.game_data.width, self.game_data.sq_size),\n        )\n\n        col: int = int(math.floor(event.posx / self.game_data.sq_size))\n\n        if self.game_data.game_board.is_valid_location(col):\n            row: int = self.game_data.game_board.get_next_open_row(col)\n\n            self.game_data.last_move_row.append(row)\n            self.game_data.last_move_col.append(col)\n            self.game_data.game_board.drop_piece(row, col, self.game_data.turn + 1)\n\n            self.draw()\n\n            bus.emit(\n                ""piece:drop"", PieceDropEvent(self.game_data.game_board.board[row][col])\n            )\n\n            self.print_board()\n\n            if self.game_data.game_board.winning_move(self.game_data.turn + 1):\n                bus.emit(\n                    ""game:over"", self.renderer, GameOver(False, self.game_data.turn + 1)\n                )\n                self.game_data.game_over = True\n\n            pygame.display.update()\n\n            self.game_data.turn += 1\n            self.game_data.turn = self.game_data.turn % 2\n\n    @bus.on(""game:undo"")\n    def undo(self):\n        """"""\n        Handles the Ctrl+Z keyboard sequence, which\n        is used to roll back the last move.\n        :return:\n        """"""\n        if self.game_data.last_move_row:\n            self.game_data.game_board.drop_piece(\n                self.game_data.last_move_row.pop(),\n                self.game_data.last_move_col.pop(),\n                0,\n            )\n\n        self.game_data.turn += 1\n        self.game_data.turn = self.game_data.turn % 2\n\n    def update(self):\n        """"""\n        Checks the game state, dispatching events as needed.\n        """"""\n        if self.game_data.game_board.tie_move():\n            bus.emit(""game:over"", self.renderer, GameOver(was_tie=True))\n\n            self.game_data.game_over = True\n\n        if self.game_data.game_over:\n            print(os.getpid())\n            pygame.time.wait(1000)\n            os.system(""game.py"")\n\n    def draw(self):\n        """"""\n        Directs the game renderer to \'render\' the game state to the audio and video devices.\n        """"""\n        self.renderer.draw(self.game_data)\n\n    def print_board(self):\n        """"""\n        Prints the state of the board to the console.\n        """"""\n        self.game_data.game_board.print_board()\n'"
events.py,0,"b'""""""\nHolds the global event bus and the classes holding data for the event messages.\n""""""\n\nfrom event_bus import EventBus\n\nbus = EventBus()\n\n\nclass MouseHoverEvent:\n    """"""\n    Fired when a user has moved their mouse to place a piece.\n    """"""\n\n    def __init__(self, posx):\n        self.posx = posx\n\n\nclass MouseClickEvent:\n    """"""\n    Fired when the user has clicked the mouse.\n    """"""\n\n    def __init__(self, posx):\n        self.posx = posx\n\n\nclass GameOver:\n    """"""\n    Fired when the game is over, including tie games.\n    """"""\n\n    def __init__(self, was_tie=True, winner=None):\n        self.was_tie = was_tie\n        self.winner = winner\n\n\nclass PieceDropEvent:\n    """"""\n    Fired when a game piece is dropped into an open slot.\n    """"""\n\n    def __init__(self, side):\n        self.side = side\n'"
game.py,0,"b'import sys\n\nimport pygame\nfrom pygame.locals import KEYDOWN\n\nfrom config import black, blue, white\nfrom connect_game import ConnectGame\nfrom events import MouseClickEvent, MouseHoverEvent, bus\nfrom game_data import GameData\nfrom game_renderer import GameRenderer\n\n\ndef quit():\n    sys.exit()\n\n\ndef start():\n    data = GameData()\n    screen = pygame.display.set_mode(data.size)\n    game = ConnectGame(data, GameRenderer(screen, data))\n\n    game.print_board()\n    game.draw()\n\n    pygame.display.update()\n    pygame.time.wait(1000)\n\n    # Processes mouse and keyboard events, dispatching events to the event bus.\n    # The events are handled by the ConnectGame and GameRenderer classes.\n    while not game.game_data.game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game.quit()\n\n            if event.type == pygame.MOUSEMOTION:\n                bus.emit(""mouse:hover"", game.renderer, MouseHoverEvent(event.pos[0]))\n\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                bus.emit(""mouse:click"", game, MouseClickEvent(event.pos[0]))\n\n            if event.type == KEYDOWN:\n                if event.key == pygame.K_z:\n                    mods: int = pygame.key.get_mods()\n                    if mods & pygame.KMOD_CTRL:\n                        bus.emit(""game:undo"", game)\n\n            game.update()\n            game.draw()\n\n\ndef text_objects(text, font, color):\n    textSurface = font.render(text, True, color)\n    return textSurface, textSurface.get_rect()\n\n\ndef message_display(text, color, p, q, v):\n    largeText = pygame.font.SysFont(""monospace"", v)\n    TextSurf, TextRect = text_objects(text, largeText, color)\n    TextRect.center = (p, q)\n    screen.blit(TextSurf, TextRect)\n\n\npygame.init()\nscreen = pygame.display.set_mode(GameData().size)\npygame.display.set_caption(""Connect Four | Mayank Singh"")\nmessage_display(""CONNECT FOUR!!"", white, 350, 150, 75)\nmessage_display(""HAVE FUN!"", (23, 196, 243), 350, 300, 75)\n\nrunning = True\nwhile running:\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    def button(msg, x, y, w, h, ic, ac, action=None):\n        mouse = pygame.mouse.get_pos()\n        click = pygame.mouse.get_pressed()\n\n        if x + w > mouse[0] > x and y + h > mouse[1] > y:\n            pygame.draw.rect(screen, ac, (x, y, w, h))\n\n            if click[0] == 1 and action != None:\n                action()\n        else:\n            pygame.draw.rect(screen, ic, (x, y, w, h))\n\n        smallText = pygame.font.SysFont(""monospace"", 30)\n        textSurf, textRect = text_objects(msg, smallText, white)\n        textRect.center = ((x + (w / 2)), (y + (h / 2)))\n        screen.blit(textSurf, textRect)\n\n    button(""PLAY!"", 150, 450, 100, 50, white, white, start)\n    button(""PLAY"", 152, 452, 96, 46, black, black, start)\n    button(""QUIT"", 450, 450, 100, 50, white, white, quit)\n    button(""QUIT"", 452, 452, 96, 46, black, black, quit)\n    pygame.display.update()\n'"
game_board.py,0,"b'from numpy import flip, zeros\nfrom numpy.core._multiarray_umath import ndarray\n\n\nclass GameBoard:\n    """"""\n    The GameBoard class holds the state of the game board,\n    and methods to manipulate and query the board.\n    """"""\n\n    board: ndarray\n    cols: int\n    rows: int\n\n    def __init__(self, rows=6, cols=7):\n        """"""\n        Initializes the game board.\n        :param rows: The height of the board in rows.\n        :param cols: The width of the boarrd in columns.\n        """"""\n        self.rows = rows\n        self.cols = cols\n        self.board = zeros((rows, cols))\n\n    def print_board(self):\n        """"""\n        Prints the state of the board to the console.\n        """"""\n        print(flip(self.board, 0))\n        print("" ---------------------"")\n        print("" "" + str([1, 2, 3, 4, 5, 6, 7]))\n\n    def drop_piece(self, row, col, piece):\n        """"""\n        Drops a piece into the slot at position (row, col)\n        :param row: The row of the slot.\n        :param col: The column of the slot.\n        :param piece: The piece to drop.\n        """"""\n        self.board[row][col] = piece\n\n    def is_valid_location(self, col):\n        """"""\n        Returns whether the position exists on the board.\n        :param col: The column to check.\n        :return: Whether the specified column exists on the board.\n        """"""\n        return self.board[self.rows - 1][col] == 0\n\n    def get_next_open_row(self, col):\n        """"""\n        Returns the next free row for a column.\n        :param col: The column to check for a free space.\n        :return: The next free row for a column.\n        """"""\n        for row in range(self.rows):\n            if self.board[row][col] == 0:\n                return row\n\n    def check_square(self, piece, r, c):\n        """"""\n        Checks if a particular square is a certain color.  If\n        the space is off of the board it returns False.\n\n        :param piece: The piece color to look for.\n        :param r: The row to check.\n        :param c: The column to check.\n        :return: Whether the square is on the board and has the color/piece specified.\n        """"""\n        if r < 0 or r >= self.rows:\n            return False\n\n        if c < 0 or c >= self.cols:\n            return False\n\n        return self.board[r][c] == piece\n\n    def horizontal_win(self, piece, r, c):\n        """"""\n        Checks if there is a horizontal win at the position (r,c)\n        :param piece: The color of the chip to check for.\n        :param r: The row.\n        :param c: The column.\n        :return: Whether there is a horizontal win at the position (r, c).\n        """"""\n        return (\n            self.check_square(piece, r, c)\n            and self.check_square(piece, r, c + 1)\n            and self.check_square(piece, r, c + 2)\n            and self.check_square(piece, r, c + 3)\n        )\n\n    def vertical_win(self, piece, r, c):\n        """"""\n        Checks if there is vertical win at the position (r, c)\n        :param piece: The color of the chip to check for.\n        :param r: The row\n        :param c: The column\n        :return: Whether there is a vertical win at the position (r, c)\n        """"""\n        return (\n            self.check_square(piece, r, c)\n            and self.check_square(piece, r + 1, c)\n            and self.check_square(piece, r + 2, c)\n            and self.check_square(piece, r + 3, c)\n        )\n\n    def diagonal_win(self, piece, r, c):\n        """"""\n        Checks if there is a diagonal_win at the position (r, c)\n        :param piece: The color of the chip to check for.\n        :param r: The row\n        :param c: The column\n        :return: Whether there is a diagonal win at the position (r,c)\n        """"""\n        return (\n            self.check_square(piece, r, c)\n            and self.check_square(piece, r + 1, c + 1)\n            and self.check_square(piece, r + 2, c + 2)\n            and self.check_square(piece, r + 3, c + 3)\n        ) or (\n            self.check_square(piece, r, c)\n            and self.check_square(piece, r - 1, c + 1)\n            and self.check_square(piece, r - 2, c + 2)\n            and self.check_square(piece, r - 3, c + 3)\n        )\n\n    def winning_move(self, piece):\n        """"""\n        Checks if the current piece has won the game.\n        :param piece: The color of the chip to check for.\n        :return: Whether the current piece has won the game.\n        """"""\n        for c in range(self.cols):\n            for r in range(self.rows):\n                if (\n                    self.horizontal_win(piece, r, c)\n                    or self.vertical_win(piece, r, c)\n                    or self.diagonal_win(piece, r, c)\n                ):\n                    return True\n        return False\n\n    def tie_move(self):\n        """"""\n        Checks for a tie game.\n        :return:  Whether a tie has occurred.\n        """"""\n        slots_filled: int = 0\n\n        for c in range(self.cols):\n            for r in range(self.rows):\n                if self.board[r][c] != 0:\n                    slots_filled += 1\n\n        return slots_filled == 42\n'"
game_data.py,0,"b'from typing import Tuple\n\nfrom game_board import GameBoard\n\n\nclass GameData:\n    """"""\n    The game data class contains all of the data for the game.\n    """"""\n\n    radius: int\n    height: int\n    width: int\n    sq_size: int\n    size: Tuple[int, int]\n    game_over: bool\n    turn: int\n    last_move_row: [int]\n    last_move_col: [int]\n    game_board: GameBoard\n\n    def __init__(self):\n        self.game_over = False\n        self.turn = 0\n        self.last_move_row = []\n        self.last_move_col = []\n        self.game_board = GameBoard()\n        self.action = None\n\n        self.sq_size: int = 100\n        self.width: int = 7 * self.sq_size\n        self.height: int = 7 * self.sq_size\n        self.size: Tuple[int, int] = (self.width, self.height)\n        self.radius: int = int(self.sq_size / 2 - 5)\n'"
game_renderer.py,0,"b'import os\nfrom typing import Any, Optional, Union\n\nimport pygame\nfrom pygame import mixer\nfrom pygame.font import FontType\nfrom pygame.ftfont import Font\nfrom pygame.gfxdraw import aacircle, filled_circle\n\nfrom assets import (black_coin, disc_drop_1, disc_drop_2, event_sound,\n                    red_coin, yellow_coin)\nfrom config import black, blue, red, white, yellow\nfrom events import GameOver, MouseHoverEvent, PieceDropEvent, bus\nfrom game_data import GameData\n\n\n@bus.on(""piece:drop"")\ndef on_piece_drop(event: PieceDropEvent):\n    """"""\n    Plays a sound when a piece is dropped over an empty slot.\n    :param event: Information about the drop, namely the slot where the piece was dropped.\n    """"""\n    if event.side == 1:\n        mixer.music.load(disc_drop_1)\n        mixer.music.play(0)\n\n    if event.side == 2:\n        mixer.music.load(disc_drop_2)\n        mixer.music.play(0)\n\n\nclass GameRenderer:\n    """"""\n    Renders the current game state to the screen and the speakers.\n    """"""\n\n    game_data: GameData\n    label: Optional[Any]\n    myfont: Union[None, Font, FontType]\n\n    def __init__(self, screen, game_data: GameData):\n        """"""\n        Initializes the game renderer.\n        :param screen: The screen.\n        :param game_data: All of the data for the game.\n        """"""\n        self.myfont = pygame.font.SysFont(""monospace"", 75)\n        self.label = self.myfont.render(""CONNECT FOUR!!"", 1, white)\n        screen.blit(self.label, (40, 10))\n        self.screen = screen\n        self.game_data = game_data\n\n        pygame.display.set_caption(""Connect Four | Mayank Singh"")\n        pygame.display.update()\n\n    @bus.on(""mouse:hover"")\n    def on_mouse_move(self, event: MouseHoverEvent):\n        """"""\n        Draws a coin over the slot that the mouse is positioned.\n        :param event: Information about the hover, namely the x position\n        """"""\n        posx = event.posx\n\n        pygame.draw.rect(\n            self.screen, black, (0, 0, self.game_data.width, self.game_data.sq_size)\n        )\n        self.draw_coin(\n            self.game_data,\n            posx - (self.game_data.sq_size / 2),\n            int(self.game_data.sq_size) - self.game_data.sq_size + 5,\n        )\n\n    def draw_red_coin(self, x, y):\n        """"""\n        Draws a red coin.\n        :param x: The x position to draw the coin.\n        :param y: The y position to draw the coin.\n        """"""\n        self.screen.blit(red_coin, (x, y))\n\n    def draw_yellow_coin(self, x, y):\n        """"""\n        Draws a yellow coin.\n        :param x: The x position to draw the coin.\n        :param y: The y position to draw the coin.\n        """"""\n        self.screen.blit(yellow_coin, (x, y))\n\n    def draw_black_coin(self, x, y):\n        """"""\n        Draws a black coin.\n        :param x: The x position to draw the coin.\n        :param y: The y position to draw the coin.\n        """"""\n        self.screen.blit(black_coin, (x, y))\n\n    def draw_coin(self, game_data, x, y):\n        """"""\n        Draws a coin to the specified position\n        using the color of the current player.\n\n        :param game_data: All of the data for the game.\n        :param x: The x position for the coin to be drawn.\n        :param y: The y position for the coin to be drawn.\n        """"""\n        if game_data.turn == 0:\n            self.screen.blit(red_coin, (x, y))\n        else:\n            self.screen.blit(yellow_coin, (x, y))\n\n    def draw(self, game_data: GameData):\n        """"""\n        Draws the game state, including the board and the pieces.\n        :param game_data: All of the data associated with the game.\n        """"""\n        if game_data.action == ""undo"":\n            filled_circle(\n                self.screen,\n                game_data.last_move_row,\n                game_data.last_move_col,\n                self.game_data.radius,\n                black,\n            )\n\n            aacircle(\n                self.screen,\n                game_data.last_move_row,\n                game_data.last_move_col,\n                self.game_data.radius,\n                black,\n            )\n\n            self.draw_black_coin(\n                game_data.last_move_col * self.game_data.sq_size + 5,\n                self.game_data.height\n                - (\n                    game_data.last_move_row * self.game_data.sq_size\n                    + self.game_data.sq_size\n                    - 5\n                ),\n            )\n\n            game_data.game_board.print_board()\n            game_data.action = None\n\n        self.draw_board(game_data.game_board)\n\n    @bus.on(""game:over"")\n    def on_game_over(self, event: GameOver):\n        """"""\n        Handles a game over event.\n        :param event: Data about how the game ended.\n        """"""\n        color = None\n\n        if event.winner == 1:\n            color = red\n        if event.winner == 2:\n            color = yellow\n\n        if not event.was_tie:\n            self.label = self.myfont.render(f""PLAYER {event.winner} WINS!"", 1, color)\n            self.screen.blit(self.label, (40, 10))\n\n            mixer.music.load(event_sound)\n            mixer.music.play(0)\n        else:\n            mixer.music.load(os.path.join(""sounds"", ""event.ogg""))\n            mixer.music.play(0)\n            self.myfont = pygame.font.SysFont(""monospace"", 75)\n            self.label = self.myfont.render(""GAME DRAW !!!!"", 1, white)\n            self.screen.blit(self.label, (40, 10))\n\n    def draw_board(self, board):\n        """"""\n        Draws the game board to the screen.\n        :param board: The game board.\n        """"""\n        sq_size = 100\n        height = 700\n        radius = int(sq_size / 2 - 5)\n\n        for c in range(board.cols):\n            for r in range(board.rows):\n                pygame.draw.rect(\n                    self.screen,\n                    blue,\n                    (c * sq_size, (r + 1) * sq_size, sq_size, sq_size),\n                )\n                aacircle(\n                    self.screen,\n                    int(c * sq_size + sq_size / 2),\n                    int((r + 1) * sq_size + sq_size / 2),\n                    radius,\n                    black,\n                )\n                filled_circle(\n                    self.screen,\n                    int(c * sq_size + sq_size / 2),\n                    int((r + 1) * sq_size + sq_size / 2),\n                    radius,\n                    black,\n                )\n\n        for c in range(board.cols):\n            for r in range(board.rows):\n                if board.board[r][c] == 1:\n                    self.draw_red_coin(\n                        int(c * sq_size) + 5, height - int(r * sq_size + sq_size - 5)\n                    )\n\n                elif board.board[r][c] == 2:\n                    self.draw_yellow_coin(\n                        int(c * sq_size) + 5, height - int(r * sq_size + sq_size - 5)\n                    )\n\n        pygame.display.update()\n'"
