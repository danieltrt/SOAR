file_path,api_count,code
bpnn.py,10,"b'import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom data import Dataset\nfrom diagram import Diagram\nclass BPNN(object):\n    def __init__(self , dataset , learning_rate = 0.01 , n_iter = 10000 , momentum = 0.9 , shutdown_condition = 0.01):\n        self.n_iter = n_iter\n        self.dataset = dataset\n        self.learning_rate = learning_rate\n        self.x = dataset.train_x\n        self.Y = dataset.train_Y\n        self.shutdown_condition = shutdown_condition\n        self.cost = []\n        self.momentum = momentum\n        self.setup()\n        self.diagram = Diagram(self)\n    def setup(self):\n        self.set_nn_architecture()\n        self.set_weight()\n    # step1\n    def set_nn_architecture(self):\n        self.input_node = self.x.shape[1]\n        self.output_node = self.Y.shape[1]\n        self.hidden_node = int((self.input_node + self.output_node) / 2)\n\n        # bias\n        self.h_b = np.random.random(self.hidden_node) * 0.3 + 0.1\n        self.y_b = np.random.random(self.output_node) * 0.3 + 0.1\n    # step2\n    def set_weight(self):\n        self.w1 = np.random.random((self.input_node , self.hidden_node))\n        self.w2 = np.random.random((self.hidden_node , self.output_node))\n    # step3\n    def predict(self , x , Y):\n        self.h = self.sigmoid((np.dot(x , self.w1) + self.h_b))\n        self.y = self.sigmoid((np.dot(self.h , self.w2) + self.y_b))\n        zy = np.where(self.y > 0.5 , 1 , 0)\n        p_y = Y - zy\n        self.acc = 0\n        for i in p_y:\n            if (i.sum() == 0):\n                self.acc += 1\n        self.acc = self.acc / Y.shape[0] * 100.0\n        return self\n    # step4\n    def backend(self):\n        E = (self.Y - self.y)\n        errors = np.sum(np.square(E)) / self.Y.shape[1] / self.Y.shape[0]\n        #### \xe8\xbc\xb8\xe5\x87\xba\xe5\xb1\xa4 delta \xe8\xa8\x88\xe7\xae\x97\n        delta_y = E * self.y * (1 - self.y)\n        ### \xe9\x9a\xb1\xe8\x97\x8f\xe5\xb1\xa4 delta \xe8\xa8\x88\xe7\xae\x97\n        delta_h = (1 - self.h) * self.h * np.dot(delta_y , self.w2.T)\n        # self.w2 += self.learning_rate * self.h.T.dot(delta_y) + self.momentum * self.h.T.dot(delta_y)\n        # self.w1 += self.learning_rate * self.x.T.dot(delta_h) + self.momentum * self.x.T.dot(delta_h)\n        self.w2 += self.learning_rate * self.h.T.dot(delta_y)\n        self.w1 += self.learning_rate * self.x.T.dot(delta_h)\n        self.y_b = self.learning_rate * delta_y.sum()\n        self.h_b = self.learning_rate * delta_h.sum()\n        return errors\n\n    def train(self):\n        self.error = 0\n        for _iter in range(0 , self.n_iter):\n            self.predict(self.x , self.Y)\n            self.error = self.backend()\n            self.cost.append(self.error)\n            # if (_iter % 1000 == 0):\n            #     print(""Accuracy\xef\xbc\x9a%.2f"" % self.acc)\n            if (self.acc >= 98):\n                return self\n        return self\n\n    def test(self):\n        self.predict(self.dataset.test_x , self.dataset.test_Y)\n        return self\n\n    def sigmoid(self, x):\n        return 1 / (1 + np.exp(-x))\n    def draw(self , xlabel = \'\' , ylabel = \'\' , legend_loc = \'\' , title = \'\'):\n        self.diagram.draw(xlabel , ylabel , legend_loc , title )\n'"
data.py,15,"b'import numpy as np\nimport pandas as pd\n\nclass Dataset(object):\n    def __init__(self , data_path):\n        self.df = pd.read_csv(data_path, header = None)\n        self.Y = self.one_hot_encoding(self.df.iloc[0:, 4].values)\n        self.x = self.standard_deviation(self.df.iloc[0:, [0 , 1 , 2 , 3]].values)\n    def split_data(self , x , Y , p):\n        data = []\n        for i in range(x.shape[0]):\n            data.append([])\n            data[i].append(np.array(x[i]))\n            data[i].append(np.array(Y[i]))\n        np.random.shuffle(data)\n\n        split = int(Y.shape[0] * p)\n        data = np.array(data)\n        self.train_x  , self.train_Y = data[: split , 0] , data[: split , 1]\n        self.test_x  , self.test_Y = data[split:  , 0] , data[split:  , 1]\n        self.train_x = np.array([x.tolist() for x in self.train_x.tolist()])\n        self.train_Y = np.array([Y.tolist() for Y in self.train_Y.tolist()])\n        self.test_x = np.array([x.tolist() for x in self.test_x.tolist()])\n        self.test_Y = np.array([Y.tolist() for Y in self.test_Y.tolist()])\n        return self\n    def standard_deviation(self , X):\n        X_std = np.copy(X)\n        for i in range(0 , X.shape[1]):\n            X_std[: , i] = (X[: , i] - X[: , i].mean()) / X[: , i].std()\n        return X_std\n    def one_hot_encoding(self,Y):\n        classes = np.unique(Y)\n        number = [x for x in range(0 , classes.shape[0])]\n        a = np.array([classes , number]).T\n        for i in range(0 , a.shape[0]):\n            Y = np.where(Y == a[i][0] , a[i][1] , Y)\n        Y = [i for i in Y]\n        targets = np.array(Y).reshape(-1)\n        one_hot_targets = np.eye(a.shape[0])[targets]\n        return one_hot_targets\n    def output_process(self,Y):\n        output = list()\n        for i in Y:\n            output.append(self.output_transform(i))\n        return np.array(output)\n'"
diagram.py,0,"b""import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nclass Diagram(object):\n    def __init__(self , classifier):\n        self.classifier = classifier\n        self.setup()\n    def setup(self):\n        self.classifier.train()\n    def draw(self , xlabel = '' , ylabel = '' , legend_loc = '' , title = ''):\n        self.training_progress_diagram()\n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n        plt.title(title)\n        plt.legend(loc=legend_loc)\n        plt.show()\n    def training_progress_diagram(self):\n        cost = self.classifier.cost\n        plt.plot(range(1 , len(cost) + 1) , cost , 'b-')\n"""
main.py,0,"b'from bpnn import BPNN\nfrom data import Dataset\nfrom diagram import Diagram\n\nif __name__ == ""__main__"":\n    dataset = Dataset(\'iris.txt\')\n    dataset.split_data(dataset.x , dataset.Y , 0.8)\n    bpn = BPNN(dataset , learning_rate = 0.01, n_iter = 20000)\n    bpn.train()\n    bpn.test()\n    print(""Accuracy = %r %% , iteration = %r , MSE =  %.3f"" %(bpn.acc , len(bpn.cost) , bpn.error))\n    bpn.draw( title = \'learning_rate = %r , MSE = %.3f , Accuracy = %.f %%\' % (bpn.learning_rate , bpn.error , bpn.acc),\n              xlabel = \'iterator numbers\' ,\n              ylabel = \'MSE\',\n              legend_loc = \'upper left\')\n'"
