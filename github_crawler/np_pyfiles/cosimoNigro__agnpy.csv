file_path,api_count,code
setup.py,0,"b'import setuptools\n\nwith open(""README.md"", ""r"") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=""agnpy"",\n    version=""0.0.6"",\n    author=""Cosimo Nigro"",\n    author_email=""cosimonigro2@gmail.com.com"",\n    description=""Modelling jetted Active Galactic Nuclei radiative processes with python"",\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    url=""https://github.com/cosimoNigro/agnpy"",\n    packages=setuptools.find_packages(),\n    classifiers=[\n        ""Programming Language :: Python :: 3"",\n        ""License :: OSI Approved :: GNU General Public License v3 (GPLv3)"",\n        ""Operating System :: OS Independent"",\n    ],\n    install_requires=[""astropy"", ""numpy"", ""scipy"", ""matplotlib""],\n    python_requires="">=3.6"",\n)\n'"
agnpy/__init__.py,0,b'from .spectra import *\nfrom .emission_regions import *\nfrom .synchrotron import *\nfrom .compton import *\nfrom .targets import *\nfrom .absorption import *\n'
agnpy/absorption.py,35,"b'import numpy as np\nfrom astropy.constants import h, c, m_e, sigma_T\nimport astropy.units as u\nfrom .compton import cos_psi, x_re_shell, x_re_ring, mu_star\n\n\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\n# equivalency to transform frequencies to energies in electron rest mass units\nepsilon_equivalency = [\n    (u.Hz, u.Unit(""""), lambda x: h.cgs * x / mec2, lambda x: x * mec2 / h.cgs)\n]\n\n\n__all__ = [""sigma"", ""Absorption""]\n\n\ndef sigma(s):\n    """"""photon-photon pair production cross section, Eq. 17 of [Dermer2009]""""""\n    beta_cm = np.sqrt(1 - np.power(s, -1))\n    _prefactor = 3 / 16 * sigma_T * (1 - np.power(beta_cm, 2))\n    _term1 = (3 - np.power(beta_cm, 4)) * np.log((1 + beta_cm) / (1 - beta_cm))\n    _term2 = -2 * beta_cm * (2 - np.power(beta_cm, 2))\n    values = _prefactor * (_term1 + _term2)\n    values[s < 1] = 0\n    return values\n\n\nclass Absorption:\n    """"""class to compute the absorption due to gamma-gamma pair production\n\n    Parameters\n    ----------\n    blob : :class:`~agnpy.emission_regions.Blob`\n        emission region and electron distribution hitting the photon target\n    target : :class:`~agnpy.targets`\n        class describing the target photon field    \n    r : :class:`~astropy.units.Quantity`\n        distance of the blob from the Black Hole (i.e. from the target photons)\n    """"""\n\n    def __init__(self, blob, target, r):\n        self.blob = blob\n        self.target = target\n        self.r = r\n        self.set_mu()\n        self.set_phi()\n        self.set_l()\n\n    def set_mu(self, mu_size=100):\n        self.mu_size = mu_size\n        if self.target.type == ""SSDisk"":\n            # in case of hte disk the mu interval does not go from -1 to 1\n            r_tilde = (self.r / self.target.R_g).to_value("""")\n            self.mu = self.target.mu_from_r_tilde(r_tilde)\n        else:\n            self.mu = np.linspace(-1, 1, self.mu_size)\n\n    def set_phi(self, phi_size=50):\n        self.phi_size = phi_size\n        self.phi = np.linspace(0, 2 * np.pi, self.phi_size)\n\n    def set_l(self, l_size=50):\n        """"""set the range of integration for the distance\n        """"""\n        # integrate up 3000 pc\n        self.l_size = l_size\n        l_max = 3000 * u.pc\n        self.l = (\n            np.logspace(\n                np.log10(self.r.to_value(""cm"")),\n                np.log10(l_max.to_value(""cm"")),\n                self.l_size,\n            )\n            * u.cm\n        )\n\n    def _opacity_disk(self, nu):\n        """"""opacity generated by a Shakura Sunyaev disk\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_1 = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_1 *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: mu\n        # axis 1: phi\n        # axis 2: l\n        # axis 3: epsilon_1\n        # arrays starting with _ are multidimensional and used for integration\n        l_tilde = (self.r / self.target.R_g).to_value("""")\n        _mu = np.reshape(self.mu, (self.mu.size, 1, 1, 1))\n        _phi = np.reshape(self.phi, (1, self.phi.size, 1, 1))\n        _l = np.reshape(self.l, (1, 1, self.l.size, 1))\n        _l_tilde = np.reshape(l_tilde, (1, 1, l_tilde.size, 1))\n        _epsilon_1 = np.reshape(epsilon_1, (1, 1, 1, epsilon_1.size))\n        # epsilon and phi of the disk have the same dimensions of mu\n        # this time though they do not depend on a fixed distance r, but\n        # on the variable distance l\n        _epsilon = self.target.epsilon_mu(_mu, _l_tilde)\n        _phi_disk_mu = self.target.phi_disk_mu(_mu, _l_tilde)\n        _cos_psi = cos_psi(self.blob.mu_s, _mu, _phi)\n        _s = _epsilon_1 * _epsilon * (1 - _cos_psi) / 2\n        _integrand_mu = _phi_disk_mu / (\n            _epsilon * np.power(_l, 3) * np.power(np.power(_mu, -2) - 1, 3 / 2)\n        )\n        _integrand = (1 - _cos_psi) * _integrand_mu * sigma(_s)\n\n        prefactor_num = 3 * self.target.L_disk * self.target.R_g\n        prefactor_denum = 16 * np.pi * self.target.eta * m_e * np.power(c, 3)\n\n        integral_mu = np.trapz(_integrand, self.mu, axis=0)\n        integral_phi = np.trapz(integral_mu, self.phi, axis=0)\n        integral = np.trapz(integral_phi, self.l, axis=0)\n\n        tau = prefactor_num / prefactor_denum * integral\n        return tau.to_value("""")\n\n    def _opacity_shell_blr(self, nu):\n        """"""opacity generated by a spherical shell Broad Line Region\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_1 = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_1 *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: mu_re\n        # axis 1: phi\n        # axis 2: l\n        # axis 3: epsilon_1\n        # arrays starting with _ are multidimensional and used for integration\n        _mu = np.reshape(self.mu, (self.mu.size, 1, 1, 1))\n        _phi = np.reshape(self.phi, (1, self.phi.size, 1, 1))\n        _l = np.reshape(self.l, (1, 1, self.l.size, 1))\n        _epsilon_1 = np.reshape(epsilon_1, (1, 1, 1, epsilon_1.size))\n        # define integrating function\n        _x = x_re_shell(_mu, self.target.R_line, _l)\n        _mu_star = mu_star(_mu, self.target.R_line, _l)\n\n        _cos_psi = cos_psi(self.blob.mu_s, _mu_star, _phi)\n        _s = _epsilon_1 * self.target.epsilon_line * (1 - _cos_psi) / 2\n        _integrand = (1 - _cos_psi) * np.power(_x, -2) * sigma(_s)\n\n        prefactor_num = self.target.xi_line * self.target.L_disk\n        prefactor_denum = (\n            np.power(4 * np.pi, 2) * self.target.epsilon_line * m_e * np.power(c, 3)\n        )\n\n        integral_mu = np.trapz(_integrand, self.mu, axis=0)\n        integral_phi = np.trapz(integral_mu, self.phi, axis=0)\n        integral = np.trapz(integral_phi, self.l, axis=0)\n\n        tau = prefactor_num / prefactor_denum * integral\n        return tau.to_value("""")\n\n    def _opacity_ring_torus(self, nu):\n        """"""opacity generated by a ring Dust Torus\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_1 = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_1 *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: phi\n        # axis 1: l\n        # axis 2: epsilon_1\n        # arrays starting with _ are multidimensional and used for integration\n        _phi = np.reshape(self.phi, (self.phi.size, 1, 1))\n        _l = np.reshape(self.l, (1, self.l.size, 1))\n        _epsilon_1 = np.reshape(epsilon_1, (1, 1, epsilon_1.size))\n        _x = x_re_ring(self.target.R_dt, _l)\n        _mu = _l / _x\n\n        _cos_psi = cos_psi(self.blob.mu_s, _mu, _phi)\n        _s = _epsilon_1 * self.target.epsilon_dt * (1 - _cos_psi) / 2\n        _integrand = (1 - _cos_psi) * np.power(_x, -2) * sigma(_s)\n\n        prefactor_num = self.target.xi_dt * self.target.L_disk\n        prefactor_denum = (\n            np.power(4 * np.pi, 2) * self.target.epsilon_dt * m_e * np.power(c, 3)\n        )\n\n        integral_phi = np.trapz(_integrand, self.phi, axis=0)\n        integral = np.trapz(integral_phi, self.l, axis=0)\n\n        tau = prefactor_num / prefactor_denum * integral\n        return tau.to_value("""")\n\n    def tau(self, nu):\n        """"""optical depth\n\n        .. math::\n            \\\\tau_{\\\\gamma \\\\gamma}(\\\\nu)\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the opacity, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        if self.target.type == ""SSDisk"":\n            return self._opacity_disk(nu)\n        if self.target.type == ""SphericalShellBLR"":\n            return self._opacity_shell_blr(nu)\n        if self.target.type == ""RingDustTorus"":\n            return self._opacity_ring_torus(nu)\n'"
agnpy/compton.py,102,"b'import numpy as np\nfrom astropy.constants import h, c, m_e, sigma_T, G\nimport astropy.units as u\nfrom .targets import CMB, PointSourceBehindJet, SSDisk, SphericalShellBLR, RingDustTorus\n\n\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\n# equivalency to transform frequencies to energies in electron rest mass units\nepsilon_equivalency = [\n    (u.Hz, u.Unit(""""), lambda x: h.cgs * x / mec2, lambda x: x * mec2 / h.cgs)\n]\n\n\n__all__ = [""SynchrotronSelfCompton"", ""ExternalCompton"", ""cos_psi""]\n\n\ndef F_c(q, gamma_e):\n    """"""isotropic Compton kernel, Eq. 6.75 in [DermerMenon2009]_, Eq. 10 in [Finke2008]_""""""\n    term_1 = 2 * q * np.log(q)\n    term_2 = (1 + 2 * q) * (1 - q)\n    term_3 = 1 / 2 * np.power(gamma_e * q, 2) / (1 + gamma_e * q) * (1 - q)\n    return term_1 + term_2 + term_3\n\n\ndef isotropic_kernel(gamma, epsilon, epsilon_s):\n    """"""Compton kernel for isotropic nonthermal electrons scattering photons of \n    an isotropic external radiation field.\n    Integrand of Eq. 6.74 in [DermerMenon2009]_.\n\n    Parameters\n    ----------\n    gamma : :class:`~numpy.ndarray`\n        Lorentz factors of the electrons distribution\n    epsilon : :class:`~numpy.ndarray`\n        dimesnionless energies (in electron rest mass units) of the target photons\n    epsilon_s : :class:`~numpy.ndarray`\n        dimensionless energies (in electron rest mass units) of the scattered photons\n    """"""\n    gamma_e = 4 * gamma * epsilon\n    q = (epsilon_s / gamma) / (gamma_e * (1 - epsilon_s / gamma))\n    q_min = 1 / (4 * np.power(gamma, 2))\n    return np.where((q_min <= q) * (q <= 1), F_c(q, gamma_e), 0)\n\n\ndef cos_psi(mu_s, mu, phi):\n    """"""compute the angle between the blob (with zenith mu_s) and a photon with\n    zenith and azimuth (mu, phi). The system is symmetric in azimuth for the\n    electron phi_s = 0, Eq. 8 in [Finke2016]_.""""""\n    term_1 = mu * mu_s\n    term_2 = np.sqrt(1 - np.power(mu, 2)) * np.sqrt(1 - np.power(mu_s, 2))\n    term_3 = np.cos(phi)\n    return term_1 + term_2 * term_3\n\n\ndef get_gamma_min(epsilon_s, epsilon, mu_s, mu, phi):\n    """"""minimum Lorentz factor for Compton integration, \n    Eq. 29 in [Dermer2009]_, Eq. 38 in [Finke2016]_.""""""\n    sqrt_term = np.sqrt(1 + 2 / (epsilon * epsilon_s * (1 - cos_psi(mu_s, mu, phi))))\n    return epsilon_s / 2 * (1 + sqrt_term)\n\n\ndef compton_kernel(gamma, epsilon_s, epsilon, mu_s, mu, phi):\n    """"""angle dependent Compton kernel:\n    Eq. 26-27 in [Dermer2009]_.\n\n    Parameters\n    ----------\n    gamma : :class:`~numpy.ndarray`\n        Lorentz factors of the electrons distribution\n    epsilon : :class:`~numpy.ndarray`\n        dimesnionless energies (in electron rest mass units) of the target photons\n    epsilon_s : :class:`~numpy.ndarray`\n        dimensionless energies (in electron rest mass units) of the scattered photons\n    mu_s : float\n        cosine of the zenith angle of the blob w.r.t the jet\n    mu : :class:`~numpy.ndarray` or float\n        (array of) cosine of the zenith angle subtended by the target\n    phi : :class:`~numpy.ndarray` or float\n        (array of) of the azimuth angle subtended by the target\n    """"""\n    epsilon_bar = gamma * epsilon * (1 - cos_psi(mu_s, mu, phi))\n    y = 1 - epsilon_s / gamma\n    y_1 = -(2 * epsilon_s) / (gamma * epsilon_bar * y)\n    y_2 = np.power(epsilon_s, 2) / np.power(gamma * epsilon_bar * y, 2)\n    values = y + 1 / y + y_1 + y_2\n    gamma_min = get_gamma_min(epsilon_s, epsilon, mu_s, mu, phi)\n    values = np.where(gamma >= gamma_min, y + 1 / y + y_1 + y_2, 0)\n    return values\n\n\ndef x_re_shell(mu, R_re, r):\n    """"""distance between the blob and a spherical reprocessing material,\n    see Fig. 9 and Eq. 76 in [Finke2016]_.\n    \n    Parameters\n    ----------\n    mu : :class:`~numpy.ndarray`\n        (array of) cosine of the zenith angle subtended by the target\n    R_re : :class:`~astropy.units.Quantity`\n        distance from the BH to the reprocessing material\n    r : :class:`~astropy.units.Quantity`\n        height of the emission region in the jet\n    """"""\n    return np.sqrt(np.power(R_re, 2) + np.power(r, 2) - 2 * r * R_re * mu)\n\n\ndef x_re_ring(R_re, r):\n    """"""distance between the blob and a ring reprocessing material""""""\n    return np.sqrt(np.power(R_re, 2) + np.power(r, 2))\n\n\ndef mu_star(mu, R_re, r):\n    """"""cosine of the angle between the blob and the reprocessing material,\n    see Fig. 9 and Eq. 76 in [Finke2016]_.\n\n    Parameters\n    ----------\n    mu : :class:`~numpy.ndarray`\n        (array of) cosine of the zenith angle subtended by the target\n    R_re : float \n        distance (in cm) from the BH to the reprocessing material\n    r : float\n        height (in cm) of the emission region in the jet\n    """"""\n    addend = np.power(R_re / x_re_shell(mu, R_re, r), 2) * (1 - np.power(mu, 2))\n    return np.sqrt(1 - addend)\n\n\nclass SynchrotronSelfCompton:\n    """"""class for Synchrotron Self Compton radiation computation\n\n    Parameters\n    ----------\n    blob : :class:`~agnpy.emission_region.Blob`\n        emission region and electron distribution hitting the photon target\n    synchrotron : :class:`~agnpy.synchrotron.Synchrotron`\n        class describing the synchrotron photons target\n    """"""\n\n    def __init__(self, blob, synchrotron):\n        self.blob = blob\n        self.synchrotron = synchrotron\n        # default grid of epsilon values over which for the synchroton emission\n        self.epsilon_syn = np.logspace(-13, 10, 300)\n        self.synch_sed_emissivity = self.synchrotron.com_sed_emissivity(\n            self.epsilon_syn\n        )\n\n    def com_sed_emissivity(self, epsilon):\n        """"""SSC  emissivity: \n\n        .. math::\n            \\epsilon\'\\,J\'_{\\mathrm{SSC}}(\\epsilon\')\\,[\\mathrm{erg}\\,\\mathrm{s}^{-1}]\n        \n        Eq. 8 and 9 of [Finke2008]_.\n\n        **Note:** This emissivity is computed in the co-moving frame of the blob.\n        When calling this function from another, these energies\n        have to be transformed in the co-moving frame of the plasmoid.\n\n        Parameters\n        ----------\n        epsilon : :class:`~numpy.ndarray`\n            dimensionless energies (in electron rest mass units) of the scattered photons\n        """"""\n        gamma = self.blob.gamma\n        N_e = self.blob.N_e(gamma).value\n        # Eq. 22 of [Finke2008]_, the factor 3 / 4 accounts for averaging in a sphere\n        # not included in Dermer and Finke\'s papers\n        J_epsilon_syn = 3 / 4 * self.synch_sed_emissivity / self.epsilon_syn\n        # for multidimensional integration\n        # axis = 0 : electrons Lorentz factors\n        # axis = 1 : target photons energies\n        # axis = 2 : scattered photons energies\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(gamma, (gamma.size, 1, 1))\n        _N_e = np.reshape(N_e, (N_e.size, 1, 1))\n        _epsilon_syn = np.reshape(self.epsilon_syn, (1, self.epsilon_syn.size, 1))\n        _J_epsilon_syn = np.reshape(J_epsilon_syn, (1, J_epsilon_syn.size, 1))\n        _epsilon = np.reshape(epsilon, (1, 1, epsilon.size))\n        _kernel = isotropic_kernel(_gamma, _epsilon_syn, _epsilon)\n        # build the integrands of Eq. 9 in [2], using the reshaped arrays\n        integrand_epsilon = _J_epsilon_syn / np.power(_epsilon_syn, 2)\n        integrand_gamma = _N_e / np.power(_gamma, 2) * _kernel\n        integrand = integrand_epsilon * integrand_gamma\n        # integrate the Lorentz factor and the target synchrotron energies axes\n        integral_gamma = np.trapz(integrand, gamma, axis=0)\n        integral_epsilon = np.trapz(integral_gamma, self.epsilon_syn, axis=0)\n        prefactor = (\n            9\n            * sigma_T\n            * np.power(epsilon, 2)\n            / (16 * np.pi * np.power(self.blob.R_b, 2))\n        )\n        emissivity = prefactor * integral_epsilon\n        return emissivity.to(""erg s-1"")\n\n    def sed_luminosity(self, nu):\n        """"""SSC luminosity SED: \n\n        .. math::\n            \\\\nu L_{\\\\nu} \\, [\\mathrm{erg}\\,\\mathrm{s}^{-1}]\n\n        Parameters\n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        # correct epsilon to the jet comoving frame\n        epsilon_prime = (1 + self.blob.z) * epsilon / self.blob.delta_D\n        prefactor = np.power(self.blob.delta_D, 4)\n        return prefactor * self.com_sed_emissivity(epsilon_prime)\n\n    def sed_flux(self, nu):\n        """"""SSC flux SED:\n        \n        .. math::\n            \\\\nu F_{\\\\nu} \\, [\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}]\n        \n        Eq. 15 in [Finke2008]_\n\n        Parameters\n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        # correct epsilon to the jet comoving frame\n        epsilon_prime = (1 + self.blob.z) * epsilon / self.blob.delta_D\n        prefactor = np.power(self.blob.delta_D, 4) / (\n            4 * np.pi * np.power(self.blob.d_L, 2)\n        )\n        sed = prefactor * self.com_sed_emissivity(epsilon_prime)\n        return sed.to(""erg cm-2 s-1"")\n\n    def sed_peak_flux(self, nu):\n        """"""provided a grid of frequencies nu, returns the peak flux of the SED\n        """"""\n        return self.sed_flux(nu).max()\n\n    def sed_peak_nu(self, nu):\n        """"""provided a grid of frequencies nu, returns the frequency at which the SED peaks\n        """"""\n        idx_max = self.sed_flux(nu).argmax()\n        return nu[idx_max]\n\n\nclass ExternalCompton:\n    """"""class for External Compton radiation computation\n\n    Parameters\n    ----------\n    blob : :class:`~agnpy.emission_region.Blob`\n        emission region and electron distribution hitting the photon target\n    target : :class:`~agnpy.targets`\n        class describing the target photon field    \n    r : `~astropy.units.Quantity`\n        distance of the blob from the Black Hole (i.e. from the target photons)\n    """"""\n\n    def __init__(self, blob, target, r=None):\n        self.blob = blob\n        # we integrate on a larger grid to account for the transformation\n        # of the electron density in the reference frame of the BH\n        self.gamma = self.blob.gamma_to_integrate\n        # N_e in the reference frame of the galaxy\n        self.transformed_N_e = self.blob.N_e(self.gamma / self.blob.delta_D).value\n        self.target = target\n        self.r = r\n        self.set_mu()\n        self.set_phi()\n\n    def set_mu(self, mu_size=100):\n        self.mu_size = mu_size\n        if isinstance(self.target, SSDisk):\n            # in case of hte disk the mu interval does not go from -1 to 1\n            r_tilde = (self.r / self.target.R_g).to_value("""")\n            self.mu = self.target.mu_from_r_tilde(r_tilde)\n        else:\n            self.mu = np.linspace(-1, 1, self.mu_size)\n\n    def set_phi(self, phi_size=50):\n        self.phi_size = phi_size\n        self.phi = np.linspace(0, 2 * np.pi, self.phi_size)\n\n    def _sed_flux_cmb(self, nu):\n        """"""SED flux for EC on CMB\n        \n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_s = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_s *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: gamma\n        # axis 1: mu\n        # axis 2: phi\n        # axis 3: epsilon_s\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(self.gamma, (self.gamma.size, 1, 1, 1))\n        _N_e = np.reshape(self.transformed_N_e, (self.transformed_N_e.size, 1, 1, 1))\n        _mu = np.reshape(self.mu, (1, self.mu.size, 1, 1))\n        _phi = np.reshape(self.phi, (1, 1, self.phi.size, 1))\n        _epsilon_s = np.reshape(epsilon_s, (1, 1, 1, epsilon_s.size))\n        # define integrating function\n        _kernel = compton_kernel(\n            _gamma, _epsilon_s, self.target.epsilon_0, self.blob.mu_s, _mu, _phi\n        )\n        _integrand = np.power(_gamma, -2) * _N_e * _kernel\n        integral_gamma = np.trapz(_integrand, self.gamma, axis=0)\n        integral_mu = np.trapz(integral_gamma, self.mu, axis=0)\n        integral_phi = np.trapz(integral_mu, self.phi, axis=0)\n        prefactor_num = (\n            3\n            * c\n            * sigma_T\n            * self.target.u_0\n            * np.power(epsilon_s, 2)\n            * np.power(self.blob.delta_D, 3)\n        )\n        prefactor_denom = (\n            np.power(2, 7)\n            * np.power(np.pi, 2)\n            * np.power(self.blob.d_L, 2)\n            * np.power(self.target.epsilon_0, 2)\n        )\n        sed = prefactor_num / prefactor_denom * integral_phi\n        return sed.to(""erg cm-2 s-1"")\n\n    def _sed_flux_point_like(self, nu):\n        """"""SED flux for EC on a point like source behind the jet\n        \n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_s = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_s *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: gamma\n        # axis 3: epsilon_s\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(self.gamma, (self.gamma.size, 1))\n        _N_e = np.reshape(self.transformed_N_e, (self.transformed_N_e.size, 1))\n        _epsilon_s = np.reshape(epsilon_s, (1, epsilon_s.size))\n        # define integrating function\n        # notice once the value of mu = 1, phi can assume any value, we put 0\n        # convenience\n        _kernel = compton_kernel(\n            _gamma, _epsilon_s, self.target.epsilon_0, self.blob.mu_s, 1, 0\n        )\n        _integrand = np.power(_gamma, -2) * _N_e * _kernel\n        integral_gamma = np.trapz(_integrand, self.gamma, axis=0)\n        prefactor_num = (\n            3\n            * sigma_T\n            * self.target.L_0\n            * np.power(epsilon_s, 2)\n            * np.power(self.blob.delta_D, 3)\n        )\n        prefactor_denom = (\n            np.power(2, 7)\n            * np.power(np.pi, 2)\n            * np.power(self.blob.d_L, 2)\n            * np.power(self.r, 2)\n            * np.power(self.target.epsilon_0, 2)\n        )\n        sed = prefactor_num / prefactor_denom * integral_gamma\n        return sed.to(""erg cm-2 s-1"")\n\n    def _sed_flux_disk(self, nu):\n        """"""SED flux for EC on SS Disk\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_s = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_s *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: gamma\n        # axis 1: mu\n        # axis 2: phi\n        # axis 3: epsilon_s\n        # arrays starting with _ are multidimensional and used for integration\n        # distance from the disk in gravitational radius units\n        r_tilde = (self.r / self.target.R_g).to_value("""")\n        _gamma = np.reshape(self.gamma, (self.gamma.size, 1, 1, 1))\n        _N_e = np.reshape(self.transformed_N_e, (self.transformed_N_e.size, 1, 1, 1))\n        _mu = np.reshape(self.mu, (1, self.mu.size, 1, 1))\n        _phi = np.reshape(self.phi, (1, 1, self.phi.size, 1))\n        _epsilon_s = np.reshape(epsilon_s, (1, 1, 1, epsilon_s.size))\n        _epsilon = self.target.epsilon_mu(_mu, r_tilde)\n        # define integrating function\n        _kernel = compton_kernel(\n            _gamma, _epsilon_s, _epsilon, self.blob.mu_s, _mu, _phi\n        )\n        _integrand_mu_num = self.target.phi_disk_mu(_mu, r_tilde)\n        _integrand_mu_denum = (\n            np.power(_epsilon, 2) * _mu * np.power(np.power(_mu, -2) - 1, 3 / 2)\n        )\n        _integrand = (\n            _integrand_mu_num\n            / _integrand_mu_denum\n            * np.power(_gamma, -2)\n            * _N_e\n            * _kernel\n        )\n        integral_gamma = np.trapz(_integrand, self.gamma, axis=0)\n        integral_mu = np.trapz(integral_gamma, self.mu, axis=0)\n        integral_phi = np.trapz(integral_mu, self.phi, axis=0)\n        prefactor_num = (\n            9\n            * sigma_T\n            * G\n            * self.target.M_BH\n            * self.target.m_dot\n            * np.power(epsilon_s, 2)\n            * np.power(self.blob.delta_D, 3)\n        )\n        prefactor_denom = (\n            np.power(2, 9)\n            * np.power(np.pi, 3)\n            * np.power(self.blob.d_L, 2)\n            * np.power(self.r, 3)\n        )\n        sed = prefactor_num / prefactor_denom * integral_phi\n        return sed.to(""erg cm-2 s-1"")\n\n    def _sed_flux_shell_blr(self, nu):\n        """"""SED flux for EC on BLR\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_s = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_s *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: gamma\n        # axis 1: mu_re (cosine zenith from BH to re-processing material)\n        # axis 2: phi\n        # axis 3: epsilon_s\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(self.gamma, (self.gamma.size, 1, 1, 1))\n        _N_e = np.reshape(self.transformed_N_e, (self.transformed_N_e.size, 1, 1, 1))\n        _mu = np.reshape(self.mu, (1, self.mu.size, 1, 1))\n        _phi = np.reshape(self.phi, (1, 1, self.phi.size, 1))\n        _epsilon_s = np.reshape(epsilon_s, (1, 1, 1, epsilon_s.size))\n        # define integrating functionlue\n        _x = x_re_shell(_mu, self.target.R_line, self.r)\n        _mu_star = mu_star(_mu, self.target.R_line, self.r)\n        _kernel = compton_kernel(\n            _gamma, _epsilon_s, self.target.epsilon_line, self.blob.mu_s, _mu_star, _phi\n        )\n        _integrand = np.power(_x, -2) * np.power(_gamma, -2) * _N_e * _kernel\n        integral_gamma = np.trapz(_integrand, self.gamma, axis=0)\n        integral_mu = np.trapz(integral_gamma, self.mu, axis=0)\n        integral_phi = np.trapz(integral_mu, self.phi, axis=0)\n        prefactor_num = (\n            3\n            * sigma_T\n            * self.target.xi_line\n            * self.target.L_disk\n            * np.power(epsilon_s, 2)\n            * np.power(self.blob.delta_D, 3)\n        )\n        prefactor_denom = (\n            np.power(2, 9)\n            * np.power(np.pi, 3)\n            * np.power(self.blob.d_L, 2)\n            * np.power(self.target.epsilon_line, 2)\n        )\n        sed = prefactor_num / prefactor_denom * integral_phi\n        return sed.to(""erg cm-2 s-1"")\n\n    def _sed_flux_ring_torus(self, nu):\n        """"""SED flux for EC on DT\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        # define the dimensionless energy\n        epsilon_s = nu.to("""", equivalencies=epsilon_equivalency)\n        # transform to BH frame\n        epsilon_s *= 1 + self.blob.z\n        # for multidimensional integration\n        # axis 0: gamma\n        # axis 1: phi\n        # axis 2: epsilon_s\n        # arrays starting with _ are multidimensional and used for integration\n        x_re = x_re_ring(self.target.R_dt, self.r)\n        # here we plug mu =  r / x. Delta function in Eq. 91 of [Finke2016]_\n        mu = (self.r / x_re).to_value("""")\n        _gamma = np.reshape(self.gamma, (self.gamma.size, 1, 1))\n        _N_e = np.reshape(self.transformed_N_e, (self.transformed_N_e.size, 1, 1))\n        _phi = np.reshape(self.phi, (1, self.phi.size, 1))\n        _epsilon_s = np.reshape(epsilon_s, (1, 1, epsilon_s.size))\n        # define integrating function\n        _kernel = compton_kernel(\n            _gamma, _epsilon_s, self.target.epsilon_dt, self.blob.mu_s, mu, _phi\n        )\n        _integrand = np.power(_gamma, -2) * _N_e * _kernel\n        integral_gamma = np.trapz(_integrand, self.gamma, axis=0)\n        integral_phi = np.trapz(integral_gamma, self.phi, axis=0)\n        prefactor_num = (\n            3\n            * sigma_T\n            * self.target.xi_dt\n            * self.target.L_disk\n            * np.power(epsilon_s, 2)\n            * np.power(self.blob.delta_D, 3)\n        )\n        prefactor_denom = (\n            np.power(2, 8)\n            * np.power(np.pi, 3)\n            * np.power(self.blob.d_L, 2)\n            * np.power(x_re, 2)\n            * np.power(self.target.epsilon_dt, 2)\n        )\n        sed = prefactor_num / prefactor_denom * integral_phi\n        return sed.to(""erg cm-2 s-1"")\n\n    def sed_flux(self, nu):\n        """"""flux SED for EC\n\n        Parameters\n        ----------\n        nu : `~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        """"""\n        if isinstance(self.target, CMB):\n            return self._sed_flux_cmb(nu)\n        if isinstance(self.target, PointSourceBehindJet):\n            return self._sed_flux_point_like(nu)\n        if isinstance(self.target, SSDisk):\n            return self._sed_flux_disk(nu)\n        if isinstance(self.target, SphericalShellBLR):\n            return self._sed_flux_shell_blr(nu)\n        if isinstance(self.target, RingDustTorus):\n            return self._sed_flux_ring_torus(nu)\n\n    def sed_peak_flux(self, nu):\n        """"""provided a grid of frequencies nu, returns the peak flux of the SED\n        """"""\n        return self.sed_flux(nu).max()\n\n    def sed_peak_nu(self, nu):\n        """"""provided a grid of frequencies nu, returns the frequency at which the SED peaks\n        """"""\n        idx_max = self.sed_flux(nu).argmax()\n        return nu[idx_max]\n'"
agnpy/emission_regions.py,25,"b'import numpy as np\nimport astropy.units as u\nfrom astropy.constants import e, c, m_e, sigma_T\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\nfrom . import spectra\n\n\ne = e.gauss\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\n# equivalency for decomposing Gauss in Gaussian-cgs units (not available in astropy)\nGauss_cgs_unit = ""cm(-1/2) g(1/2) s-1""\nGauss_cgs_equivalency = [(u.G, u.Unit(Gauss_cgs_unit), lambda x: x, lambda x: x)]\n\n\n__all__ = [""Blob""]\n\n\nclass Blob:\n    """"""Simple spherical emission region.\n\n    **Note:** all these quantities are defined in the comoving frame so they are actually\n    primed quantities, when referring the notation in [DermerMenon2009]_.\n\n    Parameters\n    ----------\n    R_b : :class:`~astropy.units.Quantity`\n        radius of the blob\n    z : float\n        redshift of the source\n    delta_D : float\n        Doppler factor of the relativistic outflow\n    Gamma : float\n        Lorentz factor of the relativistic outflow\n    B : :class:`~astropy.units.Quantity`\n        magnetic field in the blob (Gauss)\n    xi : float\n        acceleration coefficient :math:`\\\\xi` for first-order Fermi acceleration\n        :math:`(\\mathrm{d}E/\\mathrm{d}t \\\\propto v \\\\approx c)`\n        used to compute limits on the maximum Lorentz factor via\n        :math:`(\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} = \\\\xi c E / R_L`\n\n    spectrum_norm : :class:`~astropy.units.Quantity`\n        normalisation of the electron spectra, by default can be, following \n        the notation in [DermerMenon2009]_:\n\n            - :math:`n_{e,\\,tot}`: total electrons density, in :math:`\\mathrm{cm}^{-3}`\n            - :math:`u_e` : total electrons energy density, in :math:`\\mathrm{erg}\\,\\mathrm{cm}^{-3}`\n            - :math:`W_e` : total energy in electrons, in :math:`\\mathrm{erg}`\n        \n        see `spectrum_norm_type` for more details on the normalisation\n\n    spectrum_dict : dictionary\n        dictionary containing type and spectral shape information, e.g.:\n\n        .. code-block:: python\n\n            spectrum_dict = {\n                ""type"": ""PowerLaw"", \n                ""parameters"": {\n                    ""p"": 2.8, \n                    ""gamma_min"": 1e2, \n                    ""gamma_max"": 1e7\n                }\n            }\n\n    spectrum_norm_type : [""integral"", ""differential"", ""gamma=1""]\n        only with a normalisation in ""cm-3"" one can select among three types: \n\n        * `integral`: (default) the spectrum is set such that :math:`n_{e,\\,tot}` equals the value provided by `spectrum_norm`;  \n        \n        * `differential`: the spectrum is set such that :math:`k_e` equals the value provided by `spectrum_norm`;    \n        \n        * `gamma=1`: the spectrum is set such that :math:`n_e(\\gamma=1)` equals the value provided by `spectrum_norm`.\n        \n    gamma_size : int\n        size of the array of electrons Lorentz factors\n    """"""\n\n    def __init__(\n        self,\n        R_b,\n        z,\n        delta_D,\n        Gamma,\n        B,\n        spectrum_norm,\n        spectrum_dict,\n        spectrum_norm_type=""integral"",\n        xi=1.0,\n        gamma_size=200,\n    ):\n        self.R_b = R_b.to(""cm"")\n        self.z = z\n        self.d_L = Distance(z=self.z).cgs\n        self.V_b = 4 / 3 * np.pi * np.power(self.R_b, 3)\n        self.delta_D = delta_D\n        self.Gamma = Gamma\n        self.Beta = np.sqrt(1 - 1 / np.power(self.Gamma, 2))\n        # viewing angle\n        self.mu_s = (1 - 1 / (self.Gamma * self.delta_D)) / self.Beta\n        self.theta_s = (np.arccos(self.mu_s) * u.rad).to(""deg"")\n        self.B = B\n        # B decomposed in Gaussian-cgs units\n        self.B_cgs = B.to(Gauss_cgs_unit, equivalencies=Gauss_cgs_equivalency)\n        self.spectrum_norm = spectrum_norm\n        self.spectrum_norm_type = spectrum_norm_type\n        self.spectrum_dict = spectrum_dict\n        self.xi = xi\n        # size of the electron Lorentz factor grid\n        self.gamma_size = gamma_size\n        self.gamma_min = self.spectrum_dict[""parameters""][""gamma_min""]\n        self.gamma_max = self.spectrum_dict[""parameters""][""gamma_max""]\n        # grid of Lorentz factor for the integration in the blob comoving frame\n        self.gamma = np.logspace(\n            np.log10(self.gamma_min), np.log10(self.gamma_max), self.gamma_size\n        )\n        # grid of Lorentz factors for integration in the external frame\n        self.gamma_to_integrate = np.logspace(1, 9, self.gamma_size)\n        # model for the electron density\n        self.set_n_e(self.spectrum_norm, self.spectrum_dict, self.spectrum_norm_type)\n\n    def set_n_e(self, spectrum_norm, spectrum_dict, spectrum_norm_type):\n        """"""set the spectrum :math:`n_e` for the blob""""""\n        model_dict = {\n            ""PowerLaw"": spectra.PowerLaw,\n            ""BrokenPowerLaw"": spectra.BrokenPowerLaw,\n            ""BrokenPowerLaw2"": spectra.BrokenPowerLaw2,\n        }\n        spectrum_type = spectrum_dict[""type""]\n\n        if spectrum_norm_type != ""integral"" and spectrum_norm.unit in (\n            u.Unit(""erg""),\n            u.Unit(""erg cm-3""),\n        ):\n            raise NameError(\n                ""Normalisations different than \'integral\' available only for \'spectrum_norm\' in cm-3""\n            )\n\n        # check the units of the normalisation\n        # cm-3 is the only one allowing more than one normalisation type\n        if spectrum_norm.unit == u.Unit(""cm-3""):\n\n            if spectrum_norm_type == ""integral"":\n                self.n_e = model_dict[spectrum_type].from_normalised_density(\n                    spectrum_norm, **spectrum_dict[""parameters""]\n                )\n            elif spectrum_norm_type == ""differential"":\n                self.n_e = model_dict[spectrum_type](\n                    spectrum_norm, **spectrum_dict[""parameters""]\n                )\n            elif spectrum_norm_type == ""gamma=1"":\n                self.n_e = model_dict[spectrum_type].from_norm_at_gamma_1(\n                    spectrum_norm, **spectrum_dict[""parameters""]\n                )\n\n        elif spectrum_norm.unit == u.Unit(""erg cm-3""):\n            self.n_e = model_dict[spectrum_type].from_normalised_u_e(\n                spectrum_norm, **spectrum_dict[""parameters""]\n            )\n\n        elif spectrum_norm.unit == u.Unit(""erg""):\n            u_e = (spectrum_norm / self.V_b).to(""erg cm-3"")\n            self.n_e = model_dict[spectrum_type].from_normalised_u_e(\n                u_e, **spectrum_dict[""parameters""]\n            )\n\n    def __str__(self):\n        """"""printable summary of the blob""""""\n        return (\n            ""* spherical emission region\\n""\n            + f"" - R_b (radius of the blob): {self.R_b.cgs:.2e}\\n""\n            + f"" - V_b (volume of the blob): {self.V_b.cgs:.2e}\\n""\n            + f"" - z (source redshift): {self.z:.2f}\\n""\n            + f"" - d_L (source luminosity distance):{self.d_L.cgs:.2e}\\n""\n            + f"" - delta_D (blob Doppler factor): {self.delta_D:.2e}\\n""\n            + f"" - Gamma (blob Lorentz factor): {self.Gamma:.2e}\\n""\n            + f"" - Beta (blob relativistic velocity): {self.Beta:.2e}\\n""\n            + f"" - theta_s (jet viewing angle): {self.theta_s:.2e}\\n""\n            + f"" - B (magnetic field tangled to the jet): {self.B:.2e}\\n""\n            + str(self.n_e)\n        )\n\n    def set_delta_D(self, Gamma, theta_s):\n        """"""set the viewing angle and the Lorentz factor of the outflow to\n        obtain a specific Doppler factor\n\n        Parameters\n        ----------\n        Gamma : float\n            Lorentz factor of the relativistic outflow\n        theta_s : :class:`~astropy.units.Quantity`\n            viewing angle of the jet\n        """"""\n        mu_s = np.cos(theta_s.to(""rad"").value)\n        Beta = np.sqrt(1 - 1 / np.power(Gamma, 2))\n        delta_D = 1 / (Gamma * (1 - Beta * mu_s))\n\n        self.theta_s = theta_s\n        self.mu_s = mu_s\n        self.Gamma = Gamma\n        self.Beta = Beta\n        self.delta_D = delta_D\n\n    def set_gamma_size(self, gamma_size):\n        """"""change size of the array of electrons Lorentz factors""""""\n        self.gamma_size = gamma_size\n        self.gamma = np.logspace(\n            np.log10(self.gamma_min), np.log10(self.gamma_max), self.gamma_size\n        )\n        self.gamma_to_integrate = np.logspace(1, 9, self.gamma_size)\n\n    def N_e(self, gamma):\n        """"""number of electrons as a function of the Lorentz factor, \n        :math:`N_e(\\gamma\') = V_b\\,n_e(\\gamma\')`""""""\n        return self.V_b * self.n_e(gamma)\n\n    @property\n    def n_e_tot(self):\n        """"""total electrons density\n\n        .. math::\n            n_{e,\\,tot} = \\int^{\\gamma\'_{max}}_{\\gamma\'_{min}} \\mathrm{d}\\gamma\' n_e(\\gamma\')\n        """"""\n        return np.trapz(self.n_e(self.gamma), self.gamma)\n\n    @property\n    def N_e_tot(self):\n        """"""total number of electrons\n\n        .. math::\n            N_{e,\\,tot} = \\int^{\\gamma\'_{max}}_{\\gamma\'_{min}} \\mathrm{d}\\gamma\' N_e(\\gamma\')\n        """"""\n        return np.trapz(self.N_e(self.gamma), self.gamma)\n\n    @property\n    def u_e(self):\n        """"""total electrons energy density\n\n        .. math::\n            u_{e} = m_e c^2\\,\\int^{\\gamma\'_{max}}_{\\gamma\'_{min}} \\mathrm{d}\\gamma\' \\gamma\' n_e(\\gamma\')\n        """"""\n        return mec2 * np.trapz(self.gamma * self.n_e(self.gamma), self.gamma)\n\n    @property\n    def W_e(self):\n        """"""total energy in non-thermal electrons\n\n        .. math::\n            W_{e} = m_e c^2\\,\\int^{\\gamma\'_{max}}_{\\gamma\'_{min}} \\mathrm{d}\\gamma\' \\gamma\' N_e(\\gamma\')\n        """"""\n        return mec2 * np.trapz(self.gamma * self.N_e(self.gamma), self.gamma)\n\n    @property\n    def P_jet_e(self):\n        """"""jet power in electrons\n\n        .. math::\n            P_{jet,\\,e} = 2 \\pi R_b^2 \\\\beta \\Gamma^2 c u_e\n        """"""\n        prefactor = (\n            2 * np.pi * np.power(self.R_b, 2) * self.Beta * np.power(self.Gamma, 2) * c\n        )\n        return (prefactor * self.u_e).to(""erg s-1"")\n\n    @property\n    def P_jet_B(self):\n        """"""jet power in magnetic field\n\n        .. math::\n            P_{jet,\\,B} = 2 \\pi R_b^2 \\\\beta \\Gamma^2 c \\\\frac{B^2}{8\\pi}\n        """"""\n        prefactor = (\n            2 * np.pi * np.power(self.R_b, 2) * self.Beta * np.power(self.Gamma, 2) * c\n        )\n        return (prefactor * self.U_B).to(""erg s-1"")\n\n    @property\n    def gamma_max_larmor(self):\n        """"""maximum Lorentz factor of electrons that have their Larmour radius \n        smaller than the blob radius: :math:`R_L < R_b`. \n        The Larmor frequency and radius in Gaussian units read\n\n        .. math::\n\n            \\\\omega_L &= \\\\frac{eB}{\\gamma m_e c} \\\\\\\\\n            R_L &= \\\\frac{v}{\\omega_L} = \\\\frac{\\gamma m_e v c}{e B} \\\\approx \\\\frac{\\gamma m_e c^2}{e B}\n\n        therefore\n\n        .. math::\n\n            R_L < R_b \\Rightarrow \\gamma_{\\mathrm{max}} < \\\\frac{R_b e B}{m_e c^2}\n        """"""\n        return (self.R_b * e * self.B_cgs / mec2).to_value("""")\n\n    @property\n    def gamma_max_ballistic(self):\n        r""""""Naive estimation of maximum Lorentz factor of electrons comparing \n        acceleration time scale with ballistic time scale. \n        For the latter we assume that the particles crosses the blob radius.\n\n        .. math::\n\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} &= \\xi c E / R_L \\\\\\\\\n            T_{\\mathrm{acc}} &= E \\,/\\,(\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} = R_L / (\\xi c) \\\\\\\\\n            T_{\\mathrm{bal}} &= R_b / c \\\\\\\\\n            T_{\\mathrm{acc}} &< T_{\\mathrm{bal}} \n            \\Rightarrow \\gamma_{\\mathrm{max}} < \\frac{\\xi  R_b e B}{m_e c^2} \n        """"""\n        return self.xi * self.gamma_max_larmor\n\n    @property\n    def gamma_max_synch(self):\n        r""""""Simple estimation of maximum Lorentz factor of electrons \n        comparing the acceleration time scale with the synchrotron energy loss\n\n        .. math::\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} &= \\xi c E / R_L \\\\\\\\\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}} &= 4 / 3 \\sigma_T c U_B \\gamma^2 \\\\\\\\\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} &= (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}} \n            \\Rightarrow \\gamma_{\\mathrm{max}} < \\sqrt{\\frac{6 \\pi \\xi e}{\\sigma_T B}}\n        """"""\n        return np.sqrt(6 * np.pi * self.xi * e / (sigma_T * self.B_cgs)).to_value("""")\n\n    @property\n    def gamma_max_SSC(self):\n        r""""""Simple estimation of maximum Lorentz factor of electrons \n        comparing the acceleration time scale with the SSC energy loss (in Thomson range)\n        WARNING: the highest energy electrons will most often scatter in Klein-Nishina range instead\n\n        .. math::\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} &= \\xi c E / R_L \\\\\\\\\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{SSC}} &= 4 / 3 \\sigma_T c U_{\\mathrm{synch}} \\gamma^2 \\\\\\\\\n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{acc}} &= (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{SSC}} \n            \\Rightarrow \\gamma_{\\mathrm{max}} < \\sqrt{\\frac{3 \\xi e B }{\\sigma_T U_SSC}}\n        """"""\n        return np.sqrt(\n            3 * self.xi * e * self.B_cgs / (4 * sigma_T * self.u_ph_synch)\n        ).to_value("""")\n\n    def gamma_max_EC_DT(self, dt, r=0 * u.cm):\n        r""""""Simple estimation of maximum Lorentz factor of electrons comparing the acceleration time scale \n        with the EC energy loss (in Thomson range, see B&G 1970), like in gamma_max_SSC \n        WARNING: assumes Thomson regime\n\n        .. math::            \n            \\gamma_{\\mathrm{max}} = \\sqrt{\\frac{3 \\xi e B }{ \\sigma_T U\'_\\mathrm{ext}}} \n        """"""\n        return np.sqrt(\n            3 * self.xi * e * self.B_cgs / (4 * sigma_T * dt.u_ph(r, self))\n        ).to_value("""")\n\n    @property\n    def gamma_break_synch(self):\n        r""""""Simple estimation of the cooling break of electrons comparing \n        synchrotron cooling time scale with the ballistic time scale: \n        \n        .. math::\n\n            T_{\\mathrm{synch}} &= E\\,/\\,(\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}} \n            =  3 m_e c^2 / (4 \\sigma_T U_B \\gamma) \\\\\\\\\n            T_{\\mathrm{bal}} &= R_b / c \\\\\\\\\n            T_{\\mathrm{synch}} &= T_{\\mathrm{bal}} \\Rightarrow \\gamma_b = 6 \\pi m_e c^2 / \\sigma_T B^2 R_b \n        """"""\n        gamma_max = (\n            (6 * np.pi * mec2 / (sigma_T * np.power(self.B_cgs, 2) * self.R_b))\n            .to("""")\n            .value\n        )\n        return gamma_max\n\n    @property\n    def gamma_break_SSC(self):\n        r""""""Simple estimation of the cooling break of electrons comparing \n        SSC time scale (see B&G 1970) with the ballistic time scale: \n        WARNING: only applicable in Thomson regime\n\n        .. math::\n            T_{\\mathrm{SSC}} &= E\\,/\\,(\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{SSC}} \n            =  3 m_e c^2 / (4 \\sigma_T U_{\\mathrm{SSC}} \\gamma) \\\\\\\\\n            T_{\\mathrm{bal}} &= R_b / c \\\\\\\\\n            T_{\\mathrm{SSC}} &= T_{\\mathrm{bal}} \\Rightarrow \\gamma_b = 3  m_e c^2 / 4 \\sigma_T U_{\\mathrm{SSC}} R_b \n        """"""\n        return (3 * mec2 / (4 * sigma_T * self.u_ph_synch * self.R_b)).to("""").value\n\n    def gamma_break_EC_DT(self, dt, r=0 * u.cm):\n        r""""""Simple estimation of the cooling break of electrons comparing \n        EC time scale (see B&G 1970) with the ballistic time scale, like in gamma_break_SSC \n        WARNING: assumes Thomson regime\n\n        .. math::            \n            \\gamma_b = 3  m_e c^2 / 4 \\sigma_T U\'_{\\mathrm{ext}} R_b \n        """"""\n        #        u_ext=np.power(self.Gamma,2) * np.power(1-mu*self.Beta,2) * dt.xi_dt*dt.L_disk/(4*np.pi*np.power(d,2) * c)\n        return (3 * mec2 / (4 * sigma_T * dt.u_ph(r, self) * self.R_b)).to("""").value\n\n    @property\n    def U_B(self):\n        r""""""Energy density of magnetic field\n\n        .. math::\n            U_B = B^2 / (8 \\pi)\n        """"""\n        U_B = np.power(self.B_cgs, 2) / (8 * np.pi)\n        return U_B.to(""erg cm-3"")\n\n    @property\n    def u_ph_synch(self):\n        """"""energy density of the synchrotron photons energy losses are:\n\n        .. math::        \n            (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}} = 4 / 3 \\sigma_T c U_B \\gamma^2 \n\n        the radiation stays an average time of :math:`(3/4) (R_b/c)` (the factor of 3/4 cames from averaging over a sphere), \n        so an e- with Lorentz factor :math:`\\gamma` produces:\n\n        .. math::        \n            0.75\\,(\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}}\\,(R_b/c)\\,/\\,V_b \n\n        of radiation. We need to integrate over the electron spectrum  (and multiply back by V_b)\n\n        .. math::        \n            0.75\\,\\int n_e(\\gamma) (\\mathrm{d}E/\\mathrm{d}t)_{\\mathrm{synch}}  R_b  \\mathrm{d}\\gamma\n        \n        so\n\n        .. math::        \n            u_{\\mathrm{synch}} = \\sigma_T  U_B  R_b  \\int n_e(\\gamma) \\, \\gamma^2 \\mathrm{d}\\gamma\n\n        WARNING: this does not take into account SSA!\n        """"""\n        u_ph = (\n            sigma_T.cgs\n            * self.U_B\n            * self.R_b\n            * np.trapz(np.power(self.gamma, 2) * self.n_e(self.gamma), self.gamma)\n        )\n        return u_ph.to(""erg cm-3"")\n\n    def plot_n_e(self, ax=None, gamma_power=0):\n        """"""plot the  electron distribution\n        \n        Parameters \n        ----------\n        ax : :class:`~matplotlib.axes.Axes`, optional\n            Axis\n        gamma_power : float\n            power of gamma to raise the electron distribution\n        """"""\n        ax = plt.gca() if ax is None else ax\n\n        ax.loglog(self.gamma, np.power(self.gamma, gamma_power) * self.n_e(self.gamma))\n        ax.set_xlabel(r""$\\gamma$"")\n        if gamma_power == 0:\n            ax.set_ylabel(r""$n_e(\\gamma)\\,/\\,{\\rm cm}^{-3}$"")\n        else:\n            ax.set_ylabel(\n                r""$\\gamma^{""\n                + str(gamma_power)\n                + r""}$""\n                + r""$\\,n_e(\\gamma)\\,/\\,{\\rm cm}^{-3}$""\n            )\n        return ax\n'"
agnpy/spectra.py,34,"b'import numpy as np\nimport astropy.units as u\nimport astropy.constants as const\n\n\nMEC2 = (const.m_e * const.c * const.c).cgs\n\n\n__all__ = [""PowerLaw"", ""BrokenPowerLaw"", ""BrokenPowerLaw2""]\n\n\n# in the following functions k_e is supposed to have dimensions cm-3\ndef _power_law(gamma, k_e, p, gamma_min, gamma_max):\n    """"""simple power law""""""\n    pwl = np.power(gamma, -p)\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return k_e * pwl\n\n\ndef _power_law_ssa_integrand(gamma, k_e, p, gamma_min, gamma_max):\n    """"""analytical form of the SSA integrand""""""\n    pwl = np.power(gamma, -p - 1)\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return (-p - 2) * k_e * pwl\n\n\ndef _broken_power_law(gamma, k_e, p1, p2, gamma_b, gamma_min, gamma_max):\n    """"""power law with two spectral indices""""""\n    pwl = np.power(gamma / gamma_b, -p1)\n    # compute power law with the second spectral index\n    p2_condition = gamma > gamma_b\n    pwl[p2_condition] = np.power(gamma[p2_condition] / gamma_b, -p2)\n    # return zero outside minimum and maximum Lorentz factor values\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return k_e * pwl\n\n\ndef _broken_power_law_ssa_integrand(gamma, k_e, p1, p2, gamma_b, gamma_min, gamma_max):\n    """"""analytical form of the SSA integrand""""""\n    pwl = np.power(gamma / gamma_b, -p1 - 1)\n    pwl_prefactor = (-p1 - 2) / gamma\n    # compute power law with the second spectral index\n    p2_condition = gamma > gamma_b\n    pwl[p2_condition] = np.power(gamma[p2_condition] / gamma_b, -p2 - 1)\n    pwl_prefactor[p2_condition] = (-p2 - 2) / gamma[p2_condition]\n    # return zero outside minimum and maximum Lorentz factor values\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return k_e * pwl_prefactor * pwl\n\n\ndef _broken_power_law_2(gamma, k_e, p1, p2, gamma_b, gamma_min, gamma_max):\n    """"""Tavecchio\'s Broken Power Law\n    https://ui.adsabs.harvard.edu/abs/1998ApJ...509..608T/abstract""""""\n    pwl = np.power(gamma, -p1)\n    p2_condition = gamma > gamma_b\n    pwl[p2_condition] = np.power(gamma_b, p2 - p1) * np.power(gamma[p2_condition], -p2)\n    # return zero outside minimum and maximum Lorentz factor values\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return k_e * pwl\n\n\ndef _broken_power_law_2_ssa_integrand(\n    gamma, k_e, p1, p2, gamma_b, gamma_min, gamma_max\n):\n    """"""analytical form of the SSA integrand""""""\n    pwl = (-p1 - 2) * np.power(gamma, -p1 - 1)\n    # compute power law with the second spectral index\n    p2_condition = gamma > gamma_b\n    pwl[p2_condition] = (\n        (-p2 - 2) * np.power(gamma_b, p2 - p1) * np.power(gamma[p2_condition], -p2 - 1)\n    )\n    # return zero outside minimum and maximum Lorentz factor values\n    null_condition = (gamma_min <= gamma) * (gamma <= gamma_max)\n    pwl[~null_condition] = 0\n    return k_e * pwl\n\n\nclass PowerLaw:\n    """"""Class for power-law particle spectrum. \n    When called, the particle density :math:`n_e(\\gamma)` in :math:`\\mathrm{cm}^{-3}` is returned.\n\n    .. math::\n        n_e(\\gamma\') = k_e \\, \\gamma\'^{-p} \\, H(\\gamma\'; \\gamma\'_{min}, \\gamma\'_{max}) \n\n    Parameters\n    ----------\n    k_e : :class:`~astropy.units.Quantity`\n        spectral normalisation\n    p : float\n        spectral index, note it is positive by definition, will change sign in the function\n    gamma_min : float\n        minimum Lorentz factor of the electron distribution\n    gamma_max : float\n        maximum Lorentz factor of the electron distribution\n    """"""\n\n    def __init__(self, k_e=1e-13 * u.Unit(""cm-3""), p=2.0, gamma_min=10, gamma_max=1e5):\n        self.k_e = k_e\n        self.p = p\n        self.gamma_min = gamma_min\n        self.gamma_max = gamma_max\n\n    def __call__(self, gamma):\n        return _power_law(gamma, self.k_e, self.p, self.gamma_min, self.gamma_max)\n\n    def __str__(self):\n        return (\n            f""* electron spectrum\\n""\n            + f"" - power law\\n""\n            + f"" - k_e: {self.k_e:.2e}\\n""\n            + f"" - p: {self.p:.2f}\\n""\n            + f"" - gamma_min: {self.gamma_min:.2e}\\n""\n            + f"" - gamma_max: {self.gamma_max:.2e}\\n""\n        )\n\n    @classmethod\n    def from_normalised_u_e(cls, u_e, p, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total energy density \n        :math:`u_e`, Eq. 6.64 in [DermerMenon2009]_""""""\n        # avoid and exact value of 2 for the index that will make the analytical\n        # simplification diverge\n        if np.isclose(p, 2.0):\n            p += 1e-3\n        k_e_num = (p - 2) * u_e\n        k_e_denum = MEC2 * (np.power(gamma_min, 2 - p) - np.power(gamma_max, 2 - p))\n        k_e = (k_e_num / k_e_denum).to(""cm-3"")\n        return cls(k_e, p, gamma_min, gamma_max)\n\n    @classmethod\n    def from_normalised_density(cls, norm, p, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total particle density \n        :math:`n_{e,\\,tot}`""""""\n        # avoid and exact value of 1 for the index that will make the analytical\n        # simplification diverge\n        if np.isclose(p, 1.0):\n            p += 1e-3\n        k_e_num = (p - 1) * norm\n        k_e_denum = np.power(gamma_min, 1 - p) - np.power(gamma_max, 1 - p)\n        k_e = (k_e_num / k_e_denum).to(""cm-3"")\n        return cls(k_e, p, gamma_min, gamma_max)\n\n    @classmethod\n    def from_norm_at_gamma_1(cls, norm, p, gamma_min, gamma_max):\n        """"""sets :math:`k_e` such that `norm` = :math:`n_e(\\gamma=1)`.""""""\n        return cls(norm.to(""cm-3""), p, gamma_min, gamma_max)\n\n    def SSA_integrand(self, gamma):\n        """"""integrand for the synchrotron self-absorption:\n        :math:`\\gamma\'^2 \\\\frac{d}{d \\gamma\'} \\left(\\\\frac{n_e}{\\gamma\'^2}\\\\right)`""""""\n        return _power_law_ssa_integrand(\n            gamma, self.k_e, self.p, self.gamma_min, self.gamma_max\n        )\n\n\nclass BrokenPowerLaw:\n    """"""Class for broken power-law particle spectrum\n    When called, the particle density :math:`n_e(\\gamma)` in :math:`\\mathrm{cm}^{-3}` is returned.\n\n    .. math::\n        n_e(\\gamma\') = k_e \\left[\n        \\left(\\\\frac{\\gamma\'}{\\gamma_b}\\\\right)^{-p_1} \\, H(\\gamma\'; \\gamma\'_{min}, \\gamma\'_b) +\n        \\left(\\\\frac{\\gamma\'}{\\gamma_b}\\\\right)^{-p_2} \\, H(\\gamma\'; \\gamma\'_{b}, \\gamma\'_{max}) \n        \\\\right]\n\n    Parameters\n    ----------\n    k_e : :class:`~astropy.units.Quantity`\n        spectral normalisation\n    p1 : float\n        spectral index before the break (positive by definition)\n    p2 : float\n        spectral index after the break (positive by definition)   \n    gamma_b : float\n        Lorentz factor at which the change in spectral index is occurring \n    gamma_min : float\n        minimum Lorentz factor of the electron distribution\n    gamma_max : float\n        maximum Lorentz factor of the electron distribution\n    """"""\n\n    def __init__(\n        self,\n        k_e=1e-13 * u.Unit(""cm-3""),\n        p1=2.0,\n        p2=3.0,\n        gamma_b=1e3,\n        gamma_min=10,\n        gamma_max=1e5,\n    ):\n        self.k_e = k_e\n        self.p1 = p1\n        self.p2 = p2\n        self.gamma_b = gamma_b\n        self.gamma_min = gamma_min\n        self.gamma_max = gamma_max\n\n    def __call__(self, gamma):\n        return _broken_power_law(\n            gamma,\n            self.k_e,\n            self.p1,\n            self.p2,\n            self.gamma_b,\n            self.gamma_min,\n            self.gamma_max,\n        )\n\n    def __str__(self):\n        return (\n            f""* electron spectrum\\n""\n            + f"" - broken power law\\n""\n            + f"" - k_e: {self.k_e:.2e}\\n""\n            + f"" - p1: {self.p1:.2f}\\n""\n            + f"" - p2: {self.p2:.2f}\\n""\n            + f"" - gamma_b: {self.gamma_b:.2e}\\n""\n            + f"" - gamma_min: {self.gamma_min:.2e}\\n""\n            + f"" - gamma_max: {self.gamma_max:.2e}\\n""\n        )\n\n    @classmethod\n    def from_normalised_u_e(cls, u_e, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total energy density \n        :math:`u_e`, Eq. 6.64 in [DermerMenon2009]_""""""\n        if np.isclose(p1, 2.0):\n            p1 += 1e-3\n        if np.isclose(p2, 2.0):\n            p2 += 1e-3\n        denum_prefactor = MEC2 * np.power(gamma_b, 2)\n        denum_term_1 = (1 - np.power(gamma_min / gamma_b, 2 - p1)) / (2 - p1)\n        denum_term_2 = (np.power(gamma_max / gamma_b, 2 - p2) - 1) / (2 - p2)\n        k_e = (u_e / (denum_prefactor * (denum_term_1 + denum_term_2))).to(""cm-3"")\n        return cls(k_e, p1, p2, gamma_b, gamma_min, gamma_max)\n\n    @classmethod\n    def from_normalised_density(cls, norm, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total particle density \n        :math:`n_{e,\\,tot}`""""""\n        if np.isclose(p1, 1.0):\n            p1 += 1e-3\n        if np.isclose(p2, 1.0):\n            p2 += 1e-3\n        k_e_denum_1 = (gamma_min * np.power(gamma_min / gamma_b, -p1) - gamma_b) / (\n            p1 - 1\n        )\n        k_e_denum_2 = (gamma_b - gamma_max * np.power(gamma_max / gamma_b, -p2)) / (\n            p2 - 1\n        )\n        k_e = (norm / (k_e_denum_1 + k_e_denum_2)).to(""cm-3"")\n        return cls(k_e, p1, p2, gamma_b, gamma_min, gamma_max)\n\n    @classmethod\n    def from_norm_at_gamma_1(cls, norm, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""sets :math:`k_e` such that `norm` = :math:`n_e(\\gamma=1)`.""""""\n        k_e = norm.to(""cm-3"") * np.power(gamma_b, -p1)\n        print(\n            f""normalising broken power-law to value {norm:.2e} at gamma = 1, and {k_e: .2e} at gamma_b = {gamma_b:.2e}""\n        )\n        return cls(k_e, p1, p2, gamma_b, gamma_min, gamma_max)\n\n    def SSA_integrand(self, gamma):\n        """"""integrand for the synchrotron self-absorption:\n        :math:`\\gamma\'^2 \\\\frac{d}{d \\gamma\'} \\left(\\\\frac{n_e}{\\gamma\'^2}\\\\right)`""""""\n        return _broken_power_law_ssa_integrand(\n            gamma,\n            self.k_e,\n            self.p1,\n            self.p2,\n            self.gamma_b,\n            self.gamma_min,\n            self.gamma_max,\n        )\n\n\nclass BrokenPowerLaw2:\n    """"""Broken power law as in Eq. 1 of [Tavecchio1998]_.\n    When called, the particle density :math:`n_e(\\gamma)` in :math:`\\mathrm{cm}^{-3}` is returned.\n\n    .. math::\n        n_e(\\gamma\') = k_e \\left[\n        \\gamma\'^{-p_1} \\, H(\\gamma\'; \\gamma\'_{min}, \\gamma\'_b) +\n        \\gamma\'^{(p_2 - p_1)}_b \\, \\gamma\'^{-p_2} \\, H(\\gamma\'; \\gamma\'_{b}, \\gamma\'_{max}) \n        \\\\right]\n\n    Parameters\n    ----------\n    k_e : :class:`~astropy.units.Quantity`\n        spectral normalisation\n    p1 : float\n        spectral index before the break (positive by definition)\n    p2 : float\n        spectral index after the break (positive by definition)   \n    gamma_b : float\n        Lorentz factor at which the change in spectral index is occurring \n    gamma_min : float\n        minimum Lorentz factor of the electron distribution\n    gamma_max : float\n        maximum Lorentz factor of the electron distribution\n    """"""\n\n    def __init__(\n        self,\n        k_e=1e-13 * u.Unit(""cm-3""),\n        p1=2.0,\n        p2=3.0,\n        gamma_b=1e3,\n        gamma_min=10,\n        gamma_max=1e5,\n    ):\n        self.k_e = k_e\n        self.p1 = p1\n        self.p2 = p2\n        self.gamma_b = gamma_b\n        self.gamma_min = gamma_min\n        self.gamma_max = gamma_max\n\n    def __call__(self, gamma):\n        return _broken_power_law_2(\n            gamma,\n            self.k_e,\n            self.p1,\n            self.p2,\n            self.gamma_b,\n            self.gamma_min,\n            self.gamma_max,\n        )\n\n    def __str__(self):\n        return (\n            f""* electron spectrum\\n""\n            + f"" - broken power law 2\\n""\n            + f"" - k_e: {self.k_e:.2e}\\n""\n            + f"" - p1: {self.p1:.2f}\\n""\n            + f"" - p2: {self.p2:.2f}\\n""\n            + f"" - gamma_b: {self.gamma_b:.2e}\\n""\n            + f"" - gamma_min: {self.gamma_min:.2e}\\n""\n            + f"" - gamma_max: {self.gamma_max:.2e}\\n""\n        )\n\n    @classmethod\n    def from_normalised_u_e(cls, u_e, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total energy density \n        :math:`u_e`, Eq. 6.64 in [DermerMenon2009]_""""""\n        if np.isclose(p1, 2.0):\n            p1 += 1e-3\n        if np.isclose(p2, 2.0):\n            p2 += 1e-3\n        k_e_denum_1 = (np.power(gamma_b, 2 - p1) - np.power(gamma_min, 2 - p1)) / (\n            2 - p1\n        )\n        k_e_denum_2 = (\n            np.power(gamma_b, p2 - p1)\n            * (np.power(gamma_max, 2 - p2) - np.power(gamma_b, 2 - p2))\n            / (2 - p2)\n        )\n        k_e = (u_e / (MEC2 * (k_e_denum_1 + k_e_denum_2))).to(""cm-3"")\n        return cls(k_e, p1, p2, gamma_b, gamma_min, gamma_max)\n\n    @classmethod\n    def from_normalised_density(cls, norm, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""set the normalisation :math:`k_e` from the total particle density \n        :math:`n_{e,\\,tot}`""""""\n        if np.isclose(p1, 1.0):\n            p1 += 1e-3\n        if np.isclose(p2, 1.0):\n            p2 += 1e-3\n        k_e_denum_1 = (np.power(gamma_b, 1 - p1) - np.power(gamma_min, 1 - p1)) / (\n            1 - p1\n        )\n        k_e_denum_2 = (\n            np.power(gamma_b, p2 - p1)\n            * (np.power(gamma_max, 1 - p2) - np.power(gamma_b, 1 - p2))\n            / (1 - p2)\n        )\n        k_e = (norm / (k_e_denum_1 + k_e_denum_2)).to(""cm-3"")\n        return cls(k_e, p1, p2, gamma_b, gamma_min, gamma_max)\n\n    @classmethod\n    def from_norm_at_gamma_1(cls, norm, p1, p2, gamma_b, gamma_min, gamma_max):\n        """"""sets :math:`k_e` such that `spectrum_norm` = :math:`n_e(\\gamma=1)`.""""""\n        return cls(norm.to(""cm-3""), p1, p2, gamma_b, gamma_min, gamma_max)\n\n    def SSA_integrand(self, gamma):\n        """"""integrand for the synchrotron self-absorption:\n        :math:`\\gamma\'^2 \\\\frac{d}{d \\gamma\'} \\left(\\\\frac{n_e}{\\gamma\'^2}\\\\right)`""""""\n        return _broken_power_law_2_ssa_integrand(\n            gamma,\n            self.k_e,\n            self.p1,\n            self.p2,\n            self.gamma_b,\n            self.gamma_min,\n            self.gamma_max,\n        )\n'"
agnpy/synchrotron.py,26,"b'import numpy as np\nfrom astropy.constants import h, e, c, m_e, sigma_T\nimport astropy.units as u\n\n\ne = e.gauss\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\nB_cr = 4.414e13 * u.G  # critical magnetic field\nlambda_c = (h / (m_e * c)).to(""cm"")  # Compton wavelength\n# equivalency to transform frequencies to energies in electron rest mass units\nepsilon_equivalency = [\n    (u.Hz, u.Unit(""""), lambda x: h.cgs * x / mec2, lambda x: x * mec2 / h.cgs)\n]\n\n\n__all__ = [""R"", ""U_B"", ""Synchrotron""]\n\n\ndef R(x):\n    """"""Eq. 7.45 in [Dermer2009]_, angle-averaged integrand of the radiated power, the \n    approximation of this function, given in Eq. D7 of [Aharonian2010]_, is used.\n    """"""\n    term_1_num = 1.808 * np.power(x, 1 / 3)\n    term_1_denom = np.sqrt(1 + 3.4 * np.power(x, 2 / 3))\n    term_2_num = 1 + 2.21 * np.power(x, 2 / 3) + 0.347 * np.power(x, 4 / 3)\n    term_2_denom = 1 + 1.353 * np.power(x, 2 / 3) + 0.217 * np.power(x, 4 / 3)\n    return term_1_num / term_1_denom * term_2_num / term_2_denom * np.exp(-x)\n\n\ndef U_B(B):\n    """""":math:`U_B` Eq. 7.14 in [DermerMenon2009]_""""""\n    return (np.power(B, 2) / (8 * np.pi)).to(""erg cm-3"")\n\n\ndef nu_B(B):\n    """""":math:`\\\\nu_B` Eq. 7.19 in [DermerMenon2009]_""""""\n    return (e * B / (2 * np.pi * m_e * c)).to(""Hz"")\n\n\nclass Synchrotron:\n    """"""Class for synchrotron radiation computation\n\n    Parameters\n    ----------\n    blob : :class:`~agnpy.emission_region.Blob`\n        emitting region and electron distribution \n        \n    ssa : bool\n        whether or not to consider synchrotron self absorption (SSA).    \n        The absorption factor will be taken into account in\n        :func:`~agnpy.synchrotron.Synchrotron.com_sed_emissivity`, in order to be\n        propagated to :func:`~agnpy.synchrotron.Synchrotron.sed_luminosity` and\n        :func:`~agnpy.synchrotron.Synchrotron.sed_flux`.\n\t""""""\n\n    def __init__(self, blob, ssa=False):\n        self.blob = blob\n        self.U_B = U_B(self.blob.B_cgs)\n        self.nu_B = nu_B(self.blob.B_cgs)\n        self.epsilon_B = (self.blob.B / B_cr).to_value("""")\n        self.ssa = ssa\n\n    def k_epsilon(self, epsilon):\n        """"""SSA absorption factor Eq. 7.142 in [DermerMenon2009]_.\n        The part of the integrand that is dependent on :math:`\\gamma` is \n        computed analytically in each of the :class:`~agnpy.spectra` classes.""""""\n        gamma = self.blob.gamma\n        SSA_integrand = self.blob.n_e.SSA_integrand(gamma)\n        # for multidimensional integration\n        # axis 0: electrons gamma\n        # axis 1: photons epsilon\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(gamma, (gamma.size, 1))\n        _SSA_integrand = np.reshape(SSA_integrand, (SSA_integrand.size, 1))\n        _epsilon = np.reshape(epsilon, (1, epsilon.size))\n        prefactor_P_syn = np.sqrt(3) * np.power(e, 3) * self.blob.B_cgs / h\n        prefactor_k_epsilon = (\n            -1 / (8 * np.pi * m_e * np.power(epsilon, 2)) * np.power(lambda_c / c, 3)\n        )\n        x_num = 4 * np.pi * _epsilon * np.power(m_e, 2) * np.power(c, 3)\n        x_denom = 3 * e * self.blob.B_cgs * h * np.power(_gamma, 2)\n        x = (x_num / x_denom).to_value("""")\n        integrand = R(x) * _SSA_integrand\n        integral = np.trapz(integrand, gamma, axis=0)\n        return (prefactor_P_syn * prefactor_k_epsilon * integral).to(""cm-1"")\n\n    def tau_ssa(self, epsilon):\n        """"""SSA opacity, Eq. before 7.122 in [DermerMenon2009]_""""""\n        return (2 * self.k_epsilon(epsilon) * self.blob.R_b).to_value("""")\n\n    def attenuation_ssa(self, epsilon):\n        """"""SSA attenuation, Eq. 7.122 in [DermerMenon2009]_""""""\n        tau = self.tau_ssa(epsilon)\n        u = 1 / 2 + np.exp(-tau) / tau - (1 - np.exp(-tau)) / np.power(tau, 2)\n        attenuation = 3 * u / tau\n        condition = tau < 1e-3\n        attenuation[condition] = 1\n        return attenuation\n\n    def com_sed_emissivity(self, epsilon):\n        """"""Synchrotron  emissivity:\n\n        .. math::\n            \\epsilon\'\\,J\'_{\\mathrm{syn}}(\\epsilon\')\\,[\\mathrm{erg}\\,\\mathrm{s}^{-1}]\n\n        Eq. 7.116 in [DermerMenon2009]_ or Eq. 18 in [Finke2008]_.\n\n        The **SSA** is taken into account by this function and propagated\n        to the other ones computing SEDs by invoking this one. \n\n        **Note:** This emissivity is computed in the co-moving frame of the blob.\n        When calling this function from another, these energies\n        have to be transformed in the co-moving frame of the plasmoid.\n        \n        Parameters\n        ----------\n        epsilon : :class:`~numpy.ndarray`\n            array of dimensionless energies (in electron rest mass units) \n            to compute the sed, :math:`\\epsilon = h\\\\nu / (m_e c^2)`\n\n        Returns\n        -------\n        :class:`~astropy.units.Quantity`\n            array of the emissivity corresponding to each dimensionless energy\n        """"""\n        gamma = self.blob.gamma\n        N_e = self.blob.N_e(gamma)\n        prefactor = np.sqrt(3) * epsilon * np.power(e, 3) * self.blob.B_cgs / h\n        # for multidimensional integration\n        # axis 0: electrons gamma\n        # axis 1: photons epsilon\n        # arrays starting with _ are multidimensional and used for integration\n        _gamma = np.reshape(gamma, (gamma.size, 1))\n        _N_e = np.reshape(N_e, (N_e.size, 1))\n        _epsilon = np.reshape(epsilon, (1, epsilon.size))\n        x_num = 4 * np.pi * _epsilon * np.power(m_e, 2) * np.power(c, 3)\n        x_denom = 3 * e * self.blob.B_cgs * h * np.power(_gamma, 2)\n        x = (x_num / x_denom).to_value("""")\n        integrand = _N_e * R(x)\n        integral = np.trapz(integrand, gamma, axis=0)\n        emissivity = (prefactor * integral).to(""erg s-1"")\n        if self.ssa:\n            emissivity *= self.attenuation_ssa(epsilon)\n        return emissivity.to(""erg s-1"")\n\n    def sed_luminosity(self, nu):\n        """"""Synchrotron luminosity SED: \n\n        .. math::\n            \\\\nu L_{\\\\nu} \\, [\\mathrm{erg}\\,\\mathrm{s}^{-1}]\n\n        Parameters\n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n\n        Returns\n        -------\n        :class:`~astropy.units.Quantity`\n            array of the SED values corresponding to each frequency\n        """"""\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        # correct epsilon to the jet comoving frame\n        epsilon_prime = (1 + self.blob.z) * epsilon / self.blob.delta_D\n        prefactor = np.power(self.blob.delta_D, 4)\n        return prefactor * self.com_sed_emissivity(epsilon_prime)\n\n    def sed_flux(self, nu):\n        """"""Synchrotron flux SED:\n\n        .. math::\n            \\\\nu F_{\\\\nu} \\, [\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}]\n\n        Eq. 21 in [Finke2008]_.\n\n        Parameters\n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n\n        Returns\n        -------\n        :class:`~astropy.units.Quantity`\n            array of the SED values corresponding to each frequency\n        """"""\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        # correct epsilon to the jet comoving frame\n        epsilon_prime = (1 + self.blob.z) * epsilon / self.blob.delta_D\n        prefactor = np.power(self.blob.delta_D, 4) / (\n            4 * np.pi * np.power(self.blob.d_L, 2)\n        )\n        sed = prefactor * self.com_sed_emissivity(epsilon_prime)\n        return sed.to(""erg cm-2 s-1"")\n\n    def sed_peak_flux(self, nu):\n        """"""provided a grid of frequencies nu, returns the peak flux of the SED\n        """"""\n        return self.sed_flux(nu).max()\n\n    def sed_peak_nu(self, nu):\n        """"""provided a grid of frequencies nu, returns the frequency at which the SED peaks\n        """"""\n        idx_max = self.sed_flux(nu).argmax()\n        return nu[idx_max]\n'"
agnpy/targets.py,43,"b'import numpy as np\nfrom astropy.constants import m_e, h, c, k_B, M_sun, G\nimport astropy.units as u\nfrom astropy.coordinates import Distance\n\n\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\nlambda_c = (h / (m_e * c)).to(""cm"")  # Compton wavelength\n# equivalency to transform frequencies to energies in electron rest mass units\nepsilon_equivalency = [\n    (u.Hz, u.Unit(""""), lambda x: h.cgs * x / mec2, lambda x: x * mec2 / h.cgs)\n]\n\n\n# dictionary with all the available spectral lines\nlines_dictionary = {\n    ""Lyepsilon"": {""lambda"": 937.80 * u.Angstrom, ""R_Hbeta_ratio"": 2.7},\n    ""Lydelta"": {""lambda"": 949.74 * u.Angstrom, ""R_Hbeta_ratio"": 2.8},\n    ""CIII"": {""lambda"": 977.02 * u.Angstrom, ""R_Hbeta_ratio"": 0.83},\n    ""NIII"": {""lambda"": 990.69 * u.Angstrom, ""R_Hbeta_ratio"": 0.85},\n    ""Lybeta"": {""lambda"": 1025.72 * u.Angstrom, ""R_Hbeta_ratio"": 1.2},\n    ""OVI"": {""lambda"": 1033.83 * u.Angstrom, ""R_Hbeta_ratio"": 1.2},\n    ""ArI"": {""lambda"": 1066.66 * u.Angstrom, ""R_Hbeta_ratio"": 4.5},\n    ""Lyalpha"": {""lambda"": 1215.67 * u.Angstrom, ""R_Hbeta_ratio"": 0.27},\n    ""OI"": {""lambda"": 1304.35 * u.Angstrom, ""R_Hbeta_ratio"": 4.0},\n    ""SiII"": {""lambda"": 1306.82 * u.Angstrom, ""R_Hbeta_ratio"": 4.0},\n    ""SiIV"": {""lambda"": 1396.76 * u.Angstrom, ""R_Hbeta_ratio"": 0.83},\n    ""OIV]"": {""lambda"": 1402.06 * u.Angstrom, ""R_Hbeta_ratio"": 0.83},\n    ""CIV"": {""lambda"": 1549.06 * u.Angstrom, ""R_Hbeta_ratio"": 0.83},\n    ""NIV"": {""lambda"": 1718.55 * u.Angstrom, ""R_Hbeta_ratio"": 3.8},\n    ""AlII"": {""lambda"": 1721.89 * u.Angstrom, ""R_Hbeta_ratio"": 3.8},\n    ""CIII]"": {""lambda"": 1908.73 * u.Angstrom, ""R_Hbeta_ratio"": 0.46},\n    ""[NeIV]"": {""lambda"": 2423.83 * u.Angstrom, ""R_Hbeta_ratio"": 5.8},\n    ""MgII"": {""lambda"": 2798.75 * u.Angstrom, ""R_Hbeta_ratio"": 0.45},\n    ""HeI"": {""lambda"": 3188.67 * u.Angstrom, ""R_Hbeta_ratio"": 4.3},\n    ""Hdelta"": {""lambda"": 4102.89 * u.Angstrom, ""R_Hbeta_ratio"": 3.4},\n    ""Hgamma"": {""lambda"": 4341.68 * u.Angstrom, ""R_Hbeta_ratio"": 3.2},\n    ""HeII"": {""lambda"": 4687.02 * u.Angstrom, ""R_Hbeta_ratio"": 0.63},\n    ""Hbeta"": {""lambda"": 4862.68 * u.Angstrom, ""R_Hbeta_ratio"": 1.0},\n    ""[ClIII]"": {""lambda"": 5539.43 * u.Angstrom, ""R_Hbeta_ratio"": 4.8},\n    ""HeI"": {""lambda"": 5877.29 * u.Angstrom, ""R_Hbeta_ratio"": 0.39},\n    ""Halpha"": {""lambda"": 6564.61 * u.Angstrom, ""R_Hbeta_ratio"": 1.3},\n}\n\n\n__all__ = [\n    ""CMB"",\n    ""SSDisk"",\n    ""PointSourceBehindJet"",\n    ""SphericalShellBLR"",\n    ""RingDustTorus"",\n    ""print_lines_list"",\n]\n\n\ndef print_lines_list():\n    r""""""Print the list of the available spectral lines.\n    The dictionary with the possible emission lines is taken from Table 5 in \n    [Finke2016]_ and contains the value of the line wavelength and the ratio of \n    its radius to the radius of the :math:`H_{\\beta}` shell, not used at the moment.\n    """"""\n    for line in lines_dictionary.keys():\n        print(f""{line}: {lines_dictionary[line]}"")\n\n\ndef I_epsilon_bb(epsilon, Theta):\n    r""""""Black-Body intensity :math:`I_{\\nu}^{bb}`, Eq. 5.15 of [DermerMenon2009]_.\n\n    Parameters\n    ----------\n    epsilon : :class:`~numpy.ndarray`\n        array of dimensionless energies (in electron rest mass units) \n    Theta : float \n        dimensionless temperature of the Black Body \n    """"""\n    num = 2 * m_e * np.power(c, 3) * np.power(epsilon, 3)\n    denum = np.power(lambda_c, 3) * (np.exp(epsilon / Theta) - 1)\n    I = num / denum\n    return I.to(""erg cm-2 s-1"")\n\n\nclass CMB:\n    """"""Cosmic Microwave Background radiation, approximated as an isotropic\n    monochromatic target.\n    \n    Parameters\n    ----------\n    z : float\n        redshift at which the CMB is considered\n    """"""\n\n    def __init__(self, z):\n        self.name = ""Cosmic Microwave Background Radiation""\n        a = 7.5657 * 1e-15 * u.Unit(""erg cm-3 K-4"")  # radiation constant\n        T = 2.72548 * u.K\n        self.u_0 = (a * np.power(T, 4)).to(""erg cm-3"") * np.power(1 + z, 4)\n        self.epsilon_0 = (2.7 * k_B * T / mec2).to_value("""") * (1 + z)\n\n    def u(self, blob=None):\n        """"""integral energy density of the CMB\n\n        Parameters\n        ----------\n        blob : :class:`~agnpy.emission_regions.Blob`\n            if provided, the energy density is computed in a reference frame \n            comvoing with the blob\n        """"""\n        if blob:\n            return self.u_0 * np.power(blob.Gamma, 2) * (1 + np.power(blob.Beta, 2) / 3)\n        else:\n            return self.u_0\n\n\nclass PointSourceBehindJet:\n    """"""Monochromatic point source behind the jet.\n    \n    Parameters\n    ----------\n    L_0 : :class:`~astropy.units.Quantity`\n        luminosity of the source\n    epsilon_0 : float\n        dimensionless monochromatic energy of the source\n    """"""\n\n    def __init__(self, L_0, epsilon_0):\n        self.name = ""Monochromatic Point Source Behind the Jet""\n        self.L_0 = L_0\n        self.epsilon_0 = epsilon_0\n\n    def u(self, r, blob=None):\n        """"""integral energy density of the point source at distance r along the \n        jet axis\n\n        Parameters\n        ----------\n        r : :class:`~astropy.units.Quantity`\n            array of distances along the jet axis\n        blob : :class:`~agnpy.emission_regions.Blob`\n            if provided, the energy density is computed in a reference frame \n            comvoing with the blob\n        """"""\n        u_0 = (self.L_0 / (4 * np.pi * c * np.power(r, 2))).to(""erg cm-3"")\n        if blob:\n            return self.u_0 / (np.power(blob.Gamma, 2) * np.power(1 + blob.Beta, 2))\n        else:\n            return self.u_0\n\n\nclass SSDisk:\n    """"""[Shakura1973]_ accretion disk.\n\n    Parameters\n    ----------\n    M_BH : :class:`~astropy.units.Quantity`\n        Black Hole mass    \n    L_disk : :class:`~astropy.units.Quantity`\n        luminosity of the disk \n    eta : float\n        accretion efficiency\n    R_in : :class:`~astropy.units.Quantity` / float\n        inner disk radius\n    R_out : :class:`~astropy.units.Quantity` / float\n        outer disk radius\n    R_g_units : bool\n        whether or not input radiuses are specified in units of the gravitational radius\n    """"""\n\n    def __init__(self, M_BH, L_disk, eta, R_in, R_out, R_g_units=False):\n        self.name = ""Shakura Sunyaev Accretion Disk""\n        # masses and luminosities\n        self.M_BH = M_BH\n        self.M_8 = (M_BH / (1e8 * M_sun)).to_value("""")\n        self.L_Edd = 1.26 * 1e46 * self.M_8 * u.Unit(""erg s-1"")\n        self.L_disk = L_disk\n        # fraction of the Eddington luminosity at which the disk is accreting\n        self.l_Edd = (self.L_disk / self.L_Edd).to_value("""")\n        self.eta = eta\n        self.m_dot = (self.L_disk / (self.eta * np.power(c, 2))).to(""g s-1"")\n        # gravitational radius\n        self.R_g = (G * self.M_BH / np.power(c, 2)).to(""cm"")\n        if R_g_units:\n            # check that numbers have been passed\n            R_in_unit_check = isinstance(R_in, int) or isinstance(R_in, float)\n            R_out_unit_check = isinstance(R_out, int) or isinstance(R_out, float)\n            if R_in_unit_check and R_out_unit_check:\n                self.R_in = R_in * self.R_g\n                self.R_out = R_out * self.R_g\n                self.R_in_tilde = R_in\n                self.R_out_tilde = R_out\n            else:\n                raise TypeError(""R_in / R_out passed with units, int / float expected"")\n        else:\n            # check that quantities have been passed\n            R_in_unit_check = isinstance(R_in, u.Quantity)\n            R_out_unit_check = isinstance(R_out, u.Quantity)\n            if R_in_unit_check and R_out_unit_check:\n                self.R_in = R_in\n                self.R_out = R_out\n                self.R_in_tilde = (self.R_in / self.R_g).to_value("""")\n                self.R_out_tilde = (self.R_out / self.R_g).to_value("""")\n            else:\n                raise TypeError(""R_in / R_out passed without units"")\n        # array of R_tile values\n        self.R_tilde = np.linspace(self.R_in_tilde, self.R_out_tilde)\n\n    def __str__(self):\n        return (\n            f""* Shakura Sunyaev accretion disk:\\n""\n            + f"" - M_BH (central black hole mass): {self.M_BH.cgs:.2e}\\n""\n            + f"" - L_disk (disk luminosity): {self.L_disk.cgs:.2e}\\n""\n            + f"" - eta (accretion efficiency): {self.eta:.2e}\\n""\n            + f"" - dot(m) (mass accretion rate): {self.m_dot.cgs:.2e}\\n""\n            + f"" - R_in (disk inner radius): {self.R_in.cgs:.2e}\\n""\n            + f"" - R_out (disk inner radius): {self.R_out.cgs:.2e}""\n        )\n\n    def mu_from_r_tilde(self, r_tilde, size=100):\n        r""""""array of cosine angles, spanning from :math:`R_{\\mathrm{in}}` to \n        :math:`R_{\\mathrm{out}}`, viewed from a given distance :math:`\\tilde{r}` \n        along the jet axis, Eq. 72 and 73 in [Finke2016]_.""""""\n        mu_min = 1 / np.sqrt(1 + np.power((self.R_out_tilde / r_tilde), 2))\n        mu_max = 1 / np.sqrt(1 + np.power((self.R_in_tilde / r_tilde), 2))\n        return np.linspace(mu_min, mu_max, size)\n\n    def phi_disk(self, R_tilde):\n        """"""Radial dependency of disk temperature, Eq. 63 in [Dermer2009]_.\n\n        Parameters\n        ----------\n        R_tilde : :class:`~nump.ndarray`\n            radial coordinate along the disk normalised to R_g\n        """"""\n        return 1 - np.sqrt(self.R_in_tilde / R_tilde)\n\n    def phi_disk_mu(self, mu, r_tilde):\n        r""""""same as phi_disk but computed with cosine of zenith mu and normalised \n        distance from the black hole :math:`\\tilde{r}` Eq. 67 in [Dermer2009]_.""""""\n        R_tilde = r_tilde * np.sqrt(np.power(mu, -2) - 1)\n        return self.phi_disk(R_tilde)\n\n    def epsilon(self, R_tilde):\n        r""""""monochromatic approximation for the mean photon energy at radius \n        :math:`\\tilde{R}` of the accretion disk. Eq. 65 in [Dermer2009]_.""""""\n        xi = np.power(self.l_Edd / (self.M_8 * self.eta), 1 / 4)\n        return 2.7 * 1e-4 * xi * np.power(R_tilde, -3 / 4)\n\n    def epsilon_mu(self, mu, r_tilde):\n        r""""""same as epsilon but computed with cosine of zenith mu and distance\n        from the black hole :math:`\\tilde{r}`. Eq. 67 in [Dermer2009]_.""""""\n        R_tilde = r_tilde * np.sqrt(np.power(mu, -2) - 1)\n        return self.epsilon(R_tilde)\n\n    def T(self, R_tilde):\n        r""""""Temperature of the disk at distance :math:`\\tilde{R}`. \n        Eq. 64 in [Dermer2009]_.""""""\n        value = mec2 / (2.7 * k_B) * self.epsilon(R_tilde)\n        return value.to(""K"")\n\n    def Theta(self, R_tilde):\n        r""""""Dimensionless temperature of the black body at distance :math:`\\tilde{R}`""""""\n        theta = k_B * self.T(R_tilde) / mec2\n        return theta.to_value("""")\n\n    def u(self, r, blob=None):\n        """"""integral energy density of radiation produced by the Disk at the distance \n        r along the jet axis. Integral over the solid angle of Eq. 69 in [Dermer2009]_.\n        \n        Parameters\n        ----------\n        r : :class:`~astropy.units.Quantity`\n            array of distances along the jet axis\n        blob : :class:`~agnpy.emission_regions.Blob`\n            if provided, the energy density is computed in a reference frame \n            comvoing with the blob\n        """"""\n        r_tilde = (r / self.R_g).to_value("""")\n        mu = self.mu_from_r_tilde(r_tilde)\n        prefactor = (\n            3\n            * self.l_Edd\n            * self.L_Edd\n            * self.R_g\n            / (8 * np.pi * c * self.eta * np.power(r, 3))\n        )\n        integrand = (\n            1\n            / mu\n            * np.power(np.power(mu, -2) - 1, -3 / 2)\n            * self.phi_disk_mu(mu, r_tilde)\n        )\n        if blob:\n            mu_prime = (mu - blob.Beta) / (1 - blob.Beta * mu)\n            integrand_prefactor = 1 / (\n                np.power(blob.Gamma, 6)\n                * np.power(1 - blob.Beta * mu, 2)\n                * np.power(1 + blob.Beta * mu_prime, 4)\n            )\n            integrand *= integrand_prefactor\n\n        integral = np.trapz(integrand, mu, axis=0)\n        return (prefactor * integral).to(""erg cm-3"")\n\n    def sed_flux(self, nu, z):\n        """"""Black Body SED generated by the SS Disk, considered as a \n        multi-dimensional black body. I obtain the formula following \n        Chapter 5 of [DermerMenon2009]_\n\n        .. math::\n            f_{\\epsilon} (= \\\\nu F_{\\\\nu}) &= \n            \\epsilon \\, \\int_{\\Omega_s} \\mu I_{\\epsilon} \\mathrm{d}\\Omega \\\\\\\\\n            &= \\epsilon \\, 2 \\pi \\int_{\\mu_{\\mathrm{min}}}^{\\mu_{\\mathrm{max}}}\n            \\mu I_{\\epsilon} \\mathrm{d}\\mu\n\n        where the cosine of the angle under which an observer at :math:`d_L` \n        sees the disk is :math:`\\mu = 1 / \\sqrt{1 + (R / d_L)^2}`, integrating\n        over :math:`R` rather than :math:`\\mu`\n\n        .. math::\n            f_{\\epsilon} &= \\epsilon \\, 2 \\pi \\int_{R_{\\mathrm{in}}}^{R_{\\mathrm{out}}}\n            (1 + R^2 / d_L^2)^{-3/2} \\\\frac{R}{d_L^2} \\, I_{\\epsilon}(R) \\, \\mathrm{d}R \\\\\\\\\n            &= \\epsilon \\, 2 \\pi \\\\frac{R_g^2}{d_L^2} \n            \\int_{\\\\tilde{R}_{\\mathrm{in}}}^{\\\\tilde{R}_{\\mathrm{out}}}\n            \\\\left(1 + \\\\tilde{R}^2 / \\\\tilde{d_L}^2 \\\\right)^{-3/2} \\, \n            \\\\tilde{R} \\, I_{\\epsilon}(\\\\tilde{R}) \\, \\mathrm{d}\\\\tilde{R}\n      \n        where in the last integral distances with :math:`\\\\tilde{}` have been \n        scaled to the gravitational radius :math:`R_g`.\n\n        Parameters\n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        z : float\n            redshift of the galaxy, to correct the observed frequencies and to \n            compute the flux once the distance is obtained\n        """"""\n        nu *= 1 + z\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        d_L = Distance(z=z).to(""cm"")\n        d_L_tilde = (d_L / self.R_g).to_value("""")\n        Theta = self.Theta(self.R_tilde)\n        # for multidimensional integration\n        # axis 0: radiuses (and temperatures)\n        # axis 1: photons epsilon\n        _R_tilde = np.reshape(self.R_tilde, (self.R_tilde.size, 1))\n        _Theta = np.reshape(Theta, (Theta.size, 1))\n        _epsilon = np.reshape(epsilon, (1, epsilon.size))\n        _integrand = (\n            np.power(1 + np.power(_R_tilde / d_L_tilde, 2), -3 / 2)\n            * _R_tilde\n            * I_epsilon_bb(_epsilon, _Theta)\n        )\n        prefactor = 2 * np.pi * np.power(self.R_g, 2) / np.power(d_L, 2)\n        sed = epsilon * prefactor * np.trapz(_integrand, self.R_tilde, axis=0)\n        return sed.to(""erg cm-2 s-1"")\n\n\nclass SphericalShellBLR:\n    """"""Spherical Shell Broad Line Region, from [Finke2016]_.\n    Each line is emitted from an infinitesimally thin spherical shell. \n\n    Parameters\n    ----------\n    L_disk : :class:`~astropy.units.Quantity`\n        Luminosity of the disk whose radiation is being reprocessed by the BLR\n    xi_line : float\n        fraction of the disk radiation reprocessed by the BLR\n    line : string\n        type of line emitted\n    R_line : :class:`~astropy.units.Quantity`\n        radius of the BLR spherical shell\n    """"""\n\n    def __init__(self, L_disk, xi_line, line, R_line):\n        self.type = ""SphericalShellBLR""\n        self.L_disk = L_disk\n        self.xi_line = xi_line\n        if line in lines_dictionary:\n            self.line = line\n            self.lambda_line = lines_dictionary[line][""lambda""]\n        else:\n            raise NameError(f""{line} not available in the line dictionary"")\n        self.epsilon_line = (\n            self.lambda_line.to(""erg"", equivalencies=u.spectral()) / mec2\n        ).to_value("""")\n        self.R_line = R_line\n\n    def __str__(self):\n        return (\n            f""* Spherical Shell Broad Line Region:\\n""\n            + f"" - L_disk (accretion disk luminosity): {self.L_disk.cgs:.2e}\\n""\n            + f"" - xi_line (fraction of the disk radiation reprocessed by the BLR): {self.xi_line:.2e}\\n""\n            + f"" - line (type of emitted line): {self.line}, lambda = {self.lambda_line.cgs:.2f}\\n""\n            + f"" - R_line (radius of the BLR shell): {self.R_line.cgs:.2e}\\n""\n        )\n\n    def u(self, r, blob=None):\n        """"""Density of radiation produced by the BLR at the distance r along the \n        jet axis. Integral over the solid angle of Eq. 80 in [Finke2016]_.\n\n        Parameters\n        ----------\n        r : :class:`~astropy.units.Quantity`\n            array of distances along the jet axis\n        blob : :class:`~agnpy.emission_regions.Blob`\n            if provided, the energy density is computed in a reference frame \n            comvoing with the blob\n        """"""\n        mu = np.linspace(-1, 1)\n        _mu = mu.reshape(mu.size, 1)\n        _r = r.reshape(1, r.size)\n        _x2 = np.power(_r, 2) + np.power(self.R_line, 2) - 2 * _r * self.R_line * _mu\n        prefactor = self.xi_line * self.L_disk / (8 * np.pi * c)\n        integrand = 1 / _x2\n        if blob:\n            _mu_star = np.sqrt(\n                1 - np.power(self.R_line, 2) / _x2 * np.power(1 - _mu, 2)\n            )\n            integrand_prefactor = np.power(blob.Gamma, 2) * np.power(\n                1 - blob.Beta * _mu_star, 2\n            )\n            integrand *= integrand_prefactor\n        integral = np.trapz(integrand, mu, axis=0)\n        return (prefactor * integral).to(""erg cm-3"")\n\n\nclass RingDustTorus:\n    """"""Dust Torus as infinitesimally thin annulus, from [Finke2016]_.\n    For the Compton scattering monochromatic emission at the peak energy of the \n    Black Body spectrum is considered.\n\n    Parameters\n    ----------\n    L_disk : :class:`~astropy.units.Quantity`\n       Luminosity of the disk whose radiation is being reprocessed by the Torus\n    xi_dt : float\n        fraction of the disk radiation reprocessed\n    T_dt : :class:`~astropy.units.Quantity`\n        peak temperature of the black body emission of the Torus\n    R_dt : :class:`~astropy.units.Quantity`\n        radius of the Torus, if not specified the saturation radius of Eq. 96 in\n        [Finke2016]_ will be used\n    """"""\n\n    def __init__(self, L_disk, xi_dt, T_dt, R_dt=None):\n        self.type = ""RingDustTorus""\n        self.L_disk = L_disk\n        self.xi_dt = xi_dt\n        self.T_dt = T_dt\n        # dimensionless temperature of the torus\n        self.Theta = (k_B * self.T_dt / mec2).to_value("""")\n        self.epsilon_dt = 2.7 * self.Theta\n\n        # if the radius is not specified use saturation radius Eq. 96 of [Finke2016]_\n        if R_dt is None:\n            self.R_dt = (\n                3.5\n                * 1e18\n                * np.sqrt((self.L_disk / (1e45 * u.Unit(""erg s-1""))).to_value(""""))\n                * np.power((self.T_dt / (1e3 * u.K)).to_value(""""), -2.6)\n            ) * u.cm\n        else:\n            self.R_dt = R_dt\n\n    def __str__(self):\n        return (\n            f""* Ring Dust Torus:\\n""\n            + f"" - L_disk (accretion disk luminosity): {self.L_disk.cgs:.2e}\\n""\n            + f"" - xi_dt (fraction of the disk radiation reprocessed by the torus): {self.xi_dt:.2e}\\n""\n            + f"" - T_dt (temperature of the dust torus): {self.T_dt:.2e}\\n""\n            + f"" - R_dt (radius of the torus): {self.R_dt.cgs:.2e}\\n""\n        )\n\n    def u(self, r, blob=None):\n        r""""""Density of radiation produced by the Torus at the distance r along the \n        jet axis. Integral over the solid angle of Eq. 85 in [Finke2016]_\n\n        Parameters\n        ----------\n        r : :class:`~astropy.units.Quantity`\n            array of distances along the jet axis\n        blob : :class:`~agnpy.emission_regions.Blob`\n            if provided, the energy density is computed in a reference frame \n            comvoing with the blob\n        """"""\n        x2 = np.power(self.R_dt, 2) + np.power(r, 2)\n        x = np.sqrt(x2)\n        integral = self.xi_dt * self.L_disk / (4 * np.pi * c * x2)\n        if blob:\n            mu = (r / x).to_value("""")\n            integral *= np.power(blob.Gamma * (1 - blob.Beta * mu), 2)\n        return integral.to(""erg cm-3"")\n\n    def sed_flux(self, nu, z):\n        """"""Black Body SED generated by the Dust Torus:\n\n        .. math::\n            \\\\nu F_{\\\\nu} \\, [\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}]\n        \n        ----------\n        nu : :class:`~astropy.units.Quantity`\n            array of frequencies, in Hz, to compute the sed, **note** these are \n            observed frequencies (observer frame).\n        z : float\n            redshift of the galaxy, to correct the observed frequencies and to \n            compute the flux once the distance is obtained\n        """"""\n        nu *= 1 + z\n        epsilon = nu.to("""", equivalencies=epsilon_equivalency)\n        d_L = Distance(z=z).to(""cm"")\n        prefactor = np.pi * np.power((self.R_dt / d_L).to_value(""""), 2)\n        sed = prefactor * epsilon * I_epsilon_bb(epsilon, self.Theta)\n        return sed * u.Unit(""erg cm-2 s-1"")\n'"
docs/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(""../""))\n\n# -- Project information -----------------------------------------------------\n\nproject = ""agnpy""\ncopyright = ""2019, Cosimo Nigro""\nauthor = ""Cosimo Nigro""\n\n# The full version, including alpha/beta/rc tags\nrelease = ""0.0.6""\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    ""sphinx.ext.autodoc"",\n    ""sphinx.ext.autosummary"",\n    ""sphinx.ext.napoleon"",\n    ""sphinx.ext.intersphinx"",\n    ""sphinx.ext.extlinks"",\n    ""sphinx.ext.mathjax"",\n    ""nbsphinx"",\n]\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\nnumfig = True\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = ""sphinx_rtd_theme""\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\n\n# set main node of the documentation to index.rst (contents.rst is the default)\nmaster_doc = ""index""\n\n# dictionary with external packages references\nintersphinx_mapping = {\n    ""numpy"": (""https://numpy.org/doc/stable/"", None),\n    ""astropy"": (""http://docs.astropy.org/en/latest/"", None),\n    ""matplotlib"": (""https://matplotlib.org"", None),\n}\n\n# latex support\nmathjax_config = {\n    ""TeX"": {\n        ""Macros"": {\n            ""Beta"": r""{\\mathcal{B}}"",\n            ""uunits"": r""{{\\rm erg}\\,{\\rm cm}^{-3}}"",\n            ""diff"": r""{\\mathrm{d}}"",\n            ""utransform"": r""{\\Gamma^3 (1 + \\Beta \\mu\')^3}"",\n        }\n    }\n}\n'"
agnpy/tests/__init__.py,0,b''
agnpy/tests/test_emission_region.py,12,"b'import numpy as np\nimport astropy.units as u\nfrom astropy.constants import e, c, m_e\nfrom agnpy.emission_regions import Blob\nimport pytest\n\n\nmec2 = m_e.to(""erg"", equivalencies=u.mass_energy())\n# a global test blob with spectral index 2\nSPECTRUM_NORM = 1e-13 * u.Unit(""cm-3"")\nGAMMA_MIN = 1\nGAMMA_MAX = 1e6\nPWL_IDX_2_DICT = {\n    ""type"": ""PowerLaw"",\n    ""parameters"": {""p"": 2.0, ""gamma_min"": GAMMA_MIN, ""gamma_max"": GAMMA_MAX},\n}\n# blob parameters\nR_B = 1e16 * u.cm\nZ = 0.1\nDELTA_D = 10\nGAMMA = 10\nB = 0.1 * u.G\nPWL_BLOB = Blob(R_B, Z, DELTA_D, GAMMA, B, SPECTRUM_NORM, PWL_IDX_2_DICT)\n# useful for checks\nBETA = 1 - 1 / np.power(GAMMA, 2)\nV_B = 4 / 3 * np.pi * np.power(R_B, 3)\n\n\nclass TestBlob:\n    """"""class grouping all tests related to the Blob emission region""""""\n\n    def test_default_norm_type(self):\n        """"""the default norm type should be \'integral\'""""""\n        assert PWL_BLOB.spectrum_norm_type == ""integral""\n\n    def test_integral_norm_cm3(self):\n        """"""test if the integral norm in cm-3 is correctly set""""""\n        PWL_BLOB.set_n_e(SPECTRUM_NORM, PWL_IDX_2_DICT, ""integral"")\n        assert u.allclose(PWL_BLOB.n_e_tot, SPECTRUM_NORM, rtol=1e-2)\n\n    def test_differential_norm_cm3(self):\n        """"""test if the differential norm in cm-3 is correctly set""""""\n        PWL_BLOB.set_n_e(SPECTRUM_NORM, PWL_IDX_2_DICT, ""differential"")\n        assert u.allclose(PWL_BLOB.n_e.k_e, SPECTRUM_NORM)\n\n    def test_gamma_1_norm_cm3(self):\n        """"""test if the norm at gamma = 1 in cm-3 is correctly set""""""\n        PWL_BLOB.set_n_e(SPECTRUM_NORM, PWL_IDX_2_DICT, ""gamma=1"")\n        n_e_gamma_1 = PWL_BLOB.n_e(np.asarray([1]))\n        assert u.allclose(n_e_gamma_1, SPECTRUM_NORM)\n\n    @pytest.mark.parametrize(\n        ""spectrum_norm, spectrum_norm_type"",\n        [\n            (1e48 * u.erg, ""differential""),\n            (1e48 * u.erg, ""gamma=1""),\n            (1e2 * u.Unit(""erg cm-3""), ""differential""),\n            (1e2 * u.Unit(""erg cm-3""), ""gamma=1""),\n        ],\n    )\n    def test_non_available_norm_type(self, spectrum_norm, spectrum_norm_type):\n        """"""check that the spectrum_norm_type \'differential\' and \'gamma=1\' \n        raise a NameError for a spectrum_norm in erg or erg cm-3""""""\n        with pytest.raises(NameError):\n            PWL_BLOB.set_n_e(spectrum_norm, PWL_IDX_2_DICT, spectrum_norm_type)\n\n    def test_set_delta_D(self):\n        PWL_BLOB.set_delta_D(Gamma=10, theta_s=20 * u.deg)\n        assert np.allclose(PWL_BLOB.delta_D, 1.53804)\n\n    def test_set_gamma_size(self):\n        PWL_BLOB.set_gamma_size(1000)\n        assert len(PWL_BLOB.gamma) == 1000\n\n    def test_N_e(self):\n        """"""check that N_e is n_e * V_b i.e. test their ratio to be V_b""""""\n        PWL_BLOB.set_n_e(SPECTRUM_NORM, PWL_IDX_2_DICT, ""differential"")\n        n_e = PWL_BLOB.n_e(PWL_BLOB.gamma)\n        N_e = PWL_BLOB.N_e(PWL_BLOB.gamma)\n        assert u.allclose(N_e / n_e, V_B)\n\n    def test_n_e_tot(self):\n        n_e_expected = SPECTRUM_NORM * (1 / GAMMA_MIN - 1 / GAMMA_MAX)\n        assert u.allclose(PWL_BLOB.n_e_tot, n_e_expected, rtol=1e-4)\n\n    def test_N_e_tot(self):\n        N_e_expected = V_B * SPECTRUM_NORM * (1 / GAMMA_MIN - 1 / GAMMA_MAX)\n        assert u.allclose(PWL_BLOB.N_e_tot, N_e_expected, rtol=1e-4)\n\n    def test_u_e(self):\n        u_e_expected = mec2 * SPECTRUM_NORM * np.log(GAMMA_MAX / GAMMA_MIN)\n        assert u.allclose(PWL_BLOB.u_e, u_e_expected, rtol=1e-4)\n\n    def test_W_e(self):\n        W_e_expected = mec2 * V_B * SPECTRUM_NORM * np.log(GAMMA_MAX / GAMMA_MIN)\n        assert u.allclose(PWL_BLOB.W_e, W_e_expected, rtol=1e-4)\n\n    def test_U_B(self):\n        # strip the units for convenience on this one\n        U_B_expected = np.power(B.value, 2) / (8 * np.pi) * u.Unit(""erg cm-3"")\n        assert np.allclose(PWL_BLOB.U_B, U_B_expected)\n\n    def test_P_jet_e(self):\n        u_e_expected = mec2 * SPECTRUM_NORM * np.log(GAMMA_MAX / GAMMA_MIN)\n        P_jet_e_expected = (\n            2 * np.pi * np.power(R_B, 2) * BETA * np.power(GAMMA, 2) * c * u_e_expected\n        )\n        assert u.allclose(PWL_BLOB.P_jet_e, P_jet_e_expected.to(""erg s-1""), rtol=1e-2)\n\n    def test_P_jet_B(self):\n        U_B_expected = np.power(B.value, 2) / (8 * np.pi) * u.Unit(""erg cm-3"")\n        P_jet_B_expected = (\n            2 * np.pi * np.power(R_B, 2) * BETA * np.power(GAMMA, 2) * c * U_B_expected\n        )\n        assert u.allclose(PWL_BLOB.P_jet_B, P_jet_B_expected.to(""erg s-1""), rtol=1e-2)\n'"
agnpy/tests/test_targets.py,11,"b'import numpy as np\nimport astropy.units as u\nfrom astropy.constants import e, c, m_e, M_sun, G, sigma_sb\nfrom agnpy.targets import SSDisk\nimport pytest\n\n# global quantities defining the test disk\nM_BH = 1.2 * 1e9 * M_sun\nL_DISK = 1.512 * 1e46 * u.Unit(""erg s-1"")\nETA = 1 / 12\nR_G = 1.77 * 1e14 * u.cm\nR_IN_G_UNITS = 6\nR_OUT_G_UNITS = 200\nR_IN = R_IN_G_UNITS * R_G\nR_OUT = R_OUT_G_UNITS * R_G\n\nDISK = SSDisk(M_BH, L_DISK, ETA, R_IN, R_OUT)\n\n# useful for checks\nL_EDD = 15.12 * 1e46 * u.Unit(""erg s-1"")\nM_DOT = 2.019 * 1e26 * u.Unit(""g s-1"")\n\nRTOL = 1e-2\n\n\nclass TestDisk:\n    """"""class grouping all the tests related to the SSDisk target""""""\n\n    def test_L_Edd(self):\n        assert u.allclose(DISK.L_Edd, L_EDD, rtol=RTOL)\n\n    def test_l_Edd(self):\n        assert u.allclose(DISK.l_Edd, 0.1, rtol=RTOL)\n\n    def test_m_dot(self):\n        assert u.allclose(DISK.m_dot, M_DOT, rtol=RTOL)\n\n    @pytest.mark.parametrize(\n        ""R_in, R_out, R_g_units"",\n        [(R_IN_G_UNITS, R_OUT_G_UNITS, False), (R_IN, R_OUT, True),],\n    )\n    def test_R_in_R_out_units(self, R_in, R_out, R_g_units):\n        """"""check if a TypeError is raised when passing R_in and R_out with \n        (without) units but specifiying R_g_units True (False)""""""\n        with pytest.raises(TypeError):\n            disk = SSDisk(M_BH, L_DISK, ETA, R_in, R_out, R_g_units)\n\n    def test_R_g(self):\n        assert u.allclose(DISK.R_g, R_G, rtol=RTOL)\n\n    def test_mu_from_r_tilde(self):\n        mu = DISK.mu_from_r_tilde(10)\n        mu_min_expected = 0.050\n        mu_max_expected = 0.858\n        assert np.allclose(mu[0], mu_min_expected, rtol=RTOL)\n        assert np.allclose(mu[-1], mu_max_expected, rtol=RTOL)\n\n    def test_phi_disk(self):\n        R_tilde = 10\n        phi_expected = 0.225\n        assert np.allclose(DISK.phi_disk(R_tilde), phi_expected, rtol=RTOL)\n\n    def test_phi_disk_mu(self):\n        r_tilde = 10\n        # assume R_tilde = 10 as before\n        mu = 1 / np.sqrt(2)\n        phi_expected = 0.225\n        assert np.allclose(DISK.phi_disk_mu(mu, r_tilde), phi_expected, rtol=RTOL)\n\n    def test_epsilon(self):\n        R_tilde = 10\n        epsilon_expected = 2.7e-5\n        assert np.allclose(DISK.epsilon(R_tilde), epsilon_expected, rtol=RTOL)\n\n    def test_epsilon_mu(self):\n        r_tilde = 10\n        # assume R_tilde = 10 as before\n        mu = 1 / np.sqrt(2)\n        epsilon_expected = 2.7e-5\n        assert np.allclose(DISK.epsilon_mu(mu, r_tilde), epsilon_expected, rtol=1e-1)\n\n    def test_T(self):\n        R_tilde = 10\n        R = 10 * R_G\n        phi_expected = 0.225\n        # Eq. 64 [Dermer2009]\n        T_expected = np.power(\n            3 * G * M_BH * M_DOT / (8 * np.pi * np.power(R, 3) * sigma_sb), 1 / 4\n        ).to(""K"")\n        assert u.allclose(DISK.T(R_tilde), T_expected, rtol=RTOL)\n\n    def test_Theta(R_tilde):\n        R_tilde = 10\n        epsilon = DISK.epsilon(R_tilde)\n        Theta = DISK.Theta(R_tilde)\n        assert np.allclose(epsilon, 2.7 * Theta, rtol=RTOL)\n'"
experiments/basic/beaming.py,1,"b'import numpy as np\nimport math\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import interp1d\nimport sys\n\nsys.path.append(""/home/jsitarek/zdalne/agnpy/agnpy/"")\nfrom agnpy.emission_regions import Blob\nfrom agnpy.synchrotron import Synchrotron\n\nnu = np.logspace(8, 27, 100) * u.Hz  # for SED calculations\n\nspectrum_norm = 1.0 * u.Unit(""erg cm-3"")\nparameters = {\n    ""p1"": 1.5,\n    ""p2"": 2.5,\n    ""gamma_b"": 1.0e3,\n    ""gamma_min"": 1,\n    ""gamma_max"": 1.0e6,\n}\nspectrum_dict = {""type"": ""BrokenPowerLaw"", ""parameters"": parameters}\ndelta_D = 1.01\nGamma = 1.01\nB = 1.0 * u.G\nr_b = 1.0e15 * u.cm\n# no beaming\nblob0 = Blob(r_b, 0.01, delta_D, Gamma, B, spectrum_norm, spectrum_dict, xi=0.01)\n\nsynch0 = Synchrotron(blob0, ssa=True)\nsynch0_sed = synch0.sed_flux(nu)\n\n# beaming\ndelta_D = 20\nGamma = 15\nblob1 = Blob(r_b, 0.01, delta_D, Gamma, B, spectrum_norm, spectrum_dict, xi=0.01)\n\nsynch1 = Synchrotron(blob1, ssa=True)\nsynch1_sed = synch1.sed_flux(nu)\n\n# doing beaming by hand: dN/dOmega dt depsilon scales like D^2, and E^2 in SED scales with another D^2\nsynch0_sed_scale = synch0_sed * delta_D ** 4\nnu_scale = nu * delta_D\nplt.rc(""figure"", figsize=(7.5, 5.5))\nplt.rc(""font"", size=12)\nplt.rc(""axes"", grid=True)\nplt.rc(""grid"", ls="":"")\nsed_x_label = r""$\\nu\\,/\\,Hz$""\nsed_y_label = r""$\\nu F_{\\nu}\\,/\\,(\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1})$""\n\nplt.loglog(nu, synch0_sed, color=""k"", ls="":"", lw=1, label=""No beaming"")  #\nplt.loglog(nu, synch1_sed, color=""r"", ls="":"", lw=1, label=""Beaming"")  #\nplt.loglog(\n    nu_scale, synch0_sed_scale * 1.1, color=""b"", ls="":"", lw=1, label=""scaled""\n)  # 1.1 so both curves show up\n\nplt.ylim(1e-15, 1e-7)\nplt.xlim(1e8, 1e27)\nplt.xscale(""log"")\nplt.yscale(""log"")\nplt.xlabel(sed_x_label)\nplt.ylabel(sed_y_label)\nplt.legend()\nplt.show()\n'"
experiments/basic/ec_gmax.py,13,"b'# macro for testing various limits on the gamma factors of electrons\n\nimport numpy as np\nimport math\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\n\nplt.ion()\nimport sys\n\nsys.path.append(""../../"")\nfrom agnpy.emission_regions import Blob\nfrom agnpy.synchrotron import Synchrotron\nfrom agnpy.compton import ExternalCompton, SynchrotronSelfCompton\nfrom agnpy.targets import SSDisk, SphericalShellBLR, RingDustTorus\n\n# parameters of the blob with a narrow EED\nB0 = 10.1 * u.G\ngmin0 = 500.0 * 2\ngmax0 = 800.0 * 2\ngbreak = gmin0\nz = 0.01\nGamma = 17\ndelta_D = 1.99 * Gamma\nr0 = 1.0e15 * u.cm\nxi = 1.0e-4\nnu = np.logspace(8, 26, 200) * u.Hz\nnorm = 0.1 * u.Unit(""erg cm-3"")\n\nparameters = {\n    ""p1"": 2.0,\n    ""p2"": 3.0,\n    ""gamma_b"": gbreak,\n    ""gamma_min"": gmin0,\n    ""gamma_max"": gmax0,\n}\nspectrum_dict = {""type"": ""BrokenPowerLaw"", ""parameters"": parameters}\n\n\n#####################\n# test one with emission region in the center of the DT\nL_disk = 0.91e45 * u.Unit(""erg s-1"")\nxi_dt = 0.6\nT_dt = 100 * u.K\nR_dt = 1.0e18 * u.cm\nh = 0.01 * R_dt\n\n## test with lower numbers, gives virtually the same\n# B0/=10\n# T_dt/=10\n# L_disk/=100\n\nblob1 = Blob(r0, z, delta_D, Gamma, B0, norm, spectrum_dict, xi=xi)\ndt1 = RingDustTorus(L_disk, xi_dt, T_dt, R_dt=R_dt)\n\n# energy density of DT radiation field in the blob\nu_dt1 = dt1.u_ph(h, blob1)\nu_synch1 = blob1.u_ph_synch\nprint(\n    ""energy density in the blob, DT radiation: "",\n    u_dt1,\n    ""synchrotron photons: "",\n    u_synch1,\n)\ndt1_sed = dt1.sed_flux(nu, z)\n# energy density was set to be the same\n\nsynch1 = Synchrotron(blob1, ssa=False)\nsynch1_sed = synch1.sed_flux(nu)\n\nssc1 = SynchrotronSelfCompton(blob1, synch1)\nssc1_sed = ssc1.sed_flux(nu)\n\nec_dt1 = ExternalCompton(blob1, dt1, h)\nec_dt1_sed = ec_dt1.sed_flux(nu)\n\nssc1_total = (np.trapz(ssc1_sed / nu, nu)).to(""erg cm-2 s-1"")\nec_dt1_total = (np.trapz(ec_dt1_sed / nu, nu)).to(""erg cm-2 s-1"")\nprint(""SSC total="", ssc1_total, "", EC DT total="", ec_dt1_total)\n# similar density of radiation but there is a factor of ~1.4 difference in the integrated flux\n# this probably comes from different angular distribution of the radiation\n\ngbreakssc = blob1.gamma_break_SSC\ngbreakdt = blob1.gamma_break_EC_DT(dt1, h)\nprint(\n    ""break SSC="", gbreakssc, "", break EC="", gbreakdt, "", ratio: "", gbreakssc / gbreakdt\n)\n# values of the break scale with energy density so they are the same\n\ngmaxssc = blob1.gamma_max_SSC\ngmaxdt = blob1.gamma_max_EC_DT(dt1, h)\nprint(""max SSC="", gmaxssc, "", max EC="", gmaxdt, "", ratio: "", gmaxssc / gmaxdt)\n# the same with values of the maximum gamma factor\n\nplt.rc(""figure"", figsize=(7.5, 5.5))\nplt.rc(""font"", size=12)\nplt.rc(""axes"", grid=True)\nplt.rc(""grid"", ls="":"")\nsed_x_label = r""$\\nu\\,/\\,Hz$""\nsed_y_label = r""$\\nu F_{\\nu}\\,/\\,(\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1})$""\n\nplt.loglog(\n    nu / Gamma, synch1_sed, color=""k"", ls=""-"", lw=1, label=""Synchr. (shifted)""\n)  # /np.power(delta_D,4)*np.power(R_dt/r0,2)\nplt.loglog(nu, ssc1_sed, color=""r"", ls=""-"", lw=1, label=""SSC"")  #\nplt.loglog(nu, ec_dt1_sed, color=""b"", ls=""-"", lw=1, label=""EC DT"")  #\nplt.loglog(\n    nu * Gamma, dt1_sed, color=""g"", ls=""-"", lw=1, label=""DT1 (shifted)""\n)  # *np.power(Gamma,2)\nplt.ylim(1e-19, 1e-6)\nplt.xlim(1e8, 1e27)\nplt.xscale(""log"")\nplt.yscale(""log"")\nplt.xlabel(sed_x_label)\nplt.ylabel(sed_y_label)\n\n######################\n# test with emission region further along the jet\n\nh = 0.9 * R_dt\ndist = np.sqrt(h * h + R_dt * R_dt)\nfactor = blob1.Gamma * (1 - blob1.Beta * h / dist)\n\n# before we had boosting by Gamma, now by factor\nT_dt2 = T_dt / (factor / blob1.Gamma)  # shift the energies\nL_disk2 = (\n    L_disk * np.power(factor / blob1.Gamma, -2) * np.power(dist / R_dt, 2)\n)  # shift the luminosity for the beaming and larger distance\ndt2 = RingDustTorus(L_disk2, xi_dt, T_dt2, R_dt=R_dt)\nec_dt2 = ExternalCompton(blob1, dt2, h)\nec_dt2_sed = ec_dt2.sed_flux(nu)\ndt2_sed = dt2.sed_flux(nu, z)\n\nu_dt2 = dt2.u_ph(h, blob1)\nprint(""DT energy density (test 1)="", u_dt1, "", (test2)="", u_dt2)\n# same energy densities\n\nec_dt2_total = (np.trapz(ec_dt2_sed / nu, nu)).to(""erg cm-2 s-1"")\nprint(\n    ""SSC total="",\n    ssc1_total,\n    "", EC DT total (test1)="",\n    ec_dt1_total,\n    "", (test2)="",\n    ec_dt2_total,\n)\n# the obtained spectrum from EC in test 1 and 2 is the same, but even while the radiation density is the same, it has different angular distribution. Still, both test1 and test2 are nearly head-on in blob\'s frame, so the resulting EC is very similar\n\nangle2 = np.arccos((h / dist - blob1.Beta) / (1 - blob1.Beta * h / dist)).to(""deg"")\nprint(""test2, photons in blob at angle"", angle2)\n\nplt.loglog(nu * factor, dt2_sed, color=""g"", ls="":"", lw=1, label=""DT2 (shifted)"")\nplt.loglog(nu, ec_dt2_sed, color=""b"", ls="":"", lw=1, label=""EC DT2 (over EC DT1)"")\n\n\n######################\n# test with emission region far enough along the jet that beaming disappears\n\nh = 17.0 * R_dt\ndist = np.sqrt(h * h + R_dt * R_dt)\nfactor = blob1.Gamma * (1 - blob1.Beta * h / dist)\n\nprint(factor)\n# before we had boosting by Gamma, now by factor\nT_dt3 = T_dt / (factor / blob1.Gamma)  # shift the energies\nL_disk3 = (\n    L_disk * np.power(factor / blob1.Gamma, -2) * np.power(dist / R_dt, 2)\n)  # shift the luminosity for the beaming and larger distance\ndt3 = RingDustTorus(L_disk3, xi_dt, T_dt3, R_dt=R_dt)\nec_dt3 = ExternalCompton(blob1, dt3, h)\nec_dt3_sed = ec_dt3.sed_flux(nu)\ndt3_sed = dt3.sed_flux(nu, z)\n\nu_dt3 = dt3.u_ph(h, blob1)\nprint(""DT energy density (test 1)="", u_dt1, "", (test3)="", u_dt3)\n# same energy densities\n\nec_dt3_total = (np.trapz(ec_dt3_sed / nu, nu)).to(""erg cm-2 s-1"")\nprint(\n    ""SSC total="",\n    ssc1_total,\n    "", EC DT total (test1)="",\n    ec_dt1_total,\n    "", (test3)="",\n    ec_dt3_total,\n)\n# now with the same energy density, but with photons perpendicular to the jet direction in the frame of the blob we get a factor of ~4 lower flux.\n# the factor of 2 should come from the cross section,\n# and another factor of 2 from transformation of energy of the photon to the electron\'s frame\n# seems consistent\nprint(ec_dt1_total / ec_dt3_total)\nangle3 = np.arccos((h / dist - blob1.Beta) / (1 - blob1.Beta * h / dist)).to(""deg"")\nprint(""test3, photons in blob at angle"", angle3)\n\nplt.loglog(nu * factor, dt3_sed, color=""g"", ls=""-."", lw=1, label=""DT3 (shifted)"")\nplt.loglog(nu, ec_dt3_sed, color=""b"", ls=""-."", lw=1, label=""EC DT3"")\n\nplt.legend()\nplt.show()\n\n# sys.exit()\n'"
experiments/basic/ec_point_like_comparison.py,1,"b'# compare if in the limit of large distances the SED for EC on the BLR and on\n# the dust torus tend to the one generated by a point like source behind the jet\n\n# import numpy, astropy and matplotlib for basic functionalities\nimport numpy as np\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\n\n# import agnpy classes\nfrom agnpy.emission_regions import Blob\nfrom agnpy.compton import ExternalCompton\nfrom agnpy.targets import PointSourceBehindJet, SphericalShellBLR, RingDustTorus\n\nspectrum_norm = 6e42 * u.erg\nparameters = {\n    ""p1"": 2.0,\n    ""p2"": 3.5,\n    ""gamma_b"": 1e4,\n    ""gamma_min"": 20,\n    ""gamma_max"": 5e7,\n}\nspectrum_dict = {""type"": ""BrokenPowerLaw"", ""parameters"": parameters}\nR_b = 1e16 * u.cm\nB = 0.56 * u.G\nz = 1\ndelta_D = 40\nGamma = 40\nblob = Blob(R_b, z, delta_D, Gamma, B, spectrum_norm, spectrum_dict)\nblob.set_gamma_size(500)\n\n\nL_disk = 2 * 1e46 * u.Unit(""erg s-1"")\n# dust torus\nT_dt = 1e3 * u.K\ncsi_dt = 0.1\ndt = RingDustTorus(L_disk, csi_dt, T_dt)\n# blr\nxi_line = 0.024\nR_line = 1e17 * u.cm\nblr = SphericalShellBLR(L_disk, xi_line, ""Lyalpha"", R_line)\n\n# point source behind the jet approximating the DT\nps_dt = PointSourceBehindJet(dt.xi_dt * L_disk, dt.epsilon_dt)\n# point source behind the jet approximating the BLR\nps_blr = PointSourceBehindJet(blr.xi_line * L_disk, blr.epsilon_line)\n\nec_dt = ExternalCompton(blob, dt, r=1e22 * u.cm)\nec_blr = ExternalCompton(blob, blr, r=1e22 * u.cm)\nec_ps_dt = ExternalCompton(blob, ps_dt, r=1e22 * u.cm)\nec_ps_blr = ExternalCompton(blob, ps_blr, r=1e22 * u.cm)\n\n# seds\nnu = np.logspace(15, 30) * u.Hz\n\nsed_blr = ec_blr.sed_flux(nu)\nsed_ps_blr = ec_ps_blr.sed_flux(nu)\nsed_dt = ec_dt.sed_flux(nu)\nsed_ps_dt = ec_ps_dt.sed_flux(nu)\n\nplt.loglog(nu, sed_blr, ls=""-"", lw=2, color=""k"", label=""EC on BLR"")\nplt.loglog(nu, sed_dt, ls=""-"", lw=2, color=""dimgray"", label=""EC on DT"")\nplt.loglog(\n    nu,\n    sed_ps_blr,\n    ls="":"",\n    lw=2,\n    color=""crimson"",\n    label=""EC on point source approx. BLR"",\n)\nplt.loglog(\n    nu,\n    sed_ps_dt,\n    ls="":"",\n    lw=2,\n    color=""darkorange"",\n    label=""EC on point source approx. DT"",\n)\nplt.legend()\nplt.xlabel(r""$\\nu\\,/\\,{\\rm Hz}$"")\nplt.ylabel(r""$\\nu F_{\\nu}\\,/\\,({\\rm erg}\\,{\\rm cm}^{-2}\\,{\\rm s}^{-1})$"")\nplt.show()\n'"
experiments/basic/gmax.py,7,"b'# macro for testing various limits on the gamma factors of electrons\n\nimport numpy as np\nimport math\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\n\n# plt.ion()\nimport sys\n\nsys.path.append(""../../"")\nfrom agnpy.emission_regions import Blob\nfrom agnpy.synchrotron import Synchrotron\nfrom agnpy.compton import ExternalCompton, SynchrotronSelfCompton\nfrom agnpy.targets import SSDisk, SphericalShellBLR, RingDustTorus\n\n# parameters of the blob\nB0 = 0.1 * u.G\ngmin0 = 10.0\ngmax0 = 3000.0\ngbreak = 300.0\nz = 0.94\ndelta_D = 20\nGamma = 17\n# r0=1.e16 * u.cm\nr0 = 1.0e14 * u.m\ndist = 3.0e16 * u.cm\nxi = 1.0e-4\nnu = np.logspace(8, 26, 200) * u.Hz\nnorm = 15000.0 * u.Unit(""cm-3"")\n\nparameters = {\n    ""p1"": 2.0,\n    ""p2"": 3.0,\n    ""gamma_b"": gbreak,\n    ""gamma_min"": gmin0,\n    ""gamma_max"": gmax0,\n}\nspectrum_dict = {""type"": ""BrokenPowerLaw"", ""parameters"": parameters}\n\nblob = Blob(r0, z, delta_D, Gamma, B0, norm, spectrum_dict, xi=xi)\n\n# plt.loglog(blob.gamma, blob.n_e (blob.gamma))\n\n#############################################\n# limits from confinement of particles inside the blob:\ngmaxconf = blob.gamma_max_larmor\n# computing larmor radius of this electron, should be of the size of the blob\n# R_L = 33.36 km * (p/(GeV/c)) * (G/B) * Z^-1\n# https://w3.iihe.ac.be/~aguilar/PHYS-467/PA3.pdf\nrlarmor = (33.36 * u.km * gmaxconf * 511.0e3 / 1.0e9 / (blob.B / u.G)).to(""cm"")\n\n# both values are similar\nprint(""R_L (gmaxconf)="", rlarmor, ""R_b="", blob.R_b)\n\n#############################################\n# now maximum from balistic time\ngmaxbal = blob.gamma_max_ballistic\n\n# compute acceleration time for those electrons\n# eq 2 from https://arxiv.org/abs/1208.6200a, note that this is rough scaling accurate to ~10%\ntau_acc = 1.0 * gmaxbal * 511.0e3 / 1.0e9 / (blob.xi / 1.0e-4 * blob.B / u.G) * u.s\n# during this time side of R_b of the jet should pass through the blob (in the blob frame!)\ndist_cross = (tau_acc * const.c).to(""cm"")\n\n# again both values are similar\nprint(f""dist_cross (tau_acc(gmaxbal))={dist_cross:.2e}, R_b={blob.R_b:.2e}"")\n\n\n#############################################\n# now maximum from synchrotron losses\ngmaxsyn = blob.gamma_max_synch\n\n# calculate t_acc\ntau_acc = 1.0 * gmaxsyn * 511.0e3 / 1.0e9 / (blob.xi / 1.0e-4 * blob.B / u.G) * u.s\n# calculate synchrotron energy loss from the well known formula:\n# dE/dt = 4/3 * gamma^2 *U_b * c  * sigma_T\nUb = (blob.B / u.G) ** 2 / (8 * np.pi) * u.Unit(""erg cm-3"")\ndEdt = 4.0 / 3.0 * (gmaxsyn) ** 2 * Ub * (const.c * const.sigma_T).to(""cm3 s-1"")\nElost = (dEdt * tau_acc).to(""GeV"")\nEmax = (gmaxsyn * const.m_e * (const.c) ** 2).to(""GeV"")\n\n# both values are similar\nprint(f""E(gmaxsyn) = {Emax:.2e}, Elost = {Elost:.2e}"")\n\n# print(gmaxconf, gmaxbal, gmaxsyn)\n\n#############################################\n# check of synchrotron cooling break\n\n# eq F.1 from https://ui.adsabs.harvard.edu/abs/2020arXiv200107729M/abstract\n# gammab = 3pi me c^2 / sigma_T B^2 R\n# here we use 6 instead of 3 because we only have synchrotron losses and compare then\n# with dynamical time scale of crossing R\n\n# now compare the value from the class with the formula below\ngamma_b = blob.gamma_break_synch\ngamma_break_check = (\n    6\n    * np.pi\n    * 511.0e3\n    * u.eV.to(""erg"")\n    / (0.665e-24 * (blob.B / u.G) ** 2 * (blob.R_b / u.cm))\n)\n\nprint(f""gamma_break = {gamma_b:.5e}, gamma_break_check = {gamma_break_check:.5e}"")\n\n#############################################\n# limits for SSC\n# print(blob.u_e)\n# print(blob.u_dens_synchr)\n\n# redo blob without beaming\nGamma = 1.01\ndelta_D = 1.02\nz = 0.01\nblob1 = Blob(r0, z, delta_D, Gamma, B0 * 10.0, norm, spectrum_dict, xi=xi)\n\nu_ph_synch = blob1.u_ph_synch  # energy density of synchr photons\n# u_dens * V_b is the total energy in the blob,\n# photons spend an average time of 0.75 * R_b/c in the blob\n# so the total energy flux is:\n# total energy in blob / (average time  * 4 pi dist^2)\nenergy_flux_predicted = (\n    blob.u_ph_synch\n    * blob1.V_b\n    / (0.75 * blob1.R_b / const.c.cgs)\n    * np.power(blob1.d_L, -2)\n    / (4 * np.pi)\n).to(""erg cm-2 s-1"")\n\nsynch1 = Synchrotron(blob1, ssa=False)\nsynch1_sed = synch1.sed_flux(nu)\n\nenergy_flux_sim = np.trapz(synch1_sed / (nu * const.h.cgs), nu * const.h.cgs)\nprint(\n    f""predicted energy flux: {energy_flux_predicted:.5e}, simulated energy flux: {energy_flux_sim:.5e}""\n)\n# nice agreement\n\nssc1 = SynchrotronSelfCompton(blob1, synch1)\nssc1_sed = ssc1.sed_flux(nu)\n\nprint(""UB/Usynch = "", blob1.U_B / u_ph_synch)\nprint(\n    ""SED_synch/SED_SSC="",\n    energy_flux_sim / np.trapz(ssc1_sed / (nu * const.h.cgs), nu * const.h.cgs),\n)\n# same energy densities mean in Thomson regime the same energy losses ==> the same energy flux\nprint(""break_synchr/break_SSC = "", blob1.gamma_break_synch / blob1.gamma_break_SSC)\n\nprint(""gmax_synchr/gmax_SSC = "", blob1.gamma_max_synch / blob1.gamma_max_SSC)\n\n# SSC is at the same level as Synchr. so the cooling breaks and maximum energies are also same\n\n\nplt.rc(""figure"", figsize=(7.5, 5.5))\nplt.rc(""font"", size=12)\nplt.rc(""axes"", grid=True)\nplt.rc(""grid"", ls="":"")\nsed_x_label = r""$\\nu\\,/\\,Hz$""\nsed_y_label = r""$\\nu F_{\\nu}\\,/\\,(\\mathrm{erg}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1})$""\n\nplt.loglog(nu, synch1_sed, color=""k"", ls=""-"", lw=1, label=""Synchr."")  #\nplt.loglog(nu, ssc1_sed, color=""r"", ls=""-"", lw=1, label=""SSC"")  #\nplt.ylim(1e-15, 1e-10)\nplt.xlim(1e8, 1e27)\nplt.xscale(""log"")\nplt.yscale(""log"")\nplt.xlabel(sed_x_label)\nplt.ylabel(sed_y_label)\nplt.legend()\nplt.show()\n'"
experiments/basic/spectra.py,0,"b'# test different normalisations for the spectra\nimport astropy.units as u\nfrom astropy.coordinates import Distance\nfrom agnpy.emission_regions import Blob\nimport matplotlib.pyplot as plt\n\nspectrum_norm = 1e-13 * u.Unit(""cm-3"")\n\nspectrum_dict_pwl = {\n    ""type"": ""PowerLaw"",\n    ""parameters"": {""p"": 2.8, ""gamma_min"": 1, ""gamma_max"": 1e7},\n}\n\nspectrum_dict_bpl = {\n    ""type"": ""BrokenPowerLaw"",\n    ""parameters"": {\n        ""p1"": 2.0,\n        ""p2"": 3.0,\n        ""gamma_b"": 1e2,\n        ""gamma_min"": 1,\n        ""gamma_max"": 1e7,\n    },\n}\n\nspectrum_dict_bpl_2 = {\n    ""type"": ""BrokenPowerLaw2"",\n    ""parameters"": {\n        ""p1"": 2.0,\n        ""p2"": 3.0,\n        ""gamma_b"": 1e2,\n        ""gamma_min"": 1,\n        ""gamma_max"": 1e7,\n    },\n}\n\nR_b = 1e16 * u.cm\nB = 1 * u.G\nz = Distance(1e27, unit=u.cm).z\ndelta_D = 10\nGamma = 10\n\nfor spectrum_dict in (spectrum_dict_pwl, spectrum_dict_bpl, spectrum_dict_bpl_2):\n    for norm_type in (""integral"", ""differential"", ""gamma=1""):\n        blob = Blob(\n            R_b,\n            z,\n            delta_D,\n            Gamma,\n            B,\n            spectrum_norm,\n            spectrum_dict,\n            spectrum_norm_type=norm_type,\n        )\n        blob.plot_n_e()\n\n# let us trigger the error\nblob = Blob(\n    R_b,\n    z,\n    delta_D,\n    Gamma,\n    B,\n    1e48 * u.Unit(""erg""),\n    spectrum_dict_bpl_2,\n    spectrum_norm_type=""gamma=1"",\n)\n'"
experiments/basic/targets_radiation.py,1,"b'import sys\nimport numpy as np\nimport astropy.units as u\nimport matplotlib.pyplot as plt\n\nsys.path.append(""../../"")\nfrom agnpy.targets import SphericalShellBLR, RingDustTorus\n\nblr = SphericalShellBLR(1e46 * u.Unit(""erg s-1""), 0.1, ""Lyalpha"", 1e17 * u.cm)\ndt = RingDustTorus(1e46 * u.Unit(""erg s-1""), 0.6, 1000 * u.K)\nprint(blr)\nprint(dt)\n\nr = np.logspace(14, 21, 200) * u.cm\n\nplt.loglog(r, blr.u(r), label=""BLR"")\nplt.loglog(r, dt.u(r), label=""Torus"")\nplt.xlabel(r""$r\\,/\\,{\\rm cm}$"")\nplt.ylabel(r""$u\\,/\\,({\\rm erg}\\,{\\rm cm}^{-3})$"")\nplt.legend()\nplt.show()\n'"
experiments/profiling/profile_external_compton.py,1,"b'""""""profile and test external Comton radiation""""""\nimport sys\n\nsys.path.append(""../../"")\nimport numpy as np\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nfrom agnpy.emission_regions import Blob\nfrom agnpy.targets import SSDisk, SphericalShellBLR, RingDustTorus\nfrom agnpy.compton import ExternalCompton\nimport matplotlib.pyplot as plt\n\n# to profile\nimport cProfile, pstats\nimport timeit\n\n# functions to profile and time\ndef profile(command, label):\n    """"""function to profile a given command""""""\n    print(f""->{command} profiling section..."")\n    cProfile.run(command, f""Profile_{label}.prof"")\n    prof = pstats.Stats(f""Profile_{label}.prof"")\n    prof.strip_dirs().sort_stats(""time"").print_stats(10)\n\n\ndef timing(command, number):\n    """"""function to time a given command, returns time in seconds""""""\n    return timeit.timeit(command, globals=globals(), number=number)\n\n\n# define the blob\nspectrum_norm = 6e42 * u.erg\nparameters = {""p1"": 2, ""p2"": 3.5, ""gamma_b"": 1e4, ""gamma_min"": 20, ""gamma_max"": 5e7}\nspectrum_dict = {""type"": ""BrokenPowerLaw"", ""parameters"": parameters}\nR_b = 1e16 * u.cm\nB = 0.56 * u.G\nz = 1\ndelta_D = 40\nGamma = 40\nblob = Blob(R_b, z, delta_D, Gamma, B, spectrum_norm, spectrum_dict)\nprint(""\\nblob definition:"")\nprint(blob)\n\n# disk parameters\nM_sun = const.M_sun.cgs\nM_BH = 1.2 * 1e9 * M_sun\nR_g = ((const.G * M_BH) / (const.c * const.c)).cgs\nL_disk = 2 * 1e46 * u.Unit(""erg s-1"")\neta = 1 / 12\nR_in = 6 * R_g\nR_out = 200 * R_g\ndisk = SSDisk(M_BH, L_disk, eta, R_in, R_out)\nprint(""\\ndisk definition:"")\nprint(disk)\n\n# blr definition\nepsilon_line = 2e-5\ncsi_line = 0.024\nR_line = 1e17 * u.cm\nblr = SphericalShellBLR(disk, csi_line, epsilon_line, R_line)\nprint(""\\nblr definition:"")\nprint(blr)\n\n# dust torus definition\nT_dt = 1e3 * u.K\nepsilon_dt = 2.7 * ((const.k_B * T_dt) / (const.m_e * const.c * const.c)).decompose()\ncsi_dt = 0.1\ndt = RingDustTorus(disk, csi_dt, epsilon_dt)\nprint(""\\ntorus definition:"")\nprint(dt)\n\n# define the External Compton\nec_disk = ExternalCompton(blob, disk, r=1e17 * u.cm)\nec_blr = ExternalCompton(blob, blr, r=1e17 * u.cm)\nec_dt = ExternalCompton(blob, dt, r=1e17 * u.cm)\nnu = np.logspace(15, 30) * u.Hz\n\n# commands to profile\nec_disk_sed_command = ""ec_disk.sed_flux(nu)""\nec_blr_sed_command = ""ec_blr.sed_flux(nu)""\nec_dt_sed_command = ""ec_dt.sed_flux(nu)""\n\nn = 100\n\nprint(""\\nprofiling sed computation external compton on disk:"")\nprofile(ec_disk_sed_command, ""ec_disk_sed"")\ntime_ec_disk = timing(ec_disk_sed_command, n)\ntime_ec_disk /= n\nprint(f""time: {time_ec_disk:.2e} s"")\n\nprint(""\\nprofiling sed computation external compton on BLR:"")\nprofile(ec_blr_sed_command, ""ec_blr_sed"")\ntime_ec_blr = timing(ec_blr_sed_command, n)\ntime_ec_blr /= n\nprint(f""time: {time_ec_blr:.2e} s"")\n\nprint(""\\nprofiling sed computation external compton on dust torus:"")\nprofile(ec_dt_sed_command, ""ec_dt_sed"")\ntime_ec_dt = timing(ec_dt_sed_command, n)\ntime_ec_dt /= n\nprint(f""time: {time_ec_dt:.2e} s"")\n'"
experiments/profiling/profile_synchrotron.py,2,"b'""""""profile and test synchrotron and synchrotron self Comton radiation""""""\nimport sys\n\nsys.path.append(""../"")\nimport numpy as np\nimport astropy.units as u\nimport astropy.constants as const\nfrom astropy.coordinates import Distance\nimport matplotlib.pyplot as plt\nfrom agnpy.emission_regions import Blob\nfrom agnpy.synchrotron import Synchrotron\nfrom agnpy.compton import SynchrotronSelfCompton\n\n# to profile\nimport cProfile, pstats\nimport timeit\n\n# functions to profile and time\ndef profile(command, label):\n    """"""function to profile a given command""""""\n    print(f""->{command} profiling section..."")\n    cProfile.run(command, f""Profile_{label}.prof"")\n    prof = pstats.Stats(f""Profile_{label}.prof"")\n    prof.strip_dirs().sort_stats(""time"").print_stats(10)\n\n\ndef timing(command, number):\n    """"""function to time a given command, returns time in seconds""""""\n    return timeit.timeit(command, globals=globals(), number=number)\n\n\n# define the blob\nspectrum_norm = 1e48 * u.Unit(""erg"")\nspectrum_dict = {\n    ""type"": ""PowerLaw"",\n    ""parameters"": {""p"": 2.8, ""gamma_min"": 1e2, ""gamma_max"": 1e7},\n}\nR_b = 1e16 * u.cm\nB = 1 * u.G\nz = Distance(1e27, unit=u.cm).z\ndelta_D = 10\nGamma = 10\nblob = Blob(R_b, z, delta_D, Gamma, B, spectrum_norm, spectrum_dict)\nprint(""blob definition:"")\nprint(blob)\nsynch = Synchrotron(blob)\nsynch_ssa = Synchrotron(blob, ssa=True)\nssc = SynchrotronSelfCompton(blob, synch)\nssc_ssa = SynchrotronSelfCompton(blob, synch_ssa)\nnu_syn = np.logspace(8, 23) * u.Hz\nnu_ssc = np.logspace(15, 30) * u.Hz\n\n# commands to profile\nsyn_sed_command = ""synch.sed_flux(nu_syn)""\nsyn_sed_ssa_command = ""synch_ssa.sed_flux(nu_syn)""\nssc_sed_command = ""ssc.sed_flux(nu_ssc)""\nssc_ssa_sed_command = ""ssc_ssa.sed_flux(nu_ssc)""\n\nn = 100\nprint(""\\nprofiling synchrotron sed computation:"")\nprofile(syn_sed_command, ""syn_sed"")\ntime_syn = timing(syn_sed_command, n)\ntime_syn /= n\nprint(f""time: {time_syn:.2e} s"")\n\nprint(""\\nprofiling synchrotron w/ SSA sed computation:"")\nprofile(syn_sed_ssa_command, ""syn_sed_ssa"")\ntime_syn_ssa = timing(syn_sed_ssa_command, n)\ntime_syn_ssa /= n\nprint(f""time: {time_syn_ssa:.2e} s"")\n\nprint(""\\nprofiling SSC sed computation:"")\nprofile(ssc_sed_command, ""ssc_sed"")\ntime_ssc = timing(ssc_sed_command, n)\ntime_ssc /= n\nprint(f""time: {time_ssc:.2e} s"")\n\nprint(""\\nprofiling SSC w/ SSA sed computation:"")\nprofile(ssc_ssa_sed_command, ""ssc_ssa_sed"")\ntime_ssc_ssa = timing(ssc_ssa_sed_command, n)\ntime_ssc_ssa /= n\nprint(f""time: {time_ssc_ssa:.2e} s"")\n'"
experiments/profiling/profile_tau.py,1,"b'import sys\n\nsys.path.append(""../../"")\nimport numpy as np\nimport astropy.units as u\nimport astropy.constants as const\nfrom agnpy.emission_regions import Blob\nfrom agnpy.targets import SSDisk, SphericalShellBLR, RingDustTorus\nfrom agnpy.absorption import Absorption\nimport matplotlib.pyplot as plt\n\nMEC2 = const.m_e * const.c * const.c\n\n# define the blob\nspectrum_norm = 1e47 * u.erg\nparameters = {""p"": 2.8, ""gamma_min"": 10, ""gamma_max"": 1e6}\nspectrum_dict = {""type"": ""PowerLaw"", ""parameters"": parameters}\nR_b = 1e16 * u.cm\nB = 0.56 * u.G\nz = 0\ndelta_D = 40\nGamma = 40\nblob = Blob(R_b, z, delta_D, Gamma, B, spectrum_norm, spectrum_dict)\nprint(""blob definition:"")\nprint(blob)\n\n# disk parameters\nM_sun = const.M_sun.cgs\nM_BH = 1.2 * 1e9 * M_sun\nR_g = ((const.G * M_BH) / (const.c * const.c)).cgs\nL_disk = 2 * 1e46 * u.Unit(""erg s-1"")\neta = 1 / 12\nR_in = 6 * R_g\nR_out = 200 * R_g\ndisk = SSDisk(M_BH, L_disk, eta, R_in, R_out)\nprint(""disk definition:"")\nprint(disk)\n\n# blr definition\nepsilon_line = 2e-5\ncsi_line = 0.024\nR_line = 1e17 * u.cm\nblr = SphericalShellBLR(disk, csi_line, epsilon_line, R_line)\nprint(""blr definition:"")\nprint(blr)\n\n# dust torus definition\nT_dt = 1e3 * u.K\nepsilon_dt = 2.7 * ((const.k_B * T_dt) / (const.m_e * const.c * const.c)).decompose()\ncsi_dt = 0.1\ndt = RingDustTorus(disk, csi_dt, epsilon_dt)\nprint(""torus definition:"")\nprint(dt)\n\n# let us make a 2D plot of where s will be bigger than 1\nr = 1.1e16 * u.cm\n\nabsorption_disk = Absorption(blob, disk, r=r)\nabsorption_blr = Absorption(blob, blr, r=r)\nabsorption_dt = Absorption(blob, dt, r=r)\n\n# a check on the values for which s > 1 in the case of the disk\nE = np.logspace(0, 5) * u.GeV\nepsilon_1 = (E / MEC2).decompose().value\nepsilon_disk = disk._epsilon_mu(absorption_disk.mu, r.value)\nE_disk = (epsilon_disk * MEC2).to(""eV"")\n\n\ndef where_s_1(mu, r):\n    s = epsilon_1 * disk._epsilon_mu(mu, r) * (1 - mu) / 2\n    return E[s > 1][0]\n\n\nfor _r in [1e15, 1e16, 1e17]:\n    E_thr = [where_s_1(mu, _r).value for mu in absorption_disk.mu]\n    plt.semilogy(absorption_disk.mu, E_thr, label=f""r = {_r:.0e}"")\n\nplt.xlabel(r""$\\mu$"")\nplt.ylabel(""E (s>1) / GeV"")\nplt.legend()\nplt.show()\n\n\n# let\'s plot the opacities\n\nnu = E.to(""Hz"", equivalencies=u.spectral())\n\ntau_disk = absorption_disk.tau(nu)\ntau_blr = absorption_blr.tau(nu)\ntau_dt = absorption_dt.tau(nu)\n\nfig, ax = plt.subplots()\nax.loglog(E, tau_disk, lw=2, ls=""-"", label=""SS disk"")\nax.loglog(E, tau_blr, lw=2, ls=""--"", label=""spherical shell BLR"")\nax.loglog(E, tau_dt, lw=2, ls=""-."", label=""ring dust torus"")\nax.legend()\nax.set_xlabel(""E / GeV"")\nax.set_ylabel(r""$\\tau_{\\gamma \\gamma}$"")\nax.set_xlim([1, 1e5])\nax.set_ylim([1e-3, 1e5])\nplt.show()\n'"
