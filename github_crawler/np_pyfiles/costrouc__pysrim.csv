file_path,api_count,code
setup.py,0,"b'# Always prefer setuptools over distutils\nfrom setuptools import setup, find_packages\n# To use a consistent encoding\nfrom codecs import open\nfrom os import path\n\nhere = path.abspath(path.dirname(__file__))\n\n# Get the long description from the README file\nwith open(path.join(here, \'README.md\'), encoding=\'utf-8\') as f:\n    long_description = f.read()\n\n\nsetup(\n    name=\'pysrim\',\n    version=\'0.5.10\',\n    description=\'Srim Automation of Tasks via Python\',\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    url=\'https://gitlab.com/costrouc/pysrim\',\n    author=\'Christopher Ostrouchov\',\n    author_email=\'chris.ostrouchov+pysrim@gmail.com\',\n    license=""MIT"",\n    classifiers=[\n        \'Development Status :: 4 - Beta\',\n        \'Natural Language :: English\',\n        \'License :: OSI Approved :: MIT License\',\n        \'Programming Language :: Python :: 2.6\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3.3\',\n        \'Programming Language :: Python :: 3.4\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Programming Language :: Python :: 3.6\',\n        \'Programming Language :: Python :: 3.7\',\n    ],\n    keywords=\'material srim automation plotting\',\n    download_url=\'https://gitlab.com/costrouc/pysrim/repository/master/archive.zip\',\n    packages=find_packages(exclude=[\'examples\', \'tests\', \'test_files\', \'docs\']),\n    package_data={\n        \'srim\': [\'data/*.yaml\'],\n    },\n    setup_requires=[\'pytest-runner\', \'setuptools>=38.6.0\'],  # >38.6.0 needed for markdown README.md\n    install_requires=[\'pyyaml\', \'numpy>=1.10.0\'],\n    tests_require=[\'pytest\', \'pytest-mock\', \'pytest-cov\'],\n)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/stable/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'pysrim\'\ncopyright = \'2018, Chris Ostrouchov\'\nauthor = \'Chris Ostrouchov\'\n\n# The short X.Y version\nversion = \'\'\n# The full version, including alpha/beta/rc tags\nrelease = \'0.2.1\'\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.napoleon\'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pysrimdoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'pysrim.tex\', \'pysrim Documentation\',\n     \'Chris Ostrouchov\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pysrim\', \'pysrim Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'pysrim\', \'pysrim Documentation\',\n     author, \'pysrim\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n'"
srim/__init__.py,0,"b'from .srim import TRIM, SR\n\nfrom .core import ElementDB, Element, Material, Ion, Layer, Target\n'"
srim/config.py,0,"b""import os\n\nDEFAULT_SRIM_DIRECTORY = os.path.join(os.sep, 'tmp', 'srim')\n"""
srim/input.py,0,"b'"""""" Write Inputfile for SRIM and TRIM calculations\n\n""""""\n\n\nclass AutoTRIM(object):\n    def __init__(self, mode=1, restart_directroy=None):\n        """"""Writes a file AUTOTRIM to TRIM directory for autostart\n\n        Parameters\n        ----------\n        mode : int\n            (0) TRIM runs normally, (1) TRIM runs without keyboard input,\n            (2) TRIM resumes running its last saved calculation. Default 1\n            and is really the only sane option when using Python for automation\n        restart_directory : str\n            currently not implemented. default None\n        """"""\n        self._mode = mode\n\n    def write(self):\n        """""" write AUTOTRIM in current directory """"""\n        with open(\'TRIMAUTO\', \'w\') as f:\n            f.write(\'{}\'.format(self._mode))\n\n\nclass TRIMInput(object):\n    """"""Input File representation of TRIM run\n\n    Parameters\n    ----------\n    trim : :class:`srim.srim.TRIM`\n        A TRIM calculation to use for writing a file\n    """"""\n    newline = \'\\r\\n\' # TRIM uses microsoft newlines\n\n    def __init__(self, trim):\n        self._trim = trim\n\n    @property\n    def srim_num_elements(self):\n        """"""Number of unique elements in target (layer elements treated as unique)""""""\n        return sum(len(layer.elements) for layer in self._trim.target.layers)\n\n    def _write_title(self):\n        return (\n            \'This file controls TRIM Calculations \'\n            \'generated by pysrim\'\n        ) + self.newline\n\n    def _write_ion(self):\n        return (\n            \'Ion: Z, Mass [amu], Energy [keV], Angle [degrees], \'\n            \'Number Ions, Bragg Corr, AutoSave Number\'\n        ) + self.newline + \'{} {} {} {} {} {} {}\'.format(\n            self._trim.ion.atomic_number,\n            self._trim.ion.mass,\n            self._trim.ion.energy / 1000.0, # eV -> keV\n            self._trim.settings.angle_ions,\n            self._trim.number_ions,\n            self._trim.settings.bragg_correction,\n            self._trim.settings.autosave\n        ) + self.newline\n\n    def _write_cascade_options(self):\n        return (\n            \'Cascades(1=Kitchn-Peese, 2=Full-Cascade, 3=Sputtering, \'\n            \'4-5=Ions;6-7=Neutrons), Random Number Seed, Reminders\'\n        ) + self.newline + \'{} {} {}\'.format(\n        self._trim.calculation,\n            self._trim.settings.random_seed,\n            self._trim.settings.reminders\n        ) + self.newline\n\n    def _write_plot_on_off(self):\n        return (\n            \'Diskfiles (0=no,1=yes): RANGES.txt, BACKSCATT.txt, \'\n            \'TRANSMIT.txt, Sputtered, COLLISIONS.txt(0=no, 1=Ion, \'\n            \'2=Ion+Recoils), Special EXYZ.txt file\'\n        ) + self.newline + \'{} {} {} {} {} {}\'.format(\n            self._trim.settings.ranges,\n            self._trim.settings.backscattered,\n            self._trim.settings.transmit,\n            self._trim.settings.sputtered,\n            self._trim.settings.collisions,\n            self._trim.settings.exyz\n        ) + self.newline\n\n    def _write_target(self):\n        return (\n            \'Target material : Number of Elements, Number of Layers\'\n        ) + self.newline + \'""{}"" {} {}\'.format(\n            self._trim.settings.description,\n            self.srim_num_elements,\n            len(self._trim.target.layers),\n        ) + self.newline\n\n    def _write_plot_options(self):\n        return (\n            \'PlotType (0-5); Plot Depths: Xmin, Xmax(Ang.) \'\n            \'[=0 0 for Viewing Full Target]\'\n        ) + self.newline + \'{} {} {}\'.format(\n            self._trim.settings.plot_mode,\n            self._trim.settings.plot_xmin,\n            self._trim.settings.plot_xmax\n        ) + self.newline\n\n    def _write_elements(self):\n        elements_str = (\n            \'Target Elements:    Z   Mass [amu]\'\n        ) + self.newline\n        index = 1\n        for layer in self._trim.target.layers:\n            for element in layer.elements:\n                elements_str += \'Atom {} = {} =     {} {}\'.format(\n                    index,\n                    element.symbol,\n                    element.atomic_number,\n                    element.mass\n                ) + self.newline\n                index += 1\n        return elements_str\n\n    def _write_layer(self):\n        layers_str_header_1 = \'Layer    Layer Name   Width Density\'\n        layers_str_header_2 = \'Number   Description  (Ang) (g/cm^3)\'\n        layers_str = []\n\n        for layer in self._trim.target.layers:\n            for element in layer.elements:\n                layers_str_header_1 += \'  {}({})\'.format(element.symbol, element.atomic_number)\n                layers_str_header_2 += \'Stoich\'\n\n        element_index = 0\n        for layer_index, layer in enumerate(self._trim.target.layers, start=1):\n            layer_str = \'{} ""{}"" {} {}\'.format(layer_index, layer.name, layer.width, layer.density)\n            layer_str += \' 0.0\' * element_index\n            for element in layer.elements:\n                layer_str += \' {} \'.format(layer.elements[element][\'stoich\'])\n            layer_str += \' 0.0\' * (self.srim_num_elements - element_index - len(layer.elements))\n            element_index += len(layer.elements)\n            layers_str.append(layer_str)\n        return self.newline.join([layers_str_header_1, layers_str_header_2] + layers_str) + self.newline\n\n    def _write_solid_gas(self):\n        return (\n            \'0  Target layer phases (0=Solid, 1=Gas)\'\n        ) + self.newline + \' \'.join(str(layer.phase) for layer in self._trim.target.layers) + self.newline\n\n    def _write_bragg_correction(self):\n        return (\n            \'Target Compound Corrections (Bragg)\'\n        ) + self.newline + \' 1\' * len(self._trim.target.layers) + self.newline\n\n    def _write_displacement_energies(self):\n        ed_str = (\n            \'Individual target atom displacement energies (eV)\'\n        ) + self.newline\n\n        for layer in self._trim.target.layers:\n            for element in layer.elements:\n                ed_str += \' {}\'.format(layer.elements[element][\'E_d\'])\n        return ed_str + self.newline\n\n    def _write_lattice_binding(self):\n        lattice_str = (\n            \'Individual target atom lattice binding energies (eV)\'\n        ) + self.newline\n\n        for layer in self._trim.target.layers:\n            for element in layer.elements:\n                lattice_str += \' {}\'.format(layer.elements[element][\'lattice\'])\n        return lattice_str + self.newline\n\n    def _write_surface_binding(self):\n        surface_str = (\n            \'Individual target atom surface binding energies (eV)\'\n        ) + self.newline\n\n        for layer in self._trim.target.layers:\n            for element in layer.elements:\n                surface_str += \' {}\'.format(layer.elements[element][\'surface\'])\n        return surface_str + self.newline\n\n    def _write_version(self):\n        return (\n            \'Stopping Power Version (1=2011, 0=2011)\'\n        ) + self.newline + \'{}\'.format(self._trim.settings.version) + self.newline\n\n    def write(self):\n        """"""Write TRIMInput class to ``TRIM.IN``""""""\n        with open(\'TRIM.IN\', \'wb\') as f:\n            methods = [\n                self._write_title,\n                self._write_ion,\n                self._write_cascade_options,\n                self._write_plot_on_off,\n                self._write_target,\n                self._write_plot_options,\n                self._write_elements,\n                self._write_layer,\n                self._write_solid_gas,\n                self._write_bragg_correction,\n                self._write_displacement_energies,\n                self._write_lattice_binding,\n                self._write_surface_binding,\n                self._write_version\n            ]\n\n            input_str = \'\'\n            for method in methods:\n                input_str += method.__call__()\n\n            f.write(input_str.encode(\'utf-8\'))\n\n\nclass SRInput(object):\n    """"""Input file for Stopping and Range (Calculations)\n\n    Parameters\n    ----------\n    sr : :class:`srim.srim.SR`\n        SR class to use for writting file\n    """"""\n    newline = \'\\r\\n\' # TRIM uses microsoft newlines\n\n    def __init__(self, sr):\n        self._sr = sr\n\n    def _write_filename(self):\n        return (\n            \'---Stopping/Range Input Data (Number-format: Period = Decimal Point)\'\n        ) + self.newline + (\n            \'---Output File Name\'\n        ) + self.newline + \'{}\'.format(\n            self._sr.settings.output_filename\n        ) + self.newline\n\n    def _write_ion(self):\n        return (\n            \'---Ion(Z), Ion Mass(u)\'\n        ) + self.newline + \'{} {}\'.format(\n            self._sr.ion.atomic_number,\n            self._sr.ion.mass\n        ) + self.newline\n\n    def _write_layer_info(self):\n        return (\n            \'---Target Data: (Solid=0,Gas=1), Density(g/cm3), Compound Corr.\'\n        ) + self.newline + \'{} {} {}\'.format(\n            self._sr.layer.phase,\n            self._sr.layer.density,\n            self._sr.settings.correction\n        ) + self.newline + (\n            \'---Number of Target Elements\'\n        ) + self.newline + \'{}\'.format(\n            len(self._sr.layer.elements)\n        ) + self.newline\n\n    def _write_elements(self):\n        elements_str = (\n            \'---Target Elements: (Z), Target name, Stoich, Target Mass(u)\'\n        ) + self.newline\n\n        for element in self._sr.layer.elements:\n            elements_str += \'{} ""{}"" {} {}\'.format(\n                element.atomic_number,\n                element.name,\n                self._sr.layer.elements[element][\'stoich\'],\n                element.mass\n            ) + self.newline\n        return elements_str\n\n    def _write_output_options(self):\n        return (\n            \'---Output Stopping Units (1-8)\'\n        ) + self.newline + \'{}\'.format(\n            self._sr.settings.output_type\n        ) + self.newline\n\n    def _write_ion_energy_range(self):\n        return (\n            \'---Ion Energy : E-Min(keV), E-Max(keV)\'\n        ) + self.newline + \'{} {}\'.format(\n            self._sr.settings.energy_min / 1.0e3,\n            self._sr.ion.energy / 1.0e3\n        ) + self.newline\n\n    def write(self):\n        """"""Write SR calcualtion to ``SR.IN``""""""\n        with open(\'SR.IN\', \'wb\') as f:\n            methods = [\n                self._write_filename,\n                self._write_ion,\n                self._write_layer_info,\n                self._write_elements,\n                self._write_output_options,\n                self._write_ion_energy_range\n            ]\n\n            input_str = \'\'\n            for method in methods:\n                input_str += method.__call__()\n\n            f.write(input_str.encode(\'utf-8\'))\n'"
srim/output.py,4,"b'"""""" Read output files of SRIM simulation\n\nTODO: Read header information\n""""""\nimport os\nimport re\nfrom io import BytesIO\n\nimport numpy as np\n\nfrom .core.ion import Ion\n\n# Valid double_regex 4, 4.0, 4.0e100\ndouble_regex = r\'[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)?\'\nsymbol_regex = r\'[A-Z][a-z]?\'\nint_regex = \'[+-]?\\d+\'\n\n\nclass SRIMOutputParseError(Exception):\n    """"""SRIM error reading output file""""""\n    pass\n\n\nclass SRIM_Output(object):\n    def _read_name(self, output):\n        raise NotImplementedError()\n\n    def _read_ion(self, output):\n        ion_regex = \'Ion\\s+=\\s+({})\\s+Energy\\s+=\\s+({})\\s+keV\'.format(\n            symbol_regex, double_regex)\n        match = re.search(ion_regex.encode(\'utf-8\'), output)\n        if match:\n            symbol = str(match.group(1).decode(\'utf-8\'))\n            energy = float(match.group(2)) #keV\n            return Ion(symbol, 1000.0 * energy)\n        raise SRIMOutputParseError(""unable to extract ion from file"")\n\n    def _read_target(self, output):\n        match_target = re.search(b\'(?<=====\\r\\n)Layer\\s+\\d+\\s+:.*?(?=====)\', output, re.DOTALL)\n        if match_target:\n            print(match_target.group(0))\n            layer_regex = (\n                \'Layer\\s+(?P<i>\\d+)\\s+:\\s+(.+)\\r\\n\'\n                \'Layer Width\\s+=\\s+({0})\\s+A\\s+;\\r\\n\'\n                \'\\s+Layer #\\s+(?P=i)- Density = ({0}) atoms/cm3 = ({0}) g/cm3\\r\\n\'\n                \'((?:\\s+Layer #\\s+(?P=i)-\\s+{1}\\s+=\\s+{0}\\s+Atomic Percent = {0}\\s+Mass Percent\\r\\n)+)\'\n            ).format(double_regex, symbol_regex)\n            layers = re.findall(layer_regex.encode(\'utf-8\'), match_target.group(0))\n            if layers:\n                element_regex = (\n                    \'\\s+Layer #\\s+(\\d+)-\\s+({1})\\s+=\\s+({0})\\s+Atomic Percent = ({0})\\s+Mass Percent\\r\\n\'\n                ).format(double_regex, symbol_regex)\n                element_regex = element_regex.encode()\n\n                layers_elements = []\n                for layer in layers:\n                    # We know that elements will match\n                    layers_elements.append(re.findall(element_regex, layer[5]))\n\n                raise NotImpementedError()\n\n                import pytest\n                pytest.set_trace()\n\n        raise SRIMOutputParseError(""unable to extract total target from file"")\n\n    def _read_num_ions(self, output):\n        match = re.search(b\'Total Ions calculated\\s+=(\\d+.\\d+)\', output)\n        if match:\n            # Cast string -> float -> round down to nearest int\n            return int(float(match.group(1)))\n        raise SRIMOutputParseError(""unable to extract total ions from file"")\n\n    def _read_table(self, output):\n        match = re.search((\n            b\'=+(.*)\'\n            b\'-+(?:\\s+-+)+\'\n        ), output, re.DOTALL)\n        # Read Data from table\n\n        if match:\n            # Headers TODO: name the columns in table\n            header = None\n\n            # Data\n            data = np.genfromtxt(BytesIO(output[match.end():]), max_rows=100)\n            return data\n        raise SRIMOutputParseError(""unable to extract table from file"")\n\n\nclass Results(object):\n    """""" Gathers all results from folder\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n        directory to look for TRIM calculations\n\n    Notes\n    -----\n    Files that are looked for:\n      - ``IONIZ.txt`` handled by :class:`srim.output.Ioniz`\n      - ``VACANCY.txt`` handled by :class:`srim.output.Vacancy`\n      - ``NOVAC.txt`` handled by :class:`srim.output.NoVacancy`\n      - ``E2RECOIL.txt`` handled by :class:`srim.output.EnergyToRecoils`\n      - ``PHONON.txt`` handled by :class:`srim.output.Phonons`\n      - ``RANGE.txt`` handled by :class:`srim.output.Range`\n    """"""\n    def __init__(self, directory):\n        """""" Retrives all the calculation files in a given directory""""""\n        self.ioniz = Ioniz(directory)\n        self.vacancy = Vacancy(directory)\n\n        try:\n            self.novac = NoVacancy(directory)\n        except ValueError:\n            self.novac = None\n\n        self.etorecoils = EnergyToRecoils(directory)\n        self.phonons = Phonons(directory)\n        self.range = Range(directory)\n\n\nclass Ioniz(SRIM_Output):\n    """"""``IONIZ.txt`` Ionization by ions and depth. Includes header information about calculation\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for Ioniz. Default ``IONIZ.txt``\n    """"""\n    def __init__(self, directory, filename=\'IONIZ.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._ions = data[:, 1]\n        self._recoils = data[:, 2]\n\n    @property\n    def ion(self):\n        """""" Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """""" Number of Ions in SRIM simulation """"""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """""" Depth [Ang] of bins in SRIM Calculation """"""\n        return self._depth\n\n    @property\n    def ions(self):\n        """"""Ionization energy [eV/(Angstrom Ion)] lost to electronic stopping\n        in incident ions""""""\n        return self._ions\n\n    @property\n    def recoils(self):\n        """"""Ionization energy [eV/(Angstrom Ion)] lost to electronic stopping\n        in recoil ions""""""\n        return self._recoils\n\n\nclass Vacancy(SRIM_Output):\n    """"""``VACANCY.txt`` Table of the final distribution of vacancies vs depth\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for Vacancy. Default ``VACANCY.txt``\n    """"""\n    def __init__(self, directory, filename=\'VACANCY.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._ion_knock_ons = data[:, 1]\n        self._vacancies = data[:, 2:]\n\n    @property\n    def ion(self):\n        """""" Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """"""Number of Ions in SRIM simulation""""""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """"""Depth [Ang] of bins in SRIM Calculation""""""\n        return self._depth\n\n    @property\n    def knock_ons(self):\n        """"""Vacancies produced [Vacancies/(Angstrom-Ion) by ion]""""""\n        return self._ion_knock_ons\n\n    @property\n    def vacancies(self):\n        """"""Vacancies [Vacancies/(Angstrom-Ion)] produced of element in layer""""""\n        return self._vacancies\n\n\nclass NoVacancy(SRIM_Output):\n    """""" ``NOVAC.txt`` Table of Replacement Collisions\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for NoVacancy. Default ``NOVAC.txt``\n    """"""\n    def __init__(self, directory, filename=\'NOVAC.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n\n            # Check if it is KP calculation\n            if re.search(b\'Recoil/Damage Calculations made with Kinchin-Pease Estimates\',\n                         output):\n                raise ValueError(\'NOVAC has no data for KP calculations\')\n\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._number = data[:, 1]\n\n    @property\n    def ion(self):\n        """""" Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """"""Number of Ions in SRIM simulation""""""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """"""Depth [Ang] of bins in SRIM Calculation""""""\n        return self._depth\n\n    @property\n    def number(self):\n        """"""Replacement Collisions [Number/(Angstrom-Ion)]""""""\n        return self._number\n\n\nclass EnergyToRecoils(SRIM_Output):\n    """"""``E2RECOIL.txt`` Energy transfered to atoms through binary collision\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for EnergyToRecoils. Default ``E2RECOIL.txt``\n    """"""\n    def __init__(self, directory, filename=\'E2RECOIL.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._ions = data[:, 1]\n        self._recoils = data[:, 2:]\n\n    @property\n    def ion(self):\n        """"""Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """"""Number of Ions in SRIM simulation""""""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """"""Depth [Ang] of bins in SRIM Calculation""""""\n        return self._depth\n\n    @property\n    def ions(self):\n        """"""Energy [eV/(Angstrom-Ion)] transfered to material through ion collisions""""""\n        return self._ions\n\n    @property\n    def absorbed(self):\n        """"""Energy [eV/(Angstrom-Ion)] absorbed from collisions with Atom\n\n        TODO: fix terminology\n        """"""\n        return self._recoils\n\n\nclass Phonons(SRIM_Output):\n    """"""``PHONON.txt``  Distribution of Phonons\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for Phonons. Default ``PHONON.txt``\n    """"""\n    def __init__(self, directory, filename=\'PHONON.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._ions = data[:, 1]\n        self._recoils = data[:, 2]\n\n    @property\n    def ion(self):\n        """"""Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """"""Number of Ions in SRIM simulation""""""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """"""Depth [Ang] of bins in SRIM Calculation""""""\n        return self._depth\n\n    @property\n    def ions(self):\n        """"""Number of phonons [Phonons/(Angstrom Ion)] created from ions collisions""""""\n        return self._ions\n\n    @property\n    def recoils(self):\n        """"""Number of phonons [Phonons/(Angstrom Ion)] created from recoils\n        resulting from ion collisions""""""\n        return self._recoils\n\n\nclass Range(SRIM_Output):\n    """"""``RANGE.txt`` Table of the final distribution of the ions, and any recoiling target atoms\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for Range. Default ``RANGE.txt``\n    """"""\n    def __init__(self, directory, filename=\'RANGE.txt\'):\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n            ion = self._read_ion(output)\n            num_ions = self._read_num_ions(output)\n            data = self._read_table(output)\n\n        self._ion = ion\n        self._num_ions = num_ions\n        self._depth = data[:, 0]\n        self._ions = data[:, 1]\n        self._elements = data[:, 2:]\n\n    @property\n    def ion(self):\n        """"""Ion used in SRIM calculation\n\n        **mass** could be wrong\n        """"""\n        return self._ion\n\n    @property\n    def num_ions(self):\n        """"""Number of Ions in SRIM simulation""""""\n        return self._num_ions\n\n    @property\n    def depth(self):\n        """"""Depth [Ang] of bins in SRIM Calculation""""""\n        return self._depth\n\n    @property\n    def ions(self):\n        """"""Ion final distribution [(Atoms/cm3)/(Atoms/cm2)]""""""\n        return self._ions\n\n    @property\n    def elements(self):\n        """"""Per elements [(Atoms/cm3)/(Atoms/cm2)] distribution of each element""""""\n        return self._elements\n\n\n\nclass Backscat(object):\n    """""" The kinetics of all backscattered ions (energy, location and trajectory)\n\n    TODO: one day to be implemented! submit pull request please!\n    """"""\n    pass\n\n\nclass Transmit(object):\n    """""" The kinetics of all transmitted ions (energy, location and trajectory)\n\n    TODO: one day to be implemented! submit pull request please!\n    """"""\n    pass\n\n\nclass Sputter(object):\n    """""" The kinetics of all target atoms sputtered from the target.\n\n    TODO: one day to be implemented! submit pull request please!\n    """"""\n    pass\n\n\nclass Collision:\n    """"""Reads the SRIM Collisions file.\n\n    This is the most important file in my opinion. It records every\n    single collision and its energies. The file will get huge for\n    simulations with many collisions. Since the file can be larger\n    than the amount of RAM it will read the file in sections\n    (buffers).\n\n    Parameters\n    ----------\n    directory : :obj:`str`\n         directory of calculation\n    filename : :obj:`str`, optional\n         filename for Collisions. Default ``COLLISON.txt``\n\n    """"""\n    def __init__(self, directory, filename=\'COLLISON.txt\'):\n        self.filename = os.path.join(directory, filename)\n\n        with open(self.filename, encoding=""latin-1"") as f:\n            self._read_header(f)\n\n        self._ion_index = buffered_findall(self.filename, b""  Ion    Energy"")\n\n    def _read_header(self, f):\n        """"""Read Header of COLLISON.txt\n\n        Currently we do nothing with the header\n        """"""\n\n        # Collect the header of the file\n        header = []\n\n        for line in f:\n            if line == "" \\n"":\n                break\n            header.append(line)\n        return header\n\n    def _read_ion(self, ion_str):\n        """"""There are 2 types of files with and without cascades\n\n        format:\n           1 - Kinchin-Pease Theory (No full cascades)\n           2 - full cascades\n        """"""\n        # Notice that lines is an generator!\n        # This makes it so we can walk through lines\n        # in multiple for loops\n        lines = (line for line in ion_str.split(\'\\n\'))\n\n        # Skip Ion Header\n        for line in lines:\n            if re.match(""^-+\\r$"", line):\n                break\n\n        collisions = []\n\n        # Reads collisions for an ion\n        for line in lines:\n            if re.match(""^=+\\r$"", line):\n                break\n\n            tokens = line.split(chr(179))[1:-1]\n\n            # Check if a full_cascades simulation\n            # Read Cascade information\n            if re.match(r""\\s+<== Start of New Cascade\\s+"", tokens[-1]):\n                (target_disp,\n                 target_vac,\n                 target_replac,\n                 target_inter,\n                 cascade) = self._read_cascade(lines)\n            else:\n                target_disp = float(tokens[8])\n                target_vac = 0\n                target_replac = 0\n                target_inter = 0\n                cascade = None\n\n            collisions.append({\n                \'ion_number\': int(tokens[0]),\n                \'kinetic_energy\': float(tokens[1]),\n                \'depth\': float(tokens[2]),\n                \'lat_y_dist\': float(tokens[3]),\n                \'lat_z_dist\': float(tokens[4]),\n                \'stopping_energy\': float(tokens[5]),\n                \'atom\': re.search(""([A-Z][a-z]?)"", tokens[6]).group(1),\n                \'recoil_energy\': float(tokens[7]),\n                \'target_disp\': target_disp,\n                \'target_vac\': target_vac,\n                \'target_replac\': target_replac,\n                \'target_inter\': target_inter,\n                \'cascade\': cascade\n            })\n\n            # Handles weird case where no summary of cascade\n            if target_disp is None:\n                break;\n\n        # Reads ion footer\n        ion_number = re.search(int_regex, next(lines)).group(0)\n\n        footer = """"\n        for line in lines:\n            if re.match(""^=+\\r$"", line):\n                break\n            footer += line\n\n        matches = re.findall(double_regex, footer)\n\n        line = next(lines)\n\n        return {\n            \'ion_number\': int(ion_number),\n            \'displacements\': float(matches[0]),\n            \'avg_displacements\': float(matches[1]),\n            \'replacements\': float(matches[2]),\n            \'avg_replacements\': float(matches[3]),\n            \'vacancies\': float(matches[4]),\n            \'avg_vacancies\': float(matches[5]),\n            \'interstitials\': float(matches[6]),\n            \'avg_interstitials\': float(matches[7]),\n            \'sputtered_atoms\': float(matches[8]),\n            \'avg_sputtered_atoms\': float(matches[9]),\n            \'transmitted_atoms\': float(matches[10]),\n            \'avg_transmitted_atoms\': float(matches[11]),\n            \'collisions\': collisions\n        }\n\n    def _read_cascade(self, lines):\n        line = next(lines)\n\n        assert re.match(""^=+\\r$"", line)\n\n\n        line = next(lines)\n        assert re.match((\n                ""  Recoil Atom Energy\\(eV\\)   X \\(A\\)      Y \\(A\\)      Z \\(A\\)""\n                ""   Vac Repl Ion Numb \\d+=""\n        ), line)\n\n        cascade = []\n        for line in lines:\n            if re.match(""^=+\\r$"", line):\n                break\n            tokens = line.split()[1:-1]\n\n            print(tokens)\n            cascade.append({\n                \'recoil\': int(tokens[0]),\n                \'atom\': int(tokens[1]),\n                \'recoil_energy\': float(tokens[2]),\n                \'position\': np.array([float(tokens[3]),\n                                      float(tokens[4]),\n                                      float(tokens[5])]),\n                \'vac\': int(tokens[6]),\n                \'repl\': int(tokens[7])\n            })\n\n        if line.count(\'=\') > 100:\n            return None, None, None, None, cascade\n\n        line = next(lines)\n        tokens = line.split(chr(179))[1:-1]\n\n        if tokens:\n\n            target_disp = float(tokens[2])\n            target_vac = float(tokens[3])\n            target_replac = float(tokens[4])\n            target_inter = float(tokens[5])\n        else:\n            target_disp = None\n            target_vac = None\n            target_replac = None\n            target_inter = None\n\n        return target_disp, target_vac, target_replac, target_inter, cascade\n\n    def __getitem__(self, i):\n        start = self._ion_index[i]\n\n        if i == len(self._ion_index):\n            end = os.path.getsize(self.filename)\n        else:\n            end = self._ion_index[i+1]\n\n        with open(self.filename, ""rb"") as f:\n            f.seek(start)\n            # We assume that ion_str will fit in RAM\n            ion_str = f.read(end - start)\n            return self._read_ion(ion_str.decode(\'latin-1\'))\n\n    def __len__(self):\n        return len(self._ion_index) - 1\n\n\ndef buffered_findall(filename, string, start=0):\n    """"""A method of reading a file in buffered pieces (needed for HUGE files)""""""\n    with open(filename, \'rb\') as f:\n        filesize = os.path.getsize(filename)\n        BUFFERSIZE = 4096\n        overlap = len(string) - 1\n        buffer = None\n        positions = []\n\n        if start > 0:\n            f.seek(start)\n\n        while True:\n            if (f.tell() >= overlap and f.tell() < filesize):\n                f.seek(f.tell() - overlap)\n            buffer = f.read(BUFFERSIZE)\n            if buffer:\n                buffer_positions = [m.start() for m in re.finditer(string, buffer)]\n\n                for position in buffer_positions:\n                    if position >= 0:\n                        positions.append(f.tell() - len(buffer) + position)\n            else:\n                return positions\n\nclass SRResults(object):\n    """"""Read SR_OUTPUT.txt file generated by pysrim SR.run()""""""\n\n    def __init__(self, directory, filename=\'SR_OUTPUT.txt\'):\n        \'\'\'reads the file named SR_OUTPUT.txt in SR_Module folder\'\'\'\n        with open(os.path.join(directory, filename), \'rb\') as f:\n            output = f.read()\n\n        self._units = self._read_stopping_units(output)\n        self._data = self._read_stopping_table(output)\n        self._ion = self._read_ion_info(output)\n        self._target = self._read_target_info(output)\n\n    def _read_stopping_units(self, output):\n        \'\'\'read stopping units used in the calculation\'\'\'\n        match = re.search(br\'\\s+Stopping Units\\s+=+\\s+(?P<stopping_units>.*)\\s+\\r\\n\', output)\n        out_string = match.group(1).decode(\'utf-8\')\n        return out_string\n\n    def _read_ion_info(self, output):\n        \'\'\'Example line to read from the file:\n        Ion = Nickel       [28] , Mass = 58.6934 amu\'\'\'\n        projectile_rexep = r\'Ion\\s+=\\s+(.*?)\\s+\\[({})\\]\\s+, Mass\\s+=\\s({})\\s+amu+\\r\\n\'.format(int_regex, double_regex)\n        match = re.findall(projectile_rexep.encode(\'utf-8\'), output, re.DOTALL)\n        out_dict = {\n            \'name\': match[0][0].decode(\'utf-8\'),\n            \'Z1\': int(match[0][1]),\n            \'A1\': float(match[0][2])\n        }\n        return out_dict\n\n\n    def _read_target_info(self, output):\n        \'\'\'lines to find from the file:\n        Density =  2.3210E+00 g/cm3 = 4.9766E+22 atoms/cm3\n        ======= Target  Composition ========\n           Atom   Atom   Atomic    Mass\n           Name   Numb   Percent   Percent\n           ----   ----   -------   -------\n            Si     14    100.00    100.00\n        ====================================\n        \'\'\'\n\n        # first read the density info from the file\n        density_reexp = r\'Density\\s+=\\s+({})\\s+g/cm3\\s+=\\s({})\\s+atoms/cm3\'.format(double_regex, double_regex)\n\n        density_match = re.search(density_reexp.encode(\'utf-8\'), output)\n\n        density = np.array([density_match.group(1),density_match.group(2)], dtype=\'float\')\n\n        # find the target composition table\n        table_regexp = r\'=*\\s+Target\\s+Composition\\s+=*\\r\\n(.*\\r\\n){3}((?:\\s*.+\\s\\r\\n)+)\\s=*\\r\\n\\s+Bragg Correction\'#.format(symbol_regex, int_regex, double_regex, double_regex)#(=*)\\r\\n\'\n        table_match = re.search(table_regexp.encode(\'utf-8\'), output)\n\n        # rearrange the match into list of layer elements\n        target_comp = table_match.groups()[-1].decode(\'utf-8\').strip().split(\'\\r\\n\')\n\n        #create a dict object for target layers\n        elements_dict ={}\n\n        for line in target_comp:\n            element = line.strip().split()\n            Z = int(element[1])\n            stoich_percent = float(element[2])\n            mass_percent = float(element[3])\n            elements_dict[element[0]] = [Z, stoich_percent, mass_percent]\n            #print()\n\n        # create a output dict\n        target_dict = {\'density g/cm3\': density[0],\n                       \'density atoms/cm3\': density[1],\n                      \'target composition\': elements_dict\n                      }\n\n        return target_dict\n\n    def _read_stopping_table(self, output):\n        \'\'\'table header:\n                Ion        dE/dx      dE/dx     Projected  Longitudinal   Lateral\n               Energy      Elec.      Nuclear     Range     Straggling   Straggling\n          --------------  ---------- ---------- ----------  ----------  ----------\n\n          table footer:\n          -----------------------------------------------------------\n         Multiply Stopping by        for Stopping Units\n         -------------------        ------------------\n          2.2299E+01                 eV / Angstrom\n          2.2299E+02                keV / micron\n          2.2299E+02                MeV / mm\n          1.0000E+00                keV / (ug/cm2)\n          1.0000E+00                MeV / (mg/cm2)\n          1.0000E+03                keV / (mg/cm2)\n          3.1396E+01                 eV / (1E15 atoms/cm2)\n          1.8212E+01                L.S.S. reduced units\n         ==================================================================\n         (C) 1984,1989,1992,1998,2008 by J.P. Biersack and J.F. Ziegler\n        \'\'\'\n\n        table_header_regexp = r\'\\s+Ion\\s+dE/dx\\s+(.*\\r\\n){3}\'\n        table_header_match = re.search(table_header_regexp.encode(\'utf-8\'), output)\n\n        table_footer_regexp = r\'\\s*-*\\r\\n\\sMultiply\'\n        table_footer_match = re.search(table_footer_regexp.encode(\'utf-8\'), output)\n\n        start_idx = table_header_match.end()\n        stop_idx = table_footer_match.start()\n\n        rawdata = BytesIO(output[start_idx:stop_idx]).read().decode(\'utf-8\')\n\n        output_array = [[] for i in range(6)]\n\n        #function for\n        energy_conversion = lambda a: 1 if (\'keV\' in a) else (1e3 if (\'MeV\' in a) else (1e6 if \'GeV\' in a else (1e-3 if \'eV\' in a else None)))\n\n        #function for\n        length_conversion = lambda a: 1 if (\'um\' in a) else (1e-4 if (\'A\' in a) else (1e3 if (\'mm\' in a) else None))\n\n        for line in rawdata.split(\'\\r\\n\'):\n            line_array = line.split()\n            #print(line_array)\n\n            #find conversion factors for all energy values (current unit --> keV)\n            E_coeff = list(map(energy_conversion,(filter(energy_conversion, line_array))))[0]\n\n            #find conversion factors for all length values (current unit --> um)\n            L_coeff = list(map(length_conversion, filter(length_conversion, line_array)))\n\n            energy = float(line_array[0])*E_coeff\n            Se = float(line_array[2])\n            Sn = float(line_array[3])\n            Range = float(line_array[4])*L_coeff[0]\n            long_straggle = float(line_array[6])*L_coeff[1]\n            lat_straggle = float(line_array[8])*L_coeff[2]\n\n            [output_array[i].append(d) for i, d in zip(range(6), [energy, Se, Sn, Range, long_straggle, lat_straggle])]\n\n        return np.array(output_array)\n\n    @property\n    def units(self):\n        return self._units\n\n    @property\n    def data(self):\n        """"""\n         [\n           <energy in keV>,\n           <electronic stopping in <units> >,\n           <nuclear stopping in <units> >,\n           <projected range in um>,\n           <longitudinal straggling in um>,\n           <lateral straggling in um>\n         ]\n        """"""\n        return self._data\n\n    @property\n    def ion(self):\n        """"""\n        {\n           \'name\': <e.g. Silicon>,\n           \'Z1\': <int(atomic number)>,\n           \'A1\': <float(atomic mass)>\n        }\n        """"""\n        return self._ion\n\n    @property\n    def target(self):\n        """"""\n        {\n           \'density g/cm3\': <float>,\n           \'density atoms/cm3\': <float>,\n           \'target composition\': {\n               <element 1 symbol>\': {\n                   <int(Z)>,\n                   <float(stoichiometric percent)>,\n                   <float(mass percent)>\n               },\n               <element 2 symbol>\': {...},\n               ...\n            }\n        }\n        """"""\n        return self._target\n'"
srim/plot.py,1,"b'def plot_damage_energy(results, ax):\n    """"""Plot damage energy (ions + recoils) per unit depth\n\n    Parameters\n    ----------\n    results : :class:`srim.output.Results`\n        results from srim calcualtion\n    ax : matplotlib.Axes\n        matplotlib axes to plot into\n    """"""\n    phon = results[\'phonons\']\n    dx = max(phon.depth) / 100.0 # to units of Angstroms\n    energy_damage = (phon.ions + phon.recoils) * dx\n    ax.plot(phon.depth, energy_damage / phon.num_ions, label=\'{}\'.format(folder))\n    return sum(energy_damage)\n\n\ndef plot_ionization(results, ax):\n    """"""Plot ionization (ion vs recoils) per unit depth\n\n    Parameters\n    ----------\n    results : :class:`srim.output.Results`\n        results from srim calcualtion\n    ax : matplotlib.Axes\n        matplotlib axes to plot into\n    """"""\n    ioniz = results[\'ioniz\']\n    dx = max(ioniz.depth) / 100.0 # to units of Angstroms\n    ax.plot(ioniz.depth, ioniz.ions, label=\'Ionization from Ions\')\n    ax.plot(ioniz.depth, ioniz.recoils, label=\'Ionization from Recoils\')\n\n\ndef plot_vacancies(results, ax):\n    """"""Plot vacancies (ion + recoils produced) per unit depth\n\n    Parameters\n    ----------\n    results : :class:`srim.output.Results`\n        results from srim calcualtion\n    ax : matplotlib.Axes\n        matplotlib axes to plot into\n    """"""\n    vac = results[\'vacancy\']\n    vacancy_depth = vac.knock_ons + np.sum(vac.vacancies, axis=1)\n    ax.plot(vac.depth, vacancy_depth, label=""Total vacancies at depth"")\n    return sum(vacancy_depth)\n'"
srim/srim.py,0,"b'"""""" Module for automating srim calculations\n\n""""""\nimport os\nimport random\nimport subprocess\nimport shutil\nimport distutils.spawn\n\nfrom .core.utils import (\n    check_input,\n    is_zero, is_zero_or_one, is_zero_to_two, is_zero_to_five,\n    is_one_to_seven, is_one_to_eight,\n    is_srim_degrees,\n    is_positive,\n    is_quoteless\n)\n\nfrom .output import Results, SRResults\nfrom .input import AutoTRIM, TRIMInput, SRInput\nfrom .config import DEFAULT_SRIM_DIRECTORY\n\n\nclass TRIMSettings(object):\n    """""" TRIM Settings\n\n    This object can construct all options available when running a TRIM calculation.\n\n    Parameters\n    ----------\n    description : :obj:`str`, optional\n       A name to give calculation. Has no effect on the actual\n       calculation.\n    reminders : :obj:`str`, optional\n       TODO: could not find description. default 0\n    autosave : :obj:`int`, optional\n       save calculations after every `autosave` steps. default 0 will\n       not autosave except at end\n    plot_mode : :obj:`int`, optional\n       Default 5.\n       (0) ion distribution with recoils projected on y-plane\n       (1) ion distribution with recoils projected on z-plane\n       (2) ion distribution without recoils projected on y-plane\n       (3) transverse plot of ions + recoil cascades, yz-plane\n       (4) all four (0-3) on one screen\n       (5) no graphics (default and at least 5X faster than others)\n    plot_xmin : :obj:`float`, optional\n       minimum x depth to plot only really matters if ``plot_mode``\n       between 0-4. Default 0.0.\n    plot_xmax : :obj:`float`, optional\n       maximum x depth to plot only really matters if ``plot_mode``\n       between 0-4. Default 0.0.\n    ranges : :obj:`bool`, optional\n       whether include ``RANGES.txt``, ``RANGE_3D.txt`` to output\n       files. Default (0) False\n    backscattered : :obj:`bool`, optional\n       whether include ``BACKSCAT.txt`` to output files. Default (0)\n       False\n    transmit : :obj:`bool`, optional\n       whether include ``TRANSMIT.txt`` to output files. Default (0)\n       False\n    sputtered : :obj:`bool`, optional\n       whether include ``SPUTTER.txt`` to output files. Default (0)\n       False\n    collisions : :obj:`bool`, optional\n       whether include ``COLLISON.txt`` to output files. Yes they did\n       mispell collisions. Default (0) False\n    exyz : int\n       increment in eV to use for ``EXYZ.txt`` file. Default (0)\n    angle_ions : :obj:`float`, optional\n       angle of incidence of the ion with respect to the target\n       surface. Default (0) perpendicular to the target surface along\n       x-axis. Values 0 - 89.9.\n    bragg_correction : :obj:`float`, optional\n       bragg correction to stopping. Default (0) no correction\n    random_seed : :obj:`int`, optional\n       a random seed to start calculation with. Default random integer\n       between 0 and 100,000. Thus all calculations by default are random.\n    version : :obj:`int`, optional\n       SRIM-2008 or SRIM-2008 so not really much choice. Default (0)\n\n    Notes\n    -----\n        This class should never explicitely created. Instead set as\n        kwargs in :class:`srim.srim.TRIM`\n    """"""\n    def __init__(self, **kwargs):\n        """"""Initialize settings for a TRIM running""""""\n        self._settings = {\n            \'description\': check_input(str, is_quoteless, kwargs.get(\'description\', \'pysrim run\')),\n            \'reminders\': check_input(int, is_zero_or_one, kwargs.get(\'reminders\', 0)),\n            \'autosave\': check_input(int, is_zero_or_one, kwargs.get(\'autosave\', 0)),\n            \'plot_mode\': check_input(int, is_zero_to_five, kwargs.get(\'plot_mode\', 5)),\n            \'plot_xmin\': check_input(float, is_positive, kwargs.get(\'plot_xmin\', 0.0)),\n            \'plot_xmax\': check_input(float, is_positive, kwargs.get(\'plot_xmax\', 0.0)),\n            \'ranges\': check_input(int, is_zero_or_one, kwargs.get(\'ranges\', 0)),\n            \'backscattered\': check_input(int, is_zero_or_one, kwargs.get(\'backscattered\', 0)),\n            \'transmit\': check_input(int, is_zero_or_one, kwargs.get(\'transmit\', 0)),\n            \'sputtered\': check_input(int, is_zero_or_one, kwargs.get(\'ranges\', 0)),\n            \'collisions\': check_input(int, is_zero_to_two, kwargs.get(\'collisions\', 0)),\n            \'exyz\': check_input(int, is_positive, kwargs.get(\'exyz\', 0)),\n            \'angle_ions\': check_input(float, is_srim_degrees, kwargs.get(\'angle_ions\', 0.0)),\n            \'bragg_correction\': float(kwargs.get(\'bragg_correction\', 1.0)), # TODO: Not sure what correct values are\n            \'random_seed\': check_input(int, is_positive, kwargs.get(\'random_seed\', random.randint(0, 100000))),\n            \'version\': check_input(int, is_zero_or_one, kwargs.get(\'version\', 0)),\n        }\n\n        if self.plot_xmin > self.plot_xmax:\n            raise ValueError(\'xmin must be <= xmax\')\n\n    def __getattr__(self, attr):\n        return self._settings[attr]\n\n\nclass TRIM(object):\n    """""" Automate TRIM Calculations\n\n    Parameters\n    ----------\n    target : :class:`srim.core.target.Target`\n        constructed target for TRIM calculation\n    ion : :class:`srim.core.ion.Ion`\n        constructed ion for TRIM calculation\n    calculation : :obj:`int`, optional\n        Default 1 quick KP calculation\n        (1) Ion Distribution and Quick Calculation of Damage (quick KP)\n        (2) Detailed Calculation with full Damage Cascades (full cascades)\n        (3) Monolayer Collision Steps / Surface Sputtering\n        (4) Ions with specific energy/angle/depth (quick KP damage) using TRIM.DAT\n        (5) Ions with specific energy/angle/depth (full cascades) using TRIM.DAT\n        (6) Recoil cascades from neutrons, etc. (full cascades) using TRIM.DAT\n        (7) Recoil cascades and monolayer steps (full cascades) using TRIM.DAT\n        (8) Recoil cascades from neutrons, etc. (quick KP damage) using TRIM.DAT\n    number_ions : :obj:`int`, optional\n        number of ions that you want to simulate. Default 1000. A lot\n        better than the 99999 default in TRIM...\n    kwargs :\n        See :class:`srim.srim.TRIMSettings` for available TRIM\n        options. There are many and none are required defaults are\n        appropriate for most cases.\n\n    Notes\n    -----\n        If you are doing a simulation with over 1,000 ions it is\n        recomended to split the calculaion into several smaller\n        calculations. TRIM has been known to unexpectedly crash mainly\n        due to memory usage.\n    """"""\n    def __init__(self, target, ion, calculation=1, number_ions=1000, **kwargs):\n        """""" Initialize TRIM calcualtion""""""\n        self.settings = TRIMSettings(**kwargs)\n        self.calculation = check_input(int, is_one_to_seven, calculation)\n        self.number_ions = check_input(int, is_positive, number_ions)\n        self.target = target\n        self.ion = ion\n\n    def _write_input_files(self):\n        """""" Write necissary TRIM input files for calculation """"""\n        AutoTRIM().write()\n        TRIMInput(self).write()\n\n    @staticmethod\n    def copy_output_files(src_directory, dest_directory, check_srim_output=True):\n        """"""Copies known TRIM files in directory to destination directory\n\n        Parameters\n        ----------\n        src_directory : :obj:`str`\n            source directory to look for TRIM output files\n        dest_directory : :obj:`str`\n            destination directory to copy TRIM output files to\n        check_srim_output : :obj:`bool`, optional\n            ensure that all files exist\n        """"""\n        known_files = {\n            \'TRIM.IN\', \'PHONON.txt\', \'E2RECOIL.txt\', \'IONIZ.txt\',\n            \'LATERAL.txt\', \'NOVAC.txt\', \'RANGE.txt\', \'VACANCY.txt\',\n            \'COLLISON.txt\', \'BACKSCAT.txt\', \'SPUTTER.txt\',\n            \'RANGE_3D.txt\', \'TRANSMIT.txt\', \'TRIMOUT.txt\',\n            \'TDATA.txt\'\n        }\n\n        if not os.path.isdir(src_directory):\n            raise ValueError(\'src_directory must be directory\')\n\n        if not os.path.isdir(dest_directory):\n            raise ValueError(\'dest_directory must be directory\')\n\n        for known_file in known_files:\n            if os.path.isfile(os.path.join(\n                    src_directory, known_file)):\n                shutil.copy(os.path.join(\n                    src_directory, known_file), dest_directory)\n            elif os.path.isfile(os.path.join(src_directory, \'SRIM Outputs\', known_file)) and check_srim_output:\n                shutil.move(os.path.join(\n                    src_directory, \'SRIM Outputs\', known_file), dest_directory)\n\n    def run(self, srim_directory=DEFAULT_SRIM_DIRECTORY):\n        """"""Run configured srim calculation\n\n        This method:\n         - writes the input file to ``<srim_directory>/TRIM.IN``\n         - launches ``<srim_directory>/TRIM.exe``. Uses ``wine`` if available (needed for linux and osx)\n\n        Parameters\n        ----------\n        srim_directory : :obj:`str`, optional\n            path to srim directory. ``SRIM.exe`` should be located in\n            this directory. Default ``/tmp/srim/`` will absolutely\n            need to change for windows.\n        """"""\n        current_directory = os.getcwd()\n        try:\n            os.chdir(srim_directory)\n            self._write_input_files()\n            # Make sure compatible with Windows, OSX, and Linux\n            # If \'wine\' command exists use it to launch TRIM\n            if distutils.spawn.find_executable(""wine""):\n                subprocess.check_call([\'wine\', str(os.path.join(\'.\', \'TRIM.exe\'))])\n            else:\n                subprocess.check_call([str(os.path.join(\'.\', \'TRIM.exe\'))])\n            os.chdir(current_directory)\n            return Results(srim_directory)\n        finally:\n            os.chdir(current_directory)\n\n\nclass SRSettings(object):\n    """""" SR Settings\n\n    Parameters\n    ----------\n    energy_min : :obj:`float`, optional\n       lowest energy in [eV] to calculation range\n    output_type : :obj:`int`, optional\n       specify units for output table\n       (1) eV/Angstrom\n       (2) keV/micron\n       (3) MeV/mm\n       (4) keV / (ug/cm2)\n       (5) MeV / (mg/cm2)\n       (6) keV / (mg/cm2)\n       (7) eV / (1E15 atoms/cm2)\n       (8) L.S.S reduced units\n    output_filename : :obj:`str`, optional\n       filename to give for SR output from calcualtion\n    correction : :obj:`float`, optional\n       Bragg rule correction. Usually no correction needed for heavy\n       elements. Default 1.0 implies 100% of value (no change). 1.1\n       will increase by 10%.\n\n    Notes\n    -----\n        This class should never explicitely created. Instead set as\n        kwargs in :class:`srim.srim.SR`\n    """"""\n    def __init__(self, **args):\n        self._settings = {\n            \'energy_min\': check_input(float, is_positive, args.get(\'energy_min\', 1.0E3)),\n            \'output_type\': check_input(int, is_one_to_eight, args.get(\'output_type\', 1)),\n            \'output_filename\': args.get(\'output_filename\', \'SR_OUTPUT.txt\'),\n            \'correction\': check_input(float, is_positive, args.get(\'correction\', 1.0))\n        }\n\n    def __getattr__(self, attr):\n        return self._settings[attr]\n\n\nclass SR(object):\n    """""" Automate SR Calculations\n\n    Parameters\n    ----------\n    leyer : :class:`srim.core.layer.Layer`\n        constructed layer for SR calculation\n    ion : :class:`srim.core.ion.Ion`\n        constructed ion for SR calculation\n    kwargs :\n        See :class:`srim.srim.SRSettings` for available SR\n        options. There are a few and none are required. Defaults are\n        appropriate for most cases.\n    """"""\n    def __init__(self, layer, ion, **kwargs):\n        self.settings = SRSettings(**kwargs)\n        self.layer = layer\n        self.ion = ion\n\n    def _write_input_file(self):\n        """""" Write necissary SR input file for calculation """"""\n        SRInput(self).write()\n\n    def run(self, srim_directory=DEFAULT_SRIM_DIRECTORY):\n        """"""Run configured srim calculation\n\n        This method:\n         - writes the input file to ``<srim_directory/SR Module/TRIM.IN``\n         - launches ``<srim_directory>/SR Module/SRModule.exe``. Uses ``wine`` if available (needed for linux and osx)\n\n        Parameters\n        ----------\n        srim_directory : :obj:`str`, optional\n            path to srim directory. ``SRIM.exe`` should be located in\n            this directory. Default ``/tmp/srim`` will absolutely need\n            to be changed for windows.\n        """"""\n        current_directory = os.getcwd()\n        try:\n            os.chdir(os.path.join(srim_directory, \'SR Module\'))\n            self._write_input_file()\n            # Make sure compatible with Windows, OSX, and Linux\n            # If \'wine\' command exists use it to launch TRIM\n            if distutils.spawn.find_executable(""wine""):\n                subprocess.check_call([\'wine\', str(os.path.join(\'.\', \'SRModule.exe\'))])\n            else:\n                subprocess.check_call([str(os.path.join(\'.\', \'SRModule.exe\'))])\n\n            return SRResults(os.path.join(srim_directory, \'SR Module\'))\n        finally:\n            os.chdir(current_directory)\n'"
tests/test_integration.py,0,"b'"""""" Integration Testing for pysrim\n\n""""""\n\nimport pytest\n\nfrom srim.core.target import Target\nfrom srim.core.layer import Layer\nfrom srim.core.element import Element\n'"
tests/test_output.py,0,"b'import os\n\nimport pytest\n\nfrom srim.output import (\n    Ioniz, NoVacancy, Vacancy, EnergyToRecoils, Phonons, Range,\n    Results, SRResults\n)\n\nTESTDATA_DIRECTORY = \'test_files\'\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3""), (""4"")])\ndef test_ioniz_init(directory):\n    ion = Ioniz(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert ion.depth.shape == (100,)\n    assert ion.ions.shape == (100,)\n    assert ion.recoils.shape == (100,)\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3""), (""4"")])\ndef test_phonons_init(directory):\n    phonons = Phonons(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert phonons.depth.shape == (100,)\n    assert phonons.ions.shape == (100,)\n    assert phonons.recoils.shape == (100,)\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3""), (""4"")])\ndef test_vacancy_init(directory):\n    vac = Vacancy(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert vac.depth.shape == (100,)\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3""), (""4"")])\ndef test_range_init(directory):\n    range = Range(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert range.depth.shape == (100,)\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3"")])\ndef test_novacancy_init_full_calculation(directory):\n    novac = NoVacancy(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert novac.depth.shape == (100,)\n    assert novac.number.shape == (100,)\n\n\ndef test_novacancy_init_kp_calculation():\n    with pytest.raises(ValueError) as excinfo:\n        NoVacancy(os.path.join(TESTDATA_DIRECTORY, \'4\'))\n    assert excinfo.value.args[0] == \'NOVAC has no data for KP calculations\'\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3""), (""4"")])\ndef test_energytorecoils_init(directory):\n    etorec = EnergyToRecoils(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert etorec.depth.shape == (100,)\n\n\n@pytest.mark.parametrize(""directory"", [(""1""), (""2""), (""3"")])\ndef test_results_init_full(directory):\n    results = Results(os.path.join(TESTDATA_DIRECTORY, directory))\n    assert isinstance(results.ioniz, Ioniz)\n    assert isinstance(results.vacancy, Vacancy)\n    assert isinstance(results.novac, NoVacancy)\n    assert isinstance(results.etorecoils, EnergyToRecoils)\n    assert isinstance(results.phonons, Phonons)\n    assert isinstance(results.range, Range)\n\n\ndef test_resuls_init_kp_calculation():\n    results = Results(os.path.join(TESTDATA_DIRECTORY, \'4\'))\n    assert isinstance(results.ioniz, Ioniz)\n    assert isinstance(results.vacancy, Vacancy)\n    assert results.novac == None\n    assert isinstance(results.etorecoils, EnergyToRecoils)\n    assert isinstance(results.phonons, Phonons)\n    assert isinstance(results.range, Range)\n\ndef test_results_srim_calcluation():\n    results = SRResults(os.path.join(TESTDATA_DIRECTORY, \'SRIM\'))\n    assert results.ion == {\'A1\': 131.293, \'Z1\': 54, \'name\': \'Xenon\'}\n    assert results.data.shape == (6, 159)\n    assert results.units == ""MeV/(mg/cm2)""\n    assert results.target == {\n        \'density atoms/cm3\': 9.6421e+22,\n        \'density g/cm3\': 3.21,\n        \'target composition\': {\n            \'C\': [6, 50.0, 29.95],\n            \'Si\': [14, 50.0, 70.05]\n        }\n    }\n'"
tests/test_srim.py,0,"b""from srim.srim import TRIM, SR\nfrom srim.core.target import Target\nfrom srim.core.layer import Layer\nfrom srim.core.ion import Ion\n\nTESTDATA_DIRECTORY = 'test_files'\n\ndef test_simple_trim_init():\n    ion = Ion('Ni', 1.0e6)\n\n    layer = Layer.from_formula('Ni', 8.9, 1000.0)\n    target = Target([layer])\n\n    trim = TRIM(target, ion)\n\n\ndef test_simple_srim_init():\n    # Construct a Nickel ion\n    ion = Ion('Xe', energy=1.2e9)\n\n    # Construct a layer of nick 20um thick with a displacement energy of 30 eV\n    layer = Layer({\n        'Si': {\n            'stoich': 0.5,\n            'E_d': 35.0, # Displacement Energy\n            'lattice': 0.0,\n            'surface': 3.0\n        },\n        'C': {\n            'stoich': 0.5,\n            'E_d': 20.0, # Displacement Energy\n            'lattice': 0.0,\n            'surface': 3.0\n        }\n    }, density=3.21, width=10000.0)\n\n    target = Target([layer])\n\n    srim = SR(layer, ion, output_type=5)\n\n    # resulting file should be equal to\n    # test_files/SRIM/SR_OUTPUT.txt\n"""
examples/docker/ni.py,0,"b""import os\n\nfrom srim import Ion, Layer, Target, TRIM\n\n# Construct a 3MeV Nickel ion\nion = Ion('Ni', energy=3.0e6)\n\n# Construct a layer of nick 20um thick with a displacement energy of 30 eV\nlayer = Layer({\n        'Ni': {\n            'stoich': 0.5,\n            'E_d': 30.0,\n            'lattice': 0.0,\n            'surface': 3.0\n        }, 'Au': {'stoich': 0.5, 'E_d': 25.0, 'lattice': 0.0, 'surface': 3.0}}, density=8.9, width=20000.0)\n\n# Construct a target of a single layer of Nickel\ntarget = Target([layer])\n\n# Initialize a TRIM calculation with given target and ion for 25 ions, quick calculation\ntrim = TRIM(target, ion, number_ions=100000, calculation=1)\n\n# Specify the directory of SRIM.exe\n# For windows users the path will include C://...\nsrim_executable_directory = '/tmp/srim'\n\n# takes about 10 seconds on my laptop\nresults = trim.run(srim_executable_directory)\n# If all went successfull you should have seen a TRIM window popup and run 25 ions!\n# results is `srim.output.Results` and contains all output files parsed\n\nos.makedirs('/tmp/output', exist_ok=True)\nTRIM.copy_output_files('/tmp/srim', '/tmp/output')\n"""
srim/core/__init__.py,0,b'from .element import Element\nfrom .elementdb import ElementDB\nfrom .material import Material\nfrom .ion import Ion\nfrom .layer import Layer\nfrom .target import Target\n'
srim/core/element.py,0,"b'from .elementdb import ElementDB\n\nclass Element(object):\n    """""" Element from periodic table\n\n    Parameters\n    ----------\n    identifier : :obj:`str`, :obj:`int`\n        Symbol, Name, or Atomic Number of element\n    mass : :obj:`float`, optional\n        Mass [amu] of element. Default is most common isotope atomic\n        weight\n\n    Examples\n    --------\n    Constructing a Helium Atom.\n\n    >>> Element(\'He\')\n    <Element symbol:He name:Helium mass:4.00>\n\n    >>> Element(\'Helium\')\n    <Element symbol:He name:Helium mass:4.00>\n\n    >>> Element(2)\n    <Element symbol:He name:Helium mass:4.00>\n\n    >>> Element(\'He\', 4.3)\n    <Element symbol:He name:Helium mass:4.30>\n    """"""\n    def __init__(self, identifier, mass=None):\n        """"""Initializes element from identifier and mass""""""\n        element = ElementDB.lookup(identifier)\n\n        self._symbol = element[\'symbol\']\n        self._name = element[\'name\']\n        self._atomic_number = element[\'z\']\n\n        if mass:\n            self._mass = mass\n        else:\n            self._mass = element[\'mass\']\n\n    def __eq__(self, element):\n        if (self.symbol == element.symbol and\n            self.name == element.name and\n            self.atomic_number == element.atomic_number and\n            self.mass == element.mass):\n            return True\n        return False\n\n    def __repr__(self):\n        return ""<Element symbol:{} name:{} mass:{:2.2f}>"".format(\n            self.symbol, self.name, self.mass)\n\n    def __hash__(self):\n        return sum(hash(item) for item in [\n            self._mass, self._symbol, self._name, self.atomic_number\n        ])\n\n    @property\n    def symbol(self):\n        """"""Element\'s atomic symbol""""""\n        return self._symbol\n\n    @property\n    def name(self):\n        """"""Element\'s formal name""""""\n        return self._name\n\n    @property\n    def atomic_number(self):\n        """"""Element\'s atomic number""""""\n        return self._atomic_number\n\n    @property\n    def mass(self):\n        """"""Element\'s mass""""""\n        return self._mass\n'"
srim/core/elementdb.py,0,"b'import yaml\nimport os\nimport re\n\nimport srim\n\n\ndef create_elementdb():\n    dbpath = os.path.join(srim.__path__[0], \'data\', \'elements.yaml\')\n    return yaml.load(open(dbpath, ""r""))\n\n\nclass ElementDB(object):\n    """"""Element database at ``srim.data.elements.yaml``""""""\n    _db = create_elementdb()\n\n    @classmethod\n    def lookup(cls, identifier):\n        """""" Looks up element from symbol, name, or atomic number\n\n        Parameters\n        ----------\n        identifier : :obj:`str`, :obj:`int`\n            Unique symbol, name, or atomic number of element\n\n        Notes\n        -----\n            This class is used for creation of elements, ions,\n            etc. but generally will not be needed by the user.\n        """"""\n        if isinstance(identifier, (bytes, str)):\n            if re.match(""^[A-Z][a-z]?$"", identifier):   # Symbol\n                return cls._lookup_symbol(identifier)\n            elif re.match(""^[A-Z][a-z]*$"", identifier): # Name\n                return cls._lookup_name(identifier)\n        elif isinstance(identifier, int):               # Atomic Number\n            return cls._lookup_atomic_number(identifier)\n        raise ValueError(\'identifier of type:{} value:{} not value see doc\'.format(\n            type(identifier), identifier))\n\n    @classmethod\n    def _lookup_symbol(cls, symbol):\n        """""" Looks up symbol in element database\n\n        :param str symbol: Symbol of atomic element\n        """"""\n        return cls._db[symbol]\n\n    @classmethod\n    def _lookup_name(cls, name):\n        """""" Looks element in database by name\n\n        :param str name: (Full) Name of atomic element (British spelling)\n        """"""\n        for symbol in cls._db:\n            if cls._db[symbol][\'name\'] == name:\n                return cls._db[symbol]\n        raise KeyError(\'name:{} does not exist\'.format(name))\n\n    @classmethod\n    def _lookup_atomic_number(cls, atomic_number):\n        """""" Look up element in database by atomic number (Z)\n\n        :param int atomic_number: Atomic number of atomic element\n        """"""\n        for symbol in cls._db:\n            if cls._db[symbol][\'z\'] == atomic_number:\n                return cls._db[symbol]\n        raise IndexError(\'atomic number:{} does not exist\'.format(atomic_number))\n'"
srim/core/ion.py,0,"b'from math import sqrt\n\nfrom . import units\nfrom .element import Element\n\nclass Ion(Element):\n    """""" Representation of ion traveling through medium\n\n    Similar to :class:`srim.core.element.Element` but associates an\n    energy with the element.\n\n    Parameters\n    ----------\n    identifier : :obj:`str`, :obj:`int`\n        Symbol, Name, or Atomic Number of ion\n    energy : :obj:`float`\n        Energy [eV] of ion\n    mass : :obj:`float`, optional\n        Mass [amu] of element. Default is most common isotope atomic\n        weight\n\n    Examples\n    --------\n    Constructing a Helium Ion.\n\n    >>> Ion(\'He\', 1e6)\n    ""<Ion element:He mass:4.00 energy:1.00e6 eV>""\n\n    >>> Ion(\'He\', energy=1e6, mass=4.2)\n    ""<Ion element:He mass:4.20 energy:1.00e6 eV>""\n    """"""\n    def __init__(self, identifier, energy, mass=None):\n        """"""Initialize Ion""""""\n        if energy <= 0.0:\n            raise ValueError(\'energy {} cannot be 0.0 or less\'.format(energy))\n\n        self._energy = energy\n        super(Ion, self).__init__(identifier, mass)\n\n    def __repr__(self):\n        return ""<Ion element:{} mass:{:2.2f} energy:{:1.2E} eV>"".format(\n            self.name, self.mass, self.energy)\n\n    @property\n    def energy(self):\n        """"""Ion\'s energy [eV]""""""\n        return self._energy\n\n    @property\n    def velocity(self):\n        """"""Ion\'s velocity [m/s]""""""\n        return sqrt(2 * (self.energy * units.eV) / (self.mass * units.amu))\n'"
srim/core/layer.py,0,"b'from .material import Material\nfrom .utils import check_input, is_positive\n\nclass Layer(Material):\n    """""" Represents a layer in target\n\n    Parameters\n    ----------\n    elements : :obj:`dict`\n        dictionary of elements (:class:`srim.core.elements.Element`, :obj:`str`, or :obj:`int`) with properties\n         - ``stoich``  (float, int, required): Stoichiometry of element (fraction)\n         - ``E_d``     (float, int, optional): Displacement energy [eV] default 25.0 eV\n         - ``lattice`` (float, int, optional): Lattice binding energies [eV] default 0.0 eV\n         - ``surface`` (float, int, optional): Surface binding energies [eV] default 3.0 eV\n    density : :obj:`float`\n       density [g/cm^3] of material\n    width : :obj:`float`\n       width [Angstroms] of layer\n    phase : :obj:`int`\n       phase of material (solid = 0, gas = 1). Default solid (0).\n    name : :obj:`str:, optional\n       name of the Layer (defaults to chemical_formula)\n\n    Examples\n    --------\n    Construct a layer of SiC with experimental values.\n\n    >>> Layer({\n        \'Si\': {\n           \'stoich\': 0.5,\n           \'E_d\': 35.0, # Displacement Energy [eV]\n           \'lattice\': 0.0,\n           \'surface\': 3.0\n        },\n        \'C\': {\n           \'stoich\': 0.5,\n           \'E_d\': 20.0, # Displacement Energy [eV]\n           \'lattice\': 0.0,\n           \'surface\': 3.0\n    }, density=3.21, width=10000.0)\n    """"""\n    def __init__(self, elements, density, width, phase=0, name=None):\n        """"""Creation of Layer from elements, density, width, phase, and\nname""""""\n        self.width = width\n        self.name = name\n        super(Layer, self).__init__(elements, density, phase)\n\n    @classmethod\n    def from_formula(cls, chemical_formula, density, width, phase=0, name=None):\n        """""" Creation Layer from chemical formula string, density, width, phase, and name\n\n        Parameters\n        ----------\n        chemical_formula : str\n            see :meth:`srim.core.material.Material.from_formula` for\n            allowed formulas. Quite flexible.\n        density : :obj:`float`\n            density [g/cm^3] of material\n        width : :obj:`float`\n            width [Angstroms] of layer\n        phase : :obj:`int`\n            phase of material (solid = 0, gas = 1). Default solid (0).\n        name : :obj:`str:, optional\n            name of the Layer (defaults to chemical_formula)\n\n        Notes\n        -----\n            This method is not used as much since you do not have an\n            easy way to set the displacement energy.\n        """"""\n        elements = cls._formula_to_elements(chemical_formula)\n        return Layer(elements, density, width, phase, name)\n\n    @property\n    def width(self):\n        """"""Layer\'s width""""""\n        return self._width\n\n    @width.setter\n    def width(self, value):\n        self._width = check_input(float, is_positive, value)\n\n    @property\n    def name(self):\n        """"""Layer\'s Name""""""\n        if self._name:\n            return self._name\n        return self.chemical_formula\n\n    @name.setter\n    def name(self, value):\n        self._name = str(value)\n\n    def __repr__(self):\n        return ""<Layer material:{} width:{}>"".format(self.chemical_formula, self.width)\n'"
srim/core/material.py,0,"b'import re\n\nfrom .utils import (\n    check_input,\n    is_positive, is_greater_than_zero,\n    is_zero_or_one\n)\nfrom .element import Element\n\nclass Material(object):\n    """""" Material Representation """"""\n    def __init__(self, elements, density, phase=0):\n        """"""Create Material from elements, density, and phase\n\n        Parameters\n        ----------\n        elements : :obj:`dict`\n             dictionary of elements (:class:`srim.core.elements.Element`, :obj:`str`, or :obj:`int`) with properties\n               - ``stoich``  (float, int, required): Stoichiometry of element (fraction)\n               - ``E_d``     (float, int, optional): Displacement energy [eV] default 25.0 eV\n               - ``lattice`` (float, int, optional): Lattice binding energies [eV] default 0.0 eV\n               - ``surface`` (float, int, optional): Surface binding energies [eV] default 3.0 eV\n        density : :obj:`float`\n             density [g/cm^3] of material\n        phase : :obj:`int`\n             phase of material (solid = 0, gas = 1). Default solid (0).\n\n\n        Notes\n        -----\n        This class is more featureful that `srim.core.layer.Layer`\n        would lead you to believe. In general this class will not be\n        called by the user.\n\n        Structure of dictionary elements properties:\n         - stoich  (required): Stoichiometry of element (fraction)\n         - E_d     (optional): Displacement energy [eV] default 25.0 eV\n         - lattice (optional): Lattice binding energies [eV] default 0.0 eV\n         - surface (optional): Surface binding energies [eV] default 3.0 eV\n\n        dictionary element properties can be:\n\n        float or int: stoich\n          all others take default values for now\n\n        dictionary:\n          {\'stoich\', \'E_d\', \'lattice\', \'surface\'}\n          stoich is required all others are optional\n\n        elements list structure:\n          [stoich, E_d, lattice, surface]\n          first element is required all others optional\n\n        For example a single element in elements can be specified as:\n          - {\'Cu\': 1.0}\n          - {Element(\'Cu\'): 1.0}\n          - {Element(\'Cu\'): [1.0, 25.0]}\n          - {\'Cu\': {\'stoich\': 1.0}}\n          - {Element(\'Cu\'): {\'stoich\': 1.0, \'E_d\': 25.0, \'lattice\': 0.0, \'surface\': 3.0}\n\n        All stoichiometries will be normalized to 1.0\n\n        Eventually the materials will have better defaults that come\n        from databases.\n        """"""\n        self.phase = phase\n        self.density = density\n        self.elements = {}\n\n        stoich_sum = 0.0\n        for element in elements:\n            values = elements[element]\n\n            if isinstance(values, dict):\n                stoich = values[\'stoich\']\n                e_disp = values.get(\'E_d\', 25.0)\n                lattice = values.get(\'lattice\', 0.0)\n                surface = values.get(\'surface\', 3.0)\n            elif isinstance(values, list):\n                default_values = [0.0, 25.0, 0.0, 3.0]\n                if len(values) == 0 or len(values) > 4:\n                    raise ValueError(\'list must be 0 < length < 5\')\n                values = values + default_values[len(values):]\n                stoich, e_disp, lattice, surface = values\n            elif isinstance(values, (int, float)):\n                stoich = values\n                e_disp = 25.0\n                lattice = 0.0\n                surface = 3.0\n            else:\n                raise ValueError(\'elements must be of type int, float, list, or dict\')\n\n            # Check input\n            stoich = check_input(float, is_greater_than_zero, stoich)\n            e_disp = check_input(float, is_positive, e_disp)\n            lattice = check_input(float, is_positive, lattice)\n            surface = check_input(float, is_positive, surface)\n\n            stoich_sum += stoich\n\n            if not isinstance(element, Element):\n                element = Element(element)\n\n            self.elements.update({element: {\n                \'stoich\': stoich, \'E_d\': e_disp,\n                \'lattice\': lattice, \'surface\': surface\n            }})\n\n        # Normalize the Chemical Composisiton to 1.0\n        for element in self.elements:\n            self.elements[element][\'stoich\'] /= stoich_sum\n\n\n    @classmethod\n    def from_formula(cls, chemical_formula, density, phase=0):\n        """""" Creation Material from chemical formula string and density\n\n        Parameters\n        ----------\n        chemical_formula : :obj:`str`\n            chemical formula string in specific format\n        density : :obj:`float`\n            density [g/cm^3] of material\n        phase : :obj:`int`, optional\n            phase of material (solid = 0, gas = 1). Default solid (0).\n\n        Notes\n        -----\n        Examples of chemical_formula that can be used:\n         - SiC\n         - CO2\n         - AuFe1.5\n         - Al10.0Fe90.0\n\n        Chemical Formula will be normalized to 1.0\n        """"""\n        elements = cls._formula_to_elements(chemical_formula)\n        return Material(elements, density, phase)\n\n    @staticmethod\n    def _formula_to_elements(chemical_formula):\n        """""" Convert chemical formula to elements """"""\n        single_element = \'([A-Z][a-z]?)([0-9]*(?:\\.[0-9]*)?)?\'\n        elements = {}\n\n        if re.match(\'^(?:{})+$\'.format(single_element), chemical_formula):\n            matches = re.findall(single_element, chemical_formula)\n        else:\n            error_str = \'chemical formula string {} does not match regex\'\n            raise ValueError(error_str.format(chemical_formula))\n\n        # Check for errors in stoichiometry\n        for symbol, fraction in matches:\n            element = Element(symbol)\n\n            if element in elements:\n                error_str = \'cannot have duplicate elements {} in stoichiometry\'\n                raise ValueError(error_str.format(element.symbol))\n\n            if fraction == \'\':\n                fraction = 1.0\n\n            elements.update({element: float(fraction)})\n        return elements\n\n    @property\n    def density(self):\n        """"""Material\'s density""""""\n        return self._density\n\n    @density.setter\n    def density(self, value):\n        self._density = check_input(float, is_positive, value)\n\n    @property\n    def phase(self):\n        """"""Material\'s phase""""""\n        return self._phase\n\n    @phase.setter\n    def phase(self, value):\n        self._phase = check_input(int, is_zero_or_one, value)\n\n    @property\n    def chemical_formula(self):\n        """"""Material\'s chemical formula""""""\n        return \' \'.join(\'{} {:1.2f}\'.format(element.symbol, self.elements[element][\'stoich\']) for element in self.elements)\n\n    def __repr__(self):\n        material_str = ""<Material formula:{} density:{:2.3f}>""\n        return material_str.format(self.chemical_formula, self.density)\n\n    def __eq__(self, material):\n        if abs(self.density - material.density) > 1e-6:\n            return False\n\n        if len(self.elements) != len(material.elements):\n            return False\n\n        for element in self.elements:\n            if not element in material.elements:\n                return False\n            for prop in self.elements[element]:\n                if abs(self.elements[element][prop] - material.elements[element][prop]) > 1e-6:\n                    return False\n        return True\n'"
srim/core/target.py,0,"b'class Target(object):\n    """""" Target that Ion Impacts\n\n    Parameters\n    ----------\n    layers : list\n        list of :class:`srim.core.layer.Layer` to construct Target\n\n    Examples\n    --------\n    Lets construct a SiC target. While only one layer is shown an\n    arbitrary number of them can be used.\n\n    >>> Target([Layer({\n        \'Si\': {\n           \'stoich\': 0.5,\n           \'E_d\': 35.0, # Displacement Energy [eV]\n           \'lattice\': 0.0,\n           \'surface\': 3.0\n        },\n        \'C\': {\n           \'stoich\': 0.5,\n           \'E_d\': 20.0, # Displacement Energy [eV]\n           \'lattice\': 0.0,\n           \'surface\': 3.0\n    }, density=3.21, width=10000.0)])\n    """"""\n    def __init__(self, layers):\n        self.layers = layers\n\n    @property\n    def width(self):\n        """"""total width of target (sum of layers)""""""\n        return sum(layer.width for layer in self.layers)\n'"
srim/core/units.py,0,"b'"""""" Units module to convert some SI units to SRIM units\n\n - ``eV <-> J/eV``\n - ``amu <-> kg/amu``\n""""""\n\neV = 1.60218E-19                # J/eV\namu = 1.66054e-27               # kg/amu\n'"
srim/core/utils.py,0,"b'""""""Utility functions that are used to construct Target and Ion\n\n""""""\n\ndef check_input(input_type, condition, value):\n    value = input_type(value)\n    if not condition(value):\n        raise ValueError(\'type of argument does not satisfy condition\')\n    return value\n\nis_zero = lambda value: True if value == 0 else False\nis_zero_or_one = lambda value: True if value in range(2) else False\nis_zero_to_two = lambda value: True if value in range(3) else False\nis_zero_to_five = lambda value: True if value in range(6) else False\nis_one_to_seven = lambda value: True if value in range(1,8) else False\nis_one_to_eight = lambda value: True if value in range(1,9) else False\nis_srim_degrees = lambda value: True if 0.0 <= value < 90.0 else False\nis_positive = lambda value: True if value >= 0.0 else False\nis_greater_than_zero = lambda value: True if value > 0.0 else False\nis_quoteless = lambda value: True if \'""\' not in value else False\n'"
tests/core/test_element.py,0,"b""import pytest\n\nfrom srim.core.element import Element\n\n# Element Initialization\ndef test_init_mass_default():\n    element = Element('Au')\n    assert abs(element.mass - 196.966995239) < 1e-8\n\ndef test_init_set_mass():\n    element = Element('Au', 1.0)\n    assert element.mass == 1.0\n\ndef test_init_symbol():\n    element = Element('Au')\n    assert element.symbol == 'Au'\n    assert element.name == 'Gold'\n    assert element.atomic_number == 79\n    assert abs(element.mass - 196.966995239) < 1e-8\n\ndef test_init_name():\n    element = Element('Gold')\n    assert element.symbol == 'Au'\n    assert element.name == 'Gold'\n    assert element.atomic_number == 79\n    assert abs(element.mass - 196.966995239) < 1e-8\n\ndef test_init_atomic_number():\n    element = Element(79)\n    assert element.symbol == 'Au'\n    assert element.name == 'Gold'\n    assert element.atomic_number == 79\n    assert abs(element.mass - 196.966995239) < 1e-8\n\n\n# Element equality\ndef test_equality_eqaul():\n    element1 = Element('Au', 2.0)\n    element2 = Element('Au', 2.0)\n    assert element1 == element2\n\ndef test_equality_not_equal():\n    element1 = Element('H')\n    element2 = Element('Au')\n    assert element1 != element2\n"""
tests/core/test_elementdb.py,0,"b""import pytest\n\nfrom srim.core.elementdb import ElementDB\n\n# ElementDB size\ndef test_db_size():\n    assert len(ElementDB._db) == 112\n\n\n# ElementDB Lookups\ndef test_lookup_symbol():\n    element = ElementDB._lookup_symbol('Fe')\n    assert element['symbol'] == 'Fe'\n    assert element['name'] == 'Iron'\n\n\ndef test_lookup_invalid_symbol():\n    with pytest.raises(KeyError):\n        ElementDB._lookup_symbol('Zx')\n\n\ndef test_lookup_name():\n    element = ElementDB._lookup_name('Aluminium')\n    assert element['symbol'] == 'Al'\n    assert element['name'] == 'Aluminium'\n\n\ndef test_lookup_invalid_name():\n    with pytest.raises(KeyError):\n        ElementDB._lookup_name('Macium') # My gf's name\n\n\ndef test_lookup_atomic_number():\n    element = ElementDB._lookup_atomic_number(100)\n    assert element['symbol'] == 'Fm'\n    assert element['name'] == 'Fermium'\n\n\ndef test_lookup_invalid_atomic_number_negative():\n    with pytest.raises(IndexError):\n        ElementDB._lookup_atomic_number(-1)\n\n\ndef test_lookup_invalid_atomic_number_large():\n    with pytest.raises(IndexError):\n        ElementDB._lookup_atomic_number(130)\n\n\n# Test lookup correct function\ndef test_lookup_call_symbol(mocker):\n    mocker.patch('srim.core.elementdb.ElementDB._lookup_symbol')\n    ElementDB.lookup('Au')\n    ElementDB._lookup_symbol.assert_called_once_with('Au')\n\n\ndef test_lookup_call_name(mocker):\n    mocker.patch('srim.core.elementdb.ElementDB._lookup_name')\n    ElementDB.lookup('Gold')\n    ElementDB._lookup_name.assert_called_once_with('Gold')\n\n\ndef test_lookup_call_atomic_number(mocker):\n    mocker.patch('srim.core.elementdb.ElementDB._lookup_atomic_number')\n    ElementDB.lookup(100)\n    ElementDB._lookup_atomic_number.assert_called_once_with(100)\n"""
tests/core/test_ion.py,0,"b""import pytest\n\nfrom srim.core.ion import Ion\n\n# Test Ion Init\ndef test_init_symbol():\n    ion = Ion('Au', 1.0)\n    assert ion.symbol == 'Au'\n    assert ion.name == 'Gold'\n    assert ion.atomic_number == 79\n    assert ion.energy == 1.0\n\n\ndef test_init_name():\n    ion = Ion('Gold', 1.0)\n    assert ion.symbol == 'Au'\n    assert ion.name == 'Gold'\n    assert ion.atomic_number == 79\n    assert ion.energy == 1.0\n\n\ndef test_init_atomic_number():\n    ion = Ion(79, 1.0)\n    assert ion.symbol == 'Au'\n    assert ion.name == 'Gold'\n    assert ion.atomic_number == 79\n    assert ion.energy == 1.0\n\n\ndef test_init_invalid_energy_zero():\n    with pytest.raises(ValueError):\n        Ion('Au', 0.0)\n\n\ndef test_init_invalid_energy_negative():\n    with pytest.raises(ValueError):\n        Ion('Au', -1.0)\n\n\n# Test Ion Velocity\ndef test_ion_velocity():\n    ion = Ion('Au', 1.0)                                # Energy [eV]\n    assert abs(ion.velocity - 989.8041041365332) < 1e-6 # Velocity [m/s]\n"""
tests/core/test_layer.py,0,"b""import pytest\n\nfrom srim.core.layer import Layer\nfrom srim.core.element import Element\n\n\ndef test_layer_init_simple():\n    layer = Layer.from_formula('Ni99Fe1', density=1.0, width=1.0, phase=0, name='layer 1')\n    assert layer.name == 'layer 1'\n    assert layer.density == 1.0\n    assert layer.width == 1.0\n    assert layer.phase == 0\n    assert len(layer.elements) == 2\n    assert Element('Ni') in layer.elements\n    assert Element('Fe') in layer.elements\n\n"""
tests/core/test_material.py,0,"b'import pytest\n\nfrom srim.core.element import Element\nfrom srim.core.material import Material\n\n\n# Material Init\n@pytest.mark.parametrize(""elements, check"", [\n    ({Element(\'Au\'): 1.0}, (1.0, 25.0, 0.0, 3.0)),\n    ({\'Au\': 1.0}, (1.0, 25.0, 0.0, 3.0)),\n    ({Element(\'Au\'): [1.0]}, (1.0, 25.0, 0.0, 3.0)),\n    ({\'Au\': [1.0]}, (1.0, 25.0, 0.0, 3.0)),\n    ({\'Au\': [1.0, 30.0, 1.0, 1.0]}, (1.0, 30.0, 1.0, 1.0)),\n    ({Element(\'Au\'): {\'stoich\': 1.0}}, (1.0, 25.0, 0.0, 3.0)),\n    ({\'Au\': {\'stoich\': 1.0}}, (1.0, 25.0, 0.0, 3.0)),\n    ({\'Au\': {\'stoich\': 1.0, \'E_d\': 30.0, \'lattice\': 1.0, \'surface\': 1.0}}, (1.0, 30.0, 1.0, 1.0))\n])\ndef test_init_simple_prenormalized(elements, check):\n    element = Element(\'Au\')\n    material = Material(elements, 1.0)\n    \n    assert len(material.elements) == 1\n    assert element in material.elements\n    assert abs(material.elements[element][\'stoich\'] - check[0]) < 1e-6\n    assert abs(material.elements[element][\'E_d\'] - check[1]) < 1e-6\n    assert abs(material.elements[element][\'lattice\'] - check[2]) < 1e-6\n    assert abs(material.elements[element][\'surface\'] - check[3]) < 1e-6\n    assert material.density == 1.0\n\ndef test_init_single_normalize():\n    element = Element(\'Au\')\n    material = Material({element: 2.0}, 1.0)\n\n    assert len(material.elements) == 1\n    assert element in material.elements\n    assert abs(material.elements[element][\'stoich\'] - 1.0) < 1e-6\n    assert abs(material.elements[element][\'E_d\'] - 25.0) < 1e-6\n    assert abs(material.elements[element][\'lattice\'] - 0.0) < 1e-6\n    assert abs(material.elements[element][\'surface\'] - 3.0) < 1e-6\n    assert material.density == 1.0\n\n\ndef test_init_single_invalid_stoich_zero():\n    with pytest.raises(ValueError):\n        Material({\'Au\': 0.0}, 1.0)\n\n\ndef test_init_single_invalid_frac_negative():\n    with pytest.raises(ValueError):\n        Material({\'Au\': -0.1}, 1.0)\n\n\ndef test_init_multiple():\n    element1 = Element(\'Au\')\n    element2 = Element(\'Fe\')\n    material = Material({element1: 0.5, element2: 0.5}, 1.0)\n\n    assert len(material.elements) == 2\n    assert element1 in material.elements\n    assert abs(material.elements[element1][\'stoich\'] - 0.5) < 1e-6\n    assert element2 in material.elements\n    assert abs(material.elements[element2][\'stoich\'] - 0.5) < 1e-6\n    assert material.density == 1.0\n\n\ndef test_init_formula_FeAl():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material = Material.from_formula(\'Fe10.0Al90.0\', 1.0)\n\n    assert len(material.elements) == 2\n    assert element1 in material.elements\n    assert abs(material.elements[element1][\'stoich\'] - 0.1) < 1e-6\n    assert element2 in material.elements\n    assert abs(material.elements[element2][\'stoich\'] - 0.9) < 1e-6\n    assert material.density == 1.0\n\ndef test_init_formula_FeAl_floats():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material = Material.from_formula(\'Fe0.1Al.9\', 1.0)\n\n    assert len(material.elements) == 2\n    assert element1 in material.elements\n    assert abs(material.elements[element1][\'stoich\'] - 0.1) < 1e-6\n    assert element2 in material.elements\n    assert abs(material.elements[element2][\'stoich\'] - 0.9) < 1e-6\n    assert material.density == 1.0\n\n\ndef test_init_invalid_formula_SiSi():\n    with pytest.raises(ValueError):\n        Material.from_formula(\'SiSi\', 1.0)\n\n\n# Test equality material\ndef test_material_equality_equal():\n    material1 = Material.from_formula(\'Fe0.1Al0.9\', 1.0)\n    material2 = Material({Element(\'Fe\'): 0.1, Element(\'Al\'): 0.9}, 1.0)\n\n    assert material1 == material2\n\ndef test_material_equality_not_equal_density():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material1 = Material.from_formula(\'Fe0.1Al0.9\', 1.0)\n    material2 = Material({element1: 0.1, element2: 0.9}, 2.0)\n\n    assert material1 != material2\n\ndef test_material_equality_not_equal_stoich():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material1 = Material.from_formula(\'Fe0.2Al0.8\', 1.0)\n    material2 = Material({element1: 0.1, element2: 0.9}, 1.0)\n\n    assert material1 != material2\n\ndef test_material_equality_not_equal_elements():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material1 = Material.from_formula(\'Sn0.1Al0.9\', 1.0)\n    material2 = Material({element1: 0.1, element2: 0.9}, 1.0)\n\n    assert material1 != material2\n\n\ndef test_material_equality_not_equal_num_elements():\n    element1 = Element(\'Fe\')\n    element2 = Element(\'Al\')\n    material1 = Material.from_formula(\'Fe0.2Al0.8Au1.0\', 1.0)\n    material2 = Material({element1: 0.1, element2: 0.9}, 1.0)\n\n    assert material1 != material2\n    \n'"
tests/core/test_target.py,0,"b""import pytest\n\nfrom srim.core.target import Target\nfrom srim.core.layer import Layer\n\n\ndef test_init_simple():\n    layer1 = Layer.from_formula('Ni99Fe1', density=1.0, width=1.0)\n    layer2 = Layer.from_formula('Au', density=1.0, width=2.0)\n    target = Target([layer1, layer2])\n    assert target.width == 3.0\n"""
