file_path,api_count,code
setup.py,0,"b""import setuptools\n\nsetuptools.setup(\n    name='shared-ndarray',\n    version='1.1.1',\n    description='A pickleable wrapper for sharing NumPy ndarrays between processes using POSIX shared memory.',\n    long_description=open('README.rst').read(),\n    url='https://github.com/crowsonkb/shared_ndarray',\n    author='Katherine Crowson',\n    author_email='crowsonkb@gmail.com',\n    license='MIT',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 3',\n        'Topic :: Scientific/Engineering',\n    ],\n    keywords='numpy ndarray array shared memory shm',\n    packages=['shared_ndarray'],\n    install_requires=['numpy >= 1.11.3', 'posix_ipc >= 1.0.0'],\n)\n"""
shared_ndarray/__init__.py,0,"b'""""""A pickleable wrapper for sharing NumPy ndarrays between processes using POSIX shared memory.""""""\n\nimport posix_ipc\n\nfrom .shared_ndarray import SharedNDArray\n\nSharedNDArrayError = posix_ipc.Error\n\n__all__ = [\'SharedNDArray\', \'SharedNDArrayError\']\n\n__author__ = \'Katherine Crowson\'\n__copyright__ = \'Copyright 2017, Katherine Crowson\'\n__credits__ = [\'Katherine Crowson\']\n__license__ = \'MIT\'\n__maintainer__ = \'Katherine Crowson\'\n__email__ = \'crowsonkb@gmail.com\'\n'"
shared_ndarray/shared_ndarray.py,3,"b'""""""A pickleable wrapper for sharing NumPy ndarrays between processes using POSIX shared memory.""""""\n\nimport mmap\n\nimport numpy as np\nimport posix_ipc\n\n\nclass SharedNDArray:\n    """"""Creates a new SharedNDArray, a pickleable wrapper for sharing NumPy ndarrays between\n    processes using POSIX shared memory.\n\n    SharedNDArrays are designed to be sent over multiprocessing.Pipe and Queue without serializing\n    or transmitting the underlying ndarray or buffer. While the associated file descriptor is\n    closed when the SharedNDArray is garbage collected, the underlying buffer is not released when\n    the process ends: you must manually call the unlink() method from the last process to use it.\n\n    Attributes:\n        array: The wrapped NumPy ndarray, backed by POSIX shared memory.\n    """"""\n\n    def __init__(self, shape, dtype=np.float64, name=None):\n        """"""Creates a new SharedNDArray.\n\n        If name is left blank, a new POSIX shared memory segment is created using a random name.\n\n        Args:\n            shape: Shape of the wrapped ndarray.\n            dtype: Data type of the wrapped ndarray.\n            name: Optional; the filesystem path of the underlying POSIX shared memory.\n\n        Returns:\n            A new SharedNDArray of the given shape and dtype and backed by the given optional name.\n\n        Raises:\n            SharedNDArrayError: if an error occurs.\n        """"""\n        size = int(np.prod(shape)) * np.dtype(dtype).itemsize\n        if name:\n            self._shm = posix_ipc.SharedMemory(name)\n        else:\n            self._shm = posix_ipc.SharedMemory(None, posix_ipc.O_CREX, size=size)\n        self._buf = mmap.mmap(self._shm.fd, size)\n        self.array = np.ndarray(shape, dtype, self._buf, order=\'C\')\n\n    @classmethod\n    def copy(cls, arr):\n        """"""Creates a new SharedNDArray that is a copy of the given ndarray.\n\n        Args:\n            arr: The ndarray to copy.\n\n        Returns:\n            A new SharedNDArray object with the given ndarray\'s shape and data type and a copy of\n            its data.\n\n        Raises:\n            SharedNDArrayError: if an error occurs.\n        """"""\n        new_shm = cls.zeros_like(arr)\n        new_shm.array[:] = arr\n        return new_shm\n\n    @classmethod\n    def zeros_like(cls, arr):\n        """"""Creates a new zero-filled SharedNDArray with the shape and dtype of the given ndarray.\n\n        Raises:\n            SharedNDArrayError: if an error occurs.\n        """"""\n        return cls(arr.shape, arr.dtype)\n\n    def unlink(self):\n        """"""Marks the underlying shared for deletion.\n\n        This method should be called exactly once from one process. Failure to call it before all\n        processes exit will result in a memory leak! It will raise SharedNDArrayError if the\n        underlying shared memory was already marked for deletion from any process.\n\n        Raises:\n            SharedNDArrayError: if an error occurs.\n        """"""\n        self._shm.unlink()\n\n    def __del__(self):\n        self._buf.close()\n        self._shm.close_fd()\n\n    def __getstate__(self):\n        return self.array.shape, self.array.dtype, self._shm.name\n\n    def __setstate__(self, state):\n        self.__init__(*state)\n'"
shared_ndarray/test_shared_ndarray.py,2,"b""import multiprocessing as mp\nimport unittest\n\nimport numpy as np\n\nfrom . import SharedNDArray, SharedNDArrayError\n\n\nclass TestSharedNDArray(unittest.TestCase):\n    def test_create(self):\n        try:\n            shm = SharedNDArray(4)\n            shm.array[0] = 1\n\n            def write_to_shm(q):\n                shm = q.get()\n                shm.array += 1\n\n            q = mp.Queue()\n            p = mp.Process(target=write_to_shm, args=(q,))\n            p.start()\n            q.put(shm)\n            p.join()\n\n            self.assertEqual(shm.array[0], 2)\n        finally:\n            shm.unlink()\n\n    def test_unlink_twice(self):\n        shm = SharedNDArray(4)\n        shm.unlink()\n        with self.assertRaises(SharedNDArrayError):\n            shm.unlink()\n\n    def test_unlink_two_processes(self):\n        shm = SharedNDArray(4)\n        q = mp.Queue()\n        p = mp.Process(target=lambda q: q.get().unlink(), args=(q,))\n        p.start()\n        q.put(shm)\n        p.join()\n        with self.assertRaises(SharedNDArrayError):\n            shm.unlink()\n\n    def test_copy(self):\n        try:\n            arr = np.array(range(4))\n            shm = SharedNDArray.copy(arr)\n            self.assertEqual(arr.shape, shm.array.shape)\n            self.assertEqual(arr.dtype, shm.array.dtype)\n            self.assertTrue((arr == shm.array).all())\n        finally:\n            shm.unlink()\n\n    def test_zeros_like(self):\n        try:\n            arr = np.array(range(4))\n            shm = SharedNDArray.zeros_like(arr)\n            self.assertEqual(arr.shape, shm.array.shape)\n            self.assertEqual(arr.dtype, shm.array.dtype)\n            self.assertTrue((shm.array == 0).all())\n        finally:\n            shm.unlink()\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
