file_path,api_count,code
example.py,0,"b'def func1(param1, param2=\'default val\'):\n    \'\'\'Description of func with docstring javadoc style.\n\n    @param param1: descr of param\n    @type param1: type\n    @return: some value\n    @raise KeyError: raises a key exception\n\n    \'\'\'\n    pass\n\ndef func2(param1, param2=\'default val2\'):\n    \'\'\'Description of func with docstring reST style.\n\n    :param param1: descr of param\n    :type param1: type\n    :returns: some value\n    :raises keyError: raises exception\n\n    \'\'\'\n    pass\n\ndef func3(param1, param2=\'default val\'):\n    \'\'\'Description of func with docstring groups style.\n\n    Params: \n        param1 - descr of param\n\n    Returns:\n        some value\n\n    Raises:\n        keyError: raises key exception\n        TypeError: raises type exception\n\n    \'\'\'\n    pass\n\nclass SomeClass(object):\n    \'\'\'My class.\n    \'\'\'\n    def method(self, prm):\n        \'\'\'description\'\'\'\n        pass\n\n    def method2(self, prm1, prm2=\'defaultprm\'):\n        pass\n\n    def method_numpy(self):\n        """"""\n        My numpydoc description of a kind\n        of very exhautive numpydoc format docstring.\n\n        Parameters\n        ----------\n        first : array_like\n            the 1st param name `first`\n        second :\n            the 2nd param\n        third : {\'value\', \'other\'}, optional\n            the 3rd param, by default \'value\'\n\n        Returns\n        -------\n        string\n            a value in a string\n\n        Raises\n        ------\n        KeyError\n            when a key error\n        OtherError\n            when an other error\n\n        See Also\n        --------\n        a_func : linked (optional), with things to say\n                 on several lines\n        some blabla\n\n        Note\n        ----\n        Some informations.\n\n        Some maths also:\n        .. math:: f(x) = e^{- x}\n\n        References\n        ----------\n        Biblio with cited ref [1]_. The ref can be cited in Note section.\n\n        .. [1] Adel Daouzli, Sylvain Sa\xc3\xafghi, Michelle Rudolph, Alain Destexhe,\n           Sylvie Renaud: Convergence in an Adaptive Neural Network:\n           The Influence of Noise Inputs Correlation. IWANN (1) 2009: 140-148\n\n        Examples\n        --------\n        This is example of use\n        >>> print ""a""\n        a\n\n        """"""\n        pass\n'"
setup.py,0,"b'#!/usr/bin/env python\n\nfrom setuptools import setup\nfrom os import path\nimport pyment\n\n\ncurr_dir = path.abspath(path.dirname(__file__))\n\nwith open(path.join(curr_dir, ""README.rst"")) as f:\n    long_desc = f.read()\n\n\nsetup(name=\'Pyment\',\n      version=pyment.__version__,\n      description=\'Generate/convert automatically the docstrings from code signature\',\n      long_description=long_desc,\n      long_description_content_type=""text/x-rst"",\n      author=\'A. Daouzli\',\n      author_email=\'dadel@hadoly.fr\',\n      license=\'GPLv3\',\n      keywords=""pyment docstring numpydoc googledoc restructuredtext epydoc epytext javadoc development generate auto"",\n      platforms=[\'any\'],\n      classifiers=[\n          \'Intended Audience :: Developers\',\n          \'Topic :: Documentation\',\n          \'License :: OSI Approved :: GNU General Public License v3 (GPLv3)\',\n          \'Programming Language :: Python :: 2.7\',\n          \'Programming Language :: Python :: 3\',\n          \'Programming Language :: Python :: 3.2\',\n          \'Programming Language :: Python :: 3.3\',\n          \'Programming Language :: Python :: 3.4\',\n          \'Programming Language :: Python :: 3.5\',\n          \'Programming Language :: Python :: 3.6\'\n          ],\n      url=\'https://github.com/dadadel/pyment\',\n      packages=[\'pyment\'],\n      test_suite=\'tests.test_all\',\n      entry_points={\n        \'console_scripts\': [\n            \'pyment = pyment.pymentapp:main\'\n            ]\n        },\n      )\n'"
pyment/__init__.py,0,"b'from .pyment import PyComment, __version__, __copyright__, __author__, __licence__\n\nname = ""pyment""\n\n__all__ = [\'PyComment\', \'__version__\', \'__copyright__\', \'__author__\', \'__licence__\']\n'"
pyment/docstring.py,0,"b'# -*- coding: utf-8 -*-\n\nimport re\nfrom collections import defaultdict\n\n__author__ = ""A. Daouzli""\n__copyright__ = ""Copyright 2012-2018, A. Daouzli""\n__licence__ = ""GPL3""\n__version__ = ""0.3.3""\n__maintainer__ = ""A. Daouzli""\n\n""""""\nFormats supported at the time:\n - javadoc, reST (restructured text, Sphinx):\n managed  -> description, param, type, return, rtype, raise\n - google:\n managed  -> description, parameters, return, raises\n - numpydoc:\n managed  -> description, parameters, return (first of list only), raises\n\n""""""\n\nRAISES_NAME_REGEX = r\'^([\\w.]+)\'\n\n\ndef isin_alone(elems, line):\n    """"""Check if an element from a list is the only element of a string.\n\n    :type elems: list\n    :type line: str\n\n    """"""\n    found = False\n    for e in elems:\n        if line.strip().lower() == e.lower():\n            found = True\n            break\n    return found\n\n\ndef isin_start(elems, line):\n    """"""Check if an element from a list starts a string.\n\n    :type elems: list\n    :type line: str\n\n    """"""\n    found = False\n    elems = [elems] if type(elems) is not list else elems\n    for e in elems:\n        if line.lstrip().lower().startswith(e):\n            found = True\n            break\n    return found\n\n\ndef isin(elems, line):\n    """"""Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    """"""\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found\n\n\ndef get_leading_spaces(data):\n    """"""Get the leading space of a string if it is not empty\n\n    :type data: str\n\n    """"""\n    spaces = \'\'\n    m = re.match(r\'^(\\s*)\', data)\n    if m:\n        spaces = m.group(1)\n    return spaces\n\n\nclass DocToolsBase(object):\n    """"""\n\n    """"""\n\n    def __init__(self,\n                 first_line=None,\n                 optional_sections=None,\n                 excluded_sections=None,\n                 opt=None,\n                 section_headers=None,\n                 ):\n        """"""\n\n        :param first_line: indicate if description should start\n          on first or second line. By default it will follow global config.\n        :type first_line: boolean\n        :param optional_sections: list of sections that are not mandatory\n          if empty. See subclasses for further description.\n        :type optional_sections: list\n        :param excluded_sections: list of sections that are excluded,\n          even if mandatory. The list is the same as for optional sections.\n        :type excluded_sections: list\n        :param opt:\n        :type opt:\n        :param section_headers:\n        :type section_headers:\n        """"""\n        self.first_line = first_line\n        self.optional_sections = list(optional_sections)\n        self.excluded_sections = list(excluded_sections)\n        self.opt = opt\n        self.section_headers = section_headers\n\n    def __iter__(self):\n        return self.opt.__iter__()\n\n    def __getitem__(self, key):\n        return self.opt[key]\n\n    def get_optional_sections(self):\n        """"""Get optional sections""""""\n        return self.optional_sections\n\n    def get_excluded_sections(self):\n        """"""Get excluded sections""""""\n        return self.excluded_sections\n\n    def get_mandatory_sections(self):\n        """"""Get mandatory sections""""""\n        return [s for s in self.opt\n                if s not in self.optional_sections and\n                   s not in self.excluded_sections]\n\n    def _get_list_key(self, spaces, lines):\n        """""" Parse lines and extract the list of key elements.\n\n        :param spaces: leading spaces of starting line\n        :type spaces: str\n        :param lines: list of strings\n        :type lines: list(str)\n        :return: list of key elements\n        """"""\n        raise NotImplementedError\n\n    def get_list_key(self, data, key, header_lines=1):\n        """"""Get the list of a key elements.\n        Each element is a tuple (key=None, description, type=None).\n        Note that the tuple\'s element can differ depending on the key.\n\n        :param data: the data to proceed\n        :param key: the key\n\n        """"""\n        data = data.splitlines()\n        init = self.get_section_key_line(data, key)\n        if init == -1:\n            return []\n        start, end = self.get_next_section_lines(data[init:])\n        # get the spacing of line with key\n        spaces = get_leading_spaces(data[init + start])\n        start += init + header_lines\n        if end != -1:\n            end += init\n        else:\n            end = len(data)\n\n        return self._get_list_key(spaces, data[start:end])\n\n    def get_raise_list(self, data):\n        """"""Get the list of exceptions.\n        The list contains tuples (name, desc)\n\n        :param data: the data to proceed\n\n        """"""\n        return_list = []\n        lst = self.get_list_key(data, \'raise\')\n        for l in lst:\n            # assume raises are only a name and a description\n            name, desc, _ = l\n            return_list.append((name, desc))\n\n        return return_list\n\n    def get_return_list(self, data):\n        """"""Get the list of returned values.\n        The list contains tuples (name=None, desc, type=None)\n\n        :param data: the data to proceed\n\n        """"""\n        return_list = []\n        lst = self.get_list_key(data, \'return\')\n        for l in lst:\n            name, desc, rtype = l\n            if l[2] is None:\n                rtype = l[0]\n                name = None\n                desc = desc.strip()\n            return_list.append((name, desc, rtype))\n\n        return return_list\n\n    def get_param_list(self, data):\n        """"""Get the list of parameters.\n        The list contains tuples (name, desc, type=None)\n\n        :param data: the data to proceed\n\n        """"""\n        return self.get_list_key(data, \'param\')\n\n    def get_next_section_start_line(self, data):\n        """"""Get the starting line number of next section.\n        It will return -1 if no section was found.\n        The section is a section key (e.g. \'Parameters:\')\n        then the content\n\n        :param data: a list of strings containing the docstring\'s lines\n        :returns: the index of next section else -1\n        """"""\n        raise NotImplementedError\n\n    def get_next_section_lines(self, data):\n        """"""Get the starting line number and the ending line number of next section.\n        It will return (-1, -1) if no section was found.\n        The section is a section key (e.g. \'Parameters\') then the content\n        The ending line number is the line after the end of the section or -1 if\n        the section is at the end.\n\n        :param data: the data to proceed\n\n        """"""\n        end = -1\n        start = self.get_next_section_start_line(data)\n        if start != -1:\n            end = self.get_next_section_start_line(data[start + 1:])\n        return start, end\n\n    def get_key_section_header(self, key, spaces):\n        """"""Get the key of the section header\n\n        :param key: the key name\n        :param spaces: spaces to set at the beginning of the header\n\n        """"""\n        if key in self.section_headers:\n            header = self.section_headers[key]\n        else:\n            return \'\'\n\n        return header\n\n    def get_section_key_line(self, data, key, opt_extension=\'\'):\n        """"""Get the next section line for a given key.\n\n        :param data: the data to proceed\n        :param key: the key\n        :param opt_extension: an optional extension to delimit the opt value\n\n        """"""\n        start = 0\n        init = 0\n        while start != -1:\n            start = self.get_next_section_start_line(data[init:])\n            init += start\n            if start != -1:\n                if data[init].strip().lower() == self.opt[key] + opt_extension:\n                    break\n                init += 1\n        if start != -1:\n            start = init\n        return start\n\n\nclass NumpydocTools(DocToolsBase):\n    """""" """"""\n\n    def __init__(self,\n                 first_line=None,\n                 optional_sections=(\'raise\', \'also\', \'ref\', \'note\', \'other\', \'example\', \'method\', \'attr\'),\n                 excluded_sections=()):\n        \'\'\'\n        :param first_line: indicate if description should start\n          on first or second line. By default it will follow global config.\n        :type first_line: boolean\n        :param optional_sections: list of sections that are not mandatory\n          if empty. The accepted sections are:\n          -param\n          -return\n          -raise\n          -also\n          -ref\n          -note\n          -other\n          -example\n          -method\n          -attr\n        :type optional_sections: list\n        :param excluded_sections: list of sections that are excluded,\n          even if mandatory. The list is the same than for optional sections.\n        :type excluded_sections: list\n\n        \'\'\'\n        super(NumpydocTools, self).__init__(first_line=first_line,\n                                            optional_sections=optional_sections,\n                                            excluded_sections=excluded_sections,\n                                            opt={\n                                                \'also\': \'see also\',\n                                                \'attr\': \'attributes\',\n                                                \'example\': \'examples\',\n                                                \'method\': \'methods\',\n                                                \'note\': \'notes\',\n                                                \'other\': \'other parameters\',\n                                                \'param\': \'parameters\',\n                                                \'raise\': \'raises\',\n                                                \'ref\': \'references\',\n                                                \'return\': \'returns\',\n                                            },\n                                            section_headers={\n                                                \'param\': \'Parameters\',\n                                                \'return\': \'Returns\',\n                                                \'raise\': \'Raises\',\n                                            },\n                                            )\n\n        self.keywords = [\n            \':math:\',\n            \'.. math::\',\n            \'see also\',\n            \'.. image::\',\n        ]\n\n    def get_next_section_start_line(self, data):\n        """"""Get the starting line number of next section.\n        It will return -1 if no section was found.\n        The section is a section key (e.g. \'Parameters\') followed by underline\n        (made by -), then the content\n\n        :param data: a list of strings containing the docstring\'s lines\n        :type data: list(str)\n        :returns: the index of next section else -1\n\n        """"""\n        start = -1\n        for i, line in enumerate(data):\n            if start != -1:\n                # we found the key so check if this is the underline\n                if line.strip() and isin_alone([\'-\' * len(line.strip())], line):\n                    break\n                else:\n                    start = -1\n            if isin_alone(self.opt.values(), line):\n                start = i\n        return start\n\n    def get_list_key(self, data, key, header_lines=2):\n        """"""Get the list of a key elements.\n        Each element is a tuple (key=None, description, type=None).\n        Note that the tuple\'s element can differ depending on the key.\n\n        :param data: the data to proceed\n        :param key: the key\n\n        """"""\n        return super(NumpydocTools, self).get_list_key(data, key, header_lines=header_lines)\n\n    def _get_list_key(self, spaces, lines):\n        key_list = []\n        parse_key = False\n        key, desc, ptype = None, \'\', None\n\n        for line in lines:\n            if len(line.strip()) == 0:\n                continue\n            # on the same column of the key is the key\n            curr_spaces = get_leading_spaces(line)\n            if len(curr_spaces) == len(spaces):\n                if parse_key:\n                    key_list.append((key, desc, ptype))\n                elems = line.split(\':\', 1)\n                key = elems[0].strip()\n                ptype = elems[1].strip() if len(elems) > 1 else None\n                desc = \'\'\n                parse_key = True\n            else:\n                if len(curr_spaces) > len(spaces):\n                    line = line.replace(spaces, \'\', 1)\n                if desc:\n                    desc += \'\\n\'\n                desc += line\n        if parse_key:\n            key_list.append((key, desc, ptype))\n\n        return key_list\n\n    def get_attr_list(self, data):\n        """"""Get the list of attributes.\n        The list contains tuples (name, desc, type=None)\n\n        :param data: the data to proceed\n\n        """"""\n        return self.get_list_key(data, \'attr\')\n\n    def get_raw_not_managed(self, data):\n        """"""Get elements not managed. They can be used as is.\n\n        :param data: the data to proceed\n\n        """"""\n        keys = [\'also\', \'ref\', \'note\', \'other\', \'example\', \'method\', \'attr\']\n        elems = [self.opt[k] for k in self.opt if k in keys]\n        data = data.splitlines()\n        start = 0\n        init = 0\n        raw = \'\'\n        spaces = None\n        while start != -1:\n            start, end = self.get_next_section_lines(data[init:])\n            if start != -1:\n                init += start\n                if isin_alone(elems, data[init]) and \\\n                        not isin_alone([self.opt[e] for e in self.excluded_sections], data[init]):\n                    spaces = get_leading_spaces(data[init])\n                    if end != -1:\n                        section = [d.replace(spaces, \'\', 1).rstrip() for d in data[init:init + end]]\n                    else:\n                        section = [d.replace(spaces, \'\', 1).rstrip() for d in data[init:]]\n                    raw += \'\\n\'.join(section) + \'\\n\'\n                init += 2\n        return raw\n\n    def get_key_section_header(self, key, spaces):\n        """"""Get the key of the header section\n\n        :param key: the key name\n        :param spaces: spaces to set at the beginning of the header\n\n        """"""\n        header = super(NumpydocTools, self).get_key_section_header(key, spaces)\n        header = spaces + header + \'\\n\' + spaces + \'-\' * len(header) + \'\\n\'\n        return header\n\n\nclass GoogledocTools(DocToolsBase):\n    """""" """"""\n    def __init__(self,\n                 first_line=None,\n                 optional_sections=(\'raise\'),\n                 excluded_sections=()):\n        """"""\n        :param first_line: indicate if description should start\n          on first or second line. By default it will follow global config.\n        :type first_line: boolean\n        :param optional_sections: list of sections that are not mandatory\n          if empty. The accepted sections are:\n          -param\n          -return\n          -raise\n        :type optional_sections: list\n        :param excluded_sections: list of sections that are excluded,\n          even if mandatory. The list is the same than for optional sections.\n        :type excluded_sections: list\n\n        """"""\n        super(GoogledocTools, self).__init__(first_line=first_line,\n                                             optional_sections=optional_sections,\n                                             excluded_sections=excluded_sections,\n                                             opt={\n                                                 \'attr\': \'attributes\',\n                                                 \'param\': \'args\',\n                                                 \'raise\': \'raises\',\n                                                 \'return\': \'returns\',\n                                                 \'yield\': \'yields\',\n                                             },\n                                             section_headers={\n                                                 \'param\': \'Args\',\n                                                 \'return\': \'Returns\',\n                                                 \'raise\': \'Raises\',\n                                             },\n                                             )\n\n    def get_section_key_line(self, data, key, opt_extension=\':\'):\n        """"""Get the next section line for a given key.\n\n        :param data: the data to proceed\n        :param key: the key\n        :param opt_extension: an optional extension to delimit the opt value\n\n        """"""\n        return super(GoogledocTools, self).get_section_key_line(data, key, opt_extension)\n\n    def _get_list_key(self, spaces, lines):\n        key_list = []\n        parse_key = False\n        key, desc, ptype = None, \'\', None\n        param_spaces = 0\n\n        for line in lines:\n            if len(line.strip()) == 0:\n                continue\n            curr_spaces = get_leading_spaces(line)\n            if not param_spaces:\n                param_spaces = len(curr_spaces)\n            if len(curr_spaces) == param_spaces:\n                if parse_key:\n                    key_list.append((key, desc, ptype))\n                if \':\' in line:\n                    elems = line.split(\':\', 1)\n                    ptype = None\n                    key = elems[0].strip()\n                    # the param\'s type is near the key in parenthesis\n                    if \'(\' in key and \')\' in key:\n                        tstart = key.index(\'(\') + 1\n                        tend = key.index(\')\')\n                        # the \'optional\' keyword can follow the style after a comma\n                        if \',\' in key:\n                            tend = key.index(\',\')\n                        ptype = key[tstart:tend].strip()\n                        key = key[:tstart - 1].strip()\n                    desc = elems[1].strip()\n                    parse_key = True\n                else:\n                    if len(curr_spaces) > len(spaces):\n                        line = line.replace(spaces, \'\', 1)\n                    if desc:\n                        desc += \'\\n\'\n                    desc += line\n            else:\n                if len(curr_spaces) > len(spaces):\n                    line = line.replace(spaces, \'\', 1)\n                if desc:\n                    desc += \'\\n\'\n                desc += line\n        if parse_key or desc:\n            key_list.append((key, desc, ptype))\n\n        return key_list\n\n    def get_next_section_start_line(self, data):\n        """"""Get the starting line number of next section.\n        It will return -1 if no section was found.\n        The section is a section key (e.g. \'Parameters:\')\n        then the content\n\n        :param data: a list of strings containing the docstring\'s lines\n        :returns: the index of next section else -1\n\n        """"""\n        start = -1\n        for i, line in enumerate(data):\n            if isin_alone([k + "":"" for k in self.opt.values()], line):\n                start = i\n                break\n        return start\n\n    def get_key_section_header(self, key, spaces):\n        """"""Get the key of the section header\n\n        :param key: the key name\n        :param spaces: spaces to set at the beginning of the header\n\n        """"""\n        header = super(GoogledocTools, self).get_key_section_header(key, spaces)\n        header = spaces + header + \':\' + \'\\n\'\n        return header\n\n\nclass DocsTools(object):\n    """"""This class provides the tools to manage several types of docstring.\n    Currently the following are managed:\n    - \'javadoc\': javadoc style\n    - \'reST\': restructured text style compatible with Sphinx\n    - \'groups\': parameters on beginning of lines (like Google Docs)\n    - \'google\': the numpy format for docstrings (using an external module)\n    - \'numpydoc\': the numpy format for docstrings (using an external module)\n\n    """"""\n    # TODO: enhance style dependent separation\n    # TODO: add set methods to generate style specific outputs\n    # TODO: manage C style (\\param)\n    def __init__(self, style_in=\'javadoc\', style_out=\'reST\', params=None):\n        """"""Choose the kind of docstring type.\n\n        :param style_in: docstring input style (\'javadoc\', \'reST\', \'groups\', \'numpydoc\', \'google\')\n        :type style_in: string\n        :param style_out: docstring output style (\'javadoc\', \'reST\', \'groups\', \'numpydoc\', \'google\')\n        :type style_out: string\n        :param params: if known the parameters names that should be found in the docstring.\n        :type params: list\n\n        """"""\n        self.style = {\'in\': style_in,\n                      \'out\': style_out}\n        self.opt = {}\n        self.tagstyles = []\n        self._set_available_styles()\n        self.params = params\n        self.numpydoc = NumpydocTools()\n        self.googledoc = GoogledocTools()\n\n    def _set_available_styles(self):\n        """"""Set the internal styles list and available options in a structure as following:\n\n            param: javadoc: name = \'@param\'\n                            sep  = \':\'\n                   reST:    name = \':param\'\n                            sep  = \':\'\n                   ...\n            type:  javadoc: name = \'@type\'\n                            sep  = \':\'\n                   ...\n            ...\n\n        And sets the internal groups style:\n            param:  \'params\', \'args\', \'parameters\', \'arguments\'\n            return: \'returns\', \'return\'\n            raise:  \'raises\', \'raise\', \'exceptions\', \'exception\'\n\n        """"""\n        options_tagstyle = {\'keys\': [\'param\', \'type\', \'returns\', \'return\', \'rtype\', \'raise\'],\n                            \'styles\': {\'javadoc\': (\'@\', \':\'),  # tuple:  key prefix, separator\n                                       \'reST\': (\':\', \':\'),\n                                       \'cstyle\': (\'\\\\\', \' \')}\n                           }\n        self.tagstyles = list(options_tagstyle[\'styles\'].keys())\n        for op in options_tagstyle[\'keys\']:\n            self.opt[op] = {}\n            for style in options_tagstyle[\'styles\']:\n                self.opt[op][style] = {\'name\': options_tagstyle[\'styles\'][style][0] + op,\n                                       \'sep\': options_tagstyle[\'styles\'][style][1]\n                                      }\n        self.opt[\'return\'][\'reST\'][\'name\'] = \':returns\'\n        self.opt[\'raise\'][\'reST\'][\'name\'] = \':raises\'\n        self.groups = {\n                    \'param\': [\'params\', \'args\', \'parameters\', \'arguments\'],\n                    \'return\': [\'returns\', \'return\'],\n                    \'raise\': [\'raises\', \'exceptions\', \'raise\', \'exception\']\n                    }\n\n    def autodetect_style(self, data):\n        """"""Determine the style of a docstring,\n        and sets it as the default input one for the instance.\n\n        :param data: the docstring\'s data to recognize.\n        :type data: str\n        :returns: the style detected else \'unknown\'\n        :rtype: str\n\n        """"""\n        # evaluate styles with keys\n\n        found_keys = defaultdict(int)\n        for style in self.tagstyles:\n            for key in self.opt:\n                found_keys[style] += data.count(self.opt[key][style][\'name\'])\n        fkey = max(found_keys, key=found_keys.get)\n        detected_style = fkey if found_keys[fkey] else \'unknown\'\n\n        # evaluate styles with groups\n\n        if detected_style == \'unknown\':\n            found_groups = 0\n            found_googledoc = 0\n            found_numpydoc = 0\n            found_numpydocsep = 0\n            for line in data.strip().splitlines():\n                for key in self.groups:\n                    found_groups += 1 if isin_start(self.groups[key], line) else 0\n                for key in self.googledoc:\n                    found_googledoc += 1 if isin_start(self.googledoc[key], line) else 0\n                for key in self.numpydoc:\n                    found_numpydoc += 1 if isin_start(self.numpydoc[key], line) else 0\n                if line.strip() and isin_alone([\'-\' * len(line.strip())], line):\n                    found_numpydocsep += 1\n                elif isin(self.numpydoc.keywords, line):\n                    found_numpydoc += 1\n            # TODO: check if not necessary to have > 1??\n            if found_numpydoc and found_numpydocsep:\n                detected_style = \'numpydoc\'\n            elif found_googledoc >= found_groups:\n                detected_style = \'google\'\n            elif found_groups:\n                detected_style = \'groups\'\n        self.style[\'in\'] = detected_style\n\n        return detected_style\n\n    def set_input_style(self, style):\n        """"""Set the input docstring style\n\n        :param style: style to set for input docstring\n        :type style: str\n\n        """"""\n        self.style[\'in\'] = style\n\n    def set_output_style(self, style):\n        """"""Set the output docstring style\n\n        :param style: style to set for output docstring\n        :type style: str\n\n        """"""\n        self.style[\'out\'] = style\n\n    def _get_options(self, style):\n        """"""Get the list of keywords for a particular style\n\n        :param style: the style that the keywords are wanted\n\n        """"""\n        return [self.opt[o][style][\'name\'] for o in self.opt]\n\n    def get_key(self, key, target=\'in\'):\n        """"""Get the name of a key in current style.\n        e.g.: in javadoc style, the returned key for \'param\' is \'@param\'\n\n        :param key: the key wanted (param, type, return, rtype,..)\n        :param target: the target docstring is \'in\' for the input or\n          \'out\' for the output to generate. (Default value = \'in\')\n\n        """"""\n        target = \'out\' if target == \'out\' else \'in\'\n        return self.opt[key][self.style[target]][\'name\']\n\n    def get_sep(self, key=\'param\', target=\'in\'):\n        """"""Get the separator of current style.\n        e.g.: in reST and javadoc style, it is "":""\n\n        :param key: the key which separator is wanted (param, type, return, rtype,..) (Default value = \'param\')\n        :param target: the target docstring is \'in\' for the input or\n          \'out\' for the output to generate. (Default value = \'in\')\n\n        """"""\n        target = \'out\' if target == \'out\' else \'in\'\n        if self.style[target] in [\'numpydoc\', \'google\']:\n            return \'\'\n        return self.opt[key][self.style[target]][\'sep\']\n\n    def set_known_parameters(self, params):\n        """"""Set known parameters names.\n\n        :param params: the docstring parameters names\n        :type params: list\n\n        """"""\n        self.params = params\n\n    def get_doctests_indexes(self, data):\n        """"""Extract Doctests if found and return it\n\n        :param data: string to parse\n        :return: index of start and index of end of the doctest, else (-1, -1)\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        datalst = data.splitlines()\n        for i, line in enumerate(datalst):\n            if start > -1:\n                if line.strip() == """":\n                    break\n                end = i\n            elif line.strip().startswith("">>>""):\n                start = i\n                end = i\n        return start, end\n\n    def get_group_key_line(self, data, key):\n        """"""Get the next group-style key\'s line number.\n\n        :param data: string to parse\n        :param key: the key category\n        :returns: the found line number else -1\n\n        """"""\n        idx = -1\n        for i, line in enumerate(data.splitlines()):\n            if isin_start(self.groups[key], line):\n                idx = i\n        return idx\n#        search = \'\\s*(%s)\' % \'|\'.join(self.groups[key])\n#        m = re.match(search, data.lower())\n#        if m:\n#            key_param = m.group(1)\n\n    def get_group_key_index(self, data, key):\n        """"""Get the next groups style\'s starting line index for a key\n\n        :param data: string to parse\n        :param key: the key category\n        :returns: the index if found else -1\n\n        """"""\n        idx = -1\n        li = self.get_group_key_line(data, key)\n        if li != -1:\n            idx = 0\n            for line in data.splitlines()[:li]:\n                idx += len(line) + len(\'\\n\')\n        return idx\n\n    def get_group_line(self, data):\n        """"""Get the next group-style key\'s line.\n\n        :param data: the data to proceed\n        :returns: the line number\n\n        """"""\n        idx = -1\n        for key in self.groups:\n            i = self.get_group_key_line(data, key)\n            if (i < idx and i != -1) or idx == -1:\n                idx = i\n        return idx\n\n    def get_group_index(self, data):\n        """"""Get the next groups style\'s starting line index\n\n        :param data: string to parse\n        :returns: the index if found else -1\n\n        """"""\n        idx = -1\n        li = self.get_group_line(data)\n        if li != -1:\n            idx = 0\n            for line in data.splitlines()[:li]:\n                idx += len(line) + len(\'\\n\')\n        return idx\n\n    def get_key_index(self, data, key, starting=True):\n        """"""Get from a docstring the next option with a given key.\n\n        :param data: string to parse\n        :param starting: does the key element must start the line (Default value = True)\n        :type starting: boolean\n        :param key: the key category. Can be \'param\', \'type\', \'return\', ...\n        :returns: index of found element else -1\n        :rtype: integer\n\n        """"""\n        key = self.opt[key][self.style[\'in\']][\'name\']\n        if key.startswith(\':returns\'):\n            data = data.replace(\':return:\', \':returns:\')  # see issue 9\n        idx = len(data)\n        ini = 0\n        loop = True\n        if key in data:\n            while loop:\n                i = data.find(key)\n                if i != -1:\n                    if starting:\n                        if not data[:i].rstrip(\' \\t\').endswith(\'\\n\') and len(data[:i].strip()) > 0:\n                            ini = i + 1\n                            data = data[ini:]\n                        else:\n                            idx = ini + i\n                            loop = False\n                    else:\n                        idx = ini + i\n                        loop = False\n                else:\n                    loop = False\n        if idx == len(data):\n            idx = -1\n        return idx\n\n    def get_elem_index(self, data, starting=True):\n        """"""Get from a docstring the next option.\n        In javadoc style it could be @param, @return, @type,...\n\n        :param data: string to parse\n        :param starting: does the key element must start the line (Default value = True)\n        :type starting: boolean\n        :returns: index of found element else -1\n        :rtype: integer\n\n        """"""\n        idx = len(data)\n        for opt in self.opt.keys():\n            i = self.get_key_index(data, opt, starting)\n            if i < idx and i != -1:\n                idx = i\n        if idx == len(data):\n            idx = -1\n        return idx\n\n    def get_elem_desc(self, data, key):\n        """"""TODO """"""\n\n    def get_elem_param(self):\n        """"""TODO """"""\n\n    def get_raise_indexes(self, data):\n        """"""Get from a docstring the next raise name indexes.\n        In javadoc style it is after @raise.\n\n        :param data: string to parse\n        :returns: start and end indexes of found element else (-1, -1)\n          or else (-2, -2) if try to use params style but no parameters were provided.\n          Note: the end index is the index after the last name character\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        stl_param = self.opt[\'raise\'][self.style[\'in\']][\'name\']\n        if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n            idx_p = self.get_key_index(data, \'raise\')\n            if idx_p >= 0:\n                idx_p += len(stl_param)\n                m = re.match(RAISES_NAME_REGEX, data[idx_p:].strip())\n                if m:\n                    param = m.group(1)\n                    start = idx_p + data[idx_p:].find(param)\n                    end = start + len(param)\n\n        if self.style[\'in\'] in [\'groups\', \'unknown\'] and (start, end) == (-1, -1):\n            # search = \'\\s*(%s)\' % \'|\'.join(self.groups[\'param\'])\n            # m = re.match(search, data.lower())\n            # if m:\n            #    key_param = m.group(1)\n            pass\n\n        return start, end\n\n    def get_raise_description_indexes(self, data, prev=None):\n        """"""Get from a docstring the next raise\'s description.\n        In javadoc style it is after @param.\n\n        :param data: string to parse\n        :param prev: index after the param element name (Default value = None)\n        :returns: start and end indexes of found element else (-1, -1)\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        if not prev:\n            _, prev = self.get_raise_indexes(data)\n        if prev < 0:\n            return -1, -1\n        m = re.match(r\'\\W*(\\w+)\', data[prev:])\n        if m:\n            first = m.group(1)\n            start = data[prev:].find(first)\n            if start >= 0:\n                start += prev\n                if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n                    end = self.get_elem_index(data[start:])\n                    if end >= 0:\n                        end += start\n                if self.style[\'in\'] in [\'params\', \'unknown\'] and end == -1:\n                    p1, _ = self.get_raise_indexes(data[start:])\n                    if p1 >= 0:\n                        end = p1\n                    else:\n                        end = len(data)\n\n        return start, end\n\n    def get_param_indexes(self, data):\n        """"""Get from a docstring the next parameter name indexes.\n        In javadoc style it is after @param.\n\n        :param data: string to parse\n        :returns: start and end indexes of found element else (-1, -1)\n          or else (-2, -2) if try to use params style but no parameters were provided.\n          Note: the end index is the index after the last name character\n        :rtype: tuple\n\n        """"""\n        # TODO: new method to extract an element\'s name so will be available for @param and @types and other styles (:param, \\param)\n        start, end = -1, -1\n        stl_param = self.opt[\'param\'][self.style[\'in\']][\'name\']\n        if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n            idx_p = self.get_key_index(data, \'param\')\n            if idx_p >= 0:\n                idx_p += len(stl_param)\n                m = re.match(r\'^([\\w]+)\', data[idx_p:].strip())\n                if m:\n                    param = m.group(1)\n                    start = idx_p + data[idx_p:].find(param)\n                    end = start + len(param)\n\n        if self.style[\'in\'] in [\'groups\', \'unknown\'] and (start, end) == (-1, -1):\n            # search = \'\\s*(%s)\' % \'|\'.join(self.groups[\'param\'])\n            # m = re.match(search, data.lower())\n            # if m:\n            #    key_param = m.group(1)\n            pass\n\n        if self.style[\'in\'] in [\'params\', \'groups\', \'unknown\'] and (start, end) == (-1, -1):\n            if self.params is None:\n                return -2, -2\n            idx = -1\n            param = None\n            for p in self.params:\n                if type(p) is tuple:\n                    p = p[0]\n                i = data.find(\'\\n\' + p)\n                if i >= 0:\n                    if idx == -1 or i < idx:\n                        idx = i\n                        param = p\n            if idx != -1:\n                start, end = idx, idx + len(param)\n        return start, end\n\n    def get_param_description_indexes(self, data, prev=None):\n        """"""Get from a docstring the next parameter\'s description.\n        In javadoc style it is after @param.\n\n        :param data: string to parse\n        :param prev: index after the param element name (Default value = None)\n        :returns: start and end indexes of found element else (-1, -1)\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        if not prev:\n            _, prev = self.get_param_indexes(data)\n        if prev < 0:\n            return -1, -1\n        m = re.match(r\'\\W*(\\w+)\', data[prev:])\n        if m:\n            first = m.group(1)\n            start = data[prev:].find(first)\n            if start >= 0:\n                start += prev\n                if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n                    end = self.get_elem_index(data[start:])\n                    if end >= 0:\n                        end += start\n                if self.style[\'in\'] in [\'params\', \'unknown\'] and end == -1:\n                    p1, _ = self.get_param_indexes(data[start:])\n                    if p1 >= 0:\n                        end = p1\n                    else:\n                        end = len(data)\n\n        return start, end\n\n    def get_param_type_indexes(self, data, name=None, prev=None):\n        """"""Get from a docstring a parameter type indexes.\n        In javadoc style it is after @type.\n\n        :param data: string to parse\n        :param name: the name of the parameter (Default value = None)\n        :param prev: index after the previous element (param or param\'s description) (Default value = None)\n        :returns: start and end indexes of found element else (-1, -1)\n          Note: the end index is the index after the last included character or -1 if\n          reached the end\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        stl_type = self.opt[\'type\'][self.style[\'in\']][\'name\']\n        if not prev:\n            _, prev = self.get_param_description_indexes(data)\n        if prev >= 0:\n            if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n                idx = self.get_elem_index(data[prev:])\n                if idx >= 0 and data[prev + idx:].startswith(stl_type):\n                    idx = prev + idx + len(stl_type)\n                    m = re.match(r\'\\W*(\\w+)\\W+(\\w+)\\W*\', data[idx:].strip())\n                    if m:\n                        param = m.group(1).strip()\n                        if (name and param == name) or not name:\n                            desc = m.group(2)\n                            start = data[idx:].find(desc) + idx\n                            end = self.get_elem_index(data[start:])\n                            if end >= 0:\n                                end += start\n\n            if self.style[\'in\'] in [\'params\', \'unknown\'] and (start, end) == (-1, -1):\n                # TODO: manage this\n                pass\n\n        return (start, end)\n\n    def get_return_description_indexes(self, data):\n        """"""Get from a docstring the return parameter description indexes.\n        In javadoc style it is after @return.\n\n        :param data: string to parse\n        :returns: start and end indexes of found element else (-1, -1)\n          Note: the end index is the index after the last included character or -1 if\n          reached the end\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        stl_return = self.opt[\'return\'][self.style[\'in\']][\'name\']\n        if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n            idx = self.get_key_index(data, \'return\')\n            idx_abs = idx\n            # search starting description\n            if idx >= 0:\n                # FIXME: take care if a return description starts with <, >, =,...\n                m = re.match(r\'\\W*(\\w+)\', data[idx_abs + len(stl_return):])\n                if m:\n                    first = m.group(1)\n                    idx = data[idx_abs:].find(first)\n                    idx_abs += idx\n                    start = idx_abs\n                else:\n                    idx = -1\n            # search the end\n            idx = self.get_elem_index(data[idx_abs:])\n            if idx > 0:\n                idx_abs += idx\n                end = idx_abs\n\n        if self.style[\'in\'] in [\'params\', \'unknown\'] and (start, end) == (-1, -1):\n            # TODO: manage this\n            pass\n\n        return start, end\n\n    def get_return_type_indexes(self, data):\n        """"""Get from a docstring the return parameter type indexes.\n        In javadoc style it is after @rtype.\n\n        :param data: string to parse\n        :returns: start and end indexes of found element else (-1, -1)\n          Note: the end index is the index after the last included character or -1 if\n          reached the end\n        :rtype: tuple\n\n        """"""\n        start, end = -1, -1\n        stl_rtype = self.opt[\'rtype\'][self.style[\'in\']][\'name\']\n        if self.style[\'in\'] in self.tagstyles + [\'unknown\']:\n            dstart, dend = self.get_return_description_indexes(data)\n            # search the start\n            if dstart >= 0 and dend > 0:\n                idx = self.get_elem_index(data[dend:])\n                if idx >= 0 and data[dend + idx:].startswith(stl_rtype):\n                    idx = dend + idx + len(stl_rtype)\n                    m = re.match(r\'\\W*(\\w+)\', data[idx:])\n                    if m:\n                        first = m.group(1)\n                        start = data[idx:].find(first) + idx\n            # search the end\n            idx = self.get_elem_index(data[start:])\n            if idx > 0:\n                end = idx + start\n\n        if self.style[\'in\'] in [\'params\', \'unknown\'] and (start, end) == (-1, -1):\n            # TODO: manage this\n            pass\n\n        return start, end\n\n\nclass DocString(object):\n    """"""This class represents the docstring""""""\n\n    def __init__(self, elem_raw, spaces=\'\', docs_raw=None, quotes=""\'\'\'"", input_style=None, output_style=None,\n                 first_line=False, trailing_space=True, **kwargs):\n        """"""\n        :param elem_raw: raw data of the element (def or class).\n        :param spaces: the leading whitespaces before the element\n        :param docs_raw: the raw data of the docstring part if any.\n        :param quotes: the type of quotes to use for output: \' \' \' or "" "" ""\n        :param style_in: docstring input style (\'javadoc\', \'reST\', \'groups\', \'numpydoc\', \'google\', None).\n          If None will be autodetected\n        :type style_in: string\n        :param style_out: docstring output style (\'javadoc\', \'reST\', \'groups\', \'numpydoc\', \'google\')\n        :type style_out: string\n        :param first_line: indicate if description should start\n          on first or second line\n        :type first_line: boolean\n        :param trailing_space: if set, a trailing space will be inserted in places where the user\n          should write a description\n        :type trailing_space: boolean\n\n        """"""\n        self.dst = DocsTools()\n        self.first_line = first_line\n        self.trailing_space = \'\'\n        if trailing_space:\n            self.trailing_space = \' \'\n        if docs_raw and not input_style:\n            self.dst.autodetect_style(docs_raw)\n        elif input_style:\n            self.set_input_style(input_style)\n        if output_style:\n            self.set_output_style(output_style)\n        self.element = {\n            \'raw\': elem_raw,\n            \'name\': None,\n            \'type\': None,\n            \'params\': [],\n            \'spaces\': spaces\n            }\n        if docs_raw:\n            docs_raw = docs_raw.strip()\n            if docs_raw.startswith(\'""""""\') or docs_raw.startswith(""\'\'\'""):\n                docs_raw = docs_raw[3:]\n            if docs_raw.endswith(\'""""""\') or docs_raw.endswith(""\'\'\'""):\n                docs_raw = docs_raw[:-3]\n        self.docs = {\n            \'in\': {\n                \'raw\': docs_raw,\n                \'doctests\': """",\n                \'desc\': None,\n                \'params\': [],\n                \'types\': [],\n                \'return\': None,\n                \'rtype\': None,\n                \'raises\': []\n                },\n            \'out\': {\n                \'raw\': \'\',\n                \'desc\': None,\n                \'params\': [],\n                \'types\': [],\n                \'return\': None,\n                \'rtype\': None,\n                \'raises\': [],\n                \'spaces\': spaces + \' \' * kwargs.get(\'indent\', 2)\n                }\n            }\n        if \'\\t\' in spaces:\n            self.docs[\'out\'][\'spaces\'] = spaces + \'\\t\'\n        elif (len(spaces) % 4) == 0 or spaces == \'\':\n            # FIXME: should bug if tabs for class or function (as spaces==\'\')\n            self.docs[\'out\'][\'spaces\'] = spaces + \' \' * 4\n        self.parsed_elem = False\n        self.parsed_docs = False\n        self.generated_docs = False\n\n        self.parse_element()\n        self.quotes = quotes\n\n    def __str__(self):\n        # for debuging\n        txt = ""\\n\\n** "" + str(self.element[\'name\'])\n        txt += \' of type \' + str(self.element[\'type\']) + \':\'\n        txt += str(self.docs[\'in\'][\'desc\']) + \'\\n\'\n        txt += \'->\' + str(self.docs[\'in\'][\'params\']) + \'\\n\'\n        txt += \'***>>\' + str(self.docs[\'out\'][\'raw\']) + \'\\n\' + \'\\n\'\n        return txt\n\n    def __repr__(self):\n        return self.__str__()\n\n    def get_input_docstring(self):\n        """"""Get the input raw docstring.\n\n        :returns: the input docstring if any.\n        :rtype: str or None\n\n        """"""\n        return self.docs[\'in\'][\'raw\']\n\n    def get_input_style(self):\n        """"""Get the input docstring style\n\n        :returns: the style for input docstring\n        :rtype: style: str\n\n        """"""\n        # TODO: use a getter\n        return self.dst.style[\'in\']\n\n    def set_input_style(self, style):\n        """"""Sets the input docstring style\n\n        :param style: style to set for input docstring\n        :type style: str\n\n        """"""\n        # TODO: use a setter\n        self.dst.style[\'in\'] = style\n\n    def get_output_style(self):\n        """"""Sets the output docstring style\n\n        :returns: the style for output docstring\n        :rtype: style: str\n\n        """"""\n        # TODO: use a getter\n        return self.dst.style[\'out\']\n\n    def set_output_style(self, style):\n        """"""Sets the output docstring style\n\n        :param style: style to set for output docstring\n        :type style: str\n\n        """"""\n        # TODO: use a setter\n        self.dst.style[\'out\'] = style\n\n    def get_spaces(self):\n        """"""Get the output docstring initial spaces.\n\n        :returns: the spaces\n\n        """"""\n        return self.docs[\'out\'][\'spaces\']\n\n    def set_spaces(self, spaces):\n        """"""Set for output docstring the initial spaces.\n\n        :param spaces: the spaces to set\n\n        """"""\n        self.docs[\'out\'][\'spaces\'] = spaces\n\n    def parse_element(self, raw=None):\n        """"""Parses the element\'s elements (type, name and parameters) :)\n        e.g.: def methode(param1, param2=\'default\')\n        def                      -> type\n        methode                  -> name\n        param1, param2=\'default\' -> parameters\n\n        :param raw: raw data of the element (def or class). (Default value = None)\n\n        """"""\n        # TODO: retrieve return from element external code (in parameter)\n        if raw is None:\n            l = self.element[\'raw\'].strip()\n        else:\n            l = raw.strip()\n        is_class = False\n        if l.startswith(\'def \') or l.startswith(\'class \'):\n            # retrieves the type\n            if l.startswith(\'def\'):\n                self.element[\'type\'] = \'def\'\n                l = l.replace(\'def \', \'\')\n            else:\n                self.element[\'type\'] = \'class\'\n                l = l.replace(\'class \', \'\')\n                is_class = True\n            # retrieves the name\n            self.element[\'name\'] = l[:l.find(\'(\')].strip()\n            if not is_class:\n                if l[-1] == \':\':\n                    l = l[:-1].strip()\n                # retrieves the parameters\n                l = l[l.find(\'(\') + 1:l.rfind(\'):\')].strip()\n                lst = [c.strip() for c in l.split(\',\')]\n                for e in lst:\n                    if \'=\' in e:\n                        k, v = e.split(\'=\', 1)\n                        self.element[\'params\'].append((k.strip(), v.strip()))\n                    elif e and e != \'self\' and e != \'cls\':\n                        self.element[\'params\'].append(e)\n        self.parsed_elem = True\n\n    def _extract_docs_doctest(self):\n        """"""Extract the doctests if found.\n        If there are doctests, they are removed from the input data and set on\n        a specific buffer as they won\'t be altered.\n\n        :return: True if found and proceeded else False\n        """"""\n        result = False\n        data = self.docs[\'in\'][\'raw\']\n        start, end = self.dst.get_doctests_indexes(data)\n        while start != -1:\n            print (start, end)\n            result = True\n            datalst = data.splitlines()\n            if self.docs[\'in\'][\'doctests\'] != """":\n                self.docs[\'in\'][\'doctests\'] += \'\\n\'\n            self.docs[\'in\'][\'doctests\'] += \'\\n\'.join(datalst[start:end + 1]) + \'\\n\'\n            self.docs[\'in\'][\'raw\'] = \'\\n\'.join(datalst[:start] + datalst[end + 1:])\n            data = self.docs[\'in\'][\'raw\']\n            start, end = self.dst.get_doctests_indexes(data)\n        if self.docs[\'in\'][\'doctests\'] != """":\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'doctests\'].splitlines()])\n            self.docs[\'out\'][\'doctests\'] = data\n        return result\n\n    def _extract_docs_description(self):\n        """"""Extract main description from docstring""""""\n        # FIXME: the indentation of descriptions is lost\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        if self.dst.style[\'in\'] == \'groups\':\n            idx = self.dst.get_group_index(data)\n        elif self.dst.style[\'in\'] == \'google\':\n            lines = data.splitlines()\n            line_num = self.dst.googledoc.get_next_section_start_line(lines)\n            if line_num == -1:\n                idx = -1\n            else:\n                idx = len(\'\\n\'.join(lines[:line_num]))\n        elif self.dst.style[\'in\'] == \'numpydoc\':\n            lines = data.splitlines()\n            line_num = self.dst.numpydoc.get_next_section_start_line(lines)\n            if line_num == -1:\n                idx = -1\n            else:\n                idx = len(\'\\n\'.join(lines[:line_num]))\n        elif self.dst.style[\'in\'] == \'unknown\':\n            idx = -1\n        else:\n            idx = self.dst.get_elem_index(data)\n        if idx == 0:\n            self.docs[\'in\'][\'desc\'] = \'\'\n        elif idx == -1:\n            self.docs[\'in\'][\'desc\'] = data\n        else:\n            self.docs[\'in\'][\'desc\'] = data[:idx]\n\n    def _extract_groupstyle_docs_params(self):\n        """"""Extract group style parameters""""""\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        idx = self.dst.get_group_key_line(data, \'param\')\n        if idx >= 0:\n            data = data.splitlines()[idx + 1:]\n            end = self.dst.get_group_line(\'\\n\'.join(data))\n            end = end if end != -1 else len(data)\n            for i in range(end):\n                # FIXME: see how retrieve multiline param description and how get type\n                line = data[i]\n                param = None\n                desc = \'\'\n                ptype = \'\'\n                m = re.match(r\'^\\W*(\\w+)[\\W\\s]+(\\w[\\s\\w]+)\', line.strip())\n                if m:\n                    param = m.group(1).strip()\n                    desc = m.group(2).strip()\n                else:\n                    m = re.match(r\'^\\W*(\\w+)\\W*\', line.strip())\n                    if m:\n                        param = m.group(1).strip()\n                if param:\n                    self.docs[\'in\'][\'params\'].append((param, desc, ptype))\n\n    def _extract_tagstyle_docs_params(self):\n        """""" """"""\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        listed = 0\n        loop = True\n        maxi = 10000  # avoid infinite loop but should never happen\n        i = 0\n        while loop:\n            i += 1\n            if i > maxi:\n                loop = False\n            start, end = self.dst.get_param_indexes(data)\n            if start >= 0:\n                param = data[start: end]\n                desc = \'\'\n                start, end = self.dst.get_param_description_indexes(data, prev=end)\n                if start > 0:\n                    desc = data[start: end].strip()\n                ptype = \'\'\n                start, pend = self.dst.get_param_type_indexes(data, name=param, prev=end)\n                if start > 0:\n                    ptype = data[start: pend].strip()\n                # a parameter is stored with: (name, description, type)\n                self.docs[\'in\'][\'params\'].append((param, desc, ptype))\n                data = data[end:]\n                listed += 1\n            else:\n                loop = False\n        if i > maxi:\n            print(""WARNING: an infinite loop was reached while extracting docstring parameters (>10000). This should never happen!!!"")\n\n    def _extract_docs_params(self):\n        """"""Extract parameters description and type from docstring. The internal computed parameters list is\n        composed by tuples (parameter, description, type).\n\n        """"""\n        if self.dst.style[\'in\'] == \'numpydoc\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'params\'] += self.dst.numpydoc.get_param_list(data)\n        elif self.dst.style[\'in\'] == \'google\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'params\'] += self.dst.googledoc.get_param_list(data)\n        elif self.dst.style[\'in\'] == \'groups\':\n            self._extract_groupstyle_docs_params()\n        elif self.dst.style[\'in\'] in [\'javadoc\', \'reST\']:\n            self._extract_tagstyle_docs_params()\n\n    def _extract_groupstyle_docs_raises(self):\n        """""" """"""\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        idx = self.dst.get_group_key_line(data, \'raise\')\n        if idx >= 0:\n            data = data.splitlines()[idx + 1:]\n            end = self.dst.get_group_line(\'\\n\'.join(data))\n            end = end if end != -1 else len(data)\n            for i in range(end):\n                # FIXME: see how retrieve multiline raise description\n                line = data[i]\n                param = None\n                desc = \'\'\n                m = re.match(r\'^\\W*([\\w.]+)[\\W\\s]+(\\w[\\s\\w]+)\', line.strip())\n                if m:\n                    param = m.group(1).strip()\n                    desc = m.group(2).strip()\n                else:\n                    m = re.match(r\'^\\W*(\\w+)\\W*\', line.strip())\n                    if m:\n                        param = m.group(1).strip()\n                if param:\n                    self.docs[\'in\'][\'raises\'].append((param, desc))\n\n    def _extract_tagstyle_docs_raises(self):\n        """""" """"""\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        listed = 0\n        loop = True\n        maxi = 10000  # avoid infinite loop but should never happen\n        i = 0\n        while loop:\n            i += 1\n            if i > maxi:\n                loop = False\n            start, end = self.dst.get_raise_indexes(data)\n            if start >= 0:\n                param = data[start: end]\n                desc = \'\'\n                start, end = self.dst.get_raise_description_indexes(data, prev=end)\n                if start > 0:\n                    desc = data[start: end].strip()\n                # a parameter is stored with: (name, description)\n                self.docs[\'in\'][\'raises\'].append((param, desc))\n                data = data[end:]\n                listed += 1\n            else:\n                loop = False\n        if i > maxi:\n            print(""WARNING: an infinite loop was reached while extracting docstring parameters (>10000). This should never happen!!!"")\n\n    def _extract_docs_raises(self):\n        """"""Extract raises description from docstring. The internal computed raises list is\n        composed by tuples (raise, description).\n\n        """"""\n        if self.dst.style[\'in\'] == \'numpydoc\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'raises\'] += self.dst.numpydoc.get_raise_list(data)\n        if self.dst.style[\'in\'] == \'google\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'raises\'] += self.dst.googledoc.get_raise_list(data)\n        elif self.dst.style[\'in\'] == \'groups\':\n            self._extract_groupstyle_docs_raises()\n        elif self.dst.style[\'in\'] in [\'javadoc\', \'reST\']:\n            self._extract_tagstyle_docs_raises()\n\n    def _extract_groupstyle_docs_return(self):\n        """""" """"""\n        # TODO: manage rtype\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        idx = self.dst.get_group_key_line(data, \'return\')\n        if idx >= 0:\n            data = data.splitlines()[idx + 1:]\n            end = self.dst.get_group_line(\'\\n\'.join(data))\n            end = end if end != -1 else len(data)\n            data = \'\\n\'.join(data[:end]).strip()\n            self.docs[\'in\'][\'return\'] = data.rstrip()\n\n    def _extract_tagstyle_docs_return(self):\n        """""" """"""\n        data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n        start, end = self.dst.get_return_description_indexes(data)\n        if start >= 0:\n            if end >= 0:\n                self.docs[\'in\'][\'return\'] = data[start:end].rstrip()\n            else:\n                self.docs[\'in\'][\'return\'] = data[start:].rstrip()\n        start, end = self.dst.get_return_type_indexes(data)\n        if start >= 0:\n            if end >= 0:\n                self.docs[\'in\'][\'rtype\'] = data[start:end].rstrip()\n            else:\n                self.docs[\'in\'][\'rtype\'] = data[start:].rstrip()\n\n    def _extract_docs_return(self):\n        """"""Extract return description and type""""""\n        if self.dst.style[\'in\'] == \'numpydoc\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'return\'] = self.dst.numpydoc.get_return_list(data)\n            self.docs[\'in\'][\'rtype\'] = None\n# TODO: fix this\n        elif self.dst.style[\'in\'] == \'google\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            self.docs[\'in\'][\'return\'] = self.dst.googledoc.get_return_list(data)\n            self.docs[\'in\'][\'rtype\'] = None\n        elif self.dst.style[\'in\'] == \'groups\':\n            self._extract_groupstyle_docs_return()\n        elif self.dst.style[\'in\'] in [\'javadoc\', \'reST\']:\n            self._extract_tagstyle_docs_return()\n\n    def _extract_docs_other(self):\n        """"""Extract other specific sections""""""\n        if self.dst.style[\'in\'] == \'numpydoc\':\n            data = \'\\n\'.join([d.rstrip().replace(self.docs[\'out\'][\'spaces\'], \'\', 1) for d in self.docs[\'in\'][\'raw\'].splitlines()])\n            lst = self.dst.numpydoc.get_list_key(data, \'also\')\n            lst = self.dst.numpydoc.get_list_key(data, \'ref\')\n            lst = self.dst.numpydoc.get_list_key(data, \'note\')\n            lst = self.dst.numpydoc.get_list_key(data, \'other\')\n            lst = self.dst.numpydoc.get_list_key(data, \'example\')\n            lst = self.dst.numpydoc.get_list_key(data, \'attr\')\n            # TODO do something with this?\n\n    def parse_docs(self, raw=None):\n        """"""Parses the docstring\n\n        :param raw: the data to parse if not internally provided (Default value = None)\n\n        """"""\n        if raw is not None:\n            raw = raw.strip()\n            if raw.startswith(\'""""""\') or raw.startswith(""\'\'\'""):\n                raw = raw[3:]\n            if raw.endswith(\'""""""\') or raw.endswith(""\'\'\'""):\n                raw = raw[:-3]\n            self.docs[\'in\'][\'raw\'] = raw\n            self.dst.autodetect_style(raw)\n        if self.docs[\'in\'][\'raw\'] is None:\n            return\n        self.dst.set_known_parameters(self.element[\'params\'])\n        self._extract_docs_doctest()\n        self._extract_docs_params()\n        self._extract_docs_return()\n        self._extract_docs_raises()\n        self._extract_docs_description()\n        self._extract_docs_other()\n        self.parsed_docs = True\n\n    def _set_desc(self):\n        """"""Sets the global description if any""""""\n        # TODO: manage different in/out styles\n        if self.docs[\'in\'][\'desc\']:\n            self.docs[\'out\'][\'desc\'] = self.docs[\'in\'][\'desc\']\n        else:\n            self.docs[\'out\'][\'desc\'] = \'\'\n\n    def _set_params(self):\n        """"""Sets the parameters with types, descriptions and default value if any""""""\n        # TODO: manage different in/out styles\n        if self.docs[\'in\'][\'params\']:\n            # list of parameters is like: (name, description, type)\n            self.docs[\'out\'][\'params\'] = list(self.docs[\'in\'][\'params\'])\n        for e in self.element[\'params\']:\n            if type(e) is tuple:\n                # tuple is: (name, default)\n                param = e[0]\n            else:\n                param = e\n            found = False\n            for i, p in enumerate(self.docs[\'out\'][\'params\']):\n                if param == p[0]:\n                    found = True\n                    # add default value if any\n                    if type(e) is tuple:\n                        # param will contain: (name, desc, type, default)\n                        self.docs[\'out\'][\'params\'][i] = (p[0], p[1], p[2], e[1])\n            if not found:\n                if type(e) is tuple:\n                    p = (param, \'\', None, e[1])\n                else:\n                    p = (param, \'\', None, None)\n                self.docs[\'out\'][\'params\'].append(p)\n\n    def _set_raises(self):\n        """"""Sets the raises and descriptions""""""\n        # TODO: manage different in/out styles\n        # manage setting if not mandatory for numpy but optional\n        if self.docs[\'in\'][\'raises\']:\n            if self.dst.style[\'out\'] != \'numpydoc\' or self.dst.style[\'in\'] == \'numpydoc\' or \\\n                    (self.dst.style[\'out\'] == \'numpydoc\' and\n                     \'raise\' not in self.dst.numpydoc.get_excluded_sections()):\n                # list of parameters is like: (name, description)\n                self.docs[\'out\'][\'raises\'] = list(self.docs[\'in\'][\'raises\'])\n\n    def _set_return(self):\n        """"""Sets the return parameter with description and rtype if any""""""\n        # TODO: manage return retrieved from element code (external)\n        # TODO: manage different in/out styles\n        if type(self.docs[\'in\'][\'return\']) is list and self.dst.style[\'out\'] not in [\'groups\', \'numpydoc\', \'google\']:\n            # TODO: manage return names\n            # manage not setting return if not mandatory for numpy\n            lst = self.docs[\'in\'][\'return\']\n            if lst:\n                if lst[0][0] is not None:\n                    self.docs[\'out\'][\'return\'] = ""%s-> %s"" % (lst[0][0], lst[0][1])\n                else:\n                    self.docs[\'out\'][\'return\'] = lst[0][1]\n                self.docs[\'out\'][\'rtype\'] = lst[0][2]\n        else:\n            self.docs[\'out\'][\'return\'] = self.docs[\'in\'][\'return\']\n            self.docs[\'out\'][\'rtype\'] = self.docs[\'in\'][\'rtype\']\n\n    def _set_other(self):\n        """"""Sets other specific sections""""""\n        # manage not setting if not mandatory for numpy\n        if self.dst.style[\'in\'] == \'numpydoc\':\n            if self.docs[\'in\'][\'raw\'] is not None:\n                self.docs[\'out\'][\'post\'] = self.dst.numpydoc.get_raw_not_managed(self.docs[\'in\'][\'raw\'])\n            elif \'post\' not in self.docs[\'out\'] or self.docs[\'out\'][\'post\'] is None:\n                self.docs[\'out\'][\'post\'] = \'\'\n\n    def _set_raw_params(self, sep):\n        """"""Set the output raw parameters section\n\n        :param sep: the separator of current style\n\n        """"""\n        raw = \'\\n\'\n        if self.dst.style[\'out\'] == \'numpydoc\':\n            spaces = \' \' * 4\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + spaces +\\\n                                                    l.lstrip() if i > 0 else\\\n                                                    l for i, l in enumerate(s.splitlines())])\n            raw += self.dst.numpydoc.get_key_section_header(\'param\', self.docs[\'out\'][\'spaces\'])\n            for p in self.docs[\'out\'][\'params\']:\n                raw += self.docs[\'out\'][\'spaces\'] + p[0] + \' :\'\n                if p[2] is not None and len(p[2]) > 0:\n                    raw += \' \' + p[2]\n                raw += \'\\n\'\n                raw += self.docs[\'out\'][\'spaces\'] + spaces + with_space(p[1]).strip()\n                if len(p) > 2:\n                    if \'default\' not in p[1].lower() and len(p) > 3 and p[3] is not None:\n                        raw += \' (Default value = \' + str(p[3]) + \')\'\n                raw += \'\\n\'\n        elif self.dst.style[\'out\'] == \'google\':\n            spaces = \' \' * 2\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] +\\\n                                                    l.lstrip() if i > 0 else\\\n                                                    l for i, l in enumerate(s.splitlines())])\n            raw += self.dst.googledoc.get_key_section_header(\'param\', self.docs[\'out\'][\'spaces\'])\n            for p in self.docs[\'out\'][\'params\']:\n                raw += self.docs[\'out\'][\'spaces\'] + spaces + p[0]\n                if p[2] is not None and len(p[2]) > 0:\n                    raw += \'(\' + p[2]\n                    if len(p) > 3 and p[3] is not None:\n                        raw += \', optional\'\n                    raw += \')\'\n                raw += \': \' + with_space(p[1]).strip()\n                if len(p) > 2:\n                    if \'default\' not in p[1].lower() and len(p) > 3 and p[3] is not None:\n                        raw += \' (Default value = \' + str(p[3]) + \')\'\n                raw += \'\\n\'\n        elif self.dst.style[\'out\'] == \'groups\':\n            pass\n        else:\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + l\\\n                                                    if i > 0 else l for i, l in enumerate(s.splitlines())])\n            if len(self.docs[\'out\'][\'params\']):\n                for p in self.docs[\'out\'][\'params\']:\n                    raw += self.docs[\'out\'][\'spaces\'] + self.dst.get_key(\'param\', \'out\') + \' \' + p[0] + sep + with_space(p[1]).strip()\n                    if len(p) > 2:\n                        if \'default\' not in p[1].lower() and len(p) > 3 and p[3] is not None:\n                            raw += \' (Default value = \' + str(p[3]) + \')\'\n                        if p[2] is not None and len(p[2]) > 0:\n                            raw += \'\\n\'\n                            raw += self.docs[\'out\'][\'spaces\'] + self.dst.get_key(\'type\', \'out\') + \' \' + p[0] + sep + p[2]\n                        raw += \'\\n\'\n                    else:\n                        raw += \'\\n\'\n        return raw\n\n    def _set_raw_raise(self, sep):\n        """"""Set the output raw exception section\n\n        :param sep: the separator of current style\n\n        """"""\n        raw = \'\'\n        if self.dst.style[\'out\'] == \'numpydoc\':\n            if \'raise\' not in self.dst.numpydoc.get_excluded_sections():\n                raw += \'\\n\'\n                if \'raise\' in self.dst.numpydoc.get_mandatory_sections() or \\\n                        (self.docs[\'out\'][\'raises\'] and \'raise\' in self.dst.numpydoc.get_optional_sections()):\n                    spaces = \' \' * 4\n                    with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + spaces + l.lstrip() if i > 0 else l for i, l in enumerate(s.splitlines())])\n                    raw += self.dst.numpydoc.get_key_section_header(\'raise\', self.docs[\'out\'][\'spaces\'])\n                    if len(self.docs[\'out\'][\'raises\']):\n                        for p in self.docs[\'out\'][\'raises\']:\n                            raw += self.docs[\'out\'][\'spaces\'] + p[0] + \'\\n\'\n                            raw += self.docs[\'out\'][\'spaces\'] + spaces + with_space(p[1]).strip() + \'\\n\'\n                    raw += \'\\n\'\n        elif self.dst.style[\'out\'] == \'google\':\n            if \'raise\' not in self.dst.googledoc.get_excluded_sections():\n                raw += \'\\n\'\n                if \'raise\' in self.dst.googledoc.get_mandatory_sections() or \\\n                        (self.docs[\'out\'][\'raises\'] and \'raise\' in self.dst.googledoc.get_optional_sections()):\n                    spaces = \' \' * 2\n                    with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + spaces + \\\n                                                            l.lstrip() if i > 0 else \\\n                                                            l for i, l in enumerate(s.splitlines())])\n                    raw += self.dst.googledoc.get_key_section_header(\'raise\', self.docs[\'out\'][\'spaces\'])\n                    if len(self.docs[\'out\'][\'raises\']):\n                        for p in self.docs[\'out\'][\'raises\']:\n                            raw += self.docs[\'out\'][\'spaces\'] + spaces\n                            if p[0] is not None:\n                                raw += p[0] + sep\n                            if p[1]:\n                                raw += p[1].strip()\n                            raw += \'\\n\'\n                    raw += \'\\n\'\n        elif self.dst.style[\'out\'] == \'groups\':\n            pass\n        else:\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + l if i > 0 else l for i, l in enumerate(s.splitlines())])\n            if len(self.docs[\'out\'][\'raises\']):\n                if not self.docs[\'out\'][\'params\'] and not self.docs[\'out\'][\'return\']:\n                    raw += \'\\n\'\n                for p in self.docs[\'out\'][\'raises\']:\n                    raw += self.docs[\'out\'][\'spaces\'] + self.dst.get_key(\'raise\', \'out\') + \' \'\n                    if p[0] is not None:\n                        raw += p[0] + sep\n                    if p[1]:\n                        raw += with_space(p[1]).strip()\n                    raw += \'\\n\'\n            raw += \'\\n\'\n        return raw\n\n    def _set_raw_return(self, sep):\n        """"""Set the output raw return section\n\n        :param sep: the separator of current style\n\n        """"""\n        raw = \'\'\n        if self.dst.style[\'out\'] == \'numpydoc\':\n            raw += \'\\n\'\n            spaces = \' \' * 4\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + spaces + l.lstrip() if i > 0 else l for i, l in enumerate(s.splitlines())])\n            raw += self.dst.numpydoc.get_key_section_header(\'return\', self.docs[\'out\'][\'spaces\'])\n            if self.docs[\'out\'][\'rtype\']:\n                rtype = self.docs[\'out\'][\'rtype\']\n            else:\n                rtype = \'type\'\n            # case of several returns\n            if type(self.docs[\'out\'][\'return\']) is list:\n                for ret_elem in self.docs[\'out\'][\'return\']:\n                    # if tuple (name, desc, rtype) else string desc\n                    if type(ret_elem) is tuple and len(ret_elem) == 3:\n                        rtype = ret_elem[2]\n                        if rtype is None:\n                            rtype = \'\'\n                        raw += self.docs[\'out\'][\'spaces\']\n                        if ret_elem[0]:\n                            raw += ret_elem[0] + \' : \'\n                        raw += rtype + \'\\n\' + self.docs[\'out\'][\'spaces\'] + spaces + with_space(ret_elem[1]).strip() + \'\\n\'\n                    else:\n                        # There can be a problem\n                        raw += self.docs[\'out\'][\'spaces\'] + rtype + \'\\n\'\n                        raw += self.docs[\'out\'][\'spaces\'] + spaces + with_space(str(ret_elem)).strip() + \'\\n\'\n            # case of a unique return\n            elif self.docs[\'out\'][\'return\'] is not None:\n                raw += self.docs[\'out\'][\'spaces\'] + rtype\n                raw += \'\\n\' + self.docs[\'out\'][\'spaces\'] + spaces + with_space(self.docs[\'out\'][\'return\']).strip() + \'\\n\'\n        elif self.dst.style[\'out\'] == \'google\':\n            raw += \'\\n\'\n            spaces = \' \' * 2\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + spaces +\\\n                                                    l.lstrip() if i > 0 else\\\n                                                    l for i, l in enumerate(s.splitlines())])\n            raw += self.dst.googledoc.get_key_section_header(\'return\', self.docs[\'out\'][\'spaces\'])\n            if self.docs[\'out\'][\'rtype\']:\n                rtype = self.docs[\'out\'][\'rtype\']\n            else:\n                rtype = None\n            # case of several returns\n            if type(self.docs[\'out\'][\'return\']) is list:\n                for ret_elem in self.docs[\'out\'][\'return\']:\n                    # if tuple (name=None, desc, rtype) else string desc\n                    if type(ret_elem) is tuple and len(ret_elem) == 3:\n                        rtype = ret_elem[2]\n                        if rtype is None:\n                            rtype = \'\'\n                        raw += self.docs[\'out\'][\'spaces\'] + spaces\n                        raw += rtype + \': \' + with_space(ret_elem[1]).strip() + \'\\n\'\n                    else:\n                        # There can be a problem\n                        if rtype:\n                            raw += self.docs[\'out\'][\'spaces\'] + spaces + rtype + \': \'\n                            raw += with_space(str(ret_elem)).strip() + \'\\n\'\n                        else:\n                            raw += self.docs[\'out\'][\'spaces\'] + spaces + with_space(str(ret_elem)).strip() + \'\\n\'\n            # case of a unique return\n            elif self.docs[\'out\'][\'return\'] is not None:\n                if rtype:\n                    raw += self.docs[\'out\'][\'spaces\'] + spaces + rtype + \': \'\n                    raw += with_space(self.docs[\'out\'][\'return\']).strip() + \'\\n\'\n                else:\n                    raw += self.docs[\'out\'][\'spaces\'] + spaces + with_space(self.docs[\'out\'][\'return\']).strip() + \'\\n\'\n        elif self.dst.style[\'out\'] == \'groups\':\n            pass\n        else:\n            with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + l if i > 0 else l for i, l in enumerate(s.splitlines())])\n            if self.docs[\'out\'][\'return\']:\n                if not self.docs[\'out\'][\'params\']:\n                    raw += \'\\n\'\n                raw += self.docs[\'out\'][\'spaces\'] + self.dst.get_key(\'return\', \'out\') + sep + with_space(self.docs[\'out\'][\'return\'].rstrip()).strip() + \'\\n\'\n            if self.docs[\'out\'][\'rtype\']:\n                if not self.docs[\'out\'][\'params\']:\n                    raw += \'\\n\'\n                raw += self.docs[\'out\'][\'spaces\'] + self.dst.get_key(\'rtype\', \'out\') + sep + self.docs[\'out\'][\'rtype\'].rstrip() + \'\\n\'\n        return raw\n\n    def _set_raw(self):\n        """"""Sets the output raw docstring""""""\n        sep = self.dst.get_sep(target=\'out\')\n        sep = sep + \' \' if sep != \' \' else sep\n        with_space = lambda s: \'\\n\'.join([self.docs[\'out\'][\'spaces\'] + l if i > 0 else l for i, l in enumerate(s.splitlines())])\n\n        # sets the description section\n        raw = self.docs[\'out\'][\'spaces\'] + self.quotes\n        desc = self.docs[\'out\'][\'desc\'].strip()\n        if not desc or not desc.count(\'\\n\'):\n            if not self.docs[\'out\'][\'params\'] and not self.docs[\'out\'][\'return\'] and not self.docs[\'out\'][\'rtype\'] and not self.docs[\'out\'][\'raises\']:\n                raw += desc if desc else self.trailing_space\n                raw += self.quotes\n                self.docs[\'out\'][\'raw\'] = raw.rstrip()\n                return\n        if not self.first_line:\n            raw += \'\\n\' + self.docs[\'out\'][\'spaces\']\n        raw += with_space(self.docs[\'out\'][\'desc\']).strip() + \'\\n\'\n\n        # sets the parameters section\n        raw += self._set_raw_params(sep)\n\n        # sets the return section\n        raw += self._set_raw_return(sep)\n\n        # sets the raises section\n        raw += self._set_raw_raise(sep)\n\n        # sets post specific if any\n        if \'post\' in self.docs[\'out\']:\n            raw += self.docs[\'out\'][\'spaces\'] + with_space(self.docs[\'out\'][\'post\']).strip() + \'\\n\'\n\n        # sets the doctests if any\n        if \'doctests\' in self.docs[\'out\']:\n            raw += self.docs[\'out\'][\'spaces\'] + with_space(self.docs[\'out\'][\'doctests\']).strip() + \'\\n\'\n\n        if raw.count(self.quotes) == 1:\n            raw += self.docs[\'out\'][\'spaces\'] + self.quotes\n        self.docs[\'out\'][\'raw\'] = raw.rstrip()\n\n    def generate_docs(self):\n        """"""Generates the output docstring""""""\n        if self.dst.style[\'out\'] == \'numpydoc\' and self.dst.numpydoc.first_line is not None:\n            self.first_line = self.dst.numpydoc.first_line\n        self._set_desc()\n        self._set_params()\n        self._set_return()\n        self._set_raises()\n        self._set_other()\n        self._set_raw()\n        self.generated_docs = True\n\n    def get_raw_docs(self):\n        """"""Generates raw docstring\n\n        :returns: the raw docstring\n\n        """"""\n        if not self.generated_docs:\n            self.generate_docs()\n        return self.docs[\'out\'][\'raw\']\n\n\nif __name__ == ""__main__"":\n    help(DocString)\n'"
pyment/pyment.py,0,"b'# -*- coding: utf-8 -*-\n\nimport os\nimport re\nimport difflib\nimport platform\nimport sys\n\nfrom .docstring import DocString\n\n__author__ = ""A. Daouzli""\n__copyright__ = ""Copyright 2012-2018""\n__licence__ = ""GPL3""\n__version__ = ""0.3.3""\n__maintainer__ = ""A. Daouzli""\n\n#TODO:\n# -generate a return if return is used with argument in element\n# -generate raises if raises are used\n# -generate diagnosis/statistics\n# -parse classes public methods and list them in class docstring\n# -allow excluding files from processing\n# -add managing a unique patch\n# -manage docstrings templates\n# -manage c/c++ sources\n# -accept archives containing source files\n# -dev a server that take sources and send back patches\n\n\nclass PyComment(object):\n    """"""This class allow to manage several python scripts docstrings.\n    It is used to parse and rewrite in a Pythonic way all the functions\', methods\' and classes\' docstrings.\n    The changes are then provided in a patch file.\n\n    """"""\n    def __init__(self, input_file, input_style=None, output_style=\'reST\', quotes=\'""""""\', first_line=True,\n                 convert_only=False, config_file=None, ignore_private=False, **kwargs):\n        """"""Sets the configuration including the source to proceed and options.\n\n        :param input_file: path name (file or folder)\n        :param input_style: the type of doctrings format of the output. By default, it will\n          autodetect the format for each docstring.\n        :param output_style: the docstring docstyle to generate (\'javadoc\', \'reST\', \'groups\', \'numpydoc\', \'google\').\n        :param quotes: the type of quotes to use for output: \' \' \' or "" "" "" (default "" "" "")\n        :param first_line: indicate if description should start on first or second line. By default it is True\n        :type first_line: boolean\n        :param convert_only: if set only existing docstring will be converted. No missing docstring will be created.\n        :param config_file: if given configuration file for Pyment\n        :param ignore_private: don\'t proceed the private methods/functions starting with __ (two underscores)\n\n        """"""\n        self.file_type = \'.py\'\n        self.first_line = first_line\n        self.filename_list = []\n        self.input_file = input_file\n        self.input_lines = []  # Need to remember the file when reading off stdin\n        self.input_style = input_style\n        self.output_style = output_style\n        self.doc_index = -1\n        self.file_index = 0\n        self.docs_list = []\n        self.parsed = False\n        self.quotes = quotes\n        self.convert_only = convert_only\n        self.config_file = config_file\n        self.ignore_private = ignore_private\n        self.kwargs = kwargs\n\n    def _parse(self):\n        """"""Parses the input file\'s content and generates a list of its elements/docstrings.\n\n        :returns: the list of elements\n\n        """"""\n        #TODO manage decorators\n        #TODO manage default params with strings escaping chars as (, ), \', \', #, ...\n        #TODO manage elements ending with comments like: def func(param): # blabla\n        elem_list = []\n        reading_element = None\n        reading_docs = None\n        waiting_docs = False\n        elem = \'\'\n        raw = \'\'\n        start = 0\n        end = 0\n\n        try:\n            if self.input_file == \'-\':\n                fd = sys.stdin\n            else:\n                fd = open(self.input_file)\n\n            self.input_lines = fd.readlines()\n\n            if self.input_file != \'-\':\n                fd.close()\n\n        except IOError:\n            msg = BaseException(\'Failed to open file ""\' + self.input_file + \'"". Please provide a valid file.\')\n            raise msg\n        for i, ln in enumerate(self.input_lines):\n            l = ln.strip()\n            if reading_element:\n                elem += l\n                if l.endswith(\':\'):\n                    reading_element = \'end\'\n            elif (l.startswith(\'def \') or l.startswith(\'class \')) and not reading_docs:\n                if self.ignore_private and l[l.find(\' \'):].strip().startswith(""__""):\n                    continue\n                reading_element = \'start\'\n                elem = l\n                m = re.match(r\'^(\\s*)[dc]{1}\', ln)\n                if m is not None and m.group(1) is not None:\n                    spaces = m.group(1)\n                else:\n                    spaces = \'\'\n                if re.search(r\'\'\':(|\\s*#[^\'""]*)$\'\'\', l):\n                    reading_element = \'end\'\n            if reading_element == \'end\':\n                reading_element = None\n                # if currently reading an element content\n                waiting_docs = True\n                # *** Creates the DocString object ***\n                e = DocString(elem.replace(\'\\n\', \' \'), spaces, quotes=self.quotes,\n                              input_style=self.input_style,\n                              output_style=self.output_style,\n                              first_line=self.first_line,\n                              **self.kwargs)\n                elem_list.append({\'docs\': e, \'location\': (-i, -i)})\n            else:\n                if waiting_docs and (\'""""""\' in l or ""\'\'\'"" in l):\n                    # start of docstring bloc\n                    if not reading_docs:\n                        start = i\n                        # determine which delimiter\n                        idx_c = l.find(\'""""""\')\n                        idx_dc = l.find(""\'\'\'"")\n                        lim = \'""""""\'\n                        if idx_c >= 0 and idx_dc >= 0:\n                            if idx_c < idx_dc:\n                                lim = \'""""""\'\n                            else:\n                                lim = ""\'\'\'""\n                        elif idx_c < 0:\n                            lim = ""\'\'\'""\n                        reading_docs = lim\n                        raw = ln\n                        # one line docstring\n                        if l.count(lim) == 2:\n                            end = i\n                            elem_list[-1][\'docs\'].parse_docs(raw)\n                            elem_list[-1][\'location\'] = (start, end)\n                            reading_docs = None\n                            waiting_docs = False\n                            reading_element = False\n                            raw = \'\'\n                    # end of docstring bloc\n                    elif waiting_docs and lim in l:\n                        end = i\n                        raw += ln\n                        elem_list[-1][\'docs\'].parse_docs(raw)\n                        elem_list[-1][\'location\'] = (start, end)\n                        reading_docs = None\n                        waiting_docs = False\n                        reading_element = False\n                        raw = \'\'\n                    # inside a docstring bloc\n                    elif waiting_docs:\n                        raw += ln\n                # no docstring found for current element\n                elif waiting_docs and l != \'\' and reading_docs is None:\n                    waiting_docs = False\n                else:\n                    if reading_docs is not None:\n                        raw += ln\n        if self.convert_only:\n            i = 0\n            while i < len(elem_list):\n                if elem_list[i][\'docs\'].get_input_docstring() is None:\n                    elem_list.pop(i)\n                else:\n                    i += 1\n        self.docs_list = elem_list\n\n        self.parsed = True\n        return elem_list\n\n    def docs_init_to_class(self):\n        """"""If found a __init__ method\'s docstring and the class\n        without any docstring, so set the class docstring with __init__one,\n        and let __init__ without docstring.\n\n        :returns: True if done\n        :rtype: boolean\n\n        """"""\n        result = False\n        if not self.parsed:\n            self._parse()\n        einit = []\n        eclass = []\n        for e in self.docs_list:\n            if len(eclass) == len(einit) + 1 and e[\'docs\'].element[\'name\'] == \'__init__\':\n                einit.append(e)\n            elif not eclass and e[\'docs\'].element[\'type\'] == \'class\':\n                eclass.append(e)\n        for c, i in zip(eclass, einit):\n            start, _ = c[\'location\']\n            if start < 0:\n                start, _ = i[\'location\']\n                if start > 0:\n                    result = True\n                    cspaces = c[\'docs\'].get_spaces()\n                    ispaces = i[\'docs\'].get_spaces()\n                    c[\'docs\'].set_spaces(ispaces)\n                    i[\'docs\'].set_spaces(cspaces)\n                    c[\'docs\'].generate_docs()\n                    i[\'docs\'].generate_docs()\n                    c[\'docs\'], i[\'docs\'] = i[\'docs\'], c[\'docs\']\n        return result\n\n    def get_output_docs(self):\n        """"""Return the output docstrings once formatted\n\n        :returns: the formatted docstrings\n        :rtype: list\n\n        """"""\n        if not self.parsed:\n            self._parse()\n        lst = []\n        for e in self.docs_list:\n            lst.append(e[\'docs\'].get_raw_docs())\n        return lst\n\n    def compute_before_after(self):\n        """"""Compute the list of lines before and after the proposed docstring changes.\n\n        :return: tuple of before,after where each is a list of lines of python code.\n        """"""\n        if not self.parsed:\n            self._parse()\n        list_from = self.input_lines\n        list_to = []\n        last = 0\n        for e in self.docs_list:\n            start, end = e[\'location\']\n            if start <= 0:\n                start, end = -start, -end\n                list_to.extend(list_from[last:start + 1])\n            else:\n                list_to.extend(list_from[last:start])\n            docs = e[\'docs\'].get_raw_docs()\n            list_docs = [l + \'\\n\' for l in docs.splitlines()]\n            list_to.extend(list_docs)\n            last = end + 1\n        if last < len(list_from):\n            list_to.extend(list_from[last:])\n\n        return list_from, list_to\n\n    def diff(self, source_path=\'\', target_path=\'\', which=-1):\n        """"""Build the diff between original docstring and proposed docstring.\n\n        :type which: int\n          -> -1 means all the dosctrings of the file\n          -> >=0 means the index of the docstring to proceed (Default value = -1)\n        :param source_path:  (Default value = \'\')\n        :param target_path:  (Default value = \'\')\n        :returns: the resulted diff\n        :rtype: List[str]\n        """"""\n        list_from, list_to = self.compute_before_after()\n\n        if source_path.startswith(os.sep):\n            source_path = source_path[1:]\n        if source_path and not source_path.endswith(os.sep):\n            source_path += os.sep\n        if target_path.startswith(os.sep):\n            target_path = target_path[1:]\n        if target_path and not target_path.endswith(os.sep):\n            target_path += os.sep\n\n        fromfile = \'a/\' + source_path + os.path.basename(self.input_file)\n        tofile = \'b/\' + target_path + os.path.basename(self.input_file)\n        diff_list = difflib.unified_diff(list_from, list_to, fromfile, tofile)\n        return [d for d in diff_list]\n\n    def get_patch_lines(self, source_path, target_path):\n        """"""Return the diff between source_path and target_path\n\n        :param source_path: name of the original file (Default value = \'\')\n        :param target_path: name of the final file (Default value = \'\')\n\n        :return: the diff as a list of \\n terminated lines\n        :rtype: List[str]\n        """"""\n        diff = self.diff(source_path, target_path)\n\n        return [""# Patch generated by Pyment v{0}\\n\\n"".format(__version__)] + diff\n\n    def write_patch_file(self, patch_file, lines_to_write):\n        """"""Write lines_to_write to a the file called patch_file\n\n        :param patch_file: file name of the patch to generate\n        :param lines_to_write: lines to write to the file - they should be \\n terminated\n        :type lines_to_write: list[str]\n\n        :return: None\n        """"""\n        with open(patch_file, \'w\') as f:\n            f.writelines(lines_to_write)\n\n    def overwrite_source_file(self, lines_to_write):\n        """"""overwrite the file with line_to_write\n\n        :param lines_to_write: lines to write to the file - they should be \\n terminated\n        :type lines_to_write: List[str]\n\n        :return: None\n        """"""\n        tmp_filename = \'{0}.writing\'.format(self.input_file)\n        ok = False\n        try:\n            with open(tmp_filename, \'w\') as fh:\n                fh.writelines(lines_to_write)\n            ok = True\n        finally:\n            if ok:\n                if platform.system() == \'Windows\':\n                    self._windows_rename(tmp_filename)\n                else:\n                    os.rename(tmp_filename, self.input_file)\n            else:\n                os.unlink(tmp_filename)\n\n    def _windows_rename(self, tmp_filename):\n        """""" Workaround the fact that os.rename raises an OSError on Windows\n        \n        :param tmp_filename: The file to rename\n    \n        """"""\n\n        os.remove(self.input_file) if os.path.isfile(self.input_file) else None\n        os.rename(tmp_filename, self.input_file)\n\n    def proceed(self):\n        """"""Parses the input file and generates/converts the docstrings.\n\n        :return: the list of docstrings\n        :rtype: list of dictionaries\n\n        """"""\n        self._parse()\n        for e in self.docs_list:\n            e[\'docs\'].generate_docs()\n        return self.docs_list\n'"
pyment/pymentapp.py,0,"b'#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport glob\nimport argparse\nimport os\nimport sys\n\nfrom pyment import PyComment\nfrom pyment import __version__, __copyright__, __author__, __licence__\n\n\nMAX_DEPTH_RECUR = 50\n\'\'\' The maximum depth to reach while recursively exploring sub folders\'\'\'\n\n\ndef get_files_from_dir(path, recursive=True, depth=0, file_ext=\'.py\'):\n    """"""Retrieve the list of files from a folder.\n\n    @param path: file or directory where to search files\n    @param recursive: if True will search also sub-directories\n    @param depth: if explore recursively, the depth of sub directories to follow\n    @param file_ext: the files extension to get. Default is \'.py\'\n    @return: the file list retrieved. if the input is a file then a one element list.\n\n    """"""\n    file_list = []\n    if os.path.isfile(path) or path == \'-\':\n        return [path]\n    if path[-1] != os.sep:\n        path = path + os.sep\n    for f in glob.glob(path + ""*""):\n        if os.path.isdir(f):\n            if depth < MAX_DEPTH_RECUR:  # avoid infinite recursive loop\n                file_list.extend(get_files_from_dir(f, recursive, depth + 1))\n            else:\n                continue\n        elif f.endswith(file_ext):\n            file_list.append(f)\n    return file_list\n\n\ndef get_config(config_file):\n    """"""Get the configuration from a file.\n\n    @param config_file: the configuration file\n    @return: the configuration\n    @rtype: dict\n\n    """"""\n    config = {}\n    tobool = lambda s: True if s.lower() == \'true\' else False\n    if config_file:\n        try:\n            f = open(config_file, \'r\')\n        except:\n            print (""Unable to open configuration file \'{0}\'"".format(config_file))\n        else:\n            for line in f.readlines():\n                if len(line.strip()):\n                    key, value = line.split(""="", 1)\n                    key, value = key.strip(), value.strip()\n                    if key in [\'init2class\', \'first_line\', \'convert_only\']:\n                        value = tobool(value)\n                    if key == \'indent\':\n                        value = int(value)\n                    config[key] = value\n    return config\n\n\ndef run(source, files=[], input_style=\'auto\', output_style=\'reST\', first_line=True, quotes=\'""""""\',\n        init2class=False, convert=False, config_file=None, ignore_private=False, overwrite=False):\n    if input_style == \'auto\':\n        input_style = None\n\n    config = get_config(config_file)\n    if \'init2class\' in config:\n        init2class = config.pop(\'init2class\')\n    if \'convert_only\' in config:\n        convert = config.pop(\'convert_only\')\n    if \'quotes\' in config:\n        quotes = config.pop(\'quotes\')\n    if \'input_style\' in config:\n        input_style = config.pop(\'input_style\')\n    if \'output_style\' in config:\n        output_style = config.pop(\'output_style\')\n    if \'first_line\' in config:\n        first_line = config.pop(\'first_line\')\n    for f in files:\n        if os.path.isdir(source):\n            path = source + os.sep + os.path.relpath(os.path.abspath(f), os.path.abspath(source))\n            path = path[:-len(os.path.basename(f))]\n        else:\n            path = \'\'\n        c = PyComment(f, quotes=quotes,\n                      input_style=input_style,\n                      output_style=output_style,\n                      first_line=first_line,\n                      ignore_private=ignore_private,\n                      convert_only=convert,\n                      **config)\n        c.proceed()\n        if init2class:\n            c.docs_init_to_class()\n\n        if overwrite:\n            list_from, list_to = c.compute_before_after()\n            lines_to_write = list_to\n        else:\n            lines_to_write = c.get_patch_lines(path, path)\n\n        if f == \'-\':\n            sys.stdout.writelines(lines_to_write)\n        else:\n            if overwrite:\n                if list_from != list_to:\n                    c.overwrite_source_file(lines_to_write)\n            else:\n                c.write_patch_file(os.path.basename(f) + "".patch"", lines_to_write)\n\n\ndef main():\n    desc = \'Pyment v{0} - {1} - {2} - {3}\'.format(__version__, __copyright__, __author__, __licence__)\n    parser = argparse.ArgumentParser(description=\'Generates patches after (re)writing docstrings.\')\n    parser.add_argument(\'path\', type=str,\n                        help=\'python file or folder containing python files to proceed (explore also sub-folders). Use ""-"" to read from stdin and write to stdout\')\n    parser.add_argument(\'-i\', \'--input\', metavar=\'style\', default=\'auto\',\n                        dest=\'input\', help=\'Input docstring style in [""javadoc"", ""reST"", ""numpydoc"", ""google"", ""auto""] (default autodetected)\')\n    parser.add_argument(\'-o\', \'--output\', metavar=\'style\', default=""reST"",\n                        dest=\'output\', help=\'Output docstring style in [""javadoc"", ""reST"", ""numpydoc"", ""google""] (default ""reST"")\')\n    parser.add_argument(\'-q\', \'--quotes\', metavar=\'quotes\', default=\'""""""\',\n                        dest=\'quotes\', help=\'Type of docstring delimiter quotes: \\\'\\\'\\\' or \\""\\""\\"" (default \\""\\""\\""). Note that you may escape the characters using \\\\ like \\\\\\\'\\\\\\\'\\\\\\\', or surround it with the opposite quotes like \\""\\\'\\\'\\\'\\""\')\n    parser.add_argument(\'-f\', \'--first-line\', metavar=\'status\', default=""True"",\n                        dest=\'first_line\', help=\'Does the comment starts on the first line after the quotes (default ""True"")\')\n    parser.add_argument(\'-t\', \'--convert\', action=""store_true"", default=False,\n                        help=""Existing docstrings will be converted but won\'t create missing ones"")\n    parser.add_argument(\'-c\', \'--config-file\', metavar=\'config\', default="""",\n                        dest=\'config_file\', help=\'Get a Pyment configuration from a file. Note that the config values will overload the command line ones.\')\n    parser.add_argument(\'-d\', \'--init2class\', help=\'If no docstring to class, then move the __init__ one\',\n                        action=""store_true"")\n    parser.add_argument(\'-p\', \'--ignore-private\', metavar=\'status\', default=""True"",\n                        dest=\'ignore_private\', help=\'Don\\\'t proceed the private methods/functions starting with __ (two underscores) (default ""True"")\')\n    parser.add_argument(\'-v\', \'--version\', action=\'version\',\n                        version=desc)\n    parser.add_argument(\'-w\', \'--write\', action=\'store_true\', dest=\'overwrite\',\n                        default=False, help=""Don\'t write patches. Overwrite files instead. If used with path \'-\' won\\\'t overwrite but write to stdout the new content instead of a patch/."")\n    # parser.add_argument(\'-c\', \'--config\', metavar=\'config_file\',\n    #                   dest=\'config\', help=\'Configuration file\')\n\n    args = parser.parse_args()\n    source = args.path\n\n    files = get_files_from_dir(source)\n    if not files:\n        msg = BaseException(""No files were found matching {0}"".format(args.path))\n        raise msg\n    if not args.config_file:\n        config_file = \'\'\n    else:\n        config_file = args.config_file\n\n    tobool = lambda s: True if s.lower() == \'true\' else False\n    run(source, files, args.input, args.output,\n        tobool(args.first_line), args.quotes,\n        args.init2class, args.convert, config_file,\n        tobool(args.ignore_private), overwrite=args.overwrite)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
tests/__init__.py,0,b'import os\nimport unittest\n\ncurrent_dir = os.path.dirname(__file__)\ntest_all = unittest.TestLoader().discover(current_dir)\n'
tests/docs_already_google.py,0,"b'def func1(param1):\n    """"""Function 1\n    with 1 param\n\n    Args:\n      param1(type): 1st parameter\n\n    Returns:\n      None\n\n    Raises:\n      Exception: an exception\n\n    """"""\n    return None\n\n\ndef func2(param1, param2):\n    """"""Function 2\n    with 2 params\n\n    Args:\n      param1(type): 1st parameter\n      param2: 2nd parameter\n\n    Returns:\n\n    """"""\n    pass\n\n\n'"
tests/docs_already_javadoc.py,0,"b'def func1(param1):\n    """"""Function 1\n    with 1 param\n\n    @param param1: 1st parameter\n    @type param1: type\n    @return: None\n\n    """"""\n    return None\n\n\ndef func2(param1, param2):\n    """"""Function 2\n    with 2 params\n\n    @param param1: 1st parameter\n    @type param1: type\n    @param param2: 2nd parameter\n\n    """"""\n    pass\n\n\n'"
tests/docs_already_numpydoc.py,0,"b'def func1(param1):\n    """"""Function 1\n    with 1 param\n\n    Parameters\n    ----------\n    param1 : type\n        1st parameter\n\n    Returns\n    -------\n    string\n        a message\n\n    Raises\n    ------\n    KeyError\n        when a key error\n    """"""\n    return ""huh""\n\n\ndef func2(param1, param2):\n    """"""Function 2\n    with 2 params\n\n    Parameters\n    ----------\n    param1 : type\n        1st parameter\n    param2 :\n        2nd parameter\n\n    Returns\n    -------\n\n    """"""\n    pass\n\n\n'"
tests/docs_already_reST.py,0,"b'def func1(param1):\n    """"""Function 1\n    with 1 param\n\n    :param param1: 1st parameter\n    :type param1: type\n    :returns: None\n\n    """"""\n    return None\n\n\ndef func2(param1, param2):\n    """"""Function 2\n    with 2 params\n\n    :param param1: 1st parameter\n    :type param1: type\n    :param param2: 2nd parameter\n\n    """"""\n    pass\n\n\n'"
tests/free_cases.py,0,"b'def func1():\n    """"""Function 1 no parameter""""""\n    pass\n\n'"
tests/issue10.py,0,"b""# -*- coding: utf-8 -*-\n\n__version__ = '1.3.1'\n# $Source$\n\n#Some commentary\n\n\nfrom .mod1 import *\n#import mod2\nfrom . import mod3, mod4\n\n\ndef init_test():\n    '''\n    Only working when in WinPython root directory.\n\n    Returns:\n    maske, data0, data1, no_motion, motion\n    '''\n    maske = read_mask('./MRR/Testdaten/55_mask.bmp')\n    display(maske)\n    data0 = read_dicom_set('./MRR/Testdaten/188_13-12-10_56_1',\n                               unwrap=True, mask=maske, verbose=False)\n    data1 = read_dicom_set('./MRR/Testdaten/188_13-12-10_54_1',\n                               unwrap=True, mask=maske, verbose=False)\n    no_motion = mean(data0, axis=0)\n    motion = mean(data1, axis=0)\n    return maske , data0, data1, no_motion, motion"""
tests/issue15.py,0,"b'def func(param1=True, param2=\'default val\'):\n    \'\'\'Description of func with docstring groups style.\n\n    Params:\n        param1 - descr of param1 that has True for default value.\n        param2 - descr of param2\n\n    Returns:\n        some value\n\n    Raises:\n        keyError: raises key exception\n        TypeError: raises type exception\n\n    \'\'\'\n    pass\n\nclass A:\n    def method(self, param1, param2=None):\n        pass\n\nif __name__ == ""__main__"":\n    import os\n    from pyment import PyComment\n\n    filename = __file__\n    print filename\n\n    c = PyComment(filename)\n    c.proceed()\n    c.diff_to_file(os.path.basename(filename) + "".patch"")\n    for s in c.get_output_docs():\n        print(s)\n\n'"
tests/issue22.py,0,"b'class Issue22(object):\n    """"""Test class for issue 22""""""\n\n    def __init__(self, param1):\n        pass\n'"
tests/issue30.py,0,"b""def hello_world(a=22, b='hello'):\n  return 42"""
tests/issue32.py,0,"b""def hello_world(a=22, b='hello'):\n  return 42"""
tests/issue34.py,0,"b'def func(a, b):\n    """"""desc\n\n    :param a: \n    :param b: \n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param a: \n    :type a: \n    :param b: \n    :type b: \n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param a: \n    :type a: str\n    :param b: \n    :type b: str\n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param a: \n    :type a: str\n    :param b: \n    :type b: \n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param a: desc a\n    :param b: \n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param b: \n    :param a: desc a\n\n    """"""\n    pass\n\ndef func(a, b):\n    """"""desc\n\n    :param a: \n    :param b: desc b\n\n    """"""\n    pass\n\ndef func(a, b, c):\n    """"""desc\n\n    :param a: \n    :param b: \n    :param c: \n\n    """"""\n    pass\n\ndef func(a, b, c):\n    """"""desc\n\n    :param a: \n    :param b: desc b\n    :param c: \n\n    """"""\n    pass\n\ndef func(a, b, c):\n    """"""desc\n\n    :param a: desc a\n    :param b: \n    :param c: \n\n    """"""\n    pass\n\ndef func(a, b, c):\n    """"""desc\n\n    :param a: desc a\n    :param b: \n    :param c: desc c\n\n    """"""\n    pass\n\n'"
tests/issue46.py,0,"b'def func1(param1=[1, None, ""hehe""]):\n    pass\n\n\ndef func2(param1=(1, None, ""hehe"")):\n    pass\n\n\ndef func3(param1={0: 1, ""a"": None}):\n    pass\n\n'"
tests/issue47.py,0,"b'def func():\n    """"""Description\n    in two lines\n\n    """"""\n    pass\n\n\n'"
tests/issue49.py,0,"b'def func1(param1):\n    """"""Function to test issue #49\n\n    Parameters\n    ----------\n    param1 : object\n        Description of param1\n\n    Returns\n    -------\n    None\n        Description for return value\n\n    Raises\n    ------\n    AssertionError\n        Raises an error if run\n\n    \n    """"""\n    assert False\n'"
tests/issue51.py,0,"b'def foo():\n    """"""Bar bar bar.\n\n    Args:\n\n    Returns:\n\n    Raises:\n      test\n\n    """"""\n    pass\n'"
tests/issue58.py,0,"b'def func(param): # some comment\n    """"""some docstring""""""\n    pass\n\n\n'"
tests/issue9.py,0,"b'def func(p):\n    """"""\n    :param p: blabla\n    :type p: ptype\n    :return: smthg\n    :rtype: ret type\n    """"""\n    pass\n'"
tests/origin_test.py,0,"b'#!/usr/bin/python\n\nimport unittest\n\ndef my_func_full(first, second=None, third=""value""):\n    """"""This is a description of a method.\n    It is on several lines.\n    Several styles exists:\n      -javadoc,\n      -reST,\n      -groups.\n    It uses the javadoc style.\n\n    @param first: the 1st argument.\n    with multiple lines\n    @type first: str\n    @param second: the 2nd argument.\n    @return: the result value\n    @rtype: int\n    @raise KeyError: raises an exception\n\n    """"""\n    print (""this is the code of my full func"")\n\ndef my_func_multiline_elem(first,\n                           second,\n                           third=""""):\n    \'\'\'multiline\'\'\'\n    print (""this has elems in several lines"")\n\ndef my_func_empty_params(first, second=None, third=""value""):\n    print (""this is the code of my empty func"")\n\ndef my_func_empty_no_params():\n    print (""this is the code of my empty func no params"")\n\ndef my_func_desc_lines_params(first, second=None, third=""value""):\n    \'\'\'This is a description but params not described.\n    And a new line!\n    \'\'\'\n    print (""this is the code of my func"")\n\ndef my_func_desc_line_params(first, second=None, third=""value""):\n    \'\'\'This is a description but params not described.\n    \'\'\'\n    print (""this is the code of my func"")\n \ndef my_func_desc_line_no_params():\n    \'\'\'This is a description but no params.\n    \'\'\'\n    print (""this is the code of my func"")\n\n\ndef my_func_groups_style(first, second=None, third=""value""):\n    \'\'\'My desc of groups style.\n\n    Parameters:\n      first: the first param\n      second: the 2nd param\n      third: the 3rd param\n\n    \'\'\'\n    print(""group style!"")\n\n\nclass MyTestClass(object):\n\n    def __init__(self, one_param=None):\n        \'\'\'The init with one param\n\n        @param one_param:\n        \'\'\'\n        self.param = one_param\n        print(""init"")\n\n    @classmethod\n    def my_cls_method(cls):\n        print(""cls method"")\n\n    def my_method_no_param(self):\n        """"""Do something\n        perhaps!\n        """"""\n        print(""or not"")\n\n    def my_method_params_no_docs(self, first, second=None, third=""value""):\n        print(""method params no docs"")\n\n    def my_method_multiline_shift_elem(self, first,\n                                             second,\n                                             third="""",\n                                             **kwargs):\n        \'\'\'there are multilines, shift and kwargs\'\'\'\n        print (""this has elems in several lines"")\n\n    def my_method_full(self, first, second=None, third=""value""):\n        \'\'\'The desctiption of method with 3 params and return value\n        on several lines\n\n        @param first: the 1st param\n        @type first: int\n        @param second: the 2nd param with default at None\n        @type first: tuple\n        @param third: the 3rd param\n        @type third: str\n        @return: the value\n        @rtype: str\n        @raise KeyError: key exception\n\n        \'\'\'\n        print(""method full"")\n        return third\n\n\n'"
tests/params.py,0,"b'def func1():\n    pass\n\n\ndef func2(param1):\n    pass\n\n\ndef func3(param1, param2):\n    pass\n\n\ndef func3(param1, param2, param3):\n    pass\n\n\ndef func4(param1=123):\n    pass\n\n\ndef func5(param1, param2=123):\n    pass\n\n\ndef func6(param1, param2, param3=123):\n    pass\n\n\ndef func7(param1, param2=None, param3=123):\n    pass\n\n\ndef func8(param1=123, param2=+456, param3=""!:@""):\n    pass\n\n\ndef func9(param1=func1(), param2=""stuff""):\n    pass\n\n\ndef func10(param1=func1(), param2=""stuff""):  # comments with (parentheses):\n    pass\n'"
tests/test_app.py,0,"b'# -*- coding: utf-8 -*-\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nimport unittest\n\nimport pyment.pyment\n\n\nclass AppTests(unittest.TestCase):\n    """"""\n    Test pyment as an app in a shell.\n\n    It\'s an integration test.\n    """"""\n\n    # You have to run this as a module when testing so the relative imports work.\n    CMD_PREFIX = sys.executable + \' -m pyment.pymentapp {}\'\n\n    RE_TYPE = type(re.compile(\'get the type to test if an argument is an re\'))\n\n    # cwd to use when running subprocess.\n    # It has to be at the repo directory so python -m can be used\n    CWD = os.path.dirname(os.path.dirname(__file__))\n\n    INPUT = textwrap.dedent(\'\'\'\n    \n        def func():\n            """"""First line\n\n            :returns: smthg\n            \n            :rtype: ret type\n            \n            """"""\n            pass\n    \'\'\')\n\n    # Expected output in overwrite mode.\n    EXPECTED_OUTPUT = textwrap.dedent(\'\'\'\n    \n        def func():\n            """"""First line\n        \n            Args:\n\n            Returns:\n              ret type: smthg\n\n            Raises:\n\n            """"""\n            pass\n    \'\'\')\n\n    PATCH_PREFIX = \'# Patch generated by Pyment v{}\'.format(pyment.pyment.__version__)\n\n    # a/- and b/- is replaced by a filename when not testing stdin/stdout\n    EXPECTED_PATCH = textwrap.dedent(\'\'\'\\\n        {}\n    \n        --- a/-\n        +++ b/-\n        @@ -3,9 +3,12 @@\n         def func():\n             """"""First line\n        \n        -    :returns: smthg\n        +    Args:\n        \n        -    :rtype: ret type\n        +    Returns:\n        +      ret type: smthg\n        +\n        +    Raises:\n        \n             \n             """"""\n             pass\n\n    \'\'\'.format(PATCH_PREFIX))\n\n    # The format which will turn INPUT into EXPECTED_PATCH and EXPECTED_OUTPUT\n    OUTPUT_FORMAT = \'google\'\n\n    @classmethod\n    def normalise_empty_lines(cls, lines):\n        """"""\n            Replace any lines that are only whitespace with a single \\n\n\n            textwrap.dedent removes all whitespace characters on lines only containing whitespaces\n            see: https://bugs.python.org/issue30754\n\n            And some people set their editors to strip trailing white space.\n\n            But sometimes there is a space on an empty line in the output which will fail the comparison.\n\n            So strip the spaces on empty lines\n\n        :param lines: string of lines to normalise\n        :type lines: str\n\n        :return: normalised lines\n        """"""\n\n        return re.sub(\'^\\s+$\', \'\', lines, flags=re.MULTILINE)\n\n    def run_command(self, cmd_to_run, write_to_stdin=None):\n        """"""\n        Run a command in shell mode returning stdout, stderr and the returncode.\n\n        :param cmd_to_run: shell command to run\n        :type cmd_to_run: str\n\n        :param write_to_stdin: string to put on stdin if not None\n        :type write_to_stdin: str | None\n\n        :return: stdout, stderr, returncode\n        :rtype: (str, str, int)\n        """"""\n\n        p = subprocess.Popen(\n            cmd_to_run, shell=True, cwd=self.CWD,\n            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        if write_to_stdin:\n            # Python3 compatibility - input has to be bytes\n            write_to_stdin = write_to_stdin.encode()\n\n        stdout, stderr = p.communicate(write_to_stdin)\n\n        if isinstance(stdout, bytes):\n            # Python 3 compatibility - output will be bytes\n            stdout = stdout.decode()\n            stderr = stderr.decode()\n\n        return stdout, stderr, p.returncode\n\n    def runPymentAppAndAssertIsExpected(self,\n                                        cmd_args, write_to_stdin=None,\n                                        expected_stdout=\'\', expected_stderr=\'\', expected_returncode=0,\n                                        output_format=None):\n        """"""\n        Run pyment with the cmd_args and output_format specified in a shell and assert it\'s output matches\n        the arguments.\n\n        if expected_stdout and expected_stderr is the result of a re.compile() the output will be checked\n        re.search().\n\n        :param cmd_args: Extra arguments to pass to pyment - excluding the output_format\n        :param write_to_stdin: the input to put on stdin, use None if there\'s nothing\n\n        :param expected_stdout: Expected string to see on stdout\n        :type expected_stdout: str | Pattern[str]\n\n        :param expected_stderr: Expected string to see on stderr\n        :type expected_stderr: str | Pattern[str]\n\n        :param expected_returncode: Expected returncode after running pyment\n        :param output_format: The output format - it adds the --output option, use None if auto is required\n\n        :return: None\n        :raises: Assertion error if the expected rsult is not found\n        """"""\n\n        def assert_output(cmd_to_run, what, got, expected):\n            """"""\n            The comparison works as described in the docstring for runPymentAppAndAssertIsExpected\n\n            :param cmd_to_run: full command that was run - used to build an error message\n            :param what: The attribute being checked - used for the error message\n            :param got: The result from the test\n            :param expected: The expected result from the test\n            :raises: AssertionError if the expected result was not found\n            """"""\n            if isinstance(expected, self.RE_TYPE):\n                msg = ""Test failed for cmd {}\\n{} was expected to match the regex:\\n{}\\n"" \\\n                      ""But this was the output:\\n{!r}\\n"" \\\n                    .format(cmd_to_run, what, expected, got)\n                assert expected.search(got) is not None, msg\n            else:\n                if isinstance(expected, str):\n                    # Turn lines that only have whitespace into single newline lines to workaround textwrap.dedent\n                    # behaviour\n                    got = self.normalise_empty_lines(got).replace(\'\\r\\n\', \'\\n\')\n                    expected = self.normalise_empty_lines(expected)\n\n                #  repr is used instead of str to make it easier to see newlines and spaces if there\'s a difference\n                msg = ""Test failed for cmd {}\\n{} was expected to be:\\n{!r}\\nBut this was the output:\\n{!r}\\n"" \\\n                    .format(cmd_to_run, what, expected, got)\n                assert got == expected, msg\n\n        cmd_to_run = self.CMD_PREFIX.format(cmd_args)\n\n        if output_format:\n            cmd_to_run = \'{} --output {} \'.format(cmd_to_run, output_format)\n\n        stdout, stderr, returncode = self.run_command(cmd_to_run, write_to_stdin)\n\n        assert_output(cmd_to_run, \'stderr\', stderr, expected_stderr)\n        assert_output(cmd_to_run, \'returncode\', returncode, expected_returncode)\n        assert_output(cmd_to_run, \'stdout\', stdout, expected_stdout)\n\n    @unittest.skipIf(sys.version_info[:2] >= (3, 3),\n                     \'Python version >= 3.3\')\n    def testNoArgs_lt_py33(self):\n        # Ensure the app outputs an error if there are no arguments.\n        self.runPymentAppAndAssertIsExpected(\n            cmd_args="""",\n            write_to_stdin=None,\n            expected_stderr=re.compile(\'too few arguments\'),\n            expected_returncode=2\n        )\n\n    @unittest.skipIf(sys.version_info[:2] < (3, 3),\n                     \'Python version < 3.3\')\n    def testNoArgs_ge_py33(self):\n        # Ensure the app outputs an error if there are no arguments.\n        self.runPymentAppAndAssertIsExpected(\n            cmd_args="""",\n            write_to_stdin=None,\n            # expected_stderr=re.compile(\'too few arguments\'),\n            expected_stderr=re.compile(\n                r\'usage: pymentapp.py \\[-h\\] \\[-i style\\] \\[-o style\\] \\[-q quotes\\] \\[-f status\\] \\[-t\\].?.?\\s{20}\\[-c config\\] \\[-d\\] \\[-p status\\] \\[-v\\] \\[-w\\].?.?\\s{20}path.?.?pymentapp\\.py: error: the following arguments are required: path\',\n                re.DOTALL),\n            expected_returncode=2\n        )\n\n    def testStdinPatchMode(self):\n        # Test non overwrite mode when using stdin - which means a patch will be written to stdout\n        self.runPymentAppAndAssertIsExpected(\n            cmd_args=""-"",\n            write_to_stdin=self.INPUT,\n            expected_stdout=self.EXPECTED_PATCH,\n            output_format=self.OUTPUT_FORMAT,\n        )\n\n    def testRunOnStdinOverwrite(self):\n        # Check \'overwrite\' mode with stdin.\n        # In overwrite mode the output is the new file, not a patch.\n        self.runPymentAppAndAssertIsExpected(\n            cmd_args=""-w -"",\n            write_to_stdin=self.INPUT,\n            expected_stdout=self.EXPECTED_OUTPUT,\n            output_format=self.OUTPUT_FORMAT,\n        )\n\n    def runPymentAppWithAFileAndAssertIsExpected(self,\n                                                 file_contents, cmd_args="""", overwrite_mode=False,\n                                                 expected_file_contents=\'\', expected_stderr=\'\', expected_returncode=0,\n                                                 output_format=None):\n        """"""\n        Run the pyment app with a file - not stdin.\n\n        A temporary file is created, file_contents is written into it then the test is run.\n        The .patch and temporary files are removed at the end of the test.\n\n        :param file_contents: write this into the temporary file\n        :param cmd_args: Arguments to pyment - do not put the \'-w\' argument here - it is trigged by overwrite_mode\n        :param overwrite_mode: set to True if in overwrite mode\n        :param expected_file_contents: expected result - for a patch file ensure the filename is \'-\'. The \'-\'\n            is replaced with the patch filename when overwrite_mode is False\n        :param expected_stderr: expected output on stderr. You can match on a regex if you pass it the result of\n            re.compile(\'some pattern\'). Default is empty string.\n        :param expected_returncode: Expected return code from pyment. Default is 0.\n        :param output_format: If not using auto mode set the output format to this.\n\n        """"""\n\n        patch_filename = input_filename = \'\'\n        input_file = None\n\n        try:\n\n            # Create the input file\n            input_fd, input_filename = tempfile.mkstemp(suffix=\'.input\', text=True)\n            input_file = os.fdopen(input_fd, \'w\')\n            input_file.write(file_contents)\n            input_file.close()\n\n            # Get the patch file name so it can be removed if it\'s created.\n            # pyment will create it in the current working directory\n            patch_filename = os.path.join(self.CWD, os.path.basename(input_filename) + \'.patch\')\n\n            cmd_args = ""{} {}"".format(cmd_args, input_filename)\n\n            if overwrite_mode:\n                cmd_args = ""{} -w "".format(cmd_args)\n\n            self.runPymentAppAndAssertIsExpected(\n                cmd_args=cmd_args,\n                expected_stderr=expected_stderr,\n                expected_returncode=expected_returncode,\n                write_to_stdin=file_contents,\n                output_format=output_format,\n            )\n\n            if overwrite_mode:\n                with open(input_filename) as f:\n                    output = f.read()\n            else:\n                with open(patch_filename) as f:\n                    output = f.read()\n                # The expected output will have filenames of \'-\'  - replace them with the actual filename\n                output = re.sub(\n                    r\'/{}$\'.format(os.path.basename(input_filename)),\n                    r\'/-\',\n                    output,\n                    flags=re.MULTILINE\n                )\n\n            normalised_output = self.normalise_empty_lines(output)\n            normalised_expected_output = self.normalise_empty_lines(expected_file_contents)\n\n            assert normalised_output == normalised_expected_output, \\\n                ""Output from cmd: {} was:\\n{!r}\\nnot the expected:\\n{!r}"" \\\n                    .format(cmd_args, normalised_output, normalised_expected_output)\n\n        finally:\n            if input_filename:\n                if input_file:\n                    if not input_file.closed:\n                        input_file.close()\n                os.remove(input_filename)\n\n            if not overwrite_mode:\n                if os.path.isfile(patch_filename):\n                    os.remove(patch_filename)\n\n    def testOverwriteFilesTheSame(self):\n        # Test that the file is correct when the output is the same as the input.\n        self.runPymentAppWithAFileAndAssertIsExpected(\n            file_contents=self.EXPECTED_OUTPUT,\n            expected_file_contents=self.EXPECTED_OUTPUT,\n            output_format=self.OUTPUT_FORMAT,\n            overwrite_mode=True,\n        )\n\n    def testOverwriteFilesDifferent(self):\n        # Test the file is overwritten with the correct result\n        self.runPymentAppWithAFileAndAssertIsExpected(\n            file_contents=self.INPUT,\n            expected_file_contents=self.EXPECTED_OUTPUT,\n            output_format=self.OUTPUT_FORMAT,\n            overwrite_mode=True,\n        )\n\n    def testPatchFilesTheSame(self):\n        # Check the patch file created when the files are the same\n        self.runPymentAppWithAFileAndAssertIsExpected(\n            file_contents=self.EXPECTED_OUTPUT,\n            expected_file_contents=self.PATCH_PREFIX + \'\\n\',\n            output_format=self.OUTPUT_FORMAT\n        )\n\n    def testPatchFilesDifferent(self):\n        # Test the patch file is correct\n        self.runPymentAppWithAFileAndAssertIsExpected(\n            file_contents=self.INPUT,\n            expected_file_contents=self.EXPECTED_PATCH,\n            output_format=self.OUTPUT_FORMAT\n        )\n\n\ndef main():\n    unittest.main()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/test_docs.py,0,"b'#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport unittest\nimport pyment.docstring as docs\n\nmyelem = \'    def my_method(self, first, second=None, third=""value""):\'\nmydocs = \'\'\'        """"""This is a description of a method.\n        It is on several lines.\n        Several styles exists:\n            -javadoc,\n            -reST,\n            -cstyle.\n        It uses the javadoc style.\n\n        @param first: the 1st argument.\n        with multiple lines\n        @type first: str\n        @param second: the 2nd argument.\n        @return: the result value\n        @rtype: int\n        @raise KeyError: raises a key error exception\n        @raise OtherError: raises an other error exception\n\n        """"""\'\'\'\n\nmygrpdocs = \'\'\'\n    """"""\n    My desc of groups style.\n    On two lines.\n\n    Parameters:\n      first: the 1st param\n      second: the 2nd param\n      third: the 3rd param\n\n    Returns:\n      a value in a string\n\n    Raises:\n      KeyError: when a key error\n      OtherError: when an other error\n    """"""\'\'\'\n\ngoogledocs = \'\'\'""""""This is a Google style docs.\n\n    Args:\n      first(str): this is the first param\n      second(int): this is a second param\n      third(str, optional): this is a third param\n\n    Returns:\n      This is a description of what is returned\n\n    Raises:\n      KeyError: raises an exception\n      OtherError: when an other error\n""""""\'\'\'\n\nmygrpdocs2 = \'\'\'\n    """"""\n    My desc of an other kind \n    of groups style.\n\n    Params:\n      first -- the 1st param\n      second -- the 2nd param\n      third -- the 3rd param\n\n    Returns:\n      a value in a string\n\n    Raises:\n      KeyError -- when a key error\n      OtherError -- when an other error\n    """"""\'\'\'\n\nmynumpydocs = \'\'\'\n    """"""\n    My numpydoc description of a kind \n    of very exhautive numpydoc format docstring.\n\n    Parameters\n    ----------\n    first : array_like\n        the 1st param name `first`\n    second :\n        the 2nd param\n    third : {\'value\', \'other\'}, optional\n        the 3rd param, by default \'value\'\n\n    Returns\n    -------\n    string\n        a value in a string\n\n    Raises\n    ------\n    KeyError\n        when a key error\n    OtherError\n        when an other error\n\n    See Also\n    --------\n    a_func : linked (optional), with things to say\n             on several lines\n    some blabla\n\n    Note\n    ----\n    Some informations.\n\n    Some maths also:\n    .. math:: f(x) = e^{- x}\n\n    References\n    ----------\n    Biblio with cited ref [1]_. The ref can be cited in Note section.\n\n    .. [1] Adel Daouzli, Sylvain Sa\xc3\xafghi, Michelle Rudolph, Alain Destexhe, \n       Sylvie Renaud: Convergence in an Adaptive Neural Network: \n       The Influence of Noise Inputs Correlation. IWANN (1) 2009: 140-148\n\n    Examples\n    --------\n    This is example of use\n    >>> print ""a""\n    a\n\n    """"""\'\'\'\n\n\ndef torest(docs):\n    docs = docs.replace(""@"", "":"")\n    docs = docs.replace("":return"", "":returns"")\n    docs = docs.replace("":raise"", "":raises"")\n    return docs\n\n\nclass DocStringTests(unittest.TestCase):\n\n    def testChekListParamsGoogledoc(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d._extract_docs_params()\n        self.assertTrue(d.get_input_style() == \'google\')\n\n    def testAutoInputStyleGoogledoc(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        self.assertTrue(d.get_input_style() == \'google\')\n\n    def testAutoInputStyleNumpydoc(self):\n        doc = mynumpydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        self.assertTrue(d.get_input_style() == \'numpydoc\')\n\n    def testAutoInputStyleJavadoc(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        self.assertTrue(d.get_input_style() == \'javadoc\')\n\n    def testAutoInputStyleReST(self):\n        doc = torest(mydocs)\n        d = docs.DocString(myelem, \'    \', doc)\n        self.assertTrue(d.get_input_style() == \'reST\')\n\n    def testAutoInputStyleGroups(self):\n        doc = mygrpdocs\n        d = docs.DocString(myelem, \'    \', doc)\n        self.assertTrue(d.get_input_style() == \'groups\')\n\n    def testSameOutputJavadocReST(self):\n        doc = mydocs\n        dj = docs.DocString(myelem, \'    \')\n        dj.parse_docs(doc)\n        doc = torest(mydocs)\n        dr = docs.DocString(myelem, \'    \')\n        dr.parse_docs(doc)\n        self.assertEqual(dj.get_raw_docs(), dr.get_raw_docs())\n\n    def testParsingElement(self):\n        d = docs.DocString(myelem, \'    \')\n        self.assertTrue(d.element[\'type\'] == \'def\')\n        self.assertTrue(d.element[\'name\'] == \'my_method\')\n        self.assertTrue(len(d.element[\'params\']) == 3)\n        self.assertTrue(type(d.element[\'params\'][0]) is str)\n        self.assertTrue(d.element[\'params\'][2] == (\'third\', \'""value""\'))\n\n    def testIfParsedDocs(self):\n        doc = mydocs\n        # nothing to parse\n        d = docs.DocString(myelem, \'    \')\n        d.parse_docs()\n        self.assertFalse(d.parsed_docs)\n        # parse docstring given at init\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.parsed_docs)\n        # parse docstring given in parsing method\n        d = docs.DocString(myelem, \'    \')\n        d.parse_docs(doc)\n        self.assertTrue(d.parsed_docs)\n\n    def testParsingDocsDesc(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().startswith(\'This \'))\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().endswith(\'style.\'))\n\n    def testParsingGroupsDocsDesc(self):\n        doc = mygrpdocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().startswith(\'My \'))\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().endswith(\'lines.\'))\n    \n    def testParsingNumpyDocsDesc(self):\n        doc = mynumpydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().startswith(\'My numpydoc\'))\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().endswith(\'format docstring.\'))\n\n    def testParsingGoogleDocsDesc(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'desc\'].strip().startswith(\'This is a Google style docs.\'))\n\n    def testParsingDocsParams(self):\n        doc = torest(mydocs)\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'params\']) == 2)\n        self.assertTrue(type(d.docs[\'in\'][\'params\'][1]) is tuple)\n        # param\'s name\n        self.assertTrue(d.docs[\'in\'][\'params\'][1][0] == \'second\')\n        # param\'s type\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][2] == \'str\')\n        self.assertFalse(d.docs[\'in\'][\'params\'][1][2])\n        # param\'s description\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][1].startswith(""the 1""))\n\n    def testParsingGoogleDocsParams(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'params\']) == 3)\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][0] == \'first\')\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][1].startswith(\'this is the first\'))\n        self.assertTrue(d.docs[\'in\'][\'params\'][2][1].startswith(\'this is a third\'))\n\n    def testParsingGroupsDocsParams(self):\n        doc = mygrpdocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'params\']) == 3)\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][0] == \'first\')\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][1].startswith(\'the 1\'))\n        self.assertTrue(d.docs[\'in\'][\'params\'][2][1].startswith(\'the 3rd\'))\n\n    def testParsingGroups2DocsParams(self):\n        doc = mygrpdocs2\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'params\']) == 3)\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][0] == \'first\')\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][1].startswith(\'the 1\'))\n        self.assertTrue(d.docs[\'in\'][\'params\'][2][1].startswith(\'the 3rd\'))\n\n    def testParsingNumpyDocsParams(self):\n        doc = mynumpydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'params\']) == 3)\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][0] == \'first\')\n        self.assertTrue(d.docs[\'in\'][\'params\'][0][1].strip().startswith(\'the 1\'))\n        self.assertTrue(d.docs[\'in\'][\'params\'][2][1].strip().endswith(""default \'value\'""))\n\n    def testParsingDocsRaises(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        d.generate_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][0].startswith(\'KeyError\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][1].startswith(\'raises a key\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][0].startswith(\'OtherError\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][1].startswith(\'raises an other\'))\n\n    def testParsingGoogleDocsRaises(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][0] == \'KeyError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][1].startswith(\'raises an\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][0] == \'OtherError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][1].startswith(\'when an other\'))\n\n    def testParsingGroupsDocsRaises(self):\n        doc = mygrpdocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][0] == \'KeyError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][1].startswith(\'when a key\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][0] == \'OtherError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][1].startswith(\'when an other\'))\n\n    def testParsingGroups2DocsRaises(self):\n        doc = mygrpdocs2\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][0] == \'KeyError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][1].startswith(\'when a key\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][0] == \'OtherError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][1].startswith(\'when an other\'))\n\n    def testParsingNumpyDocsRaises(self):\n        doc = mynumpydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(len(d.docs[\'in\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][0] == \'KeyError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][0][1].strip().startswith(\'when a key\'))\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][0] == \'OtherError\')\n        self.assertTrue(d.docs[\'in\'][\'raises\'][1][1].strip().startswith(\'when an other\'))\n\n    def testParsingDocsReturn(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'return\'].startswith(\'the result\'))\n        self.assertTrue(d.docs[\'in\'][\'rtype\'] == \'int\')\n\n    def testParsingGroupsDocsReturn(self):\n        doc = mygrpdocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'return\'] == \'a value in a string\')\n\n    def testParsingGoogleDocsReturn(self):\n        doc = googledocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'return\'][0][1] == \'This is a description of what is returned\')\n\n    def testParsingNumpyDocsReturn(self):\n        doc = mynumpydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        self.assertTrue(d.docs[\'in\'][\'return\'][0][1] == \'a value in a string\')\n        d.set_output_style(\'numpydoc\')\n\n    def testGeneratingDocsDesc(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        d.generate_docs()\n        self.assertTrue(d.docs[\'out\'][\'desc\'] == d.docs[\'in\'][\'desc\'])\n\n    def testGeneratingDocsReturn(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        d.generate_docs()\n        self.assertTrue(d.docs[\'out\'][\'return\'].startswith(\'the result\'))\n        self.assertTrue(d.docs[\'out\'][\'rtype\'] == \'int\')\n\n    def testGeneratingDocsRaise(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        d.generate_docs()\n        self.assertTrue(len(d.docs[\'out\'][\'raises\']) == 2)\n        self.assertTrue(d.docs[\'out\'][\'raises\'][0][0].startswith(\'KeyError\'))\n        self.assertTrue(d.docs[\'out\'][\'raises\'][0][1].startswith(\'raises a key\'))\n        self.assertTrue(d.docs[\'out\'][\'raises\'][1][0].startswith(\'OtherError\'))\n        self.assertTrue(d.docs[\'out\'][\'raises\'][1][1].startswith(\'raises an other\'))\n\n    def testGeneratingDocsParams(self):\n        doc = mydocs\n        d = docs.DocString(myelem, \'    \', doc)\n        d.parse_docs()\n        d.generate_docs()\n        self.assertTrue(len(d.docs[\'out\'][\'params\']) == 3)\n        self.assertTrue(type(d.docs[\'out\'][\'params\'][2]) is tuple)\n        self.assertTrue(d.docs[\'out\'][\'params\'][2] == (\'third\', \'\', None, \'""value""\'))\n        # param\'s description\n        self.assertTrue(d.docs[\'out\'][\'params\'][1][1].startswith(""the 2""))\n\n    def testNoParam(self):\n        elem = ""    def noparam():""\n        doc = """"""        \'\'\'the no param docstring\n        \'\'\'""""""\n        d = docs.DocString(elem, \'    \', doc, input_style=\'javadoc\')\n        d.parse_docs()\n        d.generate_docs()\n        self.assertFalse(d.docs[\'out\'][\'params\'])\n\n    def testOneLineDocs(self):\n        elem = ""    def oneline(self):""\n        doc = """"""        \'\'\'the one line docstring\n        \'\'\'""""""\n        d = docs.DocString(elem, \'    \', doc, input_style=\'javadoc\')\n        d.parse_docs()\n        d.generate_docs()\n        #print(d.docs[\'out\'][\'raw\'])\n        self.assertFalse(d.docs[\'out\'][\'raw\'].count(\'\\n\'))\n\n\ndef main():\n    unittest.main()\n\nif __name__ == \'__main__\':\n    main()\n\n'"
tests/test_issues.py,0,"b'#!/usr/bin/python\n\nimport unittest\nimport os\nimport pyment.pyment as pym\nimport pyment.docstring as ds\n\ncurrent_dir = os.path.dirname(__file__)\nabsdir = lambda f: os.path.join(current_dir, f)\n\n\nclass IssuesTests(unittest.TestCase):\n\n    def testIssue9(self):\n        # Title: :rtype: is removed from doc comments; :return: loses indentation\n        issue9 = absdir(\'issue9.py\')\n        p = pym.PyComment(issue9)\n        p._parse()\n        self.assertTrue(p.parsed)\n        res = p.diff(issue9, ""{0}.patch"".format(issue9))\n        self.assertTrue(res[8].strip() == ""-    :return: smthg"")\n        self.assertTrue(res[9].strip() == ""+    :returns: smthg"")\n        self.assertTrue((res[10][1:].rstrip() == ""    :rtype: ret type"")\n                        and (res[10][0] == \' \'))\n\n    def testIssue10(self):\n        # Title: created patch-file not correct\n        try:\n            f = open(absdir(""issue10.py.patch.expected""))\n            expected = f.read()\n            f.close()\n        except Exception as e:\n            self.fail(\'Raised exception: ""{0}""\'.format(e))\n        p = pym.PyComment(absdir(\'issue10.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n    def testIssue11(self):\n        # Title: doctests incorrectly formatted with reST option\n        deftxt = ""def meaning(subject, answer=False):""\n        txt = \'\'\'""""""\n    >>> meaning(\'life\', answer=True)\n    42\n    """"""\'\'\'\n        expected = \'\'\'    """"""\n    \n\n    :param subject: \n    :param answer:  (Default value = False)\n\n    >>> meaning(\'life\', answer=True)\n    42\n    """"""\'\'\'\n        d = ds.DocString(deftxt, quotes=\'""""""\')\n        d.parse_docs(txt)\n        self.assertTrue(d.get_raw_docs() == expected)\n\n    def testIssue15(self):\n        # Title: Does not convert existing docstrings\n        try:\n            f = open(absdir(""issue15.py.patch.expected""))\n            expected = f.read()\n            f.close()\n        except Exception as e:\n            self.fail(\'Raised exception: ""{0}""\'.format(e))\n        p = pym.PyComment(absdir(\'issue15.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n    def testIssue19(self):\n        # Title: :raises in reST is incorrectly parsed\n        txt = \'\'\'""""""\n\n    :raises ValueError: on incorrect JSON\n    :raises requests.exceptions.HTTPError: on response error from server\n    """"""\'\'\'\n        expected = \'\'\'    """"""\n    \n\n\n    :raises ValueError: on incorrect JSON\n    :raises requests.exceptions.HTTPError: on response error from server\n\n    """"""\'\'\'\n        docs = ds.DocString(\'def test():\', quotes=\'""""""\')\n        docs.parse_docs(txt)\n        self.assertTrue(docs.get_raw_docs() == expected)\n\n    def testIssue22(self):\n        # Title: Class __init__() docstrings are not generated\n        expected = \'\'\'--- a/issue22.py\n+++ b/issue22.py\n@@ -2,4 +2,9 @@\n     """"""Test class for issue 22""""""\n \n     def __init__(self, param1):\n+        """"""\n+\n+        :param param1: \n+\n+        """"""\n         pass\n\'\'\'\n        p = pym.PyComment(absdir(\'issue22.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n    def testIssue30(self):\n        # if file starting with a function/class definition, patching the file\n        # will remove the first line!\n        p = pym.PyComment(absdir(\'issue30.py\'), input_style=""numpydoc"", output_style=""numpydoc"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        try:\n            p.diff()\n        except Exception as e:\n            self.fail(\'Raised exception: ""{0}""\'.format(e))\n\n    def testIssue32(self):\n        # Title: def statement gets deleted\n        # if file starting with a function/class definition, patching the file\n        # will remove the first line!\n        expected = \'\'\'--- a/issue32.py\n+++ b/issue32.py\n@@ -1,2 +1,8 @@\n def hello_world(a=22, b=\'hello\'):\n+    """"""\n+\n+    :param a:  (Default value = 22)\n+    :param b:  (Default value = \'hello\')\n+\n+    """"""\n   return 42\'\'\'\n        p = pym.PyComment(absdir(\'issue32.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n    @unittest.expectedFailure\n    def testIssue34(self):\n        # Title: Problem with regenerating empty param docstring\n        # if two consecutive params have empty descriptions, the first will\n        # be filled with the full second param line\n        p = pym.PyComment(absdir(\'issue34.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    @unittest.expectedFailure\n    def testIssue46(self):\n        # Title: list, tuple, dict default param values are not parsed correctly\n        # if a list/tuple/dict is given as default value for a parameter, the\n        # commas will be considered as separators for parameters\n        try:\n            f = open(absdir(""issue46.py.patch.expected""))\n            expected = f.readlines()\n            if expected[0].startswith(""# Patch""):\n                expected = expected[2:]\n            expected = """".join(expected)\n            f.close()\n        except Exception as e:\n            self.fail(\'Raised exception: ""{0}""\'.format(e))\n        p = pym.PyComment(absdir(\'issue46.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n    @unittest.expectedFailure\n    def testIssue47(self):\n        # Title:  Extra blank line for docstring with a muli-line description #47\n        # If a function has no argument and a multi-line description, Pyment will insert two blank lines\n        # between the description and the end of the docstring.\n        p = pym.PyComment(absdir(\'issue47.py\'))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    def testIssue49(self):\n        # Title: If already numpydoc format, will remove the Raises section\n        # If the last section in a numpydoc docstring is a `Raises` section,\n        # it will be removed if the output format is also set to numpydoc\n        p = pym.PyComment(absdir(\'issue49.py\'), output_style=\'numpydoc\')\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        print(result)\n        self.assertTrue(result == \'\')\n\n    def testIssue51(self):\n        # Title:  Raise block convertion\n        p = pym.PyComment(absdir(\'issue51.py\'), output_style=\'google\')\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    def testIssue58(self):\n        # Title: Comments after def statement not supported\n        # If a function\'s def statement is followed by a comment it won\'t be proceeded.\n        p = pym.PyComment(absdir(\'issue58.py\'))\n        expected = \'\'\'--- a/issue58.py\n+++ b/issue58.py\n@@ -1,5 +1,9 @@\n def func(param): # some comment\n-    """"""some docstring""""""\n+    """"""some docstring\n+\n+    :param param: \n+\n+    """"""\n     pass\n \n \n\'\'\'\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == expected)\n\n\ndef main():\n    unittest.main()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/test_pyment.py,0,"b'#!/usr/bin/python\n\nimport unittest\nimport shutil\nimport os\nimport pyment.pyment as pym\n\nmyelem = \'    def my_method(self, first, second=None, third=""value""):\'\nmydocs = \'\'\'        """"""This is a description of a method.\n        It is on several lines.\n        Several styles exists:\n            -javadoc,\n            -reST,\n            -cstyle.\n        It uses the javadoc style.\n\n        @param first: the 1st argument.\n        with multiple lines\n        @type first: str\n        @param second: the 2nd argument.\n        @return: the result value\n        @rtype: int\n        @raise KeyError: raises exception\n\n        """"""\'\'\'\n\ncurrent_dir = os.path.dirname(__file__)\nabsdir = lambda f: os.path.join(current_dir, f)\n\ninifile = absdir(\'origin_test.py\')\njvdfile = absdir(\'javadoc_test.py\')\nrstfile = absdir(\'rest_test.py\')\nfoo = absdir(""foo"")\n\n\nclass DocStringTests(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        # prepare test file\n        txt = """"\n        shutil.copyfile(inifile, jvdfile)\n        with open(jvdfile, \'r\') as fs:\n            txt = fs.read()\n        txt = txt.replace(""@return"", "":returns"")\n        txt = txt.replace(""@raise"", "":raises"")\n        txt = txt.replace(""@"", "":"")\n        with open(rstfile, \'w\') as ft:\n            ft.write(txt)\n        with open(foo, ""w"") as fooo:\n            fooo.write(""foo"")\n        print(""setup"")\n\n    @classmethod\n    def tearDownClass(cls):\n        os.remove(jvdfile)\n        os.remove(rstfile)\n        os.remove(foo)\n        print(""end"")\n\n    def testParsedJavadoc(self):\n        p = pym.PyComment(inifile)\n        p._parse()\n        self.assertTrue(p.parsed)\n\n    def testSameOutJavadocReST(self):\n        pj = pym.PyComment(jvdfile)\n        pr = pym.PyComment(rstfile)\n        pj._parse()\n        pr._parse()\n        self.assertEqual(pj.get_output_docs(), pr.get_output_docs())\n\n    def testMultiLinesElements(self):\n        p = pym.PyComment(inifile)\n        p._parse()\n        self.assertTrue(\'first\' in p.get_output_docs()[1])\n        self.assertTrue(\'second\' in p.get_output_docs()[1])\n        self.assertTrue(\'third\' in p.get_output_docs()[1])\n        self.assertTrue(\'multiline\' in p.get_output_docs()[1])\n\n    def testMultiLinesShiftElements(self):\n        p = pym.PyComment(inifile)\n        p._parse()\n        #TODO: improve this test\n        self.assertEqual((len(p.get_output_docs()[13])-len(p.get_output_docs()[13].lstrip())), 8)\n        self.assertTrue(\'first\' in p.get_output_docs()[13])\n        self.assertTrue(\'second\' in p.get_output_docs()[13])\n        self.assertTrue(\'third\' in p.get_output_docs()[13])\n        self.assertTrue(\'multiline\' in p.get_output_docs()[13])\n\n    def testWindowsRename(self):\n        bar = absdir(""bar"")\n        with open(bar, ""w"") as fbar:\n            fbar.write(""bar"")\n        p = pym.PyComment(foo)\n        p._windows_rename(bar)\n        self.assertFalse(os.path.isfile(bar))\n        self.assertTrue(os.path.isfile(foo))\n        with open(foo, ""r"") as fooo:\n            foo_txt = fooo.read()\n        self.assertTrue(foo_txt == ""bar"")\n\n\ndef main():\n    unittest.main()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
tests/test_pyment_cases.py,0,"b'#!/usr/bin/python\n\nimport unittest\nimport os\nimport pyment.pyment as pym\nimport re\n\ncurrent_dir = os.path.dirname(__file__)\nabsdir = lambda f: os.path.join(current_dir, f)\n\n\ndef get_expected_patch(self, name):\n    """"""Open a patch file, and if found Pyment signature remove the 2 first lines""""""\n    try:\n        f = open(absdir(name))\n        expected = f.readlines()\n        if expected[0].startswith(""# Patch""):\n            expected = expected[2:]\n        expected = """".join(expected)\n        f.close()\n    except Exception as e:\n        self.fail(\'Raised exception: ""{0}""\'.format(e))\n    return expected\n\n\ndef remove_diff_header(diff):\n    return re.sub(\'@@.+@@\', \'\', diff)\n\n\nclass FilesConversionTests(unittest.TestCase):\n\n    def testCaseFreeTesting(self):\n        # free cases\n        p = pym.PyComment(absdir(""free_cases.py""))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    def testCaseGenAllParamsReST(self):\n        # The file has several functions with no or several parameters,\n        # so Pyment should produce docstrings in reST format\n        expected = get_expected_patch(self, ""params.py.patch.reST.expected"")\n        p = pym.PyComment(absdir(""params.py""))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(remove_diff_header(result) == remove_diff_header(expected))\n\n    @unittest.expectedFailure\n    def testCaseGenAllParamsGoogle(self):\n        # The file has several functions with no or several parameters,\n        # so Pyment should produce docstrings in google format\n        expected = get_expected_patch(self, ""params.py.patch.google.expected"")\n        p = pym.PyComment(absdir(""params.py""), output_style=""google"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(remove_diff_header(result) == remove_diff_header(expected))\n\n    def testCaseGenAllParamsNumpydoc(self):\n        # The file has several functions with no or several parameters,\n        # so Pyment should produce docstrings in numpydoc format\n        expected = get_expected_patch(self, ""params.py.patch.numpydoc.expected"")\n        p = pym.PyComment(absdir(""params.py""), output_style=""numpydoc"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(remove_diff_header(result) == remove_diff_header(expected))\n\n    def testCaseGenAllParamsJavadoc(self):\n        # The file has several functions with no or several parameters,\n        # so Pyment should produce docstrings in javadoc\n        expected = get_expected_patch(self, ""params.py.patch.javadoc.expected"")\n        p = pym.PyComment(absdir(""params.py""), output_style=""javadoc"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(remove_diff_header(result) == remove_diff_header(expected))\n\n    def testCaseNoGenDocsAlreadyReST(self):\n        # The file has functions with already docstrings in reST format,\n        # so no docstring should be produced\n        p = pym.PyComment(absdir(""docs_already_reST.py""))\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    def testCaseNoGenDocsAlreadyJavadoc(self):\n        # The file has functions with already docstrings in javadoc format,\n        # so no docstring should be produced\n        p = pym.PyComment(absdir(""docs_already_javadoc.py""), output_style=""javadoc"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    @unittest.expectedFailure\n    def testCaseNoGenDocsAlreadyNumpydoc(self):\n        # The file has functions with already docstrings in numpydoc format,\n        # so no docstring should be produced\n        p = pym.PyComment(absdir(""docs_already_numpydoc.py""), output_style=""numpydoc"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n    @unittest.expectedFailure\n    def testCaseNoGenDocsAlreadyGoogle(self):\n        # The file has functions with already docstrings in google format,\n        # so no docstring should be produced\n        p = pym.PyComment(absdir(""docs_already_google.py""), output_style=""google"")\n        p._parse()\n        self.assertTrue(p.parsed)\n        result = \'\'.join(p.diff())\n        self.assertTrue(result == \'\')\n\n\ndef main():\n    unittest.main()\n\n\nif __name__ == \'__main__\':\n    main()\n'"
doc/sphinx/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Pyment documentation build configuration file, created by\n# sphinx-quickstart on Wed Sep 27 21:39:14 2017.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath(\'../../../pyment\'))\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\'sphinx.ext.autodoc\',\n    \'sphinx.ext.githubpages\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Pyment\'\ncopyright = u\'2017, Daouzli Adel\'\nauthor = u\'Daouzli Adel\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = u\'0.3.2\'\n# The full version, including alpha/beta/rc tags.\nrelease = u\'0.3.2\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'classic\'\n#html_theme = \'sphinx_rtd_theme\'\nhtml_theme_path = [""_themes"", ]\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# This is required for the alabaster theme\n# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars\n# html_sidebars = {\n#     \'**\': [\n#         \'about.html\',\n#         \'navigation.html\',\n#         \'relations.html\',  # needs \'show_related\': True theme option to display\n#         \'searchbox.html\',\n#         \'donate.html\',\n#     ]\n# }\n\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'Pymentdoc\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'Pyment.tex\', u\'Pyment Documentation\',\n     u\'Daouzli Adel\', \'manual\'),\n]\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pyment\', u\'Pyment Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'Pyment\', u\'Pyment Documentation\',\n     author, \'Pyment\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n\n'"
