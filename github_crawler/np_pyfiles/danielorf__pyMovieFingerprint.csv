file_path,api_count,code
pymoviefingerprint.py,9,"b'import cv2\nimport numpy as np\nimport math\nimport sys\n\n\nclass MovieFingerprint(object):\n    \'\'\'\n    MovieFingerprint converts a movie into an abstract \'fingerprint\' image.  This image is meant to preserve the\n    dominant colors and patterns of a movie.\n    \'\'\'\n\n    def __init__(self, movie_path, movie_title):\n        \'\'\'\n        Takes a path to a video file and title as params and sets initial properties in preparation for following methods\n\n        :param movie_path:\n        :param movie_title:\n        \'\'\'\n        self.total_samples = 250\n        self.output_image_height = 1080\n        self.fraction_of_movie_to_capture = 0.9\n        self.movie_path = movie_path\n        self.movie_title = movie_title\n\n        self.video = cv2.VideoCapture(self.movie_path)\n        self.success, self.temp_image = self.video.read()\n        self.total_frames = int(self.video.get(cv2.CAP_PROP_FRAME_COUNT))\n        self.image_width = int(self.temp_image.shape[1] * float(self.output_image_height) / self.temp_image.shape[0])\n        self.sample_rate = int(round(self.total_frames / self.total_samples, 0))\n        self.final_image = None\n        self.best_match_image = None\n\n    def set_path(self, movie_path):\n        \'\'\'\n        Sets the path of the video file\n\n        :param movie_path:\n        :return: void\n        \'\'\'\n        self.movie_path = movie_path\n\n    def set_title(self, movie_title):\n        \'\'\'\n        Sets the title of the video file and resulting images\n\n        :param movie_title:\n        :return: void\n        \'\'\'\n        self.movie_title = movie_title\n\n    def make_fingerprint(self, hist_eq=None):\n        \'\'\'\n        Generates the MovieFingerprint image\n\n        :return: void\n        \'\'\'\n\n        if (self.movie_path or self.movie_title) is not None:\n\n            if hist_eq == None:\n                self.movie_title = self.movie_title + \'_noHEQ\'\n            elif hist_eq == \'HSV\':\n                self.movie_title = self.movie_title + \'_HSV\'\n            elif hist_eq == \'SV\':\n                self.movie_title = self.movie_title + \'_SV\'\n\n            print(self.movie_title)\n            print(\'Total frames: \', self.total_frames)\n            print(\'Frames to capture: \', self.fraction_of_movie_to_capture * self.total_frames)\n            print(\'Sample rate: \', self.sample_rate)\n            print()\n\n            sampled_frames = float(self.total_frames) / self.sample_rate\n\n            temp_image_rescaled = cv2.resize(self.temp_image, (self.image_width, self.output_image_height),\n                                             interpolation=cv2.INTER_CUBIC)\n            image = np.asarray(temp_image_rescaled, dtype=""int32"") / sampled_frames\n\n            frame_count = 1\n            success = True\n\n            while success and frame_count < self.fraction_of_movie_to_capture * self.total_frames:\n                success, temp_image_rescaled = self.video.read()\n                if not success:\n                    print(\'FAILURE, current frame is \', frame_count)\n                if frame_count % self.sample_rate == 0:\n                    print(\'{}% complete\'.format(round(100 * frame_count / self.total_frames, 1)))\n\n                    print(\'frame_count: \', frame_count)\n\n                    temp_image_rescaled = cv2.cvtColor(temp_image_rescaled, cv2.COLOR_BGR2HSV)\n\n                    if hist_eq != None:\n                        if hist_eq == \'HSV\':\n                            temp_image_rescaled[:, :, 0] = cv2.equalizeHist(temp_image_rescaled[:, :, 0])\n                            temp_image_rescaled[:, :, 1] = cv2.equalizeHist(temp_image_rescaled[:, :, 1])\n                            temp_image_rescaled[:, :, 2] = cv2.equalizeHist(temp_image_rescaled[:, :, 2])\n                        elif hist_eq == \'SV\':\n                            temp_image_rescaled[:, :, 1] = cv2.equalizeHist(temp_image_rescaled[:, :, 1])\n                            temp_image_rescaled[:, :, 2] = cv2.equalizeHist(temp_image_rescaled[:, :, 2])\n                        else:\n                            print(\'Invalid hist_EQ param; must be ""SV"", ""HSV"" or None\')\n\n                    temp_image_rescaled = cv2.cvtColor(temp_image_rescaled, cv2.COLOR_HSV2BGR)\n                    temp_image_rescaled = cv2.GaussianBlur(temp_image_rescaled, (5, 5), 0)\n                    temp_image_rescaled = cv2.resize(temp_image_rescaled, (self.image_width, self.output_image_height),\n                                                     interpolation=cv2.INTER_CUBIC)\n                    image += np.asarray(temp_image_rescaled, dtype=""int32"") / sampled_frames\n                    frame_count += 1\n                else:\n                    frame_count += 1\n\n            if frame_count / self.total_frames > 0.6:\n                image = cv2.GaussianBlur(image, (5, 5), 0)\n                self.final_image = np.asarray(image, dtype=""uint8"")\n                print(\'Fingerprint image complete\')\n            else:\n                print(\'Failed before reaching 60% completion.  Please retry with better quality movie.\')\n\n    def write_fingerprint_image(self):\n        \'\'\'\n        Writes MovieFingerprint image to file\n\n        :return: void\n        \'\'\'\n        if self.final_image is not None:\n            cv2.imwrite(""images\\{}.jpg"".format(self.movie_title), self.final_image)  # save frame as JPEG file\n            print(\'Fingerprint image written to images\\{}.jpg\'.format(self.movie_title))\n        else:\n            print(\'Error writing Fingerprint Image, make sure to get it first with make_fingerprint()\')\n\n    def get_matching_image(self):\n        \'\'\'\n        Compare MovieFingerprint image to regularly sampled movie frames to find the closest matching frame\n\n        :return: void\n        \'\'\'\n        # Compare averaged image to a regularly sampled movie frames to find the closest match\n\n        if self.final_image is None:\n            new_image_path = input(\'Enter path of image to match to movie frame: \')\n            self.final_image = cv2.imread(new_image_path)\n\n        frame_count = 1\n        video = cv2.VideoCapture(self.movie_path)\n        final_image_width_quarter = int(self.image_width / 4.0)\n        final_image_height_quarter = int(self.output_image_height / 4.0)\n        final_image_small = cv2.resize(self.final_image, (final_image_width_quarter, final_image_height_quarter),\n                                       interpolation=cv2.INTER_CUBIC)\n        final_image_small_YCrCb = cv2.cvtColor(final_image_small, cv2.COLOR_BGR2YCrCb)  # Convert to YCrCb color space \n\n        success, best_match_image = video.read()\n        best_match_image_score = math.inf\n\n        while success and frame_count < self.fraction_of_movie_to_capture * self.total_frames:\n            success, temp_image = video.read()\n            if not success:\n                print(\'FAILURE at image comparison, current frame is \', frame_count)\n            if frame_count % self.sample_rate == 0:\n                print(\'Comparison is {}% complete\'.format(round(100 * frame_count / self.total_frames, 1)))\n                temp_image_small = cv2.resize(temp_image, (final_image_width_quarter, final_image_height_quarter),\n                                              interpolation=cv2.INTER_CUBIC)\n                temp_image_small = cv2.GaussianBlur(temp_image_small, (5, 5), 0)\n                temp_image_small_YCrCb = cv2.cvtColor(temp_image_small,\n                                                      cv2.COLOR_BGR2YCrCb)  # Convert to YCrCb color space\n\n                # Scoring function is modified RMS of difference between Y/Cr/Cb color channels of the averaged image found\n                # with makeFingerprint() and each frame gathered by the video.read() call at the top of this method\n                temp_image_score = math.sqrt(np.sum(\n                    0.5 * np.square((final_image_small_YCrCb[:, :, 0] - temp_image_small_YCrCb[:, :, 0]))\n                    + np.square((final_image_small_YCrCb[:, :, 1] - temp_image_small_YCrCb[:, :, 1]))\n                    + np.square((final_image_small_YCrCb[:, :, 2] - temp_image_small_YCrCb[:, :, 2]))) / (\n                                                 3 * (final_image_width_quarter * final_image_height_quarter)))\n\n                if temp_image_score < best_match_image_score:\n                    best_match_image_score = temp_image_score\n                    best_match_image = temp_image\n                frame_count += 1\n            else:\n                frame_count += 1\n\n        print(\'best_match_image_score: \', best_match_image_score)\n        self.best_match_image = best_match_image\n\n    def write_matching_image(self):\n        \'\'\'\n        Writes matching image to file\n\n        :return: void\n        \'\'\'\n        if self.best_match_image is not None:\n            cv2.imwrite(""images\\{}_{}.jpg"".format(\'MatchImage\', self.movie_title),\n                        self.best_match_image)  # save frame as JPEG file\n            print(\'Matching image written to images\\{}_{}.jpg\'.format(\'MatchImage\', self.movie_title))\n        else:\n            print(\'Error writing Match Image, make sure to get it first with get_matching_image()\')\n\n    def write_combined_image(self):\n        \'\'\'\n        Writes combined MovieFingerprint and matching image to file\n\n        :return: void\n        \'\'\'\n        if self.final_image is not None and self.best_match_image is not None:\n            scaled_image_width = 500\n            scaled_image_height = int(scaled_image_width * float(self.output_image_height) / self.image_width)\n            print(self.image_width)\n            print(self.output_image_height)\n            print(scaled_image_width)\n            print(scaled_image_height)\n            scaled_final_image = cv2.resize(self.final_image, (scaled_image_width, scaled_image_height),\n                                            interpolation=cv2.INTER_CUBIC)\n            scaled_best_match_image = cv2.resize(self.best_match_image, (scaled_image_width, scaled_image_height),\n                                                 interpolation=cv2.INTER_CUBIC)\n            middle_black_bar = np.zeros((scaled_final_image.shape[0], 10, scaled_final_image.shape[2]))\n\n            cv2.imwrite(""images\\{}_{}.jpg"".format(\'Both\', self.movie_title),\n                        np.concatenate((scaled_final_image, middle_black_bar, scaled_best_match_image),\n                                       axis=1))  # save side-by-side image as JPEG file\n        else:\n            print(\n            \'Error writing Side-by-Side Image, make sure to get both images first with make_fingerprint() and get_matching_image()\')\n'"
