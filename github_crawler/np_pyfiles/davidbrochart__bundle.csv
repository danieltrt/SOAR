file_path,api_count,code
setup.py,0,"b'import setuptools\n\nsetuptools.setup(\n    name=""bundle"",\n    version=""0.0.1"",\n    author=""David Brochart"",\n    author_email=""david.brochart@gmail.com"",\n    description=""FPGA architecture for array computing"",\n    long_description=""An architecture to process array computing in hardware (typically in an FPGA)."",\n    long_description_content_type=""text/markdown"",\n    url=""https://github.com/davidbrochart/bundle"",\n    packages=setuptools.find_packages(),\n    classifiers=(\n        ""Programming Language :: Python :: 3"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: OS Independent"",\n    ),\n)\n'"
bundle/__init__.py,0,b'from .scheduler import evaluate\n'
bundle/cpu_config.py,0,"b""class Config(object):\n    def __init__(self, mem_nb, mem_depth, thread_nb):\n        self.config = {\n                'mem_nb': mem_nb,\n                'mem_depth': mem_depth,\n                'thread_nb': thread_nb\n                }\n"""
bundle/cpu_dashboard.py,0,"b""import matplotlib.pyplot as plt\n\nclass Dashboard(object):\n    def __init__(self, thread_nb):\n        self.prev_time = None\n        self.prev_busy = [False for i in range(thread_nb)]\n        self.bar = {'t0': [], 't1': [], 'c': []}\n        self.thread_nb = thread_nb\n\n    def show(self):\n        plt.figure(figsize=(16, 5))\n        for i, colors in enumerate(self.bar['c']):\n            b = plt.barh(range(self.thread_nb), [self.bar['t1'][i] - self.bar['t0'][i]] * self.thread_nb, left=self.bar['t0'][i])\n            for j, c in enumerate(colors):\n                b[j].set_color(c)\n        plt.show()\n\n    def set(self, thread_i, time, busy):\n        self.bar['c'].append([])\n        for i in range(self.thread_nb):\n            if self.prev_busy[i]:\n                self.bar['c'][-1].append('r')\n            else:\n                self.bar['c'][-1].append('w')\n        self.bar['t1'].append(time)\n        if self.prev_time is None:\n            self.prev_time = time\n        self.bar['t0'].append(self.prev_time)\n        self.prev_time = time\n        self.prev_busy[thread_i] = busy\n"""
bundle/cpu_device.py,5,"b""from .cpu_state import CPU_state\nimport numpy as np\nnp.mul = np.multiply\nimport asyncio\nfrom time import time\nfrom numba import jit\n\n@jit(nopython=True, nogil=True)\ndef sin(a, r):\n    for i in range(a.size):\n        r[i] = np.sin(a[i])\n\nclass Device(object):\n    def __init__(self, config, dashboard=None):\n        self.maxitemsize = 8\n        self.chunk_array = [np.empty(shape=(config['mem_depth'],), dtype=f'uint{self.maxitemsize*8}') for i in range(config['mem_nb'])]\n        self.chunk_array_saved = list(self.chunk_array)\n\n        self.state = CPU_state(config)\n        self.config = config\n        self.dashboard = dashboard\n\n    # Arguments\n\n    def copy_to_chunk(self, data_nb, mem_i, input_array):\n        # change type of chunk to type of input array\n        self.chunk_array[mem_i] = self.chunk_array[mem_i].view(input_array.dtype)\n        # copy chunk\n        self.chunk_array[mem_i][:data_nb] = input_array[:data_nb]\n        # notify copy completion\n        #self.state.copy_to_chunk_done[mem_i].set()\n\n    async def arg_chunk(self, data_nb, mem_i, input_array):\n        if input_array.itemsize > self.maxitemsize:\n            raise RuntimeError(f'Item size cannot be greater than {self.maxitemsize} bytes')\n        elif input_array.itemsize < self.maxitemsize:\n            # copy arguments\n            self.chunk_array[mem_i] = self.chunk_array_saved[mem_i]\n            while self.state.free_thread_nb == 0:\n                await self.state.thread_freed.wait()\n                self.state.thread_freed.clear()\n            thread_i = self.state.thread_alloc()\n            loop = asyncio.get_running_loop()\n            await loop.run_in_executor(self.state.executor, self.copy_to_chunk, data_nb, mem_i, input_array)\n            self.state.thread_free(thread_i)\n        else: # same item size\n            # don't copy arguments, just get a view\n            # save a reference to chunk arrays which will be restored\n            # when evaluation is done\n            self.chunk_array[mem_i] = input_array\n\n    # Results\n\n    def copy_from_chunk(self, data_nb, mem_i, output_array):\n        assert output_array.dtype == self.chunk_array[mem_i].dtype\n        # copy chunk\n        output_array[:data_nb] = self.chunk_array[mem_i][:data_nb]\n        # notify copy completion\n        #self.state.copy_from_chunk_done[mem_i].set()\n\n    async def res_chunk(self, data_nb, mem_i, output_array, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        while self.state.free_thread_nb == 0:\n            await self.state.thread_freed.wait()\n            self.state.thread_freed.clear()\n        thread_i = self.state.thread_alloc()\n        loop = asyncio.get_running_loop()\n        await loop.run_in_executor(self.state.executor, self.copy_from_chunk, data_nb, mem_i, output_array)\n        self.state.thread_free(thread_i)\n\n    # Functions\n\n    def do_unary_func(self, func, data_nb, mem_i0, mem_i1):\n        # change type of chunk to type of arguments\n        self.chunk_array[mem_i1] = self.chunk_array[mem_i1].view(self.chunk_array[mem_i0].dtype)\n        #t0 = time()\n        self.chunk_array[mem_i1][:data_nb] = np.__getattribute__(func)(self.chunk_array[mem_i0][:data_nb])\n        t1 = time()\n        # function is associated to result memory\n        #self.state.func_done[mem_i1].set()\n        return t1\n\n    async def unary_func(self, func, data_nb, mem_i0, mem_i1, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        while self.state.free_thread_nb == 0:\n            await self.state.thread_freed.wait()\n            self.state.thread_freed.clear()\n        thread_i = self.state.thread_alloc()\n        loop = asyncio.get_running_loop()\n        self.dashboard.set(thread_i, time(), True)\n        t1 = await loop.run_in_executor(self.state.executor, self.do_unary_func, func, data_nb, mem_i0, mem_i1)\n        self.dashboard.set(thread_i, t1, False)\n        #print('thread_i', thread_i, t0, t1)\n        self.state.thread_free(thread_i)\n\n    def do_binary_func(self, func, data_nb, mem_i0, mem_i1, mem_i2):\n        # arguments and result must be of same type for now\n        # TODO: handle type casting\n        assert self.chunk_array[mem_i0].dtype == self.chunk_array[mem_i1].dtype\n        # change type of chunk to type of arguments\n        self.chunk_array[mem_i2] = self.chunk_array[mem_i2].view(self.chunk_array[mem_i0].dtype)\n        #t0 = time()\n        self.chunk_array[mem_i2][:data_nb] = np.__getattribute__(func)(self.chunk_array[mem_i0][:data_nb], self.chunk_array[mem_i1][:data_nb])\n        t1 = time()\n        # function is associated to result memory\n        #self.state.func_done[mem_i2].set()\n        return t1\n\n    async def binary_func(self, func, data_nb, mem_i0, mem_i1, mem_i2, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        while self.state.free_thread_nb == 0:\n            await self.state.thread_freed.wait()\n            self.state.thread_freed.clear()\n        thread_i = self.state.thread_alloc()\n        loop = asyncio.get_running_loop()\n        self.dashboard.set(thread_i, time(), True)\n        t1 = await loop.run_in_executor(self.state.executor, self.do_binary_func, func, data_nb, mem_i0, mem_i1, mem_i2)\n        self.dashboard.set(thread_i, t1, False)\n        self.state.thread_free(thread_i)\n\n    async def free_mem(self, mem, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        for i in mem:\n            self.state.mem_free(i)\n"""
bundle/cpu_state.py,0,"b""import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\n#class Event_threadsafe(asyncio.Event):\n#    def set(self):\n#        self._loop.call_soon_threadsafe(super().set)\n#    def clear(self):\n#        self._loop.call_soon_threadsafe(super().clear)\n\nclass CPU_state(object):\n    def __init__(self, config):\n        mem_nb = config['mem_nb']\n        thread_nb = config['thread_nb']\n        self.mem_busy = [False for i in range(mem_nb)]\n        self.free_mem_nb = mem_nb\n        self.thread_busy = [False for i in range(thread_nb)]\n        self.free_thread_nb = thread_nb\n        self.executor = ThreadPoolExecutor(max_workers=thread_nb)\n        #self.func_done = [Event_threadsafe() for i in range(thread_nb)]\n        self.thread_freed = asyncio.Event()\n    def alloc(self, busy, nb, i0=0, i1=None):\n        res = []\n        if i1 is None:\n            i1 = len(busy)\n        i = i0\n        for _ in range(nb):\n            while busy[i]:\n                i += 1\n                if i == i1:\n                    i = i0\n            busy[i] = True\n            res.append(i)\n        if nb == 1:\n            return res[0]\n        return res\n    def mem_alloc(self, nb=1):\n        self.free_mem_nb -= nb\n        res = self.alloc(self.mem_busy, nb)\n        return res\n    def mem_free(self, i):\n        assert self.mem_busy[i]\n        self.free_mem_nb += 1\n        self.mem_busy[i] = False\n    def thread_alloc(self):\n        self.free_thread_nb -= 1\n        return self.alloc(self.thread_busy, 1)\n    def thread_free(self, i):\n        assert self.thread_busy[i]\n        self.free_thread_nb += 1\n        self.thread_busy[i] = False\n        self.thread_freed.set()\n"""
bundle/ddr2fpga.py,0,"b'from pyclk import Sig, Reg, In, Out, List, Module\n\nclass ddr2fpga(Module):\n\n    def __init__(self):\n        self.IDLE, self.COUNTING, self.COMPLETE = range(3)\n        self.r_state    = Reg()\n        self.r_addr     = Reg()\n        self.r_wena     = Reg()\n        self.r_done     = Reg()\n\n        # I/O\n        self.array_ptr  = None\n        self.o_mem_addr = Out()\n        self.o_mem_wena = Out()\n        self.o_mem_din  = Out()\n        self.i_data_nb  = In()\n        self.o_done     = Out()\n\n    def logic(self):\n        if self.r_state.q == self.IDLE:\n            if self.i_data_nb.d != 0:\n                self.r_state.d = self.COUNTING\n                self.r_wena.d = 1\n        elif self.r_state.q == self.COUNTING:\n            if self.r_addr.q == self.i_data_nb.d - 1:\n                self.r_state.d = self.COMPLETE\n                self.r_wena.d = 0\n                self.r_addr.d = 0\n                self.r_done.d = 1\n            else:\n                self.r_addr.d = self.r_addr.q + 1\n        elif self.r_state.q == self.COMPLETE:\n            if self.i_data_nb.d == 0:\n                self.r_state.d = self.IDLE\n                self.r_done.d = 0\n        else:\n            self.r_state.d = self.IDLE\n\n        self.o_mem_addr.d = self.r_addr.q\n        self.o_mem_wena.d = self.r_wena.q\n        if self.r_wena.q == 1:\n            self.o_mem_din.d = self.array_ptr[self.r_addr.q]\n        else:\n            self.o_mem_din.d = 0\n        self.o_done.d = self.r_done.q\n'"
bundle/expression.py,4,"b'# Author: AxiaCore S.A.S. http://axiacore.com\n#\n# Based on js-expression-eval, by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)\n# https://github.com/silentmatt/js-expression-eval\n#\n# Ported to Python and modified by Vera Mazhuga (ctrl-alt-delete@live.com, http://vero4ka.info/)\n#\n# You are free to use and modify this code in anyway you find useful. Please leave this comment in the code\n# to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,\n# but don\'t feel like you have to let me know or ask permission.\n\nimport math\nimport random\nimport numpy as np\n\nTNUMBER = 0\nTOP1 = 1\nTOP2 = 2\nTVAR = 3\nTFUNCALL = 4\n\nclass Token():\n\n    def __init__(self, type_, index_, prio_, number_):\n        self.type_ = type_\n        self.index_ = index_ or 0\n        self.prio_ = prio_ or 0\n        self.number_ = number_ if number_ != None else 0\n\n    def toString(self):\n        if self.type_ == TNUMBER:\n            return self.number_\n        if self.type_ == TOP1 or self.type_ == TOP2 or self.type_ == TVAR:\n            return self.index_\n        elif self.type_ == TFUNCALL:\n            return \'CALL\'\n        else:\n            return \'Invalid Token\'\n\n\nclass Expression():\n\n    def __init__(self, tokens, ops1, ops2, functions):\n        self.tokens = tokens\n        self.ops1 = ops1\n        self.ops2 = ops2\n        self.functions = functions\n\n    def simplify(self, values):\n        values = values or {}\n        nstack = []\n        newexpression = []\n        L = len(self.tokens)\n        for i in range(0, L):\n            item = self.tokens[i]\n            type_ = item.type_\n            if type_ == TNUMBER:\n                nstack.append(item)\n            elif type_ == TVAR and item.index_ in values:\n                item = Token(TNUMBER, 0, 0, values[item.index_])\n                nstack.append(item)\n            elif type_ == TOP2 and len(nstack) > 1:\n                n2 = nstack.pop()\n                n1 = nstack.pop()\n                f = self.ops2[item.index_]\n                item = Token(TNUMBER, 0, 0, f(n1.number_, n2.number_))\n                nstack.append(item)\n            elif type_ == TOP1 and nstack:\n                n1 = nstack.pop()\n                f = self.ops1[item.index_]\n                item = Token(TNUMBER, 0, 0, f(n1.number_))\n                nstack.append(item)\n            else:\n                while len(nstack) > 0:\n                    newexpression.append(nstack.pop(0))\n                newexpression.append(item)\n        while nstack:\n            newexpression.append(nstack.pop(0))\n\n        return Expression(newexpression, self.ops1, self.ops2, self.functions)\n\n    def substitute(self, variable, expr):\n        if not isinstance(expr, Expression):\n            expr = Parser().parse(str(expr))\n        newexpression = []\n        L = len(self.tokens)\n        for i in range(0, L):\n            item = self.tokens[i]\n            type_ = item.type_\n            if type_ == TVAR and item.index_ == variable:\n                for j in range(0, len(expr.tokens)):\n                    expritem = expr.tokens[j]\n                    replitem = Token(\n                        expritem.type_,\n                        expritem.index_,\n                        expritem.prio_,\n                        expritem.number_,\n                    )\n                    newexpression.append(replitem)\n            else:\n                newexpression.append(item)\n\n        ret = Expression(newexpression, self.ops1, self.ops2, self.functions)\n        return ret\n\n    def evaluate(self, values={}, to_device=False):\n        if to_device:\n            tasks = []\n            var = self.variables()\n            values = {v:i for i,v in enumerate(var)}\n            n3 = list(values.values())[-1] + 1\n        else:\n            values = values or {}\n        nstack = []\n        L = len(self.tokens)\n        for item in self.tokens:\n            type_ = item.type_\n            if type_ == TNUMBER:\n                nstack.append(item.number_)\n            elif type_ == TOP2:\n                n2 = nstack.pop()\n                n1 = nstack.pop()\n                f = self.ops2[item.index_]\n                if to_device:\n                    tasks.append(f(n1, n2, n3))\n                    nstack.append(n3)\n                    n3 += 1\n                else:\n                    nstack.append(f(n1, n2, device=False))\n            elif type_ == TVAR:\n                if item.index_ in values:\n                    nstack.append(values[item.index_])\n                elif item.index_ in self.functions:\n                    nstack.append(self.functions[item.index_])\n                else:\n                    raise Exception(\'undefined variable: \' + item.index_)\n            elif type_ == TOP1:\n                n1 = nstack.pop()\n                f = self.ops1[item.index_]\n                if to_device:\n                    tasks.append(f(n1, n3))\n                    nstack.append(n3)\n                    n3 += 1\n                else:\n                    nstack.append(f(n1), device=False)\n            elif type_ == TFUNCALL:\n                n1 = nstack.pop()\n                f = nstack.pop()\n                if callable(f):\n                    if type(n1) is list:\n                        nstack.append(f(*n1))\n                    else:\n                        nstack.append(f(n1))\n                else:\n                    raise Exception(f + \' is not a function\')\n            else:\n                raise Exception(\'invalid Expression\')\n        if len(nstack) > 1:\n            raise Exception(\'invalid Expression (parity)\')\n        if to_device:\n            return tasks\n        else:\n            return nstack[0]\n\n    def toString(self, toJS=False):\n        nstack = []\n        L = len(self.tokens)\n        for i in range(0, L):\n            item = self.tokens[i]\n            type_ = item.type_\n            if type_ == TNUMBER:\n                if type(item.number_) == str:\n                    nstack.append(""\'""+item.number_+""\'"")\n                else:\n                    nstack.append( item.number_)\n            elif type_ == TOP2:\n                n2 = nstack.pop()\n                n1 = nstack.pop()\n                f = item.index_\n                if toJS and f == \'^\':\n                    nstack.append(\'math.pow(\' + n1 + \',\' + n2 + \')\')\n                else:\n                    frm=\'({n1}{f}{n2})\'\n                    if f == \',\':\n                        frm = \'{n1}{f}{n2}\'\n\n                    nstack.append(frm.format(\n                        n1=n1,\n                        n2=n2,\n                        f=f,\n                    ))\n\n\n            elif type_ == TVAR:\n                nstack.append(item.index_)\n            elif type_ == TOP1:\n                n1 = nstack.pop()\n                f = item.index_\n                if f == \'-\':\n                    nstack.append(\'(\' + f + n1 + \')\')\n                else:\n                    nstack.append(f + \'(\' + n1 + \')\')\n            elif type_ == TFUNCALL:\n                n1 = nstack.pop()\n                f = nstack.pop()\n                nstack.append(f + \'(\' + n1 + \')\')\n            else:\n                raise Exception(\'invalid Expression\')\n        if len(nstack) > 1:\n            raise Exception(\'invalid Expression (parity)\')\n        return nstack[0]\n\n    def __str__(self):\n        return self.toString()\n\n    def symbols(self):\n        vars = []\n        for i in range(0, len(self.tokens)):\n            item = self.tokens[i]\n            if item.type_ == TVAR and not item.index_ in vars:\n                vars.append(item.index_)\n        return vars\n\n    def variables(self):\n        return [\n            sym for sym in self.symbols()\n            if sym not in self.functions]\n\nclass Parser:\n\n    #class Expression(Expression):\n    #    pass\n\n    PRIMARY      = 1\n    OPERATOR     = 2\n    FUNCTION     = 4\n    LPAREN       = 8\n    RPAREN       = 16\n    COMMA        = 32\n    SIGN         = 64\n    CALL         = 128\n    NULLARY_CALL = 256\n\n    def sin(self, a, c=None, device=True):\n        if device:\n            return (\'unary_func\', \'sin\', a, c)\n        else:\n            return np.sin(a)\n\n    def cos(self, a, c=None, device=True):\n        if device:\n            return (\'unary_func\', \'cos\', a, c)\n        else:\n            return np.cos(a)\n\n    def add(self, a, b, c=None, device=True):\n        if device:\n            return (\'binary_func\', \'add\', a, b, c)\n        else:\n            return np.add(a, b)\n\n    def sub(self, a, b):\n        return a - b\n\n    def mul(self, a, b, c=None, device=True):\n        if device:\n            return (\'binary_func\', \'mul\', a, b, c)\n        else:\n            return np.multiply(a, b)\n\n    def div(self, a, b):\n        return a / b\n\n    def mod(self, a, b):\n        return a % b\n\n    def concat(self, a, b,*args):\n        result=u\'{0}{1}\'.format(a, b)\n        for arg in args:\n            result=u\'{0}{1}\'.format(result, arg)\n        return result\n\n    def equal (self, a, b ):\n        return a == b\n\n    def notEqual (self, a, b ):\n        return a != b\n\n    def greaterThan (self, a, b ):\n        return a > b\n\n    def lessThan (self, a, b ):\n        return a < b\n\n    def greaterThanEqual (self, a, b ):\n        return a >= b\n\n    def lessThanEqual (self, a, b ):\n        return a <= b\n\n    def andOperator (self, a, b ):\n        return ( a and b )\n\n    def orOperator (self, a, b ):\n        return  ( a or  b )\n\n    def neg(self, a):\n        return -a\n\n    def random(self, a):\n        return math.random() * (a or 1)\n\n    def fac(self, a):  # a!\n        return math.factorial(a)\n\n    def pyt(self, a, b):\n        return math.sqrt(a * a + b * b)\n\n    def ifFunction(self,a,b,c):\n        return b if a else c\n\n    def append(self, a, b):\n        if type(a) != list:\n            return [a, b]\n        a.append(b)\n        return a\n\n    def __init__(self):\n        self.success = False\n        self.errormsg = \'\'\n        self.expression = \'\'\n\n        self.pos = 0\n\n        self.tokennumber = 0\n        self.tokenprio = 0\n        self.tokenindex = 0\n        self.tmpprio = 0\n\n        self.ops1 = {\n            \'sin\': self.sin,\n            \'cos\': self.cos,\n            \'tan\': math.tan,\n            \'asin\': math.asin,\n            \'acos\': math.acos,\n            \'atan\': math.atan,\n            \'sqrt\': math.sqrt,\n            \'log\': math.log,\n            \'abs\': abs,\n            \'ceil\': math.ceil,\n            \'floor\': math.floor,\n            \'round\': round,\n            \'-\': self.neg,\n            \'exp\': math.exp,\n        }\n\n        self.ops2 = {\n            \'+\': self.add,\n            \'-\': self.sub,\n            \'*\': self.mul,\n            \'/\': self.div,\n            \'%\': self.mod,\n            \'^\': math.pow,\n            \',\': self.append,\n            \'||\': self.concat,\n            ""=="": self.equal,\n            ""!="": self.notEqual,\n            "">"": self.greaterThan,\n            ""<"": self.lessThan,\n            "">="": self.greaterThanEqual,\n            ""<="": self.lessThanEqual,\n            ""and"": self.andOperator,\n            ""or"": self.orOperator\n        }\n\n        self.functions = {\n            \'random\': random,\n            \'fac\': self.fac,\n            \'min\': min,\n            \'max\': max,\n            \'pyt\': self.pyt,\n            \'pow\': math.pow,\n            \'atan2\': math.atan2,\n            \'concat\':self.concat,\n            \'if\': self.ifFunction\n        }\n\n        self.consts = {\n            \'E\': math.e,\n            \'PI\': math.pi,\n        }\n\n        self.values = {\n            \'sin\': math.sin,\n            \'cos\': math.cos,\n            \'tan\': math.tan,\n            \'asin\': math.asin,\n            \'acos\': math.acos,\n            \'atan\': math.atan,\n            \'sqrt\': math.sqrt,\n            \'log\': math.log,\n            \'abs\': abs,\n            \'ceil\': math.ceil,\n            \'floor\': math.floor,\n            \'round\': round,\n            \'random\': self.random,\n            \'fac\': self.fac,\n            \'exp\': math.exp,\n            \'min\': min,\n            \'max\': max,\n            \'pyt\': self.pyt,\n            \'pow\': math.pow,\n            \'atan2\': math.atan2,\n            \'E\': math.e,\n            \'PI\': math.pi\n        }\n\n    def parse(self, expr):\n        self.errormsg = \'\'\n        self.success = True\n        operstack = []\n        tokenstack = []\n        self.tmpprio = 0\n        expected = self.PRIMARY | self.LPAREN | self.FUNCTION | self.SIGN\n        noperators = 0\n        self.expression = expr\n        self.pos = 0\n\n        while self.pos < len(self.expression):\n            if self.isOperator():\n                if self.isSign() and expected & self.SIGN:\n                    if self.isNegativeSign():\n                        self.tokenprio = 5\n                        self.tokenindex = \'-\'\n                        noperators += 1\n                        self.addfunc(tokenstack, operstack, TOP1)\n                    expected = \\\n                        self.PRIMARY | self.LPAREN | self.FUNCTION | self.SIGN\n                elif self.isComment():\n                    pass\n                else:\n                    if expected and self.OPERATOR == 0:\n                        self.error_parsing(self.pos, \'unexpected operator\')\n                    noperators += 2\n                    self.addfunc(tokenstack, operstack, TOP2)\n                    expected = \\\n                        self.PRIMARY | self.LPAREN | self.FUNCTION | self.SIGN\n            elif self.isNumber():\n                if expected and self.PRIMARY == 0:\n                    self.error_parsing(self.pos, \'unexpected number\')\n                token = Token(TNUMBER, 0, 0, self.tokennumber)\n                tokenstack.append(token)\n                expected = self.OPERATOR | self.RPAREN | self.COMMA\n            elif self.isString():\n                if (expected & self.PRIMARY) == 0:\n                    self.error_parsing(self.pos, \'unexpected string\')\n                token = Token(TNUMBER, 0, 0, self.tokennumber)\n                tokenstack.append(token)\n                expected = self.OPERATOR | self.RPAREN | self.COMMA\n            elif self.isLeftParenth():\n                if (expected & self.LPAREN) == 0:\n                    self.error_parsing(self.pos, \'unexpected \\""(\\""\')\n                if expected & self.CALL:\n                    noperators += 2\n                    self.tokenprio = -2\n                    self.tokenindex = -1\n                    self.addfunc(tokenstack, operstack, TFUNCALL)\n                expected = \\\n                    self.PRIMARY | self.LPAREN | self.FUNCTION | \\\n                    self.SIGN | self.NULLARY_CALL\n            elif self.isRightParenth():\n                if expected & self.NULLARY_CALL:\n                    token = Token(TNUMBER, 0, 0, [])\n                    tokenstack.append(token)\n                elif (expected & self.RPAREN) == 0:\n                    self.error_parsing(self.pos, \'unexpected \\"")\\""\')\n                expected = \\\n                    self.OPERATOR | self.RPAREN | self.COMMA | \\\n                    self.LPAREN | self.CALL\n            elif self.isComma():\n                if (expected & self.COMMA) == 0:\n                    self.error_parsing(self.pos, \'unexpected \\"",\\""\')\n                self.addfunc(tokenstack, operstack, TOP2)\n                noperators += 2\n                expected = \\\n                    self.PRIMARY | self.LPAREN | self.FUNCTION | self.SIGN\n            elif self.isConst():\n                if (expected & self.PRIMARY) == 0:\n                    self.error_parsing(self.pos, \'unexpected constant\')\n                consttoken = Token(TNUMBER, 0, 0, self.tokennumber)\n                tokenstack.append(consttoken)\n                expected = self.OPERATOR | self.RPAREN | self.COMMA\n            elif self.isOp2():\n                if (expected & self.FUNCTION) == 0:\n                    self.error_parsing(self.pos, \'unexpected function\')\n                self.addfunc(tokenstack, operstack, TOP2)\n                noperators += 2\n                expected = self.LPAREN\n            elif self.isOp1():\n                if (expected & self.FUNCTION) == 0:\n                    self.error_parsing(self.pos, \'unexpected function\')\n                self.addfunc(tokenstack, operstack, TOP1)\n                noperators += 1\n                expected = self.LPAREN\n            elif self.isVar():\n                if (expected & self.PRIMARY) == 0:\n                    self.error_parsing(self.pos, \'unexpected variable\')\n                vartoken = Token(TVAR, self.tokenindex, 0, 0)\n                tokenstack.append(vartoken)\n                expected = \\\n                    self.OPERATOR | self.RPAREN | \\\n                    self.COMMA | self.LPAREN | self.CALL\n            elif self.isWhite():\n                pass\n            else:\n                if self.errormsg == \'\':\n                    self.error_parsing(self.pos, \'unknown character\')\n                else:\n                    self.error_parsing(self.pos, self.errormsg)\n        if self.tmpprio < 0 or self.tmpprio >= 10:\n            self.error_parsing(self.pos, \'unmatched \\""()\\""\')\n        while len(operstack) > 0:\n            tmp = operstack.pop()\n            tokenstack.append(tmp)\n        if (noperators + 1) != len(tokenstack):\n            self.error_parsing(self.pos, \'parity\')\n\n        return Expression(tokenstack, self.ops1, self.ops2, self.functions)\n\n    def evaluate(self, expr, variables):\n        return self.parse(expr).evaluate(variables)\n\n    def error_parsing(self, column, msg):\n        self.success = False\n        self.errormsg = \'parse error [column \' + str(column) + \']: \' + msg\n        raise Exception(self.errormsg)\n\n    def addfunc(self, tokenstack, operstack, type_):\n        operator = Token(\n            type_,\n            self.tokenindex,\n            self.tokenprio + self.tmpprio,\n            0,\n        )\n        while len(operstack) > 0:\n            if operator.prio_ <= operstack[len(operstack) - 1].prio_:\n                tokenstack.append(operstack.pop())\n            else:\n                break\n        operstack.append(operator)\n\n    def isNumber(self):\n        r = False\n        str = \'\'\n        while self.pos < len(self.expression):\n            code = self.expression[self.pos]\n            if (code >= \'0\' and code <= \'9\') or code == \'.\':\n                if (len(str) == 0 and code == \'.\' ):\n                    str = \'0\'\n                str += code\n                self.pos += 1\n                self.tokennumber = float(str)\n                r = True\n            else:\n                break\n        return r\n\n    def unescape(self, v, pos):\n        buffer = []\n        escaping = False\n\n        for i in range(0, len(v)):\n            c = v[i]\n\n            if escaping:\n                if c == ""\'"":\n                    buffer.append(""\'"")\n                    break\n                elif c == \'\\\\\':\n                    buffer.append(\'\\\\\')\n                    break\n                elif c == \'/\':\n                    buffer.append(\'/\')\n                    break\n                elif c == \'b\':\n                    buffer.append(\'\\b\')\n                    break\n                elif c == \'f\':\n                    buffer.append(\'\\f\')\n                    break\n                elif c == \'n\':\n                    buffer.append(\'\\n\')\n                    break\n                elif c == \'r\':\n                    buffer.append(\'\\r\')\n                    break\n                elif c == \'t\':\n                    buffer.append(\'\\t\')\n                    break\n                elif c == \'u\':\n                    # interpret the following 4 characters\n                    # as the hex of the unicode code point\n                    codePoint = int(v[i + 1, i + 5], 16)\n                    buffer.append(unichr(codePoint))\n                    i += 4\n                    break\n                else:\n                    raise self.error_parsing(\n                        pos + i,\n                        \'Illegal escape sequence: \\\'\\\\\' + c + \'\\\'\',\n                    )\n                escaping = False\n            else:\n                if c == \'\\\\\':\n                    escaping = True\n                else:\n                    buffer.append(c)\n\n        return \'\'.join(buffer)\n\n    def isString(self):\n        r = False\n        str = \'\'\n        startpos = self.pos\n        if self.pos < len(self.expression) and self.expression[self.pos] == ""\'"":\n            self.pos += 1\n            while self.pos < len(self.expression):\n                code = self.expression[self.pos]\n                if code != \'\\\'\' or (str != \'\' and str[-1] == \'\\\\\'):\n                    str += self.expression[self.pos]\n                    self.pos += 1\n                else:\n                    self.pos += 1\n                    self.tokennumber = self.unescape(str, startpos)\n                    r = True\n                    break\n        return r\n\n    def isConst(self):\n        for i in self.consts:\n            L = len(i)\n            str = self.expression[self.pos:self.pos+L]\n            if i == str:\n                if len(self.expression) <= self.pos + L:\n                    self.tokennumber = self.consts[i]\n                    self.pos += L\n                    return True\n                if not self.expression[self.pos + L].isalnum() and self.expression[self.pos + L] != ""_"":\n                    self.tokennumber = self.consts[i]\n                    self.pos += L\n                    return True\n        return False\n\n    def isOperator(self):\n        ops = (\n            (\'+\', 2, \'+\'),\n            (\'-\', 2, \'-\'),\n            (\'*\', 3, \'*\'),\n            (u\'\\u2219\', 3, \'*\'), # bullet operator\n            (u\'\\u2022\', 3, \'*\'), # black small circle\n            (\'/\', 4, \'/\'),\n            (\'%\', 4, \'%\'),\n            (\'^\', 6, \'^\'),\n            (\'||\', 1, \'||\'),\n            (\'==\', 1, \'==\'),\n            (\'!=\', 1, \'!=\'),\n            (\'<=\', 1, \'<=\'),\n            (\'>=\', 1, \'>=\'),\n            (\'<\', 1, \'<\'),\n            (\'>\', 1, \'>\'),\n            (\'and\', 0, \'and\'),\n            (\'or\', 0, \'or\'),\n        )\n        for token, priority, index in ops:\n            if self.expression.startswith(token, self.pos):\n                self.tokenprio = priority\n                self.tokenindex = index\n                self.pos += len(token)\n                return True\n        return False\n\n    def isSign(self):\n        code = self.expression[self.pos - 1]\n        return (code == \'+\') or (code == \'-\')\n\n    def isPositiveSign(self):\n        code = self.expression[self.pos - 1]\n        return code == \'+\'\n\n    def isNegativeSign(self):\n        code = self.expression[self.pos - 1]\n        return code == \'-\'\n\n    def isLeftParenth(self):\n        code = self.expression[self.pos]\n        if code == \'(\':\n            self.pos += 1\n            self.tmpprio += 10\n            return True\n        return False\n\n    def isRightParenth(self):\n        code = self.expression[self.pos]\n        if code == \')\':\n            self.pos += 1\n            self.tmpprio -= 10\n            return True\n        return False\n\n    def isComma(self):\n        code = self.expression[self.pos]\n        if code==\',\':\n            self.pos+=1\n            self.tokenprio=-1\n            self.tokenindex="",""\n            return True\n        return False\n\n    def isWhite(self):\n        code = self.expression[self.pos]\n        if code.isspace():\n            self.pos += 1\n            return True\n        return False\n\n    def isOp1(self):\n        str = \'\'\n        for i in range(self.pos, len(self.expression)):\n            c = self.expression[i]\n            if c.upper() == c.lower():\n                if i == self.pos or (c != \'_\' and (c < \'0\' or c > \'9\')):\n                    break\n            str += c\n        if len(str) > 0 and str in self.ops1:\n            self.tokenindex = str\n            self.tokenprio = 7\n            self.pos += len(str)\n            return True\n        return False\n\n    def isOp2(self):\n        str = \'\'\n        for i in range(self.pos, len(self.expression)):\n            c = self.expression[i]\n            if c.upper() == c.lower():\n                if i == self.pos or (c != \'_\' and (c < \'0\' or c > \'9\')):\n                    break\n            str += c\n        if len(str) > 0 and (str in self.ops2):\n            self.tokenindex = str\n            self.tokenprio = 7\n            self.pos += len(str)\n            return True\n        return False\n\n    def isVar(self):\n        str = \'\'\n        inQuotes = False\n        for i in range(self.pos, len(self.expression)):\n            c = self.expression[i]\n            if c.lower() == c.upper():\n                if ((i == self.pos and c != \'""\') or (not (c in \'_.""\') and (c < \'0\' or c > \'9\'))) and not inQuotes :\n                    break\n            if c == \'""\':\n                inQuotes = not inQuotes\n            str += c\n        if str:\n            self.tokenindex = str\n            self.tokenprio = 4\n            self.pos += len(str)\n            return True\n        return False\n\n    def isComment(self):\n        code = self.expression[self.pos - 1]\n        if code == \'/\' and self.expression[self.pos] == \'*\':\n            self.pos = self.expression.index(\'*/\', self.pos) + 2\n            if self.pos == 1:\n                self.pos = len(self.expression)\n            return True\n        return False\n'"
bundle/fpga2ddr.py,0,"b'from pyclk import Sig, Reg, In, Out, List, Module\n\nclass fpga2ddr(Module):\n\n    def __init__(self):\n        self.IDLE, self.COUNTING, self.COMPLETE = range(3)\n        self.r_state = Reg()\n        self.r_addr = Reg()\n        self.r_addr_reg = Reg()\n        self.r_rena = Reg()\n        self.r_rvalid = Reg()\n        self.r_done = Reg()\n\n        # I/O\n        self.array_ptr   = None\n        self.o_mem_addr  = Out()\n        self.i_mem_dout  = In()\n        self.i_data_nb   = In()\n        self.o_done      = Out()\n\n    def logic(self):\n        if self.r_state.q == self.IDLE:\n            if self.i_data_nb.d != 0:\n                self.r_state.d = self.COUNTING\n                self.r_rena.d = 1\n        elif self.r_state.q == self.COUNTING:\n            if self.r_addr.q == self.i_data_nb.d - 1:\n                self.r_state.d = self.COMPLETE\n                self.r_rena.d = 0\n                self.r_done.d = 1\n                self.r_addr.d = 0\n            else:\n                self.r_addr.d = self.r_addr.q + 1\n        elif self.r_state.q == self.COMPLETE:\n            if self.i_data_nb.d == 0:\n                self.r_state.d = self.IDLE\n                self.r_done.d = 0\n        else:\n            self.r_state.d = self.IDLE\n\n        self.r_rvalid.d = self.r_rena.q\n        self.r_addr_reg.d = self.r_addr.q\n        self.o_mem_addr.d = self.r_addr.q\n        if self.r_rvalid.q == 1:\n            self.array_ptr[self.r_addr_reg.q] = self.i_mem_dout.d\n        self.o_done.d = self.r_done.q\n'"
bundle/fpga_config.py,0,"b""class FPGA_config(object):\n    def __init__(self, ddr2fpga_nb, fpga2ddr_nb, iter_nb, mem_nb, mem_depth, add_nb, mul_nb):\n        self.func_layout = {'add': add_nb, 'mul': mul_nb}\n        func_nb = sum(self.func_layout.values())\n        self.config = {\n                'ddr2fpga_nb': ddr2fpga_nb,\n                'fpga2ddr_nb': fpga2ddr_nb,\n                'iter_nb': iter_nb,\n                'func_nb': func_nb,\n                'mem_nb': mem_nb,\n                'mem_depth': mem_depth\n                }\n        i = 0\n        for fname, fnb in self.func_layout.items():\n            self.config[f'{fname}_nb'] = fnb\n            self.config[f'{fname}_i0'] = i\n            self.config[f'{fname}_i1'] = i + fnb\n            i += fnb\n"""
bundle/fpga_dashboard.py,0,"b""import matplotlib.pyplot as plt\n\nclass Dashboard(object):\n    def __init__(self, config):\n        self.config = config\n        self.opnb = config['ddr2fpga_nb'] + config['iter_nb'] + config['add_nb'] + config['mul_nb'] + config['fpga2ddr_nb']\n        self.prev_time = 0\n        self.prev_busy = [False for i in range(self.opnb)]\n        self.bar = {'t0': [], 't1': [], 'c': []}\n\n    def show(self):\n        plt.figure(figsize=(16, 5))\n        for i, colors in enumerate(self.bar['c']):\n            b = plt.barh(range(self.opnb, 0, -1), [self.bar['t1'][i] - self.bar['t0'][i]] * self.opnb, left=self.bar['t0'][i])\n            for j, c in enumerate(colors):\n                b[j].set_color(c)\n\n    def set(self, what, which, time, busy):\n        nb = 0\n        if what == 'ddr2fpga':\n            offset = nb\n        nb += self.config['ddr2fpga_nb']\n        if what == 'iter':\n            offset = nb\n        nb += self.config['iter_nb']\n        if what == 'add':\n            offset = nb\n        nb += self.config['add_nb']\n        if what == 'mul':\n            offset = nb\n            which -= self.config['add_nb']\n        nb += self.config['mul_nb']\n        if what == 'fpga2ddr':\n            offset = nb\n        self.bar['c'].append([])\n        for i in range(self.opnb):\n            if i < self.config['ddr2fpga_nb']:\n                color = 'r'\n            elif i < self.config['ddr2fpga_nb'] + self.config['iter_nb']:\n                color = 'b'\n            elif i < self.config['ddr2fpga_nb'] + self.config['iter_nb'] + self.config['add_nb']:\n                color = 'y'\n            elif i < self.config['ddr2fpga_nb'] + self.config['iter_nb'] + self.config['add_nb'] + self.config['add_nb']:\n                color = 'g'\n            else:\n                color = 'r'\n            if self.prev_busy[i]:\n                self.bar['c'][-1].append(color)\n            else:\n                self.bar['c'][-1].append('w')\n        self.bar['t1'].append(time)\n        self.bar['t0'].append(self.prev_time)\n        self.prev_time = time\n        self.prev_busy[offset + which] = busy\n"""
bundle/fpga_dashboard_bqp.py,0,"b""from bqplot import OrdinalScale, LinearScale, OrdinalColorScale, Bars, Axis, Figure\nfrom ipywidgets import VBox, Layout\n\nclass Dashboard(object):\n    def __init__(self, fpga):\n        self.fpga = fpga\n\n        ddr2fpga = self.get_figs('ddr2fpga', 'Red')\n        iterators = self.get_figs('iter', 'Blue')\n        add = self.get_figs('add', 'Yellow')\n        mul = self.get_figs('mul', 'Green')\n        fpga2ddr = self.get_figs('fpga2ddr', 'Red')\n\n        nb = self.fpga.config['ddr2fpga_nb'] + self.fpga.config['iter_nb'] + self.fpga.config['add_nb'] + self.fpga.config['mul_nb'] + self.fpga.config['fpga2ddr_nb']\n        self.prev_time = [0 for i in range(nb)]\n        self.prev_busy = [False for i in range(nb)]\n        self.db = VBox(ddr2fpga + iterators + add + mul + fpga2ddr)\n\n    def get_figs(self, opname, color):\n        x = OrdinalScale()\n        y = LinearScale()\n        col_sc = OrdinalColorScale(colors=['White', color])\n        figs = []\n        for _ in range(self.fpga.config[f'{opname}_nb']):\n            time = [[0, 0], [0, 0]]\n            busy = [False, False]\n            \n            bar = Bars(x=[0], y=time, scales={'x': x, 'y': y, 'color': col_sc}, orientation='horizontal', stroke='White')\n            xax = Axis(scale=x, orientation='vertical')\n            yax = Axis(scale=y, orientation='horizontal', num_ticks=0)\n            \n            bar.color = busy\n            \n            fig = Figure(marks=[bar], axes=[xax, yax], background_style={'fill': 'White'}, layout=Layout(width='99%', height='10px'), fig_margin={'top': 0, 'bottom': 0, 'left': 0, 'right': 0})\n            figs.append(fig)\n        return figs\n\n    def show(self):\n        return self.db\n\n    def set(self, what, which, time, busy):\n        nb = 0\n        if what == 'ddr2fpga':\n            offset = nb\n        nb += self.fpga.config['ddr2fpga_nb']\n        if what == 'iter':\n            offset = nb\n        nb += self.fpga.config['iter_nb']\n        if what == 'add':\n            offset = nb\n        nb += self.fpga.config['add_nb']\n        if what == 'mul':\n            offset = nb\n            which -= self.fpga.config['add_nb']\n        nb += self.fpga.config['mul_nb']\n        if what == 'fpga2ddr':\n            offset = nb\n        child = self.db.children[offset + which]\n        bar = child.marks[0]\n        busys = list(bar.color)\n        busys.append(self.prev_busy[offset + which])\n        self.prev_busy[offset + which] = busy\n        times = []\n        for row in bar.y:\n            times.append(list(row))\n        times.append(list(times[-1]))\n        times[-1][0] = time - self.prev_time[offset + which]\n        self.prev_time[offset + which] = time\n        for i in range(len(times)):\n            times[i] += [0]\n        bar.color = busys\n        bar.y = times\n"""
bundle/fpga_device.py,1,"b""from .fpga_state import FPGA_state\nimport numpy as np\nimport asyncio\nfrom time import time\nfrom numba import jit\n\nclass Device(object):\n    def __init__(self, config, fpga, debug=False, dashboard=None):\n        self.maxitemsize = 8\n        #self.chunk_array = [np.empty(shape=(config.config['mem_depth'],), dtype=f'uint{self.maxitemsize*8}') for i in range(config.config['mem_nb'])]\n        #self.chunk_array_saved = list(self.chunk_array)\n\n        self.state = FPGA_state(config)\n        self.config = config.config\n        self.fpga = fpga\n        self.debug = debug\n        self.dashboard = dashboard\n\n    # Arguments\n\n    async def arg_chunk(self, data_nb, mem_i, input_array):\n        if self.debug:\n            print(f'arg_chunk(data_nb={data_nb}, mem_i={mem_i}, input_array)')\n        self.fpga.chunk_array[mem_i][:data_nb] = input_array[:data_nb]\n        while self.state.free_ddr2fpga_nb == 0:\n            await self.state.ddr2fpga_freed.wait()\n            self.state.ddr2fpga_freed.clear()\n        ddr2fpga_i = self.state.ddr2fpga_alloc()\n        if self.debug:\n            print(f'ddr2fpga start (mem_i = {mem_i}, ddr2fpga_i = {ddr2fpga_i})')\n        if self.dashboard:\n            self.dashboard.set('ddr2fpga', ddr2fpga_i, self.fpga.time, True)\n        await self.fpga.ddr2fpga(ddr2fpga_i, mem_i, self.fpga.chunk_array[mem_i], data_nb)\n        if self.dashboard:\n            self.dashboard.set('ddr2fpga', ddr2fpga_i, self.fpga.time, False)\n        self.state.ddr2fpga_free(ddr2fpga_i)\n        if self.debug:\n            print(f'ddr2fpga done (mem_i = {mem_i}, ddr2fpga_i = {ddr2fpga_i})')\n\n    # Results\n\n    async def res_chunk(self, data_nb, mem_i, output_array, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        while self.state.free_fpga2ddr_nb == 0:\n            await self.state.fpga2ddr_freed.wait()\n            self.state.fpga2ddr_freed.clear()\n        fpga2ddr_i = self.state.fpga2ddr_alloc()\n        if self.debug:\n            print(f'fpga2ddr start (mem_i = {mem_i}, fpga2ddr_i = {fpga2ddr_i})')\n        if self.dashboard:\n            self.dashboard.set('fpga2ddr', fpga2ddr_i, self.fpga.time, True)\n        await self.fpga.fpga2ddr(fpga2ddr_i, mem_i, self.fpga.chunk_array[mem_i], data_nb)\n        if self.dashboard:\n            self.dashboard.set('fpga2ddr', fpga2ddr_i, self.fpga.time, False)\n        self.state.fpga2ddr_free(fpga2ddr_i)\n        output_array[:data_nb] = self.fpga.chunk_array[mem_i][:data_nb]\n        if self.debug:\n            print(f'fpga2ddr done (mem_i = {mem_i}, fpga2ddr_i = {fpga2ddr_i})')\n\n    # Functions\n\n    async def binary_func(self, func, data_nb, mem_i0, mem_i1, mem_i2, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        if self.debug:\n            print(f'binary_func({func}) start (mem_i0 = {mem_i0}, mem_i1 = {mem_i1}, mem_i2 = {mem_i2})')\n        while self.state.free_func_nb[func] == 0:\n            await self.state.func_freed[func].wait()\n            self.state.func_freed[func].clear()\n        func_i = self.state.func_alloc(func)\n        while self.state.free_iter_nb == 0:\n            await self.state.iter_freed.wait()\n            self.state.iter_freed.clear()\n        iter_i = self.state.iter_alloc()\n        if self.dashboard:\n            self.dashboard.set('iter', iter_i, self.fpga.time, True)\n            self.dashboard.set(func, func_i, self.fpga.time, True)\n        await self.fpga.op(iter_i, func_i, mem_i0, mem_i1, mem_i2, data_nb)\n        if self.dashboard:\n            self.dashboard.set('iter', iter_i, self.fpga.time, False)\n            self.dashboard.set(func, func_i, self.fpga.time, False)\n        # free ressources\n        self.state.func_free(func, func_i)\n        self.state.iter_free(iter_i)\n        if self.debug:\n            print(f'binary_func({func}) done (mem_i0 = {mem_i0}, mem_i1 = {mem_i1}, mem_i2 = {mem_i2})')\n\n    async def free_mem(self, mem, await_tasks=[]):\n        for t in await_tasks:\n            await t\n        for i in mem:\n            self.state.mem_free(i)\n"""
bundle/fpga_pynq.py,1,"b""from .fpga_state import FPGA_state\nfrom pynq import Xlnk\nimport numpy as np\n\nclass PYNQ(object):\n    def __init__(self, fpga_config, overlay):\n        ddr2fpga_nb = fpga_config.config['ddr2fpga_nb']\n        fpga2ddr_nb = fpga_config.config['fpga2ddr_nb']\n        mem_nb = fpga_config.config['mem_nb']\n        self.u_axi_dma_ddr2fpga = [overlay.__getattr__(f'axi_dma_ddr2fpga_{i}') for i in range(ddr2fpga_nb)]\n        self.u_axi_dma_fpga2ddr = [overlay.__getattr__(f'axi_dma_fpga2ddr_{i}') for i in range(fpga2ddr_nb)]\n        self.u_mem = [overlay.__getattr__(f'memory_{i}') for i in range(mem_nb)]\n        self.u_func = []\n        for name, nb in fpga_config.func_layout.items():\n            self.u_func += [overlay.__getattr__(f'{name}_{i}') for i in range(nb)]\n        self.u_ddr2fpga = [overlay.__getattr__(f'ddr2fpga_{i}') for i in range(ddr2fpga_nb)]\n        # enable function interrupts\n        for i in self.u_func:\n            i.write(0x04, 1)\n            i.write(0x08, 1)\n\n        xlnk = Xlnk()\n        self.chunk_array = [xlnk.cma_array(shape=(fpga_config.config['mem_depth'],), dtype=np.uint64) for i in range(fpga_config.config['mem_nb'])]\n\n        self.state = FPGA_state(fpga_config)\n        self.config = fpga_config.config\n\n    async def op(self, iter_i, func_i, rmem0_i, rmem1_i, wmem_i, data_nb):\n        # operation request\n        # memory for arg0\n        self.u_mem[rmem0_i].write(0x10, 2) # mode\n        self.u_mem[rmem0_i].write(0x18, data_nb)\n        self.u_mem[rmem0_i].write(0x20, 2 * func_i) # TDEST\n        self.u_mem[rmem0_i].write(0x00, 1) # ap_start\n        # memory for arg1\n        self.u_mem[rmem1_i].write(0x10, 2) # mode\n        self.u_mem[rmem1_i].write(0x18, data_nb)\n        self.u_mem[rmem1_i].write(0x20, 2 * func_i + 1) # TDEST\n        self.u_mem[rmem1_i].write(0x00, 1) # ap_start\n        # memory for result\n        self.u_mem[wmem_i].write(0x10, 3) # mode\n        self.u_mem[wmem_i].write(0x18, data_nb)\n        self.u_mem[wmem_i].write(0x00, 1) # ap_start\n        # function\n        self.u_func[func_i].write(0x10, data_nb)\n        self.u_func[func_i].write(0x18, wmem_i) # TDEST\n        self.u_func[func_i].write(0x00, 1) # ap_start\n        # operation completion check\n        await self.u_func[func_i].interrupt.wait()\n        self.u_func[func_i].write(0x0C, 1) # clear interrupt\n\n    async def ddr2fpga(self, ddr2fpga_i, mem_i, array_ptr, data_nb):\n        # memory write\n        self.u_mem[mem_i].write(0x10, 0) # mode\n        self.u_mem[mem_i].write(0x18, data_nb)\n        self.u_mem[mem_i].write(0x00, 1) # ap_start\n        self.u_ddr2fpga[ddr2fpga_i].write(0x10, data_nb)\n        self.u_ddr2fpga[ddr2fpga_i].write(0x18, mem_i) # TDEST\n        self.u_ddr2fpga[ddr2fpga_i].write(0x00, 1) # ap_start\n        ptr = array_ptr.physical_address\n        array_ptr = array_ptr[:data_nb]\n        array_ptr.physical_address = ptr\n        array_ptr.cacheable = 0\n        self.u_axi_dma_ddr2fpga[ddr2fpga_i].sendchannel.transfer(array_ptr)\n        # memory copy completion check\n        await self.u_axi_dma_ddr2fpga[ddr2fpga_i].sendchannel.wait_async()\n\n    async def fpga2ddr(self, fpga2ddr_i, mem_i, array_ptr, data_nb):\n        # memory read\n        ptr = array_ptr.physical_address\n        array_ptr = array_ptr[:data_nb]\n        array_ptr.physical_address = ptr\n        array_ptr.cacheable = 0\n        self.u_axi_dma_fpga2ddr[fpga2ddr_i].recvchannel.transfer(array_ptr)\n        self.u_mem[mem_i].write(0x10, 1) # mode\n        self.u_mem[mem_i].write(0x18, data_nb)\n        self.u_mem[mem_i].write(0x20, fpga2ddr_i)\n        self.u_mem[mem_i].write(0x00, 1) # ap_start\n        # memory copy completion check\n        await self.u_axi_dma_fpga2ddr[fpga2ddr_i].recvchannel.wait_async()\n"""
bundle/fpga_simu.py,1,"b""from pyclk import Sig, Reg, In, Out, List, Module\n\nfrom .memory import memory\nfrom .ddr2fpga import ddr2fpga\nfrom .fpga2ddr import fpga2ddr\nfrom .iterator import iterator\nfrom .functions import func\nfrom .fpga_state import FPGA_state\n\nfrom random import randint\nimport asyncio\nimport numpy as np\n\nclass Simu(Module):\n    def __init__(self, fpga_config):\n        self.func_layout = fpga_config.func_layout\n        self.mem_nb = fpga_config.config['mem_nb']\n        self.ddr2fpga_nb = fpga_config.config['ddr2fpga_nb']\n        self.fpga2ddr_nb = fpga_config.config['fpga2ddr_nb']\n        self.func_nb = fpga_config.config['func_nb']\n        self.iter_nb = fpga_config.config['iter_nb']\n        self.mem_depth = fpga_config.config['mem_depth']\n\n        self.chunk_array = [[0 for j in range(fpga_config.config['mem_depth'])] for i in range(fpga_config.config['mem_nb'])]\n        #self.chunk_array = [np.zeros(fpga_config.config['mem_depth'], dtype=np.uint64) for i in range(fpga_config.config['mem_nb'])]\n\n        self.cycle_nb = -1\n        self.randmax = 2\n\n        self.trace = None\n\n        # memories\n        self.u_mem = List()\n        self.s_mem_wena = List()\n        self.s_mem_addr = List()\n        self.s_mem_din = List()\n        self.s_mem_dout = List()\n        for i in range(self.mem_nb):\n            self.s_mem_wena[i] = Sig()\n            self.s_mem_addr[i] = Sig()\n            self.s_mem_din[i] = Sig()\n            self.s_mem_dout[i] = Sig()\n\n            self.u_mem[i] = _ = memory(self.mem_depth)\n            _.i_wena    (self.s_mem_wena[i])\n            _.i_addr    (self.s_mem_addr[i])\n            _.i_din     (self.s_mem_din[i])\n            _.o_dout    (self.s_mem_dout[i])\n\n        # ddr2fpga\n        self.u_ddr2fpga = List()\n        self.s_ddr2fpga_mem_i = List()\n        self.s_ddr2fpga_data_nb = List()\n        self.s_ddr2fpga_done = List()\n        self.s_ddr2fpga_wena = List()\n        self.s_ddr2fpga_addr = List()\n        self.s_ddr2fpga_din = List()\n\n        for i in range(self.ddr2fpga_nb):\n            self.s_ddr2fpga_mem_i[i] = Sig()\n            self.s_ddr2fpga_data_nb[i] = Sig()\n            self.s_ddr2fpga_done[i] = Sig()\n            self.s_ddr2fpga_wena[i] = Sig()\n            self.s_ddr2fpga_addr[i] = Sig()\n            self.s_ddr2fpga_din[i] = Sig()\n\n            self.u_ddr2fpga[i] = _ = ddr2fpga()\n            _.i_data_nb     (self.s_ddr2fpga_data_nb[i])\n            _.o_done        (self.s_ddr2fpga_done[i])\n            _.o_mem_wena    (self.s_ddr2fpga_wena[i])\n            _.o_mem_addr    (self.s_ddr2fpga_addr[i])\n            _.o_mem_din     (self.s_ddr2fpga_din[i])\n\n        # fpga2ddr\n        self.s_fpga2ddr_mem_i = List()\n        self.s_fpga2ddr_data_nb = List()\n        self.s_fpga2ddr_done = List()\n        self.s_fpga2ddr_addr = List()\n        self.s_fpga2ddr_mem_dout = List()\n        self.u_fpga2ddr = List()\n\n        for i in range(self.fpga2ddr_nb):\n            self.s_fpga2ddr_mem_dout[i] = Sig()\n            self.s_fpga2ddr_addr[i] = Sig()\n            self.s_fpga2ddr_mem_i[i] = Sig()\n            self.s_fpga2ddr_data_nb[i] = Sig()\n            self.s_fpga2ddr_done[i] = Sig()\n\n            self.u_fpga2ddr[i] = _ = fpga2ddr()\n            _.i_data_nb  (self.s_fpga2ddr_data_nb[i])\n            _.o_done     (self.s_fpga2ddr_done[i])\n            _.o_mem_addr (self.s_fpga2ddr_addr[i])\n            _.i_mem_dout (self.s_fpga2ddr_mem_dout[i])\n\n        # iterators\n        self.u_iter = List()\n        self.s_iter_data_nb = List()\n        self.s_iter_done = List()\n        self.s_iter_raddr = List()\n        self.s_iter_waddr = List()\n        self.s_iter_wena = List()\n        self.s_iter_arg_valid = List()\n        self.s_iter_res_valid = List()\n        for i in range(self.iter_nb):\n            self.s_iter_data_nb[i] = Sig()\n            self.s_iter_done[i] = Sig()\n            self.s_iter_raddr[i] = Sig()\n            self.s_iter_waddr[i] = Sig()\n            self.s_iter_wena[i] = Sig()\n            self.s_iter_arg_valid[i] = Sig()\n            self.s_iter_res_valid[i] = Sig()\n\n            self.u_iter[i] = _ = iterator()\n            _.i_data_nb     (self.s_iter_data_nb[i])\n            _.o_done        (self.s_iter_done[i])\n            _.o_raddr       (self.s_iter_raddr[i])\n            _.o_waddr       (self.s_iter_waddr[i])\n            _.o_wena        (self.s_iter_wena[i])\n            _.o_arg_valid   (self.s_iter_arg_valid[i])\n            _.i_res_valid   (self.s_iter_res_valid[i])\n\n        # functions\n        self.u_func = List()\n        self.s_func_arg0 = List()\n        self.s_func_arg1 = List()\n        self.s_func_arg_valid = List()\n        self.s_func_res = List()\n        self.s_func_res_valid = List()\n        i = 0\n        for fname, fnb in self.func_layout.items():\n            for j in range(fnb):\n                self.s_func_arg0[i] = Sig()\n                self.s_func_arg1[i] = Sig()\n                self.s_func_arg_valid[i] = Sig()\n                self.s_func_res[i] = Sig()\n                self.s_func_res_valid[i] = Sig()\n\n                self.u_func[i] = _ = func(fname)\n                _.i_arg0        (self.s_func_arg0[i])\n                _.i_arg1        (self.s_func_arg1[i])\n                _.i_arg_valid   (self.s_func_arg_valid[i])\n                _.o_res         (self.s_func_res[i])\n                _.o_res_valid   (self.s_func_res_valid[i])\n\n                i += 1\n\n        self.s_iter_rmem0_i = List()\n        self.s_iter_rmem1_i = List()\n        self.s_iter_wmem_i = List()\n        self.s_iter_func_i = List()\n\n        for i in range(self.iter_nb):\n            self.s_iter_rmem0_i[i] = Sig()\n            self.s_iter_rmem1_i[i] = Sig()\n            self.s_iter_wmem_i[i] = Sig()\n            self.s_iter_func_i[i] = Sig()\n\n        self.state = FPGA_state(fpga_config)\n        self.config = fpga_config.config\n\n    def logic(self):\n        # DDR <-> memory\n        for i in range(self.mem_nb):\n            self.s_mem_addr[i].d = 0\n            self.s_mem_din[i].d  = 0\n            self.s_mem_wena[i].d = 0\n        for i in range(self.fpga2ddr_nb):\n            self.s_mem_addr[self.s_fpga2ddr_mem_i[i].d].d       += self.s_fpga2ddr_addr[i].d\n            self.s_fpga2ddr_mem_dout[i].d                        = self.s_mem_dout[self.s_fpga2ddr_mem_i[i].d].d\n        for i in range(self.ddr2fpga_nb):\n            self.s_mem_wena[self.s_ddr2fpga_mem_i[i].d].d       += self.s_ddr2fpga_wena[i].d\n            self.s_mem_addr[self.s_ddr2fpga_mem_i[i].d].d       += self.s_ddr2fpga_addr[i].d\n            self.s_mem_din[self.s_ddr2fpga_mem_i[i].d].d        += self.s_ddr2fpga_din[i].d\n\n        # memory <-> iterator <-> function\n        for i in range(self.func_nb):\n            self.s_func_arg_valid[i].d = 0\n            self.s_func_arg0[i].d = 0\n            self.s_func_arg1[i].d = 0\n        for i in range(self.iter_nb):\n            self.s_mem_addr[self.s_iter_rmem0_i[i].d].d         += self.s_iter_raddr[i].d\n            self.s_mem_addr[self.s_iter_rmem1_i[i].d].d         += self.s_iter_raddr[i].d\n            self.s_mem_addr[self.s_iter_wmem_i[i].d].d          += self.s_iter_waddr[i].d\n            self.s_mem_wena[self.s_iter_wmem_i[i].d].d          += self.s_iter_wena[i].d\n            self.s_func_arg_valid[self.s_iter_func_i[i].d].d    += self.s_iter_arg_valid[i].d\n            self.s_iter_res_valid[i].d                           = self.s_func_res_valid[self.s_iter_func_i[i].d].d\n            if self.s_iter_data_nb[i].d != 0:\n                self.s_mem_din[self.s_iter_wmem_i[i].d].d       += self.s_func_res[self.s_iter_func_i[i].d].d\n            if self.s_iter_arg_valid[i].d == 1:\n                self.s_func_arg0[self.s_iter_func_i[i].d].d     += self.s_mem_dout[self.s_iter_rmem0_i[i].d].d\n                self.s_func_arg1[self.s_iter_func_i[i].d].d     += self.s_mem_dout[self.s_iter_rmem1_i[i].d].d\n\n    def set_cycle_nb(self, cycle_nb=-1):\n        self.cycle_nb = cycle_nb\n\n    def set_trace(self, trace):\n        self.trace = trace\n\n    async def op(self, iter_i, func_i, rmem0_i, rmem1_i, wmem_i, data_nb):\n        # operation request\n        self.s_iter_data_nb[iter_i].d = data_nb\n        self.s_iter_func_i[iter_i].d = func_i\n        self.s_iter_rmem0_i[iter_i].d = rmem0_i\n        self.s_iter_rmem1_i[iter_i].d = rmem1_i\n        self.s_iter_wmem_i[iter_i].d = wmem_i\n        clkNb = randint(1, self.randmax)\n        self.run(clkNb=clkNb, trace=self.trace)\n        # operation completion check\n        # software is polling, run the FPGA\n        done = False\n        while not done:\n            if (self.cycle_nb >= 0) and (self.time >= self.cycle_nb):\n                return\n            if self.s_iter_done[iter_i].d == 1:\n                self.s_iter_data_nb[iter_i].d = 0\n                done = True\n            else:\n                done = False\n            clkNb = randint(1, self.randmax)\n            self.run(clkNb=clkNb, trace=self.trace)\n            await asyncio.sleep(0)\n\n    async def ddr2fpga(self, ddr2fpga_i, mem_i, array_ptr, data_nb):\n        # memory write\n        self.s_ddr2fpga_mem_i[ddr2fpga_i].d = mem_i\n        self.s_ddr2fpga_data_nb[ddr2fpga_i].d = data_nb\n        self.u_ddr2fpga[ddr2fpga_i].array_ptr = array_ptr\n        clkNb = randint(1, self.randmax)\n        self.run(clkNb=clkNb, trace=self.trace)\n        # memory copy completion check\n        # software is polling, run the FPGA\n        done = False\n        while not done:\n            if (self.cycle_nb >= 0) and (self.time >= self.cycle_nb):\n                return\n            if self.s_ddr2fpga_done[ddr2fpga_i].d == 1:\n                self.s_ddr2fpga_data_nb[ddr2fpga_i].d = 0\n                done = True\n            else:\n                done = False\n            clkNb = randint(1, self.randmax)\n            self.run(clkNb=clkNb, trace=self.trace)\n            await asyncio.sleep(0)\n\n    async def fpga2ddr(self, fpga2ddr_i, mem_i, array_ptr, data_nb):\n        # memory read\n        self.s_fpga2ddr_mem_i[fpga2ddr_i].d = mem_i\n        self.s_fpga2ddr_data_nb[fpga2ddr_i].d = data_nb\n        self.u_fpga2ddr[fpga2ddr_i].array_ptr = array_ptr\n        clkNb = randint(1, self.randmax)\n        self.run(clkNb=clkNb, trace=self.trace)\n        # memory copy completion check\n        # software is polling, run the FPGA\n        done = False\n        while not done:\n            if (self.cycle_nb >= 0) and (self.time >= self.cycle_nb):\n                return\n            if self.s_fpga2ddr_done[fpga2ddr_i].d == 1:\n                self.s_fpga2ddr_data_nb[fpga2ddr_i].d = 0\n                done = True\n            else:\n                done = False\n            clkNb = randint(1, self.randmax)\n            self.run(clkNb=clkNb, trace=self.trace)\n            await asyncio.sleep(0)\n"""
bundle/fpga_state.py,0,"b""import asyncio\n\nclass FPGA_state(object):\n    def __init__(self, fpga_config):\n        self.mem_nb = fpga_config.config['mem_nb']\n        self.ddr2fpga_nb = fpga_config.config['ddr2fpga_nb']\n        self.fpga2ddr_nb = fpga_config.config['fpga2ddr_nb']\n        self.iter_nb = fpga_config.config['iter_nb']\n        self.allfunc_nb = fpga_config.config['func_nb']\n        self.func_nb = {func: fpga_config.config[f'{func}_nb'] for func in fpga_config.func_layout.keys()}\n        self.func_i0 = {func: fpga_config.config[f'{func}_i0'] for func in fpga_config.func_layout.keys()}\n        self.func_i1 = {func: fpga_config.config[f'{func}_i1'] for func in fpga_config.func_layout.keys()}\n        self.free_mem_nb = self.mem_nb\n        self.free_ddr2fpga_nb = self.ddr2fpga_nb\n        self.free_fpga2ddr_nb = self.fpga2ddr_nb\n        self.free_iter_nb = self.iter_nb\n        self.free_func_nb = {func: self.func_nb[func] for func in fpga_config.func_layout.keys()}\n        self.mem_busy = [False for i in range(self.mem_nb)]\n        self.ddr2fpga_busy = [False for i in range(self.ddr2fpga_nb)]\n        self.fpga2ddr_busy = [False for i in range(self.fpga2ddr_nb)]\n        self.iter_busy = [False for i in range(self.iter_nb)]\n        self.func_busy = [False for i in range(self.allfunc_nb)]\n        self.func_freed = {func: asyncio.Event() for func in fpga_config.func_layout.keys()}\n        self.ddr2fpga_freed = asyncio.Event()\n        self.fpga2ddr_freed = asyncio.Event()\n        self.iter_freed = asyncio.Event()\n    def alloc(self, busy, nb, i0=0, i1=None):\n        res = []\n        if i1 is None:\n            i1 = len(busy)\n        i = i0\n        for _ in range(nb):\n            while busy[i]:\n                i += 1\n                if i == i1:\n                    i = i0\n            busy[i] = True\n            res.append(i)\n        if nb == 1:\n            return res[0]\n        return res\n    def mem_alloc(self, nb=1):\n        self.free_mem_nb -= nb\n        return self.alloc(self.mem_busy, nb)\n    def ddr2fpga_alloc(self, nb=1):\n        self.free_ddr2fpga_nb -= nb\n        return self.alloc(self.ddr2fpga_busy, nb)\n    def fpga2ddr_alloc(self, nb=1):\n        self.free_fpga2ddr_nb -= nb\n        return self.alloc(self.fpga2ddr_busy, nb)\n    def iter_alloc(self, nb=1):\n        self.free_iter_nb -= nb\n        return self.alloc(self.iter_busy, nb)\n    def func_alloc(self, func, nb=1):\n        self.free_func_nb[func] -= nb\n        return self.alloc(self.func_busy, nb, i0=self.func_i0[func], i1=self.func_i1[func])\n    def mem_free(self, i):\n        assert self.mem_busy[i]\n        self.free_mem_nb += 1\n        self.mem_busy[i] = False\n    def func_free(self, func, i):\n        assert self.func_busy[i]\n        self.free_func_nb[func] += 1\n        self.func_busy[i] = False\n        self.func_freed[func].set()\n    def ddr2fpga_free(self, i):\n        assert self.ddr2fpga_busy[i]\n        self.free_ddr2fpga_nb += 1\n        self.ddr2fpga_busy[i] = False\n        self.ddr2fpga_freed.set()\n    def fpga2ddr_free(self, i):\n        assert self.fpga2ddr_busy[i]\n        self.free_fpga2ddr_nb += 1\n        self.fpga2ddr_busy[i] = False\n        self.fpga2ddr_freed.set()\n    def iter_free(self, i):\n        assert self.iter_busy[i]\n        self.free_iter_nb += 1\n        self.iter_busy[i] = False\n        self.iter_freed.set()\n"""
bundle/functions.py,0,"b""from pyclk import Sig, Reg, In, Out, List, Module\n\nclass func(Module):\n    def __init__(self, fname):\n        self.fname = fname\n\n        self.r_res          = Reg()\n        self.r_res_valid    = Reg()\n\n        self.i_arg0         = In()\n        self.i_arg1         = In()\n        self.i_arg_valid    = In()\n        self.o_res          = Out()\n        self.o_res_valid    = Out()\n\n    def logic(self):\n        if self.i_arg_valid.d == 1:\n            if self.fname == 'add':\n                self.r_res.d = self.i_arg0.d + self.i_arg1.d\n            elif self.fname == 'mul':\n                self.r_res.d = self.i_arg0.d * self.i_arg1.d\n        else:\n            self.r_res.d = 0\n\n        self.r_res_valid.d = self.i_arg_valid.d\n\n        self.o_res.d = self.r_res.q\n        self.o_res_valid.d = self.r_res_valid.q\n"""
bundle/iterator.py,0,"b'from pyclk import Sig, Reg, In, Out, List, Module\n\nclass iterator(Module):\n\n    def __init__(self):\n        self.IDLE, self.ITERATING, self.FINISHING, self.COMPLETE = range(4)\n        self.r_state = Reg()\n        self.r_raddr = Reg()\n        self.r_waddr = Reg()\n        self.r_done = Reg()\n        self.r_arg_valid = Reg()\n\n        # I/O\n        self.i_data_nb      = In()\n        self.o_done         = Out()\n        self.o_raddr        = Out()\n        self.o_waddr        = Out()\n        self.o_wena         = Out()\n        self.o_arg_valid    = Out()\n        self.i_res_valid    = In()\n\n    def logic(self):\n        self.o_wena.d = 0\n\n        if self.r_state.q == self.IDLE:\n            if self.i_data_nb.d != 0:\n                self.r_state.d = self.ITERATING\n        elif self.r_state.q == self.ITERATING:\n            self.r_arg_valid.d = 1\n            if self.r_raddr.q == self.i_data_nb.d - 1:\n                self.r_raddr.d = 0\n                self.r_state.d = self.FINISHING\n            else:\n                self.r_raddr.d = self.r_raddr.q + 1\n            if self.i_res_valid.d == 1:\n                self.r_waddr.d = self.r_waddr.q + 1\n                self.o_wena.d = 1\n        elif self.r_state.q == self.FINISHING:\n            self.r_arg_valid.d = 0\n            if self.i_res_valid.d == 1:\n                self.o_wena.d = 1\n                if self.r_waddr.q == self.i_data_nb.d - 1:\n                    self.r_state.d = self.COMPLETE\n                    self.r_done.d = 1\n                    self.r_waddr.d = 0\n                else:\n                    self.r_waddr.d = self.r_waddr.q + 1\n        elif self.r_state.q == self.COMPLETE:\n            if self.i_data_nb.d == 0:\n                self.r_state.d = self.IDLE\n                self.r_done.d = 0\n        else:\n            self.r_state.d = self.IDLE\n\n        self.o_done.d = self.r_done.q\n        self.o_raddr.d = self.r_raddr.q\n        self.o_waddr.d = self.r_waddr.q\n        self.o_arg_valid.d = self.r_arg_valid.q\n'"
bundle/memory.py,0,"b'from pyclk import Sig, Reg, In, Out, List, Module\n\nclass memory(Module):\n\n    def __init__(self, depth):\n        # content\n        self.ram = [0 for i in range(depth)]\n        self.r_dout = Reg()\n\n        # I/O\n        self.i_wena = In()\n        self.i_addr = In()\n        self.i_din  = In()\n        self.o_dout = Out()\n\n    def logic(self):\n        self.r_dout.d = self.ram[self.i_addr.d]\n        if self.i_wena.d == 1:\n            self.ram[self.i_addr.d] = int(self.i_din.d)\n        self.o_dout.d = self.r_dout.q\n'"
bundle/scheduler.py,0,"b'import inspect\nimport asyncio\nfrom .expression import Parser\n\nparser = Parser()\nevent_loop = asyncio.get_event_loop()\n\ndef evaluate(expression, device=None, debug=False):\n    frame = inspect.currentframe()\n    try:\n        out_locals = frame.f_back.f_locals\n    finally:\n        del frame\n    e = parser.parse(expression)\n    var = e.variables()\n    if device is None:\n        values = {v:out_locals[v] for v in var}\n        return e.evaluate(values)\n    input_arrays = [out_locals[v] for v in var]\n    out_array = input_arrays[0].copy()\n    tasks = e.evaluate(to_device=True)\n    required_mem_nb = len(var) + len(tasks)\n    mem_depth = device.config[\'mem_depth\']\n    idx0 = 0\n    data_nb = out_array.size # remaining data number\n    remaining_tasks = []\n    all_done = False\n    while not all_done:\n        # this loop is done when all operations have been scheduled\n        done = False\n        while not done:\n            if debug:\n                print(f\'Remaining data number to be scheduled: {data_nb}\')\n            # this loop is done when there are not enough ressources\n            # left for a new operation to be scheduled, or when all\n            # operations have been scheduled\n            if data_nb >= mem_depth:\n                ndata = mem_depth\n            else:\n                ndata = data_nb\n            if debug:\n                print(f\'Expression requires {required_mem_nb} memories, and {device.state.free_mem_nb} are available.\')\n            if device.state.free_mem_nb >= required_mem_nb:\n                mem = device.state.mem_alloc(required_mem_nb)\n                idx1 = idx0 + ndata\n                # tasks\n                # copy data to device memory in the order that they are needed\n                # But queue them without waiting for computation\n                # because it is independant and should be done ASAP.\n                t = [None for i in range(len(var))]\n                for task in tasks:\n                    if task[0] == \'binary_func\':\n                        for i in task[2:4]:\n                            if (i < len(var)) and (t[i] is None):\n                                t[i] = asyncio.ensure_future(device.arg_chunk(idx1-idx0, mem[i], input_arrays[i][idx0:idx1]))\n                    elif task[0] == \'unary_func\':\n                        i = task[2]\n                        if (i < len(var)) and (t[i] is None):\n                            t[i] = asyncio.ensure_future(device.arg_chunk(idx1-idx0, mem[i], input_arrays[i][idx0:idx1]))\n                for task in tasks:\n                    if task[0] == \'binary_func\':\n                        func = task[1]\n                        i0, i1, i2 = task[2:5]\n                        t.append(asyncio.ensure_future(device.binary_func(func, ndata, mem[i0], mem[i1], mem[i2], await_tasks=[t[i0], t[i1]])))\n                    elif task[0] == \'unary_func\':\n                        func = task[1]\n                        i0, i1 = task[2:4]\n                        t.append(asyncio.ensure_future(device.unary_func(func, ndata, mem[i0], mem[i1], await_tasks=[t[i0]])))\n                # last task is final operation, get its result memory\n                # and copy it back to output array\n                task = tasks[-1]\n                if task[0] == \'binary_func\':\n                    i = task[4]\n                elif task[0] == \'unary_func\':\n                    i = task[3]\n                t.append(asyncio.ensure_future(device.res_chunk(ndata, mem[i], out_array[idx0:idx1], await_tasks=[t[-1]])))\n                t.append(asyncio.ensure_future(device.free_mem(mem, await_tasks=[t[-1]])))\n                remaining_tasks += t\n                data_nb -= ndata\n                idx0 = idx1\n                if data_nb == 0:\n                    # all operations have been scheduled\n                    done = True\n            elif not remaining_tasks:\n                raise RuntimeError(""You don\'t have enough device memories to perform this operation"")\n            else:\n                # not enough free memories,\n                # wait for one task to complete\n                done = True\n        if data_nb > 0:\n            # still some data to process, schedule more operations\n            # (first task to complete will free up ressources)\n            when = asyncio.FIRST_COMPLETED\n        else:\n            # all operations have been scheduled, wait for all of them to complete\n            when = asyncio.ALL_COMPLETED\n            all_done = True\n        finished, unfinished = event_loop.run_until_complete(asyncio.wait(remaining_tasks, return_when=when))\n        remaining_tasks = list(unfinished)\n    return out_array\n'"
vivado/config.py,0,"b""def write_cpp(mem_width, mem_depth, mem_depth_bitnb):\n    config_h = f'''\\\n#ifndef config_h\n#define config_h\n\n#define MEM_WIDTH       {mem_width}\n#define MEM_DEPTH       {mem_depth}\n#define MEM_DEPTH_BITNB {mem_depth_bitnb}\n\n#endif\n'''\n\n    with open('ip/config.h', 'w') as f:\n        f.write(config_h)\n"""
vivado/do_fpga.py,0,"b'from math import ceil, log2\nfrom subprocess import call\nimport config\n\nmem_nb      = 16\nmem_width   = 64\nmem_depth   = 4096\nddr2fpga_nb = 4\nfpga2ddr_nb = 2\nadd_nb      = 4\nmul_nb      = 4\nfunc_nb     = add_nb + mul_nb\n\nmem_bitnb       = int(ceil(log2(mem_nb)))\nmem_depth_bitnb = int(ceil(log2(mem_depth)))\nfunc_bitnb      = int(ceil(log2(func_nb)))\n\nconfig.write_cpp(mem_width, mem_depth, mem_depth_bitnb)\n\ncall(\'cd ip; vivado_hls ddr2fpga/solution1/script.tcl\', shell=True)\ncall(\'cd ip; vivado_hls memory/solution1/script.tcl\', shell=True)\ncall(\'cd ip; vivado_hls add/solution1/script.tcl\', shell=True)\ncall(\'cd ip; vivado_hls mul/solution1/script.tcl\', shell=True)\n\n# design_1_bd.tcl\n\ndesign_tcl = \'\'\'\n################################################################\n# This is a generated script based on design: design_1\n#\n# Though there are limitations about the generated script,\n# the main purpose of this utility is to make learning\n# IP Integrator Tcl commands easier.\n################################################################\n\nnamespace eval _tcl {\nproc get_script_folder {} {\n   set script_path [file normalize [info script]]\n   set script_folder [file dirname $script_path]\n   return $script_folder\n}\n}\nvariable script_folder\nset script_folder [_tcl::get_script_folder]\n\n################################################################\n# Check if script is running in correct Vivado version.\n################################################################\nset scripts_vivado_version 2016.1\nset current_vivado_version [version -short]\n\nif { [string first $scripts_vivado_version $current_vivado_version] == -1 } {\n   puts """"\n   catch {common::send_msg_id ""BD_TCL-109"" ""ERROR"" ""This script was generated using Vivado <$scripts_vivado_version> and is being run in <$current_vivado_version> of Vivado. Please run the script in Vivado <$scripts_vivado_version> then open the design in Vivado <$current_vivado_version>. Upgrade the design by running \\\\""Tools => Report => Report IP Status...\\\\"", then run write_bd_tcl to create an updated script.""}\n\n   return 1\n}\n\n################################################################\n# START\n################################################################\n\n# To test this script, run the following commands from Vivado Tcl console:\n# source design_1_script.tcl\n\n# If there is no project opened, this script will create a\n# project, but make sure you do not have an existing project\n# <./myproj/project_1.xpr> in the current working folder.\n\nset list_projs [get_projects -quiet]\nif { $list_projs eq """" } {\n   create_project project_1 bundle -part xc7z020clg400-1 -force\n   set_property BOARD_PART www.digilentinc.com:pynq-z1:part0:1.0 [current_project]\n}\n\n# CHANGE DESIGN NAME HERE\nset design_name design_1\n\n# If you do not already have an existing IP Integrator design open,\n# you can create a design using the following command:\n#    create_bd_design $design_name\n\n# Creating design if needed\nset errMsg """"\nset nRet 0\n\nset cur_design [current_bd_design -quiet]\nset list_cells [get_bd_cells -quiet]\n\nif { ${design_name} eq """" } {\n   # USE CASES:\n   #    1) Design_name not set\n\n   set errMsg ""Please set the variable <design_name> to a non-empty value.""\n   set nRet 1\n\n} elseif { ${cur_design} ne """" && ${list_cells} eq """" } {\n   # USE CASES:\n   #    2): Current design opened AND is empty AND names same.\n   #    3): Current design opened AND is empty AND names diff; design_name NOT in project.\n   #    4): Current design opened AND is empty AND names diff; design_name exists in project.\n\n   if { $cur_design ne $design_name } {\n      common::send_msg_id ""BD_TCL-001"" ""INFO"" ""Changing value of <design_name> from <$design_name> to <$cur_design> since current design is empty.""\n      set design_name [get_property NAME $cur_design]\n   }\n   common::send_msg_id ""BD_TCL-002"" ""INFO"" ""Constructing design in IPI design <$cur_design>...""\n\n} elseif { ${cur_design} ne """" && $list_cells ne """" && $cur_design eq $design_name } {\n   # USE CASES:\n   #    5) Current design opened AND has components AND same names.\n\n   set errMsg ""Design <$design_name> already exists in your project, please set the variable <design_name> to another value.""\n   set nRet 1\n} elseif { [get_files -quiet ${design_name}.bd] ne """" } {\n   # USE CASES: \n   #    6) Current opened design, has components, but diff names, design_name exists in project.\n   #    7) No opened design, design_name exists in project.\n\n   set errMsg ""Design <$design_name> already exists in your project, please set the variable <design_name> to another value.""\n   set nRet 2\n\n} else {\n   # USE CASES:\n   #    8) No opened design, design_name not in project.\n   #    9) Current opened design, has components, but diff names, design_name not in project.\n\n   common::send_msg_id ""BD_TCL-003"" ""INFO"" ""Currently there is no design <$design_name> in project, so creating one...""\n\n   create_bd_design $design_name\n\n   common::send_msg_id ""BD_TCL-004"" ""INFO"" ""Making design <$design_name> as current_bd_design.""\n   current_bd_design $design_name\n\n}\n\ncommon::send_msg_id ""BD_TCL-005"" ""INFO"" ""Currently the variable <design_name> is equal to \\\\""$design_name\\\\"".""\n\nif { $nRet != 0 } {\n   catch {common::send_msg_id ""BD_TCL-114"" ""ERROR"" $errMsg}\n   return $nRet\n}\n\n##################################################################\n# DESIGN PROCs\n##################################################################\n\n\n\n# Procedure to create entire design; Provide argument to make\n# procedure reusable. If parentCell is """", will use root.\nproc create_root_design { parentCell } {\n\n  variable script_folder\n\n  if { $parentCell eq """" } {\n     set parentCell [get_bd_cells /]\n  }\n\n  # Get object for parentCell\n  set parentObj [get_bd_cells $parentCell]\n  if { $parentObj == """" } {\n     catch {common::send_msg_id ""BD_TCL-100"" ""ERROR"" ""Unable to find parent cell <$parentCell>!""}\n     return\n  }\n\n  # Make sure parentObj is hier blk\n  set parentType [get_property TYPE $parentObj]\n  if { $parentType ne ""hier"" } {\n     catch {common::send_msg_id ""BD_TCL-101"" ""ERROR"" ""Parent <$parentObj> has TYPE = <$parentType>. Expected to be <hier>.""}\n     return\n  }\n\n  # Save current instance; Restore later\n  set oldCurInst [current_bd_instance .]\n\n  # Set parent object as current\n  current_bd_instance $parentObj\n\n\n  # Create interface ports\n  set DDR [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:ddrx_rtl:1.0 DDR ]\n  set FIXED_IO [ create_bd_intf_port -mode Master -vlnv xilinx.com:display_processing_system7:fixedio_rtl:1.0 FIXED_IO ]\n\n  # Create ports\n\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: axi_dma_ddr2fpga_{i}, and set properties\n  set axi_dma_ddr2fpga_{i} [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:7.1 axi_dma_ddr2fpga_{i} ]\n  set_property -dict [ list \\\\\nCONFIG.c_include_s2mm {{0}} \\\\\nCONFIG.c_include_sg {{0}} \\\\\nCONFIG.c_m_axi_mm2s_data_width {{64}} \\\\\nCONFIG.c_m_axis_mm2s_tdata_width {{64}} \\\\\nCONFIG.c_mm2s_burst_size {{256}} \\\\\nCONFIG.c_sg_include_stscntrl_strm {{0}} \\\\\nCONFIG.c_sg_length_width {{23}} \\\\\n ] $axi_dma_ddr2fpga_{i}\n\n\'\'\'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: axi_dma_fpga2ddr_{i}, and set properties\n  set axi_dma_fpga2ddr_{i} [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:7.1 axi_dma_fpga2ddr_{i} ]\n  set_property -dict [ list \\\\\nCONFIG.c_include_mm2s {{0}} \\\\\nCONFIG.c_include_sg {{0}} \\\\\nCONFIG.c_m_axi_s2mm_data_width {{64}} \\\\\nCONFIG.c_s2mm_burst_size {{256}} \\\\\nCONFIG.c_sg_include_stscntrl_strm {{0}} \\\\\nCONFIG.c_sg_length_width {{23}} \\\\\n ] $axi_dma_fpga2ddr_{i}\n\n\'\'\'\n\ndesign_tcl += f\'\'\'\\\n  # Create instance: axi_intc_0, and set properties\n  set axi_intc_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_intc:4.1 axi_intc_0 ]\n  set_property -dict [ list \\\\\nCONFIG.C_IRQ_CONNECTION {{1}} \\\\\n ] $axi_intc_0\n\n  # Create instance: axi_dma2ddr_intercon, and set properties\n  set axi_dma2ddr_intercon [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:2.1 axi_dma2ddr_intercon ]\n  set_property -dict [ list \\\\\nCONFIG.NUM_MI {{1}} \\\\\nCONFIG.NUM_SI { {ddr2fpga_nb + fpga2ddr_nb} } \\\\\n ] $axi_dma2ddr_intercon\n\n  # Create instance: axis_dma2mem_intercon, and set properties\n  set axis_dma2mem_intercon [ create_bd_cell -type ip -vlnv xilinx.com:ip:axis_interconnect:2.1 axis_dma2mem_intercon ]\n  set_property -dict [ list \\\nCONFIG.NUM_MI { {mem_nb} } \\\nCONFIG.NUM_SI { {ddr2fpga_nb} } \\\n ] $axis_dma2mem_intercon\n\n  # Create instance: axis_mem2dma_intercon, and set properties\n  set axis_mem2dma_intercon [ create_bd_cell -type ip -vlnv xilinx.com:ip:axis_interconnect:2.1 axis_mem2dma_intercon ]\n  set_property -dict [ list \\\nCONFIG.NUM_MI { {fpga2ddr_nb} } \\\nCONFIG.NUM_SI { {mem_nb} } \\\n ] $axis_mem2dma_intercon\n\n  # Create instance: axis_mem2func_intercon, and set properties\n  set axis_mem2func_intercon [ create_bd_cell -type ip -vlnv xilinx.com:ip:axis_interconnect:2.1 axis_mem2func_intercon ]\n  set_property -dict [ list \\\nCONFIG.NUM_MI { {2 * func_nb} } \\\nCONFIG.NUM_SI { {mem_nb} } \\\n ] $axis_mem2func_intercon\n\n  # Create instance: axis_func2mem_intercon, and set properties\n  set axis_func2mem_intercon [ create_bd_cell -type ip -vlnv xilinx.com:ip:axis_interconnect:2.1 axis_func2mem_intercon ]\n  set_property -dict [ list \\\nCONFIG.NUM_MI { {mem_nb} } \\\nCONFIG.NUM_SI { {func_nb} } \\\n ] $axis_func2mem_intercon\n\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: ddr2fpga_{i}, and set properties\n  set ddr2fpga_{i} [ create_bd_cell -type ip -vlnv xilinx.com:hls:ddr2fpga:1.0 ddr2fpga_{i} ]\n\n\'\'\'\n\nfor i in range(mem_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: memory_{i}, and set properties\n  set memory_{i} [ create_bd_cell -type ip -vlnv xilinx.com:hls:memory:1.0 memory_{i} ]\n\n\'\'\'\n\nfor i in range(add_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: add_{i}, and set properties\n  set add_{i} [ create_bd_cell -type ip -vlnv xilinx.com:hls:add:1.0 add_{i} ]\n\n\'\'\'\n\nfor i in range(mul_nb):\n    design_tcl += f\'\'\'\\\n  # Create instance: mul_{i}, and set properties\n  set mul_{i} [ create_bd_cell -type ip -vlnv xilinx.com:hls:mul:1.0 mul_{i} ]\n\n\'\'\'\n\ndesign_tcl += \'\'\'\\\n  # Create instance: processing_system7_0, and set properties\n  set processing_system7_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:processing_system7:5.5 processing_system7_0 ]\n  set_property -dict [ list \\\\\nCONFIG.PCW_ACT_APU_PERIPHERAL_FREQMHZ {650.000000} \\\\\nCONFIG.PCW_ACT_CAN0_PERIPHERAL_FREQMHZ {23.8095} \\\\\nCONFIG.PCW_ACT_CAN1_PERIPHERAL_FREQMHZ {23.8095} \\\\\nCONFIG.PCW_ACT_CAN_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_DCI_PERIPHERAL_FREQMHZ {10.096154} \\\\\nCONFIG.PCW_ACT_ENET0_PERIPHERAL_FREQMHZ {125.000000} \\\\\nCONFIG.PCW_ACT_ENET1_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_FPGA0_PERIPHERAL_FREQMHZ {100.000000} \\\\\nCONFIG.PCW_ACT_FPGA1_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_FPGA2_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_FPGA3_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_I2C_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_ACT_PCAP_PERIPHERAL_FREQMHZ {200.000000} \\\\\nCONFIG.PCW_ACT_QSPI_PERIPHERAL_FREQMHZ {200.000000} \\\\\nCONFIG.PCW_ACT_SDIO_PERIPHERAL_FREQMHZ {50.000000} \\\\\nCONFIG.PCW_ACT_SMC_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_SPI_PERIPHERAL_FREQMHZ {10.000000} \\\\\nCONFIG.PCW_ACT_TPIU_PERIPHERAL_FREQMHZ {200.000000} \\\\\nCONFIG.PCW_ACT_TTC0_CLK0_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC0_CLK1_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC0_CLK2_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC1_CLK0_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC1_CLK1_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC1_CLK2_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_ACT_TTC_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_ACT_UART_PERIPHERAL_FREQMHZ {100.000000} \\\\\nCONFIG.PCW_ACT_USB0_PERIPHERAL_FREQMHZ {60} \\\\\nCONFIG.PCW_ACT_USB1_PERIPHERAL_FREQMHZ {60} \\\\\nCONFIG.PCW_ACT_WDT_PERIPHERAL_FREQMHZ {108.333336} \\\\\nCONFIG.PCW_APU_CLK_RATIO_ENABLE {6:2:1} \\\\\nCONFIG.PCW_APU_PERIPHERAL_FREQMHZ {650} \\\\\nCONFIG.PCW_ARMPLL_CTRL_FBDIV {26} \\\\\nCONFIG.PCW_CAN0_BASEADDR {0xE0008000} \\\\\nCONFIG.PCW_CAN0_CAN0_IO {<Select>} \\\\\nCONFIG.PCW_CAN0_GRP_CLK_ENABLE {0} \\\\\nCONFIG.PCW_CAN0_GRP_CLK_IO {<Select>} \\\\\nCONFIG.PCW_CAN0_HIGHADDR {0xE0008FFF} \\\\\nCONFIG.PCW_CAN0_PERIPHERAL_CLKSRC {External} \\\\\nCONFIG.PCW_CAN0_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_CAN0_PERIPHERAL_FREQMHZ {-1} \\\\\nCONFIG.PCW_CAN1_BASEADDR {0xE0009000} \\\\\nCONFIG.PCW_CAN1_CAN1_IO {<Select>} \\\\\nCONFIG.PCW_CAN1_GRP_CLK_ENABLE {0} \\\\\nCONFIG.PCW_CAN1_GRP_CLK_IO {<Select>} \\\\\nCONFIG.PCW_CAN1_HIGHADDR {0xE0009FFF} \\\\\nCONFIG.PCW_CAN1_PERIPHERAL_CLKSRC {External} \\\\\nCONFIG.PCW_CAN1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_CAN1_PERIPHERAL_FREQMHZ {-1} \\\\\nCONFIG.PCW_CAN_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_CAN_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_CAN_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_CAN_PERIPHERAL_FREQMHZ {100} \\\\\nCONFIG.PCW_CAN_PERIPHERAL_VALID {0} \\\\\nCONFIG.PCW_CLK0_FREQ {100000000} \\\\\nCONFIG.PCW_CLK1_FREQ {10000000} \\\\\nCONFIG.PCW_CLK2_FREQ {10000000} \\\\\nCONFIG.PCW_CLK3_FREQ {10000000} \\\\\nCONFIG.PCW_CORE0_FIQ_INTR {0} \\\\\nCONFIG.PCW_CORE0_IRQ_INTR {0} \\\\\nCONFIG.PCW_CORE1_FIQ_INTR {0} \\\\\nCONFIG.PCW_CORE1_IRQ_INTR {0} \\\\\nCONFIG.PCW_CPU_CPU_6X4X_MAX_RANGE {667} \\\\\nCONFIG.PCW_CPU_CPU_PLL_FREQMHZ {1300.000} \\\\\nCONFIG.PCW_CPU_PERIPHERAL_CLKSRC {ARM PLL} \\\\\nCONFIG.PCW_CPU_PERIPHERAL_DIVISOR0 {2} \\\\\nCONFIG.PCW_CRYSTAL_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_DCI_PERIPHERAL_CLKSRC {DDR PLL} \\\\\nCONFIG.PCW_DCI_PERIPHERAL_DIVISOR0 {52} \\\\\nCONFIG.PCW_DCI_PERIPHERAL_DIVISOR1 {2} \\\\\nCONFIG.PCW_DCI_PERIPHERAL_FREQMHZ {10.159} \\\\\nCONFIG.PCW_DDRPLL_CTRL_FBDIV {21} \\\\\nCONFIG.PCW_DDR_DDR_PLL_FREQMHZ {1050.000} \\\\\nCONFIG.PCW_DDR_HPRLPR_QUEUE_PARTITION {HPR(0)/LPR(32)} \\\\\nCONFIG.PCW_DDR_HPR_TO_CRITICAL_PRIORITY_LEVEL {15} \\\\\nCONFIG.PCW_DDR_LPR_TO_CRITICAL_PRIORITY_LEVEL {2} \\\\\nCONFIG.PCW_DDR_PERIPHERAL_CLKSRC {DDR PLL} \\\\\nCONFIG.PCW_DDR_PERIPHERAL_DIVISOR0 {2} \\\\\nCONFIG.PCW_DDR_PORT0_HPR_ENABLE {0} \\\\\nCONFIG.PCW_DDR_PORT1_HPR_ENABLE {0} \\\\\nCONFIG.PCW_DDR_PORT2_HPR_ENABLE {0} \\\\\nCONFIG.PCW_DDR_PORT3_HPR_ENABLE {0} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_0 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_1 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_2 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_3 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_0 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_1 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_2 {<Select>} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_3 {<Select>} \\\\\nCONFIG.PCW_DDR_RAM_BASEADDR {0x00100000} \\\\\nCONFIG.PCW_DDR_RAM_HIGHADDR {0x1FFFFFFF} \\\\\nCONFIG.PCW_DDR_WRITE_TO_CRITICAL_PRIORITY_LEVEL {2} \\\\\nCONFIG.PCW_DM_WIDTH {4} \\\\\nCONFIG.PCW_DQS_WIDTH {4} \\\\\nCONFIG.PCW_DQ_WIDTH {32} \\\\\nCONFIG.PCW_ENET0_BASEADDR {0xE000B000} \\\\\nCONFIG.PCW_ENET0_ENET0_IO {MIO 16 .. 27} \\\\\nCONFIG.PCW_ENET0_GRP_MDIO_ENABLE {1} \\\\\nCONFIG.PCW_ENET0_GRP_MDIO_IO {MIO 52 .. 53} \\\\\nCONFIG.PCW_ENET0_HIGHADDR {0xE000BFFF} \\\\\nCONFIG.PCW_ENET0_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_ENET0_PERIPHERAL_DIVISOR0 {8} \\\\\nCONFIG.PCW_ENET0_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_ENET0_PERIPHERAL_ENABLE {1} \\\\\nCONFIG.PCW_ENET0_PERIPHERAL_FREQMHZ {1000 Mbps} \\\\\nCONFIG.PCW_ENET0_RESET_ENABLE {1} \\\\\nCONFIG.PCW_ENET0_RESET_IO {MIO 9} \\\\\nCONFIG.PCW_ENET1_BASEADDR {0xE000C000} \\\\\nCONFIG.PCW_ENET1_ENET1_IO {<Select>} \\\\\nCONFIG.PCW_ENET1_GRP_MDIO_ENABLE {0} \\\\\nCONFIG.PCW_ENET1_GRP_MDIO_IO {<Select>} \\\\\nCONFIG.PCW_ENET1_HIGHADDR {0xE000CFFF} \\\\\nCONFIG.PCW_ENET1_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_ENET1_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_ENET1_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_ENET1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_ENET1_PERIPHERAL_FREQMHZ {1000 Mbps} \\\\\nCONFIG.PCW_ENET1_RESET_ENABLE {0} \\\\\nCONFIG.PCW_ENET1_RESET_IO {<Select>} \\\\\nCONFIG.PCW_ENET_RESET_ENABLE {1} \\\\\nCONFIG.PCW_ENET_RESET_POLARITY {Active Low} \\\\\nCONFIG.PCW_ENET_RESET_SELECT {Share reset pin} \\\\\nCONFIG.PCW_EN_4K_TIMER {0} \\\\\nCONFIG.PCW_EN_CAN0 {0} \\\\\nCONFIG.PCW_EN_CAN1 {0} \\\\\nCONFIG.PCW_EN_CLK0_PORT {1} \\\\\nCONFIG.PCW_EN_CLK1_PORT {0} \\\\\nCONFIG.PCW_EN_CLK2_PORT {0} \\\\\nCONFIG.PCW_EN_CLK3_PORT {0} \\\\\nCONFIG.PCW_EN_CLKTRIG0_PORT {0} \\\\\nCONFIG.PCW_EN_CLKTRIG1_PORT {0} \\\\\nCONFIG.PCW_EN_CLKTRIG2_PORT {0} \\\\\nCONFIG.PCW_EN_CLKTRIG3_PORT {0} \\\\\nCONFIG.PCW_EN_DDR {1} \\\\\nCONFIG.PCW_EN_EMIO_CAN0 {0} \\\\\nCONFIG.PCW_EN_EMIO_CAN1 {0} \\\\\nCONFIG.PCW_EN_EMIO_CD_SDIO0 {0} \\\\\nCONFIG.PCW_EN_EMIO_CD_SDIO1 {0} \\\\\nCONFIG.PCW_EN_EMIO_ENET0 {0} \\\\\nCONFIG.PCW_EN_EMIO_ENET1 {0} \\\\\nCONFIG.PCW_EN_EMIO_GPIO {0} \\\\\nCONFIG.PCW_EN_EMIO_I2C0 {0} \\\\\nCONFIG.PCW_EN_EMIO_I2C1 {0} \\\\\nCONFIG.PCW_EN_EMIO_MODEM_UART0 {0} \\\\\nCONFIG.PCW_EN_EMIO_MODEM_UART1 {0} \\\\\nCONFIG.PCW_EN_EMIO_PJTAG {0} \\\\\nCONFIG.PCW_EN_EMIO_SDIO0 {0} \\\\\nCONFIG.PCW_EN_EMIO_SDIO1 {0} \\\\\nCONFIG.PCW_EN_EMIO_SPI0 {0} \\\\\nCONFIG.PCW_EN_EMIO_SPI1 {0} \\\\\nCONFIG.PCW_EN_EMIO_SRAM_INT {0} \\\\\nCONFIG.PCW_EN_EMIO_TRACE {0} \\\\\nCONFIG.PCW_EN_EMIO_TTC0 {0} \\\\\nCONFIG.PCW_EN_EMIO_TTC1 {0} \\\\\nCONFIG.PCW_EN_EMIO_UART0 {0} \\\\\nCONFIG.PCW_EN_EMIO_UART1 {0} \\\\\nCONFIG.PCW_EN_EMIO_WDT {0} \\\\\nCONFIG.PCW_EN_EMIO_WP_SDIO0 {0} \\\\\nCONFIG.PCW_EN_EMIO_WP_SDIO1 {0} \\\\\nCONFIG.PCW_EN_ENET0 {1} \\\\\nCONFIG.PCW_EN_ENET1 {0} \\\\\nCONFIG.PCW_EN_GPIO {1} \\\\\nCONFIG.PCW_EN_I2C0 {0} \\\\\nCONFIG.PCW_EN_I2C1 {0} \\\\\nCONFIG.PCW_EN_MODEM_UART0 {0} \\\\\nCONFIG.PCW_EN_MODEM_UART1 {0} \\\\\nCONFIG.PCW_EN_PJTAG {0} \\\\\nCONFIG.PCW_EN_PTP_ENET0 {0} \\\\\nCONFIG.PCW_EN_PTP_ENET1 {0} \\\\\nCONFIG.PCW_EN_QSPI {1} \\\\\nCONFIG.PCW_EN_RST0_PORT {1} \\\\\nCONFIG.PCW_EN_RST1_PORT {0} \\\\\nCONFIG.PCW_EN_RST2_PORT {0} \\\\\nCONFIG.PCW_EN_RST3_PORT {0} \\\\\nCONFIG.PCW_EN_SDIO0 {1} \\\\\nCONFIG.PCW_EN_SDIO1 {0} \\\\\nCONFIG.PCW_EN_SMC {0} \\\\\nCONFIG.PCW_EN_SPI0 {0} \\\\\nCONFIG.PCW_EN_SPI1 {0} \\\\\nCONFIG.PCW_EN_TRACE {0} \\\\\nCONFIG.PCW_EN_TTC0 {0} \\\\\nCONFIG.PCW_EN_TTC1 {0} \\\\\nCONFIG.PCW_EN_UART0 {1} \\\\\nCONFIG.PCW_EN_UART1 {0} \\\\\nCONFIG.PCW_EN_USB0 {1} \\\\\nCONFIG.PCW_EN_USB1 {0} \\\\\nCONFIG.PCW_EN_WDT {0} \\\\\nCONFIG.PCW_FCLK0_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_FCLK0_PERIPHERAL_DIVISOR0 {5} \\\\\nCONFIG.PCW_FCLK0_PERIPHERAL_DIVISOR1 {2} \\\\\nCONFIG.PCW_FCLK1_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_FCLK1_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_FCLK1_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_FCLK2_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_FCLK2_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_FCLK2_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_FCLK3_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_FCLK3_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_FCLK3_PERIPHERAL_DIVISOR1 {1} \\\\\nCONFIG.PCW_FCLK_CLK0_BUF {true} \\\\\nCONFIG.PCW_FCLK_CLK1_BUF {false} \\\\\nCONFIG.PCW_FCLK_CLK2_BUF {false} \\\\\nCONFIG.PCW_FCLK_CLK3_BUF {false} \\\\\nCONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ {100} \\\\\nCONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_FPGA2_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_FPGA3_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_FPGA_FCLK0_ENABLE {1} \\\\\nCONFIG.PCW_FPGA_FCLK1_ENABLE {0} \\\\\nCONFIG.PCW_FPGA_FCLK2_ENABLE {0} \\\\\nCONFIG.PCW_FPGA_FCLK3_ENABLE {0} \\\\\nCONFIG.PCW_FTM_CTI_IN0 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_IN1 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_IN2 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_IN3 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_OUT0 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_OUT1 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_OUT2 {<Select>} \\\\\nCONFIG.PCW_FTM_CTI_OUT3 {<Select>} \\\\\nCONFIG.PCW_GPIO_BASEADDR {0xE000A000} \\\\\nCONFIG.PCW_GPIO_EMIO_GPIO_ENABLE {0} \\\\\nCONFIG.PCW_GPIO_EMIO_GPIO_IO {<Select>} \\\\\nCONFIG.PCW_GPIO_EMIO_GPIO_WIDTH {64} \\\\\nCONFIG.PCW_GPIO_HIGHADDR {0xE000AFFF} \\\\\nCONFIG.PCW_GPIO_MIO_GPIO_ENABLE {1} \\\\\nCONFIG.PCW_GPIO_MIO_GPIO_IO {MIO} \\\\\nCONFIG.PCW_GPIO_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_I2C0_BASEADDR {0xE0004000} \\\\\nCONFIG.PCW_I2C0_GRP_INT_ENABLE {0} \\\\\nCONFIG.PCW_I2C0_GRP_INT_IO {<Select>} \\\\\nCONFIG.PCW_I2C0_HIGHADDR {0xE0004FFF} \\\\\nCONFIG.PCW_I2C0_I2C0_IO {<Select>} \\\\\nCONFIG.PCW_I2C0_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_I2C0_RESET_ENABLE {0} \\\\\nCONFIG.PCW_I2C0_RESET_IO {<Select>} \\\\\nCONFIG.PCW_I2C1_BASEADDR {0xE0005000} \\\\\nCONFIG.PCW_I2C1_GRP_INT_ENABLE {0} \\\\\nCONFIG.PCW_I2C1_GRP_INT_IO {<Select>} \\\\\nCONFIG.PCW_I2C1_HIGHADDR {0xE0005FFF} \\\\\nCONFIG.PCW_I2C1_I2C1_IO {<Select>} \\\\\nCONFIG.PCW_I2C1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_I2C1_RESET_ENABLE {0} \\\\\nCONFIG.PCW_I2C1_RESET_IO {<Select>} \\\\\nCONFIG.PCW_I2C_PERIPHERAL_FREQMHZ {25} \\\\\nCONFIG.PCW_I2C_RESET_ENABLE {0} \\\\\nCONFIG.PCW_I2C_RESET_POLARITY {Active Low} \\\\\nCONFIG.PCW_I2C_RESET_SELECT {<Select>} \\\\\nCONFIG.PCW_IMPORT_BOARD_PRESET {None} \\\\\nCONFIG.PCW_INCLUDE_ACP_TRANS_CHECK {0} \\\\\nCONFIG.PCW_INCLUDE_TRACE_BUFFER {0} \\\\\nCONFIG.PCW_IOPLL_CTRL_FBDIV {20} \\\\\nCONFIG.PCW_IO_IO_PLL_FREQMHZ {1000.000} \\\\\nCONFIG.PCW_IRQ_F2P_INTR {1} \\\\\nCONFIG.PCW_IRQ_F2P_MODE {DIRECT} \\\\\nCONFIG.PCW_MIO_0_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_0_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_0_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_0_SLEW {slow} \\\\\nCONFIG.PCW_MIO_10_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_10_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_10_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_10_SLEW {slow} \\\\\nCONFIG.PCW_MIO_11_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_11_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_11_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_11_SLEW {slow} \\\\\nCONFIG.PCW_MIO_12_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_12_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_12_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_12_SLEW {slow} \\\\\nCONFIG.PCW_MIO_13_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_13_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_13_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_13_SLEW {slow} \\\\\nCONFIG.PCW_MIO_14_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_14_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_14_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_14_SLEW {slow} \\\\\nCONFIG.PCW_MIO_15_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_15_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_15_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_15_SLEW {slow} \\\\\nCONFIG.PCW_MIO_16_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_16_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_16_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_16_SLEW {slow} \\\\\nCONFIG.PCW_MIO_17_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_17_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_17_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_17_SLEW {slow} \\\\\nCONFIG.PCW_MIO_18_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_18_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_18_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_18_SLEW {slow} \\\\\nCONFIG.PCW_MIO_19_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_19_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_19_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_19_SLEW {slow} \\\\\nCONFIG.PCW_MIO_1_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_1_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_1_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_1_SLEW {slow} \\\\\nCONFIG.PCW_MIO_20_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_20_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_20_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_20_SLEW {slow} \\\\\nCONFIG.PCW_MIO_21_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_21_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_21_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_21_SLEW {slow} \\\\\nCONFIG.PCW_MIO_22_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_22_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_22_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_22_SLEW {slow} \\\\\nCONFIG.PCW_MIO_23_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_23_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_23_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_23_SLEW {slow} \\\\\nCONFIG.PCW_MIO_24_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_24_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_24_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_24_SLEW {slow} \\\\\nCONFIG.PCW_MIO_25_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_25_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_25_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_25_SLEW {slow} \\\\\nCONFIG.PCW_MIO_26_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_26_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_26_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_26_SLEW {slow} \\\\\nCONFIG.PCW_MIO_27_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_27_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_27_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_27_SLEW {slow} \\\\\nCONFIG.PCW_MIO_28_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_28_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_28_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_28_SLEW {slow} \\\\\nCONFIG.PCW_MIO_29_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_29_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_29_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_29_SLEW {slow} \\\\\nCONFIG.PCW_MIO_2_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_2_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_2_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_2_SLEW {slow} \\\\\nCONFIG.PCW_MIO_30_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_30_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_30_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_30_SLEW {slow} \\\\\nCONFIG.PCW_MIO_31_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_31_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_31_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_31_SLEW {slow} \\\\\nCONFIG.PCW_MIO_32_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_32_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_32_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_32_SLEW {slow} \\\\\nCONFIG.PCW_MIO_33_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_33_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_33_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_33_SLEW {slow} \\\\\nCONFIG.PCW_MIO_34_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_34_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_34_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_34_SLEW {slow} \\\\\nCONFIG.PCW_MIO_35_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_35_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_35_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_35_SLEW {slow} \\\\\nCONFIG.PCW_MIO_36_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_36_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_36_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_36_SLEW {slow} \\\\\nCONFIG.PCW_MIO_37_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_37_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_37_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_37_SLEW {slow} \\\\\nCONFIG.PCW_MIO_38_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_38_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_38_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_38_SLEW {slow} \\\\\nCONFIG.PCW_MIO_39_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_39_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_39_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_39_SLEW {slow} \\\\\nCONFIG.PCW_MIO_3_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_3_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_3_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_3_SLEW {slow} \\\\\nCONFIG.PCW_MIO_40_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_40_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_40_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_40_SLEW {slow} \\\\\nCONFIG.PCW_MIO_41_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_41_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_41_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_41_SLEW {slow} \\\\\nCONFIG.PCW_MIO_42_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_42_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_42_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_42_SLEW {slow} \\\\\nCONFIG.PCW_MIO_43_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_43_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_43_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_43_SLEW {slow} \\\\\nCONFIG.PCW_MIO_44_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_44_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_44_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_44_SLEW {slow} \\\\\nCONFIG.PCW_MIO_45_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_45_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_45_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_45_SLEW {slow} \\\\\nCONFIG.PCW_MIO_46_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_46_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_46_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_46_SLEW {slow} \\\\\nCONFIG.PCW_MIO_47_DIRECTION {in} \\\\\nCONFIG.PCW_MIO_47_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_47_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_47_SLEW {slow} \\\\\nCONFIG.PCW_MIO_48_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_48_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_48_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_48_SLEW {slow} \\\\\nCONFIG.PCW_MIO_49_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_49_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_49_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_49_SLEW {slow} \\\\\nCONFIG.PCW_MIO_4_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_4_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_4_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_4_SLEW {slow} \\\\\nCONFIG.PCW_MIO_50_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_50_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_50_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_50_SLEW {slow} \\\\\nCONFIG.PCW_MIO_51_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_51_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_51_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_51_SLEW {slow} \\\\\nCONFIG.PCW_MIO_52_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_52_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_52_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_52_SLEW {slow} \\\\\nCONFIG.PCW_MIO_53_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_53_IOTYPE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_MIO_53_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_53_SLEW {slow} \\\\\nCONFIG.PCW_MIO_5_DIRECTION {inout} \\\\\nCONFIG.PCW_MIO_5_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_5_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_5_SLEW {slow} \\\\\nCONFIG.PCW_MIO_6_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_6_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_6_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_6_SLEW {slow} \\\\\nCONFIG.PCW_MIO_7_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_7_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_7_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_7_SLEW {slow} \\\\\nCONFIG.PCW_MIO_8_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_8_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_8_PULLUP {disabled} \\\\\nCONFIG.PCW_MIO_8_SLEW {slow} \\\\\nCONFIG.PCW_MIO_9_DIRECTION {out} \\\\\nCONFIG.PCW_MIO_9_IOTYPE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_MIO_9_PULLUP {enabled} \\\\\nCONFIG.PCW_MIO_9_SLEW {slow} \\\\\nCONFIG.PCW_MIO_PRIMITIVE {54} \\\\\nCONFIG.PCW_MIO_TREE_PERIPHERALS {GPIO#Quad SPI Flash#Quad SPI Flash#Quad SPI Flash#Quad SPI Flash#Quad SPI Flash#Quad SPI Flash#GPIO#Quad SPI Flash#ENET Reset#GPIO#GPIO#GPIO#GPIO#UART 0#UART 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#Enet 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#USB 0#SD 0#SD 0#SD 0#SD 0#SD 0#SD 0#USB Reset#SD 0#GPIO#GPIO#GPIO#GPIO#Enet 0#Enet 0} \\\\\nCONFIG.PCW_MIO_TREE_SIGNALS {gpio[0]#qspi0_ss_b#qspi0_io[0]#qspi0_io[1]#qspi0_io[2]#qspi0_io[3]#qspi0_sclk#gpio[7]#qspi_fbclk#reset#gpio[10]#gpio[11]#gpio[12]#gpio[13]#rx#tx#tx_clk#txd[0]#txd[1]#txd[2]#txd[3]#tx_ctl#rx_clk#rxd[0]#rxd[1]#rxd[2]#rxd[3]#rx_ctl#data[4]#dir#stp#nxt#data[0]#data[1]#data[2]#data[3]#clk#data[5]#data[6]#data[7]#clk#cmd#data[0]#data[1]#data[2]#data[3]#reset#cd#gpio[48]#gpio[49]#gpio[50]#gpio[51]#mdc#mdio} \\\\\nCONFIG.PCW_M_AXI_GP0_ENABLE_STATIC_REMAP {0} \\\\\nCONFIG.PCW_M_AXI_GP0_FREQMHZ {10} \\\\\nCONFIG.PCW_M_AXI_GP0_ID_WIDTH {12} \\\\\nCONFIG.PCW_M_AXI_GP0_SUPPORT_NARROW_BURST {0} \\\\\nCONFIG.PCW_M_AXI_GP0_THREAD_ID_WIDTH {12} \\\\\nCONFIG.PCW_M_AXI_GP1_ENABLE_STATIC_REMAP {0} \\\\\nCONFIG.PCW_M_AXI_GP1_FREQMHZ {10} \\\\\nCONFIG.PCW_M_AXI_GP1_ID_WIDTH {12} \\\\\nCONFIG.PCW_M_AXI_GP1_SUPPORT_NARROW_BURST {0} \\\\\nCONFIG.PCW_M_AXI_GP1_THREAD_ID_WIDTH {12} \\\\\nCONFIG.PCW_NAND_CYCLES_T_AR {1} \\\\\nCONFIG.PCW_NAND_CYCLES_T_CLR {1} \\\\\nCONFIG.PCW_NAND_CYCLES_T_RC {11} \\\\\nCONFIG.PCW_NAND_CYCLES_T_REA {1} \\\\\nCONFIG.PCW_NAND_CYCLES_T_RR {1} \\\\\nCONFIG.PCW_NAND_CYCLES_T_WC {11} \\\\\nCONFIG.PCW_NAND_CYCLES_T_WP {1} \\\\\nCONFIG.PCW_NAND_GRP_D8_ENABLE {0} \\\\\nCONFIG.PCW_NAND_GRP_D8_IO {<Select>} \\\\\nCONFIG.PCW_NAND_NAND_IO {<Select>} \\\\\nCONFIG.PCW_NAND_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_NOR_CS0_T_CEOE {1} \\\\\nCONFIG.PCW_NOR_CS0_T_PC {1} \\\\\nCONFIG.PCW_NOR_CS0_T_RC {11} \\\\\nCONFIG.PCW_NOR_CS0_T_TR {1} \\\\\nCONFIG.PCW_NOR_CS0_T_WC {11} \\\\\nCONFIG.PCW_NOR_CS0_T_WP {1} \\\\\nCONFIG.PCW_NOR_CS0_WE_TIME {0} \\\\\nCONFIG.PCW_NOR_CS1_T_CEOE {1} \\\\\nCONFIG.PCW_NOR_CS1_T_PC {1} \\\\\nCONFIG.PCW_NOR_CS1_T_RC {11} \\\\\nCONFIG.PCW_NOR_CS1_T_TR {1} \\\\\nCONFIG.PCW_NOR_CS1_T_WC {11} \\\\\nCONFIG.PCW_NOR_CS1_T_WP {1} \\\\\nCONFIG.PCW_NOR_CS1_WE_TIME {0} \\\\\nCONFIG.PCW_NOR_GRP_A25_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_A25_IO {<Select>} \\\\\nCONFIG.PCW_NOR_GRP_CS0_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_CS0_IO {<Select>} \\\\\nCONFIG.PCW_NOR_GRP_CS1_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_CS1_IO {<Select>} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS0_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS0_IO {<Select>} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS1_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS1_IO {<Select>} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_INT_ENABLE {0} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_INT_IO {<Select>} \\\\\nCONFIG.PCW_NOR_NOR_IO {<Select>} \\\\\nCONFIG.PCW_NOR_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_CEOE {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_PC {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_RC {11} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_TR {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_WC {11} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_T_WP {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS0_WE_TIME {0} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_CEOE {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_PC {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_RC {11} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_TR {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_WC {11} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_T_WP {1} \\\\\nCONFIG.PCW_NOR_SRAM_CS1_WE_TIME {0} \\\\\nCONFIG.PCW_OVERRIDE_BASIC_CLOCK {0} \\\\\nCONFIG.PCW_P2F_CAN0_INTR {0} \\\\\nCONFIG.PCW_P2F_CAN1_INTR {0} \\\\\nCONFIG.PCW_P2F_CTI_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC0_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC1_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC2_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC3_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC4_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC5_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC6_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC7_INTR {0} \\\\\nCONFIG.PCW_P2F_DMAC_ABORT_INTR {0} \\\\\nCONFIG.PCW_P2F_ENET0_INTR {0} \\\\\nCONFIG.PCW_P2F_ENET1_INTR {0} \\\\\nCONFIG.PCW_P2F_GPIO_INTR {0} \\\\\nCONFIG.PCW_P2F_I2C0_INTR {0} \\\\\nCONFIG.PCW_P2F_I2C1_INTR {0} \\\\\nCONFIG.PCW_P2F_QSPI_INTR {0} \\\\\nCONFIG.PCW_P2F_SDIO0_INTR {0} \\\\\nCONFIG.PCW_P2F_SDIO1_INTR {0} \\\\\nCONFIG.PCW_P2F_SMC_INTR {0} \\\\\nCONFIG.PCW_P2F_SPI0_INTR {0} \\\\\nCONFIG.PCW_P2F_SPI1_INTR {0} \\\\\nCONFIG.PCW_P2F_UART0_INTR {0} \\\\\nCONFIG.PCW_P2F_UART1_INTR {0} \\\\\nCONFIG.PCW_P2F_USB0_INTR {0} \\\\\nCONFIG.PCW_P2F_USB1_INTR {0} \\\\\nCONFIG.PCW_PACKAGE_DDR_BOARD_DELAY0 {0.223} \\\\\nCONFIG.PCW_PACKAGE_DDR_BOARD_DELAY1 {0.212} \\\\\nCONFIG.PCW_PACKAGE_DDR_BOARD_DELAY2 {0.085} \\\\\nCONFIG.PCW_PACKAGE_DDR_BOARD_DELAY3 {0.092} \\\\\nCONFIG.PCW_PACKAGE_DDR_DQS_TO_CLK_DELAY_0 {0.040} \\\\\nCONFIG.PCW_PACKAGE_DDR_DQS_TO_CLK_DELAY_1 {0.058} \\\\\nCONFIG.PCW_PACKAGE_DDR_DQS_TO_CLK_DELAY_2 {-0.009} \\\\\nCONFIG.PCW_PACKAGE_DDR_DQS_TO_CLK_DELAY_3 {-0.033} \\\\\nCONFIG.PCW_PACKAGE_NAME {clg400} \\\\\nCONFIG.PCW_PCAP_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_PCAP_PERIPHERAL_DIVISOR0 {5} \\\\\nCONFIG.PCW_PCAP_PERIPHERAL_FREQMHZ {200} \\\\\nCONFIG.PCW_PERIPHERAL_BOARD_PRESET {part0} \\\\\nCONFIG.PCW_PJTAG_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_PJTAG_PJTAG_IO {<Select>} \\\\\nCONFIG.PCW_PLL_BYPASSMODE_ENABLE {0} \\\\\nCONFIG.PCW_PRESET_BANK0_VOLTAGE {LVCMOS 3.3V} \\\\\nCONFIG.PCW_PRESET_BANK1_VOLTAGE {LVCMOS 1.8V} \\\\\nCONFIG.PCW_PS7_SI_REV {PRODUCTION} \\\\\nCONFIG.PCW_QSPI_GRP_FBCLK_ENABLE {1} \\\\\nCONFIG.PCW_QSPI_GRP_FBCLK_IO {MIO 8} \\\\\nCONFIG.PCW_QSPI_GRP_IO1_ENABLE {0} \\\\\nCONFIG.PCW_QSPI_GRP_IO1_IO {<Select>} \\\\\nCONFIG.PCW_QSPI_GRP_SINGLE_SS_ENABLE {1} \\\\\nCONFIG.PCW_QSPI_GRP_SINGLE_SS_IO {MIO 1 .. 6} \\\\\nCONFIG.PCW_QSPI_GRP_SS1_ENABLE {0} \\\\\nCONFIG.PCW_QSPI_GRP_SS1_IO {<Select>} \\\\\nCONFIG.PCW_QSPI_INTERNAL_HIGHADDRESS {0xFCFFFFFF} \\\\\nCONFIG.PCW_QSPI_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_QSPI_PERIPHERAL_DIVISOR0 {5} \\\\\nCONFIG.PCW_QSPI_PERIPHERAL_ENABLE {1} \\\\\nCONFIG.PCW_QSPI_PERIPHERAL_FREQMHZ {200} \\\\\nCONFIG.PCW_QSPI_QSPI_IO {MIO 1 .. 6} \\\\\nCONFIG.PCW_SD0_GRP_CD_ENABLE {1} \\\\\nCONFIG.PCW_SD0_GRP_CD_IO {MIO 47} \\\\\nCONFIG.PCW_SD0_GRP_POW_ENABLE {0} \\\\\nCONFIG.PCW_SD0_GRP_POW_IO {<Select>} \\\\\nCONFIG.PCW_SD0_GRP_WP_ENABLE {0} \\\\\nCONFIG.PCW_SD0_GRP_WP_IO {<Select>} \\\\\nCONFIG.PCW_SD0_PERIPHERAL_ENABLE {1} \\\\\nCONFIG.PCW_SD0_SD0_IO {MIO 40 .. 45} \\\\\nCONFIG.PCW_SD1_GRP_CD_ENABLE {0} \\\\\nCONFIG.PCW_SD1_GRP_CD_IO {<Select>} \\\\\nCONFIG.PCW_SD1_GRP_POW_ENABLE {0} \\\\\nCONFIG.PCW_SD1_GRP_POW_IO {<Select>} \\\\\nCONFIG.PCW_SD1_GRP_WP_ENABLE {0} \\\\\nCONFIG.PCW_SD1_GRP_WP_IO {<Select>} \\\\\nCONFIG.PCW_SD1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_SD1_SD1_IO {<Select>} \\\\\nCONFIG.PCW_SDIO0_BASEADDR {0xE0100000} \\\\\nCONFIG.PCW_SDIO0_HIGHADDR {0xE0100FFF} \\\\\nCONFIG.PCW_SDIO1_BASEADDR {0xE0101000} \\\\\nCONFIG.PCW_SDIO1_HIGHADDR {0xE0101FFF} \\\\\nCONFIG.PCW_SDIO_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_SDIO_PERIPHERAL_DIVISOR0 {20} \\\\\nCONFIG.PCW_SDIO_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_SDIO_PERIPHERAL_VALID {1} \\\\\nCONFIG.PCW_SMC_CYCLE_T0 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T1 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T2 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T3 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T4 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T5 {NA} \\\\\nCONFIG.PCW_SMC_CYCLE_T6 {NA} \\\\\nCONFIG.PCW_SMC_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_SMC_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_SMC_PERIPHERAL_FREQMHZ {100} \\\\\nCONFIG.PCW_SMC_PERIPHERAL_VALID {0} \\\\\nCONFIG.PCW_SPI0_BASEADDR {0xE0006000} \\\\\nCONFIG.PCW_SPI0_GRP_SS0_ENABLE {0} \\\\\nCONFIG.PCW_SPI0_GRP_SS0_IO {<Select>} \\\\\nCONFIG.PCW_SPI0_GRP_SS1_ENABLE {0} \\\\\nCONFIG.PCW_SPI0_GRP_SS1_IO {<Select>} \\\\\nCONFIG.PCW_SPI0_GRP_SS2_ENABLE {0} \\\\\nCONFIG.PCW_SPI0_GRP_SS2_IO {<Select>} \\\\\nCONFIG.PCW_SPI0_HIGHADDR {0xE0006FFF} \\\\\nCONFIG.PCW_SPI0_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_SPI0_SPI0_IO {<Select>} \\\\\nCONFIG.PCW_SPI1_BASEADDR {0xE0007000} \\\\\nCONFIG.PCW_SPI1_GRP_SS0_ENABLE {0} \\\\\nCONFIG.PCW_SPI1_GRP_SS0_IO {<Select>} \\\\\nCONFIG.PCW_SPI1_GRP_SS1_ENABLE {0} \\\\\nCONFIG.PCW_SPI1_GRP_SS1_IO {<Select>} \\\\\nCONFIG.PCW_SPI1_GRP_SS2_ENABLE {0} \\\\\nCONFIG.PCW_SPI1_GRP_SS2_IO {<Select>} \\\\\nCONFIG.PCW_SPI1_HIGHADDR {0xE0007FFF} \\\\\nCONFIG.PCW_SPI1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_SPI1_SPI1_IO {<Select>} \\\\\nCONFIG.PCW_SPI_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_SPI_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_SPI_PERIPHERAL_FREQMHZ {166.666666} \\\\\nCONFIG.PCW_SPI_PERIPHERAL_VALID {0} \\\\\nCONFIG.PCW_S_AXI_ACP_ARUSER_VAL {31} \\\\\nCONFIG.PCW_S_AXI_ACP_AWUSER_VAL {31} \\\\\nCONFIG.PCW_S_AXI_ACP_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_ACP_ID_WIDTH {3} \\\\\nCONFIG.PCW_S_AXI_GP0_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_GP0_ID_WIDTH {6} \\\\\nCONFIG.PCW_S_AXI_GP1_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_GP1_ID_WIDTH {6} \\\\\nCONFIG.PCW_S_AXI_HP0_DATA_WIDTH {64} \\\\\nCONFIG.PCW_S_AXI_HP0_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_HP0_ID_WIDTH {6} \\\\\nCONFIG.PCW_S_AXI_HP1_DATA_WIDTH {64} \\\\\nCONFIG.PCW_S_AXI_HP1_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_HP1_ID_WIDTH {6} \\\\\nCONFIG.PCW_S_AXI_HP2_DATA_WIDTH {64} \\\\\nCONFIG.PCW_S_AXI_HP2_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_HP2_ID_WIDTH {6} \\\\\nCONFIG.PCW_S_AXI_HP3_DATA_WIDTH {64} \\\\\nCONFIG.PCW_S_AXI_HP3_FREQMHZ {10} \\\\\nCONFIG.PCW_S_AXI_HP3_ID_WIDTH {6} \\\\\nCONFIG.PCW_TPIU_PERIPHERAL_CLKSRC {External} \\\\\nCONFIG.PCW_TPIU_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TPIU_PERIPHERAL_FREQMHZ {200} \\\\\nCONFIG.PCW_TRACE_BUFFER_CLOCK_DELAY {12} \\\\\nCONFIG.PCW_TRACE_BUFFER_FIFO_SIZE {128} \\\\\nCONFIG.PCW_TRACE_GRP_16BIT_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_GRP_16BIT_IO {<Select>} \\\\\nCONFIG.PCW_TRACE_GRP_2BIT_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_GRP_2BIT_IO {<Select>} \\\\\nCONFIG.PCW_TRACE_GRP_32BIT_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_GRP_32BIT_IO {<Select>} \\\\\nCONFIG.PCW_TRACE_GRP_4BIT_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_GRP_4BIT_IO {<Select>} \\\\\nCONFIG.PCW_TRACE_GRP_8BIT_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_GRP_8BIT_IO {<Select>} \\\\\nCONFIG.PCW_TRACE_INTERNAL_WIDTH {2} \\\\\nCONFIG.PCW_TRACE_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_TRACE_PIPELINE_WIDTH {8} \\\\\nCONFIG.PCW_TRACE_TRACE_IO {<Select>} \\\\\nCONFIG.PCW_TTC0_BASEADDR {0xE0104000} \\\\\nCONFIG.PCW_TTC0_CLK0_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC0_CLK0_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC0_CLK0_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC0_CLK1_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC0_CLK1_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC0_CLK1_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC0_CLK2_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC0_CLK2_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC0_CLK2_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC0_HIGHADDR {0xE0104fff} \\\\\nCONFIG.PCW_TTC0_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_TTC0_TTC0_IO {<Select>} \\\\\nCONFIG.PCW_TTC1_BASEADDR {0xE0105000} \\\\\nCONFIG.PCW_TTC1_CLK0_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC1_CLK0_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC1_CLK0_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC1_CLK1_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC1_CLK1_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC1_CLK1_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC1_CLK2_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_TTC1_CLK2_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_TTC1_CLK2_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_TTC1_HIGHADDR {0xE0105fff} \\\\\nCONFIG.PCW_TTC1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_TTC1_TTC1_IO {<Select>} \\\\\nCONFIG.PCW_TTC_PERIPHERAL_FREQMHZ {50} \\\\\nCONFIG.PCW_UART0_BASEADDR {0xE0000000} \\\\\nCONFIG.PCW_UART0_BAUD_RATE {115200} \\\\\nCONFIG.PCW_UART0_GRP_FULL_ENABLE {0} \\\\\nCONFIG.PCW_UART0_GRP_FULL_IO {<Select>} \\\\\nCONFIG.PCW_UART0_HIGHADDR {0xE0000FFF} \\\\\nCONFIG.PCW_UART0_PERIPHERAL_ENABLE {1} \\\\\nCONFIG.PCW_UART0_UART0_IO {MIO 14 .. 15} \\\\\nCONFIG.PCW_UART1_BASEADDR {0xE0001000} \\\\\nCONFIG.PCW_UART1_BAUD_RATE {115200} \\\\\nCONFIG.PCW_UART1_GRP_FULL_ENABLE {0} \\\\\nCONFIG.PCW_UART1_GRP_FULL_IO {<Select>} \\\\\nCONFIG.PCW_UART1_HIGHADDR {0xE0001FFF} \\\\\nCONFIG.PCW_UART1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_UART1_UART1_IO {<Select>} \\\\\nCONFIG.PCW_UART_PERIPHERAL_CLKSRC {IO PLL} \\\\\nCONFIG.PCW_UART_PERIPHERAL_DIVISOR0 {10} \\\\\nCONFIG.PCW_UART_PERIPHERAL_FREQMHZ {100} \\\\\nCONFIG.PCW_UART_PERIPHERAL_VALID {1} \\\\\nCONFIG.PCW_UIPARAM_ACT_DDR_FREQ_MHZ {525.000000} \\\\\nCONFIG.PCW_UIPARAM_DDR_ADV_ENABLE {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_AL {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_BANK_ADDR_COUNT {3} \\\\\nCONFIG.PCW_UIPARAM_DDR_BL {8} \\\\\nCONFIG.PCW_UIPARAM_DDR_BOARD_DELAY0 {0.223} \\\\\nCONFIG.PCW_UIPARAM_DDR_BOARD_DELAY1 {0.212} \\\\\nCONFIG.PCW_UIPARAM_DDR_BOARD_DELAY2 {0.085} \\\\\nCONFIG.PCW_UIPARAM_DDR_BOARD_DELAY3 {0.092} \\\\\nCONFIG.PCW_UIPARAM_DDR_BUS_WIDTH {16 Bit} \\\\\nCONFIG.PCW_UIPARAM_DDR_CL {7} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_0_LENGTH_MM {25.8} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_0_PACKAGE_LENGTH {80.4535} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_0_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_1_LENGTH_MM {25.8} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_1_PACKAGE_LENGTH {80.4535} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_1_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_2_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_2_PACKAGE_LENGTH {80.4535} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_2_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_3_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_3_PACKAGE_LENGTH {80.4535} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_3_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_CLOCK_STOP_EN {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_COL_ADDR_COUNT {10} \\\\\nCONFIG.PCW_UIPARAM_DDR_CWL {6} \\\\\nCONFIG.PCW_UIPARAM_DDR_DEVICE_CAPACITY {4096 MBits} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_0_LENGTH_MM {15.6} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_0_PACKAGE_LENGTH {105.056} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_0_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_1_LENGTH_MM {18.8} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_1_PACKAGE_LENGTH {66.904} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_1_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_2_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_2_PACKAGE_LENGTH {89.1715} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_2_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_3_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_3_PACKAGE_LENGTH {113.63} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_3_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_0 {0.040} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_1 {0.058} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_2 {-0.009} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQS_TO_CLK_DELAY_3 {-0.033} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_0_LENGTH_MM {16.5} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_0_PACKAGE_LENGTH {98.503} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_0_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_1_LENGTH_MM {18} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_1_PACKAGE_LENGTH {68.5855} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_1_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_2_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_2_PACKAGE_LENGTH {90.295} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_2_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_3_LENGTH_MM {0} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_3_PACKAGE_LENGTH {103.977} \\\\\nCONFIG.PCW_UIPARAM_DDR_DQ_3_PROPOGATION_DELAY {160} \\\\\nCONFIG.PCW_UIPARAM_DDR_DRAM_WIDTH {16 Bits} \\\\\nCONFIG.PCW_UIPARAM_DDR_ECC {Disabled} \\\\\nCONFIG.PCW_UIPARAM_DDR_ENABLE {1} \\\\\nCONFIG.PCW_UIPARAM_DDR_FREQ_MHZ {525} \\\\\nCONFIG.PCW_UIPARAM_DDR_HIGH_TEMP {Normal (0-85)} \\\\\nCONFIG.PCW_UIPARAM_DDR_MEMORY_TYPE {DDR 3} \\\\\nCONFIG.PCW_UIPARAM_DDR_PARTNO {MT41J256M16 RE-125} \\\\\nCONFIG.PCW_UIPARAM_DDR_ROW_ADDR_COUNT {15} \\\\\nCONFIG.PCW_UIPARAM_DDR_SPEED_BIN {DDR3_1066F} \\\\\nCONFIG.PCW_UIPARAM_DDR_TRAIN_DATA_EYE {1} \\\\\nCONFIG.PCW_UIPARAM_DDR_TRAIN_READ_GATE {1} \\\\\nCONFIG.PCW_UIPARAM_DDR_TRAIN_WRITE_LEVEL {1} \\\\\nCONFIG.PCW_UIPARAM_DDR_T_FAW {40.0} \\\\\nCONFIG.PCW_UIPARAM_DDR_T_RAS_MIN {35.0} \\\\\nCONFIG.PCW_UIPARAM_DDR_T_RC {48.91} \\\\\nCONFIG.PCW_UIPARAM_DDR_T_RCD {7} \\\\\nCONFIG.PCW_UIPARAM_DDR_T_RP {7} \\\\\nCONFIG.PCW_UIPARAM_DDR_USE_INTERNAL_VREF {0} \\\\\nCONFIG.PCW_UIPARAM_GENERATE_SUMMARY {NA} \\\\\nCONFIG.PCW_USB0_BASEADDR {0xE0102000} \\\\\nCONFIG.PCW_USB0_HIGHADDR {0xE0102fff} \\\\\nCONFIG.PCW_USB0_PERIPHERAL_ENABLE {1} \\\\\nCONFIG.PCW_USB0_PERIPHERAL_FREQMHZ {60} \\\\\nCONFIG.PCW_USB0_RESET_ENABLE {1} \\\\\nCONFIG.PCW_USB0_RESET_IO {MIO 46} \\\\\nCONFIG.PCW_USB0_USB0_IO {MIO 28 .. 39} \\\\\nCONFIG.PCW_USB1_BASEADDR {0xE0103000} \\\\\nCONFIG.PCW_USB1_HIGHADDR {0xE0103fff} \\\\\nCONFIG.PCW_USB1_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_USB1_PERIPHERAL_FREQMHZ {60} \\\\\nCONFIG.PCW_USB1_RESET_ENABLE {0} \\\\\nCONFIG.PCW_USB1_RESET_IO {<Select>} \\\\\nCONFIG.PCW_USB1_USB1_IO {<Select>} \\\\\nCONFIG.PCW_USB_RESET_ENABLE {1} \\\\\nCONFIG.PCW_USB_RESET_POLARITY {Active Low} \\\\\nCONFIG.PCW_USB_RESET_SELECT {Share reset pin} \\\\\nCONFIG.PCW_USE_AXI_FABRIC_IDLE {0} \\\\\nCONFIG.PCW_USE_AXI_NONSECURE {0} \\\\\nCONFIG.PCW_USE_CORESIGHT {0} \\\\\nCONFIG.PCW_USE_CROSS_TRIGGER {0} \\\\\nCONFIG.PCW_USE_CR_FABRIC {1} \\\\\nCONFIG.PCW_USE_DDR_BYPASS {0} \\\\\nCONFIG.PCW_USE_DEBUG {0} \\\\\nCONFIG.PCW_USE_DEFAULT_ACP_USER_VAL {0} \\\\\nCONFIG.PCW_USE_DMA0 {0} \\\\\nCONFIG.PCW_USE_DMA1 {0} \\\\\nCONFIG.PCW_USE_DMA2 {0} \\\\\nCONFIG.PCW_USE_DMA3 {0} \\\\\nCONFIG.PCW_USE_EXPANDED_IOP {0} \\\\\nCONFIG.PCW_USE_EXPANDED_PS_SLCR_REGISTERS {0} \\\\\nCONFIG.PCW_USE_FABRIC_INTERRUPT {1} \\\\\nCONFIG.PCW_USE_HIGH_OCM {0} \\\\\nCONFIG.PCW_USE_M_AXI_GP0 {1} \\\\\nCONFIG.PCW_USE_M_AXI_GP1 {0} \\\\\nCONFIG.PCW_USE_PROC_EVENT_BUS {0} \\\\\nCONFIG.PCW_USE_PS_SLCR_REGISTERS {0} \\\\\nCONFIG.PCW_USE_S_AXI_ACP {0} \\\\\nCONFIG.PCW_USE_S_AXI_GP0 {0} \\\\\nCONFIG.PCW_USE_S_AXI_GP1 {0} \\\\\nCONFIG.PCW_USE_S_AXI_HP0 {1} \\\\\nCONFIG.PCW_USE_S_AXI_HP1 {0} \\\\\nCONFIG.PCW_USE_S_AXI_HP2 {0} \\\\\nCONFIG.PCW_USE_S_AXI_HP3 {0} \\\\\nCONFIG.PCW_USE_TRACE {0} \\\\\nCONFIG.PCW_USE_TRACE_DATA_EDGE_DETECTOR {0} \\\\\nCONFIG.PCW_VALUE_SILVERSION {3} \\\\\nCONFIG.PCW_WDT_PERIPHERAL_CLKSRC {CPU_1X} \\\\\nCONFIG.PCW_WDT_PERIPHERAL_DIVISOR0 {1} \\\\\nCONFIG.PCW_WDT_PERIPHERAL_ENABLE {0} \\\\\nCONFIG.PCW_WDT_PERIPHERAL_FREQMHZ {133.333333} \\\\\nCONFIG.PCW_WDT_WDT_IO {<Select>} \\\\\n ] $processing_system7_0\n\n  # Need to retain value_src of defaults\n  set_property -dict [ list \\\\\nCONFIG.PCW_CAN0_CAN0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN0_GRP_CLK_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN0_GRP_CLK_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN0_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN1_CAN1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN1_GRP_CLK_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN1_GRP_CLK_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_CAN1_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_0.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_1.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_2.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_READPORT_3.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_0.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_1.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_2.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_DDR_PRIORITY_WRITEPORT_3.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_ENET1_ENET1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_ENET1_GRP_MDIO_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_ENET1_RESET_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_IN0.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_IN1.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_IN2.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_IN3.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_OUT0.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_OUT1.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_OUT2.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_FTM_CTI_OUT3.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_GPIO_EMIO_GPIO_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_GRP_INT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_GRP_INT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_I2C0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_RESET_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C0_RESET_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_GRP_INT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_GRP_INT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_I2C1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_RESET_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C1_RESET_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C_RESET_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_I2C_RESET_SELECT.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NAND_GRP_D8_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NAND_NAND_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_A25_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_CS0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_CS1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_CS1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_GRP_SRAM_INT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_NOR_NOR_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_PJTAG_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_PJTAG_PJTAG_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_QSPI_GRP_IO1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_QSPI_GRP_SS1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD0_GRP_POW_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD0_GRP_WP_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD1_GRP_CD_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD1_GRP_POW_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD1_GRP_WP_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SD1_SD1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI0_GRP_SS0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI0_GRP_SS1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI0_GRP_SS2_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI0_SPI0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI1_GRP_SS0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI1_GRP_SS1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI1_GRP_SS2_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI1_GRP_SS2_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_SPI1_SPI1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_16BIT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_16BIT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_2BIT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_2BIT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_32BIT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_32BIT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_4BIT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_4BIT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_8BIT_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_GRP_8BIT_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_INTERNAL_WIDTH.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TRACE_TRACE_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TTC0_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TTC0_TTC0_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TTC1_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_TTC1_TTC1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_UART0_GRP_FULL_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_UART1_GRP_FULL_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_UART1_UART1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_USB1_RESET_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_USB1_RESET_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_USB1_USB1_IO.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_WDT_PERIPHERAL_ENABLE.VALUE_SRC {DEFAULT} \\\\\nCONFIG.PCW_WDT_WDT_IO.VALUE_SRC {DEFAULT} \\\\\n ] $processing_system7_0\n\n\'\'\'\n\ndesign_tcl += f\'\'\'\\\n  # Create instance: processing_system7_0_axi_periph, and set properties\n  set processing_system7_0_axi_periph [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:2.1 processing_system7_0_axi_periph ]\n  set_property -dict [ list \\\\\nCONFIG.NUM_MI { {2 * ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb + 1} } \\\\\n ] $processing_system7_0_axi_periph\n\n  # Create instance: rst_processing_system7_0_50M, and set properties\n  set rst_processing_system7_0_50M [ create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 rst_processing_system7_0_50M ]\n\n  # Create instance: xlconcat_0, and set properties\n  set xlconcat_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:2.1 xlconcat_0 ]\n  set_property -dict [ list \\\\\nCONFIG.NUM_PORTS { {ddr2fpga_nb + fpga2ddr_nb + func_nb} } \\\\\n ] $xlconcat_0\n\n  # Create interface connections\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net s_dma2mem3_{i} [get_bd_intf_pins axi_dma_ddr2fpga_{i}/M_AXIS_MM2S] [get_bd_intf_pins ddr2fpga_{i}/i_stream]\n  connect_bd_intf_net -intf_net s_dma2mem_{i} [get_bd_intf_pins ddr2fpga_{i}/o_stream] [get_bd_intf_pins axis_dma2mem_intercon/S{str(i).zfill(2)}_AXIS]\n  connect_bd_intf_net -intf_net s_ddr2dma_{i} [get_bd_intf_pins axi_dma_ddr2fpga_{i}/M_AXI_MM2S] [get_bd_intf_pins axi_dma2ddr_intercon/S{str(i).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net s_dma2ddr_{i} [get_bd_intf_pins axi_dma_fpga2ddr_{i}/M_AXI_S2MM] [get_bd_intf_pins axi_dma2ddr_intercon/S{str(i + ddr2fpga_nb).zfill(2)}_AXI]\n  connect_bd_intf_net -intf_net s_mem2dma_{i} [get_bd_intf_pins axi_dma_fpga2ddr_{i}/S_AXIS_S2MM] [get_bd_intf_pins axis_mem2dma_intercon/M{str(i).zfill(2)}_AXIS]\n\'\'\'\n\nfor i in range(mem_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net s_dma2mem2_{i} [get_bd_intf_pins axis_dma2mem_intercon/M{str(i).zfill(2)}_AXIS] [get_bd_intf_pins memory_{i}/i_ddr2fpga]\n  connect_bd_intf_net -intf_net s_mem2dma2_{i} [get_bd_intf_pins axis_mem2dma_intercon/S{str(i).zfill(2)}_AXIS] [get_bd_intf_pins memory_{i}/o_fpga2ddr]\n  connect_bd_intf_net -intf_net s_func2mem_{i} [get_bd_intf_pins axis_func2mem_intercon/M{str(i).zfill(2)}_AXIS] [get_bd_intf_pins memory_{i}/i_func2mem]\n  connect_bd_intf_net -intf_net s_mem2func_{i} [get_bd_intf_pins axis_mem2func_intercon/S{str(i).zfill(2)}_AXIS] [get_bd_intf_pins memory_{i}/o_mem2func]\n\'\'\'\n\nfor i in range(add_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net s_mem2add0_{i} [get_bd_intf_pins add_{i}/i_arg0] [get_bd_intf_pins axis_mem2func_intercon/M{str(2 * i).zfill(2)}_AXIS]\n  connect_bd_intf_net -intf_net s_mem2add1_{i} [get_bd_intf_pins add_{i}/i_arg1] [get_bd_intf_pins axis_mem2func_intercon/M{str(2 * i + 1).zfill(2)}_AXIS]\n  connect_bd_intf_net -intf_net s_add2mem_{i} [get_bd_intf_pins add_{i}/o_res] [get_bd_intf_pins axis_func2mem_intercon/S{str(i).zfill(2)}_AXIS]\n\'\'\'\n\nfor i in range(mul_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net s_mem2mul0_{i} [get_bd_intf_pins mul_{i}/i_arg0] [get_bd_intf_pins axis_mem2func_intercon/M{str(2 * add_nb + 2 * i).zfill(2)}_AXIS]\n  connect_bd_intf_net -intf_net s_mem2mul1_{i} [get_bd_intf_pins mul_{i}/i_arg1] [get_bd_intf_pins axis_mem2func_intercon/M{str(2 * add_nb + 2 * i + 1).zfill(2)}_AXIS]\n  connect_bd_intf_net -intf_net s_mul2mem_{i} [get_bd_intf_pins mul_{i}/o_res] [get_bd_intf_pins axis_func2mem_intercon/S{str(add_nb + i).zfill(2)}_AXIS]\n\'\'\'\n\ndesign_tcl += \'\'\'\\\n  connect_bd_intf_net -intf_net axi_dma2ddr_intercon_M00_AXI [get_bd_intf_pins axi_dma2ddr_intercon/M00_AXI] [get_bd_intf_pins processing_system7_0/S_AXI_HP0]\n  connect_bd_intf_net -intf_net processing_system7_0_DDR [get_bd_intf_ports DDR] [get_bd_intf_pins processing_system7_0/DDR]\n  connect_bd_intf_net -intf_net processing_system7_0_FIXED_IO [get_bd_intf_ports FIXED_IO] [get_bd_intf_pins processing_system7_0/FIXED_IO]\n  connect_bd_intf_net -intf_net processing_system7_0_M_AXI_GP0 [get_bd_intf_pins processing_system7_0/M_AXI_GP0] [get_bd_intf_pins processing_system7_0_axi_periph/S00_AXI]\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i).zfill(2)}_AXI [get_bd_intf_pins axi_dma_ddr2fpga_{i}/S_AXI_LITE] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i + ddr2fpga_nb).zfill(2)}_AXI [get_bd_intf_pins axi_dma_fpga2ddr_{i}/S_AXI_LITE] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i + ddr2fpga_nb).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(mem_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i + ddr2fpga_nb + fpga2ddr_nb).zfill(2)}_AXI [get_bd_intf_pins memory_{i}/s_axi_ctrl] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i + ddr2fpga_nb + fpga2ddr_nb).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(add_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb).zfill(2)}_AXI [get_bd_intf_pins add_{i}/s_axi_ctrl] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(mul_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb + add_nb).zfill(2)}_AXI [get_bd_intf_pins mul_{i}/s_axi_ctrl] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb + add_nb).zfill(2)}_AXI]\n\'\'\'\n\ndesign_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb).zfill(2)}_AXI [get_bd_intf_pins axi_intc_0/s_axi] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb).zfill(2)}_AXI]\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_intf_net -intf_net processing_system7_0_axi_periph_M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb + 1).zfill(2)}_AXI [get_bd_intf_pins ddr2fpga_{i}/s_axi_ctrl] [get_bd_intf_pins processing_system7_0_axi_periph/M{str(i + ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb + 1).zfill(2)}_AXI]\n\'\'\'\n\ndesign_tcl += \'\'\'\\\n\n  # Create port connections\n  connect_bd_net -net axi_intc_0_irq [get_bd_pins axi_intc_0/irq] [get_bd_pins processing_system7_0/IRQ_F2P]\n  connect_bd_net -net processing_system7_0_FCLK_RESET0_N [get_bd_pins processing_system7_0/FCLK_RESET0_N] [get_bd_pins rst_processing_system7_0_50M/ext_reset_in]\n  connect_bd_net -net rst_processing_system7_0_50M_interconnect_aresetn [get_bd_pins axi_dma2ddr_intercon/ARESETN] [get_bd_pins processing_system7_0_axi_periph/ARESETN] [get_bd_pins rst_processing_system7_0_50M/interconnect_aresetn]\n  connect_bd_net -net xlconcat_0_dout [get_bd_pins axi_intc_0/intr] [get_bd_pins xlconcat_0/dout]\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_net -net axi_dma_ddr2fpga_{i}_mm2s_introut [get_bd_pins axi_dma_ddr2fpga_{i}/mm2s_introut] [get_bd_pins xlconcat_0/In{i}]\n\'\'\'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_net -net axi_dma_fpga2ddr_{i}_s2mm_introut [get_bd_pins axi_dma_fpga2ddr_{i}/s2mm_introut] [get_bd_pins xlconcat_0/In{i + ddr2fpga_nb}]\n\'\'\'\n\nfor i in range(add_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_net -net add_{i}_interrupt [get_bd_pins add_{i}/interrupt] [get_bd_pins xlconcat_0/In{i + ddr2fpga_nb + fpga2ddr_nb}]\n\'\'\'\n\nfor i in range(mul_nb):\n    design_tcl += f\'\'\'\\\n  connect_bd_net -net mul_{i}_interrupt [get_bd_pins mul_{i}/interrupt] [get_bd_pins xlconcat_0/In{i + ddr2fpga_nb + fpga2ddr_nb + add_nb}]\n\'\'\'\n\ndesign_tcl += \'  connect_bd_net -net processing_system7_0_FCLK_CLK0 \'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'[get_bd_pins axi_dma_ddr2fpga_{i}/m_axi_mm2s_aclk] [get_bd_pins axi_dma_ddr2fpga_{i}/s_axi_lite_aclk] \'\n    design_tcl += f\'[get_bd_pins ddr2fpga_{i}/ap_clk] \'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axi_dma_fpga2ddr_{i}/m_axi_s2mm_aclk] [get_bd_pins axi_dma_fpga2ddr_{i}/s_axi_lite_aclk] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins memory_{i}/ap_clk] \'\n\nfor i in range(add_nb):\n    design_tcl += f\'[get_bd_pins add_{i}/ap_clk] \'\n\nfor i in range(mul_nb):\n    design_tcl += f\'[get_bd_pins mul_{i}/ap_clk] \'\n\nfor i in range(ddr2fpga_nb + fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axi_dma2ddr_intercon/S{str(i).zfill(2)}_ACLK] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2func_intercon/S{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(func_nb):\n    design_tcl += f\'[get_bd_pins axis_func2mem_intercon/S{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(2 * func_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2func_intercon/M{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_func2mem_intercon/M{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'[get_bd_pins axis_dma2mem_intercon/S{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2dma_intercon/S{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_dma2mem_intercon/M{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2dma_intercon/M{str(i).zfill(2)}_AXIS_ACLK] \'\n\nfor i in range(2 * ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb + 1):\n    design_tcl += f\'[get_bd_pins processing_system7_0_axi_periph/M{str(i).zfill(2)}_ACLK] \'\n\ndesign_tcl += \'[get_bd_pins axi_intc_0/s_axi_aclk] [get_bd_pins axi_dma2ddr_intercon/ACLK] [get_bd_pins axis_dma2mem_intercon/ACLK]  [get_bd_pins axis_mem2dma_intercon/ACLK] [get_bd_pins axis_mem2func_intercon/ACLK] [get_bd_pins axis_func2mem_intercon/ACLK] [get_bd_pins axi_dma2ddr_intercon/M00_ACLK] [get_bd_pins processing_system7_0/FCLK_CLK0] [get_bd_pins processing_system7_0/M_AXI_GP0_ACLK] [get_bd_pins processing_system7_0/S_AXI_HP0_ACLK] [get_bd_pins processing_system7_0_axi_periph/ACLK] [get_bd_pins processing_system7_0_axi_periph/S00_ACLK] [get_bd_pins rst_processing_system7_0_50M/slowest_sync_clk]\\n\'\n    \ndesign_tcl += \'  connect_bd_net -net rst_processing_system7_0_50M_peripheral_aresetn \'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'[get_bd_pins axi_dma_ddr2fpga_{i}/axi_resetn] \'\n    design_tcl += f\'[get_bd_pins ddr2fpga_{i}/ap_rst_n] \'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axi_dma_fpga2ddr_{i}/axi_resetn] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins memory_{i}/ap_rst_n] \'\n\nfor i in range(add_nb):\n    design_tcl += f\'[get_bd_pins add_{i}/ap_rst_n] \'\n\nfor i in range(mul_nb):\n    design_tcl += f\'[get_bd_pins mul_{i}/ap_rst_n] \'\n\nfor i in range(ddr2fpga_nb + fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axi_dma2ddr_intercon/S{str(i).zfill(2)}_ARESETN] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2func_intercon/S{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(func_nb):\n    design_tcl += f\'[get_bd_pins axis_func2mem_intercon/S{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(2 * func_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2func_intercon/M{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_func2mem_intercon/M{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'[get_bd_pins axis_dma2mem_intercon/S{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2dma_intercon/S{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(mem_nb):\n    design_tcl += f\'[get_bd_pins axis_dma2mem_intercon/M{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'[get_bd_pins axis_mem2dma_intercon/M{str(i).zfill(2)}_AXIS_ARESETN] \'\n\nfor i in range(ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb + 1):\n    design_tcl += f\'[get_bd_pins processing_system7_0_axi_periph/M{str(i).zfill(2)}_ARESETN] \'\n\ndesign_tcl += \'[get_bd_pins axi_intc_0/s_axi_aresetn] [get_bd_pins axi_dma2ddr_intercon/M00_ARESETN] [get_bd_pins axis_dma2mem_intercon/ARESETN]  [get_bd_pins axis_mem2dma_intercon/ARESETN] [get_bd_pins axis_mem2func_intercon/ARESETN] [get_bd_pins axis_func2mem_intercon/ARESETN] [get_bd_pins processing_system7_0_axi_periph/S00_ARESETN] [get_bd_pins rst_processing_system7_0_50M/peripheral_aresetn]\\n\'\n\ndesign_tcl += \'\'\'\n\n  # Create address segments\n  create_bd_addr_seg -range 0x00010000 -offset 0x41800000 [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs axi_intc_0/s_axi/Reg] SEG_axi_intc_0_Reg\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x20000000 -offset 0x00000000 [get_bd_addr_spaces axi_dma_ddr2fpga_{i}/Data_MM2S] [get_bd_addr_segs processing_system7_0/S_AXI_HP0/HP0_DDR_LOWOCM] SEG_processing_system7_0_HP0_DDR_LOWOCM\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x40400000 + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs axi_dma_ddr2fpga_{i}/S_AXI_LITE/Reg] SEG_axi_dma_ddr2fpga_{i}_Reg\n\'\'\'\n\nfor i in range(fpga2ddr_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x20000000 -offset 0x00000000 [get_bd_addr_spaces axi_dma_fpga2ddr_{i}/Data_S2MM] [get_bd_addr_segs processing_system7_0/S_AXI_HP0/HP0_DDR_LOWOCM] SEG_processing_system7_0_HP0_DDR_LOWOCM\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x40400000 + 0x10000 * ddr2fpga_nb + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs axi_dma_fpga2ddr_{i}/S_AXI_LITE/Reg] SEG_axi_dma_fpga2ddr_{i}_Reg\n\'\'\'\n\nfor i in range(mem_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x43C00000 + 0x10000 * (ddr2fpga_nb + fpga2ddr_nb) + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs memory_{i}/s_axi_ctrl/Reg] SEG_memory_{i}_Reg\n\'\'\'\n\nfor i in range(add_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x43C00000 + 0x10000 * (ddr2fpga_nb + fpga2ddr_nb + mem_nb) + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs add_{i}/s_axi_ctrl/Reg] SEG_add_{i}_Reg\n\'\'\'\n\nfor i in range(mul_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x43C00000 + 0x10000 * (ddr2fpga_nb + fpga2ddr_nb + mem_nb + add_nb) + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs mul_{i}/s_axi_ctrl/Reg] SEG_mul_{i}_Reg\n\'\'\'\n\nfor i in range(ddr2fpga_nb):\n    design_tcl += f\'\'\'\\\n  create_bd_addr_seg -range 0x00010000 -offset {hex(0x43C00000 + 0x10000 * (ddr2fpga_nb + fpga2ddr_nb + mem_nb + func_nb) + 0x10000 * i)} [get_bd_addr_spaces processing_system7_0/Data] [get_bd_addr_segs ddr2fpga_{i}/s_axi_ctrl/Reg] SEG_ddr2fpga_{i}_Reg\n\'\'\'\n\ndesign_tcl += \'\'\'\n  # Restore current instance\n  current_bd_instance $oldCurInst\n\n  save_bd_design\n}\n# End of create_root_design()\n\n\n##################################################################\n# MAIN FLOW\n##################################################################\n\nset_property target_language VHDL [current_project]\nset_property ip_repo_paths { \\\n        ip/ddr2fpga/solution1 \\\n        ip/memory/solution1 \\\n        ip/add/solution1 \\\n        ip/mul/solution1 \\\n        } [current_project]\nupdate_ip_catalog -rebuild\ncreate_root_design """"\n\nmake_wrapper -files [get_files bundle/project_1.srcs/sources_1/bd/design_1/design_1.bd] -top\nset_property top design_1 [current_fileset]\nlaunch_runs synth_1 -jobs 2\nwait_on_run synth_1\nlaunch_runs impl_1 -to_step write_bitstream -jobs 2\nwait_on_run impl_1\n\'\'\'\n\nwith open(\'design_1.tcl\', \'w\') as f:\n    f.write(design_tcl)\n\ncall(\'vivado -mode batch -source design_1.tcl\'.split())\n'"
