file_path,api_count,code
app.py,0,"b""'Main Module'\n#!/usr/bin/python\nimport os\nimport src.utils as util\nimport src.compression as dwt\nimport numpy as np\n\nFOLDER = 'data'\nRIGHT_FILENAME = 'lena.png'\n\ndef run():\n    img = util.load_img(os.path.join(FOLDER, RIGHT_FILENAME))\n    #print (dwt.extract_rgb_coeff(img))\n\nif __name__ == '__main__':\n    run()\n"""
example/__init__.py,0,b''
src/__init__.py,0,b''
src/main.py,0,b'# TODO\n'
tests/runner.py,0,"b""import unittest\nfrom .modules.dwt_test import CompressionTest\nfrom .modules.utils_test import UtilTest\n\nif __name__ == '__main__':\n    unittest.main()\n"""
src/compression/__init__.py,0,"b'# pylint: disable=C0103,E0401,W0631\n\'Compression methods\'\nimport pywt\nimport numpy\nfrom PIL import Image\nimport src.utils as util\n\ndef rgb_to_yuv(img):\n    """"""\n    Returns yuv image\n    Parameters\n    ----------\n    img: PIL Image\n    Returns\n    -------\n    PIL Image:\n        image converted to yuv\n    """"""\n    yuv_img = img.convert(\'RGB\')\n    (width, height) = img.size\n    for x in range(width):\n        for y in range(height):\n            (r, g, b) = yuv_img.getpixel((x, y))\n        Y = 0.299 * r + 0.587 * g + 0.114 * b\n        CB = - 0.168935 * r + - 0.331665 * g + 0.50059 * b + 128\n        CR = 0.499813 * r - 0.4187 * g + - 0.081282 * b + 128\n        Y = 255 if (Y >= 255) else Y\n        Y = 0 if (Y <= 0) else Y\n        CB = 255 if (CB >= 255) else CB\n        CB = 0 if (CB <= 0) else CB\n        CR = 255 if (CR >= 255) else CR\n        CR = 0 if (CR <= 0) else CR\n        yuv_img.putpixel((x, y), (int(Y), int(CB), int(CR)))\n    return yuv_img\n\ndef yuv_to_rgb(img):\n    """"""\n    Returns rgb image\n    Parameters\n    ----------\n    img: PIL Image\n    Returns\n    -------\n    PIL Image:\n        image converted to rgb\n    """"""\n    (width, height) = img.size\n    rgb_img = img.copy()\n    for x in range(width):\n        for y in range(height):\n            (Y, CB, CR) = img.getpixel((x, y))\n        R = Y + 1.402 * (CR - 128)\n        G = Y - 0.34414 * (CB - 128) - 0.71414 * (CR - 128)\n        B = Y + 1.772 * (CB -128)\n        R = 255 if (R >= 255) else R\n        R = 0 if (R <= 0) else R\n        G = 255 if (G >= 255) else G\n        G = 0 if (G <= 0) else G\n        B = 255 if (B >= 255) else B\n        B = 0 if (B <= 0) else B\n        rgb_img.putpixel((x, y), (int(R), int(G), int(B)))\n    return  rgb_img\n\ndef rgb_to_grayscale(img):\n    """"""\n    Returns greyscale image\n    Parameters\n    ----------\n    img: PIL Image\n    Returns\n    -------\n    PIL Image:\n        image converted to greyscale\n    """"""\n    width, height = img.size\n    res = img.copy()\n    for i in range(width):\n        for j in range(height):\n            (r, g, b) = img.getpixel((i, j))\n            gs = int((r + g + b) / 3)\n            res.putpixel((i, j), (gs, gs, gs))\n    return res\n\ndef extract_rgb_coeff(img):\n    """"""\n    Returns RGB dwt applied coefficients tuple\n    Parameters\n    ----------\n    img: PIL Image\n    Returns\n    -------\n    (coeffs_r, coeffs_g, coeffs_b):\n        RGB coefficients with Discrete Wavelet Transform Applied\n    """"""\n    (width, height) = img.size\n    img = img.copy()\n\n    mat_r = numpy.empty((width, height))\n    mat_g = numpy.empty((width, height))\n    mat_b = numpy.empty((width, height))\n\n    for i in range(width):\n        for j in range(height):\n            (r, g, b) = img.getpixel((i, j))\n            mat_r[i, j] = r\n            mat_g[i, j] = g\n            mat_b[i, j] = b\n\n    # coeffs_r: cA,(cH,cV,cD)\n    coeffs_r = pywt.dwt2(mat_r, \'haar\')\n    # coeffs_g: cA,(cH,cV,cD)\n    coeffs_g = pywt.dwt2(mat_g, \'haar\')\n    # coeffs_b: cA,(cH,cV,cD)\n    coeffs_b = pywt.dwt2(mat_b, \'haar\')\n    return (coeffs_r, coeffs_g, coeffs_b)\n\ndef img_from_dwt_coeff(coeff_dwt):\n    """"""\n    Returns Image recreated from dwt coefficients\n    Parameters\n    ----------\n    (coeffs_r, coeffs_g, coeffs_b):\n        RGB coefficients with Discrete Wavelet Transform Applied\n    Returns\n    -------\n    Image from dwt coefficients\n    """"""\n    #Channel Red\n    (coeffs_r, coeffs_g, coeffs_b) = coeff_dwt\n    cARed = numpy.array(coeffs_r[0])\n    (width, height) = coeffs_r.shape\n    cHRed = numpy.array(coeffs_r[1][0])\n    cVRed = numpy.array(coeffs_r[1][1])\n    cDRed = numpy.array(coeffs_r[1][2])\n    #Channel Green\n    cAGreen = numpy.array(coeffs_g[0])\n    cHGreen = numpy.array(coeffs_g[1][0])\n    cVGreen = numpy.array(coeffs_g[1][1])\n    cDGreen = numpy.array(coeffs_g[1][2])\n    #Channel Blue\n    cABlue = numpy.array(coeffs_b[0])\n    cHBlue = numpy.array(coeffs_b[1][0])\n    cVBlue = numpy.array(coeffs_b[1][1])\n    cDBlue = numpy.array(coeffs_b[1][2])\n\n    # maxValue per channel par matrix\n    cAMaxRed = util.max_ndarray(cARed)\n    cAMaxGreen = util.max_ndarray(cAGreen)\n    cAMaxBlue = util.max_ndarray(cABlue)\n\n    cHMaxRed = util.max_ndarray(cHRed)\n    cHMaxGreen = util.max_ndarray(cHGreen)\n    cHMaxBlue = util.max_ndarray(cHBlue)\n\n    cVMaxRed = util.max_ndarray(cVRed)\n    cVMaxGreen = util.max_ndarray(cVGreen)\n    cVMaxBlue = util.max_ndarray(cVBlue)\n\n    cDMaxRed = util.max_ndarray(cDRed)\n    cDMaxGreen = util.max_ndarray(cDGreen)\n    cDMaxBlue = util.max_ndarray(cDBlue)\n\n    # Image object init\n    dwt_img = Image.new(\'RGB\', (width*2, height*2), (0, 0, 20))\n    #cA reconstruction\n    for i in range(width):\n        for j in range(height):\n            R = cARed[i][j]\n            R = (R/cAMaxRed)*160.0\n            G = cAGreen[i][j]\n            G = (G/cAMaxGreen)*85.0\n            B = cABlue[i][j]\n            B = (B/cAMaxBlue)*100.0\n            new_value = (int(R), int(G), int(B))\n            dwt_img.putpixel((i, j), new_value)\n    #cH reconstruction\n    for i in range(width):\n        for j in range(height):\n            R = cHRed[i][j]\n            R = (R/cHMaxRed)*160.0\n            G = cHGreen[i][j]\n            G = (G/cHMaxGreen)*85.0\n            B = cHBlue[i][j]\n            B = (B/cHMaxBlue)*100.0\n            new_value = (int(R), int(G), int(B))\n            dwt_img.putpixel((i+width, j), new_value)\n    #cV reconstruction\n    for i in range(width):\n        for j in range(height):\n            R = cVRed[i][j]\n            R = (R/cVMaxRed)*160.0\n            G = cVGreen[i][j]\n            G = (G/cVMaxGreen)*85.0\n            B = cVBlue[i][j]\n            B = (B/cVMaxBlue)*100.0\n            new_value = (int(R), int(G), int(B))\n            dwt_img.putpixel((i, j+height), new_value)\n    #cD reconstruction\n    for i in range(width):\n        for j in range(height):\n            R = cDRed[i][j]\n            R = (R/cDMaxRed)*160.0\n            G = cDGreen[i][j]\n            G = (G/cDMaxGreen)*85.0\n            B = cDBlue[i][j]\n            B = (B/cDMaxBlue)*100.0\n            new_value = (int(R), int(G), int(B))\n            dwt_img.putpixel((i+width, j+height), new_value)\n    return dwt_img\n\ndef quantization(mat):\n    pass\n'"
src/utils/__init__.py,1,"b'# pylint: disable=E0401\n\'Utility methods for the project\'\nfrom PIL import Image\nimport numpy as np\n\ndef load_img(path):\n    """"""\n    Returns an Image object if path is an existing image, otherwise None\n    Parameters\n    ----------\n    path: string\n        image path to open\n    Returns\n    -------\n    Image:\n        image object\n    """"""\n    try:\n        return Image.open(path)\n    except IOError:\n        return None\n\ndef max_ndarray(mat):\n    """"""\n    Returns maximum value within a given 2D Matrix, otherwise 0\n    Parameters\n    ----------\n    mat: numpy.ndarray\n        matrix from which we want to compute the max value\n    Returns\n    -------\n    int32:\n        matrix maximum value\n    """"""\n    return np.amax(mat) if type(mat).__name__ == \'ndarray\' else 0\n'"
tests/modules/dwt_test.py,0,"b""'Test Definition for Compression methods'\nimport unittest\nimport os\nfrom src.utils import load_img\nfrom src.compression import (\n    rgb_to_yuv, \\\n    yuv_to_rgb, \\\n    extract_rgb_coeff, \\\n    img_from_dwt_coeff\n)\n\nFOLDER = 'data'\nFILENAME = 'lena.png'\n\nclass CompressionTest(unittest.TestCase):\n    'Units test for compression methods'\n    def test_rgb_to_yuv(self):\n        'it should return an Image Type after conversion'\n        img = load_img(os.path.join(FOLDER, FILENAME))\n        img_yuv = rgb_to_yuv(img)\n        self.assertEqual(type(img_yuv).__name__, 'Image')\n\n    def test_yuv_to_rgb(self):\n        'it should return an Image Type after conversion'\n        img = load_img(os.path.join(FOLDER, FILENAME))\n        img_yuv = yuv_to_rgb(img)\n        self.assertEqual(type(img_yuv).__name__, 'Image')\n\n    def test_extract_rgb_coeff(self):\n        'it should return a Tuple of coefficient per each channel (RGB)'\n        img = load_img(os.path.join(FOLDER, FILENAME))\n        (c_r, c_g, c_b) = extract_rgb_coeff(img)\n        self.assertTrue(c_r[0] is not None)\n        self.assertTrue(c_r[1] is not None)\n        self.assertTrue(c_g[0] is not None)\n        self.assertTrue(c_g[1] is not None)\n        self.assertTrue(c_b[0] is not None)\n        self.assertTrue(c_b[1] is not None)\n\n    def test_img_from_dwt_coeff(self):\n        'TODO'\n        img = load_img(os.path.join(FOLDER, FILENAME))\n        coeff = extract_rgb_coeff(img)\n        pass\n\n    # Demo function\n    def sum(self, a, b):\n        return a + b\n\n    def test_demo(self):\n        self.assertEqual(self.sum(1,1), 2)\n        self.assertEqual(self.sum(1,2), 3)\n"""
tests/modules/utils_test.py,1,"b""'Test Definition for Utility methods'\nimport unittest\nimport os\nimport numpy as np\nfrom src.utils import load_img, max_ndarray\n\nFOLDER = 'data'\nRIGHT_FILENAME = 'lena.png'\nWRONG_FILENAME = 'dummy_file.png'\n\nclass UtilTest(unittest.TestCase):\n    'Units test for utility methods'\n    def test_load_png_file(self):\n        'it should return an Image Type if file exists and is an Image file'\n        # case 1 (it should return PngImageFile):\n        img = load_img(os.path.join(FOLDER, RIGHT_FILENAME))\n        self.assertEqual(type(img).__name__, 'PngImageFile')\n        # case 2 (it should return NoneType):\n        img = load_img(os.path.join(FOLDER, WRONG_FILENAME))\n        self.assertEqual(type(img).__name__, 'NoneType')\n\n    def test_max_ndarray(self):\n        'it should return an Integer, max if matrix is valid, 0 otherwise'\n        # case 1 (it should return 6):\n        tmp_array = np.array([[1, 2, 3], [4, 5, 6]], np.int32)\n        max_value = max_ndarray(tmp_array)\n        self.assertEqual(type(max_value).__name__, 'int32')\n        self.assertEqual(max_value, 6)\n        # case 2 (it should return 0):\n        max_none = max_ndarray(None)\n        self.assertEqual(type(max_none).__name__, 'int')\n        self.assertEqual(max_none, 0)\n"""
